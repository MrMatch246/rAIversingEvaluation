{
    "functions": {
        "FUN_0800071c": {
            "renaming": {
                "FUN_0800071c": "FUNC_0800071c"
            },
            "code": "\nulonglong FUNC_0800071c(undefined4 param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  uint unaff_r5;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  bool bVar14;\n  bool bVar15;\n  bool bVar16;\n  ulonglong uVar17;\n  \n  uVar17 = CONCAT44(param_2,param_1);\n  uVar13 = 0x7ff;\n  uVar7 = param_2 >> 0x14 & 0x7ff;\n  bVar14 = uVar7 == 0;\n  if (!bVar14) {\n    unaff_r5 = param_4 >> 0x14 & 0x7ff;\n    bVar14 = unaff_r5 == 0;\n  }\n  if (!bVar14) {\n    bVar14 = uVar7 == 0x7ff;\n  }\n  if (!bVar14) {\n    bVar14 = unaff_r5 == 0x7ff;\n  }\n  if (bVar14) {\n    uVar17 = binary_to_double_0800088a();\n  }\n  uVar9 = (uint)(uVar17 >> 0x20);\n  uVar11 = (uint)uVar17;\n  iVar8 = uVar7 - unaff_r5;\n  if ((param_3 | param_4 << 0xc) == 0) {\n    uVar7 = (uVar9 ^ param_4) & 0x80000000 | uVar9 & 0xfffff;\n    bVar16 = SCARRY4(iVar8,uVar13 >> 1);\n    uVar9 = iVar8 + (uVar13 >> 1);\n    bVar14 = (int)uVar9 < 0;\n    bVar15 = uVar9 == 0;\n    if (!bVar15 && bVar14 == bVar16) {\n      bVar16 = SBORROW4(uVar13,uVar9);\n      bVar14 = (int)(uVar13 - uVar9) < 0;\n      bVar15 = uVar13 == uVar9;\n    }\n    if (!bVar15 && bVar14 == bVar16) {\n      uVar7 = uVar7 | uVar9 * 0x100000;\n    }\n    if (!bVar15 && bVar14 == bVar16) {\n      return uVar17 & 0xffffffff | (ulonglong)uVar7 << 0x20;\n    }\n    uVar7 = uVar7 | 0x100000;\n    uVar13 = 0;\n    bVar15 = SBORROW4(uVar9,1);\n    uVar9 = uVar9 - 1;\n    bVar14 = uVar9 == 0;\n    uVar3 = uVar9;\n  }\n  else {\n    uVar3 = (param_4 << 0xc) >> 4 | 0x10000000 | param_3 >> 0x18;\n    uVar13 = param_3 << 8;\n    uVar10 = (uVar9 << 0xc) >> 4 | 0x10000000 | uVar11 >> 0x18;\n    uVar11 = uVar11 * 0x100;\n    uVar7 = (uVar9 ^ param_4) & 0x80000000;\n    bVar14 = uVar3 <= uVar10;\n    if (uVar10 == uVar3) {\n      bVar14 = uVar13 <= uVar11;\n    }\n    iVar8 = iVar8 + (uint)bVar14;\n    uVar9 = iVar8 + 0x3fd;\n    if (bVar14 == false) {\n      uVar3 = uVar3 >> 1;\n      uVar13 = (uint)((param_3 >> 0x18 & 1) != 0) << 0x1f | uVar13 >> 1;\n    }\n    uVar12 = uVar11 - uVar13;\n    uVar10 = (uVar10 - uVar3) - (uint)(uVar11 < uVar13);\n    uVar4 = uVar3 >> 1;\n    uVar1 = (uint)((uVar3 & 1) != 0) << 0x1f | uVar13 >> 1;\n    uVar11 = 0x100000;\n    uVar3 = 0x80000;\n    while( true ) {\n      bVar14 = uVar1 <= uVar12;\n      if (uVar4 < uVar10 || uVar10 - uVar4 < (uint)bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar11 = uVar11 | uVar3;\n        uVar10 = (uVar10 - uVar4) - (uint)!bVar14;\n      }\n      uVar5 = uVar4 >> 1;\n      uVar1 = (uint)((uVar4 & 1) != 0) << 0x1f | uVar1 >> 1;\n      bVar15 = uVar1 <= uVar12;\n      bVar14 = uVar10 - uVar5 < (uint)bVar15;\n      uVar13 = uVar10;\n      if (uVar5 < uVar10 || bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar13 = (uVar10 - uVar5) - (uint)!bVar15;\n      }\n      if (uVar5 < uVar10 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 1;\n      }\n      uVar10 = uVar4 >> 2;\n      uVar2 = (uint)((uVar5 & 1) != 0) << 0x1f | uVar1 >> 1;\n      bVar15 = uVar2 <= uVar12;\n      bVar14 = uVar13 - uVar10 < (uint)bVar15;\n      uVar5 = uVar13;\n      if (uVar10 < uVar13 || bVar14) {\n        uVar12 = uVar12 - uVar2;\n        uVar5 = (uVar13 - uVar10) - (uint)!bVar15;\n      }\n      if (uVar10 < uVar13 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 2;\n      }\n      uVar6 = uVar4 >> 3;\n      uVar1 = (uint)((uVar10 & 1) != 0) << 0x1f | uVar2 >> 1;\n      bVar15 = uVar1 <= uVar12;\n      bVar14 = uVar5 - uVar6 < (uint)bVar15;\n      uVar10 = uVar5;\n      if (uVar6 < uVar5 || bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar10 = (uVar5 - uVar6) - (uint)!bVar15;\n      }\n      if (uVar6 < uVar5 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 3;\n      }\n      uVar13 = uVar10 | uVar12;\n      if (uVar13 == 0) break;\n      uVar10 = uVar10 << 4 | uVar12 >> 0x1c;\n      uVar12 = uVar12 << 4;\n      uVar4 = uVar4 & 0xfffffff8 | uVar1 >> 0x1d;\n      uVar1 = (uVar2 >> 1) << 3;\n      uVar3 = uVar3 >> 4;\n      if (uVar3 == 0) {\n        uVar6 = uVar4;\n        if ((uVar7 & 0x100000) != 0) goto LAB_0800083a;\n        uVar7 = uVar7 | uVar11;\n        uVar11 = 0;\n        uVar3 = 0x80000000;\n      }\n    }\n    if ((uVar7 & 0x100000) == 0) {\n      uVar7 = uVar7 | uVar11;\n      uVar11 = 0;\n    }\nLAB_0800083a:\n    bVar16 = 0xfc < uVar9;\n    bVar15 = SBORROW4(uVar9,0xfd);\n    uVar4 = iVar8 + 0x300;\n    bVar14 = uVar4 == 0;\n    uVar3 = uVar4;\n    if (bVar16 && !bVar14) {\n      bVar16 = 0x6ff < uVar4;\n      bVar15 = SBORROW4(uVar4,0x700);\n      uVar3 = iVar8 - 0x400;\n      bVar14 = uVar4 == 0x700;\n    }\n    if (!bVar16 || bVar14) {\n      bVar14 = uVar6 <= uVar10;\n      if (uVar10 == uVar6) {\n        bVar14 = uVar1 <= uVar12;\n      }\n      if (uVar10 == uVar6 && uVar12 == uVar1) {\n        bVar14 = (uVar11 & 1) != 0;\n      }\n      return CONCAT44(uVar7 + uVar9 * 0x100000 + (uint)CARRY4(uVar11,(uint)bVar14),uVar11 + bVar14);\n    }\n  }\n  if (!bVar14 && (int)uVar3 < 0 == bVar15) {\n    return (ulonglong)(uVar7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bVar16 = SCARRY4(uVar9,0x36);\n  bVar14 = (int)(uVar9 + 0x36) < 0;\n  bVar15 = uVar9 == 0xffffffca;\n  if (bVar15 || bVar14 != bVar16) {\n    uVar11 = 0;\n  }\n  if (bVar15 || bVar14 != bVar16) {\n    uVar7 = uVar7 & 0x80000000;\n  }\n  if (bVar15 || bVar14 != bVar16) {\n    return CONCAT44(uVar7,uVar11);\n  }\n  uVar3 = -uVar9;\n  uVar10 = uVar3 - 0x20;\n  if (0x1f < (int)uVar3) {\n    uVar3 = uVar11 >> (uVar10 & 0xff) | uVar7 << (0x20 - uVar10 & 0xff);\n    uVar9 = (uVar7 >> (uVar10 & 0xff) & ~((uVar7 & 0x80000000) >> (uVar10 & 0xff))) -\n            ((int)uVar3 >> 0x1f);\n    if ((uVar13 | uVar11 << (0x20 - uVar10 & 0xff) | uVar3 << 1) == 0) {\n      uVar9 = uVar9 & ~(uVar3 >> 0x1f);\n    }\n    return CONCAT44(uVar7,uVar9) & 0x80000000ffffffff;\n  }\n  iVar8 = uVar3 - 0x14;\n  if (iVar8 != 0 && iVar8 < 0 == SCARRY4(uVar10,0xc)) {\n    uVar9 = 0xc - iVar8;\n    uVar3 = uVar11 << (uVar9 & 0xff);\n    uVar11 = uVar11 >> (0x20 - uVar9 & 0xff) | uVar7 << (uVar9 & 0xff);\n    uVar9 = uVar11 + -((int)uVar3 >> 0x1f);\n    if ((uVar13 | uVar3 << 1) == 0) {\n      uVar9 = uVar9 & ~(uVar3 >> 0x1f);\n    }\n    return CONCAT44((uVar7 & 0x80000000) + (uint)CARRY4(uVar11,-((int)uVar3 >> 0x1f)),uVar9);\n  }\n  uVar10 = uVar11 << (uVar9 + 0x20 & 0xff);\n  uVar11 = uVar11 >> (uVar3 & 0xff) | uVar7 << (uVar9 + 0x20 & 0xff);\n  uVar9 = uVar11 + -((int)uVar10 >> 0x1f);\n  if ((uVar13 | uVar10 << 1) == 0) {\n    uVar9 = uVar9 & ~(uVar10 >> 0x1f);\n  }\n  return CONCAT44((uVar7 & 0x80000000) +\n                  ((uVar7 & 0x7fffffff) >> (uVar3 & 0xff)) +\n                  (uint)CARRY4(uVar11,-((int)uVar10 >> 0x1f)),uVar9);\n}\n\n",
            "called": [
                "FUN_0800088a"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0800071c",
            "calling": [
                "FUN_08005838",
                "FUN_08004d78",
                "FUN_08004bd8",
                "FUN_080079e8",
                "FUN_080059f0"
            ],
            "imported": false,
            "current_name": "FUNC_0800071c"
        },
        "FUN_080036a8": {
            "renaming": {
                "FUN_080036a8": "update_and_set_bitwise_value_080036a8",
                "param_1": "bitwise_value",
                "param_2": "bitwise_flag"
            },
            "code": "\nundefined4 update_and_set_bitwise_value_080036a8(uint **bitwise_value,undefined4 bitwise_flag)\n\n{\n  update_bitwise_value_080041ea(*bitwise_value,bitwise_flag,1);\n  if (*bitwise_value == DAT_080036f4) {\n    (*bitwise_value)[0x11] = (*bitwise_value)[0x11] | 0x8000;\n  }\n  **bitwise_value = **bitwise_value | 1;\n  return 0;\n}\n\n",
            "called": [
                "FUN_080041ea"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036a8",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "update_and_set_bitwise_value_080036a8"
        },
        "FUN_080088ec": {
            "renaming": {
                "FUN_080088ec": "allocate_memory_block_080088ec",
                "param_1": "memory_pool",
                "param_2": "block_size",
                "param_3": "unused",
                "param_4": "unused",
                "iVar1": "next_block",
                "iVar2": "current_block",
                "iVar11": "prev_block",
                "puVar3": "block_header",
                "puVar7": "prev_free_block",
                "puVar8": "memory_pool_header",
                "puVar9": "next_free_block",
                "uVar4": "unused",
                "uVar5": "block_size_aligned",
                "uVar6": "block_header_size",
                "uVar10": "block_header_flag"
            },
            "code": "\nvoid allocate_memory_block_080088ec(undefined4 memory_pool,int block_size,undefined4 unused,undefined4 unused)\n\n{\n  int next_block;\n  int current_block;\n  uint *block_header;\n  uint unused;\n  uint block_size_aligned;\n  uint block_header_size;\n  undefined *prev_free_block;\n  undefined *memory_pool_header;\n  undefined *next_free_block;\n  uint block_header_flag;\n  int prev_block;\n  \n  if (block_size == 0) {\n    return;\n  }\n  do_nothing_with_pointer_080090a8();\n  memory_pool_header = PTR_DAT_08008ac4;\n  block_header_flag = *(uint *)(block_size + -4);\n  current_block = block_size + -8;\n  block_size_aligned = block_header_flag & 0xfffffffe;\n  block_header = (uint *)(current_block + block_size_aligned);\n  block_header_size = block_header[1] & 0xfffffffc;\n  if (*(uint **)(PTR_DAT_08008ac4 + 8) == block_header) {\n    block_size_aligned = block_size_aligned + block_header_size;\n    if ((block_header_flag & 1) == 0) {\n      current_block = current_block - *(int *)(block_size + -8);\n      prev_block = *(int *)(current_block + 8);\n      next_block = *(int *)(current_block + 0xc);\n      block_size_aligned = block_size_aligned + *(int *)(block_size + -8);\n      *(int *)(prev_block + 0xc) = next_block;\n      *(int *)(next_block + 8) = prev_block;\n    }\n    block_header_size = *(uint *)PTR_DAT_08008acc;\n    *(uint *)(current_block + 4) = block_size_aligned | 1;\n    *(int *)(memory_pool_header + 8) = current_block;\n    if (block_header_size <= block_size_aligned) {\n      allocate_and_resize_memory_0800884c(memory_pool,*(undefined4 *)PTR_DAT_08008ad0);\n    }\nLAB_080089f0:\n    do_nothing_with_pointer_080090b4(memory_pool);\n    return;\n  }\n  block_header[1] = block_header_size;\n  if ((block_header_flag & 1) == 0) {\n    current_block = current_block - *(int *)(block_size + -8);\n    next_free_block = *(undefined **)(current_block + 8);\n    block_size_aligned = block_size_aligned + *(int *)(block_size + -8);\n    block_header_flag = *(uint *)((int)block_header + block_header_size + 4) & 1;\n    if (next_free_block == memory_pool_header + 8) {\n      if (block_header_flag == 0) {\n        block_header_flag = block_header[2];\n        unused = block_header[3];\n        block_size_aligned = block_size_aligned + block_header_size;\n        *(uint *)(block_header_flag + 0xc) = unused;\n        *(uint *)(unused + 8) = block_header_flag;\n        *(uint *)(current_block + 4) = block_size_aligned | 1;\n        *(uint *)(current_block + block_size_aligned) = block_size_aligned;\n      }\n      else {\n        *(uint *)(current_block + 4) = block_size_aligned | 1;\n        *block_header = block_size_aligned;\n      }\n      goto LAB_080089f0;\n    }\n    prev_block = *(int *)(current_block + 0xc);\n    *(int *)(next_free_block + 0xc) = prev_block;\n    *(undefined **)(prev_block + 8) = next_free_block;\n  }\n  else {\n    block_header_flag = *(uint *)((int)block_header + block_header_size + 4) & 1;\n  }\n  if (block_header_flag == 0) {\n    next_free_block = (undefined *)block_header[2];\n    block_size_aligned = block_size_aligned + block_header_size;\n    if (next_free_block == PTR_PTR_DAT_08008ac8) {\n      *(int *)(memory_pool_header + 0x10) = current_block;\n      *(int *)(memory_pool_header + 0x14) = current_block;\n      *(undefined **)(current_block + 8) = next_free_block;\n      *(undefined **)(current_block + 0xc) = next_free_block;\n      *(uint *)(current_block + 4) = block_size_aligned | 1;\n      *(uint *)(current_block + block_size_aligned) = block_size_aligned;\n      goto LAB_080089f0;\n    }\n    block_header_size = block_header[3];\n    *(uint *)(next_free_block + 0xc) = block_header_size;\n    *(undefined **)(block_header_size + 8) = next_free_block;\n    *(uint *)(current_block + 4) = block_size_aligned | 1;\n    *(uint *)(current_block + block_size_aligned) = block_size_aligned;\n  }\n  else {\n    *(uint *)(current_block + 4) = block_size_aligned | 1;\n    *(uint *)(current_block + block_size_aligned) = block_size_aligned;\n  }\n  if (block_size_aligned < 0x200) {\n    prev_block = (block_size_aligned >> 3) + 1;\n    block_size_aligned = 1 << ((int)(block_size_aligned >> 3) >> 2 & 0xffU) | *(uint *)(memory_pool_header + 4);\n    next_block = *(int *)(memory_pool_header + prev_block * 8);\n    *(int *)(current_block + 8) = next_block;\n    *(undefined **)(current_block + 0xc) = memory_pool_header + prev_block * 8 + -8;\n    *(uint *)(memory_pool_header + 4) = block_size_aligned;\n    *(int *)(memory_pool_header + prev_block * 8) = current_block;\n    *(int *)(next_block + 0xc) = current_block;\n    do_nothing_with_pointer_080090b4(memory_pool,current_block,block_size_aligned,unused);\n    return;\n  }\n  block_header_size = block_size_aligned >> 9;\n  if (block_header_size < 5) {\n    prev_block = ((block_size_aligned >> 6) + 0x39) * 8;\n    next_block = (block_size_aligned >> 6) + 0x38;\n  }\n  else if (block_header_size < 0x15) {\n    prev_block = (block_header_size + 0x5c) * 8;\n    next_block = block_header_size + 0x5b;\n  }\n  else if (block_header_size < 0x55) {\n    prev_block = ((block_size_aligned >> 0xc) + 0x6f) * 8;\n    next_block = (block_size_aligned >> 0xc) + 0x6e;\n  }\n  else if (block_header_size < 0x155) {\n    prev_block = ((block_size_aligned >> 0xf) + 0x78) * 8;\n    next_block = (block_size_aligned >> 0xf) + 0x77;\n  }\n  else if (block_header_size < 0x555) {\n    prev_block = ((block_size_aligned >> 0x12) + 0x7d) * 8;\n    next_block = (block_size_aligned >> 0x12) + 0x7c;\n  }\n  else {\n    prev_block = 0x3f8;\n    next_block = 0x7e;\n  }\n  next_free_block = *(undefined **)(memory_pool_header + prev_block);\n  prev_free_block = memory_pool_header + prev_block + -8;\n  if (prev_free_block == next_free_block) {\n    next_free_block = (undefined *)(1 << (next_block >> 2 & 0xffU) | *(uint *)(memory_pool_header + 4));\n    *(undefined **)(memory_pool_header + 4) = next_free_block;\n    memory_pool_header = prev_free_block;\n  }\n  else {\n    do {\n      memory_pool_header = next_free_block;\n      if ((*(uint *)(next_free_block + 4) & 0xfffffffc) <= block_size_aligned) break;\n      next_free_block = *(undefined **)(next_free_block + 8);\n      memory_pool_header = prev_free_block;\n    } while (prev_free_block != next_free_block);\n    prev_free_block = *(undefined **)(memory_pool_header + 0xc);\n  }\n  *(undefined **)(current_block + 8) = memory_pool_header;\n  *(undefined **)(current_block + 0xc) = prev_free_block;\n  *(int *)(prev_free_block + 8) = current_block;\n  *(int *)(memory_pool_header + 0xc) = current_block;\n  do_nothing_with_pointer_080090b4(memory_pool,current_block,next_free_block,unused);\n  return;\n}\n\n",
            "called": [
                "FUN_0800884c",
                "FUN_080090b4",
                "FUN_080090a8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080088ec",
            "calling": [
                "FUN_08005e9c",
                "FUN_080097cc",
                "FUN_08009adc",
                "FUN_08008af8"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_080088ec"
        },
        "FUN_08005224": {
            "renaming": {
                "FUN_08005224": "initialize_device_08005224",
                "set_memory_param_080014f0": "set_memory_parameters",
                "calculate_and_write_result_080052a0": "calculate_and_write_results",
                "set_bit_flags_and_parse_bits_080055f4": "set_bit_flags_and_parse_bits",
                "set_initial_values_08005348": "set_initial_values",
                "initialize_device_and_check_errors_08005598": "initialize_device_and_check_for_errors",
                "initialize_memory_08005500": "initialize_memory",
                "initialize_binary_execution_080053b0": "initialize_binary_execution",
                "update_and_set_bitwise_value_080036a8": "update_and_set_bitwise_value",
                "initialize_data_and_calculate_statistics_0800491c": "initialize_data_and_calculate_statistics",
                "set_bit_and_flag_0800360c": "set_bit_and_flag",
                "interrupt_handler_08004e74": "interrupt_handler"
            },
            "code": "\nvoid initialize_device_08005224(void)\n\n{\n  set_memory_parameters();\n  calculate_and_write_results();\n  set_bit_flags_and_parse_bits_080055f4();\n  set_initial_values_08005348();\n  initialize_device_08005224_and_check_for_errors();\n  initialize_memory_08005500();\n  initialize_binary_execution_080053b0();\n  *(undefined **)PTR_DAT_0800527c = PTR_process_and_return_data_08004ea4_1_08005280;\n  *(undefined **)PTR_DAT_08005284 = PTR_execute_data_transfer_08004ee8_1_08005288;\n  *(undefined **)PTR_DAT_0800528c = PTR_get_pointer_value_08004f2c_1_08005290;\n  update_and_set_bitwise_value_080036a8(PTR_DAT_08005294,0);\n  update_and_set_bitwise_value_080036a8(PTR_DAT_08005294,0xc);\n  initialize_data_and_calculate_statistics(PTR_DAT_08005298);\n  set_bit_and_flag_0800360c(PTR_DAT_0800529c);\n  interrupt_handler_08004e74(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "FUN_080052a0",
                "FUN_08005598",
                "FUN_0800360c",
                "FUN_08005348",
                "FUN_080014f0",
                "FUN_080055f4",
                "FUN_080036a8",
                "FUN_08004e74",
                "FUN_0800491c",
                "FUN_08005500",
                "FUN_080053b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005224",
            "calling": [
                "FUN_080057e8"
            ],
            "imported": false,
            "current_name": "initialize_device_08005224"
        },
        "FUN_08003440": {
            "renaming": {
                "FUN_08003440": "calculate_result_08003440",
                "local_30": "value_1",
                "local_2c": "value_2",
                "uStack_28": "value_3",
                "uStack_24": "value_4",
                "uStack_20": "value_5",
                "local_1c": "result_1",
                "local_18": "result_2",
                "local_14": "data",
                "local_10": "final_result",
                "local_c": "result_3"
            },
            "code": "\nuint calculate_result_08003440(void)\n\n{\n  undefined2 value_1;\n  undefined4 value_2;\n  undefined4 value_3;\n  undefined4 value_4;\n  undefined4 value_5;\n  uint result_1;\n  undefined4 result_2;\n  uint data;\n  uint final_result;\n  uint result_3;\n  \n  value_2 = *(undefined4 *)PTR_DAT_080034f0;\n  value_3 = *(undefined4 *)(PTR_DAT_080034f0 + 4);\n  value_4 = *(undefined4 *)(PTR_DAT_080034f0 + 8);\n  value_5 = *(undefined4 *)(PTR_DAT_080034f0 + 0xc);\n  value_1 = *(undefined2 *)PTR_DAT_080034f4;\n  result_2 = 0;\n  result_3 = 0;\n  result_1 = 0;\n  final_result = 0;\n  data = *(uint *)(DAT_080034f8 + 4);\n  if ((data & 0xc) == 4) {\n    final_result = DAT_080034fc;\n  }\n  else if ((data & 0xc) == 8) {\n    result_1 = (uint)*(byte *)((int)&value_2 + (data >> 0x12 & 0xf));\n    if ((data & 0x10000) == 0) {\n      result_3 = DAT_08003500 * result_1;\n    }\n    else {\n      result_3 = (DAT_080034fc * result_1) /\n                (uint)*(byte *)((int)&value_1 + (*(uint *)(DAT_080034f8 + 4) >> 0x11 & 1));\n    }\n    final_result = result_3;\n  }\n  else {\n    final_result = DAT_080034fc;\n  }\n  return final_result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003440",
            "calling": [
                "FUN_08003260"
            ],
            "imported": false,
            "current_name": "calculate_result_08003440"
        },
        "FUN_080035fa": {
            "renaming": {
                "FUN_080035fa": "do_nothing_080035fa"
            },
            "code": "\nvoid do_nothing_080035fa(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035fa",
            "calling": [
                "FUN_080035a4"
            ],
            "imported": false,
            "current_name": "do_nothing_080035fa"
        },
        "FUN_08004f2c": {
            "renaming": {
                "FUN_08004f2c": "get_pointer_value_08004f2c",
                "uVar1": "pointer_value"
            },
            "code": "\nundefined4 get_pointer_value_08004f2c(void)\n\n{\n  undefined4 pointer_value;\n  \n  pointer_value = get_pointer_value_08004f2c_080015a0();\n  return pointer_value;\n}\n\n",
            "called": [
                "FUN_080015a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f2c",
            "calling": [],
            "imported": false,
            "current_name": "get_pointer_value_08004f2c"
        },
        "FUN_08005348": {
            "renaming": {
                "FUN_08005348": "set_initial_values_08005348",
                "calculate_values_and_set_flags_08001ab0": "calculate_values",
                "infinite_loop_08005674": "infinite_loop"
            },
            "code": "\nvoid set_initial_values_08005348(void)\n\n{\n  int iVar1;\n  \n  *(undefined4 *)PTR_DAT_080053a0 = DAT_080053a4;\n  *(undefined4 *)(PTR_DAT_080053a0 + 4) = DAT_080053a8;\n  *(undefined4 *)(PTR_DAT_080053a0 + 8) = 0;\n  *(undefined4 *)(PTR_DAT_080053a0 + 0xc) = 0;\n  *(undefined4 *)(PTR_DAT_080053a0 + 0x10) = 0x4000;\n  *(undefined4 *)(PTR_DAT_080053a0 + 0x14) = 0;\n  *(undefined4 *)(PTR_DAT_080053a0 + 0x18) = 0;\n  *(undefined4 *)(PTR_DAT_080053a0 + 0x1c) = 0;\n  *(undefined4 *)(PTR_DAT_080053a0 + 0x20) = 0;\n  iVar1 = calculate_values(PTR_DAT_080053a0);\n  if (iVar1 != 0) {\n    infinite_loop_08005674(PTR_s____src_main_c_080053ac,0x17a);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08005674",
                "FUN_08001ab0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005348",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "set_initial_values_08005348"
        },
        "FUN_08004378": {
            "renaming": {
                "FUN_08004378": "do_nothing_08004378"
            },
            "code": "\nvoid do_nothing_08004378(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004378",
            "calling": [
                "FUN_080036f8"
            ],
            "imported": false,
            "current_name": "do_nothing_08004378"
        },
        "FUN_080046ec": {
            "renaming": {
                "FUN_080046ec": "calculate_checksum_080046ec",
                "param_1": "input_array",
                "lVar1": "first_calculation_result",
                "lVar2": "second_calculation_result",
                "iVar3": "temp_integer_1",
                "iVar4": "temp_integer_2",
                "iVar5": "temp_integer_3",
                "uVar6": "shifted_pointer_value"
            },
            "code": "\nvoid calculate_checksum_080046ec(int *input_array)\n\n{\n  longlong first_calculation_result;\n  longlong second_calculation_result;\n  int temp_integer_1;\n  int temp_integer_2;\n  int temp_integer_3;\n  undefined8 shifted_pointer_value;\n  \n  *(uint *)(*input_array + 0x10) = input_array[3] | *(uint *)(*input_array + 0x10) & 0xffffcfff;\n  *(uint *)(*input_array + 0xc) =\n       *(uint *)(*input_array + 0xc) & 0xffffe9f3 | input_array[5] | input_array[2] | input_array[4];\n  *(uint *)(*input_array + 0x14) = input_array[6] | *(uint *)(*input_array + 0x14) & 0xfffffcff;\n  if (*input_array == DAT_08004914) {\n    shifted_pointer_value = shift_pointer_value_08003540();\n    first_calculation_result = (ulonglong)DAT_08004918 *\n            ((ulonglong)(uint)((int)shifted_pointer_value * 0x19) / (ulonglong)(uint)(input_array[1] << 2));\n    temp_integer_1 = shift_pointer_value_08003540((int)shifted_pointer_value,(int)((ulonglong)shifted_pointer_value >> 0x20),(int)first_calculation_result);\n    temp_integer_2 = input_array[1];\n    shifted_pointer_value = shift_pointer_value_08003540();\n    second_calculation_result = (ulonglong)DAT_08004918 *\n            (ulonglong)\n            (((uint)(temp_integer_1 * 0x19) / (uint)(temp_integer_2 << 2) +\n             (uint)((ulonglong)DAT_08004918 *\n                    ((ulonglong)(uint)((int)shifted_pointer_value * 0x19) / (ulonglong)(uint)(input_array[1] << 2)) >>\n                   0x25) * -100) * 0x10 + 0x32);\n    temp_integer_1 = shift_pointer_value_08003540((int)shifted_pointer_value,(int)((ulonglong)shifted_pointer_value >> 0x20),(int)second_calculation_result);\n    temp_integer_3 = input_array[1];\n    temp_integer_2 = shift_pointer_value_08003540();\n    *(uint *)(*input_array + 8) =\n         ((uint)((ulonglong)DAT_08004918 *\n                 (ulonglong)\n                 (((uint)(temp_integer_1 * 0x19) / (uint)(temp_integer_3 << 2) +\n                  (uint)((ulonglong)DAT_08004918 *\n                         ((ulonglong)(uint)(temp_integer_2 * 0x19) / (ulonglong)(uint)(input_array[1] << 2)) >>\n                        0x25) * -100) * 0x10 + 0x32) >> 0x25) & 0xf) +\n         (uint)((ulonglong)first_calculation_result >> 0x25) * 0x10 + ((uint)((ulonglong)second_calculation_result >> 0x25) & 0xf0);\n  }\n  else {\n    shifted_pointer_value = get_shifted_pointer_value_08003518();\n    first_calculation_result = (ulonglong)DAT_08004918 *\n            ((ulonglong)(uint)((int)shifted_pointer_value * 0x19) / (ulonglong)(uint)(input_array[1] << 2));\n    temp_integer_1 = get_shifted_pointer_value_08003518((int)shifted_pointer_value,(int)((ulonglong)shifted_pointer_value >> 0x20),(int)first_calculation_result);\n    temp_integer_2 = input_array[1];\n    shifted_pointer_value = get_shifted_pointer_value_08003518();\n    second_calculation_result = (ulonglong)DAT_08004918 *\n            (ulonglong)\n            (((uint)(temp_integer_1 * 0x19) / (uint)(temp_integer_2 << 2) +\n             (uint)((ulonglong)DAT_08004918 *\n                    ((ulonglong)(uint)((int)shifted_pointer_value * 0x19) / (ulonglong)(uint)(input_array[1] << 2)) >>\n                   0x25) * -100) * 0x10 + 0x32);\n    temp_integer_1 = get_shifted_pointer_value_08003518((int)shifted_pointer_value,(int)((ulonglong)shifted_pointer_value >> 0x20),(int)second_calculation_result);\n    temp_integer_3 = input_array[1];\n    temp_integer_2 = get_shifted_pointer_value_08003518();\n    *(uint *)(*input_array + 8) =\n         ((uint)((ulonglong)DAT_08004918 *\n                 (ulonglong)\n                 (((uint)(temp_integer_1 * 0x19) / (uint)(temp_integer_3 << 2) +\n                  (uint)((ulonglong)DAT_08004918 *\n                         ((ulonglong)(uint)(temp_integer_2 * 0x19) / (ulonglong)(uint)(input_array[1] << 2)) >>\n                        0x25) * -100) * 0x10 + 0x32) >> 0x25) & 0xf) +\n         (uint)((ulonglong)first_calculation_result >> 0x25) * 0x10 + ((uint)((ulonglong)second_calculation_result >> 0x25) & 0xf0);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08003540",
                "FUN_08003518"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080046ec",
            "calling": [
                "FUN_0800438a"
            ],
            "imported": false,
            "current_name": "calculate_checksum_080046ec"
        },
        "FUN_08005500": {
            "renaming": {
                "FUN_08005500": "initialize_memory_08005500",
                "local_20": "permission_flags",
                "local_1c": "permission_mask",
                "local_18": "permission_array",
                "check_params_and_update_080035a4": "check_memory_params",
                "infinite_loop_08005674": "halt_execution",
                "update_permissions_08003a94": "set_memory_permissions",
                "check_flag_status_080042de": "check_permission_flags"
            },
            "code": "\nvoid initialize_memory_08005500(void)\n\n{\n  int iVar1;\n  undefined4 permission_flags;\n  undefined4 permission_mask;\n  undefined4 permission_array [4];\n  \n  *(undefined4 *)PTR_DAT_08005590 = 0x40000000;\n  *(undefined4 *)(PTR_DAT_08005590 + 4) = 36000;\n  *(undefined4 *)(PTR_DAT_08005590 + 8) = 0;\n  *(undefined4 *)(PTR_DAT_08005590 + 0xc) = 0x14;\n  *(undefined4 *)(PTR_DAT_08005590 + 0x10) = 0;\n  *(undefined4 *)(PTR_DAT_08005590 + 0x18) = 0;\n  iVar1 = check_params_and_update_080035a4(PTR_DAT_08005590);\n  if (iVar1 != 0) {\n    infinite_loop_08005674(PTR_s____src_main_c_08005594,0x1d0);\n  }\n  permission_array[0] = 0x1000;\n  iVar1 = update_permissions_08003a94(PTR_DAT_08005590,permission_array);\n  if (iVar1 != 0) {\n    infinite_loop_08005674(PTR_s____src_main_c_08005594,0x1d5);\n  }\n  permission_flags = 0x20;\n  permission_mask = 0;\n  iVar1 = check_flag_status_080042de(PTR_DAT_08005590,&permission_flags);\n  if (iVar1 != 0) {\n    infinite_loop_08005674(PTR_s____src_main_c_08005594,0x1dc);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08003a94",
                "FUN_08005674",
                "FUN_080042de",
                "FUN_080035a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005500",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "initialize_memory_08005500"
        },
        "FUN_08002c2e": {
            "renaming": {
                "FUN_08002c2e": "check_for_flag_and_update_08002c2e",
                "param_1": "flag_ptr",
                "param_2": "max_size",
                "param_3": "offset",
                "iVar1": "flag_check_result",
                "get_pointer_value_080015a0": "get_current_pointer_value",
                "param_1[0x10]": "flag_state",
                "param_1[0xc]": "flag_reset_value"
            },
            "code": "\nundefined4 check_for_flag_and_update_08002c2e(int *flag_ptr,uint max_size,int offset)\n\n{\n  int flag_check_result;\n  \n  while( true ) {\n    if ((*(uint *)(*flag_ptr + 0x14) & 4) == 4) {\n      return 0;\n    }\n    flag_check_result = check_flag_08002d3c(flag_ptr);\n    if (flag_check_result != 0) break;\n    if ((max_size != 0xffffffff) &&\n       ((max_size == 0 || (flag_check_result = get_pointer_value_080015a0(), max_size < (uint)(flag_check_result - offset))))) {\n      flag_state = flag_state | 0x20;\n      flag_reset_value = 0;\n      *(undefined *)((int)flag_ptr + 0x3d) = 0x20;\n      *(undefined *)(flag_ptr + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "called": [
                "FUN_08002d3c",
                "FUN_080015a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c2e",
            "calling": [
                "FUN_08001ccc"
            ],
            "imported": false,
            "current_name": "check_for_flag_and_update_08002c2e"
        },
        "FUN_08003568": {
            "renaming": {
                "FUN_08003568": "count_down_by_param_multiplied_with_constant_08003568",
                "param_1": "input_number",
                "local_c": "counter",
                "bVar1": "is_counter_not_zero"
            },
            "code": "\nvoid count_down_by_param_multiplied_with_constant_08003568(int input_number)\n\n{\n  bool is_counter_not_zero;\n  int counter;\n  \n  counter = input_number * (uint)((ulonglong)DAT_080035a0 * (ulonglong)*(uint *)PTR_DAT_0800359c >> 0x29)\n  ;\n  do {\n    is_counter_not_zero = counter != 0;\n    counter = counter + -1;\n  } while (is_counter_not_zero);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003568",
            "calling": [
                "FUN_08002d98"
            ],
            "imported": false,
            "current_name": "count_down_by_param_multiplied_with_constant_08003568"
        },
        "FUN_080049cc": {
            "renaming": {
                "FUN_080049cc": "calculate_statistics_080049cc",
                "param_1": "data",
                "local_2c": "sum_of_floats",
                "local_28": "sum_of_integers",
                "local_24": "hash_function",
                "local_20": "number_of_elements",
                "local_1c": "counter",
                "local_18": "sum_of_hashed_floats",
                "local_14": "sum_of_hashed_integers",
                "local_10": "sum_of_data_floats",
                "local_c": "sum_of_data_integers"
            },
            "code": "\nvoid calculate_statistics_080049cc(int data)\n\n{\n  undefined4 uVar1;\n  undefined4 sum_of_floats;\n  undefined4 sum_of_integers;\n  undefined4 hash_function;\n  int number_of_elements;\n  int counter;\n  undefined4 sum_of_hashed_floats;\n  undefined4 sum_of_hashed_integers;\n  undefined4 sum_of_data_floats;\n  undefined4 sum_of_data_integers;\n  \n  number_of_elements = 1;\n  sum_of_data_integers = 0;\n  sum_of_data_floats = 0;\n  sum_of_hashed_integers = 0;\n  sum_of_hashed_floats = 0;\n  hash_function = (**(code **)PTR_DAT_08004adc)();\n  counter = 0;\n  while( true ) {\n    if (number_of_elements <= counter) break;\n    sum_of_integers = 0;\n    sum_of_floats = 0;\n    calculate_hashes_08004ae0(data);\n    calculate_integer_from_floating_point_08004d78(data,&sum_of_integers,&sum_of_floats);\n    sum_of_hashed_integers = binary_float_arithmetic_08000aa8(sum_of_hashed_integers,sum_of_integers);\n    sum_of_hashed_floats = binary_float_arithmetic_08000aa8(sum_of_hashed_floats,sum_of_floats);\n    sum_of_data_integers = binary_float_arithmetic_08000aa8(sum_of_data_integers,*(undefined4 *)(data + 0x10));\n    sum_of_data_floats = binary_float_arithmetic_08000aa8(sum_of_data_floats,*(undefined4 *)(data + 0x14));\n    hash_function = (**(code **)PTR_DAT_08004adc)();\n    counter = counter + 1;\n  }\n  uVar1 = calculate_hash_08000c10(number_of_elements);\n  uVar1 = floating_point_arithmetic_08000e20(sum_of_data_integers,uVar1);\n  *(undefined4 *)(data + 0x1c) = uVar1;\n  uVar1 = calculate_hash_08000c10(number_of_elements);\n  uVar1 = floating_point_arithmetic_08000e20(sum_of_data_floats,uVar1);\n  *(undefined4 *)(data + 0x20) = uVar1;\n  uVar1 = calculate_hash_08000c10(number_of_elements);\n  uVar1 = floating_point_arithmetic_08000e20(sum_of_hashed_integers,uVar1);\n  *(undefined4 *)(data + 0x24) = uVar1;\n  uVar1 = calculate_hash_08000c10(number_of_elements);\n  uVar1 = floating_point_arithmetic_08000e20(sum_of_hashed_floats,uVar1);\n  *(undefined4 *)(data + 0x28) = uVar1;\n  return;\n}\n\n",
            "called": [
                "FUN_08000e20",
                "FUN_08004d78",
                "FUN_08000aa8",
                "FUN_08004ae0",
                "FUN_08000c10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080049cc",
            "calling": [
                "FUN_0800491c"
            ],
            "imported": false,
            "current_name": "calculate_statistics_080049cc"
        },
        "FUN_08003c94": {
            "renaming": {
                "FUN_08003c94": "update_params_08003c94",
                "param_1": "params",
                "param_2": "new_params",
                "local_c": "old_param_value"
            },
            "code": "\nvoid update_params_08003c94(uint *params,uint *new_params)\n\n{\n  uint old_param_value;\n  \n  old_param_value = *params;\n  if ((((params == DAT_08003d54) || (params == (uint *)0x40000000)) || (params == DAT_08003d58))\n     || (params == DAT_08003d5c)) {\n    old_param_value = new_params[1] | old_param_value & 0xffffff8f;\n  }\n  if (((params == DAT_08003d54) || (params == (uint *)0x40000000)) ||\n     ((params == DAT_08003d58 || (params == DAT_08003d5c)))) {\n    old_param_value = new_params[3] | old_param_value & 0xfffffcff;\n  }\n  *params = new_params[5] | old_param_value & 0xffffff7f;\n  params[0xb] = new_params[2];\n  params[10] = *new_params;\n  if (params == DAT_08003d54) {\n    params[0xc] = new_params[4];\n  }\n  params[5] = 1;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003c94",
            "calling": [
                "FUN_080035a4",
                "FUN_08003640"
            ],
            "imported": false,
            "current_name": "update_params_08003c94"
        },
        "FUN_08000978": {
            "renaming": {
                "FUN_08000978": "check_params_and_return_08000978",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "param_3": "param_to_check_1",
                "param_4": "param_to_check_2"
            },
            "code": "\nvoid check_params_and_return_08000978(undefined4 input_param_1,undefined4 input_param_2,undefined4 param_to_check_1,undefined4 param_to_check_2)\n\n{\n  check_and_return_param_08000988(param_to_check_1,param_to_check_2,input_param_1,input_param_2);\n  return;\n}\n\n",
            "called": [
                "FUN_08000988"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000978",
            "calling": [
                "FUN_080009d4",
                "FUN_080009e8"
            ],
            "imported": false,
            "current_name": "check_params_and_return_08000978"
        },
        "FUN_0800884c": {
            "renaming": {
                "FUN_0800884c": "allocate_and_resize_memory_0800884c",
                "param_1": "ptr_to_memory",
                "param_2": "current_size",
                "puVar1": "ptr_to_data",
                "puVar2": "ptr_to_data2",
                "iVar3": "return_value",
                "iVar4": "new_size",
                "uVar5": "data_size"
            },
            "code": "\nundefined4 allocate_and_resize_memory_0800884c(undefined4 ptr_to_memory,int current_size)\n\n{\n  undefined *ptr_to_data;\n  undefined *ptr_to_data2;\n  int return_value;\n  int new_size;\n  uint data_size;\n  \n  ptr_to_data = PTR_DAT_080088e0;\n  do_nothing_with_pointer_080090a8();\n  data_size = *(uint *)(*(int *)(ptr_to_data + 8) + 4) & 0xfffffffc;\n  new_size = ((0xfef - current_size) + data_size & 0xfffff000) - 0x1000;\n  if (0xfff < new_size) {\n    return_value = allocate_memory_and_return_pointer_08009744(ptr_to_memory,0);\n    if (return_value == *(int *)(ptr_to_data + 8) + data_size) {\n      return_value = allocate_memory_and_return_pointer_08009744(ptr_to_memory,-new_size);\n      ptr_to_data2 = PTR_DAT_080088e4;\n      if (return_value != -1) {\n        return_value = *(int *)PTR_DAT_080088e4;\n        *(uint *)(*(int *)(ptr_to_data + 8) + 4) = data_size - new_size | 1;\n        *(int *)ptr_to_data2 = return_value - new_size;\n        do_nothing_with_pointer_080090b4(ptr_to_memory);\n        return 1;\n      }\n      new_size = allocate_memory_and_return_pointer_08009744(ptr_to_memory,0);\n      ptr_to_data2 = PTR_DAT_080088e4;\n      data_size = new_size - *(int *)(ptr_to_data + 8);\n      if (0xf < (int)data_size) {\n        return_value = *(int *)PTR_DAT_080088e8;\n        *(uint *)(*(int *)(ptr_to_data + 8) + 4) = data_size | 1;\n        *(int *)ptr_to_data2 = new_size - return_value;\n      }\n    }\n  }\n  do_nothing_with_pointer_080090b4(ptr_to_memory);\n  return 0;\n}\n\n",
            "called": [
                "FUN_08009744",
                "FUN_080090b4",
                "FUN_080090a8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800884c",
            "calling": [
                "FUN_080088ec"
            ],
            "imported": false,
            "current_name": "allocate_and_resize_memory_0800884c"
        },
        "FUN_0800901c": {
            "renaming": {
                "FUN_0800901c": "find_byte_sequence_0800901c",
                "param_1": "byte_sequence",
                "param_2": "byte_sequence_length",
                "param_3": "data",
                "puVar1": "current_byte_sequence",
                "uVar2": "mask",
                "uVar3": "xor_result",
                "puVar4": "current_data_byte",
                "uVar5": "last_byte_of_sequence",
                "bVar6": "end_of_data_reached"
            },
            "code": "\nuint * find_byte_sequence_0800901c(uint *byte_sequence,uint byte_sequence_length,uint *data)\n\n{\n  uint *current_byte_sequence;\n  uint mask;\n  uint xor_result;\n  uint *current_data_byte;\n  uint last_byte_of_sequence;\n  bool end_of_data_reached;\n  \n  last_byte_of_sequence = byte_sequence_length & 0xff;\n  current_byte_sequence = byte_sequence;\n  if (((uint)byte_sequence & 3) == 0) {\nLAB_0800904a:\n    byte_sequence = data;\n    if ((uint *)0x3 < data) {\n      mask = (byte_sequence_length & 0xff) << 8 | last_byte_of_sequence;\n      current_data_byte = current_byte_sequence;\n      do {\n        xor_result = *current_data_byte ^ (mask | mask << 0x10);\n        current_byte_sequence = current_data_byte + 1;\n        if ((xor_result + 0xfefefeff & ~xor_result & 0x80808080) != 0) goto LAB_08009050;\n        data = data + -1;\n        byte_sequence = data;\n        current_data_byte = current_byte_sequence;\n      } while ((uint *)0x3 < data);\n    }\n    current_data_byte = current_byte_sequence;\n    data = byte_sequence;\n    if (byte_sequence != (uint *)0x0) {\nLAB_08009050:\n      byte_sequence = current_data_byte;\n      if (*(byte *)byte_sequence != last_byte_of_sequence) {\n        data = (uint *)((int)data + (int)byte_sequence);\n        do {\n          byte_sequence = (uint *)((int)byte_sequence + 1);\n          if (data == byte_sequence) goto LAB_0800906c;\n        } while (*(byte *)byte_sequence != last_byte_of_sequence);\n      }\n    }\n  }\n  else {\n    current_data_byte = (uint *)((int)data + -1);\n    if (data == (uint *)0x0) {\nLAB_0800906c:\n      byte_sequence = (uint *)0x0;\n    }\n    else if (*(byte *)byte_sequence != last_byte_of_sequence) {\n      current_byte_sequence = (uint *)((int)byte_sequence + 1);\n      do {\n        byte_sequence = current_byte_sequence;\n        current_byte_sequence = byte_sequence;\n        data = current_data_byte;\n        if (((uint)byte_sequence & 3) == 0) goto LAB_0800904a;\n        end_of_data_reached = current_data_byte == (uint *)0x0;\n        current_data_byte = (uint *)((int)current_data_byte + -1);\n        if (end_of_data_reached) goto LAB_0800906c;\n        current_byte_sequence = (uint *)((int)byte_sequence + 1);\n      } while (*(byte *)byte_sequence != last_byte_of_sequence);\n    }\n  }\n  return byte_sequence;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800901c",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "find_byte_sequence_0800901c"
        },
        "FUN_0800177c": {
            "renaming": {
                "FUN_0800177c": "set_flag_if_param_1_is_4_0800177c",
                "param_1": "input_value"
            },
            "code": "\nvoid set_flag_if_param_1_is_4_0800177c(int input_value)\n\n{\n  if (input_value == 4) {\n    *DAT_080017b0 = *DAT_080017b0 | 4;\n  }\n  else {\n    *DAT_080017b0 = *DAT_080017b0 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800177c",
            "calling": [
                "FUN_080052a0"
            ],
            "imported": false,
            "current_name": "set_flag_if_param_1_is_4_0800177c"
        },
        "FUN_080017b4": {
            "renaming": {
                "FUN_080017b4": "process_input_080017b4",
                "process_input_data_08004f78": "process_input_data"
            },
            "code": "\nvoid process_input_080017b4(void)\n\n{\n  process_input_080017b4_data(0);\n  return;\n}\n\n",
            "called": [
                "FUN_08004f78"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080017b4",
            "calling": [
                "FUN_08005704"
            ],
            "imported": false,
            "current_name": "process_input_080017b4"
        },
        "FUN_08005598": {
            "renaming": {
                "FUN_08005598": "initialize_device_and_check_errors_08005598",
                "initialize_device_0800438a": "initialize_device",
                "infinite_loop_08005674": "infinite_loop"
            },
            "code": "\nvoid initialize_device_and_check_errors_08005598(void)\n\n{\n  int iVar1;\n  \n  *(undefined4 *)PTR_DAT_080055e8 = DAT_080055ec;\n  *(undefined4 *)(PTR_DAT_080055e8 + 4) = 0x1c200;\n  *(undefined4 *)(PTR_DAT_080055e8 + 8) = 0;\n  *(undefined4 *)(PTR_DAT_080055e8 + 0xc) = 0;\n  *(undefined4 *)(PTR_DAT_080055e8 + 0x10) = 0;\n  *(undefined4 *)(PTR_DAT_080055e8 + 0x14) = 0xc;\n  *(undefined4 *)(PTR_DAT_080055e8 + 0x18) = 0;\n  *(undefined4 *)(PTR_DAT_080055e8 + 0x1c) = 0;\n  iVar1 = initialize_device_0800438a(PTR_DAT_080055e8);\n  if (iVar1 != 0) {\n    infinite_loop_08005674(PTR_s____src_main_c_080055f0,0x1ed);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08005674",
                "FUN_0800438a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005598",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "initialize_device_and_check_errors_08005598"
        },
        "FUN_08001030": {
            "renaming": {
                "FUN_08001030": "check_null_termination_08001030",
                "in_CY": "last_character",
                "concatenate_64bit_values_08000fc8": "concatenate_64bit_values"
            },
            "code": "\nbool check_null_termination_08001030(void)\n\n{\n  char last_character;\n  \n  concatenate_64bit_values();\n  return last_character == '\\0';\n}\n\n",
            "called": [
                "FUN_08000fc8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001030",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "check_null_termination_08001030"
        },
        "FUN_080011ec": {
            "renaming": {
                "FUN_080011ec": "calculate_result_080011ec",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "quotient",
                "CONCAT44": "combine_integers",
                "uVar1": "result"
            },
            "code": "\nundefined8 calculate_result_080011ec(int dividend,int divisor,int remainder,int quotient)\n\n{\n  undefined8 result;\n  \n  if ((quotient == 0) && (remainder == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      divisor = -1;\n      dividend = -1;\n    }\n    return combine_integers(divisor,dividend);\n  }\n  result = calculate_division_remainder_0800121c();\n  return result;\n}\n\n",
            "called": [
                "FUN_0800121c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080011ec",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "calculate_result_080011ec"
        },
        "FUN_08004424": {
            "renaming": {
                "FUN_08004424": "do_nothing_08004424"
            },
            "code": "\nvoid do_nothing_08004424(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004424",
            "calling": [
                "FUN_0800438a"
            ],
            "imported": false,
            "current_name": "do_nothing_08004424"
        },
        "FUN_08004f3c": {
            "renaming": {
                "FUN_08004f3c": "validate_input_08004f3c",
                "param_1": "input_ptr",
                "param_2": "input_str"
            },
            "code": "\nvoid validate_input_08004f3c(undefined4 input_ptr,undefined2 input_str)\n\n{\n  validate_input_08004f3c_08004436(PTR_DAT_08004f5c,input_ptr,input_str,0x32);\n  return;\n}\n\n",
            "called": [
                "FUN_08004436"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f3c",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "validate_input_08004f3c"
        },
        "FUN_08009adc": {
            "renaming": {
                "FUN_08009adc": "allocate_or_resize_memory_block_08009adc",
                "param_1": "mem_pool",
                "param_2": "memory_block",
                "param_3": "new_size",
                "puVar1": "header",
                "piVar2": "prev_block",
                "iVar3": "temp",
                "piVar4": "curr_block",
                "uVar5": "block_size",
                "iVar6": "temp_2",
                "uVar7": "curr_block_size",
                "uVar9": "new_block_size",
                "uVar10": "aligned_size",
                "uVar11": "new_block_total_size",
                "iVar12": "next_block"
            },
            "code": "\nint * allocate_or_resize_memory_block_08009adc(undefined4 *mem_pool,int *memory_block,uint new_size)\n\n{\n  undefined *header;\n  int *prev_block;\n  int temp;\n  int *curr_block;\n  uint block_size;\n  int temp_2;\n  uint curr_block_size;\n  int *piVar8;\n  uint new_block_size;\n  uint aligned_size;\n  uint new_block_total_size;\n  int next_block;\n  \n  if (memory_block == (int *)0x0) {\n    curr_block = (int *)allocate_and_return_pointer_08008af8(mem_pool,new_size);\n    return curr_block;\n  }\n  do_nothing_with_pointer_080090a8();\n  header = PTR_DAT_08009e38;\n  curr_block_size = memory_block[-1];\n  aligned_size = curr_block_size & 0xfffffffc;\n  curr_block = memory_block + -2;\n  if (new_size + 0xb < 0x17) {\n    new_block_size = 0x10;\n  }\n  else {\n    new_block_size = new_size + 0xb & 0xfffffff8;\n    if ((int)new_block_size < 0) goto LAB_08009b8e;\n  }\n  if (new_block_size < new_size) {\nLAB_08009b8e:\n    *mem_pool = 0xc;\n    return (int *)0x0;\n  }\n  next_block = (int)curr_block + aligned_size;\n  new_block_total_size = aligned_size;\n  if ((int)aligned_size < (int)new_block_size) {\n    if (*(int *)(PTR_DAT_08009e38 + 8) == next_block) {\n      next_block = (*(uint *)(*(int *)(PTR_DAT_08009e38 + 8) + 4) & 0xfffffffc) + aligned_size;\n      if ((int)(new_block_size + 0x10) <= next_block) {\n        *(uint *)(PTR_DAT_08009e38 + 8) = (int)curr_block + new_block_size;\n        *(uint *)((int)curr_block + new_block_size + 4) = next_block - new_block_size | 1;\n        memory_block[-1] = new_block_size | memory_block[-1] & 1U;\n        do_nothing_with_pointer_080090b4(mem_pool);\n        return memory_block;\n      }\n      if (-1 < (int)(curr_block_size << 0x1f)) {\n        prev_block = (int *)((int)curr_block - memory_block[-2]);\n        curr_block_size = prev_block[1] & 0xfffffffc;\n        if ((int)(new_block_size + 0x10) <= (int)(next_block + curr_block_size)) {\n          temp_2 = prev_block[3];\n          curr_block = prev_block + 2;\n          temp = *curr_block;\n          aligned_size = aligned_size - 4;\n          *(int *)(temp + 0xc) = temp_2;\n          *(int *)(temp_2 + 8) = temp;\n          if (aligned_size < 0x25) {\n            temp = *memory_block;\n            piVar8 = curr_block;\n            if (0x13 < aligned_size) {\n              prev_block[2] = temp;\n              prev_block[3] = memory_block[1];\n              temp = memory_block[2];\n              if (aligned_size < 0x1c) {\n                memory_block = memory_block + 2;\n                piVar8 = prev_block + 4;\n              }\n              else {\n                prev_block[4] = temp;\n                prev_block[5] = memory_block[3];\n                temp = memory_block[4];\n                if (aligned_size == 0x24) {\n                  prev_block[6] = temp;\n                  prev_block[7] = memory_block[5];\n                  temp = memory_block[6];\n                  memory_block = memory_block + 6;\n                  piVar8 = prev_block + 8;\n                }\n                else {\n                  memory_block = memory_block + 4;\n                  piVar8 = prev_block + 6;\n                }\n              }\n            }\n            *piVar8 = temp;\n            piVar8[1] = memory_block[1];\n            piVar8[2] = memory_block[2];\n          }\n          else {\n            copy_memory_backward_08009a18(curr_block,memory_block);\n          }\n          *(uint *)(header + 8) = (int)prev_block + new_block_size;\n          *(uint *)((int)prev_block + new_block_size + 4) = (next_block + curr_block_size) - new_block_size | 1;\n          prev_block[1] = new_block_size | prev_block[1] & 1U;\n          do_nothing_with_pointer_080090b4(mem_pool);\n          return curr_block;\n        }\nLAB_08009bb0:\n        new_block_total_size = aligned_size + curr_block_size;\n        if ((int)new_block_size <= (int)new_block_total_size) {\n          temp_2 = prev_block[3];\n          piVar8 = prev_block + 2;\n          temp = *piVar8;\n          *(int *)(temp + 0xc) = temp_2;\n          next_block = (int)prev_block + new_block_total_size;\n          *(int *)(temp_2 + 8) = temp;\n          curr_block = prev_block;\n          if (aligned_size - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          copy_memory_backward_08009a18(piVar8,memory_block);\n          memory_block = piVar8;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(next_block + 4) & 0xfffffffe) + next_block + 4) << 0x1f) {\n        block_size = *(uint *)(next_block + 4) & 0xfffffffc;\n        new_block_total_size = aligned_size + block_size;\n        if ((int)new_block_total_size < (int)new_block_size) {\n          if ((int)(curr_block_size << 0x1f) < 0) goto LAB_08009b36;\n          prev_block = (int *)((int)curr_block - memory_block[-2]);\n          curr_block_size = prev_block[1] & 0xfffffffc;\n          new_block_total_size = block_size + curr_block_size + aligned_size;\n          if ((int)new_block_total_size < (int)new_block_size) goto LAB_08009bb0;\n          temp = *(int *)(next_block + 8);\n          next_block = *(int *)(next_block + 0xc);\n          *(int *)(temp + 0xc) = next_block;\n          *(int *)(next_block + 8) = temp;\n          piVar8 = prev_block + 2;\n          temp = *piVar8;\n          temp_2 = prev_block[3];\n          *(int *)(temp + 0xc) = temp_2;\n          next_block = (int)prev_block + new_block_total_size;\n          *(int *)(temp_2 + 8) = temp;\n          curr_block = prev_block;\n          if (0x24 < aligned_size - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          aligned_size = aligned_size - 4;\n          temp = *memory_block;\n          prev_block = piVar8;\n          if (0x13 < aligned_size) {\n            curr_block[2] = temp;\n            curr_block[3] = memory_block[1];\n            temp = memory_block[2];\n            if (aligned_size < 0x1c) {\n              memory_block = memory_block + 2;\n              prev_block = curr_block + 4;\n            }\n            else {\n              curr_block[4] = temp;\n              curr_block[5] = memory_block[3];\n              temp = memory_block[4];\n              if (aligned_size == 0x24) {\n                curr_block[6] = temp;\n                curr_block[7] = memory_block[5];\n                temp = memory_block[6];\n                memory_block = memory_block + 6;\n                prev_block = curr_block + 8;\n              }\n              else {\n                memory_block = memory_block + 4;\n                prev_block = curr_block + 6;\n              }\n            }\n          }\n          *prev_block = temp;\n          prev_block[1] = memory_block[1];\n          prev_block[2] = memory_block[2];\n          memory_block = piVar8;\n        }\n        else {\n          temp = *(int *)(next_block + 8);\n          temp_2 = *(int *)(next_block + 0xc);\n          *(int *)(temp + 0xc) = temp_2;\n          next_block = (int)curr_block + new_block_total_size;\n          *(int *)(temp_2 + 8) = temp;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(curr_block_size << 0x1f)) {\n        prev_block = (int *)((int)curr_block - memory_block[-2]);\n        curr_block_size = prev_block[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    prev_block = (int *)allocate_and_return_pointer_08008af8(mem_pool,new_size);\n    if (prev_block != (int *)0x0) {\n      if ((int *)((memory_block[-1] & 0xfffffffeU) + (int)curr_block) == prev_block + -2) {\n        new_block_total_size = aligned_size + (prev_block[-1] & 0xfffffffcU);\n        next_block = (int)curr_block + new_block_total_size;\n        goto LAB_08009c00;\n      }\n      aligned_size = aligned_size - 4;\n      if (aligned_size < 0x25) {\n        next_block = *memory_block;\n        curr_block = memory_block;\n        piVar8 = prev_block;\n        if (0x13 < aligned_size) {\n          *prev_block = next_block;\n          prev_block[1] = memory_block[1];\n          if (aligned_size < 0x1c) {\n            next_block = memory_block[2];\n            curr_block = memory_block + 2;\n            piVar8 = prev_block + 2;\n          }\n          else {\n            prev_block[2] = memory_block[2];\n            prev_block[3] = memory_block[3];\n            if (aligned_size == 0x24) {\n              prev_block[4] = memory_block[4];\n              prev_block[5] = memory_block[5];\n              next_block = memory_block[6];\n              curr_block = memory_block + 6;\n              piVar8 = prev_block + 6;\n            }\n            else {\n              next_block = memory_block[4];\n              curr_block = memory_block + 4;\n              piVar8 = prev_block + 4;\n            }\n          }\n        }\n        *piVar8 = next_block;\n        piVar8[1] = curr_block[1];\n        piVar8[2] = curr_block[2];\n      }\n      else {\n        copy_memory_backward_08009a18(prev_block,memory_block);\n      }\n      allocate_memory_block_080088ec(mem_pool,memory_block);\n    }\n    do_nothing_with_pointer_080090b4(mem_pool);\n    memory_block = prev_block;\n  }\n  else {\nLAB_08009c00:\n    if (new_block_total_size - new_block_size < 0x10) {\n      curr_block[1] = curr_block[1] & 1U | new_block_total_size;\n      *(uint *)(next_block + 4) = *(uint *)(next_block + 4) | 1;\n    }\n    else {\n      curr_block[1] = curr_block[1] & 1U | new_block_size;\n      *(uint *)((int)curr_block + new_block_size + 4) = new_block_total_size - new_block_size | 1;\n      *(uint *)(next_block + 4) = *(uint *)(next_block + 4) | 1;\n      allocate_memory_block_080088ec(mem_pool,(int)curr_block + new_block_size + 8);\n    }\n    do_nothing_with_pointer_080090b4(mem_pool);\n  }\n  return memory_block;\n}\n\n",
            "called": [
                "FUN_080090b4",
                "FUN_08009a18",
                "FUN_080090a8",
                "FUN_08008af8",
                "FUN_080088ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009adc",
            "calling": [
                "FUN_080097cc"
            ],
            "imported": false,
            "current_name": "allocate_or_resize_memory_block_08009adc"
        },
        "FUN_08003696": {
            "renaming": {
                "FUN_08003696": "do_nothing_08003696"
            },
            "code": "\nvoid do_nothing_08003696(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003696",
            "calling": [
                "FUN_08003640"
            ],
            "imported": false,
            "current_name": "do_nothing_08003696"
        },
        "FUN_08002640": {
            "renaming": {
                "FUN_08002640": "check_and_set_flag_08002640",
                "param_1": "pptr",
                "param_2": "byte_val",
                "param_3": "ushort_val",
                "param_4": "flag",
                "param_5": "max_value",
                "param_6": "ptr",
                "iVar1": "result",
                "uVar2": "return_val"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nundefined4\ncheck_and_set_flag_08002640(uint **pptr,byte byte_val,undefined2 ushort_val,short flag,uint max_value,int ptr)\n\n{\n  int result;\n  undefined4 return_val;\n  \n  **pptr = **pptr | 0x100;\n  do {\n    if ((~(*pptr)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_0800270a;\n    }\n  } while ((max_value == 0xffffffff) ||\n          ((max_value != 0 && (result = get_pointer_value_080015a0(), (uint)(result - ptr) <= max_value))));\n  pptr[0xc] = (uint *)0x0;\n  *(undefined *)((int)pptr + 0x3d) = 0x20;\n  *(undefined *)((int)pptr + 0x3e) = 0;\n  *(undefined *)(pptr + 0xf) = 0;\n  result = 3;\nLAB_0800270a:\n  if (result == 0) {\n    (*pptr)[4] = byte_val & 0xfe;\n    result = check_and_set_flag_08002640_08002ad8(pptr,DAT_080027f0,max_value,ptr);\n    if (result == 0) {\n      result = check_pointer_value_08002bb4(pptr,max_value,ptr,(*pptr)[6]);\n      if (result == 0) {\n        if (flag == 1) {\n          (*pptr)[4] = (uint)(byte)ushort_val;\n        }\n        else {\n          (*pptr)[4] = (uint)(byte)((ushort)ushort_val >> 8);\n          result = check_pointer_value_08002bb4(pptr,max_value,ptr);\n          if (result != 0) {\n            if (pptr[0x10] == (uint *)0x4) {\n              **pptr = **pptr | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*pptr)[4] = (uint)(byte)ushort_val;\n        }\n        return_val = 0;\n      }\n      else if (pptr[0x10] == (uint *)0x4) {\n        **pptr = **pptr | 0x200;\n        return_val = 1;\n      }\n      else {\n        return_val = 3;\n      }\n    }\n    else if (pptr[0x10] == (uint *)0x4) {\n      return_val = 1;\n    }\n    else {\n      return_val = 3;\n    }\n  }\n  else {\n    return_val = 3;\n  }\n  return return_val;\n}\n\n",
            "called": [
                "FUN_080015a0",
                "FUN_08002bb4",
                "FUN_08002ad8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002640",
            "calling": [
                "FUN_08001ccc"
            ],
            "imported": false,
            "current_name": "check_and_set_flag_08002640"
        },
        "FUN_080008fc": {
            "renaming": {
                "FUN_080008fc": "check_parameters_080008fc",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "code": "\nuint check_parameters_080008fc(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(param_2 << 1) >> 0x15 == -1 || (int)(param_4 << 1) >> 0x15 == -1) &&\n     ((((int)(param_2 << 1) >> 0x15 == -1 && ((param_1 | param_2 << 0xc) != 0)) ||\n      (((int)(param_4 << 1) >> 0x15 == -1 && ((param_3 | param_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (param_1 | param_2 << 1) == 0;\n  if (isZero) {\n    isZero = (param_3 | param_4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = param_2 == param_4;\n  }\n  if (isZero) {\n    isZero = param_1 == param_3;\n  }\n  if (!isZero) {\n    result = param_2 ^ param_4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = param_2 == param_4;\n    }\n    isNegative = -1 < (int)result && param_4 <= param_2;\n    if (isZero) {\n      isNegative = param_3 <= param_1;\n    }\n    param_4 = (int)param_4 >> 0x1f;\n    if (!isNegative) {\n      param_4 = ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080008fc",
            "calling": [
                "FUN_08000988"
            ],
            "imported": false,
            "current_name": "check_parameters_080008fc"
        },
        "FUN_08000988": {
            "renaming": {
                "FUN_08000988": "check_and_return_param_08000988",
                "param_1": "input_param",
                "check_parameters_080008fc": "validate_input",
                "return": "output"
            },
            "code": "\nundefined4 check_and_return_param_08000988(undefined4 input_param)\n\n{\n  check_parameters_080008fc();\n  output input_param;\n}\n\n",
            "called": [
                "FUN_080008fc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000988",
            "calling": [
                "FUN_08000978",
                "FUN_080009c0",
                "FUN_08000998",
                "FUN_080009ac"
            ],
            "imported": false,
            "current_name": "check_and_return_param_08000988"
        },
        "FUN_08001714": {
            "renaming": {
                "FUN_08001714": "set_param_in_memory_08001714",
                "param_1": "memory_parameter"
            },
            "code": "\nvoid set_param_in_memory_08001714(undefined4 memory_parameter)\n\n{\n  set_param_in_memory_08001714_080015b4(memory_parameter);\n  return;\n}\n\n",
            "called": [
                "FUN_080015b4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001714",
            "calling": [
                "FUN_080014f0"
            ],
            "imported": false,
            "current_name": "set_param_in_memory_08001714"
        },
        "FUN_08005dfc": {
            "renaming": {
                "FUN_08005dfc": "process_data_08005dfc",
                "param_1": "input_buffer",
                "param_2": "buffer_size",
                "param_3": "output_buffer",
                "param_4": "output_buffer_size",
                "local_80": "output_buffer_ptr",
                "local_78": "max_output_size",
                "uStack_74": "constant_value",
                "local_70": "current_input_position",
                "local_6c": "max_input_size",
                "uStack_8": "additional_input",
                "uStack_4": "additional_input_size"
            },
            "code": "\nvoid process_data_08005dfc(undefined *input_buffer,undefined4 buffer_size,undefined4 output_buffer,undefined4 output_buffer_size)\n\n{\n  undefined *output_buffer_ptr [2];\n  undefined4 max_output_size;\n  undefined4 constant_value;\n  undefined *current_input_position;\n  undefined4 max_input_size;\n  undefined4 additional_input;\n  undefined4 additional_input_size;\n  \n  max_input_size = 0x7fffffff;\n  max_output_size = 0x7fffffff;\n  constant_value = DAT_08005e3c;\n  output_buffer_ptr[0] = input_buffer;\n  current_input_position = input_buffer;\n  additional_input = output_buffer;\n  additional_input_size = output_buffer_size;\n  FUNC_08005e9c(*(undefined4 *)PTR_PTR_DAT_08005e38,output_buffer_ptr,buffer_size,&additional_input);\n  *output_buffer_ptr[0] = 0;\n  return;\n}\n\n",
            "called": [
                "FUN_08005e9c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005dfc",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "process_data_08005dfc"
        },
        "FUN_080078c0": {
            "renaming": {
                "FUN_080078c0": "calculate_division_and_subtraction_080078c0",
                "param_1": "array1",
                "param_2": "array2",
                "uVar1": "carry",
                "puVar2": "ptr1",
                "iVar3": "temp",
                "iVar4": "length2",
                "iVar5": "index",
                "uVar6": "quotient",
                "puVar7": "ptr2",
                "puVar8": "ptr3",
                "puVar9": "ptr4",
                "uVar10": "carry2",
                "puVar11": "ptr5",
                "puVar12": "ptr6"
            },
            "code": "\nuint calculate_division_and_subtraction_080078c0(int array1,int array2)\n\n{\n  uint carry;\n  uint *ptr1;\n  int temp;\n  int length2;\n  int index;\n  uint quotient;\n  uint *ptr2;\n  uint *ptr3;\n  uint *ptr4;\n  uint carry2;\n  uint *ptr5;\n  uint *ptr6;\n  \n  length2 = *(int *)(array2 + 0x10);\n  if (*(int *)(array1 + 0x10) < length2) {\n    return 0;\n  }\n  index = length2 + -1;\n  ptr2 = (uint *)(array2 + 0x14);\n  ptr3 = (uint *)(array1 + 0x14);\n  quotient = ptr3[index] / (ptr2[index] + 1);\n  ptr4 = ptr2 + index;\n  if (quotient != 0) {\n    carry = 0;\n    temp = 0;\n    ptr1 = ptr3;\n    ptr5 = ptr2;\n    do {\n      ptr6 = ptr5 + 1;\n      carry = quotient * (*ptr5 & 0xffff) + carry;\n      carry2 = quotient * (*ptr5 >> 0x10) + (carry >> 0x10);\n      carry = (temp - (carry & 0xffff)) + (*ptr1 & 0xffff);\n      temp = ((*ptr1 >> 0x10) - (carry2 & 0xffff)) + ((int)carry >> 0x10);\n      *ptr1 = carry & 0xffff | temp * 0x10000;\n      temp = temp >> 0x10;\n      carry = carry2 >> 0x10;\n      ptr1 = ptr1 + 1;\n      ptr5 = ptr6;\n    } while (ptr6 <= ptr4);\n    if (ptr3[index] == 0) {\n      if ((ptr3 < ptr3 + length2 + -2) && (ptr3[length2 + -2] == 0)) {\n        ptr1 = ptr3 + length2 + -3;\n        do {\n          index = index + -1;\n          if (ptr1 <= ptr3) break;\n          carry = *ptr1;\n          ptr1 = ptr1 + -1;\n        } while (carry == 0);\n      }\n      *(int *)(array1 + 0x10) = index;\n    }\n  }\n  length2 = compare_arrays_080094f8();\n  if (-1 < length2) {\n    length2 = 0;\n    quotient = quotient + 1;\n    ptr1 = ptr3;\n    do {\n      ptr5 = ptr2 + 1;\n      carry = (length2 - (*ptr2 & 0xffff)) + (*ptr1 & 0xffff);\n      length2 = ((*ptr1 >> 0x10) - (*ptr2 >> 0x10)) + ((int)carry >> 0x10);\n      *ptr1 = carry & 0xffff | length2 * 0x10000;\n      length2 = length2 >> 0x10;\n      ptr1 = ptr1 + 1;\n      ptr2 = ptr5;\n    } while (ptr5 <= ptr4);\n    if (ptr3[index] == 0) {\n      if ((ptr3 < ptr3 + index + -1) && (ptr3[index + -1] == 0)) {\n        ptr2 = ptr3 + index + -2;\n        do {\n          index = index + -1;\n          if (ptr2 <= ptr3) break;\n          carry = *ptr2;\n          ptr2 = ptr2 + -1;\n        } while (carry == 0);\n      }\n      *(int *)(array1 + 0x10) = index;\n    }\n  }\n  return quotient;\n}\n\n",
            "called": [
                "FUN_080094f8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078c0",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "calculate_division_and_subtraction_080078c0"
        },
        "thunk_FUN_08005838": {
            "renaming": {
                "thunk_FUN_08005838": "calculate_result_thunk_08005838",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "difference",
                "uVar2": "upperResult",
                "uVar3": "resultType",
                "uVar4": "result",
                "uVar5": "absoluteInput2",
                "uVar6": "combinedInputs"
            },
            "code": "\nuint calculate_result_thunk_08005838(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int difference;\n  undefined4 upperResult;\n  uint resultType;\n  uint result;\n  uint absoluteInput2;\n  undefined8 combinedInputs;\n  \n  combinedInputs = CONCAT44(DAT_080059bc,DAT_080059b8);\n  result = input4 & 0x7fffffff;\n  if ((DAT_080059e8 < (result | (-input3 | input3) >> 0x1f)) ||\n     (absoluteInput2 = input2 & 0x7fffffff, DAT_080059e8 < (absoluteInput2 | (-input1 | input1) >> 0x1f))) {\n    result = calculate_double_precision_float_0800015c(input3,input4,input1,input2);\n    return result;\n  }\n  if ((input4 + 0xc0100000 | input3) == 0) {\n    result = calculate_result_thunk_08005838_080059f0();\n    return result;\n  }\n  resultType = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n  if ((absoluteInput2 | input1) == 0) {\n    if (resultType == 2) {\n      return DAT_080059b0;\n    }\n    result = DAT_080059a0;\n    if (resultType != 3) {\n      return input1;\n    }\n  }\n  else {\n    if ((result | input3) != 0) {\n      if (result == DAT_080059e8) {\n        if (absoluteInput2 == result) {\n          if (resultType == 2) {\n            return DAT_080059e0;\n          }\n          if (resultType == 3) {\n            return DAT_080059d8;\n          }\n          if (resultType == 1) {\n            return DAT_080059d0;\n          }\n          return DAT_080059c8;\n        }\n        if (resultType == 2) {\n          return DAT_080059b0;\n        }\n        if (resultType == 3) {\n          return DAT_080059a0;\n        }\n        if (resultType == 1) {\n          return 0;\n        }\n        return 0;\n      }\n      if (absoluteInput2 != DAT_080059e8) {\n        difference = (int)(absoluteInput2 - result) >> 0x14;\n        if (difference < 0x3d) {\n          if (((int)input4 < 0) && (difference + 0x3c < 0 != SCARRY4(difference,0x3c))) {\n            combinedInputs = 0;\n          }\n          else {\n            FUNC_0800071c(input1,input2,input3,input4,input4);\n            do_nothing_08005d0c();\n            combinedInputs = calculate_result_thunk_08005838_080059f0();\n          }\n        }\n        upperResult = (undefined4)((ulonglong)combinedInputs >> 0x20);\n        result = (uint)combinedInputs;\n        if (resultType == 1) {\n          return result;\n        }\n        if (resultType == 2) {\n          combinedInputs = floating_point_addition_08000158(result,upperResult,DAT_080059a8,DAT_080059ac);\n          result = floating_point_addition_08000158(DAT_080059b0,DAT_080059b4,(int)combinedInputs,(int)((ulonglong)combinedInputs >> 0x20))\n          ;\n          return result;\n        }\n        if (resultType == 0) {\n          return result;\n        }\n        combinedInputs = floating_point_addition_08000158(result,upperResult,DAT_080059a8,DAT_080059ac);\n        result = floating_point_addition_08000158((int)combinedInputs,(int)((ulonglong)combinedInputs >> 0x20),DAT_080059b0,DAT_080059b4);\n        return result;\n      }\n    }\n    result = DAT_080059c0;\n    if (-1 < (int)input2) {\n      result = DAT_080059b8;\n    }\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_08005838"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005834",
            "calling": [
                "FUN_08004d78",
                "FUN_08004bd8"
            ],
            "imported": false,
            "current_name": "calculate_result_thunk_08005838"
        },
        "FUN_080003f4": {
            "renaming": {
                "FUN_080003f4": "bit_shift_and_concatenate_080003f4",
                "param_1": "input_number",
                "uVar1": "upper_32_bits",
                "uVar2": "absolute_value",
                "uVar3": "shift_amount",
                "iVar4": "leading_zeros",
                "uVar5": "total_bits",
                "uVar6": "is_negative",
                "in_r12": "unused_register",
                "bVar7": "is_negative_shift",
                "bVar8": "is_zero_shift",
                "bVar9": "is_overflow_shift"
            },
            "code": "\nulonglong bit_shift_and_concatenate_080003f4(uint input_number)\n\n{\n  uint upper_32_bits;\n  uint absolute_value;\n  uint shift_amount;\n  int leading_zeros;\n  uint total_bits;\n  uint is_negative;\n  uint unused_register;\n  bool is_negative_shift;\n  bool is_zero_shift;\n  bool is_overflow_shift;\n  \n  if (input_number == 0) {\n    return 0;\n  }\n  is_negative = input_number & 0x80000000;\n  absolute_value = input_number;\n  if ((int)is_negative < 0) {\n    absolute_value = -input_number;\n  }\n  upper_32_bits = 0;\n  leading_zeros = count_leading_zeroes(absolute_value);\n  total_bits = leading_zeros + 0x15;\n  is_overflow_shift = SBORROW4(total_bits,0x20);\n  shift_amount = leading_zeros - 0xb;\n  is_negative_shift = (int)shift_amount < 0;\n  is_zero_shift = shift_amount == 0;\n  if ((int)total_bits < 0x20) {\n    is_overflow_shift = SCARRY4(shift_amount,0xc);\n    leading_zeros = leading_zeros + 1;\n    is_negative_shift = leading_zeros < 0;\n    is_zero_shift = leading_zeros == 0;\n    shift_amount = total_bits;\n    if (!is_zero_shift && is_negative_shift == is_overflow_shift) {\n      upper_32_bits = absolute_value << (total_bits & 0xff);\n      absolute_value = absolute_value >> (0xcU - leading_zeros & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_zero_shift || is_negative_shift != is_overflow_shift) {\n    unused_register = 0x20 - shift_amount;\n  }\n  absolute_value = absolute_value << (shift_amount & 0xff);\n  if (is_zero_shift || is_negative_shift != is_overflow_shift) {\n    absolute_value = absolute_value | 0U >> (unused_register & 0xff);\n  }\n  if (is_zero_shift || is_negative_shift != is_overflow_shift) {\n    upper_32_bits = 0 << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if ((int)total_bits < 0x433) {\n    return CONCAT44(absolute_value + (0x432 - total_bits) * 0x100000 | is_negative,upper_32_bits);\n  }\n  shift_amount = ~(0x432 - total_bits);\n  if (0x1e < (int)shift_amount) {\n    return CONCAT44(input_number,absolute_value >> (shift_amount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zeros = shift_amount - 0x13;\n  if (leading_zeros == 0 || leading_zeros < 0 != SCARRY4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(is_negative | absolute_value >> (shift_amount & 0xff),\n                    upper_32_bits >> (shift_amount & 0xff) | absolute_value << (0x20 - shift_amount & 0xff));\n  }\n  return CONCAT44(input_number,upper_32_bits >> (0x20 - (0xcU - leading_zeros) & 0xff) | absolute_value << (0xcU - leading_zeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080003f4",
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "bit_shift_and_concatenate_080003f4"
        },
        "FUN_080079e8": {
            "renaming": {
                "FUN_080079e8": "parse_float_080079e8",
                "param_1": "input",
                "param_2": "param2",
                "param_3": "sign",
                "param_4": "exponent",
                "param_5": "numDigits",
                "param_6": "decimalDigits",
                "param_7": "errorCode",
                "param_8": "isNegative",
                "param_9": "output",
                "cVar1": "digit",
                "bVar2": "carry",
                "uVar3": "value",
                "uVar4": "mask",
                "uVar5": "divisor",
                "uVar6": "mantissa",
                "uVar7": "mantissaLow",
                "uVar8": "temp",
                "uVar11": "divisorLow",
                "uVar12": "divisorHigh",
                "uVar17": "tempHigh",
                "uVar21": "accum",
                "uVar22": "temp2",
                "uVar23": "temp3",
                "iVar9": "i",
                "iVar10": "j",
                "iVar13": "k",
                "iVar19": "length",
                "bVar20": "isNegativeExponent",
                "local_80": "dividend",
                "local_7c": "numDigitsCopy",
                "local_74": "numDigitsRemaining",
                "local_70": "exponentAdjustment",
                "local_68": "decimalDigitsCopy",
                "local_64": "isFinite",
                "local_60": "exponentOverflow",
                "local_5c": "decimalOffset",
                "local_58": "leadingZeros",
                "local_54": "trailingZeros",
                "local_48": "divisorCopy",
                "uStack_44": "divisorLowCopy",
                "local_38": "divisorHighCopy",
                "local_34": "exponentCopy",
                "local_30": "exponentOffset",
                "local_2c": "exponentOffsets"
            },
            "code": "\nchar * parseFloat_080079e8(int input,undefined4 param2,uint sign,uint exponent,uint numDigits,\n                   uint decimalDigits,int *errorCode,uint *isNegative,char **output)\n\n{\n  char digit;\n  byte carry;\n  undefined4 value;\n  uint mask;\n  uint divisor;\n  uint mantissa;\n  undefined4 mantissaLow;\n  undefined4 temp;\n  int i;\n  int j;\n  undefined4 divisorLow;\n  uint divisorHigh;\n  int k;\n  char *pdigit4;\n  char *pdigit5;\n  undefined4 *puVar16;\n  undefined4 tempHigh;\n  char *pdigit8;\n  int length;\n  bool isNegativeExponent;\n  undefined8 accum;\n  undefined8 temp2;\n  undefined8 temp3;\n  uint dividend;\n  uint numDigitsCopy;\n  uint numDigitsRemaining;\n  int exponentAdjustment;\n  uint decimalDigitsCopy;\n  uint isFinite;\n  int exponentOverflow;\n  int decimalOffset;\n  uint leadingZeros;\n  int trailingZeros;\n  uint divisorCopy;\n  uint divisorLowCopy;\n  uint divisorHighCopy;\n  uint exponentCopy;\n  int exponentOffset;\n  int exponentOffsets [2];\n  \n  i = *(int *)(input + 0x40);\n  if (i != 0) {\n    divisorHigh = *(uint *)(input + 0x44);\n    *(uint *)(i + 4) = divisorHigh;\n    *(int *)(i + 8) = 1 << (divisorHigh & 0xff);\n    retrieve_and_set_value_0800910c(input,i);\n    *(undefined4 *)(input + 0x40) = 0;\n  }\n  isNegativeExponent = (int)exponent < 0;\n  divisorHigh = exponent;\n  if (isNegativeExponent) {\n    divisorHigh = exponent & 0x7fffffff;\n  }\n  *isNegative = (uint)isNegativeExponent;\n  numDigitsCopy = exponent;\n  if (isNegativeExponent) {\n    numDigitsCopy = divisorHigh;\n  }\n  mask = numDigitsCopy;\n  if ((DAT_08007bf8 & ~divisorHigh) == 0) {\n    *errorCode = 9999;\n    if ((sign == 0) && ((divisorHigh & 0xfffff) == 0)) {\n      if (output == (char **)0x0) {\n        return PTR_s_Infinity_08007c08;\n      }\n      pdigit5 = PTR_s_Infinity_08007c08 + 8;\n      pdigit8 = PTR_s_Infinity_08007c08;\n    }\n    else {\n      if (output == (char **)0x0) {\n        return PTR_DAT_08007c0c;\n      }\n      pdigit5 = PTR_DAT_08007c0c + 3;\n      pdigit8 = PTR_DAT_08007c0c;\n    }\n    *output = pdigit5;\n    return pdigit8;\n  }\n  accum = check_if_input_is_not_null_08000998(sign,numDigitsCopy,0,0);\n  exponentOverflow = (int)accum;\n  if (exponentOverflow != 0) {\n    *errorCode = 1;\n    if (output != (char **)0x0) {\n      pdigit8 = PTR_DAT_08007bfc + -1;\n      *output = PTR_DAT_08007bfc;\n      return pdigit8;\n    }\n    return PTR_DAT_08007c10;\n  }\n  value = calculate_bits_08009630(input,(int)((ulonglong)accum >> 0x20),sign,numDigitsCopy,exponentOffsets,&exponentOffset)\n  ;\n  i = exponentOffset;\n  if (divisorHigh >> 0x14 == 0) {\n    k = exponentOffsets[0] + exponentOffset;\n    j = k + 0x432;\n    if (j < 0x21) {\n      divisorHigh = sign << (0x20U - j & 0xff);\n    }\n    else {\n      divisorHigh = sign >> (k + 0x412U & 0xff) | divisorHigh << (0x40U - j & 0xff);\n    }\n    accum = reverse_and_concatenate_bits_080003d4(divisorHigh);\n    k = k + -1;\n    exponentOverflow = 1;\n    divisor = (int)((ulonglong)accum >> 0x20) + 0xfe100000;\n    divisorHigh = (uint)accum;\n  }\n  else {\n    k = (divisorHigh >> 0x14) - 0x3ff;\n    divisor = numDigitsCopy & 0xfffff | 0x3ff00000;\n    divisorHigh = sign;\n  }\n  accum = floating_point_addition_08000158(divisorHigh,divisor,0,DAT_08007c00);\n  accum = calculate_double_precision_floating_point_value_080004c8((int)accum,(int)((ulonglong)accum >> 0x20),DAT_08007be0,DAT_08007be4);\n  accum = calculate_double_precision_float_0800015c((int)accum,(int)((ulonglong)accum >> 0x20),DAT_08007be8,DAT_08007bec);\n  temp2 = bit_shift_and_concatenate_080003f4(k);\n  temp2 = calculate_double_precision_floating_point_value_080004c8((int)temp2,(int)((ulonglong)temp2 >> 0x20),DAT_08007bf0,DAT_08007bf4);\n  accum = calculate_double_precision_float_0800015c((int)accum,(int)((ulonglong)accum >> 0x20),(int)temp2,\n                        (int)((ulonglong)temp2 >> 0x20));\n  temp = (undefined4)((ulonglong)accum >> 0x20);\n  numDigitsRemaining = convert_to_fixed_point_0800119c();\n  j = check_null_termination_080009ac((int)accum,temp,0,0);\n  if (j != 0) {\n    temp2 = bit_shift_and_concatenate_080003f4(numDigitsRemaining);\n    j = check_if_input_is_not_null_08000998((int)temp2,(int)((ulonglong)temp2 >> 0x20),(int)accum,temp);\n    if (j == 0) {\n      numDigitsRemaining = numDigitsRemaining - 1;\n    }\n  }\n  if (numDigitsRemaining < 0x17) {\n    trailingZeros = check_if_string_terminated_080009e8(*(undefined4 *)(PTR_DAT_08007c04 + numDigitsRemaining * 8),\n                            *(undefined4 *)((int)(PTR_DAT_08007c04 + numDigitsRemaining * 8) + 4),sign,\n                            numDigitsCopy);\n    if (trailingZeros != 0) {\n      numDigitsRemaining = numDigitsRemaining - 1;\n      trailingZeros = 0;\n    }\n  }\n  else {\n    trailingZeros = 1;\n  }\n  j = (i - k) + -1;\n  if (j < 0) {\n    exponentAdjustment = 1 - (i - k);\n    j = 0;\n  }\n  else {\n    exponentAdjustment = 0;\n  }\n  if ((int)numDigitsRemaining < 0) {\n    leadingZeros = 0;\n    exponentAdjustment = exponentAdjustment - numDigitsRemaining;\n    decimalOffset = -numDigitsRemaining;\n  }\n  else {\n    j = j + numDigitsRemaining;\n    leadingZeros = numDigitsRemaining;\n    decimalOffset = 0;\n  }\n  if (9 < numDigits) {\n    divisorHighCopy = 0xffffffff;\n    isNegativeExponent = true;\n    decimalDigitsCopy = 0xffffffff;\n    isFinite = 1;\n    numDigits = 0;\n    decimalDigits = 0;\n    goto LAB_08007c24;\n  }\n  isNegativeExponent = (int)numDigits < 6;\n  if (!isNegativeExponent) {\n    numDigits = numDigits - 4;\n  }\n  switch(numDigits) {\n  case 2:\n    isFinite = 0;\n    break;\n  case 3:\n    isFinite = 0;\n    goto LAB_08008300;\n  case 4:\n    isFinite = 1;\n    break;\n  case 5:\n    isFinite = 1;\nLAB_08008300:\n    divisorHighCopy = numDigitsRemaining + decimalDigits;\n    decimalDigitsCopy = divisorHighCopy + 1;\n    divisorHigh = decimalDigitsCopy;\n    if ((int)decimalDigitsCopy < 1) {\n      divisorHigh = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(input + 0x44) = 0;\n    pdigit8 = (char *)allocate_or_get_pointer_080090c0(input,0);\n    divisorHighCopy = 0xffffffff;\n    decimalDigitsCopy = 0xffffffff;\n    decimalDigits = 0;\n    *(char **)(input + 0x40) = pdigit8;\n    isFinite = 1;\n    goto LAB_08007e36;\n  }\n  if ((int)decimalDigits < 1) {\n    divisorHighCopy = 1;\n    decimalDigits = 1;\n    decimalDigitsCopy = 1;\nLAB_08007c24:\n    *(undefined4 *)(input + 0x44) = 0;\n    divisor = divisorHighCopy;\n  }\n  else {\n    divisorHighCopy = decimalDigits;\n    decimalDigitsCopy = decimalDigits;\n    divisorHigh = decimalDigits;\nLAB_08008314:\n    *(undefined4 *)(input + 0x44) = 0;\n    divisor = decimalDigitsCopy;\n    if (0x17 < (int)divisorHigh) {\n      k = 4;\n      i = 1;\n      do {\n        length = i;\n        k = k * 2;\n        i = length + 1;\n      } while (k + 0x14U <= divisorHigh);\n      *(int *)(input + 0x44) = length;\n    }\n  }\n  pdigit8 = (char *)allocate_or_get_pointer_080090c0(input);\n  *(char **)(input + 0x40) = pdigit8;\n  if ((divisor < 0xf) && (isNegativeExponent)) {\n    if ((int)numDigitsRemaining < 1) {\n      if (numDigitsRemaining == 0) {\n        i = 2;\n        dividend = sign;\n      }\n      else {\n        accum = calculate_double_precision_floating_point_value_080004c8(sign,numDigitsCopy,\n                              *(undefined4 *)(PTR_DAT_080086cc + (-numDigitsRemaining & 0xf) * 8),\n                              *(undefined4 *)((int)(PTR_DAT_080086cc + (-numDigitsRemaining & 0xf) * 8) + 4));\n        numDigitsCopy = (uint)((ulonglong)accum >> 0x20);\n        dividend = (uint)accum;\n        k = (int)-numDigitsRemaining >> 4;\n        if (k == 0) {\n          i = 2;\n        }\n        else {\n          isNegativeExponent = false;\n          i = 2;\n          puVar16 = (undefined4 *)PTR_DAT_080086d0;\n          do {\n            if (k << 0x1f < 0) {\n              accum = calculate_double_precision_floating_point_value_080004c8((int)accum,(int)((ulonglong)accum >> 0x20),*puVar16,puVar16[1]\n                                   );\n              isNegativeExponent = true;\n              i = i + 1;\n            }\n            k = k >> 1;\n            puVar16 = puVar16 + 2;\n          } while (k != 0);\n          if (isNegativeExponent) {\n            dividend = (uint)accum;\n            numDigitsCopy = (uint)((ulonglong)accum >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      divisorHigh = (int)numDigitsRemaining >> 4;\n      accum = *(undefined8 *)(PTR_DAT_08007ec4 + (numDigitsRemaining & 0xf) * 8);\n      if ((int)(divisorHigh << 0x1b) < 0) {\n        temp2 = FUNC_0800071c(sign,numDigitsCopy,*(undefined4 *)(PTR_DAT_08007ec8 + 0x20),\n                              *(undefined4 *)(PTR_DAT_08007ec8 + 0x24));\n        divisorLowCopy = (uint)((ulonglong)temp2 >> 0x20);\n        divisorCopy = (uint)temp2;\n        i = 3;\n        divisorHigh = divisorHigh & 0xf;\n        puVar16 = (undefined4 *)PTR_DAT_08007ec8;\n      }\n      else {\n        i = 2;\n        divisorLowCopy = numDigitsCopy;\n        puVar16 = (undefined4 *)PTR_DAT_08007ec8;\n        divisorCopy = sign;\n      }\n      while( true ) {\n        temp = (undefined4)((ulonglong)accum >> 0x20);\n        if (divisorHigh == 0) break;\n        if ((int)(divisorHigh << 0x1f) < 0) {\n          accum = calculate_double_precision_floating_point_value_080004c8((int)accum,temp,*puVar16,puVar16[1]);\n          i = i + 1;\n        }\n        divisorHigh = (int)divisorHigh >> 1;\n        puVar16 = puVar16 + 2;\n      }\n      accum = FUNC_0800071c(divisorCopy,divisorLowCopy,(int)accum,temp);\n      dividend = (uint)accum;\n      numDigitsCopy = (uint)((ulonglong)accum >> 0x20);\n    }\n    accum = CONCAT44(numDigitsCopy,dividend);\n    if ((trailingZeros != 0) && (k = check_null_termination_080009ac(dividend,numDigitsCopy,0,DAT_08007ecc), k != 0)) {\n      if (decimalDigitsCopy == 0) {\n        accum = bit_shift_and_concatenate_080003f4(i);\n        accum = calculate_double_precision_floating_point_value_080004c8((int)accum,(int)((ulonglong)accum >> 0x20),dividend,numDigitsCopy);\n        accum = calculate_double_precision_float_0800015c((int)accum,(int)((ulonglong)accum >> 0x20),0,DAT_080086d4);\n        temp = (undefined4)accum;\n        i = (int)((ulonglong)accum >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)divisorHighCopy) {\n        accum = calculate_double_precision_floating_point_value_080004c8(dividend,numDigitsCopy,0,DAT_0800880c);\n        temp2 = bit_shift_and_concatenate_080003f4(i + 1);\n        temp2 = calculate_double_precision_floating_point_value_080004c8((int)temp2,(int)((ulonglong)temp2 >> 0x20),(int)accum,\n                              (int)((ulonglong)accum >> 0x20));\n        temp2 = calculate_double_precision_float_0800015c((int)temp2,(int)((ulonglong)temp2 >> 0x20),0,DAT_08008810);\n        temp = (undefined4)temp2;\n        divisorCopy = divisorHighCopy;\n        exponentCopy = numDigitsRemaining - 1;\n        i = (int)((ulonglong)temp2 >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    temp2 = bit_shift_and_concatenate_080003f4(i);\n    temp2 = calculate_double_precision_floating_point_value_080004c8((int)temp2,(int)((ulonglong)temp2 >> 0x20),dividend,numDigitsCopy);\n    temp2 = calculate_double_precision_float_0800015c((int)temp2,(int)((ulonglong)temp2 >> 0x20),0,DAT_08007ed0);\n    temp = (undefined4)temp2;\n    i = (int)((ulonglong)temp2 >> 0x20) + -0x3400000;\n    if (decimalDigitsCopy != 0) {\n      exponentCopy = numDigitsRemaining;\n      divisorCopy = decimalDigitsCopy;\nLAB_08007cfa:\n      numDigitsCopy = (uint)((ulonglong)accum >> 0x20);\n      dividend = (uint)accum;\n      digit = convert_to_fixed_point_0800119c(dividend,numDigitsCopy);\n      digit = digit + '0';\n      divisorLow = *(undefined4 *)(PTR_DAT_08007ec4 + divisorCopy * 8 + -8);\n      mantissaLow = *(undefined4 *)(PTR_DAT_08007ec4 + divisorCopy * 8 + -4);\n      accum = bit_shift_and_concatenate_080003f4();\n      accum = floating_point_addition_08000158(dividend,numDigitsCopy,(int)accum,(int)((ulonglong)accum >> 0x20));\n      tempHigh = (undefined4)((ulonglong)accum >> 0x20);\n      pdigit5 = pdigit8 + 1;\n      if (isFinite == 0) {\n        temp2 = calculate_double_precision_floating_point_value_080004c8(temp,i,divisorLow,mantissaLow);\n        temp = (undefined4)((ulonglong)temp2 >> 0x20);\n        *pdigit8 = digit;\n        if (divisorCopy != 1) {\n          pdigit4 = pdigit5;\n          do {\n            accum = calculate_double_precision_floating_point_value_080004c8((int)accum,(int)((ulonglong)accum >> 0x20),0,DAT_080086d8);\n            digit = convert_to_fixed_point_0800119c();\n            temp3 = bit_shift_and_concatenate_080003f4();\n            accum = floating_point_addition_08000158((int)accum,(int)((ulonglong)accum >> 0x20),(int)temp3,\n                                  (int)((ulonglong)temp3 >> 0x20));\n            pdigit5 = pdigit4 + 1;\n            *pdigit4 = digit + '0';\n            pdigit4 = pdigit5;\n          } while (pdigit5 != pdigit8 + divisorCopy);\n        }\n        divisorLow = (undefined4)((ulonglong)accum >> 0x20);\n        temp3 = calculate_double_precision_float_0800015c((int)temp2,temp,0,DAT_080086dc);\n        i = check_null_termination_080009ac((int)temp3,(int)((ulonglong)temp3 >> 0x20),(int)accum,divisorLow);\n        if (i == 0) {\n          temp2 = floating_point_addition_08000158(0,DAT_08008814,(int)temp2,temp);\n          i = check_if_string_terminated_080009e8((int)temp2,(int)((ulonglong)temp2 >> 0x20),(int)accum,divisorLow);\n          pdigit4 = pdigit5;\n          if (i == 0) goto LAB_08007e36;\n          do {\n            pdigit5 = pdigit4;\n            pdigit4 = pdigit5 + -1;\n          } while (pdigit5[-1] == '0');\n          goto LAB_08008784;\n        }\n        numDigitsRemaining = exponentCopy;\n        digit = pdigit5[-1];\n      }\n      else {\n        temp2 = FUNC_0800071c(0,DAT_08007ed4,divisorLow,mantissaLow);\n        temp2 = floating_point_addition_08000158((int)temp2,(int)((ulonglong)temp2 >> 0x20),temp,i);\n        temp = (undefined4)((ulonglong)temp2 >> 0x20);\n        *pdigit8 = digit;\n        i = check_if_string_terminated_080009e8((int)temp2,temp,(int)accum,tempHigh);\n        if (i != 0) {\nLAB_08008784:\n          numDigitsRemaining = exponentCopy;\n          goto LAB_08008294;\n        }\n        temp3 = floating_point_addition_08000158(0,DAT_08007ecc,(int)accum,tempHigh);\n        i = check_if_string_terminated_080009e8((int)temp2,temp,(int)temp3,(int)((ulonglong)temp3 >> 0x20));\n        if (i == 0) {\n          if (divisorCopy != 1) {\n            pdigit4 = pdigit5;\n            do {\n              temp2 = calculate_double_precision_floating_point_value_080004c8((int)temp2,(int)((ulonglong)temp2 >> 0x20),0,DAT_08007ed8);\n              temp = (undefined4)((ulonglong)temp2 >> 0x20);\n              accum = calculate_double_precision_floating_point_value_080004c8((int)accum,(int)((ulonglong)accum >> 0x20),0,DAT_08007ed8);\n              digit = convert_to_fixed_point_0800119c();\n              temp3 = bit_shift_and_concatenate_080003f4();\n              accum = floating_point_addition_08000158((int)accum,(int)((ulonglong)accum >> 0x20),(int)temp3,\n                                    (int)((ulonglong)temp3 >> 0x20));\n              divisorLow = (undefined4)((ulonglong)accum >> 0x20);\n              digit = digit + '0';\n              pdigit5 = pdigit4 + 1;\n              *pdigit4 = digit;\n              i = check_null_termination_080009ac((int)accum,divisorLow,(int)temp2,temp);\n              if (i != 0) {\n                numDigitsRemaining = exponentCopy;\n                goto LAB_08008294;\n              }\n              temp3 = floating_point_addition_08000158(0,DAT_08007ecc,(int)accum,divisorLow);\n              i = check_null_termination_080009ac((int)temp3,(int)((ulonglong)temp3 >> 0x20),(int)temp2,temp);\n              if (i != 0) goto LAB_08008798;\n              pdigit4 = pdigit5;\n            } while (pdigit5 != pdigit8 + divisorCopy);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        numDigitsRemaining = exponentCopy;\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    accum = floating_point_addition_08000158(dividend,numDigitsCopy,0,DAT_080086c8);\n    divisorLow = (undefined4)((ulonglong)accum >> 0x20);\n    divisorHigh = check_if_string_terminated_080009e8((int)accum,divisorLow,temp,i);\n    if (divisorHigh == 0) {\n      i = check_null_termination_080009ac((int)accum,divisorLow,temp,i + -0x80000000);\n      divisor = divisorHigh;\n      pdigit5 = pdigit8;\n      if (i == 0) goto LAB_08007e36;\n      goto LAB_080084f0;\n    }\n    decimalDigitsCopy = 0;\n    divisorHigh = 0;\nLAB_08008406:\n    *pdigit8 = '1';\n    numDigitsRemaining = numDigitsRemaining + 1;\n    pdigit5 = pdigit8 + 1;\n    divisor = decimalDigitsCopy;\nLAB_08008416:\n    retrieve_and_set_value_0800910c(input,divisor);\n    if (divisorHigh == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pdigit5 = pdigit8;\n    if ((-1 < exponentOffsets[0]) && ((int)numDigitsRemaining < 0xf)) {\n      temp = *(undefined4 *)(PTR_DAT_08007ec4 + numDigitsRemaining * 8);\n      divisorLow = *(undefined4 *)((int)(PTR_DAT_08007ec4 + numDigitsRemaining * 8) + 4);\n      if ((-1 < (int)decimalDigits) || (0 < (int)decimalDigitsCopy)) {\n        FUNC_0800071c(sign,mask,temp,divisorLow);\n        carry = convert_to_fixed_point_0800119c();\n        accum = bit_shift_and_concatenate_080003f4();\n        accum = calculate_double_precision_floating_point_value_080004c8((int)accum,(int)((ulonglong)accum >> 0x20),temp,divisorLow);\n        accum = floating_point_addition_08000158(sign,mask,(int)accum,(int)((ulonglong)accum >> 0x20));\n        *pdigit8 = carry + 0x30;\n        pdigit5 = pdigit8 + 1;\n        if (decimalDigitsCopy != 1) {\n          accum = calculate_double_precision_floating_point_value_080004c8((int)accum,(int)((ulonglong)accum >> 0x20),0,DAT_08007ed8);\n          i = check_if_input_is_not_null_08000998((int)accum,(int)((ulonglong)accum >> 0x20),0,0);\n          while (i == 0) {\n            tempHigh = (undefined4)((ulonglong)accum >> 0x20);\n            FUNC_0800071c((int)accum,tempHigh,temp,divisorLow);\n            carry = convert_to_fixed_point_0800119c();\n            temp2 = bit_shift_and_concatenate_080003f4();\n            temp2 = calculate_double_precision_floating_point_value_080004c8((int)temp2,(int)((ulonglong)temp2 >> 0x20),temp,divisorLow);\n            accum = floating_point_addition_08000158((int)accum,tempHigh,(int)temp2,(int)((ulonglong)temp2 >> 0x20));\n            pdigit4 = pdigit5 + 1;\n            *pdigit5 = carry + 0x30;\n            pdigit5 = pdigit4;\n            if (decimalDigitsCopy == (int)pdigit4 - (int)pdigit8) goto LAB_08007f3a;\n            accum = calculate_double_precision_floating_point_value_080004c8((int)accum,(int)((ulonglong)accum >> 0x20),0,DAT_080081f8);\n            i = check_if_input_is_not_null_08000998((int)accum,(int)((ulonglong)accum >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        accum = calculate_double_precision_float_0800015c((int)accum,(int)((ulonglong)accum >> 0x20));\n        tempHigh = (undefined4)((ulonglong)accum >> 0x20);\n        i = check_if_string_terminated_080009e8((int)accum,tempHigh,temp,divisorLow);\n        if ((i == 0) &&\n           ((i = check_if_input_is_not_null_08000998((int)accum,tempHigh,temp,divisorLow), i == 0 || ((carry & 1) == 0)\n            ))) goto LAB_08008294;\n        digit = pdigit5[-1];\nLAB_08007f7c:\n        while (pdigit4 = pdigit5 + -1, digit == '9') {\n          if (pdigit8 == pdigit4) {\n            *pdigit8 = '0';\n            digit = pdigit5[-1];\n            numDigitsRemaining = numDigitsRemaining + 1;\n            pdigit4 = pdigit8;\n            break;\n          }\n          digit = pdigit5[-2];\n          pdigit5 = pdigit4;\n        }\n        *pdigit4 = digit + '\\x01';\n        goto LAB_08008294;\n      }\n      if (decimalDigitsCopy == 0) {\n        accum = calculate_double_precision_floating_point_value_080004c8(temp,divisorLow,0,DAT_080086c8);\n        i = check_and_return_080009d4((int)accum,(int)((ulonglong)accum >> 0x20),sign,mask);\n        divisorHigh = decimalDigitsCopy;\n        divisor = decimalDigitsCopy;\n        if (i == 0) goto LAB_08008406;\n      }\n      else {\n        divisorHigh = 0;\n        divisor = 0;\n      }\nLAB_080084f0:\n      numDigitsRemaining = ~decimalDigits;\n      pdigit8 = pdigit5;\n      goto LAB_08008416;\n    }\n    i = decimalOffset;\n    if (isFinite == 0) {\n      exponentOverflow = exponentAdjustment;\n      divisorHigh = isFinite;\n    }\n    else {\n      if ((int)numDigits < 2) {\n        if (exponentOverflow == 0) {\n          exponentOverflow = exponentAdjustment;\n          exponentAdjustment = exponentAdjustment + (0x36 - exponentOffset);\n          j = j + (0x36 - exponentOffset);\n        }\n        else {\n          exponentOverflow = exponentAdjustment;\n          exponentAdjustment = exponentAdjustment + exponentOffsets[0] + 0x433;\n          j = j + exponentOffsets[0] + 0x433;\n        }\n      }\n      else {\n        k = decimalDigitsCopy - 1;\n        if (decimalOffset < k) {\n          leadingZeros = leadingZeros + (k - decimalOffset);\n          i = 0;\n          decimalOffset = k;\n        }\n        else {\n          i = decimalOffset - k;\n        }\n        if ((int)decimalDigitsCopy < 0) {\n          exponentOverflow = exponentAdjustment - decimalDigitsCopy;\n        }\n        else {\n          j = j + decimalDigitsCopy;\n          exponentOverflow = exponentAdjustment;\n          exponentAdjustment = exponentAdjustment + decimalDigitsCopy;\n        }\n      }\n      divisorHigh = allocate_and_initialize_08009244(input,1);\n    }\n    if ((0 < exponentOverflow) && (0 < j)) {\n      k = exponentOverflow;\n      if (j <= exponentOverflow) {\n        k = j;\n      }\n      j = j - k;\n      exponentAdjustment = exponentAdjustment - k;\n      exponentOverflow = exponentOverflow - k;\n    }\n    if (decimalOffset != 0) {\n      if (isFinite == 0) {\n        value = calculate_hash_080093a4(input,value,decimalOffset);\n      }\n      else {\n        temp = value;\n        if (i != 0) {\n          divisorHigh = calculate_hash_080093a4(input,divisorHigh,i);\n          temp = calculate_polynomial_hash_08009258(input,divisorHigh,value);\n          retrieve_and_set_value_0800910c(input,value);\n          value = temp;\n          if (decimalOffset - i == 0) goto LAB_08008062;\n        }\n        value = calculate_hash_080093a4(input,temp,decimalOffset - i);\n      }\n    }\nLAB_08008062:\n    divisor = allocate_and_initialize_08009244(input,1);\n    if (leadingZeros == 0) {\n      if (((int)numDigits < 2) && (sign == 0)) {\nLAB_0800835a:\n        if ((mask & 0xfffff) == 0) {\n          mask = mask & 0x7ff00000;\n          if (mask != 0) {\n            j = j + 1;\n            exponentAdjustment = exponentAdjustment + 1;\n            mask = 1;\n          }\n        }\n        else {\n          mask = 0;\n        }\n        isNegativeExponent = leadingZeros != 0;\n        mantissa = sign;\n        leadingZeros = mask;\n        if (isNegativeExponent) goto LAB_080082d4;\n      }\n      i = 1;\n    }\n    else {\n      accum = calculate_hash_080093a4(input,divisor);\n      divisor = (uint)accum;\n      if (((int)numDigits < 2) && (sign == 0)) goto LAB_0800835a;\n      leadingZeros = 0;\n      mantissa = (uint)((ulonglong)accum >> 0x20);\nLAB_080082d4:\n      i = find_highest_bit_set_080091a4(*(undefined4 *)(divisor + *(int *)(divisor + 0x10) * 4 + 0x10),mantissa);\n      i = 0x20 - i;\n    }\n    mask = i + j & 0x1f;\n    if (mask == 0) {\n      i = 0x1c;\nLAB_08008096:\n      j = j + i;\n      exponentAdjustment = exponentAdjustment + i;\n      exponentOverflow = exponentOverflow + i;\n    }\n    else {\n      if (4 < (int)(0x20 - mask)) {\n        i = 0x1c - mask;\n        goto LAB_08008096;\n      }\n      if (0x20 - mask != 4) {\n        i = 0x3c - mask;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < exponentAdjustment) {\n      value = compress_data_08009444(input,value,exponentAdjustment);\n    }\n    if (0 < j) {\n      divisor = compress_data_08009444(input,divisor,j);\n    }\n    pdigit4 = pdigit8;\n    if ((trailingZeros != 0) && (i = compare_arrays_080094f8(value,divisor), i < 0)) {\n      numDigitsRemaining = numDigitsRemaining - 1;\n      value = multiply_and_accumulate_08009120(input,value,10,0);\n      if (isFinite == 0) {\n        if ((0 < (int)divisorHighCopy) || ((int)numDigits < 3)) {\n          decimalDigitsCopy = divisorHighCopy;\n          goto LAB_0800820a;\n        }\n      }\n      else {\n        divisorHigh = multiply_and_accumulate_08009120(input,divisorHigh,10,0);\n        if ((0 < (int)divisorHighCopy) || ((int)numDigits < 3)) {\n          decimalDigitsCopy = divisorHighCopy;\n          goto LAB_080080de;\n        }\n      }\n      decimalDigitsCopy = divisorHighCopy;\nLAB_080084e8:\n      if (decimalDigitsCopy == 0) {\n        decimalDigitsCopy = multiply_and_accumulate_08009120(input,divisor,5);\n        i = compare_arrays_080094f8(value,decimalDigitsCopy);\n        divisor = decimalDigitsCopy;\n        if (0 < i) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)decimalDigitsCopy < 1) && (2 < (int)numDigits)) goto LAB_080084e8;\n    if (isFinite == 0) {\nLAB_0800820a:\n      while( true ) {\n        length = calculate_division_and_subtraction_080078c0(value,divisor);\n        length = length + 0x30;\n        pdigit5 = pdigit4 + 1;\n        *pdigit4 = (char)length;\n        if ((int)decimalDigitsCopy <= (int)pdigit5 - (int)pdigit8) break;\n        value = multiply_and_accumulate_08009120(input,value,10,0);\n        pdigit4 = pdigit5;\n      }\n      dividend = 0;\n    }\n    else {\nLAB_080080de:\n      dividend = divisorHigh;\n      if (0 < exponentOverflow) {\n        dividend = compress_data_08009444(input,divisorHigh,exponentOverflow);\n      }\n      divisorHigh = dividend;\n      if (leadingZeros != 0) {\n        i = allocate_or_get_pointer_080090c0(input,*(undefined4 *)(dividend + 4));\n        copy_memory_08001084(i + 0xc,dividend + 0xc,(*(int *)(dividend + 0x10) + 2) * 4);\n        divisorHigh = compress_data_08009444(input,i,1);\n      }\nLAB_08008108:\n      i = calculate_division_and_subtraction_080078c0(value,divisor);\n      k = compare_arrays_080094f8(value,dividend);\n      j = compare_and_allocate_08009530(input,divisor,divisorHigh);\n      length = i + 0x30;\n      if (*(int *)(j + 0xc) == 0) {\n        mask = compare_arrays_080094f8(value);\n        retrieve_and_set_value_0800910c(input,j);\n        if (((mask != 0) || (numDigits != 0)) || (mask = numDigits, (sign & 1) != 0))\n        goto LAB_0800815a;\n        if (length != 0x39) {\n          if (0 < k) {\nLAB_0800874c:\n            length = i + 0x31;\n          }\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pdigit5 = pdigit4 + 1;\n        digit = '9';\n        *pdigit4 = '9';\n        goto LAB_08008268;\n      }\n      retrieve_and_set_value_0800910c(input,j);\n      mask = 1;\nLAB_0800815a:\n      if ((k < 0) || (((k == 0 && (numDigits == 0)) && ((sign & 1) == 0)))) {\n        if (0 < (int)mask) {\n          value = compress_data_08009444(input,value,1);\n          k = compare_arrays_080094f8(value,divisor);\n          if ((0 < k) || ((k == 0 && (i << 0x1f < 0)))) {\n            if (length != 0x39) goto LAB_0800874c;\n            goto LAB_08008752;\n          }\n        }\nLAB_080085a4:\n        pdigit5 = pdigit4 + 1;\n        *pdigit4 = (char)length;\n        goto LAB_08008274;\n      }\n      pdigit5 = pdigit4 + 1;\n      if (0 < (int)mask) {\n        if (length == 0x39) goto LAB_08008752;\n        *pdigit4 = (char)i + '1';\n        goto LAB_08008274;\n      }\n      *pdigit4 = (char)length;\n      if (pdigit8 + (decimalDigitsCopy - 1) != pdigit4) {\n        value = multiply_and_accumulate_08009120(input,value,10,0);\n        pdigit4 = pdigit5;\n        if (dividend == divisorHigh) {\n          dividend = multiply_and_accumulate_08009120(input,dividend,10,0);\n          divisorHigh = dividend;\n        }\n        else {\n          dividend = multiply_and_accumulate_08009120(input,dividend,10,0);\n          divisorHigh = multiply_and_accumulate_08009120(input,divisorHigh,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    value = compress_data_08009444(input,value,1);\n    i = compare_arrays_080094f8(value,divisor);\n    digit = pdigit5[-1];\n    if ((0 < i) || ((i == 0 && (length << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pdigit4 = pdigit5 + -1;\n        if (digit != '9') goto code_r0x08008270;\n        if (pdigit8 == pdigit4) {\n          *pdigit8 = '1';\n          numDigitsRemaining = numDigitsRemaining + 1;\n          goto LAB_08008274;\n        }\n        digit = pdigit5[-2];\n        pdigit5 = pdigit4;\n      } while( true );\n    }\n    while (digit == '0') {\n      digit = pdigit5[-2];\n      pdigit5 = pdigit5 + -1;\n    }\nLAB_08008274:\n    retrieve_and_set_value_0800910c(input,divisor);\n    if (divisorHigh == 0) goto LAB_08008294;\n    if ((dividend != 0) && (dividend != divisorHigh)) {\n      retrieve_and_set_value_0800910c(input);\n    }\n  }\n  retrieve_and_set_value_0800910c(input,divisorHigh);\nLAB_08008294:\n  retrieve_and_set_value_0800910c(input,value);\n  *pdigit5 = '\\0';\n  *errorCode = numDigitsRemaining + 1;\n  if (output == (char **)0x0) {\n    return pdigit8;\n  }\n  *output = pdigit5;\n  return pdigit8;\ncode_r0x08008270:\n  *pdigit4 = digit + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "called": [
                "FUN_080004c8",
                "FUN_080003f4",
                "FUN_08009630",
                "FUN_08001084",
                "FUN_0800015c",
                "FUN_080009e8",
                "FUN_0800910c",
                "FUN_080093a4",
                "FUN_08000998",
                "FUN_08009444",
                "FUN_08009120",
                "FUN_0800119c",
                "FUN_080091a4",
                "FUN_08009530",
                "FUN_080078c0",
                "FUN_08009258",
                "FUN_080003d4",
                "FUN_08009244",
                "FUN_08000158",
                "FUN_080009d4",
                "FUN_0800071c",
                "FUN_080094f8",
                "FUN_080090c0",
                "FUN_080009ac"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080079e8",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "parse_float_080079e8"
        },
        "FUN_0800166c": {
            "renaming": {
                "FUN_0800166c": "bitwise_shift_and_merge_0800166c",
                "param_1": "bit_offset",
                "param_2": "bits_to_merge",
                "param_3": "bit_mask",
                "uVar1": "bits_to_shift"
            },
            "code": "\nuint bitwise_shift_and_merge_0800166c(uint bit_offset,uint bits_to_merge,uint bit_mask)\n\n{\n  uint bits_to_shift;\n  \n  bit_offset = bit_offset & 7;\n  bits_to_shift = 7 - bit_offset;\n  if (3 < bits_to_shift) {\n    bits_to_shift = 4;\n  }\n  if (bit_offset + 4 < 7) {\n    bit_offset = 0;\n  }\n  else {\n    bit_offset = bit_offset - 3;\n  }\n  return bit_mask & ~(-1 << (bit_offset & 0xff)) |\n         (~(-1 << (bits_to_shift & 0xff)) & bits_to_merge) << (bit_offset & 0xff);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800166c",
            "calling": [
                "FUN_0800172a"
            ],
            "imported": false,
            "current_name": "bitwise_shift_and_merge_0800166c"
        },
        "FUN_0800360c": {
            "renaming": {
                "FUN_0800360c": "set_bit_and_flag_0800360c",
                "param_1": "ptr_to_uint_ptr"
            },
            "code": "\nundefined4 set_bit_and_flag_0800360c(uint **ptr_to_uint_ptr)\n\n{\n  (*ptr_to_uint_ptr)[3] = (*ptr_to_uint_ptr)[3] | 1;\n  **ptr_to_uint_ptr = **ptr_to_uint_ptr | 1;\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800360c",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "set_bit_and_flag_0800360c"
        },
        "FUN_08005d68": {
            "renaming": {
                "FUN_08005d68": "memset_aligned_08005d68",
                "param_1": "dest",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "dest_aligned",
                "puVar2": "dest_next_aligned",
                "uVar3": "size_remaining",
                "uVar4": "value_4byte",
                "bVar5": "size_is_zero"
            },
            "code": "\nvoid memset_aligned_08005d68(undefined4 *dest,undefined value,uint size)\n\n{\n  undefined4 *dest_aligned;\n  undefined4 *dest_next_aligned;\n  uint size_remaining;\n  undefined4 value_4byte;\n  bool size_is_zero;\n  \n  if (((uint)dest & 3) != 0) {\n    size_remaining = size - 1;\n    dest_aligned = dest;\n    if (size == 0) {\n      return;\n    }\n    while( true ) {\n      dest = (undefined4 *)((int)dest_aligned + 1);\n      *(undefined *)dest_aligned = value;\n      size = size_remaining;\n      if (((uint)dest & 3) == 0) break;\n      size_is_zero = size_remaining == 0;\n      size_remaining = size_remaining - 1;\n      dest_aligned = dest;\n      if (size_is_zero) {\n        return;\n      }\n    }\n  }\n  if (3 < size) {\n    value_4byte = CONCAT22(CONCAT11(value,value),CONCAT11(value,value));\n    size_remaining = size;\n    dest_aligned = dest;\n    if (0xf < size) {\n      size_remaining = size - 0x10;\n      dest_aligned = dest + 4;\n      do {\n        dest_aligned[-4] = value_4byte;\n        dest_aligned[-3] = value_4byte;\n        dest_aligned[-2] = value_4byte;\n        dest_aligned[-1] = value_4byte;\n        dest_aligned = dest_aligned + 4;\n      } while (dest_aligned != (undefined4 *)((int)dest + (size_remaining & 0xfffffff0) + 0x20));\n      size = size & 0xf;\n      dest = dest + ((size_remaining >> 4) + 1) * 4;\n      size_remaining = size;\n      dest_aligned = dest;\n      if (size < 4) goto LAB_08005de4;\n    }\n    do {\n      size = size - 4;\n      *dest = value_4byte;\n      dest = dest + 1;\n    } while (3 < size);\n    dest = (undefined4 *)((int)dest_aligned + (size_remaining - 4 & 0xfffffffc) + 4);\n    size = size_remaining & 3;\n  }\nLAB_08005de4:\n  if (size != 0) {\n    dest_aligned = dest;\n    do {\n      dest_next_aligned = (undefined4 *)((int)dest_aligned + 1);\n      *(undefined *)dest_aligned = value;\n      dest_aligned = dest_next_aligned;\n    } while ((undefined4 *)(size + (int)dest) != dest_next_aligned);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d68",
            "calling": [
                "FUN_08009980",
                "FUN_08004f60"
            ],
            "imported": false,
            "current_name": "memset_aligned_08005d68"
        },
        "FUN_080017c4": {
            "renaming": {
                "FUN_080017c4": "parse_bits_080017c4",
                "param_1": "output_array",
                "param_2": "input_array",
                "uVar1": "var1",
                "uVar2": "var2",
                "uVar3": "mask",
                "uVar4": "bit",
                "uVar5": "type",
                "puVar6": "output_ptr",
                "iVar7": "index",
                "local_10": "offset",
                "local_c": "bit_index"
            },
            "code": "\nvoid parse_bits_080017c4(uint *output_array,uint *input_array)\n\n{\n  uint var1;\n  uint var2;\n  uint mask;\n  uint bit;\n  uint type;\n  uint *output_ptr;\n  int index;\n  uint offset;\n  uint bit_index;\n  \n  offset = 0;\n  bit_index = 0;\n  do {\n    if (0xf < bit_index) {\n      return;\n    }\n    mask = 1 << (bit_index & 0xff);\n    bit = *input_array & mask;\n    if (bit == mask) {\n      type = input_array[1];\n      if (type == 0x12) {\n        offset = input_array[3] + 0xc;\n      }\n      else if (type < 0x13) {\n        if (type == 2) {\n          offset = input_array[3] + 8;\n        }\n        else if (type < 3) {\n          if (type == 0) goto LAB_08001882;\n          if (type == 1) {\n            offset = input_array[3];\n          }\n        }\n        else if (type == 3) {\n          offset = 0;\n        }\n        else if (type == 0x11) {\n          offset = input_array[3] + 4;\n        }\n      }\n      else if (((type == DAT_08001a4c) ||\n               (((var1 = DAT_08001a54, var2 = DAT_08001a50, DAT_08001a4c < type &&\n                 (var1 = DAT_08001a60, var2 = DAT_08001a5c, type == DAT_08001a58)) ||\n                (type == var2)))) || (type == var1)) {\nLAB_08001882:\n        if (input_array[2] == 0) {\n          offset = 4;\n        }\n        else if (input_array[2] == 1) {\n          offset = 8;\n          output_array[4] = mask;\n        }\n        else {\n          offset = 8;\n          output_array[5] = mask;\n        }\n      }\n      if (bit < 0x100) {\n        mask = bit_index << 2;\n        output_ptr = output_array;\n      }\n      else {\n        output_ptr = output_array + 1;\n        mask = (bit_index - 8) * 4;\n      }\n      *output_ptr = *output_ptr & ~(0xf << (mask & 0xff)) | offset << (mask & 0xff);\n      if ((input_array[1] & 0x10000000) != 0) {\n        *(uint *)(DAT_08001a64 + 0x18) = *(uint *)(DAT_08001a64 + 0x18) | 1;\n        if (output_array == DAT_08001a6c) {\n          index = 0;\n        }\n        else if (output_array == DAT_08001a70) {\n          index = 1;\n        }\n        else if (output_array == DAT_08001a74) {\n          index = 2;\n        }\n        else if (output_array == DAT_08001a78) {\n          index = 3;\n        }\n        else {\n          index = 4;\n        }\n        *(uint *)(DAT_08001a68 + ((bit_index >> 2) + 2) * 4) =\n             index << ((bit_index & 3) << 2) |\n             ~(0xf << ((bit_index & 3) << 2)) & *(uint *)(DAT_08001a68 + ((bit_index >> 2) + 2) * 4);\n        if ((input_array[1] & 0x10000) == 0) {\n          *DAT_08001a7c = ~bit & *DAT_08001a7c;\n        }\n        else {\n          *DAT_08001a7c = bit | *DAT_08001a7c;\n        }\n        if ((input_array[1] & 0x20000) == 0) {\n          DAT_08001a7c[1] = ~bit & DAT_08001a7c[1];\n        }\n        else {\n          DAT_08001a7c[1] = bit | DAT_08001a7c[1];\n        }\n        if ((input_array[1] & 0x100000) == 0) {\n          DAT_08001a7c[2] = ~bit & DAT_08001a7c[2];\n        }\n        else {\n          DAT_08001a7c[2] = bit | DAT_08001a7c[2];\n        }\n        if ((input_array[1] & 0x200000) == 0) {\n          DAT_08001a7c[3] = ~bit & DAT_08001a7c[3];\n        }\n        else {\n          DAT_08001a7c[3] = bit | DAT_08001a7c[3];\n        }\n      }\n    }\n    bit_index = bit_index + 1;\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080017c4",
            "calling": [
                "FUN_08005680",
                "FUN_080055f4"
            ],
            "imported": false,
            "current_name": "parse_bits_080017c4"
        },
        "FUN_080035a4": {
            "renaming": {
                "FUN_080035a4": "check_params_and_update_080035a4",
                "param_1": "params",
                "uVar1": "result",
                "do_nothing_080035fa": "perform_nothing",
                "update_params_08003c94": "update_params"
            },
            "code": "\nundefined4 check_params_and_update_080035a4(undefined4 *params)\n\n{\n  undefined4 result;\n  \n  if (params == (undefined4 *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)params + 0x3d) == '\\0') {\n      *(undefined *)(params + 0xf) = 0;\n      do_nothing_080035fa(params);\n    }\n    *(undefined *)((int)params + 0x3d) = 2;\n    update_params_08003c94(*params,params + 1);\n    *(undefined *)((int)params + 0x3d) = 1;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_080035fa",
                "FUN_08003c94"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035a4",
            "calling": [
                "FUN_08005500",
                "FUN_080053b0"
            ],
            "imported": false,
            "current_name": "check_params_and_update_080035a4"
        },
        "FUN_080041ea": {
            "renaming": {
                "FUN_080041ea": "update_bitwise_value_080041ea",
                "param_1": "ptr",
                "param_2": "bit_position",
                "param_3": "new_value"
            },
            "code": "\nvoid update_bitwise_value_080041ea(int ptr,uint bit_position,int new_value)\n\n{\n  *(uint *)(ptr + 0x20) = *(uint *)(ptr + 0x20) & ~(1 << (bit_position & 0xff));\n  *(uint *)(ptr + 0x20) = *(uint *)(ptr + 0x20) | new_value << (bit_position & 0xff);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041ea",
            "calling": [
                "FUN_080036a8"
            ],
            "imported": false,
            "current_name": "update_bitwise_value_080041ea"
        },
        "FUN_08004ae0": {
            "renaming": {
                "FUN_08004ae0": "calculate_hashes_08004ae0",
                "param_1": "hash_array",
                "local_2c": "hash_input",
                "local_2b": "unused",
                "local_2a": "byte_5",
                "local_29": "byte_4",
                "local_28": "byte_3",
                "local_27": "byte_2",
                "local_26": "byte_1",
                "local_25": "byte_0",
                "local_24": "short_3",
                "local_23": "short_2",
                "local_22": "short_1",
                "local_21": "short_0",
                "local_20": "unused",
                "local_1f": "unused",
                "local_1e": "hash_6",
                "local_1c": "hash_4",
                "local_1a": "hash_3",
                "local_18": "hash_2",
                "local_16": "hash_1",
                "local_14": "hash_0"
            },
            "code": "\nvoid calculate_hashes_08004ae0(undefined4 *hash_array)\n\n{\n  undefined4 uVar1;\n  undefined hash_input;\n  undefined unused;\n  undefined byte_5;\n  undefined byte_4;\n  undefined byte_3;\n  undefined byte_2;\n  undefined byte_1;\n  undefined byte_0;\n  undefined short_3;\n  undefined short_2;\n  undefined short_1;\n  undefined short_0;\n  undefined unused;\n  undefined unused;\n  short hash_6;\n  short hash_4;\n  short hash_3;\n  short hash_2;\n  short hash_1;\n  short hash_0;\n  \n  (**(code **)PTR_DAT_08004bd4)(0xd0,0x3b,&hash_input,0xe);\n  hash_0 = CONCAT11(byte_5,byte_4);\n  hash_1 = CONCAT11(byte_3,byte_2);\n  hash_2 = CONCAT11(byte_1,byte_0);\n  hash_3 = CONCAT11(short_3,short_2);\n  hash_4 = CONCAT11(short_1,short_0);\n  hash_6 = CONCAT11(unused,unused);\n  uVar1 = calculate_hash_08000c10((int)CONCAT11(hash_input,unused));\n  *hash_array = uVar1;\n  uVar1 = calculate_hash_08000c10((int)hash_0);\n  hash_array[1] = uVar1;\n  uVar1 = calculate_hash_08000c10((int)hash_1);\n  hash_array[2] = uVar1;\n  uVar1 = calculate_hash_08000c10((int)hash_2);\n  hash_array[3] = uVar1;\n  uVar1 = calculate_hash_08000c10((int)hash_3);\n  hash_array[4] = uVar1;\n  uVar1 = calculate_hash_08000c10((int)hash_4);\n  hash_array[5] = uVar1;\n  uVar1 = calculate_hash_08000c10((int)hash_6);\n  hash_array[6] = uVar1;\n  return;\n}\n\n",
            "called": [
                "FUN_08000c10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ae0",
            "calling": [
                "FUN_080049cc",
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "calculate_hashes_08004ae0"
        },
        "FUN_08001044": {
            "renaming": {
                "FUN_08001044": "decode_unsigned_integer_08001044",
                "param_1": "unsigned_int",
                "uVar1": "result"
            },
            "code": "\nuint decode_unsigned_integer_08001044(uint unsigned_int)\n\n{\n  uint result;\n  \n  if (((unsigned_int & 0x80000000) != 0) || (unsigned_int << 1 < 0x7f000000)) {\n    return 0;\n  }\n  result = 0x9e - ((unsigned_int << 1) >> 0x18);\n  if (-1 < (int)result) {\n    return (unsigned_int << 8 | 0x80000000) >> (result & 0xff);\n  }\n  if ((result == 0xffffff9f) && ((unsigned_int & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001044",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "decode_unsigned_integer_08001044"
        },
        "FUN_08009444": {
            "renaming": {
                "FUN_08009444": "compress_data_08009444",
                "param_1": "data_buffer",
                "param_2": "metadata",
                "param_3": "data_size",
                "iVar1": "temp_var_1",
                "iVar2": "temp_var_2",
                "iVar3": "temp_var_3",
                "uVar4": "temp_var_4",
                "iVar5": "metadata_offset",
                "iVar6": "temp_var_5",
                "puVar7": "compressed_data",
                "puVar8": "uncompressed_data",
                "puVar9": "temp_var_6",
                "puVar10": "temp_var_7",
                "puVar11": "temp_var_8",
                "iVar12": "num_blocks",
                "iVar13": "compressed_data_size",
                "uVar14": "temp_var_9"
            },
            "code": "\nvoid compress_data_08009444(int data_buffer,undefined4 *metadata,uint data_size)\n\n{\n  int temp_var_1;\n  int temp_var_2;\n  int temp_var_3;\n  undefined4 temp_var_4;\n  int metadata_offset;\n  int temp_var_5;\n  uint *compressed_data;\n  uint *uncompressed_data;\n  uint *temp_var_7;\n  uint *temp_var_8;\n  int num_blocks;\n  int compressed_data_size;\n  uint temp_var_9;\n  uint *temp_var_6;\n  \n  metadata_offset = metadata[4];\n  num_blocks = (int)data_size >> 5;\n  compressed_data_size = num_blocks + metadata_offset + 1;\n  temp_var_3 = metadata[1];\n  temp_var_2 = metadata[2];\n  if ((int)metadata[2] < compressed_data_size) {\n    do {\n      temp_var_5 = temp_var_2 * 2;\n      temp_var_1 = temp_var_2 * -2;\n      temp_var_3 = temp_var_3 + 1;\n      temp_var_2 = temp_var_5;\n    } while (compressed_data_size != temp_var_5 && compressed_data_size + temp_var_1 < 0 == SBORROW4(compressed_data_size,temp_var_5));\n  }\n  temp_var_2 = allocate_or_get_pointer_080090c0(data_buffer,temp_var_3);\n  compressed_data = (uint *)(temp_var_2 + 0x14);\n  if (0 < num_blocks) {\n    temp_var_8 = compressed_data + num_blocks;\n    uncompressed_data = compressed_data;\n    do {\n      temp_var_6 = uncompressed_data + 1;\n      *uncompressed_data = 0;\n      compressed_data = temp_var_8;\n      uncompressed_data = temp_var_6;\n    } while (temp_var_6 != temp_var_8);\n  }\n  temp_var_3 = metadata[4];\n  uncompressed_data = metadata + 5;\n  data_size = data_size & 0x1f;\n  if (data_size == 0) {\n    compressed_data = compressed_data + -1;\n    temp_var_8 = uncompressed_data;\n    do {\n      temp_var_6 = temp_var_8 + 1;\n      compressed_data = compressed_data + 1;\n      *compressed_data = *temp_var_8;\n      temp_var_8 = temp_var_6;\n    } while (temp_var_6 < uncompressed_data + temp_var_3);\n  }\n  else {\n    temp_var_9 = 0;\n    temp_var_8 = uncompressed_data;\n    do {\n      temp_var_6 = compressed_data;\n      *temp_var_6 = *temp_var_8 << data_size | temp_var_9;\n      temp_var_7 = temp_var_8 + 1;\n      temp_var_9 = *temp_var_8 >> (0x20 - data_size & 0xff);\n      compressed_data = temp_var_6 + 1;\n      temp_var_8 = temp_var_7;\n    } while (temp_var_7 < uncompressed_data + temp_var_3);\n    temp_var_6[1] = temp_var_9;\n    if (temp_var_9 != 0) {\n      compressed_data_size = num_blocks + metadata_offset + 2;\n    }\n  }\n  metadata_offset = *(int *)(data_buffer + 0x4c);\n  temp_var_3 = metadata[1];\n  temp_var_4 = *(undefined4 *)(metadata_offset + temp_var_3 * 4);\n  *(int *)(temp_var_2 + 0x10) = compressed_data_size + -1;\n  *metadata = temp_var_4;\n  *(undefined4 **)(metadata_offset + temp_var_3 * 4) = metadata;\n  return;\n}\n\n",
            "called": [
                "FUN_080090c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009444",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "compress_data_08009444"
        },
        "FUN_080015fc": {
            "renaming": {
                "FUN_080015fc": "get_data_bits_080015fc"
            },
            "code": "\nuint get_data_bits_080015fc(void)\n\n{\n  return *(uint *)(DAT_08001614 + 0xc) >> 8 & 7;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015fc",
            "calling": [
                "FUN_0800172a"
            ],
            "imported": false,
            "current_name": "get_data_bits_080015fc"
        },
        "FUN_08004436": {
            "renaming": {
                "FUN_08004436": "validate_input_08004436",
                "param_1": "input_data",
                "param_2": "input_string",
                "param_3": "input_string_len",
                "param_4": "timeout",
                "iVar1": "start_time",
                "iVar2": "elapsed_time",
                "uVar3": "result",
                "local_58": "current_char"
            },
            "code": "\nundefined4 validate_input_08004436(uint **input_data,ushort *input_string,short input_string_len,uint timeout)\n\n{\n  int start_time;\n  int elapsed_time;\n  undefined4 result;\n  ushort *current_char;\n  \n  if (*(char *)((int)input_data + 0x39) == ' ') {\n    if ((input_string == (ushort *)0x0) || (input_string_len == 0)) {\n      result = 1;\n    }\n    else if (*(char *)(input_data + 0xe) == '\\x01') {\n      result = 2;\n    }\n    else {\n      *(undefined *)(input_data + 0xe) = 1;\n      input_data[0xf] = (uint *)0x0;\n      *(undefined *)((int)input_data + 0x39) = 0x21;\n      start_time = get_pointer_value_080015a0();\n      *(short *)(input_data + 9) = input_string_len;\n      *(short *)((int)input_data + 0x26) = input_string_len;\n      current_char = input_string;\n      while (*(short *)((int)input_data + 0x26) != 0) {\n        *(short *)((int)input_data + 0x26) = *(short *)((int)input_data + 0x26) + -1;\n        if (input_data[2] == (uint *)0x1000) {\n          do {\n            if ((**input_data & 0x80) == 0x80) {\n              elapsed_time = 0;\n              goto LAB_0800454c;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (elapsed_time = get_pointer_value_080015a0(), (uint)(elapsed_time - start_time) <= timeout))));\n          (*input_data)[3] = (*input_data)[3] & 0xfffffe5f;\n          (*input_data)[5] = (*input_data)[5] & 0xfffffffe;\n          *(undefined *)((int)input_data + 0x39) = 0x20;\n          *(undefined *)((int)input_data + 0x3a) = 0x20;\n          *(undefined *)(input_data + 0xe) = 0;\n          elapsed_time = 3;\nLAB_0800454c:\n          if (elapsed_time != 0) {\n            return 3;\n          }\n          (*input_data)[1] = *current_char & 0x1ff;\n          if (input_data[4] == (uint *)0x0) {\n            current_char = current_char + 1;\n          }\n          else {\n            current_char = (ushort *)((int)current_char + 1);\n          }\n        }\n        else {\n          do {\n            if ((**input_data & 0x80) == 0x80) {\n              elapsed_time = 0;\n              goto LAB_08004614;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (elapsed_time = get_pointer_value_080015a0(), (uint)(elapsed_time - start_time) <= timeout))));\n          (*input_data)[3] = (*input_data)[3] & 0xfffffe5f;\n          (*input_data)[5] = (*input_data)[5] & 0xfffffffe;\n          *(undefined *)((int)input_data + 0x39) = 0x20;\n          *(undefined *)((int)input_data + 0x3a) = 0x20;\n          *(undefined *)(input_data + 0xe) = 0;\n          elapsed_time = 3;\nLAB_08004614:\n          if (elapsed_time != 0) {\n            return 3;\n          }\n          (*input_data)[1] = (uint)*(byte *)current_char;\n          current_char = (ushort *)((int)current_char + 1);\n        }\n      }\n      do {\n        if ((**input_data & 0x40) == 0x40) {\n          start_time = 0;\n          goto LAB_080046c6;\n        }\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (elapsed_time = get_pointer_value_080015a0(), (uint)(elapsed_time - start_time) <= timeout))));\n      (*input_data)[3] = (*input_data)[3] & 0xfffffe5f;\n      (*input_data)[5] = (*input_data)[5] & 0xfffffffe;\n      *(undefined *)((int)input_data + 0x39) = 0x20;\n      *(undefined *)((int)input_data + 0x3a) = 0x20;\n      *(undefined *)(input_data + 0xe) = 0;\n      start_time = 3;\nLAB_080046c6:\n      if (start_time == 0) {\n        *(undefined *)((int)input_data + 0x39) = 0x20;\n        *(undefined *)(input_data + 0xe) = 0;\n        result = 0;\n      }\n      else {\n        result = 3;\n      }\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_080015a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004436",
            "calling": [
                "FUN_08004f3c"
            ],
            "imported": false,
            "current_name": "validate_input_08004436"
        },
        "FUN_08000110": {
            "renaming": {
                "FUN_08000110": "check_and_set_flag_08000110",
                "param_1": "input_str"
            },
            "code": "\nundefined * check_and_set_flag_08000110(undefined *input_str)\n\n{\n  if (*PTR_DAT_08000128 == '\\0') {\n    if (DAT_0800012c != 0) {\n      input_str = PTR_FUN_08000130;\n    }\n    *PTR_DAT_08000128 = 1;\n  }\n  return input_str;\n}\n\n",
            "called": [
                "FUN_08009e68"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000110",
            "calling": [],
            "imported": false,
            "current_name": "check_and_set_flag_08000110"
        },
        "FUN_08003504": {
            "renaming": {
                "FUN_08003504": "get_pointer_value_08003504"
            },
            "code": "\nundefined4 get_pointer_value_08003504(void)\n\n{\n  return *(undefined4 *)PTR_DAT_08003514;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003504",
            "calling": [
                "FUN_080052a0",
                "FUN_08003540",
                "FUN_08003518"
            ],
            "imported": false,
            "current_name": "get_pointer_value_08003504"
        },
        "FUN_08000aa4": {
            "renaming": {
                "FUN_08000aa4": "floating_point_conversion_08000aa4",
                "param_1": "input_float",
                "param_2": "input_float_bits",
                "param_3": "rounding_mode",
                "param_4": "exception_flags",
                "iVar1": "exponent_difference",
                "uVar2": "input_float_bits_without_sign",
                "uVar3": "mantissa_bits_output",
                "uVar4": "input_float_bits_shifted_left_by_1",
                "uVar5": "shift_amount",
                "uVar6": "exponent_difference_absolute",
                "iVar7": "input_float_exponent",
                "bVar8": "condition"
            },
            "code": "\nuint floating_point_conversion_08000aa4(uint input_float,uint input_float_bits,undefined4 rounding_mode,uint exception_flags)\n\n{\n  int exponent_difference;\n  uint input_float_bits_without_sign;\n  uint mantissa_bits_output;\n  uint input_float_bits_shifted_left_by_1;\n  uint shift_amount;\n  uint exponent_difference_absolute;\n  int input_float_exponent;\n  bool condition;\n  \n  input_float_bits_without_sign = input_float_bits ^ 0x80000000;\n  input_float_bits_shifted_left_by_1 = input_float << 1;\n  condition = input_float_bits_shifted_left_by_1 == 0;\n  if (!condition) {\n    exception_flags = input_float_bits << 1;\n    condition = exception_flags == 0;\n  }\n  if (!condition) {\n    condition = input_float_bits_shifted_left_by_1 == exception_flags;\n  }\n  input_float_exponent = (int)input_float_bits_shifted_left_by_1 >> 0x18;\n  if (!condition) {\n    condition = input_float_exponent == -1;\n  }\n  if (!condition) {\n    condition = (int)exception_flags >> 0x18 == -1;\n  }\n  if (condition) {\n    exponent_difference = (int)(input_float_bits << 1) >> 0x18;\n    if (input_float_exponent == -1 || exponent_difference == -1) {\n      input_float_bits_shifted_left_by_1 = input_float_bits_without_sign;\n      if (input_float_exponent == -1) {\n        input_float_bits_shifted_left_by_1 = input_float;\n      }\n      if (input_float_exponent != -1 || exponent_difference != -1) {\n        input_float_bits_without_sign = input_float_bits_shifted_left_by_1;\n      }\n      condition = (input_float_bits_shifted_left_by_1 & 0x7fffff) == 0;\n      if (condition) {\n        condition = (input_float_bits_without_sign & 0x7fffff) == 0;\n      }\n      if (condition) {\n        condition = input_float_bits_shifted_left_by_1 == input_float_bits_without_sign;\n      }\n      if (!condition) {\n        input_float_bits_shifted_left_by_1 = input_float_bits_shifted_left_by_1 | 0x400000;\n      }\n      return input_float_bits_shifted_left_by_1;\n    }\n    if (((input_float ^ input_float_bits_without_sign) & 0x7fffffff) != 0) {\n      if (input_float_bits_shifted_left_by_1 == 0) {\n        input_float = input_float_bits_without_sign;\n      }\n      return input_float;\n    }\n    if (input_float != input_float_bits_without_sign) {\n      return 0;\n    }\n    if ((input_float_bits_shifted_left_by_1 & 0xff000000) == 0) {\n      input_float_bits_without_sign = input_float << 1;\n      if ((input_float & 0x80000000) != 0) {\n        input_float_bits_without_sign = input_float_bits_without_sign | 0x80000000;\n      }\n      return input_float_bits_without_sign;\n    }\n    if (input_float_bits_shifted_left_by_1 < 0xfe000000) {\n      return input_float + 0x800000;\n    }\n    input_float = input_float & 0x80000000;\nLAB_08000bde:\n    return input_float | 0x7f800000;\n  }\n  input_float_bits_shifted_left_by_1 = input_float_bits_shifted_left_by_1 >> 0x18;\n  exception_flags = exception_flags >> 0x18;\n  exponent_difference_absolute = exception_flags - input_float_bits_shifted_left_by_1;\n  condition = exponent_difference_absolute != 0;\n  shift_amount = input_float_bits_shifted_left_by_1;\n  if (condition && input_float_bits_shifted_left_by_1 <= exception_flags) {\n    shift_amount = input_float_bits_shifted_left_by_1 + exponent_difference_absolute;\n  }\n  if (condition && input_float_bits_shifted_left_by_1 <= exception_flags) {\n    input_float_bits_without_sign = input_float_bits_without_sign ^ input_float;\n  }\n  if (condition && input_float_bits_shifted_left_by_1 <= exception_flags) {\n    input_float = input_float ^ input_float_bits_without_sign;\n  }\n  if (condition && input_float_bits_shifted_left_by_1 <= exception_flags) {\n    input_float_bits_without_sign = input_float_bits_without_sign ^ input_float;\n  }\n  if (exception_flags < input_float_bits_shifted_left_by_1) {\n    exponent_difference_absolute = -exponent_difference_absolute;\n  }\n  if (0x19 < exponent_difference_absolute) {\n    return input_float;\n  }\n  input_float_bits_shifted_left_by_1 = input_float & 0xffffff | 0x800000;\n  if ((input_float & 0x80000000) != 0) {\n    input_float_bits_shifted_left_by_1 = -input_float_bits_shifted_left_by_1;\n  }\n  mantissa_bits_output = input_float_bits_without_sign & 0xffffff | 0x800000;\n  if ((input_float_bits_without_sign & 0x80000000) != 0) {\n    mantissa_bits_output = -mantissa_bits_output;\n  }\n  if (shift_amount == exponent_difference_absolute) {\n    mantissa_bits_output = mantissa_bits_output ^ 0x800000;\n    if (shift_amount == 0) {\n      input_float_bits_shifted_left_by_1 = input_float_bits_shifted_left_by_1 ^ 0x800000;\n      shift_amount = 1;\n    }\n    else {\n      exponent_difference_absolute = exponent_difference_absolute - 1;\n    }\n  }\n  input_float_bits_shifted_left_by_1 = input_float_bits_shifted_left_by_1 + ((int)mantissa_bits_output >> (exponent_difference_absolute & 0xff));\n  mantissa_bits_output = mantissa_bits_output << (0x20 - exponent_difference_absolute & 0xff);\n  input_float = input_float_bits_shifted_left_by_1 & 0x80000000;\n  if ((int)input_float_bits_shifted_left_by_1 < 0) {\n    condition = mantissa_bits_output != 0;\n    mantissa_bits_output = -mantissa_bits_output;\n    input_float_bits_shifted_left_by_1 = -input_float_bits_shifted_left_by_1 - (uint)condition;\n  }\n  if (input_float_bits_shifted_left_by_1 < 0x800000) {\n    input_float_bits_without_sign = mantissa_bits_output & 0x80000000;\n    mantissa_bits_output = mantissa_bits_output << 1;\n    input_float_bits_shifted_left_by_1 = input_float_bits_shifted_left_by_1 * 2 + (uint)(input_float_bits_without_sign != 0);\n    input_float_bits_without_sign = shift_amount - 2;\n    if ((input_float_bits_shifted_left_by_1 & 0x800000) == 0) {\n      input_float_exponent = count_leading_zeroes(input_float_bits_shifted_left_by_1);\n      exponent_difference_absolute = input_float_exponent - 8;\n      input_float_bits_shifted_left_by_1 = input_float_bits_shifted_left_by_1 << (exponent_difference_absolute & 0xff);\n      if ((int)input_float_bits_without_sign < (int)exponent_difference_absolute) {\n        input_float_bits_shifted_left_by_1 = input_float_bits_shifted_left_by_1 >> (-(input_float_bits_without_sign - exponent_difference_absolute) & 0xff);\n      }\n      else {\n        input_float_bits_shifted_left_by_1 = input_float_bits_shifted_left_by_1 + (input_float_bits_without_sign - exponent_difference_absolute) * 0x800000;\n      }\n      return input_float_bits_shifted_left_by_1 | input_float;\n    }\n  }\n  else {\n    input_float_bits_without_sign = shift_amount - 1;\n    if (0xffffff < input_float_bits_shifted_left_by_1) {\n      input_float_bits_without_sign = input_float_bits_shifted_left_by_1 & 1;\n      input_float_bits_shifted_left_by_1 = input_float_bits_shifted_left_by_1 >> 1;\n      mantissa_bits_output = (uint)(input_float_bits_without_sign != 0) << 0x1f | mantissa_bits_output >> 1;\n      input_float_bits_without_sign = shift_amount;\n      if (0xfd < shift_amount) goto LAB_08000bde;\n    }\n  }\n  input_float_bits_shifted_left_by_1 = input_float_bits_shifted_left_by_1 + input_float_bits_without_sign * 0x800000 + (uint)(0x7fffffff < mantissa_bits_output);\n  if (mantissa_bits_output == 0x80000000) {\n    input_float_bits_shifted_left_by_1 = input_float_bits_shifted_left_by_1 & 0xfffffffe;\n  }\n  return input_float_bits_shifted_left_by_1 | input_float;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000aa4",
            "calling": [
                "FUN_08004f78",
                "FUN_08004bd8"
            ],
            "imported": false,
            "current_name": "floating_point_conversion_08000aa4"
        },
        "FUN_08004ee8": {
            "renaming": {
                "FUN_08004ee8": "execute_data_transfer_08004ee8",
                "param_1": "source_address",
                "param_2": "destination_address",
                "param_3": "transfer_size",
                "param_4": "transfer_mode"
            },
            "code": "\nvoid execute_data_transfer_08004ee8(undefined source_address,undefined destination_address,undefined4 transfer_size,undefined2 transfer_mode)\n\n{\n  FUNC_08001f6c(PTR_DAT_08004f28,source_address,destination_address,1,transfer_size,transfer_mode,*(undefined4 *)PTR_DAT_08004f24);\n  return;\n}\n\n",
            "called": [
                "FUN_08001f6c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ee8",
            "calling": [],
            "imported": false,
            "current_name": "execute_data_transfer_08004ee8"
        },
        "FUN_080094f8": {
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1",
                "param_2": "array2",
                "iVar1": "difference",
                "puVar2": "ptr2",
                "iVar3": "offset",
                "puVar4": "ptr1"
            },
            "code": "\nint compare_arrays_080094f8(int array1,int array2)\n\n{\n  int difference;\n  uint *ptr2;\n  int offset;\n  uint *ptr1;\n  \n  offset = *(int *)(array2 + 0x10);\n  difference = *(int *)(array1 + 0x10) - offset;\n  if (difference == 0) {\n    ptr2 = (uint *)(array2 + 0x14 + offset * 4);\n    ptr1 = (uint *)(array1 + 0x14) + offset;\n    do {\n      ptr1 = ptr1 + -1;\n      ptr2 = ptr2 + -1;\n      if (*ptr1 != *ptr2) {\n        if (*ptr2 <= *ptr1) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1 + 0x14) < ptr1);\n  }\n  return difference;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080094f8",
            "calling": [
                "FUN_080079e8",
                "FUN_080078c0"
            ],
            "imported": false,
            "current_name": "compare_arrays_080094f8"
        },
        "FUN_08000998": {
            "renaming": {
                "FUN_08000998": "check_if_input_is_not_null_08000998",
                "in_ZR": "input_char"
            },
            "code": "\nbool check_if_input_is_not_null_08000998(void)\n\n{\n  char input_char;\n  \n  check_and_return_param_08000988();\n  return input_char != '\\0';\n}\n\n",
            "called": [
                "FUN_08000988"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000998",
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "check_if_input_is_not_null_08000998"
        },
        "FUN_08000aa8": {
            "renaming": {
                "FUN_08000aa8": "binary_float_arithmetic_08000aa8",
                "param_1": "float_1",
                "param_2": "float_2",
                "param_3": "float_3",
                "param_4": "float_4",
                "iVar1": "int_1",
                "iVar6": "int_2",
                "uVar2": "uint_1",
                "uVar3": "uint_2",
                "uVar4": "uint_3",
                "uVar5": "uint_4",
                "bVar7": "bool_1"
            },
            "code": "\nuint binary_float_arithmetic_08000aa8(uint float_1,uint float_2,undefined4 float_3,uint float_4)\n\n{\n  int int_1;\n  uint uint_1;\n  uint uint_2;\n  uint uint_3;\n  uint uint_4;\n  int int_2;\n  bool bool_1;\n  \n  uint_2 = float_1 << 1;\n  bool_1 = uint_2 == 0;\n  if (!bool_1) {\n    float_4 = float_2 << 1;\n    bool_1 = float_4 == 0;\n  }\n  if (!bool_1) {\n    bool_1 = uint_2 == float_4;\n  }\n  int_2 = (int)uint_2 >> 0x18;\n  if (!bool_1) {\n    bool_1 = int_2 == -1;\n  }\n  if (!bool_1) {\n    bool_1 = (int)float_4 >> 0x18 == -1;\n  }\n  if (bool_1) {\n    int_1 = (int)(float_2 << 1) >> 0x18;\n    if (int_2 == -1 || int_1 == -1) {\n      uint_2 = float_2;\n      if (int_2 == -1) {\n        uint_2 = float_1;\n      }\n      if (int_2 != -1 || int_1 != -1) {\n        float_2 = uint_2;\n      }\n      bool_1 = (uint_2 & 0x7fffff) == 0;\n      if (bool_1) {\n        bool_1 = (float_2 & 0x7fffff) == 0;\n      }\n      if (bool_1) {\n        bool_1 = uint_2 == float_2;\n      }\n      if (!bool_1) {\n        uint_2 = uint_2 | 0x400000;\n      }\n      return uint_2;\n    }\n    if (((float_1 ^ float_2) & 0x7fffffff) != 0) {\n      if (uint_2 == 0) {\n        float_1 = float_2;\n      }\n      return float_1;\n    }\n    if (float_1 != float_2) {\n      return 0;\n    }\n    if ((uint_2 & 0xff000000) == 0) {\n      uint_2 = float_1 << 1;\n      if ((float_1 & 0x80000000) != 0) {\n        uint_2 = uint_2 | 0x80000000;\n      }\n      return uint_2;\n    }\n    if (uint_2 < 0xfe000000) {\n      return float_1 + 0x800000;\n    }\n    float_1 = float_1 & 0x80000000;\nLAB_08000bde:\n    return float_1 | 0x7f800000;\n  }\n  uint_2 = uint_2 >> 0x18;\n  float_4 = float_4 >> 0x18;\n  uint_4 = float_4 - uint_2;\n  bool_1 = uint_4 != 0;\n  uint_3 = uint_2;\n  if (bool_1 && uint_2 <= float_4) {\n    uint_3 = uint_2 + uint_4;\n  }\n  if (bool_1 && uint_2 <= float_4) {\n    float_2 = float_2 ^ float_1;\n  }\n  if (bool_1 && uint_2 <= float_4) {\n    float_1 = float_1 ^ float_2;\n  }\n  if (bool_1 && uint_2 <= float_4) {\n    float_2 = float_2 ^ float_1;\n  }\n  if (float_4 < uint_2) {\n    uint_4 = -uint_4;\n  }\n  if (0x19 < uint_4) {\n    return float_1;\n  }\n  uint_2 = float_1 & 0xffffff | 0x800000;\n  if ((float_1 & 0x80000000) != 0) {\n    uint_2 = -uint_2;\n  }\n  uint_1 = float_2 & 0xffffff | 0x800000;\n  if ((float_2 & 0x80000000) != 0) {\n    uint_1 = -uint_1;\n  }\n  if (uint_3 == uint_4) {\n    uint_1 = uint_1 ^ 0x800000;\n    if (uint_3 == 0) {\n      uint_2 = uint_2 ^ 0x800000;\n      uint_3 = 1;\n    }\n    else {\n      uint_4 = uint_4 - 1;\n    }\n  }\n  uint_2 = uint_2 + ((int)uint_1 >> (uint_4 & 0xff));\n  uint_1 = uint_1 << (0x20 - uint_4 & 0xff);\n  float_1 = uint_2 & 0x80000000;\n  if ((int)uint_2 < 0) {\n    bool_1 = uint_1 != 0;\n    uint_1 = -uint_1;\n    uint_2 = -uint_2 - (uint)bool_1;\n  }\n  if (uint_2 < 0x800000) {\n    uint_4 = uint_1 & 0x80000000;\n    uint_1 = uint_1 << 1;\n    uint_2 = uint_2 * 2 + (uint)(uint_4 != 0);\n    uint_4 = uint_3 - 2;\n    if ((uint_2 & 0x800000) == 0) {\n      int_2 = count_leading_zeroes(uint_2);\n      uint_3 = int_2 - 8;\n      uint_2 = uint_2 << (uint_3 & 0xff);\n      if ((int)uint_4 < (int)uint_3) {\n        uint_2 = uint_2 >> (-(uint_4 - uint_3) & 0xff);\n      }\n      else {\n        uint_2 = uint_2 + (uint_4 - uint_3) * 0x800000;\n      }\n      return uint_2 | float_1;\n    }\n  }\n  else {\n    uint_4 = uint_3 - 1;\n    if (0xffffff < uint_2) {\n      uint_4 = uint_2 & 1;\n      uint_2 = uint_2 >> 1;\n      uint_1 = (uint)(uint_4 != 0) << 0x1f | uint_1 >> 1;\n      uint_4 = uint_3;\n      if (0xfd < uint_3) goto LAB_08000bde;\n    }\n  }\n  uint_2 = uint_2 + uint_4 * 0x800000 + (uint)(0x7fffffff < uint_1);\n  if (uint_1 == 0x80000000) {\n    uint_2 = uint_2 & 0xfffffffe;\n  }\n  return uint_2 | float_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000aa8",
            "calling": [
                "FUN_080049cc",
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "binary_float_arithmetic_08000aa8"
        },
        "FUN_080009ac": {
            "renaming": {
                "FUN_080009ac": "check_null_termination_080009ac",
                "in_CY": "input_char"
            },
            "code": "\nbool check_null_termination_080009ac(void)\n\n{\n  char input_char;\n  \n  check_and_return_param_08000988();\n  return input_char == '\\0';\n}\n\n",
            "called": [
                "FUN_08000988"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009ac",
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "check_null_termination_080009ac"
        },
        "FUN_08000fc8": {
            "renaming": {
                "FUN_08000fc8": "concatenate_64bit_values_08000fc8",
                "param_1": "value_1",
                "param_2": "value_2"
            },
            "code": "\nvoid concatenate_64bit_values_08000fc8(undefined4 value_1,undefined4 value_2)\n\n{\n  concatenate_64bit_values_08000fc8_08000fd0(value_2,value_1);\n  return;\n}\n\n",
            "called": [
                "FUN_08000fd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000fc8",
            "calling": [
                "FUN_08001030"
            ],
            "imported": false,
            "current_name": "concatenate_64bit_values_08000fc8"
        },
        "FUN_08001cb8": {
            "renaming": {
                "FUN_08001cb8": "do_nothing_08001cb8"
            },
            "code": "\nvoid do_nothing_08001cb8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001cb8",
            "calling": [
                "FUN_08001ab0"
            ],
            "imported": false,
            "current_name": "do_nothing_08001cb8"
        },
        "FUN_0800438a": {
            "renaming": {
                "FUN_0800438a": "initialize_device_0800438a",
                "param_1": "device_ptr",
                "uVar1": "return_value",
                "do_nothing_08004424": "perform_initialization",
                "calculate_checksum_080046ec": "calculate_device_checksum"
            },
            "code": "\nundefined4 initialize_device_0800438a(int *device_ptr)\n\n{\n  undefined4 return_value;\n  \n  if (device_ptr == (int *)0x0) {\n    return_value = 1;\n  }\n  else {\n    if (*(char *)((int)device_ptr + 0x39) == '\\0') {\n      *(undefined *)(device_ptr + 0xe) = 0;\n      do_nothing_08004424(device_ptr);\n    }\n    *(undefined *)((int)device_ptr + 0x39) = 0x24;\n    *(uint *)(*device_ptr + 0xc) = *(uint *)(*device_ptr + 0xc) & 0xffffdfff;\n    calculate_checksum_080046ec(device_ptr);\n    *(uint *)(*device_ptr + 0x10) = *(uint *)(*device_ptr + 0x10) & 0xffffb7ff;\n    *(uint *)(*device_ptr + 0x14) = *(uint *)(*device_ptr + 0x14) & 0xffffffd5;\n    *(uint *)(*device_ptr + 0xc) = *(uint *)(*device_ptr + 0xc) | 0x2000;\n    device_ptr[0xf] = 0;\n    *(undefined *)((int)device_ptr + 0x39) = 0x20;\n    *(undefined *)((int)device_ptr + 0x3a) = 0x20;\n    return_value = 0;\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_080046ec",
                "FUN_08004424"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800438a",
            "calling": [
                "FUN_08005598"
            ],
            "imported": false,
            "current_name": "initialize_device_0800438a"
        },
        "FUN_080014f0": {
            "renaming": {
                "FUN_080014f0": "set_memory_param_080014f0",
                "set_param_in_memory_08001714": "set_memory_param_type",
                "write_param_to_memory_0800151c": "write_memory_param",
                "do_nothing_08002d8a": "do_nothing"
            },
            "code": "\nundefined4 set_memory_param_080014f0(void)\n\n{\n  *DAT_08001518 = *DAT_08001518 | 0x10;\n  set_param_in_memory_08001714(3);\n  write_param_to_memory_0800151c(0xf);\n  do_nothing_08002d8a();\n  return 0;\n}\n\n",
            "called": [
                "FUN_08002d8a",
                "FUN_08001714",
                "FUN_0800151c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080014f0",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "set_memory_param_080014f0"
        },
        "FUN_08003908": {
            "renaming": {
                "FUN_08003908": "update_flags_and_registers_08003908",
                "param_1": "flags_and_registers",
                "param_2": "parameters",
                "param_3": "data_type",
                "uVar1": "return_value"
            },
            "code": "\nundefined4 update_flags_and_registers_08003908(int *flags_and_registers,int parameters,undefined4 data_type)\n\n{\n  undefined4 return_value;\n  \n  if (*(char *)(flags_and_registers + 0xf) == '\\x01') {\n    return_value = 2;\n  }\n  else {\n    *(undefined *)(flags_and_registers + 0xf) = 1;\n    *(undefined *)((int)flags_and_registers + 0x3d) = 2;\n    switch(data_type) {\n    case 0:\n      update_flags_and_registers_08003908_08003d60(*flags_and_registers,parameters);\n      *(uint *)(*flags_and_registers + 0x18) = *(uint *)(*flags_and_registers + 0x18) | 8;\n      *(uint *)(*flags_and_registers + 0x18) = *(uint *)(*flags_and_registers + 0x18) & 0xfffffffb;\n      *(uint *)(*flags_and_registers + 0x18) = *(uint *)(parameters + 0x10) | *(uint *)(*flags_and_registers + 0x18);\n      break;\n    case 4:\n      update_parameters_08003e38(*flags_and_registers,parameters);\n      *(uint *)(*flags_and_registers + 0x18) = *(uint *)(*flags_and_registers + 0x18) | 0x800;\n      *(uint *)(*flags_and_registers + 0x18) = *(uint *)(*flags_and_registers + 0x18) & 0xfffffbff;\n      *(uint *)(*flags_and_registers + 0x18) = *(int *)(parameters + 0x10) << 8 | *(uint *)(*flags_and_registers + 0x18);\n      break;\n    case 8:\n      update_data_08003f18(*flags_and_registers,parameters);\n      *(uint *)(*flags_and_registers + 0x1c) = *(uint *)(*flags_and_registers + 0x1c) | 8;\n      *(uint *)(*flags_and_registers + 0x1c) = *(uint *)(*flags_and_registers + 0x1c) & 0xfffffffb;\n      *(uint *)(*flags_and_registers + 0x1c) = *(uint *)(parameters + 0x10) | *(uint *)(*flags_and_registers + 0x1c);\n      break;\n    case 0xc:\n      update_data_08003ff8(*flags_and_registers,parameters);\n      *(uint *)(*flags_and_registers + 0x1c) = *(uint *)(*flags_and_registers + 0x1c) | 0x800;\n      *(uint *)(*flags_and_registers + 0x1c) = *(uint *)(*flags_and_registers + 0x1c) & 0xfffffbff;\n      *(uint *)(*flags_and_registers + 0x1c) = *(int *)(parameters + 0x10) << 8 | *(uint *)(*flags_and_registers + 0x1c);\n    }\n    *(undefined *)((int)flags_and_registers + 0x3d) = 1;\n    *(undefined *)(flags_and_registers + 0xf) = 0;\n    return_value = 0;\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_08003d60",
                "FUN_08003f18",
                "FUN_08003ff8",
                "FUN_08003e38"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003908",
            "calling": [
                "FUN_080053b0"
            ],
            "imported": false,
            "current_name": "update_flags_and_registers_08003908"
        },
        "FUN_08004f60": {
            "renaming": {
                "FUN_08004f60": "clear_memory_08004f60",
                "memset_aligned_08005d68": "clear_memory_aligned"
            },
            "code": "\nvoid clear_memory_08004f60(void)\n\n{\n  memset_aligned_08005d68(PTR_DAT_08004f74,0,0x40);\n  return;\n}\n\n",
            "called": [
                "FUN_08005d68"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f60",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "clear_memory_08004f60"
        },
        "FUN_080009c0": {
            "renaming": {
                "FUN_080009c0": "check_and_return_param_080009c0",
                "in_ZR": "param1",
                "in_CY": "param2",
                "!(bool)in_CY": "param2_false",
                "(bool)in_ZR": "param1_true"
            },
            "code": "\nbool check_and_return_param_080009c0(void)\n\n{\n  undefined param1;\n  undefined param2;\n  \n  check_and_return_param_080009c0_08000988();\n  return param2_false || param1_true;\n}\n\n",
            "called": [
                "FUN_08000988"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009c0",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "check_and_return_param_080009c0"
        },
        "FUN_08001170": {
            "renaming": {
                "FUN_08001170": "check_params_08001170",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4"
            },
            "code": "\nundefined4 check_params_08001170(uint input_1,int input_2,uint input_3,int input_4)\n\n{\n  if ((((input_2 << 1) >> 0x15 != -1) || ((input_1 | input_2 << 0xc) == 0)) &&\n     (((input_4 << 1) >> 0x15 != -1 || ((input_3 | input_4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001170",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "check_params_08001170"
        },
        "FUN_08003f18": {
            "renaming": {
                "FUN_08003f18": "update_data_08003f18",
                "param_1": "data_pointer",
                "param_2": "data_array",
                "uVar1": "data_array_value1",
                "uVar2": "data_array_value2",
                "local_10": "local_data"
            },
            "code": "\nvoid update_data_08003f18(int data_pointer,uint *data_array)\n\n{\n  uint data_array_value1;\n  uint data_array_value2;\n  uint local_data;\n  \n  *(uint *)(data_pointer + 0x20) = *(uint *)(data_pointer + 0x20) & 0xfffffeff;\n  local_data = *(uint *)(data_pointer + 4);\n  data_array_value1 = *data_array;\n  data_array_value2 = data_array[2] << 8 | *(uint *)(data_pointer + 0x20) & 0xfffffdff;\n  if (data_pointer == DAT_08003ff4) {\n    data_array_value2 = (data_array[3] << 8 | data_array_value2 & 0xfffff7ff) & 0xfffffbff;\n    local_data = data_array[6] << 4 | data_array[5] << 4 | local_data & 0xffffcfff;\n  }\n  *(uint *)(data_pointer + 4) = local_data;\n  *(uint *)(data_pointer + 0x1c) = data_array_value1 | *(uint *)(data_pointer + 0x1c) & 0xffffff8c;\n  *(uint *)(data_pointer + 0x3c) = data_array[1];\n  *(uint *)(data_pointer + 0x20) = data_array_value2;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f18",
            "calling": [
                "FUN_08003908"
            ],
            "imported": false,
            "current_name": "update_data_08003f18"
        },
        "FUN_080097cc": {
            "renaming": {
                "FUN_080097cc": "copy_and_update_memory_block_080097cc",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "metadata",
                "iVar1": "source_index",
                "uVar2": "copy_length",
                "iVar3": "new_block_address",
                "iVar4": "metadata_length",
                "uVar5": "new_block_size",
                "uVar6": "metadata_copy_length",
                "puVar7": "source_pointer",
                "puVar8": "metadata_pointer",
                "uVar9": "source_value"
            },
            "code": "\nundefined4 copy_and_update_memory_block_080097cc(undefined4 *destination,int *source,int *metadata)\n\n{\n  int source_index;\n  uint copy_length;\n  int new_block_address;\n  int metadata_length;\n  uint new_block_size;\n  uint metadata_copy_length;\n  undefined4 *source_pointer;\n  undefined4 *metadata_pointer;\n  undefined4 source_value;\n  \n  if (metadata[2] != 0) {\n    source_index = *source;\n    new_block_size = source[2];\n    metadata_pointer = (undefined4 *)*metadata;\n    do {\n      do {\n        source_pointer = metadata_pointer + 2;\n        source_value = *metadata_pointer;\n        metadata_copy_length = metadata_pointer[1];\n        metadata_pointer = source_pointer;\n      } while (metadata_copy_length == 0);\n      copy_length = metadata_copy_length;\n      if ((new_block_size <= metadata_copy_length) && (copy_length = new_block_size, (*(ushort *)(source + 3) & 0x480) != 0)) {\n        metadata_length = source_index - source[4];\n        new_block_size = (source[5] * 3) / 2;\n        copy_length = metadata_copy_length + 1 + metadata_length;\n        if (new_block_size < copy_length) {\n          new_block_size = copy_length;\n        }\n        if ((int)((uint)*(ushort *)(source + 3) << 0x15) < 0) {\n          new_block_address = allocate_and_return_pointer_08008af8(destination,new_block_size);\n          if (new_block_address == 0) {\nLAB_08009896:\n            *destination = 0xc;\n            *(ushort *)(source + 3) = *(ushort *)(source + 3) | 0x40;\n            metadata[1] = 0;\n            metadata[2] = 0;\n            return 0xffffffff;\n          }\n          copy_memory_08001084(new_block_address,source[4],metadata_length);\n          *(ushort *)(source + 3) = *(ushort *)(source + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          new_block_address = allocate_or_resize_memory_block_08009adc(destination);\n          if (new_block_address == 0) {\n            allocate_memory_block_080088ec(destination,source[4]);\n            goto LAB_08009896;\n          }\n        }\n        source_index = new_block_address + metadata_length;\n        source[5] = new_block_size;\n        source[4] = new_block_address;\n        *source = source_index;\n        source[2] = new_block_size - metadata_length;\n        copy_length = metadata_copy_length;\n      }\n      copy_memory_backward_08009a18(source_index,source_value,copy_length);\n      metadata_length = metadata[2];\n      new_block_size = source[2] - copy_length;\n      source_index = *source + copy_length;\n      source[2] = new_block_size;\n      *source = source_index;\n      metadata[2] = metadata_length - metadata_copy_length;\n    } while (metadata_length - metadata_copy_length != 0);\n  }\n  metadata[1] = 0;\n  return 0;\n}\n\n",
            "called": [
                "FUN_08001084",
                "FUN_08009a18",
                "FUN_08009adc",
                "FUN_08008af8",
                "FUN_080088ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080097cc",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "copy_and_update_memory_block_080097cc"
        },
        "FUN_08001f6c": {
            "renaming": {
                "FUN_08001f6c": "FUNC_08001f6c"
            },
            "code": "\nundefined4\nFUNC_08001f6c(uint **param_1,undefined2 param_2,undefined2 param_3,undefined2 param_4,uint *param_5,\n            undefined2 param_6,uint param_7)\n\n{\n  int iVar1;\n  uint uVar2;\n  char cVar3;\n  uint uVar4;\n  int iVar5;\n  undefined4 uVar6;\n  uint *puVar7;\n  bool bVar8;\n  \n  iVar1 = get_pointer_value_080015a0();\n  uVar2 = DAT_080021e0;\n  if (*(char *)((int)param_1 + 0x3d) == ' ') {\n    do {\n      if ((uVar2 >> 0x10 & 0xff) == 1) {\n        uVar4 = uVar2 & ~(*param_1)[5] & 0xffff;\n        bVar8 = uVar4 == 0;\n        if (bVar8) {\n          uVar4 = 1;\n        }\n        cVar3 = (char)uVar4;\n        if (!bVar8) {\n          cVar3 = '\\0';\n        }\n      }\n      else {\n        uVar4 = uVar2 & ~(*param_1)[6] & 0xffff;\n        bVar8 = uVar4 == 0;\n        if (bVar8) {\n          uVar4 = 1;\n        }\n        cVar3 = (char)uVar4;\n        if (!bVar8) {\n          cVar3 = '\\0';\n        }\n      }\n      if (cVar3 != '\\x01') {\n        iVar5 = 0;\n        goto LAB_08002040;\n      }\n      iVar5 = get_pointer_value_080015a0();\n    } while ((uint)(iVar5 - iVar1) < 0x1a);\n    param_1[0xc] = (uint *)0x0;\n    *(undefined *)((int)param_1 + 0x3d) = 0x20;\n    *(undefined *)((int)param_1 + 0x3e) = 0;\n    *(undefined *)(param_1 + 0xf) = 0;\n    iVar5 = 3;\nLAB_08002040:\n    if (iVar5 == 0) {\n      if (*(char *)(param_1 + 0xf) == '\\x01') {\n        uVar6 = 2;\n      }\n      else {\n        *(undefined *)(param_1 + 0xf) = 1;\n        if ((**param_1 & 1) != 1) {\n          **param_1 = **param_1 | 1;\n        }\n        **param_1 = **param_1 & 0xfffff7ff;\n        *(undefined *)((int)param_1 + 0x3d) = 0x22;\n        *(undefined *)((int)param_1 + 0x3e) = 0x40;\n        param_1[0x10] = (uint *)0x0;\n        param_1[9] = param_5;\n        *(undefined2 *)((int)param_1 + 0x2a) = param_6;\n        param_1[0xb] = DAT_080021e4;\n        *(undefined2 *)(param_1 + 10) = *(undefined2 *)((int)param_1 + 0x2a);\n        iVar5 = set_flag_and_check_pointer_080027f4(param_1,param_2,param_3,param_4,param_7,iVar1);\n        if (iVar5 == 0) {\n          if (*(short *)(param_1 + 10) == 0) {\n            **param_1 = **param_1 | 0x200;\n          }\n          else if (*(short *)(param_1 + 10) == 1) {\n            **param_1 = **param_1 & 0xfffffbff;\n            disableIRQinterrupts();\n            **param_1 = **param_1 | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (*(short *)(param_1 + 10) == 2) {\n            **param_1 = **param_1 | 0x800;\n            disableIRQinterrupts();\n            **param_1 = **param_1 & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            **param_1 = **param_1 | 0x400;\n          }\n          while (uVar2 = DAT_080024bc, *(short *)(param_1 + 10) != 0) {\n            if (*(ushort *)(param_1 + 10) < 4) {\n              if (*(short *)(param_1 + 10) == 1) {\n                iVar5 = check_memory_access_08002ca8(param_1,param_7,iVar1);\n                if (iVar5 != 0) {\n                  if (param_1[0x10] == (uint *)0x20) {\n                    return 3;\n                  }\n                  return 1;\n                }\n                uVar2 = (*param_1)[4];\n                puVar7 = param_1[9];\n                param_1[9] = (uint *)((int)puVar7 + 1);\n                *(char *)puVar7 = (char)uVar2;\n                *(short *)(param_1 + 10) = *(short *)(param_1 + 10) + -1;\n                *(short *)((int)param_1 + 0x2a) = *(short *)((int)param_1 + 0x2a) + -1;\n              }\n              else if (*(short *)(param_1 + 10) == 2) {\n                do {\n                  if ((uVar2 >> 0x10 & 0xff) == 1) {\n                    uVar4 = uVar2 & ~(*param_1)[5] & 0xffff;\n                    bVar8 = uVar4 == 0;\n                    if (bVar8) {\n                      uVar4 = 1;\n                    }\n                    cVar3 = (char)uVar4;\n                    if (!bVar8) {\n                      cVar3 = '\\0';\n                    }\n                  }\n                  else {\n                    uVar4 = uVar2 & ~(*param_1)[6] & 0xffff;\n                    bVar8 = uVar4 == 0;\n                    if (bVar8) {\n                      uVar4 = 1;\n                    }\n                    cVar3 = (char)uVar4;\n                    if (!bVar8) {\n                      cVar3 = '\\0';\n                    }\n                  }\n                  if (cVar3 != '\\0') {\n                    iVar5 = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((param_7 == 0xffffffff) ||\n                        ((param_7 != 0 && (iVar5 = get_pointer_value_080015a0(), (uint)(iVar5 - iVar1) <= param_7)\n                         )));\n                param_1[0xc] = (uint *)0x0;\n                *(undefined *)((int)param_1 + 0x3d) = 0x20;\n                *(undefined *)((int)param_1 + 0x3e) = 0;\n                *(undefined *)(param_1 + 0xf) = 0;\n                iVar5 = 3;\nLAB_080022fa:\n                if (iVar5 != 0) {\n                  return 3;\n                }\n                disableIRQinterrupts();\n                **param_1 = **param_1 | 0x200;\n                uVar2 = (*param_1)[4];\n                puVar7 = param_1[9];\n                param_1[9] = (uint *)((int)puVar7 + 1);\n                *(char *)puVar7 = (char)uVar2;\n                *(short *)(param_1 + 10) = *(short *)(param_1 + 10) + -1;\n                *(short *)((int)param_1 + 0x2a) = *(short *)((int)param_1 + 0x2a) + -1;\n                enableIRQinterrupts();\n                uVar2 = (*param_1)[4];\n                puVar7 = param_1[9];\n                param_1[9] = (uint *)((int)puVar7 + 1);\n                *(char *)puVar7 = (char)uVar2;\n                *(short *)(param_1 + 10) = *(short *)(param_1 + 10) + -1;\n                *(short *)((int)param_1 + 0x2a) = *(short *)((int)param_1 + 0x2a) + -1;\n              }\n              else {\n                do {\n                  if ((uVar2 >> 0x10 & 0xff) == 1) {\n                    uVar4 = uVar2 & ~(*param_1)[5] & 0xffff;\n                    bVar8 = uVar4 == 0;\n                    if (bVar8) {\n                      uVar4 = 1;\n                    }\n                    cVar3 = (char)uVar4;\n                    if (!bVar8) {\n                      cVar3 = '\\0';\n                    }\n                  }\n                  else {\n                    uVar4 = uVar2 & ~(*param_1)[6] & 0xffff;\n                    bVar8 = uVar4 == 0;\n                    if (bVar8) {\n                      uVar4 = 1;\n                    }\n                    cVar3 = (char)uVar4;\n                    if (!bVar8) {\n                      cVar3 = '\\0';\n                    }\n                  }\n                  if (cVar3 != '\\0') {\n                    iVar5 = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((param_7 == 0xffffffff) ||\n                        ((param_7 != 0 && (iVar5 = get_pointer_value_080015a0(), (uint)(iVar5 - iVar1) <= param_7)\n                         )));\n                param_1[0xc] = (uint *)0x0;\n                *(undefined *)((int)param_1 + 0x3d) = 0x20;\n                *(undefined *)((int)param_1 + 0x3e) = 0;\n                *(undefined *)(param_1 + 0xf) = 0;\n                iVar5 = 3;\nLAB_08002418:\n                if (iVar5 != 0) {\n                  return 3;\n                }\n                **param_1 = **param_1 & 0xfffffbff;\n                disableIRQinterrupts();\n                uVar2 = (*param_1)[4];\n                puVar7 = param_1[9];\n                param_1[9] = (uint *)((int)puVar7 + 1);\n                *(char *)puVar7 = (char)uVar2;\n                *(short *)(param_1 + 10) = *(short *)(param_1 + 10) + -1;\n                *(short *)((int)param_1 + 0x2a) = *(short *)((int)param_1 + 0x2a) + -1;\n                uVar2 = DAT_080024bc;\n                do {\n                  if ((uVar2 >> 0x10 & 0xff) == 1) {\n                    uVar4 = uVar2 & ~(*param_1)[5] & 0xffff;\n                    bVar8 = uVar4 == 0;\n                    if (bVar8) {\n                      uVar4 = 1;\n                    }\n                    cVar3 = (char)uVar4;\n                    if (!bVar8) {\n                      cVar3 = '\\0';\n                    }\n                  }\n                  else {\n                    uVar4 = uVar2 & ~(*param_1)[6] & 0xffff;\n                    bVar8 = uVar4 == 0;\n                    if (bVar8) {\n                      uVar4 = 1;\n                    }\n                    cVar3 = (char)uVar4;\n                    if (!bVar8) {\n                      cVar3 = '\\0';\n                    }\n                  }\n                  if (cVar3 != '\\0') {\n                    iVar5 = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((param_7 == 0xffffffff) ||\n                        ((param_7 != 0 && (iVar5 = get_pointer_value_080015a0(), (uint)(iVar5 - iVar1) <= param_7)\n                         )));\n                param_1[0xc] = (uint *)0x0;\n                *(undefined *)((int)param_1 + 0x3d) = 0x20;\n                *(undefined *)((int)param_1 + 0x3e) = 0;\n                *(undefined *)(param_1 + 0xf) = 0;\n                iVar5 = 3;\nLAB_0800250a:\n                if (iVar5 != 0) {\n                  return 3;\n                }\n                **param_1 = **param_1 | 0x200;\n                uVar2 = (*param_1)[4];\n                puVar7 = param_1[9];\n                param_1[9] = (uint *)((int)puVar7 + 1);\n                *(char *)puVar7 = (char)uVar2;\n                *(short *)(param_1 + 10) = *(short *)(param_1 + 10) + -1;\n                *(short *)((int)param_1 + 0x2a) = *(short *)((int)param_1 + 0x2a) + -1;\n                enableIRQinterrupts();\n                uVar2 = (*param_1)[4];\n                puVar7 = param_1[9];\n                param_1[9] = (uint *)((int)puVar7 + 1);\n                *(char *)puVar7 = (char)uVar2;\n                *(short *)(param_1 + 10) = *(short *)(param_1 + 10) + -1;\n                *(short *)((int)param_1 + 0x2a) = *(short *)((int)param_1 + 0x2a) + -1;\n              }\n            }\n            else {\n              iVar5 = check_memory_access_08002ca8(param_1,param_7,iVar1);\n              if (iVar5 != 0) {\n                if (param_1[0x10] == (uint *)0x20) {\n                  return 3;\n                }\n                return 1;\n              }\n              uVar2 = (*param_1)[4];\n              puVar7 = param_1[9];\n              param_1[9] = (uint *)((int)puVar7 + 1);\n              *(char *)puVar7 = (char)uVar2;\n              *(short *)(param_1 + 10) = *(short *)(param_1 + 10) + -1;\n              *(short *)((int)param_1 + 0x2a) = *(short *)((int)param_1 + 0x2a) + -1;\n              if (((*param_1)[5] & 4) == 4) {\n                uVar2 = (*param_1)[4];\n                puVar7 = param_1[9];\n                param_1[9] = (uint *)((int)puVar7 + 1);\n                *(char *)puVar7 = (char)uVar2;\n                *(short *)(param_1 + 10) = *(short *)(param_1 + 10) + -1;\n                *(short *)((int)param_1 + 0x2a) = *(short *)((int)param_1 + 0x2a) + -1;\n              }\n            }\n          }\n          *(undefined *)((int)param_1 + 0x3d) = 0x20;\n          *(undefined *)((int)param_1 + 0x3e) = 0;\n          *(undefined *)(param_1 + 0xf) = 0;\n          uVar6 = 0;\n        }\n        else if (param_1[0x10] == (uint *)0x4) {\n          *(undefined *)(param_1 + 0xf) = 0;\n          uVar6 = 1;\n        }\n        else {\n          *(undefined *)(param_1 + 0xf) = 0;\n          uVar6 = 3;\n        }\n      }\n    }\n    else {\n      uVar6 = 2;\n    }\n  }\n  else {\n    uVar6 = 2;\n  }\n  return uVar6;\n}\n\n",
            "called": [
                "FUN_08002ca8",
                "FUN_080015a0",
                "FUN_080027f4"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08001f6c",
            "calling": [
                "FUN_08004ee8"
            ],
            "imported": false,
            "current_name": "FUNC_08001f6c"
        },
        "FUN_08002ad8": {
            "renaming": {
                "FUN_08002ad8": "check_and_set_flag_08002ad8",
                "param_1": "ptrs",
                "param_2": "flag",
                "param_3": "limit",
                "param_4": "ptr",
                "iVar1": "ptr_value",
                "cVar2": "result",
                "uVar3": "masked_flag",
                "bVar4": "flag_not_zero"
            },
            "code": "\nundefined4 check_and_set_flag_08002ad8(uint **ptrs,uint flag,uint limit,int ptr)\n\n{\n  int ptr_value;\n  char result;\n  uint masked_flag;\n  bool flag_not_zero;\n  \n  do {\n    if ((flag >> 0x10 & 0xff) == 1) {\n      masked_flag = flag & ~(*ptrs)[5] & 0xffff;\n      flag_not_zero = masked_flag != 0;\n      if (flag_not_zero) {\n        masked_flag = 1;\n      }\n      result = (char)masked_flag;\n      if (!flag_not_zero) {\n        result = '\\0';\n      }\n    }\n    else {\n      masked_flag = flag & ~(*ptrs)[6] & 0xffff;\n      flag_not_zero = masked_flag != 0;\n      if (flag_not_zero) {\n        masked_flag = 1;\n      }\n      result = (char)masked_flag;\n      if (!flag_not_zero) {\n        result = '\\0';\n      }\n    }\n    if (result == '\\0') {\n      return 0;\n    }\n    if (((*ptrs)[5] & 0x400) == 0x400) {\n      **ptrs = **ptrs | 0x200;\n      (*ptrs)[5] = 0xfffffbff;\n      ptrs[0x10] = (uint *)0x4;\n      ptrs[0xc] = (uint *)0x0;\n      *(undefined *)((int)ptrs + 0x3d) = 0x20;\n      *(undefined *)(ptrs + 0xf) = 0;\n      return 1;\n    }\n  } while ((limit == 0xffffffff) ||\n          ((limit != 0 && (ptr_value = get_pointer_value_080015a0(), (uint)(ptr_value - ptr) <= limit))));\n  ptrs[0xc] = (uint *)0x0;\n  *(undefined *)((int)ptrs + 0x3d) = 0x20;\n  *(undefined *)(ptrs + 0xf) = 0;\n  return 3;\n}\n\n",
            "called": [
                "FUN_080015a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ad8",
            "calling": [
                "FUN_08002640",
                "FUN_080027f4"
            ],
            "imported": false,
            "current_name": "check_and_set_flag_08002ad8"
        },
        "FUN_08000fd0": {
            "renaming": {
                "FUN_08000fd0": "concatenate_64bit_values_08000fd0",
                "param_1": "lower_32bit_value",
                "param_2": "higher_32bit_value",
                "check_overflow_08000f68": "check_for_overflow",
                "CONCAT44": "combine_64bit_values"
            },
            "code": "\nundefined8 concatenate_64bit_values_08000fd0(undefined4 lower_32bit_value,undefined4 higher_32bit_value)\n\n{\n  check_overflow_08000f68();\n  return combine_64bit_values(higher_32bit_value,lower_32bit_value);\n}\n\n",
            "called": [
                "FUN_08000f68"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000fd0",
            "calling": [
                "FUN_08000ff4",
                "FUN_08000fc8"
            ],
            "imported": false,
            "current_name": "concatenate_64bit_values_08000fd0"
        },
        "FUN_08003d60": {
            "renaming": {
                "FUN_08003d60": "update_flags_and_registers_08003d60",
                "param_1": "register_address",
                "param_2": "register_values",
                "uVar1": "value_1",
                "uVar2": "value_2",
                "local_10": "local_value"
            },
            "code": "\nvoid update_flags_and_registers_08003d60(int register_address,uint *register_values)\n\n{\n  uint value_1;\n  uint value_2;\n  uint local_value;\n  \n  *(uint *)(register_address + 0x20) = *(uint *)(register_address + 0x20) & 0xfffffffe;\n  local_value = *(uint *)(register_address + 4);\n  value_1 = *register_values;\n  value_2 = register_values[2] | *(uint *)(register_address + 0x20) & 0xfffffffd;\n  if (register_address == DAT_08003e34) {\n    value_2 = (register_values[3] | value_2 & 0xfffffff7) & 0xfffffffb;\n    local_value = register_values[6] | register_values[5] | local_value & 0xfffffcff;\n  }\n  *(uint *)(register_address + 4) = local_value;\n  *(uint *)(register_address + 0x18) = value_1 | *(uint *)(register_address + 0x18) & 0xffffff8c;\n  *(uint *)(register_address + 0x34) = register_values[1];\n  *(uint *)(register_address + 0x20) = value_2;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003d60",
            "calling": [
                "FUN_08003908"
            ],
            "imported": false,
            "current_name": "update_flags_and_registers_08003d60"
        },
        "FUN_08009e68": {
            "renaming": {
                "FUN_08009e68": "do_nothing_08009e68"
            },
            "code": "\nvoid do_nothing_08009e68(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009e68",
            "calling": [
                "FUN_08005d20",
                "FUN_08000134",
                "FUN_08000110"
            ],
            "imported": false,
            "current_name": "do_nothing_08009e68"
        },
        "FUN_08003518": {
            "renaming": {
                "FUN_08003518": "get_shifted_pointer_value_08003518",
                "uVar1": "pointer_value"
            },
            "code": "\nuint get_shifted_pointer_value_08003518(void)\n\n{\n  uint pointer_value;\n  \n  pointer_value = get_pointer_value_08003504();\n  return pointer_value >> PTR_DAT_0800353c[*(uint *)(DAT_08003538 + 4) >> 8 & 7];\n}\n\n",
            "called": [
                "FUN_08003504"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003518",
            "calling": [
                "FUN_080046ec",
                "FUN_08001ab0"
            ],
            "imported": false,
            "current_name": "get_shifted_pointer_value_08003518"
        },
        "FUN_08001618": {
            "renaming": {
                "FUN_08001618": "write_to_memory_08001618",
                "param_1": "byte_offset",
                "param_2": "data"
            },
            "code": "\nvoid write_to_memory_08001618(byte byte_offset,uint data)\n\n{\n  if ((char)byte_offset < '\\0') {\n    *(char *)((byte_offset & 0xf) + DAT_08001664 + 0x14) = (char)((data & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)byte_offset + DAT_08001668 + 0x300) = (char)((data & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001618",
            "calling": [
                "FUN_080016d0",
                "FUN_0800172a"
            ],
            "imported": false,
            "current_name": "write_to_memory_08001618"
        },
        "FUN_080091a4": {
            "renaming": {
                "FUN_080091a4": "find_highest_bit_set_080091a4",
                "param_1": "input_number",
                "iVar1": "highest_bit_position"
            },
            "code": "\nint find_highest_bit_set_080091a4(uint input_number)\n\n{\n  int highest_bit_position;\n  \n  if ((input_number & 0xffff0000) == 0) {\n    input_number = input_number << 0x10;\n    highest_bit_position = 0x10;\n  }\n  else {\n    highest_bit_position = 0;\n  }\n  if ((input_number & 0xff000000) == 0) {\n    input_number = input_number << 8;\n    highest_bit_position = highest_bit_position + 8;\n  }\n  if ((input_number & 0xf0000000) == 0) {\n    input_number = input_number << 4;\n    highest_bit_position = highest_bit_position + 4;\n  }\n  if ((input_number & 0xc0000000) == 0) {\n    input_number = input_number << 2;\n    highest_bit_position = highest_bit_position + 2;\n  }\n  if (-1 < (int)input_number) {\n    if ((int)(input_number << 1) < 0) {\n      return highest_bit_position + 1;\n    }\n    highest_bit_position = 0x20;\n  }\n  return highest_bit_position;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091a4",
            "calling": [
                "FUN_08009630",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "find_highest_bit_set_080091a4"
        },
        "FUN_08004f78": {
            "renaming": {
                "FUN_08004f78": "process_input_data_08004f78",
                "local_11": "byte_value"
            },
            "code": "\nvoid process_input_data_08004f78(void)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  byte byte_value;\n  \n  calculate_hashes_08004ae0(PTR_DAT_080051e0);\n  calculate_result_08004bd8(PTR_DAT_080051e0,PTR_DAT_080051e4);\n  clear_memory_08004f60();\n  uVar5 = decode_unsigned_long_long_08000418(*(undefined4 *)PTR_DAT_080051e4);\n  process_data_08005dfc(PTR_DAT_080051ec,PTR_s_Pitch___f_080051e8,(int)uVar5,(int)((ulonglong)uVar5 >> 0x20))\n  ;\n  uVar1 = find_first_set_bit_index_08005e40(PTR_DAT_080051ec);\n  validate_input_08004f3c(PTR_DAT_080051ec,uVar1);\n  uVar1 = floating_point_conversion_08000aa4(*(undefined4 *)PTR_DAT_080051f0,*(undefined4 *)PTR_DAT_080051e4);\n  *(undefined4 *)PTR_DAT_080051f4 = uVar1;\n  uVar1 = floating_point_addition_08000cb8(*(undefined4 *)PTR_DAT_080051f8,*(undefined4 *)PTR_DAT_080051f4);\n  *(undefined4 *)PTR_DAT_080051fc = uVar1;\n  uVar1 = floating_point_addition_08000cb8(*(undefined4 *)PTR_DAT_08005200,*(undefined4 *)PTR_DAT_080051f4);\n  uVar1 = binary_float_arithmetic_08000aa8(uVar1,*(undefined4 *)PTR_DAT_08005204);\n  *(undefined4 *)PTR_DAT_08005204 = uVar1;\n  uVar1 = calculate_hash_08000c10(*PTR_DAT_08005208);\n  iVar2 = check_if_input_is_null_terminated_08000ff4(uVar1,*(undefined4 *)PTR_DAT_08005204);\n  if (iVar2 == 0) {\n    uVar1 = calculate_hash_08000c10(*PTR_DAT_0800520c);\n    iVar2 = check_null_termination_08001030(uVar1,*(undefined4 *)PTR_DAT_08005204);\n    if (iVar2 != 0) {\n      uVar1 = calculate_hash_08000c08(*PTR_DAT_0800520c);\n      *(undefined4 *)PTR_DAT_08005204 = uVar1;\n    }\n  }\n  else {\n    uVar1 = calculate_hash_08000c08(*PTR_DAT_08005208);\n    *(undefined4 *)PTR_DAT_08005204 = uVar1;\n  }\n  uVar4 = *(uint *)PTR_DAT_08005210;\n  uVar1 = floating_point_conversion_08000aa4(*(undefined4 *)PTR_DAT_080051f4,*(undefined4 *)PTR_DAT_08005214);\n  uVar1 = floating_point_addition_08000cb8(uVar4 ^ 0x80000000,uVar1);\n  *(undefined4 *)PTR_DAT_08005218 = uVar1;\n  uVar1 = binary_float_arithmetic_08000aa8(*(undefined4 *)PTR_DAT_080051fc,*(undefined4 *)PTR_DAT_08005204);\n  uVar1 = binary_float_arithmetic_08000aa8(uVar1,*(undefined4 *)PTR_DAT_08005218);\n  uVar3 = calculate_hash_08000c10(*PTR_DAT_08005208);\n  iVar2 = check_null_termination_08001030(uVar1,uVar3);\n  if (iVar2 == 0) {\n    uVar3 = calculate_hash_08000c10(*PTR_DAT_0800520c);\n    iVar2 = check_if_input_is_null_terminated_08000ff4(uVar1,uVar3);\n    if (iVar2 == 0) {\n      byte_value = decode_unsigned_integer_08001044(uVar1);\n    }\n    else {\n      byte_value = *PTR_DAT_0800520c;\n    }\n  }\n  else {\n    byte_value = *PTR_DAT_08005208;\n  }\n  *(undefined4 *)PTR_DAT_08005214 = *(undefined4 *)PTR_DAT_080051f4;\n  iVar2 = check_null_termination_08001030(*(undefined4 *)PTR_DAT_080051f4,0);\n  set_parameter_value_08001a80(DAT_0800521c,2,iVar2 != 0);\n  iVar2 = check_null_termination_08001030(*(undefined4 *)PTR_DAT_080051f4,0);\n  set_parameter_value_08001a80(DAT_0800521c,4,iVar2 == 0);\n  iVar2 = check_null_termination_08001030(*(undefined4 *)PTR_DAT_080051f4,0);\n  set_parameter_value_08001a80(DAT_0800521c,8,iVar2 != 0);\n  iVar2 = check_null_termination_08001030(*(undefined4 *)PTR_DAT_080051f4,0);\n  set_parameter_value_08001a80(DAT_0800521c,0x10,iVar2 == 0);\n  *(uint *)(*(int *)PTR_DAT_08005220 + 0x34) = (uint)byte_value;\n  *(uint *)(*(int *)PTR_DAT_08005220 + 0x40) = (uint)byte_value;\n  return;\n}\n\n",
            "called": [
                "FUN_08004f60",
                "FUN_08005dfc",
                "FUN_08004f3c",
                "FUN_08001044",
                "FUN_08000c10",
                "FUN_08000aa4",
                "FUN_08000cb8",
                "FUN_08001a80",
                "FUN_08000ff4",
                "FUN_08005e40",
                "FUN_08000aa8",
                "FUN_08001030",
                "FUN_08000418",
                "FUN_08000c08",
                "FUN_08004bd8",
                "FUN_08004ae0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f78",
            "calling": [
                "FUN_080017b4",
                "FUN_080036f8"
            ],
            "imported": false,
            "current_name": "process_input_data_08004f78"
        },
        "FUN_080015a0": {
            "renaming": {
                "FUN_080015a0": "get_pointer_value_080015a0"
            },
            "code": "\nundefined4 get_pointer_value_080015a0(void)\n\n{\n  return *(undefined4 *)PTR_DAT_080015b0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015a0",
            "calling": [
                "FUN_08002640",
                "FUN_08004436",
                "FUN_08002c2e",
                "FUN_08002ca8",
                "FUN_08001f6c",
                "FUN_08003260",
                "FUN_08002ad8",
                "FUN_08002bb4",
                "FUN_080027f4",
                "FUN_08002d98",
                "FUN_08004f2c",
                "FUN_08001ccc"
            ],
            "imported": false,
            "current_name": "get_pointer_value_080015a0"
        },
        "FUN_08002d98": {
            "renaming": {
                "FUN_08002d98": "check_parameters_08002d98",
                "param_1": "parameters",
                "iVar1": "start_time",
                "iVar2": "current_time",
                "uVar3": "result",
                "bVar4": "flag"
            },
            "code": "\nundefined4 check_parameters_08002d98(uint *parameters)\n\n{\n  int start_time;\n  int current_time;\n  undefined4 result;\n  bool flag;\n  \n  if ((*parameters & 1) != 0) {\n    if (((DAT_08002ffc[1] & 0xc) == 4) ||\n       (((DAT_08002ffc[1] & 0xc) == 8 && ((DAT_08002ffc[1] & 0x10000) == 0x10000)))) {\n      if (((*DAT_08002ffc & 0x20000) != 0) && (parameters[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      if (parameters[1] == 0x10000) {\n        *DAT_08002ffc = *DAT_08002ffc | 0x10000;\n      }\n      else if (parameters[1] == 0) {\n        *DAT_08002ffc = *DAT_08002ffc & 0xfffeffff;\n        *DAT_08002ffc = *DAT_08002ffc & 0xfffbffff;\n      }\n      else if (parameters[1] == 0x50000) {\n        *DAT_08002ffc = *DAT_08002ffc | 0x40000;\n        *DAT_08002ffc = *DAT_08002ffc | 0x10000;\n      }\n      else {\n        *DAT_08002ffc = *DAT_08002ffc & 0xfffeffff;\n        *DAT_08002ffc = *DAT_08002ffc & 0xfffbffff;\n      }\n      if (parameters[1] == 0) {\n        start_time = get_pointer_value_080015a0();\n        while ((*DAT_08002ffc & 0x20000) != 0) {\n          current_time = get_pointer_value_080015a0();\n          if (100 < (uint)(current_time - start_time)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        start_time = get_pointer_value_080015a0();\n        while ((*DAT_08002ffc & 0x20000) == 0) {\n          current_time = get_pointer_value_080015a0();\n          if (100 < (uint)(current_time - start_time)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*parameters & 2) != 0) {\n    if (((DAT_08002ffc[1] & 0xc) == 0) ||\n       (((DAT_08002ffc[1] & 0xc) == 8 && ((DAT_08002ffc[1] & 0x10000) == 0)))) {\n      if (((*DAT_08002ffc & 2) != 0) && (parameters[4] != 1)) {\n        return 1;\n      }\n      *DAT_08002ffc = parameters[5] << 3 | *DAT_08002ffc & 0xffffff07;\n    }\n    else if (parameters[4] == 0) {\n      *DAT_08003000 = 0;\n      start_time = get_pointer_value_080015a0();\n      while ((*DAT_08002ffc & 2) != 0) {\n        current_time = get_pointer_value_080015a0();\n        if (2 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      *DAT_08003000 = 1;\n      start_time = get_pointer_value_080015a0();\n      while ((*DAT_08002ffc & 2) == 0) {\n        current_time = get_pointer_value_080015a0();\n        if (2 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n      *DAT_08002ffc = parameters[5] << 3 | *DAT_08002ffc & 0xffffff07;\n    }\n  }\n  if ((*parameters & 8) != 0) {\n    if (parameters[6] == 0) {\n      *DAT_08003004 = 0;\n      start_time = get_pointer_value_080015a0();\n      while ((DAT_08003254[9] & 2) != 0) {\n        current_time = get_pointer_value_080015a0();\n        if (2 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      *DAT_08003004 = 1;\n      start_time = get_pointer_value_080015a0();\n      while ((DAT_08002ffc[9] & 2) == 0) {\n        current_time = get_pointer_value_080015a0();\n        if (2 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n      count_down_by_param_multiplied_with_constant_08003568(1);\n    }\n  }\n  if ((*parameters & 4) != 0) {\n    flag = (DAT_08003254[7] & 0x10000000) == 0;\n    if (flag) {\n      DAT_08003254[7] = DAT_08003254[7] | 0x10000000;\n    }\n    if ((*DAT_08003258 & 0x100) == 0) {\n      *DAT_08003258 = *DAT_08003258 | 0x100;\n      start_time = get_pointer_value_080015a0();\n      while ((*DAT_08003258 & 0x100) == 0) {\n        current_time = get_pointer_value_080015a0();\n        if (100 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    if (parameters[3] == 1) {\n      DAT_08003254[8] = DAT_08003254[8] | 1;\n    }\n    else if (parameters[3] == 0) {\n      DAT_08003254[8] = DAT_08003254[8] & 0xfffffffe;\n      DAT_08003254[8] = DAT_08003254[8] & 0xfffffffb;\n    }\n    else if (parameters[3] == 5) {\n      DAT_08003254[8] = DAT_08003254[8] | 4;\n      DAT_08003254[8] = DAT_08003254[8] | 1;\n    }\n    else {\n      DAT_08003254[8] = DAT_08003254[8] & 0xfffffffe;\n      DAT_08003254[8] = DAT_08003254[8] & 0xfffffffb;\n    }\n    if (parameters[3] == 0) {\n      start_time = get_pointer_value_080015a0();\n      while ((DAT_08003254[8] & 2) != 0) {\n        current_time = get_pointer_value_080015a0();\n        if (5000 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      start_time = get_pointer_value_080015a0();\n      while ((DAT_08003254[8] & 2) == 0) {\n        current_time = get_pointer_value_080015a0();\n        if (5000 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    if (flag) {\n      DAT_08003254[7] = DAT_08003254[7] & 0xefffffff;\n    }\n  }\n  if (parameters[7] == 0) {\nLAB_0800324a:\n    result = 0;\n  }\n  else if ((DAT_08003254[1] & 0xc) == 8) {\n    result = 1;\n  }\n  else if (parameters[7] == 2) {\n    *DAT_0800325c = 0;\n    start_time = get_pointer_value_080015a0();\n    do {\n      if ((*DAT_08003254 & 0x2000000) == 0) {\n        if (parameters[8] == 0x10000) {\n          DAT_08003254[1] = parameters[2] | DAT_08003254[1] & 0xfffdffff;\n        }\n        DAT_08003254[1] = parameters[9] | parameters[8] | DAT_08003254[1] & 0xffc2ffff;\n        *DAT_0800325c = 1;\n        start_time = get_pointer_value_080015a0();\n        while ((*DAT_08003254 & 0x2000000) == 0) {\n          current_time = get_pointer_value_080015a0();\n          if (2 < (uint)(current_time - start_time)) {\n            return 3;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      current_time = get_pointer_value_080015a0();\n    } while ((uint)(current_time - start_time) < 3);\n    result = 3;\n  }\n  else {\n    *DAT_0800325c = 0;\n    start_time = get_pointer_value_080015a0();\n    do {\n      if ((*DAT_08003254 & 0x2000000) == 0) goto LAB_0800324a;\n      current_time = get_pointer_value_080015a0();\n    } while ((uint)(current_time - start_time) < 3);\n    result = 3;\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_08003568",
                "FUN_080015a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d98",
            "calling": [
                "FUN_080052a0"
            ],
            "imported": false,
            "current_name": "check_parameters_08002d98"
        },
        "FUN_0800172a": {
            "renaming": {
                "FUN_0800172a": "write_data_to_memory_0800172a",
                "param_1": "memory_address",
                "param_2": "bitmask_1",
                "param_3": "bitmask_2",
                "uVar1": "data_bits",
                "get_data_bits_080015fc": "get_data_bits",
                "bitwise_shift_and_merge_0800166c": "merge_data_bits",
                "write_to_memory_08001618": "write_data"
            },
            "code": "\nvoid write_data_to_memory_0800172a(char memory_address,undefined4 bitmask_1,undefined4 bitmask_2)\n\n{\n  undefined4 data_bits;\n  \n  data_bits = get_data_bits_080015fc();\n  data_bits = bitwise_shift_and_merge_0800166c(data_bits,bitmask_1,bitmask_2);\n  write_to_memory_08001618((int)memory_address,data_bits);\n  return;\n}\n\n",
            "called": [
                "FUN_080015fc",
                "FUN_0800166c",
                "FUN_08001618"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800172a",
            "calling": [
                "FUN_080052a0",
                "FUN_0800151c"
            ],
            "imported": false,
            "current_name": "write_data_to_memory_0800172a"
        },
        "FUN_080009d4": {
            "renaming": {
                "FUN_080009d4": "check_and_return_080009d4",
                "in_ZR": "zero_flag",
                "in_CY": "carry_flag"
            },
            "code": "\nbool check_and_return_080009d4(void)\n\n{\n  undefined zero_flag;\n  undefined carry_flag;\n  \n  check_params_and_return_08000978();\n  return !(bool)carry_flag || (bool)zero_flag;\n}\n\n",
            "called": [
                "FUN_08000978"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009d4",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "check_and_return_080009d4"
        },
        "FUN_08002d8a": {
            "renaming": {
                "FUN_08002d8a": "do_nothing_08002d8a"
            },
            "code": "\nvoid do_nothing_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d8a",
            "calling": [
                "FUN_080014f0"
            ],
            "imported": false,
            "current_name": "do_nothing_08002d8a"
        },
        "FUN_08005780": {
            "renaming": {
                "FUN_08005780": "set_bit_and_clear_flags_08005780"
            },
            "code": "\nvoid set_bit_and_clear_flags_08005780(void)\n\n{\n  *DAT_080057dc = *DAT_080057dc | 1;\n  DAT_080057dc[1] = DAT_080057e0 & DAT_080057dc[1];\n  *DAT_080057dc = *DAT_080057dc & 0xfef6ffff;\n  *DAT_080057dc = *DAT_080057dc & 0xfffbffff;\n  DAT_080057dc[1] = DAT_080057dc[1] & 0xff80ffff;\n  DAT_080057dc[2] = 0x9f0000;\n  *(undefined4 *)(DAT_080057e4 + 8) = 0x8000000;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005780",
            "calling": [
                "FUN_080057e8"
            ],
            "imported": false,
            "current_name": "set_bit_and_clear_flags_08005780"
        },
        "FUN_08009744": {
            "renaming": {
                "FUN_08009744": "allocate_memory_and_return_pointer_08009744",
                "param_1": "output_pointer",
                "param_2": "allocation_size",
                "puVar1": "previous_allocation_pointer",
                "iVar2": "allocation_result"
            },
            "code": "\nvoid allocate_memory_and_return_pointer_08009744(int *output_pointer,undefined4 allocation_size)\n\n{\n  undefined *previous_allocation_pointer;\n  int allocation_result;\n  \n  previous_allocation_pointer = PTR_DAT_08009764;\n  *(undefined4 *)PTR_DAT_08009764 = 0;\n  allocation_result = update_memory_allocation_pointer_08005728(allocation_size);\n  if ((allocation_result == -1) && (*(int *)previous_allocation_pointer != 0)) {\n    *output_pointer = *(int *)previous_allocation_pointer;\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08005728"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009744",
            "calling": [
                "FUN_0800884c",
                "FUN_08008af8"
            ],
            "imported": false,
            "current_name": "allocate_memory_and_return_pointer_08009744"
        },
        "FUN_08003640": {
            "renaming": {
                "FUN_08003640": "check_params_and_update_08003640",
                "param_1": "params",
                "uVar1": "result",
                "do_nothing_08003696": "perform_no_action",
                "update_params_08003c94": "update_params"
            },
            "code": "\nundefined4 check_params_and_update_08003640(undefined4 *params)\n\n{\n  undefined4 result;\n  \n  if (params == (undefined4 *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)params + 0x3d) == '\\0') {\n      *(undefined *)(params + 0xf) = 0;\n      do_nothing_08003696(params);\n    }\n    *(undefined *)((int)params + 0x3d) = 2;\n    update_params_08003c94(*params,params + 1);\n    *(undefined *)((int)params + 0x3d) = 1;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_08003696",
                "FUN_08003c94"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003640",
            "calling": [
                "FUN_080053b0"
            ],
            "imported": false,
            "current_name": "check_params_and_update_08003640"
        },
        "FUN_08009980": {
            "renaming": {
                "FUN_08009980": "allocate_and_initialize_memory_08009980",
                "param_1": "memory_address",
                "param_2": "element_size",
                "param_3": "num_elements",
                "puVar1": "allocated_memory",
                "uVar2": "allocated_memory_size",
                "puVar3": "initialized_memory"
            },
            "code": "\nundefined4 * allocate_and_initialize_memory_08009980(undefined4 memory_address,int element_size,int num_elements)\n\n{\n  undefined4 *allocated_memory;\n  uint allocated_memory_size;\n  undefined4 *initialized_memory;\n  \n  allocated_memory = (undefined4 *)allocate_and_return_pointer_08008af8(memory_address,num_elements * element_size);\n  if (allocated_memory == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  allocated_memory_size = (allocated_memory[-1] & 0xfffffffc) - 4;\n  if (allocated_memory_size < 0x25) {\n    initialized_memory = allocated_memory;\n    if (0x13 < allocated_memory_size) {\n      *allocated_memory = 0;\n      allocated_memory[1] = 0;\n      if (0x1b < allocated_memory_size) {\n        allocated_memory[2] = 0;\n        allocated_memory[3] = 0;\n        if (allocated_memory_size == 0x24) {\n          allocated_memory[4] = 0;\n          allocated_memory[5] = 0;\n          initialized_memory = allocated_memory + 6;\n        }\n        else {\n          initialized_memory = allocated_memory + 4;\n        }\n        *initialized_memory = 0;\n        initialized_memory[1] = 0;\n        initialized_memory[2] = 0;\n        return allocated_memory;\n      }\n      initialized_memory = allocated_memory + 2;\n    }\n    *initialized_memory = 0;\n    initialized_memory[1] = 0;\n    initialized_memory[2] = 0;\n    return allocated_memory;\n  }\n  memset_aligned_08005d68(allocated_memory,0);\n  return allocated_memory;\n}\n\n",
            "called": [
                "FUN_08005d68",
                "FUN_08008af8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009980",
            "calling": [
                "FUN_080090c0"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_memory_08009980"
        },
        "FUN_08005e9c": {
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n/* WARNING: Could not reconcile some variable overlaps */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  int iVar8;\n  int *piVar9;\n  undefined4 uVar10;\n  int **ppiVar11;\n  undefined uVar12;\n  ushort uVar13;\n  int **ppiVar14;\n  byte **ppbVar15;\n  int *piVar16;\n  int **ppiVar17;\n  char *pcVar18;\n  uint uVar19;\n  undefined *puVar20;\n  int *piVar21;\n  int *piVar22;\n  int *piVar23;\n  int *piVar24;\n  int *piVar25;\n  byte *pbVar26;\n  int *piVar27;\n  int *piVar28;\n  undefined4 *puVar29;\n  byte *pbVar30;\n  bool bVar31;\n  longlong lVar32;\n  undefined8 uVar33;\n  undefined8 uVar34;\n  undefined4 local_188;\n  int *piStack_184;\n  int **local_180;\n  undefined *puStack_17c;\n  int **local_178;\n  undefined4 *local_16c;\n  int *local_168;\n  byte *local_164;\n  int *local_160;\n  int *local_15c;\n  int **local_158;\n  int **local_154;\n  undefined8 local_150;\n  int *local_148;\n  int *local_144;\n  int *local_140;\n  int **local_13c;\n  int *local_138;\n  int *local_134;\n  int *local_130;\n  uint local_12c;\n  undefined4 local_128;\n  undefined4 local_124;\n  undefined4 local_120;\n  undefined *local_11c;\n  int *local_118;\n  int *local_114;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  int *local_100;\n  int *local_fc;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0;\n  undefined auStack_ec [4];\n  char local_e8;\n  undefined local_e7;\n  char local_e6 [6];\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int *local_d4;\n  int *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  local_16c = param_1;\n  local_160 = param_2;\n  local_154 = param_4;\n  ppiVar2 = (int **)FUNC_08008ad4();\n  local_114 = *ppiVar2;\n  local_118 = (int *)find_first_set_bit_index_08005e40(local_114);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar3 = allocate_and_return_pointer_08008af8(local_16c,0x40);\n    *local_160 = iVar3;\n    local_160[4] = iVar3;\n    if (iVar3 == 0) {\n      *local_16c = 0xc;\n      return (byte *)0xffffffff;\n    }\n    local_160[5] = 0x40;\n  }\n  local_128 = 0;\n  local_138 = (int *)0x0;\n  local_12c = 0;\n  local_d4 = (int *)0x0;\n  local_d0 = (int *)0x0;\n  local_11c = (undefined *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  local_124 = 0;\n  local_120 = 0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = local_164 + (int)piVar27;\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    piVar25 = (int *)0x0;\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    puVar29 = local_16c;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    switch(piVar24) {\n    case (int *)0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (piVar24 == (int *)0x0) goto LAB_08006216;\n      piVar16 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_158 = (int **)0x1;\n      piVar23 = (int *)&local_8c;\n      piVar22 = piVar16;\n      local_8c = (char)piVar24;\n      goto LAB_08006298;\n    case (int *)0x23:\n      piVar25 = (int *)((uint)piVar25 | 1);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x27:\n      iVar3 = FUNC_08008ad4(local_16c);\n      local_110 = *(int **)(iVar3 + 4);\n      piVar24 = (int *)find_first_set_bit_index_08005e40(local_110);\n      local_104 = piVar24;\n      iVar3 = FUNC_08008ad4(puVar29);\n      local_108 = *(byte **)(iVar3 + 8);\n      if (piVar24 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 0x400);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2a:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2b:\n      local_f5 = 0x2b;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x2d:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\nLAB_08006602:\n      piVar25 = (int *)((uint)piVar25 | 4);\n      goto LAB_08005f4a;\n    case (int *)0x2e:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x2a) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (piVar24 + -0xc < (int *)0xa) {\n        piVar27 = (int *)((int)(piVar24 + -0xc) + (int)piVar27 * 10);\n        piVar24 = (int *)(uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case (int *)0x30:\n      piVar25 = (int *)((uint)piVar25 | 0x80);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x31:\n    case (int *)0x32:\n    case (int *)0x33:\n    case (int *)0x34:\n    case (int *)0x35:\n    case (int *)0x36:\n    case (int *)0x37:\n    case (int *)0x38:\n    case (int *)0x39:\n      goto switchD_08005f58_caseD_31;\n    case (int *)0x41:\n    case (int *)0x45:\n    case (int *)0x46:\n    case (int *)0x47:\n    case (int *)0x61:\n    case (int *)0x65:\n    case (int *)0x66:\n    case (int *)0x67:\n      puVar29 = (undefined4 *)((int)local_154 + 7U & 0xfffffff8);\n      uVar10 = *puVar29;\n      local_12c = puVar29[1];\n      local_168 = (int *)(local_12c & 0x7fffffff);\n      local_154 = (int **)(puVar29 + 2);\n      local_128 = uVar10;\n      iVar3 = check_params_08001170(uVar10,local_168,0xffffffff,DAT_08006724);\n      if ((iVar3 == 0) &&\n         (iVar3 = check_and_return_param_080009c0(uVar10,local_168,0xffffffff,DAT_08006724), iVar3 == 0)) {\n        iVar3 = check_null_termination_080009ac(local_128,local_12c,local_124,local_120);\n        piVar23 = (int *)PTR_DAT_08006728;\n        piVar27 = (int *)PTR_DAT_0800672c;\n        if (iVar3 == 0) {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (piVar24 < (int *)0x48) {\n          piVar23 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar25 = (int *)((uint)piVar25 & 0xffffff7f);\n        local_158 = (int **)0x3;\n        local_13c = (int **)0x0;\n        piVar22 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      piVar22 = (int *)check_params_08001170(local_128,local_12c,local_128,local_12c);\n      if (piVar22 != (int *)0x0) {\n        piVar23 = (int *)PTR_DAT_08007898;\n        piVar27 = (int *)PTR_DAT_0800789c;\n        if ((int)local_12c < 0) {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        goto LAB_08006524;\n      }\n      piVar16 = piVar27;\n      if (piVar24 == (int *)0x61) {\n        uVar12 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar12,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          piVar25 = (int *)((uint)piVar25 | 2);\n        }\n        else {\n          param_3 = (int *)allocate_and_return_pointer_08008af8(local_16c,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar13 = *(ushort *)(local_160 + 3) | 0x40;\n            *(ushort *)(local_160 + 3) = uVar13;\n            goto LAB_0800604e;\n          }\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          piVar25 = (int *)((uint)piVar25 | 2);\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        piVar27 = piVar16;\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = (int *)0x2d;\n          uVar19 = local_12c + 0x80000000;\n          piVar16 = piVar27;\n        }\n        else {\n          local_144 = (int *)0x0;\n          uVar19 = local_12c;\n        }\n        local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n        local_158 = (int **)local_128;\n        if (piVar24 == (int *)0x61) {\n          uVar33 = calculate_floating_point_value_080096e0(local_128,uVar19,&local_f0);\n          local_150 = calculate_double_precision_floating_point_value_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = check_if_input_is_not_null_08000998((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                               local_120);\n          if (iVar3 != 0) {\n            local_f0 = (int *)0x1;\n          }\n          local_158 = (int **)PTR_s_0123456789abcdef_08007888;\n          local_13c = ppiVar2;\n          local_138 = piVar28;\n          local_134 = piVar24;\n          local_130 = piVar16;\n          local_100 = piVar25;\n          local_fc = param_3;\n          puVar20 = PTR_s_0123456789abcdef_08007888;\n          uVar33 = local_150;\n          goto LAB_080072ba;\n        }\n        piVar27 = piVar16;\n        if (piVar24 == (int *)0x41) {\n          uVar33 = calculate_floating_point_value_080096e0(local_128,uVar19,&local_f0);\n          local_150 = calculate_double_precision_floating_point_value_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = check_if_input_is_not_null_08000998((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                               local_120);\n          if (iVar3 == 0) {\n            local_158 = (int **)PTR_s_0123456789ABCDEF_0800739c;\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar16;\n            local_100 = piVar25;\n            local_fc = param_3;\n            puVar20 = PTR_s_0123456789ABCDEF_0800739c;\n            uVar33 = local_150;\n          }\n          else {\n            local_f0 = (int *)0x1;\n            local_158 = (int **)PTR_s_0123456789ABCDEF_08007894;\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar16;\n            local_100 = piVar25;\n            local_fc = param_3;\n            puVar20 = PTR_s_0123456789ABCDEF_08007894;\n            uVar33 = local_150;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (piVar24 == (int *)0x41) {\n          uVar12 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = (int *)((uint)piVar25 | 0x100);\n        local_148 = piVar22;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar16 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if (((uint)piVar24 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar16 = (int *)0x1;\n            local_148 = piVar27;\n          }\n          goto LAB_0800724a;\n        }\n        uVar19 = local_12c;\n        local_144 = piVar22;\n        if ((int)local_12c < 0) goto LAB_08007414;\n      }\n      local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n      piStack_184 = piVar27;\n      local_158 = (int **)local_128;\n      if (piVar24 == (int *)0x66) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)parse_float_080079e8(local_16c,local_180,local_128,uVar19);\n        piVar22 = (int *)((int)piVar23 + (int)piVar27);\n        local_150._0_4_ = piVar27;\nLAB_0800764c:\n        if ((*(byte *)piVar23 == 0x30) &&\n           (iVar3 = check_if_input_is_not_null_08000998(local_158,uVar19,local_124,local_120), iVar3 == 0)) {\n          local_f0 = (int *)(1 - (int)(int *)local_150);\n        }\n        piVar22 = (int *)((int)piVar22 + (int)local_f0);\n      }\n      else if (piVar24 == (int *)0x46) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)parse_float_080079e8(local_16c,local_180,local_128,uVar19);\n        local_150._0_4_ = piVar27;\nLAB_08007760:\n        piVar22 = (int *)((int)piVar23 + (int)(int *)local_150);\n        if (piVar24 == (int *)0x46) goto LAB_0800764c;\n      }\n      else {\n        local_178 = &local_e0;\n        local_150._0_4_ = piVar27;\n        if (local_168 == (int *)0x45) {\n          local_150._0_4_ = (int *)((int)piVar27 + 1);\n        }\n        local_188 = 2;\n        piStack_184 = (int *)local_150;\n        local_180 = &local_f0;\n        puStack_17c = auStack_ec;\n        piVar23 = (int *)parse_float_080079e8(local_16c,local_180,local_128,uVar19);\n        piVar16 = local_e0;\n        if (piVar24 == (int *)0x67) {\n          if (((uint)piVar25 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (piVar24 == (int *)0x47) {\n          if (((uint)piVar25 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar22 = (int *)((int)(int *)local_150 + (int)piVar23);\n      }\n      iVar3 = check_if_input_is_not_null_08000998(local_158,uVar19,local_124,local_120);\n      piVar16 = piVar22;\n      if (iVar3 == 0) {\n        for (; piVar16 = local_e0, local_e0 < piVar22; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)piVar16 - (int)piVar23);\n      goto LAB_08006cb0;\n    case (int *)0x43:\n    case (int *)0x63:\n      piVar16 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar22 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (int **)0x1;\n      local_8c = SUB41(piVar27,0);\n      piVar23 = (int *)&local_8c;\n      goto LAB_08006298;\n    case (int *)0x44:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_08006102;\n    case (int *)0x4c:\n      piVar25 = (int *)((uint)piVar25 | 8);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x4f:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n    case (int *)0x6f:\n      if (((uint)piVar25 & 0x20) == 0) {\n        ppiVar14 = local_154 + 1;\n        if (((uint)piVar25 & 0x10) == 0) {\n          if (((uint)piVar25 & 0x40) == 0) {\n            if (((uint)piVar25 & 0x200) == 0) goto LAB_08006be2;\n            piVar22 = (int *)(uint)*(byte *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n          else {\n            piVar22 = (int *)(uint)*(ushort *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar22 = *local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\n        ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar22 = *ppiVar14;\n        piVar16 = ppiVar14[1];\n        local_154 = ppiVar14 + 2;\n      }\n      iVar3 = 0;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n      break;\n    case (int *)0x53:\n    case (int *)0x73:\n      local_f5 = 0;\n      piVar22 = *local_154;\n      ppiVar14 = local_154 + 1;\n      if (piVar22 == (int *)0x0) {\n        piVar16 = piVar22;\n        piVar23 = (int *)PTR_s__null__08007084;\n        local_168 = piVar27;\n        local_158 = (int **)piVar27;\n        local_154 = ppiVar14;\n        local_148 = piVar22;\n        local_13c = (int **)piVar22;\n        local_134 = piVar22;\n        local_130 = piVar22;\n        if ((int *)0x5 < piVar27) {\n          local_158 = (int **)0x6;\n          local_168 = (int *)local_158;\n        }\n        goto LAB_08006538;\n      }\n      piVar23 = piVar22;\n      if (piVar27 == (int *)0xffffffff) {\n        local_158 = (int **)find_first_set_bit_index_08005e40(piVar22);\n      }\n      else {\n        local_148 = (int *)find_byte_sequence_0800901c(piVar22,0,piVar27);\n        if (local_148 == (int *)0x0) {\n          piVar16 = (int *)(uint)local_f5;\n          piVar22 = local_148;\n          local_168 = piVar27;\n          local_158 = (int **)piVar27;\n          local_154 = ppiVar14;\n          local_13c = (int **)local_148;\n          local_134 = local_148;\n          local_130 = local_148;\n          goto LAB_08006538;\n        }\n        local_158 = (int **)((int)local_148 - (int)piVar22);\n      }\n      local_148 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      piVar16 = (int *)(uint)local_f5;\n      piVar22 = (int *)0x0;\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      local_154 = ppiVar14;\n      goto LAB_08006538;\n    case (int *)0x55:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      iVar3 = 1;\n      local_154 = ppiVar14 + 2;\n      break;\n    case (int *)0x58:\n      local_11c = PTR_s_0123456789ABCDEF_08006730;\n      if (((uint)piVar25 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_080061be;\n    case (int *)0x64:\n    case (int *)0x69:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bcc:\n        piVar22 = *local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(int)*(short *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bcc;\n        piVar22 = (int *)(int)*(char *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\nLAB_08006102:\n      if ((int)piVar16 < 0) {\n        bVar31 = piVar22 != (int *)0x0;\n        piVar22 = (int *)-(int)piVar22;\n        piVar16 = (int *)(-(int)piVar16 - (uint)bVar31);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar3 = 1;\n        iVar8 = 1;\n        piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n        if (((uint)piVar22 | (uint)piVar16) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      piVar21 = piVar25;\n      if (piVar16 != (int *)0x0 || (int *)0x9 < piVar22) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case (int *)0x68:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x68) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar25 = (int *)((uint)piVar25 | 0x200);\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        piVar25 = (int *)((uint)piVar25 | 0x40);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x6a:\n    case (int *)0x71:\n      piVar25 = (int *)((uint)piVar25 | 0x20);\n    case (int *)0x74:\n    case (int *)0x7a:\nswitchD_08005f58_caseD_74:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case (int *)0x6e:\n      ppiVar14 = local_154 + 1;\n      ppbVar15 = (byte **)*local_154;\n      local_154 = ppiVar14;\n      if (((uint)piVar25 & 0x20) != 0) {\n        *ppbVar15 = local_164;\n        ppbVar15[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) != 0) {\n          *(short *)ppbVar15 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if (((uint)piVar25 & 0x200) != 0) {\n          *(char *)ppbVar15 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar15 = local_164;\n      goto LAB_0800620e;\n    case (int *)0x70:\n      local_f4 = 0x7830;\n      local_11c = PTR_s_0123456789abcdef_08006434;\n      piVar22 = *local_154;\n      piVar25 = (int *)((uint)piVar25 | 2);\n      piVar16 = (int *)0x0;\n      iVar3 = 2;\n      piVar24 = (int *)0x78;\n      local_154 = local_154 + 1;\n      break;\n    case (int *)0x75:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bf2:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(uint)*(ushort *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bf2;\n        piVar22 = (int *)(uint)*(byte *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      break;\n    case (int *)0x78:\n      local_11c = PTR_s_0123456789abcdef_08006434;\n      if (((uint)piVar25 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar14 = local_154 + 1;\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) == 0) {\n          if (((uint)piVar25 & 0x200) == 0) goto LAB_08006bbc;\n          piVar22 = (int *)(uint)*(byte *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n        else {\n          piVar22 = (int *)(uint)*(ushort *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        local_154 = ppiVar14;\n      }\nLAB_080061be:\n      if ((((uint)piVar25 & 1) != 0) && (((uint)piVar22 | (uint)piVar16) != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 2);\n        local_f4 = CONCAT11((char)piVar24,0x30);\n      }\n      iVar3 = 2;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      if (iVar3 != 1) goto LAB_08006136;\nLAB_08006980:\n      piVar21 = piVar25;\n      if (piVar16 == (int *)0x0 && piVar22 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar32 = CONCAT44(piVar16,piVar22);\n      piVar23 = (int *)(&bStack_2a + 2);\n      piVar22 = (int *)0x0;\n      pbVar26 = local_108;\n      local_168 = piVar23;\n      local_158 = ppiVar2;\n      local_150._0_4_ = piVar25;\n      local_148 = piVar24;\n      do {\n        iVar3 = (int)((ulonglong)lVar32 >> 0x20);\n        uVar19 = (uint)lVar32;\n        cVar6 = '\\n';\n        calculate_result_080011ec(uVar19,iVar3,10,0);\n        *(byte *)((int)piVar23 + -1) = cVar6 + 0x30;\n        piVar22 = (int *)((int)piVar22 + 1);\n        piVar23 = (int *)((int)piVar23 + -1);\n        if ((((((uint)piVar25 & 0x400) != 0) && (piVar22 == (int *)(uint)*pbVar26)) &&\n            (piVar22 != (int *)0xff)) && (iVar3 != 0 || 9 < uVar19)) {\n          piVar23 = (int *)((int)piVar23 - (int)local_104);\n          copy_string_08009768(piVar23,local_110,local_104);\n          piVar22 = (int *)(uint)pbVar26[1];\n          if (piVar22 != (int *)0x0) {\n            pbVar26 = pbVar26 + 1;\n            piVar22 = (int *)0x0;\n          }\n        }\n        lVar32 = calculate_result_080011ec(uVar19,iVar3,10,0);\n      } while (lVar32 != 0);\n      piVar24 = local_148;\n      piVar25 = (int *)local_150;\n      ppiVar2 = local_158;\n      local_158 = (int **)((int)local_168 - (int)piVar23);\n      local_138 = piVar22;\n      local_108 = pbVar26;\n    }\n    else {\n      piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n      iVar8 = iVar3;\n      if (((uint)piVar22 | (uint)piVar16) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar3 == 0) {\n            local_158 = (int **)((uint)piVar25 & 1);\n            if (local_158 == (int **)0x0) {\n              piVar23 = (int *)(&bStack_2a + 2);\n              piVar25 = piVar21;\n            }\n            else {\n              piVar23 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n              piVar25 = piVar21;\n            }\n          }\n          else {\n            piVar23 = (int *)(&bStack_2a + 2);\n            piVar25 = piVar21;\n            local_158 = (int **)piVar27;\n          }\n        }\n        else {\n          piVar25 = piVar21;\n          if (iVar3 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar22 + '0';\n          piVar23 = (int *)(&bStack_2a + 1);\n          local_158 = (int **)0x1;\n          piVar25 = piVar21;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar3 = iVar8;\n        piVar25 = piVar21;\n        if (iVar8 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar3 == 2) {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = (int *)((uint)piVar22 >> 4 | (int)piVar16 << 0x1c);\n            piVar16 = (int *)((uint)piVar16 >> 4);\n            piVar23 = (int *)((int)piVar23 + -1);\n            *(undefined *)piVar23 = local_11c[(uint)piVar22 & 0xf];\n            piVar22 = piVar21;\n          } while (((uint)piVar21 | (uint)piVar16) != 0);\n        }\n        else {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = piVar23;\n            piVar9 = (int *)((uint)piVar22 >> 3 | (int)piVar16 << 0x1d);\n            piVar16 = (int *)((uint)piVar16 >> 3);\n            iVar3 = ((uint)piVar22 & 7) + 0x30;\n            *(byte *)((int)piVar21 + -1) = (byte)iVar3;\n            piVar23 = (int *)((int)piVar21 + -1);\n            piVar22 = piVar9;\n          } while (((uint)piVar9 | (uint)piVar16) != 0);\n          if ((((uint)piVar25 & 1) != 0) && (iVar3 != 0x30)) {\n            piVar23 = (int *)((int)piVar21 + -2);\n            *(byte *)((int)piVar21 + -2) = 0x30;\n            local_158 = (int **)(&bStack_2a + (2 - (int)piVar23));\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (int **)(&bStack_2a + (2 - (int)piVar23));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  piVar28 = local_160;\n  if (local_d0 == (int *)0x0) {\nLAB_0800604a:\n    uVar13 = *(ushort *)(local_160 + 3);\n  }\n  else {\n    copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n    uVar13 = *(ushort *)(piVar28 + 3);\n  }\nLAB_0800604e:\n  if ((uVar13 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (piVar24 == (int *)0x6c) {\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    piVar25 = (int *)((uint)piVar25 | 0x20);\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    piVar25 = (int *)((uint)piVar25 | 0x10);\n  }\n  goto LAB_08005f4a;\n  while( true ) {\n    iVar8 = check_if_input_is_not_null_08000998((int)uVar33,uVar10,local_124,local_120);\n    if (iVar8 != 0) break;\nLAB_080072ba:\n    piVar22 = param_3;\n    piVar16 = (int *)((int)piVar16 + -1);\n    uVar33 = calculate_double_precision_floating_point_value_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,DAT_080073a0);\n    iVar3 = convert_to_fixed_point_0800119c();\n    uVar34 = bit_shift_and_concatenate_080003f4();\n    uVar33 = floating_point_addition_08000158((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar34,\n                          (int)((ulonglong)uVar34 >> 0x20));\n    uVar10 = (undefined4)((ulonglong)uVar33 >> 0x20);\n    param_3 = (int *)((int)piVar22 + 1);\n    *(undefined *)piVar22 = puVar20[iVar3];\n    if (piVar16 == (int *)0xffffffff) break;\n  }\n  piVar23 = local_fc;\n  piVar25 = local_100;\n  piVar27 = local_130;\n  piVar24 = local_134;\n  piVar28 = local_138;\n  ppiVar2 = local_13c;\n  local_13c = (int **)piVar16;\n  local_134 = piVar22;\n  local_150 = uVar33;\n  iVar8 = check_if_string_terminated_080009e8((int)uVar33,uVar10,0,DAT_080073a4);\n  if (iVar8 == 0) {\n    iVar8 = check_if_input_is_not_null_08000998((int *)local_150,local_150._4_4_,0,DAT_080073a4);\n    if ((iVar8 != 0) && (iVar3 << 0x1f < 0)) goto LAB_0800748a;\n    if (-1 < (int)local_13c) {\n      piVar16 = (int *)((byte *)((int)local_13c + 1) + (int)param_3);\n      piVar22 = param_3;\n      do {\n        param_3 = (int *)((int)piVar22 + 1);\n        *(byte *)piVar22 = 0x30;\n        piVar22 = param_3;\n      } while (piVar16 != param_3);\n    }\n  }\n  else {\nLAB_0800748a:\n    bVar1 = *(byte *)((int)local_158 + 0xf);\n    bVar7 = *(byte *)piVar22;\n    piVar22 = param_3;\n    local_e0 = local_134;\n    while (bVar1 == bVar7) {\n      *(byte *)((int)piVar22 + -1) = 0x30;\n      bVar7 = *(byte *)((int)local_e0 + -1);\n      piVar22 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar7 == 0x39) {\n      bVar7 = *(byte *)((int)local_158 + 10);\n    }\n    else {\n      bVar7 = bVar7 + 1;\n    }\n    *(byte *)((int)piVar22 + -1) = bVar7;\n  }\n  local_138 = (int *)((int)param_3 - (int)piVar23);\nLAB_08006cb0:\n  local_134 = local_f0;\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0 + 3) < 0 == SCARRY4((int)local_f0,3)) &&\n       ((int)local_f0 <= (int)piVar27)) {\n      if ((int)local_f0 < (int)local_138) {\n        local_158 = (int **)((int)local_138 + (int)local_118);\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (int **)((int)local_158 + (1 - (int)local_f0));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        piVar24 = (int *)0x67;\n      }\n      else {\n        if ((int)piVar25 << 0x1f < 0) {\n          local_158 = (int **)((int)local_f0 + (int)local_118);\n        }\n        else {\n          local_158 = (int **)local_f0;\n        }\n        if (-1 < (int)piVar25 << 0x15) {\n          piVar24 = (int *)0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074fc;\n        }\n        piVar24 = (int *)0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    piVar24 = (int *)((int)piVar24 + -2);\n    local_168 = (int *)((uint)piVar24 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8 = (char)piVar24;\n    if (local_168 == (int *)0x41) {\n      local_e8 = local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0 + -1);\n    if ((int)piVar27 < 0) {\n      local_e7 = 0x2d;\n      local_f0 = (int *)(1 - (int)local_f0);\n    }\n    else {\n      local_e7 = 0x2b;\n      local_f0 = piVar27;\n    }\n    if ((int)local_f0 < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e6[0] = 0x30;\n        pcVar18 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar18 = (char)local_f0 + '0';\n      pcVar18 = pcVar18 + 1;\n    }\n    else {\n      pbVar30 = abStack_dc + 3;\n      pbVar26 = pbVar30;\n      do {\n        pbVar5 = pbVar26;\n        piVar22 = (int *)((ulonglong)DAT_08007890 * ZEXT48(local_f0) >> 0x23);\n        pbVar5[-1] = (char)local_f0 + (char)piVar22 * -10 + 0x30;\n        pbVar26 = pbVar5 + -1;\n        local_f0 = piVar22;\n      } while ((int *)0x9 < piVar22);\n      uVar19 = (uint)(piVar22 + 0xc) & 0xff;\n      pbVar5[-2] = (byte)uVar19;\n      if (pbVar5 + -2 < pbVar30) {\n        pbVar5 = pbVar26;\n        puVar20 = (undefined *)((int)&local_e8 + 2);\n        while( true ) {\n          *puVar20 = (char)uVar19;\n          if (pbVar30 == pbVar5) break;\n          uVar19 = (uint)*pbVar5;\n          pbVar5 = pbVar5 + 1;\n          puVar20 = puVar20 + 1;\n        }\n        pcVar18 = (char *)(((int)&local_188 * 2 - (int)pbVar26) + 0x152);\n      }\n      else {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar18 + -(int)&local_e8);\n    local_158 = (int **)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)piVar25 << 0x1f < 0)) {\n      local_158 = (int **)((int)local_158 + (int)local_118);\n    }\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    piVar25 = (int *)((uint)piVar25 & 0xfffffbff | 0x100);\n    local_f0 = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0 < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_168 = (int *)0x1;\n        local_158 = (int **)0x1;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (int **)((byte *)((int)local_118 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      piVar25 = local_140;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_158 = (int **)local_f0;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (int **)((byte *)((int)local_f0 + (int)local_118) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)piVar25 << 0x15) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      uVar19 = (uint)*local_108;\n      while (uVar19 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar19) goto LAB_08007524;\n          uVar4 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar19);\n          if (uVar4 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = (int *)((int)local_130 + 1);\n          uVar19 = uVar4;\n          if (uVar4 == 0xff) goto LAB_08007524;\n        }\n        local_13c = (int **)((int)local_13c + 1);\n      }\nLAB_08007524:\n      local_158 = (int **)((int)local_158 + (int)local_104 * (int)((int)local_130 + (int)local_13c))\n      ;\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      piVar25 = local_140;\n    }\n  }\n  if (local_144 == (int *)0x0) {\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = local_144;\nLAB_08006538:\n    if (piVar16 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar16 = (int *)0x2d;\n    piVar22 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n  }\nLAB_08006298:\n  piVar27 = local_160;\n  puVar29 = local_16c;\n  local_150._0_4_ = (int *)((uint)piVar25 & 2);\n  if ((int *)local_150 != (int *)0x0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  local_144 = (int *)((uint)piVar25 & 0x84);\n  if ((local_144 == (int *)0x0) &&\n     (piVar21 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar21)) {\n    if (0x10 < (int)piVar21) {\n      piVar16 = (int *)0x10;\n      local_100 = piVar24;\n      do {\n        piVar9 = piVar21;\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)PTR_s__0000000000000000Infinity_08006438;\n        ppiVar2[1] = piVar16;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n          piVar24 = local_100;\n        }\n        else {\n          local_140 = piVar16;\n          iVar3 = copy_and_update_memory_block_080097cc(puVar29,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = local_140;\n          piVar24 = local_100;\n        }\n        piVar21 = piVar9 + -4;\n        local_100 = piVar24;\n      } while (0x10 < (int)piVar21);\n      piVar21 = piVar9 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar21);\n    *ppiVar2 = (int *)PTR_s__0000000000000000Infinity_08006438;\n    ppiVar2[1] = piVar21;\n    if ((int)local_d4 < 8) {\n      piVar16 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar16 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar16 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 1);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((int *)local_150 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 2);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  puVar20 = PTR_s_0000000000000000Infinity_08006a54;\n  if ((local_144 == (int *)0x80) &&\n     (piVar16 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar16)) {\n    if (0x10 < (int)piVar16) {\n      do {\n        while( true ) {\n          piVar21 = piVar16;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)puVar20;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = copy_and_update_memory_block_080097cc(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = piVar21 + -4;\n          if ((int)(piVar21 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar16 = piVar21 + -4;\n      } while (0x10 < (int)(piVar21 + -4));\nLAB_08006882:\n      piVar16 = piVar21 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar16);\n    *ppiVar2 = (int *)puVar20;\n    ppiVar2[1] = piVar16;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  puVar20 = PTR_s_0000000000000000Infinity_0800643c;\n  piVar22 = (int *)((int)piVar22 - (int)local_158);\n  if (0 < (int)piVar22) {\n    piVar16 = (int *)PTR_s_0000000000000000Infinity_08007088;\n    if (0x10 < (int)piVar22) {\n      do {\n        while( true ) {\n          piVar16 = piVar22;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)puVar20;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = copy_and_update_memory_block_080097cc(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar22 = piVar16 + -4;\n          if ((int)(piVar16 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar22 = piVar16 + -4;\n      } while (0x10 < (int)(piVar16 + -4));\nLAB_080063d2:\n      piVar22 = piVar16 + -4;\n      piVar16 = (int *)puVar20;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar22);\n    *ppiVar2 = piVar16;\n    ppiVar2[1] = piVar22;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_d0;\n  if (((uint)piVar25 & 0x100) == 0) {\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)local_158);\n    *ppiVar2 = piVar23;\n    ppiVar2[1] = (int *)local_158;\n    if ((int)local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else if ((int)piVar24 < 0x66) {\n    local_158 = (int **)((int)local_d0 + 1);\n    piVar27 = (int *)((int)local_d4 + 1);\n    ppiVar14 = ppiVar2 + 2;\n    local_d0 = (int *)local_158;\n    if (((int)local_138 < 2) && (((uint)piVar25 & 1) == 0)) {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)piVar27 < 8) {\n        local_150._0_4_ = (int *)((int)local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = piVar27;\n        iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        local_150._0_4_ = (int *)((int)local_d4 + 1);\n        ppiVar14 = local_cc;\n        local_158 = (int **)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = piVar27;\n      if (7 < (int)piVar27) {\n        iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar14 = local_cc;\n        local_158 = (int **)local_d0;\n      }\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_158 = (int **)((int)local_158 + (int)local_118);\n      *ppiVar14 = local_114;\n      ppiVar14[1] = local_118;\n      local_d0 = (int *)local_158;\n      if ((int)local_d4 < 8) {\n        ppiVar17 = ppiVar14 + 2;\n      }\n      else {\n        iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar17 = local_cc;\n      }\n      piVar24 = local_d4;\n      local_150._0_4_ = (int *)((int)local_d4 + 1);\n      piVar22 = (int *)((int)local_138 + -1);\n      ppiVar11 = ppiVar17 + 2;\n      local_158 = (int **)local_d0;\n      local_144 = (int *)local_150;\n      iVar3 = check_if_input_is_not_null_08000998(local_128,local_12c,local_124,local_120);\n      piVar27 = local_160;\n      puVar29 = local_16c;\n      puVar20 = PTR_s_0000000000000000Infinity_08006d94;\n      if (iVar3 == 0) {\n        local_158 = (int **)((int)local_158 + (int)piVar22);\n        *ppiVar17 = (int *)((int)piVar23 + 1);\n        ppiVar17[1] = piVar22;\n        local_d0 = (int *)local_158;\n        if ((int)(int *)local_150 < 8) {\n          local_150._0_4_ = (int *)((int)piVar24 + 2);\n          ppiVar14 = ppiVar11;\n          ppiVar2 = ppiVar17 + 4;\n        }\n        else {\nLAB_08006d9c:\n          local_158 = (int **)local_d0;\n          local_d4 = (int *)local_150;\n          iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          local_150._0_4_ = (int *)((int)local_d4 + 1);\n          local_158 = (int **)local_d0;\n          ppiVar14 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar14 = ppiVar17;\n        ppiVar2 = ppiVar11;\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)local_158;\n          piVar24 = (int *)PTR_s_0000000000000000Infinity_0800788c;\n          local_d4 = local_144;\n          if (0x10 < (int)piVar22) {\n            while( true ) {\n              local_d0 = local_d0 + 4;\n              *ppiVar17 = (int *)puVar20;\n              ppiVar17[1] = (int *)0x10;\n              if ((int)local_d4 < 8) {\n                ppiVar17 = ppiVar17 + 2;\n              }\n              else {\n                iVar3 = copy_and_update_memory_block_080097cc(puVar29,piVar27,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar17 = local_cc;\n              }\n              piVar22 = piVar22 + -4;\n              if ((int)piVar22 < 0x11) break;\n              local_d4 = (int *)((int)local_d4 + 1);\n            }\n            local_150._0_4_ = (int *)((int)local_d4 + 1);\n            ppiVar11 = ppiVar17 + 2;\n            piVar24 = (int *)puVar20;\n            local_158 = (int **)local_d0;\n          }\n          *ppiVar17 = piVar24;\n          ppiVar17[1] = piVar22;\n          local_158 = (int **)((int)local_158 + (int)piVar22);\n          local_d0 = (int *)local_158;\n          if (7 < (int)(int *)local_150) goto LAB_08006d9c;\n          local_150._0_4_ = (int *)((int)(int *)local_150 + 1);\n          ppiVar2 = ppiVar11 + 2;\n          ppiVar14 = ppiVar11;\n        }\n      }\n    }\n    ppiVar14[1] = local_10c;\n    local_d0 = (int *)((int)local_158 + (int)local_10c);\n    local_d4 = (int *)local_150;\n    *ppiVar14 = (int *)&local_e8;\n    piVar27 = local_d0;\n    if (7 < (int)(int *)local_150) {\n      iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else {\n    iVar3 = check_if_input_is_not_null_08000998(local_128,local_12c,local_124,local_120);\n    if (iVar3 == 0) {\n      if ((int)local_f0 < 1) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)piVar27 + 1);\n        *ppiVar2 = (int *)PTR_DAT_08006d98;\n        ppiVar2[1] = (int *)0x1;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0 != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)local_d0 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          puVar29 = local_16c;\n          puVar20 = PTR_s_0000000000000000Infinity_0800788c;\n          if ((int)local_f0 < 0) {\n            piVar27 = (int *)-(int)local_f0;\n            if ((int)(local_f0 + 4) < 0 != SCARRY4((int)local_f0,0x10)) {\n              do {\n                local_d4 = (int *)((int)local_d4 + 1);\n                local_d0 = local_d0 + 4;\n                *ppiVar2 = (int *)puVar20;\n                ppiVar2[1] = (int *)0x10;\n                if ((int)local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar3 = copy_and_update_memory_block_080097cc(puVar29,local_160,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)local_d0 + (int)piVar27);\n            *ppiVar2 = (int *)puVar20;\n            ppiVar2[1] = piVar27;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = (int *)((int)local_d0 + (int)local_138);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar24 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar24 = local_138;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar24);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = piVar24;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        puVar20 = PTR_s_0000000000000000Infinity_08006d94;\n        piVar22 = local_134;\n        if (-1 < (int)piVar24) {\n          piVar22 = (int *)((int)local_134 - (int)piVar24);\n        }\n        piVar24 = (int *)PTR_s_0000000000000000Infinity_0800788c;\n        if (0 < (int)piVar22) {\n          for (; 0x10 < (int)piVar22; piVar22 = piVar22 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = piVar27 + 4;\n            *ppiVar2 = (int *)puVar20;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_update_memory_block_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n            piVar24 = (int *)puVar20;\n          }\n          local_d4 = (int *)((int)local_d4 + 1);\n          piVar27 = (int *)((int)piVar27 + (int)piVar22);\n          *ppiVar2 = piVar24;\n          ppiVar2[1] = piVar22;\n          local_d0 = piVar27;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar22 = local_104;\n        piVar24 = local_160;\n        puVar29 = local_16c;\n        puVar20 = PTR_s_0000000000000000Infinity_08007398;\n        piVar16 = (int *)((int)local_134 + (int)piVar23);\n        if (((uint)piVar25 & 0x400) != 0) {\n          local_158 = (int **)((int)piVar23 + (int)local_138);\n          pbVar26 = local_108;\n          local_150._0_4_ = piVar28;\n          local_144 = piVar25;\n          local_140 = piVar23;\n          if (local_130 == (int *)0x0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != (int **)0x0) goto LAB_0800717e;\n          pbVar26 = pbVar26 + -1;\n          local_130 = (int *)((int)local_130 + -1);\n          do {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)piVar27 + (int)piVar22);\n            *ppiVar2 = local_110;\n            ppiVar2[1] = piVar22;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_update_memory_block_080097cc(puVar29,piVar24,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = (int *)(uint)*pbVar26;\n            piVar28 = (int *)((int)local_158 - (int)piVar16);\n            if ((int)piVar27 <= (int)(int *)((int)local_158 - (int)piVar16)) {\n              piVar28 = piVar27;\n            }\n            if (0 < (int)piVar28) {\n              local_d0 = (int *)((int)local_d0 + (int)piVar28);\n              local_d4 = (int *)((int)local_d4 + 1);\n              *ppiVar2 = piVar16;\n              ppiVar2[1] = piVar28;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = copy_and_update_memory_block_080097cc(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar27 = (int *)(uint)*pbVar26;\n              }\n            }\n            piVar25 = piVar27;\n            if (-1 < (int)piVar28) {\n              piVar25 = (int *)((int)piVar27 - (int)piVar28);\n            }\n            if (0 < (int)piVar25) {\n              for (; 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n                while( true ) {\n                  local_d4 = (int *)((int)local_d4 + 1);\n                  local_d0 = local_d0 + 4;\n                  *ppiVar2 = (int *)puVar20;\n                  ppiVar2[1] = (int *)0x10;\n                  if ((int)local_d4 < 8) break;\n                  iVar3 = copy_and_update_memory_block_080097cc(puVar29,piVar24,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  piVar25 = piVar25 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar25 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = (int *)((int)local_d4 + 1);\n              local_d0 = (int *)((int)local_d0 + (int)piVar25);\n              *ppiVar2 = (int *)puVar20;\n              ppiVar2[1] = piVar25;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = copy_and_update_memory_block_080097cc(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = local_cc;\n              }\n            }\n            piVar16 = (int *)((int)piVar16 + (int)piVar27);\n            piVar27 = local_d0;\n            if (local_130 != (int *)0x0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == (int **)0x0) {\n              piVar23 = local_140;\n              piVar25 = local_144;\n              piVar28 = (int *)local_150;\n              local_108 = pbVar26;\n              if ((int *)((int)local_140 + (int)local_138) <= piVar16) {\n                piVar16 = (int *)((int)local_140 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = (int **)((int)local_13c + -1);\n          } while( true );\n        }\n        if (((int)local_f0 < (int)local_138) || (((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)piVar27 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar24 = (int *)((int)local_138 - (int)local_f0);\n        piVar22 = (int *)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16);\n        if ((int)piVar24 <= (int)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16)) {\n          piVar22 = piVar24;\n        }\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar22);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar16;\n          ppiVar2[1] = piVar22;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar24 = (int *)((int)local_138 - (int)local_f0);\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        puVar20 = PTR_s_0000000000000000Infinity_08007088;\n        if (-1 < (int)piVar22) {\n          piVar24 = (int *)((int)piVar24 - (int)piVar22);\n        }\n        piVar22 = (int *)PTR_s_0000000000000000Infinity_0800788c;\n        if (0 < (int)piVar24) {\n          for (; local_d0 = piVar27, 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)puVar20;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_update_memory_block_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n            piVar22 = (int *)puVar20;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_d0 = (int *)((int)piVar27 + 1);\n      *ppiVar2 = (int *)PTR_DAT_08006a50;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0 < (int)local_138) || (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)local_118);\n        *ppiVar2 = local_114;\n        ppiVar2[1] = local_118;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        puVar20 = PTR_s_0000000000000000Infinity_08006a54;\n        piVar24 = (int *)((int)local_138 + -1);\n        piVar27 = local_d0;\n        piVar22 = (int *)PTR_s_0000000000000000Infinity_0800788c;\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)puVar20;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_update_memory_block_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar22 = (int *)puVar20;\n          }\nLAB_08007014:\n          local_d0 = (int *)((int)local_d0 + (int)piVar24);\n          *ppiVar2 = piVar22;\n          ppiVar2[1] = piVar24;\njoined_r0x08006a1c:\n          local_d4 = (int *)((int)local_d4 + 1);\n          if (7 < (int)local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  piVar24 = local_160;\n  puVar29 = local_16c;\n  if ((((uint)piVar25 & 4) != 0) &&\n     (piVar25 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar25)) {\n    for (; local_d0 = piVar27, 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n      while( true ) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)PTR_s__0000000000000000Infinity_08006720;\n        ppiVar2[1] = (int *)0x10;\n        if ((int)local_d4 < 8) break;\n        iVar3 = copy_and_update_memory_block_080097cc(puVar29,piVar24,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        piVar25 = piVar25 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar25 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar25);\n    *ppiVar2 = (int *)PTR_s__0000000000000000Infinity_08006720;\n    ppiVar2[1] = piVar25;\n    piVar27 = local_d0;\n    if ((7 < (int)local_d4) &&\n       (iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8), piVar27 = local_d0, iVar3 != 0))\n    goto LAB_0800603e;\n  }\n  piVar24 = local_15c;\n  if ((int)local_15c < (int)local_168) {\n    piVar24 = local_168;\n  }\n  local_164 = local_164 + (int)piVar24;\n  if ((piVar27 == (int *)0x0) || (iVar3 = copy_and_update_memory_block_080097cc(local_16c,local_160,&local_d8), iVar3 == 0))\n  {\n    local_d4 = (int *)0x0;\n    if (local_148 != (int *)0x0) {\n      allocate_memory_block_080088ec(local_16c,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    allocate_memory_block_080088ec(local_16c,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  piVar16 = piVar24 + -0xc;\n  piVar22 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar22 + 1);\n    piVar24 = (int *)(uint)*(byte *)piVar22;\n    local_15c = (int *)((int)piVar16 + (int)local_15c * 10);\n    piVar16 = piVar24 + -0xc;\n    piVar22 = piVar28;\n  } while (piVar16 < (int *)0xa);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "called": [
                "FUN_080004c8",
                "FUN_080003f4",
                "FUN_080011ec",
                "FUN_080009e8",
                "FUN_080009c0",
                "FUN_08000998",
                "FUN_0800119c",
                "FUN_08001170",
                "FUN_08008ad4",
                "FUN_08000158",
                "FUN_080096e0",
                "FUN_080097cc",
                "FUN_08005e40",
                "FUN_080079e8",
                "FUN_08009768",
                "FUN_08008af8",
                "FUN_0800901c",
                "FUN_080088ec",
                "FUN_080009ac"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08005e9c",
            "calling": [
                "FUN_08005dfc"
            ],
            "imported": false,
            "current_name": "FUNC_08005e9c"
        },
        "FUN_08000134": {
            "renaming": {
                "FUN_08000134": "concatenate_64bit_pointers_08000134",
                "param_1": "pointer_1",
                "param_2": "pointer_2"
            },
            "code": "\nundefined8 concatenate_64bit_pointers_08000134(undefined *pointer_1,undefined *pointer_2)\n\n{\n  if (DAT_08000144 != 0) {\n    pointer_1 = PTR_FUN_0800014c;\n    pointer_2 = PTR_DAT_08000148;\n  }\n  return CONCAT44(pointer_2,pointer_1);\n}\n\n",
            "called": [
                "FUN_08009e68"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000134",
            "calling": [
                "FUN_08005d20"
            ],
            "imported": false,
            "current_name": "concatenate_64bit_pointers_08000134"
        },
        "FUN_08005704": {
            "renaming": {
                "FUN_08005704": "process_input_and_add_byte_08005704",
                "add_byte_to_uint_0800157c": "add_byte_to_uint",
                "process_input_080017b4": "process_input"
            },
            "code": "\nvoid process_input_and_add_byte_08005704(void)\n\n{\n  add_byte_to_uint_0800157c();\n  process_input();\n  return;\n}\n\n",
            "called": [
                "FUN_080017b4",
                "FUN_0800157c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005704",
            "calling": [],
            "imported": false,
            "current_name": "process_input_and_add_byte_08005704"
        },
        "FUN_08000418": {
            "renaming": {
                "FUN_08000418": "decode_unsigned_long_long_08000418",
                "param_1": "input_value",
                "param_2": "unused_param_1",
                "param_3": "unused_param_2",
                "param_4": "mask",
                "uVar1": "high_bits",
                "uVar2": "lower_bits",
                "uVar3": "result_high_bits",
                "uVar4": "shifted_input_value",
                "uVar5": "temp",
                "uVar7": "shift_amount",
                "iVar6": "leading_zeroes",
                "bVar8": "is_shift_amount_zero",
                "bVar9": "is_mask_equal_to_0_or_0xff000000",
                "bVar10": "is_shift_amount_larger_than_0x20",
                "in_r12": "unused_param_3"
            },
            "code": "\nulonglong decode_unsigned_long_long_08000418(uint input_value,undefined4 unused_param_1,undefined4 unused_param_2,uint mask)\n\n{\n  uint high_bits;\n  uint lower_bits;\n  uint result_high_bits;\n  uint shifted_input_value;\n  uint temp;\n  int leading_zeroes;\n  uint shift_amount;\n  uint unused_param_3;\n  bool is_shift_amount_zero;\n  bool is_mask_equal_to_0_or_0xff000000;\n  bool is_shift_amount_larger_than_0x20;\n  \n  temp = input_value << 1;\n  is_mask_equal_to_0_or_0xff000000 = temp == 0;\n  high_bits = (uint)((input_value & 0x80000000) != 0) << 0x1f;\n  shifted_input_value = (uint)((int)temp >> 3) >> 1;\n  result_high_bits = high_bits | shifted_input_value;\n  input_value = input_value << 0x1d;\n  if (!is_mask_equal_to_0_or_0xff000000) {\n    mask = temp & 0xff000000;\n    is_mask_equal_to_0_or_0xff000000 = mask == 0;\n  }\n  if (!is_mask_equal_to_0_or_0xff000000) {\n    is_mask_equal_to_0_or_0xff000000 = mask == 0xff000000;\n  }\n  if (!is_mask_equal_to_0_or_0xff000000) {\n    return CONCAT44(result_high_bits,input_value) ^ 0x3800000000000000;\n  }\n  if ((temp & 0xffffff) == 0) {\n    return CONCAT44(result_high_bits,input_value);\n  }\n  if (mask == 0xff000000) {\n    return CONCAT44(result_high_bits,input_value) | 0x8000000000000;\n  }\n  lower_bits = input_value;\n  temp = shifted_input_value;\n  if (shifted_input_value == 0) {\n    lower_bits = 0;\n    temp = input_value;\n  }\n  leading_zeroes = count_leading_zeroes(temp);\n  if (shifted_input_value == 0) {\n    leading_zeroes = leading_zeroes + 0x20;\n  }\n  shift_amount = leading_zeroes - 0xb;\n  is_shift_amount_larger_than_0x20 = SBORROW4(shift_amount,0x20);\n  shifted_input_value = leading_zeroes - 0x2b;\n  is_mask_equal_to_0_or_0xff000000 = (int)shifted_input_value < 0;\n  is_shift_amount_zero = shifted_input_value == 0;\n  if ((int)shift_amount < 0x20) {\n    is_shift_amount_larger_than_0x20 = SCARRY4(shifted_input_value,0xc);\n    leading_zeroes = leading_zeroes + -0x1f;\n    is_mask_equal_to_0_or_0xff000000 = leading_zeroes < 0;\n    is_shift_amount_zero = leading_zeroes == 0;\n    shifted_input_value = shift_amount;\n    if (!is_shift_amount_zero && is_mask_equal_to_0_or_0xff000000 == is_shift_amount_larger_than_0x20) {\n      lower_bits = temp << (shift_amount & 0xff);\n      temp = temp >> (0xcU - leading_zeroes & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_shift_amount_zero || is_mask_equal_to_0_or_0xff000000 != is_shift_amount_larger_than_0x20) {\n    unused_param_3 = 0x20 - shifted_input_value;\n  }\n  temp = temp << (shifted_input_value & 0xff);\n  if (is_shift_amount_zero || is_mask_equal_to_0_or_0xff000000 != is_shift_amount_larger_than_0x20) {\n    temp = temp | lower_bits >> (unused_param_3 & 0xff);\n  }\n  if (is_shift_amount_zero || is_mask_equal_to_0_or_0xff000000 != is_shift_amount_larger_than_0x20) {\n    lower_bits = lower_bits << (shifted_input_value & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shift_amount < 0x381) {\n    return CONCAT44(temp + (0x380 - shift_amount) * 0x100000 | high_bits,lower_bits);\n  }\n  shifted_input_value = ~(0x380 - shift_amount);\n  if (0x1e < (int)shifted_input_value) {\n    return CONCAT44(result_high_bits,temp >> (shifted_input_value - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zeroes = shifted_input_value - 0x13;\n  if (leading_zeroes == 0 || leading_zeroes < 0 != SCARRY4(shifted_input_value - 0x1f,0xc)) {\n    shifted_input_value = shifted_input_value + 1;\n    return CONCAT44(high_bits | temp >> (shifted_input_value & 0xff),\n                    lower_bits >> (shifted_input_value & 0xff) | temp << (0x20 - shifted_input_value & 0xff));\n  }\n  return CONCAT44(result_high_bits,lower_bits >> (0x20 - (0xcU - leading_zeroes) & 0xff) | temp << (0xcU - leading_zeroes & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000418",
            "calling": [
                "FUN_08004d78",
                "FUN_08004f78",
                "FUN_08004bd8"
            ],
            "imported": false,
            "current_name": "decode_unsigned_long_long_08000418"
        },
        "FUN_08002ca8": {
            "renaming": {
                "FUN_08002ca8": "check_memory_access_08002ca8",
                "param_1": "memory_access_info",
                "param_2": "access_size",
                "param_3": "access_offset",
                "iVar1": "pointer_value"
            },
            "code": "\nundefined4 check_memory_access_08002ca8(int *memory_access_info,uint access_size,int access_offset)\n\n{\n  int pointer_value;\n  \n  while( true ) {\n    if ((*(uint *)(*memory_access_info + 0x14) & 0x40) == 0x40) {\n      return 0;\n    }\n    if ((*(uint *)(*memory_access_info + 0x14) & 0x10) == 0x10) break;\n    if ((access_size == 0) || (pointer_value = get_pointer_value_080015a0(), access_size < (uint)(pointer_value - access_offset))) {\n      memory_access_info[0x10] = memory_access_info[0x10] | 0x20;\n      *(undefined *)((int)memory_access_info + 0x3d) = 0x20;\n      *(undefined *)(memory_access_info + 0xf) = 0;\n      return 3;\n    }\n  }\n  *(undefined4 *)(*memory_access_info + 0x14) = 0xffffffef;\n  memory_access_info[0x10] = 0;\n  memory_access_info[0xc] = 0;\n  *(undefined *)((int)memory_access_info + 0x3d) = 0x20;\n  *(undefined *)(memory_access_info + 0xf) = 0;\n  return 1;\n}\n\n",
            "called": [
                "FUN_080015a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ca8",
            "calling": [
                "FUN_08001f6c"
            ],
            "imported": false,
            "current_name": "check_memory_access_08002ca8"
        },
        "FUN_08003a94": {
            "renaming": {
                "FUN_08003a94": "update_permissions_08003a94",
                "param_1": "permissions_ptr",
                "param_2": "permission_values_ptr",
                "uVar1": "return_value",
                "uVar2": "permission_value"
            },
            "code": "\nundefined4 update_permissions_08003a94(int *permissions_ptr,uint *permission_values_ptr)\n\n{\n  undefined4 return_value;\n  uint permission_value;\n  \n  if (*(char *)(permissions_ptr + 0xf) == '\\x01') {\n    return_value = 2;\n  }\n  else {\n    *(undefined *)(permissions_ptr + 0xf) = 1;\n    *(undefined *)((int)permissions_ptr + 0x3d) = 2;\n    *(uint *)(*permissions_ptr + 8) = *(uint *)(*permissions_ptr + 8) & 0xffff0088;\n    permission_value = *permission_values_ptr;\n    if (permission_value == 0x40) {\n      update_flags_080040a0(*permissions_ptr,permission_values_ptr[1],permission_values_ptr[3]);\n      set_permissions_0800416a(*permissions_ptr,0x40);\n    }\n    else if (permission_value < 0x41) {\n      if (permission_value == 0x10) {\n        set_permissions_0800416a(*permissions_ptr,0x10);\n      }\n      else if (permission_value < 0x11) {\n        if (permission_value == 0) {\n          set_permissions_0800416a(*permissions_ptr,0);\n        }\n      }\n      else if (permission_value == 0x20) {\n        set_permissions_0800416a(*permissions_ptr,0x20);\n      }\n      else if (permission_value == 0x30) {\n        set_permissions_0800416a(*permissions_ptr,0x30);\n      }\n    }\n    else if (permission_value == 0x70) {\n      combine_uints_080041a8(*permissions_ptr,permission_values_ptr[2],permission_values_ptr[1],permission_values_ptr[3]);\n      *(uint *)(*permissions_ptr + 8) = *(uint *)(*permissions_ptr + 8) & 0xffffff88 | 0x77;\n    }\n    else if (permission_value < 0x71) {\n      if (permission_value == 0x50) {\n        update_flags_080040a0(*permissions_ptr,permission_values_ptr[1],permission_values_ptr[3]);\n        set_permissions_0800416a(*permissions_ptr,0x50);\n      }\n      else if (permission_value == 0x60) {\n        set_bits_shift_left_08004104(*permissions_ptr,permission_values_ptr[1],permission_values_ptr[3]);\n        set_permissions_0800416a(*permissions_ptr,0x60);\n      }\n    }\n    else if (permission_value == 0x1000) {\n      *(uint *)(*permissions_ptr + 8) = *(uint *)(*permissions_ptr + 8) & 0xfffffff8;\n    }\n    else if (permission_value == 0x2000) {\n      combine_uints_080041a8(*permissions_ptr,permission_values_ptr[2],permission_values_ptr[1],permission_values_ptr[3]);\n      *(uint *)(*permissions_ptr + 8) = *(uint *)(*permissions_ptr + 8) | 0x4000;\n    }\n    *(undefined *)((int)permissions_ptr + 0x3d) = 1;\n    *(undefined *)(permissions_ptr + 0xf) = 0;\n    return_value = 0;\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_0800416a",
                "FUN_080041a8",
                "FUN_080040a0",
                "FUN_08004104"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a94",
            "calling": [
                "FUN_08005500",
                "FUN_080053b0"
            ],
            "imported": false,
            "current_name": "update_permissions_08003a94"
        },
        "FUN_0800416a": {
            "renaming": {
                "FUN_0800416a": "set_permissions_0800416a",
                "param_1": "file_descriptor",
                "param_2": "permissions"
            },
            "code": "\nvoid set_permissions_0800416a(int file_descriptor,ushort permissions)\n\n{\n  *(uint *)(file_descriptor + 8) = *(uint *)(file_descriptor + 8) & 0xffffff8f | (uint)(permissions | 7);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800416a",
            "calling": [
                "FUN_08003a94"
            ],
            "imported": false,
            "current_name": "set_permissions_0800416a"
        },
        "FUN_080055f4": {
            "renaming": {
                "FUN_080055f4": "set_bit_flags_and_parse_bits_080055f4",
                "local_18": "parameter_id",
                "local_14": "parameter_value",
                "local_c": "parse_bits_value",
                "set_parameter_value_08001a80": "set_parameter_value",
                "parse_bits_080017c4": "parse_bits"
            },
            "code": "\nvoid set_bit_flags_and_parse_bits_080055f4(void)\n\n{\n  undefined4 parameter_id;\n  undefined4 parameter_value;\n  undefined4 parse_bits_080017c4_value;\n  \n  *(uint *)(DAT_0800566c + 0x18) = *(uint *)(DAT_0800566c + 0x18) | 0x20;\n  *(uint *)(DAT_0800566c + 0x18) = *(uint *)(DAT_0800566c + 0x18) | 4;\n  *(uint *)(DAT_0800566c + 0x18) = *(uint *)(DAT_0800566c + 0x18) | 8;\n  set_parameter_value_08001a80(DAT_08005670,0x1e,0,*(uint *)(DAT_0800566c + 0x18) & 8);\n  parameter_id = 0x1e;\n  parameter_value = 1;\n  parse_bits_080017c4_value = 2;\n  parse_bits_080017c4(DAT_08005670,&parameter_id);\n  return;\n}\n\n",
            "called": [
                "FUN_080017c4",
                "FUN_08001a80"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080055f4",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "set_bit_flags_and_parse_bits_080055f4"
        },
        "FUN_080059f0": {
            "renaming": {
                "FUN_080059f0": "calculate_result_080059f0",
                "param_1": "value_1",
                "param_2": "value_2",
                "param_3": "unused_param",
                "param_4": "unused_param_2",
                "uVar1": "result_1",
                "uVar2": "result_2",
                "uVar3": "result_3",
                "uVar4": "result_4",
                "uVar5": "result_5",
                "uVar6": "result_6",
                "uVar7": "temp_value",
                "iVar8": "operation_type",
                "uVar9": "temp_result_1",
                "uVar10": "temp_result_2",
                "uVar11": "final_result"
            },
            "code": "\nulonglong calculate_result_080059f0(int value_1,uint value_2,undefined4 unused_param,undefined4 unused_param_2)\n\n{\n  undefined4 result_1;\n  undefined4 result_2;\n  undefined4 result_3;\n  undefined4 result_4;\n  undefined4 result_5;\n  undefined4 result_6;\n  uint temp_value;\n  int operation_type;\n  undefined8 temp_result_1;\n  undefined8 temp_result_2;\n  ulonglong final_result;\n  \n  temp_result_1 = CONCAT44(value_2,value_1);\n  temp_value = value_2 & 0x7fffffff;\n  if (DAT_08005cd8 < (int)temp_value) {\n    if ((temp_value == DAT_08005cdc || (int)temp_value < (int)DAT_08005cdc) &&\n       ((temp_value != DAT_08005cdc || (value_1 == 0)))) {\n      result_1 = DAT_08005ce4;\n      if (0 < (int)value_2) {\n        result_1 = DAT_08005ce0;\n      }\n      return CONCAT44(result_1,DAT_08005ce8);\n    }\n    final_result = calculate_double_precision_float_0800015c(value_1,value_2,value_1,value_2,unused_param_2);\n  }\n  else {\n    if (DAT_08005cec < (int)temp_value) {\n      temp_result_1 = do_nothing_08005d0c();\n      result_4 = (undefined4)((ulonglong)temp_result_1 >> 0x20);\n      result_1 = (undefined4)temp_result_1;\n      if (DAT_08005cfc < (int)temp_value) {\n        if (DAT_08005d00 < (int)temp_value) {\n          temp_result_1 = FUNC_0800071c(0,DAT_08005d08,result_1,result_4);\n          operation_type = 3;\n        }\n        else {\n          temp_result_1 = floating_point_addition_08000158(result_1,result_4,0,DAT_08005d04);\n          temp_result_2 = calculate_double_precision_floating_point_value_080004c8(result_1,result_4,0,DAT_08005d04);\n          temp_result_2 = calculate_double_precision_float_0800015c((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0,DAT_08005cf8);\n          temp_result_1 = FUNC_0800071c((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),(int)temp_result_2,\n                               (int)((ulonglong)temp_result_2 >> 0x20));\n          operation_type = 2;\n        }\n      }\n      else if (DAT_08005cfc + -0xd0000 < (int)temp_value) {\n        temp_result_1 = floating_point_addition_08000158(result_1,result_4,0,DAT_08005cf8);\n        temp_result_2 = calculate_double_precision_float_0800015c(result_1,result_4,0,DAT_08005cf8);\n        temp_result_1 = FUNC_0800071c((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),(int)temp_result_2,\n                             (int)((ulonglong)temp_result_2 >> 0x20));\n        operation_type = 1;\n      }\n      else {\n        temp_result_1 = calculate_double_precision_float_0800015c(result_1,result_4,result_1,result_4);\n        temp_result_1 = floating_point_addition_08000158((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0,DAT_08005cf8);\n        temp_result_2 = calculate_double_precision_float_0800015c(result_1,result_4,0,0x40000000);\n        temp_result_1 = FUNC_0800071c((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),(int)temp_result_2,\n                             (int)((ulonglong)temp_result_2 >> 0x20));\n        operation_type = 0;\n      }\n    }\n    else {\n      if ((int)temp_value <= DAT_08005cec + -0x1bc0000) {\n        temp_result_2 = calculate_double_precision_float_0800015c(value_1,value_2,DAT_08005cd0,DAT_08005cd4,unused_param_2);\n        operation_type = check_if_string_terminated_080009e8((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0,DAT_08005cf8);\n        if (operation_type != 0) {\n          return CONCAT44(value_2,value_1);\n        }\n      }\n      operation_type = -1;\n    }\n    result_6 = (undefined4)((ulonglong)temp_result_1 >> 0x20);\n    result_5 = (undefined4)temp_result_1;\n    temp_result_1 = calculate_double_precision_floating_point_value_080004c8(result_5,result_6,result_5,result_6);\n    result_2 = (undefined4)((ulonglong)temp_result_1 >> 0x20);\n    result_1 = (undefined4)temp_result_1;\n    temp_result_1 = calculate_double_precision_floating_point_value_080004c8(result_1,result_2,result_1,result_2);\n    result_3 = (undefined4)((ulonglong)temp_result_1 >> 0x20);\n    result_4 = (undefined4)temp_result_1;\n    temp_result_1 = calculate_double_precision_floating_point_value_080004c8(result_4,result_3,DAT_08005c78,DAT_08005c7c);\n    temp_result_1 = calculate_double_precision_float_0800015c((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),DAT_08005c80,DAT_08005c84);\n    temp_result_1 = calculate_double_precision_floating_point_value_080004c8((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),result_4,result_3);\n    temp_result_1 = calculate_double_precision_float_0800015c((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),DAT_08005c88,DAT_08005c8c);\n    temp_result_1 = calculate_double_precision_floating_point_value_080004c8((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),result_4,result_3);\n    temp_result_1 = calculate_double_precision_float_0800015c((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),DAT_08005c90,DAT_08005c94);\n    temp_result_1 = calculate_double_precision_floating_point_value_080004c8((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),result_4,result_3);\n    temp_result_1 = calculate_double_precision_float_0800015c((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),DAT_08005c98,DAT_08005c9c);\n    temp_result_1 = calculate_double_precision_floating_point_value_080004c8((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),result_4,result_3);\n    temp_result_1 = calculate_double_precision_float_0800015c((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),DAT_08005ca0,DAT_08005ca4);\n    temp_result_1 = calculate_double_precision_floating_point_value_080004c8((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),result_1,result_2);\n    temp_result_2 = calculate_double_precision_floating_point_value_080004c8(result_4,result_3,DAT_08005ca8,DAT_08005cac);\n    temp_result_2 = floating_point_addition_08000158((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),DAT_08005cb0,DAT_08005cb4);\n    temp_result_2 = calculate_double_precision_floating_point_value_080004c8((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),result_4,result_3);\n    temp_result_2 = floating_point_addition_08000158((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),DAT_08005cb8,DAT_08005cbc);\n    temp_result_2 = calculate_double_precision_floating_point_value_080004c8((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),result_4,result_3);\n    temp_result_2 = floating_point_addition_08000158((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),DAT_08005cc0,DAT_08005cc4);\n    temp_result_2 = calculate_double_precision_floating_point_value_080004c8((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),result_4,result_3);\n    temp_result_2 = floating_point_addition_08000158((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),DAT_08005cc8,DAT_08005ccc);\n    temp_result_2 = calculate_double_precision_floating_point_value_080004c8((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),result_4,result_3);\n    temp_result_1 = calculate_double_precision_float_0800015c((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),(int)temp_result_2,\n                         (int)((ulonglong)temp_result_2 >> 0x20));\n    temp_result_1 = calculate_double_precision_floating_point_value_080004c8((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),result_5,result_6);\n    result_1 = (undefined4)((ulonglong)temp_result_1 >> 0x20);\n    if (operation_type == -1) {\n      final_result = floating_point_addition_08000158(result_5,result_6,(int)temp_result_1,result_1);\n      return final_result;\n    }\n    temp_result_1 = floating_point_addition_08000158((int)temp_result_1,result_1,*(undefined4 *)(PTR_DAT_08005cf0 + operation_type * 8),\n                         *(undefined4 *)((int)(PTR_DAT_08005cf0 + operation_type * 8) + 4));\n    temp_result_1 = floating_point_addition_08000158((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),result_5,result_6);\n    final_result = floating_point_addition_08000158(*(undefined4 *)(PTR_DAT_08005cf4 + operation_type * 8),\n                          *(undefined4 *)((int)(PTR_DAT_08005cf4 + operation_type * 8) + 4),(int)temp_result_1,\n                          (int)((ulonglong)temp_result_1 >> 0x20));\n    if ((int)value_2 < 0) {\n      return final_result & 0xffffffff | (ulonglong)((int)(final_result >> 0x20) + 0x80000000) << 0x20;\n    }\n  }\n  return final_result;\n}\n\n",
            "called": [
                "FUN_08000158",
                "FUN_080004c8",
                "FUN_0800015c",
                "FUN_080009e8",
                "FUN_0800071c",
                "FUN_08005d0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080059f0",
            "calling": [
                "FUN_08005838"
            ],
            "imported": false,
            "current_name": "calculate_result_080059f0"
        },
        "FUN_080053b0": {
            "renaming": {
                "FUN_080053b0": "initialize_binary_execution_080053b0",
                "local_58": "flag_1",
                "local_54": "flag_2",
                "local_50": "flag_3",
                "local_4c": "flag_4",
                "local_48": "flag_5",
                "local_44": "permission_flags",
                "local_40": "flag_6",
                "local_3c": "register_flags",
                "local_38": "flag_7",
                "local_34": "flag_8",
                "local_30": "flag_9",
                "local_2c": "flag_10",
                "local_28": "flag_11",
                "local_24": "flag_12",
                "local_20": "flag_13",
                "local_1c": "flag_14",
                "local_18": "permission_values"
            },
            "code": "\nvoid initialize_binary_execution_080053b0(void)\n\n{\n  int iVar1;\n  undefined4 flag_1;\n  undefined4 flag_2;\n  undefined4 flag_3;\n  undefined4 flag_4;\n  undefined4 flag_5;\n  undefined4 permission_flags;\n  undefined4 flag_6;\n  undefined4 register_flags;\n  undefined4 flag_7;\n  undefined4 flag_8;\n  undefined4 flag_9;\n  undefined4 flag_10;\n  undefined4 flag_11;\n  undefined4 flag_12;\n  undefined4 flag_13;\n  undefined4 flag_14;\n  undefined4 permission_values [4];\n  \n  *(undefined4 *)PTR_DAT_080054f4 = DAT_080054f8;\n  *(undefined4 *)(PTR_DAT_080054f4 + 4) = 0x708;\n  *(undefined4 *)(PTR_DAT_080054f4 + 8) = 0;\n  *(undefined4 *)(PTR_DAT_080054f4 + 0xc) = 100;\n  *(undefined4 *)(PTR_DAT_080054f4 + 0x10) = 0;\n  *(undefined4 *)(PTR_DAT_080054f4 + 0x14) = 0;\n  *(undefined4 *)(PTR_DAT_080054f4 + 0x18) = 0;\n  iVar1 = check_params_and_update_080035a4(PTR_DAT_080054f4);\n  if (iVar1 != 0) {\n    infinite_loop_08005674(PTR_s____src_main_c_080054fc,399);\n  }\n  permission_values[0] = 0x1000;\n  iVar1 = update_permissions_08003a94(PTR_DAT_080054f4,permission_values);\n  if (iVar1 != 0) {\n    infinite_loop_08005674(PTR_s____src_main_c_080054fc,0x194);\n  }\n  iVar1 = check_params_and_update_08003640(PTR_DAT_080054f4);\n  if (iVar1 != 0) {\n    infinite_loop_08005674(PTR_s____src_main_c_080054fc,0x198);\n  }\n  flag_13 = 0;\n  flag_14 = 0;\n  iVar1 = check_flag_status_080042de(PTR_DAT_080054f4,&flag_13);\n  if (iVar1 != 0) {\n    infinite_loop_08005674(PTR_s____src_main_c_080054fc,0x19f);\n  }\n  register_flags = 0x60;\n  flag_7 = 0;\n  flag_8 = 0;\n  flag_9 = 0;\n  flag_10 = 0;\n  flag_11 = 0;\n  flag_12 = 0;\n  iVar1 = update_flags_and_registers_08003908(PTR_DAT_080054f4,&register_flags,0);\n  if (iVar1 != 0) {\n    infinite_loop_08005674(PTR_s____src_main_c_080054fc,0x1ab);\n  }\n  iVar1 = update_flags_and_registers_08003908(PTR_DAT_080054f4,&register_flags,0xc);\n  if (iVar1 != 0) {\n    infinite_loop_08005674(PTR_s____src_main_c_080054fc,0x1b0);\n  }\n  flag_1 = 0;\n  flag_2 = 0;\n  flag_3 = 0;\n  flag_4 = 0;\n  flag_5 = 0;\n  permission_flags = 0x2000;\n  flag_6 = 0;\n  iVar1 = check_flag_0800422e(PTR_DAT_080054f4,&flag_1);\n  if (iVar1 != 0) {\n    infinite_loop_08005674(PTR_s____src_main_c_080054fc,0x1bc);\n  }\n  parse_bits_from_binary_08005680(PTR_DAT_080054f4);\n  return;\n}\n\n",
            "called": [
                "FUN_08005674",
                "FUN_08003a94",
                "FUN_08005680",
                "FUN_080042de",
                "FUN_080035a4",
                "FUN_08003908",
                "FUN_08003640",
                "FUN_0800422e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053b0",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "initialize_binary_execution_080053b0"
        },
        "FUN_08009e74": {
            "renaming": {
                "FUN_08009e74": "do_nothing_08009e74"
            },
            "code": "\nvoid do_nothing_08009e74(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009e74",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08009e74"
        },
        "FUN_0800088a": {
            "renaming": {
                "FUN_0800088a": "binary_to_double_0800088a",
                "param_1": "first_half_1",
                "param_2": "first_half_2",
                "param_3": "second_half_1",
                "param_4": "second_half_2",
                "uVar1": "bit_1",
                "unaff_r4": "constant",
                "uVar2": "shifted_constant",
                "uVar3": "first_half",
                "in_r12": "mask",
                "bVar4": "is_zero"
            },
            "code": "\nulonglong binary_to_double_0800088a(uint first_half_1,uint first_half_2,uint second_half_1,uint second_half_2)\n\n{\n  uint bit_1;\n  uint constant;\n  uint shifted_constant;\n  uint first_half;\n  uint mask;\n  bool is_zero;\n  \n  shifted_constant = mask & second_half_2 >> 0x14;\n  first_half = first_half_2;\n  if (constant != mask || shifted_constant != mask) {\n    if (constant == mask) {\n      if (((first_half_1 | first_half_2 << 0xc) == 0) && (first_half_1 = second_half_1, first_half = second_half_2, shifted_constant != mask)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((first_half_2 ^ second_half_2) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (shifted_constant == mask) {\n      first_half_1 = second_half_1;\n      first_half = second_half_2;\n      if ((second_half_1 | second_half_2 << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((first_half_2 ^ second_half_2) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      is_zero = (first_half_1 | first_half_2 << 1) == 0;\n      if (!is_zero) {\n        is_zero = (second_half_1 | second_half_2 << 1) == 0;\n      }\n      if (!is_zero) {\n        if (constant == 0) {\n          first_half = first_half_2 & 0x80000000;\n          do {\n            bit_1 = first_half_1 & 0x80000000;\n            first_half_1 = first_half_1 << 1;\n            first_half_2 = first_half_2 * 2 + (uint)(bit_1 != 0);\n          } while ((first_half_2 & 0x100000) == 0);\n          first_half_2 = first_half_2 | first_half;\n          if (shifted_constant != 0) {\n            return CONCAT44(first_half_2,first_half_1);\n          }\n        }\n        do {\n          first_half = second_half_1 & 0x80000000;\n          second_half_1 = second_half_1 << 1;\n          second_half_2 = second_half_2 * 2 + (uint)(first_half != 0);\n        } while ((second_half_2 & 0x100000) == 0);\n        return CONCAT44(first_half_2,first_half_1);\n      }\n      if ((first_half_1 | first_half_2 << 1) != 0) goto LAB_080006fc;\n      if ((second_half_1 | second_half_2 << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(first_half,first_half_1) | 0x7ff8000000000000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800088a",
            "calling": [
                "FUN_0800071c"
            ],
            "imported": false,
            "current_name": "binary_to_double_0800088a"
        },
        "FUN_080016d0": {
            "renaming": {
                "FUN_080016d0": "check_param_and_write_to_memory_080016d0",
                "param_1": "input_param",
                "bVar1": "is_valid_input",
                "write_to_memory_08001618": "write_to_memory"
            },
            "code": "\nbool check_param_and_write_to_memory_080016d0(int input_param)\n\n{\n  bool is_valid_input;\n  \n  is_valid_input = input_param - 1U < 0x1000000;\n  if (is_valid_input) {\n    DAT_08001710[1] = input_param + -1;\n    write_to_memory_08001618(0xffffffff,0xf);\n    DAT_08001710[2] = 0;\n    *DAT_08001710 = 7;\n  }\n  return !is_valid_input;\n}\n\n",
            "called": [
                "FUN_08001618"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080016d0",
            "calling": [
                "FUN_08001762"
            ],
            "imported": false,
            "current_name": "check_param_and_write_to_memory_080016d0"
        },
        "FUN_08001ccc": {
            "renaming": {
                "FUN_08001ccc": "process_data_08001ccc",
                "param_1": "data_ptr",
                "param_2": "input_1",
                "param_3": "input_2",
                "param_4": "input_3",
                "param_5": "input_data",
                "param_6": "input_4",
                "param_7": "input_5",
                "uVar1": "data_value_1",
                "iVar2": "pointer_value_1",
                "cVar3": "char_value",
                "uVar4": "data_value_2",
                "iVar5": "pointer_value_2",
                "uVar6": "return_value",
                "puVar7": "data_ptr_2",
                "bVar8": "bool_value"
            },
            "code": "\nundefined4\nprocess_data_08001ccc(uint **data_ptr,undefined2 input_1,undefined2 input_2,undefined2 input_3,uint *input_data,\n            undefined2 input_4,undefined4 input_5)\n\n{\n  uint data_value_1;\n  int pointer_value_1;\n  char char_value;\n  uint data_value_2;\n  int pointer_value_2;\n  undefined4 return_value;\n  uint *data_ptr_2;\n  bool bool_value;\n  \n  pointer_value_1 = get_pointer_value_080015a0();\n  data_value_1 = DAT_08001f64;\n  if (*(char *)((int)data_ptr + 0x3d) == ' ') {\n    do {\n      if ((data_value_1 >> 0x10 & 0xff) == 1) {\n        data_value_2 = data_value_1 & ~(*data_ptr)[5] & 0xffff;\n        bool_value = data_value_2 == 0;\n        if (bool_value) {\n          data_value_2 = 1;\n        }\n        char_value = (char)data_value_2;\n        if (!bool_value) {\n          char_value = '\\0';\n        }\n      }\n      else {\n        data_value_2 = data_value_1 & ~(*data_ptr)[6] & 0xffff;\n        bool_value = data_value_2 == 0;\n        if (bool_value) {\n          data_value_2 = 1;\n        }\n        char_value = (char)data_value_2;\n        if (!bool_value) {\n          char_value = '\\0';\n        }\n      }\n      if (char_value != '\\x01') {\n        pointer_value_2 = 0;\n        goto LAB_08001d9c;\n      }\n      pointer_value_2 = get_pointer_value_080015a0();\n    } while ((uint)(pointer_value_2 - pointer_value_1) < 0x1a);\n    data_ptr[0xc] = (uint *)0x0;\n    *(undefined *)((int)data_ptr + 0x3d) = 0x20;\n    *(undefined *)((int)data_ptr + 0x3e) = 0;\n    *(undefined *)(data_ptr + 0xf) = 0;\n    pointer_value_2 = 3;\nLAB_08001d9c:\n    if (pointer_value_2 == 0) {\n      if (*(char *)(data_ptr + 0xf) == '\\x01') {\n        return_value = 2;\n      }\n      else {\n        *(undefined *)(data_ptr + 0xf) = 1;\n        if ((**data_ptr & 1) != 1) {\n          **data_ptr = **data_ptr | 1;\n        }\n        **data_ptr = **data_ptr & 0xfffff7ff;\n        *(undefined *)((int)data_ptr + 0x3d) = 0x21;\n        *(undefined *)((int)data_ptr + 0x3e) = 0x40;\n        data_ptr[0x10] = (uint *)0x0;\n        data_ptr[9] = input_data;\n        *(undefined2 *)((int)data_ptr + 0x2a) = input_4;\n        data_ptr[0xb] = DAT_08001f68;\n        *(undefined2 *)(data_ptr + 10) = *(undefined2 *)((int)data_ptr + 0x2a);\n        pointer_value_2 = check_and_set_flag_08002640(data_ptr,input_1,input_2,input_3,input_5,pointer_value_1);\n        if (pointer_value_2 == 0) {\n          while (*(short *)(data_ptr + 10) != 0) {\n            pointer_value_2 = check_pointer_value_08002bb4(data_ptr,input_5,pointer_value_1);\n            if (pointer_value_2 != 0) {\n              if (data_ptr[0x10] == (uint *)0x4) {\n                **data_ptr = **data_ptr | 0x200;\n                return 1;\n              }\n              return 3;\n            }\n            data_ptr_2 = data_ptr[9];\n            data_ptr[9] = (uint *)((int)data_ptr_2 + 1);\n            (*data_ptr)[4] = (uint)*(byte *)data_ptr_2;\n            *(short *)(data_ptr + 10) = *(short *)(data_ptr + 10) + -1;\n            *(short *)((int)data_ptr + 0x2a) = *(short *)((int)data_ptr + 0x2a) + -1;\n            if ((((*data_ptr)[5] & 4) == 4) && (*(short *)(data_ptr + 10) != 0)) {\n              data_ptr_2 = data_ptr[9];\n              data_ptr[9] = (uint *)((int)data_ptr_2 + 1);\n              (*data_ptr)[4] = (uint)*(byte *)data_ptr_2;\n              *(short *)(data_ptr + 10) = *(short *)(data_ptr + 10) + -1;\n              *(short *)((int)data_ptr + 0x2a) = *(short *)((int)data_ptr + 0x2a) + -1;\n            }\n          }\n          pointer_value_1 = check_for_flag_and_update_08002c2e(data_ptr,input_5,pointer_value_1);\n          if (pointer_value_1 == 0) {\n            **data_ptr = **data_ptr | 0x200;\n            *(undefined *)((int)data_ptr + 0x3d) = 0x20;\n            *(undefined *)((int)data_ptr + 0x3e) = 0;\n            *(undefined *)(data_ptr + 0xf) = 0;\n            return_value = 0;\n          }\n          else if (data_ptr[0x10] == (uint *)0x4) {\n            **data_ptr = **data_ptr | 0x200;\n            return_value = 1;\n          }\n          else {\n            return_value = 3;\n          }\n        }\n        else if (data_ptr[0x10] == (uint *)0x4) {\n          *(undefined *)(data_ptr + 0xf) = 0;\n          return_value = 1;\n        }\n        else {\n          *(undefined *)(data_ptr + 0xf) = 0;\n          return_value = 3;\n        }\n      }\n    }\n    else {\n      return_value = 2;\n    }\n  }\n  else {\n    return_value = 2;\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_08002640",
                "FUN_08002c2e",
                "FUN_080015a0",
                "FUN_08002bb4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001ccc",
            "calling": [
                "FUN_08004ea4"
            ],
            "imported": false,
            "current_name": "process_data_08001ccc"
        },
        "FUN_0800157c": {
            "renaming": {
                "FUN_0800157c": "add_byte_to_uint_0800157c"
            },
            "code": "\nvoid add_byte_to_uint_0800157c(void)\n\n{\n  *(uint *)PTR_DAT_0800159c = *(int *)PTR_DAT_0800159c + (uint)(byte)*PTR_DAT_08001598;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800157c",
            "calling": [
                "FUN_08005704"
            ],
            "imported": false,
            "current_name": "add_byte_to_uint_0800157c"
        },
        "FUN_08000e20": {
            "renaming": {
                "FUN_08000e20": "floating_point_arithmetic_08000e20",
                "param_1": "float_1",
                "param_2": "float_2",
                "param_3": "mask",
                "param_4": "exponent",
                "uVar1": "mantissa_1",
                "uVar2": "mantissa_2",
                "iVar3": "exponent_diff",
                "uVar4": "shifted_exponent",
                "iVar5": "adjusted_exponent",
                "uVar6": "result",
                "bVar7": "condition",
                "bVar8": "condition_2",
                "bVar9": "condition_3"
            },
            "code": "\nuint floating_point_arithmetic_08000e20(uint float_1,uint float_2,undefined4 mask,uint exponent)\n\n{\n  uint mantissa_1;\n  uint mantissa_2;\n  int exponent_diff;\n  uint shifted_exponent;\n  int adjusted_exponent;\n  uint result;\n  bool condition;\n  bool condition_2;\n  bool condition_3;\n  \n  mantissa_2 = float_1 >> 0x17 & 0xff;\n  condition = mantissa_2 == 0;\n  if (!condition) {\n    exponent = float_2 >> 0x17 & 0xff;\n    condition = exponent == 0;\n  }\n  if (!condition) {\n    condition = mantissa_2 == 0xff;\n  }\n  if (!condition) {\n    condition = exponent == 0xff;\n  }\n  if (condition) {\n    exponent = float_2 >> 0x17 & 0xff;\n    result = float_1;\n    if (mantissa_2 == 0xff) {\n      if (((float_1 & 0x7fffff) != 0) || (result = float_2, exponent == 0xff)) {\nLAB_08000e16:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (exponent == 0xff) {\n        result = float_2;\n        if ((float_2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (float_1 ^ float_2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      condition = (float_1 & 0x7fffffff) == 0;\n      if (!condition) {\n        condition = (float_2 & 0x7fffffff) == 0;\n      }\n      if (!condition) {\n        condition = mantissa_2 == 0;\n        result = float_1 & 0x80000000;\n        while( true ) {\n          if (condition) {\n            float_1 = float_1 << 1;\n            condition = (float_1 & 0x800000) == 0;\n          }\n          if (!condition) break;\n          mantissa_2 = mantissa_2 - 1;\n        }\n        float_1 = float_1 | result;\n        condition = exponent == 0;\n        result = float_2 & 0x80000000;\n        while( true ) {\n          if (condition) {\n            float_2 = float_2 << 1;\n            condition = (float_2 & 0x800000) == 0;\n          }\n          if (!condition) break;\n          exponent = exponent - 1;\n        }\n        float_2 = float_2 | result;\n        goto LAB_08000e38;\n      }\n      if ((float_1 & 0x7fffffff) == 0) {\n        if ((float_2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    float_1 = float_1 ^ float_2;\n  }\n  else {\nLAB_08000e38:\n    exponent_diff = mantissa_2 - exponent;\n    if (float_2 << 9 == 0) {\n      float_1 = (float_1 ^ float_2) & 0x80000000 | float_1 & 0x7fffff;\n      condition_3 = SCARRY4(exponent_diff,0x7f);\n      adjusted_exponent = exponent_diff + 0x7f;\n      condition = adjusted_exponent < 0;\n      condition_2 = adjusted_exponent == 0;\n      if (!condition_2 && condition == condition_3) {\n        condition_3 = SBORROW4(0xff,adjusted_exponent);\n        condition = 0xff - adjusted_exponent < 0;\n        condition_2 = adjusted_exponent == 0xff;\n      }\n      if (!condition_2 && condition == condition_3) {\n        float_1 = float_1 | adjusted_exponent * 0x800000;\n      }\n      if (!condition_2 && condition == condition_3) {\n        return float_1;\n      }\n      float_1 = float_1 | 0x800000;\n      mantissa_2 = 0;\n      condition_2 = SBORROW4(adjusted_exponent,1);\n      shifted_exponent = exponent_diff + 0x7e;\n      condition = shifted_exponent == 0;\n      result = shifted_exponent;\n    }\n    else {\n      mantissa_1 = (float_2 << 9) >> 4 | 0x10000000;\n      mantissa_2 = (float_1 << 9) >> 4 | 0x10000000;\n      float_1 = (float_1 ^ float_2) & 0x80000000;\n      condition = mantissa_1 <= mantissa_2;\n      if (!condition) {\n        mantissa_2 = mantissa_2 << 1;\n      }\n      shifted_exponent = exponent_diff + 0x7d + (uint)condition;\n      result = 0x800000;\n      do {\n        if (mantissa_1 <= mantissa_2) {\n          mantissa_2 = mantissa_2 - mantissa_1;\n          float_1 = float_1 | result;\n        }\n        condition = mantissa_1 >> 1 <= mantissa_2;\n        if (condition) {\n          mantissa_2 = mantissa_2 - (mantissa_1 >> 1);\n        }\n        if (condition) {\n          float_1 = float_1 | result >> 1;\n        }\n        condition = mantissa_1 >> 2 <= mantissa_2;\n        if (condition) {\n          mantissa_2 = mantissa_2 - (mantissa_1 >> 2);\n        }\n        if (condition) {\n          float_1 = float_1 | result >> 2;\n        }\n        condition = mantissa_1 >> 3 <= mantissa_2;\n        if (condition) {\n          mantissa_2 = mantissa_2 - (mantissa_1 >> 3);\n        }\n        if (condition) {\n          float_1 = float_1 | result >> 3;\n        }\n        mantissa_2 = mantissa_2 * 0x10;\n        condition = mantissa_2 == 0;\n        if (!condition) {\n          result = result >> 4;\n          condition = result == 0;\n        }\n      } while (!condition);\n      condition_2 = SBORROW4(shifted_exponent,0xfd);\n      condition = shifted_exponent == 0xfd;\n      result = shifted_exponent - 0xfd;\n      if (shifted_exponent < 0xfe) {\n        float_1 = float_1 + shifted_exponent * 0x800000 + (uint)(mantissa_1 <= mantissa_2);\n        if (mantissa_2 - mantissa_1 == 0) {\n          float_1 = float_1 & 0xfffffffe;\n        }\n        return float_1;\n      }\n    }\n    if (condition || (int)result < 0 != condition_2) {\n      condition = (int)(shifted_exponent + 0x19) < 0;\n      if (shifted_exponent == 0xffffffe7 || condition != SCARRY4(shifted_exponent,0x19)) {\n        float_1 = float_1 & 0x80000000;\n      }\n      if (shifted_exponent == 0xffffffe7 || condition != SCARRY4(shifted_exponent,0x19)) {\n        return float_1;\n      }\n      result = (float_1 << 1) >> (-shifted_exponent & 0xff);\n      shifted_exponent = float_1 << (shifted_exponent + 0x20 & 0xff);\n      result = ((uint)((float_1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((mantissa_2 | shifted_exponent << 1) == 0) {\n        result = result & ~(shifted_exponent >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return float_1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000e20",
            "calling": [
                "FUN_080049cc",
                "FUN_08004d78"
            ],
            "imported": false,
            "current_name": "floating_point_arithmetic_08000e20"
        },
        "FUN_0800121c": {
            "renaming": {
                "FUN_0800121c": "calculate_division_remainder_0800121c",
                "param_1": "dividend",
                "param_2": "dividend_high",
                "param_3": "divisor",
                "param_4": "divisor_high",
                "param_5": "remainder",
                "UNRECOVERED_JUMPTABLE": "unrecovered_jumptable",
                "uVar1": "temp_var_1",
                "uVar2": "quotient",
                "puVar3": "result",
                "uVar4": "quotient_high",
                "uVar5": "temp_var_2",
                "uVar6": "shift_amount",
                "uVar7": "temp_var_3",
                "uVar8": "temp_var_4",
                "uVar11": "temp_var_5",
                "uVar12": "temp_var_6",
                "uVar13": "temp_var_7",
                "bVar14": "carry_flag",
                "uVar15": "return_value"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 calculate_division_remainder_0800121c(uint dividend,uint dividend_high,uint divisor,uint divisor_high,uint *remainder)\n\n{\n  code *unrecovered_jumptable;\n  ulonglong temp_var_1;\n  uint quotient;\n  uint *result;\n  uint quotient_high;\n  uint temp_var_2;\n  uint shift_amount;\n  uint temp_var_3;\n  uint temp_var_4;\n  uint *puVar9;\n  uint *ptemp_var_10;\n  uint temp_var_5;\n  uint temp_var_6;\n  uint temp_var_7;\n  bool carry_flag;\n  undefined8 return_value;\n  \n  if (divisor_high == 0) {\n    if (dividend_high < divisor) {\n      shift_amount = count_leading_zeroes(divisor);\n      if (shift_amount != 0) {\n        divisor = divisor << (shift_amount & 0xff);\n        dividend_high = dividend >> (0x20 - shift_amount & 0xff) | dividend_high << (shift_amount & 0xff);\n        dividend = dividend << (shift_amount & 0xff);\n      }\n      temp_var_6 = divisor >> 0x10;\n      temp_var_4 = dividend_high / temp_var_6;\n      temp_var_5 = temp_var_4 * (divisor & 0xffff);\n      temp_var_3 = dividend >> 0x10 | (dividend_high - temp_var_6 * temp_var_4) * 0x10000;\n      quotient_high = temp_var_4;\n      if (temp_var_3 <= temp_var_5 && temp_var_5 - temp_var_3 != 0) {\n        carry_flag = CARRY4(divisor,temp_var_3);\n        temp_var_3 = divisor + temp_var_3;\n        quotient_high = temp_var_4 - 1;\n        if ((carry_flag == false) && (temp_var_3 <= temp_var_5 && temp_var_5 - temp_var_3 != 0)) {\n          quotient_high = temp_var_4 - 2;\n          temp_var_3 = temp_var_3 + divisor;\n        }\n      }\n      quotient = (temp_var_3 - temp_var_5) / temp_var_6;\n      temp_var_2 = quotient * (divisor & 0xffff);\n      temp_var_4 = dividend & 0xffff | ((temp_var_3 - temp_var_5) - temp_var_6 * quotient) * 0x10000;\n      temp_var_3 = quotient;\n      if (temp_var_4 <= temp_var_2 && temp_var_2 - temp_var_4 != 0) {\n        carry_flag = CARRY4(divisor,temp_var_4);\n        temp_var_4 = divisor + temp_var_4;\n        temp_var_3 = quotient - 1;\n        if ((carry_flag == false) && (temp_var_4 <= temp_var_2 && temp_var_2 - temp_var_4 != 0)) {\n          temp_var_3 = quotient - 2;\n          temp_var_4 = temp_var_4 + divisor;\n        }\n      }\n      result = (uint *)(temp_var_3 | quotient_high << 0x10);\n      puVar9 = (uint *)0x0;\n      temp_var_4 = temp_var_4 - temp_var_2;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Could not recover jumptable at 0x08001302. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        unrecovered_jumptable = (code *)software_udf(0xff,0x8001302);\n        return_value = (*unrecovered_jumptable)();\n        return return_value;\n      }\n      shift_amount = count_leading_zeroes(divisor);\n      if (shift_amount == 0) {\n        puVar9 = (uint *)0x1;\n        dividend_high = dividend_high - divisor;\n        temp_var_6 = divisor >> 0x10;\n        quotient = divisor & 0xffff;\n      }\n      else {\n        divisor = divisor << (shift_amount & 0xff);\n        quotient_high = dividend_high >> (0x20 - shift_amount & 0xff);\n        temp_var_6 = divisor >> 0x10;\n        temp_var_5 = quotient_high / temp_var_6;\n        quotient = divisor & 0xffff;\n        temp_var_2 = temp_var_5 * quotient;\n        temp_var_4 = dividend >> (0x20 - shift_amount & 0xff) | dividend_high << (shift_amount & 0xff);\n        temp_var_3 = temp_var_4 >> 0x10 | (quotient_high - temp_var_6 * temp_var_5) * 0x10000;\n        dividend = dividend << (shift_amount & 0xff);\n        quotient_high = temp_var_5;\n        if (temp_var_3 <= temp_var_2 && temp_var_2 - temp_var_3 != 0) {\n          carry_flag = CARRY4(divisor,temp_var_3);\n          temp_var_3 = divisor + temp_var_3;\n          quotient_high = temp_var_5 - 1;\n          if ((carry_flag == false) && (temp_var_3 <= temp_var_2 && temp_var_2 - temp_var_3 != 0)) {\n            quotient_high = temp_var_5 - 2;\n            temp_var_3 = temp_var_3 + divisor;\n          }\n        }\n        temp_var_5 = (temp_var_3 - temp_var_2) / temp_var_6;\n        temp_var_7 = temp_var_5 * quotient;\n        dividend_high = temp_var_4 & 0xffff | ((temp_var_3 - temp_var_2) - temp_var_6 * temp_var_5) * 0x10000;\n        temp_var_3 = temp_var_5;\n        if (dividend_high <= temp_var_7 && temp_var_7 - dividend_high != 0) {\n          carry_flag = CARRY4(divisor,dividend_high);\n          dividend_high = divisor + dividend_high;\n          temp_var_3 = temp_var_5 - 1;\n          if ((carry_flag == false) && (dividend_high <= temp_var_7 && temp_var_7 - dividend_high != 0)) {\n            temp_var_3 = temp_var_5 - 2;\n            dividend_high = dividend_high + divisor;\n          }\n        }\n        dividend_high = dividend_high - temp_var_7;\n        puVar9 = (uint *)(temp_var_3 | quotient_high << 0x10);\n      }\n      temp_var_5 = dividend_high / temp_var_6;\n      temp_var_3 = quotient * temp_var_5;\n      temp_var_4 = dividend >> 0x10 | (dividend_high - temp_var_6 * temp_var_5) * 0x10000;\n      quotient_high = temp_var_5;\n      if (temp_var_4 <= temp_var_3 && temp_var_3 - temp_var_4 != 0) {\n        carry_flag = CARRY4(divisor,temp_var_4);\n        temp_var_4 = divisor + temp_var_4;\n        quotient_high = temp_var_5 - 1;\n        if ((carry_flag == false) && (temp_var_4 <= temp_var_3 && temp_var_3 - temp_var_4 != 0)) {\n          quotient_high = temp_var_5 - 2;\n          temp_var_4 = temp_var_4 + divisor;\n        }\n      }\n      temp_var_5 = (temp_var_4 - temp_var_3) / temp_var_6;\n      quotient = quotient * temp_var_5;\n      temp_var_4 = dividend & 0xffff | ((temp_var_4 - temp_var_3) - temp_var_6 * temp_var_5) * 0x10000;\n      temp_var_3 = temp_var_5;\n      if (temp_var_4 <= quotient && quotient - temp_var_4 != 0) {\n        carry_flag = CARRY4(divisor,temp_var_4);\n        temp_var_4 = divisor + temp_var_4;\n        temp_var_3 = temp_var_5 - 1;\n        if ((carry_flag == false) && (temp_var_4 <= quotient && quotient - temp_var_4 != 0)) {\n          temp_var_3 = temp_var_5 - 2;\n          temp_var_4 = temp_var_4 + divisor;\n        }\n      }\n      temp_var_4 = temp_var_4 - quotient;\n      result = (uint *)(temp_var_3 | quotient_high << 0x10);\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = temp_var_4 >> (shift_amount & 0xff);\n      remainder[1] = 0;\n    }\n  }\n  else {\n    puVar9 = remainder;\n    if (dividend_high < divisor_high) {\n      result = remainder;\n      if (remainder != (uint *)0x0) {\n        *remainder = dividend;\n        remainder[1] = dividend_high;\n        return 0;\n      }\n    }\n    else {\n      ptemp_var_10 = (uint *)count_leading_zeroes(divisor_high);\n      if (ptemp_var_10 == (uint *)0x0) {\n        if ((divisor_high < dividend_high) || (result = ptemp_var_10, divisor <= dividend)) {\n          carry_flag = dividend < divisor;\n          dividend = dividend - divisor;\n          dividend_high = (dividend_high - divisor_high) - (uint)carry_flag;\n          result = (uint *)0x1;\n        }\n        puVar9 = ptemp_var_10;\n        if (remainder != (uint *)0x0) {\n          *remainder = dividend;\n          remainder[1] = dividend_high;\n        }\n      }\n      else {\n        temp_var_4 = 0x20 - (int)ptemp_var_10;\n        quotient = divisor >> (temp_var_4 & 0xff) | divisor_high << ((uint)ptemp_var_10 & 0xff);\n        shift_amount = dividend_high >> (temp_var_4 & 0xff);\n        temp_var_2 = quotient >> 0x10;\n        temp_var_5 = shift_amount / temp_var_2;\n        temp_var_6 = temp_var_5 * (quotient & 0xffff);\n        quotient_high = dividend_high << ((uint)ptemp_var_10 & 0xff) | dividend >> (temp_var_4 & 0xff);\n        temp_var_3 = quotient_high >> 0x10 | (shift_amount - temp_var_2 * temp_var_5) * 0x10000;\n        divisor = divisor << ((uint)ptemp_var_10 & 0xff);\n        dividend = dividend << ((uint)ptemp_var_10 & 0xff);\n        shift_amount = temp_var_5;\n        if (temp_var_3 <= temp_var_6 && temp_var_6 - temp_var_3 != 0) {\n          carry_flag = CARRY4(quotient,temp_var_3);\n          temp_var_3 = quotient + temp_var_3;\n          shift_amount = temp_var_5 - 1;\n          if ((carry_flag == false) && (temp_var_3 <= temp_var_6 && temp_var_6 - temp_var_3 != 0)) {\n            shift_amount = temp_var_5 - 2;\n            temp_var_3 = temp_var_3 + quotient;\n          }\n        }\n        temp_var_5 = (temp_var_3 - temp_var_6) / temp_var_2;\n        temp_var_7 = temp_var_5 * (quotient & 0xffff);\n        temp_var_3 = quotient_high & 0xffff | ((temp_var_3 - temp_var_6) - temp_var_2 * temp_var_5) * 0x10000;\n        quotient_high = temp_var_5;\n        if (temp_var_3 <= temp_var_7 && temp_var_7 - temp_var_3 != 0) {\n          carry_flag = CARRY4(quotient,temp_var_3);\n          temp_var_3 = quotient + temp_var_3;\n          quotient_high = temp_var_5 - 1;\n          if ((carry_flag == false) && (temp_var_3 <= temp_var_7 && temp_var_7 - temp_var_3 != 0)) {\n            quotient_high = temp_var_5 - 2;\n            temp_var_3 = temp_var_3 + quotient;\n          }\n        }\n        result = (uint *)(quotient_high | shift_amount << 0x10);\n        temp_var_1 = ZEXT48(result) * (ulonglong)divisor;\n        if (CONCAT44(temp_var_3 - temp_var_7,dividend) < temp_var_1) {\n          result = (uint *)((int)result + -1);\n          temp_var_1 = temp_var_1 - CONCAT44(quotient,divisor);\n        }\n        if (remainder != (uint *)0x0) {\n          shift_amount = ((temp_var_3 - temp_var_7) - (int)(temp_var_1 >> 0x20)) - (uint)(dividend < (uint)temp_var_1);\n          *remainder = shift_amount << (temp_var_4 & 0xff) | dividend - (uint)temp_var_1 >> ((uint)ptemp_var_10 & 0xff);\n          remainder[1] = shift_amount >> ((uint)ptemp_var_10 & 0xff);\n          puVar9 = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(puVar9,result);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800121c",
            "calling": [
                "FUN_080011ec"
            ],
            "imported": false,
            "current_name": "calculate_division_remainder_0800121c"
        },
        "FUN_08005d14": {
            "renaming": {
                "FUN_08005d14": "get_pointer_value_08005d14"
            },
            "code": "\nundefined4 get_pointer_value_08005d14(void)\n\n{\n  return *(undefined4 *)PTR_PTR_DAT_08005d1c;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d14",
            "calling": [
                "FUN_08005728"
            ],
            "imported": false,
            "current_name": "get_pointer_value_08005d14"
        },
        "FUN_080015b4": {
            "renaming": {
                "FUN_080015b4": "set_param_in_memory_080015b4",
                "param_1": "param"
            },
            "code": "\nvoid set_param_in_memory_080015b4(uint param)\n\n{\n  *(uint *)(DAT_080015f8 + 0xc) =\n       *(uint *)(DAT_080015f8 + 0xc) & 0xf8ff | (param & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015b4",
            "calling": [
                "FUN_08001714"
            ],
            "imported": false,
            "current_name": "set_param_in_memory_080015b4"
        },
        "FUN_080036f8": {
            "renaming": {
                "FUN_080036f8": "process_data_080036f8",
                "param_1": "data_ptr"
            },
            "code": "\nvoid process_data_080036f8(int *data_ptr)\n\n{\n  if (((*(uint *)(*data_ptr + 0x10) & 2) == 2) && ((*(uint *)(*data_ptr + 0xc) & 2) == 2)) {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xfffffffd;\n    *(undefined *)(data_ptr + 7) = 1;\n    if ((*(uint *)(*data_ptr + 0x18) & 3) == 0) {\n      do_nothing_08003c4a(data_ptr);\n      do_nothing_08003c6e(data_ptr);\n    }\n    else {\n      do_nothing_08003c5c(data_ptr);\n    }\n    *(undefined *)(data_ptr + 7) = 0;\n  }\n  if (((*(uint *)(*data_ptr + 0x10) & 4) == 4) && ((*(uint *)(*data_ptr + 0xc) & 4) == 4)) {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xfffffffb;\n    *(undefined *)(data_ptr + 7) = 2;\n    if ((*(uint *)(*data_ptr + 0x18) & 0x300) == 0) {\n      do_nothing_08003c4a(data_ptr);\n      do_nothing_08003c6e(data_ptr);\n    }\n    else {\n      do_nothing_08003c5c(data_ptr);\n    }\n    *(undefined *)(data_ptr + 7) = 0;\n  }\n  if (((*(uint *)(*data_ptr + 0x10) & 8) == 8) && ((*(uint *)(*data_ptr + 0xc) & 8) == 8)) {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xfffffff7;\n    *(undefined *)(data_ptr + 7) = 4;\n    if ((*(uint *)(*data_ptr + 0x1c) & 3) == 0) {\n      do_nothing_08003c4a(data_ptr);\n      do_nothing_08003c6e(data_ptr);\n    }\n    else {\n      do_nothing_08003c5c(data_ptr);\n    }\n    *(undefined *)(data_ptr + 7) = 0;\n  }\n  if (((*(uint *)(*data_ptr + 0x10) & 0x10) == 0x10) && ((*(uint *)(*data_ptr + 0xc) & 0x10) == 0x10))\n  {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xffffffef;\n    *(undefined *)(data_ptr + 7) = 8;\n    if ((*(uint *)(*data_ptr + 0x1c) & 0x300) == 0) {\n      do_nothing_08003c4a(data_ptr);\n      do_nothing_08003c6e(data_ptr);\n    }\n    else {\n      do_nothing_08003c5c(data_ptr);\n    }\n    *(undefined *)(data_ptr + 7) = 0;\n  }\n  if (((*(uint *)(*data_ptr + 0x10) & 1) == 1) && ((*(uint *)(*data_ptr + 0xc) & 1) == 1)) {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xfffffffe;\n    process_input_data_08004f78(data_ptr);\n  }\n  if (((*(uint *)(*data_ptr + 0x10) & 0x80) == 0x80) && ((*(uint *)(*data_ptr + 0xc) & 0x80) == 0x80))\n  {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xffffff7f;\n    do_nothing_08004378(data_ptr);\n  }\n  if (((*(uint *)(*data_ptr + 0x10) & 0x40) == 0x40) && ((*(uint *)(*data_ptr + 0xc) & 0x40) == 0x40))\n  {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xffffffbf;\n    do_nothing_08003c80(data_ptr);\n  }\n  if (((*(uint *)(*data_ptr + 0x10) & 0x20) == 0x20) && ((*(uint *)(*data_ptr + 0xc) & 0x20) == 0x20))\n  {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xffffffdf;\n    do_nothing_08004366(data_ptr);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08003c80",
                "FUN_08003c5c",
                "FUN_08004366",
                "FUN_08003c6e",
                "FUN_08004f78",
                "FUN_08003c4a",
                "FUN_08004378"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036f8",
            "calling": [
                "FUN_08005714"
            ],
            "imported": false,
            "current_name": "process_data_080036f8"
        },
        "FUN_080041a8": {
            "renaming": {
                "FUN_080041a8": "combine_uints_080041a8",
                "param_1": "ptr",
                "param_2": "uint1",
                "param_3": "uint2",
                "param_4": "shift_amount"
            },
            "code": "\nvoid combine_uints_080041a8(int ptr,uint uint1,uint uint2,int shift_amount)\n\n{\n  *(uint *)(ptr + 8) = uint1 | shift_amount << 8 | uint2 | *(uint *)(ptr + 8) & 0xffff00ff;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041a8",
            "calling": [
                "FUN_08003a94"
            ],
            "imported": false,
            "current_name": "combine_uints_080041a8"
        },
        "FUN_080004c8": {
            "renaming": {
                "FUN_080004c8": "calculate_double_precision_floating_point_value_080004c8",
                "param_1": "sign_bit",
                "param_2": "exponent_and_mantissa_high_bits",
                "param_3": "mantissa_low_bits",
                "param_4": "exponent_and_significand_high_bits",
                "uVar1": "lower_32_bits_of_multiplication",
                "lVar2": "64_bit_result_of_multiplication",
                "uVar3": "upper_32_bits_of_multiplication",
                "uVar4": "exponent_of_mantissa_high_bits",
                "uVar6": "temporary_variable",
                "unaff_r5": "exponent_of_significand_high_bits",
                "uVar7": "mask",
                "uVar8": "most_significant_32_bits_of_multiplication",
                "bVar9": "boolean_variable",
                "bVar10": "boolean_variable",
                "bVar11": "boolean_variable",
                "uVar12": "64_bit_input_value"
            },
            "code": "\nulonglong calculate_double_precision_floating_point_value_080004c8(undefined4 sign_bit,uint exponent_and_mantissa_high_bits,uint mantissa_low_bits,uint exponent_and_significand_high_bits)\n\n{\n  ulonglong lower_32_bits_of_multiplication;\n  longlong 64_bit_result_of_multiplication;\n  uint upper_32_bits_of_multiplication;\n  uint exponent_of_mantissa_high_bits;\n  int iVar5;\n  uint temporary_variable;\n  uint exponent_of_significand_high_bits;\n  uint mask;\n  uint most_significant_32_bits_of_multiplication;\n  bool boolean_variable;\n  bool boolean_variable;\n  bool boolean_variable;\n  ulonglong 64_bit_input_value;\n  \n  64_bit_input_value = CONCAT44(exponent_and_mantissa_high_bits,sign_bit);\n  mask = 0x7ff;\n  exponent_of_mantissa_high_bits = exponent_and_mantissa_high_bits >> 0x14 & 0x7ff;\n  boolean_variable = exponent_of_mantissa_high_bits == 0;\n  if (!boolean_variable) {\n    exponent_of_significand_high_bits = exponent_and_significand_high_bits >> 0x14 & 0x7ff;\n    boolean_variable = exponent_of_significand_high_bits == 0;\n  }\n  if (!boolean_variable) {\n    boolean_variable = exponent_of_mantissa_high_bits == 0x7ff;\n  }\n  if (!boolean_variable) {\n    boolean_variable = exponent_of_significand_high_bits == 0x7ff;\n  }\n  if (boolean_variable) {\n    64_bit_input_value = binary_to_double_080006a4();\n  }\n  upper_32_bits_of_multiplication = (uint)(64_bit_input_value >> 0x20);\n  iVar5 = exponent_of_mantissa_high_bits + exponent_of_significand_high_bits;\n  exponent_of_mantissa_high_bits = upper_32_bits_of_multiplication ^ exponent_and_significand_high_bits;\n  upper_32_bits_of_multiplication = upper_32_bits_of_multiplication & ~(mask << 0x15);\n  exponent_and_significand_high_bits = exponent_and_significand_high_bits & ~(mask << 0x15);\n  boolean_variable = ((uint)64_bit_input_value | upper_32_bits_of_multiplication << 0xc) == 0;\n  if (!boolean_variable) {\n    boolean_variable = (mantissa_low_bits | exponent_and_significand_high_bits << 0xc) == 0;\n  }\n  upper_32_bits_of_multiplication = upper_32_bits_of_multiplication | 0x100000;\n  exponent_and_significand_high_bits = exponent_and_significand_high_bits | 0x100000;\n  if (boolean_variable) {\n    mantissa_low_bits = (uint)64_bit_input_value | mantissa_low_bits;\n    exponent_and_significand_high_bits = (exponent_of_mantissa_high_bits & 0x80000000 | upper_32_bits_of_multiplication) ^ exponent_and_significand_high_bits;\n    exponent_of_mantissa_high_bits = mask >> 1;\n    boolean_variable = SBORROW4(iVar5,exponent_of_mantissa_high_bits);\n    temporary_variable = iVar5 - exponent_of_mantissa_high_bits;\n    boolean_variable = temporary_variable == 0;\n    upper_32_bits_of_multiplication = temporary_variable;\n    if (!boolean_variable && (int)exponent_of_mantissa_high_bits <= iVar5) {\n      boolean_variable = SBORROW4(mask,temporary_variable);\n      upper_32_bits_of_multiplication = mask - temporary_variable;\n      boolean_variable = mask == temporary_variable;\n    }\n    if (!boolean_variable && (int)upper_32_bits_of_multiplication < 0 == boolean_variable) {\n      exponent_and_significand_high_bits = exponent_and_significand_high_bits | temporary_variable * 0x100000;\n    }\n    if (!boolean_variable && (int)upper_32_bits_of_multiplication < 0 == boolean_variable) {\n      return CONCAT44(exponent_and_significand_high_bits,mantissa_low_bits);\n    }\n    exponent_and_significand_high_bits = exponent_and_significand_high_bits | 0x100000;\n    mask = 0;\n    boolean_variable = SBORROW4(temporary_variable,1);\n    temporary_variable = temporary_variable - 1;\n    boolean_variable = temporary_variable == 0;\n    exponent_of_mantissa_high_bits = temporary_variable;\n  }\n  else {\n    lower_32_bits_of_multiplication = (64_bit_input_value & 0xffffffff) * (ulonglong)mantissa_low_bits;\n    64_bit_input_value = (64_bit_input_value & 0xffffffff) * (ulonglong)exponent_and_significand_high_bits +\n             (ulonglong)upper_32_bits_of_multiplication * (ulonglong)mantissa_low_bits + (lower_32_bits_of_multiplication >> 0x20);\n    most_significant_32_bits_of_multiplication = (uint)64_bit_input_value;\n    64_bit_result_of_multiplication = (ulonglong)upper_32_bits_of_multiplication * (ulonglong)exponent_and_significand_high_bits + (64_bit_input_value >> 0x20);\n    mask = (uint)64_bit_result_of_multiplication;\n    upper_32_bits_of_multiplication = (uint)((ulonglong)64_bit_result_of_multiplication >> 0x20);\n    if ((int)lower_32_bits_of_multiplication != 0) {\n      most_significant_32_bits_of_multiplication = most_significant_32_bits_of_multiplication | 1;\n    }\n    temporary_variable = (iVar5 + -0x3ff) - (uint)(upper_32_bits_of_multiplication < 0x200);\n    if (upper_32_bits_of_multiplication < 0x200) {\n      boolean_variable = (most_significant_32_bits_of_multiplication & 0x80000000) != 0;\n      most_significant_32_bits_of_multiplication = most_significant_32_bits_of_multiplication << 1;\n      64_bit_result_of_multiplication = CONCAT44(upper_32_bits_of_multiplication * 2 + (uint)(CARRY4(mask,mask) || CARRY4(mask * 2,(uint)boolean_variable)),\n                       mask * 2 + (uint)boolean_variable);\n    }\n    exponent_and_significand_high_bits = exponent_of_mantissa_high_bits & 0x80000000 | (int)((ulonglong)64_bit_result_of_multiplication >> 0x20) << 0xb | (uint)64_bit_result_of_multiplication >> 0x15;\n    mantissa_low_bits = (uint)64_bit_result_of_multiplication << 0xb | most_significant_32_bits_of_multiplication >> 0x15;\n    mask = most_significant_32_bits_of_multiplication * 0x800;\n    boolean_variable = 0xfc < temporary_variable;\n    boolean_variable = SBORROW4(temporary_variable,0xfd);\n    upper_32_bits_of_multiplication = temporary_variable - 0xfd;\n    boolean_variable = upper_32_bits_of_multiplication == 0;\n    exponent_of_mantissa_high_bits = upper_32_bits_of_multiplication;\n    if (boolean_variable && !boolean_variable) {\n      boolean_variable = 0x6ff < upper_32_bits_of_multiplication;\n      boolean_variable = SBORROW4(upper_32_bits_of_multiplication,0x700);\n      exponent_of_mantissa_high_bits = temporary_variable - 0x7fd;\n      boolean_variable = upper_32_bits_of_multiplication == 0x700;\n    }\n    if (!boolean_variable || boolean_variable) {\n      boolean_variable = 0x7fffffff < mask;\n      if (mask == 0x80000000) {\n        boolean_variable = (most_significant_32_bits_of_multiplication >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(exponent_and_significand_high_bits + temporary_variable * 0x100000 + (uint)CARRY4(mantissa_low_bits,(uint)boolean_variable),mantissa_low_bits + boolean_variable\n                     );\n    }\n  }\n  if (!boolean_variable && (int)exponent_of_mantissa_high_bits < 0 == boolean_variable) {\n    return (ulonglong)(exponent_and_significand_high_bits & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  boolean_variable = SCARRY4(temporary_variable,0x36);\n  boolean_variable = (int)(temporary_variable + 0x36) < 0;\n  boolean_variable = temporary_variable == 0xffffffca;\n  if (boolean_variable || boolean_variable != boolean_variable) {\n    mantissa_low_bits = 0;\n  }\n  if (boolean_variable || boolean_variable != boolean_variable) {\n    exponent_and_significand_high_bits = exponent_and_significand_high_bits & 0x80000000;\n  }\n  if (boolean_variable || boolean_variable != boolean_variable) {\n    return CONCAT44(exponent_and_significand_high_bits,mantissa_low_bits);\n  }\n  exponent_of_mantissa_high_bits = -temporary_variable;\n  upper_32_bits_of_multiplication = exponent_of_mantissa_high_bits - 0x20;\n  if (0x1f < (int)exponent_of_mantissa_high_bits) {\n    temporary_variable = mantissa_low_bits >> (upper_32_bits_of_multiplication & 0xff) | exponent_and_significand_high_bits << (0x20 - upper_32_bits_of_multiplication & 0xff);\n    exponent_of_mantissa_high_bits = (exponent_and_significand_high_bits >> (upper_32_bits_of_multiplication & 0xff) & ~((exponent_and_significand_high_bits & 0x80000000) >> (upper_32_bits_of_multiplication & 0xff))) -\n            ((int)temporary_variable >> 0x1f);\n    if ((mask | mantissa_low_bits << (0x20 - upper_32_bits_of_multiplication & 0xff) | temporary_variable << 1) == 0) {\n      exponent_of_mantissa_high_bits = exponent_of_mantissa_high_bits & ~(temporary_variable >> 0x1f);\n    }\n    return CONCAT44(exponent_and_significand_high_bits,exponent_of_mantissa_high_bits) & 0x80000000ffffffff;\n  }\n  iVar5 = exponent_of_mantissa_high_bits - 0x14;\n  if (iVar5 == 0 || iVar5 < 0 != SCARRY4(upper_32_bits_of_multiplication,0xc)) {\n    most_significant_32_bits_of_multiplication = mantissa_low_bits << (temporary_variable + 0x20 & 0xff);\n    upper_32_bits_of_multiplication = mantissa_low_bits >> (exponent_of_mantissa_high_bits & 0xff) | exponent_and_significand_high_bits << (temporary_variable + 0x20 & 0xff);\n    temporary_variable = upper_32_bits_of_multiplication + -((int)most_significant_32_bits_of_multiplication >> 0x1f);\n    if ((mask | most_significant_32_bits_of_multiplication << 1) == 0) {\n      temporary_variable = temporary_variable & ~(most_significant_32_bits_of_multiplication >> 0x1f);\n    }\n    return CONCAT44((exponent_and_significand_high_bits & 0x80000000) +\n                    ((exponent_and_significand_high_bits & 0x7fffffff) >> (exponent_of_mantissa_high_bits & 0xff)) +\n                    (uint)CARRY4(upper_32_bits_of_multiplication,-((int)most_significant_32_bits_of_multiplication >> 0x1f)),temporary_variable);\n  }\n  exponent_of_mantissa_high_bits = 0xc - iVar5;\n  temporary_variable = mantissa_low_bits << (exponent_of_mantissa_high_bits & 0xff);\n  exponent_of_mantissa_high_bits = mantissa_low_bits >> (0x20 - exponent_of_mantissa_high_bits & 0xff) | exponent_and_significand_high_bits << (exponent_of_mantissa_high_bits & 0xff);\n  upper_32_bits_of_multiplication = exponent_of_mantissa_high_bits + -((int)temporary_variable >> 0x1f);\n  if ((mask | temporary_variable << 1) == 0) {\n    upper_32_bits_of_multiplication = upper_32_bits_of_multiplication & ~(temporary_variable >> 0x1f);\n  }\n  return CONCAT44((exponent_and_significand_high_bits & 0x80000000) + (uint)CARRY4(exponent_of_mantissa_high_bits,-((int)temporary_variable >> 0x1f)),upper_32_bits_of_multiplication);\n}\n\n",
            "called": [
                "FUN_080006a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004c8",
            "calling": [
                "FUN_080096e0",
                "FUN_08005e9c",
                "FUN_08004d78",
                "FUN_08004bd8",
                "FUN_080079e8",
                "FUN_080059f0"
            ],
            "imported": false,
            "current_name": "calculate_double_precision_floating_point_value_080004c8"
        },
        "FUN_08008ad4": {
            "renaming": {
                "FUN_08008ad4": "FUNC_08008ad4"
            },
            "code": "\nundefined * FUNC_08008ad4(void)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = *(undefined **)(*(int *)PTR_PTR_DAT_08008ae8 + 0x34);\n  if (*(undefined **)(*(int *)PTR_PTR_DAT_08008ae8 + 0x34) == (undefined *)0x0) {\n    puVar1 = PTR_DAT_08008aec;\n  }\n  return puVar1 + 0xf0;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008ad4",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "FUNC_08008ad4"
        },
        "FUN_080009e8": {
            "renaming": {
                "FUN_080009e8": "check_if_string_terminated_080009e8",
                "in_CY": "input_char",
                "check_params_and_return_08000978": "validate_input_and_return"
            },
            "code": "\nbool check_if_string_terminated_080009e8(void)\n\n{\n  char input_char;\n  \n  check_params_and_return_08000978();\n  return input_char == '\\0';\n}\n\n",
            "called": [
                "FUN_08000978"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009e8",
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8",
                "FUN_080059f0"
            ],
            "imported": false,
            "current_name": "check_if_string_terminated_080009e8"
        },
        "FUN_08005674": {
            "renaming": {
                "FUN_08005674": "infinite_loop_08005674"
            },
            "code": "\nvoid infinite_loop_08005674(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005674",
            "calling": [
                "FUN_080052a0",
                "FUN_08005598",
                "FUN_08005348",
                "FUN_08005500",
                "FUN_080053b0"
            ],
            "imported": false,
            "current_name": "infinite_loop_08005674"
        },
        "FUN_08003c4a": {
            "renaming": {
                "FUN_08003c4a": "do_nothing_08003c4a"
            },
            "code": "\nvoid do_nothing_08003c4a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003c4a",
            "calling": [
                "FUN_080036f8"
            ],
            "imported": false,
            "current_name": "do_nothing_08003c4a"
        },
        "FUN_08009630": {
            "renaming": {
                "FUN_08009630": "calculate_bits_08009630",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "param_3": "input_value_3",
                "param_4": "input_value_4",
                "param_5": "output_value_1",
                "param_6": "output_value_2",
                "iVar1": "pointer_to_allocated_memory",
                "uVar2": "number_of_bits",
                "iVar3": "leading_zeros",
                "iVar4": "number_of_values",
                "uVar5": "shifted_value",
                "uVar6": "shifted_bits",
                "local_20": "temporary_value_1",
                "local_1c": "temporary_value_2",
                "uVar7": "highest_bit_set"
            },
            "code": "\nint calculate_bits_08009630(undefined4 input_value_1,undefined4 input_value_2,uint input_value_3,uint input_value_4,int *output_value_1,\n                int *output_value_2)\n\n{\n  int pointer_to_allocated_memory;\n  uint number_of_bits;\n  int leading_zeros;\n  int number_of_values;\n  uint shifted_value;\n  uint shifted_bits;\n  undefined8 highest_bit_set;\n  uint temporary_value_1;\n  uint temporary_value_2;\n  \n  pointer_to_allocated_memory = allocate_or_get_pointer_080090c0(input_value_1,1);\n  shifted_bits = (input_value_4 << 1) >> 0x15;\n  temporary_value_2 = input_value_4 & 0xfffff;\n  if (shifted_bits != 0) {\n    temporary_value_2 = temporary_value_2 | 0x100000;\n  }\n  if (input_value_3 == 0) {\n    leading_zeros = count_leading_zeros_080091e4(&temporary_value_2);\n    number_of_values = 1;\n    number_of_bits = leading_zeros + 0x20;\n    *(undefined4 *)(pointer_to_allocated_memory + 0x10) = 1;\n    *(uint *)(pointer_to_allocated_memory + 0x14) = temporary_value_2;\n  }\n  else {\n    temporary_value_1 = input_value_3;\n    number_of_bits = count_leading_zeros_080091e4(&temporary_value_1);\n    if (number_of_bits == 0) {\n      *(uint *)(pointer_to_allocated_memory + 0x14) = temporary_value_1;\n    }\n    else {\n      shifted_value = temporary_value_2 << (0x20 - number_of_bits & 0xff);\n      temporary_value_2 = temporary_value_2 >> (number_of_bits & 0xff);\n      *(uint *)(pointer_to_allocated_memory + 0x14) = shifted_value | temporary_value_1;\n    }\n    if (temporary_value_2 == 0) {\n      number_of_values = 1;\n    }\n    else {\n      number_of_values = 2;\n    }\n    *(uint *)(pointer_to_allocated_memory + 0x18) = temporary_value_2;\n    *(int *)(pointer_to_allocated_memory + 0x10) = number_of_values;\n  }\n  if (shifted_bits == 0) {\n    *output_value_1 = number_of_bits - 0x432;\n    highest_bit_set = find_highest_bit_set_080091a4(*(undefined4 *)(pointer_to_allocated_memory + number_of_values * 4 + 0x10));\n    *output_value_2 = (int)((ulonglong)highest_bit_set >> 0x20) * 0x20 - (int)highest_bit_set;\n    return pointer_to_allocated_memory;\n  }\n  *output_value_1 = (shifted_bits - 0x433) + number_of_bits;\n  *output_value_2 = 0x35 - number_of_bits;\n  return pointer_to_allocated_memory;\n}\n\n",
            "called": [
                "FUN_080091e4",
                "FUN_080091a4",
                "FUN_080090c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009630",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "calculate_bits_08009630"
        },
        "FUN_08004104": {
            "renaming": {
                "FUN_08004104": "set_bits_shift_left_08004104",
                "param_1": "object_address",
                "param_2": "bits_to_set",
                "param_3": "bits_to_shift"
            },
            "code": "\nvoid set_bits_shift_left_08004104(int object_address,int bits_to_set,int bits_to_shift)\n\n{\n  *(uint *)(object_address + 0x20) = *(uint *)(object_address + 0x20) & 0xffffffef;\n  *(uint *)(object_address + 0x18) = bits_to_shift << 0xc | *(uint *)(object_address + 0x18) & 0xffff0fff;\n  *(uint *)(object_address + 0x20) = bits_to_set << 4 | *(uint *)(object_address + 0x20) & 0xffffff5f;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004104",
            "calling": [
                "FUN_08003a94"
            ],
            "imported": false,
            "current_name": "set_bits_shift_left_08004104"
        },
        "FUN_08000ff4": {
            "renaming": {
                "FUN_08000ff4": "check_if_input_is_null_terminated_08000ff4",
                "in_CY": "input_char",
                "concatenate_64bit_values_08000fd0": "concatenate_64bit_values"
            },
            "code": "\nbool check_if_input_is_null_terminated_08000ff4(void)\n\n{\n  char input_char;\n  \n  concatenate_64bit_values_08000fd0();\n  return input_char == '\\0';\n}\n\n",
            "called": [
                "FUN_08000fd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000ff4",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "check_if_input_is_null_terminated_08000ff4"
        },
        "FUN_08005714": {
            "renaming": {
                "FUN_08005714": "process_data_08005714"
            },
            "code": "\nvoid process_data_08005714(void)\n\n{\n  process_data_08005714_080036f8(PTR_DAT_08005724);\n  return;\n}\n\n",
            "called": [
                "FUN_080036f8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005714",
            "calling": [],
            "imported": false,
            "current_name": "process_data_08005714"
        },
        "FUN_08005d0c": {
            "renaming": {
                "FUN_08005d0c": "do_nothing_08005d0c"
            },
            "code": "\nvoid do_nothing_08005d0c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d0c",
            "calling": [
                "FUN_08005838",
                "FUN_080059f0"
            ],
            "imported": false,
            "current_name": "do_nothing_08005d0c"
        },
        "FUN_08005e40": {
            "renaming": {
                "FUN_08005e40": "find_first_set_bit_index_08005e40",
                "param_1": "input",
                "iVar1": "bit_offset",
                "puVar2": "data_ptr",
                "iVar3": "leading_zeroes_count",
                "uVar4": "data"
            },
            "code": "\nint find_first_set_bit_index_08005e40(uint input)\n\n{\n  int bit_offset;\n  uint *data_ptr;\n  int leading_zeroes_count;\n  uint data;\n  \n  data_ptr = (uint *)(input & 0xfffffffc);\n  bit_offset = -(input & 3);\n  data = *data_ptr;\n  if ((input & 3) != 0) {\n    data = data | 0xffffffffU >> ((bit_offset + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    data_ptr = data_ptr + 1;\n    data = data + 0xfefefeff & ~data & 0x80808080;\n    if (data != 0) break;\n    data = *data_ptr;\n    bit_offset = bit_offset + 4;\n  }\n  leading_zeroes_count = count_leading_zeroes(data & -data);\n  return bit_offset + (0x1fU - leading_zeroes_count >> 3);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e40",
            "calling": [
                "FUN_08005e9c",
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "find_first_set_bit_index_08005e40"
        },
        "FUN_08005d20": {
            "renaming": {
                "FUN_08005d20": "execute_functions_08005d20",
                "puVar1": "pointer_to_end_of_functions",
                "iVar2": "counter",
                "ppcVar3": "pointer_to_functions",
                "iVar4": "number_of_functions"
            },
            "code": "\nvoid execute_functions_08005d20(void)\n\n{\n  undefined *pointer_to_end_of_functions;\n  int counter;\n  code **pointer_to_functions;\n  int number_of_functions;\n  \n  number_of_functions = (int)PTR_DAT_08005d58 - (int)PTR_DAT_08005d5c >> 2;\n  if (number_of_functions != 0) {\n    counter = 0;\n    pointer_to_functions = (code **)PTR_DAT_08005d5c;\n    do {\n      counter = counter + 1;\n      (**pointer_to_functions)();\n      pointer_to_functions = pointer_to_functions + 1;\n    } while (number_of_functions != counter);\n  }\n  pointer_to_functions = (code **)PTR_DAT_08005d64;\n  pointer_to_end_of_functions = PTR_DAT_08005d60;\n  do_nothing_08009e68();\n  number_of_functions = (int)pointer_to_end_of_functions - (int)pointer_to_functions >> 2;\n  if (number_of_functions != 0) {\n    counter = 0;\n    do {\n      counter = counter + 1;\n      (**pointer_to_functions)();\n      pointer_to_functions = pointer_to_functions + 1;\n    } while (number_of_functions != counter);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08000134",
                "FUN_080078a0",
                "FUN_08009e68"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d20",
            "calling": [
                "FUN_080057e8"
            ],
            "imported": false,
            "current_name": "execute_functions_08005d20"
        },
        "FUN_08001a80": {
            "renaming": {
                "FUN_08001a80": "set_parameter_value_08001a80",
                "param_1": "parameter_address",
                "param_2": "parameter_value",
                "param_3": "is_high_byte_set",
                "uint": "unsigned_integer"
            },
            "code": "\nvoid set_parameter_value_08001a80(int parameter_address,ushort parameter_value,char is_high_byte_set)\n\n{\n  if (is_high_byte_set == '\\0') {\n    *(unsigned_integer *)(parameter_address + 0x10) = (unsigned_integer)parameter_value << 0x10;\n  }\n  else {\n    *(unsigned_integer *)(parameter_address + 0x10) = (unsigned_integer)parameter_value;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001a80",
            "calling": [
                "FUN_080055f4",
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "set_parameter_value_08001a80"
        },
        "FUN_08005838": {
            "renaming": {
                "FUN_08005838": "calculate_result_08005838",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "difference",
                "uVar2": "upper_result",
                "uVar3": "operation_type",
                "uVar4": "result",
                "uVar5": "positive_input_2",
                "uVar6": "concatenated_values"
            },
            "code": "\nuint calculate_result_08005838(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  int difference;\n  undefined4 upper_result;\n  uint operation_type;\n  uint result;\n  uint positive_input_2;\n  undefined8 concatenated_values;\n  \n  concatenated_values = CONCAT44(DAT_080059bc,DAT_080059b8);\n  result = input_4 & 0x7fffffff;\n  if ((DAT_080059e8 < (result | (-input_3 | input_3) >> 0x1f)) ||\n     (positive_input_2 = input_2 & 0x7fffffff, DAT_080059e8 < (positive_input_2 | (-input_1 | input_1) >> 0x1f))) {\n    result = calculate_double_precision_float_0800015c(input_3,input_4,input_1,input_2);\n    return result;\n  }\n  if ((input_4 + 0xc0100000 | input_3) == 0) {\n    result = calculate_result_08005838_080059f0();\n    return result;\n  }\n  operation_type = (int)input_4 >> 0x1e & 2U | input_2 >> 0x1f;\n  if ((positive_input_2 | input_1) == 0) {\n    if (operation_type == 2) {\n      return DAT_080059b0;\n    }\n    result = DAT_080059a0;\n    if (operation_type != 3) {\n      return input_1;\n    }\n  }\n  else {\n    if ((result | input_3) != 0) {\n      if (result == DAT_080059e8) {\n        if (positive_input_2 == result) {\n          if (operation_type == 2) {\n            return DAT_080059e0;\n          }\n          if (operation_type == 3) {\n            return DAT_080059d8;\n          }\n          if (operation_type == 1) {\n            return DAT_080059d0;\n          }\n          return DAT_080059c8;\n        }\n        if (operation_type == 2) {\n          return DAT_080059b0;\n        }\n        if (operation_type == 3) {\n          return DAT_080059a0;\n        }\n        if (operation_type == 1) {\n          return 0;\n        }\n        return 0;\n      }\n      if (positive_input_2 != DAT_080059e8) {\n        difference = (int)(positive_input_2 - result) >> 0x14;\n        if (difference < 0x3d) {\n          if (((int)input_4 < 0) && (difference + 0x3c < 0 != SCARRY4(difference,0x3c))) {\n            concatenated_values = 0;\n          }\n          else {\n            FUNC_0800071c(input_1,input_2,input_3,input_4,input_4);\n            do_nothing_08005d0c();\n            concatenated_values = calculate_result_08005838_080059f0();\n          }\n        }\n        upper_result = (undefined4)((ulonglong)concatenated_values >> 0x20);\n        result = (uint)concatenated_values;\n        if (operation_type == 1) {\n          return result;\n        }\n        if (operation_type == 2) {\n          concatenated_values = floating_point_addition_08000158(result,upper_result,DAT_080059a8,DAT_080059ac);\n          result = floating_point_addition_08000158(DAT_080059b0,DAT_080059b4,(int)concatenated_values,(int)((ulonglong)concatenated_values >> 0x20))\n          ;\n          return result;\n        }\n        if (operation_type == 0) {\n          return result;\n        }\n        concatenated_values = floating_point_addition_08000158(result,upper_result,DAT_080059a8,DAT_080059ac);\n        result = floating_point_addition_08000158((int)concatenated_values,(int)((ulonglong)concatenated_values >> 0x20),DAT_080059b0,DAT_080059b4);\n        return result;\n      }\n    }\n    result = DAT_080059c0;\n    if (-1 < (int)input_2) {\n      result = DAT_080059b8;\n    }\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_08000158",
                "FUN_0800015c",
                "FUN_0800071c",
                "FUN_08005d0c",
                "FUN_080059f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005838",
            "calling": [
                "thunk_FUN_08005838"
            ],
            "imported": false,
            "current_name": "calculate_result_08005838"
        },
        "FUN_080090a8": {
            "renaming": {
                "FUN_080090a8": "do_nothing_with_pointer_080090a8"
            },
            "code": "\nvoid do_nothing_with_pointer_080090a8(void)\n\n{\n  do_nothing_08008af0(PTR_DAT_080090b0);\n  return;\n}\n\n",
            "called": [
                "FUN_08008af0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090a8",
            "calling": [
                "FUN_0800884c",
                "FUN_08009adc",
                "FUN_08008af8",
                "FUN_080088ec"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_080090a8"
        },
        "FUN_08004e74": {
            "renaming": {
                "FUN_08004e74": "interrupt_handler_08004e74",
                "param_1": "input_value",
                "uVar1": "return_value"
            },
            "code": "\nundefined4 interrupt_handler_08004e74(undefined4 input_value)\n\n{\n  undefined4 return_value;\n  \n  if (*(int *)PTR_DAT_08004ea0 == 0) {\n    return_value = software_interrupt_handler_08004e74_08004e6c(1,input_value,0);\n  }\n  else {\n    return_value = 0;\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_08004e6c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e74",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "interrupt_handler_08004e74"
        },
        "FUN_080096e0": {
            "renaming": {
                "FUN_080096e0": "calculate_floating_point_value_080096e0",
                "param_1": "mantissa_low",
                "param_2": "mantissa_high",
                "param_3": "exponent",
                "param_4": "rounding_mode",
                "iVar1": "max_exponent",
                "iVar2": "exponent_offset",
                "uVar3": "absolute_value",
                "uVar4": "floating_point_value"
            },
            "code": "\nundefined8 calculate_floating_point_value_080096e0(uint mantissa_low,uint mantissa_high,int *exponent,undefined4 rounding_mode)\n\n{\n  int max_exponent;\n  int exponent_offset;\n  uint absolute_value;\n  undefined8 floating_point_value;\n  \n  max_exponent = DAT_08009740;\n  floating_point_value = CONCAT44(mantissa_high,mantissa_low);\n  exponent_offset = 0;\n  absolute_value = mantissa_high & 0x7fffffff;\n  *exponent = 0;\n  if (((int)absolute_value <= max_exponent) && ((absolute_value | mantissa_low) != 0)) {\n    if (absolute_value < 0x100000) {\n      floating_point_value = calculate_double_precision_floating_point_value_080004c8(mantissa_low,mantissa_high,0,DAT_0800973c,rounding_mode);\n      exponent_offset = -0x36;\n      absolute_value = (uint)((ulonglong)floating_point_value >> 0x20) & 0x7fffffff;\n    }\n    mantissa_low = (uint)floating_point_value;\n    mantissa_high = (uint)((ulonglong)floating_point_value >> 0x20) & 0x800fffff | 0x3fe00000;\n    *exponent = ((int)absolute_value >> 0x14) + -0x3fe + exponent_offset;\n  }\n  return CONCAT44(mantissa_high,mantissa_low);\n}\n\n",
            "called": [
                "FUN_080004c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080096e0",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "calculate_floating_point_value_080096e0"
        },
        "FUN_0800910c": {
            "renaming": {
                "FUN_0800910c": "retrieve_and_set_value_0800910c",
                "param_1": "base_address",
                "param_2": "value_pointer",
                "iVar1": "data_address"
            },
            "code": "\nvoid retrieve_and_set_value_0800910c(int base_address,undefined4 *value_pointer)\n\n{\n  int data_address;\n  \n  if (value_pointer != (undefined4 *)0x0) {\n    data_address = *(int *)(base_address + 0x4c);\n    *value_pointer = *(undefined4 *)(data_address + value_pointer[1] * 4);\n    *(undefined4 **)(data_address + value_pointer[1] * 4) = value_pointer;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800910c",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "retrieve_and_set_value_0800910c"
        },
        "FUN_080052a0": {
            "renaming": {
                "FUN_080052a0": "calculate_and_write_result_080052a0",
                "local_30": "param_1",
                "local_2c": "param_2",
                "local_28": "param_3",
                "local_20": "param_4",
                "local_14": "param_5",
                "local_10": "param_6",
                "local_c": "param_7",
                "local_44": "result_mask",
                "local_40": "result_shift",
                "local_3c": "result_offset",
                "local_38": "unused_1",
                "local_34": "unused_2",
                "iVar2": "result"
            },
            "code": "\nvoid calculate_and_write_result_080052a0(void)\n\n{\n  longlong lVar1;\n  int result;\n  ulonglong uVar3;\n  undefined4 result_mask;\n  undefined4 result_shift;\n  undefined4 result_offset;\n  undefined4 unused_1;\n  undefined4 unused_2;\n  undefined4 param_1;\n  undefined4 param_2;\n  undefined4 param_3;\n  undefined4 param_4;\n  undefined4 param_5;\n  undefined4 param_6;\n  undefined4 param_7;\n  \n  param_1 = 1;\n  param_2 = 0x10000;\n  param_3 = 0;\n  param_4 = 1;\n  param_5 = 2;\n  param_6 = 0x10000;\n  param_7 = 0x1c0000;\n  result = check_parameters_08002d98(&param_1);\n  if (result != 0) {\n    infinite_loop_08005674(PTR_s____src_main_c_08005340,0x151);\n  }\n  result_mask = 0xf;\n  result_shift = 2;\n  result_offset = 0x80;\n  unused_1 = 0;\n  unused_2 = 0;\n  result = calculate_and_write_result_080052a0_to_memory_08003260(&result_mask,2);\n  if (result != 0) {\n    infinite_loop_08005674(PTR_s____src_main_c_08005340,0x15e);\n  }\n  uVar3 = get_pointer_value_08003504();\n  lVar1 = (ulonglong)DAT_08005344 * (uVar3 & 0xffffffff);\n  write_param_to_memory_08001762((uint)((ulonglong)lVar1 >> 0x26),(int)(uVar3 >> 0x20),(int)lVar1);\n  set_flag_if_param_1_is_4_0800177c(4);\n  write_data_to_memory_0800172a(0xffffffff,0,0);\n  return;\n}\n\n",
            "called": [
                "FUN_08005674",
                "FUN_08003504",
                "FUN_08001762",
                "FUN_08003260",
                "FUN_0800177c",
                "FUN_08002d98",
                "FUN_0800172a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052a0",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "calculate_and_write_result_080052a0"
        },
        "FUN_08009120": {
            "renaming": {
                "FUN_08009120": "multiply_and_accumulate_08009120",
                "param_1": "param_address",
                "param_2": "input_array",
                "param_3": "multiplier",
                "param_4": "accumulator",
                "puVar1": "output_array",
                "uVar2": "carry",
                "iVar3": "array_length",
                "puVar4": "input_array_ptr",
                "iVar5": "loop_counter"
            },
            "code": "\nundefined4 * multiply_and_accumulate_08009120(int param_address,undefined4 *input_array,int multiplier,uint accumulator)\n\n{\n  undefined4 *output_array;\n  uint carry;\n  int array_length;\n  uint *input_array_ptr;\n  int loop_counter;\n  \n  loop_counter = 0;\n  array_length = input_array[4];\n  input_array_ptr = input_array + 5;\n  do {\n    loop_counter = loop_counter + 1;\n    accumulator = multiplier * (*input_array_ptr & 0xffff) + accumulator;\n    carry = multiplier * (*input_array_ptr >> 0x10) + (accumulator >> 0x10);\n    *input_array_ptr = (accumulator & 0xffff) + carry * 0x10000;\n    accumulator = carry >> 0x10;\n    input_array_ptr = input_array_ptr + 1;\n  } while (loop_counter < array_length);\n  output_array = input_array;\n  if (accumulator != 0) {\n    if ((int)input_array[2] <= array_length) {\n      output_array = (undefined4 *)allocate_or_get_pointer_080090c0(param_address,input_array[1] + 1);\n      copy_memory_08001084(output_array + 3,input_array + 3,(input_array[4] + 2) * 4);\n      loop_counter = *(int *)(param_address + 0x4c);\n      *input_array = *(undefined4 *)(loop_counter + input_array[1] * 4);\n      *(undefined4 **)(loop_counter + input_array[1] * 4) = input_array;\n    }\n    output_array[array_length + 5] = accumulator;\n    output_array[4] = array_length + 1;\n  }\n  return output_array;\n}\n\n",
            "called": [
                "FUN_08001084",
                "FUN_080090c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009120",
            "calling": [
                "FUN_080093a4",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "multiply_and_accumulate_08009120"
        },
        "FUN_08001084": {
            "renaming": {
                "FUN_08001084": "copy_memory_08001084",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "size",
                "puVar1": "dest_ptr",
                "puVar2": "dst",
                "puVar3": "src",
                "uVar4": "remaining_size",
                "uVar5": "remaining_size_2",
                "bVar6": "loop_condition"
            },
            "code": "\nundefined4 * copy_memory_08001084(undefined4 *destination,undefined4 *source,uint size)\n\n{\n  undefined4 *dest_ptr;\n  undefined4 *dst;\n  undefined4 *src;\n  uint remaining_size;\n  uint remaining_size_2;\n  bool loop_condition;\n  \n  dst = destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (size < 8) {\n      remaining_size_2 = size - 4;\n      if (3 < size) {\n        do {\n          dest_ptr = source;\n          src = dst;\n          loop_condition = remaining_size_2 != 0;\n          remaining_size_2 = remaining_size_2 - 1;\n          *(undefined *)src = *(undefined *)dest_ptr;\n          dst = (undefined4 *)((int)src + 1);\n          source = (undefined4 *)((int)dest_ptr + 1);\n        } while (loop_condition);\n        *(undefined *)(undefined4 *)((int)src + 1) =\n             *(undefined *)(undefined4 *)((int)dest_ptr + 1);\n        *(undefined *)((int)src + 2) = *(undefined *)((int)dest_ptr + 2);\n        *(undefined *)((int)src + 3) = *(undefined *)((int)dest_ptr + 3);\n        return destination;\n      }\n      goto LAB_08001108;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      remaining_size_2 = 4 - ((uint)destination & 3);\n      size = size - remaining_size_2;\n      dest_ptr = destination;\n      src = source;\n      if (((uint)destination & 1) != 0) {\n        src = (undefined4 *)((int)source + 1);\n        dest_ptr = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *(undefined *)source;\n      }\n      dst = dest_ptr;\n      source = src;\n      if ((remaining_size_2 & 2) != 0) {\n        source = (undefined4 *)((int)src + 2);\n        dst = (undefined4 *)((int)dest_ptr + 2);\n        *(undefined2 *)dest_ptr = *(undefined2 *)src;\n      }\n    }\n  }\n  while (0x3f < size) {\n    *dst = *source;\n    dst[1] = source[1];\n    dst[2] = source[2];\n    dst[3] = source[3];\n    dst[4] = source[4];\n    dst[5] = source[5];\n    dst[6] = source[6];\n    dst[7] = source[7];\n    dst[8] = source[8];\n    dst[9] = source[9];\n    dst[10] = source[10];\n    dst[0xb] = source[0xb];\n    dst[0xc] = source[0xc];\n    dst[0xd] = source[0xd];\n    dst[0xe] = source[0xe];\n    dst[0xf] = source[0xf];\n    dst = dst + 0x10;\n    source = source + 0x10;\n    size = size - 0x40;\n  }\n  remaining_size = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n      *dst = *source;\n      dst[1] = source[1];\n      dst[2] = source[2];\n      dst[3] = source[3];\n      dst = dst + 4;\n      source = source + 4;\n      loop_condition = 0xf < remaining_size;\n      remaining_size = remaining_size - 0x10;\n    } while (loop_condition);\n  }\n  remaining_size_2 = remaining_size + 0xc;\n  src = dst;\n  dest_ptr = source;\n  if (0xfffffff3 < remaining_size) {\n    do {\n      source = dest_ptr + 1;\n      *src = *dest_ptr;\n      loop_condition = 3 < remaining_size_2;\n      remaining_size_2 = remaining_size_2 - 4;\n      dst = src + 1;\n      src = src + 1;\n      dest_ptr = source;\n    } while (loop_condition);\n  }\nLAB_08001108:\n  if (remaining_size_2 + 4 != 0) {\n    dest_ptr = dst;\n    src = source;\n    if ((remaining_size_2 & 1) != 0) {\n      src = (undefined4 *)((int)source + 1);\n      dest_ptr = (undefined4 *)((int)dst + 1);\n      *(undefined *)dst = *(undefined *)source;\n    }\n    if ((remaining_size_2 + 4 & 2) != 0) {\n      *(undefined2 *)dest_ptr = *(undefined2 *)src;\n    }\n  }\n  return destination;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001084",
            "calling": [
                "FUN_080097cc",
                "FUN_08009120",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "copy_memory_08001084"
        },
        "FUN_08005680": {
            "renaming": {
                "FUN_08005680": "parse_bits_from_binary_08005680",
                "param_1": "binary_data",
                "local_18": "bits_to_parse",
                "local_14": "parse_limit",
                "local_c": "parse_offset"
            },
            "code": "\nvoid parse_bits_from_binary_08005680(int *binary_data)\n\n{\n  undefined4 bits_to_parse;\n  undefined4 parse_limit;\n  undefined4 parse_offset;\n  \n  if (*binary_data == DAT_080056b4) {\n    bits_to_parse = 0x900;\n    parse_limit = 2;\n    parse_offset = 2;\n    parse_bits_080017c4(DAT_080056b8,&bits_to_parse);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_080017c4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005680",
            "calling": [
                "FUN_080053b0"
            ],
            "imported": false,
            "current_name": "parse_bits_from_binary_08005680"
        },
        "FUN_08003260": {
            "renaming": {
                "FUN_08003260": "calculate_and_write_result_to_memory_08003260",
                "param_1": "input_params",
                "param_2": "input_param_length",
                "iVar1": "start_pointer_value",
                "iVar2": "current_pointer_value",
                "uVar3": "result",
                "uVar4": "return_value"
            },
            "code": "\nundefined4 calculate_and_write_result_to_memory_08003260(uint *input_params,uint input_param_length)\n\n{\n  int start_pointer_value;\n  int current_pointer_value;\n  uint result;\n  undefined4 return_value;\n  \n  if (((*DAT_08003430 & 7) < input_param_length) &&\n     (*DAT_08003430 = input_param_length | *DAT_08003430 & 0xfffffff8, input_param_length != (*DAT_08003430 & 7))) {\n    return_value = 1;\n  }\n  else {\n    if ((*input_params & 2) != 0) {\n      DAT_08003434[1] = input_params[2] | DAT_08003434[1] & 0xffffff0f;\n    }\n    if ((*input_params & 1) == 0) {\nLAB_08003394:\n      if ((input_param_length < (*DAT_08003430 & 7)) &&\n         (*DAT_08003430 = input_param_length | *DAT_08003430 & 0xfffffff8, input_param_length != (*DAT_08003430 & 7))) {\n        return_value = 1;\n      }\n      else {\n        if ((*input_params & 4) != 0) {\n          DAT_08003434[1] = input_params[3] | DAT_08003434[1] & 0xfffff8ff;\n        }\n        if ((*input_params & 8) != 0) {\n          DAT_08003434[1] = input_params[4] << 3 | DAT_08003434[1] & 0xffffc7ff;\n        }\n        result = calculate_result_08003440();\n        *(uint *)PTR_DAT_0800343c = result >> PTR_DAT_08003438[DAT_08003434[1] >> 4 & 0xf];\n        write_param_to_memory_0800151c(0xf);\n        return_value = 0;\n      }\n    }\n    else {\n      if (input_params[1] == 1) {\n        if ((*DAT_08003434 & 0x20000) == 0) {\n          return 1;\n        }\n      }\n      else if ((input_params[1] != 2) && ((*DAT_08003434 & 2) == 0)) {\n        return 1;\n      }\n      DAT_08003434[1] = input_params[1] | DAT_08003434[1] & 0xfffffffc;\n      start_pointer_value = get_pointer_value_080015a0();\n      if (input_params[1] == 1) {\n        do {\n          if ((DAT_08003434[1] & 0xc) == 4) goto LAB_08003394;\n          current_pointer_value = get_pointer_value_080015a0();\n        } while ((uint)(current_pointer_value - start_pointer_value) < 0x1389);\n        return_value = 3;\n      }\n      else if (input_params[1] == 2) {\n        do {\n          if ((DAT_08003434[1] & 0xc) == 8) goto LAB_08003394;\n          current_pointer_value = get_pointer_value_080015a0();\n        } while ((uint)(current_pointer_value - start_pointer_value) < 0x1389);\n        return_value = 3;\n      }\n      else {\n        do {\n          if ((DAT_08003434[1] & 0xc) == 0) goto LAB_08003394;\n          current_pointer_value = get_pointer_value_080015a0();\n        } while ((uint)(current_pointer_value - start_pointer_value) < 0x1389);\n        return_value = 3;\n      }\n    }\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_08003440",
                "FUN_0800151c",
                "FUN_080015a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003260",
            "calling": [
                "FUN_080052a0"
            ],
            "imported": false,
            "current_name": "calculate_and_write_result_to_memory_08003260"
        },
        "FUN_08001ab0": {
            "renaming": {
                "FUN_08001ab0": "calculate_values_and_set_flags_08001ab0",
                "param_1": "params",
                "uVar1": "shifted_pointer_value",
                "cVar2": "should_set_flag",
                "uVar3": "return_value",
                "uVar4": "temp_value",
                "bVar5": "is_zero",
                "do_nothing_08001cb8": "do_nothing",
                "param_1[1]": "params_1",
                "param_1[2]": "params_2"
            },
            "code": "\nundefined4 calculate_values_and_set_flags_08001ab0(uint **params)\n\n{\n  uint shifted_pointer_value;\n  char should_set_flag;\n  undefined4 return_value;\n  uint temp_value;\n  bool is_zero;\n  \n  if (params == (uint **)0x0) {\n    return_value = 1;\n  }\n  else {\n    if (*(char *)((int)params + 0x3d) == '\\0') {\n      *(undefined *)(params + 0xf) = 0;\n      do_nothing_08001cb8(params);\n    }\n    *(undefined *)((int)params + 0x3d) = 0x24;\n    **params = **params & 0xfffffffe;\n    shifted_pointer_value = get_shifted_pointer_value_08003518();\n    if (DAT_08001ca4 < params_1) {\n      temp_value = shifted_pointer_value;\n      if (shifted_pointer_value <= DAT_08001cac) {\n        temp_value = 1;\n      }\n      should_set_flag = (char)temp_value;\n      if (DAT_08001cac < shifted_pointer_value) {\n        should_set_flag = '\\0';\n      }\n    }\n    else {\n      temp_value = shifted_pointer_value;\n      if (shifted_pointer_value <= DAT_08001ca8) {\n        temp_value = 1;\n      }\n      should_set_flag = (char)temp_value;\n      if (DAT_08001ca8 < shifted_pointer_value) {\n        should_set_flag = '\\0';\n      }\n    }\n    if (should_set_flag == '\\0') {\n      temp_value = (uint)((ulonglong)DAT_08001cb0 * (ulonglong)shifted_pointer_value >> 0x32);\n      (*params)[1] = temp_value;\n      if (DAT_08001ca4 < params_1) {\n        temp_value = (uint)((ulonglong)DAT_08001cb4 * (ulonglong)(temp_value * 300) >> 0x26);\n      }\n      (*params)[8] = temp_value + 1;\n      if (DAT_08001ca4 < params_1) {\n        if (params_2 == (uint *)0x0) {\n          temp_value = (shifted_pointer_value - 1) / (uint)((int)params_1 * 3) + 1 & 0xfff;\n          is_zero = temp_value == 0;\n          if (is_zero) {\n            temp_value = 1;\n          }\n          should_set_flag = (char)temp_value;\n          if (!is_zero) {\n            should_set_flag = '\\0';\n          }\n        }\n        else {\n          temp_value = (shifted_pointer_value - 1) / (uint)((int)params_1 * 0x19) + 1 & 0xfff;\n          is_zero = temp_value == 0;\n          if (is_zero) {\n            temp_value = 1;\n          }\n          should_set_flag = (char)temp_value;\n          if (!is_zero) {\n            should_set_flag = '\\0';\n          }\n        }\n        if (should_set_flag == '\\0') {\n          if (params_2 == (uint *)0x0) {\n            shifted_pointer_value = (shifted_pointer_value - 1) / (uint)((int)params_1 * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            shifted_pointer_value = (shifted_pointer_value - 1) / (uint)((int)params_1 * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          shifted_pointer_value = 1;\n        }\n      }\n      else {\n        shifted_pointer_value = (shifted_pointer_value - 1) / (uint)((int)params_1 << 1) + 1 & 0xfff;\n        if (shifted_pointer_value < 4) {\n          shifted_pointer_value = 4;\n        }\n      }\n      (*params)[7] = shifted_pointer_value;\n      **params = (uint)params[8] | (uint)params[7];\n      (*params)[2] = (uint)params[3] | (uint)params[4];\n      (*params)[3] = (uint)params[6] | (uint)params[5];\n      **params = **params | 1;\n      params[0x10] = (uint *)0x0;\n      *(undefined *)((int)params + 0x3d) = 0x20;\n      params[0xc] = (uint *)0x0;\n      *(undefined *)((int)params + 0x3e) = 0;\n      return_value = 0;\n    }\n    else {\n      return_value = 1;\n    }\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_08001cb8",
                "FUN_08003518"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001ab0",
            "calling": [
                "FUN_08005348"
            ],
            "imported": false,
            "current_name": "calculate_values_and_set_flags_08001ab0"
        },
        "FUN_08003540": {
            "renaming": {
                "FUN_08003540": "shift_pointer_value_08003540",
                "uVar1": "pointer_value"
            },
            "code": "\nuint shift_pointer_value_08003540(void)\n\n{\n  uint pointer_value;\n  \n  pointer_value = get_pointer_value_08003504();\n  return pointer_value >> PTR_DAT_08003564[*(uint *)(DAT_08003560 + 4) >> 0xb & 7];\n}\n\n",
            "called": [
                "FUN_08003504"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003540",
            "calling": [
                "FUN_080046ec"
            ],
            "imported": false,
            "current_name": "shift_pointer_value_08003540"
        },
        "FUN_08009244": {
            "renaming": {
                "FUN_08009244": "allocate_and_initialize_08009244",
                "param_1": "size",
                "param_2": "value",
                "iVar1": "allocated_pointer"
            },
            "code": "\nvoid allocate_and_initialize_08009244(undefined4 size,undefined4 value)\n\n{\n  int allocated_pointer;\n  \n  allocated_pointer = allocate_or_get_pointer_080090c0(size,1);\n  *(undefined4 *)(allocated_pointer + 0x10) = 1;\n  *(undefined4 *)(allocated_pointer + 0x14) = value;\n  return;\n}\n\n",
            "called": [
                "FUN_080090c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009244",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_08009244"
        },
        "FUN_08003c5c": {
            "renaming": {
                "FUN_08003c5c": "do_nothing_08003c5c"
            },
            "code": "\nvoid do_nothing_08003c5c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003c5c",
            "calling": [
                "FUN_080036f8"
            ],
            "imported": false,
            "current_name": "do_nothing_08003c5c"
        },
        "FUN_08004e6c": {
            "renaming": {
                "FUN_08004e6c": "software_interrupt_handler_08004e6c"
            },
            "code": "\nvoid software_interrupt_handler_08004e6c(void)\n\n{\n  software_interrupt(0x3f);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e6c",
            "calling": [
                "FUN_08004e74"
            ],
            "imported": false,
            "current_name": "software_interrupt_handler_08004e6c"
        },
        "FUN_08001762": {
            "renaming": {
                "FUN_08001762": "write_param_to_memory_08001762",
                "param_1": "param",
                "uVar1": "result"
            },
            "code": "\nundefined4 write_param_to_memory_08001762(undefined4 param)\n\n{\n  undefined4 result;\n  \n  result = check_param_and_write_to_memory_080016d0(param);\n  return result;\n}\n\n",
            "called": [
                "FUN_080016d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001762",
            "calling": [
                "FUN_080052a0",
                "FUN_0800151c"
            ],
            "imported": false,
            "current_name": "write_param_to_memory_08001762"
        },
        "FUN_08000158": {
            "renaming": {
                "FUN_08000158": "floating_point_addition_08000158",
                "iVar1": "shift_amount_1",
                "bVar2": "carry_flag_1",
                "uVar3": "sum_1",
                "uVar4": "mantissa_a",
                "uVar5": "mantissa_c",
                "uVar6": "mantissa_b",
                "uVar7": "mantissa_d",
                "iVar8": "shift_amount_2",
                "uVar9": "exponent_a",
                "uVar10": "exponent_c",
                "uVar11": "exponent_b",
                "uVar12": "exponent_d",
                "bVar13": "equal_exponents",
                "bVar14": "carry_flag_2",
                "bVar15": "negative_result"
            },
            "code": "\nulonglong floating_point_addition_08000158(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int shift_amount_1;\n  byte carry_flag_1;\n  uint sum_1;\n  uint mantissa_a;\n  uint mantissa_c;\n  uint mantissa_b;\n  uint mantissa_d;\n  int shift_amount_2;\n  uint exponent_a;\n  uint exponent_c;\n  uint exponent_b;\n  uint exponent_d;\n  bool equal_exponents;\n  bool carry_flag_2;\n  bool negative_result;\n  \n  mantissa_b = param_4 ^ 0x80000000;\n  exponent_a = param_2 << 1;\n  param_4 = param_4 << 1;\n  equal_exponents = ((param_2 ^ mantissa_b) & 0x7fffffff) == 0;\n  carry_flag_2 = equal_exponents && param_1 == param_3;\n  if (!equal_exponents || param_1 != param_3) {\n    carry_flag_2 = (exponent_a | param_1) == 0;\n  }\n  if (!carry_flag_2) {\n    carry_flag_2 = (param_4 | param_3) == 0;\n  }\n  shift_amount_2 = (int)exponent_a >> 0x15;\n  if (!carry_flag_2) {\n    carry_flag_2 = shift_amount_2 == -1;\n  }\n  shift_amount_1 = (int)param_4 >> 0x15;\n  if (!carry_flag_2) {\n    carry_flag_2 = shift_amount_1 == -1;\n  }\n  if (carry_flag_2) {\n    if (shift_amount_2 == -1 || shift_amount_1 == -1) {\n      exponent_a = mantissa_b;\n      exponent_b = param_3;\n      if (shift_amount_2 == -1) {\n        exponent_a = param_2;\n        exponent_b = param_1;\n      }\n      if (shift_amount_2 != -1 || shift_amount_1 != -1) {\n        param_3 = exponent_b;\n        mantissa_b = exponent_a;\n      }\n      carry_flag_2 = (exponent_b | exponent_a << 0xc) == 0;\n      if (carry_flag_2) {\n        carry_flag_2 = (param_3 | mantissa_b << 0xc) == 0;\n      }\n      if (carry_flag_2) {\n        carry_flag_2 = exponent_a == mantissa_b;\n      }\n      if (!carry_flag_2) {\n        exponent_a = exponent_a | 0x80000;\n      }\n      return CONCAT44(exponent_a,exponent_b);\n    }\n    if (((param_2 ^ mantissa_b) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((exponent_a | param_1) == 0) {\n        param_1 = param_3;\n        param_2 = mantissa_b;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 != mantissa_b) {\n      return 0;\n    }\n    if (exponent_a >> 0x15 == 0) {\n      carry_flag_2 = (param_1 & 0x80000000) != 0;\n      mantissa_b = param_2 * 2 + (uint)carry_flag_2;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)carry_flag_2)) {\n        mantissa_b = mantissa_b | 0x80000000;\n      }\n      return CONCAT44(mantissa_b,param_1 << 1);\n    }\n    if (exponent_a < 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 = param_2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(param_2 | 0x7ff00000) << 0x20;\n  }\n  exponent_a = exponent_a >> 0x15;\n  param_4 = param_4 >> 0x15;\n  exponent_b = param_4 - exponent_a;\n  carry_flag_2 = exponent_b != 0;\n  if (param_4 < exponent_a) {\n    exponent_b = -exponent_b;\n  }\n  exponent_c = param_1;\n  mantissa_d = param_2;\n  if (carry_flag_2 && exponent_a <= param_4) {\n    exponent_a = exponent_a + exponent_b;\n    exponent_c = param_3;\n    mantissa_d = mantissa_b;\n    param_3 = param_1;\n    mantissa_b = param_2;\n  }\n  if (0x36 < exponent_b) {\n    return CONCAT44(mantissa_d,exponent_c);\n  }\n  mantissa_a = mantissa_d & 0xfffff | 0x100000;\n  if ((mantissa_d & 0x80000000) != 0) {\n    carry_flag_2 = exponent_c != 0;\n    exponent_c = -exponent_c;\n    mantissa_a = -mantissa_a - (uint)carry_flag_2;\n  }\n  mantissa_d = mantissa_b & 0xfffff | 0x100000;\n  if ((mantissa_b & 0x80000000) != 0) {\n    carry_flag_2 = param_3 != 0;\n    param_3 = -param_3;\n    mantissa_d = -mantissa_d - (uint)carry_flag_2;\n  }\n  if (exponent_a == exponent_b) {\n    mantissa_d = mantissa_d ^ 0x100000;\n    if (exponent_a == 0) {\n      mantissa_a = mantissa_a ^ 0x100000;\n      exponent_a = 1;\n    }\n    else {\n      exponent_b = exponent_b - 1;\n    }\n  }\n  mantissa_b = -exponent_b + 0x20;\n  if ((int)exponent_b < 0x21) {\n    exponent_d = param_3 << (mantissa_b & 0xff);\n    param_3 = param_3 >> (exponent_b & 0xff);\n    sum_1 = exponent_c + param_3;\n    mantissa_c = mantissa_d << (mantissa_b & 0xff);\n    mantissa_b = sum_1 + mantissa_c;\n    mantissa_a = mantissa_a + CARRY4(exponent_c,param_3) + ((int)mantissa_d >> (exponent_b & 0xff)) +\n            (uint)CARRY4(sum_1,mantissa_c);\n  }\n  else {\n    exponent_d = mantissa_d << (-exponent_b + 0x40 & 0xff);\n    if (param_3 != 0) {\n      exponent_d = exponent_d | 2;\n    }\n    mantissa_d = (int)mantissa_d >> (exponent_b - 0x20 & 0xff);\n    mantissa_b = exponent_c + mantissa_d;\n    mantissa_a = mantissa_a + ((int)mantissa_d >> 0x1f) + (uint)CARRY4(exponent_c,mantissa_d);\n  }\n  param_2 = mantissa_a & 0x80000000;\n  exponent_b = mantissa_a;\n  if ((int)mantissa_a < 0) {\n    carry_flag_2 = exponent_d == 0;\n    exponent_d = -exponent_d;\n    exponent_b = -mantissa_b;\n    mantissa_b = -(uint)!carry_flag_2 - mantissa_b;\n    exponent_b = -(uint)(carry_flag_2 <= exponent_b) - mantissa_a;\n  }\n  if (0xfffff < exponent_b) {\n    exponent_c = exponent_a - 1;\n    if (0x1fffff < exponent_b) {\n      exponent_c = exponent_b & 1;\n      exponent_b = exponent_b >> 1;\n      carry_flag_1 = (byte)mantissa_b;\n      mantissa_b = (uint)(exponent_c != 0) << 0x1f | mantissa_b >> 1;\n      exponent_d = (uint)(carry_flag_1 & 1) << 0x1f | exponent_d >> 1;\n      exponent_c = exponent_a;\n      if (0xffbfffff < exponent_a * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    carry_flag_2 = 0x7fffffff < exponent_d;\n    if (exponent_d == 0x80000000) {\n      carry_flag_2 = (mantissa_b & 1) != 0;\n    }\n    return CONCAT44(exponent_b + exponent_c * 0x100000 + (uint)CARRY4(mantissa_b,(uint)carry_flag_2) | param_2,\n                    mantissa_b + carry_flag_2);\n  }\n  equal_exponents = (exponent_d & 0x80000000) != 0;\n  exponent_d = exponent_d << 1;\n  exponent_c = mantissa_b * 2;\n  carry_flag_2 = CARRY4(mantissa_b,mantissa_b);\n  mantissa_b = mantissa_b * 2 + (uint)equal_exponents;\n  exponent_b = exponent_b * 2 + (uint)(carry_flag_2 || CARRY4(exponent_c,(uint)equal_exponents));\n  exponent_c = exponent_a - 2;\n  if ((exponent_b & 0x100000) != 0) goto LAB_08000268;\n  mantissa_d = mantissa_b;\n  exponent_a = exponent_b;\n  if (exponent_b == 0) {\n    mantissa_d = 0;\n    exponent_a = mantissa_b;\n  }\n  shift_amount_2 = count_leading_zeroes(exponent_a);\n  if (exponent_b == 0) {\n    shift_amount_2 = shift_amount_2 + 0x20;\n  }\n  exponent_b = shift_amount_2 - 0xb;\n  negative_result = SBORROW4(exponent_b,0x20);\n  mantissa_b = shift_amount_2 - 0x2b;\n  carry_flag_2 = (int)mantissa_b < 0;\n  equal_exponents = mantissa_b == 0;\n  if ((int)exponent_b < 0x20) {\n    negative_result = SCARRY4(mantissa_b,0xc);\n    shift_amount_2 = shift_amount_2 + -0x1f;\n    carry_flag_2 = shift_amount_2 < 0;\n    equal_exponents = shift_amount_2 == 0;\n    mantissa_b = exponent_b;\n    if (!equal_exponents && carry_flag_2 == negative_result) {\n      mantissa_d = exponent_a << (exponent_b & 0xff);\n      exponent_a = exponent_a >> (0xcU - shift_amount_2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (equal_exponents || carry_flag_2 != negative_result) {\n    exponent_d = 0x20 - mantissa_b;\n  }\n  exponent_a = exponent_a << (mantissa_b & 0xff);\n  if (equal_exponents || carry_flag_2 != negative_result) {\n    exponent_a = exponent_a | mantissa_d >> (exponent_d & 0xff);\n  }\n  if (equal_exponents || carry_flag_2 != negative_result) {\n    mantissa_d = mantissa_d << (mantissa_b & 0xff);\n  }\nLAB_080002e0:\n  if ((int)exponent_b <= (int)exponent_c) {\n    return CONCAT44(exponent_a + (exponent_c - exponent_b) * 0x100000 | param_2,mantissa_d);\n  }\n  mantissa_b = ~(exponent_c - exponent_b);\n  if ((int)mantissa_b < 0x1f) {\n    shift_amount_2 = mantissa_b - 0x13;\n    if (shift_amount_2 != 0 && shift_amount_2 < 0 == SCARRY4(mantissa_b - 0x1f,0xc)) {\n      return CONCAT44(mantissa_a,mantissa_d >> (0x20 - (0xcU - shift_amount_2) & 0xff) | exponent_a << (0xcU - shift_amount_2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    mantissa_b = mantissa_b + 1;\n    return CONCAT44(param_2 | exponent_a >> (mantissa_b & 0xff),\n                    mantissa_d >> (mantissa_b & 0xff) | exponent_a << (0x20 - mantissa_b & 0xff));\n  }\n  return CONCAT44(mantissa_a,exponent_a >> (mantissa_b - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000158",
            "calling": [
                "FUN_08005838",
                "FUN_08005e9c",
                "FUN_08004bd8",
                "FUN_080079e8",
                "FUN_080059f0"
            ],
            "imported": false,
            "current_name": "floating_point_addition_08000158"
        },
        "FUN_08009768": {
            "renaming": {
                "FUN_08009768": "copy_string_08009768",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "num_bytes",
                "cVar1": "current_char",
                "puVar2": "src_ptr",
                "puVar3": "dest_ptr",
                "uVar4": "current_word"
            },
            "code": "\nvoid copy_string_08009768(uint *dest,uint *src,uint num_bytes)\n\n{\n  char current_char;\n  uint *src_ptr;\n  uint *dest_ptr;\n  uint current_word;\n  \n  if (((((uint)dest | (uint)src) & 3) == 0) &&\n     (dest_ptr = dest, src_ptr = src, 3 < num_bytes)) {\n    do {\n      src = src_ptr + 1;\n      current_word = *src_ptr;\n      dest = dest_ptr;\n      if ((current_word + 0xfefefeff & ~current_word & 0x80808080) != 0) goto LAB_0800979c;\n      num_bytes = num_bytes - 4;\n      dest = dest_ptr + 1;\n      *dest_ptr = current_word;\n      dest_ptr = dest;\n      src_ptr = src;\n    } while (3 < num_bytes);\n  }\n  src_ptr = src;\n  if (num_bytes != 0) {\nLAB_0800979c:\n    current_char = *(char *)src_ptr;\n    *(char *)dest = current_char;\n    while( true ) {\n      dest = (uint *)((int)dest + 1);\n      num_bytes = num_bytes - 1;\n      if (current_char == '\\0') break;\n      if (num_bytes == 0) {\n        return;\n      }\n      src_ptr = (uint *)((int)src_ptr + 1);\n      current_char = *(char *)src_ptr;\n      *(char *)dest = current_char;\n    }\n    if (num_bytes != 0) {\n      src_ptr = dest;\n      do {\n        dest_ptr = (uint *)((int)src_ptr + 1);\n        *(char *)src_ptr = '\\0';\n        src_ptr = dest_ptr;\n      } while (dest_ptr != (uint *)(num_bytes + (int)dest));\n    }\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009768",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "copy_string_08009768"
        },
        "FUN_08003ff8": {
            "renaming": {
                "FUN_08003ff8": "update_data_08003ff8",
                "param_1": "data_address",
                "param_2": "input_data",
                "local_c": "data_value",
                "iVar1": "input_value_1",
                "iVar2": "input_value_2"
            },
            "code": "\nvoid update_data_08003ff8(int data_address,int *input_data)\n\n{\n  int input_value_1;\n  int input_value_2;\n  uint data_value;\n  \n  *(uint *)(data_address + 0x20) = *(uint *)(data_address + 0x20) & 0xffffefff;\n  data_value = *(uint *)(data_address + 4);\n  input_value_1 = *input_data;\n  input_value_2 = input_data[2];\n  if (data_address == DAT_0800409c) {\n    data_value = input_data[5] << 6 | data_value & 0xffffbfff;\n  }\n  *(uint *)(data_address + 4) = data_value;\n  *(uint *)(data_address + 0x1c) = input_value_1 << 8 | *(uint *)(data_address + 0x1c) & 0xffff8cff;\n  *(int *)(data_address + 0x40) = input_data[1];\n  *(uint *)(data_address + 0x20) = input_value_2 << 0xc | *(uint *)(data_address + 0x20) & 0xffffdfff;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ff8",
            "calling": [
                "FUN_08003908"
            ],
            "imported": false,
            "current_name": "update_data_08003ff8"
        },
        "FUN_08004ea4": {
            "renaming": {
                "FUN_08004ea4": "process_and_return_data_08004ea4",
                "param_1": "input_data_1",
                "param_2": "input_data_2",
                "param_3": "data_size",
                "param_4": "input_data_type"
            },
            "code": "\nvoid process_and_return_data_08004ea4(undefined input_data_1,undefined input_data_2,undefined4 data_size,undefined2 input_data_type)\n\n{\n  process_data_08001ccc(PTR_DAT_08004ee4,input_data_1,input_data_2,1,data_size,input_data_type,*(undefined4 *)PTR_DAT_08004ee0);\n  return;\n}\n\n",
            "called": [
                "FUN_08001ccc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ea4",
            "calling": [],
            "imported": false,
            "current_name": "process_and_return_data_08004ea4"
        },
        "FUN_080040a0": {
            "renaming": {
                "FUN_080040a0": "update_flags_080040a0",
                "param_1": "ptr",
                "param_2": "flags",
                "param_3": "value",
                "uVar1": "old_flags"
            },
            "code": "\nvoid update_flags_080040a0(int ptr,uint flags,int value)\n\n{\n  uint old_flags;\n  \n  old_flags = *(uint *)(ptr + 0x20);\n  *(uint *)(ptr + 0x20) = *(uint *)(ptr + 0x20) & 0xfffffffe;\n  *(uint *)(ptr + 0x18) = value << 4 | *(uint *)(ptr + 0x18) & 0xffffff0f;\n  *(uint *)(ptr + 0x20) = flags | old_flags & 0xfffffff5;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040a0",
            "calling": [
                "FUN_08003a94"
            ],
            "imported": false,
            "current_name": "update_flags_080040a0"
        },
        "FUN_08009a18": {
            "renaming": {
                "FUN_08009a18": "copy_memory_backward_08009a18",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "num_bytes",
                "puVar1": "dst_ptr",
                "puVar2": "src_ptr",
                "iVar3": "num_loops",
                "puVar4": "dst_byte_ptr",
                "puVar5": "src_byte_ptr",
                "uVar6": "loop_counter",
                "uVar7": "remaining_bytes"
            },
            "code": "\nvoid copy_memory_backward_08009a18(undefined4 *destination,undefined4 *source,uint num_bytes)\n\n{\n  undefined4 *dst_ptr;\n  undefined4 *src_ptr;\n  int num_loops;\n  undefined *dst_byte_ptr;\n  undefined4 *src_byte_ptr;\n  uint loop_counter;\n  uint remaining_bytes;\n  \n  if ((source < destination) && (src_ptr = (undefined4 *)((int)source + num_bytes), destination < src_ptr)) {\n    dst_byte_ptr = (undefined *)((int)destination + num_bytes);\n    if (num_bytes != 0) {\n      do {\n        src_ptr = (undefined4 *)((int)src_ptr + -1);\n        dst_byte_ptr = dst_byte_ptr + -1;\n        *dst_byte_ptr = *(undefined *)src_ptr;\n      } while (source != src_ptr);\n    }\n  }\n  else {\n    remaining_bytes = num_bytes;\n    if (0xf < num_bytes) {\n      if ((((uint)destination | (uint)source) & 3) != 0) goto LAB_08009abc;\n      src_ptr = source + 4;\n      dst_ptr = destination + 4;\n      do {\n        src_byte_ptr = src_ptr + 4;\n        dst_ptr[-4] = src_ptr[-4];\n        dst_ptr[-3] = src_ptr[-3];\n        dst_ptr[-2] = src_ptr[-2];\n        dst_ptr[-1] = src_ptr[-1];\n        src_ptr = src_byte_ptr;\n        dst_ptr = dst_ptr + 4;\n      } while (src_byte_ptr != (undefined4 *)((int)source + (num_bytes - 0x10 & 0xfffffff0) + 0x20));\n      num_loops = (num_bytes - 0x10 >> 4) + 1;\n      remaining_bytes = num_bytes & 0xf;\n      source = source + num_loops * 4;\n      destination = destination + num_loops * 4;\n      if (3 < remaining_bytes) {\n        src_ptr = destination + -1;\n        loop_counter = remaining_bytes;\n        dst_ptr = source;\n        do {\n          loop_counter = loop_counter - 4;\n          src_ptr = src_ptr + 1;\n          *src_ptr = *dst_ptr;\n          dst_ptr = dst_ptr + 1;\n        } while (3 < loop_counter);\n        num_loops = (remaining_bytes - 4 & 0xfffffffc) + 4;\n        destination = (undefined4 *)((int)destination + num_loops);\n        source = (undefined4 *)((int)source + num_loops);\n        remaining_bytes = num_bytes & 3;\n      }\n    }\n    num_bytes = remaining_bytes;\n    if (remaining_bytes != 0) {\nLAB_08009abc:\n      dst_byte_ptr = (undefined *)((int)destination + -1);\n      src_ptr = source;\n      do {\n        dst_ptr = (undefined4 *)((int)src_ptr + 1);\n        dst_byte_ptr = dst_byte_ptr + 1;\n        *dst_byte_ptr = *(undefined *)src_ptr;\n        src_ptr = dst_ptr;\n      } while (dst_ptr != (undefined4 *)(num_bytes + (int)source));\n      return;\n    }\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009a18",
            "calling": [
                "FUN_080097cc",
                "FUN_08009adc"
            ],
            "imported": false,
            "current_name": "copy_memory_backward_08009a18"
        },
        "FUN_0800119c": {
            "renaming": {
                "FUN_0800119c": "convert_to_fixed_point_0800119c",
                "param_1": "input_fractional",
                "param_2": "input_integer",
                "uVar1": "shift_amount",
                "iVar2": "temp_value",
                "uVar3": "shift_amount_negative"
            },
            "code": "\nuint convert_to_fixed_point_0800119c(uint input_fractional,uint input_integer)\n\n{\n  uint shift_amount;\n  int temp_value;\n  uint shift_amount_negative;\n  \n  temp_value = input_integer * 2 + 0x200000;\n  if (input_integer * 2 < 0xffe00000) {\n    if (-1 < temp_value) {\n      return 0;\n    }\n    shift_amount = temp_value >> 0x15;\n    shift_amount_negative = -shift_amount - 0x3e1;\n    if (shift_amount < 0xfffffc20 && shift_amount_negative != 0) {\n      shift_amount = (input_integer << 0xb | 0x80000000 | input_fractional >> 0x15) >> (shift_amount_negative & 0xff);\n      if ((input_integer & 0x80000000) != 0) {\n        shift_amount = -shift_amount;\n      }\n      return shift_amount;\n    }\n  }\n  else if ((input_fractional | input_integer << 0xc) != 0) {\n    return 0;\n  }\n  input_integer = input_integer & 0x80000000;\n  if (input_integer == 0) {\n    input_integer = 0x7fffffff;\n  }\n  return input_integer;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800119c",
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "convert_to_fixed_point_0800119c"
        },
        "FUN_08005728": {
            "renaming": {
                "FUN_08005728": "update_memory_allocation_pointer_08005728",
                "param_1": "memory_size",
                "puVar1": "memory_allocation_status",
                "auStack_18": "memory_allocation_pointer",
                "local_14": "remaining_memory",
                "local_c": "previous_memory_allocation_pointer"
            },
            "code": "\nundefined4 update_memory_allocation_pointer_08005728(int memory_size)\n\n{\n  undefined4 *memory_allocation_status;\n  undefined memory_allocation_pointer [4];\n  int remaining_memory;\n  undefined4 previous_memory_allocation_pointer;\n  \n  if (*(int *)PTR_DAT_08005778 == 0) {\n    *(undefined **)PTR_DAT_08005778 = PTR_DAT_0800577c;\n  }\n  previous_memory_allocation_pointer = *(undefined4 *)PTR_DAT_08005778;\n  if (memory_allocation_pointer < (undefined *)(memory_size + *(int *)PTR_DAT_08005778)) {\n    remaining_memory = memory_size;\n    memory_allocation_status = (undefined4 *)get_pointer_value_08005d14();\n    *memory_allocation_status = 0xc;\n    previous_memory_allocation_pointer = 0xffffffff;\n  }\n  else {\n    *(int *)PTR_DAT_08005778 = memory_size + *(int *)PTR_DAT_08005778;\n  }\n  return previous_memory_allocation_pointer;\n}\n\n",
            "called": [
                "FUN_08005d14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005728",
            "calling": [
                "FUN_08009744"
            ],
            "imported": false,
            "current_name": "update_memory_allocation_pointer_08005728"
        },
        "FUN_080090b4": {
            "renaming": {
                "FUN_080090b4": "do_nothing_with_pointer_080090b4"
            },
            "code": "\nvoid do_nothing_with_pointer_080090b4(void)\n\n{\n  do_nothing_08008af4(PTR_DAT_080090bc);\n  return;\n}\n\n",
            "called": [
                "FUN_08008af4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090b4",
            "calling": [
                "FUN_0800884c",
                "FUN_08009adc",
                "FUN_08008af8",
                "FUN_080088ec"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_080090b4"
        },
        "FUN_0800422e": {
            "renaming": {
                "FUN_0800422e": "check_flag_0800422e",
                "param_1": "flag_data",
                "param_2": "input_data",
                "uVar1": "result",
                "param_2[1]": "input_data_1",
                "param_2[2]": "input_data_2",
                "param_2[3]": "input_data_3",
                "param_2[4]": "input_data_4",
                "param_2[5]": "input_data_5",
                "param_2[6]": "input_data_6"
            },
            "code": "\nundefined4 check_flag_0800422e(int *flag_data,uint *input_data)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(flag_data + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(flag_data + 0xf) = 1;\n    *(uint *)(*flag_data + 0x44) =\n         input_data_6 |\n         (input_data_6 |\n         (input_data_5 |\n         (input_data_4 |\n         (*input_data | (input_data_1 | (input_data_2 | input_data_3 & 0xfffffcff) & 0xfffffbff) & 0xfffff7ff\n         ) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    *(undefined *)(flag_data + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800422e",
            "calling": [
                "FUN_080053b0"
            ],
            "imported": false,
            "current_name": "check_flag_0800422e"
        },
        "FUN_08008af4": {
            "renaming": {
                "FUN_08008af4": "do_nothing_08008af4"
            },
            "code": "\nvoid do_nothing_08008af4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008af4",
            "calling": [
                "FUN_080098c0",
                "FUN_080090b4"
            ],
            "imported": false,
            "current_name": "do_nothing_08008af4"
        },
        "FUN_08003e38": {
            "renaming": {
                "FUN_08003e38": "update_parameters_08003e38",
                "param_1": "param_address",
                "param_2": "parameter_values",
                "iVar1": "value_1",
                "uVar2": "value_2",
                "local_10": "value_3"
            },
            "code": "\nvoid update_parameters_08003e38(int param_address,int *parameter_values)\n\n{\n  int value_1;\n  uint value_2;\n  uint value_3;\n  \n  *(uint *)(param_address + 0x20) = *(uint *)(param_address + 0x20) & 0xffffffef;\n  value_3 = *(uint *)(param_address + 4);\n  value_1 = *parameter_values;\n  value_2 = parameter_values[2] << 4 | *(uint *)(param_address + 0x20) & 0xffffffdf;\n  if (param_address == DAT_08003f14) {\n    value_2 = (parameter_values[3] << 4 | value_2 & 0xffffff7f) & 0xffffffbf;\n    value_3 = parameter_values[6] << 2 | parameter_values[5] << 2 | value_3 & 0xfffff3ff;\n  }\n  *(uint *)(param_address + 4) = value_3;\n  *(uint *)(param_address + 0x18) = value_1 << 8 | *(uint *)(param_address + 0x18) & 0xffff8cff;\n  *(int *)(param_address + 0x38) = parameter_values[1];\n  *(uint *)(param_address + 0x20) = value_2;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003e38",
            "calling": [
                "FUN_08003908"
            ],
            "imported": false,
            "current_name": "update_parameters_08003e38"
        },
        "FUN_08008af0": {
            "renaming": {
                "FUN_08008af0": "do_nothing_08008af0"
            },
            "code": "\nvoid do_nothing_08008af0(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008af0",
            "calling": [
                "FUN_080098c0",
                "FUN_080090a8"
            ],
            "imported": false,
            "current_name": "do_nothing_08008af0"
        },
        "FUN_0800151c": {
            "renaming": {
                "FUN_0800151c": "write_param_to_memory_0800151c",
                "param_1": "input_value",
                "iVar1": "write_result",
                "uVar2": "return_value"
            },
            "code": "\nundefined4 write_param_to_memory_0800151c(uint input_value)\n\n{\n  int write_result;\n  undefined4 return_value;\n  \n  write_result = write_param_to_memory_0800151c_08001762((int)((ulonglong)*(uint *)PTR_DAT_08001570 /\n                            (1000 / (ulonglong)(byte)*PTR_DAT_08001574)));\n  if (write_result == 0) {\n    if (input_value < 0x10) {\n      write_data_to_memory_0800172a(0xffffffff,input_value,0);\n      *(uint *)PTR_DAT_08001578 = input_value;\n      return_value = 0;\n    }\n    else {\n      return_value = 1;\n    }\n  }\n  else {\n    return_value = 1;\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_08001762",
                "FUN_0800172a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800151c",
            "calling": [
                "FUN_080014f0",
                "FUN_08003260"
            ],
            "imported": false,
            "current_name": "write_param_to_memory_0800151c"
        },
        "FUN_080006a4": {
            "renaming": {
                "FUN_080006a4": "binary_to_double_080006a4",
                "param_1": "binary_part1",
                "param_2": "binary_part2",
                "param_3": "binary_part3",
                "param_4": "binary_part4",
                "uVar1": "bit_check1",
                "unaff_r4": "bit_check2",
                "uVar2": "bit_check3",
                "uVar3": "binary_part2_updated",
                "in_r12": "constant",
                "bVar4": "is_binary_zero"
            },
            "code": "\nulonglong binary_to_double_080006a4(uint binary_part1,uint binary_part2,uint binary_part3,uint binary_part4)\n\n{\n  uint bit_check1;\n  uint bit_check2;\n  uint bit_check3;\n  uint binary_part2_updated;\n  uint constant;\n  bool is_binary_zero;\n  \n  bit_check3 = constant & binary_part4 >> 0x14;\n  if (bit_check2 != constant && bit_check3 != constant) {\n    is_binary_zero = (binary_part1 | binary_part2 << 1) == 0;\n    if (!is_binary_zero) {\n      is_binary_zero = (binary_part3 | binary_part4 << 1) == 0;\n    }\n    if (is_binary_zero) {\n      return (ulonglong)((binary_part2 ^ binary_part4) & 0x80000000) << 0x20;\n    }\n    if (bit_check2 == 0) {\n      binary_part2_updated = binary_part2 & 0x80000000;\n      do {\n        bit_check1 = binary_part1 & 0x80000000;\n        binary_part1 = binary_part1 << 1;\n        binary_part2 = binary_part2 * 2 + (uint)(bit_check1 != 0);\n      } while ((binary_part2 & 0x100000) == 0);\n      binary_part2 = binary_part2 | binary_part2_updated;\n      if (bit_check3 != 0) {\n        return CONCAT44(binary_part2,binary_part1);\n      }\n    }\n    do {\n      bit_check3 = binary_part3 & 0x80000000;\n      binary_part3 = binary_part3 << 1;\n      binary_part4 = binary_part4 * 2 + (uint)(bit_check3 != 0);\n    } while ((binary_part4 & 0x100000) == 0);\n    return CONCAT44(binary_part2,binary_part1);\n  }\n  is_binary_zero = (binary_part1 | binary_part2 << 1) == 0;\n  if (is_binary_zero) {\n    binary_part2 = binary_part4;\n    binary_part1 = binary_part3;\n  }\n  if (!is_binary_zero) {\n    is_binary_zero = (binary_part3 | binary_part4 << 1) == 0;\n  }\n  binary_part2_updated = binary_part2;\n  if (((!is_binary_zero) && ((bit_check2 != constant || ((binary_part1 | binary_part2 << 0xc) == 0)))) &&\n     ((bit_check3 != constant || (binary_part1 = binary_part3, binary_part2_updated = binary_part4, (binary_part3 | binary_part4 << 0xc) == 0)))) {\n    return (ulonglong)((binary_part2 ^ binary_part4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(binary_part2_updated,binary_part1) | 0x7ff8000000000000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080006a4",
            "calling": [
                "FUN_080004c8"
            ],
            "imported": false,
            "current_name": "binary_to_double_080006a4"
        },
        "FUN_08000f68": {
            "renaming": {
                "FUN_08000f68": "check_overflow_08000f68",
                "param_1": "num_1",
                "param_2": "num_2",
                "bVar1": "is_overflow",
                "uVar2": "double_num_1",
                "uVar3": "double_num_2",
                "uVar4": "combined_nums",
                "bVar5": "is_zero"
            },
            "code": "\nuint check_overflow_08000f68(uint num_1,uint num_2)\n\n{\n  bool is_overflow;\n  uint double_num_1;\n  uint double_num_2;\n  uint combined_nums;\n  bool is_zero;\n  \n  double_num_1 = num_1 * 2;\n  double_num_2 = num_2 * 2;\n  if (((int)double_num_1 >> 0x18 == -1 || (int)double_num_2 >> 0x18 == -1) &&\n     ((((int)double_num_1 >> 0x18 == -1 && ((num_1 & 0x7fffff) != 0)) ||\n      (((int)double_num_2 >> 0x18 == -1 && ((num_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_nums = double_num_1 | num_2 & 0x7fffffff;\n  is_zero = combined_nums == 0;\n  if (!is_zero) {\n    combined_nums = num_1 ^ num_2;\n    is_zero = combined_nums == 0;\n  }\n  is_overflow = -1 < (int)combined_nums;\n  if (is_overflow) {\n    num_1 = double_num_1 + num_2 * -2;\n    is_zero = num_1 == 0;\n  }\n  if ((is_overflow && double_num_2 <= double_num_1) && !is_zero) {\n    num_1 = (int)num_2 >> 0x1f;\n  }\n  if (!is_overflow || double_num_2 > double_num_1) {\n    num_1 = ~((int)num_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    num_1 = num_1 | 1;\n  }\n  return num_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f68",
            "calling": [
                "FUN_08000fd0"
            ],
            "imported": false,
            "current_name": "check_overflow_08000f68"
        },
        "FUN_08009258": {
            "renaming": {
                "FUN_08009258": "calculate_polynomial_hash_08009258",
                "param_1": "hash_table",
                "param_2": "str1",
                "param_3": "str2",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "iVar3": "hash_table_size",
                "uVar4": "temp1",
                "puVar5": "str1_ptr",
                "uVar6": "temp2",
                "puVar7": "str2_ptr",
                "uVar8": "temp3",
                "iVar9": "str1_len",
                "iVar10": "str2_len",
                "uVar11": "temp4",
                "iVar12": "max_len",
                "iVar13": "longer_str_ptr",
                "puVar14": "ptr3",
                "puVar15": "ptr4",
                "puVar16": "ptr5",
                "puVar17": "ptr6",
                "puVar18": "hash_ptr"
            },
            "code": "\nvoid calculate_polynomial_hash_08009258(undefined4 hash_table,int str1,int str2)\n\n{\n  uint *ptr1;\n  uint *ptr2;\n  int hash_table_size;\n  uint temp1;\n  uint *str1_ptr;\n  uint temp2;\n  uint *str2_ptr;\n  uint temp3;\n  int str1_len;\n  int str2_len;\n  uint temp4;\n  int max_len;\n  int longer_str_ptr;\n  uint *ptr3;\n  uint *ptr4;\n  uint *ptr5;\n  uint *ptr6;\n  uint *hash_ptr;\n  \n  max_len = *(int *)(str1 + 0x10);\n  str1_len = *(int *)(str2 + 0x10);\n  str2_len = str1_len;\n  longer_str_ptr = str1;\n  if (max_len < str1_len) {\n    str2_len = max_len;\n    max_len = str1_len;\n    longer_str_ptr = str2;\n    str2 = str1;\n  }\n  str1_len = max_len + str2_len;\n  hash_table_size = *(int *)(longer_str_ptr + 4);\n  if (*(int *)(longer_str_ptr + 8) < str1_len) {\n    hash_table_size = hash_table_size + 1;\n  }\n  hash_table_size = allocate_or_get_pointer_080090c0(hash_table,hash_table_size);\n  hash_ptr = (uint *)(hash_table_size + 0x14);\n  ptr6 = hash_ptr + str1_len;\n  for (str1_ptr = hash_ptr; str1_ptr < ptr6; str1_ptr = str1_ptr + 1) {\n    *str1_ptr = 0;\n  }\n  temp2 = str2 + 0x14;\n  temp4 = temp2 + str2_len * 4;\n  str1_ptr = (uint *)(longer_str_ptr + 0x14);\n  if (temp2 < temp4) {\n    str2_ptr = (uint *)(temp2 + ((temp4 - str2) - 0x15 & 0xfffffffc));\n    ptr5 = (uint *)(str2 + 0x10);\n    do {\n      while( true ) {\n        ptr5 = ptr5 + 1;\n        temp2 = *ptr5 & 0xffff;\n        if (temp2 != 0) break;\n        temp2 = *ptr5 >> 0x10;\n        if (temp2 == 0) goto LAB_080092d2;\nLAB_0800932c:\n        temp3 = *hash_ptr;\n        temp1 = 0;\n        ptr1 = str1_ptr;\n        ptr3 = hash_ptr;\n        temp4 = temp3;\n        do {\n          ptr4 = ptr3;\n          temp1 = temp1 + temp2 * *(ushort *)ptr1 + (temp4 >> 0x10);\n          *ptr4 = temp3 & 0xffff | temp1 * 0x10000;\n          ptr2 = ptr1 + 1;\n          temp4 = ptr4[1];\n          temp3 = temp2 * (*ptr1 >> 0x10) + (temp4 & 0xffff) + (temp1 >> 0x10);\n          temp1 = temp3 >> 0x10;\n          ptr1 = ptr2;\n          ptr3 = ptr4 + 1;\n        } while (ptr2 < str1_ptr + max_len);\n        ptr4[1] = temp3;\n        hash_ptr = hash_ptr + 1;\n        if (str2_ptr == ptr5) goto LAB_0800937a;\n      }\n      temp4 = 0;\n      ptr1 = hash_ptr;\n      ptr3 = str1_ptr;\n      do {\n        ptr2 = ptr1;\n        ptr4 = ptr3 + 1;\n        temp3 = temp2 * (*ptr3 & 0xffff) + (*ptr2 & 0xffff) + temp4;\n        temp1 = temp2 * (*ptr3 >> 0x10) + (*ptr2 >> 0x10) + (temp3 >> 0x10);\n        temp4 = temp1 >> 0x10;\n        *ptr2 = temp3 & 0xffff | temp1 * 0x10000;\n        ptr1 = ptr2 + 1;\n        ptr3 = ptr4;\n      } while (ptr4 < str1_ptr + max_len);\n      ptr2[1] = temp4;\n      temp2 = *ptr5 >> 0x10;\n      if (temp2 != 0) goto LAB_0800932c;\nLAB_080092d2:\n      hash_ptr = hash_ptr + 1;\n    } while (str2_ptr != ptr5);\n  }\nLAB_0800937a:\n  if (0 < str1_len) {\n    temp2 = ptr6[-1];\n    ptr6 = ptr6 + -1;\n    while ((temp2 == 0 && (str1_len = str1_len + -1, str1_len != 0))) {\n      ptr6 = ptr6 + -1;\n      temp2 = *ptr6;\n    }\n  }\n  *(int *)(hash_table_size + 0x10) = str1_len;\n  return;\n}\n\n",
            "called": [
                "FUN_080090c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009258",
            "calling": [
                "FUN_080093a4",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "calculate_polynomial_hash_08009258"
        },
        "FUN_08000c08": {
            "renaming": {
                "FUN_08000c08": "calculate_hash_08000c08",
                "param_1": "input",
                "iVar1": "leading_zeroes_count",
                "uVar2": "shift_amount",
                "iVar3": "constant",
                "uVar4": "mask",
                "count_leading_zeroes": "count_leading_zero_bits"
            },
            "code": "\nuint calculate_hash_08000c08(uint input)\n\n{\n  int leading_zeroes_count;\n  uint shift_amount;\n  int constant;\n  uint mask;\n  \n  if (input == 0) {\n    return 0;\n  }\n  leading_zeroes_count = count_leading_zero_bits(input);\n  shift_amount = leading_zeroes_count - 8;\n  constant = shift_amount * -0x800000 + 0x4a800000;\n  if (7 < leading_zeroes_count) {\n    mask = 0 << (shift_amount & 0xff);\n    shift_amount = constant + (input << (shift_amount & 0xff)) +\n            (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < mask);\n    if (mask == 0x80000000) {\n      shift_amount = shift_amount & 0xfffffffe;\n    }\n    return shift_amount;\n  }\n  mask = input << (leading_zeroes_count + 0x18U & 0xff);\n  shift_amount = constant + ((input >> (0x20 - (leading_zeroes_count + 0x18U) & 0xff)) - ((int)mask >> 0x1f));\n  if ((mask & 0x7fffffff) == 0) {\n    shift_amount = shift_amount & ~(mask >> 0x1f);\n  }\n  return shift_amount;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c08",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "calculate_hash_08000c08"
        },
        "FUN_08003c6e": {
            "renaming": {
                "FUN_08003c6e": "do_nothing_08003c6e"
            },
            "code": "\nvoid do_nothing_08003c6e(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003c6e",
            "calling": [
                "FUN_080036f8"
            ],
            "imported": false,
            "current_name": "do_nothing_08003c6e"
        },
        "FUN_080042de": {
            "renaming": {
                "FUN_080042de": "check_flag_status_080042de",
                "param_1": "flag_data",
                "param_2": "flag_mask",
                "uVar1": "result"
            },
            "code": "\nundefined4 check_flag_status_080042de(int *flag_data,uint *flag_mask)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(flag_data + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(flag_data + 0xf) = 1;\n    *(undefined *)((int)flag_data + 0x3d) = 2;\n    *(uint *)(*flag_data + 4) = *(uint *)(*flag_data + 4) & 0xffffff8f;\n    *(uint *)(*flag_data + 4) = *flag_mask | *(uint *)(*flag_data + 4);\n    *(uint *)(*flag_data + 8) = *(uint *)(*flag_data + 8) & 0xffffff7f;\n    *(uint *)(*flag_data + 8) = flag_mask[1] | *(uint *)(*flag_data + 8);\n    *(undefined *)((int)flag_data + 0x3d) = 1;\n    *(undefined *)(flag_data + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042de",
            "calling": [
                "FUN_08005500",
                "FUN_080053b0"
            ],
            "imported": false,
            "current_name": "check_flag_status_080042de"
        },
        "FUN_08004366": {
            "renaming": {
                "FUN_08004366": "do_nothing_08004366"
            },
            "code": "\nvoid do_nothing_08004366(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004366",
            "calling": [
                "FUN_080036f8"
            ],
            "imported": false,
            "current_name": "do_nothing_08004366"
        },
        "FUN_08009530": {
            "renaming": {
                "FUN_08009530": "compare_and_allocate_08009530",
                "param_1": "memory",
                "param_2": "array1",
                "param_3": "array2",
                "param_4": "value",
                "iVar1": "result",
                "puVar2": "array2_ptr",
                "uVar3": "array1_length",
                "uVar4": "carry",
                "iVar5": "comparison",
                "puVar6": "array1_ptr",
                "puVar7": "array1_ptr_temp",
                "puVar8": "result_ptr",
                "puVar9": "array2_ptr_temp",
                "puVar10": "array2_ptr_temp2",
                "puVar11": "array1_end",
                "puVar13": "array2_end",
                "iVar12": "carry_temp",
                "uVar14": "array2_length"
            },
            "code": "\nvoid compare_and_allocate_08009530(undefined4 memory,uint *array1,uint *array2,undefined4 value)\n\n{\n  int result;\n  uint *array2_ptr;\n  uint array1_length;\n  uint carry;\n  int comparison;\n  uint *array1_ptr;\n  uint *array1_ptr_temp;\n  uint *array2_ptr_temp;\n  uint *array2_ptr_temp2;\n  uint *array1_end;\n  int carry_temp;\n  uint *array2_end;\n  uint array2_length;\n  uint *result_ptr;\n  \n  array2_ptr = (uint *)array2[4];\n  comparison = array1[4] - (int)array2_ptr;\n  array1_end = array1 + 5;\n  array2_end = array2 + 5;\n  array1_ptr_temp = array1_end;\n  array2_ptr_temp = array1;\n  if (comparison == 0) {\n    array1_ptr = array1_end + (int)array2_ptr;\n    array2_ptr = array2_end + (int)array2_ptr;\n    while( true ) {\n      array1_ptr = array1_ptr + -1;\n      array2_ptr = array2_ptr + -1;\n      if (*array1_ptr != *array2_ptr) break;\n      if (array1_ptr <= array1_end) {\n        comparison = allocate_or_get_pointer_080090c0(memory,0,array1_ptr,array2_ptr,value);\n        *(undefined4 *)(comparison + 0x10) = 1;\n        *(undefined4 *)(comparison + 0x14) = 0;\n        return;\n      }\n    }\n    if (*array2_ptr <= *array1_ptr) goto LAB_08009578;\n  }\n  else if (-1 < comparison) {\n    comparison = 0;\n    array1_ptr = array2;\n    goto LAB_08009578;\n  }\n  comparison = 1;\n  array1_ptr = array1_end;\n  array2_ptr = array1;\n  array1_ptr_temp = array2_end;\n  array2_ptr_temp = array2;\n  array2 = array1;\n  array2_end = array1_end;\nLAB_08009578:\n  result = allocate_or_get_pointer_080090c0(memory,array2_ptr_temp[1],array1_ptr,array2_ptr,value);\n  carry_temp = 0;\n  array2_length = array2_ptr_temp[4];\n  array1_length = array2[4];\n  *(int *)(result + 0xc) = comparison;\n  array1_end = array1_ptr_temp + array2_length;\n  array2_ptr = (uint *)(result + 0x14);\n  array2_ptr_temp = array2_end;\n  do {\n    result_ptr = array1_ptr_temp + 1;\n    array2_ptr_temp2 = array2_ptr_temp + 1;\n    carry = ((*array1_ptr_temp & 0xffff) + carry_temp) - (*array2_ptr_temp & 0xffff);\n    carry_temp = ((*array1_ptr_temp >> 0x10) - (*array2_ptr_temp >> 0x10)) + ((int)carry >> 0x10);\n    carry = carry & 0xffff | carry_temp * 0x10000;\n    array1_ptr = array2_ptr + 1;\n    *array2_ptr = carry;\n    carry_temp = carry_temp >> 0x10;\n    array2_ptr = array1_ptr;\n    array1_ptr_temp = result_ptr;\n    array2_ptr_temp = array2_ptr_temp2;\n  } while (array2_ptr_temp2 < array2_end + array1_length);\n  array2_ptr = result_ptr;\n  array1_ptr_temp = array1_ptr;\n  if (result_ptr < array1_end) {\n    do {\n      array2_ptr_temp = array2_ptr + 1;\n      array1_length = (*array2_ptr & 0xffff) + carry_temp;\n      carry_temp = ((int)array1_length >> 0x10) + (*array2_ptr >> 0x10);\n      carry = array1_length & 0xffff | carry_temp * 0x10000;\n      *array1_ptr_temp = carry;\n      carry_temp = carry_temp >> 0x10;\n      array2_ptr = array2_ptr_temp;\n      array1_ptr_temp = array1_ptr_temp + 1;\n    } while (array2_ptr_temp < array1_end);\n    array1_ptr = (uint *)((int)array1_ptr + ((int)array1_end + ~(uint)result_ptr & 0xfffffffc) + 4);\n  }\n  array1_ptr = array1_ptr + -1;\n  while (carry == 0) {\n    array1_ptr = array1_ptr + -1;\n    array2_length = array2_length - 1;\n    carry = *array1_ptr;\n  }\n  *(uint *)(result + 0x10) = array2_length;\n  return;\n}\n\n",
            "called": [
                "FUN_080090c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009530",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "compare_and_allocate_08009530"
        },
        "FUN_08008af8": {
            "renaming": {
                "FUN_08008af8": "allocate_and_return_pointer_08008af8",
                "param_1": "param_pointer",
                "param_2": "param_size",
                "puVar1": "pointer_1",
                "puVar2": "pointer_2",
                "puVar3": "pointer_3",
                "uVar4": "var_4",
                "uVar5": "var_5",
                "puVar6": "pointer_6",
                "iVar7": "var_7",
                "puVar8": "pointer_8",
                "uVar9": "var_9",
                "uVar10": "var_10",
                "puVar11": "pointer_11",
                "puVar12": "pointer_12",
                "puVar13": "pointer_13",
                "uVar14": "var_14",
                "uVar15": "var_15",
                "iVar16": "var_16",
                "puVar17": "pointer_17",
                "puVar18": "pointer_18"
            },
            "code": "\nint * allocate_and_return_pointer_08008af8(undefined4 *param_pointer,uint param_size)\n\n{\n  undefined *pointer_1;\n  undefined *pointer_2;\n  undefined *pointer_3;\n  uint var_4;\n  uint var_5;\n  uint *pointer_6;\n  int var_7;\n  undefined *pointer_8;\n  uint var_9;\n  uint var_10;\n  undefined4 *pointer_11;\n  undefined *pointer_12;\n  undefined *pointer_13;\n  uint var_14;\n  uint var_15;\n  int var_16;\n  undefined4 *pointer_17;\n  undefined4 *pointer_18;\n  \n  var_14 = param_size + 0xb;\n  if (var_14 < 0x17) {\n    if (0x10 < param_size) goto LAB_08008c7a;\n    do_nothing_with_pointer_080090a8();\n    var_15 = 0x10;\n    var_7 = 0x18;\n    var_14 = 2;\nLAB_08008b18:\n    pointer_8 = PTR_DAT_08008e4c + var_7;\n    pointer_12 = *(undefined **)(pointer_8 + 4);\n    if ((pointer_12 != pointer_8 + -8) || (pointer_12 = *(undefined **)(pointer_8 + 0xc), pointer_8 != pointer_12)) {\n      var_7 = *(int *)(pointer_12 + 0xc);\n      pointer_8 = pointer_12 + (*(uint *)(pointer_12 + 4) & 0xfffffffc);\n      var_14 = *(uint *)(pointer_8 + 4);\nLAB_08008b34:\n      var_16 = *(int *)(pointer_12 + 8);\n      *(int *)(var_16 + 0xc) = var_7;\n      *(int *)(var_7 + 8) = var_16;\n      *(uint *)(pointer_8 + 4) = var_14 | 1;\n      do_nothing_with_pointer_080090b4(param_pointer);\n      return (int *)(pointer_12 + 8);\n    }\n    var_14 = var_14 + 2;\n  }\n  else {\n    var_15 = var_14 & 0xfffffff8;\n    if (((int)var_15 < 0) || (var_15 < param_size)) {\nLAB_08008c7a:\n      *param_pointer = 0xc;\n      return (int *)0x0;\n    }\n    do_nothing_with_pointer_080090a8();\n    if (var_15 < 0x1f8) {\n      var_14 = var_14 >> 3;\n      var_7 = var_15 + 8;\n      goto LAB_08008b18;\n    }\n    var_4 = var_14 >> 9;\n    if (var_4 == 0) {\n      var_7 = 0x200;\n      var_9 = 0x40;\n      var_4 = 0x3f;\n    }\n    else if (var_4 < 5) {\n      var_9 = (var_14 >> 6) + 0x39;\n      var_4 = (var_14 >> 6) + 0x38;\n      var_7 = var_9 * 8;\n    }\n    else if (var_4 < 0x15) {\n      var_9 = var_4 + 0x5c;\n      var_4 = var_4 + 0x5b;\n      var_7 = var_9 * 8;\n    }\n    else if (var_4 < 0x55) {\n      var_9 = (var_14 >> 0xc) + 0x6f;\n      var_4 = (var_14 >> 0xc) + 0x6e;\n      var_7 = var_9 * 8;\n    }\n    else if (var_4 < 0x155) {\n      var_9 = (var_14 >> 0xf) + 0x78;\n      var_4 = (var_14 >> 0xf) + 0x77;\n      var_7 = var_9 * 8;\n    }\n    else if (var_4 < 0x555) {\n      var_9 = (var_14 >> 0x12) + 0x7d;\n      var_4 = (var_14 >> 0x12) + 0x7c;\n      var_7 = var_9 * 8;\n    }\n    else {\n      var_7 = 0x3f8;\n      var_9 = 0x7f;\n      var_4 = 0x7e;\n    }\n    for (pointer_12 = *(undefined **)(PTR_DAT_08008e4c + var_7 + 4); var_14 = var_9,\n        PTR_DAT_08008e4c + var_7 + -8 != pointer_12; pointer_12 = *(undefined **)(pointer_12 + 0xc)) {\n      var_16 = (*(uint *)(pointer_12 + 4) & 0xfffffffc) - var_15;\n      var_14 = var_4;\n      if (0xf < var_16) break;\n      if (-1 < var_16) {\n        pointer_8 = pointer_12 + (*(uint *)(pointer_12 + 4) & 0xfffffffc);\n        var_14 = *(uint *)(pointer_8 + 4);\n        var_7 = *(int *)(pointer_12 + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  pointer_8 = PTR_PTR_DAT_08008e60;\n  pointer_12 = PTR_DAT_08008e4c;\n  pointer_13 = *(undefined **)(PTR_DAT_08008e4c + 0x10);\n  if (pointer_13 == PTR_PTR_DAT_08008e60) {\n    var_4 = *(uint *)(PTR_DAT_08008e4c + 4);\n    var_9 = 1 << ((int)var_14 >> 2 & 0xffU);\n    if (var_9 <= var_4) goto LAB_08008c06;\n  }\n  else {\n    var_9 = *(uint *)(pointer_13 + 4);\n    var_10 = var_9 & 0xfffffffc;\n    var_4 = var_10 - var_15;\n    if (0xf < (int)var_4) {\n      pointer_3 = pointer_13 + var_15;\n      *(uint *)(pointer_13 + 4) = var_15 | 1;\n      *(undefined **)(pointer_12 + 0x10) = pointer_3;\n      *(undefined **)(pointer_12 + 0x14) = pointer_3;\n      *(undefined **)(pointer_3 + 8) = pointer_8;\n      *(undefined **)(pointer_3 + 0xc) = pointer_8;\n      *(uint *)(pointer_3 + 4) = var_4 | 1;\n      *(uint *)(pointer_13 + var_10) = var_4;\n      do_nothing_with_pointer_080090b4(param_pointer);\n      return (int *)(pointer_13 + 8);\n    }\n    *(undefined **)(PTR_DAT_08008e4c + 0x10) = PTR_PTR_DAT_08008e60;\n    *(undefined **)(pointer_12 + 0x14) = pointer_8;\n    if (-1 < (int)var_4) {\n      *(uint *)(pointer_13 + var_10 + 4) = *(uint *)(pointer_13 + var_10 + 4) | 1;\n      do_nothing_with_pointer_080090b4(param_pointer);\n      return (int *)(pointer_13 + 8);\n    }\n    if (var_10 < 0x200) {\n      var_7 = (var_9 >> 3) + 1;\n      var_16 = *(int *)(pointer_12 + var_7 * 8);\n      var_4 = 1 << ((int)(var_9 >> 3) >> 2 & 0xffU) | *(uint *)(pointer_12 + 4);\n      *(int *)(pointer_13 + 8) = var_16;\n      *(undefined **)(pointer_13 + 0xc) = pointer_12 + var_7 * 8 + -8;\n      *(uint *)(pointer_12 + 4) = var_4;\n      *(undefined **)(pointer_12 + var_7 * 8) = pointer_13;\n      *(undefined **)(var_16 + 0xc) = pointer_13;\n    }\n    else {\n      var_4 = var_9 >> 9;\n      if (var_4 < 5) {\n        var_7 = ((var_9 >> 6) + 0x39) * 8;\n        var_16 = (var_9 >> 6) + 0x38;\n      }\n      else if (var_4 < 0x15) {\n        var_7 = (var_4 + 0x5c) * 8;\n        var_16 = var_4 + 0x5b;\n      }\n      else if (var_4 < 0x55) {\n        var_7 = ((var_9 >> 0xc) + 0x6f) * 8;\n        var_16 = (var_9 >> 0xc) + 0x6e;\n      }\n      else if (var_4 < 0x155) {\n        var_7 = ((var_9 >> 0xf) + 0x78) * 8;\n        var_16 = (var_9 >> 0xf) + 0x77;\n      }\n      else if (var_4 < 0x555) {\n        var_7 = ((var_9 >> 0x12) + 0x7d) * 8;\n        var_16 = (var_9 >> 0x12) + 0x7c;\n      }\n      else {\n        var_7 = 0x3f8;\n        var_16 = 0x7e;\n      }\n      pointer_3 = *(undefined **)(pointer_12 + var_7);\n      pointer_1 = pointer_12 + var_7 + -8;\n      if (pointer_1 == pointer_3) {\n        var_4 = 1 << (var_16 >> 2 & 0xffU) | *(uint *)(pointer_12 + 4);\n        *(uint *)(pointer_12 + 4) = var_4;\n      }\n      else {\n        do {\n          if ((*(uint *)(pointer_3 + 4) & 0xfffffffc) <= var_10) break;\n          pointer_3 = *(undefined **)(pointer_3 + 8);\n        } while (pointer_1 != pointer_3);\n        pointer_1 = *(undefined **)(pointer_3 + 0xc);\n        var_4 = *(uint *)(pointer_12 + 4);\n      }\n      *(undefined **)(pointer_13 + 8) = pointer_3;\n      *(undefined **)(pointer_13 + 0xc) = pointer_1;\n      *(undefined **)(pointer_1 + 8) = pointer_13;\n      *(undefined **)(pointer_3 + 0xc) = pointer_13;\n    }\n    var_9 = 1 << ((int)var_14 >> 2 & 0xffU);\n    if (var_9 <= var_4) {\nLAB_08008c06:\n      if ((var_9 & var_4) == 0) {\n        var_14 = var_14 & 0xfffffffc;\n        do {\n          var_9 = var_9 << 1;\n          var_14 = var_14 + 4;\n        } while ((var_9 & var_4) == 0);\n      }\n      do {\n        pointer_17 = (undefined4 *)(pointer_12 + var_14 * 8);\n        var_4 = var_14;\n        pointer_18 = pointer_17;\n        do {\n          for (pointer_11 = (undefined4 *)pointer_18[3]; pointer_18 != pointer_11;\n              pointer_11 = (undefined4 *)pointer_11[3]) {\n            var_10 = pointer_11[1] & 0xfffffffc;\n            var_5 = var_10 - var_15;\n            if (0xf < (int)var_5) {\n              var_16 = pointer_11[2];\n              var_7 = pointer_11[3];\n              pointer_13 = (undefined *)(var_15 + (int)pointer_11);\n              pointer_11[1] = var_15 | 1;\n              *(int *)(var_16 + 0xc) = var_7;\n              *(int *)(var_7 + 8) = var_16;\n              *(undefined **)(pointer_12 + 0x10) = pointer_13;\n              *(undefined **)(pointer_12 + 0x14) = pointer_13;\n              *(undefined **)(pointer_13 + 8) = pointer_8;\n              *(undefined **)(pointer_13 + 0xc) = pointer_8;\n              *(uint *)(pointer_13 + 4) = var_5 | 1;\n              *(uint *)((int)pointer_11 + var_10) = var_5;\n              do_nothing_with_pointer_080090b4(param_pointer);\n              return pointer_11 + 2;\n            }\n            if (-1 < (int)var_5) {\n              var_7 = pointer_11[3];\n              var_16 = pointer_11[2];\n              *(uint *)((int)pointer_11 + var_10 + 4) = *(uint *)((int)pointer_11 + var_10 + 4) | 1;\n              *(int *)(var_16 + 0xc) = var_7;\n              *(int *)(var_7 + 8) = var_16;\n              do_nothing_with_pointer_080090b4(param_pointer);\n              return pointer_11 + 2;\n            }\n          }\n          var_4 = var_4 + 1;\n          pointer_18 = pointer_18 + 2;\n        } while ((var_4 & 3) != 0);\n        do {\n          var_10 = var_14 & 3;\n          pointer_18 = pointer_17 + -2;\n          var_14 = var_14 - 1;\n          if (var_10 == 0) {\n            var_10 = *(uint *)(pointer_12 + 4) & ~var_9;\n            *(uint *)(pointer_12 + 4) = var_10;\n            goto LAB_08008f24;\n          }\n          pointer_17 = (undefined4 *)*pointer_17;\n        } while (pointer_17 == pointer_18);\n        var_10 = *(uint *)(pointer_12 + 4);\nLAB_08008f24:\n        var_9 = var_9 * 2;\n        if ((var_10 <= var_9 && var_9 - var_10 != 0) || (var_14 = var_4, var_9 == 0)) break;\n        for (; (var_9 & var_10) == 0; var_9 = var_9 << 1) {\n          var_14 = var_14 + 4;\n        }\n      } while( true );\n    }\n  }\n  pointer_8 = PTR_DAT_08008e64;\n  pointer_13 = *(undefined **)(pointer_12 + 8);\n  var_14 = *(uint *)(pointer_13 + 4) & 0xfffffffc;\n  if ((var_15 <= var_14) && (var_4 = var_14 - var_15, 0xf < (int)var_4)) goto LAB_08008dac;\n  if (*(int *)PTR_DAT_08008e64 == -1) {\n    var_4 = var_15 + *(int *)PTR_DAT_08008e50 + 0x10;\n  }\n  else {\n    var_4 = var_15 + *(int *)PTR_DAT_08008e50 + 0x100f & 0xfffff000;\n  }\n  pointer_1 = (undefined *)allocate_memory_and_return_pointer_08009744(param_pointer,var_4);\n  pointer_6 = (uint *)PTR_DAT_08009018;\n  pointer_3 = PTR_DAT_08008e54;\n  if (pointer_1 == (undefined *)0xffffffff) {\nLAB_08008ed8:\n    pointer_13 = *(undefined **)(pointer_12 + 8);\n    var_14 = *(uint *)(pointer_13 + 4);\n  }\n  else {\n    pointer_2 = pointer_13 + var_14;\n    if (pointer_2 < pointer_1 || pointer_2 == pointer_1) {\n      var_9 = *(int *)PTR_DAT_08008e54 + var_4;\n      *(uint *)PTR_DAT_08008e54 = var_9;\n      pointer_6 = (uint *)pointer_3;\n      if ((pointer_2 != pointer_1) || (((uint)pointer_2 & 0xfff) != 0)) goto LAB_08008d02;\n      *(uint *)(*(int *)(pointer_12 + 8) + 4) = var_14 + var_4 | 1;\n    }\n    else {\n      if (pointer_13 != pointer_12) goto LAB_08008ed8;\n      var_9 = *(int *)PTR_DAT_08009018 + var_4;\n      *(uint *)PTR_DAT_08009018 = var_9;\nLAB_08008d02:\n      if (*(int *)pointer_8 == -1) {\n        *(undefined **)pointer_8 = pointer_1;\n      }\n      else {\n        *pointer_6 = (uint)(pointer_1 + (var_9 - (int)pointer_2));\n      }\n      var_9 = (uint)pointer_1 & 7;\n      if (var_9 == 0) {\n        var_7 = 0x1000;\n      }\n      else {\n        pointer_1 = pointer_1 + (8 - var_9);\n        var_7 = 0x1008 - var_9;\n      }\n      var_7 = var_7 - ((uint)(pointer_1 + var_4) & 0xfff);\n      var_16 = allocate_memory_and_return_pointer_08009744(param_pointer,var_7);\n      if (var_16 == -1) {\n        var_4 = 1;\n        var_7 = 0;\n      }\n      else {\n        var_4 = (var_16 - (int)pointer_1) + var_7 | 1;\n      }\n      var_9 = *pointer_6 + var_7;\n      *(undefined **)(pointer_12 + 8) = pointer_1;\n      *pointer_6 = var_9;\n      *(uint *)(pointer_1 + 4) = var_4;\n      if (pointer_13 != pointer_12) {\n        if (var_14 < 0x10) {\n          *(undefined4 *)(pointer_1 + 4) = 1;\n          goto LAB_08008eee;\n        }\n        var_14 = var_14 - 0xc & 0xfffffff8;\n        *(uint *)(pointer_13 + 4) = *(uint *)(pointer_13 + 4) & 1 | var_14;\n        *(undefined4 *)(pointer_13 + var_14 + 4) = 5;\n        *(undefined4 *)(pointer_13 + var_14 + 8) = 5;\n        if (0xf < var_14) {\n          allocate_memory_block_080088ec(param_pointer,pointer_13 + 8);\n          var_9 = *pointer_6;\n        }\n      }\n    }\n    pointer_8 = PTR_DAT_08008e5c;\n    pointer_13 = *(undefined **)(pointer_12 + 8);\n    var_4 = *(uint *)PTR_DAT_08008e5c;\n    if (*(uint *)PTR_DAT_08008e58 < var_9) {\n      *(uint *)PTR_DAT_08008e58 = var_9;\n    }\n    var_14 = *(uint *)(pointer_13 + 4);\n    if (var_4 < var_9) {\n      *(uint *)pointer_8 = var_9;\n    }\n  }\n  var_4 = (var_14 & 0xfffffffc) - var_15;\n  if ((var_15 <= (var_14 & 0xfffffffc)) && (0xf < (int)var_4)) {\nLAB_08008dac:\n    *(uint *)(pointer_13 + 4) = var_15 | 1;\n    *(undefined **)(pointer_12 + 8) = pointer_13 + var_15;\n    *(uint *)(pointer_13 + var_15 + 4) = var_4 | 1;\n    do_nothing_with_pointer_080090b4(param_pointer);\n    return (int *)(pointer_13 + 8);\n  }\nLAB_08008eee:\n  do_nothing_with_pointer_080090b4(param_pointer);\n  return (int *)0x0;\n}\n\n",
            "called": [
                "FUN_08009744",
                "FUN_080090b4",
                "FUN_080090a8",
                "FUN_080088ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008af8",
            "calling": [
                "FUN_08009980",
                "FUN_08005e9c",
                "FUN_080097cc",
                "FUN_08009adc"
            ],
            "imported": false,
            "current_name": "allocate_and_return_pointer_08008af8"
        },
        "FUN_08002bb4": {
            "renaming": {
                "FUN_08002bb4": "check_pointer_value_08002bb4",
                "param_1": "pointer",
                "param_2": "max_pointer_distance",
                "param_3": "pointer_offset",
                "iVar1": "check_result",
                "get_pointer_value_080015a0": "get_pointer_value",
                "check_flag_08002d3c": "check_flag",
                "param_1[0x10]": "pointer_status",
                "param_1[0xc]": "pointer_index"
            },
            "code": "\nundefined4 check_pointer_value_08002bb4(int *pointer,uint max_pointer_distance,int pointer_offset)\n\n{\n  int check_result;\n  \n  while( true ) {\n    if ((*(uint *)(*pointer + 0x14) & 0x80) == 0x80) {\n      return 0;\n    }\n    check_result = check_flag_08002d3c(pointer);\n    if (check_result != 0) break;\n    if ((max_pointer_distance != 0xffffffff) &&\n       ((max_pointer_distance == 0 || (check_result = get_pointer_value_080015a0(), max_pointer_distance < (uint)(check_result - pointer_offset))))) {\n      pointer_status = pointer_status | 0x20;\n      pointer_index = 0;\n      *(undefined *)((int)pointer + 0x3d) = 0x20;\n      *(undefined *)(pointer + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "called": [
                "FUN_08002d3c",
                "FUN_080015a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002bb4",
            "calling": [
                "FUN_08002640",
                "FUN_080027f4",
                "FUN_08001ccc"
            ],
            "imported": false,
            "current_name": "check_pointer_value_08002bb4"
        },
        "FUN_08002d3c": {
            "renaming": {
                "FUN_08002d3c": "check_flag_08002d3c",
                "param_1": "flag_ptr",
                "bVar1": "is_flag_set",
                "int": "flag_type"
            },
            "code": "\nbool check_flag_08002d3c(flag_type *flag_ptr)\n\n{\n  bool is_flag_set;\n  \n  is_flag_set = (*(uflag_type *)(*flag_ptr + 0x14) & 0x400) == 0x400;\n  if (is_flag_set) {\n    *(undefined4 *)(*flag_ptr + 0x14) = 0xfffffbff;\n    flag_ptr[0x10] = 4;\n    flag_ptr[0xc] = 0;\n    *(undefined *)((flag_type)flag_ptr + 0x3d) = 0x20;\n    *(undefined *)(flag_ptr + 0xf) = 0;\n  }\n  return is_flag_set;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d3c",
            "calling": [
                "FUN_08002c2e",
                "FUN_08002bb4"
            ],
            "imported": false,
            "current_name": "check_flag_08002d3c"
        },
        "FUN_08004bd8": {
            "renaming": {
                "FUN_08004bd8": "calculate_result_08004bd8",
                "param_1": "input_array",
                "param_2": "output_value",
                "uVar1": "converted_float",
                "uVar2": "unsigned_long_long_1",
                "uVar3": "unsigned_long_long_2"
            },
            "code": "\nvoid calculate_result_08004bd8(int input_array,undefined4 *output_value)\n\n{\n  undefined4 converted_float;\n  undefined8 unsigned_long_long_1;\n  undefined8 unsigned_long_long_2;\n  \n  converted_float = floating_point_conversion_08000aa4(*(undefined4 *)(input_array + 0x10),*(undefined4 *)(input_array + 0x1c));\n  unsigned_long_long_1 = decode_unsigned_long_long_08000418(*(undefined4 *)PTR_DAT_08004d60);\n  unsigned_long_long_2 = decode_unsigned_long_long_08000418(converted_float);\n  unsigned_long_long_2 = calculate_double_precision_floating_point_value_080004c8((int)unsigned_long_long_2,(int)((ulonglong)unsigned_long_long_2 >> 0x20),DAT_08004d40,DAT_08004d44);\n  unsigned_long_long_1 = calculate_double_precision_float_0800015c((int)unsigned_long_long_1,(int)((ulonglong)unsigned_long_long_1 >> 0x20),(int)unsigned_long_long_2,\n                       (int)((ulonglong)unsigned_long_long_2 >> 0x20));\n  converted_float = floating_point_to_unsigned_integer_080009fc((int)unsigned_long_long_1,(int)((ulonglong)unsigned_long_long_1 >> 0x20));\n  *(undefined4 *)PTR_DAT_08004d60 = converted_float;\n  unsigned_long_long_1 = decode_unsigned_long_long_08000418(*(undefined4 *)(input_array + 4));\n  unsigned_long_long_1 = FUNC_0800071c((int)unsigned_long_long_1,(int)((ulonglong)unsigned_long_long_1 >> 0x20),0,DAT_08004d64);\n  unsigned_long_long_2 = decode_unsigned_long_long_08000418(*(undefined4 *)(input_array + 8));\n  unsigned_long_long_2 = FUNC_0800071c((int)unsigned_long_long_2,(int)((ulonglong)unsigned_long_long_2 >> 0x20),0,DAT_08004d64);\n  unsigned_long_long_1 = thunk_calculate_result_08004bd8_08005838((int)unsigned_long_long_1,(int)((ulonglong)unsigned_long_long_1 >> 0x20),(int)unsigned_long_long_2,\n                             (int)((ulonglong)unsigned_long_long_2 >> 0x20));\n  unsigned_long_long_1 = calculate_double_precision_floating_point_value_080004c8((int)unsigned_long_long_1,(int)((ulonglong)unsigned_long_long_1 >> 0x20),0,DAT_08004d68);\n  unsigned_long_long_1 = FUNC_0800071c((int)unsigned_long_long_1,(int)((ulonglong)unsigned_long_long_1 >> 0x20),DAT_08004d48,DAT_08004d4c);\n  unsigned_long_long_2 = decode_unsigned_long_long_08000418(*(undefined4 *)(input_array + 0x24));\n  unsigned_long_long_1 = floating_point_addition_08000158((int)unsigned_long_long_1,(int)((ulonglong)unsigned_long_long_1 >> 0x20),(int)unsigned_long_long_2,\n                       (int)((ulonglong)unsigned_long_long_2 >> 0x20));\n  unsigned_long_long_1 = calculate_double_precision_float_0800015c((int)unsigned_long_long_1,(int)((ulonglong)unsigned_long_long_1 >> 0x20),0,DAT_08004d6c);\n  converted_float = floating_point_to_unsigned_integer_080009fc((int)unsigned_long_long_1,(int)((ulonglong)unsigned_long_long_1 >> 0x20));\n  if (*PTR_DAT_08004d70 == '\\0') {\n    unsigned_long_long_1 = decode_unsigned_long_long_08000418(*(undefined4 *)PTR_DAT_08004d60);\n    unsigned_long_long_1 = calculate_double_precision_floating_point_value_080004c8((int)unsigned_long_long_1,(int)((ulonglong)unsigned_long_long_1 >> 0x20),DAT_08004d50,DAT_08004d54);\n    unsigned_long_long_2 = decode_unsigned_long_long_08000418(converted_float);\n    unsigned_long_long_2 = calculate_double_precision_floating_point_value_080004c8((int)unsigned_long_long_2,(int)((ulonglong)unsigned_long_long_2 >> 0x20),DAT_08004d58,DAT_08004d5c);\n    unsigned_long_long_1 = calculate_double_precision_float_0800015c((int)unsigned_long_long_1,(int)((ulonglong)unsigned_long_long_1 >> 0x20),(int)unsigned_long_long_2,\n                         (int)((ulonglong)unsigned_long_long_2 >> 0x20));\n    converted_float = floating_point_to_unsigned_integer_080009fc((int)unsigned_long_long_1,(int)((ulonglong)unsigned_long_long_1 >> 0x20));\n    *(undefined4 *)PTR_DAT_08004d60 = converted_float;\n  }\n  else {\n    *(undefined4 *)PTR_DAT_08004d60 = converted_float;\n    *PTR_DAT_08004d70 = 0;\n  }\n  *output_value = *(undefined4 *)PTR_DAT_08004d60;\n  return;\n}\n\n",
            "called": [
                "FUN_08000158",
                "FUN_080004c8",
                "FUN_0800015c",
                "FUN_080009fc",
                "FUN_0800071c",
                "FUN_08000418",
                "FUN_08000aa4",
                "thunk_FUN_08005838"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004bd8",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "calculate_result_08004bd8"
        },
        "FUN_080090c0": {
            "renaming": {
                "FUN_080090c0": "allocate_or_get_pointer_080090c0",
                "param_1": "pointer_to_memory_block",
                "param_2": "index",
                "puVar1": "pointer_to_data",
                "iVar2": "memory_block_index"
            },
            "code": "\nundefined4 * allocate_or_get_pointer_080090c0(int pointer_to_memory_block,uint index)\n\n{\n  undefined4 *pointer_to_data;\n  int memory_block_index;\n  \n  memory_block_index = *(int *)(pointer_to_memory_block + 0x4c);\n  if (memory_block_index == 0) {\n    memory_block_index = allocate_and_initialize_memory_08009980(pointer_to_memory_block,4,0x21);\n    *(int *)(pointer_to_memory_block + 0x4c) = memory_block_index;\n    if (memory_block_index == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  pointer_to_data = *(undefined4 **)(memory_block_index + index * 4);\n  if (pointer_to_data == (undefined4 *)0x0) {\n    memory_block_index = 1 << (index & 0xff);\n    pointer_to_data = (undefined4 *)allocate_and_initialize_memory_08009980(pointer_to_memory_block,1,(memory_block_index + 5) * 4);\n    if (pointer_to_data == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    pointer_to_data[1] = index;\n    pointer_to_data[2] = memory_block_index;\n  }\n  else {\n    *(undefined4 *)(memory_block_index + index * 4) = *pointer_to_data;\n  }\n  pointer_to_data[3] = 0;\n  pointer_to_data[4] = 0;\n  return pointer_to_data;\n}\n\n",
            "called": [
                "FUN_08009980"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090c0",
            "calling": [
                "FUN_08009244",
                "FUN_08009630",
                "FUN_080093a4",
                "FUN_08009120",
                "FUN_08009444",
                "FUN_080079e8",
                "FUN_08009530",
                "FUN_08009258"
            ],
            "imported": false,
            "current_name": "allocate_or_get_pointer_080090c0"
        },
        "FUN_080091e4": {
            "renaming": {
                "FUN_080091e4": "count_leading_zeros_080091e4",
                "param_1": "num_ptr",
                "uVar1": "leading_zeros_count",
                "uVar2": "num"
            },
            "code": "\nuint count_leading_zeros_080091e4(uint *num_ptr)\n\n{\n  uint leading_zeros_count;\n  uint num;\n  \n  num = *num_ptr;\n  leading_zeros_count = num & 7;\n  if (leading_zeros_count == 0) {\n    if ((num & 0xffff) == 0) {\n      num = num >> 0x10;\n      leading_zeros_count = 0x10;\n    }\n    if ((num & 0xff) == 0) {\n      num = num >> 8;\n      leading_zeros_count = leading_zeros_count + 8;\n    }\n    if ((num & 0xf) == 0) {\n      num = num >> 4;\n      leading_zeros_count = leading_zeros_count + 4;\n    }\n    if ((num & 3) == 0) {\n      num = num >> 2;\n      leading_zeros_count = leading_zeros_count + 2;\n    }\n    if (-1 < (int)(num << 0x1f)) {\n      num = num >> 1;\n      if (num == 0) {\n        return 0x20;\n      }\n      leading_zeros_count = leading_zeros_count + 1;\n    }\n    *num_ptr = num;\n    return leading_zeros_count;\n  }\n  if (-1 < (int)(num << 0x1f)) {\n    if ((int)(num << 0x1e) < 0) {\n      *num_ptr = num >> 1;\n      return 1;\n    }\n    *num_ptr = num >> 2;\n    return 2;\n  }\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091e4",
            "calling": [
                "FUN_08009630"
            ],
            "imported": false,
            "current_name": "count_leading_zeros_080091e4"
        },
        "FUN_080009fc": {
            "renaming": {
                "FUN_080009fc": "floating_point_to_unsigned_integer_080009fc",
                "param_1": "floating_point_value",
                "param_2": "floating_point_bits",
                "uVar1": "result",
                "uVar2": "bits_times_two",
                "uVar3": "adjusted_bits_times_two",
                "in_r12": "adjusted_bits_times_two_alt",
                "bVar4": "is_zero",
                "bVar5": "is_small"
            },
            "code": "\nuint floating_point_to_unsigned_integer_080009fc(uint floating_point_value,uint floating_point_bits)\n\n{\n  uint result;\n  uint bits_times_two;\n  uint adjusted_bits_times_two;\n  uint adjusted_bits_times_two_alt;\n  bool is_zero;\n  bool is_small;\n  \n  bits_times_two = floating_point_bits * 2;\n  is_small = bits_times_two < 0x70000000;\n  adjusted_bits_times_two = bits_times_two + 0x90000000;\n  result = adjusted_bits_times_two;\n  if (!is_small) {\n    adjusted_bits_times_two_alt = bits_times_two + 0x8fe00000;\n    result = adjusted_bits_times_two_alt;\n  }\n  is_zero = result == 0;\n  if (!is_small && adjusted_bits_times_two >= 0x200000) {\n    is_zero = adjusted_bits_times_two_alt == 0x1fc00000;\n  }\n  if (((is_small || adjusted_bits_times_two < 0x200000) || 0x1fc00000 < adjusted_bits_times_two_alt) || is_zero) {\n    if ((floating_point_bits & 0x40000000) != 0) {\n      if (((int)bits_times_two >> 0x15 == -1) && ((floating_point_value | floating_point_bits << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return floating_point_bits & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(bits_times_two + 0x92e00000) < 0 != SCARRY4(adjusted_bits_times_two,0x2e00000)) {\n      return floating_point_bits & 0x80000000;\n    }\n    bits_times_two = 0x18 - (bits_times_two + 0x92e00000 >> 0x15);\n    result = floating_point_value >> (bits_times_two & 0xff);\n    if (floating_point_value << (0x20 - bits_times_two & 0xff) != 0) {\n      result = result | 1;\n    }\n    adjusted_bits_times_two = floating_point_bits & 0x1fffff | 0x100000;\n    floating_point_value = result | adjusted_bits_times_two << (0x20 - bits_times_two & 0xff);\n    adjusted_bits_times_two = (adjusted_bits_times_two >> (bits_times_two & 0xff)) << 1;\n  }\n  result = (floating_point_bits & 0x80000000 | floating_point_value >> 0x1d) + adjusted_bits_times_two * 4 + (uint)(0x7fffffff < floating_point_value * 8);\n  if (floating_point_value * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009fc",
            "calling": [
                "FUN_08004d78",
                "FUN_08004bd8"
            ],
            "imported": false,
            "current_name": "floating_point_to_unsigned_integer_080009fc"
        },
        "FUN_08000cb8": {
            "renaming": {
                "FUN_08000cb8": "floating_point_addition_08000cb8",
                "param_1": "float_1",
                "param_2": "float_2",
                "param_3": "float_3",
                "param_4": "float_4",
                "lVar1": "product",
                "uVar2": "result",
                "uVar3": "exponent_1",
                "uVar6": "mantissa_product",
                "uVar8": "exponent_result",
                "bVar9": "condition",
                "bVar10": "borrow_flag",
                "iVar4": "exponent_sum",
                "iVar5": "shift_amount",
                "iVar7": "shifted_exponent",
                "SBORROW4": "signed_subtraction_overflow",
                "SCARRY4": "signed_addition_overflow"
            },
            "code": "\nuint floating_point_addition_08000cb8(uint float_1,uint float_2,undefined4 float_3,uint float_4)\n\n{\n  longlong product;\n  uint result;\n  uint exponent_1;\n  int exponent_sum;\n  int shift_amount;\n  uint mantissa_product;\n  int shifted_exponent;\n  uint exponent_result;\n  bool condition;\n  bool borrow_flag;\n  \n  exponent_1 = float_1 >> 0x17 & 0xff;\n  condition = exponent_1 == 0;\n  if (!condition) {\n    float_4 = float_2 >> 0x17 & 0xff;\n    condition = float_4 == 0;\n  }\n  if (!condition) {\n    condition = exponent_1 == 0xff;\n  }\n  if (!condition) {\n    condition = float_4 == 0xff;\n  }\n  if (condition) {\n    float_4 = float_2 >> 0x17 & 0xff;\n    if (exponent_1 == 0xff || float_4 == 0xff) {\n      condition = float_1 == 0 || float_1 == 0x80000000;\n      result = float_2;\n      if (float_1 != 0 && float_1 != 0x80000000) {\n        condition = float_2 == 0;\n        result = float_1;\n      }\n      if (!condition) {\n        condition = float_2 == 0x80000000;\n      }\n      exponent_result = result;\n      if (((condition) || ((exponent_1 == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((float_4 == 0xff && (exponent_result = float_2, (float_2 & 0x7fffff) != 0)))) {\n        return exponent_result | 0x7fc00000;\n      }\n      result = result ^ float_2;\n      goto LAB_08000e08;\n    }\n    condition = (float_1 & 0x7fffffff) == 0;\n    if (!condition) {\n      condition = (float_2 & 0x7fffffff) == 0;\n    }\n    if (condition) {\n      return (float_1 ^ float_2) & 0x80000000;\n    }\n    condition = exponent_1 == 0;\n    result = float_1 & 0x80000000;\n    while( true ) {\n      if (condition) {\n        float_1 = float_1 << 1;\n        condition = (float_1 & 0x800000) == 0;\n      }\n      if (!condition) break;\n      exponent_1 = exponent_1 - 1;\n    }\n    float_1 = float_1 | result;\n    condition = float_4 == 0;\n    result = float_2 & 0x80000000;\n    while( true ) {\n      if (condition) {\n        float_2 = float_2 << 1;\n        condition = (float_2 & 0x800000) == 0;\n      }\n      if (!condition) break;\n      float_4 = float_4 - 1;\n    }\n    float_2 = float_2 | result;\n  }\n  exponent_sum = exponent_1 + float_4;\n  exponent_result = float_1 ^ float_2;\n  exponent_1 = float_1 << 9;\n  condition = exponent_1 == 0;\n  if (!condition) {\n    float_2 = float_2 << 9;\n    condition = float_2 == 0;\n  }\n  if (condition) {\n    if (exponent_1 == 0) {\n      float_2 = float_2 << 9;\n    }\n    result = exponent_result & 0x80000000 | float_1 & 0x7fffff | float_2 >> 9;\n    borrow_flag = signed_subtraction_overflow(exponent_sum,0x7f);\n    shift_amount = exponent_sum + -0x7f;\n    condition = shift_amount == 0;\n    shifted_exponent = shift_amount;\n    if (!condition && 0x7e < exponent_sum) {\n      borrow_flag = signed_subtraction_overflow(0xff,shift_amount);\n      shifted_exponent = 0xff - shift_amount;\n      condition = shift_amount == 0xff;\n    }\n    if (!condition && shifted_exponent < 0 == borrow_flag) {\n      result = result | shift_amount * 0x800000;\n    }\n    if (!condition && shifted_exponent < 0 == borrow_flag) {\n      return result;\n    }\n    result = result | 0x800000;\n    mantissa_product = 0;\n    borrow_flag = signed_subtraction_overflow(shift_amount,1);\n    exponent_result = exponent_sum - 0x80;\n    condition = exponent_result == 0;\n    exponent_1 = exponent_result;\n  }\n  else {\n    product = (ulonglong)(exponent_1 >> 5 | 0x8000000) * (ulonglong)(float_2 >> 5 | 0x8000000);\n    mantissa_product = (uint)product;\n    result = (uint)((ulonglong)product >> 0x20);\n    condition = result < 0x800000;\n    if (condition) {\n      result = result << 1;\n    }\n    if (condition) {\n      result = result | mantissa_product >> 0x1f;\n      mantissa_product = mantissa_product << 1;\n    }\n    result = exponent_result & 0x80000000 | result;\n    exponent_result = (exponent_sum + -0x7f) - (uint)condition;\n    borrow_flag = signed_subtraction_overflow(exponent_result,0xfd);\n    condition = exponent_result == 0xfd;\n    exponent_1 = exponent_result - 0xfd;\n    if (exponent_result < 0xfe) {\n      result = result + exponent_result * 0x800000 + (uint)(0x7fffffff < mantissa_product);\n      if (mantissa_product == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (condition || (int)exponent_1 < 0 != borrow_flag) {\n    condition = (int)(exponent_result + 0x19) < 0;\n    if (exponent_result == 0xffffffe7 || condition != signed_addition_overflow(exponent_result,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (exponent_result != 0xffffffe7 && condition == signed_addition_overflow(exponent_result,0x19)) {\n      exponent_1 = (result << 1) >> (-exponent_result & 0xff);\n      exponent_result = result << (exponent_result + 0x20 & 0xff);\n      exponent_1 = ((uint)((result & 0x80000000) != 0) << 0x1f | exponent_1 >> 1) + (uint)((byte)exponent_1 & 1);\n      if ((mantissa_product | exponent_result << 1) == 0) {\n        exponent_1 = exponent_1 & ~(exponent_result >> 0x1f);\n      }\n      return exponent_1;\n    }\n    return result;\n  }\nLAB_08000e08:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000cb8",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "floating_point_addition_08000cb8"
        },
        "FUN_080093a4": {
            "renaming": {
                "FUN_080093a4": "calculate_hash_080093a4",
                "param_1": "hash_table",
                "param_2": "data",
                "param_3": "data_size",
                "iVar1": "index",
                "iVar2": "data_size_in_words",
                "puVar3": "current_data",
                "puVar4": "hash_value"
            },
            "code": "\nundefined4 * calculate_hash_080093a4(int hash_table,undefined4 *data,uint data_size)\n\n{\n  int index;\n  int data_size_in_words;\n  undefined4 *current_data;\n  undefined4 *hash_value;\n  \n  if ((data_size & 3) != 0) {\n    data = (undefined4 *)\n              multiply_and_accumulate_08009120(hash_table,data,\n                           *(undefined4 *)(PTR_DAT_08009440 + ((data_size & 3) - 1) * 4),0);\n  }\n  data_size_in_words = (int)data_size >> 2;\n  if (data_size_in_words != 0) {\n    hash_value = *(undefined4 **)(hash_table + 0x48);\n    if (hash_value == (undefined4 *)0x0) {\n      hash_value = (undefined4 *)allocate_or_get_pointer_080090c0(hash_table,1);\n      hash_value[4] = 1;\n      hash_value[5] = 0x271;\n      *(undefined4 **)(hash_table + 0x48) = hash_value;\n      *hash_value = 0;\n    }\n    current_data = data;\n    if (data_size_in_words << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    data_size_in_words = data_size_in_words >> 1;\n    current_data = hash_value;\n    if (data_size_in_words != 0) {\n      while( true ) {\n        hash_value = (undefined4 *)*current_data;\n        if (hash_value == (undefined4 *)0x0) {\n          hash_value = (undefined4 *)calculate_polynomial_hash_08009258(hash_table,current_data,current_data);\n          *current_data = hash_value;\n          *hash_value = 0;\n        }\n        current_data = data;\n        if (-1 < data_size_in_words << 0x1f) break;\nLAB_080093d2:\n        data = (undefined4 *)calculate_polynomial_hash_08009258(hash_table,current_data,hash_value);\n        if (current_data == (undefined4 *)0x0) break;\n        index = *(int *)(hash_table + 0x4c);\n        data_size_in_words = data_size_in_words >> 1;\n        *current_data = *(undefined4 *)(index + current_data[1] * 4);\n        *(undefined4 **)(index + current_data[1] * 4) = current_data;\n        current_data = hash_value;\n        if (data_size_in_words == 0) {\n          return data;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return data;\n}\n\n",
            "called": [
                "FUN_08009120",
                "FUN_08009258",
                "FUN_080090c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080093a4",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "calculate_hash_080093a4"
        },
        "FUN_080098c0": {
            "renaming": {
                "FUN_080098c0": "update_data_080098c0",
                "param_1": "update_type",
                "param_2": "data",
                "param_3": "value_1",
                "param_4": "value_2",
                "puVar1": "global_ptr",
                "uVar2": "return_value",
                "uVar3": "bit_mask",
                "uVar4": "index",
                "iVar5": "data_ptr",
                "iVar6": "global_data_ptr",
                "iVar7": "new_index"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 update_data_080098c0(int update_type,undefined4 data,undefined4 value_1,undefined4 value_2)\n\n{\n  undefined *global_ptr;\n  undefined4 return_value;\n  uint bit_mask;\n  uint index;\n  int data_ptr;\n  int global_data_ptr;\n  int new_index;\n  \n  global_ptr = PTR_PTR_DAT_08009974;\n  do_nothing_08008af0(*(undefined4 *)PTR_PTR_DAT_08009974);\n  global_data_ptr = *(int *)PTR_PTR_DAT_08009978;\n  data_ptr = *(int *)(global_data_ptr + 0x148);\n  if (data_ptr == 0) {\n    data_ptr = global_data_ptr + 0x14c;\n    *(int *)(global_data_ptr + 0x148) = data_ptr;\n  }\n  index = *(uint *)(data_ptr + 4);\n  if ((int)index < 0x20) {\n    new_index = index + 1;\n  }\n  else {\n    if (DAT_0800997c == 0) {\n      do_nothing_08008af4(*(undefined4 *)global_ptr);\n      return 0xffffffff;\n    }\n    data_ptr = 400;\n    index = 0;\n    _DAT_00000190 = *(undefined4 *)(global_data_ptr + 0x148);\n    new_index = 1;\n    _DAT_00000194 = 0;\n    *(undefined4 *)(global_data_ptr + 0x148) = 400;\n    _DAT_00000318 = 0;\n    _DAT_0000031c = 0;\n  }\n  if (update_type != 0) {\n    global_data_ptr = data_ptr + index * 4;\n    *(undefined4 *)(global_data_ptr + 0x88) = value_1;\n    bit_mask = 1 << (index & 0xff);\n    *(uint *)(data_ptr + 0x188) = *(uint *)(data_ptr + 0x188) | bit_mask;\n    *(undefined4 *)(global_data_ptr + 0x108) = value_2;\n    if (update_type == 2) {\n      *(uint *)(data_ptr + 0x18c) = bit_mask | *(uint *)(data_ptr + 0x18c);\n    }\n  }\n  *(int *)(data_ptr + 4) = new_index;\n  return_value = *(undefined4 *)global_ptr;\n  *(undefined4 *)(data_ptr + (index + 2) * 4) = data;\n  do_nothing_08008af4(return_value);\n  return 0;\n}\n\n",
            "called": [
                "FUN_08008af4",
                "FUN_08008af0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080098c0",
            "calling": [
                "FUN_080078a0"
            ],
            "imported": false,
            "current_name": "update_data_080098c0"
        },
        "FUN_08003c80": {
            "renaming": {
                "FUN_08003c80": "do_nothing_08003c80"
            },
            "code": "\nvoid do_nothing_08003c80(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003c80",
            "calling": [
                "FUN_080036f8"
            ],
            "imported": false,
            "current_name": "do_nothing_08003c80"
        },
        "FUN_0800015c": {
            "renaming": {
                "FUN_0800015c": "calculate_double_precision_float_0800015c",
                "param_1": "low_bits_a",
                "param_2": "high_bits_a",
                "param_3": "low_bits_b",
                "param_4": "high_bits_b",
                "iVar1": "shift_amount_b",
                "bVar2": "lsb",
                "uVar3": "sum_low",
                "uVar4": "sum_high",
                "iVar6": "shift_amount_a",
                "uVar7": "a_shifted",
                "uVar8": "low_bits",
                "uVar9": "high_bits",
                "uVar10": "diff",
                "uVar11": "temp",
                "uVar12": "carry",
                "bVar13": "equal",
                "bVar14": "condition",
                "bVar15": "borrow"
            },
            "code": "\nulonglong calculate_double_precision_float_0800015c(uint low_bits_a,uint high_bits_a,uint low_bits_b,uint high_bits_b)\n\n{\n  int shift_amount_b;\n  byte lsb;\n  uint sum_low;\n  uint sum_high;\n  uint uVar5;\n  int shift_amount_a;\n  uint a_shifted;\n  uint low_bits;\n  uint high_bits;\n  uint diff;\n  uint temp;\n  uint carry;\n  bool equal;\n  bool condition;\n  bool borrow;\n  \n  a_shifted = high_bits_a << 1;\n  high_bits = high_bits_b << 1;\n  equal = ((high_bits_a ^ high_bits_b) & 0x7fffffff) == 0;\n  condition = equal && low_bits_a == low_bits_b;\n  if (!equal || low_bits_a != low_bits_b) {\n    condition = (a_shifted | low_bits_a) == 0;\n  }\n  if (!condition) {\n    condition = (high_bits | low_bits_b) == 0;\n  }\n  shift_amount_a = (int)a_shifted >> 0x15;\n  if (!condition) {\n    condition = shift_amount_a == -1;\n  }\n  shift_amount_b = (int)high_bits >> 0x15;\n  if (!condition) {\n    condition = shift_amount_b == -1;\n  }\n  if (condition) {\n    if (shift_amount_a == -1 || shift_amount_b == -1) {\n      high_bits = high_bits_b;\n      a_shifted = low_bits_b;\n      if (shift_amount_a == -1) {\n        high_bits = high_bits_a;\n        a_shifted = low_bits_a;\n      }\n      if (shift_amount_a != -1 || shift_amount_b != -1) {\n        low_bits_b = a_shifted;\n        high_bits_b = high_bits;\n      }\n      condition = (a_shifted | high_bits << 0xc) == 0;\n      if (condition) {\n        condition = (low_bits_b | high_bits_b << 0xc) == 0;\n      }\n      if (condition) {\n        condition = high_bits == high_bits_b;\n      }\n      if (!condition) {\n        high_bits = high_bits | 0x80000;\n      }\n      return CONCAT44(high_bits,a_shifted);\n    }\n    if (((high_bits_a ^ high_bits_b) & 0x7fffffff) != 0 || low_bits_a != low_bits_b) {\n      if ((a_shifted | low_bits_a) == 0) {\n        low_bits_a = low_bits_b;\n        high_bits_a = high_bits_b;\n      }\n      return CONCAT44(high_bits_a,low_bits_a);\n    }\n    if (high_bits_a != high_bits_b) {\n      return 0;\n    }\n    if (a_shifted >> 0x15 == 0) {\n      condition = (low_bits_a & 0x80000000) != 0;\n      high_bits = high_bits_a * 2 + (uint)condition;\n      if (CARRY4(high_bits_a,high_bits_a) || CARRY4(high_bits_a * 2,(uint)condition)) {\n        high_bits = high_bits | 0x80000000;\n      }\n      return CONCAT44(high_bits,low_bits_a << 1);\n    }\n    if (a_shifted < 0xffc00000) {\n      return CONCAT44(high_bits_a + 0x100000,low_bits_a);\n    }\n    high_bits_a = high_bits_a & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(high_bits_a | 0x7ff00000) << 0x20;\n  }\n  a_shifted = a_shifted >> 0x15;\n  high_bits = high_bits >> 0x15;\n  diff = high_bits - a_shifted;\n  condition = diff != 0;\n  if (high_bits < a_shifted) {\n    diff = -diff;\n  }\n  low_bits = low_bits_a;\n  uVar5 = high_bits_a;\n  if (condition && a_shifted <= high_bits) {\n    a_shifted = a_shifted + diff;\n    low_bits = low_bits_b;\n    uVar5 = high_bits_b;\n    low_bits_b = low_bits_a;\n    high_bits_b = high_bits_a;\n  }\n  if (0x36 < diff) {\n    return CONCAT44(uVar5,low_bits);\n  }\n  high_bits = uVar5 & 0xfffff | 0x100000;\n  if ((uVar5 & 0x80000000) != 0) {\n    condition = low_bits != 0;\n    low_bits = -low_bits;\n    high_bits = -high_bits - (uint)condition;\n  }\n  uVar5 = high_bits_b & 0xfffff | 0x100000;\n  if ((high_bits_b & 0x80000000) != 0) {\n    condition = low_bits_b != 0;\n    low_bits_b = -low_bits_b;\n    uVar5 = -uVar5 - (uint)condition;\n  }\n  if (a_shifted == diff) {\n    uVar5 = uVar5 ^ 0x100000;\n    if (a_shifted == 0) {\n      high_bits = high_bits ^ 0x100000;\n      a_shifted = 1;\n    }\n    else {\n      diff = diff - 1;\n    }\n  }\n  carry = -diff + 0x20;\n  if ((int)diff < 0x21) {\n    temp = low_bits_b << (carry & 0xff);\n    low_bits_b = low_bits_b >> (diff & 0xff);\n    sum_low = low_bits + low_bits_b;\n    sum_high = uVar5 << (carry & 0xff);\n    carry = sum_low + sum_high;\n    high_bits = high_bits + CARRY4(low_bits,low_bits_b) + ((int)uVar5 >> (diff & 0xff)) +\n            (uint)CARRY4(sum_low,sum_high);\n  }\n  else {\n    temp = uVar5 << (-diff + 0x40 & 0xff);\n    if (low_bits_b != 0) {\n      temp = temp | 2;\n    }\n    uVar5 = (int)uVar5 >> (diff - 0x20 & 0xff);\n    carry = low_bits + uVar5;\n    high_bits = high_bits + ((int)uVar5 >> 0x1f) + (uint)CARRY4(low_bits,uVar5);\n  }\n  high_bits_a = high_bits & 0x80000000;\n  diff = high_bits;\n  if ((int)high_bits < 0) {\n    condition = temp == 0;\n    temp = -temp;\n    diff = -carry;\n    carry = -(uint)!condition - carry;\n    diff = -(uint)(condition <= diff) - high_bits;\n  }\n  if (0xfffff < diff) {\n    low_bits = a_shifted - 1;\n    if (0x1fffff < diff) {\n      high_bits = diff & 1;\n      diff = diff >> 1;\n      lsb = (byte)carry;\n      carry = (uint)(high_bits != 0) << 0x1f | carry >> 1;\n      temp = (uint)(lsb & 1) << 0x1f | temp >> 1;\n      low_bits = a_shifted;\n      if (0xffbfffff < a_shifted * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    condition = 0x7fffffff < temp;\n    if (temp == 0x80000000) {\n      condition = (carry & 1) != 0;\n    }\n    return CONCAT44(diff + low_bits * 0x100000 + (uint)CARRY4(carry,(uint)condition) | high_bits_a,\n                    carry + condition);\n  }\n  equal = (temp & 0x80000000) != 0;\n  temp = temp << 1;\n  low_bits = carry * 2;\n  condition = CARRY4(carry,carry);\n  carry = carry * 2 + (uint)equal;\n  diff = diff * 2 + (uint)(condition || CARRY4(low_bits,(uint)equal));\n  low_bits = a_shifted - 2;\n  if ((diff & 0x100000) != 0) goto LAB_08000268;\n  uVar5 = carry;\n  a_shifted = diff;\n  if (diff == 0) {\n    uVar5 = 0;\n    a_shifted = carry;\n  }\n  shift_amount_a = count_leading_zeroes(a_shifted);\n  if (diff == 0) {\n    shift_amount_a = shift_amount_a + 0x20;\n  }\n  carry = shift_amount_a - 0xb;\n  borrow = SBORROW4(carry,0x20);\n  diff = shift_amount_a - 0x2b;\n  condition = (int)diff < 0;\n  equal = diff == 0;\n  if ((int)carry < 0x20) {\n    borrow = SCARRY4(diff,0xc);\n    shift_amount_a = shift_amount_a + -0x1f;\n    condition = shift_amount_a < 0;\n    equal = shift_amount_a == 0;\n    diff = carry;\n    if (!equal && condition == borrow) {\n      uVar5 = a_shifted << (carry & 0xff);\n      a_shifted = a_shifted >> (0xcU - shift_amount_a & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (equal || condition != borrow) {\n    temp = 0x20 - diff;\n  }\n  a_shifted = a_shifted << (diff & 0xff);\n  if (equal || condition != borrow) {\n    a_shifted = a_shifted | uVar5 >> (temp & 0xff);\n  }\n  if (equal || condition != borrow) {\n    uVar5 = uVar5 << (diff & 0xff);\n  }\nLAB_080002e0:\n  if ((int)carry <= (int)low_bits) {\n    return CONCAT44(a_shifted + (low_bits - carry) * 0x100000 | high_bits_a,uVar5);\n  }\n  diff = ~(low_bits - carry);\n  if ((int)diff < 0x1f) {\n    shift_amount_a = diff - 0x13;\n    if (shift_amount_a != 0 && shift_amount_a < 0 == SCARRY4(diff - 0x1f,0xc)) {\n      return CONCAT44(high_bits,uVar5 >> (0x20 - (0xcU - shift_amount_a) & 0xff) | a_shifted << (0xcU - shift_amount_a & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    diff = diff + 1;\n    return CONCAT44(high_bits_a | a_shifted >> (diff & 0xff),\n                    uVar5 >> (diff & 0xff) | a_shifted << (0x20 - diff & 0xff));\n  }\n  return CONCAT44(high_bits,a_shifted >> (diff - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800015c",
            "calling": [
                "FUN_08005838",
                "FUN_08004bd8",
                "FUN_080079e8",
                "FUN_080059f0"
            ],
            "imported": false,
            "current_name": "calculate_double_precision_float_0800015c"
        },
        "FUN_080027f4": {
            "renaming": {
                "FUN_080027f4": "set_flag_and_check_pointer_080027f4",
                "param_1": "pointer",
                "param_2": "flag",
                "param_3": "value",
                "param_4": "value_size",
                "param_5": "max_pointer_diff",
                "param_6": "base_pointer",
                "iVar1": "result",
                "uVar2": "return_value"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nundefined4\nset_flag_and_check_pointer_080027f4(uint **pointer,byte flag,undefined2 value,short value_size,uint max_pointer_diff,int base_pointer)\n\n{\n  int result;\n  undefined4 return_value;\n  \n  **pointer = **pointer | 0x400;\n  **pointer = **pointer | 0x100;\n  do {\n    if ((~(*pointer)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_080028d2;\n    }\n  } while ((max_pointer_diff == 0xffffffff) ||\n          ((max_pointer_diff != 0 && (result = get_pointer_value_080015a0(), (uint)(result - base_pointer) <= max_pointer_diff))));\n  pointer[0xc] = (uint *)0x0;\n  *(undefined *)((int)pointer + 0x3d) = 0x20;\n  *(undefined *)((int)pointer + 0x3e) = 0;\n  *(undefined *)(pointer + 0xf) = 0;\n  result = 3;\nLAB_080028d2:\n  if (result == 0) {\n    (*pointer)[4] = flag & 0xfe;\n    result = check_and_set_flag_08002ad8(pointer,DAT_08002ad4,max_pointer_diff,base_pointer);\n    if (result == 0) {\n      result = check_pointer_value_08002bb4(pointer,max_pointer_diff,base_pointer,(*pointer)[6]);\n      if (result == 0) {\n        if (value_size == 1) {\n          (*pointer)[4] = (uint)(byte)value;\n        }\n        else {\n          (*pointer)[4] = (uint)(byte)((ushort)value >> 8);\n          result = check_pointer_value_08002bb4(pointer,max_pointer_diff,base_pointer);\n          if (result != 0) {\n            if (pointer[0x10] == (uint *)0x4) {\n              **pointer = **pointer | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*pointer)[4] = (uint)(byte)value;\n        }\n        result = check_pointer_value_08002bb4(pointer,max_pointer_diff,base_pointer);\n        if (result == 0) {\n          **pointer = **pointer | 0x100;\n          do {\n            if ((~(*pointer)[5] & 1) == 0) {\n              result = 0;\n              goto LAB_08002a90;\n            }\n          } while ((max_pointer_diff == 0xffffffff) ||\n                  ((max_pointer_diff != 0 && (result = get_pointer_value_080015a0(), (uint)(result - base_pointer) <= max_pointer_diff))));\n          pointer[0xc] = (uint *)0x0;\n          *(undefined *)((int)pointer + 0x3d) = 0x20;\n          *(undefined *)((int)pointer + 0x3e) = 0;\n          *(undefined *)(pointer + 0xf) = 0;\n          result = 3;\nLAB_08002a90:\n          if (result == 0) {\n            (*pointer)[4] = (uint)(flag | 1);\n            result = check_and_set_flag_08002ad8(pointer,DAT_08002ad4,max_pointer_diff,base_pointer);\n            if (result == 0) {\n              return_value = 0;\n            }\n            else if (pointer[0x10] == (uint *)0x4) {\n              return_value = 1;\n            }\n            else {\n              return_value = 3;\n            }\n          }\n          else {\n            return_value = 3;\n          }\n        }\n        else if (pointer[0x10] == (uint *)0x4) {\n          **pointer = **pointer | 0x200;\n          return_value = 1;\n        }\n        else {\n          return_value = 3;\n        }\n      }\n      else if (pointer[0x10] == (uint *)0x4) {\n        **pointer = **pointer | 0x200;\n        return_value = 1;\n      }\n      else {\n        return_value = 3;\n      }\n    }\n    else if (pointer[0x10] == (uint *)0x4) {\n      return_value = 1;\n    }\n    else {\n      return_value = 3;\n    }\n  }\n  else {\n    return_value = 3;\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_080015a0",
                "FUN_08002bb4",
                "FUN_08002ad8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080027f4",
            "calling": [
                "FUN_08001f6c"
            ],
            "imported": false,
            "current_name": "set_flag_and_check_pointer_080027f4"
        },
        "FUN_080003d4": {
            "renaming": {
                "FUN_080003d4": "reverse_and_concatenate_bits_080003d4",
                "param_1": "input_number",
                "uVar1": "upper_bits",
                "uVar2": "shift_amount",
                "iVar3": "leading_zero_count",
                "uVar4": "shift_amount_2",
                "in_r12": "temp_var",
                "bVar5": "is_negative_shift_amount",
                "bVar6": "is_zero_shift_amount",
                "bVar7": "is_negative_shift_amount_2"
            },
            "code": "\nulonglong reverse_and_concatenate_bits_080003d4(uint input_number)\n\n{\n  uint upper_bits;\n  uint shift_amount;\n  int leading_zero_count;\n  uint shift_amount_2;\n  uint temp_var;\n  bool is_negative_shift_amount;\n  bool is_zero_shift_amount;\n  bool is_negative_shift_amount_2;\n  \n  if (input_number == 0) {\n    return 0;\n  }\n  upper_bits = 0;\n  leading_zero_count = count_leading_zeroes(input_number);\n  shift_amount_2 = leading_zero_count + 0x15;\n  is_negative_shift_amount_2 = SBORROW4(shift_amount_2,0x20);\n  shift_amount = leading_zero_count - 0xb;\n  is_negative_shift_amount = (int)shift_amount < 0;\n  is_zero_shift_amount = shift_amount == 0;\n  if ((int)shift_amount_2 < 0x20) {\n    is_negative_shift_amount_2 = SCARRY4(shift_amount,0xc);\n    leading_zero_count = leading_zero_count + 1;\n    is_negative_shift_amount = leading_zero_count < 0;\n    is_zero_shift_amount = leading_zero_count == 0;\n    shift_amount = shift_amount_2;\n    if (!is_zero_shift_amount && is_negative_shift_amount == is_negative_shift_amount_2) {\n      upper_bits = input_number << (shift_amount_2 & 0xff);\n      input_number = input_number >> (0xcU - leading_zero_count & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_zero_shift_amount || is_negative_shift_amount != is_negative_shift_amount_2) {\n    temp_var = 0x20 - shift_amount;\n  }\n  input_number = input_number << (shift_amount & 0xff);\n  if (is_zero_shift_amount || is_negative_shift_amount != is_negative_shift_amount_2) {\n    input_number = input_number | 0U >> (temp_var & 0xff);\n  }\n  if (is_zero_shift_amount || is_negative_shift_amount != is_negative_shift_amount_2) {\n    upper_bits = 0 << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shift_amount_2 < 0x433) {\n    return CONCAT44(input_number + (0x432 - shift_amount_2) * 0x100000,upper_bits);\n  }\n  shift_amount = ~(0x432 - shift_amount_2);\n  if (0x1e < (int)shift_amount) {\n    return (ulonglong)(input_number >> (shift_amount - 0x1f & 0xff));\n  }\n  leading_zero_count = shift_amount - 0x13;\n  if (leading_zero_count == 0 || leading_zero_count < 0 != SCARRY4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(input_number >> (shift_amount & 0xff),\n                    upper_bits >> (shift_amount & 0xff) | input_number << (0x20 - shift_amount & 0xff));\n  }\n  return (ulonglong)(upper_bits >> (0x20 - (0xcU - leading_zero_count) & 0xff) | input_number << (0xcU - leading_zero_count & 0xff));\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080003d4",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "reverse_and_concatenate_bits_080003d4"
        },
        "FUN_08004d78": {
            "renaming": {
                "FUN_08004d78": "calculate_integer_from_floating_point_08004d78",
                "param_1": "floating_point_values",
                "param_2": "result_1",
                "param_3": "result_2",
                "uVar1": "converted_fp_val_1",
                "uVar2": "converted_fp_val_2",
                "uVar3": "converted_fp_val_3",
                "uVar4": "calculation_result",
                "uVar5": "decoded_val_2",
                "decode_unsigned_long_long_08000418": "decode_unsigned_long_long",
                "floating_point_arithmetic_08000e20": "convert_to_floating_point",
                "calculate_double_precision_floating_point_value_080004c8": "calculate_double_precision_floating_point_value",
                "floating_point_to_unsigned_integer_080009fc": "convert_to_unsigned_integer",
                "thunk_calculate_result_08005838": "calculate_result_with_two_values"
            },
            "code": "\nvoid calculate_integer_from_floating_point_08004d78(undefined4 *floating_point_values,undefined4 *result_1,undefined4 *result_2)\n\n{\n  undefined4 converted_fp_val_1;\n  undefined4 converted_fp_val_2;\n  undefined4 converted_fp_val_3;\n  undefined8 calculation_result;\n  undefined8 decoded_val_2;\n  \n  converted_fp_val_1 = floating_point_arithmetic_08000e20(*floating_point_values,0x45800000);\n  converted_fp_val_2 = floating_point_arithmetic_08000e20(floating_point_values[1],0x45800000);\n  converted_fp_val_3 = floating_point_arithmetic_08000e20(floating_point_values[2],0x45800000);\n  calculation_result = decode_unsigned_long_long_08000418(converted_fp_val_2);\n  decoded_val_2 = decode_unsigned_long_long_08000418(converted_fp_val_3);\n  calculation_result = calculate_result_with_two_values((int)calculation_result,(int)((ulonglong)calculation_result >> 0x20),(int)decoded_val_2,\n                             (int)((ulonglong)decoded_val_2 >> 0x20));\n  calculation_result = calculate_double_precision_floating_point_value_080004c8((int)calculation_result,(int)((ulonglong)calculation_result >> 0x20),0,DAT_08004e68);\n  calculation_result = FUNC_0800071c((int)calculation_result,(int)((ulonglong)calculation_result >> 0x20),DAT_08004e60,DAT_08004e64);\n  converted_fp_val_2 = floating_point_to_unsigned_integer_080009fc((int)calculation_result,(int)((ulonglong)calculation_result >> 0x20));\n  calculation_result = decode_unsigned_long_long_08000418(converted_fp_val_1);\n  decoded_val_2 = decode_unsigned_long_long_08000418(converted_fp_val_3);\n  calculation_result = calculate_result_with_two_values((int)calculation_result,(int)((ulonglong)calculation_result >> 0x20),(int)decoded_val_2,\n                             (int)((ulonglong)decoded_val_2 >> 0x20));\n  calculation_result = calculate_double_precision_floating_point_value_080004c8((int)calculation_result,(int)((ulonglong)calculation_result >> 0x20),0,DAT_08004e68);\n  calculation_result = FUNC_0800071c((int)calculation_result,(int)((ulonglong)calculation_result >> 0x20),DAT_08004e60,DAT_08004e64);\n  converted_fp_val_1 = floating_point_to_unsigned_integer_080009fc((int)calculation_result,(int)((ulonglong)calculation_result >> 0x20));\n  *result_1 = converted_fp_val_2;\n  *result_2 = converted_fp_val_1;\n  return;\n}\n\n",
            "called": [
                "FUN_080004c8",
                "FUN_080009fc",
                "FUN_08000e20",
                "FUN_0800071c",
                "FUN_08000418",
                "thunk_FUN_08005838"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d78",
            "calling": [
                "FUN_080049cc"
            ],
            "imported": false,
            "current_name": "calculate_integer_from_floating_point_08004d78"
        },
        "FUN_08000c10": {
            "renaming": {
                "FUN_08000c10": "calculate_hash_08000c10",
                "param_1": "input_number",
                "iVar1": "leading_zeroes_count",
                "uVar2": "shift_amount",
                "iVar4": "hash_base",
                "uVar3": "hash_result",
                "uVar5": "overflow_check",
                "count_leading_zeroes": "count_leading_zero_bits"
            },
            "code": "\nuint calculate_hash_08000c10(uint input_number)\n\n{\n  int leading_zeroes_count;\n  uint shift_amount;\n  uint hash_result;\n  int hash_base;\n  uint overflow_check;\n  \n  hash_result = input_number & 0x80000000;\n  if ((int)hash_result < 0) {\n    input_number = -input_number;\n  }\n  if (input_number == 0) {\n    return 0;\n  }\n  leading_zeroes_count = count_leading_zero_bits(input_number);\n  shift_amount = leading_zeroes_count - 8;\n  hash_base = ((hash_result | 0x4b000000) - 0x800000) + shift_amount * -0x800000;\n  if (7 < leading_zeroes_count) {\n    overflow_check = 0 << (shift_amount & 0xff);\n    hash_result = hash_base + (input_number << (shift_amount & 0xff)) +\n            (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < overflow_check);\n    if (overflow_check == 0x80000000) {\n      hash_result = hash_result & 0xfffffffe;\n    }\n    return hash_result;\n  }\n  shift_amount = input_number << (leading_zeroes_count + 0x18U & 0xff);\n  hash_result = hash_base + ((input_number >> (0x20 - (leading_zeroes_count + 0x18U) & 0xff)) - ((int)shift_amount >> 0x1f));\n  if ((shift_amount & 0x7fffffff) == 0) {\n    hash_result = hash_result & ~(shift_amount >> 0x1f);\n  }\n  return hash_result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c10",
            "calling": [
                "FUN_080049cc",
                "FUN_08004f78",
                "FUN_08004ae0"
            ],
            "imported": false,
            "current_name": "calculate_hash_08000c10"
        },
        "FUN_0800491c": {
            "renaming": {
                "FUN_0800491c": "initialize_data_and_calculate_statistics_0800491c",
                "param_1": "data_array",
                "local_13": "byte_zero",
                "local_12": "byte_sixteen",
                "local_11": "byte_array",
                "calculate_statistics_080049cc": "calculate_statistics"
            },
            "code": "\nvoid initialize_data_and_calculate_statistics_0800491c(undefined4 *data_array)\n\n{\n  undefined byte_zero;\n  undefined byte_sixteen;\n  undefined byte_array [5];\n  \n  byte_zero = 0;\n  (**(code **)PTR_DAT_080049c8)(0xd0,0x6b,&byte_zero,1);\n  byte_sixteen = 0x10;\n  (**(code **)PTR_DAT_080049c8)(0xd0,0x1c,&byte_sixteen,1);\n  byte_array[0] = 8;\n  (**(code **)PTR_DAT_080049c8)(0xd0,0x1b,byte_array,1);\n  *data_array = 0;\n  data_array[1] = 0;\n  data_array[2] = 0;\n  data_array[3] = 0;\n  data_array[4] = 0;\n  data_array[5] = 0;\n  data_array[6] = 0;\n  data_array[7] = 0;\n  data_array[8] = 0;\n  data_array[9] = 0;\n  data_array[10] = 0;\n  calculate_statistics(data_array);\n  return;\n}\n\n",
            "called": [
                "FUN_080049cc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800491c",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "initialize_data_and_calculate_statistics_0800491c"
        },
        "FUN_080078a0": {
            "renaming": {
                "FUN_080078a0": "check_data_and_update_080078a0",
                "update_data_080098c0": "update_data"
            },
            "code": "\nvoid check_data_and_update_080078a0(void)\n\n{\n  if (DAT_080078ac != 0) {\n    update_data_080098c0(0,PTR_LAB_08008818_1_080078b0,0);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_080098c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078a0",
            "calling": [
                "FUN_08005d20"
            ],
            "imported": false,
            "current_name": "check_data_and_update_080078a0"
        },
        "FUN_080057e8": {
            "renaming": {
                "FUN_080057e8": "initialize_device_and_set_flags_080057e8",
                "iVar1": "index",
                "puVar2": "pointer",
                "UNRECOVERED_JUMPTABLE": "jump_table"
            },
            "code": "\nvoid initialize_device_and_set_flags_080057e8(void)\n\n{\n  int index;\n  undefined4 *pointer;\n  code *jump_table;\n  \n  for (index = 0; pointer = (undefined4 *)PTR_DAT_08005828,\n      PTR_DAT_08005820 + index < PTR_DAT_08005824; index = index + 4) {\n    *(undefined4 *)(PTR_DAT_08005820 + index) = *(undefined4 *)(DAT_0800581c + index);\n  }\n  for (; pointer < PTR_DAT_0800582c; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  set_bit_and_clear_flags_08005780();\n  execute_functions_08005d20();\n  jump_table = (code *)0x800581a;\n  initialize_device_08005224();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jump_table)();\n  return;\n}\n\n",
            "called": [
                "FUN_08005d20",
                "FUN_08005224",
                "FUN_08005780"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080057e8",
            "calling": [],
            "imported": false,
            "current_name": "initialize_device_and_set_flags_080057e8"
        }
    },
    "used_tokens": 147062,
    "layers": [
        [
            "FUN_08003440",
            "FUN_08003568",
            "FUN_08003c94",
            "FUN_0800901c",
            "FUN_0800177c",
            "FUN_080008fc",
            "FUN_08005dfc",
            "FUN_080003f4",
            "FUN_0800166c",
            "FUN_0800360c",
            "FUN_08005d68",
            "FUN_080017c4",
            "FUN_080041ea",
            "FUN_08001044",
            "FUN_080015fc",
            "FUN_08000110",
            "FUN_08003504",
            "FUN_08000aa4",
            "FUN_080094f8",
            "FUN_08000aa8",
            "FUN_08001170",
            "FUN_08003f18",
            "FUN_08003d60",
            "FUN_08001618",
            "FUN_080091a4",
            "FUN_080015a0",
            "FUN_08005780",
            "FUN_08000134",
            "FUN_08000418",
            "FUN_0800416a",
            "FUN_0800088a",
            "FUN_0800157c",
            "FUN_08000e20",
            "FUN_0800121c",
            "FUN_08005d14",
            "FUN_080015b4",
            "FUN_080041a8",
            "FUN_08008ad4",
            "FUN_08005674",
            "FUN_08004104",
            "FUN_08005e40",
            "FUN_08005d20",
            "FUN_08001a80",
            "FUN_080090a8",
            "FUN_0800910c",
            "FUN_08001084",
            "FUN_08004e6c",
            "FUN_08000158",
            "FUN_08009768",
            "FUN_08003ff8",
            "FUN_080040a0",
            "FUN_08009a18",
            "FUN_0800119c",
            "FUN_080090b4",
            "FUN_0800422e",
            "FUN_08003e38",
            "FUN_080006a4",
            "FUN_08000f68",
            "FUN_08000c08",
            "FUN_080042de",
            "FUN_08002d3c",
            "FUN_080091e4",
            "FUN_080009fc",
            "FUN_08000cb8",
            "FUN_080098c0",
            "FUN_0800015c",
            "FUN_080003d4",
            "FUN_08000c10"
        ],
        [
            "FUN_0800071c",
            "FUN_080036a8",
            "FUN_08004f2c",
            "FUN_08002c2e",
            "FUN_080011ec",
            "FUN_08000988",
            "FUN_08001714",
            "FUN_080078c0",
            "FUN_080035a4",
            "FUN_08004ae0",
            "FUN_08004436",
            "FUN_08003908",
            "FUN_08004f60",
            "FUN_08002ad8",
            "FUN_08000fd0",
            "FUN_08003518",
            "FUN_08002d98",
            "FUN_0800172a",
            "FUN_08003640",
            "FUN_08002ca8",
            "FUN_08003a94",
            "FUN_080055f4",
            "FUN_080016d0",
            "FUN_080004c8",
            "FUN_08004e74",
            "FUN_08005680",
            "FUN_08003540",
            "FUN_08005728",
            "FUN_08002bb4",
            "FUN_080078a0"
        ],
        [
            "FUN_080046ec",
            "FUN_08005500",
            "FUN_08000978",
            "FUN_08004f3c",
            "FUN_08002640",
            "FUN_08000998",
            "FUN_080009ac",
            "FUN_08000fc8",
            "FUN_080009c0",
            "FUN_08009744",
            "FUN_080053b0",
            "FUN_08000ff4",
            "FUN_080096e0",
            "FUN_08001ab0",
            "FUN_08001762",
            "FUN_080027f4"
        ],
        [
            "FUN_08005348",
            "FUN_0800884c",
            "FUN_08001030",
            "FUN_0800438a",
            "FUN_08001f6c",
            "FUN_080009d4",
            "FUN_08001ccc",
            "FUN_080009e8",
            "FUN_0800151c"
        ],
        [
            "FUN_080088ec",
            "FUN_08005598",
            "FUN_08004ee8",
            "FUN_080014f0",
            "FUN_080059f0",
            "FUN_08003260",
            "FUN_08004ea4"
        ],
        [
            "thunk_FUN_08005838",
            "FUN_08005838",
            "FUN_080052a0",
            "FUN_08008af8"
        ],
        [
            "FUN_08009adc",
            "FUN_08009980",
            "FUN_08004bd8",
            "FUN_08004d78"
        ],
        [
            "FUN_080049cc",
            "FUN_080097cc",
            "FUN_08004f78",
            "FUN_080090c0"
        ],
        [
            "FUN_080017b4",
            "FUN_08009444",
            "FUN_080036f8",
            "FUN_08009630",
            "FUN_08009120",
            "FUN_08009244",
            "FUN_08009258",
            "FUN_08009530",
            "FUN_0800491c"
        ],
        [
            "FUN_08005224",
            "FUN_08005704",
            "FUN_08005714",
            "FUN_080093a4"
        ],
        [
            "FUN_080079e8",
            "FUN_080057e8"
        ]
    ],
    "locked_functions": []
}