{
    "functions": {
        "FUN_0800071c": {
            "renaming": {
                "FUN_0800071c": "calculate_double_0800071c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "uVar7": "temp7",
                "iVar8": "temp8",
                "uVar9": "temp9",
                "unaff_r5": "temp10",
                "uVar10": "temp11",
                "uVar11": "temp12",
                "uVar12": "temp13",
                "uVar13": "temp14",
                "bVar14": "flag1",
                "bVar15": "flag2",
                "bVar16": "flag3",
                "uVar17": "result"
            },
            "code": "\nulonglong calculate_double_0800071c(undefined4 input1,uint input2,uint input3,uint input4)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  int temp8;\n  uint temp9;\n  uint temp10;\n  uint temp11;\n  uint temp12;\n  uint temp13;\n  uint temp14;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  ulonglong result;\n  \n  result = CONCAT44(input2,input1);\n  temp14 = 0x7ff;\n  temp7 = input2 >> 0x14 & 0x7ff;\n  flag1 = temp7 == 0;\n  if (!flag1) {\n    temp10 = input4 >> 0x14 & 0x7ff;\n    flag1 = temp10 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp7 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp10 == 0x7ff;\n  }\n  if (flag1) {\n    result = binary_to_double_0800088a();\n  }\n  temp9 = (uint)(result >> 0x20);\n  temp12 = (uint)result;\n  temp8 = temp7 - temp10;\n  if ((input3 | input4 << 0xc) == 0) {\n    temp7 = (temp9 ^ input4) & 0x80000000 | temp9 & 0xfffff;\n    flag3 = SCARRY4(temp8,temp14 >> 1);\n    temp9 = temp8 + (temp14 >> 1);\n    flag1 = (int)temp9 < 0;\n    flag2 = temp9 == 0;\n    if (!flag2 && flag1 == flag3) {\n      flag3 = SBORROW4(temp14,temp9);\n      flag1 = (int)(temp14 - temp9) < 0;\n      flag2 = temp14 == temp9;\n    }\n    if (!flag2 && flag1 == flag3) {\n      temp7 = temp7 | temp9 * 0x100000;\n    }\n    if (!flag2 && flag1 == flag3) {\n      return result & 0xffffffff | (ulonglong)temp7 << 0x20;\n    }\n    temp7 = temp7 | 0x100000;\n    temp14 = 0;\n    flag2 = SBORROW4(temp9,1);\n    temp9 = temp9 - 1;\n    flag1 = temp9 == 0;\n    temp3 = temp9;\n  }\n  else {\n    temp3 = (input4 << 0xc) >> 4 | 0x10000000 | input3 >> 0x18;\n    temp14 = input3 << 8;\n    temp11 = (temp9 << 0xc) >> 4 | 0x10000000 | temp12 >> 0x18;\n    temp12 = temp12 * 0x100;\n    temp7 = (temp9 ^ input4) & 0x80000000;\n    flag1 = temp3 <= temp11;\n    if (temp11 == temp3) {\n      flag1 = temp14 <= temp12;\n    }\n    temp8 = temp8 + (uint)flag1;\n    temp9 = temp8 + 0x3fd;\n    if (flag1 == false) {\n      temp3 = temp3 >> 1;\n      temp14 = (uint)((input3 >> 0x18 & 1) != 0) << 0x1f | temp14 >> 1;\n    }\n    temp13 = temp12 - temp14;\n    temp11 = (temp11 - temp3) - (uint)(temp12 < temp14);\n    temp4 = temp3 >> 1;\n    temp1 = (uint)((temp3 & 1) != 0) << 0x1f | temp14 >> 1;\n    temp12 = 0x100000;\n    temp3 = 0x80000;\n    while( true ) {\n      flag1 = temp1 <= temp13;\n      if (temp4 < temp11 || temp11 - temp4 < (uint)flag1) {\n        temp13 = temp13 - temp1;\n        temp12 = temp12 | temp3;\n        temp11 = (temp11 - temp4) - (uint)!flag1;\n      }\n      temp5 = temp4 >> 1;\n      temp1 = (uint)((temp4 & 1) != 0) << 0x1f | temp1 >> 1;\n      flag2 = temp1 <= temp13;\n      flag1 = temp11 - temp5 < (uint)flag2;\n      temp14 = temp11;\n      if (temp5 < temp11 || flag1) {\n        temp13 = temp13 - temp1;\n        temp14 = (temp11 - temp5) - (uint)!flag2;\n      }\n      if (temp5 < temp11 || flag1) {\n        temp12 = temp12 | temp3 >> 1;\n      }\n      temp11 = temp4 >> 2;\n      temp2 = (uint)((temp5 & 1) != 0) << 0x1f | temp1 >> 1;\n      flag2 = temp2 <= temp13;\n      flag1 = temp14 - temp11 < (uint)flag2;\n      temp5 = temp14;\n      if (temp11 < temp14 || flag1) {\n        temp13 = temp13 - temp2;\n        temp5 = (temp14 - temp11) - (uint)!flag2;\n      }\n      if (temp11 < temp14 || flag1) {\n        temp12 = temp12 | temp3 >> 2;\n      }\n      temp6 = temp4 >> 3;\n      temp1 = (uint)((temp11 & 1) != 0) << 0x1f | temp2 >> 1;\n      flag2 = temp1 <= temp13;\n      flag1 = temp5 - temp6 < (uint)flag2;\n      temp11 = temp5;\n      if (temp6 < temp5 || flag1) {\n        temp13 = temp13 - temp1;\n        temp11 = (temp5 - temp6) - (uint)!flag2;\n      }\n      if (temp6 < temp5 || flag1) {\n        temp12 = temp12 | temp3 >> 3;\n      }\n      temp14 = temp11 | temp13;\n      if (temp14 == 0) break;\n      temp11 = temp11 << 4 | temp13 >> 0x1c;\n      temp13 = temp13 << 4;\n      temp4 = temp4 & 0xfffffff8 | temp1 >> 0x1d;\n      temp1 = (temp2 >> 1) << 3;\n      temp3 = temp3 >> 4;\n      if (temp3 == 0) {\n        temp6 = temp4;\n        if ((temp7 & 0x100000) != 0) goto LAB_0800083a;\n        temp7 = temp7 | temp12;\n        temp12 = 0;\n        temp3 = 0x80000000;\n      }\n    }\n    if ((temp7 & 0x100000) == 0) {\n      temp7 = temp7 | temp12;\n      temp12 = 0;\n    }\nLAB_0800083a:\n    flag3 = 0xfc < temp9;\n    flag2 = SBORROW4(temp9,0xfd);\n    temp4 = temp8 + 0x300;\n    flag1 = temp4 == 0;\n    temp3 = temp4;\n    if (flag3 && !flag1) {\n      flag3 = 0x6ff < temp4;\n      flag2 = SBORROW4(temp4,0x700);\n      temp3 = temp8 - 0x400;\n      flag1 = temp4 == 0x700;\n    }\n    if (!flag3 || flag1) {\n      flag1 = temp6 <= temp11;\n      if (temp11 == temp6) {\n        flag1 = temp1 <= temp13;\n      }\n      if (temp11 == temp6 && temp13 == temp1) {\n        flag1 = (temp12 & 1) != 0;\n      }\n      return CONCAT44(temp7 + temp9 * 0x100000 + (uint)CARRY4(temp12,(uint)flag1),temp12 + flag1);\n    }\n  }\n  if (!flag1 && (int)temp3 < 0 == flag2) {\n    return (ulonglong)(temp7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag3 = SCARRY4(temp9,0x36);\n  flag1 = (int)(temp9 + 0x36) < 0;\n  flag2 = temp9 == 0xffffffca;\n  if (flag2 || flag1 != flag3) {\n    temp12 = 0;\n  }\n  if (flag2 || flag1 != flag3) {\n    temp7 = temp7 & 0x80000000;\n  }\n  if (flag2 || flag1 != flag3) {\n    return CONCAT44(temp7,temp12);\n  }\n  temp3 = -temp9;\n  temp11 = temp3 - 0x20;\n  if (0x1f < (int)temp3) {\n    temp3 = temp12 >> (temp11 & 0xff) | temp7 << (0x20 - temp11 & 0xff);\n    temp9 = (temp7 >> (temp11 & 0xff) & ~((temp7 & 0x80000000) >> (temp11 & 0xff))) -\n            ((int)temp3 >> 0x1f);\n    if ((temp14 | temp12 << (0x20 - temp11 & 0xff) | temp3 << 1) == 0) {\n      temp9 = temp9 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44(temp7,temp9) & 0x80000000ffffffff;\n  }\n  temp8 = temp3 - 0x14;\n  if (temp8 != 0 && temp8 < 0 == SCARRY4(temp11,0xc)) {\n    temp9 = 0xc - temp8;\n    temp3 = temp12 << (temp9 & 0xff);\n    temp12 = temp12 >> (0x20 - temp9 & 0xff) | temp7 << (temp9 & 0xff);\n    temp9 = temp12 + -((int)temp3 >> 0x1f);\n    if ((temp14 | temp3 << 1) == 0) {\n      temp9 = temp9 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44((temp7 & 0x80000000) + (uint)CARRY4(temp12,-((int)temp3 >> 0x1f)),temp9);\n  }\n  temp11 = temp12 << (temp9 + 0x20 & 0xff);\n  temp12 = temp12 >> (temp3 & 0xff) | temp7 << (temp9 + 0x20 & 0xff);\n  temp9 = temp12 + -((int)temp11 >> 0x1f);\n  if ((temp14 | temp11 << 1) == 0) {\n    temp9 = temp9 & ~(temp11 >> 0x1f);\n  }\n  return CONCAT44((temp7 & 0x80000000) +\n                  ((temp7 & 0x7fffffff) >> (temp3 & 0xff)) +\n                  (uint)CARRY4(temp12,-((int)temp11 >> 0x1f)),temp9);\n}\n\n",
            "called": [
                "FUN_0800088a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800071c",
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch",
                "atan"
            ],
            "imported": false,
            "current_name": "calculate_double_0800071c"
        },
        "FUN_08003440": {
            "renaming": {
                "FUN_08003440": "calculate_sysclockfreq_08003440",
                "aPredivFactorTable": "prediv_factor_table",
                "aPLLMULFactorTable": "pllmul_factor_table",
                "pllmul": "pll_multiplier",
                "prediv": "predivisor",
                "tmpreg": "temporary_register",
                "sysclockfreq": "sysclock_frequency",
                "pllclk": "pll_frequency"
            },
            "code": "\nuint32_t calculate_sysclockfreq_08003440(void)\n\n{\n  uint uVar1;\n  uint8_t prediv_factor_table [2];\n  uint8_t pllmul_factor_table [16];\n  uint32_t pll_multiplier;\n  uint32_t predivisor;\n  uint32_t temporary_register;\n  uint32_t sysclock_frequency;\n  uint32_t pll_frequency;\n  \n  pllmul_factor_table._0_4_ = *(undefined4 *)PTR__etext_080034f0;\n  pllmul_factor_table._4_4_ = *(undefined4 *)(PTR__etext_080034f0 + 4);\n  pllmul_factor_table._8_4_ = *(undefined4 *)(PTR__etext_080034f0 + 8);\n  pllmul_factor_table._12_4_ = *(undefined4 *)(PTR__etext_080034f0 + 0xc);\n  prediv_factor_table = *(uint8_t (*) [2])PTR_DAT_080034f4;\n  uVar1 = *(uint *)(DAT_080034f8 + 4);\n  if ((uVar1 & 0xc) == 4) {\n    sysclock_frequency = DAT_080034fc;\n  }\n  else if ((uVar1 & 0xc) == 8) {\n    if ((uVar1 & 0x10000) == 0) {\n      pll_frequency = DAT_08003500 * (uint)pllmul_factor_table[uVar1 >> 0x12 & 0xf];\n    }\n    else {\n      pll_frequency = (DAT_080034fc * pllmul_factor_table[uVar1 >> 0x12 & 0xf]) /\n               (uint)prediv_factor_table[*(uint *)(DAT_080034f8 + 4) >> 0x11 & 1];\n    }\n    sysclock_frequency = pll_frequency;\n  }\n  else {\n    sysclock_frequency = DAT_080034fc;\n  }\n  return sysclock_frequency;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003440",
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "calculate_sysclockfreq_08003440"
        },
        "FUN_080035fa": {
            "renaming": {
                "FUN_080035fa": "FUNC_080035fa"
            },
            "code": "\nvoid FUNC_080035fa(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080035fa",
            "calling": [
                "HAL_TIM_Base_Init"
            ],
            "imported": false,
            "current_name": "FUNC_080035fa"
        },
        "FUN_08004f2c": {
            "renaming": {
                "FUN_08004f2c": "get_current_tick_08004f2c",
                "uVar1": "current_tick"
            },
            "code": "\nuint32_t get_current_tick_08004f2c(void)\n\n{\n  uint32_t current_tick;\n  \n  current_tick = HAL_GetTick();\n  return current_tick;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f2c",
            "calling": [],
            "imported": false,
            "current_name": "get_current_tick_08004f2c"
        },
        "FUN_080056bc": {
            "renaming": {
                "FUN_080056bc": "FUNC_080056bc"
            },
            "code": "\nvoid FUNC_080056bc(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080056bc",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_080056bc"
        },
        "FUN_080046ec": {
            "renaming": {
                "FUN_080046ec": "configure_uart_080046ec",
                "huart": "UART_handle",
                "HAL_RCC_GetPCLK2Freq()": "PCLK2_frequency",
                "HAL_RCC_GetPCLK1Freq()": "PCLK1_frequency",
                "uVar1": "UART_BRR_part1",
                "uVar2": "UART_BRR_part2",
                "uVar3": "UART_BRR_part3",
                "uVar4": "PCLK_frequency",
                "uVar5": "PCLK_frequency_2",
                "uVar6": "PCLK_frequency_3",
                "uVar7": "PCLK_frequency_4",
                "uVar8": "PCLK_frequency_5",
                "uVar9": "UART_baud_rate_2",
                "uVar10": "UART_baud_rate_3",
                "uVar11": "UART_baud_rate_4",
                "uVar12": "UART_baud_rate_5",
                "tmpreg": "temporary_register"
            },
            "code": "\nvoid configure_UART_080046ec(UART_HandleTypeDef *UART_handle)\n\n{\n  ulonglong UART_BRR_part1;\n  ulonglong UART_BRR_part2;\n  ulonglong UART_BRR_part3;\n  uint32_t PCLK_frequency;\n  uint32_t PCLK_frequency_2;\n  uint32_t PCLK_frequency_3;\n  uint32_t PCLK_frequency_4;\n  uint32_t PCLK_frequency_5;\n  uint32_t UART_baud_rate_2;\n  uint32_t UART_baud_rate_3;\n  uint32_t UART_baud_rate_4;\n  uint32_t UART_baud_rate_5;\n  uint32_t temporary_register;\n  \n  UART_handle->Instance->CR2 = (UART_handle->Init).StopBits | UART_handle->Instance->CR2 & 0xffffcfff;\n  UART_handle->Instance->CR1 =\n       UART_handle->Instance->CR1 & 0xffffe9f3 |\n       (UART_handle->Init).Mode | (UART_handle->Init).WordLength | (UART_handle->Init).Parity;\n  UART_handle->Instance->CR3 = (UART_handle->Init).HwFlowCtl | UART_handle->Instance->CR3 & 0xfffffcff;\n  if (UART_handle->Instance == DAT_08004914) {\n    PCLK_frequency = PCLK2_frequency;\n    UART_baud_rate_2 = (UART_handle->Init).BaudRate;\n    UART_BRR_part1 = (ulonglong)DAT_08004918;\n    PCLK_frequency_2 = PCLK2_frequency;\n    UART_baud_rate_3 = (UART_handle->Init).BaudRate;\n    PCLK_frequency_3 = PCLK2_frequency;\n    UART_baud_rate_4 = (UART_handle->Init).BaudRate;\n    UART_BRR_part2 = (ulonglong)DAT_08004918;\n    UART_BRR_part3 = (ulonglong)DAT_08004918;\n    PCLK_frequency_4 = PCLK2_frequency;\n    UART_baud_rate_5 = (UART_handle->Init).BaudRate;\n    PCLK_frequency_5 = PCLK2_frequency;\n    UART_handle->Instance->BRR =\n         ((uint)((ulonglong)DAT_08004918 *\n                 (ulonglong)\n                 (((PCLK_frequency_4 * 0x19) / (UART_baud_rate_5 << 2) +\n                  (uint)((ulonglong)DAT_08004918 *\n                         ((ulonglong)(PCLK_frequency_5 * 0x19) / (ulonglong)((UART_handle->Init).BaudRate << 2)) >>\n                        0x25) * -100) * 0x10 + 0x32) >> 0x25) & 0xf) +\n         (uint)(UART_BRR_part1 * ((ulonglong)(PCLK_frequency * 0x19) / (ulonglong)(UART_baud_rate_2 << 2)) >> 0x25) * 0x10 +\n         ((uint)(UART_BRR_part3 * (((PCLK_frequency_2 * 0x19) / (UART_baud_rate_3 << 2) +\n                          (uint)(UART_BRR_part2 * ((ulonglong)(PCLK_frequency_3 * 0x19) / (ulonglong)(UART_baud_rate_4 << 2)) >>\n                                0x25) * -100) * 0x10 + 0x32) >> 0x25) & 0xf0);\n  }\n  else {\n    PCLK_frequency = PCLK1_frequency;\n    UART_baud_rate_2 = (UART_handle->Init).BaudRate;\n    UART_BRR_part1 = (ulonglong)DAT_08004918;\n    PCLK_frequency_2 = PCLK1_frequency;\n    UART_baud_rate_3 = (UART_handle->Init).BaudRate;\n    PCLK_frequency_3 = PCLK1_frequency;\n    UART_baud_rate_4 = (UART_handle->Init).BaudRate;\n    UART_BRR_part2 = (ulonglong)DAT_08004918;\n    UART_BRR_part3 = (ulonglong)DAT_08004918;\n    PCLK_frequency_4 = PCLK1_frequency;\n    UART_baud_rate_5 = (UART_handle->Init).BaudRate;\n    PCLK_frequency_5 = PCLK1_frequency;\n    UART_handle->Instance->BRR =\n         ((uint)((ulonglong)DAT_08004918 *\n                 (ulonglong)\n                 (((PCLK_frequency_4 * 0x19) / (UART_baud_rate_5 << 2) +\n                  (uint)((ulonglong)DAT_08004918 *\n                         ((ulonglong)(PCLK_frequency_5 * 0x19) / (ulonglong)((UART_handle->Init).BaudRate << 2)) >>\n                        0x25) * -100) * 0x10 + 0x32) >> 0x25) & 0xf) +\n         (uint)(UART_BRR_part1 * ((ulonglong)(PCLK_frequency * 0x19) / (ulonglong)(UART_baud_rate_2 << 2)) >> 0x25) * 0x10 +\n         ((uint)(UART_BRR_part3 * (((PCLK_frequency_2 * 0x19) / (UART_baud_rate_3 << 2) +\n                          (uint)(UART_BRR_part2 * ((ulonglong)(PCLK_frequency_3 * 0x19) / (ulonglong)(UART_baud_rate_4 << 2)) >>\n                                0x25) * -100) * 0x10 + 0x32) >> 0x25) & 0xf0);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080046ec",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "configure_uart_080046ec"
        },
        "FUN_08005500": {
            "renaming": {
                "FUN_08005500": "initialize_timer_08005500",
                "HVar1": "status",
                "sMasterConfig": "master_config",
                "sClockSourceConfig": "clock_config"
            },
            "code": "\nvoid initialize_timer_08005500(void)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_MasterConfigTypeDef master_config;\n  TIM_ClockConfigTypeDef clock_config;\n  \n  *(undefined4 *)PTR_htim2_08005590 = 0x40000000;\n  *(undefined4 *)(PTR_htim2_08005590 + 4) = 36000;\n  *(undefined4 *)(PTR_htim2_08005590 + 8) = 0;\n  *(undefined4 *)(PTR_htim2_08005590 + 0xc) = 0x14;\n  *(undefined4 *)(PTR_htim2_08005590 + 0x10) = 0;\n  *(undefined4 *)(PTR_htim2_08005590 + 0x18) = 0;\n  status = HAL_TIM_Base_Init((TIM_HandleTypeDef *)PTR_htim2_08005590);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s____src_main_c_08005594,0x1d0);\n  }\n  clock_config.ClockSource = 0x1000;\n  status = HAL_TIM_ConfigClockSource((TIM_HandleTypeDef *)PTR_htim2_08005590,&clock_config);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s____src_main_c_08005594,0x1d5);\n  }\n  master_config.MasterOutputTrigger = 0x20;\n  master_config.MasterSlaveMode = 0;\n  status = HAL_TIMEx_MasterConfigSynchronization\n                    ((TIM_HandleTypeDef *)PTR_htim2_08005590,&master_config);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s____src_main_c_08005594,0x1dc);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_TIM_ConfigClockSource",
                "_Error_Handler",
                "HAL_TIMEx_MasterConfigSynchronization",
                "HAL_TIM_Base_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005500",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_timer_08005500"
        },
        "FUN_08003568": {
            "renaming": {
                "FUN_08003568": "delay_in_milliseconds_08003568",
                "mdelay": "milliseconds",
                "Delay": "delay_cycles",
                "bVar1": "delay_completed"
            },
            "code": "\nvoid delay_in_milliseconds_08003568(uint32_t milliseconds)\n\n{\n  bool delay_completed;\n  uint32_t delay_cycles;\n  \n  delay_cycles = milliseconds * (uint)((ulonglong)DAT_080035a0 * (ulonglong)*(uint *)PTR_SystemCoreClock_0800359c\n                         >> 0x29);\n  do {\n    delay_completed = delay_cycles != 0;\n    delay_cycles = delay_cycles - 1;\n  } while (delay_completed);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003568",
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "imported": false,
            "current_name": "delay_in_milliseconds_08003568"
        },
        "FUN_08002c2e": {
            "renaming": {
                "FUN_08002c2e": "wait_for_i2_c_acknowledge_08002c2e",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "halStatus",
                "uVar2": "tickCount"
            },
            "code": "\nHAL_StatusTypeDef\nwaitForI2CAcknowledge_08002c2e(I2C_HandleTypeDef *i2cHandle,uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef halStatus;\n  uint32_t tickCount;\n  \n  while( true ) {\n    if ((i2cHandle->Instance->SR1 & 4) == 4) {\n      return HAL_OK;\n    }\n    halStatus = I2C_IsAcknowledgeFailed(i2cHandle);\n    if (halStatus != HAL_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (tickCount = HAL_GetTick(), timeout < tickCount - tickStart)))) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "called": [
                "I2C_IsAcknowledgeFailed",
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c2e",
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "imported": false,
            "current_name": "wait_for_i2_c_acknowledge_08002c2e"
        },
        "FUN_080008ec": {
            "renaming": {
                "FUN_080008ec": "compare_and_set_080008ec",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "is_zero",
                "bVar3": "is_less_than"
            },
            "code": "\nuint compare_and_set_080008ec(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool is_zero;\n  bool is_less_than;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  is_zero = (value1 | value2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (value3 | value4 << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = value2 == value4;\n  }\n  if (is_zero) {\n    is_zero = value1 == value3;\n  }\n  if (!is_zero) {\n    result = value2 ^ value4;\n    is_zero = result == 0;\n    if (-1 < (int)result) {\n      is_zero = value2 == value4;\n    }\n    is_less_than = -1 < (int)result && value4 <= value2;\n    if (is_zero) {\n      is_less_than = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!is_less_than) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080008ec",
            "calling": [],
            "imported": false,
            "current_name": "compare_and_set_080008ec"
        },
        "FUN_08000978": {
            "renaming": {
                "FUN_08000978": "compare_double_values_08000978",
                "param_1": "value_1_ptr",
                "param_2": "value_2_ptr",
                "param_3": "double_value_1_ptr",
                "param_4": "double_value_2_ptr"
            },
            "code": "\nvoid compare_double_values_08000978(undefined4 value_1_ptr,undefined4 value_2_ptr,undefined4 double_value_1_ptr,undefined4 double_value_2_ptr)\n\n{\n  __aeabi_cdcmpeq(double_value_1_ptr,double_value_2_ptr,value_1_ptr,value_2_ptr);\n  return;\n}\n\n",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000978",
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "imported": false,
            "current_name": "compare_double_values_08000978"
        },
        "FUN_0800101c": {
            "renaming": {
                "FUN_0800101c": "compare_floats_0800101c",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_set",
                "__aeabi_cfrcmple": "compare_floats_using_cfrcmple"
            },
            "code": "\nbool compare_floats_0800101c(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_set;\n  \n  compare_floats_0800101c_using_cfrcmple();\n  return !(bool)is_carry_set || (bool)is_zero_result;\n}\n\n",
            "called": [
                "__aeabi_cfrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800101c",
            "calling": [],
            "imported": false,
            "current_name": "compare_floats_0800101c"
        },
        "FUN_080056d4": {
            "renaming": {
                "FUN_080056d4": "infinite_loop_080056d4"
            },
            "code": "\nvoid infinite_loop_080056d4(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080056d4",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_080056d4"
        },
        "FUN_080078b4": {
            "renaming": {
                "FUN_080078b4": "register_exit_proc_080078b4",
                "__func": "exit_function",
                "iVar1": "exit_proc_register_result"
            },
            "code": "\nint register_exit_proc_080078b4(exit_function *exit_function)\n\n{\n  int exit_proc_register_result;\n  \n  exit_proc_register_result = __register_exitproc(0,exit_function,0);\n  return exit_proc_register_result;\n}\n\n",
            "called": [
                "__register_exitproc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078b4",
            "calling": [
                "register_fini"
            ],
            "imported": false,
            "current_name": "register_exit_proc_080078b4"
        },
        "FUN_080017b4": {
            "renaming": {
                "FUN_080017b4": "update_timer_period_080017b4",
                "TIM_HandleTypeDef": "timer_handler",
                "HAL_TIM_PeriodElapsedCallback": "handle_period_elapsed_callback"
            },
            "code": "\nvoid update_timer_period_080017b4(void)\n\n{\n  handle_period_elapsed_callback((timer_handler *)0x0);\n  return;\n}\n\n",
            "called": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080017b4",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "update_timer_period_080017b4"
        },
        "FUN_08001030": {
            "renaming": {
                "FUN_08001030": "check_null_termination_08001030",
                "in_CY": "input_char"
            },
            "code": "\nbool check_null_termination_08001030(void)\n\n{\n  char input_char;\n  \n  __aeabi_cfrcmple();\n  return input_char == '\\0';\n}\n\n",
            "called": [
                "__aeabi_cfrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001030",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "imported": false,
            "current_name": "check_null_termination_08001030"
        },
        "FUN_080011ec": {
            "renaming": {
                "FUN_080011ec": "handle_division_080011ec",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "__aeabi_idiv0": "handle_divide_by_zero",
                "__udivmoddi4": "handle_unsigned_division"
            },
            "code": "\nvoid handle_division_080011ec(int dividend,int divisor,int quotient,int remainder)\n\n{\n  if ((remainder == 0) && (quotient == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      divisor = -1;\n      dividend = -1;\n    }\n    handle_divide_by_zero(dividend,divisor);\n    return;\n  }\n  handle_unsigned_division();\n  return;\n}\n\n",
            "called": [
                "__udivmoddi4",
                "__aeabi_idiv0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080011ec",
            "calling": [
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "handle_division_080011ec"
        },
        "FUN_080056ce": {
            "renaming": {
                "FUN_080056ce": "infinite_loop_080056ce"
            },
            "code": "\nvoid infinite_loop_080056ce(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080056ce",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_080056ce"
        },
        "FUN_08004424": {
            "renaming": {
                "FUN_08004424": "FUNC_08004424"
            },
            "code": "\nvoid FUNC_08004424(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08004424",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "FUNC_08004424"
        },
        "FUN_08004f3c": {
            "renaming": {
                "FUN_08004f3c": "transmit_uart_data_08004f3c",
                "str": "data_to_transmit",
                "len": "data_length",
                "HAL_UART_Transmit": "send_data_via_uart"
            },
            "code": "\nvoid transmit_uart_data_08004f3c(char *data_to_transmit,uint32_t data_length)\n\n{\n  send_data_via_uart((UART_HandleTypeDef *)PTR_huart1_08004f5c,(uint8_t *)data_to_transmit,(uint16_t)data_length,0x32);\n  return;\n}\n\n",
            "called": [
                "HAL_UART_Transmit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f3c",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "imported": false,
            "current_name": "transmit_uart_data_08004f3c"
        },
        "FUN_08003696": {
            "renaming": {
                "FUN_08003696": "FUNC_08003696"
            },
            "code": "\nvoid FUNC_08003696(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003696",
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "imported": false,
            "current_name": "FUNC_08003696"
        },
        "FUN_080008fc": {
            "renaming": {
                "FUN_080008fc": "compare_and_set_080008fc",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "xor_result",
                "bVar2": "is_zero",
                "bVar3": "is_negative"
            },
            "code": "\nuint compare_and_set_080008fc(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint xor_result;\n  bool is_zero;\n  bool is_negative;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  is_zero = (value1 | value2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (value3 | value4 << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = value2 == value4;\n  }\n  if (is_zero) {\n    is_zero = value1 == value3;\n  }\n  if (!is_zero) {\n    xor_result = value2 ^ value4;\n    is_zero = xor_result == 0;\n    if (-1 < (int)xor_result) {\n      is_zero = value2 == value4;\n    }\n    is_negative = -1 < (int)xor_result && value4 <= value2;\n    if (is_zero) {\n      is_negative = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!is_negative) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080008fc",
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "imported": false,
            "current_name": "compare_and_set_080008fc"
        },
        "FUN_08001714": {
            "renaming": {
                "FUN_08001714": "set_nvic_priority_grouping_08001714",
                "PriorityGroup": "priority_group"
            },
            "code": "\nvoid set_NVIC_priority_grouping_08001714(uint32_t priority_group)\n\n{\n  NVIC_Setpriority_grouping(priority_group);\n  return;\n}\n\n",
            "called": [
                "NVIC_SetPriorityGrouping"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001714",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "set_nvic_priority_grouping_08001714"
        },
        "FUN_08000988": {
            "renaming": {
                "FUN_08000988": "convert_double_to_float_08000988",
                "param_1": "input_float",
                "__nedf2": "double_to_float_conversion",
                "return": "output_float"
            },
            "code": "\nundefined4 convert_double_to_float_08000988(undefined4 input_float)\n\n{\n  double_to_float_conversion();\n  output_float input_float;\n}\n\n",
            "called": [
                "__nedf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000988",
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_dcmple",
                "__aeabi_cdrcmple",
                "__aeabi_dcmplt"
            ],
            "imported": false,
            "current_name": "convert_double_to_float_08000988"
        },
        "FUN_080078c0": {
            "renaming": {
                "FUN_080078c0": "calculate_quotient_080078c0",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar1": "carry_over",
                "puVar2": "dividend_ptr",
                "iVar3": "temp",
                "iVar4": "divisor_length",
                "iVar5": "dividend_length",
                "uVar6": "quotient",
                "puVar7": "divisor_ptr",
                "puVar8": "quotient_ptr",
                "puVar9": "last_divisor_ptr",
                "uVar10": "temp_carry_over",
                "puVar11": "current_divisor_ptr",
                "puVar12": "next_divisor_ptr"
            },
            "code": "\nuint calculate_quotient_080078c0(int dividend,int divisor)\n\n{\n  uint carry_over;\n  uint *dividend_ptr;\n  int temp;\n  int divisor_length;\n  int dividend_length;\n  uint quotient;\n  uint *divisor_ptr;\n  uint *quotient_ptr;\n  uint *last_divisor_ptr;\n  uint temp_carry_over;\n  uint *current_divisor_ptr;\n  uint *next_divisor_ptr;\n  \n  divisor_length = *(int *)(divisor + 0x10);\n  if (*(int *)(dividend + 0x10) < divisor_length) {\n    return 0;\n  }\n  dividend_length = divisor_length + -1;\n  divisor_ptr = (uint *)(divisor + 0x14);\n  quotient_ptr = (uint *)(dividend + 0x14);\n  quotient = quotient_ptr[dividend_length] / (divisor_ptr[dividend_length] + 1);\n  last_divisor_ptr = divisor_ptr + dividend_length;\n  if (quotient != 0) {\n    carry_over = 0;\n    temp = 0;\n    dividend_ptr = quotient_ptr;\n    current_divisor_ptr = divisor_ptr;\n    do {\n      next_divisor_ptr = current_divisor_ptr + 1;\n      carry_over = quotient * (*current_divisor_ptr & 0xffff) + carry_over;\n      temp_carry_over = quotient * (*current_divisor_ptr >> 0x10) + (carry_over >> 0x10);\n      carry_over = (temp - (carry_over & 0xffff)) + (*dividend_ptr & 0xffff);\n      temp = ((*dividend_ptr >> 0x10) - (temp_carry_over & 0xffff)) + ((int)carry_over >> 0x10);\n      *dividend_ptr = carry_over & 0xffff | temp * 0x10000;\n      temp = temp >> 0x10;\n      carry_over = temp_carry_over >> 0x10;\n      dividend_ptr = dividend_ptr + 1;\n      current_divisor_ptr = next_divisor_ptr;\n    } while (next_divisor_ptr <= last_divisor_ptr);\n    if (quotient_ptr[dividend_length] == 0) {\n      if ((quotient_ptr < quotient_ptr + divisor_length + -2) && (quotient_ptr[divisor_length + -2] == 0)) {\n        dividend_ptr = quotient_ptr + divisor_length + -3;\n        do {\n          dividend_length = dividend_length + -1;\n          if (dividend_ptr <= quotient_ptr) break;\n          carry_over = *dividend_ptr;\n          dividend_ptr = dividend_ptr + -1;\n        } while (carry_over == 0);\n      }\n      *(int *)(dividend + 0x10) = dividend_length;\n    }\n  }\n  divisor_length = __mcmp();\n  if (-1 < divisor_length) {\n    divisor_length = 0;\n    quotient = quotient + 1;\n    dividend_ptr = quotient_ptr;\n    do {\n      current_divisor_ptr = divisor_ptr + 1;\n      carry_over = (divisor_length - (*divisor_ptr & 0xffff)) + (*dividend_ptr & 0xffff);\n      divisor_length = ((*dividend_ptr >> 0x10) - (*divisor_ptr >> 0x10)) + ((int)carry_over >> 0x10);\n      *dividend_ptr = carry_over & 0xffff | divisor_length * 0x10000;\n      divisor_length = divisor_length >> 0x10;\n      dividend_ptr = dividend_ptr + 1;\n      divisor_ptr = current_divisor_ptr;\n    } while (current_divisor_ptr <= last_divisor_ptr);\n    if (quotient_ptr[dividend_length] == 0) {\n      if ((quotient_ptr < quotient_ptr + dividend_length + -1) && (quotient_ptr[dividend_length + -1] == 0)) {\n        divisor_ptr = quotient_ptr + dividend_length + -2;\n        do {\n          dividend_length = dividend_length + -1;\n          if (divisor_ptr <= quotient_ptr) break;\n          carry_over = *divisor_ptr;\n          divisor_ptr = divisor_ptr + -1;\n        } while (carry_over == 0);\n      }\n      *(int *)(dividend + 0x10) = dividend_length;\n    }\n  }\n  return quotient;\n}\n\n",
            "called": [
                "__mcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078c0",
            "calling": [
                "_dtoa_r"
            ],
            "imported": false,
            "current_name": "calculate_quotient_080078c0"
        },
        "FUN_080056e0": {
            "renaming": {
                "FUN_080056e0": "FUNC_080056e0"
            },
            "code": "\nvoid FUNC_080056e0(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080056e0",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_080056e0"
        },
        "FUN_080079e8": {
            "renaming": {
                "FUN_080079e8": "convert_float_to_string_080079e8",
                "param_1": "value",
                "param_2": "param2",
                "param_3": "integerPart",
                "param_4": "fractionalPart",
                "param_5": "precision",
                "param_6": "roundingMode",
                "param_7": "length",
                "param_8": "isNegative",
                "param_9": "outputString",
                "cVar1": "digitChar",
                "bVar2": "comparisonResult",
                "uVar3": "quotient",
                "uVar4": "remainder",
                "uVar5": "tempValue",
                "uVar6": "tempIntegerPart",
                "uVar7": "tempFractionalPart",
                "uVar8": "temp",
                "iVar9": "digit",
                "iVar10": "shift",
                "iVar13": "exponent",
                "iVar19": "tempLength",
                "bVar20": "isNegativeFractionalPart",
                "uVar21": "tempFloat",
                "uVar22": "tempFloat2",
                "uVar23": "tempFloat3",
                "local_80": "integerPartFloat",
                "local_7c": "fractionalPartFloat",
                "local_74": "exponentDiff",
                "local_70": "shiftAmount",
                "local_68": "roundingPrecision",
                "local_64": "isZero",
                "local_60": "isOne",
                "local_5c": "exponentOffset",
                "local_58": "leadingZeros",
                "local_54": "isSmaller",
                "local_48": "tempFloat4",
                "uStack_44": "tempFloat5",
                "local_38": "maxDigits",
                "local_34": "tempFloat6",
                "local_30": "tempLength2",
                "local_2c": "tempArray"
            },
            "code": "\nchar * convertFloatToString_080079e8(int value,undefined4 param2,uint integerPart,uint fractionalPart,uint precision,uint roundingMode,\n              int *length,uint *isNegative,char **outputString)\n\n{\n  char digitChar;\n  byte comparisonResult;\n  undefined4 quotient;\n  uint remainder;\n  uint tempValue;\n  uint tempIntegerPart;\n  undefined4 tempFractionalPart;\n  undefined4 temp;\n  int digit;\n  int shift;\n  undefined4 uVar11;\n  uint uVar12;\n  int exponent;\n  char *pdigitChar4;\n  char *pdigitChar5;\n  undefined4 *puVar16;\n  undefined4 uVar17;\n  char *pdigitChar8;\n  int tempLength;\n  bool isNegativeFractionalPart;\n  undefined8 tempFloat;\n  undefined8 tempFloat2;\n  undefined8 tempFloat3;\n  uint integerPartFloat;\n  uint fractionalPartFloat;\n  uint exponentDiff;\n  int shiftAmount;\n  uint roundingPrecision;\n  uint isZero;\n  int isOne;\n  int exponentOffset;\n  uint leadingZeros;\n  int isSmaller;\n  uint tempFloat4;\n  uint tempFloat5;\n  uint maxDigits;\n  uint tempFloat6;\n  int tempLength2;\n  int tempArray [2];\n  \n  digit = *(int *)(value + 0x40);\n  if (digit != 0) {\n    uVar12 = *(uint *)(value + 0x44);\n    *(uint *)(digit + 4) = uVar12;\n    *(int *)(digit + 8) = 1 << (uVar12 & 0xff);\n    _Bfree(value,digit);\n    *(undefined4 *)(value + 0x40) = 0;\n  }\n  isNegativeFractionalPart = (int)fractionalPart < 0;\n  uVar12 = fractionalPart;\n  if (isNegativeFractionalPart) {\n    uVar12 = fractionalPart & 0x7fffffff;\n  }\n  *isNegative = (uint)isNegativeFractionalPart;\n  fractionalPartFloat = fractionalPart;\n  if (isNegativeFractionalPart) {\n    fractionalPartFloat = uVar12;\n  }\n  remainder = fractionalPartFloat;\n  if ((DAT_08007bf8 & ~uVar12) == 0) {\n    *length = 9999;\n    if ((integerPart == 0) && ((uVar12 & 0xfffff) == 0)) {\n      if (outputString == (char **)0x0) {\n        return PTR_s_Infinity_08007c08;\n      }\n      pdigitChar5 = PTR_s_Infinity_08007c08 + 8;\n      pdigitChar8 = PTR_s_Infinity_08007c08;\n    }\n    else {\n      if (outputString == (char **)0x0) {\n        return PTR_DAT_08007c0c;\n      }\n      pdigitChar5 = PTR_DAT_08007c0c + 3;\n      pdigitChar8 = PTR_DAT_08007c0c;\n    }\n    *outputString = pdigitChar5;\n    return pdigitChar8;\n  }\n  tempFloat = __aeabi_dcmpeq(integerPart,fractionalPartFloat,0,0);\n  isOne = (int)tempFloat;\n  if (isOne != 0) {\n    *length = 1;\n    if (outputString != (char **)0x0) {\n      pdigitChar8 = PTR_DAT_08007bfc + -1;\n      *outputString = PTR_DAT_08007bfc;\n      return pdigitChar8;\n    }\n    return PTR_DAT_08007c10;\n  }\n  quotient = __d2b(value,(int)((ulonglong)tempFloat >> 0x20),integerPart,fractionalPartFloat,tempArray,&tempLength2);\n  digit = tempLength2;\n  if (uVar12 >> 0x14 == 0) {\n    exponent = tempArray[0] + tempLength2;\n    shift = exponent + 0x432;\n    if (shift < 0x21) {\n      uVar12 = integerPart << (0x20U - shift & 0xff);\n    }\n    else {\n      uVar12 = integerPart >> (exponent + 0x412U & 0xff) | uVar12 << (0x40U - shift & 0xff);\n    }\n    tempFloat = __floatunsidf(uVar12);\n    exponent = exponent + -1;\n    isOne = 1;\n    tempValue = (int)((ulonglong)tempFloat >> 0x20) + 0xfe100000;\n    uVar12 = (uint)tempFloat;\n  }\n  else {\n    exponent = (uVar12 >> 0x14) - 0x3ff;\n    tempValue = fractionalPartFloat & 0xfffff | 0x3ff00000;\n    uVar12 = integerPart;\n  }\n  tempFloat = __subdf3(uVar12,tempValue,0,DAT_08007c00);\n  tempFloat = __muldf3((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),DAT_08007be0,DAT_08007be4);\n  tempFloat = __aeabi_dadd((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),DAT_08007be8,DAT_08007bec);\n  tempFloat2 = __aeabi_i2d(exponent);\n  tempFloat2 = __muldf3((int)tempFloat2,(int)((ulonglong)tempFloat2 >> 0x20),DAT_08007bf0,DAT_08007bf4);\n  tempFloat = __aeabi_dadd((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),(int)tempFloat2,\n                        (int)((ulonglong)tempFloat2 >> 0x20));\n  temp = (undefined4)((ulonglong)tempFloat >> 0x20);\n  exponentDiff = __aeabi_d2iz();\n  shift = __aeabi_dcmplt((int)tempFloat,temp,0,0);\n  if (shift != 0) {\n    tempFloat2 = __aeabi_i2d(exponentDiff);\n    shift = __aeabi_dcmpeq((int)tempFloat2,(int)((ulonglong)tempFloat2 >> 0x20),(int)tempFloat,temp);\n    if (shift == 0) {\n      exponentDiff = exponentDiff - 1;\n    }\n  }\n  if (exponentDiff < 0x17) {\n    isSmaller = __aeabi_dcmpgt(*(undefined4 *)(PTR___mprec_tens_08007c04 + exponentDiff * 8),\n                              *(undefined4 *)((int)(PTR___mprec_tens_08007c04 + exponentDiff * 8) + 4),\n                              integerPart,fractionalPartFloat);\n    if (isSmaller != 0) {\n      exponentDiff = exponentDiff - 1;\n      isSmaller = 0;\n    }\n  }\n  else {\n    isSmaller = 1;\n  }\n  shift = (digit - exponent) + -1;\n  if (shift < 0) {\n    shiftAmount = 1 - (digit - exponent);\n    shift = 0;\n  }\n  else {\n    shiftAmount = 0;\n  }\n  if ((int)exponentDiff < 0) {\n    leadingZeros = 0;\n    shiftAmount = shiftAmount - exponentDiff;\n    exponentOffset = -exponentDiff;\n  }\n  else {\n    shift = shift + exponentDiff;\n    leadingZeros = exponentDiff;\n    exponentOffset = 0;\n  }\n  if (9 < precision) {\n    maxDigits = 0xffffffff;\n    isNegativeFractionalPart = true;\n    roundingPrecision = 0xffffffff;\n    isZero = 1;\n    precision = 0;\n    roundingMode = 0;\n    goto LAB_08007c24;\n  }\n  isNegativeFractionalPart = (int)precision < 6;\n  if (!isNegativeFractionalPart) {\n    precision = precision - 4;\n  }\n  switch(precision) {\n  case 2:\n    isZero = 0;\n    break;\n  case 3:\n    isZero = 0;\n    goto LAB_08008300;\n  case 4:\n    isZero = 1;\n    break;\n  case 5:\n    isZero = 1;\nLAB_08008300:\n    maxDigits = exponentDiff + roundingMode;\n    roundingPrecision = maxDigits + 1;\n    uVar12 = roundingPrecision;\n    if ((int)roundingPrecision < 1) {\n      uVar12 = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(value + 0x44) = 0;\n    pdigitChar8 = (char *)_Balloc(value,0);\n    maxDigits = 0xffffffff;\n    roundingPrecision = 0xffffffff;\n    roundingMode = 0;\n    *(char **)(value + 0x40) = pdigitChar8;\n    isZero = 1;\n    goto LAB_08007e36;\n  }\n  if ((int)roundingMode < 1) {\n    maxDigits = 1;\n    roundingMode = 1;\n    roundingPrecision = 1;\nLAB_08007c24:\n    *(undefined4 *)(value + 0x44) = 0;\n    tempValue = maxDigits;\n  }\n  else {\n    maxDigits = roundingMode;\n    roundingPrecision = roundingMode;\n    uVar12 = roundingMode;\nLAB_08008314:\n    *(undefined4 *)(value + 0x44) = 0;\n    tempValue = roundingPrecision;\n    if (0x17 < (int)uVar12) {\n      exponent = 4;\n      digit = 1;\n      do {\n        tempLength = digit;\n        exponent = exponent * 2;\n        digit = tempLength + 1;\n      } while (exponent + 0x14U <= uVar12);\n      *(int *)(value + 0x44) = tempLength;\n    }\n  }\n  pdigitChar8 = (char *)_Balloc(value);\n  *(char **)(value + 0x40) = pdigitChar8;\n  if ((tempValue < 0xf) && (isNegativeFractionalPart)) {\n    if ((int)exponentDiff < 1) {\n      if (exponentDiff == 0) {\n        digit = 2;\n        integerPartFloat = integerPart;\n      }\n      else {\n        tempFloat = __muldf3(integerPart,fractionalPartFloat,\n                          *(undefined4 *)(PTR___mprec_tens_080086cc + (-exponentDiff & 0xf) * 8),\n                          *(undefined4 *)\n                           ((int)(PTR___mprec_tens_080086cc + (-exponentDiff & 0xf) * 8) + 4));\n        fractionalPartFloat = (uint)((ulonglong)tempFloat >> 0x20);\n        integerPartFloat = (uint)tempFloat;\n        exponent = (int)-exponentDiff >> 4;\n        if (exponent == 0) {\n          digit = 2;\n        }\n        else {\n          isNegativeFractionalPart = false;\n          digit = 2;\n          puVar16 = (undefined4 *)PTR___mprec_bigtens_080086d0;\n          do {\n            if (exponent << 0x1f < 0) {\n              tempFloat = __muldf3((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),*puVar16,puVar16[1]);\n              isNegativeFractionalPart = true;\n              digit = digit + 1;\n            }\n            exponent = exponent >> 1;\n            puVar16 = puVar16 + 2;\n          } while (exponent != 0);\n          if (isNegativeFractionalPart) {\n            integerPartFloat = (uint)tempFloat;\n            fractionalPartFloat = (uint)((ulonglong)tempFloat >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      uVar12 = (int)exponentDiff >> 4;\n      tempFloat = *(undefined8 *)(PTR___mprec_tens_08007ec4 + (exponentDiff & 0xf) * 8);\n      if ((int)(uVar12 << 0x1b) < 0) {\n        tempFloat2 = __divdf3(integerPart,fractionalPartFloat,*(undefined4 *)(PTR___mprec_bigtens_08007ec8 + 0x20),\n                          *(undefined4 *)(PTR___mprec_bigtens_08007ec8 + 0x24));\n        tempFloat5 = (uint)((ulonglong)tempFloat2 >> 0x20);\n        tempFloat4 = (uint)tempFloat2;\n        digit = 3;\n        uVar12 = uVar12 & 0xf;\n        puVar16 = (undefined4 *)PTR___mprec_bigtens_08007ec8;\n      }\n      else {\n        digit = 2;\n        tempFloat5 = fractionalPartFloat;\n        puVar16 = (undefined4 *)PTR___mprec_bigtens_08007ec8;\n        tempFloat4 = integerPart;\n      }\n      while( true ) {\n        temp = (undefined4)((ulonglong)tempFloat >> 0x20);\n        if (uVar12 == 0) break;\n        if ((int)(uVar12 << 0x1f) < 0) {\n          tempFloat = __muldf3((int)tempFloat,temp,*puVar16,puVar16[1]);\n          digit = digit + 1;\n        }\n        uVar12 = (int)uVar12 >> 1;\n        puVar16 = puVar16 + 2;\n      }\n      tempFloat = __divdf3(tempFloat4,tempFloat5,(int)tempFloat,temp);\n      integerPartFloat = (uint)tempFloat;\n      fractionalPartFloat = (uint)((ulonglong)tempFloat >> 0x20);\n    }\n    tempFloat = CONCAT44(fractionalPartFloat,integerPartFloat);\n    if ((isSmaller != 0) && (exponent = __aeabi_dcmplt(integerPartFloat,fractionalPartFloat,0,DAT_08007ecc), exponent != 0))\n    {\n      if (roundingPrecision == 0) {\n        tempFloat = __aeabi_i2d(digit);\n        tempFloat = __muldf3((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),integerPartFloat,fractionalPartFloat);\n        tempFloat = __aeabi_dadd((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),0,DAT_080086d4);\n        temp = (undefined4)tempFloat;\n        digit = (int)((ulonglong)tempFloat >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)maxDigits) {\n        tempFloat = __muldf3(integerPartFloat,fractionalPartFloat,0,DAT_0800880c);\n        tempFloat2 = __aeabi_i2d(digit + 1);\n        tempFloat2 = __muldf3((int)tempFloat2,(int)((ulonglong)tempFloat2 >> 0x20),(int)tempFloat,\n                          (int)((ulonglong)tempFloat >> 0x20));\n        tempFloat2 = __aeabi_dadd((int)tempFloat2,(int)((ulonglong)tempFloat2 >> 0x20),0,DAT_08008810);\n        temp = (undefined4)tempFloat2;\n        tempFloat4 = maxDigits;\n        tempFloat6 = exponentDiff - 1;\n        digit = (int)((ulonglong)tempFloat2 >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    tempFloat2 = __aeabi_i2d(digit);\n    tempFloat2 = __muldf3((int)tempFloat2,(int)((ulonglong)tempFloat2 >> 0x20),integerPartFloat,fractionalPartFloat);\n    tempFloat2 = __aeabi_dadd((int)tempFloat2,(int)((ulonglong)tempFloat2 >> 0x20),0,DAT_08007ed0);\n    temp = (undefined4)tempFloat2;\n    digit = (int)((ulonglong)tempFloat2 >> 0x20) + -0x3400000;\n    if (roundingPrecision != 0) {\n      tempFloat6 = exponentDiff;\n      tempFloat4 = roundingPrecision;\nLAB_08007cfa:\n      fractionalPartFloat = (uint)((ulonglong)tempFloat >> 0x20);\n      integerPartFloat = (uint)tempFloat;\n      digitChar = __aeabi_d2iz(integerPartFloat,fractionalPartFloat);\n      digitChar = digitChar + '0';\n      uVar11 = *(undefined4 *)(PTR___mprec_tens_08007ec4 + tempFloat4 * 8 + -8);\n      tempFractionalPart = *(undefined4 *)(PTR___mprec_tens_08007ec4 + tempFloat4 * 8 + -4);\n      tempFloat = __aeabi_i2d();\n      tempFloat = __subdf3(integerPartFloat,fractionalPartFloat,(int)tempFloat,(int)((ulonglong)tempFloat >> 0x20));\n      uVar17 = (undefined4)((ulonglong)tempFloat >> 0x20);\n      pdigitChar5 = pdigitChar8 + 1;\n      if (isZero == 0) {\n        tempFloat2 = __muldf3(temp,digit,uVar11,tempFractionalPart);\n        temp = (undefined4)((ulonglong)tempFloat2 >> 0x20);\n        *pdigitChar8 = digitChar;\n        if (tempFloat4 != 1) {\n          pdigitChar4 = pdigitChar5;\n          do {\n            tempFloat = __muldf3((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),0,DAT_080086d8);\n            digitChar = __aeabi_d2iz();\n            tempFloat3 = __aeabi_i2d();\n            tempFloat = __subdf3((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),(int)tempFloat3,\n                              (int)((ulonglong)tempFloat3 >> 0x20));\n            pdigitChar5 = pdigitChar4 + 1;\n            *pdigitChar4 = digitChar + '0';\n            pdigitChar4 = pdigitChar5;\n          } while (pdigitChar5 != pdigitChar8 + tempFloat4);\n        }\n        uVar11 = (undefined4)((ulonglong)tempFloat >> 0x20);\n        tempFloat3 = __aeabi_dadd((int)tempFloat2,temp,0,DAT_080086dc);\n        digit = __aeabi_dcmplt((int)tempFloat3,(int)((ulonglong)tempFloat3 >> 0x20),(int)tempFloat,uVar11);\n        if (digit == 0) {\n          tempFloat2 = __subdf3(0,DAT_08008814,(int)tempFloat2,temp);\n          digit = __aeabi_dcmpgt((int)tempFloat2,(int)((ulonglong)tempFloat2 >> 0x20),(int)tempFloat,uVar11);\n          pdigitChar4 = pdigitChar5;\n          if (digit == 0) goto LAB_08007e36;\n          do {\n            pdigitChar5 = pdigitChar4;\n            pdigitChar4 = pdigitChar5 + -1;\n          } while (pdigitChar5[-1] == '0');\n          goto LAB_08008784;\n        }\n        exponentDiff = tempFloat6;\n        digitChar = pdigitChar5[-1];\n      }\n      else {\n        tempFloat2 = __divdf3(0,DAT_08007ed4,uVar11,tempFractionalPart);\n        tempFloat2 = __subdf3((int)tempFloat2,(int)((ulonglong)tempFloat2 >> 0x20),temp,digit);\n        temp = (undefined4)((ulonglong)tempFloat2 >> 0x20);\n        *pdigitChar8 = digitChar;\n        digit = __aeabi_dcmpgt((int)tempFloat2,temp,(int)tempFloat,uVar17);\n        if (digit != 0) {\nLAB_08008784:\n          exponentDiff = tempFloat6;\n          goto LAB_08008294;\n        }\n        tempFloat3 = __subdf3(0,DAT_08007ecc,(int)tempFloat,uVar17);\n        digit = __aeabi_dcmpgt((int)tempFloat2,temp,(int)tempFloat3,(int)((ulonglong)tempFloat3 >> 0x20));\n        if (digit == 0) {\n          if (tempFloat4 != 1) {\n            pdigitChar4 = pdigitChar5;\n            do {\n              tempFloat2 = __muldf3((int)tempFloat2,(int)((ulonglong)tempFloat2 >> 0x20),0,DAT_08007ed8);\n              temp = (undefined4)((ulonglong)tempFloat2 >> 0x20);\n              tempFloat = __muldf3((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),0,DAT_08007ed8);\n              digitChar = __aeabi_d2iz();\n              tempFloat3 = __aeabi_i2d();\n              tempFloat = __subdf3((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),(int)tempFloat3,\n                                (int)((ulonglong)tempFloat3 >> 0x20));\n              uVar11 = (undefined4)((ulonglong)tempFloat >> 0x20);\n              digitChar = digitChar + '0';\n              pdigitChar5 = pdigitChar4 + 1;\n              *pdigitChar4 = digitChar;\n              digit = __aeabi_dcmplt((int)tempFloat,uVar11,(int)tempFloat2,temp);\n              if (digit != 0) {\n                exponentDiff = tempFloat6;\n                goto LAB_08008294;\n              }\n              tempFloat3 = __subdf3(0,DAT_08007ecc,(int)tempFloat,uVar11);\n              digit = __aeabi_dcmplt((int)tempFloat3,(int)((ulonglong)tempFloat3 >> 0x20),(int)tempFloat2,temp)\n              ;\n              if (digit != 0) goto LAB_08008798;\n              pdigitChar4 = pdigitChar5;\n            } while (pdigitChar5 != pdigitChar8 + tempFloat4);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        exponentDiff = tempFloat6;\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    tempFloat = __subdf3(integerPartFloat,fractionalPartFloat,0,DAT_080086c8);\n    uVar11 = (undefined4)((ulonglong)tempFloat >> 0x20);\n    uVar12 = __aeabi_dcmpgt((int)tempFloat,uVar11,temp,digit);\n    if (uVar12 == 0) {\n      digit = __aeabi_dcmplt((int)tempFloat,uVar11,temp,digit + -0x80000000);\n      tempValue = uVar12;\n      pdigitChar5 = pdigitChar8;\n      if (digit == 0) goto LAB_08007e36;\n      goto LAB_080084f0;\n    }\n    roundingPrecision = 0;\n    uVar12 = 0;\nLAB_08008406:\n    *pdigitChar8 = '1';\n    exponentDiff = exponentDiff + 1;\n    pdigitChar5 = pdigitChar8 + 1;\n    tempValue = roundingPrecision;\nLAB_08008416:\n    _Bfree(value,tempValue);\n    if (uVar12 == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pdigitChar5 = pdigitChar8;\n    if ((-1 < tempArray[0]) && ((int)exponentDiff < 0xf)) {\n      temp = *(undefined4 *)(PTR___mprec_tens_08007ec4 + exponentDiff * 8);\n      uVar11 = *(undefined4 *)((int)(PTR___mprec_tens_08007ec4 + exponentDiff * 8) + 4);\n      if ((-1 < (int)roundingMode) || (0 < (int)roundingPrecision)) {\n        __divdf3(integerPart,remainder,temp,uVar11);\n        comparisonResult = __aeabi_d2iz();\n        tempFloat = __aeabi_i2d();\n        tempFloat = __muldf3((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),temp,uVar11);\n        tempFloat = __subdf3(integerPart,remainder,(int)tempFloat,(int)((ulonglong)tempFloat >> 0x20));\n        *pdigitChar8 = comparisonResult + 0x30;\n        pdigitChar5 = pdigitChar8 + 1;\n        if (roundingPrecision != 1) {\n          tempFloat = __muldf3((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),0,DAT_08007ed8);\n          digit = __aeabi_dcmpeq((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),0,0);\n          while (digit == 0) {\n            uVar17 = (undefined4)((ulonglong)tempFloat >> 0x20);\n            __divdf3((int)tempFloat,uVar17,temp,uVar11);\n            comparisonResult = __aeabi_d2iz();\n            tempFloat2 = __aeabi_i2d();\n            tempFloat2 = __muldf3((int)tempFloat2,(int)((ulonglong)tempFloat2 >> 0x20),temp,uVar11);\n            tempFloat = __subdf3((int)tempFloat,uVar17,(int)tempFloat2,(int)((ulonglong)tempFloat2 >> 0x20));\n            pdigitChar4 = pdigitChar5 + 1;\n            *pdigitChar5 = comparisonResult + 0x30;\n            pdigitChar5 = pdigitChar4;\n            if (roundingPrecision == (int)pdigitChar4 - (int)pdigitChar8) goto LAB_08007f3a;\n            tempFloat = __muldf3((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),0,DAT_080081f8);\n            digit = __aeabi_dcmpeq((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        tempFloat = __aeabi_dadd((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20));\n        uVar17 = (undefined4)((ulonglong)tempFloat >> 0x20);\n        digit = __aeabi_dcmpgt((int)tempFloat,uVar17,temp,uVar11);\n        if ((digit == 0) &&\n           ((digit = __aeabi_dcmpeq((int)tempFloat,uVar17,temp,uVar11), digit == 0 ||\n            ((comparisonResult & 1) == 0)))) goto LAB_08008294;\n        digitChar = pdigitChar5[-1];\nLAB_08007f7c:\n        while (pdigitChar4 = pdigitChar5 + -1, digitChar == '9') {\n          if (pdigitChar8 == pdigitChar4) {\n            *pdigitChar8 = '0';\n            digitChar = pdigitChar5[-1];\n            exponentDiff = exponentDiff + 1;\n            pdigitChar4 = pdigitChar8;\n            break;\n          }\n          digitChar = pdigitChar5[-2];\n          pdigitChar5 = pdigitChar4;\n        }\n        *pdigitChar4 = digitChar + '\\x01';\n        goto LAB_08008294;\n      }\n      if (roundingPrecision == 0) {\n        tempFloat = __muldf3(temp,uVar11,0,DAT_080086c8);\n        digit = __aeabi_dcmpge((int)tempFloat,(int)((ulonglong)tempFloat >> 0x20),integerPart,remainder);\n        uVar12 = roundingPrecision;\n        tempValue = roundingPrecision;\n        if (digit == 0) goto LAB_08008406;\n      }\n      else {\n        uVar12 = 0;\n        tempValue = 0;\n      }\nLAB_080084f0:\n      exponentDiff = ~roundingMode;\n      pdigitChar8 = pdigitChar5;\n      goto LAB_08008416;\n    }\n    digit = exponentOffset;\n    if (isZero == 0) {\n      isOne = shiftAmount;\n      uVar12 = isZero;\n    }\n    else {\n      if ((int)precision < 2) {\n        if (isOne == 0) {\n          isOne = shiftAmount;\n          shiftAmount = shiftAmount + (0x36 - tempLength2);\n          shift = shift + (0x36 - tempLength2);\n        }\n        else {\n          isOne = shiftAmount;\n          shiftAmount = shiftAmount + tempArray[0] + 0x433;\n          shift = shift + tempArray[0] + 0x433;\n        }\n      }\n      else {\n        exponent = roundingPrecision - 1;\n        if (exponentOffset < exponent) {\n          leadingZeros = leadingZeros + (exponent - exponentOffset);\n          digit = 0;\n          exponentOffset = exponent;\n        }\n        else {\n          digit = exponentOffset - exponent;\n        }\n        if ((int)roundingPrecision < 0) {\n          isOne = shiftAmount - roundingPrecision;\n        }\n        else {\n          shift = shift + roundingPrecision;\n          isOne = shiftAmount;\n          shiftAmount = shiftAmount + roundingPrecision;\n        }\n      }\n      uVar12 = __i2b(value,1);\n    }\n    if ((0 < isOne) && (0 < shift)) {\n      exponent = isOne;\n      if (shift <= isOne) {\n        exponent = shift;\n      }\n      shift = shift - exponent;\n      shiftAmount = shiftAmount - exponent;\n      isOne = isOne - exponent;\n    }\n    if (exponentOffset != 0) {\n      if (isZero == 0) {\n        quotient = __pow5mult(value,quotient,exponentOffset);\n      }\n      else {\n        temp = quotient;\n        if (digit != 0) {\n          uVar12 = __pow5mult(value,uVar12,digit);\n          temp = __multiply(value,uVar12,quotient);\n          _Bfree(value,quotient);\n          quotient = temp;\n          if (exponentOffset - digit == 0) goto LAB_08008062;\n        }\n        quotient = __pow5mult(value,temp,exponentOffset - digit);\n      }\n    }\nLAB_08008062:\n    tempValue = __i2b(value,1);\n    if (leadingZeros == 0) {\n      if (((int)precision < 2) && (integerPart == 0)) {\nLAB_0800835a:\n        if ((remainder & 0xfffff) == 0) {\n          remainder = remainder & 0x7ff00000;\n          if (remainder != 0) {\n            shift = shift + 1;\n            shiftAmount = shiftAmount + 1;\n            remainder = 1;\n          }\n        }\n        else {\n          remainder = 0;\n        }\n        isNegativeFractionalPart = leadingZeros != 0;\n        tempIntegerPart = integerPart;\n        leadingZeros = remainder;\n        if (isNegativeFractionalPart) goto LAB_080082d4;\n      }\n      digit = 1;\n    }\n    else {\n      tempFloat = __pow5mult(value,tempValue);\n      tempValue = (uint)tempFloat;\n      if (((int)precision < 2) && (integerPart == 0)) goto LAB_0800835a;\n      leadingZeros = 0;\n      tempIntegerPart = (uint)((ulonglong)tempFloat >> 0x20);\nLAB_080082d4:\n      digit = __hi0bits(*(undefined4 *)(tempValue + *(int *)(tempValue + 0x10) * 4 + 0x10),tempIntegerPart);\n      digit = 0x20 - digit;\n    }\n    remainder = digit + shift & 0x1f;\n    if (remainder == 0) {\n      digit = 0x1c;\nLAB_08008096:\n      shift = shift + digit;\n      shiftAmount = shiftAmount + digit;\n      isOne = isOne + digit;\n    }\n    else {\n      if (4 < (int)(0x20 - remainder)) {\n        digit = 0x1c - remainder;\n        goto LAB_08008096;\n      }\n      if (0x20 - remainder != 4) {\n        digit = 0x3c - remainder;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < shiftAmount) {\n      quotient = __lshift(value,quotient,shiftAmount);\n    }\n    if (0 < shift) {\n      tempValue = __lshift(value,tempValue,shift);\n    }\n    pdigitChar4 = pdigitChar8;\n    if ((isSmaller != 0) && (digit = __mcmp(quotient,tempValue), digit < 0)) {\n      exponentDiff = exponentDiff - 1;\n      quotient = __multadd(value,quotient,10,0);\n      if (isZero == 0) {\n        if ((0 < (int)maxDigits) || ((int)precision < 3)) {\n          roundingPrecision = maxDigits;\n          goto LAB_0800820a;\n        }\n      }\n      else {\n        uVar12 = __multadd(value,uVar12,10,0);\n        if ((0 < (int)maxDigits) || ((int)precision < 3)) {\n          roundingPrecision = maxDigits;\n          goto LAB_080080de;\n        }\n      }\n      roundingPrecision = maxDigits;\nLAB_080084e8:\n      if (roundingPrecision == 0) {\n        roundingPrecision = __multadd(value,tempValue,5);\n        digit = __mcmp(quotient,roundingPrecision);\n        tempValue = roundingPrecision;\n        if (0 < digit) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)roundingPrecision < 1) && (2 < (int)precision)) goto LAB_080084e8;\n    if (isZero == 0) {\nLAB_0800820a:\n      while( true ) {\n        tempLength = quorem(quotient,tempValue);\n        tempLength = tempLength + 0x30;\n        pdigitChar5 = pdigitChar4 + 1;\n        *pdigitChar4 = (char)tempLength;\n        if ((int)roundingPrecision <= (int)pdigitChar5 - (int)pdigitChar8) break;\n        quotient = __multadd(value,quotient,10,0);\n        pdigitChar4 = pdigitChar5;\n      }\n      integerPartFloat = 0;\n    }\n    else {\nLAB_080080de:\n      integerPartFloat = uVar12;\n      if (0 < isOne) {\n        integerPartFloat = __lshift(value,uVar12,isOne);\n      }\n      uVar12 = integerPartFloat;\n      if (leadingZeros != 0) {\n        digit = _Balloc(value,*(undefined4 *)(integerPartFloat + 4));\n        memcpy((void *)(digit + 0xc),(void *)(integerPartFloat + 0xc),(*(int *)(integerPartFloat + 0x10) + 2) * 4);\n        uVar12 = __lshift(value,digit,1);\n      }\nLAB_08008108:\n      digit = quorem(quotient,tempValue);\n      exponent = __mcmp(quotient,integerPartFloat);\n      shift = __mdiff(value,tempValue,uVar12);\n      tempLength = digit + 0x30;\n      if (*(int *)(shift + 0xc) == 0) {\n        remainder = __mcmp(quotient);\n        _Bfree(value,shift);\n        if (((remainder != 0) || (precision != 0)) || (remainder = precision, (integerPart & 1) != 0))\n        goto LAB_0800815a;\n        if (tempLength != 0x39) {\n          if (0 < exponent) {\nLAB_0800874c:\n            tempLength = digit + 0x31;\n          }\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pdigitChar5 = pdigitChar4 + 1;\n        digitChar = '9';\n        *pdigitChar4 = '9';\n        goto LAB_08008268;\n      }\n      _Bfree(value,shift);\n      remainder = 1;\nLAB_0800815a:\n      if ((exponent < 0) || (((exponent == 0 && (precision == 0)) && ((integerPart & 1) == 0)))) {\n        if (0 < (int)remainder) {\n          quotient = __lshift(value,quotient,1);\n          exponent = __mcmp(quotient,tempValue);\n          if ((0 < exponent) || ((exponent == 0 && (digit << 0x1f < 0)))) {\n            if (tempLength != 0x39) goto LAB_0800874c;\n            goto LAB_08008752;\n          }\n        }\nLAB_080085a4:\n        pdigitChar5 = pdigitChar4 + 1;\n        *pdigitChar4 = (char)tempLength;\n        goto LAB_08008274;\n      }\n      pdigitChar5 = pdigitChar4 + 1;\n      if (0 < (int)remainder) {\n        if (tempLength == 0x39) goto LAB_08008752;\n        *pdigitChar4 = (char)digit + '1';\n        goto LAB_08008274;\n      }\n      *pdigitChar4 = (char)tempLength;\n      if (pdigitChar8 + (roundingPrecision - 1) != pdigitChar4) {\n        quotient = __multadd(value,quotient,10,0);\n        pdigitChar4 = pdigitChar5;\n        if (integerPartFloat == uVar12) {\n          integerPartFloat = __multadd(value,integerPartFloat,10,0);\n          uVar12 = integerPartFloat;\n        }\n        else {\n          integerPartFloat = __multadd(value,integerPartFloat,10,0);\n          uVar12 = __multadd(value,uVar12,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    quotient = __lshift(value,quotient,1);\n    digit = __mcmp(quotient,tempValue);\n    digitChar = pdigitChar5[-1];\n    if ((0 < digit) || ((digit == 0 && (tempLength << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pdigitChar4 = pdigitChar5 + -1;\n        if (digitChar != '9') goto code_r0x08008270;\n        if (pdigitChar8 == pdigitChar4) {\n          *pdigitChar8 = '1';\n          exponentDiff = exponentDiff + 1;\n          goto LAB_08008274;\n        }\n        digitChar = pdigitChar5[-2];\n        pdigitChar5 = pdigitChar4;\n      } while( true );\n    }\n    while (digitChar == '0') {\n      digitChar = pdigitChar5[-2];\n      pdigitChar5 = pdigitChar5 + -1;\n    }\nLAB_08008274:\n    _Bfree(value,tempValue);\n    if (uVar12 == 0) goto LAB_08008294;\n    if ((integerPartFloat != 0) && (integerPartFloat != uVar12)) {\n      _Bfree(value);\n    }\n  }\n  _Bfree(value,uVar12);\nLAB_08008294:\n  _Bfree(value,quotient);\n  *pdigitChar5 = '\\0';\n  *length = exponentDiff + 1;\n  if (outputString == (char **)0x0) {\n    return pdigitChar8;\n  }\n  *outputString = pdigitChar5;\n  return pdigitChar8;\ncode_r0x08008270:\n  *pdigitChar4 = digitChar + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "called": [
                "__aeabi_dcmpeq",
                "__aeabi_dcmpgt",
                "__muldf3",
                "__floatunsidf",
                "_Bfree",
                "__lshift",
                "__pow5mult",
                "__multadd",
                "__aeabi_dcmplt",
                "__divdf3",
                "__i2b",
                "__multiply",
                "__aeabi_i2d",
                "__mcmp",
                "_Balloc",
                "__subdf3",
                "__d2b",
                "__mdiff",
                "__hi0bits",
                "memcpy",
                "__aeabi_d2iz",
                "quorem",
                "__aeabi_dcmpge",
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080079e8",
            "calling": [
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "convert_float_to_string_080079e8"
        },
        "FUN_080017c4": {
            "renaming": {
                "FUN_080017c4": "configure_gpio_pins_080017c4",
                "GPIOx": "gpio_port",
                "GPIO_Init": "gpio_init_config",
                "uVar1": "temp_var_1",
                "uVar2": "temp_var_2",
                "uVar3": "temp_var_3",
                "uVar4": "temp_var_4",
                "uVar5": "temp_var_5",
                "pGVar6": "gpio_port_ptr",
                "iVar7": "gpio_port_index",
                "tmpreg": "temp_reg",
                "configregister": "config_reg_ptr",
                "registeroffset": "reg_offset",
                "temp": "temp_val",
                "iocurrent": "current_io",
                "ioposition": "io_position",
                "config": "pin_config",
                "position": "pin_position"
            },
            "code": "\nvoid configure_GPIO_pins_080017c4(GPIO_TypeDef *gpio_port,gpio_init_configTypeDef *gpio_init_config)\n\n{\n  uint temp_var_1;\n  uint temp_var_2;\n  uint temp_var_3;\n  uint temp_var_4;\n  uint temp_var_5;\n  GPIO_TypeDef *gpio_port_ptr;\n  int gpio_port_index;\n  uint32_t temp_reg;\n  uint32_t *config_reg_ptr;\n  uint32_t reg_offset;\n  uint32_t temp_val;\n  uint32_t current_io;\n  uint32_t io_position;\n  uint32_t pin_config;\n  uint32_t pin_position;\n  \n  pin_config = 0;\n  pin_position = 0;\n  do {\n    if (0xf < pin_position) {\n      return;\n    }\n    temp_var_3 = 1 << (pin_position & 0xff);\n    temp_var_4 = gpio_init_config->Pin & temp_var_3;\n    if (temp_var_4 == temp_var_3) {\n      temp_var_5 = gpio_init_config->Mode;\n      if (temp_var_5 == 0x12) {\n        pin_config = gpio_init_config->Speed + 0xc;\n      }\n      else if (temp_var_5 < 0x13) {\n        if (temp_var_5 == 2) {\n          pin_config = gpio_init_config->Speed + 8;\n        }\n        else if (temp_var_5 < 3) {\n          if (temp_var_5 == 0) goto LAB_08001882;\n          if (temp_var_5 == 1) {\n            pin_config = gpio_init_config->Speed;\n          }\n        }\n        else if (temp_var_5 == 3) {\n          pin_config = 0;\n        }\n        else if (temp_var_5 == 0x11) {\n          pin_config = gpio_init_config->Speed + 4;\n        }\n      }\n      else if (((temp_var_5 == DAT_08001a4c) ||\n               (((temp_var_1 = DAT_08001a54, temp_var_2 = DAT_08001a50, DAT_08001a4c < temp_var_5 &&\n                 (temp_var_1 = DAT_08001a60, temp_var_2 = DAT_08001a5c, temp_var_5 == DAT_08001a58)) ||\n                (temp_var_5 == temp_var_2)))) || (temp_var_5 == temp_var_1)) {\nLAB_08001882:\n        if (gpio_init_config->Pull == 0) {\n          pin_config = 4;\n        }\n        else if (gpio_init_config->Pull == 1) {\n          pin_config = 8;\n          gpio_port->BSRR = temp_var_3;\n        }\n        else {\n          pin_config = 8;\n          gpio_port->BRR = temp_var_3;\n        }\n      }\n      if (temp_var_4 < 0x100) {\n        temp_var_3 = pin_position << 2;\n        gpio_port_ptr = gpio_port;\n      }\n      else {\n        gpio_port_ptr = (GPIO_TypeDef *)&gpio_port->CRH;\n        temp_var_3 = (pin_position - 8) * 4;\n      }\n      gpio_port_ptr->CRL = gpio_port_ptr->CRL & ~(0xf << (temp_var_3 & 0xff)) | pin_config << (temp_var_3 & 0xff);\n      if ((gpio_init_config->Mode & 0x10000000) != 0) {\n        *(uint *)(DAT_08001a64 + 0x18) = *(uint *)(DAT_08001a64 + 0x18) | 1;\n        if (gpio_port == DAT_08001a6c) {\n          gpio_port_index = 0;\n        }\n        else if (gpio_port == DAT_08001a70) {\n          gpio_port_index = 1;\n        }\n        else if (gpio_port == DAT_08001a74) {\n          gpio_port_index = 2;\n        }\n        else if (gpio_port == DAT_08001a78) {\n          gpio_port_index = 3;\n        }\n        else {\n          gpio_port_index = 4;\n        }\n        *(uint *)(DAT_08001a68 + ((pin_position >> 2) + 2) * 4) =\n             gpio_port_index << ((pin_position & 3) << 2) |\n             ~(0xf << ((pin_position & 3) << 2)) & *(uint *)(DAT_08001a68 + ((pin_position >> 2) + 2) * 4);\n        if ((gpio_init_config->Mode & 0x10000) == 0) {\n          *DAT_08001a7c = ~temp_var_4 & *DAT_08001a7c;\n        }\n        else {\n          *DAT_08001a7c = temp_var_4 | *DAT_08001a7c;\n        }\n        if ((gpio_init_config->Mode & 0x20000) == 0) {\n          DAT_08001a7c[1] = ~temp_var_4 & DAT_08001a7c[1];\n        }\n        else {\n          DAT_08001a7c[1] = temp_var_4 | DAT_08001a7c[1];\n        }\n        if ((gpio_init_config->Mode & 0x100000) == 0) {\n          DAT_08001a7c[2] = ~temp_var_4 & DAT_08001a7c[2];\n        }\n        else {\n          DAT_08001a7c[2] = temp_var_4 | DAT_08001a7c[2];\n        }\n        if ((gpio_init_config->Mode & 0x200000) == 0) {\n          DAT_08001a7c[3] = ~temp_var_4 & DAT_08001a7c[3];\n        }\n        else {\n          DAT_08001a7c[3] = temp_var_4 | DAT_08001a7c[3];\n        }\n      }\n    }\n    pin_position = pin_position + 1;\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080017c4",
            "calling": [
                "HAL_TIM_MspPostInit",
                "MX_GPIO_Init"
            ],
            "imported": false,
            "current_name": "configure_gpio_pins_080017c4"
        },
        "FUN_080056da": {
            "renaming": {
                "FUN_080056da": "infinite_loop_080056da"
            },
            "code": "\nvoid infinite_loop_080056da(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080056da",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_080056da"
        },
        "FUN_08001044": {
            "renaming": {
                "FUN_08001044": "decode_unsigned_integer_08001044",
                "param_1": "unsigned_integer",
                "uVar1": "shift_amount"
            },
            "code": "\nuint decode_unsigned_integer_08001044(uint unsigned_integer)\n\n{\n  uint shift_amount;\n  \n  if (((unsigned_integer & 0x80000000) != 0) || (unsigned_integer << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shift_amount = 0x9e - ((unsigned_integer << 1) >> 0x18);\n  if (-1 < (int)shift_amount) {\n    return (unsigned_integer << 8 | 0x80000000) >> (shift_amount & 0xff);\n  }\n  if ((shift_amount == 0xffffff9f) && ((unsigned_integer & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001044",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "imported": false,
            "current_name": "decode_unsigned_integer_08001044"
        },
        "FUN_08009444": {
            "renaming": {
                "FUN_08009444": "expand_bits_08009444",
                "param_1": "destination_size",
                "param_2": "source_array",
                "param_3": "source_size",
                "iVar1": "increment",
                "iVar2": "current_bit",
                "iVar3": "bits_required",
                "uVar4": "first_value",
                "iVar5": "source_array_offset",
                "iVar6": "doubled_value",
                "puVar7": "destination_array",
                "puVar8": "source_array_ptr",
                "puVar9": "destination_array_ptr",
                "puVar10": "next_source_ptr",
                "puVar11": "source_array_end_ptr",
                "iVar12": "destination_array_size",
                "iVar13": "expanded_size",
                "uVar14": "carryover_bits"
            },
            "code": "\nvoid expand_bits_08009444(int destination_size,undefined4 *source_array,uint source_size)\n\n{\n  int increment;\n  int current_bit;\n  int bits_required;\n  undefined4 first_value;\n  int source_array_offset;\n  int doubled_value;\n  uint *destination_array;\n  uint *source_array_ptr;\n  uint *next_source_ptr;\n  uint *source_array_end_ptr;\n  int destination_array_size;\n  int expanded_size;\n  uint carryover_bits;\n  uint *destination_array_ptr;\n  \n  source_array_offset = source_array[4];\n  destination_array_size = (int)source_size >> 5;\n  expanded_size = destination_array_size + source_array_offset + 1;\n  bits_required = source_array[1];\n  current_bit = source_array[2];\n  if ((int)source_array[2] < expanded_size) {\n    do {\n      doubled_value = current_bit * 2;\n      increment = current_bit * -2;\n      bits_required = bits_required + 1;\n      current_bit = doubled_value;\n    } while (expanded_size != doubled_value && expanded_size + increment < 0 == SBORROW4(expanded_size,doubled_value));\n  }\n  current_bit = _Balloc(destination_size,bits_required);\n  destination_array = (uint *)(current_bit + 0x14);\n  if (0 < destination_array_size) {\n    source_array_end_ptr = destination_array + destination_array_size;\n    source_array_ptr = destination_array;\n    do {\n      destination_array_ptr = source_array_ptr + 1;\n      *source_array_ptr = 0;\n      destination_array = source_array_end_ptr;\n      source_array_ptr = destination_array_ptr;\n    } while (destination_array_ptr != source_array_end_ptr);\n  }\n  bits_required = source_array[4];\n  source_array_ptr = source_array + 5;\n  source_size = source_size & 0x1f;\n  if (source_size == 0) {\n    destination_array = destination_array + -1;\n    source_array_end_ptr = source_array_ptr;\n    do {\n      destination_array_ptr = source_array_end_ptr + 1;\n      destination_array = destination_array + 1;\n      *destination_array = *source_array_end_ptr;\n      source_array_end_ptr = destination_array_ptr;\n    } while (destination_array_ptr < source_array_ptr + bits_required);\n  }\n  else {\n    carryover_bits = 0;\n    source_array_end_ptr = source_array_ptr;\n    do {\n      destination_array_ptr = destination_array;\n      *destination_array_ptr = *source_array_end_ptr << source_size | carryover_bits;\n      next_source_ptr = source_array_end_ptr + 1;\n      carryover_bits = *source_array_end_ptr >> (0x20 - source_size & 0xff);\n      destination_array = destination_array_ptr + 1;\n      source_array_end_ptr = next_source_ptr;\n    } while (next_source_ptr < source_array_ptr + bits_required);\n    destination_array_ptr[1] = carryover_bits;\n    if (carryover_bits != 0) {\n      expanded_size = destination_array_size + source_array_offset + 2;\n    }\n  }\n  source_array_offset = *(int *)(destination_size + 0x4c);\n  bits_required = source_array[1];\n  first_value = *(undefined4 *)(source_array_offset + bits_required * 4);\n  *(int *)(current_bit + 0x10) = expanded_size + -1;\n  *source_array = first_value;\n  *(undefined4 **)(source_array_offset + bits_required * 4) = source_array;\n  return;\n}\n\n",
            "called": [
                "_Balloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009444",
            "calling": [
                "_dtoa_r"
            ],
            "imported": false,
            "current_name": "expand_bits_08009444"
        },
        "FUN_08004436": {
            "renaming": {
                "FUN_08004436": "send_data_over_uart_08004436",
                "huart": "uart_handle",
                "pData": "data_buffer",
                "Size": "data_size",
                "Timeout": "timeout_ms",
                "HVar3": "status",
                "iVar4": "status_check",
                "local_58": "data_ptr",
                "tmp": "unused_ptr",
                "uVar1": "start_tick",
                "uVar2": "current_tick",
                "tickstart": "start_tick"
            },
            "code": "\nHAL_StatusTypeDef\nsend_data_over_uart_08004436(UART_HandleTypeDef *uart_handle,uint8_t *data_buffer,uint16_t data_size,uint32_t timeout_ms)\n\n{\n  uint32_t start_tick;\n  uint32_t current_tick;\n  HAL_StatusTypeDef status;\n  int status_check;\n  ushort *data_ptr;\n  uint16_t *unused_ptr;\n  uint32_t start_tick;\n  \n  if (uart_handle->gState == HAL_UART_STATE_READY) {\n    if ((data_buffer == (uint8_t *)0x0) || (data_size == 0)) {\n      status = HAL_ERROR;\n    }\n    else if (uart_handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uart_handle->Lock = HAL_LOCKED;\n      uart_handle->ErrorCode = 0;\n      uart_handle->gState = HAL_UART_STATE_BUSY_TX;\n      start_tick = HAL_GetTick();\n      uart_handle->TxXferdata_size = data_size;\n      uart_handle->TxXferCount = data_size;\n      data_ptr = (ushort *)data_buffer;\n      while (uart_handle->TxXferCount != 0) {\n        uart_handle->TxXferCount = uart_handle->TxXferCount - 1;\n        if ((uart_handle->Init).WordLength == 0x1000) {\n          do {\n            if ((uart_handle->Instance->SR & 0x80) == 0x80) {\n              status_check = 0;\n              goto LAB_0800454c;\n            }\n          } while ((timeout_ms == 0xffffffff) ||\n                  ((timeout_ms != 0 && (current_tick = HAL_GetTick(), current_tick - start_tick <= timeout_ms))));\n          uart_handle->Instance->CR1 = uart_handle->Instance->CR1 & 0xfffffe5f;\n          uart_handle->Instance->CR3 = uart_handle->Instance->CR3 & 0xfffffffe;\n          uart_handle->gState = HAL_UART_STATE_READY;\n          uart_handle->RxState = HAL_UART_STATE_READY;\n          uart_handle->Lock = HAL_UNLOCKED;\n          status_check = 3;\nLAB_0800454c:\n          if (status_check != 0) {\n            return HAL_TIMEOUT;\n          }\n          uart_handle->Instance->DR = *data_ptr & 0x1ff;\n          if ((uart_handle->Init).Parity == 0) {\n            data_ptr = data_ptr + 1;\n          }\n          else {\n            data_ptr = (ushort *)((int)data_ptr + 1);\n          }\n        }\n        else {\n          do {\n            if ((uart_handle->Instance->SR & 0x80) == 0x80) {\n              status_check = 0;\n              goto LAB_08004614;\n            }\n          } while ((timeout_ms == 0xffffffff) ||\n                  ((timeout_ms != 0 && (current_tick = HAL_GetTick(), current_tick - start_tick <= timeout_ms))));\n          uart_handle->Instance->CR1 = uart_handle->Instance->CR1 & 0xfffffe5f;\n          uart_handle->Instance->CR3 = uart_handle->Instance->CR3 & 0xfffffffe;\n          uart_handle->gState = HAL_UART_STATE_READY;\n          uart_handle->RxState = HAL_UART_STATE_READY;\n          uart_handle->Lock = HAL_UNLOCKED;\n          status_check = 3;\nLAB_08004614:\n          if (status_check != 0) {\n            return HAL_TIMEOUT;\n          }\n          uart_handle->Instance->DR = (uint)*(byte *)data_ptr;\n          data_ptr = (ushort *)((int)data_ptr + 1);\n        }\n      }\n      do {\n        if ((uart_handle->Instance->SR & 0x40) == 0x40) {\n          status_check = 0;\n          goto LAB_080046c6;\n        }\n      } while ((timeout_ms == 0xffffffff) ||\n              ((timeout_ms != 0 && (current_tick = HAL_GetTick(), current_tick - start_tick <= timeout_ms))));\n      uart_handle->Instance->CR1 = uart_handle->Instance->CR1 & 0xfffffe5f;\n      uart_handle->Instance->CR3 = uart_handle->Instance->CR3 & 0xfffffffe;\n      uart_handle->gState = HAL_UART_STATE_READY;\n      uart_handle->RxState = HAL_UART_STATE_READY;\n      uart_handle->Lock = HAL_UNLOCKED;\n      status_check = 3;\nLAB_080046c6:\n      if (status_check == 0) {\n        uart_handle->gState = HAL_UART_STATE_READY;\n        uart_handle->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004436",
            "calling": [
                "uart_print"
            ],
            "imported": false,
            "current_name": "send_data_over_uart_08004436"
        },
        "FUN_08009e50": {
            "renaming": {
                "FUN_08009e50": "write_byte_or_error_08009e50",
                "param_1": "output_buffer",
                "param_2": "byte_to_write",
                "param_3": "byte_value",
                "undefined": "void"
            },
            "code": "\nvoid * write_byte_or_error_08009e50(void4 *output_buffer,void *byte_to_write,uint byte_value)\n\n{\n  if (byte_to_write != (void *)0x0) {\n    if (byte_value < 0x100) {\n      *byte_to_write = (char)byte_value;\n      byte_to_write = (void *)0x1;\n    }\n    else {\n      byte_to_write = (void *)0xffffffff;\n      *output_buffer = 0x8a;\n    }\n  }\n  return byte_to_write;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009e50",
            "calling": [],
            "imported": false,
            "current_name": "write_byte_or_error_08009e50"
        },
        "FUN_08004ee8": {
            "renaming": {
                "FUN_08004ee8": "read_i2c_memory_08004ee8",
                "addr": "device_address",
                "reg": "memory_address",
                "len": "data_length"
            },
            "code": "\nvoid read_i2c_memory_08004ee8(uint8_t device_address,uint8_t memory_address,uint8_t *data,uint16_t data_length)\n\n{\n  HAL_I2C_Mem_Read((I2C_HandleTypeDef *)PTR_hi2c1_08004f28,(ushort)device_address,(ushort)memory_address,1,data,data_length,\n                   *(uint32_t *)PTR_I2C_TIMEOUT_08004f24);\n  return;\n}\n\n",
            "called": [
                "HAL_I2C_Mem_Read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ee8",
            "calling": [],
            "imported": false,
            "current_name": "read_i2c_memory_08004ee8"
        },
        "FUN_080094f8": {
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1",
                "param_2": "array2",
                "iVar1": "array_difference",
                "puVar2": "ptr_array2",
                "iVar3": "array2_offset",
                "puVar4": "ptr_array1"
            },
            "code": "\nint compare_arrays_080094f8(int array1,int array2)\n\n{\n  int array_difference;\n  uint *ptr_array2;\n  int array2_offset;\n  uint *ptr_array1;\n  \n  array2_offset = *(int *)(array2 + 0x10);\n  array_difference = *(int *)(array1 + 0x10) - array2_offset;\n  if (array_difference == 0) {\n    ptr_array2 = (uint *)(array2 + 0x14 + array2_offset * 4);\n    ptr_array1 = (uint *)(array1 + 0x14) + array2_offset;\n    do {\n      ptr_array1 = ptr_array1 + -1;\n      ptr_array2 = ptr_array2 + -1;\n      if (*ptr_array1 != *ptr_array2) {\n        if (*ptr_array2 <= *ptr_array1) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1 + 0x14) < ptr_array1);\n  }\n  return array_difference;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080094f8",
            "calling": [
                "_dtoa_r",
                "quorem"
            ],
            "imported": false,
            "current_name": "compare_arrays_080094f8"
        },
        "FUN_08000998": {
            "renaming": {
                "FUN_08000998": "compare_double_08000998",
                "in_ZR": "is_not_equal",
                "__aeabi_cdcmpeq": "compare_double_equal"
            },
            "code": "\nbool compare_double_08000998(void)\n\n{\n  char is_not_equal;\n  \n  compare_double_08000998_equal();\n  return is_not_equal != '\\0';\n}\n\n",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000998",
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "compare_double_08000998"
        },
        "FUN_08000fc8": {
            "renaming": {
                "FUN_08000fc8": "compare_floats_08000fc8",
                "param_1": "float_1",
                "param_2": "float_2"
            },
            "code": "\nvoid compare_floats_08000fc8(undefined4 float_1,undefined4 float_2)\n\n{\n  __aeabi_cfcmpeq(float_2,float_1);\n  return;\n}\n\n",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000fc8",
            "calling": [
                "__aeabi_fcmpge",
                "__aeabi_fcmpgt"
            ],
            "imported": false,
            "current_name": "compare_floats_08000fc8"
        },
        "FUN_08003908": {
            "renaming": {
                "FUN_08003908": "configure_tim_output_compare_08003908",
                "htim": "TIM_handle",
                "sConfig": "TIM_output_compare_init",
                "Channel": "TIM_channel",
                "HVar1": "status",
                "HAL_LOCKED": "locked",
                "HAL_BUSY": "busy",
                "HAL_TIM_STATE_BUSY": "busy_state",
                "HAL_TIM_STATE_READY": "ready_state",
                "HAL_UNLOCKED": "unlocked",
                "TIM_OC1_SetConfig": "configure_TIM_output_compare_channel_1",
                "TIM_OC2_SetConfig": "configure_TIM_output_compare_channel_2",
                "TIM_OC3_SetConfig": "configure_TIM_output_compare_channel_3",
                "TIM_OC4_SetConfig": "configure_TIM_output_compare_channel_4",
                "Instance": "TIM_instance",
                "CCMR1": "TIM_CCMR1",
                "CCMR2": "TIM_CCMR2",
                "OCFastMode": "TIM_OC_fast_mode"
            },
            "code": "\nHAL_StatusTypeDef\nconfigure_TIM_output_compare_08003908(TIM_HandleTypeDef *TIM_handle,TIM_OC_InitTypeDef *TIM_output_compare_init,uint32_t TIM_channel)\n\n{\n  HAL_StatusTypeDef status;\n  \n  if (TIM_handle->Lock == locked) {\n    status = busy;\n  }\n  else {\n    TIM_handle->Lock = locked;\n    TIM_handle->State = busy_state;\n    switch(TIM_channel) {\n    case 0:\n      configure_TIM_output_compare_08003908_channel_1(TIM_handle->TIM_instance,TIM_output_compare_init);\n      TIM_handle->TIM_instance->TIM_CCMR1 = TIM_handle->TIM_instance->TIM_CCMR1 | 8;\n      TIM_handle->TIM_instance->TIM_CCMR1 = TIM_handle->TIM_instance->TIM_CCMR1 & 0xfffffffb;\n      TIM_handle->TIM_instance->TIM_CCMR1 = TIM_output_compare_init->TIM_OC_fast_mode | TIM_handle->TIM_instance->TIM_CCMR1;\n      break;\n    case 4:\n      configure_TIM_output_compare_08003908_channel_2(TIM_handle->TIM_instance,TIM_output_compare_init);\n      TIM_handle->TIM_instance->TIM_CCMR1 = TIM_handle->TIM_instance->TIM_CCMR1 | 0x800;\n      TIM_handle->TIM_instance->TIM_CCMR1 = TIM_handle->TIM_instance->TIM_CCMR1 & 0xfffffbff;\n      TIM_handle->TIM_instance->TIM_CCMR1 = TIM_output_compare_init->TIM_OC_fast_mode << 8 | TIM_handle->TIM_instance->TIM_CCMR1;\n      break;\n    case 8:\n      configure_TIM_output_compare_08003908_channel_3(TIM_handle->TIM_instance,TIM_output_compare_init);\n      TIM_handle->TIM_instance->TIM_CCMR2 = TIM_handle->TIM_instance->TIM_CCMR2 | 8;\n      TIM_handle->TIM_instance->TIM_CCMR2 = TIM_handle->TIM_instance->TIM_CCMR2 & 0xfffffffb;\n      TIM_handle->TIM_instance->TIM_CCMR2 = TIM_output_compare_init->TIM_OC_fast_mode | TIM_handle->TIM_instance->TIM_CCMR2;\n      break;\n    case 0xc:\n      configure_TIM_output_compare_08003908_channel_4(TIM_handle->TIM_instance,TIM_output_compare_init);\n      TIM_handle->TIM_instance->TIM_CCMR2 = TIM_handle->TIM_instance->TIM_CCMR2 | 0x800;\n      TIM_handle->TIM_instance->TIM_CCMR2 = TIM_handle->TIM_instance->TIM_CCMR2 & 0xfffffbff;\n      TIM_handle->TIM_instance->TIM_CCMR2 = TIM_output_compare_init->TIM_OC_fast_mode << 8 | TIM_handle->TIM_instance->TIM_CCMR2;\n    }\n    TIM_handle->State = ready_state;\n    TIM_handle->Lock = unlocked;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC2_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC1_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003908",
            "calling": [
                "MX_TIM1_Init"
            ],
            "imported": false,
            "current_name": "configure_tim_output_compare_08003908"
        },
        "FUN_08004f60": {
            "renaming": {
                "FUN_08004f60": "clear_string_buffer_08004f60",
                "memset": "clear_memory"
            },
            "code": "\nvoid clear_string_buffer_08004f60(void)\n\n{\n  clear_memory(PTR_strbuf_08004f74,0,0x40);\n  return;\n}\n\n",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f60",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "imported": false,
            "current_name": "clear_string_buffer_08004f60"
        },
        "FUN_080056f8": {
            "renaming": {
                "FUN_080056f8": "FUNC_080056f8"
            },
            "code": "\nvoid FUNC_080056f8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080056f8",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_080056f8"
        },
        "FUN_08001170": {
            "renaming": {
                "FUN_08001170": "check_parameters_validity_08001170",
                "param_1": "first_parameter",
                "param_2": "second_parameter",
                "param_3": "third_parameter",
                "param_4": "fourth_parameter"
            },
            "code": "\nundefined4 check_parameters_validity_08001170(uint first_parameter,int second_parameter,uint third_parameter,int fourth_parameter)\n\n{\n  if ((((second_parameter << 1) >> 0x15 != -1) || ((first_parameter | second_parameter << 0xc) == 0)) &&\n     (((fourth_parameter << 1) >> 0x15 != -1 || ((third_parameter | fourth_parameter << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001170",
            "calling": [
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "check_parameters_validity_08001170"
        },
        "FUN_080056ec": {
            "renaming": {
                "FUN_080056ec": "FUNC_080056ec"
            },
            "code": "\nvoid FUNC_080056ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080056ec",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_080056ec"
        },
        "FUN_08002ad8": {
            "renaming": {
                "FUN_08002ad8": "check_i2c_status_08002ad8",
                "hi2c": "i2c_handle",
                "Flag": "status_flag",
                "Timeout": "timeout_ms",
                "Tickstart": "start_tick",
                "uVar1": "elapsed_time",
                "cVar2": "status_char",
                "uVar3": "status_value",
                "bVar4": "status_bool"
            },
            "code": "\nHAL_StatusTypeDef\ncheck_i2c_status_08002ad8(I2C_HandleTypeDef *i2c_handle,uint32_t status_flag,uint32_t timeout_ms,uint32_t start_tick)\n\n{\n  uint32_t elapsed_time;\n  char status_char;\n  uint status_value;\n  bool status_bool;\n  \n  do {\n    if ((status_flag >> 0x10 & 0xff) == 1) {\n      status_value = status_flag & ~i2c_handle->Instance->SR1 & 0xffff;\n      status_bool = status_value != 0;\n      if (status_bool) {\n        status_value = 1;\n      }\n      status_char = (char)status_value;\n      if (!status_bool) {\n        status_char = '\\0';\n      }\n    }\n    else {\n      status_value = status_flag & ~i2c_handle->Instance->SR2 & 0xffff;\n      status_bool = status_value != 0;\n      if (status_bool) {\n        status_value = 1;\n      }\n      status_char = (char)status_value;\n      if (!status_bool) {\n        status_char = '\\0';\n      }\n    }\n    if (status_char == '\\0') {\n      return HAL_OK;\n    }\n    if ((i2c_handle->Instance->SR1 & 0x400) == 0x400) {\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n      i2c_handle->Instance->SR1 = 0xfffffbff;\n      i2c_handle->ErrorCode = 4;\n      i2c_handle->PreviousState = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      return HAL_ERROR;\n    }\n  } while ((timeout_ms == 0xffffffff) ||\n          ((timeout_ms != 0 && (elapsed_time = HAL_GetTick(), elapsed_time - start_tick <= timeout_ms))));\n  i2c_handle->PreviousState = 0;\n  i2c_handle->State = HAL_I2C_STATE_READY;\n  i2c_handle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ad8",
            "calling": [
                "I2C_RequestMemoryRead",
                "I2C_RequestMemoryWrite"
            ],
            "imported": false,
            "current_name": "check_i2c_status_08002ad8"
        },
        "FUN_08000fd0": {
            "renaming": {
                "FUN_08000fd0": "concatenate_ints_08000fd0",
                "param_1": "first_int",
                "param_2": "second_int",
                "__cmpsf2": "compare_single_precision_floats",
                "CONCAT44": "concatenate_44_bits"
            },
            "code": "\nundefined8 concatenate_ints_08000fd0(undefined4 first_int,undefined4 second_int)\n\n{\n  compare_single_precision_floats();\n  return concatenate_44_bits(second_int,first_int);\n}\n\n",
            "called": [
                "__cmpsf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000fd0",
            "calling": [
                "__aeabi_cfrcmple",
                "__aeabi_fcmplt",
                "__aeabi_fcmple",
                "__aeabi_fcmpeq"
            ],
            "imported": false,
            "current_name": "concatenate_ints_08000fd0"
        },
        "FUN_08003d60": {
            "renaming": {
                "FUN_08003d60": "configure_timer_output_compare_08003d60",
                "TIMx": "timer",
                "OC_Config": "output_compare_config",
                "uVar1": "output_compare_mode",
                "uVar2": "output_compare_polarity",
                "tmpccmrx": "temporary_ccmrx",
                "tmpcr2": "temporary_cr2",
                "tmpccer": "temporary_ccer"
            },
            "code": "\nvoid configure_timer_output_compare_08003d60(TIM_TypeDef *timer,TIM_OC_InitTypeDef *output_compare_config)\n\n{\n  uint output_compare_mode;\n  uint32_t output_compare_polarity;\n  uint32_t temporary_ccmrx;\n  uint32_t temporary_cr2;\n  uint32_t temporary_ccer;\n  \n  timer->CCER = timer->CCER & 0xfffffffe;\n  temporary_cr2 = timer->CR2;\n  output_compare_mode = output_compare_config->OCMode;\n  output_compare_polarity = output_compare_config->OCPolarity | timer->CCER & 0xfffffffd;\n  if (timer == DAT_08003e34) {\n    output_compare_polarity = (output_compare_config->OCNPolarity | output_compare_polarity & 0xfffffff7) & 0xfffffffb;\n    temporary_cr2 = output_compare_config->OCNIdleState | output_compare_config->OCIdleState | temporary_cr2 & 0xfffffcff;\n  }\n  timer->CR2 = temporary_cr2;\n  timer->CCMR1 = output_compare_mode | timer->CCMR1 & 0xffffff8c;\n  timer->CCR1 = output_compare_config->Pulse;\n  timer->CCER = output_compare_polarity;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003d60",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_output_compare_08003d60"
        },
        "FUN_08009e68": {
            "renaming": {
                "FUN_08009e68": "get_evp_pkey_ctx_pointer_08009e68",
                "ctx": "EVP_PKEY_ctx_pointer"
            },
            "code": "\nint get_EVP_PKEY_CTX_pointer_08009e68(EVP_PKEY_CTX *EVP_PKEY_ctx_pointer)\n\n{\n  return (int)EVP_PKEY_ctx_pointer;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009e68",
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux",
                "frame_dummy"
            ],
            "imported": false,
            "current_name": "get_evp_pkey_ctx_pointer_08009e68"
        },
        "FUN_08001618": {
            "renaming": {
                "FUN_08001618": "set_interrupt_priority_08001618",
                "IRQn": "interrupt_number",
                "priority": "new_priority",
                "WWDG_IRQn": "watchdog_interrupt_number"
            },
            "code": "\nvoid set_interrupt_priority_08001618(interrupt_number_Type interrupt_number,uint32_t new_priority)\n\n{\n  if (interrupt_number < watchdog_interrupt_number) {\n    *(char *)(((byte)interrupt_number & 0xf) + DAT_08001664 + 0x14) = (char)((new_priority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interrupt_number + DAT_08001668 + 0x300) = (char)((new_priority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001618",
            "calling": [
                "HAL_NVIC_SetPriority",
                "SysTick_Config"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_08001618"
        },
        "FUN_080091a4": {
            "renaming": {
                "FUN_080091a4": "find_highest_bit_set_080091a4",
                "param_1": "input_number",
                "iVar1": "highest_bit_index"
            },
            "code": "\nint find_highest_bit_set_080091a4(uint input_number)\n\n{\n  int highest_bit_index;\n  \n  if ((input_number & 0xffff0000) == 0) {\n    input_number = input_number << 0x10;\n    highest_bit_index = 0x10;\n  }\n  else {\n    highest_bit_index = 0;\n  }\n  if ((input_number & 0xff000000) == 0) {\n    input_number = input_number << 8;\n    highest_bit_index = highest_bit_index + 8;\n  }\n  if ((input_number & 0xf0000000) == 0) {\n    input_number = input_number << 4;\n    highest_bit_index = highest_bit_index + 4;\n  }\n  if ((input_number & 0xc0000000) == 0) {\n    input_number = input_number << 2;\n    highest_bit_index = highest_bit_index + 2;\n  }\n  if (-1 < (int)input_number) {\n    if ((int)(input_number << 1) < 0) {\n      return highest_bit_index + 1;\n    }\n    highest_bit_index = 0x20;\n  }\n  return highest_bit_index;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091a4",
            "calling": [
                "_dtoa_r",
                "__d2b"
            ],
            "imported": false,
            "current_name": "find_highest_bit_set_080091a4"
        },
        "FUN_08004f78": {
            "renaming": {
                "FUN_08004f78": "flight_controller_08004f78",
                "htim": "timer_handler",
                "len": "string_length",
                "uVar1": "proportional_error",
                "iVar2": "comparison_result",
                "uVar3": "integral_error",
                "uVar4": "derivative_gain",
                "uVar5": "pitch_angle",
                "pid_pwm": "pid_output",
                "out_pwm": "output_pwm",
                "mpu6050_update": "update_mpu6050",
                "mpu6050_calc_pitch": "calculate_pitch_mpu6050",
                "flush_strbuf": "flush_string_buffer",
                "sprintf": "format_string",
                "uart_print": "print_uart",
                "HAL_GPIO_WritePin": "write_gpio_pin"
            },
            "code": "\nvoid flight_controller_08004f78(TIM_HandleTypeDef *timer_handler)\n\n{\n  size_t string_length;\n  undefined4 proportional_error;\n  int comparison_result;\n  undefined4 integral_error;\n  uint derivative_gain;\n  undefined8 pitch_angle;\n  float pid_output;\n  uint8_t output_pwm;\n  \n  update_mpu6050((Mpu6050 *)PTR_mpu6050_080051e0);\n  calculate_pitch_mpu6050((Mpu6050 *)PTR_mpu6050_080051e0,(float *)PTR_pitch_080051e4);\n  flush_string_buffer();\n  pitch_angle = __aeabi_f2d(*(undefined4 *)PTR_pitch_080051e4);\n  format_string(PTR_strbuf_080051ec,PTR_s_Pitch___f_080051e8,(int)pitch_angle,(int)((ulonglong)pitch_angle >> 0x20));\n  string_length = strstring_length(PTR_strbuf_080051ec);\n  print_uart(PTR_strbuf_080051ec,string_length);\n  proportional_error = __aeabi_fsub(*(undefined4 *)PTR_setpoint_080051f0,*(undefined4 *)PTR_pitch_080051e4);\n  *(undefined4 *)PTR_error_080051f4 = proportional_error;\n  proportional_error = __aeabi_fmul(*(undefined4 *)PTR_Kp_080051f8,*(undefined4 *)PTR_error_080051f4);\n  *(undefined4 *)PTR_P_080051fc = proportional_error;\n  proportional_error = __aeabi_fmul(*(undefined4 *)PTR_Ki_08005200,*(undefined4 *)PTR_error_080051f4);\n  proportional_error = __addsf3(proportional_error,*(undefined4 *)PTR_I_08005204);\n  *(undefined4 *)PTR_I_08005204 = proportional_error;\n  proportional_error = __floatsisf(*PTR_maxPwm_08005208);\n  comparison_result = __aeabi_fcmplt(proportional_error,*(undefined4 *)PTR_I_08005204);\n  if (comparison_result == 0) {\n    proportional_error = __floatsisf(*PTR_minPwm_0800520c);\n    comparison_result = __aeabi_fcmpgt(proportional_error,*(undefined4 *)PTR_I_08005204);\n    if (comparison_result != 0) {\n      proportional_error = __floatunsisf(*PTR_minPwm_0800520c);\n      *(undefined4 *)PTR_I_08005204 = proportional_error;\n    }\n  }\n  else {\n    proportional_error = __floatunsisf(*PTR_maxPwm_08005208);\n    *(undefined4 *)PTR_I_08005204 = proportional_error;\n  }\n  derivative_gain = *(uint *)PTR_Kd_08005210;\n  proportional_error = __aeabi_fsub(*(undefined4 *)PTR_error_080051f4,*(undefined4 *)PTR_lastError_08005214);\n  proportional_error = __aeabi_fmul(derivative_gain ^ 0x80000000,proportional_error);\n  *(undefined4 *)PTR_D_08005218 = proportional_error;\n  proportional_error = __addsf3(*(undefined4 *)PTR_P_080051fc,*(undefined4 *)PTR_I_08005204);\n  proportional_error = __addsf3(proportional_error,*(undefined4 *)PTR_D_08005218);\n  integral_error = __floatsisf(*PTR_maxPwm_08005208);\n  comparison_result = __aeabi_fcmpgt(proportional_error,integral_error);\n  if (comparison_result == 0) {\n    integral_error = __floatsisf(*PTR_minPwm_0800520c);\n    comparison_result = __aeabi_fcmplt(proportional_error,integral_error);\n    if (comparison_result == 0) {\n      output_pwm = __fixunssfsi(proportional_error);\n    }\n    else {\n      output_pwm = *PTR_minPwm_0800520c;\n    }\n  }\n  else {\n    output_pwm = *PTR_maxPwm_08005208;\n  }\n  *(undefined4 *)PTR_lastError_08005214 = *(undefined4 *)PTR_error_080051f4;\n  comparison_result = __aeabi_fcmpgt(*(undefined4 *)PTR_error_080051f4,0);\n  write_gpio_pin(DAT_0800521c,2,comparison_result != 0);\n  comparison_result = __aeabi_fcmpgt(*(undefined4 *)PTR_error_080051f4,0);\n  write_gpio_pin(DAT_0800521c,4,comparison_result == 0);\n  comparison_result = __aeabi_fcmpgt(*(undefined4 *)PTR_error_080051f4,0);\n  write_gpio_pin(DAT_0800521c,8,comparison_result != 0);\n  comparison_result = __aeabi_fcmpgt(*(undefined4 *)PTR_error_080051f4,0);\n  write_gpio_pin(DAT_0800521c,0x10,comparison_result == 0);\n  *(uint *)(*(int *)PTR_timer_handler1_08005220 + 0x34) = (uint)output_pwm;\n  *(uint *)(*(int *)PTR_timer_handler1_08005220 + 0x40) = (uint)output_pwm;\n  return;\n}\n\n",
            "called": [
                "sprintf",
                "__aeabi_fcmplt",
                "uart_print",
                "strlen",
                "HAL_GPIO_WritePin",
                "mpu6050_update",
                "__fixunssfsi",
                "__aeabi_fcmpgt",
                "__floatsisf",
                "__aeabi_fmul",
                "__floatunsisf",
                "__addsf3",
                "__aeabi_f2d",
                "__aeabi_fsub",
                "flush_strbuf",
                "mpu6050_calc_pitch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f78",
            "calling": [
                "HAL_TIM_IRQHandler",
                "HAL_SYSTICK_IRQHandler"
            ],
            "imported": false,
            "current_name": "flight_controller_08004f78"
        },
        "FUN_080015a0": {
            "renaming": {
                "FUN_080015a0": "get_uw_tick_value_080015a0"
            },
            "code": "\nuint32_t get_uwTick_value_080015a0(void)\n\n{\n  return *(uint32_t *)PTR_uwTick_080015b0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015a0",
            "calling": [
                "I2C_WaitOnBTFFlagUntilTimeout",
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Write",
                "HAL_I2C_Mem_Read",
                "I2C_RequestMemoryWrite",
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig",
                "HAL_UART_Transmit",
                "_get_ms_tick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout"
            ],
            "imported": false,
            "current_name": "get_uw_tick_value_080015a0"
        },
        "FUN_08002d98": {
            "renaming": {
                "FUN_08002d98": "configure_rcc_oscillator_08002d98",
                "RCC_OscInitStruct": "oscillator_config",
                "uVar1": "start_tick",
                "uVar2": "current_tick",
                "HVar3": "status",
                "bVar4": "is_LSE_off",
                "tmpreg": "temporary_register",
                "tickstart": "start_tick",
                "pwrclkchanged": "power_clock_changed",
                "HAL_StatusTypeDef": "status_t",
                "RCC_OscInitTypeDef": "oscillator_config_t",
                "FlagStatus": "flag_status_t"
            },
            "code": "\nstatus_t configure_RCC_Oscillator_08002d98(oscillator_config_t *oscillator_config)\n\n{\n  uint32_t start_tick;\n  uint32_t current_tick;\n  status_t status;\n  bool is_LSE_off;\n  uint32_t temporary_register;\n  uint32_t start_tick;\n  flag_status_t power_clock_changed;\n  \n  if ((oscillator_config->OscillatorType & 1) != 0) {\n    if (((DAT_08002ffc[1] & 0xc) == 4) ||\n       (((DAT_08002ffc[1] & 0xc) == 8 && ((DAT_08002ffc[1] & 0x10000) == 0x10000)))) {\n      if (((*DAT_08002ffc & 0x20000) != 0) && (oscillator_config->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (oscillator_config->HSEState == 0x10000) {\n        *DAT_08002ffc = *DAT_08002ffc | 0x10000;\n      }\n      else if (oscillator_config->HSEState == 0) {\n        *DAT_08002ffc = *DAT_08002ffc & 0xfffeffff;\n        *DAT_08002ffc = *DAT_08002ffc & 0xfffbffff;\n      }\n      else if (oscillator_config->HSEState == 0x50000) {\n        *DAT_08002ffc = *DAT_08002ffc | 0x40000;\n        *DAT_08002ffc = *DAT_08002ffc | 0x10000;\n      }\n      else {\n        *DAT_08002ffc = *DAT_08002ffc & 0xfffeffff;\n        *DAT_08002ffc = *DAT_08002ffc & 0xfffbffff;\n      }\n      if (oscillator_config->HSEState == 0) {\n        start_tick = HAL_GetTick();\n        while ((*DAT_08002ffc & 0x20000) != 0) {\n          current_tick = HAL_GetTick();\n          if (100 < current_tick - start_tick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        start_tick = HAL_GetTick();\n        while ((*DAT_08002ffc & 0x20000) == 0) {\n          current_tick = HAL_GetTick();\n          if (100 < current_tick - start_tick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscillator_config->OscillatorType & 2) != 0) {\n    if (((DAT_08002ffc[1] & 0xc) == 0) ||\n       (((DAT_08002ffc[1] & 0xc) == 8 && ((DAT_08002ffc[1] & 0x10000) == 0)))) {\n      if (((*DAT_08002ffc & 2) != 0) && (oscillator_config->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      *DAT_08002ffc = oscillator_config->HSICalibrationValue << 3 | *DAT_08002ffc & 0xffffff07;\n    }\n    else if (oscillator_config->HSIState == 0) {\n      *DAT_08003000 = 0;\n      start_tick = HAL_GetTick();\n      while ((*DAT_08002ffc & 2) != 0) {\n        current_tick = HAL_GetTick();\n        if (2 < current_tick - start_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08003000 = 1;\n      start_tick = HAL_GetTick();\n      while ((*DAT_08002ffc & 2) == 0) {\n        current_tick = HAL_GetTick();\n        if (2 < current_tick - start_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_08002ffc = oscillator_config->HSICalibrationValue << 3 | *DAT_08002ffc & 0xffffff07;\n    }\n  }\n  if ((oscillator_config->OscillatorType & 8) != 0) {\n    if (oscillator_config->LSIState == 0) {\n      *DAT_08003004 = 0;\n      start_tick = HAL_GetTick();\n      while ((DAT_08003254[9] & 2) != 0) {\n        current_tick = HAL_GetTick();\n        if (2 < current_tick - start_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08003004 = 1;\n      start_tick = HAL_GetTick();\n      while ((DAT_08002ffc[9] & 2) == 0) {\n        current_tick = HAL_GetTick();\n        if (2 < current_tick - start_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((oscillator_config->OscillatorType & 4) != 0) {\n    is_LSE_off = (DAT_08003254[7] & 0x10000000) == 0;\n    if (is_LSE_off) {\n      DAT_08003254[7] = DAT_08003254[7] | 0x10000000;\n    }\n    if ((*DAT_08003258 & 0x100) == 0) {\n      *DAT_08003258 = *DAT_08003258 | 0x100;\n      start_tick = HAL_GetTick();\n      while ((*DAT_08003258 & 0x100) == 0) {\n        current_tick = HAL_GetTick();\n        if (100 < current_tick - start_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (oscillator_config->LSEState == 1) {\n      DAT_08003254[8] = DAT_08003254[8] | 1;\n    }\n    else if (oscillator_config->LSEState == 0) {\n      DAT_08003254[8] = DAT_08003254[8] & 0xfffffffe;\n      DAT_08003254[8] = DAT_08003254[8] & 0xfffffffb;\n    }\n    else if (oscillator_config->LSEState == 5) {\n      DAT_08003254[8] = DAT_08003254[8] | 4;\n      DAT_08003254[8] = DAT_08003254[8] | 1;\n    }\n    else {\n      DAT_08003254[8] = DAT_08003254[8] & 0xfffffffe;\n      DAT_08003254[8] = DAT_08003254[8] & 0xfffffffb;\n    }\n    if (oscillator_config->LSEState == 0) {\n      start_tick = HAL_GetTick();\n      while ((DAT_08003254[8] & 2) != 0) {\n        current_tick = HAL_GetTick();\n        if (5000 < current_tick - start_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      start_tick = HAL_GetTick();\n      while ((DAT_08003254[8] & 2) == 0) {\n        current_tick = HAL_GetTick();\n        if (5000 < current_tick - start_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (is_LSE_off) {\n      DAT_08003254[7] = DAT_08003254[7] & 0xefffffff;\n    }\n  }\n  if ((oscillator_config->PLL).PLLState == 0) {\nLAB_0800324a:\n    status = HAL_OK;\n  }\n  else if ((DAT_08003254[1] & 0xc) == 8) {\n    status = HAL_ERROR;\n  }\n  else if ((oscillator_config->PLL).PLLState == 2) {\n    *DAT_0800325c = 0;\n    start_tick = HAL_GetTick();\n    do {\n      if ((*DAT_08003254 & 0x2000000) == 0) {\n        if ((oscillator_config->PLL).PLLSource == 0x10000) {\n          DAT_08003254[1] = oscillator_config->HSEPredivValue | DAT_08003254[1] & 0xfffdffff;\n        }\n        DAT_08003254[1] =\n             (oscillator_config->PLL).PLLMUL | (oscillator_config->PLL).PLLSource |\n             DAT_08003254[1] & 0xffc2ffff;\n        *DAT_0800325c = 1;\n        start_tick = HAL_GetTick();\n        while ((*DAT_08003254 & 0x2000000) == 0) {\n          current_tick = HAL_GetTick();\n          if (2 < current_tick - start_tick) {\n            return HAL_TIMEOUT;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      current_tick = HAL_GetTick();\n    } while (current_tick - start_tick < 3);\n    status = HAL_TIMEOUT;\n  }\n  else {\n    *DAT_0800325c = 0;\n    start_tick = HAL_GetTick();\n    do {\n      if ((*DAT_08003254 & 0x2000000) == 0) goto LAB_0800324a;\n      current_tick = HAL_GetTick();\n    } while (current_tick - start_tick < 3);\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d98",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configure_rcc_oscillator_08002d98"
        },
        "FUN_0800172a": {
            "renaming": {
                "FUN_0800172a": "set_irq_priority_0800172a",
                "IRQn": "irq_number",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "uVar1": "priority_encoding",
                "prioritygroup": "priority_group",
                "NVIC_GetPriorityGrouping": "get_priority_grouping",
                "NVIC_EncodePriority": "encode_priority",
                "NVIC_SetPriority": "set_priority"
            },
            "code": "\nvoid set_irq_priority_0800172a(irq_number_Type irq_number,uint32_t preempt_priority,uint32_t sub_priority)\n\n{\n  uint32_t priority_encoding;\n  uint32_t priority_group;\n  \n  priority_encoding = get_priority_grouping();\n  priority_encoding = encode_priority(priority_encoding,preempt_priority,sub_priority);\n  set_priority(irq_number,priority_encoding);\n  return;\n}\n\n",
            "called": [
                "NVIC_GetPriorityGrouping",
                "NVIC_SetPriority",
                "NVIC_EncodePriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800172a",
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_irq_priority_0800172a"
        },
        "FUN_080009d4": {
            "renaming": {
                "FUN_080009d4": "compare_floats_080009d4",
                "in_ZR": "is_less_than",
                "in_CY": "is_greater_than_or_equal_to"
            },
            "code": "\nbool compare_floats_080009d4(void)\n\n{\n  undefined is_less_than;\n  undefined is_greater_than_or_equal_to;\n  \n  __aeabi_cdrcmple();\n  return !(bool)is_greater_than_or_equal_to || (bool)is_less_than;\n}\n\n",
            "called": [
                "__aeabi_cdrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009d4",
            "calling": [
                "_dtoa_r"
            ],
            "imported": false,
            "current_name": "compare_floats_080009d4"
        },
        "FUN_08009744": {
            "renaming": {
                "FUN_08009744": "allocate_memory_08009744",
                "param_1": "error_code",
                "param_2": "size",
                "puVar1": "errno_pointer",
                "pcVar2": "memory_pointer"
            },
            "code": "\nvoid allocate_memory_08009744(int *error_code,int size)\n\n{\n  undefined *errno_pointer;\n  caddr_t memory_pointer;\n  \n  errno_pointer = PTR_errno_08009764;\n  *(undefined4 *)PTR_errno_08009764 = 0;\n  memory_pointer = _sbrk(size);\n  if ((memory_pointer == (caddr_t)0xffffffff) && (*(int *)errno_pointer != 0)) {\n    *error_code = *(int *)errno_pointer;\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "_sbrk"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009744",
            "calling": [
                "_malloc_trim_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009744"
        },
        "FUN_08003640": {
            "renaming": {
                "FUN_08003640": "configure_timer_08003640",
                "htim": "timer_handle",
                "HVar1": "status",
                "HAL_ERROR": "error",
                "HAL_TIM_STATE_RESET": "reset_state",
                "HAL_UNLOCKED": "unlocked",
                "HAL_TIM_STATE_BUSY": "busy_state",
                "HAL_TIM_STATE_READY": "ready_state",
                "HAL_OK": "ok",
                "HAL_TIM_PWM_MspInit": "initialize_pwm",
                "TIM_Base_SetConfig": "set_timer_config"
            },
            "code": "\nHAL_StatusTypeDef configure_timer_08003640(TIM_HandleTypeDef *timer_handle)\n\n{\n  HAL_StatusTypeDef status;\n  \n  if (timer_handle == (TIM_HandleTypeDef *)0x0) {\n    status = error;\n  }\n  else {\n    if (timer_handle->State == reset_state) {\n      timer_handle->Lock = unlocked;\n      initialize_pwm(timer_handle);\n    }\n    timer_handle->State = busy_state;\n    set_timer_config(timer_handle->Instance,&timer_handle->Init);\n    timer_handle->State = ready_state;\n    status = ok;\n  }\n  return status;\n}\n\n",
            "called": [
                "TIM_Base_SetConfig",
                "HAL_TIM_PWM_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003640",
            "calling": [
                "MX_TIM1_Init"
            ],
            "imported": false,
            "current_name": "configure_timer_08003640"
        },
        "FUN_08009980": {
            "renaming": {
                "FUN_08009980": "allocate_and_initialize_memory_08009980",
                "param_1": "size",
                "param_2": "num_elements",
                "param_3": "element_size",
                "__s": "allocated_memory",
                "__n": "allocated_size",
                "puVar1": "initialized_memory"
            },
            "code": "\nundefined4 * allocate_and_initialize_memory_08009980(undefined4 size,int num_elements,int element_size)\n\n{\n  undefined4 *allocated_memory;\n  size_t allocated_size;\n  undefined4 *initialized_memory;\n  \n  allocated_memory = (undefined4 *)_malloc_r(size,element_size * num_elements);\n  if (allocated_memory == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  allocated_size = (allocated_memory[-1] & 0xfffffffc) - 4;\n  if (allocated_size < 0x25) {\n    initialized_memory = allocated_memory;\n    if (0x13 < allocated_size) {\n      *allocated_memory = 0;\n      allocated_memory[1] = 0;\n      if (0x1b < allocated_size) {\n        allocated_memory[2] = 0;\n        allocated_memory[3] = 0;\n        if (allocated_size == 0x24) {\n          allocated_memory[4] = 0;\n          allocated_memory[5] = 0;\n          initialized_memory = allocated_memory + 6;\n        }\n        else {\n          initialized_memory = allocated_memory + 4;\n        }\n        *initialized_memory = 0;\n        initialized_memory[1] = 0;\n        initialized_memory[2] = 0;\n        return allocated_memory;\n      }\n      initialized_memory = allocated_memory + 2;\n    }\n    *initialized_memory = 0;\n    initialized_memory[1] = 0;\n    initialized_memory[2] = 0;\n    return allocated_memory;\n  }\n  memset(allocated_memory,0,allocated_size);\n  return allocated_memory;\n}\n\n",
            "called": [
                "_malloc_r",
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009980",
            "calling": [
                "_Balloc"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_memory_08009980"
        },
        "FUN_08005e9c": {
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n/* WARNING: Could not reconcile some variable overlaps */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  undefined *puVar2;\n  int **ppiVar3;\n  int *piVar4;\n  int iVar5;\n  int iVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  byte *pbVar9;\n  char cVar10;\n  byte bVar11;\n  int *piVar12;\n  int **ppiVar13;\n  undefined uVar14;\n  ushort uVar15;\n  int *__s;\n  int **ppiVar16;\n  byte **ppbVar17;\n  int *piVar18;\n  int *piVar19;\n  int **ppiVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *pbVar23;\n  int *piVar24;\n  uint uVar25;\n  uint uVar26;\n  int *piVar27;\n  int *piVar28;\n  byte *pbVar29;\n  bool bVar30;\n  longlong lVar31;\n  undefined8 uVar32;\n  undefined8 uVar33;\n  undefined4 in_stack_fffffe78;\n  int *in_stack_fffffe7c;\n  int *local_168;\n  byte *local_164;\n  int *local_15c;\n  int *local_158;\n  int **local_154;\n  int *local_150;\n  int *local_148;\n  int *local_144;\n  uint local_140;\n  int *local_13c;\n  int *local_138;\n  int *local_134;\n  int *local_130;\n  int *local_12c;\n  int *local_128;\n  undefined *local_11c;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0 [2];\n  undefined4 local_e8;\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int local_d4;\n  byte *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  ppiVar3 = (int **)_localeconv_r();\n  __s = *ppiVar3;\n  piVar4 = (int *)strlen((char *)__s);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar5 = _malloc_r(param_1,0x40);\n    *param_2 = iVar5;\n    param_2[4] = iVar5;\n    if (iVar5 == 0) {\n      *param_1 = 0xc;\n      return (byte *)0xffffffff;\n    }\n    param_2[5] = 0x40;\n  }\n  local_128 = (int *)0x0;\n  local_138 = (int *)0x0;\n  local_12c = (int *)0x0;\n  local_d4 = 0;\n  local_d0 = (byte *)0x0;\n  local_11c = (undefined *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  ppiVar3 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar3;\n  local_154 = param_4;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = local_d4 + 1;\n        local_d0 = (byte *)((int)local_d0 + (int)piVar27);\n        *ppiVar3 = param_3;\n        *(int **)((int)ppiVar3 + 4) = piVar27;\n        if (local_d4 < 8) {\n          ppiVar3 = (int **)((int)ppiVar3 + 8);\n        }\n        else {\n          iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar5 != 0) goto LAB_0800604a;\n          ppiVar3 = local_cc;\n        }\n        local_164 = (byte *)((int)local_164 + (int)piVar27);\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    uVar26 = 0;\n    uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    local_158 = piVar27;\n    local_168 = piVar27;\n    switch(uVar25) {\n    case 0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (uVar25 == 0) goto LAB_08006216;\n      piVar18 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = (int *)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_158 = (int *)0x1;\n      param_3 = (int *)&local_8c;\n      local_144 = piVar18;\n      local_8c = (char)uVar25;\n      goto LAB_08006298;\n    case 0x23:\n      uVar26 = uVar26 | 1;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x27:\n      iVar5 = _localeconv_r(param_1);\n      local_110 = *(int **)(iVar5 + 4);\n      local_104 = (int *)strlen((char *)local_110);\n      iVar5 = _localeconv_r(param_1);\n      local_108 = *(byte **)(iVar5 + 8);\n      if (local_104 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      uVar25 = (uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        uVar26 = uVar26 | 0x400;\n      }\n      goto LAB_08005f4a;\n    case 0x2a:\n      uVar25 = (uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case 0x2b:\n      local_f5 = 0x2b;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x2d:\n      uVar25 = (uint)*(byte *)piVar28;\nLAB_08006602:\n      uVar26 = uVar26 | 4;\n      goto LAB_08005f4a;\n    case 0x2e:\n      uVar25 = (uint)*(byte *)piVar28;\n      if (uVar25 == 0x2a) {\n        uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (uVar25 - 0x30 < 10) {\n        piVar27 = (int *)((uVar25 - 0x30) + (int)piVar27 * 10);\n        uVar25 = (uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case 0x30:\n      uVar26 = uVar26 | 0x80;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_08005f58_caseD_31;\n    case 0x41:\n    case 0x45:\n    case 0x46:\n    case 0x47:\n    case 0x61:\n    case 0x65:\n    case 0x66:\n    case 0x67:\n      local_154 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      local_128 = *local_154;\n      local_12c = local_154[1];\n      local_154 = local_154 + 2;\n      iVar5 = __unorddf2(local_128,(uint)local_12c & 0x7fffffff,0xffffffff,DAT_08006724);\n      if ((iVar5 == 0) &&\n         (iVar5 = __aeabi_dcmple(local_128,(uint)local_12c & 0x7fffffff,0xffffffff,DAT_08006724),\n         iVar5 == 0)) {\n        iVar5 = __aeabi_dcmplt(local_128,local_12c,0,0);\n        param_3 = (int *)PTR_DAT_08006728;\n        piVar27 = (int *)PTR_DAT_0800672c;\n        if (iVar5 == 0) {\n          piVar18 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar18 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (uVar25 < 0x48) {\n          param_3 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        local_158 = (int *)0x3;\n        local_13c = (int *)0x0;\n        local_140 = uVar26 & 0xffffff7f;\n        local_144 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      local_148 = (int *)__unorddf2(local_128,local_12c,local_128,local_12c);\n      if (local_148 != (int *)0x0) {\n        param_3 = (int *)PTR_DAT_08007898;\n        piVar27 = (int *)PTR_DAT_0800789c;\n        if ((int)local_12c < 0) {\n          piVar18 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar18 = (int *)(uint)local_f5;\n        }\n        goto LAB_08006524;\n      }\n      piVar18 = local_12c;\n      piVar24 = piVar27;\n      if (uVar25 == 0x61) {\n        uVar14 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar14,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = uVar26 | 0x102;\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          uVar26 = uVar26 | 2;\n        }\n        else {\n          param_3 = (int *)_malloc_r(param_1,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar15 = *(ushort *)(param_2 + 3) | 0x40;\n            *(ushort *)(param_2 + 3) = uVar15;\n            goto LAB_0800604e;\n          }\n          local_140 = uVar26 | 0x102;\n          uVar26 = uVar26 | 2;\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        piVar27 = piVar24;\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = (int *)0x2d;\n          piVar18 = local_12c + -0x20000000;\n          piVar24 = piVar27;\n        }\n        else {\n          local_144 = (int *)0x0;\n        }\n        if (uVar25 == 0x61) {\n          frexp((double)CONCAT44(in_stack_fffffe7c,in_stack_fffffe78),local_128);\n          uVar32 = __muldf3();\n          iVar5 = __aeabi_dcmpeq((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,0);\n          if (iVar5 != 0) {\n            local_f0[0] = (int *)0x1;\n          }\n          local_158 = (int *)PTR_s_0123456789abcdef_08007888;\n          local_138 = param_3;\n          piVar27 = piVar24;\n          goto LAB_080072ba;\n        }\n        if (uVar25 == 0x41) {\n          frexp((double)CONCAT44(in_stack_fffffe7c,in_stack_fffffe78),local_128);\n          uVar32 = __muldf3();\n          iVar5 = __aeabi_dcmpeq((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,0);\n          if (iVar5 == 0) {\n            local_158 = (int *)PTR_s_0123456789ABCDEF_0800739c;\n            local_138 = param_3;\n            piVar27 = piVar24;\n          }\n          else {\n            local_f0[0] = (int *)0x1;\n            local_158 = (int *)PTR_s_0123456789ABCDEF_08007894;\n            local_138 = param_3;\n            piVar27 = piVar24;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (uVar25 == 0x41) {\n          uVar14 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = uVar26 | 0x100;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar24 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if ((uVar25 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar24 = (int *)0x1;\n            local_148 = piVar27;\n          }\n          goto LAB_0800724a;\n        }\n        local_144 = local_148;\n        if ((int)local_12c < 0) goto LAB_08007414;\n      }\n      local_168 = (int *)(uVar25 & 0xffffffdf);\n      in_stack_fffffe7c = piVar24;\n      local_150 = piVar24;\n      if (uVar25 == 0x66) {\n        in_stack_fffffe78 = 3;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar18);\n        piVar27 = (int *)((int)param_3 + (int)piVar24);\nLAB_0800764c:\n        if ((*(byte *)param_3 == 0x30) &&\n           (iVar5 = __aeabi_dcmpeq(local_128,piVar18,0,0), iVar5 == 0)) {\n          local_f0[0] = (int *)(1 - (int)local_150);\n        }\n        piVar27 = (int *)((int)piVar27 + (int)local_f0[0]);\n      }\n      else if (uVar25 == 0x46) {\n        in_stack_fffffe78 = 3;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar18);\nLAB_08007760:\n        piVar27 = (int *)((int)param_3 + (int)local_150);\n        if (uVar25 == 0x46) goto LAB_0800764c;\n      }\n      else {\n        if (local_168 == (int *)0x45) {\n          local_150 = (int *)((int)piVar24 + 1);\n        }\n        in_stack_fffffe78 = 2;\n        in_stack_fffffe7c = local_150;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar18);\n        local_138 = local_e0;\n        if (uVar25 == 0x67) {\n          if ((uVar26 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (uVar25 == 0x47) {\n          if ((uVar26 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar27 = (int *)((int)local_150 + (int)param_3);\n      }\n      iVar5 = __aeabi_dcmpeq(local_128,piVar18,0,0);\n      local_138 = piVar27;\n      if (iVar5 == 0) {\n        for (; local_138 = local_e0, local_e0 < piVar27; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)local_138 - (int)param_3);\n      goto LAB_08006cb0;\n    case 0x43:\n    case 99:\n      piVar18 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_144 = (int *)0x0;\n      local_13c = (int *)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (int *)0x1;\n      local_8c = SUB41(piVar27,0);\n      param_3 = (int *)&local_8c;\n      goto LAB_08006298;\n    case 0x44:\n      uVar26 = uVar26 | 0x10;\n      if ((int)(uVar26 << 0x1a) < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar16 = local_154 + 1;\n      if ((int)(uVar26 << 0x1b) < 0) {\nLAB_08006bcc:\n        piVar18 = *local_154;\n        piVar24 = (int *)((int)piVar18 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      else if ((int)(uVar26 << 0x19) < 0) {\n        piVar18 = (int *)(int)*(short *)local_154;\n        piVar24 = (int *)((int)piVar18 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      else {\n        if (-1 < (int)(uVar26 << 0x16)) goto LAB_08006bcc;\n        piVar18 = (int *)(int)*(char *)local_154;\n        piVar24 = (int *)((int)piVar18 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      goto LAB_08006102;\n    case 0x4c:\n      uVar26 = uVar26 | 8;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x4f:\n      uVar26 = uVar26 | 0x10;\n    case 0x6f:\n      if ((uVar26 & 0x20) == 0) {\n        ppiVar16 = local_154 + 1;\n        if ((uVar26 & 0x10) == 0) {\n          if ((uVar26 & 0x40) == 0) {\n            if ((uVar26 & 0x200) == 0) goto LAB_08006be2;\n            piVar18 = (int *)(uint)*(byte *)local_154;\n            piVar24 = (int *)0x0;\n            local_154 = ppiVar16;\n          }\n          else {\n            piVar18 = (int *)(uint)*(ushort *)local_154;\n            piVar24 = (int *)0x0;\n            local_154 = ppiVar16;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar18 = *local_154;\n          piVar24 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n      }\n      else {\n        ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar18 = *ppiVar16;\n        piVar24 = ppiVar16[1];\n        local_154 = ppiVar16 + 2;\n      }\n      iVar5 = 0;\n      uVar26 = uVar26 & 0xfffffbff;\n      break;\n    case 0x53:\n    case 0x73:\n      local_f5 = 0;\n      local_144 = *local_154;\n      local_154 = local_154 + 1;\n      local_140 = uVar26;\n      if (local_144 == (int *)0x0) {\n        piVar18 = local_144;\n        param_3 = (int *)PTR_s__null__08007084;\n        local_148 = local_144;\n        local_13c = local_144;\n        local_134 = local_144;\n        local_130 = local_144;\n        if ((int *)0x5 < piVar27) {\n          local_158 = (int *)0x6;\n          local_168 = local_158;\n        }\n        goto LAB_08006538;\n      }\n      param_3 = local_144;\n      if (piVar27 == (int *)0xffffffff) {\n        local_158 = (int *)strlen((char *)local_144);\n      }\n      else {\n        local_148 = (int *)memchr(local_144,0,(size_t)piVar27);\n        if (local_148 == (int *)0x0) {\n          piVar18 = (int *)(uint)local_f5;\n          local_144 = local_148;\n          local_13c = local_148;\n          local_134 = local_148;\n          local_130 = local_148;\n          goto LAB_08006538;\n        }\n        local_158 = (int *)((int)local_148 - (int)local_144);\n      }\n      local_148 = (int *)0x0;\n      local_13c = (int *)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      piVar18 = (int *)(uint)local_f5;\n      local_144 = (int *)0x0;\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      goto LAB_08006538;\n    case 0x55:\n      uVar26 = uVar26 | 0x10;\n      if ((int)(uVar26 << 0x1a) < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar16 = local_154 + 1;\n      if ((int)(uVar26 << 0x1b) < 0) {\nLAB_08006bf2:\n        piVar18 = *local_154;\n        piVar24 = (int *)0x0;\n        iVar5 = 1;\n        local_154 = ppiVar16;\n      }\n      else if ((int)(uVar26 << 0x19) < 0) {\n        piVar18 = (int *)(uint)*(ushort *)local_154;\n        piVar24 = (int *)0x0;\n        iVar5 = 1;\n        local_154 = ppiVar16;\n      }\n      else {\n        if (-1 < (int)(uVar26 << 0x16)) goto LAB_08006bf2;\n        piVar18 = (int *)(uint)*(byte *)local_154;\n        piVar24 = (int *)0x0;\n        iVar5 = 1;\n        local_154 = ppiVar16;\n      }\n      break;\n    case 0x58:\n      local_11c = PTR_s_0123456789ABCDEF_08006730;\n      if ((uVar26 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar16 = local_154 + 1;\n      if ((uVar26 & 0x10) == 0) {\n        if ((uVar26 & 0x40) == 0) {\n          if ((uVar26 & 0x200) == 0) goto LAB_08006bbc;\n          piVar18 = (int *)(uint)*(byte *)local_154;\n          piVar24 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n        else {\n          piVar18 = (int *)(uint)*(ushort *)local_154;\n          piVar24 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar18 = *local_154;\n        piVar24 = (int *)0x0;\n        local_154 = ppiVar16;\n      }\n      goto LAB_080061be;\n    case 100:\n    case 0x69:\n      if (-1 < (int)(uVar26 << 0x1a)) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar18 = *ppiVar16;\n      piVar24 = ppiVar16[1];\n      local_154 = ppiVar16 + 2;\nLAB_08006102:\n      if ((int)piVar24 < 0) {\n        bVar30 = piVar18 != (int *)0x0;\n        piVar18 = (int *)-(int)piVar18;\n        piVar24 = (int *)(-(int)piVar24 - (uint)bVar30);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar5 = 1;\n        iVar6 = 1;\n        local_140 = uVar26 & 0xffffff7f;\n        if (((uint)piVar18 | (uint)piVar24) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      local_140 = uVar26;\n      if (piVar24 != (int *)0x0 || (int *)0x9 < piVar18) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case 0x68:\n      uVar25 = (uint)*(byte *)piVar28;\n      if (uVar25 == 0x68) {\n        uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n        uVar26 = uVar26 | 0x200;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        uVar26 = uVar26 | 0x40;\n      }\n      goto LAB_08005f4a;\n    case 0x6a:\n    case 0x71:\n      uVar26 = uVar26 | 0x20;\n    case 0x74:\n    case 0x7a:\nswitchD_08005f58_caseD_74:\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case 0x6e:\n      ppiVar16 = local_154 + 1;\n      ppbVar17 = (byte **)*local_154;\n      local_154 = ppiVar16;\n      if ((uVar26 & 0x20) != 0) {\n        *ppbVar17 = local_164;\n        ppbVar17[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if ((uVar26 & 0x10) == 0) {\n        if ((uVar26 & 0x40) != 0) {\n          *(short *)ppbVar17 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if ((uVar26 & 0x200) != 0) {\n          *(char *)ppbVar17 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar17 = local_164;\n      goto LAB_0800620e;\n    case 0x70:\n      local_f4 = 0x7830;\n      local_11c = PTR_s_0123456789abcdef_08006434;\n      piVar18 = *local_154;\n      uVar26 = uVar26 | 2;\n      piVar24 = (int *)0x0;\n      iVar5 = 2;\n      uVar25 = 0x78;\n      local_154 = local_154 + 1;\n      break;\n    case 0x75:\n      if (-1 < (int)(uVar26 << 0x1a)) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar18 = *ppiVar16;\n      piVar24 = ppiVar16[1];\n      iVar5 = 1;\n      local_154 = ppiVar16 + 2;\n      break;\n    case 0x78:\n      local_11c = PTR_s_0123456789abcdef_08006434;\n      if ((uVar26 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar18 = *ppiVar16;\n      piVar24 = ppiVar16[1];\n      local_154 = ppiVar16 + 2;\nLAB_080061be:\n      if (((uVar26 & 1) != 0) && (((uint)piVar18 | (uint)piVar24) != 0)) {\n        uVar26 = uVar26 | 2;\n        local_f4 = CONCAT11((char)uVar25,0x30);\n      }\n      iVar5 = 2;\n      uVar26 = uVar26 & 0xfffffbff;\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      local_140 = uVar26;\n      if (iVar5 != 1) goto LAB_08006136;\nLAB_08006980:\n      local_140 = uVar26;\n      if (piVar24 == (int *)0x0 && piVar18 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar31 = CONCAT44(piVar24,piVar18);\n      local_138 = (int *)0x0;\n      param_3 = (int *)(&bStack_2a + 2);\n      do {\n        iVar5 = (int)((ulonglong)lVar31 >> 0x20);\n        uVar26 = (uint)lVar31;\n        cVar10 = '\\n';\n        __aeabi_uldivmod(uVar26,iVar5,10,0);\n        *(byte *)((int)param_3 + -1) = cVar10 + 0x30;\n        local_138 = (int *)((int)local_138 + 1);\n        param_3 = (int *)((int)param_3 + -1);\n        if (((((local_140 & 0x400) != 0) && (local_138 == (int *)(uint)*local_108)) &&\n            (local_138 != (int *)0xff)) && (iVar5 != 0 || 9 < uVar26)) {\n          param_3 = (int *)((int)param_3 - (int)local_104);\n          strncpy((char *)param_3,(char *)local_110,(size_t)local_104);\n          local_138 = (int *)(uint)local_108[1];\n          if (local_138 != (int *)0x0) {\n            local_108 = local_108 + 1;\n            local_138 = (int *)0x0;\n          }\n        }\n        lVar31 = __aeabi_uldivmod(uVar26,iVar5,10,0);\n      } while (lVar31 != 0);\n      local_158 = (int *)((int)(&bStack_2a + 2) - (int)param_3);\n    }\n    else {\n      local_140 = uVar26 & 0xffffff7f;\n      iVar6 = iVar5;\n      if (((uint)piVar18 | (uint)piVar24) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar5 == 0) {\n            local_158 = (int *)(uVar26 & 1);\n            if (local_158 == (int *)0x0) {\n              param_3 = (int *)(&bStack_2a + 2);\n            }\n            else {\n              param_3 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n            }\n          }\n          else {\n            param_3 = (int *)(&bStack_2a + 2);\n          }\n        }\n        else {\n          if (iVar5 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar18 + '0';\n          param_3 = (int *)(&bStack_2a + 1);\n          local_158 = (int *)0x1;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar5 = iVar6;\n        uVar26 = local_140;\n        if (iVar6 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar5 == 2) {\n          param_3 = (int *)(&bStack_2a + 2);\n          do {\n            piVar19 = (int *)((uint)piVar18 >> 4 | (int)piVar24 << 0x1c);\n            piVar24 = (int *)((uint)piVar24 >> 4);\n            param_3 = (int *)((int)param_3 + -1);\n            *(undefined *)param_3 = local_11c[(uint)piVar18 & 0xf];\n            piVar18 = piVar19;\n          } while (((uint)piVar19 | (uint)piVar24) != 0);\n        }\n        else {\n          param_3 = (int *)(&bStack_2a + 2);\n          do {\n            piVar19 = param_3;\n            piVar12 = (int *)((uint)piVar18 >> 3 | (int)piVar24 << 0x1d);\n            piVar24 = (int *)((uint)piVar24 >> 3);\n            iVar5 = ((uint)piVar18 & 7) + 0x30;\n            *(byte *)((int)piVar19 + -1) = (byte)iVar5;\n            param_3 = (int *)((int)piVar19 + -1);\n            piVar18 = piVar12;\n          } while (((uint)piVar12 | (uint)piVar24) != 0);\n          if (((local_140 & 1) != 0) && (iVar5 != 0x30)) {\n            param_3 = (int *)((int)piVar19 + -2);\n            local_158 = (int *)(&bStack_2a + (2 - (int)param_3));\n            *(byte *)((int)piVar19 + -2) = 0x30;\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (int *)(&bStack_2a + (2 - (int)param_3));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = (int *)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    piVar18 = (int *)(uint)local_f5;\n    local_144 = piVar27;\n    local_168 = local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  if (local_d0 == (byte *)0x0) {\nLAB_0800604a:\n    uVar15 = *(ushort *)(param_2 + 3);\n  }\n  else {\n    __ssprint_r(param_1,param_2,&local_d8);\n    uVar15 = *(ushort *)(param_2 + 3);\n  }\nLAB_0800604e:\n  if ((uVar15 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  uVar25 = (uint)*(byte *)piVar28;\n  if (uVar25 == 0x6c) {\n    uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n    uVar26 = uVar26 | 0x20;\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    uVar26 = uVar26 | 0x10;\n  }\n  goto LAB_08005f4a;\n  while (iVar6 = __aeabi_dcmpeq(uVar7,uVar8,0,0), iVar6 == 0) {\nLAB_080072ba:\n    piVar18 = piVar27;\n    piVar19 = local_138;\n    piVar27 = (int *)((int)piVar18 + -1);\n    uVar32 = __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,DAT_080073a0);\n    iVar5 = __aeabi_d2iz();\n    uVar33 = __aeabi_i2d();\n    uVar32 = __subdf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),(int)uVar33,\n                      (int)((ulonglong)uVar33 >> 0x20));\n    uVar8 = (undefined4)((ulonglong)uVar32 >> 0x20);\n    uVar7 = (undefined4)uVar32;\n    local_138 = (int *)((int)piVar19 + 1);\n    *(byte *)piVar19 = *(byte *)((int)local_158 + iVar5);\n    if (piVar27 == (int *)0xffffffff) break;\n  }\n  iVar6 = __aeabi_dcmpgt(uVar7,uVar8,0,DAT_080073a4);\n  if ((iVar6 == 0) &&\n     ((iVar6 = __aeabi_dcmpeq(uVar7,uVar8,0,DAT_080073a4), iVar6 == 0 || (-1 < iVar5 << 0x1f)))) {\n    if (-1 < (int)piVar27) {\n      piVar18 = (int *)((int)piVar18 + (int)local_138);\n      piVar27 = local_138;\n      do {\n        local_138 = (int *)((int)piVar27 + 1);\n        *(byte *)piVar27 = 0x30;\n        piVar27 = local_138;\n      } while (piVar18 != local_138);\n    }\n  }\n  else {\n    bVar1 = *(byte *)((int)local_158 + 0xf);\n    bVar11 = *(byte *)piVar19;\n    piVar27 = local_138;\n    local_e0 = piVar19;\n    while (bVar1 == bVar11) {\n      *(byte *)((int)piVar27 + -1) = 0x30;\n      bVar11 = *(byte *)((int)local_e0 + -1);\n      piVar27 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar11 == 0x39) {\n      bVar11 = *(byte *)((int)local_158 + 10);\n    }\n    else {\n      bVar11 = bVar11 + 1;\n    }\n    *(byte *)((int)piVar27 + -1) = bVar11;\n  }\n  local_138 = (int *)((int)local_138 - (int)param_3);\nLAB_08006cb0:\n  local_168 = (int *)(uVar25 & 0xffffffdf);\n  local_134 = local_f0[0];\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0[0] + 3) < 0 == SCARRY4((int)local_f0[0],3)) &&\n       ((int)local_f0[0] <= (int)piVar24)) {\n      if ((int)local_f0[0] < (int)local_138) {\n        local_158 = (int *)((int)local_138 + (int)piVar4);\n        if (0 < (int)local_f0[0]) {\n          uVar25 = 0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (int *)((int)local_158 + (1 - (int)local_f0[0]));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        uVar25 = 0x67;\n      }\n      else {\n        if ((int)(uVar26 << 0x1f) < 0) {\n          local_158 = (int *)((int)local_f0[0] + (int)piVar4);\n        }\n        else {\n          local_158 = local_f0[0];\n        }\n        if (-1 < (int)(uVar26 << 0x15)) {\n          uVar25 = 0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0[0]) {\n          uVar25 = 0x67;\n          goto LAB_080074fc;\n        }\n        uVar25 = 0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    uVar25 = uVar25 - 2;\n    local_168 = (int *)(uVar25 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8._0_1_ = (char)uVar25;\n    if (local_168 == (int *)0x41) {\n      local_e8._0_1_ = (char)local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0[0] + -1);\n    if ((int)piVar27 < 0) {\n      local_e8._1_1_ = 0x2d;\n      local_f0[0] = (int *)(1 - (int)local_f0[0]);\n    }\n    else {\n      local_e8._1_1_ = 0x2b;\n      local_f0[0] = piVar27;\n    }\n    if ((int)local_f0[0] < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar21 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e8._2_1_ = 0x30;\n        pcVar21 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar21 = (char)local_f0[0] + '0';\n      pcVar21 = pcVar21 + 1;\n    }\n    else {\n      pbVar29 = abStack_dc + 3;\n      pbVar23 = pbVar29;\n      do {\n        pbVar9 = pbVar23;\n        piVar18 = (int *)((ulonglong)DAT_08007890 * ZEXT48(local_f0[0]) >> 0x23);\n        pbVar9[-1] = (char)local_f0[0] + (char)piVar18 * -10 + 0x30;\n        pbVar23 = pbVar9 + -1;\n        local_f0[0] = piVar18;\n      } while ((int *)0x9 < piVar18);\n      uVar22 = (uint)(piVar18 + 0xc) & 0xff;\n      pbVar9[-2] = (byte)uVar22;\n      if (pbVar9 + -2 < pbVar29) {\n        pbVar9 = pbVar23;\n        pcVar21 = (char *)((int)&local_e8 + 2);\n        while( true ) {\n          *pcVar21 = (char)uVar22;\n          if (pbVar29 == pbVar9) break;\n          uVar22 = (uint)*pbVar9;\n          pbVar9 = pbVar9 + 1;\n          pcVar21 = pcVar21 + 1;\n        }\n        pcVar21 = (char *)(((int)&stack0xfffffe78 * 2 - (int)pbVar23) + 0x152);\n      }\n      else {\n        pcVar21 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar21 + -(int)&local_e8);\n    local_158 = (int *)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)(uVar26 << 0x1f) < 0)) {\n      local_158 = (int *)((int)local_158 + (int)piVar4);\n    }\n    local_13c = (int *)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    local_140 = uVar26 & 0xfffffbff | 0x100;\n    local_f0[0] = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0[0] < 1) {\n      if ((piVar24 == (int *)0x0) && (-1 < (int)(uVar26 << 0x1f))) {\n        uVar25 = 0x66;\n        local_168 = (int *)0x1;\n        local_158 = (int *)0x1;\n      }\n      else {\n        uVar25 = 0x66;\n        local_158 = (int *)((byte *)((int)piVar4 + 1) + (int)piVar24);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = (int *)0x0;\n      local_130 = (int *)0x0;\n    }\n    else {\n      if ((piVar24 == (int *)0x0) && (-1 < (int)(uVar26 << 0x1f))) {\n        uVar25 = 0x66;\n        local_158 = local_f0[0];\n      }\n      else {\n        uVar25 = 0x66;\n        local_158 = (int *)((byte *)((int)local_f0[0] + (int)piVar4) + (int)piVar24);\n      }\nLAB_080074f8:\n      if (-1 < (int)(uVar26 << 0x15)) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = (int *)0x0;\n      local_130 = (int *)0x0;\n      uVar26 = (uint)*local_108;\n      while (uVar26 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar26) goto LAB_08007524;\n          uVar22 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar26);\n          if (uVar22 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = (int *)((int)local_130 + 1);\n          uVar26 = uVar22;\n          if (uVar22 == 0xff) goto LAB_08007524;\n        }\n        local_13c = (int *)((int)local_13c + 1);\n      }\nLAB_08007524:\n      local_158 = (int *)((int)local_104 * (int)((int)local_130 + (int)local_13c) + (int)local_158);\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    }\n  }\n  if (local_144 == (int *)0x0) {\n    piVar18 = (int *)(uint)local_f5;\nLAB_08006538:\n    uVar26 = local_140;\n    if (piVar18 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar18 = (int *)0x2d;\n    local_144 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n    uVar26 = local_140;\n  }\nLAB_08006298:\n  if ((uVar26 & 2) != 0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  if (((uVar26 & 0x84) == 0) &&\n     (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27)) {\n    if (0x10 < (int)piVar27) {\n      do {\n        piVar18 = piVar27;\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + 0x10;\n        *ppiVar3 = (int *)PTR_blanks_7315_08006438;\n        ppiVar3[1] = (int *)0x10;\n        if (local_d4 < 8) {\n          ppiVar3 = ppiVar3 + 2;\n        }\n        else {\n          iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar5 != 0) goto LAB_0800603e;\n          ppiVar3 = local_cc;\n        }\n        piVar27 = piVar18 + -4;\n      } while (0x10 < (int)piVar27);\n      piVar27 = piVar18 + -4;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar3 = (int *)PTR_blanks_7315_08006438;\n    ppiVar3[1] = piVar27;\n    if (local_d4 < 8) {\n      piVar18 = (int *)(uint)local_f5;\n      ppiVar3 = ppiVar3 + 2;\n    }\n    else {\n      iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar5 != 0) goto LAB_0800603e;\n      ppiVar3 = local_cc;\n      piVar18 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar18 != (int *)0x0) {\n    local_d0 = local_d0 + 1;\n    local_d4 = local_d4 + 1;\n    *ppiVar3 = (int *)&local_f5;\n    ppiVar3[1] = (int *)0x1;\n    if (local_d4 < 8) {\n      ppiVar3 = ppiVar3 + 2;\n    }\n    else {\n      iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar5 != 0) goto LAB_0800603e;\n      ppiVar3 = local_cc;\n    }\n  }\n  if ((uVar26 & 2) != 0) {\n    local_d0 = local_d0 + 2;\n    local_d4 = local_d4 + 1;\n    *ppiVar3 = (int *)&local_f4;\n    ppiVar3[1] = (int *)0x2;\n    if (local_d4 < 8) {\n      ppiVar3 = ppiVar3 + 2;\n    }\n    else {\n      iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar5 != 0) goto LAB_0800603e;\n      ppiVar3 = local_cc;\n    }\n  }\n  puVar2 = PTR_zeroes_7316_08006a54;\n  if (((uVar26 & 0x84) == 0x80) &&\n     (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27)) {\n    if (0x10 < (int)piVar27) {\n      do {\n        while( true ) {\n          piVar18 = piVar27;\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + 0x10;\n          *ppiVar3 = (int *)puVar2;\n          ppiVar3[1] = (int *)0x10;\n          if (local_d4 < 8) break;\n          iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar5 != 0) goto LAB_0800603e;\n          ppiVar3 = local_cc;\n          piVar27 = piVar18 + -4;\n          if ((int)(piVar18 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar3 = ppiVar3 + 2;\n        piVar27 = piVar18 + -4;\n      } while (0x10 < (int)(piVar18 + -4));\nLAB_08006882:\n      piVar27 = piVar18 + -4;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar3 = (int *)puVar2;\n    ppiVar3[1] = piVar27;\n    if (local_d4 < 8) {\n      ppiVar3 = ppiVar3 + 2;\n    }\n    else {\n      iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar5 != 0) goto LAB_0800603e;\n      ppiVar3 = local_cc;\n    }\n  }\n  puVar2 = PTR_zeroes_7316_0800643c;\n  local_144 = (int *)((int)local_144 - (int)local_158);\n  if (0 < (int)local_144) {\n    piVar27 = (int *)PTR_zeroes_7316_08007088;\n    if (0x10 < (int)local_144) {\n      do {\n        while( true ) {\n          piVar27 = local_144;\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + 0x10;\n          *ppiVar3 = (int *)puVar2;\n          ppiVar3[1] = (int *)0x10;\n          if (local_d4 < 8) break;\n          iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar5 != 0) goto LAB_0800603e;\n          ppiVar3 = local_cc;\n          local_144 = piVar27 + -4;\n          if ((int)(piVar27 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar3 = ppiVar3 + 2;\n        local_144 = piVar27 + -4;\n      } while (0x10 < (int)(piVar27 + -4));\nLAB_080063d2:\n      local_144 = piVar27 + -4;\n      piVar27 = (int *)puVar2;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)local_144;\n    *ppiVar3 = piVar27;\n    ppiVar3[1] = local_144;\n    if (local_d4 < 8) {\n      ppiVar3 = ppiVar3 + 2;\n    }\n    else {\n      iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar5 != 0) goto LAB_0800603e;\n      ppiVar3 = local_cc;\n    }\n  }\n  pbVar23 = local_d0;\n  if ((uVar26 & 0x100) == 0) {\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)local_158;\n    *ppiVar3 = param_3;\n    ppiVar3[1] = local_158;\n    if (local_d4 < 8) {\nLAB_0800640e:\n      ppiVar3 = ppiVar3 + 2;\n      pbVar23 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar5 != 0) goto LAB_0800603e;\n      ppiVar3 = local_cc;\n      pbVar23 = local_d0;\n    }\n  }\n  else if ((int)uVar25 < 0x66) {\n    local_158 = (int *)(local_d0 + 1);\n    iVar5 = local_d4 + 1;\n    ppiVar16 = ppiVar3 + 2;\n    local_d0 = (byte *)local_158;\n    if (((int)local_138 < 2) && ((uVar26 & 1) == 0)) {\n      *ppiVar3 = param_3;\n      ppiVar3[1] = (int *)0x1;\n      if (iVar5 < 8) {\n        local_150 = (int *)(local_d4 + 2);\n        ppiVar3 = ppiVar3 + 4;\n      }\n      else {\n        local_d4 = iVar5;\n        iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar5 != 0) goto LAB_0800603e;\n        local_150 = (int *)(local_d4 + 1);\n        ppiVar16 = local_cc;\n        local_158 = (int *)local_d0;\n        ppiVar3 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar3 = param_3;\n      ppiVar3[1] = (int *)0x1;\n      local_d4 = iVar5;\n      if (7 < iVar5) {\n        iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar5 != 0) goto LAB_0800603e;\n        ppiVar16 = local_cc;\n        local_158 = (int *)local_d0;\n      }\n      local_d4 = local_d4 + 1;\n      local_d0 = (byte *)((int)local_158 + (int)piVar4);\n      *ppiVar16 = __s;\n      ppiVar16[1] = piVar4;\n      if (local_d4 < 8) {\n        ppiVar20 = ppiVar16 + 2;\n      }\n      else {\n        iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar5 != 0) goto LAB_0800603e;\n        ppiVar20 = local_cc;\n      }\n      local_158 = (int *)local_d0;\n      iVar5 = local_d4;\n      local_150 = (int *)(local_d4 + 1);\n      piVar27 = (int *)((int)local_138 + -1);\n      ppiVar13 = ppiVar20 + 2;\n      iVar6 = __aeabi_dcmpeq(local_128,local_12c,0,0);\n      puVar2 = PTR_zeroes_7316_08006d94;\n      local_d4 = (int)local_150;\n      if (iVar6 == 0) {\n        local_158 = (int *)((int)local_158 + (int)piVar27);\n        *ppiVar20 = (int *)((int)param_3 + 1);\n        ppiVar20[1] = piVar27;\n        local_d0 = (byte *)local_158;\n        if ((int)local_150 < 8) {\n          local_150 = (int *)(iVar5 + 2);\n          ppiVar16 = ppiVar13;\n          ppiVar3 = ppiVar20 + 4;\n        }\n        else {\nLAB_08006d9c:\n          iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar5 != 0) goto LAB_0800603e;\n          local_150 = (int *)(local_d4 + 1);\n          local_158 = (int *)local_d0;\n          ppiVar16 = local_cc;\n          ppiVar3 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar16 = ppiVar20;\n        ppiVar3 = ppiVar13;\n        if (0 < (int)piVar27) {\n          piVar18 = (int *)PTR_zeroes_7316_0800788c;\n          if (0x10 < (int)piVar27) {\n            while( true ) {\n              local_d0 = (byte *)((int)local_158 + 0x10);\n              *ppiVar20 = (int *)puVar2;\n              ppiVar20[1] = (int *)0x10;\n              if (local_d4 < 8) {\n                ppiVar20 = ppiVar20 + 2;\n              }\n              else {\n                iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar5 != 0) goto LAB_0800603e;\n                ppiVar20 = local_cc;\n              }\n              piVar27 = piVar27 + -4;\n              local_158 = (int *)local_d0;\n              if ((int)piVar27 < 0x11) break;\n              local_d4 = local_d4 + 1;\n            }\n            local_150 = (int *)(local_d4 + 1);\n            ppiVar13 = ppiVar20 + 2;\n            piVar18 = (int *)puVar2;\n          }\n          *ppiVar20 = piVar18;\n          ppiVar20[1] = piVar27;\n          local_158 = (int *)((int)local_158 + (int)piVar27);\n          local_d4 = (int)local_150;\n          local_d0 = (byte *)local_158;\n          if (7 < (int)local_150) goto LAB_08006d9c;\n          local_150 = (int *)((int)local_150 + 1);\n          ppiVar3 = ppiVar13 + 2;\n          ppiVar16 = ppiVar13;\n        }\n      }\n    }\n    ppiVar16[1] = local_10c;\n    local_d0 = (byte *)((int)local_158 + (int)local_10c);\n    local_d4 = (int)local_150;\n    *ppiVar16 = &local_e8;\n    pbVar23 = local_d0;\n    if (7 < (int)local_150) {\n      iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar5 != 0) goto LAB_0800603e;\n      ppiVar3 = local_cc;\n      pbVar23 = local_d0;\n    }\n  }\n  else {\n    iVar5 = __aeabi_dcmpeq(local_128,local_12c,0,0);\n    if (iVar5 == 0) {\n      if ((int)local_f0[0] < 1) {\n        local_d4 = local_d4 + 1;\n        local_d0 = pbVar23 + 1;\n        *ppiVar3 = (int *)PTR_DAT_08006d98;\n        ppiVar3[1] = (int *)0x1;\n        if (local_d4 < 8) {\n          ppiVar3 = ppiVar3 + 2;\n        }\n        else {\n          iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar5 != 0) goto LAB_0800603e;\n          ppiVar3 = local_cc;\n        }\n        if (((local_f0[0] != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (pbVar23 = local_d0, (uVar26 & 1) != 0)) {\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + (int)piVar4;\n          *ppiVar3 = __s;\n          ppiVar3[1] = piVar4;\n          if (local_d4 < 8) {\n            ppiVar3 = ppiVar3 + 2;\n          }\n          else {\n            iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar5 != 0) goto LAB_0800603e;\n            ppiVar3 = local_cc;\n          }\n          puVar2 = PTR_zeroes_7316_0800788c;\n          if ((int)local_f0[0] < 0) {\n            piVar27 = (int *)-(int)local_f0[0];\n            if ((int)(local_f0[0] + 4) < 0 != SCARRY4((int)local_f0[0],0x10)) {\n              do {\n                local_d4 = local_d4 + 1;\n                local_d0 = local_d0 + 0x10;\n                *ppiVar3 = (int *)puVar2;\n                ppiVar3[1] = (int *)0x10;\n                if (local_d4 < 8) {\n                  ppiVar3 = ppiVar3 + 2;\n                }\n                else {\n                  iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n                  if (iVar5 != 0) goto LAB_0800603e;\n                  ppiVar3 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = local_d4 + 1;\n            local_d0 = local_d0 + (int)piVar27;\n            *ppiVar3 = (int *)puVar2;\n            ppiVar3[1] = piVar27;\n            if (local_d4 < 8) {\n              ppiVar3 = ppiVar3 + 2;\n            }\n            else {\n              iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar5 != 0) goto LAB_0800603e;\n              ppiVar3 = local_cc;\n            }\n          }\n          local_d0 = local_d0 + (int)local_138;\n          *ppiVar3 = param_3;\n          ppiVar3[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar27 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar27 = local_138;\n        }\n        if (0 < (int)piVar27) {\n          local_d0 = pbVar23 + (int)piVar27;\n          local_d4 = local_d4 + 1;\n          *ppiVar3 = param_3;\n          ppiVar3[1] = piVar27;\n          if (local_d4 < 8) {\n            ppiVar3 = ppiVar3 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar5 != 0) goto LAB_0800603e;\n            ppiVar3 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        puVar2 = PTR_zeroes_7316_08006d94;\n        piVar18 = local_134;\n        if (-1 < (int)piVar27) {\n          piVar18 = (int *)((int)local_134 - (int)piVar27);\n        }\n        piVar27 = (int *)PTR_zeroes_7316_0800788c;\n        if (0 < (int)piVar18) {\n          for (; 0x10 < (int)piVar18; piVar18 = piVar18 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar3 = (int *)puVar2;\n            ppiVar3[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar3 = ppiVar3 + 2;\n            }\n            else {\n              iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar5 != 0) goto LAB_0800603e;\n              ppiVar3 = local_cc;\n            }\n            pbVar23 = local_d0;\n            piVar27 = (int *)puVar2;\n          }\n          local_d4 = local_d4 + 1;\n          pbVar23 = pbVar23 + (int)piVar18;\n          *ppiVar3 = piVar27;\n          ppiVar3[1] = piVar18;\n          local_d0 = pbVar23;\n          if (local_d4 < 8) {\n            ppiVar3 = ppiVar3 + 2;\n          }\n          else {\n            iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar5 != 0) goto LAB_0800603e;\n            ppiVar3 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        puVar2 = PTR_zeroes_7316_08007398;\n        local_134 = (int *)((int)local_134 + (int)param_3);\n        if ((uVar26 & 0x400) != 0) {\n          if (local_130 == (int *)0x0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != (int *)0x0) goto LAB_0800717e;\n          local_108 = local_108 + -1;\n          local_130 = (int *)((int)local_130 + -1);\n          do {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + (int)local_104;\n            *ppiVar3 = local_110;\n            ppiVar3[1] = local_104;\n            if (local_d4 < 8) {\n              ppiVar3 = ppiVar3 + 2;\n            }\n            else {\n              iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar5 != 0) goto LAB_0800603e;\n              ppiVar3 = local_cc;\n            }\n            piVar18 = (int *)(uint)*local_108;\n            piVar27 = (int *)((byte *)((int)param_3 + (int)local_138) + -(int)local_134);\n            if ((int)piVar18 <= (int)((byte *)((int)param_3 + (int)local_138) + -(int)local_134)) {\n              piVar27 = piVar18;\n            }\n            if (0 < (int)piVar27) {\n              local_d0 = local_d0 + (int)piVar27;\n              local_d4 = local_d4 + 1;\n              *ppiVar3 = local_134;\n              ppiVar3[1] = piVar27;\n              if (local_d4 < 8) {\n                piVar18 = (int *)(uint)*local_108;\n                ppiVar3 = ppiVar3 + 2;\n              }\n              else {\n                iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar5 != 0) goto LAB_0800603e;\n                ppiVar3 = local_cc;\n                piVar18 = (int *)(uint)*local_108;\n              }\n            }\n            piVar24 = piVar18;\n            if (-1 < (int)piVar27) {\n              piVar24 = (int *)((int)piVar18 - (int)piVar27);\n            }\n            if (0 < (int)piVar24) {\n              for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n                while( true ) {\n                  local_d4 = local_d4 + 1;\n                  local_d0 = local_d0 + 0x10;\n                  *ppiVar3 = (int *)puVar2;\n                  ppiVar3[1] = (int *)0x10;\n                  if (local_d4 < 8) break;\n                  iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n                  if (iVar5 != 0) goto LAB_0800603e;\n                  piVar24 = piVar24 + -4;\n                  ppiVar3 = local_cc;\n                  if ((int)piVar24 < 0x11) goto LAB_08007156;\n                }\n                ppiVar3 = ppiVar3 + 2;\n              }\nLAB_08007156:\n              local_d4 = local_d4 + 1;\n              local_d0 = local_d0 + (int)piVar24;\n              *ppiVar3 = (int *)puVar2;\n              ppiVar3[1] = piVar24;\n              if (local_d4 < 8) {\n                piVar18 = (int *)(uint)*local_108;\n                ppiVar3 = ppiVar3 + 2;\n              }\n              else {\n                iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar5 != 0) goto LAB_0800603e;\n                piVar18 = (int *)(uint)*local_108;\n                ppiVar3 = local_cc;\n              }\n            }\n            local_134 = (int *)((int)local_134 + (int)piVar18);\n            pbVar23 = local_d0;\n            if (local_130 != (int *)0x0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == (int *)0x0) {\n              if ((int *)((int)param_3 + (int)local_138) <= local_134) {\n                local_134 = (int *)((int)param_3 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = (int *)((int)local_13c + -1);\n          } while( true );\n        }\n        if (((int)local_f0[0] < (int)local_138) || ((uVar26 & 1) != 0)) {\n          local_d4 = local_d4 + 1;\n          local_d0 = pbVar23 + (int)piVar4;\n          *ppiVar3 = __s;\n          ppiVar3[1] = piVar4;\n          if (local_d4 < 8) {\n            ppiVar3 = ppiVar3 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar5 != 0) goto LAB_0800603e;\n            ppiVar3 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        piVar27 = (int *)((int)local_138 - (int)local_f0[0]);\n        piVar18 = (int *)((byte *)((int)param_3 + (int)local_138) + -(int)local_134);\n        if ((int)piVar27 <= (int)((byte *)((int)param_3 + (int)local_138) + -(int)local_134)) {\n          piVar18 = piVar27;\n        }\n        if (0 < (int)piVar18) {\n          local_d0 = pbVar23 + (int)piVar18;\n          local_d4 = local_d4 + 1;\n          *ppiVar3 = local_134;\n          ppiVar3[1] = piVar18;\n          if (local_d4 < 8) {\n            ppiVar3 = ppiVar3 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar5 != 0) goto LAB_0800603e;\n            ppiVar3 = local_cc;\n            piVar27 = (int *)((int)local_138 - (int)local_f0[0]);\n            pbVar23 = local_d0;\n          }\n        }\n        puVar2 = PTR_zeroes_7316_08007088;\n        if (-1 < (int)piVar18) {\n          piVar27 = (int *)((int)piVar27 - (int)piVar18);\n        }\n        piVar18 = (int *)PTR_zeroes_7316_0800788c;\n        if (0 < (int)piVar27) {\n          for (; 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar3 = (int *)puVar2;\n            ppiVar3[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar3 = ppiVar3 + 2;\n            }\n            else {\n              iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar5 != 0) goto LAB_0800603e;\n              ppiVar3 = local_cc;\n            }\n            pbVar23 = local_d0;\n            piVar18 = (int *)puVar2;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = local_d4 + 1;\n      local_d0 = pbVar23 + 1;\n      *ppiVar3 = (int *)PTR_DAT_08006a50;\n      ppiVar3[1] = (int *)0x1;\n      if (local_d4 < 8) {\n        ppiVar3 = ppiVar3 + 2;\n      }\n      else {\n        iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar5 != 0) goto LAB_0800603e;\n        ppiVar3 = local_cc;\n      }\n      if (((int)local_f0[0] < (int)local_138) || (pbVar23 = local_d0, (uVar26 & 1) != 0)) {\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + (int)piVar4;\n        *ppiVar3 = __s;\n        ppiVar3[1] = piVar4;\n        if (local_d4 < 8) {\n          ppiVar3 = ppiVar3 + 2;\n        }\n        else {\n          iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar5 != 0) goto LAB_0800603e;\n          ppiVar3 = local_cc;\n        }\n        puVar2 = PTR_zeroes_7316_08006a54;\n        piVar27 = (int *)((int)local_138 + -1);\n        pbVar23 = local_d0;\n        piVar18 = (int *)PTR_zeroes_7316_0800788c;\n        if (0 < (int)piVar27) {\n          for (; 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar3 = (int *)puVar2;\n            ppiVar3[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar3 = ppiVar3 + 2;\n            }\n            else {\n              iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar5 != 0) goto LAB_0800603e;\n              ppiVar3 = local_cc;\n            }\n            piVar18 = (int *)puVar2;\n            pbVar23 = local_d0;\n          }\nLAB_08007014:\n          local_d0 = pbVar23 + (int)piVar27;\n          *ppiVar3 = piVar18;\n          ppiVar3[1] = piVar27;\njoined_r0x08006a1c:\n          local_d4 = local_d4 + 1;\n          if (7 < local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  if (((uVar26 & 4) != 0) && (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27))\n  {\n    for (; local_d0 = pbVar23, 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n      while( true ) {\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + 0x10;\n        *ppiVar3 = (int *)PTR_blanks_7315_08006720;\n        ppiVar3[1] = (int *)0x10;\n        if (local_d4 < 8) break;\n        iVar5 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar5 != 0) goto LAB_0800603e;\n        piVar27 = piVar27 + -4;\n        ppiVar3 = local_cc;\n        if ((int)piVar27 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar3 = ppiVar3 + 2;\n      pbVar23 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar3 = (int *)PTR_blanks_7315_08006720;\n    ppiVar3[1] = piVar27;\n    pbVar23 = local_d0;\n    if ((7 < local_d4) &&\n       (iVar5 = __ssprint_r(param_1,param_2,&local_d8), pbVar23 = local_d0, iVar5 != 0))\n    goto LAB_0800603e;\n  }\n  if ((int)local_15c < (int)local_168) {\n    local_15c = local_168;\n  }\n  local_164 = local_164 + (int)local_15c;\n  if ((pbVar23 == (byte *)0x0) || (iVar5 = __ssprint_r(param_1,param_2,&local_d8), iVar5 == 0)) {\n    local_d4 = 0;\n    if (local_148 != (int *)0x0) {\n      _free_r(param_1,local_148);\n    }\n    ppiVar3 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    _free_r(param_1,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  uVar22 = uVar25 - 0x30;\n  piVar18 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar18 + 1);\n    uVar25 = (uint)*(byte *)piVar18;\n    local_15c = (int *)(uVar22 + (int)local_15c * 10);\n    uVar22 = uVar25 - 0x30;\n    piVar18 = piVar28;\n  } while (uVar22 < 10);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  uVar25 = (uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "called": [
                "__aeabi_dcmpeq",
                "__aeabi_dcmpgt",
                "_dtoa_r",
                "_malloc_r",
                "__muldf3",
                "strncpy",
                "__aeabi_dcmple",
                "strlen",
                "__aeabi_dcmplt",
                "__aeabi_uldivmod",
                "__ssprint_r",
                "__unorddf2",
                "__aeabi_i2d",
                "__subdf3",
                "_localeconv_r",
                "_free_r",
                "frexp",
                "memchr",
                "__aeabi_d2iz"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08005e9c",
            "calling": [
                "sprintf"
            ],
            "imported": false,
            "current_name": "FUNC_08005e9c"
        },
        "FUN_08000134": {
            "renaming": {
                "FUN_08000134": "concatenate_64_bit_pointers_08000134",
                "param_1": "pointer_1",
                "param_2": "pointer_2"
            },
            "code": "\nundefined8 concatenate_64_bit_pointers_08000134(undefined *pointer_1,undefined *pointer_2)\n\n{\n  if (DAT_08000144 != 0) {\n    pointer_1 = PTR__init_0800014c;\n    pointer_2 = PTR_object_8660_08000148;\n  }\n  return CONCAT44(pointer_2,pointer_1);\n}\n\n",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000134",
            "calling": [
                "__libc_init_array",
                "__libc_fini_array"
            ],
            "imported": false,
            "current_name": "concatenate_64_bit_pointers_08000134"
        },
        "FUN_08005704": {
            "renaming": {
                "FUN_08005704": "update_system_tick_08005704",
                "HAL_IncTick": "increment_system_tick",
                "HAL_SYSTICK_IRQHandler": "handle_system_tick_interrupt"
            },
            "code": "\nvoid update_system_tick_08005704(void)\n\n{\n  increment_system_tick();\n  handle_system_tick_interrupt();\n  return;\n}\n\n",
            "called": [
                "HAL_IncTick",
                "HAL_SYSTICK_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005704",
            "calling": [],
            "imported": false,
            "current_name": "update_system_tick_08005704"
        },
        "FUN_08002ca8": {
            "renaming": {
                "FUN_08002ca8": "i2c_wait_for_event_08002ca8",
                "hi2c": "i2c_handle",
                "Timeout": "timeout_ms",
                "Tickstart": "tick_start",
                "uVar1": "elapsed_time_ms"
            },
            "code": "\nHAL_StatusTypeDef\ni2c_wait_for_event_08002ca8(I2C_HandleTypeDef *i2c_handle,uint32_t timeout_ms,uint32_t tick_start)\n\n{\n  uint32_t elapsed_time_ms;\n  \n  while( true ) {\n    if ((i2c_handle->Instance->SR1 & 0x40) == 0x40) {\n      return HAL_OK;\n    }\n    if ((i2c_handle->Instance->SR1 & 0x10) == 0x10) break;\n    if ((timeout_ms == 0) || (elapsed_time_ms = HAL_GetTick(), timeout_ms < elapsed_time_ms - tick_start)) {\n      i2c_handle->ErrorCode = i2c_handle->ErrorCode | 0x20;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  i2c_handle->Instance->SR1 = 0xffffffef;\n  i2c_handle->ErrorCode = 0;\n  i2c_handle->PreviousState = 0;\n  i2c_handle->State = HAL_I2C_STATE_READY;\n  i2c_handle->Lock = HAL_UNLOCKED;\n  return HAL_ERROR;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ca8",
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "imported": false,
            "current_name": "i2c_wait_for_event_08002ca8"
        },
        "FUN_08003a94": {
            "renaming": {
                "FUN_08003a94": "configure_tim_clock_08003a94",
                "htim": "TIM_handle",
                "sClockSourceConfig": "clock_config",
                "HVar1": "status",
                "uVar2": "clock_source",
                "tmpsmcr": "temp_SMCR",
                "HAL_LOCKED": "TIM_LOCKED",
                "HAL_BUSY": "TIM_BUSY",
                "HAL_TIM_STATE_BUSY": "TIM_STATE_BUSY",
                "HAL_TIM_STATE_READY": "TIM_STATE_READY",
                "HAL_UNLOCKED": "TIM_UNLOCKED"
            },
            "code": "\nHAL_StatusTypeDef\nconfigure_TIM_clock_08003a94(TIM_HandleTypeDef *TIM_handle,TIM_ClockConfigTypeDef *clock_config)\n\n{\n  HAL_StatusTypeDef status;\n  uint clock_source;\n  uint32_t temp_SMCR;\n  \n  if (TIM_handle->Lock == TIM_LOCKED) {\n    status = TIM_BUSY;\n  }\n  else {\n    TIM_handle->Lock = TIM_LOCKED;\n    TIM_handle->State = TIM_STATE_BUSY;\n    TIM_handle->Instance->SMCR = TIM_handle->Instance->SMCR & 0xffff0088;\n    clock_source = clock_config->ClockSource;\n    if (clock_source == 0x40) {\n      TIM_TI1_ConfigInputStage\n                (TIM_handle->Instance,clock_config->ClockPolarity,clock_config->ClockFilter);\n      TIM_ITRx_SetConfig(TIM_handle->Instance,0x40);\n    }\n    else if (clock_source < 0x41) {\n      if (clock_source == 0x10) {\n        TIM_ITRx_SetConfig(TIM_handle->Instance,0x10);\n      }\n      else if (clock_source < 0x11) {\n        if (clock_source == 0) {\n          TIM_ITRx_SetConfig(TIM_handle->Instance,0);\n        }\n      }\n      else if (clock_source == 0x20) {\n        TIM_ITRx_SetConfig(TIM_handle->Instance,0x20);\n      }\n      else if (clock_source == 0x30) {\n        TIM_ITRx_SetConfig(TIM_handle->Instance,0x30);\n      }\n    }\n    else if (clock_source == 0x70) {\n      TIM_ETR_SetConfig(TIM_handle->Instance,clock_config->ClockPrescaler,\n                        clock_config->ClockPolarity,clock_config->ClockFilter);\n      TIM_handle->Instance->SMCR = TIM_handle->Instance->SMCR & 0xffffff88 | 0x77;\n    }\n    else if (clock_source < 0x71) {\n      if (clock_source == 0x50) {\n        TIM_TI1_ConfigInputStage\n                  (TIM_handle->Instance,clock_config->ClockPolarity,clock_config->ClockFilter)\n        ;\n        TIM_ITRx_SetConfig(TIM_handle->Instance,0x50);\n      }\n      else if (clock_source == 0x60) {\n        TIM_TI2_ConfigInputStage\n                  (TIM_handle->Instance,clock_config->ClockPolarity,clock_config->ClockFilter)\n        ;\n        TIM_ITRx_SetConfig(TIM_handle->Instance,0x60);\n      }\n    }\n    else if (clock_source == 0x1000) {\n      TIM_handle->Instance->SMCR = TIM_handle->Instance->SMCR & 0xfffffff8;\n    }\n    else if (clock_source == 0x2000) {\n      TIM_ETR_SetConfig(TIM_handle->Instance,clock_config->ClockPrescaler,\n                        clock_config->ClockPolarity,clock_config->ClockFilter);\n      TIM_handle->Instance->SMCR = TIM_handle->Instance->SMCR | 0x4000;\n    }\n    TIM_handle->State = TIM_STATE_READY;\n    TIM_handle->Lock = TIM_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "called": [
                "TIM_ETR_SetConfig",
                "TIM_ITRx_SetConfig",
                "TIM_TI1_ConfigInputStage",
                "TIM_TI2_ConfigInputStage"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a94",
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "imported": false,
            "current_name": "configure_tim_clock_08003a94"
        },
        "FUN_0800416a": {
            "renaming": {
                "FUN_0800416a": "set_input_trigger_source_0800416a",
                "TIMx": "timer",
                "InputTriggerSource": "input_source",
                "tmpsmcr": "temporary_register"
            },
            "code": "\nvoid set_input_trigger_source_0800416a(TIM_TypeDef *timer,uint16_t input_source)\n\n{\n  uint32_t temporary_register;\n  \n  timer->SMCR = timer->SMCR & 0xffffff8f | (uint)(input_source | 7);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800416a",
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "imported": false,
            "current_name": "set_input_trigger_source_0800416a"
        },
        "FUN_080059f0": {
            "renaming": {
                "FUN_080059f0": "calculate_polynomial_approximation_080059f0",
                "__x": "x",
                "in_r0": "int_part",
                "uVar1": "product_high_1",
                "uVar2": "product_low_1",
                "in_r1": "x_bits",
                "uVar3": "product_high_2",
                "uVar4": "product_low_2",
                "extraout_r1": "extra_output_register_1",
                "in_r3": "temp_register",
                "unaff_r4": "unused_register_4",
                "uVar5": "product_high_3",
                "uVar6": "product_low_3",
                "uVar7": "absolute_x_bits",
                "iVar8": "approximation_index",
                "in_d0": "input_double",
                "dVar9": "output_double",
                "extraout_d0": "unused_output_double",
                "uVar10": "product_high",
                "uVar11": "product_low"
            },
            "code": "\ndouble calculate_polynomial_approximation_080059f0(double x)\n\n{\n  int int_part;\n  undefined4 product_high_1;\n  undefined4 product_low_1;\n  uint x_bits;\n  undefined4 product_high_2;\n  undefined4 product_low_2;\n  undefined4 extra_output_register_1;\n  undefined4 temp_register;\n  undefined4 unused_register_4;\n  undefined4 product_high_3;\n  undefined4 product_low_3;\n  uint absolute_x_bits;\n  int approximation_index;\n  double input_double;\n  double output_double;\n  double unused_output_double;\n  undefined8 product_high;\n  undefined8 product_low;\n  \n  product_high = CONCAT44(x_bits,int_part);\n  absolute_x_bits = x_bits & 0x7fffffff;\n  if (DAT_08005cd8 < (int)absolute_x_bits) {\n    if ((absolute_x_bits == DAT_08005cdc || (int)absolute_x_bits < (int)DAT_08005cdc) &&\n       ((absolute_x_bits != DAT_08005cdc || (int_part == 0)))) {\n      return input_double;\n    }\n    output_double = (double)__aeabi_dadd();\n  }\n  else {\n    if (DAT_08005cec < (int)absolute_x_bits) {\n      fabs((double)CONCAT44(unused_register_4,temp_register));\n      if (DAT_08005cfc < (int)absolute_x_bits) {\n        if (DAT_08005d00 < (int)absolute_x_bits) {\n          product_high = __divdf3(0,DAT_08005d08,int_part,extra_output_register_1);\n          approximation_index = 3;\n        }\n        else {\n          product_high = __subdf3();\n          product_low = __muldf3(int_part,extra_output_register_1,0,DAT_08005d04);\n          product_low = __aeabi_dadd((int)product_low,(int)((ulonglong)product_low >> 0x20),0,DAT_08005cf8);\n          product_high = __divdf3((int)product_high,(int)((ulonglong)product_high >> 0x20),(int)product_low,\n                            (int)((ulonglong)product_low >> 0x20));\n          approximation_index = 2;\n        }\n      }\n      else if (DAT_08005cfc + -0xd0000 < (int)absolute_x_bits) {\n        product_high = __subdf3();\n        product_low = __aeabi_dadd(int_part,extra_output_register_1,0,DAT_08005cf8);\n        product_high = __divdf3((int)product_high,(int)((ulonglong)product_high >> 0x20),(int)product_low,\n                          (int)((ulonglong)product_low >> 0x20));\n        approximation_index = 1;\n      }\n      else {\n        product_high = __aeabi_dadd();\n        product_high = __subdf3((int)product_high,(int)((ulonglong)product_high >> 0x20),0,DAT_08005cf8);\n        product_low = __aeabi_dadd(int_part,extra_output_register_1,0,0x40000000);\n        product_high = __divdf3((int)product_high,(int)((ulonglong)product_high >> 0x20),(int)product_low,\n                          (int)((ulonglong)product_low >> 0x20));\n        approximation_index = 0;\n      }\n    }\n    else {\n      if ((int)absolute_x_bits <= DAT_08005cec + -0x1bc0000) {\n        product_low = __aeabi_dadd(int_part,x_bits,DAT_08005cd0,DAT_08005cd4);\n        approximation_index = __aeabi_dcmpgt((int)product_low,(int)((ulonglong)product_low >> 0x20),0,DAT_08005cf8);\n        if (approximation_index != 0) {\n          return unused_output_double;\n        }\n      }\n      approximation_index = -1;\n    }\n    product_low_3 = (undefined4)((ulonglong)product_high >> 0x20);\n    product_high_3 = (undefined4)product_high;\n    product_high = __muldf3(product_high_3,product_low_3,product_high_3,product_low_3);\n    product_high_2 = (undefined4)((ulonglong)product_high >> 0x20);\n    product_high_1 = (undefined4)product_high;\n    product_high = __muldf3(product_high_1,product_high_2,product_high_1,product_high_2);\n    product_low_2 = (undefined4)((ulonglong)product_high >> 0x20);\n    product_low_1 = (undefined4)product_high;\n    product_high = __muldf3(product_low_1,product_low_2,DAT_08005c78,DAT_08005c7c);\n    product_high = __aeabi_dadd((int)product_high,(int)((ulonglong)product_high >> 0x20),DAT_08005c80,DAT_08005c84);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),product_low_1,product_low_2);\n    product_high = __aeabi_dadd((int)product_high,(int)((ulonglong)product_high >> 0x20),DAT_08005c88,DAT_08005c8c);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),product_low_1,product_low_2);\n    product_high = __aeabi_dadd((int)product_high,(int)((ulonglong)product_high >> 0x20),DAT_08005c90,DAT_08005c94);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),product_low_1,product_low_2);\n    product_high = __aeabi_dadd((int)product_high,(int)((ulonglong)product_high >> 0x20),DAT_08005c98,DAT_08005c9c);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),product_low_1,product_low_2);\n    product_high = __aeabi_dadd((int)product_high,(int)((ulonglong)product_high >> 0x20),DAT_08005ca0,DAT_08005ca4);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),product_high_1,product_high_2);\n    product_low = __muldf3(product_low_1,product_low_2,DAT_08005ca8,DAT_08005cac);\n    product_low = __subdf3((int)product_low,(int)((ulonglong)product_low >> 0x20),DAT_08005cb0,DAT_08005cb4);\n    product_low = __muldf3((int)product_low,(int)((ulonglong)product_low >> 0x20),product_low_1,product_low_2);\n    product_low = __subdf3((int)product_low,(int)((ulonglong)product_low >> 0x20),DAT_08005cb8,DAT_08005cbc);\n    product_low = __muldf3((int)product_low,(int)((ulonglong)product_low >> 0x20),product_low_1,product_low_2);\n    product_low = __subdf3((int)product_low,(int)((ulonglong)product_low >> 0x20),DAT_08005cc0,DAT_08005cc4);\n    product_low = __muldf3((int)product_low,(int)((ulonglong)product_low >> 0x20),product_low_1,product_low_2);\n    product_low = __subdf3((int)product_low,(int)((ulonglong)product_low >> 0x20),DAT_08005cc8,DAT_08005ccc);\n    product_low = __muldf3((int)product_low,(int)((ulonglong)product_low >> 0x20),product_low_1,product_low_2);\n    product_high = __aeabi_dadd((int)product_high,(int)((ulonglong)product_high >> 0x20),(int)product_low,\n                          (int)((ulonglong)product_low >> 0x20));\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),product_high_3,product_low_3);\n    product_high_1 = (undefined4)((ulonglong)product_high >> 0x20);\n    if (approximation_index == -1) {\n      output_double = (double)__subdf3(product_high_3,product_low_3,(int)product_high,product_high_1);\n      return output_double;\n    }\n    product_high = __subdf3((int)product_high,product_high_1,*(undefined4 *)(PTR_calculate_polynomial_approximation_080059f0lo_08005cf0 + approximation_index * 8),\n                      *(undefined4 *)((int)(PTR_calculate_polynomial_approximation_080059f0lo_08005cf0 + approximation_index * 8) + 4));\n    product_high = __subdf3((int)product_high,(int)((ulonglong)product_high >> 0x20),product_high_3,product_low_3);\n    output_double = (double)__subdf3(*(undefined4 *)(PTR_calculate_polynomial_approximation_080059f0hi_08005cf4 + approximation_index * 8),\n                             *(undefined4 *)((int)(PTR_calculate_polynomial_approximation_080059f0hi_08005cf4 + approximation_index * 8) + 4),(int)product_high\n                             ,(int)((ulonglong)product_high >> 0x20));\n    if ((int)x_bits < 0) {\n      return output_double;\n    }\n  }\n  return output_double;\n}\n\n",
            "called": [
                "__subdf3",
                "__aeabi_dcmpgt",
                "__muldf3",
                "__divdf3",
                "__aeabi_dadd",
                "fabs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080059f0",
            "calling": [
                "__ieee754_atan2"
            ],
            "imported": false,
            "current_name": "calculate_polynomial_approximation_080059f0"
        },
        "FUN_08001ccc": {
            "renaming": {
                "FUN_08001ccc": "i2_c_mem_write_08001ccc",
                "hi2c": "I2C_handle",
                "DevAddress": "DeviceAddress",
                "MemAddress": "MemoryAddress",
                "MemAddSize": "MemoryAddressSize",
                "pData": "Data",
                "Size": "DataSize",
                "Tickstart": "StartTick",
                "uVar1": "Var1",
                "HVar2": "Status",
                "uVar3": "Var3",
                "cVar4": "CharVar",
                "uVar5": "Var5",
                "iVar6": "IntVar",
                "pbVar7": "BytePtr",
                "bVar8": "BoolVar",
                "tickstart": "StartTick2"
            },
            "code": "\nHAL_StatusTypeDef\nI2C_Mem_Write_08001ccc(I2C_HandleTypeDef *I2C_handle,uint16_t DeviceAddress,uint16_t MemoryAddress,\n                 uint16_t MemoryAddressSize,uint8_t *Data,uint16_t DataSize,uint32_t Timeout)\n\n{\n  uint Var1;\n  HAL_StatusTypeDef Status;\n  uint32_t StartTick;\n  uint32_t Var3;\n  char CharVar;\n  uint Var5;\n  int IntVar;\n  byte *BytePtr;\n  bool BoolVar;\n  uint32_t StartTick2;\n  \n  StartTick = HAL_GetTick();\n  Var1 = DAT_08001f64;\n  if (I2C_handle->State == HAL_I2C_STATE_READY) {\n    do {\n      if ((Var1 >> 0x10 & 0xff) == 1) {\n        Var5 = Var1 & ~I2C_handle->Instance->SR1 & 0xffff;\n        BoolVar = Var5 == 0;\n        if (BoolVar) {\n          Var5 = 1;\n        }\n        CharVar = (char)Var5;\n        if (!BoolVar) {\n          CharVar = '\\0';\n        }\n      }\n      else {\n        Var5 = Var1 & ~I2C_handle->Instance->SR2 & 0xffff;\n        BoolVar = Var5 == 0;\n        if (BoolVar) {\n          Var5 = 1;\n        }\n        CharVar = (char)Var5;\n        if (!BoolVar) {\n          CharVar = '\\0';\n        }\n      }\n      if (CharVar != '\\x01') {\n        IntVar = 0;\n        goto LAB_08001d9c;\n      }\n      Var3 = HAL_GetTick();\n    } while (Var3 - StartTick < 0x1a);\n    I2C_handle->PreviousState = 0;\n    I2C_handle->State = HAL_I2C_STATE_READY;\n    I2C_handle->Mode = HAL_I2C_MODE_NONE;\n    I2C_handle->Lock = HAL_UNLOCKED;\n    IntVar = 3;\nLAB_08001d9c:\n    if (IntVar == 0) {\n      if (I2C_handle->Lock == HAL_LOCKED) {\n        Status = HAL_BUSY;\n      }\n      else {\n        I2C_handle->Lock = HAL_LOCKED;\n        if ((I2C_handle->Instance->CR1 & 1) != 1) {\n          I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 | 1;\n        }\n        I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 & 0xfffff7ff;\n        I2C_handle->State = HAL_I2C_STATE_BUSY_TX;\n        I2C_handle->Mode = HAL_I2C_MODE_MEM;\n        I2C_handle->ErrorCode = 0;\n        I2C_handle->pBuffPtr = Data;\n        I2C_handle->XferCount = DataSize;\n        I2C_handle->XferOptions = DAT_08001f68;\n        I2C_handle->XferDataSize = I2C_handle->XferCount;\n        Status = I2C_RequestMemoryWrite(I2C_handle,DeviceAddress,MemoryAddress,MemoryAddressSize,Timeout,StartTick);\n        if (Status == HAL_OK) {\n          while (I2C_handle->XferDataSize != 0) {\n            Status = I2C_WaitOnTXEFlagUntilTimeout(I2C_handle,Timeout,StartTick);\n            if (Status != HAL_OK) {\n              if (I2C_handle->ErrorCode == 4) {\n                I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 | 0x200;\n                return HAL_ERROR;\n              }\n              return HAL_TIMEOUT;\n            }\n            BytePtr = I2C_handle->pBuffPtr;\n            I2C_handle->pBuffPtr = BytePtr + 1;\n            I2C_handle->Instance->DR = (uint)*BytePtr;\n            I2C_handle->XferDataSize = I2C_handle->XferDataSize - 1;\n            I2C_handle->XferCount = I2C_handle->XferCount - 1;\n            if (((I2C_handle->Instance->SR1 & 4) == 4) && (I2C_handle->XferDataSize != 0)) {\n              BytePtr = I2C_handle->pBuffPtr;\n              I2C_handle->pBuffPtr = BytePtr + 1;\n              I2C_handle->Instance->DR = (uint)*BytePtr;\n              I2C_handle->XferDataSize = I2C_handle->XferDataSize - 1;\n              I2C_handle->XferCount = I2C_handle->XferCount - 1;\n            }\n          }\n          Status = I2C_WaitOnBTFFlagUntilTimeout(I2C_handle,Timeout,StartTick);\n          if (Status == HAL_OK) {\n            I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 | 0x200;\n            I2C_handle->State = HAL_I2C_STATE_READY;\n            I2C_handle->Mode = HAL_I2C_MODE_NONE;\n            I2C_handle->Lock = HAL_UNLOCKED;\n            Status = HAL_OK;\n          }\n          else if (I2C_handle->ErrorCode == 4) {\n            I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 | 0x200;\n            Status = HAL_ERROR;\n          }\n          else {\n            Status = HAL_TIMEOUT;\n          }\n        }\n        else if (I2C_handle->ErrorCode == 4) {\n          I2C_handle->Lock = HAL_UNLOCKED;\n          Status = HAL_ERROR;\n        }\n        else {\n          I2C_handle->Lock = HAL_UNLOCKED;\n          Status = HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      Status = HAL_BUSY;\n    }\n  }\n  else {\n    Status = HAL_BUSY;\n  }\n  return Status;\n}\n\n",
            "called": [
                "I2C_WaitOnBTFFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_RequestMemoryWrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001ccc",
            "calling": [
                "_i2c_write_reg"
            ],
            "imported": false,
            "current_name": "i2_c_mem_write_08001ccc"
        },
        "FUN_0800157c": {
            "renaming": {
                "FUN_0800157c": "update_tick_0800157c"
            },
            "code": "\nvoid update_tick_0800157c(void)\n\n{\n  *(uint *)PTR_uwTick_0800159c = *(int *)PTR_uwTick_0800159c + (uint)(byte)*PTR_uwTickFreq_08001598;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800157c",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "update_tick_0800157c"
        },
        "FUN_0800121c": {
            "renaming": {
                "FUN_0800121c": "calculate_division_0800121c",
                "param_1": "dividend",
                "param_2": "dividend_high",
                "param_3": "divisor",
                "param_4": "divisor_high",
                "param_5": "remainder",
                "UNRECOVERED_JUMPTABLE": "unrecovered_jumptable",
                "uVar1": "temp_var1",
                "uVar2": "quotient",
                "puVar3": "quotient_ptr",
                "uVar4": "quotient_low",
                "uVar5": "mul_result",
                "uVar6": "shift_amount",
                "uVar7": "temp_var2",
                "uVar8": "temp_var3",
                "uVar11": "quotient_mid",
                "uVar12": "divisor_low",
                "uVar13": "mul_result_low",
                "bVar14": "carry_flag",
                "uVar15": "result"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 calculate_division_0800121c(uint dividend,uint dividend_high,uint divisor,uint divisor_high,uint *remainder)\n\n{\n  code *unrecovered_jumptable;\n  ulonglong temp_var1;\n  uint quotient;\n  uint *quotient_ptr;\n  uint quotient_low;\n  uint mul_result;\n  uint shift_amount;\n  uint temp_var2;\n  uint temp_var3;\n  uint *puVar9;\n  uint *ptemp_var10;\n  uint quotient_mid;\n  uint divisor_low;\n  uint mul_result_low;\n  bool carry_flag;\n  undefined8 result;\n  \n  if (divisor_high == 0) {\n    if (dividend_high < divisor) {\n      shift_amount = count_leading_zeroes(divisor);\n      if (shift_amount != 0) {\n        divisor = divisor << (shift_amount & 0xff);\n        dividend_high = dividend >> (0x20 - shift_amount & 0xff) | dividend_high << (shift_amount & 0xff);\n        dividend = dividend << (shift_amount & 0xff);\n      }\n      divisor_low = divisor >> 0x10;\n      temp_var3 = dividend_high / divisor_low;\n      quotient_mid = temp_var3 * (divisor & 0xffff);\n      temp_var2 = dividend >> 0x10 | (dividend_high - divisor_low * temp_var3) * 0x10000;\n      quotient_low = temp_var3;\n      if (temp_var2 <= quotient_mid && quotient_mid - temp_var2 != 0) {\n        carry_flag = CARRY4(divisor,temp_var2);\n        temp_var2 = divisor + temp_var2;\n        quotient_low = temp_var3 - 1;\n        if ((carry_flag == false) && (temp_var2 <= quotient_mid && quotient_mid - temp_var2 != 0)) {\n          quotient_low = temp_var3 - 2;\n          temp_var2 = temp_var2 + divisor;\n        }\n      }\n      quotient = (temp_var2 - quotient_mid) / divisor_low;\n      mul_result = quotient * (divisor & 0xffff);\n      temp_var3 = dividend & 0xffff | ((temp_var2 - quotient_mid) - divisor_low * quotient) * 0x10000;\n      temp_var2 = quotient;\n      if (temp_var3 <= mul_result && mul_result - temp_var3 != 0) {\n        carry_flag = CARRY4(divisor,temp_var3);\n        temp_var3 = divisor + temp_var3;\n        temp_var2 = quotient - 1;\n        if ((carry_flag == false) && (temp_var3 <= mul_result && mul_result - temp_var3 != 0)) {\n          temp_var2 = quotient - 2;\n          temp_var3 = temp_var3 + divisor;\n        }\n      }\n      quotient_ptr = (uint *)(temp_var2 | quotient_low << 0x10);\n      puVar9 = (uint *)0x0;\n      temp_var3 = temp_var3 - mul_result;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Could not recover jumptable at 0x08001302. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        unrecovered_jumptable = (code *)software_udf(0xff,0x8001302);\n        result = (*unrecovered_jumptable)();\n        return result;\n      }\n      shift_amount = count_leading_zeroes(divisor);\n      if (shift_amount == 0) {\n        puVar9 = (uint *)0x1;\n        dividend_high = dividend_high - divisor;\n        divisor_low = divisor >> 0x10;\n        quotient = divisor & 0xffff;\n      }\n      else {\n        divisor = divisor << (shift_amount & 0xff);\n        quotient_low = dividend_high >> (0x20 - shift_amount & 0xff);\n        divisor_low = divisor >> 0x10;\n        quotient_mid = quotient_low / divisor_low;\n        quotient = divisor & 0xffff;\n        mul_result = quotient_mid * quotient;\n        temp_var3 = dividend >> (0x20 - shift_amount & 0xff) | dividend_high << (shift_amount & 0xff);\n        temp_var2 = temp_var3 >> 0x10 | (quotient_low - divisor_low * quotient_mid) * 0x10000;\n        dividend = dividend << (shift_amount & 0xff);\n        quotient_low = quotient_mid;\n        if (temp_var2 <= mul_result && mul_result - temp_var2 != 0) {\n          carry_flag = CARRY4(divisor,temp_var2);\n          temp_var2 = divisor + temp_var2;\n          quotient_low = quotient_mid - 1;\n          if ((carry_flag == false) && (temp_var2 <= mul_result && mul_result - temp_var2 != 0)) {\n            quotient_low = quotient_mid - 2;\n            temp_var2 = temp_var2 + divisor;\n          }\n        }\n        quotient_mid = (temp_var2 - mul_result) / divisor_low;\n        mul_result_low = quotient_mid * quotient;\n        dividend_high = temp_var3 & 0xffff | ((temp_var2 - mul_result) - divisor_low * quotient_mid) * 0x10000;\n        temp_var2 = quotient_mid;\n        if (dividend_high <= mul_result_low && mul_result_low - dividend_high != 0) {\n          carry_flag = CARRY4(divisor,dividend_high);\n          dividend_high = divisor + dividend_high;\n          temp_var2 = quotient_mid - 1;\n          if ((carry_flag == false) && (dividend_high <= mul_result_low && mul_result_low - dividend_high != 0)) {\n            temp_var2 = quotient_mid - 2;\n            dividend_high = dividend_high + divisor;\n          }\n        }\n        dividend_high = dividend_high - mul_result_low;\n        puVar9 = (uint *)(temp_var2 | quotient_low << 0x10);\n      }\n      quotient_mid = dividend_high / divisor_low;\n      temp_var2 = quotient * quotient_mid;\n      temp_var3 = dividend >> 0x10 | (dividend_high - divisor_low * quotient_mid) * 0x10000;\n      quotient_low = quotient_mid;\n      if (temp_var3 <= temp_var2 && temp_var2 - temp_var3 != 0) {\n        carry_flag = CARRY4(divisor,temp_var3);\n        temp_var3 = divisor + temp_var3;\n        quotient_low = quotient_mid - 1;\n        if ((carry_flag == false) && (temp_var3 <= temp_var2 && temp_var2 - temp_var3 != 0)) {\n          quotient_low = quotient_mid - 2;\n          temp_var3 = temp_var3 + divisor;\n        }\n      }\n      quotient_mid = (temp_var3 - temp_var2) / divisor_low;\n      quotient = quotient * quotient_mid;\n      temp_var3 = dividend & 0xffff | ((temp_var3 - temp_var2) - divisor_low * quotient_mid) * 0x10000;\n      temp_var2 = quotient_mid;\n      if (temp_var3 <= quotient && quotient - temp_var3 != 0) {\n        carry_flag = CARRY4(divisor,temp_var3);\n        temp_var3 = divisor + temp_var3;\n        temp_var2 = quotient_mid - 1;\n        if ((carry_flag == false) && (temp_var3 <= quotient && quotient - temp_var3 != 0)) {\n          temp_var2 = quotient_mid - 2;\n          temp_var3 = temp_var3 + divisor;\n        }\n      }\n      temp_var3 = temp_var3 - quotient;\n      quotient_ptr = (uint *)(temp_var2 | quotient_low << 0x10);\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = temp_var3 >> (shift_amount & 0xff);\n      remainder[1] = 0;\n    }\n  }\n  else {\n    puVar9 = remainder;\n    if (dividend_high < divisor_high) {\n      quotient_ptr = remainder;\n      if (remainder != (uint *)0x0) {\n        *remainder = dividend;\n        remainder[1] = dividend_high;\n        return 0;\n      }\n    }\n    else {\n      ptemp_var10 = (uint *)count_leading_zeroes(divisor_high);\n      if (ptemp_var10 == (uint *)0x0) {\n        if ((divisor_high < dividend_high) || (quotient_ptr = ptemp_var10, divisor <= dividend)) {\n          carry_flag = dividend < divisor;\n          dividend = dividend - divisor;\n          dividend_high = (dividend_high - divisor_high) - (uint)carry_flag;\n          quotient_ptr = (uint *)0x1;\n        }\n        puVar9 = ptemp_var10;\n        if (remainder != (uint *)0x0) {\n          *remainder = dividend;\n          remainder[1] = dividend_high;\n        }\n      }\n      else {\n        temp_var3 = 0x20 - (int)ptemp_var10;\n        quotient = divisor >> (temp_var3 & 0xff) | divisor_high << ((uint)ptemp_var10 & 0xff);\n        shift_amount = dividend_high >> (temp_var3 & 0xff);\n        mul_result = quotient >> 0x10;\n        quotient_mid = shift_amount / mul_result;\n        divisor_low = quotient_mid * (quotient & 0xffff);\n        quotient_low = dividend_high << ((uint)ptemp_var10 & 0xff) | dividend >> (temp_var3 & 0xff);\n        temp_var2 = quotient_low >> 0x10 | (shift_amount - mul_result * quotient_mid) * 0x10000;\n        divisor = divisor << ((uint)ptemp_var10 & 0xff);\n        dividend = dividend << ((uint)ptemp_var10 & 0xff);\n        shift_amount = quotient_mid;\n        if (temp_var2 <= divisor_low && divisor_low - temp_var2 != 0) {\n          carry_flag = CARRY4(quotient,temp_var2);\n          temp_var2 = quotient + temp_var2;\n          shift_amount = quotient_mid - 1;\n          if ((carry_flag == false) && (temp_var2 <= divisor_low && divisor_low - temp_var2 != 0)) {\n            shift_amount = quotient_mid - 2;\n            temp_var2 = temp_var2 + quotient;\n          }\n        }\n        quotient_mid = (temp_var2 - divisor_low) / mul_result;\n        mul_result_low = quotient_mid * (quotient & 0xffff);\n        temp_var2 = quotient_low & 0xffff | ((temp_var2 - divisor_low) - mul_result * quotient_mid) * 0x10000;\n        quotient_low = quotient_mid;\n        if (temp_var2 <= mul_result_low && mul_result_low - temp_var2 != 0) {\n          carry_flag = CARRY4(quotient,temp_var2);\n          temp_var2 = quotient + temp_var2;\n          quotient_low = quotient_mid - 1;\n          if ((carry_flag == false) && (temp_var2 <= mul_result_low && mul_result_low - temp_var2 != 0)) {\n            quotient_low = quotient_mid - 2;\n            temp_var2 = temp_var2 + quotient;\n          }\n        }\n        quotient_ptr = (uint *)(quotient_low | shift_amount << 0x10);\n        temp_var1 = ZEXT48(quotient_ptr) * (ulonglong)divisor;\n        if (CONCAT44(temp_var2 - mul_result_low,dividend) < temp_var1) {\n          quotient_ptr = (uint *)((int)quotient_ptr + -1);\n          temp_var1 = temp_var1 - CONCAT44(quotient,divisor);\n        }\n        if (remainder != (uint *)0x0) {\n          shift_amount = ((temp_var2 - mul_result_low) - (int)(temp_var1 >> 0x20)) - (uint)(dividend < (uint)temp_var1);\n          *remainder = shift_amount << (temp_var3 & 0xff) | dividend - (uint)temp_var1 >> ((uint)ptemp_var10 & 0xff);\n          remainder[1] = shift_amount >> ((uint)ptemp_var10 & 0xff);\n          puVar9 = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(puVar9,quotient_ptr);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800121c",
            "calling": [
                "__aeabi_uldivmod"
            ],
            "imported": false,
            "current_name": "calculate_division_0800121c"
        },
        "FUN_080036f8": {
            "renaming": {
                "FUN_080036f8": "handle_timer_interrupts_080036f8",
                "htim": "timer_handle",
                "Instance": "timer_instance",
                "SR": "status_register",
                "DIER": "interrupt_enable_register",
                "Channel": "active_channel",
                "HAL_TIM_ACTIVE_CHANNEL_1": "channel_1",
                "HAL_TIM_ACTIVE_CHANNEL_2": "channel_2",
                "HAL_TIM_ACTIVE_CHANNEL_3": "channel_3",
                "HAL_TIM_ACTIVE_CHANNEL_4": "channel_4",
                "HAL_TIM_ACTIVE_CHANNEL_CLEARED": "channel_cleared",
                "CCMR1": "capture_compare_mode_register_1",
                "CCMR2": "capture_compare_mode_register_2",
                "HAL_TIM_OC_DelayElapsedCallback": "output_compare_delay_elapsed_callback",
                "HAL_TIM_PWM_PulseFinishedCallback": "pulse_width_modulation_pulse_finished_callback",
                "HAL_TIM_IC_CaptureCallback": "input_capture_callback",
                "HAL_TIM_PeriodElapsedCallback": "period_elapsed_callback",
                "HAL_TIMEx_BreakCallback": "break_callback",
                "HAL_TIM_TriggerCallback": "trigger_callback",
                "HAL_TIMEx_CommutationCallback": "commutation_callback"
            },
            "code": "\nvoid handle_timer_interrupts_080036f8(TIM_HandleTypeDef *timer_handle)\n\n{\n  if (((timer_handle->timer_instance->status_register & 2) == 2) && ((timer_handle->timer_instance->interrupt_enable_register & 2) == 2)) {\n    timer_handle->timer_instance->status_register = 0xfffffffd;\n    timer_handle->active_channel = channel_1;\n    if ((timer_handle->timer_instance->capture_compare_mode_register_1 & 3) == 0) {\n      output_compare_delay_elapsed_callback(timer_handle);\n      pulse_width_modulation_pulse_finished_callback(timer_handle);\n    }\n    else {\n      input_capture_callback(timer_handle);\n    }\n    timer_handle->active_channel = channel_cleared;\n  }\n  if (((timer_handle->timer_instance->status_register & 4) == 4) && ((timer_handle->timer_instance->interrupt_enable_register & 4) == 4)) {\n    timer_handle->timer_instance->status_register = 0xfffffffb;\n    timer_handle->active_channel = channel_2;\n    if ((timer_handle->timer_instance->capture_compare_mode_register_1 & 0x300) == 0) {\n      output_compare_delay_elapsed_callback(timer_handle);\n      pulse_width_modulation_pulse_finished_callback(timer_handle);\n    }\n    else {\n      input_capture_callback(timer_handle);\n    }\n    timer_handle->active_channel = channel_cleared;\n  }\n  if (((timer_handle->timer_instance->status_register & 8) == 8) && ((timer_handle->timer_instance->interrupt_enable_register & 8) == 8)) {\n    timer_handle->timer_instance->status_register = 0xfffffff7;\n    timer_handle->active_channel = channel_3;\n    if ((timer_handle->timer_instance->capture_compare_mode_register_2 & 3) == 0) {\n      output_compare_delay_elapsed_callback(timer_handle);\n      pulse_width_modulation_pulse_finished_callback(timer_handle);\n    }\n    else {\n      input_capture_callback(timer_handle);\n    }\n    timer_handle->active_channel = channel_cleared;\n  }\n  if (((timer_handle->timer_instance->status_register & 0x10) == 0x10) && ((timer_handle->timer_instance->interrupt_enable_register & 0x10) == 0x10)) {\n    timer_handle->timer_instance->status_register = 0xffffffef;\n    timer_handle->active_channel = channel_4;\n    if ((timer_handle->timer_instance->capture_compare_mode_register_2 & 0x300) == 0) {\n      output_compare_delay_elapsed_callback(timer_handle);\n      pulse_width_modulation_pulse_finished_callback(timer_handle);\n    }\n    else {\n      input_capture_callback(timer_handle);\n    }\n    timer_handle->active_channel = channel_cleared;\n  }\n  if (((timer_handle->timer_instance->status_register & 1) == 1) && ((timer_handle->timer_instance->interrupt_enable_register & 1) == 1)) {\n    timer_handle->timer_instance->status_register = 0xfffffffe;\n    period_elapsed_callback(timer_handle);\n  }\n  if (((timer_handle->timer_instance->status_register & 0x80) == 0x80) && ((timer_handle->timer_instance->interrupt_enable_register & 0x80) == 0x80)) {\n    timer_handle->timer_instance->status_register = 0xffffff7f;\n    break_callback(timer_handle);\n  }\n  if (((timer_handle->timer_instance->status_register & 0x40) == 0x40) && ((timer_handle->timer_instance->interrupt_enable_register & 0x40) == 0x40)) {\n    timer_handle->timer_instance->status_register = 0xffffffbf;\n    trigger_callback(timer_handle);\n  }\n  if (((timer_handle->timer_instance->status_register & 0x20) == 0x20) && ((timer_handle->timer_instance->interrupt_enable_register & 0x20) == 0x20)) {\n    timer_handle->timer_instance->status_register = 0xffffffdf;\n    commutation_callback(timer_handle);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIMEx_BreakCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036f8",
            "calling": [
                "TIM2_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupts_080036f8"
        },
        "FUN_080009e8": {
            "renaming": {
                "FUN_080009e8": "string_terminator_check_080009e8",
                "in_CY": "string_terminator",
                "__aeabi_cdrcmple": "check_if_string_terminator_reached"
            },
            "code": "\nbool string_terminator_check_080009e8(void)\n\n{\n  char string_terminator;\n  \n  check_if_string_terminator_reached();\n  return string_terminator == '\\0';\n}\n\n",
            "called": [
                "__aeabi_cdrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009e8",
            "calling": [
                "_dtoa_r",
                "_svfprintf_r",
                "atan"
            ],
            "imported": false,
            "current_name": "string_terminator_check_080009e8"
        },
        "FUN_08009630": {
            "renaming": {
                "FUN_08009630": "calculate_integer_division_08009630",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "shift_amount",
                "param_4": "mask",
                "param_5": "quotient",
                "param_6": "remainder",
                "iVar1": "dividend_ptr",
                "uVar2": "shifted_bits",
                "iVar3": "trailing_zeros",
                "iVar4": "divisor_type",
                "uVar5": "shifted_mask",
                "uVar6": "mask_type",
                "uVar7": "leading_zeros",
                "local_20": "shifted_dividend",
                "local_1c": "divisor_mask"
            },
            "code": "\nint calculate_integer_division_08009630(undefined4 dividend,undefined4 divisor,uint shift_amount,uint mask,int *quotient,int *remainder)\n\n{\n  int dividend_ptr;\n  uint shifted_bits;\n  int trailing_zeros;\n  int divisor_type;\n  uint shifted_mask;\n  uint mask_type;\n  undefined8 leading_zeros;\n  uint shifted_dividend;\n  uint divisor_mask;\n  \n  dividend_ptr = _Balloc(dividend,1);\n  mask_type = (mask << 1) >> 0x15;\n  divisor_mask = mask & 0xfffff;\n  if (mask_type != 0) {\n    divisor_mask = divisor_mask | 0x100000;\n  }\n  if (shift_amount == 0) {\n    trailing_zeros = __lo0bits(&divisor_mask);\n    divisor_type = 1;\n    shifted_bits = trailing_zeros + 0x20;\n    *(undefined4 *)(dividend_ptr + 0x10) = 1;\n    *(uint *)(dividend_ptr + 0x14) = divisor_mask;\n  }\n  else {\n    shifted_dividend = shift_amount;\n    shifted_bits = __lo0bits(&shifted_dividend);\n    if (shifted_bits == 0) {\n      *(uint *)(dividend_ptr + 0x14) = shifted_dividend;\n    }\n    else {\n      shifted_mask = divisor_mask << (0x20 - shifted_bits & 0xff);\n      divisor_mask = divisor_mask >> (shifted_bits & 0xff);\n      *(uint *)(dividend_ptr + 0x14) = shifted_mask | shifted_dividend;\n    }\n    if (divisor_mask == 0) {\n      divisor_type = 1;\n    }\n    else {\n      divisor_type = 2;\n    }\n    *(uint *)(dividend_ptr + 0x18) = divisor_mask;\n    *(int *)(dividend_ptr + 0x10) = divisor_type;\n  }\n  if (mask_type == 0) {\n    *quotient = shifted_bits - 0x432;\n    leading_zeros = __hi0bits(*(undefined4 *)(dividend_ptr + divisor_type * 4 + 0x10));\n    *remainder = (int)((ulonglong)leading_zeros >> 0x20) * 0x20 - (int)leading_zeros;\n    return dividend_ptr;\n  }\n  *quotient = (mask_type - 0x433) + shifted_bits;\n  *remainder = 0x35 - shifted_bits;\n  return dividend_ptr;\n}\n\n",
            "called": [
                "_Balloc",
                "__hi0bits",
                "__lo0bits"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009630",
            "calling": [
                "_dtoa_r"
            ],
            "imported": false,
            "current_name": "calculate_integer_division_08009630"
        },
        "FUN_08005830": {
            "renaming": {
                "FUN_08005830": "infinite_loop_08005830"
            },
            "code": "\nvoid infinite_loop_08005830(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "USBWakeUp_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005830",
            "calling": [
                "USBWakeUp_IRQHandler"
            ],
            "imported": false,
            "current_name": "infinite_loop_08005830"
        },
        "FUN_08005714": {
            "renaming": {
                "FUN_08005714": "handle_timer_interrupt_08005714",
                "HAL_TIM_IRQHandler": "handle_timer_irq"
            },
            "code": "\nvoid handle_timer_interrupt_08005714(void)\n\n{\n  handle_timer_irq((TIM_HandleTypeDef *)PTR_htim2_08005724);\n  return;\n}\n\n",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005714",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08005714"
        },
        "FUN_08005834": {
            "renaming": {
                "FUN_08005834": "calculate_atan2_08005834",
                "param_1": "y",
                "param_2": "x",
                "param_3": "z",
                "param_4": "w",
                "param_5": "magnitude",
                "iVar1": "difference",
                "unaff_r4": "unused",
                "uVar2": "quadrant",
                "uVar3": "abs_w",
                "uVar4": "abs_x",
                "uVar5": "difference_magnitude"
            },
            "code": "\nvoid calculate_atan2_08005834(uint y,uint x,uint z,uint w,double magnitude)\n\n{\n  int difference;\n  undefined4 unused;\n  uint quadrant;\n  uint abs_w;\n  uint abs_x;\n  undefined8 difference_magnitude;\n  \n  abs_w = w & 0x7fffffff;\n  if ((DAT_080059e8 < (abs_w | (-z | z) >> 0x1f)) ||\n     (abs_x = x & 0x7fffffff, DAT_080059e8 < (abs_x | (-y | y) >> 0x1f))) {\n    __aeabi_dadd(z,w,y,x);\n  }\n  else {\n    if ((w + 0xc0100000 | z) == 0) {\n      atan(magnitude);\n      return;\n    }\n    quadrant = (int)w >> 0x1e & 2U | x >> 0x1f;\n    if (((((abs_x | y) != 0) && ((abs_w | z) != 0)) && (abs_w != DAT_080059e8)) &&\n       (abs_x != DAT_080059e8)) {\n      difference = (int)(abs_x - abs_w) >> 0x14;\n      if ((difference < 0x3d) && ((-1 < (int)w || (difference + 0x3c < 0 == SCARRY4(difference,0x3c))))) {\n        __divdf3(y,x);\n        fabs((double)CONCAT44(unused,w));\n        atan((double)CONCAT44(unused,w));\n      }\n      if (quadrant != 1) {\n        if (quadrant == 2) {\n          difference_magnitude = __subdf3();\n          __subdf3(DAT_080059b0,DAT_080059b4,(int)difference_magnitude,(int)((ulonglong)difference_magnitude >> 0x20));\n        }\n        else if (quadrant != 0) {\n          difference_magnitude = __subdf3();\n          __subdf3((int)difference_magnitude,(int)((ulonglong)difference_magnitude >> 0x20),DAT_080059b0,DAT_080059b4);\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "__ieee754_atan2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005834",
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calc_pitch"
            ],
            "imported": false,
            "current_name": "calculate_atan2_08005834"
        },
        "FUN_08005838": {
            "renaming": {
                "FUN_08005838": "calculate_atan_or_subtract_08005838",
                "param_1": "dividend_low",
                "param_2": "dividend_high",
                "param_3": "divisor_low",
                "param_4": "divisor_high",
                "param_5": "input_value",
                "iVar1": "difference",
                "unaff_r4": "undefined_var",
                "uVar2": "shifted_dividend_high_or_low",
                "uVar3": "shifted_divisor_high_or_low",
                "uVar4": "unsigned_dividend",
                "uVar5": "subtracted_result"
            },
            "code": "\nvoid calculate_atan_or_subtract_08005838(uint dividend_low,uint dividend_high,uint divisor_low,uint divisor_high,double input_value)\n\n{\n  int difference;\n  undefined4 undefined_var;\n  uint shifted_dividend_high_or_low;\n  uint shifted_divisor_high_or_low;\n  uint unsigned_dividend;\n  undefined8 subtracted_result;\n  \n  shifted_divisor_high_or_low = divisor_high & 0x7fffffff;\n  if ((DAT_080059e8 < (shifted_divisor_high_or_low | (-divisor_low | divisor_low) >> 0x1f)) ||\n     (unsigned_dividend = dividend_high & 0x7fffffff, DAT_080059e8 < (unsigned_dividend | (-dividend_low | dividend_low) >> 0x1f))) {\n    __aeabi_dadd(divisor_low,divisor_high,dividend_low,dividend_high);\n  }\n  else {\n    if ((divisor_high + 0xc0100000 | divisor_low) == 0) {\n      atan(input_value);\n      return;\n    }\n    shifted_dividend_high_or_low = (int)divisor_high >> 0x1e & 2U | dividend_high >> 0x1f;\n    if (((((unsigned_dividend | dividend_low) != 0) && ((shifted_divisor_high_or_low | divisor_low) != 0)) && (shifted_divisor_high_or_low != DAT_080059e8)) &&\n       (unsigned_dividend != DAT_080059e8)) {\n      difference = (int)(unsigned_dividend - shifted_divisor_high_or_low) >> 0x14;\n      if ((difference < 0x3d) && ((-1 < (int)divisor_high || (difference + 0x3c < 0 == SCARRY4(difference,0x3c))))) {\n        __divdf3(dividend_low,dividend_high);\n        fabs((double)CONCAT44(undefined_var,divisor_high));\n        atan((double)CONCAT44(undefined_var,divisor_high));\n      }\n      if (shifted_dividend_high_or_low != 1) {\n        if (shifted_dividend_high_or_low == 2) {\n          subtracted_result = __subdf3();\n          __subdf3(DAT_080059b0,DAT_080059b4,(int)subtracted_result,(int)((ulonglong)subtracted_result >> 0x20));\n        }\n        else if (shifted_dividend_high_or_low != 0) {\n          subtracted_result = __subdf3();\n          __subdf3((int)subtracted_result,(int)((ulonglong)subtracted_result >> 0x20),DAT_080059b0,DAT_080059b4);\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "__subdf3",
                "__divdf3",
                "__aeabi_dadd",
                "atan",
                "fabs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005838",
            "calling": [
                "atan2"
            ],
            "imported": false,
            "current_name": "calculate_atan_or_subtract_08005838"
        },
        "FUN_080096e0": {
            "renaming": {
                "FUN_080096e0": "calculate_exponent_and_mantissa_080096e0",
                "__x": "input_value",
                "__exponent": "output_exponent",
                "in_r1": "input_bits",
                "extraout_r1": "output_bits",
                "in_r2": "output_exponent_pointer",
                "iVar1": "MAXIMUM_EXPONENT",
                "iVar2": "ADJUSTMENT",
                "uVar3": "abs_input_bits",
                "in_d0": "result"
            },
            "code": "\ndouble calculate_exponent_and_mantissa_080096e0(double input_value,int *output_exponent)\n\n{\n  int MAXIMUM_EXPONENT;\n  uint input_bits;\n  uint output_bits;\n  int *output_exponent_pointer;\n  int ADJUSTMENT;\n  uint abs_input_bits;\n  double result;\n  \n  MAXIMUM_EXPONENT = DAT_08009740;\n  ADJUSTMENT = 0;\n  abs_input_bits = input_bits & 0x7fffffff;\n  *output_exponent_pointer = 0;\n  if (((int)abs_input_bits <= MAXIMUM_EXPONENT) && ((abs_input_bits | (uint)output_exponent) != 0)) {\n    if (abs_input_bits < 0x100000) {\n      result = (double)__muldf3(output_exponent,input_bits,0,DAT_0800973c);\n      ADJUSTMENT = -0x36;\n      abs_input_bits = output_bits & 0x7fffffff;\n    }\n    *output_exponent_pointer = ((int)abs_input_bits >> 0x14) + -0x3fe + ADJUSTMENT;\n  }\n  return result;\n}\n\n",
            "called": [
                "__muldf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080096e0",
            "calling": [
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "calculate_exponent_and_mantissa_080096e0"
        },
        "FUN_08003540": {
            "renaming": {
                "FUN_08003540": "get_apb_prescaler_value_08003540",
                "uVar1": "HCLK_frequency"
            },
            "code": "\nuint32_t get_APB_prescaler_value_08003540(void)\n\n{\n  uint32_t HCLK_frequency;\n  \n  HCLK_frequency = HAL_RCC_GetHCLKFreq();\n  return HCLK_frequency >> PTR_APBPrescTable_08003564[*(uint *)(DAT_08003560 + 4) >> 0xb & 7];\n}\n\n",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003540",
            "calling": [
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "get_apb_prescaler_value_08003540"
        },
        "FUN_08001ab0": {
            "renaming": {
                "FUN_08001ab0": "configure_i2c_08001ab0",
                "hi2c": "i2c_handle",
                "uVar1": "pclk1_freq",
                "cVar2": "freqrange_valid",
                "HVar3": "status",
                "uVar4": "pclk1",
                "uVar5": "trise",
                "bVar6": "is_zero",
                "pclk1": "HAL_RCC_GetPCLK1Freq()"
            },
            "code": "\nHAL_StatusTypeDef configure_i2c_08001ab0(I2C_HandleTypeDef *i2c_handle)\n\n{\n  uint32_t pclk1_freq;\n  char freqrange_valid;\n  HAL_StatusTypeDef status;\n  uint32_t pclk1;\n  uint trise;\n  bool is_zero;\n  uint32_t HAL_RCC_GetPCLK1Freq();\n  uint32_t freqrange;\n  \n  if (i2c_handle == (I2C_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    if (i2c_handle->State == HAL_I2C_STATE_RESET) {\n      i2c_handle->Lock = HAL_UNLOCKED;\n      HAL_I2C_MspInit(i2c_handle);\n    }\n    i2c_handle->State = HAL_I2C_STATE_BUSY;\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffffe;\n    pclk1_freq = HAL_RCC_GetPCLK1Freq();\n    if (DAT_08001ca4 < (i2c_handle->Init).ClockSpeed) {\n      pclk1 = pclk1_freq;\n      if (pclk1_freq <= DAT_08001cac) {\n        pclk1 = 1;\n      }\n      freqrange_valid = (char)pclk1;\n      if (DAT_08001cac < pclk1_freq) {\n        freqrange_valid = '\\0';\n      }\n    }\n    else {\n      pclk1 = pclk1_freq;\n      if (pclk1_freq <= DAT_08001ca8) {\n        pclk1 = 1;\n      }\n      freqrange_valid = (char)pclk1;\n      if (DAT_08001ca8 < pclk1_freq) {\n        freqrange_valid = '\\0';\n      }\n    }\n    if (freqrange_valid == '\\0') {\n      trise = (uint)((ulonglong)DAT_08001cb0 * (ulonglong)pclk1_freq >> 0x32);\n      i2c_handle->Instance->CR2 = trise;\n      if (DAT_08001ca4 < (i2c_handle->Init).ClockSpeed) {\n        trise = (uint)((ulonglong)DAT_08001cb4 * (ulonglong)(trise * 300) >> 0x26);\n      }\n      i2c_handle->Instance->TRISE = trise + 1;\n      if (DAT_08001ca4 < (i2c_handle->Init).ClockSpeed) {\n        if ((i2c_handle->Init).DutyCycle == 0) {\n          trise = (pclk1_freq - 1) / ((i2c_handle->Init).ClockSpeed * 3) + 1 & 0xfff;\n          is_zero = trise == 0;\n          if (is_zero) {\n            trise = 1;\n          }\n          freqrange_valid = (char)trise;\n          if (!is_zero) {\n            freqrange_valid = '\\0';\n          }\n        }\n        else {\n          trise = (pclk1_freq - 1) / ((i2c_handle->Init).ClockSpeed * 0x19) + 1 & 0xfff;\n          is_zero = trise == 0;\n          if (is_zero) {\n            trise = 1;\n          }\n          freqrange_valid = (char)trise;\n          if (!is_zero) {\n            freqrange_valid = '\\0';\n          }\n        }\n        if (freqrange_valid == '\\0') {\n          if ((i2c_handle->Init).DutyCycle == 0) {\n            pclk1_freq = (pclk1_freq - 1) / ((i2c_handle->Init).ClockSpeed * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            pclk1_freq = (pclk1_freq - 1) / ((i2c_handle->Init).ClockSpeed * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          pclk1_freq = 1;\n        }\n      }\n      else {\n        pclk1_freq = (pclk1_freq - 1) / ((i2c_handle->Init).ClockSpeed << 1) + 1 & 0xfff;\n        if (pclk1_freq < 4) {\n          pclk1_freq = 4;\n        }\n      }\n      i2c_handle->Instance->CCR = pclk1_freq;\n      i2c_handle->Instance->CR1 = (i2c_handle->Init).NoStretchMode | (i2c_handle->Init).GeneralCallMode;\n      i2c_handle->Instance->OAR1 = (i2c_handle->Init).OwnAddress1 | (i2c_handle->Init).AddressingMode;\n      i2c_handle->Instance->OAR2 = (i2c_handle->Init).OwnAddress2 | (i2c_handle->Init).DualAddressMode;\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 1;\n      i2c_handle->ErrorCode = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->PreviousState = 0;\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      status = HAL_OK;\n    }\n    else {\n      status = HAL_ERROR;\n    }\n  }\n  return status;\n}\n\n",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_I2C_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001ab0",
            "calling": [
                "MX_I2C1_Init"
            ],
            "imported": false,
            "current_name": "configure_i2c_08001ab0"
        },
        "FUN_08000150": {
            "renaming": {
                "FUN_08000150": "calculate_double_precision_floating_point_08000150",
                "param_1": "significand_a",
                "param_2": "exponent_a",
                "param_3": "significand_b",
                "param_4": "exponent_b",
                "uVar3": "sum_low",
                "uVar4": "significand_a_bits",
                "uVar5": "sum_high",
                "uVar7": "significand_b_bits",
                "uVar8": "significand_a_copy",
                "uVar9": "significand_b_copy",
                "uVar10": "diff",
                "uVar11": "bit_mask",
                "uVar12": "sum",
                "bVar13": "same_sign",
                "bVar14": "condition",
                "bVar15": "carry",
                "iVar1": "exponent_a_copy",
                "iVar6": "exponent_b_copy"
            },
            "code": "\nulonglong calculate_double_precision_floating_point_08000150(uint significand_a,uint exponent_a,uint significand_b,uint exponent_b)\n\n{\n  int exponent_a_copy;\n  byte bVar2;\n  uint sum_low;\n  uint significand_a_bits;\n  uint sum_high;\n  int exponent_b_copy;\n  uint significand_b_bits;\n  uint significand_a_copy;\n  uint significand_b_copy;\n  uint diff;\n  uint bit_mask;\n  uint sum;\n  bool same_sign;\n  bool condition;\n  bool carry;\n  \n  significand_a_bits = exponent_a ^ 0x80000000;\n  significand_b_bits = exponent_a << 1;\n  significand_b_copy = exponent_b << 1;\n  same_sign = ((significand_a_bits ^ exponent_b) & 0x7fffffff) == 0;\n  condition = same_sign && significand_a == significand_b;\n  if (!same_sign || significand_a != significand_b) {\n    condition = (significand_b_bits | significand_a) == 0;\n  }\n  if (!condition) {\n    condition = (significand_b_copy | significand_b) == 0;\n  }\n  exponent_b_copy = (int)significand_b_bits >> 0x15;\n  if (!condition) {\n    condition = exponent_b_copy == -1;\n  }\n  exponent_a_copy = (int)significand_b_copy >> 0x15;\n  if (!condition) {\n    condition = exponent_a_copy == -1;\n  }\n  if (condition) {\n    if (exponent_b_copy == -1 || exponent_a_copy == -1) {\n      significand_b_copy = exponent_b;\n      significand_b_bits = significand_b;\n      if (exponent_b_copy == -1) {\n        significand_b_copy = significand_a_bits;\n        significand_b_bits = significand_a;\n      }\n      if (exponent_b_copy != -1 || exponent_a_copy != -1) {\n        significand_b = significand_b_bits;\n        exponent_b = significand_b_copy;\n      }\n      condition = (significand_b_bits | significand_b_copy << 0xc) == 0;\n      if (condition) {\n        condition = (significand_b | exponent_b << 0xc) == 0;\n      }\n      if (condition) {\n        condition = significand_b_copy == exponent_b;\n      }\n      if (!condition) {\n        significand_b_copy = significand_b_copy | 0x80000;\n      }\n      return CONCAT44(significand_b_copy,significand_b_bits);\n    }\n    if (((significand_a_bits ^ exponent_b) & 0x7fffffff) != 0 || significand_a != significand_b) {\n      if ((significand_b_bits | significand_a) == 0) {\n        significand_a = significand_b;\n        significand_a_bits = exponent_b;\n      }\n      return CONCAT44(significand_a_bits,significand_a);\n    }\n    if (significand_a_bits != exponent_b) {\n      return 0;\n    }\n    if (significand_b_bits >> 0x15 == 0) {\n      condition = (significand_a & 0x80000000) != 0;\n      significand_b_copy = exponent_a * 2 + (uint)condition;\n      if (CARRY4(significand_a_bits,significand_a_bits) || CARRY4(exponent_a * 2,(uint)condition)) {\n        significand_b_copy = significand_b_copy | 0x80000000;\n      }\n      return CONCAT44(significand_b_copy,significand_a << 1);\n    }\n    if (significand_b_bits < 0xffc00000) {\n      return CONCAT44(significand_a_bits + 0x100000,significand_a);\n    }\n    significand_a_bits = significand_a_bits & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(significand_a_bits | 0x7ff00000) << 0x20;\n  }\n  significand_b_bits = significand_b_bits >> 0x15;\n  significand_b_copy = significand_b_copy >> 0x15;\n  diff = significand_b_copy - significand_b_bits;\n  condition = diff != 0;\n  if (significand_b_copy < significand_b_bits) {\n    diff = -diff;\n  }\n  significand_a_copy = significand_a;\n  sum = significand_a_bits;\n  if (condition && significand_b_bits <= significand_b_copy) {\n    significand_b_bits = significand_b_bits + diff;\n    significand_a_copy = significand_b;\n    sum = exponent_b;\n    significand_b = significand_a;\n    exponent_b = significand_a_bits;\n  }\n  if (0x36 < diff) {\n    return CONCAT44(sum,significand_a_copy);\n  }\n  significand_b_copy = sum & 0xfffff | 0x100000;\n  if ((sum & 0x80000000) != 0) {\n    condition = significand_a_copy != 0;\n    significand_a_copy = -significand_a_copy;\n    significand_b_copy = -significand_b_copy - (uint)condition;\n  }\n  significand_a_bits = exponent_b & 0xfffff | 0x100000;\n  if ((exponent_b & 0x80000000) != 0) {\n    condition = significand_b != 0;\n    significand_b = -significand_b;\n    significand_a_bits = -significand_a_bits - (uint)condition;\n  }\n  if (significand_b_bits == diff) {\n    significand_a_bits = significand_a_bits ^ 0x100000;\n    if (significand_b_bits == 0) {\n      significand_b_copy = significand_b_copy ^ 0x100000;\n      significand_b_bits = 1;\n    }\n    else {\n      diff = diff - 1;\n    }\n  }\n  sum = -diff + 0x20;\n  if ((int)diff < 0x21) {\n    bit_mask = significand_b << (sum & 0xff);\n    significand_b = significand_b >> (diff & 0xff);\n    sum_low = significand_a_copy + significand_b;\n    sum_high = significand_a_bits << (sum & 0xff);\n    sum = sum_low + sum_high;\n    significand_b_copy = significand_b_copy + CARRY4(significand_a_copy,significand_b) + ((int)significand_a_bits >> (diff & 0xff)) +\n            (uint)CARRY4(sum_low,sum_high);\n  }\n  else {\n    bit_mask = significand_a_bits << (-diff + 0x40 & 0xff);\n    if (significand_b != 0) {\n      bit_mask = bit_mask | 2;\n    }\n    significand_a_bits = (int)significand_a_bits >> (diff - 0x20 & 0xff);\n    sum = significand_a_copy + significand_a_bits;\n    significand_b_copy = significand_b_copy + ((int)significand_a_bits >> 0x1f) + (uint)CARRY4(significand_a_copy,significand_a_bits);\n  }\n  significand_a_bits = significand_b_copy & 0x80000000;\n  diff = significand_b_copy;\n  if ((int)significand_b_copy < 0) {\n    condition = bit_mask == 0;\n    bit_mask = -bit_mask;\n    diff = -sum;\n    sum = -(uint)!condition - sum;\n    diff = -(uint)(condition <= diff) - significand_b_copy;\n  }\n  if (0xfffff < diff) {\n    significand_a_copy = significand_b_bits - 1;\n    if (0x1fffff < diff) {\n      significand_b_copy = diff & 1;\n      diff = diff >> 1;\n      bVar2 = (byte)sum;\n      sum = (uint)(significand_b_copy != 0) << 0x1f | sum >> 1;\n      bit_mask = (uint)(bVar2 & 1) << 0x1f | bit_mask >> 1;\n      significand_a_copy = significand_b_bits;\n      if (0xffbfffff < significand_b_bits * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    condition = 0x7fffffff < bit_mask;\n    if (bit_mask == 0x80000000) {\n      condition = (sum & 1) != 0;\n    }\n    return CONCAT44(diff + significand_a_copy * 0x100000 + (uint)CARRY4(sum,(uint)condition) | significand_a_bits,\n                    sum + condition);\n  }\n  same_sign = (bit_mask & 0x80000000) != 0;\n  bit_mask = bit_mask << 1;\n  significand_a_copy = sum * 2;\n  condition = CARRY4(sum,sum);\n  sum = sum * 2 + (uint)same_sign;\n  diff = diff * 2 + (uint)(condition || CARRY4(significand_a_copy,(uint)same_sign));\n  significand_a_copy = significand_b_bits - 2;\n  if ((diff & 0x100000) != 0) goto LAB_08000268;\n  sum_low = sum;\n  significand_b_bits = diff;\n  if (diff == 0) {\n    sum_low = 0;\n    significand_b_bits = sum;\n  }\n  exponent_b_copy = count_leading_zeroes(significand_b_bits);\n  if (diff == 0) {\n    exponent_b_copy = exponent_b_copy + 0x20;\n  }\n  sum = exponent_b_copy - 0xb;\n  carry = SBORROW4(sum,0x20);\n  diff = exponent_b_copy - 0x2b;\n  condition = (int)diff < 0;\n  same_sign = diff == 0;\n  if ((int)sum < 0x20) {\n    carry = SCARRY4(diff,0xc);\n    exponent_b_copy = exponent_b_copy + -0x1f;\n    condition = exponent_b_copy < 0;\n    same_sign = exponent_b_copy == 0;\n    diff = sum;\n    if (!same_sign && condition == carry) {\n      sum_low = significand_b_bits << (sum & 0xff);\n      significand_b_bits = significand_b_bits >> (0xcU - exponent_b_copy & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (same_sign || condition != carry) {\n    bit_mask = 0x20 - diff;\n  }\n  significand_b_bits = significand_b_bits << (diff & 0xff);\n  if (same_sign || condition != carry) {\n    significand_b_bits = significand_b_bits | sum_low >> (bit_mask & 0xff);\n  }\n  if (same_sign || condition != carry) {\n    sum_low = sum_low << (diff & 0xff);\n  }\nLAB_080002e0:\n  if ((int)sum <= (int)significand_a_copy) {\n    return CONCAT44(significand_b_bits + (significand_a_copy - sum) * 0x100000 | significand_a_bits,sum_low);\n  }\n  diff = ~(significand_a_copy - sum);\n  if ((int)diff < 0x1f) {\n    exponent_b_copy = diff - 0x13;\n    if (exponent_b_copy != 0 && exponent_b_copy < 0 == SCARRY4(diff - 0x1f,0xc)) {\n      return CONCAT44(significand_b_copy,sum_low >> (0x20 - (0xcU - exponent_b_copy) & 0xff) | significand_b_bits << (0xcU - exponent_b_copy & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    diff = diff + 1;\n    return CONCAT44(significand_a_bits | significand_b_bits >> (diff & 0xff),\n                    sum_low >> (diff & 0xff) | significand_b_bits << (0x20 - diff & 0xff));\n  }\n  return CONCAT44(significand_b_copy,significand_b_bits >> (diff - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000150",
            "calling": [],
            "imported": false,
            "current_name": "calculate_double_precision_floating_point_08000150"
        },
        "FUN_08000158": {
            "renaming": {
                "FUN_08000158": "calculate_double_precision_08000158",
                "param_1": "a_low",
                "param_2": "a_high",
                "param_3": "b_low",
                "param_4": "b_high",
                "uVar3": "carry",
                "uVar4": "a_low_bits",
                "uVar5": "b_low_bits",
                "uVar9": "a_shifted",
                "uVar10": "shift",
                "uVar11": "diff",
                "uVar12": "a_sign_bit",
                "bVar2": "bit",
                "bVar13": "a_is_negative",
                "bVar14": "condition",
                "bVar15": "overflow",
                "iVar1": "b_high_bits",
                "iVar8": "leading_zeros"
            },
            "code": "\nulonglong calculate_double_precision_08000158(uint a_low,uint a_high,uint b_low,uint b_high)\n\n{\n  int b_high_bits;\n  byte bit;\n  uint carry;\n  uint a_low_bits;\n  uint b_low_bits;\n  uint uVar6;\n  uint uVar7;\n  int leading_zeros;\n  uint a_shifted;\n  uint shift;\n  uint diff;\n  uint a_sign_bit;\n  bool a_is_negative;\n  bool condition;\n  bool overflow;\n  \n  uVar6 = b_high ^ 0x80000000;\n  a_shifted = a_high << 1;\n  b_high = b_high << 1;\n  a_is_negative = ((a_high ^ uVar6) & 0x7fffffff) == 0;\n  condition = a_is_negative && a_low == b_low;\n  if (!a_is_negative || a_low != b_low) {\n    condition = (a_shifted | a_low) == 0;\n  }\n  if (!condition) {\n    condition = (b_high | b_low) == 0;\n  }\n  leading_zeros = (int)a_shifted >> 0x15;\n  if (!condition) {\n    condition = leading_zeros == -1;\n  }\n  b_high_bits = (int)b_high >> 0x15;\n  if (!condition) {\n    condition = b_high_bits == -1;\n  }\n  if (condition) {\n    if (leading_zeros == -1 || b_high_bits == -1) {\n      a_shifted = uVar6;\n      diff = b_low;\n      if (leading_zeros == -1) {\n        a_shifted = a_high;\n        diff = a_low;\n      }\n      if (leading_zeros != -1 || b_high_bits != -1) {\n        b_low = diff;\n        uVar6 = a_shifted;\n      }\n      condition = (diff | a_shifted << 0xc) == 0;\n      if (condition) {\n        condition = (b_low | uVar6 << 0xc) == 0;\n      }\n      if (condition) {\n        condition = a_shifted == uVar6;\n      }\n      if (!condition) {\n        a_shifted = a_shifted | 0x80000;\n      }\n      return CONCAT44(a_shifted,diff);\n    }\n    if (((a_high ^ uVar6) & 0x7fffffff) != 0 || a_low != b_low) {\n      if ((a_shifted | a_low) == 0) {\n        a_low = b_low;\n        a_high = uVar6;\n      }\n      return CONCAT44(a_high,a_low);\n    }\n    if (a_high != uVar6) {\n      return 0;\n    }\n    if (a_shifted >> 0x15 == 0) {\n      condition = (a_low & 0x80000000) != 0;\n      uVar6 = a_high * 2 + (uint)condition;\n      if (CARRY4(a_high,a_high) || CARRY4(a_high * 2,(uint)condition)) {\n        uVar6 = uVar6 | 0x80000000;\n      }\n      return CONCAT44(uVar6,a_low << 1);\n    }\n    if (a_shifted < 0xffc00000) {\n      return CONCAT44(a_high + 0x100000,a_low);\n    }\n    a_high = a_high & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(a_high | 0x7ff00000) << 0x20;\n  }\n  a_shifted = a_shifted >> 0x15;\n  b_high = b_high >> 0x15;\n  diff = b_high - a_shifted;\n  condition = diff != 0;\n  if (b_high < a_shifted) {\n    diff = -diff;\n  }\n  shift = a_low;\n  uVar7 = a_high;\n  if (condition && a_shifted <= b_high) {\n    a_shifted = a_shifted + diff;\n    shift = b_low;\n    uVar7 = uVar6;\n    b_low = a_low;\n    uVar6 = a_high;\n  }\n  if (0x36 < diff) {\n    return CONCAT44(uVar7,shift);\n  }\n  a_low_bits = uVar7 & 0xfffff | 0x100000;\n  if ((uVar7 & 0x80000000) != 0) {\n    condition = shift != 0;\n    shift = -shift;\n    a_low_bits = -a_low_bits - (uint)condition;\n  }\n  uVar7 = uVar6 & 0xfffff | 0x100000;\n  if ((uVar6 & 0x80000000) != 0) {\n    condition = b_low != 0;\n    b_low = -b_low;\n    uVar7 = -uVar7 - (uint)condition;\n  }\n  if (a_shifted == diff) {\n    uVar7 = uVar7 ^ 0x100000;\n    if (a_shifted == 0) {\n      a_low_bits = a_low_bits ^ 0x100000;\n      a_shifted = 1;\n    }\n    else {\n      diff = diff - 1;\n    }\n  }\n  uVar6 = -diff + 0x20;\n  if ((int)diff < 0x21) {\n    a_sign_bit = b_low << (uVar6 & 0xff);\n    b_low = b_low >> (diff & 0xff);\n    carry = shift + b_low;\n    b_low_bits = uVar7 << (uVar6 & 0xff);\n    uVar6 = carry + b_low_bits;\n    a_low_bits = a_low_bits + CARRY4(shift,b_low) + ((int)uVar7 >> (diff & 0xff)) +\n            (uint)CARRY4(carry,b_low_bits);\n  }\n  else {\n    a_sign_bit = uVar7 << (-diff + 0x40 & 0xff);\n    if (b_low != 0) {\n      a_sign_bit = a_sign_bit | 2;\n    }\n    uVar7 = (int)uVar7 >> (diff - 0x20 & 0xff);\n    uVar6 = shift + uVar7;\n    a_low_bits = a_low_bits + ((int)uVar7 >> 0x1f) + (uint)CARRY4(shift,uVar7);\n  }\n  a_high = a_low_bits & 0x80000000;\n  diff = a_low_bits;\n  if ((int)a_low_bits < 0) {\n    condition = a_sign_bit == 0;\n    a_sign_bit = -a_sign_bit;\n    diff = -uVar6;\n    uVar6 = -(uint)!condition - uVar6;\n    diff = -(uint)(condition <= diff) - a_low_bits;\n  }\n  if (0xfffff < diff) {\n    shift = a_shifted - 1;\n    if (0x1fffff < diff) {\n      shift = diff & 1;\n      diff = diff >> 1;\n      bit = (byte)uVar6;\n      uVar6 = (uint)(shift != 0) << 0x1f | uVar6 >> 1;\n      a_sign_bit = (uint)(bit & 1) << 0x1f | a_sign_bit >> 1;\n      shift = a_shifted;\n      if (0xffbfffff < a_shifted * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    condition = 0x7fffffff < a_sign_bit;\n    if (a_sign_bit == 0x80000000) {\n      condition = (uVar6 & 1) != 0;\n    }\n    return CONCAT44(diff + shift * 0x100000 + (uint)CARRY4(uVar6,(uint)condition) | a_high,\n                    uVar6 + condition);\n  }\n  a_is_negative = (a_sign_bit & 0x80000000) != 0;\n  a_sign_bit = a_sign_bit << 1;\n  shift = uVar6 * 2;\n  condition = CARRY4(uVar6,uVar6);\n  uVar6 = uVar6 * 2 + (uint)a_is_negative;\n  diff = diff * 2 + (uint)(condition || CARRY4(shift,(uint)a_is_negative));\n  shift = a_shifted - 2;\n  if ((diff & 0x100000) != 0) goto LAB_08000268;\n  uVar7 = uVar6;\n  a_shifted = diff;\n  if (diff == 0) {\n    uVar7 = 0;\n    a_shifted = uVar6;\n  }\n  leading_zeros = count_leading_zeroes(a_shifted);\n  if (diff == 0) {\n    leading_zeros = leading_zeros + 0x20;\n  }\n  diff = leading_zeros - 0xb;\n  overflow = SBORROW4(diff,0x20);\n  uVar6 = leading_zeros - 0x2b;\n  condition = (int)uVar6 < 0;\n  a_is_negative = uVar6 == 0;\n  if ((int)diff < 0x20) {\n    overflow = SCARRY4(uVar6,0xc);\n    leading_zeros = leading_zeros + -0x1f;\n    condition = leading_zeros < 0;\n    a_is_negative = leading_zeros == 0;\n    uVar6 = diff;\n    if (!a_is_negative && condition == overflow) {\n      uVar7 = a_shifted << (diff & 0xff);\n      a_shifted = a_shifted >> (0xcU - leading_zeros & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (a_is_negative || condition != overflow) {\n    a_sign_bit = 0x20 - uVar6;\n  }\n  a_shifted = a_shifted << (uVar6 & 0xff);\n  if (a_is_negative || condition != overflow) {\n    a_shifted = a_shifted | uVar7 >> (a_sign_bit & 0xff);\n  }\n  if (a_is_negative || condition != overflow) {\n    uVar7 = uVar7 << (uVar6 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)diff <= (int)shift) {\n    return CONCAT44(a_shifted + (shift - diff) * 0x100000 | a_high,uVar7);\n  }\n  uVar6 = ~(shift - diff);\n  if ((int)uVar6 < 0x1f) {\n    leading_zeros = uVar6 - 0x13;\n    if (leading_zeros != 0 && leading_zeros < 0 == SCARRY4(uVar6 - 0x1f,0xc)) {\n      return CONCAT44(a_low_bits,uVar7 >> (0x20 - (0xcU - leading_zeros) & 0xff) | a_shifted << (0xcU - leading_zeros & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar6 = uVar6 + 1;\n    return CONCAT44(a_high | a_shifted >> (uVar6 & 0xff),\n                    uVar7 >> (uVar6 & 0xff) | a_shifted << (0x20 - uVar6 & 0xff));\n  }\n  return CONCAT44(a_low_bits,a_shifted >> (uVar6 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000158",
            "calling": [
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch",
                "_svfprintf_r",
                "atan"
            ],
            "imported": false,
            "current_name": "calculate_double_precision_08000158"
        },
        "FUN_08009768": {
            "renaming": {
                "FUN_08009768": "copy_string_08009768",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "cVar1": "current_char",
                "puVar2": "source_as_uint",
                "puVar3": "destination_as_uint",
                "puVar4": "current_uint",
                "uVar5": "current_uint_value"
            },
            "code": "\nchar * copy_string_08009768(char *destination,char *source,size_t length)\n\n{\n  char current_char;\n  uint *source_as_uint;\n  uint *destination_as_uint;\n  uint *current_uint;\n  uint current_uint_value;\n  \n  destination_as_uint = (uint *)destination;\n  if (((((uint)destination | (uint)source) & 3) == 0) && (source_as_uint = (uint *)source, 3 < length)) {\n    do {\n      source = (char *)(source_as_uint + 1);\n      current_uint_value = *source_as_uint;\n      if ((current_uint_value + 0xfefefeff & ~current_uint_value & 0x80808080) != 0) goto LAB_0800979c;\n      length = length - 4;\n      source_as_uint = destination_as_uint + 1;\n      *destination_as_uint = current_uint_value;\n      destination_as_uint = source_as_uint;\n      source_as_uint = (uint *)source;\n    } while (3 < length);\n  }\n  source_as_uint = (uint *)source;\n  if (length != 0) {\nLAB_0800979c:\n    current_char = *(char *)source_as_uint;\n    *(char *)destination_as_uint = current_char;\n    while( true ) {\n      destination_as_uint = (uint *)((int)destination_as_uint + 1);\n      length = length - 1;\n      if (current_char == '\\0') break;\n      if (length == 0) {\n        return destination;\n      }\n      source_as_uint = (uint *)((int)source_as_uint + 1);\n      current_char = *(char *)source_as_uint;\n      *(char *)destination_as_uint = current_char;\n    }\n    if (length != 0) {\n      source_as_uint = destination_as_uint;\n      do {\n        current_uint = (uint *)((int)source_as_uint + 1);\n        *(char *)source_as_uint = '\\0';\n        source_as_uint = current_uint;\n      } while (current_uint != (uint *)(length + (int)destination_as_uint));\n    }\n  }\n  return destination;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009768",
            "calling": [
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "copy_string_08009768"
        },
        "FUN_08001008": {
            "renaming": {
                "FUN_08001008": "compare_floats_08001008",
                "in_ZR": "is_zero",
                "in_CY": "are_equal",
                "__aeabi_cfcmpeq": "compare_floats_using_ARM_library"
            },
            "code": "\nbool compare_floats_08001008(void)\n\n{\n  undefined is_zero;\n  undefined are_equal;\n  \n  compare_floats_08001008_using_ARM_library();\n  return !(bool)are_equal || (bool)is_zero;\n}\n\n",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001008",
            "calling": [],
            "imported": false,
            "current_name": "compare_floats_08001008"
        },
        "FUN_08003ff8": {
            "renaming": {
                "FUN_08003ff8": "configure_timer_output_compare_08003ff8",
                "TIMx": "timer",
                "OC_Config": "output_compare_config",
                "uVar1": "output_compare_mode",
                "uVar2": "output_compare_polarity",
                "tmpccer": "temporary_ccer_value",
                "tmpccmrx": "temporary_ccmrx_value",
                "tmpcr2": "temporary_cr2_value"
            },
            "code": "\nvoid configure_timer_output_compare_08003ff8(TIM_TypeDef *timer,TIM_OC_InitTypeDef *output_compare_config)\n\n{\n  uint32_t output_compare_mode;\n  uint32_t output_compare_polarity;\n  uint32_t temporary_ccer_value;\n  uint32_t temporary_ccmrx_value;\n  uint32_t temporary_cr2_value;\n  \n  timer->CCER = timer->CCER & 0xffffefff;\n  temporary_cr2_value = timer->CR2;\n  output_compare_mode = output_compare_config->OCMode;\n  output_compare_polarity = output_compare_config->OCPolarity;\n  if (timer == DAT_0800409c) {\n    temporary_cr2_value = output_compare_config->OCIdleState << 6 | temporary_cr2_value & 0xffffbfff;\n  }\n  timer->CR2 = temporary_cr2_value;\n  timer->CCMR2 = output_compare_mode << 8 | timer->CCMR2 & 0xffff8cff;\n  timer->CCR4 = output_compare_config->Pulse;\n  timer->CCER = output_compare_polarity << 0xc | timer->CCER & 0xffffdfff;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ff8",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_output_compare_08003ff8"
        },
        "FUN_08004ea4": {
            "renaming": {
                "FUN_08004ea4": "i2c_write_data_08004ea4",
                "addr": "device_address",
                "reg": "register_address",
                "len": "data_length"
            },
            "code": "\nvoid i2c_write_data_08004ea4(uint8_t device_address,uint8_t register_address,uint8_t *data,uint16_t data_length)\n\n{\n  HAL_I2C_Mem_Write((I2C_HandleTypeDef *)PTR_hi2c1_08004ee4,(ushort)device_address,(ushort)register_address,1,data,data_length,\n                    *(uint32_t *)PTR_I2C_TIMEOUT_08004ee0);\n  return;\n}\n\n",
            "called": [
                "HAL_I2C_Mem_Write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ea4",
            "calling": [],
            "imported": false,
            "current_name": "i2c_write_data_08004ea4"
        },
        "FUN_08005728": {
            "renaming": {
                "FUN_08005728": "extend_heap_08005728",
                "incr": "increment",
                "puVar1": "errno_ptr",
                "auStack_18": "heap_pointer",
                "local_14": "new_size",
                "prev_heap_end": "previous_heap_end"
            },
            "code": "\ncaddr_t extend_heap_08005728(int increment)\n\n{\n  undefined4 *errno_ptr;\n  undefined heap_pointer [4];\n  int new_size;\n  char *previous_heap_end;\n  \n  if (*(int *)PTR_heap_end_08005778 == 0) {\n    *(undefined **)PTR_heap_end_08005778 = PTR_end_0800577c;\n  }\n  previous_heap_end = *(char **)PTR_heap_end_08005778;\n  if (heap_pointer < (undefined *)(increment + *(int *)PTR_heap_end_08005778)) {\n    new_size = increment;\n    errno_ptr = (undefined4 *)__errno();\n    *errno_ptr = 0xc;\n    previous_heap_end = (caddr_t)0xffffffff;\n  }\n  else {\n    *(int *)PTR_heap_end_08005778 = increment + *(int *)PTR_heap_end_08005778;\n  }\n  return previous_heap_end;\n}\n\n",
            "called": [
                "__errno"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005728",
            "calling": [
                "_sbrk_r"
            ],
            "imported": false,
            "current_name": "extend_heap_08005728"
        },
        "FUN_08003e38": {
            "renaming": {
                "FUN_08003e38": "configure_tim_oc_08003e38",
                "TIMx": "timer",
                "OC_Config": "output_compare_config",
                "uVar1": "oc_mode",
                "uVar2": "oc_polarity_and_ccer",
                "tmpccmrx": "ccmrx",
                "tmpcr2": "cr2",
                "tmpccer": "ccer"
            },
            "code": "\nvoid configure_TIM_OC_08003e38(TIM_TypeDef *timer,TIM_OC_InitTypeDef *output_compare_config)\n\n{\n  uint32_t oc_mode;\n  uint32_t oc_polarity_and_ccer;\n  uint32_t ccmrx;\n  uint32_t cr2;\n  uint32_t ccer;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  cr2 = timer->CR2;\n  oc_mode = output_compare_config->OCMode;\n  oc_polarity_and_ccer = output_compare_config->OCPolarity << 4 | timer->CCER & 0xffffffdf;\n  if (timer == DAT_08003f14) {\n    oc_polarity_and_ccer = (output_compare_config->OCNPolarity << 4 | oc_polarity_and_ccer & 0xffffff7f) & 0xffffffbf;\n    cr2 = output_compare_config->OCNIdleState << 2 | output_compare_config->OCIdleState << 2 | cr2 & 0xfffff3ff;\n  }\n  timer->CR2 = cr2;\n  timer->CCMR1 = oc_mode << 8 | timer->CCMR1 & 0xffff8cff;\n  timer->CCR2 = output_compare_config->Pulse;\n  timer->CCER = oc_polarity_and_ccer;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003e38",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_tim_oc_08003e38"
        },
        "FUN_080006a4": {
            "renaming": {
                "FUN_080006a4": "binary_to_float_080006a4",
                "param_1": "sign_bit",
                "param_2": "exponent_bits",
                "param_3": "mantissa_bits_1",
                "param_4": "mantissa_bits_2",
                "uVar1": "bit_1",
                "unaff_r4": "bit_2",
                "uVar2": "bit_3",
                "uVar3": "temp_exponent_bits",
                "in_r12": "mask",
                "bVar4": "is_zero"
            },
            "code": "\nulonglong binary_to_float_080006a4(uint sign_bit,uint exponent_bits,uint mantissa_bits_1,uint mantissa_bits_2)\n\n{\n  uint bit_1;\n  uint bit_2;\n  uint bit_3;\n  uint temp_exponent_bits;\n  uint mask;\n  bool is_zero;\n  \n  bit_3 = mask & mantissa_bits_2 >> 0x14;\n  if (bit_2 != mask && bit_3 != mask) {\n    is_zero = (sign_bit | exponent_bits << 1) == 0;\n    if (!is_zero) {\n      is_zero = (mantissa_bits_1 | mantissa_bits_2 << 1) == 0;\n    }\n    if (is_zero) {\n      return (ulonglong)((exponent_bits ^ mantissa_bits_2) & 0x80000000) << 0x20;\n    }\n    if (bit_2 == 0) {\n      temp_exponent_bits = exponent_bits & 0x80000000;\n      do {\n        bit_1 = sign_bit & 0x80000000;\n        sign_bit = sign_bit << 1;\n        exponent_bits = exponent_bits * 2 + (uint)(bit_1 != 0);\n      } while ((exponent_bits & 0x100000) == 0);\n      exponent_bits = exponent_bits | temp_exponent_bits;\n      if (bit_3 != 0) {\n        return CONCAT44(exponent_bits,sign_bit);\n      }\n    }\n    do {\n      bit_3 = mantissa_bits_1 & 0x80000000;\n      mantissa_bits_1 = mantissa_bits_1 << 1;\n      mantissa_bits_2 = mantissa_bits_2 * 2 + (uint)(bit_3 != 0);\n    } while ((mantissa_bits_2 & 0x100000) == 0);\n    return CONCAT44(exponent_bits,sign_bit);\n  }\n  is_zero = (sign_bit | exponent_bits << 1) == 0;\n  if (is_zero) {\n    exponent_bits = mantissa_bits_2;\n    sign_bit = mantissa_bits_1;\n  }\n  if (!is_zero) {\n    is_zero = (mantissa_bits_1 | mantissa_bits_2 << 1) == 0;\n  }\n  temp_exponent_bits = exponent_bits;\n  if (((!is_zero) && ((bit_2 != mask || ((sign_bit | exponent_bits << 0xc) == 0)))) &&\n     ((bit_3 != mask || (sign_bit = mantissa_bits_1, temp_exponent_bits = mantissa_bits_2, (mantissa_bits_1 | mantissa_bits_2 << 0xc) == 0)))) {\n    return (ulonglong)((exponent_bits ^ mantissa_bits_2) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(temp_exponent_bits,sign_bit) | 0x7ff8000000000000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080006a4",
            "calling": [
                "__muldf3"
            ],
            "imported": false,
            "current_name": "binary_to_float_080006a4"
        },
        "FUN_08009530": {
            "renaming": {
                "FUN_08009530": "compare_and_alloc_08009530",
                "param_1": "mem_pool",
                "param_2": "data1",
                "param_3": "data2",
                "puVar2": "data2_ptr",
                "uVar3": "data1_size",
                "uVar4": "carry",
                "iVar5": "result",
                "puVar6": "ptr1",
                "puVar7": "ptr1_copy",
                "puVar8": "result_ptr",
                "puVar9": "ptr2",
                "puVar10": "ptr2_copy2",
                "puVar11": "data1_end",
                "puVar13": "data2_end",
                "iVar12": "carry2",
                "uVar14": "data1_size_copy"
            },
            "code": "\nvoid compare_and_alloc_08009530(undefined4 mem_pool,uint *data1,uint *data2,undefined4 param_4)\n\n{\n  int iVar1;\n  uint *data2_ptr;\n  uint data1_size;\n  uint carry;\n  int result;\n  uint *ptr1;\n  uint *ptr1_copy;\n  uint *ptr2;\n  uint *ptr2_copy2;\n  uint *data1_end;\n  int carry2;\n  uint *data2_end;\n  uint data1_size_copy;\n  uint *result_ptr;\n  \n  data2_ptr = (uint *)data2[4];\n  result = data1[4] - (int)data2_ptr;\n  data1_end = data1 + 5;\n  data2_end = data2 + 5;\n  ptr1_copy = data1_end;\n  ptr2 = data1;\n  if (result == 0) {\n    ptr1 = data1_end + (int)data2_ptr;\n    data2_ptr = data2_end + (int)data2_ptr;\n    while( true ) {\n      ptr1 = ptr1 + -1;\n      data2_ptr = data2_ptr + -1;\n      if (*ptr1 != *data2_ptr) break;\n      if (ptr1 <= data1_end) {\n        result = _Balloc(mem_pool,0,ptr1,data2_ptr,param_4);\n        *(undefined4 *)(result + 0x10) = 1;\n        *(undefined4 *)(result + 0x14) = 0;\n        return;\n      }\n    }\n    if (*data2_ptr <= *ptr1) goto LAB_08009578;\n  }\n  else if (-1 < result) {\n    result = 0;\n    ptr1 = data2;\n    goto LAB_08009578;\n  }\n  result = 1;\n  ptr1 = data1_end;\n  data2_ptr = data1;\n  ptr1_copy = data2_end;\n  ptr2 = data2;\n  data2 = data1;\n  data2_end = data1_end;\nLAB_08009578:\n  iVar1 = _Balloc(mem_pool,ptr2[1],ptr1,data2_ptr,param_4);\n  carry2 = 0;\n  data1_size_copy = ptr2[4];\n  data1_size = data2[4];\n  *(int *)(iVar1 + 0xc) = result;\n  data1_end = ptr1_copy + data1_size_copy;\n  data2_ptr = (uint *)(iVar1 + 0x14);\n  ptr2 = data2_end;\n  do {\n    result_ptr = ptr1_copy + 1;\n    ptr2_copy2 = ptr2 + 1;\n    carry = ((*ptr1_copy & 0xffff) + carry2) - (*ptr2 & 0xffff);\n    carry2 = ((*ptr1_copy >> 0x10) - (*ptr2 >> 0x10)) + ((int)carry >> 0x10);\n    carry = carry & 0xffff | carry2 * 0x10000;\n    ptr1 = data2_ptr + 1;\n    *data2_ptr = carry;\n    carry2 = carry2 >> 0x10;\n    data2_ptr = ptr1;\n    ptr1_copy = result_ptr;\n    ptr2 = ptr2_copy2;\n  } while (ptr2_copy2 < data2_end + data1_size);\n  data2_ptr = result_ptr;\n  ptr1_copy = ptr1;\n  if (result_ptr < data1_end) {\n    do {\n      ptr2 = data2_ptr + 1;\n      data1_size = (*data2_ptr & 0xffff) + carry2;\n      carry2 = ((int)data1_size >> 0x10) + (*data2_ptr >> 0x10);\n      carry = data1_size & 0xffff | carry2 * 0x10000;\n      *ptr1_copy = carry;\n      carry2 = carry2 >> 0x10;\n      data2_ptr = ptr2;\n      ptr1_copy = ptr1_copy + 1;\n    } while (ptr2 < data1_end);\n    ptr1 = (uint *)((int)ptr1 + ((int)data1_end + ~(uint)result_ptr & 0xfffffffc) + 4);\n  }\n  ptr1 = ptr1 + -1;\n  while (carry == 0) {\n    ptr1 = ptr1 + -1;\n    data1_size_copy = data1_size_copy - 1;\n    carry = *ptr1;\n  }\n  *(uint *)(iVar1 + 0x10) = data1_size_copy;\n  return;\n}\n\n",
            "called": [
                "_Balloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009530",
            "calling": [
                "_dtoa_r"
            ],
            "imported": false,
            "current_name": "compare_and_alloc_08009530"
        },
        "FUN_08002bb4": {
            "renaming": {
                "FUN_08002bb4": "check_i2c_status_08002bb4",
                "hi2c": "i2c_handle",
                "Timeout": "timeout",
                "Tickstart": "tick_start",
                "HVar1": "status",
                "uVar2": "current_tick",
                "HAL_OK": "HAL_I2C_OK",
                "I2C_IsAcknowledgeFailed": "check_acknowledge_failed",
                "HAL_TIMEOUT": "HAL_I2C_TIMEOUT",
                "HAL_ERROR": "HAL_I2C_ERROR",
                "ErrorCode": "error_code",
                "PreviousState": "previous_state",
                "State": "state",
                "HAL_I2C_STATE_READY": "I2C_READY",
                "HAL_UNLOCKED": "UNLOCKED"
            },
            "code": "\nHAL_StatusTypeDef\ncheck_i2c_status_08002bb4(I2C_HandleTypeDef *i2c_handle,uint32_t timeout,uint32_t tick_start)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t current_tick;\n  \n  while( true ) {\n    if ((i2c_handle->Instance->SR1 & 0x80) == 0x80) {\n      return HAL_I2C_OK;\n    }\n    status = check_acknowledge_failed(i2c_handle);\n    if (status != HAL_I2C_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (current_tick = HAL_GetTick(), timeout < current_tick - tick_start)))) {\n      i2c_handle->error_code = i2c_handle->error_code | 0x20;\n      i2c_handle->previous_state = 0;\n      i2c_handle->state = I2C_READY;\n      i2c_handle->Lock = UNLOCKED;\n      return HAL_I2C_TIMEOUT;\n    }\n  }\n  return HAL_I2C_ERROR;\n}\n\n",
            "called": [
                "I2C_IsAcknowledgeFailed",
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002bb4",
            "calling": [
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Write",
                "I2C_RequestMemoryWrite"
            ],
            "imported": false,
            "current_name": "check_i2c_status_08002bb4"
        },
        "FUN_08002d3c": {
            "renaming": {
                "FUN_08002d3c": "check_i2c_status_08002d3c",
                "hi2c": "i2c_handler",
                "bVar1": "status",
                "SR1": "status_register",
                "ErrorCode": "error_code",
                "PreviousState": "previous_state",
                "State": "current_state",
                "HAL_I2C_STATE_READY": "ready_state",
                "HAL_UNLOCKED": "unlocked_state"
            },
            "code": "\nHAL_StatusTypeDef check_i2c_status_08002d3c(I2C_HandleTypeDef *i2c_handler)\n\n{\n  bool status;\n  \n  status = (i2c_handler->Instance->status_register & 0x400) == 0x400;\n  if (status) {\n    i2c_handler->Instance->status_register = 0xfffffbff;\n    i2c_handler->error_code = 4;\n    i2c_handler->previous_state = 0;\n    i2c_handler->current_state = ready_state;\n    i2c_handler->Lock = unlocked_state;\n  }\n  return status;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d3c",
            "calling": [
                "I2C_WaitOnBTFFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "imported": false,
            "current_name": "check_i2c_status_08002d3c"
        },
        "FUN_080009fc": {
            "renaming": {
                "FUN_080009fc": "floating_point_to_integer_080009fc",
                "param_1": "float_value",
                "param_2": "float_bits",
                "uVar1": "result",
                "uVar2": "exponent",
                "uVar3": "fraction",
                "in_r12": "adjusted_exponent",
                "bVar4": "is_zero",
                "bVar5": "is_normal"
            },
            "code": "\nuint floating_point_to_integer_080009fc(uint float_value,uint float_bits)\n\n{\n  uint result;\n  uint exponent;\n  uint fraction;\n  uint adjusted_exponent;\n  bool is_zero;\n  bool is_normal;\n  \n  exponent = float_bits * 2;\n  is_normal = exponent < 0x70000000;\n  fraction = exponent + 0x90000000;\n  result = fraction;\n  if (!is_normal) {\n    adjusted_exponent = exponent + 0x8fe00000;\n    result = adjusted_exponent;\n  }\n  is_zero = result == 0;\n  if (!is_normal && fraction >= 0x200000) {\n    is_zero = adjusted_exponent == 0x1fc00000;\n  }\n  if (((is_normal || fraction < 0x200000) || 0x1fc00000 < adjusted_exponent) || is_zero) {\n    if ((float_bits & 0x40000000) != 0) {\n      if (((int)exponent >> 0x15 == -1) && ((float_value | float_bits << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return float_bits & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(exponent + 0x92e00000) < 0 != SCARRY4(fraction,0x2e00000)) {\n      return float_bits & 0x80000000;\n    }\n    exponent = 0x18 - (exponent + 0x92e00000 >> 0x15);\n    result = float_value >> (exponent & 0xff);\n    if (float_value << (0x20 - exponent & 0xff) != 0) {\n      result = result | 1;\n    }\n    fraction = float_bits & 0x1fffff | 0x100000;\n    float_value = result | fraction << (0x20 - exponent & 0xff);\n    fraction = (fraction >> (exponent & 0xff)) << 1;\n  }\n  result = (float_bits & 0x80000000 | float_value >> 0x1d) + fraction * 4 + (uint)(0x7fffffff < float_value * 8);\n  if (float_value * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009fc",
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calc_pitch"
            ],
            "imported": false,
            "current_name": "floating_point_to_integer_080009fc"
        },
        "FUN_080093a4": {
            "renaming": {
                "FUN_080093a4": "multiply_add_080093a4",
                "param_1": "param_pointer",
                "param_2": "array_pointer",
                "param_3": "array_length",
                "iVar1": "temp_var_1",
                "iVar2": "temp_var_2",
                "puVar3": "result_pointer",
                "puVar4": "temp_pointer"
            },
            "code": "\nundefined4 * multiply_add_080093a4(int param_pointer,undefined4 *array_pointer,uint array_length)\n\n{\n  int temp_var_1;\n  int temp_var_2;\n  undefined4 *result_pointer;\n  undefined4 *temp_pointer;\n  \n  if ((array_length & 3) != 0) {\n    array_pointer = (undefined4 *)\n              __multadd(param_pointer,array_pointer,\n                        *(undefined4 *)(PTR_p05_6092_08009440 + ((array_length & 3) - 1) * 4),0);\n  }\n  temp_var_2 = (int)array_length >> 2;\n  if (temp_var_2 != 0) {\n    temp_pointer = *(undefined4 **)(param_pointer + 0x48);\n    if (temp_pointer == (undefined4 *)0x0) {\n      temp_pointer = (undefined4 *)_Balloc(param_pointer,1);\n      temp_pointer[4] = 1;\n      temp_pointer[5] = 0x271;\n      *(undefined4 **)(param_pointer + 0x48) = temp_pointer;\n      *temp_pointer = 0;\n    }\n    result_pointer = array_pointer;\n    if (temp_var_2 << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    temp_var_2 = temp_var_2 >> 1;\n    result_pointer = temp_pointer;\n    if (temp_var_2 != 0) {\n      while( true ) {\n        temp_pointer = (undefined4 *)*result_pointer;\n        if (temp_pointer == (undefined4 *)0x0) {\n          temp_pointer = (undefined4 *)__multiply(param_pointer,result_pointer,result_pointer);\n          *result_pointer = temp_pointer;\n          *temp_pointer = 0;\n        }\n        result_pointer = array_pointer;\n        if (-1 < temp_var_2 << 0x1f) break;\nLAB_080093d2:\n        array_pointer = (undefined4 *)__multiply(param_pointer,result_pointer,temp_pointer);\n        if (result_pointer == (undefined4 *)0x0) break;\n        temp_var_1 = *(int *)(param_pointer + 0x4c);\n        temp_var_2 = temp_var_2 >> 1;\n        *result_pointer = *(undefined4 *)(temp_var_1 + result_pointer[1] * 4);\n        *(undefined4 **)(temp_var_1 + result_pointer[1] * 4) = result_pointer;\n        result_pointer = temp_pointer;\n        if (temp_var_2 == 0) {\n          return array_pointer;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return array_pointer;\n}\n\n",
            "called": [
                "_Balloc",
                "__multadd",
                "__multiply"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080093a4",
            "calling": [
                "_dtoa_r"
            ],
            "imported": false,
            "current_name": "multiply_add_080093a4"
        },
        "FUN_0800015c": {
            "renaming": {
                "FUN_0800015c": "binary_arithmetic_operation_0800015c",
                "param_1": "operand1",
                "param_2": "operand1_high",
                "param_3": "operand2",
                "param_4": "operand2_high",
                "iVar1": "operand2_high_shifted",
                "iVar6": "operand1_high_shifted",
                "bVar2": "temp_boolean",
                "bVar13": "temp_boolean1",
                "bVar14": "temp_boolean2",
                "bVar15": "temp_boolean3",
                "uVar3": "temp_operand",
                "uVar4": "temp_operand2",
                "uVar5": "result_low",
                "uVar7": "operand1_shifted",
                "uVar8": "result_high",
                "uVar9": "operand2_shifted",
                "uVar10": "difference",
                "uVar11": "temp_operand3",
                "uVar12": "temp_operand4"
            },
            "code": "\nulonglong binary_arithmetic_operation_0800015c(uint operand1,uint operand1_high,uint operand2,uint operand2_high)\n\n{\n  int operand2_high_shifted;\n  byte temp_boolean;\n  uint temp_operand;\n  uint temp_operand2;\n  uint result_low;\n  int operand1_high_shifted;\n  uint operand1_shifted;\n  uint result_high;\n  uint operand2_shifted;\n  uint difference;\n  uint temp_operand3;\n  uint temp_operand4;\n  bool temp_boolean1;\n  bool temp_boolean2;\n  bool temp_boolean3;\n  \n  operand1_shifted = operand1_high << 1;\n  operand2_shifted = operand2_high << 1;\n  temp_boolean1 = ((operand1_high ^ operand2_high) & 0x7fffffff) == 0;\n  temp_boolean2 = temp_boolean1 && operand1 == operand2;\n  if (!temp_boolean1 || operand1 != operand2) {\n    temp_boolean2 = (operand1_shifted | operand1) == 0;\n  }\n  if (!temp_boolean2) {\n    temp_boolean2 = (operand2_shifted | operand2) == 0;\n  }\n  operand1_high_shifted = (int)operand1_shifted >> 0x15;\n  if (!temp_boolean2) {\n    temp_boolean2 = operand1_high_shifted == -1;\n  }\n  operand2_high_shifted = (int)operand2_shifted >> 0x15;\n  if (!temp_boolean2) {\n    temp_boolean2 = operand2_high_shifted == -1;\n  }\n  if (temp_boolean2) {\n    if (operand1_high_shifted == -1 || operand2_high_shifted == -1) {\n      operand2_shifted = operand2_high;\n      operand1_shifted = operand2;\n      if (operand1_high_shifted == -1) {\n        operand2_shifted = operand1_high;\n        operand1_shifted = operand1;\n      }\n      if (operand1_high_shifted != -1 || operand2_high_shifted != -1) {\n        operand2 = operand1_shifted;\n        operand2_high = operand2_shifted;\n      }\n      temp_boolean2 = (operand1_shifted | operand2_shifted << 0xc) == 0;\n      if (temp_boolean2) {\n        temp_boolean2 = (operand2 | operand2_high << 0xc) == 0;\n      }\n      if (temp_boolean2) {\n        temp_boolean2 = operand2_shifted == operand2_high;\n      }\n      if (!temp_boolean2) {\n        operand2_shifted = operand2_shifted | 0x80000;\n      }\n      return CONCAT44(operand2_shifted,operand1_shifted);\n    }\n    if (((operand1_high ^ operand2_high) & 0x7fffffff) != 0 || operand1 != operand2) {\n      if ((operand1_shifted | operand1) == 0) {\n        operand1 = operand2;\n        operand1_high = operand2_high;\n      }\n      return CONCAT44(operand1_high,operand1);\n    }\n    if (operand1_high != operand2_high) {\n      return 0;\n    }\n    if (operand1_shifted >> 0x15 == 0) {\n      temp_boolean2 = (operand1 & 0x80000000) != 0;\n      operand2_shifted = operand1_high * 2 + (uint)temp_boolean2;\n      if (CARRY4(operand1_high,operand1_high) || CARRY4(operand1_high * 2,(uint)temp_boolean2)) {\n        operand2_shifted = operand2_shifted | 0x80000000;\n      }\n      return CONCAT44(operand2_shifted,operand1 << 1);\n    }\n    if (operand1_shifted < 0xffc00000) {\n      return CONCAT44(operand1_high + 0x100000,operand1);\n    }\n    operand1_high = operand1_high & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(operand1_high | 0x7ff00000) << 0x20;\n  }\n  operand1_shifted = operand1_shifted >> 0x15;\n  operand2_shifted = operand2_shifted >> 0x15;\n  difference = operand2_shifted - operand1_shifted;\n  temp_boolean2 = difference != 0;\n  if (operand2_shifted < operand1_shifted) {\n    difference = -difference;\n  }\n  result_high = operand1;\n  result_low = operand1_high;\n  if (temp_boolean2 && operand1_shifted <= operand2_shifted) {\n    operand1_shifted = operand1_shifted + difference;\n    result_high = operand2;\n    result_low = operand2_high;\n    operand2 = operand1;\n    operand2_high = operand1_high;\n  }\n  if (0x36 < difference) {\n    return CONCAT44(result_low,result_high);\n  }\n  operand2_shifted = result_low & 0xfffff | 0x100000;\n  if ((result_low & 0x80000000) != 0) {\n    temp_boolean2 = result_high != 0;\n    result_high = -result_high;\n    operand2_shifted = -operand2_shifted - (uint)temp_boolean2;\n  }\n  result_low = operand2_high & 0xfffff | 0x100000;\n  if ((operand2_high & 0x80000000) != 0) {\n    temp_boolean2 = operand2 != 0;\n    operand2 = -operand2;\n    result_low = -result_low - (uint)temp_boolean2;\n  }\n  if (operand1_shifted == difference) {\n    result_low = result_low ^ 0x100000;\n    if (operand1_shifted == 0) {\n      operand2_shifted = operand2_shifted ^ 0x100000;\n      operand1_shifted = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  temp_operand4 = -difference + 0x20;\n  if ((int)difference < 0x21) {\n    temp_operand3 = operand2 << (temp_operand4 & 0xff);\n    operand2 = operand2 >> (difference & 0xff);\n    temp_operand = result_high + operand2;\n    temp_operand2 = result_low << (temp_operand4 & 0xff);\n    temp_operand4 = temp_operand + temp_operand2;\n    operand2_shifted = operand2_shifted + CARRY4(result_high,operand2) + ((int)result_low >> (difference & 0xff)) +\n            (uint)CARRY4(temp_operand,temp_operand2);\n  }\n  else {\n    temp_operand3 = result_low << (-difference + 0x40 & 0xff);\n    if (operand2 != 0) {\n      temp_operand3 = temp_operand3 | 2;\n    }\n    result_low = (int)result_low >> (difference - 0x20 & 0xff);\n    temp_operand4 = result_high + result_low;\n    operand2_shifted = operand2_shifted + ((int)result_low >> 0x1f) + (uint)CARRY4(result_high,result_low);\n  }\n  operand1_high = operand2_shifted & 0x80000000;\n  difference = operand2_shifted;\n  if ((int)operand2_shifted < 0) {\n    temp_boolean2 = temp_operand3 == 0;\n    temp_operand3 = -temp_operand3;\n    difference = -temp_operand4;\n    temp_operand4 = -(uint)!temp_boolean2 - temp_operand4;\n    difference = -(uint)(temp_boolean2 <= difference) - operand2_shifted;\n  }\n  if (0xfffff < difference) {\n    result_high = operand1_shifted - 1;\n    if (0x1fffff < difference) {\n      operand2_shifted = difference & 1;\n      difference = difference >> 1;\n      temp_boolean = (byte)temp_operand4;\n      temp_operand4 = (uint)(operand2_shifted != 0) << 0x1f | temp_operand4 >> 1;\n      temp_operand3 = (uint)(temp_boolean & 1) << 0x1f | temp_operand3 >> 1;\n      result_high = operand1_shifted;\n      if (0xffbfffff < operand1_shifted * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    temp_boolean2 = 0x7fffffff < temp_operand3;\n    if (temp_operand3 == 0x80000000) {\n      temp_boolean2 = (temp_operand4 & 1) != 0;\n    }\n    return CONCAT44(difference + result_high * 0x100000 + (uint)CARRY4(temp_operand4,(uint)temp_boolean2) | operand1_high,\n                    temp_operand4 + temp_boolean2);\n  }\n  temp_boolean1 = (temp_operand3 & 0x80000000) != 0;\n  temp_operand3 = temp_operand3 << 1;\n  result_high = temp_operand4 * 2;\n  temp_boolean2 = CARRY4(temp_operand4,temp_operand4);\n  temp_operand4 = temp_operand4 * 2 + (uint)temp_boolean1;\n  difference = difference * 2 + (uint)(temp_boolean2 || CARRY4(result_high,(uint)temp_boolean1));\n  result_high = operand1_shifted - 2;\n  if ((difference & 0x100000) != 0) goto LAB_08000268;\n  result_low = temp_operand4;\n  operand1_shifted = difference;\n  if (difference == 0) {\n    result_low = 0;\n    operand1_shifted = temp_operand4;\n  }\n  operand1_high_shifted = count_leading_zeroes(operand1_shifted);\n  if (difference == 0) {\n    operand1_high_shifted = operand1_high_shifted + 0x20;\n  }\n  temp_operand4 = operand1_high_shifted - 0xb;\n  temp_boolean3 = SBORROW4(temp_operand4,0x20);\n  difference = operand1_high_shifted - 0x2b;\n  temp_boolean2 = (int)difference < 0;\n  temp_boolean1 = difference == 0;\n  if ((int)temp_operand4 < 0x20) {\n    temp_boolean3 = SCARRY4(difference,0xc);\n    operand1_high_shifted = operand1_high_shifted + -0x1f;\n    temp_boolean2 = operand1_high_shifted < 0;\n    temp_boolean1 = operand1_high_shifted == 0;\n    difference = temp_operand4;\n    if (!temp_boolean1 && temp_boolean2 == temp_boolean3) {\n      result_low = operand1_shifted << (temp_operand4 & 0xff);\n      operand1_shifted = operand1_shifted >> (0xcU - operand1_high_shifted & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (temp_boolean1 || temp_boolean2 != temp_boolean3) {\n    temp_operand3 = 0x20 - difference;\n  }\n  operand1_shifted = operand1_shifted << (difference & 0xff);\n  if (temp_boolean1 || temp_boolean2 != temp_boolean3) {\n    operand1_shifted = operand1_shifted | result_low >> (temp_operand3 & 0xff);\n  }\n  if (temp_boolean1 || temp_boolean2 != temp_boolean3) {\n    result_low = result_low << (difference & 0xff);\n  }\nLAB_080002e0:\n  if ((int)temp_operand4 <= (int)result_high) {\n    return CONCAT44(operand1_shifted + (result_high - temp_operand4) * 0x100000 | operand1_high,result_low);\n  }\n  difference = ~(result_high - temp_operand4);\n  if ((int)difference < 0x1f) {\n    operand1_high_shifted = difference - 0x13;\n    if (operand1_high_shifted != 0 && operand1_high_shifted < 0 == SCARRY4(difference - 0x1f,0xc)) {\n      return CONCAT44(operand2_shifted,result_low >> (0x20 - (0xcU - operand1_high_shifted) & 0xff) | operand1_shifted << (0xcU - operand1_high_shifted & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    difference = difference + 1;\n    return CONCAT44(operand1_high | operand1_shifted >> (difference & 0xff),\n                    result_low >> (difference & 0xff) | operand1_shifted << (0x20 - difference & 0xff));\n  }\n  return CONCAT44(operand2_shifted,operand1_shifted >> (difference - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800015c",
            "calling": [
                "_dtoa_r",
                "__ieee754_atan2",
                "__aeabi_drsub",
                "mpu6050_calc_pitch",
                "atan"
            ],
            "imported": false,
            "current_name": "binary_arithmetic_operation_0800015c"
        },
        "FUN_080078a0": {
            "renaming": {
                "FUN_080078a0": "register_atexit_function_if_not_registered_080078a0"
            },
            "code": "\nvoid register_atexit_function_if_not_registered_080078a0(void)\n\n{\n  if (DAT_080078ac != 0) {\n    atexit(DAT_080078b0);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078a0",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "register_atexit_function_if_not_registered_080078a0"
        },
        "FUN_080056c8": {
            "renaming": {
                "FUN_080056c8": "infinite_loop_080056c8"
            },
            "code": "\nvoid infinite_loop_080056c8(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080056c8",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_080056c8"
        },
        "FUN_080057e8": {
            "renaming": {
                "FUN_080057e8": "initialize_system_080057e8",
                "iVar1": "index",
                "puVar2": "pointer",
                "UNRECOVERED_JUMPTABLE": "jumptable"
            },
            "code": "\nvoid initialize_system_080057e8(void)\n\n{\n  int index;\n  undefined4 *pointer;\n  code *jumptable;\n  \n  for (index = 0; pointer = (undefined4 *)PTR_completed_8655_08005828,\n      PTR_uwTickPrio_08005820 + index < PTR_completed_8655_08005824; index = index + 4) {\n    *(undefined4 *)(PTR_uwTickPrio_08005820 + index) =\n         *(undefined4 *)(PTR___fini_array_end_0800581c + index);\n  }\n  for (; pointer < PTR__ebss_0800582c; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumptable = (code *)0x800581a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumptable)();\n  return;\n}\n\n",
            "called": [
                "SystemInit",
                "__libc_init_array",
                "main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080057e8",
            "calling": [],
            "imported": false,
            "current_name": "initialize_system_080057e8"
        },
        "FUN_080008f4": {
            "renaming": {
                "FUN_080008f4": "compare_and_get_result_080008f4",
                "param_1": "value_1",
                "param_2": "value_2",
                "param_3": "value_3",
                "param_4": "value_4",
                "uVar1": "result",
                "bVar2": "is_zero",
                "bVar3": "is_negative"
            },
            "code": "\nuint compare_and_get_result_080008f4(uint value_1,uint value_2,uint value_3,uint value_4)\n\n{\n  uint result;\n  bool is_zero;\n  bool is_negative;\n  \n  if (((int)(value_2 << 1) >> 0x15 == -1 || (int)(value_4 << 1) >> 0x15 == -1) &&\n     ((((int)(value_2 << 1) >> 0x15 == -1 && ((value_1 | value_2 << 0xc) != 0)) ||\n      (((int)(value_4 << 1) >> 0x15 == -1 && ((value_3 | value_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  is_zero = (value_1 | value_2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (value_3 | value_4 << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = value_2 == value_4;\n  }\n  if (is_zero) {\n    is_zero = value_1 == value_3;\n  }\n  if (!is_zero) {\n    result = value_2 ^ value_4;\n    is_zero = result == 0;\n    if (-1 < (int)result) {\n      is_zero = value_2 == value_4;\n    }\n    is_negative = -1 < (int)result && value_4 <= value_2;\n    if (is_zero) {\n      is_negative = value_3 <= value_1;\n    }\n    value_4 = (int)value_4 >> 0x1f;\n    if (!is_negative) {\n      value_4 = ~value_4;\n    }\n    return value_4 | 1;\n  }\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080008f4",
            "calling": [],
            "imported": false,
            "current_name": "compare_and_get_result_080008f4"
        },
        "FUN_080036a8": {
            "renaming": {
                "FUN_080036a8": "initialize_tim_channel_080036a8",
                "htim": "TIM_handler",
                "Channel": "channel_number",
                "Instance": "TIM_instance",
                "BDTR": "break_and_dead_time_register",
                "CR1": "control_register_1"
            },
            "code": "\nHAL_StatusTypeDef initialize_TIM_channel_080036a8(TIM_HandleTypeDef *TIM_handler,uint32_t channel_number)\n\n{\n  TIM_CCxchannel_numberCmd(TIM_handler->TIM_instance,channel_number,1);\n  if (TIM_handler->TIM_instance == DAT_080036f4) {\n    TIM_handler->TIM_instance->break_and_dead_time_register = TIM_handler->TIM_instance->break_and_dead_time_register | 0x8000;\n  }\n  TIM_handler->TIM_instance->control_register_1 = TIM_handler->TIM_instance->control_register_1 | 1;\n  return HAL_OK;\n}\n\n",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036a8",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_tim_channel_080036a8"
        },
        "FUN_080088ec": {
            "renaming": {
                "FUN_080088ec": "malloc_aligned_chunk_080088ec",
                "param_1": "lock",
                "param_2": "chunk",
                "param_3": "unused_size",
                "param_4": "flags",
                "iVar1": "next_chunk",
                "iVar2": "prev_chunk",
                "puVar3": "chunk_header",
                "uVar4": "next_chunk_size",
                "uVar5": "chunk_size",
                "uVar6": "requested_size",
                "puVar7": "prev_chunk_header",
                "puVar8": "av",
                "puVar9": "new_prev_chunk_header",
                "uVar10": "next_chunk_in_use",
                "iVar11": "new_next_chunk"
            },
            "code": "\nvoid malloc_aligned_chunk_080088ec(undefined4 lock,int chunk,undefined4 unused_size,undefined4 flags)\n\n{\n  int next_chunk;\n  int prev_chunk;\n  uint *chunk_header;\n  uint next_chunk_size;\n  uint chunk_size;\n  uint requested_size;\n  undefined *prev_chunk_header;\n  undefined *av;\n  undefined *new_prev_chunk_header;\n  uint next_chunk_in_use;\n  int new_next_chunk;\n  \n  if (chunk == 0) {\n    return;\n  }\n  __malloc_lock();\n  av = PTR___malloc_av__08008ac4;\n  next_chunk_in_use = *(uint *)(chunk + -4);\n  prev_chunk = chunk + -8;\n  chunk_size = next_chunk_in_use & 0xfffffffe;\n  chunk_header = (uint *)(prev_chunk + chunk_size);\n  requested_size = chunk_header[1] & 0xfffffffc;\n  if (*(uint **)(PTR___malloc_av__08008ac4 + 8) == chunk_header) {\n    chunk_size = chunk_size + requested_size;\n    if ((next_chunk_in_use & 1) == 0) {\n      prev_chunk = prev_chunk - *(int *)(chunk + -8);\n      new_next_chunk = *(int *)(prev_chunk + 8);\n      next_chunk = *(int *)(prev_chunk + 0xc);\n      chunk_size = chunk_size + *(int *)(chunk + -8);\n      *(int *)(new_next_chunk + 0xc) = next_chunk;\n      *(int *)(next_chunk + 8) = new_next_chunk;\n    }\n    requested_size = *(uint *)PTR___malloc_trim_threshold_08008acc;\n    *(uint *)(prev_chunk + 4) = chunk_size | 1;\n    *(int *)(av + 8) = prev_chunk;\n    if (requested_size <= chunk_size) {\n      _malloc_trim_r(lock,*(undefined4 *)PTR___malloc_top_pad_08008ad0);\n    }\nLAB_080089f0:\n    __malloc_unlock(lock);\n    return;\n  }\n  chunk_header[1] = requested_size;\n  if ((next_chunk_in_use & 1) == 0) {\n    prev_chunk = prev_chunk - *(int *)(chunk + -8);\n    new_prev_chunk_header = *(undefined **)(prev_chunk + 8);\n    chunk_size = chunk_size + *(int *)(chunk + -8);\n    next_chunk_in_use = *(uint *)((int)chunk_header + requested_size + 4) & 1;\n    if (new_prev_chunk_header == av + 8) {\n      if (next_chunk_in_use == 0) {\n        next_chunk_in_use = chunk_header[2];\n        next_chunk_size = chunk_header[3];\n        chunk_size = chunk_size + requested_size;\n        *(uint *)(next_chunk_in_use + 0xc) = next_chunk_size;\n        *(uint *)(next_chunk_size + 8) = next_chunk_in_use;\n        *(uint *)(prev_chunk + 4) = chunk_size | 1;\n        *(uint *)(prev_chunk + chunk_size) = chunk_size;\n      }\n      else {\n        *(uint *)(prev_chunk + 4) = chunk_size | 1;\n        *chunk_header = chunk_size;\n      }\n      goto LAB_080089f0;\n    }\n    new_next_chunk = *(int *)(prev_chunk + 0xc);\n    *(int *)(new_prev_chunk_header + 0xc) = new_next_chunk;\n    *(undefined **)(new_next_chunk + 8) = new_prev_chunk_header;\n  }\n  else {\n    next_chunk_in_use = *(uint *)((int)chunk_header + requested_size + 4) & 1;\n  }\n  if (next_chunk_in_use == 0) {\n    new_prev_chunk_header = (undefined *)chunk_header[2];\n    chunk_size = chunk_size + requested_size;\n    if (new_prev_chunk_header == PTR_PTR___malloc_av__08008ac8) {\n      *(int *)(av + 0x10) = prev_chunk;\n      *(int *)(av + 0x14) = prev_chunk;\n      *(undefined **)(prev_chunk + 8) = new_prev_chunk_header;\n      *(undefined **)(prev_chunk + 0xc) = new_prev_chunk_header;\n      *(uint *)(prev_chunk + 4) = chunk_size | 1;\n      *(uint *)(prev_chunk + chunk_size) = chunk_size;\n      goto LAB_080089f0;\n    }\n    requested_size = chunk_header[3];\n    *(uint *)(new_prev_chunk_header + 0xc) = requested_size;\n    *(undefined **)(requested_size + 8) = new_prev_chunk_header;\n    *(uint *)(prev_chunk + 4) = chunk_size | 1;\n    *(uint *)(prev_chunk + chunk_size) = chunk_size;\n  }\n  else {\n    *(uint *)(prev_chunk + 4) = chunk_size | 1;\n    *(uint *)(prev_chunk + chunk_size) = chunk_size;\n  }\n  if (chunk_size < 0x200) {\n    new_next_chunk = (chunk_size >> 3) + 1;\n    chunk_size = 1 << ((int)(chunk_size >> 3) >> 2 & 0xffU) | *(uint *)(av + 4);\n    next_chunk = *(int *)(av + new_next_chunk * 8);\n    *(int *)(prev_chunk + 8) = next_chunk;\n    *(undefined **)(prev_chunk + 0xc) = av + new_next_chunk * 8 + -8;\n    *(uint *)(av + 4) = chunk_size;\n    *(int *)(av + new_next_chunk * 8) = prev_chunk;\n    *(int *)(next_chunk + 0xc) = prev_chunk;\n    __malloc_unlock(lock,prev_chunk,chunk_size,flags);\n    return;\n  }\n  requested_size = chunk_size >> 9;\n  if (requested_size < 5) {\n    new_next_chunk = ((chunk_size >> 6) + 0x39) * 8;\n    next_chunk = (chunk_size >> 6) + 0x38;\n  }\n  else if (requested_size < 0x15) {\n    new_next_chunk = (requested_size + 0x5c) * 8;\n    next_chunk = requested_size + 0x5b;\n  }\n  else if (requested_size < 0x55) {\n    new_next_chunk = ((chunk_size >> 0xc) + 0x6f) * 8;\n    next_chunk = (chunk_size >> 0xc) + 0x6e;\n  }\n  else if (requested_size < 0x155) {\n    new_next_chunk = ((chunk_size >> 0xf) + 0x78) * 8;\n    next_chunk = (chunk_size >> 0xf) + 0x77;\n  }\n  else if (requested_size < 0x555) {\n    new_next_chunk = ((chunk_size >> 0x12) + 0x7d) * 8;\n    next_chunk = (chunk_size >> 0x12) + 0x7c;\n  }\n  else {\n    new_next_chunk = 0x3f8;\n    next_chunk = 0x7e;\n  }\n  new_prev_chunk_header = *(undefined **)(av + new_next_chunk);\n  prev_chunk_header = av + new_next_chunk + -8;\n  if (prev_chunk_header == new_prev_chunk_header) {\n    new_prev_chunk_header = (undefined *)(1 << (next_chunk >> 2 & 0xffU) | *(uint *)(av + 4));\n    *(undefined **)(av + 4) = new_prev_chunk_header;\n    av = prev_chunk_header;\n  }\n  else {\n    do {\n      av = new_prev_chunk_header;\n      if ((*(uint *)(new_prev_chunk_header + 4) & 0xfffffffc) <= chunk_size) break;\n      new_prev_chunk_header = *(undefined **)(new_prev_chunk_header + 8);\n      av = prev_chunk_header;\n    } while (prev_chunk_header != new_prev_chunk_header);\n    prev_chunk_header = *(undefined **)(av + 0xc);\n  }\n  *(undefined **)(prev_chunk + 8) = av;\n  *(undefined **)(prev_chunk + 0xc) = prev_chunk_header;\n  *(int *)(prev_chunk_header + 8) = prev_chunk;\n  *(int *)(av + 0xc) = prev_chunk;\n  __malloc_unlock(lock,prev_chunk,new_prev_chunk_header,flags);\n  return;\n}\n\n",
            "called": [
                "__malloc_lock",
                "__malloc_unlock",
                "_malloc_trim_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080088ec",
            "calling": [
                "_malloc_r",
                "_realloc_r",
                "__ssprint_r",
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "malloc_aligned_chunk_080088ec"
        },
        "FUN_08005224": {
            "renaming": {
                "FUN_08005224": "initialize_system_08005224",
                "HAL_Init": "initialize_hardware_abstraction_layer",
                "SystemClock_Config": "configure_system_clock",
                "MX_GPIO_Init": "initialize_gpio",
                "MX_I2C1_Init": "initialize_i2c1",
                "MX_USART1_UART_Init": "initialize_usart1_uart",
                "MX_TIM2_Init": "initialize_tim2",
                "MX_TIM1_Init": "initialize_tim1",
                "HAL_TIM_PWM_Start": "start_tim_pwm",
                "mpu6050_init": "initialize_mpu6050",
                "HAL_TIM_Base_Start_IT": "start_tim_base_it",
                "startForkserver": "start_fork_server"
            },
            "code": "\nint initialize_system_08005224(void)\n\n{\n  initialize_hardware_abstraction_layer();\n  configure_system_clock();\n  initialize_gpio();\n  initialize_i2c1();\n  initialize_usart1_uart();\n  initialize_tim2();\n  initialize_tim1();\n  *(undefined4 *)PTR_I2C_Write_Reg_0800527c = DAT_08005280;\n  *(undefined4 *)PTR_I2C_Read_Reg_08005284 = DAT_08005288;\n  *(undefined4 *)PTR_Get_ms_tick_0800528c = DAT_08005290;\n  start_tim_pwm((TIM_HandleTypeDef *)PTR_htim1_08005294,0);\n  start_tim_pwm((TIM_HandleTypeDef *)PTR_htim1_08005294,0xc);\n  initialize_mpu6050((Mpu6050 *)PTR_mpu6050_08005298);\n  start_tim_base_it((TIM_HandleTypeDef *)PTR_htim2_0800529c);\n  start_fork_server(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "HAL_TIM_PWM_Start",
                "HAL_TIM_Base_Start_IT",
                "MX_I2C1_Init",
                "startForkserver",
                "MX_TIM1_Init",
                "MX_GPIO_Init",
                "MX_USART1_UART_Init",
                "MX_TIM2_Init",
                "SystemClock_Config",
                "HAL_Init",
                "mpu6050_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005224",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "initialize_system_08005224"
        },
        "FUN_08005348": {
            "renaming": {
                "FUN_08005348": "initialize_i2_c_08005348",
                "HVar1": "init_status",
                "_Error_Handler": "handle_error"
            },
            "code": "\nvoid initialize_I2C_08005348(void)\n\n{\n  HAL_StatusTypeDef init_status;\n  \n  *(undefined4 *)PTR_hi2c1_080053a0 = DAT_080053a4;\n  *(undefined4 *)(PTR_hi2c1_080053a0 + 4) = DAT_080053a8;\n  *(undefined4 *)(PTR_hi2c1_080053a0 + 8) = 0;\n  *(undefined4 *)(PTR_hi2c1_080053a0 + 0xc) = 0;\n  *(undefined4 *)(PTR_hi2c1_080053a0 + 0x10) = 0x4000;\n  *(undefined4 *)(PTR_hi2c1_080053a0 + 0x14) = 0;\n  *(undefined4 *)(PTR_hi2c1_080053a0 + 0x18) = 0;\n  *(undefined4 *)(PTR_hi2c1_080053a0 + 0x1c) = 0;\n  *(undefined4 *)(PTR_hi2c1_080053a0 + 0x20) = 0;\n  init_status = HAL_I2C_Init((I2C_HandleTypeDef *)PTR_hi2c1_080053a0);\n  if (init_status != HAL_OK) {\n    handle_error(PTR_s____src_main_c_080053ac,0x17a);\n  }\n  return;\n}\n\n",
            "called": [
                "_Error_Handler",
                "HAL_I2C_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005348",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_i2_c_08005348"
        },
        "FUN_08004378": {
            "renaming": {
                "FUN_08004378": "FUNC_08004378"
            },
            "code": "\nvoid FUNC_08004378(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08004378",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "FUNC_08004378"
        },
        "FUN_080049cc": {
            "renaming": {
                "FUN_080049cc": "calculate_offset_values_080049cc",
                "mpu6050": "sensor",
                "uVar1": "sample_size",
                "fVar2": "offset_value",
                "acc_roll": "accelerometer_roll",
                "acc_pitch": "accelerometer_pitch",
                "now": "current_time",
                "num_samples": "number_of_samples",
                "i": "sample_count",
                "offset_accRoll": "accelerometer_roll_offset",
                "offset_accPitch": "accelerometer_pitch_offset",
                "offset_gyroY": "gyroscope_y_offset",
                "offset_gyroX": "gyroscope_x_offset"
            },
            "code": "\nvosample_countd calculate_offset_values_080049cc(Mpu6050 *sensor)\n\n{\n  undefsample_countned4 sample_size;\n  float offset_value;\n  float accelerometer_roll;\n  float accelerometer_pitch;\n  usample_countnt32_t current_time;\n  sample_countnt number_of_samples;\n  sample_countnt sample_count;\n  float accelerometer_roll_offset;\n  float accelerometer_pitch_offset;\n  float gyroscope_y_offset;\n  float gyroscope_x_offset;\n  \n  number_of_samples = 1;\n  gyroscope_x_offset = 0.0;\n  gyroscope_y_offset = 0.0;\n  accelerometer_pitch_offset = 0.0;\n  accelerometer_roll_offset = 0.0;\n  current_time = (**(code **)PTR_Get_ms_tsample_countck_08004adc)();\n  sample_count = 0;\n  whsample_countle( true ) {\n    sample_countf (number_of_samples <= sample_count) break;\n    accelerometer_pitch = 0.0;\n    accelerometer_roll = 0.0;\n    sensor_update(sensor);\n    sensor_calc_accelerometer_pitch_roll(sensor,&accelerometer_pitch,&accelerometer_roll);\n    accelerometer_pitch_offset = (float)__addsf3(accelerometer_pitch_offset,accelerometer_pitch);\n    accelerometer_roll_offset = (float)__addsf3(accelerometer_roll_offset,accelerometer_roll);\n    gyroscope_x_offset = (float)__addsf3(gyroscope_x_offset,sensor->gyroX);\n    gyroscope_y_offset = (float)__addsf3(gyroscope_y_offset,sensor->gyroY);\n    current_time = (**(code **)PTR_Get_ms_tsample_countck_08004adc)();\n    sample_count = sample_count + 1;\n  }\n  sample_size = __floatssample_countsf(number_of_samples);\n  offset_value = (float)__aeabsample_count_fdsample_countv(gyroscope_x_offset,sample_size);\n  sensor->gyroscope_x_offset = offset_value;\n  sample_size = __floatssample_countsf(number_of_samples);\n  offset_value = (float)__aeabsample_count_fdsample_countv(gyroscope_y_offset,sample_size);\n  sensor->gyroscope_y_offset = offset_value;\n  sample_size = __floatssample_countsf(number_of_samples);\n  offset_value = (float)__aeabsample_count_fdsample_countv(accelerometer_pitch_offset,sample_size);\n  sensor->offset_accelerometer_pitch = offset_value;\n  sample_size = __floatssample_countsf(number_of_samples);\n  offset_value = (float)__aeabsample_count_fdsample_countv(accelerometer_roll_offset,sample_size);\n  sensor->offset_accelerometer_roll = offset_value;\n  return;\n}\n\n",
            "called": [
                "mpu6050_calc_acc_pitch_roll",
                "__addsf3",
                "__aeabi_fdiv",
                "mpu6050_update",
                "__floatsisf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080049cc",
            "calling": [
                "mpu6050_init"
            ],
            "imported": false,
            "current_name": "calculate_offset_values_080049cc"
        },
        "FUN_08003c94": {
            "renaming": {
                "FUN_08003c94": "configure_timer_08003c94",
                "TIMx": "timer",
                "Structure": "timer_config",
                "tmpcr1": "timer_cr1",
                "CounterMode": "counter_mode",
                "ClockDivision": "clock_division",
                "AutoReloadPreload": "auto_reload_preload",
                "Period": "period",
                "Prescaler": "prescaler",
                "RepetitionCounter": "repetition_counter"
            },
            "code": "\nvoid configure_timer_08003c94(TIM_TypeDef *timer,TIM_Base_InitTypeDef *timer_config)\n\n{\n  uint32_t timer_cr1;\n  \n  timer_cr1 = timer->CR1;\n  if ((((timer == DAT_08003d54) || (timer == (TIM_TypeDef *)0x40000000)) || (timer == DAT_08003d58)) ||\n     (timer == DAT_08003d5c)) {\n    timer_cr1 = timer_config->counter_mode | timer_cr1 & 0xffffff8f;\n  }\n  if (((timer == DAT_08003d54) || (timer == (TIM_TypeDef *)0x40000000)) ||\n     ((timer == DAT_08003d58 || (timer == DAT_08003d5c)))) {\n    timer_cr1 = timer_config->clock_division | timer_cr1 & 0xfffffcff;\n  }\n  timer->CR1 = timer_config->auto_reload_preload | timer_cr1 & 0xffffff7f;\n  timer->ARR = timer_config->period;\n  timer->PSC = timer_config->prescaler;\n  if (timer == DAT_08003d54) {\n    timer->RCR = timer_config->repetition_counter;\n  }\n  timer->EGR = 1;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003c94",
            "calling": [
                "HAL_TIM_Base_Init",
                "HAL_TIM_PWM_Init"
            ],
            "imported": false,
            "current_name": "configure_timer_08003c94"
        },
        "FUN_0800884c": {
            "renaming": {
                "FUN_0800884c": "malloc_aligned_0800884c",
                "param_1": "size",
                "param_2": "alignment",
                "puVar1": "malloc_av",
                "puVar2": "malloc_current_mallinfo",
                "iVar3": "sbrk_result",
                "iVar4": "offset",
                "uVar5": "mask"
            },
            "code": "\nundefined4 malloc_aligned_0800884c(undefined4 size,int alignment)\n\n{\n  undefined *malloc_av;\n  undefined *malloc_current_mallinfo;\n  int sbrk_result;\n  int offset;\n  uint mask;\n  \n  malloc_av = PTR___malloc_av__080088e0;\n  __malloc_lock();\n  mask = *(uint *)(*(int *)(malloc_av + 8) + 4) & 0xfffffffc;\n  offset = ((0xfef - alignment) + mask & 0xfffff000) - 0x1000;\n  if (0xfff < offset) {\n    sbrk_result = _sbrk_r(size,0);\n    if (sbrk_result == *(int *)(malloc_av + 8) + mask) {\n      sbrk_result = _sbrk_r(size,-offset);\n      malloc_current_mallinfo = PTR___malloc_current_mallinfo_080088e4;\n      if (sbrk_result != -1) {\n        sbrk_result = *(int *)PTR___malloc_current_mallinfo_080088e4;\n        *(uint *)(*(int *)(malloc_av + 8) + 4) = mask - offset | 1;\n        *(int *)malloc_current_mallinfo = sbrk_result - offset;\n        __malloc_unlock(size);\n        return 1;\n      }\n      offset = _sbrk_r(size,0);\n      malloc_current_mallinfo = PTR___malloc_current_mallinfo_080088e4;\n      mask = offset - *(int *)(malloc_av + 8);\n      if (0xf < (int)mask) {\n        sbrk_result = *(int *)PTR___malloc_sbrk_base_080088e8;\n        *(uint *)(*(int *)(malloc_av + 8) + 4) = mask | 1;\n        *(int *)malloc_current_mallinfo = offset - sbrk_result;\n      }\n    }\n  }\n  __malloc_unlock(size);\n  return 0;\n}\n\n",
            "called": [
                "__malloc_lock",
                "_sbrk_r",
                "__malloc_unlock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800884c",
            "calling": [
                "_free_r"
            ],
            "imported": false,
            "current_name": "malloc_aligned_0800884c"
        },
        "FUN_0800901c": {
            "renaming": {
                "FUN_0800901c": "find_byte_pattern_0800901c",
                "__s": "data",
                "__c": "byte_pattern",
                "__n": "data_size",
                "uVar1": "pattern",
                "uVar2": "xor_result",
                "puVar3": "data_ptr",
                "puVar4": "data_ptr_aligned",
                "uVar5": "single_byte_pattern",
                "bVar6": "end_of_data"
            },
            "code": "\nvoid * find_byte_pattern_0800901c(void *data,int byte_pattern,size_t data_size)\n\n{\n  uint pattern;\n  uint xor_result;\n  uint *data_ptr;\n  uint *data_ptr_aligned;\n  uint single_byte_pattern;\n  bool end_of_data;\n  \n  single_byte_pattern = byte_pattern & 0xff;\n  data_ptr_aligned = (uint *)data;\n  if (((uint)data & 3) == 0) {\nLAB_0800904a:\n    data = (void *)data_size;\n    if ((uint *)0x3 < data_size) {\n      pattern = (byte_pattern & 0xffU) << 8 | single_byte_pattern;\n      data_ptr = data_ptr_aligned;\n      do {\n        xor_result = *data_ptr ^ (pattern | pattern << 0x10);\n        data_ptr_aligned = data_ptr + 1;\n        if ((xor_result + 0xfefefeff & ~xor_result & 0x80808080) != 0) goto LAB_08009050;\n        data_size = data_size + -4;\n        data = (void *)data_size;\n        data_ptr = data_ptr_aligned;\n      } while ((uint *)0x3 < data_size);\n    }\n    data_ptr = data_ptr_aligned;\n    data_size = (size_t)data;\n    if ((uint *)data != (uint *)0x0) {\nLAB_08009050:\n      data = data_ptr;\n                    /* WARNING: Load size is inaccurate */\n      if (*data != single_byte_pattern) {\n        data_ptr_aligned = (uint *)(data_size + (int)data);\n        do {\n          data = (void *)((int)data + 1);\n          if (data_ptr_aligned == (uint *)data) goto LAB_0800906c;\n                    /* WARNING: Load size is inaccurate */\n        } while (*data != single_byte_pattern);\n      }\n    }\n  }\n  else {\n    data_ptr = (uint *)(data_size - 1);\n    if (data_size == 0) {\nLAB_0800906c:\n      data = (uint *)0x0;\n    }\n    else {\n                    /* WARNING: Load size is inaccurate */\n      if (*data != single_byte_pattern) {\n        data_ptr_aligned = (uint *)((int)data + 1);\n        do {\n          data = data_ptr_aligned;\n          data_ptr_aligned = (uint *)data;\n          data_size = (size_t)data_ptr;\n          if (((uint)data & 3) == 0) goto LAB_0800904a;\n          end_of_data = data_ptr == (uint *)0x0;\n          data_ptr = (uint *)((int)data_ptr + -1);\n          if (end_of_data) goto LAB_0800906c;\n                    /* WARNING: Load size is inaccurate */\n          data_ptr_aligned = (uint *)((int)data + 1);\n        } while (*data != single_byte_pattern);\n      }\n    }\n  }\n  return data;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800901c",
            "calling": [
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "find_byte_pattern_0800901c"
        },
        "FUN_0800177c": {
            "renaming": {
                "FUN_0800177c": "set_clock_source_0800177c",
                "CLKSource": "clock_source"
            },
            "code": "\nvoid set_clock_source_0800177c(uint32_t clock_source)\n\n{\n  if (clock_source == 4) {\n    *DAT_080017b0 = *DAT_080017b0 | 4;\n  }\n  else {\n    *DAT_080017b0 = *DAT_080017b0 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800177c",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_clock_source_0800177c"
        },
        "FUN_080099ec": {
            "renaming": {
                "FUN_080099ec": "read_byte_080099ec",
                "param_1": "status",
                "param_2": "output",
                "param_3": "input",
                "param_4": "input_length",
                "uVar1": "result",
                "uStack_4": "default_output"
            },
            "code": "\nuint read_byte_080099ec(undefined4 status,uint *output,byte *input,int input_length)\n\n{\n  uint result;\n  uint default_output;\n  \n  if (output == (uint *)0x0) {\n    output = &default_output;\n  }\n  if (input == (byte *)0x0) {\n    return 0;\n  }\n  if (input_length == 0) {\n    result = 0xfffffffe;\n  }\n  else {\n    *output = (uint)*input;\n    result = (uint)*input;\n    if (result != 0) {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080099ec",
            "calling": [],
            "imported": false,
            "current_name": "read_byte_080099ec"
        },
        "FUN_08005598": {
            "renaming": {
                "FUN_08005598": "initialize_uart_08005598",
                "HVar1": "status",
                "_Error_Handler": "handle_error"
            },
            "code": "\nvoid initialize_uart_08005598(void)\n\n{\n  HAL_StatusTypeDef status;\n  \n  *(undefined4 *)PTR_huart1_080055e8 = DAT_080055ec;\n  *(undefined4 *)(PTR_huart1_080055e8 + 4) = 0x1c200;\n  *(undefined4 *)(PTR_huart1_080055e8 + 8) = 0;\n  *(undefined4 *)(PTR_huart1_080055e8 + 0xc) = 0;\n  *(undefined4 *)(PTR_huart1_080055e8 + 0x10) = 0;\n  *(undefined4 *)(PTR_huart1_080055e8 + 0x14) = 0xc;\n  *(undefined4 *)(PTR_huart1_080055e8 + 0x18) = 0;\n  *(undefined4 *)(PTR_huart1_080055e8 + 0x1c) = 0;\n  status = HAL_UART_Init((UART_HandleTypeDef *)PTR_huart1_080055e8);\n  if (status != HAL_OK) {\n    handle_error(PTR_s____src_main_c_080055f0,0x1ed);\n  }\n  return;\n}\n\n",
            "called": [
                "_Error_Handler",
                "HAL_UART_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005598",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_uart_08005598"
        },
        "FUN_08009adc": {
            "renaming": {
                "FUN_08009adc": "allocate_or_resize_memory_08009adc",
                "param_1": "allocator",
                "param_2": "memory_block",
                "param_3": "new_size",
                "puVar1": "malloc_av",
                "piVar2": "current_block",
                "iVar3": "temp_int",
                "piVar4": "previous_block",
                "uVar5": "temp_uint",
                "iVar6": "temp_int_2",
                "uVar7": "current_block_size",
                "sVar8": "copy_size",
                "piVar9": "new_block",
                "uVar10": "new_block_size",
                "uVar11": "current_or_new_block_size",
                "uVar12": "new_block_end_address"
            },
            "code": "\nint * allocate_or_resize_memory_08009adc(undefined4 *allocator,int *memory_block,uint new_size)\n\n{\n  undefined *malloc_av;\n  int *current_block;\n  int temp_int;\n  int *previous_block;\n  uint temp_uint;\n  int temp_int_2;\n  uint current_block_size;\n  size_t copy_size;\n  int *new_block;\n  uint new_block_size;\n  uint current_or_new_block_size;\n  uint new_block_end_address;\n  int iVar13;\n  \n  if (memory_block == (int *)0x0) {\n    previous_block = (int *)_malloc_r(allocator,new_size);\n    return previous_block;\n  }\n  __malloc_lock();\n  malloc_av = PTR___malloc_av__08009e38;\n  current_block_size = memory_block[-1];\n  current_or_new_block_size = current_block_size & 0xfffffffc;\n  previous_block = memory_block + -2;\n  if (new_size + 0xb < 0x17) {\n    new_block_size = 0x10;\n  }\n  else {\n    new_block_size = new_size + 0xb & 0xfffffff8;\n    if ((int)new_block_size < 0) goto LAB_08009b8e;\n  }\n  if (new_block_size < new_size) {\nLAB_08009b8e:\n    *allocator = 0xc;\n    return (int *)0x0;\n  }\n  iVar13 = (int)previous_block + current_or_new_block_size;\n  new_block_end_address = current_or_new_block_size;\n  if ((int)current_or_new_block_size < (int)new_block_size) {\n    if (*(int *)(PTR___malloc_av__08009e38 + 8) == iVar13) {\n      iVar13 = (*(uint *)(*(int *)(PTR___malloc_av__08009e38 + 8) + 4) & 0xfffffffc) + current_or_new_block_size;\n      if ((int)(new_block_size + 0x10) <= iVar13) {\n        *(uint *)(PTR___malloc_av__08009e38 + 8) = (int)previous_block + new_block_size;\n        *(uint *)((int)previous_block + new_block_size + 4) = iVar13 - new_block_size | 1;\n        memory_block[-1] = new_block_size | memory_block[-1] & 1U;\n        __malloc_unlock(allocator);\n        return memory_block;\n      }\n      if (-1 < (int)(current_block_size << 0x1f)) {\n        current_block = (int *)((int)previous_block - memory_block[-2]);\n        current_block_size = current_block[1] & 0xfffffffc;\n        if ((int)(new_block_size + 0x10) <= (int)(iVar13 + current_block_size)) {\n          temp_int_2 = current_block[3];\n          previous_block = current_block + 2;\n          temp_int = *previous_block;\n          copy_size = current_or_new_block_size - 4;\n          *(int *)(temp_int + 0xc) = temp_int_2;\n          *(int *)(temp_int_2 + 8) = temp_int;\n          if (copy_size < 0x25) {\n            temp_int = *memory_block;\n            new_block = previous_block;\n            if (0x13 < copy_size) {\n              current_block[2] = temp_int;\n              current_block[3] = memory_block[1];\n              temp_int = memory_block[2];\n              if (copy_size < 0x1c) {\n                memory_block = memory_block + 2;\n                new_block = current_block + 4;\n              }\n              else {\n                current_block[4] = temp_int;\n                current_block[5] = memory_block[3];\n                temp_int = memory_block[4];\n                if (copy_size == 0x24) {\n                  current_block[6] = temp_int;\n                  current_block[7] = memory_block[5];\n                  temp_int = memory_block[6];\n                  memory_block = memory_block + 6;\n                  new_block = current_block + 8;\n                }\n                else {\n                  memory_block = memory_block + 4;\n                  new_block = current_block + 6;\n                }\n              }\n            }\n            *new_block = temp_int;\n            new_block[1] = memory_block[1];\n            new_block[2] = memory_block[2];\n          }\n          else {\n            memmove(previous_block,memory_block,copy_size);\n          }\n          *(uint *)(malloc_av + 8) = (int)current_block + new_block_size;\n          *(uint *)((int)current_block + new_block_size + 4) = (iVar13 + current_block_size) - new_block_size | 1;\n          current_block[1] = new_block_size | current_block[1] & 1U;\n          __malloc_unlock(allocator);\n          return previous_block;\n        }\nLAB_08009bb0:\n        new_block_end_address = current_or_new_block_size + current_block_size;\n        if ((int)new_block_size <= (int)new_block_end_address) {\n          temp_int_2 = current_block[3];\n          new_block = current_block + 2;\n          temp_int = *new_block;\n          *(int *)(temp_int + 0xc) = temp_int_2;\n          iVar13 = (int)current_block + new_block_end_address;\n          *(int *)(temp_int_2 + 8) = temp_int;\n          previous_block = current_block;\n          if (current_or_new_block_size - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          memmove(new_block,memory_block,current_or_new_block_size - 4);\n          memory_block = new_block;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(iVar13 + 4) & 0xfffffffe) + iVar13 + 4) << 0x1f) {\n        temp_uint = *(uint *)(iVar13 + 4) & 0xfffffffc;\n        new_block_end_address = current_or_new_block_size + temp_uint;\n        if ((int)new_block_end_address < (int)new_block_size) {\n          if ((int)(current_block_size << 0x1f) < 0) goto LAB_08009b36;\n          current_block = (int *)((int)previous_block - memory_block[-2]);\n          current_block_size = current_block[1] & 0xfffffffc;\n          new_block_end_address = temp_uint + current_block_size + current_or_new_block_size;\n          if ((int)new_block_end_address < (int)new_block_size) goto LAB_08009bb0;\n          temp_int = *(int *)(iVar13 + 8);\n          iVar13 = *(int *)(iVar13 + 0xc);\n          *(int *)(temp_int + 0xc) = iVar13;\n          *(int *)(iVar13 + 8) = temp_int;\n          new_block = current_block + 2;\n          temp_int = *new_block;\n          temp_int_2 = current_block[3];\n          *(int *)(temp_int + 0xc) = temp_int_2;\n          iVar13 = (int)current_block + new_block_end_address;\n          *(int *)(temp_int_2 + 8) = temp_int;\n          previous_block = current_block;\n          if (0x24 < current_or_new_block_size - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          current_or_new_block_size = current_or_new_block_size - 4;\n          temp_int = *memory_block;\n          current_block = new_block;\n          if (0x13 < current_or_new_block_size) {\n            previous_block[2] = temp_int;\n            previous_block[3] = memory_block[1];\n            temp_int = memory_block[2];\n            if (current_or_new_block_size < 0x1c) {\n              memory_block = memory_block + 2;\n              current_block = previous_block + 4;\n            }\n            else {\n              previous_block[4] = temp_int;\n              previous_block[5] = memory_block[3];\n              temp_int = memory_block[4];\n              if (current_or_new_block_size == 0x24) {\n                previous_block[6] = temp_int;\n                previous_block[7] = memory_block[5];\n                temp_int = memory_block[6];\n                memory_block = memory_block + 6;\n                current_block = previous_block + 8;\n              }\n              else {\n                memory_block = memory_block + 4;\n                current_block = previous_block + 6;\n              }\n            }\n          }\n          *current_block = temp_int;\n          current_block[1] = memory_block[1];\n          current_block[2] = memory_block[2];\n          memory_block = new_block;\n        }\n        else {\n          temp_int = *(int *)(iVar13 + 8);\n          temp_int_2 = *(int *)(iVar13 + 0xc);\n          *(int *)(temp_int + 0xc) = temp_int_2;\n          iVar13 = (int)previous_block + new_block_end_address;\n          *(int *)(temp_int_2 + 8) = temp_int;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(current_block_size << 0x1f)) {\n        current_block = (int *)((int)previous_block - memory_block[-2]);\n        current_block_size = current_block[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    current_block = (int *)_malloc_r(allocator,new_size);\n    if (current_block != (int *)0x0) {\n      if ((int *)((memory_block[-1] & 0xfffffffeU) + (int)previous_block) == current_block + -2) {\n        new_block_end_address = current_or_new_block_size + (current_block[-1] & 0xfffffffcU);\n        iVar13 = (int)previous_block + new_block_end_address;\n        goto LAB_08009c00;\n      }\n      copy_size = current_or_new_block_size - 4;\n      if (copy_size < 0x25) {\n        iVar13 = *memory_block;\n        previous_block = memory_block;\n        new_block = current_block;\n        if (0x13 < copy_size) {\n          *current_block = iVar13;\n          current_block[1] = memory_block[1];\n          if (copy_size < 0x1c) {\n            iVar13 = memory_block[2];\n            previous_block = memory_block + 2;\n            new_block = current_block + 2;\n          }\n          else {\n            current_block[2] = memory_block[2];\n            current_block[3] = memory_block[3];\n            if (copy_size == 0x24) {\n              current_block[4] = memory_block[4];\n              current_block[5] = memory_block[5];\n              iVar13 = memory_block[6];\n              previous_block = memory_block + 6;\n              new_block = current_block + 6;\n            }\n            else {\n              iVar13 = memory_block[4];\n              previous_block = memory_block + 4;\n              new_block = current_block + 4;\n            }\n          }\n        }\n        *new_block = iVar13;\n        new_block[1] = previous_block[1];\n        new_block[2] = previous_block[2];\n      }\n      else {\n        memmove(current_block,memory_block,copy_size);\n      }\n      _free_r(allocator,memory_block);\n    }\n    __malloc_unlock(allocator);\n    memory_block = current_block;\n  }\n  else {\nLAB_08009c00:\n    if (new_block_end_address - new_block_size < 0x10) {\n      previous_block[1] = previous_block[1] & 1U | new_block_end_address;\n      *(uint *)(iVar13 + 4) = *(uint *)(iVar13 + 4) | 1;\n    }\n    else {\n      previous_block[1] = previous_block[1] & 1U | new_block_size;\n      *(uint *)((int)previous_block + new_block_size + 4) = new_block_end_address - new_block_size | 1;\n      *(uint *)(iVar13 + 4) = *(uint *)(iVar13 + 4) | 1;\n      _free_r(allocator,(int)previous_block + new_block_size + 8);\n    }\n    __malloc_unlock(allocator);\n  }\n  return memory_block;\n}\n\n",
            "called": [
                "__malloc_lock",
                "__malloc_unlock",
                "memmove",
                "_malloc_r",
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009adc",
            "calling": [
                "__ssprint_r"
            ],
            "imported": false,
            "current_name": "allocate_or_resize_memory_08009adc"
        },
        "FUN_08002640": {
            "renaming": {
                "FUN_08002640": "i2c_read_08002640",
                "hi2c": "i2c_handle",
                "DevAddress": "device_address",
                "MemAddress": "memory_address",
                "MemAddSize": "memory_address_size",
                "Timeout": "timeout",
                "Tickstart": "tick_start",
                "HVar1": "hal_status",
                "uVar2": "tick_count",
                "iVar3": "loop_var",
                "tmpreg": "temp_reg"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nHAL_StatusTypeDef\ni2c_read_08002640(I2C_HandleTypeDef *i2c_handle,uint16_t device_address,uint16_t memory_address,uint16_t memory_address_size,\n          uint32_t timeout,uint32_t tick_start)\n\n{\n  HAL_StatusTypeDef hal_status;\n  uint32_t tick_count;\n  int loop_var;\n  uint32_t temp_reg;\n  \n  i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x100;\n  do {\n    if ((~i2c_handle->Instance->SR1 & 1) == 0) {\n      loop_var = 0;\n      goto LAB_0800270a;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (tick_count = HAL_GetTick(), tick_count - tick_start <= timeout))));\n  i2c_handle->PreviousState = 0;\n  i2c_handle->State = HAL_I2C_STATE_READY;\n  i2c_handle->Mode = HAL_I2C_MODE_NONE;\n  i2c_handle->Lock = HAL_UNLOCKED;\n  loop_var = 3;\nLAB_0800270a:\n  if (loop_var == 0) {\n    i2c_handle->Instance->DR = (byte)device_address & 0xfe;\n    hal_status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2c_handle,DAT_080027f0,timeout,tick_start);\n    if (hal_status == HAL_OK) {\n      hal_status = I2C_WaitOnTXEFlagUntiltimeout(i2c_handle,timeout,tick_start);\n      if (hal_status == HAL_OK) {\n        if (memory_address_size == 1) {\n          i2c_handle->Instance->DR = (uint)(byte)memory_address;\n        }\n        else {\n          i2c_handle->Instance->DR = (uint)(byte)(memory_address >> 8);\n          hal_status = I2C_WaitOnTXEFlagUntiltimeout(i2c_handle,timeout,tick_start);\n          if (hal_status != HAL_OK) {\n            if (i2c_handle->ErrorCode == 4) {\n              i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n              return HAL_ERROR;\n            }\n            return HAL_TIMEOUT;\n          }\n          i2c_handle->Instance->DR = (uint)(byte)memory_address;\n        }\n        hal_status = HAL_OK;\n      }\n      else if (i2c_handle->ErrorCode == 4) {\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n        hal_status = HAL_ERROR;\n      }\n      else {\n        hal_status = HAL_TIMEOUT;\n      }\n    }\n    else if (i2c_handle->ErrorCode == 4) {\n      hal_status = HAL_ERROR;\n    }\n    else {\n      hal_status = HAL_TIMEOUT;\n    }\n  }\n  else {\n    hal_status = HAL_TIMEOUT;\n  }\n  return hal_status;\n}\n\n",
            "called": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002640",
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "imported": false,
            "current_name": "i2c_read_08002640"
        },
        "FUN_08005dfc": {
            "renaming": {
                "FUN_08005dfc": "print_formatted_string_08005dfc",
                "__s": "output_string",
                "__format": "format_string",
                "local_80": "args_array",
                "local_78": "width_limit",
                "uStack_74": "previous_locale",
                "local_70": "current_arg",
                "local_6c": "max_width",
                "uStack_8": "arg_pointer",
                "uStack_4": "arg_pointer_2",
                "_svfprintf_r": "formatted_string_writer"
            },
            "code": "\nint print_formatted_string_08005dfc(char *output_string,char *format_string,...)\n\n{\n  int iVar1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *args_array [2];\n  undefined4 width_limit;\n  undefined4 previous_locale;\n  char *current_arg;\n  undefined4 max_width;\n  undefined4 arg_pointer;\n  undefined4 arg_pointer_2;\n  \n  max_width = 0x7fffffff;\n  width_limit = 0x7fffffff;\n  previous_locale = DAT_08005e3c;\n  args_array[0] = output_string;\n  current_arg = output_string;\n  arg_pointer = in_r2;\n  arg_pointer_2 = in_r3;\n  iVar1 = formatted_string_writer(*(undefined4 *)PTR__impure_ptr_08005e38,args_array,format_string,&arg_pointer);\n  *args_array[0] = '\\0';\n  return iVar1;\n}\n\n",
            "called": [
                "_svfprintf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005dfc",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "imported": false,
            "current_name": "print_formatted_string_08005dfc"
        },
        "FUN_080003f4": {
            "renaming": {
                "FUN_080003f4": "reverse_bit_order_080003f4",
                "param_1": "input_num",
                "uVar1": "output_high",
                "uVar2": "temp_num",
                "uVar3": "shift_amount",
                "iVar4": "leading_zeros_count",
                "uVar5": "bits_to_shift",
                "uVar6": "is_negative",
                "bVar7": "is_negative_shift_amount",
                "bVar8": "is_zero_shift_amount",
                "bVar9": "is_overflow_shift_amount",
                "in_r12": "remaining_bits"
            },
            "code": "\nulonglong reverse_bit_order_080003f4(uint input_num)\n\n{\n  uint output_high;\n  uint temp_num;\n  uint shift_amount;\n  int leading_zeros_count;\n  uint bits_to_shift;\n  uint is_negative;\n  uint remaining_bits;\n  bool is_negative_shift_amount;\n  bool is_zero_shift_amount;\n  bool is_overflow_shift_amount;\n  \n  if (input_num == 0) {\n    return 0;\n  }\n  is_negative = input_num & 0x80000000;\n  temp_num = input_num;\n  if ((int)is_negative < 0) {\n    temp_num = -input_num;\n  }\n  output_high = 0;\n  leading_zeros_count = count_leading_zeroes(temp_num);\n  bits_to_shift = leading_zeros_count + 0x15;\n  is_overflow_shift_amount = SBORROW4(bits_to_shift,0x20);\n  shift_amount = leading_zeros_count - 0xb;\n  is_negative_shift_amount = (int)shift_amount < 0;\n  is_zero_shift_amount = shift_amount == 0;\n  if ((int)bits_to_shift < 0x20) {\n    is_overflow_shift_amount = SCARRY4(shift_amount,0xc);\n    leading_zeros_count = leading_zeros_count + 1;\n    is_negative_shift_amount = leading_zeros_count < 0;\n    is_zero_shift_amount = leading_zeros_count == 0;\n    shift_amount = bits_to_shift;\n    if (!is_zero_shift_amount && is_negative_shift_amount == is_overflow_shift_amount) {\n      output_high = temp_num << (bits_to_shift & 0xff);\n      temp_num = temp_num >> (0xcU - leading_zeros_count & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_zero_shift_amount || is_negative_shift_amount != is_overflow_shift_amount) {\n    remaining_bits = 0x20 - shift_amount;\n  }\n  temp_num = temp_num << (shift_amount & 0xff);\n  if (is_zero_shift_amount || is_negative_shift_amount != is_overflow_shift_amount) {\n    temp_num = temp_num | 0U >> (remaining_bits & 0xff);\n  }\n  if (is_zero_shift_amount || is_negative_shift_amount != is_overflow_shift_amount) {\n    output_high = 0 << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if ((int)bits_to_shift < 0x433) {\n    return CONCAT44(temp_num + (0x432 - bits_to_shift) * 0x100000 | is_negative,output_high);\n  }\n  shift_amount = ~(0x432 - bits_to_shift);\n  if (0x1e < (int)shift_amount) {\n    return CONCAT44(input_num,temp_num >> (shift_amount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zeros_count = shift_amount - 0x13;\n  if (leading_zeros_count == 0 || leading_zeros_count < 0 != SCARRY4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(is_negative | temp_num >> (shift_amount & 0xff),\n                    output_high >> (shift_amount & 0xff) | temp_num << (0x20 - shift_amount & 0xff));\n  }\n  return CONCAT44(input_num,output_high >> (0x20 - (0xcU - leading_zeros_count) & 0xff) | temp_num << (0xcU - leading_zeros_count & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080003f4",
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "reverse_bit_order_080003f4"
        },
        "FUN_0800045c": {
            "renaming": {
                "FUN_0800045c": "binary_to_float_0800045c",
                "param_1": "binary_high",
                "param_2": "binary_low",
                "bVar1": "lsb",
                "uVar2": "mantissa_high",
                "uVar3": "shift_amount",
                "uVar4": "mantissa_low",
                "iVar5": "leading_zeroes",
                "uVar6": "exponent_diff",
                "iVar7": "exponent_adjustment",
                "uVar8": "temp",
                "bVar9": "temp_bit",
                "bVar10": "temp_carry",
                "bVar11": "temp_overflow"
            },
            "code": "\nulonglong binary_to_float_0800045c(uint binary_high,uint binary_low)\n\n{\n  byte lsb;\n  uint mantissa_high;\n  uint shift_amount;\n  uint mantissa_low;\n  int leading_zeroes;\n  uint exponent_diff;\n  int exponent_adjustment;\n  uint temp;\n  bool temp_bit;\n  bool temp_carry;\n  bool temp_overflow;\n  \n  if ((binary_high | binary_low) == 0) {\n    return CONCAT44(binary_low,binary_high);\n  }\n  exponent_adjustment = 0x432;\n  temp = binary_low >> 0x16;\n  if (temp != 0) {\n    exponent_adjustment = 3;\n    if (binary_low >> 0x19 != 0) {\n      exponent_adjustment = 6;\n    }\n    if (binary_low >> 0x1c != 0) {\n      exponent_adjustment = exponent_adjustment + 3;\n    }\n    mantissa_low = exponent_adjustment - ((int)binary_low >> 0x1f);\n    temp = binary_high << (0x20 - mantissa_low & 0xff);\n    binary_high = binary_high >> (mantissa_low & 0xff) | binary_low << (0x20 - mantissa_low & 0xff);\n    binary_low = binary_low >> (mantissa_low & 0xff);\n    exponent_adjustment = mantissa_low + 0x432;\n  }\n  if (0xfffff < binary_low) {\n    if (0x1fffff < binary_low) {\n      mantissa_low = binary_low & 1;\n      binary_low = binary_low >> 1;\n      lsb = (byte)binary_high;\n      binary_high = (uint)(mantissa_low != 0) << 0x1f | binary_high >> 1;\n      temp = (uint)(lsb & 1) << 0x1f | temp >> 1;\n      exponent_adjustment = exponent_adjustment + 1;\n      if (0xffbfffff < (uint)(exponent_adjustment * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_08000268:\n    temp_carry = 0x7fffffff < temp;\n    if (temp == 0x80000000) {\n      temp_carry = (binary_high & 1) != 0;\n    }\n    return CONCAT44(binary_low + exponent_adjustment * 0x100000 + (uint)CARRY4(binary_high,(uint)temp_carry),binary_high + temp_carry\n                   );\n  }\n  temp_bit = (temp & 0x80000000) != 0;\n  temp = temp << 1;\n  mantissa_low = binary_high * 2;\n  temp_carry = CARRY4(binary_high,binary_high);\n  binary_high = binary_high * 2 + (uint)temp_bit;\n  binary_low = binary_low * 2 + (uint)(temp_carry || CARRY4(mantissa_low,(uint)temp_bit));\n  exponent_adjustment = exponent_adjustment + -1;\n  if ((binary_low & 0x100000) != 0) goto LAB_08000268;\n  mantissa_high = binary_high;\n  mantissa_low = binary_low;\n  if (binary_low == 0) {\n    mantissa_high = 0;\n    mantissa_low = binary_high;\n  }\n  leading_zeroes = count_leading_zeroes(mantissa_low);\n  if (binary_low == 0) {\n    leading_zeroes = leading_zeroes + 0x20;\n  }\n  exponent_diff = leading_zeroes - 0xb;\n  temp_overflow = SBORROW4(exponent_diff,0x20);\n  shift_amount = leading_zeroes - 0x2b;\n  temp_carry = (int)shift_amount < 0;\n  temp_bit = shift_amount == 0;\n  if ((int)exponent_diff < 0x20) {\n    temp_overflow = SCARRY4(shift_amount,0xc);\n    leading_zeroes = leading_zeroes + -0x1f;\n    temp_carry = leading_zeroes < 0;\n    temp_bit = leading_zeroes == 0;\n    shift_amount = exponent_diff;\n    if (!temp_bit && temp_carry == temp_overflow) {\n      mantissa_high = mantissa_low << (exponent_diff & 0xff);\n      mantissa_low = mantissa_low >> (0xcU - leading_zeroes & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (temp_bit || temp_carry != temp_overflow) {\n    temp = 0x20 - shift_amount;\n  }\n  mantissa_low = mantissa_low << (shift_amount & 0xff);\n  if (temp_bit || temp_carry != temp_overflow) {\n    mantissa_low = mantissa_low | mantissa_high >> (temp & 0xff);\n  }\n  if (temp_bit || temp_carry != temp_overflow) {\n    mantissa_high = mantissa_high << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if ((int)exponent_diff <= exponent_adjustment) {\n    return CONCAT44(mantissa_low + (exponent_adjustment - exponent_diff) * 0x100000,mantissa_high);\n  }\n  temp = ~(exponent_adjustment - exponent_diff);\n  if (0x1e < (int)temp) {\n    return (ulonglong)(mantissa_low >> (temp - 0x1f & 0xff));\n  }\n  exponent_adjustment = temp - 0x13;\n  if (exponent_adjustment == 0 || exponent_adjustment < 0 != SCARRY4(temp - 0x1f,0xc)) {\n    temp = temp + 1;\n    return CONCAT44(mantissa_low >> (temp & 0xff),mantissa_high >> (temp & 0xff) | mantissa_low << (0x20 - temp & 0xff)\n                   );\n  }\n  return (ulonglong)(mantissa_high >> (0x20 - (0xcU - exponent_adjustment) & 0xff) | mantissa_low << (0xcU - exponent_adjustment & 0xff));\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800045c",
            "calling": [],
            "imported": false,
            "current_name": "binary_to_float_0800045c"
        },
        "FUN_0800166c": {
            "renaming": {
                "FUN_0800166c": "calculate_priority_bits_0800166c",
                "PriorityGroup": "priority_group",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "uVar1": "priority_group_bits",
                "uVar2": "remaining_bits",
                "SubPriorityBits": "sub_priority_bits",
                "PreemptPriorityBits": "preempt_priority_bits",
                "PriorityGroupTmp": "priority_group_temp"
            },
            "code": "\nuint32_t calculate_priority_bits_0800166c(uint32_t priority_group,uint32_t preempt_priority,uint32_t sub_priority)\n\n{\n  uint priority_group_bits;\n  uint remaining_bits;\n  uint32_t sub_priority_bits;\n  uint32_t preempt_priority_bits;\n  uint32_t priority_group_temp;\n  \n  priority_group_bits = priority_group & 7;\n  remaining_bits = 7 - priority_group_bits;\n  if (3 < remaining_bits) {\n    remaining_bits = 4;\n  }\n  if (priority_group_bits + 4 < 7) {\n    priority_group_bits = 0;\n  }\n  else {\n    priority_group_bits = priority_group_bits - 3;\n  }\n  return sub_priority & ~(-1 << (priority_group_bits & 0xff)) |\n         (~(-1 << (remaining_bits & 0xff)) & preempt_priority) << (priority_group_bits & 0xff);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800166c",
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "imported": false,
            "current_name": "calculate_priority_bits_0800166c"
        },
        "FUN_0800360c": {
            "renaming": {
                "FUN_0800360c": "enable_timer_interrupts_0800360c",
                "htim": "timer_handle",
                "Instance": "timer_instance",
                "DIER": "interrupt_enable_register",
                "CR1": "control_register_1",
                "HAL_OK": "hal_status_ok"
            },
            "code": "\nHAL_StatusTypeDef enable_timer_interrupts_0800360c(TIM_HandleTypeDef *timer_handle)\n\n{\n  timer_handle->timer_instance->interrupt_enable_register = timer_handle->timer_instance->interrupt_enable_register | 1;\n  timer_handle->timer_instance->control_register_1 = timer_handle->timer_instance->control_register_1 | 1;\n  return hal_status_ok;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800360c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "enable_timer_interrupts_0800360c"
        },
        "FUN_08005d68": {
            "renaming": {
                "FUN_08005d68": "memset_words_08005d68",
                "__s": "destination",
                "__c": "value",
                "__n": "num_words",
                "puVar1": "source",
                "puVar2": "dest",
                "puVar3": "temp_dest",
                "uVar4": "num_bytes",
                "uVar5": "word_value",
                "bVar6": "end_reached"
            },
            "code": "\nvoid * memset_words_08005d68(void *destination,int value,size_t num_words)\n\n{\n  uint *source;\n  uint *dest;\n  uint *temp_dest;\n  uint num_bytes;\n  uint word_value;\n  bool end_reached;\n  \n  dest = (uint *)destination;\n  if (((uint)destination & 3) != 0) {\n    num_bytes = num_words - 1;\n    source = (uint *)destination;\n    if (num_words == 0) {\n      return destination;\n    }\n    while( true ) {\n      dest = (uint *)((int)source + 1);\n      *(char *)source = (char)value;\n      num_words = num_bytes;\n      if (((uint)dest & 3) == 0) break;\n      end_reached = num_bytes == 0;\n      num_bytes = num_bytes - 1;\n      source = dest;\n      if (end_reached) {\n        return destination;\n      }\n    }\n  }\n  if (3 < num_words) {\n    word_value = value & 0xffU | (value & 0xffU) << 8;\n    word_value = word_value | word_value << 0x10;\n    num_bytes = num_words;\n    source = dest;\n    if (0xf < num_words) {\n      num_bytes = num_words - 0x10;\n      source = dest + 4;\n      do {\n        source[-4] = word_value;\n        source[-3] = word_value;\n        source[-2] = word_value;\n        source[-1] = word_value;\n        source = source + 4;\n      } while (source != (uint *)((int)dest + (num_bytes & 0xfffffff0) + 0x20));\n      num_words = num_words & 0xf;\n      dest = dest + ((num_bytes >> 4) + 1) * 4;\n      num_bytes = num_words;\n      source = dest;\n      if (num_words < 4) goto LAB_08005de4;\n    }\n    do {\n      num_words = num_words - 4;\n      *dest = word_value;\n      dest = dest + 1;\n    } while (3 < num_words);\n    dest = (uint *)((int)source + (num_bytes - 4 & 0xfffffffc) + 4);\n    num_words = num_bytes & 3;\n  }\nLAB_08005de4:\n  if (num_words != 0) {\n    source = dest;\n    do {\n      temp_dest = (uint *)((int)source + 1);\n      *(char *)source = (char)value;\n      source = temp_dest;\n    } while ((uint *)(num_words + (int)dest) != temp_dest);\n  }\n  return destination;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d68",
            "calling": [
                "_calloc_r",
                "flush_strbuf"
            ],
            "imported": false,
            "current_name": "memset_words_08005d68"
        },
        "FUN_080035a4": {
            "renaming": {
                "FUN_080035a4": "configure_timer_080035a4",
                "htim": "timer_handle",
                "HVar1": "status",
                "HAL_ERROR": "error",
                "HAL_TIM_STATE_RESET": "reset",
                "HAL_UNLOCKED": "unlocked",
                "HAL_TIM_STATE_BUSY": "busy",
                "HAL_TIM_STATE_READY": "ready"
            },
            "code": "\nHAL_StatusTypeDef configure_timer_080035a4(TIM_HandleTypeDef *timer_handle)\n\n{\n  HAL_StatusTypeDef status;\n  \n  if (timer_handle == (TIM_HandleTypeDef *)0x0) {\n    status = error;\n  }\n  else {\n    if (timer_handle->State == reset) {\n      timer_handle->Lock = unlocked;\n      HAL_TIM_Base_MspInit(timer_handle);\n    }\n    timer_handle->State = busy;\n    TIM_Base_SetConfig(timer_handle->Instance,&timer_handle->Init);\n    timer_handle->State = ready;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "called": [
                "HAL_TIM_Base_MspInit",
                "TIM_Base_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035a4",
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "imported": false,
            "current_name": "configure_timer_080035a4"
        },
        "FUN_080041ea": {
            "renaming": {
                "FUN_080041ea": "configure_ti_mx_channel_080041ea",
                "TIMx": "timer",
                "Channel": "channel_number",
                "ChannelState": "channel_state",
                "tmp": "temporary",
                "CCER": "capture_compare_enable_register"
            },
            "code": "\nvoid configure_TIMx_Channel_080041ea(TIM_TypeDef *timer,uint32_t channel_number,uint32_t channel_state)\n\n{\n  uint32_t temporary;\n  \n  timer->capture_compare_enable_register = timer->capture_compare_enable_register & ~(1 << (channel_number & 0xff));\n  timer->capture_compare_enable_register = timer->capture_compare_enable_register | channel_state << (channel_number & 0xff);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041ea",
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "imported": false,
            "current_name": "configure_ti_mx_channel_080041ea"
        },
        "FUN_08004ae0": {
            "renaming": {
                "FUN_08004ae0": "read_mpu6050_sensor_data_08004ae0",
                "mpu6050": "sensor_data",
                "raw": "sensor_data_raw",
                "gz": "gyro_z",
                "gy": "gyro_y",
                "gx": "gyro_x",
                "t": "temperature",
                "az": "accel_z",
                "ay": "accel_y",
                "ax": "accel_x",
                "fVar1": "converted_value"
            },
            "code": "\nvoid read_mpu6050_sensor_data_08004ae0(Mpu6050 *sensor_data)\n\n{\n  floatemperature converted_value;\n  uintemperature8_temperature sensor_data_raw [14];\n  intemperature16_temperature gyro_z;\n  intemperature16_temperature gyro_y;\n  intemperature16_temperature gyro_x;\n  intemperature16_temperature temperature;\n  intemperature16_temperature accel_z;\n  intemperature16_temperature accel_y;\n  intemperature16_temperature accel_x;\n  \n  (**(code **)PTR_I2C_Read_Reg_08004bd4)(0xd0,0x3b,sensor_data_raw,0xe);\n  converted_value = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(sensor_data_raw[0],sensor_data_raw[1]));\n  sensor_data->accX = converted_value;\n  converted_value = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(sensor_data_raw[2],sensor_data_raw[3]));\n  sensor_data->accY = converted_value;\n  converted_value = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(sensor_data_raw[4],sensor_data_raw[5]));\n  sensor_data->accZ = converted_value;\n  converted_value = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(sensor_data_raw[6],sensor_data_raw[7]));\n  sensor_data->temperatureemp = converted_value;\n  converted_value = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(sensor_data_raw[8],sensor_data_raw[9]));\n  sensor_data->gyro_yroX = converted_value;\n  converted_value = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(sensor_data_raw[10],sensor_data_raw[11]));\n  sensor_data->gyro_yroY = converted_value;\n  converted_value = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(sensor_data_raw[12],sensor_data_raw[13]));\n  sensor_data->gyro_yroZ = converted_value;\n  retemperatureurn;\n}\n\n",
            "called": [
                "__floatsisf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ae0",
            "calling": [
                "mpu6050_calibrate",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "imported": false,
            "current_name": "read_mpu6050_sensor_data_08004ae0"
        },
        "FUN_080015fc": {
            "renaming": {
                "FUN_080015fc": "extract_bits_from_uint32_080015fc",
                "uint": "unsigned_integer",
                "&": "bitwise_and"
            },
            "code": "\nunsigned_integer32_t extract_bits_from_uint32_080015fc(void)\n\n{\n  return *(unsigned_integer *)(DAT_08001614 + 0xc) >> 8 bitwise_and 7;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015fc",
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "imported": false,
            "current_name": "extract_bits_from_uint32_080015fc"
        },
        "FUN_08000110": {
            "renaming": {
                "FUN_08000110": "check_completion_and_initialize_08000110",
                "param_1": "input_data"
            },
            "code": "\nundefined * check_completion_and_initialize_08000110(undefined *input_data)\n\n{\n  if (*PTR_completed_8655_08000128 == '\\0') {\n    if (DAT_0800012c != 0) {\n      input_data = PTR__init_08000130;\n    }\n    *PTR_completed_8655_08000128 = 1;\n  }\n  return input_data;\n}\n\n",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000110",
            "calling": [
                "__libc_fini_array"
            ],
            "imported": false,
            "current_name": "check_completion_and_initialize_08000110"
        },
        "FUN_08003504": {
            "renaming": {
                "FUN_08003504": "get_system_core_clock_08003504"
            },
            "code": "\nuint32_t get_system_core_clock_08003504(void)\n\n{\n  return *(uint32_t *)PTR_SystemCoreClock_08003514;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003504",
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "get_system_core_clock_08003504"
        },
        "FUN_08000aa4": {
            "renaming": {
                "FUN_08000aa4": "floating_point_comparator_08000aa4",
                "param_1": "float_1",
                "param_2": "float_2",
                "param_3": "float_3",
                "param_4": "float_4",
                "iVar1": "int_1",
                "uVar2": "float_2_xor",
                "uVar3": "float_3_modified",
                "uVar4": "float_1_shifted",
                "uVar5": "shift_amount",
                "uVar6": "difference",
                "iVar7": "float_1_sign",
                "bVar8": "comparison_result"
            },
            "code": "\nuint floating_point_comparator_08000aa4(uint float_1,uint float_2,undefined4 float_3,uint float_4)\n\n{\n  int int_1;\n  uint float_2_xor;\n  uint float_3_modified;\n  uint float_1_shifted;\n  uint shift_amount;\n  uint difference;\n  int float_1_sign;\n  bool comparison_result;\n  \n  float_2_xor = float_2 ^ 0x80000000;\n  float_1_shifted = float_1 << 1;\n  comparison_result = float_1_shifted == 0;\n  if (!comparison_result) {\n    float_4 = float_2 << 1;\n    comparison_result = float_4 == 0;\n  }\n  if (!comparison_result) {\n    comparison_result = float_1_shifted == float_4;\n  }\n  float_1_sign = (int)float_1_shifted >> 0x18;\n  if (!comparison_result) {\n    comparison_result = float_1_sign == -1;\n  }\n  if (!comparison_result) {\n    comparison_result = (int)float_4 >> 0x18 == -1;\n  }\n  if (comparison_result) {\n    int_1 = (int)(float_2 << 1) >> 0x18;\n    if (float_1_sign == -1 || int_1 == -1) {\n      float_1_shifted = float_2_xor;\n      if (float_1_sign == -1) {\n        float_1_shifted = float_1;\n      }\n      if (float_1_sign != -1 || int_1 != -1) {\n        float_2_xor = float_1_shifted;\n      }\n      comparison_result = (float_1_shifted & 0x7fffff) == 0;\n      if (comparison_result) {\n        comparison_result = (float_2_xor & 0x7fffff) == 0;\n      }\n      if (comparison_result) {\n        comparison_result = float_1_shifted == float_2_xor;\n      }\n      if (!comparison_result) {\n        float_1_shifted = float_1_shifted | 0x400000;\n      }\n      return float_1_shifted;\n    }\n    if (((float_1 ^ float_2_xor) & 0x7fffffff) != 0) {\n      if (float_1_shifted == 0) {\n        float_1 = float_2_xor;\n      }\n      return float_1;\n    }\n    if (float_1 != float_2_xor) {\n      return 0;\n    }\n    if ((float_1_shifted & 0xff000000) == 0) {\n      float_2_xor = float_1 << 1;\n      if ((float_1 & 0x80000000) != 0) {\n        float_2_xor = float_2_xor | 0x80000000;\n      }\n      return float_2_xor;\n    }\n    if (float_1_shifted < 0xfe000000) {\n      return float_1 + 0x800000;\n    }\n    float_1 = float_1 & 0x80000000;\nLAB_08000bde:\n    return float_1 | 0x7f800000;\n  }\n  float_1_shifted = float_1_shifted >> 0x18;\n  float_4 = float_4 >> 0x18;\n  difference = float_4 - float_1_shifted;\n  comparison_result = difference != 0;\n  shift_amount = float_1_shifted;\n  if (comparison_result && float_1_shifted <= float_4) {\n    shift_amount = float_1_shifted + difference;\n  }\n  if (comparison_result && float_1_shifted <= float_4) {\n    float_2_xor = float_2_xor ^ float_1;\n  }\n  if (comparison_result && float_1_shifted <= float_4) {\n    float_1 = float_1 ^ float_2_xor;\n  }\n  if (comparison_result && float_1_shifted <= float_4) {\n    float_2_xor = float_2_xor ^ float_1;\n  }\n  if (float_4 < float_1_shifted) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return float_1;\n  }\n  float_1_shifted = float_1 & 0xffffff | 0x800000;\n  if ((float_1 & 0x80000000) != 0) {\n    float_1_shifted = -float_1_shifted;\n  }\n  float_3_modified = float_2_xor & 0xffffff | 0x800000;\n  if ((float_2_xor & 0x80000000) != 0) {\n    float_3_modified = -float_3_modified;\n  }\n  if (shift_amount == difference) {\n    float_3_modified = float_3_modified ^ 0x800000;\n    if (shift_amount == 0) {\n      float_1_shifted = float_1_shifted ^ 0x800000;\n      shift_amount = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  float_1_shifted = float_1_shifted + ((int)float_3_modified >> (difference & 0xff));\n  float_3_modified = float_3_modified << (0x20 - difference & 0xff);\n  float_1 = float_1_shifted & 0x80000000;\n  if ((int)float_1_shifted < 0) {\n    comparison_result = float_3_modified != 0;\n    float_3_modified = -float_3_modified;\n    float_1_shifted = -float_1_shifted - (uint)comparison_result;\n  }\n  if (float_1_shifted < 0x800000) {\n    float_2_xor = float_3_modified & 0x80000000;\n    float_3_modified = float_3_modified << 1;\n    float_1_shifted = float_1_shifted * 2 + (uint)(float_2_xor != 0);\n    float_2_xor = shift_amount - 2;\n    if ((float_1_shifted & 0x800000) == 0) {\n      float_1_sign = count_leading_zeroes(float_1_shifted);\n      difference = float_1_sign - 8;\n      float_1_shifted = float_1_shifted << (difference & 0xff);\n      if ((int)float_2_xor < (int)difference) {\n        float_1_shifted = float_1_shifted >> (-(float_2_xor - difference) & 0xff);\n      }\n      else {\n        float_1_shifted = float_1_shifted + (float_2_xor - difference) * 0x800000;\n      }\n      return float_1_shifted | float_1;\n    }\n  }\n  else {\n    float_2_xor = shift_amount - 1;\n    if (0xffffff < float_1_shifted) {\n      float_2_xor = float_1_shifted & 1;\n      float_1_shifted = float_1_shifted >> 1;\n      float_3_modified = (uint)(float_2_xor != 0) << 0x1f | float_3_modified >> 1;\n      float_2_xor = shift_amount;\n      if (0xfd < shift_amount) goto LAB_08000bde;\n    }\n  }\n  float_1_shifted = float_1_shifted + float_2_xor * 0x800000 + (uint)(0x7fffffff < float_3_modified);\n  if (float_3_modified == 0x80000000) {\n    float_1_shifted = float_1_shifted & 0xfffffffe;\n  }\n  return float_1_shifted | float_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000aa4",
            "calling": [
                "mpu6050_calc_pitch",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "imported": false,
            "current_name": "floating_point_comparator_08000aa4"
        },
        "FUN_08000c2c": {
            "renaming": {
                "FUN_08000c2c": "calculate_with_shift_08000c2c",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar1": "result_1",
                "uVar2": "result_2",
                "iVar3": "leading_zeroes",
                "uVar4": "shift_amount",
                "iVar5": "constant",
                "uVar6": "overflow_check"
            },
            "code": "\nuint calculate_with_shift_08000c2c(uint input_1,uint input_2)\n\n{\n  uint result_1;\n  uint result_2;\n  int leading_zeroes;\n  uint shift_amount;\n  int constant;\n  uint overflow_check;\n  \n  if ((input_1 | input_2) == 0) {\n    return input_1;\n  }\n  result_1 = input_1;\n  result_2 = input_2;\n  if (input_2 == 0) {\n    result_1 = 0;\n    result_2 = input_1;\n  }\n  constant = 0x5b000000;\n  if (input_2 == 0) {\n    constant = 0x4b000000;\n  }\n  leading_zeroes = count_leading_zeroes(result_2);\n  shift_amount = leading_zeroes - 8;\n  constant = constant + -0x800000 + shift_amount * -0x800000;\n  if (leading_zeroes < 8) {\n    shift_amount = result_2 << (leading_zeroes + 0x18U & 0xff);\n    result_2 = constant + ((result_2 >> (0x20 - (leading_zeroes + 0x18U) & 0xff)) - ((int)shift_amount >> 0x1f));\n    if ((result_1 | shift_amount << 1) == 0) {\n      result_2 = result_2 & ~(shift_amount >> 0x1f);\n    }\n    return result_2;\n  }\n  overflow_check = result_1 << (shift_amount & 0xff);\n  result_2 = constant + (result_2 << (shift_amount & 0xff)) +\n          (result_1 >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < overflow_check);\n  if (overflow_check == 0x80000000) {\n    result_2 = result_2 & 0xfffffffe;\n  }\n  return result_2;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c2c",
            "calling": [],
            "imported": false,
            "current_name": "calculate_with_shift_08000c2c"
        },
        "FUN_08000aa8": {
            "renaming": {
                "FUN_08000aa8": "floating_point_comparison_08000aa8",
                "param_1": "float_1",
                "param_2": "float_2",
                "param_3": "float_3",
                "param_4": "float_4",
                "iVar1": "int_1",
                "uVar2": "uint_1",
                "uVar3": "uint_2",
                "uVar4": "uint_3",
                "uVar5": "uint_4",
                "iVar6": "int_2",
                "bVar7": "bool_1"
            },
            "code": "\nuint floating_point_comparison_08000aa8(uint float_1,uint float_2,undefined4 float_3,uint float_4)\n\n{\n  int int_1;\n  uint uint_1;\n  uint uint_2;\n  uint uint_3;\n  uint uint_4;\n  int int_2;\n  bool bool_1;\n  \n  uint_2 = float_1 << 1;\n  bool_1 = uint_2 == 0;\n  if (!bool_1) {\n    float_4 = float_2 << 1;\n    bool_1 = float_4 == 0;\n  }\n  if (!bool_1) {\n    bool_1 = uint_2 == float_4;\n  }\n  int_2 = (int)uint_2 >> 0x18;\n  if (!bool_1) {\n    bool_1 = int_2 == -1;\n  }\n  if (!bool_1) {\n    bool_1 = (int)float_4 >> 0x18 == -1;\n  }\n  if (bool_1) {\n    int_1 = (int)(float_2 << 1) >> 0x18;\n    if (int_2 == -1 || int_1 == -1) {\n      uint_2 = float_2;\n      if (int_2 == -1) {\n        uint_2 = float_1;\n      }\n      if (int_2 != -1 || int_1 != -1) {\n        float_2 = uint_2;\n      }\n      bool_1 = (uint_2 & 0x7fffff) == 0;\n      if (bool_1) {\n        bool_1 = (float_2 & 0x7fffff) == 0;\n      }\n      if (bool_1) {\n        bool_1 = uint_2 == float_2;\n      }\n      if (!bool_1) {\n        uint_2 = uint_2 | 0x400000;\n      }\n      return uint_2;\n    }\n    if (((float_1 ^ float_2) & 0x7fffffff) != 0) {\n      if (uint_2 == 0) {\n        float_1 = float_2;\n      }\n      return float_1;\n    }\n    if (float_1 != float_2) {\n      return 0;\n    }\n    if ((uint_2 & 0xff000000) == 0) {\n      uint_2 = float_1 << 1;\n      if ((float_1 & 0x80000000) != 0) {\n        uint_2 = uint_2 | 0x80000000;\n      }\n      return uint_2;\n    }\n    if (uint_2 < 0xfe000000) {\n      return float_1 + 0x800000;\n    }\n    float_1 = float_1 & 0x80000000;\nLAB_08000bde:\n    return float_1 | 0x7f800000;\n  }\n  uint_2 = uint_2 >> 0x18;\n  float_4 = float_4 >> 0x18;\n  uint_4 = float_4 - uint_2;\n  bool_1 = uint_4 != 0;\n  uint_3 = uint_2;\n  if (bool_1 && uint_2 <= float_4) {\n    uint_3 = uint_2 + uint_4;\n  }\n  if (bool_1 && uint_2 <= float_4) {\n    float_2 = float_2 ^ float_1;\n  }\n  if (bool_1 && uint_2 <= float_4) {\n    float_1 = float_1 ^ float_2;\n  }\n  if (bool_1 && uint_2 <= float_4) {\n    float_2 = float_2 ^ float_1;\n  }\n  if (float_4 < uint_2) {\n    uint_4 = -uint_4;\n  }\n  if (0x19 < uint_4) {\n    return float_1;\n  }\n  uint_2 = float_1 & 0xffffff | 0x800000;\n  if ((float_1 & 0x80000000) != 0) {\n    uint_2 = -uint_2;\n  }\n  uint_1 = float_2 & 0xffffff | 0x800000;\n  if ((float_2 & 0x80000000) != 0) {\n    uint_1 = -uint_1;\n  }\n  if (uint_3 == uint_4) {\n    uint_1 = uint_1 ^ 0x800000;\n    if (uint_3 == 0) {\n      uint_2 = uint_2 ^ 0x800000;\n      uint_3 = 1;\n    }\n    else {\n      uint_4 = uint_4 - 1;\n    }\n  }\n  uint_2 = uint_2 + ((int)uint_1 >> (uint_4 & 0xff));\n  uint_1 = uint_1 << (0x20 - uint_4 & 0xff);\n  float_1 = uint_2 & 0x80000000;\n  if ((int)uint_2 < 0) {\n    bool_1 = uint_1 != 0;\n    uint_1 = -uint_1;\n    uint_2 = -uint_2 - (uint)bool_1;\n  }\n  if (uint_2 < 0x800000) {\n    uint_4 = uint_1 & 0x80000000;\n    uint_1 = uint_1 << 1;\n    uint_2 = uint_2 * 2 + (uint)(uint_4 != 0);\n    uint_4 = uint_3 - 2;\n    if ((uint_2 & 0x800000) == 0) {\n      int_2 = count_leading_zeroes(uint_2);\n      uint_3 = int_2 - 8;\n      uint_2 = uint_2 << (uint_3 & 0xff);\n      if ((int)uint_4 < (int)uint_3) {\n        uint_2 = uint_2 >> (-(uint_4 - uint_3) & 0xff);\n      }\n      else {\n        uint_2 = uint_2 + (uint_4 - uint_3) * 0x800000;\n      }\n      return uint_2 | float_1;\n    }\n  }\n  else {\n    uint_4 = uint_3 - 1;\n    if (0xffffff < uint_2) {\n      uint_4 = uint_2 & 1;\n      uint_2 = uint_2 >> 1;\n      uint_1 = (uint)(uint_4 != 0) << 0x1f | uint_1 >> 1;\n      uint_4 = uint_3;\n      if (0xfd < uint_3) goto LAB_08000bde;\n    }\n  }\n  uint_2 = uint_2 + uint_4 * 0x800000 + (uint)(0x7fffffff < uint_1);\n  if (uint_1 == 0x80000000) {\n    uint_2 = uint_2 & 0xfffffffe;\n  }\n  return uint_2 | float_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000aa8",
            "calling": [
                "mpu6050_calibrate",
                "HAL_TIM_PeriodElapsedCallback",
                "__aeabi_frsub"
            ],
            "imported": false,
            "current_name": "floating_point_comparison_08000aa8"
        },
        "FUN_080009ac": {
            "renaming": {
                "FUN_080009ac": "string_terminator_check_080009ac",
                "in_CY": "current_character",
                "__aeabi_cdcmpeq": "compare_characters"
            },
            "code": "\nbool string_terminator_check_080009ac(void)\n\n{\n  char current_character;\n  \n  compare_characters();\n  return current_character == '\\0';\n}\n\n",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009ac",
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "string_terminator_check_080009ac"
        },
        "FUN_08001cb8": {
            "renaming": {
                "FUN_08001cb8": "FUNC_08001cb8"
            },
            "code": "\nvoid FUNC_08001cb8(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08001cb8",
            "calling": [
                "HAL_I2C_Init"
            ],
            "imported": false,
            "current_name": "FUNC_08001cb8"
        },
        "FUN_0800438a": {
            "renaming": {
                "FUN_0800438a": "initialize_uart_0800438a",
                "huart": "uart_handle",
                "HVar1": "status",
                "HAL_ERROR": "error",
                "HAL_UNLOCKED": "unlocked",
                "HAL_UART_MspInit": "initialize_uart_gpio",
                "HAL_UART_STATE_RESET": "reset",
                "HAL_UART_STATE_BUSY": "busy",
                "HAL_UART_STATE_READY": "ready",
                "UART_SetConfig": "set_uart_config"
            },
            "code": "\nHAL_StatusTypeDef initialize_uart_0800438a(UART_HandleTypeDef *uart_handle)\n\n{\n  HAL_StatusTypeDef status;\n  \n  if (uart_handle == (UART_HandleTypeDef *)0x0) {\n    status = error;\n  }\n  else {\n    if (uart_handle->gState == reset) {\n      uart_handle->Lock = unlocked;\n      initialize_uart_0800438a_gpio(uart_handle);\n    }\n    uart_handle->gState = busy;\n    uart_handle->Instance->CR1 = uart_handle->Instance->CR1 & 0xffffdfff;\n    set_uart_config(uart_handle);\n    uart_handle->Instance->CR2 = uart_handle->Instance->CR2 & 0xffffb7ff;\n    uart_handle->Instance->CR3 = uart_handle->Instance->CR3 & 0xffffffd5;\n    uart_handle->Instance->CR1 = uart_handle->Instance->CR1 | 0x2000;\n    uart_handle->ErrorCode = 0;\n    uart_handle->gState = ready;\n    uart_handle->RxState = ready;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800438a",
            "calling": [
                "MX_USART1_UART_Init"
            ],
            "imported": false,
            "current_name": "initialize_uart_0800438a"
        },
        "FUN_080014f0": {
            "renaming": {
                "FUN_080014f0": "initialize_system_080014f0",
                "HAL_NVIC_SetPriorityGrouping": "set_system_priority_grouping",
                "HAL_MspInit": "initialize_system_gpio",
                "HAL_StatusTypeDef": "system_status"
            },
            "code": "\nsystem_status initialize_system_080014f0(void)\n\n{\n  *DAT_08001518 = *DAT_08001518 | 0x10;\n  set_system_priority_grouping(3);\n  initialize_system_080014f0Tick(0xf);\n  initialize_system_080014f0_gpio();\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_InitTick",
                "HAL_MspInit",
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080014f0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_system_080014f0"
        },
        "FUN_0800046c": {
            "renaming": {
                "FUN_0800046c": "calculate_double_precision_float_0800046c",
                "param_1": "mantissa",
                "param_2": "exponent",
                "bVar1": "bit",
                "uVar2": "temp_mantissa",
                "uVar3": "temp_exponent",
                "uVar4": "temp",
                "iVar5": "count",
                "uVar6": "shift_amount",
                "iVar7": "exponent_bits",
                "uVar8": "sign_bit",
                "uVar9": "temp_sign_bit",
                "bVar10": "carry",
                "bVar11": "overflow",
                "bVar12": "borrow"
            },
            "code": "\nulonglong calculate_double_precision_float_0800046c(uint mantissa,uint exponent)\n\n{\n  byte bit;\n  uint temp_mantissa;\n  uint temp_exponent;\n  uint temp;\n  int count;\n  uint shift_amount;\n  int exponent_bits;\n  uint sign_bit;\n  uint temp_sign_bit;\n  bool carry;\n  bool overflow;\n  bool borrow;\n  \n  if ((mantissa | exponent) == 0) {\n    return CONCAT44(exponent,mantissa);\n  }\n  sign_bit = exponent & 0x80000000;\n  temp_exponent = exponent;\n  if ((int)sign_bit < 0) {\n    overflow = mantissa != 0;\n    mantissa = -mantissa;\n    temp_exponent = -exponent - (uint)overflow;\n  }\n  exponent_bits = 0x432;\n  temp_sign_bit = temp_exponent >> 0x16;\n  if (temp_sign_bit != 0) {\n    exponent_bits = 3;\n    if (temp_exponent >> 0x19 != 0) {\n      exponent_bits = 6;\n    }\n    if (temp_exponent >> 0x1c != 0) {\n      exponent_bits = exponent_bits + 3;\n    }\n    temp = exponent_bits - ((int)temp_exponent >> 0x1f);\n    temp_sign_bit = mantissa << (0x20 - temp & 0xff);\n    mantissa = mantissa >> (temp & 0xff) | temp_exponent << (0x20 - temp & 0xff);\n    temp_exponent = temp_exponent >> (temp & 0xff);\n    exponent_bits = temp + 0x432;\n  }\n  if (0xfffff < temp_exponent) {\n    if (0x1fffff < temp_exponent) {\n      temp = temp_exponent & 1;\n      temp_exponent = temp_exponent >> 1;\n      bit = (byte)mantissa;\n      mantissa = (uint)(temp != 0) << 0x1f | mantissa >> 1;\n      temp_sign_bit = (uint)(bit & 1) << 0x1f | temp_sign_bit >> 1;\n      exponent_bits = exponent_bits + 1;\n      if (0xffbfffff < (uint)(exponent_bits * 0x200000)) {\n        return (ulonglong)(sign_bit | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_08000268:\n    overflow = 0x7fffffff < temp_sign_bit;\n    if (temp_sign_bit == 0x80000000) {\n      overflow = (mantissa & 1) != 0;\n    }\n    return CONCAT44(temp_exponent + exponent_bits * 0x100000 + (uint)CARRY4(mantissa,(uint)overflow) | sign_bit,\n                    mantissa + overflow);\n  }\n  carry = (temp_sign_bit & 0x80000000) != 0;\n  temp_sign_bit = temp_sign_bit << 1;\n  temp = mantissa * 2;\n  overflow = CARRY4(mantissa,mantissa);\n  mantissa = mantissa * 2 + (uint)carry;\n  temp_exponent = temp_exponent * 2 + (uint)(overflow || CARRY4(temp,(uint)carry));\n  exponent_bits = exponent_bits + -1;\n  if ((temp_exponent & 0x100000) != 0) goto LAB_08000268;\n  temp_mantissa = mantissa;\n  temp = temp_exponent;\n  if (temp_exponent == 0) {\n    temp_mantissa = 0;\n    temp = mantissa;\n  }\n  count = count_leading_zeroes(temp);\n  if (temp_exponent == 0) {\n    count = count + 0x20;\n  }\n  shift_amount = count - 0xb;\n  borrow = SBORROW4(shift_amount,0x20);\n  temp_exponent = count - 0x2b;\n  overflow = (int)temp_exponent < 0;\n  carry = temp_exponent == 0;\n  if ((int)shift_amount < 0x20) {\n    borrow = SCARRY4(temp_exponent,0xc);\n    count = count + -0x1f;\n    overflow = count < 0;\n    carry = count == 0;\n    temp_exponent = shift_amount;\n    if (!carry && overflow == borrow) {\n      temp_mantissa = temp << (shift_amount & 0xff);\n      temp = temp >> (0xcU - count & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (carry || overflow != borrow) {\n    temp_sign_bit = 0x20 - temp_exponent;\n  }\n  temp = temp << (temp_exponent & 0xff);\n  if (carry || overflow != borrow) {\n    temp = temp | temp_mantissa >> (temp_sign_bit & 0xff);\n  }\n  if (carry || overflow != borrow) {\n    temp_mantissa = temp_mantissa << (temp_exponent & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shift_amount <= exponent_bits) {\n    return CONCAT44(temp + (exponent_bits - shift_amount) * 0x100000 | sign_bit,temp_mantissa);\n  }\n  temp_exponent = ~(exponent_bits - shift_amount);\n  if (0x1e < (int)temp_exponent) {\n    return CONCAT44(exponent,temp >> (temp_exponent - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  exponent_bits = temp_exponent - 0x13;\n  if (exponent_bits == 0 || exponent_bits < 0 != SCARRY4(temp_exponent - 0x1f,0xc)) {\n    temp_exponent = temp_exponent + 1;\n    return CONCAT44(sign_bit | temp >> (temp_exponent & 0xff),\n                    temp_mantissa >> (temp_exponent & 0xff) | temp << (0x20 - temp_exponent & 0xff));\n  }\n  return CONCAT44(exponent,temp_mantissa >> (0x20 - (0xcU - exponent_bits) & 0xff) | temp << (0xcU - exponent_bits & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800046c",
            "calling": [],
            "imported": false,
            "current_name": "calculate_double_precision_float_0800046c"
        },
        "FUN_080009c0": {
            "renaming": {
                "FUN_080009c0": "compare_double_080009c0",
                "in_ZR": "equal",
                "in_CY": "not_equal",
                "__aeabi_cdcmpeq": "compare_double_helper"
            },
            "code": "\nbool compare_double_080009c0(void)\n\n{\n  undefined equal;\n  undefined not_equal;\n  \n  compare_double_080009c0_helper();\n  return !(bool)not_equal || (bool)equal;\n}\n\n",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009c0",
            "calling": [
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "compare_double_080009c0"
        },
        "FUN_08003f18": {
            "renaming": {
                "FUN_08003f18": "configure_timer_output_compare_08003f18",
                "TIMx": "timer_instance",
                "OC_Config": "output_compare_config",
                "uVar1": "output_compare_mode",
                "uVar2": "output_compare_polarity_and_enable",
                "tmpccmrx": "ccmrx_temp",
                "tmpcr2": "cr2_temp",
                "tmpccer": "ccer_temp"
            },
            "code": "\nvoid configure_timer_output_compare_08003f18(TIM_TypeDef *timer_instance,TIM_OC_InitTypeDef *output_compare_config)\n\n{\n  uint output_compare_mode;\n  uint32_t output_compare_polarity_and_enable;\n  uint32_t ccmrx_temp;\n  uint32_t cr2_temp;\n  uint32_t ccer_temp;\n  \n  timer_instance->CCER = timer_instance->CCER & 0xfffffeff;\n  cr2_temp = timer_instance->CR2;\n  output_compare_mode = output_compare_config->OCMode;\n  output_compare_polarity_and_enable = output_compare_config->OCPolarity << 8 | timer_instance->CCER & 0xfffffdff;\n  if (timer_instance == DAT_08003ff4) {\n    output_compare_polarity_and_enable = (output_compare_config->OCNPolarity << 8 | output_compare_polarity_and_enable & 0xfffff7ff) & 0xfffffbff;\n    cr2_temp = output_compare_config->OCNIdleState << 4 | output_compare_config->OCIdleState << 4 | cr2_temp & 0xffffcfff;\n  }\n  timer_instance->CR2 = cr2_temp;\n  timer_instance->CCMR2 = output_compare_mode | timer_instance->CCMR2 & 0xffffff8c;\n  timer_instance->CCR3 = output_compare_config->Pulse;\n  timer_instance->CCER = output_compare_polarity_and_enable;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f18",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_output_compare_08003f18"
        },
        "FUN_080097cc": {
            "renaming": {
                "FUN_080097cc": "extract_data_080097cc",
                "param_1": "error_code",
                "param_2": "output_buffer",
                "param_3": "input_buffer",
                "pvVar1": "output_buffer_ptr",
                "pvVar2": "data_size",
                "pvVar4": "remaining_space",
                "pvVar5": "data_to_copy",
                "ppvVar6": "current_input_ptr",
                "ppvVar7": "start_input_ptr",
                "__src": "input_data",
                "__n": "data_to_copy_size"
            },
            "code": "\nundefined4 extract_data_080097cc(undefined4 *error_code,void **output_buffer,int *input_buffer)\n\n{\n  void *output_buffer_ptr;\n  void *data_size;\n  int iVar3;\n  void *remaining_space;\n  void *data_to_copy;\n  void **current_input_ptr;\n  void **start_input_ptr;\n  void *input_data;\n  size_t data_to_copy_size;\n  \n  if (input_buffer[2] != 0) {\n    output_buffer_ptr = *output_buffer;\n    remaining_space = output_buffer[2];\n    start_input_ptr = (void **)*input_buffer;\n    do {\n      do {\n        current_input_ptr = start_input_ptr + 2;\n        input_data = *start_input_ptr;\n        data_to_copy = start_input_ptr[1];\n        start_input_ptr = current_input_ptr;\n      } while (data_to_copy == (void *)0x0);\n      data_size = data_to_copy;\n      if ((remaining_space <= data_to_copy) && (data_size = remaining_space, (*(ushort *)(output_buffer + 3) & 0x480) != 0)) {\n        data_to_copy_size = (int)output_buffer_ptr - (int)output_buffer[4];\n        remaining_space = (void *)(((int)output_buffer[5] * 3) / 2);\n        output_buffer_ptr = (void *)((int)data_to_copy + data_to_copy_size + 1);\n        if (remaining_space < output_buffer_ptr) {\n          remaining_space = output_buffer_ptr;\n        }\n        if ((int)((uint)*(ushort *)(output_buffer + 3) << 0x15) < 0) {\n          data_size = (void *)_malloc_r(error_code,remaining_space);\n          if (data_size == (void *)0x0) {\nLAB_08009896:\n            *error_code = 0xc;\n            *(ushort *)(output_buffer + 3) = *(ushort *)(output_buffer + 3) | 0x40;\n            input_buffer[1] = 0;\n            input_buffer[2] = 0;\n            return 0xffffffff;\n          }\n          memcpy(data_size,output_buffer[4],data_to_copy_size);\n          *(ushort *)(output_buffer + 3) = *(ushort *)(output_buffer + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          data_size = (void *)_realloc_r(error_code);\n          if (data_size == (void *)0x0) {\n            _free_r(error_code,output_buffer[4]);\n            goto LAB_08009896;\n          }\n        }\n        output_buffer_ptr = (void *)((int)data_size + data_to_copy_size);\n        output_buffer[5] = remaining_space;\n        output_buffer[4] = data_size;\n        *output_buffer = output_buffer_ptr;\n        output_buffer[2] = (void *)((int)remaining_space - data_to_copy_size);\n        data_size = data_to_copy;\n      }\n      memmove(output_buffer_ptr,input_data,(size_t)data_size);\n      iVar3 = input_buffer[2];\n      remaining_space = (void *)((int)output_buffer[2] - (int)data_size);\n      output_buffer_ptr = (void *)((int)*output_buffer + (int)data_size);\n      output_buffer[2] = remaining_space;\n      *output_buffer = output_buffer_ptr;\n      input_buffer[2] = iVar3 - (int)data_to_copy;\n    } while (iVar3 - (int)data_to_copy != 0);\n  }\n  input_buffer[1] = 0;\n  return 0;\n}\n\n",
            "called": [
                "_malloc_r",
                "memmove",
                "_free_r",
                "_realloc_r",
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080097cc",
            "calling": [
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "extract_data_080097cc"
        },
        "FUN_08001f6c": {
            "renaming": {
                "FUN_08001f6c": "read_memory_from_i2_c_08001f6c",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "data",
                "Size": "dataSize",
                "Timeout": "timeout",
                "uVar1": "tempVar1",
                "HVar2": "status",
                "Tickstart": "tickStart",
                "uVar3": "tempVar2",
                "cVar4": "tempVar3",
                "uVar5": "tempVar4",
                "iVar6": "tempVar5",
                "puVar7": "tempVar6",
                "bVar8": "tempVar7",
                "tmpreg_3": "tempReg3",
                "tmpreg_2": "tempReg2",
                "tmpreg_1": "tempReg1",
                "tmpreg": "tempReg",
                "tickstart": "tempTickstart"
            },
            "code": "\nHAL_StatusTypeDef\nreadMemoryFromI2C_08001f6c(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize\n                ,uint8_t *data,uint16_t dataSize,uint32_t timeout)\n\n{\n  uint tempVar1;\n  HAL_StatusTypeDef status;\n  uint32_t tickStart;\n  uint32_t tempVar2;\n  char tempVar3;\n  uint tempVar4;\n  int tempVar5;\n  uint8_t *tempVar6;\n  bool tempVar7;\n  uint32_t tempReg3;\n  uint32_t tempReg2;\n  uint32_t tempReg1;\n  uint32_t tempReg;\n  uint32_t tempTickstart;\n  \n  tickStart = HAL_GetTick();\n  tempVar1 = DAT_080021e0;\n  if (i2cHandle->State == HAL_I2C_STATE_READY) {\n    do {\n      if ((tempVar1 >> 0x10 & 0xff) == 1) {\n        tempVar4 = tempVar1 & ~i2cHandle->Instance->SR1 & 0xffff;\n        tempVar7 = tempVar4 == 0;\n        if (tempVar7) {\n          tempVar4 = 1;\n        }\n        tempVar3 = (char)tempVar4;\n        if (!tempVar7) {\n          tempVar3 = '\\0';\n        }\n      }\n      else {\n        tempVar4 = tempVar1 & ~i2cHandle->Instance->SR2 & 0xffff;\n        tempVar7 = tempVar4 == 0;\n        if (tempVar7) {\n          tempVar4 = 1;\n        }\n        tempVar3 = (char)tempVar4;\n        if (!tempVar7) {\n          tempVar3 = '\\0';\n        }\n      }\n      if (tempVar3 != '\\x01') {\n        tempVar5 = 0;\n        goto LAB_08002040;\n      }\n      tempVar2 = HAL_GetTick();\n    } while (tempVar2 - tickStart < 0x1a);\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Lock = HAL_UNLOCKED;\n    tempVar5 = 3;\nLAB_08002040:\n    if (tempVar5 == 0) {\n      if (i2cHandle->Lock == HAL_LOCKED) {\n        status = HAL_BUSY;\n      }\n      else {\n        i2cHandle->Lock = HAL_LOCKED;\n        if ((i2cHandle->Instance->CR1 & 1) != 1) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n        i2cHandle->State = HAL_I2C_STATE_BUSY_RX;\n        i2cHandle->Mode = HAL_I2C_MODE_MEM;\n        i2cHandle->ErrorCode = 0;\n        i2cHandle->pBuffPtr = data;\n        i2cHandle->XferCount = dataSize;\n        i2cHandle->XferOptions = DAT_080021e4;\n        i2cHandle->XferdataSize = i2cHandle->XferCount;\n        status = I2C_RequestMemoryRead(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout,tickStart);\n        if (status == HAL_OK) {\n          if (i2cHandle->XferdataSize == 0) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n          }\n          else if (i2cHandle->XferdataSize == 1) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n            disableIRQinterrupts();\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (i2cHandle->XferdataSize == 2) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n            disableIRQinterrupts();\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n          }\n          while (tempVar1 = DAT_080024bc, i2cHandle->XferdataSize != 0) {\n            if (i2cHandle->XferdataSize < 4) {\n              if (i2cHandle->XferdataSize == 1) {\n                status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n                if (status != HAL_OK) {\n                  if (i2cHandle->ErrorCode == 0x20) {\n                    return HAL_TIMEOUT;\n                  }\n                  return HAL_ERROR;\n                }\n                tempVar2 = i2cHandle->Instance->DR;\n                tempVar6 = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = tempVar6 + 1;\n                *tempVar6 = (uint8_t)tempVar2;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n              else if (i2cHandle->XferdataSize == 2) {\n                do {\n                  if ((tempVar1 >> 0x10 & 0xff) == 1) {\n                    tempVar4 = tempVar1 & ~i2cHandle->Instance->SR1 & 0xffff;\n                    tempVar7 = tempVar4 == 0;\n                    if (tempVar7) {\n                      tempVar4 = 1;\n                    }\n                    tempVar3 = (char)tempVar4;\n                    if (!tempVar7) {\n                      tempVar3 = '\\0';\n                    }\n                  }\n                  else {\n                    tempVar4 = tempVar1 & ~i2cHandle->Instance->SR2 & 0xffff;\n                    tempVar7 = tempVar4 == 0;\n                    if (tempVar7) {\n                      tempVar4 = 1;\n                    }\n                    tempVar3 = (char)tempVar4;\n                    if (!tempVar7) {\n                      tempVar3 = '\\0';\n                    }\n                  }\n                  if (tempVar3 != '\\0') {\n                    tempVar5 = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (tempVar2 = HAL_GetTick(), tempVar2 - tickStart <= timeout))));\n                i2cHandle->PreviousState = 0;\n                i2cHandle->State = HAL_I2C_STATE_READY;\n                i2cHandle->Mode = HAL_I2C_MODE_NONE;\n                i2cHandle->Lock = HAL_UNLOCKED;\n                tempVar5 = 3;\nLAB_080022fa:\n                if (tempVar5 != 0) {\n                  return HAL_TIMEOUT;\n                }\n                disableIRQinterrupts();\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n                tempVar2 = i2cHandle->Instance->DR;\n                tempVar6 = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = tempVar6 + 1;\n                *tempVar6 = (uint8_t)tempVar2;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n                enableIRQinterrupts();\n                tempVar2 = i2cHandle->Instance->DR;\n                tempVar6 = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = tempVar6 + 1;\n                *tempVar6 = (uint8_t)tempVar2;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n              else {\n                do {\n                  if ((tempVar1 >> 0x10 & 0xff) == 1) {\n                    tempVar4 = tempVar1 & ~i2cHandle->Instance->SR1 & 0xffff;\n                    tempVar7 = tempVar4 == 0;\n                    if (tempVar7) {\n                      tempVar4 = 1;\n                    }\n                    tempVar3 = (char)tempVar4;\n                    if (!tempVar7) {\n                      tempVar3 = '\\0';\n                    }\n                  }\n                  else {\n                    tempVar4 = tempVar1 & ~i2cHandle->Instance->SR2 & 0xffff;\n                    tempVar7 = tempVar4 == 0;\n                    if (tempVar7) {\n                      tempVar4 = 1;\n                    }\n                    tempVar3 = (char)tempVar4;\n                    if (!tempVar7) {\n                      tempVar3 = '\\0';\n                    }\n                  }\n                  if (tempVar3 != '\\0') {\n                    tempVar5 = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (tempVar2 = HAL_GetTick(), tempVar2 - tickStart <= timeout))));\n                i2cHandle->PreviousState = 0;\n                i2cHandle->State = HAL_I2C_STATE_READY;\n                i2cHandle->Mode = HAL_I2C_MODE_NONE;\n                i2cHandle->Lock = HAL_UNLOCKED;\n                tempVar5 = 3;\nLAB_08002418:\n                if (tempVar5 != 0) {\n                  return HAL_TIMEOUT;\n                }\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n                disableIRQinterrupts();\n                tempVar2 = i2cHandle->Instance->DR;\n                tempVar6 = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = tempVar6 + 1;\n                *tempVar6 = (uint8_t)tempVar2;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n                tempVar1 = DAT_080024bc;\n                do {\n                  if ((tempVar1 >> 0x10 & 0xff) == 1) {\n                    tempVar4 = tempVar1 & ~i2cHandle->Instance->SR1 & 0xffff;\n                    tempVar7 = tempVar4 == 0;\n                    if (tempVar7) {\n                      tempVar4 = 1;\n                    }\n                    tempVar3 = (char)tempVar4;\n                    if (!tempVar7) {\n                      tempVar3 = '\\0';\n                    }\n                  }\n                  else {\n                    tempVar4 = tempVar1 & ~i2cHandle->Instance->SR2 & 0xffff;\n                    tempVar7 = tempVar4 == 0;\n                    if (tempVar7) {\n                      tempVar4 = 1;\n                    }\n                    tempVar3 = (char)tempVar4;\n                    if (!tempVar7) {\n                      tempVar3 = '\\0';\n                    }\n                  }\n                  if (tempVar3 != '\\0') {\n                    tempVar5 = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (tempVar2 = HAL_GetTick(), tempVar2 - tickStart <= timeout))));\n                i2cHandle->PreviousState = 0;\n                i2cHandle->State = HAL_I2C_STATE_READY;\n                i2cHandle->Mode = HAL_I2C_MODE_NONE;\n                i2cHandle->Lock = HAL_UNLOCKED;\n                tempVar5 = 3;\nLAB_0800250a:\n                if (tempVar5 != 0) {\n                  return HAL_TIMEOUT;\n                }\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n                tempVar2 = i2cHandle->Instance->DR;\n                tempVar6 = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = tempVar6 + 1;\n                *tempVar6 = (uint8_t)tempVar2;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n                enableIRQinterrupts();\n                tempVar2 = i2cHandle->Instance->DR;\n                tempVar6 = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = tempVar6 + 1;\n                *tempVar6 = (uint8_t)tempVar2;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n            }\n            else {\n              status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n              if (status != HAL_OK) {\n                if (i2cHandle->ErrorCode == 0x20) {\n                  return HAL_TIMEOUT;\n                }\n                return HAL_ERROR;\n              }\n              tempVar2 = i2cHandle->Instance->DR;\n              tempVar6 = i2cHandle->pBuffPtr;\n              i2cHandle->pBuffPtr = tempVar6 + 1;\n              *tempVar6 = (uint8_t)tempVar2;\n              i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n              i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              if ((i2cHandle->Instance->SR1 & 4) == 4) {\n                tempVar2 = i2cHandle->Instance->DR;\n                tempVar6 = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = tempVar6 + 1;\n                *tempVar6 = (uint8_t)tempVar2;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n            }\n          }\n          i2cHandle->State = HAL_I2C_STATE_READY;\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_OK;\n        }\n        else if (i2cHandle->ErrorCode == 4) {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_ERROR;\n        }\n        else {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      status = HAL_BUSY;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "called": [
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "I2C_RequestMemoryRead",
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001f6c",
            "calling": [
                "_i2c_read_reg"
            ],
            "imported": false,
            "current_name": "read_memory_from_i2_c_08001f6c"
        },
        "FUN_080014ec": {
            "renaming": {
                "FUN_080014ec": "FUNC_080014ec"
            },
            "code": "\nvoid FUNC_080014ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080014ec",
            "calling": [
                "__aeabi_uldivmod"
            ],
            "imported": false,
            "current_name": "FUNC_080014ec"
        },
        "FUN_08000c3c": {
            "renaming": {
                "FUN_08000c3c": "find_quotient_08000c3c",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar1": "abs_divisor",
                "uVar2": "abs_dividend",
                "iVar3": "num_leading_zeros",
                "uVar4": "shift_amount",
                "uVar5": "divisor_sign",
                "iVar6": "magic_number",
                "uVar7": "shifted_dividend",
                "bVar8": "dividend_is_negative"
            },
            "code": "\nuint find_quotient_08000c3c(uint dividend,uint divisor)\n\n{\n  uint abs_divisor;\n  uint abs_dividend;\n  int num_leading_zeros;\n  uint shift_amount;\n  uint divisor_sign;\n  int magic_number;\n  uint shifted_dividend;\n  bool dividend_is_negative;\n  \n  if ((dividend | divisor) == 0) {\n    return dividend;\n  }\n  divisor_sign = divisor & 0x80000000;\n  if ((int)divisor_sign < 0) {\n    dividend_is_negative = dividend != 0;\n    dividend = -dividend;\n    divisor = -divisor - (uint)dividend_is_negative;\n  }\n  abs_dividend = dividend;\n  abs_divisor = divisor;\n  if (divisor == 0) {\n    abs_dividend = 0;\n    abs_divisor = dividend;\n  }\n  divisor_sign = divisor_sign | 0x5b000000;\n  if (divisor == 0) {\n    divisor_sign = divisor_sign + 0xf0000000;\n  }\n  num_leading_zeros = count_leading_zeroes(abs_divisor);\n  shift_amount = num_leading_zeros - 8;\n  magic_number = (divisor_sign - 0x800000) + shift_amount * -0x800000;\n  if (num_leading_zeros < 8) {\n    shift_amount = abs_divisor << (num_leading_zeros + 0x18U & 0xff);\n    divisor_sign = magic_number + ((abs_divisor >> (0x20 - (num_leading_zeros + 0x18U) & 0xff)) - ((int)shift_amount >> 0x1f));\n    if ((abs_dividend | shift_amount << 1) == 0) {\n      divisor_sign = divisor_sign & ~(shift_amount >> 0x1f);\n    }\n    return divisor_sign;\n  }\n  shifted_dividend = abs_dividend << (shift_amount & 0xff);\n  divisor_sign = magic_number + (abs_divisor << (shift_amount & 0xff)) +\n          (abs_dividend >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < shifted_dividend);\n  if (shifted_dividend == 0x80000000) {\n    divisor_sign = divisor_sign & 0xfffffffe;\n  }\n  return divisor_sign;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c3c",
            "calling": [],
            "imported": false,
            "current_name": "find_quotient_08000c3c"
        },
        "FUN_08003518": {
            "renaming": {
                "FUN_08003518": "get_hclk_frequency_divider_08003518",
                "uVar1": "HCLK_frequency"
            },
            "code": "\nuint32_t get_HCLK_frequency_divider_08003518(void)\n\n{\n  uint32_t HCLK_frequency;\n  \n  HCLK_frequency = HAL_RCC_GetHCLKFreq();\n  return HCLK_frequency >> PTR_APBPrescTable_0800353c[*(uint *)(DAT_08003538 + 4) >> 8 & 7];\n}\n\n",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003518",
            "calling": [
                "UART_SetConfig",
                "HAL_I2C_Init"
            ],
            "imported": false,
            "current_name": "get_hclk_frequency_divider_08003518"
        },
        "FUN_08002d8a": {
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "code": "\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08002d8a",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "FUNC_08002d8a"
        },
        "FUN_08005780": {
            "renaming": {
                "FUN_08005780": "set_flag_and_clear_bits_08005780"
            },
            "code": "\nvoid set_flag_and_clear_bits_08005780(void)\n\n{\n  *DAT_080057dc = *DAT_080057dc | 1;\n  DAT_080057dc[1] = DAT_080057e0 & DAT_080057dc[1];\n  *DAT_080057dc = *DAT_080057dc & 0xfef6ffff;\n  *DAT_080057dc = *DAT_080057dc & 0xfffbffff;\n  DAT_080057dc[1] = DAT_080057dc[1] & 0xff80ffff;\n  DAT_080057dc[2] = 0x9f0000;\n  *(undefined4 *)(DAT_080057e4 + 8) = 0x8000000;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005780",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "set_flag_and_clear_bits_08005780"
        },
        "FUN_08000fe0": {
            "renaming": {
                "FUN_08000fe0": "compare_floats_08000fe0",
                "in_ZR": "result",
                "__aeabi_cfcmpeq": "compare_floats_using_equality_operator"
            },
            "code": "\nbool compare_floats_08000fe0(void)\n\n{\n  char result;\n  \n  compare_floats_08000fe0_using_equality_operator();\n  return result != '\\0';\n}\n\n",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000fe0",
            "calling": [],
            "imported": false,
            "current_name": "compare_floats_08000fe0"
        },
        "FUN_08008818": {
            "renaming": {
                "FUN_08008818": "execute_global_destructors_08008818",
                "iVar1": "num_destructors",
                "ppcVar2": "destructor_func_ptr",
                "_fini": "finalize_program"
            },
            "code": "\nvoid execute_global_destructors_08008818(void)\n\n{\n  int num_destructors;\n  code **destructor_func_ptr;\n  \n  num_destructors = (int)PTR__finalize_program_array_end_08008844 -\n          (int)PTR___do_global_dtors_auxfinalize_program_array_entry_08008848 >> 2;\n  if (num_destructors != 0) {\n    destructor_func_ptr = (code **)(PTR___do_global_dtors_auxfinalize_program_array_entry_08008848 +\n                       (num_destructors + 0x3fffffff) * 4);\n    do {\n      num_destructors = num_destructors + -1;\n      (**destructor_func_ptr)();\n      destructor_func_ptr = destructor_func_ptr + -1;\n    } while (num_destructors != 0);\n  }\n  finalize_program();\n  return;\n}\n\n",
            "called": [
                "__do_global_dtors_aux",
                "_fini",
                "frame_dummy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008818",
            "calling": [],
            "imported": false,
            "current_name": "execute_global_destructors_08008818"
        },
        "FUN_08000418": {
            "renaming": {
                "FUN_08000418": "decode_unsigned_long_long_08000418",
                "param_1": "input_value",
                "param_2": "unused_param_1",
                "param_3": "unused_param_2",
                "param_4": "input_mask",
                "uVar1": "high_bits",
                "uVar2": "lower_bits",
                "uVar3": "high_bits_masked",
                "uVar4": "shifted_input_value",
                "uVar5": "shifted_input_value_twice",
                "uVar7": "leading_zeroes",
                "iVar6": "shift_amount",
                "bVar8": "shift_amount_is_zero",
                "bVar9": "is_masked_value",
                "bVar10": "shift_amount_is_negative",
                "in_r12": "unused_register"
            },
            "code": "\nulonglong decode_unsigned_long_long_08000418(uint input_value,undefined4 unused_param_1,undefined4 unused_param_2,uint input_mask)\n\n{\n  uint high_bits;\n  uint lower_bits;\n  uint high_bits_masked;\n  uint shifted_input_value;\n  uint shifted_input_value_twice;\n  int shift_amount;\n  uint leading_zeroes;\n  uint unused_register;\n  bool shift_amount_is_zero;\n  bool is_masked_value;\n  bool shift_amount_is_negative;\n  \n  shifted_input_value_twice = input_value << 1;\n  is_masked_value = shifted_input_value_twice == 0;\n  high_bits = (uint)((input_value & 0x80000000) != 0) << 0x1f;\n  shifted_input_value = (uint)((int)shifted_input_value_twice >> 3) >> 1;\n  high_bits_masked = high_bits | shifted_input_value;\n  input_value = input_value << 0x1d;\n  if (!is_masked_value) {\n    input_mask = shifted_input_value_twice & 0xff000000;\n    is_masked_value = input_mask == 0;\n  }\n  if (!is_masked_value) {\n    is_masked_value = input_mask == 0xff000000;\n  }\n  if (!is_masked_value) {\n    return CONCAT44(high_bits_masked,input_value) ^ 0x3800000000000000;\n  }\n  if ((shifted_input_value_twice & 0xffffff) == 0) {\n    return CONCAT44(high_bits_masked,input_value);\n  }\n  if (input_mask == 0xff000000) {\n    return CONCAT44(high_bits_masked,input_value) | 0x8000000000000;\n  }\n  lower_bits = input_value;\n  shifted_input_value_twice = shifted_input_value;\n  if (shifted_input_value == 0) {\n    lower_bits = 0;\n    shifted_input_value_twice = input_value;\n  }\n  shift_amount = count_leading_zeroes(shifted_input_value_twice);\n  if (shifted_input_value == 0) {\n    shift_amount = shift_amount + 0x20;\n  }\n  leading_zeroes = shift_amount - 0xb;\n  shift_amount_is_negative = SBORROW4(leading_zeroes,0x20);\n  shifted_input_value = shift_amount - 0x2b;\n  is_masked_value = (int)shifted_input_value < 0;\n  shift_amount_is_zero = shifted_input_value == 0;\n  if ((int)leading_zeroes < 0x20) {\n    shift_amount_is_negative = SCARRY4(shifted_input_value,0xc);\n    shift_amount = shift_amount + -0x1f;\n    is_masked_value = shift_amount < 0;\n    shift_amount_is_zero = shift_amount == 0;\n    shifted_input_value = leading_zeroes;\n    if (!shift_amount_is_zero && is_masked_value == shift_amount_is_negative) {\n      lower_bits = shifted_input_value_twice << (leading_zeroes & 0xff);\n      shifted_input_value_twice = shifted_input_value_twice >> (0xcU - shift_amount & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (shift_amount_is_zero || is_masked_value != shift_amount_is_negative) {\n    unused_register = 0x20 - shifted_input_value;\n  }\n  shifted_input_value_twice = shifted_input_value_twice << (shifted_input_value & 0xff);\n  if (shift_amount_is_zero || is_masked_value != shift_amount_is_negative) {\n    shifted_input_value_twice = shifted_input_value_twice | lower_bits >> (unused_register & 0xff);\n  }\n  if (shift_amount_is_zero || is_masked_value != shift_amount_is_negative) {\n    lower_bits = lower_bits << (shifted_input_value & 0xff);\n  }\nLAB_080002e0:\n  if ((int)leading_zeroes < 0x381) {\n    return CONCAT44(shifted_input_value_twice + (0x380 - leading_zeroes) * 0x100000 | high_bits,lower_bits);\n  }\n  shifted_input_value = ~(0x380 - leading_zeroes);\n  if (0x1e < (int)shifted_input_value) {\n    return CONCAT44(high_bits_masked,shifted_input_value_twice >> (shifted_input_value - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  shift_amount = shifted_input_value - 0x13;\n  if (shift_amount == 0 || shift_amount < 0 != SCARRY4(shifted_input_value - 0x1f,0xc)) {\n    shifted_input_value = shifted_input_value + 1;\n    return CONCAT44(high_bits | shifted_input_value_twice >> (shifted_input_value & 0xff),\n                    lower_bits >> (shifted_input_value & 0xff) | shifted_input_value_twice << (0x20 - shifted_input_value & 0xff));\n  }\n  return CONCAT44(high_bits_masked,lower_bits >> (0x20 - (0xcU - shift_amount) & 0xff) | shifted_input_value_twice << (0xcU - shift_amount & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000418",
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calc_pitch",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "imported": false,
            "current_name": "decode_unsigned_long_long_08000418"
        },
        "FUN_080055f4": {
            "renaming": {
                "FUN_080055f4": "initialize_gpio_pins_080055f4",
                "GPIO_InitStruct": "gpio_init_struct",
                "tmpreg_2": "temporary_register_2",
                "tmpreg_1": "temporary_register_1",
                "tmpreg": "temporary_register"
            },
            "code": "\nvoid initialize_GPIO_pins_080055f4(void)\n\n{\n  uint32_t temporary_register_2;\n  uint32_t temporary_register_1;\n  uint32_t temporary_register;\n  GPIO_InitTypeDef gpio_init_struct;\n  \n  *(uint *)(DAT_0800566c + 0x18) = *(uint *)(DAT_0800566c + 0x18) | 0x20;\n  *(uint *)(DAT_0800566c + 0x18) = *(uint *)(DAT_0800566c + 0x18) | 4;\n  *(uint *)(DAT_0800566c + 0x18) = *(uint *)(DAT_0800566c + 0x18) | 8;\n  HAL_GPIO_WritePin(DAT_08005670,0x1e,GPIO_PIN_RESET);\n  gpio_init_struct.Pin = 0x1e;\n  gpio_init_struct.Mode = 1;\n  gpio_init_struct.Speed = 2;\n  HAL_GPIO_Init(DAT_08005670,&gpio_init_struct);\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init",
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080055f4",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_gpio_pins_080055f4"
        },
        "FUN_080053b0": {
            "renaming": {
                "FUN_080053b0": "initialize_pwm_timer_080053b0",
                "HVar1": "status",
                "sBreakDeadTimeConfig": "break_dead_time_config",
                "sConfigOC": "output_compare_config",
                "sMasterConfig": "master_config",
                "sClockSourceConfig": "clock_source_config"
            },
            "code": "\nvoid initialize_PWM_timer_080053b0(void)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_BreakDeadTimeConfigTypeDef break_dead_time_config;\n  TIM_OC_InitTypeDef output_compare_config;\n  TIM_MasterConfigTypeDef master_config;\n  TIM_ClockConfigTypeDef clock_source_config;\n  \n  *(undefined4 *)PTR_htim1_080054f4 = DAT_080054f8;\n  *(undefined4 *)(PTR_htim1_080054f4 + 4) = 0x708;\n  *(undefined4 *)(PTR_htim1_080054f4 + 8) = 0;\n  *(undefined4 *)(PTR_htim1_080054f4 + 0xc) = 100;\n  *(undefined4 *)(PTR_htim1_080054f4 + 0x10) = 0;\n  *(undefined4 *)(PTR_htim1_080054f4 + 0x14) = 0;\n  *(undefined4 *)(PTR_htim1_080054f4 + 0x18) = 0;\n  status = HAL_TIM_Base_Init((TIM_HandleTypeDef *)PTR_htim1_080054f4);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s____src_main_c_080054fc,399);\n  }\n  clock_source_config.ClockSource = 0x1000;\n  status = HAL_TIM_ConfigClockSource((TIM_HandleTypeDef *)PTR_htim1_080054f4,&clock_source_config);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s____src_main_c_080054fc,0x194);\n  }\n  status = HAL_TIM_PWM_Init((TIM_HandleTypeDef *)PTR_htim1_080054f4);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s____src_main_c_080054fc,0x198);\n  }\n  master_config.MasterOutputTrigger = 0;\n  master_config.MasterSlaveMode = 0;\n  status = HAL_TIMEx_MasterConfigSynchronization\n                    ((TIM_HandleTypeDef *)PTR_htim1_080054f4,&master_config);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s____src_main_c_080054fc,0x19f);\n  }\n  output_compare_config.OCMode = 0x60;\n  output_compare_config.Pulse = 0;\n  output_compare_config.OCPolarity = 0;\n  output_compare_config.OCNPolarity = 0;\n  output_compare_config.OCFastMode = 0;\n  output_compare_config.OCIdleState = 0;\n  output_compare_config.OCNIdleState = 0;\n  status = HAL_TIM_PWM_ConfigChannel((TIM_HandleTypeDef *)PTR_htim1_080054f4,&output_compare_config,0);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s____src_main_c_080054fc,0x1ab);\n  }\n  status = HAL_TIM_PWM_ConfigChannel((TIM_HandleTypeDef *)PTR_htim1_080054f4,&output_compare_config,0xc);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s____src_main_c_080054fc,0x1b0);\n  }\n  break_dead_time_config.OffStateRunMode = 0;\n  break_dead_time_config.OffStateIDLEMode = 0;\n  break_dead_time_config.LockLevel = 0;\n  break_dead_time_config.DeadTime = 0;\n  break_dead_time_config.BreakState = 0;\n  break_dead_time_config.BreakPolarity = 0x2000;\n  break_dead_time_config.AutomaticOutput = 0;\n  status = HAL_TIMEx_ConfigBreakDeadTime\n                    ((TIM_HandleTypeDef *)PTR_htim1_080054f4,&break_dead_time_config);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s____src_main_c_080054fc,0x1bc);\n  }\n  HAL_TIM_MspPostInit((TIM_HandleTypeDef *)PTR_htim1_080054f4);\n  return;\n}\n\n",
            "called": [
                "HAL_TIM_ConfigClockSource",
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIM_MspPostInit",
                "_Error_Handler",
                "HAL_TIMEx_MasterConfigSynchronization",
                "HAL_TIM_Base_Init",
                "HAL_TIM_PWM_Init",
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053b0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_pwm_timer_080053b0"
        },
        "FUN_08009e74": {
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08009e74",
            "calling": [
                "__libc_fini_array"
            ],
            "imported": false,
            "current_name": "FUNC_08009e74"
        },
        "FUN_080016d0": {
            "renaming": {
                "FUN_080016d0": "check_ticks_within_range_080016d0",
                "ticks": "ticks_value",
                "bVar1": "is_within_range",
                "SysTick_IRQn": "system_tick_interrupt"
            },
            "code": "\nuint32_t check_ticks_within_range_080016d0(uint32_t ticks_value)\n\n{\n  bool is_within_range;\n  \n  is_within_range = ticks_value - 1 < 0x1000000;\n  if (is_within_range) {\n    DAT_08001710[1] = ticks_value - 1;\n    NVIC_SetPriority(system_tick_interrupt,0xf);\n    DAT_08001710[2] = 0;\n    *DAT_08001710 = 7;\n  }\n  return (uint)!is_within_range;\n}\n\n",
            "called": [
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080016d0",
            "calling": [
                "HAL_SYSTICK_Config"
            ],
            "imported": false,
            "current_name": "check_ticks_within_range_080016d0"
        },
        "FUN_0800088a": {
            "renaming": {
                "FUN_0800088a": "binary_to_double_0800088a",
                "param_1": "first_half_mantissa",
                "param_2": "exponent_and_second_half_mantissa",
                "param_3": "second_half_mantissa",
                "param_4": "sign_and_exponent",
                "uVar1": "bit",
                "unaff_r4": "in_r12_copy",
                "uVar2": "shifted_sign_and_exponent",
                "uVar3": "exponent_and_second_half_mantissa_copy",
                "bVar4": "is_zero",
                "in_r12": "sign_and_exponent_copy"
            },
            "code": "\nulonglong binary_to_double_0800088a(uint first_half_mantissa,uint exponent_and_second_half_mantissa,uint second_half_mantissa,uint sign_and_exponent)\n\n{\n  uint bit;\n  uint in_r12_copy;\n  uint shifted_sign_and_exponent;\n  uint exponent_and_second_half_mantissa_copy;\n  uint sign_and_exponent_copy;\n  bool is_zero;\n  \n  shifted_sign_and_exponent = sign_and_exponent_copy & sign_and_exponent >> 0x14;\n  exponent_and_second_half_mantissa_copy = exponent_and_second_half_mantissa;\n  if (in_r12_copy != sign_and_exponent_copy || shifted_sign_and_exponent != sign_and_exponent_copy) {\n    if (in_r12_copy == sign_and_exponent_copy) {\n      if (((first_half_mantissa | exponent_and_second_half_mantissa << 0xc) == 0) && (first_half_mantissa = second_half_mantissa, exponent_and_second_half_mantissa_copy = sign_and_exponent, shifted_sign_and_exponent != sign_and_exponent_copy)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((exponent_and_second_half_mantissa ^ sign_and_exponent) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (shifted_sign_and_exponent == sign_and_exponent_copy) {\n      first_half_mantissa = second_half_mantissa;\n      exponent_and_second_half_mantissa_copy = sign_and_exponent;\n      if ((second_half_mantissa | sign_and_exponent << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((exponent_and_second_half_mantissa ^ sign_and_exponent) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      is_zero = (first_half_mantissa | exponent_and_second_half_mantissa << 1) == 0;\n      if (!is_zero) {\n        is_zero = (second_half_mantissa | sign_and_exponent << 1) == 0;\n      }\n      if (!is_zero) {\n        if (in_r12_copy == 0) {\n          exponent_and_second_half_mantissa_copy = exponent_and_second_half_mantissa & 0x80000000;\n          do {\n            bit = first_half_mantissa & 0x80000000;\n            first_half_mantissa = first_half_mantissa << 1;\n            exponent_and_second_half_mantissa = exponent_and_second_half_mantissa * 2 + (uint)(bit != 0);\n          } while ((exponent_and_second_half_mantissa & 0x100000) == 0);\n          exponent_and_second_half_mantissa = exponent_and_second_half_mantissa | exponent_and_second_half_mantissa_copy;\n          if (shifted_sign_and_exponent != 0) {\n            return CONCAT44(exponent_and_second_half_mantissa,first_half_mantissa);\n          }\n        }\n        do {\n          exponent_and_second_half_mantissa_copy = second_half_mantissa & 0x80000000;\n          second_half_mantissa = second_half_mantissa << 1;\n          sign_and_exponent = sign_and_exponent * 2 + (uint)(exponent_and_second_half_mantissa_copy != 0);\n        } while ((sign_and_exponent & 0x100000) == 0);\n        return CONCAT44(exponent_and_second_half_mantissa,first_half_mantissa);\n      }\n      if ((first_half_mantissa | exponent_and_second_half_mantissa << 1) != 0) goto LAB_080006fc;\n      if ((second_half_mantissa | sign_and_exponent << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(exponent_and_second_half_mantissa_copy,first_half_mantissa) | 0x7ff8000000000000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800088a",
            "calling": [
                "__divdf3"
            ],
            "imported": false,
            "current_name": "binary_to_double_0800088a"
        },
        "FUN_08000e20": {
            "renaming": {
                "FUN_08000e20": "floating_point_addition_08000e20",
                "param_1": "float1",
                "param_2": "float2",
                "param_3": "float3",
                "param_4": "float4",
                "uVar1": "mantissa1",
                "uVar2": "mantissa2",
                "iVar3": "exponent_difference",
                "uVar4": "exponent_sum",
                "iVar5": "sum",
                "uVar6": "result",
                "bVar7": "condition",
                "bVar8": "borrow",
                "bVar9": "carry"
            },
            "code": "\nuint floating_point_addition_08000e20(uint float1,uint float2,undefined4 float3,uint float4)\n\n{\n  uint mantissa1;\n  uint mantissa2;\n  int exponent_difference;\n  uint exponent_sum;\n  int sum;\n  uint result;\n  bool condition;\n  bool borrow;\n  bool carry;\n  \n  mantissa2 = float1 >> 0x17 & 0xff;\n  condition = mantissa2 == 0;\n  if (!condition) {\n    float4 = float2 >> 0x17 & 0xff;\n    condition = float4 == 0;\n  }\n  if (!condition) {\n    condition = mantissa2 == 0xff;\n  }\n  if (!condition) {\n    condition = float4 == 0xff;\n  }\n  if (condition) {\n    float4 = float2 >> 0x17 & 0xff;\n    result = float1;\n    if (mantissa2 == 0xff) {\n      if (((float1 & 0x7fffff) != 0) || (result = float2, float4 == 0xff)) {\nLAB_08000e16:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (float4 == 0xff) {\n        result = float2;\n        if ((float2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (float1 ^ float2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      condition = (float1 & 0x7fffffff) == 0;\n      if (!condition) {\n        condition = (float2 & 0x7fffffff) == 0;\n      }\n      if (!condition) {\n        condition = mantissa2 == 0;\n        result = float1 & 0x80000000;\n        while( true ) {\n          if (condition) {\n            float1 = float1 << 1;\n            condition = (float1 & 0x800000) == 0;\n          }\n          if (!condition) break;\n          mantissa2 = mantissa2 - 1;\n        }\n        float1 = float1 | result;\n        condition = float4 == 0;\n        result = float2 & 0x80000000;\n        while( true ) {\n          if (condition) {\n            float2 = float2 << 1;\n            condition = (float2 & 0x800000) == 0;\n          }\n          if (!condition) break;\n          float4 = float4 - 1;\n        }\n        float2 = float2 | result;\n        goto LAB_08000e38;\n      }\n      if ((float1 & 0x7fffffff) == 0) {\n        if ((float2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    float1 = float1 ^ float2;\n  }\n  else {\nLAB_08000e38:\n    exponent_difference = mantissa2 - float4;\n    if (float2 << 9 == 0) {\n      float1 = (float1 ^ float2) & 0x80000000 | float1 & 0x7fffff;\n      carry = SCARRY4(exponent_difference,0x7f);\n      sum = exponent_difference + 0x7f;\n      condition = sum < 0;\n      borrow = sum == 0;\n      if (!borrow && condition == carry) {\n        carry = SBORROW4(0xff,sum);\n        condition = 0xff - sum < 0;\n        borrow = sum == 0xff;\n      }\n      if (!borrow && condition == carry) {\n        float1 = float1 | sum * 0x800000;\n      }\n      if (!borrow && condition == carry) {\n        return float1;\n      }\n      float1 = float1 | 0x800000;\n      mantissa2 = 0;\n      borrow = SBORROW4(sum,1);\n      exponent_sum = exponent_difference + 0x7e;\n      condition = exponent_sum == 0;\n      result = exponent_sum;\n    }\n    else {\n      mantissa1 = (float2 << 9) >> 4 | 0x10000000;\n      mantissa2 = (float1 << 9) >> 4 | 0x10000000;\n      float1 = (float1 ^ float2) & 0x80000000;\n      condition = mantissa1 <= mantissa2;\n      if (!condition) {\n        mantissa2 = mantissa2 << 1;\n      }\n      exponent_sum = exponent_difference + 0x7d + (uint)condition;\n      result = 0x800000;\n      do {\n        if (mantissa1 <= mantissa2) {\n          mantissa2 = mantissa2 - mantissa1;\n          float1 = float1 | result;\n        }\n        condition = mantissa1 >> 1 <= mantissa2;\n        if (condition) {\n          mantissa2 = mantissa2 - (mantissa1 >> 1);\n        }\n        if (condition) {\n          float1 = float1 | result >> 1;\n        }\n        condition = mantissa1 >> 2 <= mantissa2;\n        if (condition) {\n          mantissa2 = mantissa2 - (mantissa1 >> 2);\n        }\n        if (condition) {\n          float1 = float1 | result >> 2;\n        }\n        condition = mantissa1 >> 3 <= mantissa2;\n        if (condition) {\n          mantissa2 = mantissa2 - (mantissa1 >> 3);\n        }\n        if (condition) {\n          float1 = float1 | result >> 3;\n        }\n        mantissa2 = mantissa2 * 0x10;\n        condition = mantissa2 == 0;\n        if (!condition) {\n          result = result >> 4;\n          condition = result == 0;\n        }\n      } while (!condition);\n      borrow = SBORROW4(exponent_sum,0xfd);\n      condition = exponent_sum == 0xfd;\n      result = exponent_sum - 0xfd;\n      if (exponent_sum < 0xfe) {\n        float1 = float1 + exponent_sum * 0x800000 + (uint)(mantissa1 <= mantissa2);\n        if (mantissa2 - mantissa1 == 0) {\n          float1 = float1 & 0xfffffffe;\n        }\n        return float1;\n      }\n    }\n    if (condition || (int)result < 0 != borrow) {\n      condition = (int)(exponent_sum + 0x19) < 0;\n      if (exponent_sum == 0xffffffe7 || condition != SCARRY4(exponent_sum,0x19)) {\n        float1 = float1 & 0x80000000;\n      }\n      if (exponent_sum == 0xffffffe7 || condition != SCARRY4(exponent_sum,0x19)) {\n        return float1;\n      }\n      result = (float1 << 1) >> (-exponent_sum & 0xff);\n      exponent_sum = float1 << (exponent_sum + 0x20 & 0xff);\n      result = ((uint)((float1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((mantissa2 | exponent_sum << 1) == 0) {\n        result = result & ~(exponent_sum >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return float1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000e20",
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calibrate"
            ],
            "imported": false,
            "current_name": "floating_point_addition_08000e20"
        },
        "FUN_08005d14": {
            "renaming": {
                "FUN_08005d14": "get_impure_ptr_value_08005d14",
                "undefined4": "unsigned_int"
            },
            "code": "\nunsigned_int get_impure_ptr_value_08005d14(void)\n\n{\n  return *(unsigned_int *)PTR__impure_ptr_08005d1c;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d14",
            "calling": [
                "_sbrk"
            ],
            "imported": false,
            "current_name": "get_impure_ptr_value_08005d14"
        },
        "FUN_080015b4": {
            "renaming": {
                "FUN_080015b4": "set_priority_group_080015b4",
                "PriorityGroup": "priority",
                "reg_value": "register_value",
                "PriorityGroupTmp": "temporary_priority",
                "uint": "unsigned_integer",
                "&": "and"
            },
            "code": "\nvoid set_priority_group_080015b4(unsigned_integer32_t priority)\n\n{\n  unsigned_integer32_t register_value;\n  unsigned_integer32_t temporary_priority;\n  \n  *(unsigned_integer *)(DAT_080015f8 + 0xc) =\n       *(unsigned_integer *)(DAT_080015f8 + 0xc) and 0xf8ff | (priority and 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015b4",
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "imported": false,
            "current_name": "set_priority_group_080015b4"
        },
        "FUN_080041a8": {
            "renaming": {
                "FUN_080041a8": "configure_external_trigger_080041a8",
                "TIMx": "timer",
                "TIM_ExtTRGPrescaler": "external_trigger_prescaler",
                "TIM_ExtTRGPolarity": "external_trigger_polarity",
                "ExtTRGFilter": "external_trigger_filter",
                "tmpsmcr": "temporary_register",
                "&": "bitwise_and"
            },
            "code": "\nvoid configure_external_trigger_080041a8(TIM_TypeDef *timer,uint32_t external_trigger_prescaler,uint32_t external_trigger_polarity,\n                      uint32_t external_trigger_filter)\n\n{\n  uint32_t temporary_register;\n  \n  timer->SMCR = external_trigger_prescaler | external_trigger_filter << 8 | external_trigger_polarity |\n               timer->SMCR bitwise_and 0xffff00ff;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041a8",
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "imported": false,
            "current_name": "configure_external_trigger_080041a8"
        },
        "FUN_080004c8": {
            "renaming": {
                "FUN_080004c8": "calculate_double_from_float_parts_080004c8",
                "param_1": "float_part1",
                "param_2": "float_part2",
                "param_3": "float_part3",
                "param_4": "float_part4",
                "uVar1": "lower_bits_result",
                "lVar2": "multiply_result",
                "uVar3": "upper_bits_result",
                "uVar4": "exponent1",
                "uVar6": "shifted_mantissa1",
                "uVar7": "shifted_mantissa2",
                "uVar8": "mantissa1",
                "bVar9": "is_zero",
                "bVar10": "is_negative",
                "bVar11": "has_overflow",
                "uVar12": "combined_float_parts",
                "unaff_r5": "exponent2"
            },
            "code": "\nulonglong calculate_double_from_float_parts_080004c8(undefined4 float_part1,uint float_part2,uint float_part3,uint float_part4)\n\n{\n  ulonglong lower_bits_result;\n  longlong multiply_result;\n  uint upper_bits_result;\n  uint exponent1;\n  int iVar5;\n  uint shifted_mantissa1;\n  uint exponent2;\n  uint shifted_mantissa2;\n  uint mantissa1;\n  bool is_zero;\n  bool is_negative;\n  bool has_overflow;\n  ulonglong combined_float_parts;\n  \n  combined_float_parts = CONCAT44(float_part2,float_part1);\n  shifted_mantissa2 = 0x7ff;\n  exponent1 = float_part2 >> 0x14 & 0x7ff;\n  is_zero = exponent1 == 0;\n  if (!is_zero) {\n    exponent2 = float_part4 >> 0x14 & 0x7ff;\n    is_zero = exponent2 == 0;\n  }\n  if (!is_zero) {\n    is_zero = exponent1 == 0x7ff;\n  }\n  if (!is_zero) {\n    is_zero = exponent2 == 0x7ff;\n  }\n  if (is_zero) {\n    combined_float_parts = binary_to_float_080006a4();\n  }\n  upper_bits_result = (uint)(combined_float_parts >> 0x20);\n  iVar5 = exponent1 + exponent2;\n  exponent1 = upper_bits_result ^ float_part4;\n  upper_bits_result = upper_bits_result & ~(shifted_mantissa2 << 0x15);\n  float_part4 = float_part4 & ~(shifted_mantissa2 << 0x15);\n  is_zero = ((uint)combined_float_parts | upper_bits_result << 0xc) == 0;\n  if (!is_zero) {\n    is_zero = (float_part3 | float_part4 << 0xc) == 0;\n  }\n  upper_bits_result = upper_bits_result | 0x100000;\n  float_part4 = float_part4 | 0x100000;\n  if (is_zero) {\n    float_part3 = (uint)combined_float_parts | float_part3;\n    float_part4 = (exponent1 & 0x80000000 | upper_bits_result) ^ float_part4;\n    exponent1 = shifted_mantissa2 >> 1;\n    has_overflow = SBORROW4(iVar5,exponent1);\n    shifted_mantissa1 = iVar5 - exponent1;\n    is_zero = shifted_mantissa1 == 0;\n    upper_bits_result = shifted_mantissa1;\n    if (!is_zero && (int)exponent1 <= iVar5) {\n      has_overflow = SBORROW4(shifted_mantissa2,shifted_mantissa1);\n      upper_bits_result = shifted_mantissa2 - shifted_mantissa1;\n      is_zero = shifted_mantissa2 == shifted_mantissa1;\n    }\n    if (!is_zero && (int)upper_bits_result < 0 == has_overflow) {\n      float_part4 = float_part4 | shifted_mantissa1 * 0x100000;\n    }\n    if (!is_zero && (int)upper_bits_result < 0 == has_overflow) {\n      return CONCAT44(float_part4,float_part3);\n    }\n    float_part4 = float_part4 | 0x100000;\n    shifted_mantissa2 = 0;\n    has_overflow = SBORROW4(shifted_mantissa1,1);\n    shifted_mantissa1 = shifted_mantissa1 - 1;\n    is_zero = shifted_mantissa1 == 0;\n    exponent1 = shifted_mantissa1;\n  }\n  else {\n    lower_bits_result = (combined_float_parts & 0xffffffff) * (ulonglong)float_part3;\n    combined_float_parts = (combined_float_parts & 0xffffffff) * (ulonglong)float_part4 +\n             (ulonglong)upper_bits_result * (ulonglong)float_part3 + (lower_bits_result >> 0x20);\n    mantissa1 = (uint)combined_float_parts;\n    multiply_result = (ulonglong)upper_bits_result * (ulonglong)float_part4 + (combined_float_parts >> 0x20);\n    shifted_mantissa2 = (uint)multiply_result;\n    upper_bits_result = (uint)((ulonglong)multiply_result >> 0x20);\n    if ((int)lower_bits_result != 0) {\n      mantissa1 = mantissa1 | 1;\n    }\n    shifted_mantissa1 = (iVar5 + -0x3ff) - (uint)(upper_bits_result < 0x200);\n    if (upper_bits_result < 0x200) {\n      is_zero = (mantissa1 & 0x80000000) != 0;\n      mantissa1 = mantissa1 << 1;\n      multiply_result = CONCAT44(upper_bits_result * 2 + (uint)(CARRY4(shifted_mantissa2,shifted_mantissa2) || CARRY4(shifted_mantissa2 * 2,(uint)is_zero)),\n                       shifted_mantissa2 * 2 + (uint)is_zero);\n    }\n    float_part4 = exponent1 & 0x80000000 | (int)((ulonglong)multiply_result >> 0x20) << 0xb | (uint)multiply_result >> 0x15;\n    float_part3 = (uint)multiply_result << 0xb | mantissa1 >> 0x15;\n    shifted_mantissa2 = mantissa1 * 0x800;\n    is_negative = 0xfc < shifted_mantissa1;\n    has_overflow = SBORROW4(shifted_mantissa1,0xfd);\n    upper_bits_result = shifted_mantissa1 - 0xfd;\n    is_zero = upper_bits_result == 0;\n    exponent1 = upper_bits_result;\n    if (is_negative && !is_zero) {\n      is_negative = 0x6ff < upper_bits_result;\n      has_overflow = SBORROW4(upper_bits_result,0x700);\n      exponent1 = shifted_mantissa1 - 0x7fd;\n      is_zero = upper_bits_result == 0x700;\n    }\n    if (!is_negative || is_zero) {\n      is_zero = 0x7fffffff < shifted_mantissa2;\n      if (shifted_mantissa2 == 0x80000000) {\n        is_zero = (mantissa1 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(float_part4 + shifted_mantissa1 * 0x100000 + (uint)CARRY4(float_part3,(uint)is_zero),float_part3 + is_zero\n                     );\n    }\n  }\n  if (!is_zero && (int)exponent1 < 0 == has_overflow) {\n    return (ulonglong)(float_part4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  is_negative = SCARRY4(shifted_mantissa1,0x36);\n  is_zero = (int)(shifted_mantissa1 + 0x36) < 0;\n  has_overflow = shifted_mantissa1 == 0xffffffca;\n  if (has_overflow || is_zero != is_negative) {\n    float_part3 = 0;\n  }\n  if (has_overflow || is_zero != is_negative) {\n    float_part4 = float_part4 & 0x80000000;\n  }\n  if (has_overflow || is_zero != is_negative) {\n    return CONCAT44(float_part4,float_part3);\n  }\n  exponent1 = -shifted_mantissa1;\n  upper_bits_result = exponent1 - 0x20;\n  if (0x1f < (int)exponent1) {\n    shifted_mantissa1 = float_part3 >> (upper_bits_result & 0xff) | float_part4 << (0x20 - upper_bits_result & 0xff);\n    exponent1 = (float_part4 >> (upper_bits_result & 0xff) & ~((float_part4 & 0x80000000) >> (upper_bits_result & 0xff))) -\n            ((int)shifted_mantissa1 >> 0x1f);\n    if ((shifted_mantissa2 | float_part3 << (0x20 - upper_bits_result & 0xff) | shifted_mantissa1 << 1) == 0) {\n      exponent1 = exponent1 & ~(shifted_mantissa1 >> 0x1f);\n    }\n    return CONCAT44(float_part4,exponent1) & 0x80000000ffffffff;\n  }\n  iVar5 = exponent1 - 0x14;\n  if (iVar5 == 0 || iVar5 < 0 != SCARRY4(upper_bits_result,0xc)) {\n    mantissa1 = float_part3 << (shifted_mantissa1 + 0x20 & 0xff);\n    upper_bits_result = float_part3 >> (exponent1 & 0xff) | float_part4 << (shifted_mantissa1 + 0x20 & 0xff);\n    shifted_mantissa1 = upper_bits_result + -((int)mantissa1 >> 0x1f);\n    if ((shifted_mantissa2 | mantissa1 << 1) == 0) {\n      shifted_mantissa1 = shifted_mantissa1 & ~(mantissa1 >> 0x1f);\n    }\n    return CONCAT44((float_part4 & 0x80000000) +\n                    ((float_part4 & 0x7fffffff) >> (exponent1 & 0xff)) +\n                    (uint)CARRY4(upper_bits_result,-((int)mantissa1 >> 0x1f)),shifted_mantissa1);\n  }\n  exponent1 = 0xc - iVar5;\n  shifted_mantissa1 = float_part3 << (exponent1 & 0xff);\n  exponent1 = float_part3 >> (0x20 - exponent1 & 0xff) | float_part4 << (exponent1 & 0xff);\n  upper_bits_result = exponent1 + -((int)shifted_mantissa1 >> 0x1f);\n  if ((shifted_mantissa2 | shifted_mantissa1 << 1) == 0) {\n    upper_bits_result = upper_bits_result & ~(shifted_mantissa1 >> 0x1f);\n  }\n  return CONCAT44((float_part4 & 0x80000000) + (uint)CARRY4(exponent1,-((int)shifted_mantissa1 >> 0x1f)),upper_bits_result);\n}\n\n",
            "called": [
                "FUN_080006a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004c8",
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "_dtoa_r",
                "frexp",
                "mpu6050_calc_pitch",
                "_svfprintf_r",
                "atan"
            ],
            "imported": false,
            "current_name": "calculate_double_from_float_parts_080004c8"
        },
        "FUN_08000a9c": {
            "renaming": {
                "FUN_08000a9c": "floating_point_conversion_08000a9c",
                "param_1": "input_bits",
                "param_2": "input_exponent",
                "param_3": "input_sign",
                "param_4": "output_bits",
                "iVar1": "output_sign",
                "uVar2": "input_bits_copy",
                "uVar3": "input_exponent_copy",
                "uVar4": "bits",
                "uVar5": "shift",
                "uVar6": "diff",
                "iVar7": "bits_shifted",
                "bVar8": "condition"
            },
            "code": "\nuint floating_point_conversion_08000a9c(uint input_bits,uint input_exponent,undefined4 input_sign,uint output_bits)\n\n{\n  int output_sign;\n  uint input_bits_copy;\n  uint input_exponent_copy;\n  uint bits;\n  uint shift;\n  uint diff;\n  int bits_shifted;\n  bool condition;\n  \n  input_bits_copy = input_bits ^ 0x80000000;\n  bits = input_bits << 1;\n  condition = bits == 0;\n  if (!condition) {\n    output_bits = input_exponent << 1;\n    condition = output_bits == 0;\n  }\n  if (!condition) {\n    condition = bits == output_bits;\n  }\n  bits_shifted = (int)bits >> 0x18;\n  if (!condition) {\n    condition = bits_shifted == -1;\n  }\n  if (!condition) {\n    condition = (int)output_bits >> 0x18 == -1;\n  }\n  if (condition) {\n    output_sign = (int)(input_exponent << 1) >> 0x18;\n    if (bits_shifted == -1 || output_sign == -1) {\n      bits = input_exponent;\n      if (bits_shifted == -1) {\n        bits = input_bits_copy;\n      }\n      if (bits_shifted != -1 || output_sign != -1) {\n        input_exponent = bits;\n      }\n      condition = (bits & 0x7fffff) == 0;\n      if (condition) {\n        condition = (input_exponent & 0x7fffff) == 0;\n      }\n      if (condition) {\n        condition = bits == input_exponent;\n      }\n      if (!condition) {\n        bits = bits | 0x400000;\n      }\n      return bits;\n    }\n    if (((input_bits ^ input_exponent) & 0x7fffffff) != 0) {\n      if (bits == 0) {\n        input_bits_copy = input_exponent;\n      }\n      return input_bits_copy;\n    }\n    if (input_bits_copy != input_exponent) {\n      return 0;\n    }\n    if ((bits & 0xff000000) == 0) {\n      input_bits = input_bits << 1;\n      if ((input_bits_copy & 0x80000000) != 0) {\n        input_bits = input_bits | 0x80000000;\n      }\n      return input_bits;\n    }\n    if (bits < 0xfe000000) {\n      return input_bits_copy + 0x800000;\n    }\n    input_bits_copy = input_bits_copy & 0x80000000;\nLAB_08000bde:\n    return input_bits_copy | 0x7f800000;\n  }\n  bits = bits >> 0x18;\n  output_bits = output_bits >> 0x18;\n  diff = output_bits - bits;\n  condition = diff != 0;\n  shift = bits;\n  if (condition && bits <= output_bits) {\n    shift = bits + diff;\n  }\n  if (condition && bits <= output_bits) {\n    input_exponent = input_exponent ^ input_bits_copy;\n  }\n  if (condition && bits <= output_bits) {\n    input_bits_copy = input_bits_copy ^ input_exponent;\n  }\n  if (condition && bits <= output_bits) {\n    input_exponent = input_exponent ^ input_bits_copy;\n  }\n  if (output_bits < bits) {\n    diff = -diff;\n  }\n  if (0x19 < diff) {\n    return input_bits_copy;\n  }\n  bits = input_bits_copy & 0xffffff | 0x800000;\n  if ((input_bits_copy & 0x80000000) != 0) {\n    bits = -bits;\n  }\n  input_exponent_copy = input_exponent & 0xffffff | 0x800000;\n  if ((input_exponent & 0x80000000) != 0) {\n    input_exponent_copy = -input_exponent_copy;\n  }\n  if (shift == diff) {\n    input_exponent_copy = input_exponent_copy ^ 0x800000;\n    if (shift == 0) {\n      bits = bits ^ 0x800000;\n      shift = 1;\n    }\n    else {\n      diff = diff - 1;\n    }\n  }\n  bits = bits + ((int)input_exponent_copy >> (diff & 0xff));\n  input_exponent_copy = input_exponent_copy << (0x20 - diff & 0xff);\n  input_bits_copy = bits & 0x80000000;\n  if ((int)bits < 0) {\n    condition = input_exponent_copy != 0;\n    input_exponent_copy = -input_exponent_copy;\n    bits = -bits - (uint)condition;\n  }\n  if (bits < 0x800000) {\n    diff = input_exponent_copy & 0x80000000;\n    input_exponent_copy = input_exponent_copy << 1;\n    bits = bits * 2 + (uint)(diff != 0);\n    diff = shift - 2;\n    if ((bits & 0x800000) == 0) {\n      bits_shifted = count_leading_zeroes(bits);\n      shift = bits_shifted - 8;\n      bits = bits << (shift & 0xff);\n      if ((int)diff < (int)shift) {\n        bits = bits >> (-(diff - shift) & 0xff);\n      }\n      else {\n        bits = bits + (diff - shift) * 0x800000;\n      }\n      return bits | input_bits_copy;\n    }\n  }\n  else {\n    diff = shift - 1;\n    if (0xffffff < bits) {\n      diff = bits & 1;\n      bits = bits >> 1;\n      input_exponent_copy = (uint)(diff != 0) << 0x1f | input_exponent_copy >> 1;\n      diff = shift;\n      if (0xfd < shift) goto LAB_08000bde;\n    }\n  }\n  bits = bits + diff * 0x800000 + (uint)(0x7fffffff < input_exponent_copy);\n  if (input_exponent_copy == 0x80000000) {\n    bits = bits & 0xfffffffe;\n  }\n  return bits | input_bits_copy;\n}\n\n",
            "called": [
                "__addsf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a9c",
            "calling": [],
            "imported": false,
            "current_name": "floating_point_conversion_08000a9c"
        },
        "FUN_08008ad4": {
            "renaming": {
                "FUN_08008ad4": "get_locale_info_08008ad4",
                "puVar1": "locale_info_ptr"
            },
            "code": "\nundefined * get_locale_info_08008ad4(void)\n\n{\n  undefined *locale_info_ptr;\n  \n  locale_info_ptr = *(undefined **)(*(int *)PTR__impure_ptr_08008ae8 + 0x34);\n  if (*(undefined **)(*(int *)PTR__impure_ptr_08008ae8 + 0x34) == (undefined *)0x0) {\n    locale_info_ptr = PTR___global_locale_08008aec;\n  }\n  return locale_info_ptr + 0xf0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ad4",
            "calling": [
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "get_locale_info_08008ad4"
        },
        "FUN_08005674": {
            "renaming": {
                "FUN_08005674": "infinite_loop_08005674"
            },
            "code": "\nvoid infinite_loop_08005674(char *file,int line)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005674",
            "calling": [
                "MX_I2C1_Init",
                "MX_TIM1_Init",
                "MX_USART1_UART_Init",
                "MX_TIM2_Init",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "infinite_loop_08005674"
        },
        "FUN_08003c4a": {
            "renaming": {
                "FUN_08003c4a": "FUNC_08003c4a"
            },
            "code": "\nvoid FUNC_08003c4a(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003c4a",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "FUNC_08003c4a"
        },
        "FUN_08004104": {
            "renaming": {
                "FUN_08004104": "configure_ti_mx_input_capture_08004104",
                "TIMx": "timer",
                "TIM_ICPolarity": "polarity",
                "TIM_ICFilter": "filter",
                "tmpccer": "ccer_temp",
                "tmpccmr1": "ccmr1_temp"
            },
            "code": "\nvoid configure_TIMx_input_capture_08004104(TIM_TypeDef *timer,uint32_t polarity,uint32_t filter)\n\n{\n  uint32_t ccer_temp;\n  uint32_t ccmr1_temp;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  timer->CCMR1 = filter << 0xc | timer->CCMR1 & 0xffff0fff;\n  timer->CCER = polarity << 4 | timer->CCER & 0xffffff5f;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004104",
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "imported": false,
            "current_name": "configure_ti_mx_input_capture_08004104"
        },
        "FUN_08000ff4": {
            "renaming": {
                "FUN_08000ff4": "is_string_terminated_08000ff4",
                "in_CY": "last_character",
                "__aeabi_cfcmpeq": "compare_floats"
            },
            "code": "\nbool is_string_terminated_08000ff4(void)\n\n{\n  char last_character;\n  \n  compare_floats();\n  return last_character == '\\0';\n}\n\n",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000ff4",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "imported": false,
            "current_name": "is_string_terminated_08000ff4"
        },
        "FUN_08005d0c": {
            "renaming": {
                "FUN_08005d0c": "calculate_square_root_08005d0c",
                "__x": "input_number",
                "in_d0": "result"
            },
            "code": "\ndouble calculate_square_root_08005d0c(double input_number)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d0c",
            "calling": [
                "__ieee754_atan2",
                "atan"
            ],
            "imported": false,
            "current_name": "calculate_square_root_08005d0c"
        },
        "FUN_08005e40": {
            "renaming": {
                "FUN_08005e40": "count_leading_zero_bits_08005e40",
                "__s": "string",
                "iVar1": "offset",
                "puVar2": "word_ptr",
                "uVar4": "word",
                "count_leading_zeroes": "count_leading_zero_bits"
            },
            "code": "\nsize_t count_leading_zero_bits_08005e40(char *string)\n\n{\n  int offset;\n  uint *word_ptr;\n  int iVar3;\n  uint word;\n  \n  word_ptr = (uint *)((uint)string & 0xfffffffc);\n  offset = -((uint)string & 3);\n  word = *word_ptr;\n  if (((uint)string & 3) != 0) {\n    word = word | 0xffffffffU >> ((offset + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    word_ptr = word_ptr + 1;\n    word = word + 0xfefefeff & ~word & 0x80808080;\n    if (word != 0) break;\n    word = *word_ptr;\n    offset = offset + 4;\n  }\n  iVar3 = count_leading_zero_bits_08005e40(word & -word);\n  return offset + (0x1fU - iVar3 >> 3);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e40",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "count_leading_zero_bits_08005e40"
        },
        "FUN_08005d20": {
            "renaming": {
                "FUN_08005d20": "execute_preinit_and_dtor_functions_08005d20",
                "param_1": "pkey_context",
                "puVar1": "dtor_array_entry",
                "iVar2": "loop_counter",
                "ppcVar3": "function_pointer_array",
                "iVar4": "array_size",
                "_init": "initialize_library"
            },
            "code": "\nvoid execute_preinit_and_dtor_functions_08005d20(EVP_PKEY_CTX *pkey_context)\n\n{\n  undefined *dtor_array_entry;\n  int loop_counter;\n  code **function_pointer_array;\n  int array_size;\n  \n  array_size = (int)PTR___preinit_array_end_08005d58 - (int)PTR___preinit_array_end_08005d5c >> 2;\n  if (array_size != 0) {\n    loop_counter = 0;\n    function_pointer_array = (code **)PTR___preinit_array_end_08005d5c;\n    do {\n      loop_counter = loop_counter + 1;\n      pkey_context = (EVP_PKEY_CTX *)(**function_pointer_array)();\n      function_pointer_array = function_pointer_array + 1;\n    } while (array_size != loop_counter);\n  }\n  function_pointer_array = (code **)PTR___preinit_array_end_08005d64;\n  dtor_array_entry = PTR___do_global_dtors_aux_fini_array_entry_08005d60;\n  initialize_library(pkey_context);\n  array_size = (int)dtor_array_entry - (int)function_pointer_array >> 2;\n  if (array_size != 0) {\n    loop_counter = 0;\n    do {\n      loop_counter = loop_counter + 1;\n      (**function_pointer_array)();\n      function_pointer_array = function_pointer_array + 1;\n    } while (array_size != loop_counter);\n  }\n  return;\n}\n\n",
            "called": [
                "register_fini",
                "_init",
                "frame_dummy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d20",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "execute_preinit_and_dtor_functions_08005d20"
        },
        "FUN_08001a80": {
            "renaming": {
                "FUN_08001a80": "set_gpio_pin_state_08001a80",
                "GPIOx": "GPIO_port",
                "GPIO_Pin": "GPIO_pin_number",
                "PinState": "desired_pin_state",
                "BSRR": "set_reset_register"
            },
            "code": "\nvoid set_GPIO_PinState_08001a80(GPIO_TypeDef *GPIO_port,uint16_t GPIO_pin_number,GPIO_pin_numberState desired_pin_state)\n\n{\n  if (desired_pin_state == GPIO_PIN_RESET) {\n    GPIO_port->set_reset_register = (uint)GPIO_pin_number << 0x10;\n  }\n  else {\n    GPIO_port->set_reset_register = (uint)GPIO_pin_number;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001a80",
            "calling": [
                "MX_GPIO_Init",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_08001a80"
        },
        "FUN_080090a8": {
            "renaming": {
                "FUN_080090a8": "acquire_recursive_lock_for_malloc_080090a8"
            },
            "code": "\nvoid acquire_recursive_lock_for_malloc_080090a8(void)\n\n{\n  __retarget_lock_acquire_recursive(PTR___lock___malloc_recursive_mutex_080090b0);\n  return;\n}\n\n",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090a8",
            "calling": [
                "_malloc_trim_r",
                "_malloc_r",
                "_free_r",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_for_malloc_080090a8"
        },
        "FUN_08004e74": {
            "renaming": {
                "FUN_08004e74": "afl_call_or_return_zero_08004e74",
                "uVar1": "result"
            },
            "code": "\nint afl_call_or_return_zero_08004e74(int ticks)\n\n{\n  uint32_t result;\n  \n  if (*(int *)PTR_noHyperCall_08004ea0 == 0) {\n    result = aflCall(1,ticks,0);\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e74",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "afl_call_or_return_zero_08004e74"
        },
        "FUN_0800910c": {
            "renaming": {
                "FUN_0800910c": "copy_value_to_pointer_0800910c",
                "param_1": "source_pointer",
                "param_2": "destination_pointer",
                "iVar1": "data_pointer"
            },
            "code": "\nvoid copy_value_to_pointer_0800910c(int source_pointer,undefined4 *destination_pointer)\n\n{\n  int data_pointer;\n  \n  if (destination_pointer != (undefined4 *)0x0) {\n    data_pointer = *(int *)(source_pointer + 0x4c);\n    *destination_pointer = *(undefined4 *)(data_pointer + destination_pointer[1] * 4);\n    *(undefined4 **)(data_pointer + destination_pointer[1] * 4) = destination_pointer;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800910c",
            "calling": [
                "_dtoa_r"
            ],
            "imported": false,
            "current_name": "copy_value_to_pointer_0800910c"
        },
        "FUN_080052a0": {
            "renaming": {
                "FUN_080052a0": "initialize_clock_080052a0",
                "RCC_ClkInitStruct": "clock_init_struct",
                "RCC_OscInitStruct": "osc_init_struct",
                "HVar1": "status",
                "uVar2": "hclk_freq",
                "_Error_Handler": "error_handler",
                "HAL_RCC_OscConfig": "configure_oscillator",
                "HAL_RCC_ClockConfig": "configure_clock",
                "HAL_RCC_GetHCLKFreq": "get_hclk_freq",
                "HAL_SYSTICK_Config": "configure_systick",
                "HAL_SYSTICK_CLKSourceConfig": "configure_systick_clk_source",
                "HAL_NVIC_SetPriority": "set_nvic_priority",
                "SysTick_IRQn": "systick_irqn"
            },
            "code": "\nvoid initialize_clock_080052a0(void)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t hclk_freq;\n  RCC_ClkInitTypeDef clock_init_struct;\n  RCC_OscInitTypeDef osc_init_struct;\n  \n  osc_init_struct.OscillatorType = 1;\n  osc_init_struct.HSEState = 0x10000;\n  osc_init_struct.HSEPredivValue = 0;\n  osc_init_struct.HSIState = 1;\n  osc_init_struct.PLL.PLLState = 2;\n  osc_init_struct.PLL.PLLSource = 0x10000;\n  osc_init_struct.PLL.PLLMUL = 0x1c0000;\n  status = configure_oscillator(&osc_init_struct);\n  if (status != HAL_OK) {\n    error_handler(PTR_s____src_main_c_08005340,0x151);\n  }\n  clock_init_struct.ClockType = 0xf;\n  clock_init_struct.SYSCLKSource = 2;\n  clock_init_struct.AHBCLKDivider = 0x80;\n  clock_init_struct.APB1CLKDivider = 0;\n  clock_init_struct.APB2CLKDivider = 0;\n  status = configure_clock(&clock_init_struct,2);\n  if (status != HAL_OK) {\n    error_handler(PTR_s____src_main_c_08005340,0x15e);\n  }\n  hclk_freq = get_hclk_freq();\n  configure_systick((uint)((ulonglong)DAT_08005344 * (ulonglong)hclk_freq >> 0x26));\n  configure_systick_clk_source(4);\n  set_nvic_priority(systick_irqn,0,0);\n  return;\n}\n\n",
            "called": [
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_SYSTICK_Config",
                "_Error_Handler",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052a0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_clock_080052a0"
        },
        "FUN_08009120": {
            "renaming": {
                "FUN_08009120": "calculate_polynomial_08009120",
                "param_1": "size_of_allocation",
                "param_2": "polynomial_coefficients",
                "param_3": "base",
                "param_4": "carry",
                "puVar1": "result",
                "uVar2": "temp_result",
                "iVar3": "num_coefficients",
                "puVar4": "coefficients_ptr",
                "iVar5": "i"
            },
            "code": "\nundefined4 * calculate_polynomial_08009120(int size_of_allocation,undefined4 *polynomial_coefficients,int base,uint carry)\n\n{\n  undefined4 *result;\n  uint temp_result;\n  int num_coefficients;\n  uint *coefficients_ptr;\n  int i;\n  \n  i = 0;\n  num_coefficients = polynomial_coefficients[4];\n  coefficients_ptr = polynomial_coefficients + 5;\n  do {\n    i = i + 1;\n    carry = base * (*coefficients_ptr & 0xffff) + carry;\n    temp_result = base * (*coefficients_ptr >> 0x10) + (carry >> 0x10);\n    *coefficients_ptr = (carry & 0xffff) + temp_result * 0x10000;\n    carry = temp_result >> 0x10;\n    coefficients_ptr = coefficients_ptr + 1;\n  } while (i < num_coefficients);\n  result = polynomial_coefficients;\n  if (carry != 0) {\n    if ((int)polynomial_coefficients[2] <= num_coefficients) {\n      result = (undefined4 *)_Balloc(size_of_allocation,polynomial_coefficients[1] + 1);\n      memcpy(result + 3,polynomial_coefficients + 3,(polynomial_coefficients[4] + 2) * 4);\n      i = *(int *)(size_of_allocation + 0x4c);\n      *polynomial_coefficients = *(undefined4 *)(i + polynomial_coefficients[1] * 4);\n      *(undefined4 **)(i + polynomial_coefficients[1] * 4) = polynomial_coefficients;\n    }\n    result[num_coefficients + 5] = carry;\n    result[4] = num_coefficients + 1;\n  }\n  return result;\n}\n\n",
            "called": [
                "_Balloc",
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009120",
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "imported": false,
            "current_name": "calculate_polynomial_08009120"
        },
        "FUN_08000f58": {
            "renaming": {
                "FUN_08000f58": "calculate_param1_xor_param2_08000f58",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "is_param1_xor_param2_negative",
                "uVar2": "input1_times_2",
                "uVar3": "input2_times_2",
                "uVar4": "input1_times_2_or_input2_and_0x7fffffff",
                "bVar5": "is_input1_times_2_or_input2_and_0x7fffffff_zero"
            },
            "code": "\nuint calculate_param1_xor_param2_08000f58(uint input1,uint input2)\n\n{\n  bool is_param1_xor_param2_negative;\n  uint input1_times_2;\n  uint input2_times_2;\n  uint input1_times_2_or_input2_and_0x7fffffff;\n  bool is_input1_times_2_or_input2_and_0x7fffffff_zero;\n  \n  input1_times_2 = input1 * 2;\n  input2_times_2 = input2 * 2;\n  if (((int)input1_times_2 >> 0x18 == -1 || (int)input2_times_2 >> 0x18 == -1) &&\n     ((((int)input1_times_2 >> 0x18 == -1 && ((input1 & 0x7fffff) != 0)) ||\n      (((int)input2_times_2 >> 0x18 == -1 && ((input2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  input1_times_2_or_input2_and_0x7fffffff = input1_times_2 | input2 & 0x7fffffff;\n  is_input1_times_2_or_input2_and_0x7fffffff_zero = input1_times_2_or_input2_and_0x7fffffff == 0;\n  if (!is_input1_times_2_or_input2_and_0x7fffffff_zero) {\n    input1_times_2_or_input2_and_0x7fffffff = input1 ^ input2;\n    is_input1_times_2_or_input2_and_0x7fffffff_zero = input1_times_2_or_input2_and_0x7fffffff == 0;\n  }\n  is_param1_xor_param2_negative = -1 < (int)input1_times_2_or_input2_and_0x7fffffff;\n  if (is_param1_xor_param2_negative) {\n    input1 = input1_times_2 + input2 * -2;\n    is_input1_times_2_or_input2_and_0x7fffffff_zero = input1 == 0;\n  }\n  if ((is_param1_xor_param2_negative && input2_times_2 <= input1_times_2) && !is_input1_times_2_or_input2_and_0x7fffffff_zero) {\n    input1 = (int)input2 >> 0x1f;\n  }\n  if (!is_param1_xor_param2_negative || input2_times_2 > input1_times_2) {\n    input1 = ~((int)input2 >> 0x1f);\n  }\n  if (!is_input1_times_2_or_input2_and_0x7fffffff_zero) {\n    input1 = input1 | 1;\n  }\n  return input1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f58",
            "calling": [],
            "imported": false,
            "current_name": "calculate_param1_xor_param2_08000f58"
        },
        "FUN_08001084": {
            "renaming": {
                "FUN_08001084": "copy_memory_08001084",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "dest_ptr",
                "puVar2": "dest_aligned_ptr",
                "puVar3": "dest_aligned_ptr",
                "puVar4": "dest_unaligned_ptr",
                "puVar5": "src_aligned_ptr",
                "puVar6": "src_unaligned_ptr",
                "uVar7": "remaining_size",
                "uVar8": "unaligned_bytes",
                "bVar9": "loop_condition"
            },
            "code": "\nvoid * copy_memory_08001084(void *destination,void *source,size_t size)\n\n{\n  undefined *dest_ptr;\n  undefined4 *dest_aligned_ptr;\n  undefined4 *dest_aligned_ptr;\n  undefined *dest_unaligned_ptr;\n  undefined4 *src_aligned_ptr;\n  undefined *src_unaligned_ptr;\n  uint remaining_size;\n  uint unaligned_bytes;\n  bool loop_condition;\n  \n  dest_aligned_ptr = (undefined4 *)destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (size < 8) {\n      unaligned_bytes = size - 4;\n      dest_ptr = (undefined *)destination;\n      if (3 < size) {\n        do {\n          src_unaligned_ptr = (undefined *)source;\n          dest_unaligned_ptr = dest_ptr;\n          loop_condition = unaligned_bytes != 0;\n          unaligned_bytes = unaligned_bytes - 1;\n          *dest_unaligned_ptr = *src_unaligned_ptr;\n          dest_ptr = dest_unaligned_ptr + 1;\n          source = src_unaligned_ptr + 1;\n        } while (loop_condition);\n        dest_unaligned_ptr[1] = src_unaligned_ptr[1];\n        dest_unaligned_ptr[2] = src_unaligned_ptr[2];\n        dest_unaligned_ptr[3] = src_unaligned_ptr[3];\n        return destination;\n      }\n      goto LAB_08001108;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      unaligned_bytes = 4 - ((uint)destination & 3);\n      size = size - unaligned_bytes;\n      dest_aligned_ptr = (undefined4 *)destination;\n      src_aligned_ptr = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n      if (((uint)destination & 1) != 0) {\n        src_aligned_ptr = (undefined4 *)((int)source + 1);\n        dest_aligned_ptr = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *source;\n      }\n      dest_aligned_ptr = dest_aligned_ptr;\n      source = src_aligned_ptr;\n      if ((unaligned_bytes & 2) != 0) {\n        source = (void *)((int)src_aligned_ptr + 2);\n        dest_aligned_ptr = (undefined4 *)((int)dest_aligned_ptr + 2);\n        *(undefined2 *)dest_aligned_ptr = *(undefined2 *)src_aligned_ptr;\n      }\n    }\n  }\n  while (0x3f < size) {\n                    /* WARNING: Load size is inaccurate */\n    *dest_aligned_ptr = *source;\n    dest_aligned_ptr[1] = *(undefined4 *)((int)source + 4);\n    dest_aligned_ptr[2] = *(undefined4 *)((int)source + 8);\n    dest_aligned_ptr[3] = *(undefined4 *)((int)source + 0xc);\n    dest_aligned_ptr[4] = *(undefined4 *)((int)source + 0x10);\n    dest_aligned_ptr[5] = *(undefined4 *)((int)source + 0x14);\n    dest_aligned_ptr[6] = *(undefined4 *)((int)source + 0x18);\n    dest_aligned_ptr[7] = *(undefined4 *)((int)source + 0x1c);\n    dest_aligned_ptr[8] = *(undefined4 *)((int)source + 0x20);\n    dest_aligned_ptr[9] = *(undefined4 *)((int)source + 0x24);\n    dest_aligned_ptr[10] = *(undefined4 *)((int)source + 0x28);\n    dest_aligned_ptr[0xb] = *(undefined4 *)((int)source + 0x2c);\n    dest_aligned_ptr[0xc] = *(undefined4 *)((int)source + 0x30);\n    dest_aligned_ptr[0xd] = *(undefined4 *)((int)source + 0x34);\n    dest_aligned_ptr[0xe] = *(undefined4 *)((int)source + 0x38);\n    dest_aligned_ptr[0xf] = *(undefined4 *)((int)source + 0x3c);\n    dest_aligned_ptr = dest_aligned_ptr + 0x10;\n    source = (undefined4 *)((int)source + 0x40);\n    size = size - 0x40;\n  }\n  remaining_size = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      *dest_aligned_ptr = *source;\n      dest_aligned_ptr[1] = *(undefined4 *)((int)source + 4);\n      dest_aligned_ptr[2] = *(undefined4 *)((int)source + 8);\n      dest_aligned_ptr[3] = *(undefined4 *)((int)source + 0xc);\n      dest_aligned_ptr = dest_aligned_ptr + 4;\n      source = (void *)((int)source + 0x10);\n      loop_condition = 0xf < remaining_size;\n      remaining_size = remaining_size - 0x10;\n    } while (loop_condition);\n  }\n  unaligned_bytes = remaining_size + 0xc;\n  src_aligned_ptr = dest_aligned_ptr;\n  dest_aligned_ptr = (undefined4 *)source;\n  if (0xfffffff3 < remaining_size) {\n    do {\n      source = dest_aligned_ptr + 1;\n      *src_aligned_ptr = *dest_aligned_ptr;\n      loop_condition = 3 < unaligned_bytes;\n      unaligned_bytes = unaligned_bytes - 4;\n      dest_aligned_ptr = src_aligned_ptr + 1;\n      src_aligned_ptr = src_aligned_ptr + 1;\n      dest_aligned_ptr = (undefined4 *)source;\n    } while (loop_condition);\n  }\nLAB_08001108:\n  if (unaligned_bytes + 4 != 0) {\n    dest_aligned_ptr = dest_aligned_ptr;\n    src_aligned_ptr = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n    if ((unaligned_bytes & 1) != 0) {\n      src_aligned_ptr = (undefined4 *)((int)source + 1);\n      dest_aligned_ptr = (undefined4 *)((int)dest_aligned_ptr + 1);\n      *(undefined *)dest_aligned_ptr = *source;\n    }\n    if ((unaligned_bytes + 4 & 2) != 0) {\n      *(undefined2 *)dest_aligned_ptr = *(undefined2 *)src_aligned_ptr;\n    }\n  }\n  return destination;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001084",
            "calling": [
                "_dtoa_r",
                "__multadd",
                "__ssprint_r"
            ],
            "imported": false,
            "current_name": "copy_memory_08001084"
        },
        "FUN_08005680": {
            "renaming": {
                "FUN_08005680": "initialize_gpio_pin_08005680",
                "htim": "timer_handler",
                "GPIO_InitStruct": "gpio_init_struct",
                "Instance": "instance",
                "Pin": "pin_number",
                "Mode": "pin_mode",
                "Speed": "pin_speed",
                "HAL_GPIO_Init": "initialize_GPIO"
            },
            "code": "\nvoid initialize_GPIO_pin_08005680(TIM_HandleTypeDef *timer_handler)\n\n{\n  GPIO_InitTypeDef gpio_init_struct;\n  \n  if (timer_handler->instance == DAT_080056b4) {\n    gpio_init_struct.pin_number = 0x900;\n    gpio_init_struct.pin_mode = 2;\n    gpio_init_struct.pin_speed = 2;\n    initialize_GPIO(DAT_080056b8,&gpio_init_struct);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005680",
            "calling": [
                "MX_TIM1_Init"
            ],
            "imported": false,
            "current_name": "initialize_gpio_pin_08005680"
        },
        "FUN_08003260": {
            "renaming": {
                "FUN_08003260": "configure_clocks_08003260",
                "RCC_ClkInitStruct": "clockInit",
                "FLatency": "flashLatency",
                "uVar1": "systemClockFreq",
                "uVar2": "currentTick",
                "HVar3": "status",
                "tickstart": "startTick"
            },
            "code": "\nHAL_StatusTypeDef configureClocks_08003260(RCC_ClkInitTypeDef *clockInit,uint32_t flashLatency)\n\n{\n  uint32_t systemClockFreq;\n  uint32_t currentTick;\n  HAL_StatusTypeDef status;\n  uint32_t startTick;\n  \n  if (((*DAT_08003430 & 7) < flashLatency) &&\n     (*DAT_08003430 = flashLatency | *DAT_08003430 & 0xfffffff8, flashLatency != (*DAT_08003430 & 7))) {\n    status = HAL_ERROR;\n  }\n  else {\n    if ((clockInit->ClockType & 2) != 0) {\n      DAT_08003434[1] = clockInit->AHBCLKDivider | DAT_08003434[1] & 0xffffff0f;\n    }\n    if ((clockInit->ClockType & 1) == 0) {\nLAB_08003394:\n      if ((flashLatency < (*DAT_08003430 & 7)) &&\n         (*DAT_08003430 = flashLatency | *DAT_08003430 & 0xfffffff8, flashLatency != (*DAT_08003430 & 7))) {\n        status = HAL_ERROR;\n      }\n      else {\n        if ((clockInit->ClockType & 4) != 0) {\n          DAT_08003434[1] = clockInit->APB1CLKDivider | DAT_08003434[1] & 0xfffff8ff;\n        }\n        if ((clockInit->ClockType & 8) != 0) {\n          DAT_08003434[1] = clockInit->APB2CLKDivider << 3 | DAT_08003434[1] & 0xffffc7ff;\n        }\n        systemClockFreq = HAL_RCC_GetSysClockFreq();\n        *(uint32_t *)PTR_SystemCoreClock_0800343c =\n             systemClockFreq >> PTR_AHBPrescTable_08003438[DAT_08003434[1] >> 4 & 0xf];\n        HAL_InitTick(0xf);\n        status = HAL_OK;\n      }\n    }\n    else {\n      if (clockInit->SYSCLKSource == 1) {\n        if ((*DAT_08003434 & 0x20000) == 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if ((clockInit->SYSCLKSource != 2) && ((*DAT_08003434 & 2) == 0)) {\n        return HAL_ERROR;\n      }\n      DAT_08003434[1] = clockInit->SYSCLKSource | DAT_08003434[1] & 0xfffffffc;\n      systemClockFreq = HAL_GetTick();\n      if (clockInit->SYSCLKSource == 1) {\n        do {\n          if ((DAT_08003434[1] & 0xc) == 4) goto LAB_08003394;\n          currentTick = HAL_GetTick();\n        } while (currentTick - systemClockFreq < 0x1389);\n        status = HAL_TIMEOUT;\n      }\n      else if (clockInit->SYSCLKSource == 2) {\n        do {\n          if ((DAT_08003434[1] & 0xc) == 8) goto LAB_08003394;\n          currentTick = HAL_GetTick();\n        } while (currentTick - systemClockFreq < 0x1389);\n        status = HAL_TIMEOUT;\n      }\n      else {\n        do {\n          if ((DAT_08003434[1] & 0xc) == 0) goto LAB_08003394;\n          currentTick = HAL_GetTick();\n        } while (currentTick - systemClockFreq < 0x1389);\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  return status;\n}\n\n",
            "called": [
                "HAL_InitTick",
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003260",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configure_clocks_08003260"
        },
        "FUN_08009244": {
            "renaming": {
                "FUN_08009244": "allocate_and_initialize_buffer_08009244",
                "param_1": "buffer_size",
                "param_2": "initial_value",
                "iVar1": "buffer_address"
            },
            "code": "\nvoid allocate_and_initialize_buffer_08009244(undefined4 buffer_size,undefined4 initial_value)\n\n{\n  int buffer_address;\n  \n  buffer_address = _Balloc(buffer_size,1);\n  *(undefined4 *)(buffer_address + 0x10) = 1;\n  *(undefined4 *)(buffer_address + 0x14) = initial_value;\n  return;\n}\n\n",
            "called": [
                "_Balloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009244",
            "calling": [
                "_dtoa_r"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_buffer_08009244"
        },
        "FUN_08003c5c": {
            "renaming": {
                "FUN_08003c5c": "FUNC_08003c5c"
            },
            "code": "\nvoid FUNC_08003c5c(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003c5c",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "FUNC_08003c5c"
        },
        "FUN_08004e6c": {
            "renaming": {
                "FUN_08004e6c": "software_interrupt_handler_08004e6c"
            },
            "code": "\nuint32_t software_interrupt_handler_08004e6c(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e6c",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "software_interrupt_handler_08004e6c"
        },
        "FUN_08001762": {
            "renaming": {
                "FUN_08001762": "configure_systick_08001762",
                "TicksNumb": "ticks_number",
                "uVar1": "config_result"
            },
            "code": "\nuint32_t configure_systick_08001762(uint32_t ticks_number)\n\n{\n  uint32_t config_result;\n  \n  config_result = SysTick_Config(ticks_number);\n  return config_result;\n}\n\n",
            "called": [
                "SysTick_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001762",
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configure_systick_08001762"
        },
        "FUN_080040a0": {
            "renaming": {
                "FUN_080040a0": "configure_ti_mx_ic_080040a0",
                "TIMx": "timer",
                "TIM_ICPolarity": "input_capture_polarity",
                "TIM_ICFilter": "input_capture_filter",
                "uVar1": "ccer_value",
                "tmpccer": "temp_ccer",
                "tmpccmr1": "temp_ccmr1"
            },
            "code": "\nvoid configure_TIMx_IC_080040a0(TIM_TypeDef *timer,uint32_t input_capture_polarity,uint32_t input_capture_filter)\n\n{\n  uint ccer_value;\n  uint32_t temp_ccer;\n  uint32_t temp_ccmr1;\n  \n  ccer_value = timer->CCER;\n  timer->CCER = timer->CCER & 0xfffffffe;\n  timer->CCMR1 = input_capture_filter << 4 | timer->CCMR1 & 0xffffff0f;\n  timer->CCER = input_capture_polarity | ccer_value & 0xfffffff5;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040a0",
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "imported": false,
            "current_name": "configure_ti_mx_ic_080040a0"
        },
        "FUN_08009a18": {
            "renaming": {
                "FUN_08009a18": "reverse_copy_memory_08009a18",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "puVar1": "dest_pointer",
                "puVar2": "src_pointer",
                "iVar3": "source_index",
                "pvVar4": "destination_pointer",
                "puVar5": "src_end_pointer",
                "iVar6": "next_source_index",
                "uVar7": "remaining_length",
                "iVar8": "next_dest_index",
                "uVar9": "remaining_length_2",
                "puVar10": "src_pointer_2"
            },
            "code": "\nvoid * reverse_copy_memory_08009a18(void *destination,void *source,size_t length)\n\n{\n  undefined4 *dest_pointer;\n  undefined *src_pointer;\n  int source_index;\n  void *destination_pointer;\n  undefined *src_end_pointer;\n  int next_source_index;\n  uint remaining_length;\n  int next_dest_index;\n  uint remaining_length_2;\n  undefined4 *src_pointer_2;\n  \n  if ((source < destination) && (src_pointer = (undefined *)((int)source + length), destination < src_pointer)) {\n    src_end_pointer = (undefined *)((int)destination + length);\n    if (length != 0) {\n      do {\n        src_pointer = src_pointer + -1;\n        src_end_pointer = src_end_pointer + -1;\n        *src_end_pointer = *src_pointer;\n      } while ((undefined *)source != src_pointer);\n    }\n  }\n  else {\n    remaining_length_2 = length;\n    destination_pointer = destination;\n    if (0xf < length) {\n      if ((((uint)destination | (uint)source) & 3) != 0) goto LAB_08009abc;\n      source_index = (int)source + 0x10;\n      next_dest_index = (int)destination + 0x10;\n      do {\n        next_source_index = source_index + 0x10;\n        *(undefined4 *)(next_dest_index + -0x10) = *(undefined4 *)(source_index + -0x10);\n        *(undefined4 *)(next_dest_index + -0xc) = *(undefined4 *)(source_index + -0xc);\n        *(undefined4 *)(next_dest_index + -8) = *(undefined4 *)(source_index + -8);\n        *(undefined4 *)(next_dest_index + -4) = *(undefined4 *)(source_index + -4);\n        source_index = next_source_index;\n        next_dest_index = next_dest_index + 0x10;\n      } while (next_source_index != (int)source + (length - 0x10 & 0xfffffff0) + 0x20);\n      remaining_length_2 = length & 0xf;\n      source_index = ((length - 0x10 >> 4) + 1) * 0x10;\n      source = (void *)((int)source + source_index);\n      destination_pointer = (void *)(source_index + (int)destination);\n      if (3 < remaining_length_2) {\n        src_pointer_2 = (undefined4 *)((int)destination_pointer + -4);\n        remaining_length = remaining_length_2;\n        dest_pointer = (undefined4 *)source;\n        do {\n          remaining_length = remaining_length - 4;\n          src_pointer_2 = src_pointer_2 + 1;\n          *src_pointer_2 = *dest_pointer;\n          dest_pointer = dest_pointer + 1;\n        } while (3 < remaining_length);\n        source_index = (remaining_length_2 - 4 & 0xfffffffc) + 4;\n        source = (void *)((int)source + source_index);\n        remaining_length_2 = length & 3;\n        destination_pointer = (void *)((int)destination_pointer + source_index);\n      }\n    }\n    length = remaining_length_2;\n    if (remaining_length_2 != 0) {\nLAB_08009abc:\n      src_pointer = (undefined *)((int)destination_pointer + -1);\n      src_pointer_2 = (undefined4 *)source;\n      do {\n        dest_pointer = (undefined4 *)((int)src_pointer_2 + 1);\n        src_pointer = src_pointer + 1;\n        *src_pointer = *(undefined *)src_pointer_2;\n        src_pointer_2 = dest_pointer;\n      } while (dest_pointer != (undefined4 *)(length + (int)source));\n      return destination;\n    }\n  }\n  return destination;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009a18",
            "calling": [
                "_realloc_r",
                "__ssprint_r"
            ],
            "imported": false,
            "current_name": "reverse_copy_memory_08009a18"
        },
        "FUN_0800119c": {
            "renaming": {
                "FUN_0800119c": "signed_integer_division_0800119c",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar1": "quotient",
                "iVar2": "shifted_divisor",
                "uVar3": "adjustment"
            },
            "code": "\nuint signed_integer_division_0800119c(uint dividend,uint divisor)\n\n{\n  uint quotient;\n  int shifted_divisor;\n  uint adjustment;\n  \n  shifted_divisor = divisor * 2 + 0x200000;\n  if (divisor * 2 < 0xffe00000) {\n    if (-1 < shifted_divisor) {\n      return 0;\n    }\n    quotient = shifted_divisor >> 0x15;\n    adjustment = -quotient - 0x3e1;\n    if (quotient < 0xfffffc20 && adjustment != 0) {\n      quotient = (divisor << 0xb | 0x80000000 | dividend >> 0x15) >> (adjustment & 0xff);\n      if ((divisor & 0x80000000) != 0) {\n        quotient = -quotient;\n      }\n      return quotient;\n    }\n  }\n  else if ((dividend | divisor << 0xc) != 0) {\n    return 0;\n  }\n  divisor = divisor & 0x80000000;\n  if (divisor == 0) {\n    divisor = 0x7fffffff;\n  }\n  return divisor;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800119c",
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "signed_integer_division_0800119c"
        },
        "FUN_080090b4": {
            "renaming": {
                "FUN_080090b4": "release_malloc_recursive_mutex_080090b4"
            },
            "code": "\nvoid release_malloc_recursive_mutex_080090b4(void)\n\n{\n  __retarget_lock_release_recursive(PTR___lock___malloc_recursive_mutex_080090bc);\n  return;\n}\n\n",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090b4",
            "calling": [
                "_malloc_trim_r",
                "_malloc_r",
                "_free_r",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "release_malloc_recursive_mutex_080090b4"
        },
        "FUN_08000f60": {
            "renaming": {
                "FUN_08000f60": "compare_and_return_08000f60",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_negative",
                "uVar2": "multiplied_input_1",
                "uVar3": "multiplied_input_2",
                "uVar4": "bitwise_or",
                "bVar5": "is_zero"
            },
            "code": "\nuint compare_and_return_08000f60(uint input_1,uint input_2)\n\n{\n  bool is_negative;\n  uint multiplied_input_1;\n  uint multiplied_input_2;\n  uint bitwise_or;\n  bool is_zero;\n  \n  multiplied_input_1 = input_1 * 2;\n  multiplied_input_2 = input_2 * 2;\n  if (((int)multiplied_input_1 >> 0x18 == -1 || (int)multiplied_input_2 >> 0x18 == -1) &&\n     ((((int)multiplied_input_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)multiplied_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  bitwise_or = multiplied_input_1 | input_2 & 0x7fffffff;\n  is_zero = bitwise_or == 0;\n  if (!is_zero) {\n    bitwise_or = input_1 ^ input_2;\n    is_zero = bitwise_or == 0;\n  }\n  is_negative = -1 < (int)bitwise_or;\n  if (is_negative) {\n    input_1 = multiplied_input_1 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_negative && multiplied_input_2 <= multiplied_input_1) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative || multiplied_input_2 > multiplied_input_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f60",
            "calling": [],
            "imported": false,
            "current_name": "compare_and_return_08000f60"
        },
        "FUN_0800422e": {
            "renaming": {
                "FUN_0800422e": "configure_tim_break_deadtime_0800422e",
                "htim": "timer_handle",
                "sBreakDeadTimeConfig": "break_deadtime_config",
                "HVar1": "status",
                "tmpbdtr": "temp_bdtr",
                "HAL_LOCKED": "HAL_TIM_LOCKED",
                "HAL_BUSY": "HAL_TIM_BUSY",
                "HAL_UNLOCKED": "HAL_TIM_UNLOCKED",
                "AutomaticOutput": "automatic_output",
                "BreakPolarity": "break_polarity",
                "BreakState": "break_state",
                "OffStateRunMode": "off_state_run_mode",
                "OffStateIDLEMode": "off_state_idle_mode",
                "LockLevel": "lock_level",
                "DeadTime": "dead_time"
            },
            "code": "\nHAL_StatusTypeDef\nconfigure_TIM_break_deadtime_0800422e(TIM_HandleTypeDef *timer_handle,TIM_Breakdead_timeConfigTypeDef *break_deadtime_config)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t temp_bdtr;\n  \n  if (timer_handle->Lock == HAL_TIM_LOCKED) {\n    status = HAL_TIM_BUSY;\n  }\n  else {\n    timer_handle->Lock = HAL_TIM_LOCKED;\n    timer_handle->Instance->BDTR =\n         break_deadtime_config->automatic_output |\n         (break_deadtime_config->automatic_output |\n         (break_deadtime_config->break_polarity |\n         (break_deadtime_config->break_state |\n         (break_deadtime_config->off_state_run_mode |\n         (break_deadtime_config->off_state_idle_mode |\n         (break_deadtime_config->lock_level | break_deadtime_config->dead_time & 0xfffffcff) &\n         0xfffffbff) & 0xfffff7ff) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    timer_handle->Lock = HAL_TIM_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800422e",
            "calling": [
                "MX_TIM1_Init"
            ],
            "imported": false,
            "current_name": "configure_tim_break_deadtime_0800422e"
        },
        "FUN_08008af4": {
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008af4",
            "calling": [
                "__malloc_unlock",
                "__register_exitproc"
            ],
            "imported": false,
            "current_name": "FUNC_08008af4"
        },
        "FUN_08008af0": {
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008af0",
            "calling": [
                "__malloc_lock",
                "__register_exitproc"
            ],
            "imported": false,
            "current_name": "FUNC_08008af0"
        },
        "FUN_0800151c": {
            "renaming": {
                "FUN_0800151c": "configure_systick_0800151c",
                "TickPriority": "tickPriority",
                "uVar1": "systickConfigStatus",
                "HVar2": "halStatus"
            },
            "code": "\nHAL_StatusTypeDef configureSystick_0800151c(uint32_t tickPriority)\n\n{\n  uint32_t systickConfigStatus;\n  HAL_StatusTypeDef halStatus;\n  \n  systickConfigStatus = HAL_SYSTICK_Config((uint32_t)\n                             ((ulonglong)*(uint *)PTR_SystemCoreClock_08001570 /\n                             (1000 / (ulonglong)(byte)*PTR_uwTickFreq_08001574)));\n  if (systickConfigStatus == 0) {\n    if (tickPriority < 0x10) {\n      HAL_NVIC_SetPriority(SysTick_IRQn,tickPriority,0);\n      *(uint32_t *)PTR_uwTickPrio_08001578 = tickPriority;\n      halStatus = HAL_OK;\n    }\n    else {\n      halStatus = HAL_ERROR;\n    }\n  }\n  else {\n    halStatus = HAL_ERROR;\n  }\n  return halStatus;\n}\n\n",
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800151c",
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "configure_systick_0800151c"
        },
        "FUN_08000f68": {
            "renaming": {
                "FUN_08000f68": "compare_and_select_08000f68",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_negative",
                "uVar2": "input_1_times_2",
                "uVar3": "input_2_times_2",
                "uVar4": "comparison_result",
                "bVar5": "is_zero"
            },
            "code": "\nuint compare_and_select_08000f68(uint input_1,uint input_2)\n\n{\n  bool is_negative;\n  uint input_1_times_2;\n  uint input_2_times_2;\n  uint comparison_result;\n  bool is_zero;\n  \n  input_1_times_2 = input_1 * 2;\n  input_2_times_2 = input_2 * 2;\n  if (((int)input_1_times_2 >> 0x18 == -1 || (int)input_2_times_2 >> 0x18 == -1) &&\n     ((((int)input_1_times_2 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)input_2_times_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  comparison_result = input_1_times_2 | input_2 & 0x7fffffff;\n  is_zero = comparison_result == 0;\n  if (!is_zero) {\n    comparison_result = input_1 ^ input_2;\n    is_zero = comparison_result == 0;\n  }\n  is_negative = -1 < (int)comparison_result;\n  if (is_negative) {\n    input_1 = input_1_times_2 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_negative && input_2_times_2 <= input_1_times_2) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative || input_2_times_2 > input_1_times_2) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f68",
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "imported": false,
            "current_name": "compare_and_select_08000f68"
        },
        "FUN_08009258": {
            "renaming": {
                "FUN_08009258": "calculate_polynomial_hash_08009258",
                "param_1": "hash_table",
                "param_2": "string1",
                "param_3": "string2",
                "puVar1": "multiplier",
                "puVar2": "temp",
                "iVar3": "hash_size",
                "uVar4": "carry",
                "puVar5": "str1_ptr",
                "uVar6": "str1_offset",
                "puVar7": "str2_ptr",
                "puVar14": "hash_ptr",
                "puVar15": "hash_ptr_next",
                "puVar16": "str1_current",
                "puVar17": "hash_ptr_end",
                "puVar18": "hash_ptr_start",
                "iVar9": "str2_length",
                "iVar10": "min_str_len",
                "uVar8": "temp2",
                "uVar11": "str1_end"
            },
            "code": "\nvoid calculate_polynomial_hash_08009258(undefined4 hash_table,int string1,int string2)\n\n{\n  uint *multiplier;\n  uint *temp;\n  int hash_size;\n  uint carry;\n  uint *str1_ptr;\n  uint str1_offset;\n  uint *str2_ptr;\n  uint temp2;\n  int str2_length;\n  int min_str_len;\n  uint str1_end;\n  int iVar12;\n  int iVar13;\n  uint *hash_ptr;\n  uint *hash_ptr_next;\n  uint *str1_current;\n  uint *hash_ptr_end;\n  uint *hash_ptr_start;\n  \n  iVar12 = *(int *)(string1 + 0x10);\n  str2_length = *(int *)(string2 + 0x10);\n  min_str_len = str2_length;\n  iVar13 = string1;\n  if (iVar12 < str2_length) {\n    min_str_len = iVar12;\n    iVar12 = str2_length;\n    iVar13 = string2;\n    string2 = string1;\n  }\n  str2_length = iVar12 + min_str_len;\n  hash_size = *(int *)(iVar13 + 4);\n  if (*(int *)(iVar13 + 8) < str2_length) {\n    hash_size = hash_size + 1;\n  }\n  hash_size = _Balloc(hash_table,hash_size);\n  hash_ptr_start = (uint *)(hash_size + 0x14);\n  hash_ptr_end = hash_ptr_start + str2_length;\n  for (str1_ptr = hash_ptr_start; str1_ptr < hash_ptr_end; str1_ptr = str1_ptr + 1) {\n    *str1_ptr = 0;\n  }\n  str1_offset = string2 + 0x14;\n  str1_end = str1_offset + min_str_len * 4;\n  str1_ptr = (uint *)(iVar13 + 0x14);\n  if (str1_offset < str1_end) {\n    str2_ptr = (uint *)(str1_offset + ((str1_end - string2) - 0x15 & 0xfffffffc));\n    str1_current = (uint *)(string2 + 0x10);\n    do {\n      while( true ) {\n        str1_current = str1_current + 1;\n        str1_offset = *str1_current & 0xffff;\n        if (str1_offset != 0) break;\n        str1_offset = *str1_current >> 0x10;\n        if (str1_offset == 0) goto LAB_080092d2;\nLAB_0800932c:\n        temp2 = *hash_ptr_start;\n        carry = 0;\n        multiplier = str1_ptr;\n        hash_ptr = hash_ptr_start;\n        str1_end = temp2;\n        do {\n          hash_ptr_next = hash_ptr;\n          carry = carry + str1_offset * *(ushort *)multiplier + (str1_end >> 0x10);\n          *hash_ptr_next = temp2 & 0xffff | carry * 0x10000;\n          temp = multiplier + 1;\n          str1_end = hash_ptr_next[1];\n          temp2 = str1_offset * (*multiplier >> 0x10) + (str1_end & 0xffff) + (carry >> 0x10);\n          carry = temp2 >> 0x10;\n          multiplier = temp;\n          hash_ptr = hash_ptr_next + 1;\n        } while (temp < str1_ptr + iVar12);\n        hash_ptr_next[1] = temp2;\n        hash_ptr_start = hash_ptr_start + 1;\n        if (str2_ptr == str1_current) goto LAB_0800937a;\n      }\n      str1_end = 0;\n      multiplier = hash_ptr_start;\n      hash_ptr = str1_ptr;\n      do {\n        temp = multiplier;\n        hash_ptr_next = hash_ptr + 1;\n        temp2 = str1_offset * (*hash_ptr & 0xffff) + (*temp & 0xffff) + str1_end;\n        carry = str1_offset * (*hash_ptr >> 0x10) + (*temp >> 0x10) + (temp2 >> 0x10);\n        str1_end = carry >> 0x10;\n        *temp = temp2 & 0xffff | carry * 0x10000;\n        multiplier = temp + 1;\n        hash_ptr = hash_ptr_next;\n      } while (hash_ptr_next < str1_ptr + iVar12);\n      temp[1] = str1_end;\n      str1_offset = *str1_current >> 0x10;\n      if (str1_offset != 0) goto LAB_0800932c;\nLAB_080092d2:\n      hash_ptr_start = hash_ptr_start + 1;\n    } while (str2_ptr != str1_current);\n  }\nLAB_0800937a:\n  if (0 < str2_length) {\n    str1_offset = hash_ptr_end[-1];\n    hash_ptr_end = hash_ptr_end + -1;\n    while ((str1_offset == 0 && (str2_length = str2_length + -1, str2_length != 0))) {\n      hash_ptr_end = hash_ptr_end + -1;\n      str1_offset = *hash_ptr_end;\n    }\n  }\n  *(int *)(hash_size + 0x10) = str2_length;\n  return;\n}\n\n",
            "called": [
                "_Balloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009258",
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "imported": false,
            "current_name": "calculate_polynomial_hash_08009258"
        },
        "FUN_08000c08": {
            "renaming": {
                "FUN_08000c08": "calculate_hash_08000c08",
                "param_1": "input",
                "iVar1": "leading_zeroes_count",
                "uVar2": "shift_amount",
                "iVar3": "hash_constant",
                "uVar4": "overflow"
            },
            "code": "\nuint calculate_hash_08000c08(uint input)\n\n{\n  int leading_zeroes_count;\n  uint shift_amount;\n  int hash_constant;\n  uint overflow;\n  \n  if (input == 0) {\n    return 0;\n  }\n  leading_zeroes_count = count_leading_zeroes(input);\n  shift_amount = leading_zeroes_count - 8;\n  hash_constant = shift_amount * -0x800000 + 0x4a800000;\n  if (7 < leading_zeroes_count) {\n    overflow = 0 << (shift_amount & 0xff);\n    shift_amount = hash_constant + (input << (shift_amount & 0xff)) +\n            (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < overflow);\n    if (overflow == 0x80000000) {\n      shift_amount = shift_amount & 0xfffffffe;\n    }\n    return shift_amount;\n  }\n  overflow = input << (leading_zeroes_count + 0x18U & 0xff);\n  shift_amount = hash_constant + ((input >> (0x20 - (leading_zeroes_count + 0x18U) & 0xff)) - ((int)overflow >> 0x1f));\n  if ((overflow & 0x7fffffff) == 0) {\n    shift_amount = shift_amount & ~(overflow >> 0x1f);\n  }\n  return shift_amount;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c08",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "imported": false,
            "current_name": "calculate_hash_08000c08"
        },
        "FUN_08004366": {
            "renaming": {
                "FUN_08004366": "FUNC_08004366"
            },
            "code": "\nvoid FUNC_08004366(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08004366",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "FUNC_08004366"
        },
        "FUN_080042de": {
            "renaming": {
                "FUN_080042de": "configure_master_timer_080042de",
                "htim": "timer_handle",
                "sMasterConfig": "master_config",
                "HVar1": "status",
                "HAL_LOCKED": "locked",
                "HAL_BUSY": "busy",
                "HAL_TIM_STATE_BUSY": "busy_state",
                "HAL_TIM_STATE_READY": "ready_state",
                "HAL_UNLOCKED": "unlocked",
                "Instance": "timer_instance",
                "CR2": "control_register_2",
                "SMCR": "slave_mode_control_register",
                "MasterOutputTrigger": "master_output_trigger",
                "MasterSlaveMode": "master_slave_mode"
            },
            "code": "\nHAL_StatusTypeDef\nconfigure_master_timer_080042de(TIM_HandleTypeDef *timer_handle,TIM_MasterConfigTypeDef *master_config)\n\n{\n  HAL_StatusTypeDef status;\n  \n  if (timer_handle->Lock == locked) {\n    status = busy;\n  }\n  else {\n    timer_handle->Lock = locked;\n    timer_handle->State = busy_state;\n    timer_handle->timer_instance->control_register_2 = timer_handle->timer_instance->control_register_2 & 0xffffff8f;\n    timer_handle->timer_instance->control_register_2 = master_config->master_output_trigger | timer_handle->timer_instance->control_register_2;\n    timer_handle->timer_instance->slave_mode_control_register = timer_handle->timer_instance->slave_mode_control_register & 0xffffff7f;\n    timer_handle->timer_instance->slave_mode_control_register = master_config->master_slave_mode | timer_handle->timer_instance->slave_mode_control_register;\n    timer_handle->State = ready_state;\n    timer_handle->Lock = unlocked;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042de",
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "imported": false,
            "current_name": "configure_master_timer_080042de"
        },
        "FUN_08003c6e": {
            "renaming": {
                "FUN_08003c6e": "FUNC_08003c6e"
            },
            "code": "\nvoid FUNC_08003c6e(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003c6e",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "FUNC_08003c6e"
        },
        "FUN_08008af8": {
            "renaming": {
                "FUN_08008af8": "allocate_memory_08008af8",
                "param_1": "lock",
                "param_2": "size",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "puVar3": "ptr3",
                "uVar4": "var1",
                "uVar5": "var2",
                "puVar6": "ptr4",
                "iVar7": "var3",
                "puVar8": "ptr5",
                "uVar9": "var4",
                "uVar10": "var5",
                "puVar11": "ptr6",
                "puVar12": "ptr7",
                "puVar13": "ptr8",
                "uVar14": "var6",
                "uVar15": "var7",
                "iVar16": "var8",
                "puVar17": "ptr9",
                "puVar18": "ptr10"
            },
            "code": "\nint * allocate_memory_08008af8(undefined4 *lock,uint size)\n\n{\n  undefined *ptr1;\n  undefined *ptr2;\n  undefined *ptr3;\n  uint var1;\n  uint var2;\n  uint *ptr4;\n  int var3;\n  undefined *ptr5;\n  uint var4;\n  uint var5;\n  undefined4 *ptr6;\n  undefined *ptr7;\n  undefined *ptr8;\n  uint var6;\n  uint var7;\n  int var8;\n  undefined4 *ptr9;\n  undefined4 *ptr10;\n  \n  var6 = size + 0xb;\n  if (var6 < 0x17) {\n    if (0x10 < size) goto LAB_08008c7a;\n    __malloc_lock();\n    var7 = 0x10;\n    var3 = 0x18;\n    var6 = 2;\nLAB_08008b18:\n    ptr5 = PTR___malloc_av__08008e4c + var3;\n    ptr7 = *(undefined **)(ptr5 + 4);\n    if ((ptr7 != ptr5 + -8) || (ptr7 = *(undefined **)(ptr5 + 0xc), ptr5 != ptr7)) {\n      var3 = *(int *)(ptr7 + 0xc);\n      ptr5 = ptr7 + (*(uint *)(ptr7 + 4) & 0xfffffffc);\n      var6 = *(uint *)(ptr5 + 4);\nLAB_08008b34:\n      var8 = *(int *)(ptr7 + 8);\n      *(int *)(var8 + 0xc) = var3;\n      *(int *)(var3 + 8) = var8;\n      *(uint *)(ptr5 + 4) = var6 | 1;\n      __malloc_unlock(lock);\n      return (int *)(ptr7 + 8);\n    }\n    var6 = var6 + 2;\n  }\n  else {\n    var7 = var6 & 0xfffffff8;\n    if (((int)var7 < 0) || (var7 < size)) {\nLAB_08008c7a:\n      *lock = 0xc;\n      return (int *)0x0;\n    }\n    __malloc_lock();\n    if (var7 < 0x1f8) {\n      var6 = var6 >> 3;\n      var3 = var7 + 8;\n      goto LAB_08008b18;\n    }\n    var1 = var6 >> 9;\n    if (var1 == 0) {\n      var3 = 0x200;\n      var4 = 0x40;\n      var1 = 0x3f;\n    }\n    else if (var1 < 5) {\n      var4 = (var6 >> 6) + 0x39;\n      var1 = (var6 >> 6) + 0x38;\n      var3 = var4 * 8;\n    }\n    else if (var1 < 0x15) {\n      var4 = var1 + 0x5c;\n      var1 = var1 + 0x5b;\n      var3 = var4 * 8;\n    }\n    else if (var1 < 0x55) {\n      var4 = (var6 >> 0xc) + 0x6f;\n      var1 = (var6 >> 0xc) + 0x6e;\n      var3 = var4 * 8;\n    }\n    else if (var1 < 0x155) {\n      var4 = (var6 >> 0xf) + 0x78;\n      var1 = (var6 >> 0xf) + 0x77;\n      var3 = var4 * 8;\n    }\n    else if (var1 < 0x555) {\n      var4 = (var6 >> 0x12) + 0x7d;\n      var1 = (var6 >> 0x12) + 0x7c;\n      var3 = var4 * 8;\n    }\n    else {\n      var3 = 0x3f8;\n      var4 = 0x7f;\n      var1 = 0x7e;\n    }\n    for (ptr7 = *(undefined **)(PTR___malloc_av__08008e4c + var3 + 4); var6 = var4,\n        PTR___malloc_av__08008e4c + var3 + -8 != ptr7; ptr7 = *(undefined **)(ptr7 + 0xc))\n    {\n      var8 = (*(uint *)(ptr7 + 4) & 0xfffffffc) - var7;\n      var6 = var1;\n      if (0xf < var8) break;\n      if (-1 < var8) {\n        ptr5 = ptr7 + (*(uint *)(ptr7 + 4) & 0xfffffffc);\n        var6 = *(uint *)(ptr5 + 4);\n        var3 = *(int *)(ptr7 + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  ptr5 = PTR_PTR___malloc_av__08008e60;\n  ptr7 = PTR___malloc_av__08008e4c;\n  ptr8 = *(undefined **)(PTR___malloc_av__08008e4c + 0x10);\n  if (ptr8 == PTR_PTR___malloc_av__08008e60) {\n    var1 = *(uint *)(PTR___malloc_av__08008e4c + 4);\n    var4 = 1 << ((int)var6 >> 2 & 0xffU);\n    if (var4 <= var1) goto LAB_08008c06;\n  }\n  else {\n    var4 = *(uint *)(ptr8 + 4);\n    var5 = var4 & 0xfffffffc;\n    var1 = var5 - var7;\n    if (0xf < (int)var1) {\n      ptr3 = ptr8 + var7;\n      *(uint *)(ptr8 + 4) = var7 | 1;\n      *(undefined **)(ptr7 + 0x10) = ptr3;\n      *(undefined **)(ptr7 + 0x14) = ptr3;\n      *(undefined **)(ptr3 + 8) = ptr5;\n      *(undefined **)(ptr3 + 0xc) = ptr5;\n      *(uint *)(ptr3 + 4) = var1 | 1;\n      *(uint *)(ptr8 + var5) = var1;\n      __malloc_unlock(lock);\n      return (int *)(ptr8 + 8);\n    }\n    *(undefined **)(PTR___malloc_av__08008e4c + 0x10) = PTR_PTR___malloc_av__08008e60;\n    *(undefined **)(ptr7 + 0x14) = ptr5;\n    if (-1 < (int)var1) {\n      *(uint *)(ptr8 + var5 + 4) = *(uint *)(ptr8 + var5 + 4) | 1;\n      __malloc_unlock(lock);\n      return (int *)(ptr8 + 8);\n    }\n    if (var5 < 0x200) {\n      var3 = (var4 >> 3) + 1;\n      var8 = *(int *)(ptr7 + var3 * 8);\n      var1 = 1 << ((int)(var4 >> 3) >> 2 & 0xffU) | *(uint *)(ptr7 + 4);\n      *(int *)(ptr8 + 8) = var8;\n      *(undefined **)(ptr8 + 0xc) = ptr7 + var3 * 8 + -8;\n      *(uint *)(ptr7 + 4) = var1;\n      *(undefined **)(ptr7 + var3 * 8) = ptr8;\n      *(undefined **)(var8 + 0xc) = ptr8;\n    }\n    else {\n      var1 = var4 >> 9;\n      if (var1 < 5) {\n        var3 = ((var4 >> 6) + 0x39) * 8;\n        var8 = (var4 >> 6) + 0x38;\n      }\n      else if (var1 < 0x15) {\n        var3 = (var1 + 0x5c) * 8;\n        var8 = var1 + 0x5b;\n      }\n      else if (var1 < 0x55) {\n        var3 = ((var4 >> 0xc) + 0x6f) * 8;\n        var8 = (var4 >> 0xc) + 0x6e;\n      }\n      else if (var1 < 0x155) {\n        var3 = ((var4 >> 0xf) + 0x78) * 8;\n        var8 = (var4 >> 0xf) + 0x77;\n      }\n      else if (var1 < 0x555) {\n        var3 = ((var4 >> 0x12) + 0x7d) * 8;\n        var8 = (var4 >> 0x12) + 0x7c;\n      }\n      else {\n        var3 = 0x3f8;\n        var8 = 0x7e;\n      }\n      ptr3 = *(undefined **)(ptr7 + var3);\n      ptr1 = ptr7 + var3 + -8;\n      if (ptr1 == ptr3) {\n        var1 = 1 << (var8 >> 2 & 0xffU) | *(uint *)(ptr7 + 4);\n        *(uint *)(ptr7 + 4) = var1;\n      }\n      else {\n        do {\n          if ((*(uint *)(ptr3 + 4) & 0xfffffffc) <= var5) break;\n          ptr3 = *(undefined **)(ptr3 + 8);\n        } while (ptr1 != ptr3);\n        ptr1 = *(undefined **)(ptr3 + 0xc);\n        var1 = *(uint *)(ptr7 + 4);\n      }\n      *(undefined **)(ptr8 + 8) = ptr3;\n      *(undefined **)(ptr8 + 0xc) = ptr1;\n      *(undefined **)(ptr1 + 8) = ptr8;\n      *(undefined **)(ptr3 + 0xc) = ptr8;\n    }\n    var4 = 1 << ((int)var6 >> 2 & 0xffU);\n    if (var4 <= var1) {\nLAB_08008c06:\n      if ((var4 & var1) == 0) {\n        var6 = var6 & 0xfffffffc;\n        do {\n          var4 = var4 << 1;\n          var6 = var6 + 4;\n        } while ((var4 & var1) == 0);\n      }\n      do {\n        ptr9 = (undefined4 *)(ptr7 + var6 * 8);\n        var1 = var6;\n        ptr10 = ptr9;\n        do {\n          for (ptr6 = (undefined4 *)ptr10[3]; ptr10 != ptr6;\n              ptr6 = (undefined4 *)ptr6[3]) {\n            var5 = ptr6[1] & 0xfffffffc;\n            var2 = var5 - var7;\n            if (0xf < (int)var2) {\n              var8 = ptr6[2];\n              var3 = ptr6[3];\n              ptr8 = (undefined *)(var7 + (int)ptr6);\n              ptr6[1] = var7 | 1;\n              *(int *)(var8 + 0xc) = var3;\n              *(int *)(var3 + 8) = var8;\n              *(undefined **)(ptr7 + 0x10) = ptr8;\n              *(undefined **)(ptr7 + 0x14) = ptr8;\n              *(undefined **)(ptr8 + 8) = ptr5;\n              *(undefined **)(ptr8 + 0xc) = ptr5;\n              *(uint *)(ptr8 + 4) = var2 | 1;\n              *(uint *)((int)ptr6 + var5) = var2;\n              __malloc_unlock(lock);\n              return ptr6 + 2;\n            }\n            if (-1 < (int)var2) {\n              var3 = ptr6[3];\n              var8 = ptr6[2];\n              *(uint *)((int)ptr6 + var5 + 4) = *(uint *)((int)ptr6 + var5 + 4) | 1;\n              *(int *)(var8 + 0xc) = var3;\n              *(int *)(var3 + 8) = var8;\n              __malloc_unlock(lock);\n              return ptr6 + 2;\n            }\n          }\n          var1 = var1 + 1;\n          ptr10 = ptr10 + 2;\n        } while ((var1 & 3) != 0);\n        do {\n          var5 = var6 & 3;\n          ptr10 = ptr9 + -2;\n          var6 = var6 - 1;\n          if (var5 == 0) {\n            var5 = *(uint *)(ptr7 + 4) & ~var4;\n            *(uint *)(ptr7 + 4) = var5;\n            goto LAB_08008f24;\n          }\n          ptr9 = (undefined4 *)*ptr9;\n        } while (ptr9 == ptr10);\n        var5 = *(uint *)(ptr7 + 4);\nLAB_08008f24:\n        var4 = var4 * 2;\n        if ((var5 <= var4 && var4 - var5 != 0) || (var6 = var1, var4 == 0)) break;\n        for (; (var4 & var5) == 0; var4 = var4 << 1) {\n          var6 = var6 + 4;\n        }\n      } while( true );\n    }\n  }\n  ptr5 = PTR___malloc_sbrk_base_08008e64;\n  ptr8 = *(undefined **)(ptr7 + 8);\n  var6 = *(uint *)(ptr8 + 4) & 0xfffffffc;\n  if ((var7 <= var6) && (var1 = var6 - var7, 0xf < (int)var1)) goto LAB_08008dac;\n  if (*(int *)PTR___malloc_sbrk_base_08008e64 == -1) {\n    var1 = var7 + *(int *)PTR___malloc_top_pad_08008e50 + 0x10;\n  }\n  else {\n    var1 = var7 + *(int *)PTR___malloc_top_pad_08008e50 + 0x100f & 0xfffff000;\n  }\n  ptr1 = (undefined *)_sbrk_r(lock,var1);\n  ptr4 = (uint *)PTR___malloc_current_mallinfo_08009018;\n  ptr3 = PTR___malloc_current_mallinfo_08008e54;\n  if (ptr1 == (undefined *)0xffffffff) {\nLAB_08008ed8:\n    ptr8 = *(undefined **)(ptr7 + 8);\n    var6 = *(uint *)(ptr8 + 4);\n  }\n  else {\n    ptr2 = ptr8 + var6;\n    if (ptr2 < ptr1 || ptr2 == ptr1) {\n      var4 = *(int *)PTR___malloc_current_mallinfo_08008e54 + var1;\n      *(uint *)PTR___malloc_current_mallinfo_08008e54 = var4;\n      ptr4 = (uint *)ptr3;\n      if ((ptr2 != ptr1) || (((uint)ptr2 & 0xfff) != 0)) goto LAB_08008d02;\n      *(uint *)(*(int *)(ptr7 + 8) + 4) = var6 + var1 | 1;\n    }\n    else {\n      if (ptr8 != ptr7) goto LAB_08008ed8;\n      var4 = *(int *)PTR___malloc_current_mallinfo_08009018 + var1;\n      *(uint *)PTR___malloc_current_mallinfo_08009018 = var4;\nLAB_08008d02:\n      if (*(int *)ptr5 == -1) {\n        *(undefined **)ptr5 = ptr1;\n      }\n      else {\n        *ptr4 = (uint)(ptr1 + (var4 - (int)ptr2));\n      }\n      var4 = (uint)ptr1 & 7;\n      if (var4 == 0) {\n        var3 = 0x1000;\n      }\n      else {\n        ptr1 = ptr1 + (8 - var4);\n        var3 = 0x1008 - var4;\n      }\n      var3 = var3 - ((uint)(ptr1 + var1) & 0xfff);\n      var8 = _sbrk_r(lock,var3);\n      if (var8 == -1) {\n        var1 = 1;\n        var3 = 0;\n      }\n      else {\n        var1 = (var8 - (int)ptr1) + var3 | 1;\n      }\n      var4 = *ptr4 + var3;\n      *(undefined **)(ptr7 + 8) = ptr1;\n      *ptr4 = var4;\n      *(uint *)(ptr1 + 4) = var1;\n      if (ptr8 != ptr7) {\n        if (var6 < 0x10) {\n          *(undefined4 *)(ptr1 + 4) = 1;\n          goto LAB_08008eee;\n        }\n        var6 = var6 - 0xc & 0xfffffff8;\n        *(uint *)(ptr8 + 4) = *(uint *)(ptr8 + 4) & 1 | var6;\n        *(undefined4 *)(ptr8 + var6 + 4) = 5;\n        *(undefined4 *)(ptr8 + var6 + 8) = 5;\n        if (0xf < var6) {\n          _free_r(lock,ptr8 + 8);\n          var4 = *ptr4;\n        }\n      }\n    }\n    ptr5 = PTR___malloc_max_total_mem_08008e5c;\n    ptr8 = *(undefined **)(ptr7 + 8);\n    var1 = *(uint *)PTR___malloc_max_total_mem_08008e5c;\n    if (*(uint *)PTR___malloc_max_sbrked_mem_08008e58 < var4) {\n      *(uint *)PTR___malloc_max_sbrked_mem_08008e58 = var4;\n    }\n    var6 = *(uint *)(ptr8 + 4);\n    if (var1 < var4) {\n      *(uint *)ptr5 = var4;\n    }\n  }\n  var1 = (var6 & 0xfffffffc) - var7;\n  if ((var7 <= (var6 & 0xfffffffc)) && (0xf < (int)var1)) {\nLAB_08008dac:\n    *(uint *)(ptr8 + 4) = var7 | 1;\n    *(undefined **)(ptr7 + 8) = ptr8 + var7;\n    *(uint *)(ptr8 + var7 + 4) = var1 | 1;\n    __malloc_unlock(lock);\n    return (int *)(ptr8 + 8);\n  }\nLAB_08008eee:\n  __malloc_unlock(lock);\n  return (int *)0x0;\n}\n\n",
            "called": [
                "__malloc_lock",
                "_sbrk_r",
                "__malloc_unlock",
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008af8",
            "calling": [
                "_realloc_r",
                "_calloc_r",
                "__ssprint_r",
                "_svfprintf_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08008af8"
        },
        "FUN_08004bd8": {
            "renaming": {
                "FUN_08004bd8": "calculate_pitch_08004bd8",
                "mpu6050": "sensor",
                "pitch": "pitch_angle",
                "uVar1": "gyro_offset",
                "uVar2": "total_pitch",
                "uVar3": "atan_result",
                "acc_pitch": "accel_pitch",
                "gyro_x": "gyro_value"
            },
            "code": "\nvoid calculate_pitch_08004bd8(Mpu6050 *sensor,float *pitch_angle)\n\n{\n  undefined4 gyro_offset;\n  undefined8 total_pitch;\n  undefined8 atan_result;\n  float accel_pitch;\n  float gyro_value;\n  \n  gyro_offset = __aeabi_fsub(sensor->gyroX,sensor->offset_gyroX);\n  total_pitch = __aeabi_f2d(*(undefined4 *)PTR_total_pitch_angle_08004d60);\n  atan_result = __aeabi_f2d(gyro_offset);\n  atan_result = __muldf3((int)atan_result,(int)((ulonglong)atan_result >> 0x20),DAT_08004d40,DAT_08004d44);\n  total_pitch = __aeabi_dadd((int)total_pitch,(int)((ulonglong)total_pitch >> 0x20),(int)atan_result,\n                       (int)((ulonglong)atan_result >> 0x20));\n  gyro_offset = __truncdfsf2((int)total_pitch,(int)((ulonglong)total_pitch >> 0x20));\n  *(undefined4 *)PTR_total_pitch_angle_08004d60 = gyro_offset;\n  total_pitch = __aeabi_f2d(sensor->accY);\n  total_pitch = __divdf3((int)total_pitch,(int)((ulonglong)total_pitch >> 0x20),0,DAT_08004d64);\n  atan_result = __aeabi_f2d(sensor->accZ);\n  atan_result = __divdf3((int)atan_result,(int)((ulonglong)atan_result >> 0x20),0,DAT_08004d64);\n  total_pitch = atan2((int)total_pitch,(int)((ulonglong)total_pitch >> 0x20),(int)atan_result,\n                (int)((ulonglong)atan_result >> 0x20));\n  total_pitch = __muldf3((int)total_pitch,(int)((ulonglong)total_pitch >> 0x20),0,DAT_08004d68);\n  total_pitch = __divdf3((int)total_pitch,(int)((ulonglong)total_pitch >> 0x20),DAT_08004d48,DAT_08004d4c);\n  atan_result = __aeabi_f2d(sensor->offset_accel_pitch);\n  total_pitch = __subdf3((int)total_pitch,(int)((ulonglong)total_pitch >> 0x20),(int)atan_result,\n                   (int)((ulonglong)atan_result >> 0x20));\n  total_pitch = __aeabi_dadd((int)total_pitch,(int)((ulonglong)total_pitch >> 0x20),0,DAT_08004d6c);\n  gyro_offset = __truncdfsf2((int)total_pitch,(int)((ulonglong)total_pitch >> 0x20));\n  if (*PTR_first_run_08004d70 == '\\0') {\n    total_pitch = __aeabi_f2d(*(undefined4 *)PTR_total_pitch_angle_08004d60);\n    total_pitch = __muldf3((int)total_pitch,(int)((ulonglong)total_pitch >> 0x20),DAT_08004d50,DAT_08004d54);\n    atan_result = __aeabi_f2d(gyro_offset);\n    atan_result = __muldf3((int)atan_result,(int)((ulonglong)atan_result >> 0x20),DAT_08004d58,DAT_08004d5c);\n    total_pitch = __aeabi_dadd((int)total_pitch,(int)((ulonglong)total_pitch >> 0x20),(int)atan_result,\n                         (int)((ulonglong)atan_result >> 0x20));\n    gyro_offset = __truncdfsf2((int)total_pitch,(int)((ulonglong)total_pitch >> 0x20));\n    *(undefined4 *)PTR_total_pitch_angle_08004d60 = gyro_offset;\n  }\n  else {\n    *(undefined4 *)PTR_total_pitch_angle_08004d60 = gyro_offset;\n    *PTR_first_run_08004d70 = 0;\n  }\n  *pitch_angle = *(float *)PTR_total_pitch_angle_08004d60;\n  return;\n}\n\n",
            "called": [
                "__subdf3",
                "__muldf3",
                "__aeabi_f2d",
                "__aeabi_fsub",
                "__divdf3",
                "atan2",
                "__aeabi_dadd",
                "__truncdfsf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004bd8",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "imported": false,
            "current_name": "calculate_pitch_08004bd8"
        },
        "FUN_080090c0": {
            "renaming": {
                "FUN_080090c0": "allocate_or_get_pointer_080090c0",
                "param_1": "pointer",
                "param_2": "index",
                "puVar1": "pointer_to_data",
                "iVar2": "pointer_to_index_data"
            },
            "code": "\nundefined4 * allocate_or_get_pointer_080090c0(int pointer,uint index)\n\n{\n  undefined4 *pointer_to_data;\n  int pointer_to_index_data;\n  \n  pointer_to_index_data = *(int *)(pointer + 0x4c);\n  if (pointer_to_index_data == 0) {\n    pointer_to_index_data = _calloc_r(pointer,4,0x21);\n    *(int *)(pointer + 0x4c) = pointer_to_index_data;\n    if (pointer_to_index_data == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  pointer_to_data = *(undefined4 **)(pointer_to_index_data + index * 4);\n  if (pointer_to_data == (undefined4 *)0x0) {\n    pointer_to_index_data = 1 << (index & 0xff);\n    pointer_to_data = (undefined4 *)_calloc_r(pointer,1,(pointer_to_index_data + 5) * 4);\n    if (pointer_to_data == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    pointer_to_data[1] = index;\n    pointer_to_data[2] = pointer_to_index_data;\n  }\n  else {\n    *(undefined4 *)(pointer_to_index_data + index * 4) = *pointer_to_data;\n  }\n  pointer_to_data[3] = 0;\n  pointer_to_data[4] = 0;\n  return pointer_to_data;\n}\n\n",
            "called": [
                "_calloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090c0",
            "calling": [
                "_dtoa_r",
                "__d2b",
                "__lshift",
                "__mdiff",
                "__multadd",
                "__pow5mult",
                "__i2b",
                "__multiply"
            ],
            "imported": false,
            "current_name": "allocate_or_get_pointer_080090c0"
        },
        "FUN_080091e4": {
            "renaming": {
                "FUN_080091e4": "count_leading_zeros_080091e4",
                "param_1": "num_ptr",
                "uVar1": "leading_zeros",
                "uVar2": "num"
            },
            "code": "\nuint count_leading_zeros_080091e4(uint *num_ptr)\n\n{\n  uint leading_zeros;\n  uint num;\n  \n  num = *num_ptr;\n  leading_zeros = num & 7;\n  if (leading_zeros == 0) {\n    if ((num & 0xffff) == 0) {\n      num = num >> 0x10;\n      leading_zeros = 0x10;\n    }\n    if ((num & 0xff) == 0) {\n      num = num >> 8;\n      leading_zeros = leading_zeros + 8;\n    }\n    if ((num & 0xf) == 0) {\n      num = num >> 4;\n      leading_zeros = leading_zeros + 4;\n    }\n    if ((num & 3) == 0) {\n      num = num >> 2;\n      leading_zeros = leading_zeros + 2;\n    }\n    if (-1 < (int)(num << 0x1f)) {\n      num = num >> 1;\n      if (num == 0) {\n        return 0x20;\n      }\n      leading_zeros = leading_zeros + 1;\n    }\n    *num_ptr = num;\n    return leading_zeros;\n  }\n  if (-1 < (int)(num << 0x1f)) {\n    if ((int)(num << 0x1e) < 0) {\n      *num_ptr = num >> 1;\n      return 1;\n    }\n    *num_ptr = num >> 2;\n    return 2;\n  }\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091e4",
            "calling": [
                "__d2b"
            ],
            "imported": false,
            "current_name": "count_leading_zeros_080091e4"
        },
        "FUN_08000cb8": {
            "renaming": {
                "FUN_08000cb8": "float_bitwise_addition_08000cb8",
                "param_1": "float_bits_1",
                "param_2": "float_bits_2",
                "param_3": "unused_parameter",
                "param_4": "exponent_bits",
                "lVar1": "product",
                "uVar2": "result_bits",
                "uVar3": "float_bits_1_exponent",
                "uVar6": "product_bits_1",
                "iVar4": "exponent_sum",
                "iVar5": "exponent_difference",
                "iVar7": "exponent_difference_clamped",
                "bVar9": "is_zero_or_infinity_or_NaN",
                "bVar10": "overflowed"
            },
            "code": "\nuint float_bitwise_addition_08000cb8(uint float_bits_1,uint float_bits_2,undefined4 unused_parameter,uint exponent_bits)\n\n{\n  longlong product;\n  uint result_bits;\n  uint float_bits_1_exponent;\n  int exponent_sum;\n  int exponent_difference;\n  uint product_bits_1;\n  int exponent_difference_clamped;\n  uint uVar8;\n  bool is_zero_or_infinity_or_NaN;\n  bool overflowed;\n  \n  float_bits_1_exponent = float_bits_1 >> 0x17 & 0xff;\n  is_zero_or_infinity_or_NaN = float_bits_1_exponent == 0;\n  if (!is_zero_or_infinity_or_NaN) {\n    exponent_bits = float_bits_2 >> 0x17 & 0xff;\n    is_zero_or_infinity_or_NaN = exponent_bits == 0;\n  }\n  if (!is_zero_or_infinity_or_NaN) {\n    is_zero_or_infinity_or_NaN = float_bits_1_exponent == 0xff;\n  }\n  if (!is_zero_or_infinity_or_NaN) {\n    is_zero_or_infinity_or_NaN = exponent_bits == 0xff;\n  }\n  if (is_zero_or_infinity_or_NaN) {\n    exponent_bits = float_bits_2 >> 0x17 & 0xff;\n    if (float_bits_1_exponent == 0xff || exponent_bits == 0xff) {\n      is_zero_or_infinity_or_NaN = float_bits_1 == 0 || float_bits_1 == 0x80000000;\n      result_bits = float_bits_2;\n      if (float_bits_1 != 0 && float_bits_1 != 0x80000000) {\n        is_zero_or_infinity_or_NaN = float_bits_2 == 0;\n        result_bits = float_bits_1;\n      }\n      if (!is_zero_or_infinity_or_NaN) {\n        is_zero_or_infinity_or_NaN = float_bits_2 == 0x80000000;\n      }\n      uVar8 = result_bits;\n      if (((is_zero_or_infinity_or_NaN) || ((float_bits_1_exponent == 0xff && ((result_bits & 0x7fffff) != 0)))) ||\n         ((exponent_bits == 0xff && (uVar8 = float_bits_2, (float_bits_2 & 0x7fffff) != 0)))) {\n        return uVar8 | 0x7fc00000;\n      }\n      result_bits = result_bits ^ float_bits_2;\n      goto LAB_08000e08;\n    }\n    is_zero_or_infinity_or_NaN = (float_bits_1 & 0x7fffffff) == 0;\n    if (!is_zero_or_infinity_or_NaN) {\n      is_zero_or_infinity_or_NaN = (float_bits_2 & 0x7fffffff) == 0;\n    }\n    if (is_zero_or_infinity_or_NaN) {\n      return (float_bits_1 ^ float_bits_2) & 0x80000000;\n    }\n    is_zero_or_infinity_or_NaN = float_bits_1_exponent == 0;\n    result_bits = float_bits_1 & 0x80000000;\n    while( true ) {\n      if (is_zero_or_infinity_or_NaN) {\n        float_bits_1 = float_bits_1 << 1;\n        is_zero_or_infinity_or_NaN = (float_bits_1 & 0x800000) == 0;\n      }\n      if (!is_zero_or_infinity_or_NaN) break;\n      float_bits_1_exponent = float_bits_1_exponent - 1;\n    }\n    float_bits_1 = float_bits_1 | result_bits;\n    is_zero_or_infinity_or_NaN = exponent_bits == 0;\n    result_bits = float_bits_2 & 0x80000000;\n    while( true ) {\n      if (is_zero_or_infinity_or_NaN) {\n        float_bits_2 = float_bits_2 << 1;\n        is_zero_or_infinity_or_NaN = (float_bits_2 & 0x800000) == 0;\n      }\n      if (!is_zero_or_infinity_or_NaN) break;\n      exponent_bits = exponent_bits - 1;\n    }\n    float_bits_2 = float_bits_2 | result_bits;\n  }\n  exponent_sum = float_bits_1_exponent + exponent_bits;\n  uVar8 = float_bits_1 ^ float_bits_2;\n  float_bits_1_exponent = float_bits_1 << 9;\n  is_zero_or_infinity_or_NaN = float_bits_1_exponent == 0;\n  if (!is_zero_or_infinity_or_NaN) {\n    float_bits_2 = float_bits_2 << 9;\n    is_zero_or_infinity_or_NaN = float_bits_2 == 0;\n  }\n  if (is_zero_or_infinity_or_NaN) {\n    if (float_bits_1_exponent == 0) {\n      float_bits_2 = float_bits_2 << 9;\n    }\n    result_bits = uVar8 & 0x80000000 | float_bits_1 & 0x7fffff | float_bits_2 >> 9;\n    overflowed = SBORROW4(exponent_sum,0x7f);\n    exponent_difference = exponent_sum + -0x7f;\n    is_zero_or_infinity_or_NaN = exponent_difference == 0;\n    exponent_difference_clamped = exponent_difference;\n    if (!is_zero_or_infinity_or_NaN && 0x7e < exponent_sum) {\n      overflowed = SBORROW4(0xff,exponent_difference);\n      exponent_difference_clamped = 0xff - exponent_difference;\n      is_zero_or_infinity_or_NaN = exponent_difference == 0xff;\n    }\n    if (!is_zero_or_infinity_or_NaN && exponent_difference_clamped < 0 == overflowed) {\n      result_bits = result_bits | exponent_difference * 0x800000;\n    }\n    if (!is_zero_or_infinity_or_NaN && exponent_difference_clamped < 0 == overflowed) {\n      return result_bits;\n    }\n    result_bits = result_bits | 0x800000;\n    product_bits_1 = 0;\n    overflowed = SBORROW4(exponent_difference,1);\n    uVar8 = exponent_sum - 0x80;\n    is_zero_or_infinity_or_NaN = uVar8 == 0;\n    float_bits_1_exponent = uVar8;\n  }\n  else {\n    product = (ulonglong)(float_bits_1_exponent >> 5 | 0x8000000) * (ulonglong)(float_bits_2 >> 5 | 0x8000000);\n    product_bits_1 = (uint)product;\n    result_bits = (uint)((ulonglong)product >> 0x20);\n    is_zero_or_infinity_or_NaN = result_bits < 0x800000;\n    if (is_zero_or_infinity_or_NaN) {\n      result_bits = result_bits << 1;\n    }\n    if (is_zero_or_infinity_or_NaN) {\n      result_bits = result_bits | product_bits_1 >> 0x1f;\n      product_bits_1 = product_bits_1 << 1;\n    }\n    result_bits = uVar8 & 0x80000000 | result_bits;\n    uVar8 = (exponent_sum + -0x7f) - (uint)is_zero_or_infinity_or_NaN;\n    overflowed = SBORROW4(uVar8,0xfd);\n    is_zero_or_infinity_or_NaN = uVar8 == 0xfd;\n    float_bits_1_exponent = uVar8 - 0xfd;\n    if (uVar8 < 0xfe) {\n      result_bits = result_bits + uVar8 * 0x800000 + (uint)(0x7fffffff < product_bits_1);\n      if (product_bits_1 == 0x80000000) {\n        result_bits = result_bits & 0xfffffffe;\n      }\n      return result_bits;\n    }\n  }\n  if (is_zero_or_infinity_or_NaN || (int)float_bits_1_exponent < 0 != overflowed) {\n    is_zero_or_infinity_or_NaN = (int)(uVar8 + 0x19) < 0;\n    if (uVar8 == 0xffffffe7 || is_zero_or_infinity_or_NaN != SCARRY4(uVar8,0x19)) {\n      result_bits = result_bits & 0x80000000;\n    }\n    if (uVar8 != 0xffffffe7 && is_zero_or_infinity_or_NaN == SCARRY4(uVar8,0x19)) {\n      float_bits_1_exponent = (result_bits << 1) >> (-uVar8 & 0xff);\n      uVar8 = result_bits << (uVar8 + 0x20 & 0xff);\n      float_bits_1_exponent = ((uint)((result_bits & 0x80000000) != 0) << 0x1f | float_bits_1_exponent >> 1) + (uint)((byte)float_bits_1_exponent & 1);\n      if ((product_bits_1 | uVar8 << 1) == 0) {\n        float_bits_1_exponent = float_bits_1_exponent & ~(uVar8 >> 0x1f);\n      }\n      return float_bits_1_exponent;\n    }\n    return result_bits;\n  }\nLAB_08000e08:\n  return result_bits & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000cb8",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "imported": false,
            "current_name": "float_bitwise_addition_08000cb8"
        },
        "FUN_080098c0": {
            "renaming": {
                "FUN_080098c0": "update_global_array_080098c0",
                "param_1": "update_type",
                "param_2": "new_value",
                "param_3": "first_value",
                "param_4": "second_value",
                "puVar1": "mutex_ptr",
                "uVar2": "return_value",
                "uVar3": "bitwise_shift",
                "uVar4": "index",
                "iVar5": "global_array_ptr",
                "iVar6": "global_impure_ptr",
                "iVar7": "new_index"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 update_global_array_080098c0(int update_type,undefined4 new_value,undefined4 first_value,undefined4 second_value)\n\n{\n  undefined *mutex_ptr;\n  undefined4 return_value;\n  uint bitwise_shift;\n  uint index;\n  int global_array_ptr;\n  int global_impure_ptr;\n  int new_index;\n  \n  mutex_ptr = PTR___atexit_recursive_mutex_08009974;\n  __retarget_lock_acquire_recursive(*(undefined4 *)PTR___atexit_recursive_mutex_08009974);\n  global_impure_ptr = *(int *)PTR__global_impure_ptr_08009978;\n  global_array_ptr = *(int *)(global_impure_ptr + 0x148);\n  if (global_array_ptr == 0) {\n    global_array_ptr = global_impure_ptr + 0x14c;\n    *(int *)(global_impure_ptr + 0x148) = global_array_ptr;\n  }\n  index = *(uint *)(global_array_ptr + 4);\n  if ((int)index < 0x20) {\n    new_index = index + 1;\n  }\n  else {\n    if (DAT_0800997c == 0) {\n      __retarget_lock_release_recursive(*(undefined4 *)mutex_ptr);\n      return 0xffffffff;\n    }\n    global_array_ptr = 400;\n    index = 0;\n    _DAT_00000190 = *(undefined4 *)(global_impure_ptr + 0x148);\n    new_index = 1;\n    _DAT_00000194 = 0;\n    *(undefined4 *)(global_impure_ptr + 0x148) = 400;\n    _DAT_00000318 = 0;\n    _DAT_0000031c = 0;\n  }\n  if (update_type != 0) {\n    global_impure_ptr = global_array_ptr + index * 4;\n    *(undefined4 *)(global_impure_ptr + 0x88) = first_value;\n    bitwise_shift = 1 << (index & 0xff);\n    *(uint *)(global_array_ptr + 0x188) = *(uint *)(global_array_ptr + 0x188) | bitwise_shift;\n    *(undefined4 *)(global_impure_ptr + 0x108) = second_value;\n    if (update_type == 2) {\n      *(uint *)(global_array_ptr + 0x18c) = bitwise_shift | *(uint *)(global_array_ptr + 0x18c);\n    }\n  }\n  *(int *)(global_array_ptr + 4) = new_index;\n  return_value = *(undefined4 *)mutex_ptr;\n  *(undefined4 *)(global_array_ptr + (index + 2) * 4) = new_value;\n  __retarget_lock_release_recursive(return_value);\n  return 0;\n}\n\n",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080098c0",
            "calling": [
                "atexit"
            ],
            "imported": false,
            "current_name": "update_global_array_080098c0"
        },
        "FUN_08003c80": {
            "renaming": {
                "FUN_08003c80": "FUNC_08003c80"
            },
            "code": "\nvoid FUNC_08003c80(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003c80",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "FUNC_08003c80"
        },
        "FUN_080027f4": {
            "renaming": {
                "FUN_080027f4": "read_from_i2c_device_080027f4",
                "hi2c": "i2c_handle",
                "DevAddress": "device_address",
                "MemAddress": "memory_address",
                "MemAddSize": "memory_address_size",
                "Timeout": "timeout",
                "Tickstart": "tick_start",
                "HVar1": "hal_status",
                "uVar2": "tick_count",
                "iVar3": "loop_count",
                "tmpreg": "temporary_register"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nHAL_StatusTypeDef\nread_from_i2c_device_080027f4(I2C_HandleTypeDef *i2c_handle,uint16_t device_address,uint16_t memory_address,uint16_t memory_address_size,\n          uint32_t timeout,uint32_t tick_start)\n\n{\n  HAL_StatusTypeDef hal_status;\n  uint32_t tick_count;\n  int loop_count;\n  uint32_t temporary_register;\n  \n  i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x400;\n  i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x100;\n  do {\n    if ((~i2c_handle->Instance->SR1 & 1) == 0) {\n      loop_count = 0;\n      goto LAB_080028d2;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (tick_count = HAL_GetTick(), tick_count - tick_start <= timeout))));\n  i2c_handle->PreviousState = 0;\n  i2c_handle->State = HAL_I2C_STATE_READY;\n  i2c_handle->Mode = HAL_I2C_MODE_NONE;\n  i2c_handle->Lock = HAL_UNLOCKED;\n  loop_count = 3;\nLAB_080028d2:\n  if (loop_count == 0) {\n    i2c_handle->Instance->DR = (byte)device_address & 0xfe;\n    hal_status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2c_handle,DAT_08002ad4,timeout,tick_start);\n    if (hal_status == HAL_OK) {\n      hal_status = I2C_WaitOnTXEFlagUntiltimeout(i2c_handle,timeout,tick_start);\n      if (hal_status == HAL_OK) {\n        if (memory_address_size == 1) {\n          i2c_handle->Instance->DR = (uint)(byte)memory_address;\n        }\n        else {\n          i2c_handle->Instance->DR = (uint)(byte)(memory_address >> 8);\n          hal_status = I2C_WaitOnTXEFlagUntiltimeout(i2c_handle,timeout,tick_start);\n          if (hal_status != HAL_OK) {\n            if (i2c_handle->ErrorCode == 4) {\n              i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n              return HAL_ERROR;\n            }\n            return HAL_TIMEOUT;\n          }\n          i2c_handle->Instance->DR = (uint)(byte)memory_address;\n        }\n        hal_status = I2C_WaitOnTXEFlagUntiltimeout(i2c_handle,timeout,tick_start);\n        if (hal_status == HAL_OK) {\n          i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x100;\n          do {\n            if ((~i2c_handle->Instance->SR1 & 1) == 0) {\n              loop_count = 0;\n              goto LAB_08002a90;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (tick_count = HAL_GetTick(), tick_count - tick_start <= timeout))));\n          i2c_handle->PreviousState = 0;\n          i2c_handle->State = HAL_I2C_STATE_READY;\n          i2c_handle->Mode = HAL_I2C_MODE_NONE;\n          i2c_handle->Lock = HAL_UNLOCKED;\n          loop_count = 3;\nLAB_08002a90:\n          if (loop_count == 0) {\n            i2c_handle->Instance->DR = (uint)(byte)((byte)device_address | 1);\n            hal_status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2c_handle,DAT_08002ad4,timeout,tick_start);\n            if (hal_status == HAL_OK) {\n              hal_status = HAL_OK;\n            }\n            else if (i2c_handle->ErrorCode == 4) {\n              hal_status = HAL_ERROR;\n            }\n            else {\n              hal_status = HAL_TIMEOUT;\n            }\n          }\n          else {\n            hal_status = HAL_TIMEOUT;\n          }\n        }\n        else if (i2c_handle->ErrorCode == 4) {\n          i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n          hal_status = HAL_ERROR;\n        }\n        else {\n          hal_status = HAL_TIMEOUT;\n        }\n      }\n      else if (i2c_handle->ErrorCode == 4) {\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n        hal_status = HAL_ERROR;\n      }\n      else {\n        hal_status = HAL_TIMEOUT;\n      }\n    }\n    else if (i2c_handle->ErrorCode == 4) {\n      hal_status = HAL_ERROR;\n    }\n    else {\n      hal_status = HAL_TIMEOUT;\n    }\n  }\n  else {\n    hal_status = HAL_TIMEOUT;\n  }\n  return hal_status;\n}\n\n",
            "called": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080027f4",
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "imported": false,
            "current_name": "read_from_i2c_device_080027f4"
        },
        "FUN_080003d4": {
            "renaming": {
                "FUN_080003d4": "count_leading_zeros_and_shift_080003d4",
                "param_1": "input_number",
                "uVar1": "shifted_bits",
                "uVar2": "shift_amount",
                "iVar3": "leading_zeros",
                "uVar4": "shift_amount_plus",
                "bVar5": "shift_amount_less_than_zero",
                "bVar6": "shift_amount_equal_to_zero",
                "bVar7": "shift_amount_plus_less_than_32",
                "in_r12": "temp",
                "SCARRY4": "signed_integer_overflow",
                "SBORROW4": "signed_integer_underflow"
            },
            "code": "\nulonglong count_leading_zeros_and_shift_080003d4(uint input_number)\n\n{\n  uint shifted_bits;\n  uint shift_amount;\n  int leading_zeros;\n  uint shift_amount_plus;\n  uint temp;\n  bool shift_amount_less_than_zero;\n  bool shift_amount_equal_to_zero;\n  bool shift_amount_plus_less_than_32;\n  \n  if (input_number == 0) {\n    return 0;\n  }\n  shifted_bits = 0;\n  leading_zeros = count_leading_zeroes(input_number);\n  shift_amount_plus = leading_zeros + 0x15;\n  shift_amount_plus_less_than_32 = signed_integer_underflow(shift_amount_plus,0x20);\n  shift_amount = leading_zeros - 0xb;\n  shift_amount_less_than_zero = (int)shift_amount < 0;\n  shift_amount_equal_to_zero = shift_amount == 0;\n  if ((int)shift_amount_plus < 0x20) {\n    shift_amount_plus_less_than_32 = signed_integer_overflow(shift_amount,0xc);\n    leading_zeros = leading_zeros + 1;\n    shift_amount_less_than_zero = leading_zeros < 0;\n    shift_amount_equal_to_zero = leading_zeros == 0;\n    shift_amount = shift_amount_plus;\n    if (!shift_amount_equal_to_zero && shift_amount_less_than_zero == shift_amount_plus_less_than_32) {\n      shifted_bits = input_number << (shift_amount_plus & 0xff);\n      input_number = input_number >> (0xcU - leading_zeros & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (shift_amount_equal_to_zero || shift_amount_less_than_zero != shift_amount_plus_less_than_32) {\n    temp = 0x20 - shift_amount;\n  }\n  input_number = input_number << (shift_amount & 0xff);\n  if (shift_amount_equal_to_zero || shift_amount_less_than_zero != shift_amount_plus_less_than_32) {\n    input_number = input_number | 0U >> (temp & 0xff);\n  }\n  if (shift_amount_equal_to_zero || shift_amount_less_than_zero != shift_amount_plus_less_than_32) {\n    shifted_bits = 0 << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shift_amount_plus < 0x433) {\n    return CONCAT44(input_number + (0x432 - shift_amount_plus) * 0x100000,shifted_bits);\n  }\n  shift_amount = ~(0x432 - shift_amount_plus);\n  if (0x1e < (int)shift_amount) {\n    return (ulonglong)(input_number >> (shift_amount - 0x1f & 0xff));\n  }\n  leading_zeros = shift_amount - 0x13;\n  if (leading_zeros == 0 || leading_zeros < 0 != signed_integer_overflow(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(input_number >> (shift_amount & 0xff),\n                    shifted_bits >> (shift_amount & 0xff) | input_number << (0x20 - shift_amount & 0xff));\n  }\n  return (ulonglong)(shifted_bits >> (0x20 - (0xcU - leading_zeros) & 0xff) | input_number << (0xcU - leading_zeros & 0xff));\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080003d4",
            "calling": [
                "_dtoa_r"
            ],
            "imported": false,
            "current_name": "count_leading_zeros_and_shift_080003d4"
        },
        "FUN_08004d78": {
            "renaming": {
                "FUN_08004d78": "calculate_pitch_and_roll_08004d78",
                "mpu6050": "sensor_data",
                "pitch": "pitch_angle",
                "roll": "roll_angle",
                "uVar1": "acc_x_normalized",
                "uVar2": "acc_y_normalized",
                "uVar3": "acc_z_normalized",
                "fVar4": "pitch_angle_calculated",
                "fVar5": "roll_angle_calculated",
                "uVar6": "temp_var1",
                "uVar7": "temp_var2",
                "acc_roll": "roll_acceleration",
                "acc_pitch": "pitch_acceleration",
                "acc_z": "normalized_z_acceleration",
                "acc_y": "normalized_y_acceleration",
                "acc_x": "normalized_x_acceleration"
            },
            "code": "\nvoid calculate_pitch_and_roll_08004d78(Mpu6050 *sensor_data,float *pitch_angle,float *roll_angle)\n\n{\n  undefined4 acc_x_normalized;\n  undefined4 acc_y_normalized;\n  undefined4 acc_z_normalized;\n  float pitch_angle_calculated;\n  float roll_angle_calculated;\n  undefined8 temp_var1;\n  undefined8 temp_var2;\n  float roll_acceleration;\n  float pitch_acceleration;\n  float normalized_z_acceleration;\n  float normalized_y_acceleration;\n  float normalized_x_acceleration;\n  \n  acc_x_normalized = __aeabi_fdiv(sensor_data->accX,0x45800000);\n  acc_y_normalized = __aeabi_fdiv(sensor_data->accY,0x45800000);\n  acc_z_normalized = __aeabi_fdiv(sensor_data->accZ,0x45800000);\n  temp_var1 = __aeabi_f2d(acc_y_normalized);\n  temp_var2 = __aeabi_f2d(acc_z_normalized);\n  temp_var1 = atan2((int)temp_var1,(int)((ulonglong)temp_var1 >> 0x20),(int)temp_var2,\n                (int)((ulonglong)temp_var2 >> 0x20));\n  temp_var1 = __muldf3((int)temp_var1,(int)((ulonglong)temp_var1 >> 0x20),0,DAT_08004e68);\n  temp_var1 = __divdf3((int)temp_var1,(int)((ulonglong)temp_var1 >> 0x20),DAT_08004e60,DAT_08004e64);\n  pitch_angle_calculated = (float)__truncdfsf2((int)temp_var1,(int)((ulonglong)temp_var1 >> 0x20));\n  temp_var1 = __aeabi_f2d(acc_x_normalized);\n  temp_var2 = __aeabi_f2d(acc_z_normalized);\n  temp_var1 = atan2((int)temp_var1,(int)((ulonglong)temp_var1 >> 0x20),(int)temp_var2,\n                (int)((ulonglong)temp_var2 >> 0x20));\n  temp_var1 = __muldf3((int)temp_var1,(int)((ulonglong)temp_var1 >> 0x20),0,DAT_08004e68);\n  temp_var1 = __divdf3((int)temp_var1,(int)((ulonglong)temp_var1 >> 0x20),DAT_08004e60,DAT_08004e64);\n  roll_angle_calculated = (float)__truncdfsf2((int)temp_var1,(int)((ulonglong)temp_var1 >> 0x20));\n  *pitch_angle = pitch_angle_calculated;\n  *roll_angle = roll_angle_calculated;\n  return;\n}\n\n",
            "called": [
                "__muldf3",
                "__aeabi_f2d",
                "__aeabi_fdiv",
                "__divdf3",
                "atan2",
                "__truncdfsf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d78",
            "calling": [
                "mpu6050_calibrate"
            ],
            "imported": false,
            "current_name": "calculate_pitch_and_roll_08004d78"
        },
        "FUN_08000c10": {
            "renaming": {
                "FUN_08000c10": "calculate_hash_08000c10",
                "param_1": "input",
                "iVar1": "leading_zeroes",
                "uVar2": "shift_amount",
                "iVar4": "hash_base",
                "uVar3": "hash",
                "uVar5": "carry"
            },
            "code": "\nuint calculate_hash_08000c10(uint input)\n\n{\n  int leading_zeroes;\n  uint shift_amount;\n  uint hash;\n  int hash_base;\n  uint carry;\n  \n  hash = input & 0x80000000;\n  if ((int)hash < 0) {\n    input = -input;\n  }\n  if (input == 0) {\n    return 0;\n  }\n  leading_zeroes = count_leading_zeroes(input);\n  shift_amount = leading_zeroes - 8;\n  hash_base = ((hash | 0x4b000000) - 0x800000) + shift_amount * -0x800000;\n  if (7 < leading_zeroes) {\n    carry = 0 << (shift_amount & 0xff);\n    hash = hash_base + (input << (shift_amount & 0xff)) +\n            (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < carry);\n    if (carry == 0x80000000) {\n      hash = hash & 0xfffffffe;\n    }\n    return hash;\n  }\n  shift_amount = input << (leading_zeroes + 0x18U & 0xff);\n  hash = hash_base + ((input >> (0x20 - (leading_zeroes + 0x18U) & 0xff)) - ((int)shift_amount >> 0x1f));\n  if ((shift_amount & 0x7fffffff) == 0) {\n    hash = hash & ~(shift_amount >> 0x1f);\n  }\n  return hash;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c10",
            "calling": [
                "mpu6050_calibrate",
                "mpu6050_update",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "imported": false,
            "current_name": "calculate_hash_08000c10"
        },
        "FUN_0800491c": {
            "renaming": {
                "FUN_0800491c": "initialize_mpu6050_0800491c",
                "mpu6050": "sensor",
                "local_13": "register_address",
                "local_12": "register_value",
                "local_11": "data_buffer"
            },
            "code": "\nvoid initialize_mpu6050_0800491c(Mpu6050 *sensor)\n\n{\n  undefined register_address;\n  undefined register_value;\n  undefined data_buffer [5];\n  \n  register_address = 0;\n  (**(code **)PTR_I2C_Write_Reg_080049c8)(0xd0,0x6b,&register_address,1);\n  register_value = 0x10;\n  (**(code **)PTR_I2C_Write_Reg_080049c8)(0xd0,0x1c,&register_value,1);\n  data_buffer[0] = 8;\n  (**(code **)PTR_I2C_Write_Reg_080049c8)(0xd0,0x1b,data_buffer,1);\n  sensor->accX = 0.0;\n  sensor->accY = 0.0;\n  sensor->accZ = 0.0;\n  sensor->temp = 0.0;\n  sensor->gyroX = 0.0;\n  sensor->gyroY = 0.0;\n  sensor->gyroZ = 0.0;\n  sensor->offset_gyroX = 0.0;\n  sensor->offset_gyroY = 0.0;\n  sensor->offset_acc_pitch = 0.0;\n  sensor->offset_acc_roll = 0.0;\n  sensor_calibrate(sensor);\n  return;\n}\n\n",
            "called": [
                "mpu6050_calibrate"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800491c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_mpu6050_0800491c"
        }
    },
    "used_tokens": 168980,
    "layers": [
        [
            "FUN_08003440",
            "FUN_08004f2c",
            "FUN_080046ec",
            "FUN_08005500",
            "FUN_08003568",
            "FUN_08002c2e",
            "FUN_080008ec",
            "FUN_08000978",
            "FUN_0800101c",
            "FUN_080056d4",
            "FUN_080078b4",
            "FUN_080017b4",
            "FUN_08001030",
            "FUN_080011ec",
            "FUN_080056ce",
            "FUN_08004f3c",
            "FUN_080008fc",
            "FUN_08001714",
            "FUN_08000988",
            "FUN_080078c0",
            "FUN_080079e8",
            "FUN_080017c4",
            "FUN_080056da",
            "FUN_08001044",
            "FUN_08009444",
            "FUN_08004436",
            "FUN_08009e50",
            "FUN_08004ee8",
            "FUN_080094f8",
            "FUN_08000998",
            "FUN_08000fc8",
            "FUN_08003908",
            "FUN_08004f60",
            "FUN_08001170",
            "FUN_08002ad8",
            "FUN_08000fd0",
            "FUN_08003d60",
            "FUN_08009e68",
            "FUN_08001618",
            "FUN_080091a4",
            "FUN_08004f78",
            "FUN_080015a0",
            "FUN_08002d98",
            "FUN_0800172a",
            "FUN_080009d4",
            "FUN_08009744",
            "FUN_08003640",
            "FUN_08009980",
            "FUN_08000134",
            "FUN_08005704",
            "FUN_08002ca8",
            "FUN_08003a94",
            "FUN_0800416a",
            "FUN_080059f0",
            "FUN_08001ccc",
            "FUN_0800157c",
            "FUN_0800121c",
            "FUN_080036f8",
            "FUN_080009e8",
            "FUN_08009630",
            "FUN_08005830",
            "FUN_08005714",
            "FUN_08005834",
            "FUN_08005838",
            "FUN_080096e0",
            "FUN_08003540",
            "FUN_08001ab0",
            "FUN_08000150",
            "FUN_08000158",
            "FUN_08009768",
            "FUN_08001008",
            "FUN_08003ff8",
            "FUN_08004ea4",
            "FUN_08005728",
            "FUN_08003e38",
            "FUN_080006a4",
            "FUN_08009530",
            "FUN_08002bb4",
            "FUN_08002d3c",
            "FUN_080009fc",
            "FUN_080093a4",
            "FUN_0800015c",
            "FUN_080078a0",
            "FUN_080056c8",
            "FUN_080057e8",
            "FUN_080008f4",
            "FUN_080036a8",
            "FUN_080088ec",
            "FUN_08005224",
            "FUN_08005348",
            "FUN_080049cc",
            "FUN_08003c94",
            "FUN_0800884c",
            "FUN_0800901c",
            "FUN_0800177c",
            "FUN_080099ec",
            "FUN_08005598",
            "FUN_08009adc",
            "FUN_08002640",
            "FUN_08005dfc",
            "FUN_080003f4",
            "FUN_0800045c",
            "FUN_0800166c",
            "FUN_0800360c",
            "FUN_08005d68",
            "FUN_080035a4",
            "FUN_080041ea",
            "FUN_08004ae0",
            "FUN_080015fc",
            "FUN_08000110",
            "FUN_08003504",
            "FUN_08000aa4",
            "FUN_08000c2c",
            "FUN_08000aa8",
            "FUN_080009ac",
            "FUN_0800438a",
            "FUN_0800046c",
            "FUN_080009c0",
            "FUN_08003f18",
            "FUN_080097cc",
            "FUN_08001f6c",
            "FUN_08000c3c",
            "FUN_08003518",
            "FUN_08005780",
            "FUN_08000fe0",
            "FUN_08008818",
            "FUN_08000418",
            "FUN_080055f4",
            "FUN_080053b0",
            "FUN_080016d0",
            "FUN_0800088a",
            "FUN_08000e20",
            "FUN_08005d14",
            "FUN_080015b4",
            "FUN_080041a8",
            "FUN_08000a9c",
            "FUN_08008ad4",
            "FUN_08005674",
            "FUN_08004104",
            "FUN_08000ff4",
            "FUN_08005d0c",
            "FUN_08005e40",
            "FUN_08005d20",
            "FUN_08001a80",
            "FUN_080090a8",
            "FUN_08004e74",
            "FUN_0800910c",
            "FUN_080052a0",
            "FUN_08009120",
            "FUN_08000f58",
            "FUN_08001084",
            "FUN_08005680",
            "FUN_08003260",
            "FUN_08009244",
            "FUN_08004e6c",
            "FUN_08001762",
            "FUN_080040a0",
            "FUN_08009a18",
            "FUN_0800119c",
            "FUN_080090b4",
            "FUN_08000f60",
            "FUN_0800422e",
            "FUN_0800151c",
            "FUN_08000f68",
            "FUN_08009258",
            "FUN_08000c08",
            "FUN_080042de",
            "FUN_08008af8",
            "FUN_08004bd8",
            "FUN_080090c0",
            "FUN_080091e4",
            "FUN_08000cb8",
            "FUN_080098c0",
            "FUN_080027f4",
            "FUN_080003d4",
            "FUN_08004d78",
            "FUN_08000c10",
            "FUN_0800491c"
        ],
        [
            "FUN_0800071c",
            "FUN_080004c8"
        ],
        [
            "FUN_080014f0"
        ]
    ],
    "locked_functions": []
}