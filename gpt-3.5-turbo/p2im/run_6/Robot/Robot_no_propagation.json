{
    "functions": {
        "FUN_0800071c": {
            "renaming": {
                "FUN_0800071c": "calculate_floating_point_0800071c",
                "param_1": "sign",
                "param_2": "exponent",
                "param_3": "mantissaHigh",
                "param_4": "mantissaLow",
                "uVar1": "exponentMasked",
                "uVar2": "mantissaHighMasked",
                "uVar3": "mantissaLowShifted",
                "uVar4": "exponentDifference",
                "uVar5": "shiftedExponent",
                "uVar6": "mantissaHighShifted",
                "uVar7": "mantissaLowShifted",
                "iVar8": "exponentDiff",
                "uVar9": "exponentDiffNormalized",
                "unaff_r5": "mantissaLowNormalized",
                "uVar10": "exponentNormalized",
                "uVar11": "mantissaHighNormalized",
                "uVar12": "mantissaLowNormalized",
                "uVar13": "carry",
                "bVar14": "isZero",
                "bVar15": "isZeroEqual",
                "bVar16": "isCarry"
            },
            "code": "\nulonglong calculateFloatingPoint_0800071c(undefined4 sign,uint exponent,uint mantissaHigh,uint mantissaLow)\n\n{\n  uint exponentMasked;\n  uint mantissaHighMasked;\n  uint mantissaLowShifted;\n  uint exponentDifference;\n  uint shiftedExponent;\n  uint mantissaHighShifted;\n  uint mantissaLowShifted;\n  int exponentDiff;\n  uint exponentDiffNormalized;\n  uint mantissaLowNormalized;\n  uint exponentNormalized;\n  uint mantissaHighNormalized;\n  uint mantissaLowNormalized;\n  uint carry;\n  bool isZero;\n  bool isZeroEqual;\n  bool isCarry;\n  ulonglong exponentMasked7;\n  \n  exponentMasked7 = CONCAT44(exponent,sign);\n  carry = 0x7ff;\n  mantissaLowShifted = exponent >> 0x14 & 0x7ff;\n  isZero = mantissaLowShifted == 0;\n  if (!isZero) {\n    mantissaLowNormalized = mantissaLow >> 0x14 & 0x7ff;\n    isZero = mantissaLowNormalized == 0;\n  }\n  if (!isZero) {\n    isZero = mantissaLowShifted == 0x7ff;\n  }\n  if (!isZero) {\n    isZero = mantissaLowNormalized == 0x7ff;\n  }\n  if (isZero) {\n    exponentMasked7 = FUN_0800088a();\n  }\n  exponentDiffNormalized = (uint)(exponentMasked7 >> 0x20);\n  mantissaHighNormalized = (uint)exponentMasked7;\n  exponentDiff = mantissaLowShifted - mantissaLowNormalized;\n  if ((mantissaHigh | mantissaLow << 0xc) == 0) {\n    mantissaLowShifted = (exponentDiffNormalized ^ mantissaLow) & 0x80000000 | exponentDiffNormalized & 0xfffff;\n    isCarry = SCARRY4(exponentDiff,carry >> 1);\n    exponentDiffNormalized = exponentDiff + (carry >> 1);\n    isZero = (int)exponentDiffNormalized < 0;\n    isZeroEqual = exponentDiffNormalized == 0;\n    if (!isZeroEqual && isZero == isCarry) {\n      isCarry = SBORROW4(carry,exponentDiffNormalized);\n      isZero = (int)(carry - exponentDiffNormalized) < 0;\n      isZeroEqual = carry == exponentDiffNormalized;\n    }\n    if (!isZeroEqual && isZero == isCarry) {\n      mantissaLowShifted = mantissaLowShifted | exponentDiffNormalized * 0x100000;\n    }\n    if (!isZeroEqual && isZero == isCarry) {\n      return exponentMasked7 & 0xffffffff | (ulonglong)mantissaLowShifted << 0x20;\n    }\n    mantissaLowShifted = mantissaLowShifted | 0x100000;\n    carry = 0;\n    isZeroEqual = SBORROW4(exponentDiffNormalized,1);\n    exponentDiffNormalized = exponentDiffNormalized - 1;\n    isZero = exponentDiffNormalized == 0;\n    mantissaLowShifted = exponentDiffNormalized;\n  }\n  else {\n    mantissaLowShifted = (mantissaLow << 0xc) >> 4 | 0x10000000 | mantissaHigh >> 0x18;\n    carry = mantissaHigh << 8;\n    exponentNormalized = (exponentDiffNormalized << 0xc) >> 4 | 0x10000000 | mantissaHighNormalized >> 0x18;\n    mantissaHighNormalized = mantissaHighNormalized * 0x100;\n    mantissaLowShifted = (exponentDiffNormalized ^ mantissaLow) & 0x80000000;\n    isZero = mantissaLowShifted <= exponentNormalized;\n    if (exponentNormalized == mantissaLowShifted) {\n      isZero = carry <= mantissaHighNormalized;\n    }\n    exponentDiff = exponentDiff + (uint)isZero;\n    exponentDiffNormalized = exponentDiff + 0x3fd;\n    if (isZero == false) {\n      mantissaLowShifted = mantissaLowShifted >> 1;\n      carry = (uint)((mantissaHigh >> 0x18 & 1) != 0) << 0x1f | carry >> 1;\n    }\n    mantissaLowNormalized = mantissaHighNormalized - carry;\n    exponentNormalized = (exponentNormalized - mantissaLowShifted) - (uint)(mantissaHighNormalized < carry);\n    exponentDifference = mantissaLowShifted >> 1;\n    exponentMasked = (uint)((mantissaLowShifted & 1) != 0) << 0x1f | carry >> 1;\n    mantissaHighNormalized = 0x100000;\n    mantissaLowShifted = 0x80000;\n    while( true ) {\n      isZero = exponentMasked <= mantissaLowNormalized;\n      if (exponentDifference < exponentNormalized || exponentNormalized - exponentDifference < (uint)isZero) {\n        mantissaLowNormalized = mantissaLowNormalized - exponentMasked;\n        mantissaHighNormalized = mantissaHighNormalized | mantissaLowShifted;\n        exponentNormalized = (exponentNormalized - exponentDifference) - (uint)!isZero;\n      }\n      shiftedExponent = exponentDifference >> 1;\n      exponentMasked = (uint)((exponentDifference & 1) != 0) << 0x1f | exponentMasked >> 1;\n      isZeroEqual = exponentMasked <= mantissaLowNormalized;\n      isZero = exponentNormalized - shiftedExponent < (uint)isZeroEqual;\n      carry = exponentNormalized;\n      if (shiftedExponent < exponentNormalized || isZero) {\n        mantissaLowNormalized = mantissaLowNormalized - exponentMasked;\n        carry = (exponentNormalized - shiftedExponent) - (uint)!isZeroEqual;\n      }\n      if (shiftedExponent < exponentNormalized || isZero) {\n        mantissaHighNormalized = mantissaHighNormalized | mantissaLowShifted >> 1;\n      }\n      exponentNormalized = exponentDifference >> 2;\n      mantissaHighMasked = (uint)((shiftedExponent & 1) != 0) << 0x1f | exponentMasked >> 1;\n      isZeroEqual = mantissaHighMasked <= mantissaLowNormalized;\n      isZero = carry - exponentNormalized < (uint)isZeroEqual;\n      shiftedExponent = carry;\n      if (exponentNormalized < carry || isZero) {\n        mantissaLowNormalized = mantissaLowNormalized - mantissaHighMasked;\n        shiftedExponent = (carry - exponentNormalized) - (uint)!isZeroEqual;\n      }\n      if (exponentNormalized < carry || isZero) {\n        mantissaHighNormalized = mantissaHighNormalized | mantissaLowShifted >> 2;\n      }\n      mantissaHighShifted = exponentDifference >> 3;\n      exponentMasked = (uint)((exponentNormalized & 1) != 0) << 0x1f | mantissaHighMasked >> 1;\n      isZeroEqual = exponentMasked <= mantissaLowNormalized;\n      isZero = shiftedExponent - mantissaHighShifted < (uint)isZeroEqual;\n      exponentNormalized = shiftedExponent;\n      if (mantissaHighShifted < shiftedExponent || isZero) {\n        mantissaLowNormalized = mantissaLowNormalized - exponentMasked;\n        exponentNormalized = (shiftedExponent - mantissaHighShifted) - (uint)!isZeroEqual;\n      }\n      if (mantissaHighShifted < shiftedExponent || isZero) {\n        mantissaHighNormalized = mantissaHighNormalized | mantissaLowShifted >> 3;\n      }\n      carry = exponentNormalized | mantissaLowNormalized;\n      if (carry == 0) break;\n      exponentNormalized = exponentNormalized << 4 | mantissaLowNormalized >> 0x1c;\n      mantissaLowNormalized = mantissaLowNormalized << 4;\n      exponentDifference = exponentDifference & 0xfffffff8 | exponentMasked >> 0x1d;\n      exponentMasked = (mantissaHighMasked >> 1) << 3;\n      mantissaLowShifted = mantissaLowShifted >> 4;\n      if (mantissaLowShifted == 0) {\n        mantissaHighShifted = exponentDifference;\n        if ((mantissaLowShifted & 0x100000) != 0) goto LAB_0800083a;\n        mantissaLowShifted = mantissaLowShifted | mantissaHighNormalized;\n        mantissaHighNormalized = 0;\n        mantissaLowShifted = 0x80000000;\n      }\n    }\n    if ((mantissaLowShifted & 0x100000) == 0) {\n      mantissaLowShifted = mantissaLowShifted | mantissaHighNormalized;\n      mantissaHighNormalized = 0;\n    }\nLAB_0800083a:\n    isCarry = 0xfc < exponentDiffNormalized;\n    isZeroEqual = SBORROW4(exponentDiffNormalized,0xfd);\n    exponentDifference = exponentDiff + 0x300;\n    isZero = exponentDifference == 0;\n    mantissaLowShifted = exponentDifference;\n    if (isCarry && !isZero) {\n      isCarry = 0x6ff < exponentDifference;\n      isZeroEqual = SBORROW4(exponentDifference,0x700);\n      mantissaLowShifted = exponentDiff - 0x400;\n      isZero = exponentDifference == 0x700;\n    }\n    if (!isCarry || isZero) {\n      isZero = mantissaHighShifted <= exponentNormalized;\n      if (exponentNormalized == mantissaHighShifted) {\n        isZero = exponentMasked <= mantissaLowNormalized;\n      }\n      if (exponentNormalized == mantissaHighShifted && mantissaLowNormalized == exponentMasked) {\n        isZero = (mantissaHighNormalized & 1) != 0;\n      }\n      return CONCAT44(mantissaLowShifted + exponentDiffNormalized * 0x100000 + (uint)CARRY4(mantissaHighNormalized,(uint)isZero),mantissaHighNormalized + isZero);\n    }\n  }\n  if (!isZero && (int)mantissaLowShifted < 0 == isZeroEqual) {\n    return (ulonglong)(mantissaLowShifted & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  isCarry = SCARRY4(exponentDiffNormalized,0x36);\n  isZero = (int)(exponentDiffNormalized + 0x36) < 0;\n  isZeroEqual = exponentDiffNormalized == 0xffffffca;\n  if (isZeroEqual || isZero != isCarry) {\n    mantissaHighNormalized = 0;\n  }\n  if (isZeroEqual || isZero != isCarry) {\n    mantissaLowShifted = mantissaLowShifted & 0x80000000;\n  }\n  if (isZeroEqual || isZero != isCarry) {\n    return CONCAT44(mantissaLowShifted,mantissaHighNormalized);\n  }\n  mantissaLowShifted = -exponentDiffNormalized;\n  exponentNormalized = mantissaLowShifted - 0x20;\n  if (0x1f < (int)mantissaLowShifted) {\n    mantissaLowShifted = mantissaHighNormalized >> (exponentNormalized & 0xff) | mantissaLowShifted << (0x20 - exponentNormalized & 0xff);\n    exponentDiffNormalized = (mantissaLowShifted >> (exponentNormalized & 0xff) & ~((mantissaLowShifted & 0x80000000) >> (exponentNormalized & 0xff))) -\n            ((int)mantissaLowShifted >> 0x1f);\n    if ((carry | mantissaHighNormalized << (0x20 - exponentNormalized & 0xff) | mantissaLowShifted << 1) == 0) {\n      exponentDiffNormalized = exponentDiffNormalized & ~(mantissaLowShifted >> 0x1f);\n    }\n    return CONCAT44(mantissaLowShifted,exponentDiffNormalized) & 0x80000000ffffffff;\n  }\n  exponentDiff = mantissaLowShifted - 0x14;\n  if (exponentDiff != 0 && exponentDiff < 0 == SCARRY4(exponentNormalized,0xc)) {\n    exponentDiffNormalized = 0xc - exponentDiff;\n    mantissaLowShifted = mantissaHighNormalized << (exponentDiffNormalized & 0xff);\n    mantissaHighNormalized = mantissaHighNormalized >> (0x20 - exponentDiffNormalized & 0xff) | mantissaLowShifted << (exponentDiffNormalized & 0xff);\n    exponentDiffNormalized = mantissaHighNormalized + -((int)mantissaLowShifted >> 0x1f);\n    if ((carry | mantissaLowShifted << 1) == 0) {\n      exponentDiffNormalized = exponentDiffNormalized & ~(mantissaLowShifted >> 0x1f);\n    }\n    return CONCAT44((mantissaLowShifted & 0x80000000) + (uint)CARRY4(mantissaHighNormalized,-((int)mantissaLowShifted >> 0x1f)),exponentDiffNormalized);\n  }\n  exponentNormalized = mantissaHighNormalized << (exponentDiffNormalized + 0x20 & 0xff);\n  mantissaHighNormalized = mantissaHighNormalized >> (mantissaLowShifted & 0xff) | mantissaLowShifted << (exponentDiffNormalized + 0x20 & 0xff);\n  exponentDiffNormalized = mantissaHighNormalized + -((int)exponentNormalized >> 0x1f);\n  if ((carry | exponentNormalized << 1) == 0) {\n    exponentDiffNormalized = exponentDiffNormalized & ~(exponentNormalized >> 0x1f);\n  }\n  return CONCAT44((mantissaLowShifted & 0x80000000) +\n                  ((mantissaLowShifted & 0x7fffffff) >> (mantissaLowShifted & 0xff)) +\n                  (uint)CARRY4(mantissaHighNormalized,-((int)exponentNormalized >> 0x1f)),exponentDiffNormalized);\n}\n\n",
            "called": [
                "FUN_0800088a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800071c",
            "calling": [
                "FUN_08005838",
                "FUN_08004d78",
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "calculate_floating_point_0800071c"
        },
        "FUN_080036a8": {
            "renaming": {
                "FUN_080036a8": "set_flag_and_enable_080036a8",
                "param_1": "ptr_to_uint_ptr",
                "param_2": "flag_value"
            },
            "code": "\nundefined4 set_flag_and_enable_080036a8(uint **ptr_to_uint_ptr,undefined4 flag_value)\n\n{\n  FUN_080041ea(*ptr_to_uint_ptr,flag_value,1);\n  if (*ptr_to_uint_ptr == DAT_080036f4) {\n    (*ptr_to_uint_ptr)[0x11] = (*ptr_to_uint_ptr)[0x11] | 0x8000;\n  }\n  **ptr_to_uint_ptr = **ptr_to_uint_ptr | 1;\n  return 0;\n}\n\n",
            "called": [
                "FUN_080041ea"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036a8",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "set_flag_and_enable_080036a8"
        },
        "FUN_080088ec": {
            "renaming": {
                "FUN_080088ec": "allocate_memory_block_080088ec",
                "param_1": "context",
                "param_2": "size",
                "param_3": "unknown_parameter_1",
                "param_4": "unknown_parameter_2",
                "iVar1": "next_block",
                "iVar2": "current_block",
                "puVar3": "block_to_coalesce",
                "uVar4": "temp_var_1",
                "uVar5": "block_size",
                "uVar6": "block_header_size",
                "puVar7": "previous_block",
                "puVar8": "memory_manager",
                "puVar9": "next_free_block",
                "uVar10": "temp_var_2",
                "iVar11": "previous_free_block"
            },
            "code": "\nvoid allocate_memory_block_080088ec(undefined4 context,int size,undefined4 unknown_parameter_1,undefined4 unknown_parameter_2)\n\n{\n  int next_block;\n  int current_block;\n  uint *block_to_coalesce;\n  uint temp_var_1;\n  uint block_size;\n  uint block_header_size;\n  undefined *previous_block;\n  undefined *memory_manager;\n  undefined *next_free_block;\n  uint temp_var_2;\n  int previous_free_block;\n  \n  if (size == 0) {\n    return;\n  }\n  FUN_080090a8();\n  memory_manager = PTR_DAT_08008ac4;\n  temp_var_2 = *(uint *)(size + -4);\n  current_block = size + -8;\n  block_size = temp_var_2 & 0xfffffffe;\n  block_to_coalesce = (uint *)(current_block + block_size);\n  block_header_size = block_to_coalesce[1] & 0xfffffffc;\n  if (*(uint **)(PTR_DAT_08008ac4 + 8) == block_to_coalesce) {\n    block_size = block_size + block_header_size;\n    if ((temp_var_2 & 1) == 0) {\n      current_block = current_block - *(int *)(size + -8);\n      previous_free_block = *(int *)(current_block + 8);\n      next_block = *(int *)(current_block + 0xc);\n      block_size = block_size + *(int *)(size + -8);\n      *(int *)(previous_free_block + 0xc) = next_block;\n      *(int *)(next_block + 8) = previous_free_block;\n    }\n    block_header_size = *(uint *)PTR_DAT_08008acc;\n    *(uint *)(current_block + 4) = block_size | 1;\n    *(int *)(memory_manager + 8) = current_block;\n    if (block_header_size <= block_size) {\n      FUN_0800884c(context,*(undefined4 *)PTR_DAT_08008ad0);\n    }\nLAB_080089f0:\n    FUN_080090b4(context);\n    return;\n  }\n  block_to_coalesce[1] = block_header_size;\n  if ((temp_var_2 & 1) == 0) {\n    current_block = current_block - *(int *)(size + -8);\n    next_free_block = *(undefined **)(current_block + 8);\n    block_size = block_size + *(int *)(size + -8);\n    temp_var_2 = *(uint *)((int)block_to_coalesce + block_header_size + 4) & 1;\n    if (next_free_block == memory_manager + 8) {\n      if (temp_var_2 == 0) {\n        temp_var_2 = block_to_coalesce[2];\n        temp_var_1 = block_to_coalesce[3];\n        block_size = block_size + block_header_size;\n        *(uint *)(temp_var_2 + 0xc) = temp_var_1;\n        *(uint *)(temp_var_1 + 8) = temp_var_2;\n        *(uint *)(current_block + 4) = block_size | 1;\n        *(uint *)(current_block + block_size) = block_size;\n      }\n      else {\n        *(uint *)(current_block + 4) = block_size | 1;\n        *block_to_coalesce = block_size;\n      }\n      goto LAB_080089f0;\n    }\n    previous_free_block = *(int *)(current_block + 0xc);\n    *(int *)(next_free_block + 0xc) = previous_free_block;\n    *(undefined **)(previous_free_block + 8) = next_free_block;\n  }\n  else {\n    temp_var_2 = *(uint *)((int)block_to_coalesce + block_header_size + 4) & 1;\n  }\n  if (temp_var_2 == 0) {\n    next_free_block = (undefined *)block_to_coalesce[2];\n    block_size = block_size + block_header_size;\n    if (next_free_block == PTR_PTR_DAT_08008ac8) {\n      *(int *)(memory_manager + 0x10) = current_block;\n      *(int *)(memory_manager + 0x14) = current_block;\n      *(undefined **)(current_block + 8) = next_free_block;\n      *(undefined **)(current_block + 0xc) = next_free_block;\n      *(uint *)(current_block + 4) = block_size | 1;\n      *(uint *)(current_block + block_size) = block_size;\n      goto LAB_080089f0;\n    }\n    block_header_size = block_to_coalesce[3];\n    *(uint *)(next_free_block + 0xc) = block_header_size;\n    *(undefined **)(block_header_size + 8) = next_free_block;\n    *(uint *)(current_block + 4) = block_size | 1;\n    *(uint *)(current_block + block_size) = block_size;\n  }\n  else {\n    *(uint *)(current_block + 4) = block_size | 1;\n    *(uint *)(current_block + block_size) = block_size;\n  }\n  if (block_size < 0x200) {\n    previous_free_block = (block_size >> 3) + 1;\n    block_size = 1 << ((int)(block_size >> 3) >> 2 & 0xffU) | *(uint *)(memory_manager + 4);\n    next_block = *(int *)(memory_manager + previous_free_block * 8);\n    *(int *)(current_block + 8) = next_block;\n    *(undefined **)(current_block + 0xc) = memory_manager + previous_free_block * 8 + -8;\n    *(uint *)(memory_manager + 4) = block_size;\n    *(int *)(memory_manager + previous_free_block * 8) = current_block;\n    *(int *)(next_block + 0xc) = current_block;\n    FUN_080090b4(context,current_block,block_size,unknown_parameter_2);\n    return;\n  }\n  block_header_size = block_size >> 9;\n  if (block_header_size < 5) {\n    previous_free_block = ((block_size >> 6) + 0x39) * 8;\n    next_block = (block_size >> 6) + 0x38;\n  }\n  else if (block_header_size < 0x15) {\n    previous_free_block = (block_header_size + 0x5c) * 8;\n    next_block = block_header_size + 0x5b;\n  }\n  else if (block_header_size < 0x55) {\n    previous_free_block = ((block_size >> 0xc) + 0x6f) * 8;\n    next_block = (block_size >> 0xc) + 0x6e;\n  }\n  else if (block_header_size < 0x155) {\n    previous_free_block = ((block_size >> 0xf) + 0x78) * 8;\n    next_block = (block_size >> 0xf) + 0x77;\n  }\n  else if (block_header_size < 0x555) {\n    previous_free_block = ((block_size >> 0x12) + 0x7d) * 8;\n    next_block = (block_size >> 0x12) + 0x7c;\n  }\n  else {\n    previous_free_block = 0x3f8;\n    next_block = 0x7e;\n  }\n  next_free_block = *(undefined **)(memory_manager + previous_free_block);\n  previous_block = memory_manager + previous_free_block + -8;\n  if (previous_block == next_free_block) {\n    next_free_block = (undefined *)(1 << (next_block >> 2 & 0xffU) | *(uint *)(memory_manager + 4));\n    *(undefined **)(memory_manager + 4) = next_free_block;\n    memory_manager = previous_block;\n  }\n  else {\n    do {\n      memory_manager = next_free_block;\n      if ((*(uint *)(next_free_block + 4) & 0xfffffffc) <= block_size) break;\n      next_free_block = *(undefined **)(next_free_block + 8);\n      memory_manager = previous_block;\n    } while (previous_block != next_free_block);\n    previous_block = *(undefined **)(memory_manager + 0xc);\n  }\n  *(undefined **)(current_block + 8) = memory_manager;\n  *(undefined **)(current_block + 0xc) = previous_block;\n  *(int *)(previous_block + 8) = current_block;\n  *(int *)(memory_manager + 0xc) = current_block;\n  FUN_080090b4(context,current_block,next_free_block,unknown_parameter_2);\n  return;\n}\n\n",
            "called": [
                "FUN_080090a8",
                "FUN_080090b4",
                "FUN_0800884c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080088ec",
            "calling": [
                "FUN_08009adc",
                "FUN_08005e9c",
                "FUN_08008af8",
                "FUN_080097cc"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_080088ec"
        },
        "FUN_08005224": {
            "renaming": {
                "FUN_08005224": "initialize_system_08005224"
            },
            "code": "\nvoid initialize_system_08005224(void)\n\n{\n  FUN_080014f0();\n  FUN_080052a0();\n  FUN_080055f4();\n  FUN_08005348();\n  FUN_08005598();\n  FUN_08005500();\n  FUN_080053b0();\n  *(undefined **)PTR_DAT_0800527c = PTR_FUN_08004ea4_1_08005280;\n  *(undefined **)PTR_DAT_08005284 = PTR_FUN_08004ee8_1_08005288;\n  *(undefined **)PTR_DAT_0800528c = PTR_FUN_08004f2c_1_08005290;\n  FUN_080036a8(PTR_DAT_08005294,0);\n  FUN_080036a8(PTR_DAT_08005294,0xc);\n  FUN_0800491c(PTR_DAT_08005298);\n  FUN_0800360c(PTR_DAT_0800529c);\n  FUN_08004e74(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "FUN_08005348",
                "FUN_08005598",
                "FUN_08004e74",
                "FUN_080055f4",
                "FUN_080052a0",
                "FUN_0800360c",
                "FUN_080053b0",
                "FUN_08005500",
                "FUN_080036a8",
                "FUN_080014f0",
                "FUN_0800491c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005224",
            "calling": [
                "FUN_080057e8"
            ],
            "imported": false,
            "current_name": "initialize_system_08005224"
        },
        "FUN_08003440": {
            "renaming": {
                "FUN_08003440": "calculate_value_08003440",
                "local_30": "short_value",
                "local_2c": "first_value",
                "uStack_28": "second_value",
                "uStack_24": "third_value",
                "uStack_20": "fourth_value",
                "local_1c": "result",
                "local_18": "zero_value",
                "local_14": "input_value",
                "local_10": "final_value"
            },
            "code": "\nuint calculate_value_08003440(void)\n\n{\n  undefined2 short_value;\n  undefined4 first_value;\n  undefined4 second_value;\n  undefined4 third_value;\n  undefined4 fourth_value;\n  uint result;\n  undefined4 zero_value;\n  uint input_value;\n  uint final_value;\n  uint local_c;\n  \n  first_value = *(undefined4 *)PTR_DAT_080034f0;\n  second_value = *(undefined4 *)(PTR_DAT_080034f0 + 4);\n  third_value = *(undefined4 *)(PTR_DAT_080034f0 + 8);\n  fourth_value = *(undefined4 *)(PTR_DAT_080034f0 + 0xc);\n  short_value = *(undefined2 *)PTR_DAT_080034f4;\n  zero_value = 0;\n  local_c = 0;\n  result = 0;\n  final_value = 0;\n  input_value = *(uint *)(DAT_080034f8 + 4);\n  if ((input_value & 0xc) == 4) {\n    final_value = DAT_080034fc;\n  }\n  else if ((input_value & 0xc) == 8) {\n    result = (uint)*(byte *)((int)&first_value + (input_value >> 0x12 & 0xf));\n    if ((input_value & 0x10000) == 0) {\n      local_c = DAT_08003500 * result;\n    }\n    else {\n      local_c = (DAT_080034fc * result) /\n                (uint)*(byte *)((int)&short_value + (*(uint *)(DAT_080034f8 + 4) >> 0x11 & 1));\n    }\n    final_value = local_c;\n  }\n  else {\n    final_value = DAT_080034fc;\n  }\n  return final_value;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003440",
            "calling": [
                "FUN_08003260"
            ],
            "imported": false,
            "current_name": "calculate_value_08003440"
        },
        "FUN_080035fa": {
            "renaming": {
                "FUN_080035fa": "FUNC_080035fa"
            },
            "code": "\nvoid FUNC_080035fa(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080035fa",
            "calling": [
                "FUN_080035a4"
            ],
            "imported": false,
            "current_name": "FUNC_080035fa"
        },
        "FUN_08004f2c": {
            "renaming": {
                "FUN_08004f2c": "get_result_08004f2c",
                "uVar1": "result"
            },
            "code": "\nundefined4 get_result_08004f2c(void)\n\n{\n  undefined4 result;\n  \n  result = FUN_080015a0();\n  return result;\n}\n\n",
            "called": [
                "FUN_080015a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f2c",
            "calling": [],
            "imported": false,
            "current_name": "get_result_08004f2c"
        },
        "FUN_08005348": {
            "renaming": {
                "FUN_08005348": "initialize_data_structures_08005348"
            },
            "code": "\nvoid initialize_data_structures_08005348(void)\n\n{\n  int iVar1;\n  \n  *(undefined4 *)PTR_DAT_080053a0 = DAT_080053a4;\n  *(undefined4 *)(PTR_DAT_080053a0 + 4) = DAT_080053a8;\n  *(undefined4 *)(PTR_DAT_080053a0 + 8) = 0;\n  *(undefined4 *)(PTR_DAT_080053a0 + 0xc) = 0;\n  *(undefined4 *)(PTR_DAT_080053a0 + 0x10) = 0x4000;\n  *(undefined4 *)(PTR_DAT_080053a0 + 0x14) = 0;\n  *(undefined4 *)(PTR_DAT_080053a0 + 0x18) = 0;\n  *(undefined4 *)(PTR_DAT_080053a0 + 0x1c) = 0;\n  *(undefined4 *)(PTR_DAT_080053a0 + 0x20) = 0;\n  iVar1 = FUN_08001ab0(PTR_DAT_080053a0);\n  if (iVar1 != 0) {\n    FUN_08005674(PTR_s____src_main_c_080053ac,0x17a);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08001ab0",
                "FUN_08005674"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005348",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "initialize_data_structures_08005348"
        },
        "FUN_08004378": {
            "renaming": {
                "FUN_08004378": "FUNC_08004378"
            },
            "code": "\nvoid FUNC_08004378(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08004378",
            "calling": [
                "FUN_080036f8"
            ],
            "imported": false,
            "current_name": "FUNC_08004378"
        },
        "FUN_080046ec": {
            "renaming": {
                "FUN_080046ec": "calculate_checksum_080046ec",
                "param_1": "checksum_data",
                "lVar1": "first_calculation_result",
                "lVar2": "second_calculation_result",
                "iVar3": "temp_variable_1",
                "iVar4": "temp_variable_2",
                "iVar5": "temp_variable_3",
                "uVar6": "random_number"
            },
            "code": "\nvoid calculate_checksum_080046ec(int *checksum_data)\n\n{\n  longlong first_calculation_result;\n  longlong second_calculation_result;\n  int temp_variable_1;\n  int temp_variable_2;\n  int temp_variable_3;\n  undefined8 random_number;\n  \n  *(uint *)(*checksum_data + 0x10) = checksum_data[3] | *(uint *)(*checksum_data + 0x10) & 0xffffcfff;\n  *(uint *)(*checksum_data + 0xc) =\n       *(uint *)(*checksum_data + 0xc) & 0xffffe9f3 | checksum_data[5] | checksum_data[2] | checksum_data[4];\n  *(uint *)(*checksum_data + 0x14) = checksum_data[6] | *(uint *)(*checksum_data + 0x14) & 0xfffffcff;\n  if (*checksum_data == DAT_08004914) {\n    random_number = FUN_08003540();\n    first_calculation_result = (ulonglong)DAT_08004918 *\n            ((ulonglong)(uint)((int)random_number * 0x19) / (ulonglong)(uint)(checksum_data[1] << 2));\n    temp_variable_1 = FUN_08003540((int)random_number,(int)((ulonglong)random_number >> 0x20),(int)first_calculation_result);\n    temp_variable_2 = checksum_data[1];\n    random_number = FUN_08003540();\n    second_calculation_result = (ulonglong)DAT_08004918 *\n            (ulonglong)\n            (((uint)(temp_variable_1 * 0x19) / (uint)(temp_variable_2 << 2) +\n             (uint)((ulonglong)DAT_08004918 *\n                    ((ulonglong)(uint)((int)random_number * 0x19) / (ulonglong)(uint)(checksum_data[1] << 2)) >>\n                   0x25) * -100) * 0x10 + 0x32);\n    temp_variable_1 = FUN_08003540((int)random_number,(int)((ulonglong)random_number >> 0x20),(int)second_calculation_result);\n    temp_variable_3 = checksum_data[1];\n    temp_variable_2 = FUN_08003540();\n    *(uint *)(*checksum_data + 8) =\n         ((uint)((ulonglong)DAT_08004918 *\n                 (ulonglong)\n                 (((uint)(temp_variable_1 * 0x19) / (uint)(temp_variable_3 << 2) +\n                  (uint)((ulonglong)DAT_08004918 *\n                         ((ulonglong)(uint)(temp_variable_2 * 0x19) / (ulonglong)(uint)(checksum_data[1] << 2)) >>\n                        0x25) * -100) * 0x10 + 0x32) >> 0x25) & 0xf) +\n         (uint)((ulonglong)first_calculation_result >> 0x25) * 0x10 + ((uint)((ulonglong)second_calculation_result >> 0x25) & 0xf0);\n  }\n  else {\n    random_number = FUN_08003518();\n    first_calculation_result = (ulonglong)DAT_08004918 *\n            ((ulonglong)(uint)((int)random_number * 0x19) / (ulonglong)(uint)(checksum_data[1] << 2));\n    temp_variable_1 = FUN_08003518((int)random_number,(int)((ulonglong)random_number >> 0x20),(int)first_calculation_result);\n    temp_variable_2 = checksum_data[1];\n    random_number = FUN_08003518();\n    second_calculation_result = (ulonglong)DAT_08004918 *\n            (ulonglong)\n            (((uint)(temp_variable_1 * 0x19) / (uint)(temp_variable_2 << 2) +\n             (uint)((ulonglong)DAT_08004918 *\n                    ((ulonglong)(uint)((int)random_number * 0x19) / (ulonglong)(uint)(checksum_data[1] << 2)) >>\n                   0x25) * -100) * 0x10 + 0x32);\n    temp_variable_1 = FUN_08003518((int)random_number,(int)((ulonglong)random_number >> 0x20),(int)second_calculation_result);\n    temp_variable_3 = checksum_data[1];\n    temp_variable_2 = FUN_08003518();\n    *(uint *)(*checksum_data + 8) =\n         ((uint)((ulonglong)DAT_08004918 *\n                 (ulonglong)\n                 (((uint)(temp_variable_1 * 0x19) / (uint)(temp_variable_3 << 2) +\n                  (uint)((ulonglong)DAT_08004918 *\n                         ((ulonglong)(uint)(temp_variable_2 * 0x19) / (ulonglong)(uint)(checksum_data[1] << 2)) >>\n                        0x25) * -100) * 0x10 + 0x32) >> 0x25) & 0xf) +\n         (uint)((ulonglong)first_calculation_result >> 0x25) * 0x10 + ((uint)((ulonglong)second_calculation_result >> 0x25) & 0xf0);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08003518",
                "FUN_08003540"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080046ec",
            "calling": [
                "FUN_0800438a"
            ],
            "imported": false,
            "current_name": "calculate_checksum_080046ec"
        },
        "FUN_08005500": {
            "renaming": {
                "FUN_08005500": "initialize_memory_and_resources_08005500",
                "local_20": "page_size",
                "local_1c": "offset",
                "local_18": "mem_protect_info"
            },
            "code": "\nvoid initialize_memory_and_resources_08005500(void)\n\n{\n  int iVar1;\n  undefined4 page_size;\n  undefined4 offset;\n  undefined4 mem_protect_info [4];\n  \n  *(undefined4 *)PTR_DAT_08005590 = 0x40000000;\n  *(undefined4 *)(PTR_DAT_08005590 + 4) = 36000;\n  *(undefined4 *)(PTR_DAT_08005590 + 8) = 0;\n  *(undefined4 *)(PTR_DAT_08005590 + 0xc) = 0x14;\n  *(undefined4 *)(PTR_DAT_08005590 + 0x10) = 0;\n  *(undefined4 *)(PTR_DAT_08005590 + 0x18) = 0;\n  iVar1 = FUN_080035a4(PTR_DAT_08005590);\n  if (iVar1 != 0) {\n    FUN_08005674(PTR_s____src_main_c_08005594,0x1d0);\n  }\n  mem_protect_info[0] = 0x1000;\n  iVar1 = FUN_08003a94(PTR_DAT_08005590,mem_protect_info);\n  if (iVar1 != 0) {\n    FUN_08005674(PTR_s____src_main_c_08005594,0x1d5);\n  }\n  page_size = 0x20;\n  offset = 0;\n  iVar1 = FUN_080042de(PTR_DAT_08005590,&page_size);\n  if (iVar1 != 0) {\n    FUN_08005674(PTR_s____src_main_c_08005594,0x1dc);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08003a94",
                "FUN_080042de",
                "FUN_08005674",
                "FUN_080035a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005500",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "initialize_memory_and_resources_08005500"
        },
        "FUN_08002c2e": {
            "renaming": {
                "FUN_08002c2e": "check_for_completion_08002c2e",
                "param_1": "status",
                "param_2": "total_size",
                "param_3": "current_size",
                "iVar1": "result",
                "&": "BITWISE_AND",
                "==": "EQUALS",
                "!=": "NOT_EQUALS",
                "true": "TRUE"
            },
            "code": "\nundefined4 check_for_completion_08002c2e(int *status,uint total_size,int current_size)\n\n{\n  int result;\n  \n  while( TRUE ) {\n    if ((*(uint *)(*status + 0x14) BITWISE_AND 4) EQUALS 4) {\n      return 0;\n    }\n    result = FUN_08002d3c(status);\n    if (result NOT_EQUALS 0) break;\n    if ((total_size NOT_EQUALS 0xffffffff) BITWISE_ANDBITWISE_AND\n       ((total_size EQUALS 0 || (result = FUN_080015a0(), total_size < (uint)(result - current_size))))) {\n      status[0x10] = status[0x10] | 0x20;\n      status[0xc] = 0;\n      *(undefined *)((int)status + 0x3d) = 0x20;\n      *(undefined *)(status + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "called": [
                "FUN_080015a0",
                "FUN_08002d3c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c2e",
            "calling": [
                "FUN_08001ccc"
            ],
            "imported": false,
            "current_name": "check_for_completion_08002c2e"
        },
        "FUN_08003568": {
            "renaming": {
                "FUN_08003568": "countdown_08003568",
                "param_1": "num_iterations",
                "local_c": "countdown_counter",
                "bVar1": "is_countdown_not_finished"
            },
            "code": "\nvoid countdown_08003568(int num_iterations)\n\n{\n  bool is_countdown_08003568_not_finished;\n  int countdown_08003568_counter;\n  \n  countdown_08003568_counter = num_iterations * (uint)((ulonglong)DAT_080035a0 * (ulonglong)*(uint *)PTR_DAT_0800359c >> 0x29)\n  ;\n  do {\n    is_countdown_08003568_not_finished = countdown_08003568_counter != 0;\n    countdown_08003568_counter = countdown_08003568_counter + -1;\n  } while (is_countdown_08003568_not_finished);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003568",
            "calling": [
                "FUN_08002d98"
            ],
            "imported": false,
            "current_name": "countdown_08003568"
        },
        "FUN_080049cc": {
            "renaming": {
                "FUN_080049cc": "calculate_statistics_080049cc",
                "param_1": "input_data",
                "local_2c": "sum_of_second_values",
                "local_28": "sum_of_first_values",
                "local_24": "get_random_value",
                "local_20": "number_of_elements",
                "local_1c": "current_element_index",
                "local_18": "sum_of_first_values_squared",
                "local_14": "sum_of_second_values_squared",
                "local_10": "sum_of_first_and_second_values_product",
                "local_c": "sum_of_third_values"
            },
            "code": "\nvoid calculate_statistics_080049cc(int input_data)\n\n{\n  undefined4 uVar1;\n  undefined4 sum_of_second_values;\n  undefined4 sum_of_first_values;\n  undefined4 get_random_value;\n  int number_of_elements;\n  int current_element_index;\n  undefined4 sum_of_first_values_squared;\n  undefined4 sum_of_second_values_squared;\n  undefined4 sum_of_first_and_second_values_product;\n  undefined4 sum_of_third_values;\n  \n  number_of_elements = 1;\n  sum_of_third_values = 0;\n  sum_of_first_and_second_values_product = 0;\n  sum_of_second_values_squared = 0;\n  sum_of_first_values_squared = 0;\n  get_random_value = (**(code **)PTR_DAT_08004adc)();\n  current_element_index = 0;\n  while( true ) {\n    if (number_of_elements <= current_element_index) break;\n    sum_of_first_values = 0;\n    sum_of_second_values = 0;\n    FUN_08004ae0(input_data);\n    FUN_08004d78(input_data,&sum_of_first_values,&sum_of_second_values);\n    sum_of_second_values_squared = FUN_08000aa8(sum_of_second_values_squared,sum_of_first_values);\n    sum_of_first_values_squared = FUN_08000aa8(sum_of_first_values_squared,sum_of_second_values);\n    sum_of_third_values = FUN_08000aa8(sum_of_third_values,*(undefined4 *)(input_data + 0x10));\n    sum_of_first_and_second_values_product = FUN_08000aa8(sum_of_first_and_second_values_product,*(undefined4 *)(input_data + 0x14));\n    get_random_value = (**(code **)PTR_DAT_08004adc)();\n    current_element_index = current_element_index + 1;\n  }\n  uVar1 = FUN_08000c10(number_of_elements);\n  uVar1 = FUN_08000e20(sum_of_third_values,uVar1);\n  *(undefined4 *)(input_data + 0x1c) = uVar1;\n  uVar1 = FUN_08000c10(number_of_elements);\n  uVar1 = FUN_08000e20(sum_of_first_and_second_values_product,uVar1);\n  *(undefined4 *)(input_data + 0x20) = uVar1;\n  uVar1 = FUN_08000c10(number_of_elements);\n  uVar1 = FUN_08000e20(sum_of_second_values_squared,uVar1);\n  *(undefined4 *)(input_data + 0x24) = uVar1;\n  uVar1 = FUN_08000c10(number_of_elements);\n  uVar1 = FUN_08000e20(sum_of_first_values_squared,uVar1);\n  *(undefined4 *)(input_data + 0x28) = uVar1;\n  return;\n}\n\n",
            "called": [
                "FUN_08004ae0",
                "FUN_08000e20",
                "FUN_08000aa8",
                "FUN_08004d78",
                "FUN_08000c10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080049cc",
            "calling": [
                "FUN_0800491c"
            ],
            "imported": false,
            "current_name": "calculate_statistics_080049cc"
        },
        "FUN_08003c94": {
            "renaming": {
                "FUN_08003c94": "update_parameters_08003c94",
                "param_1": "current_params",
                "param_2": "new_params",
                "local_c": "current_value",
                "param_2[1]": "new_params_value_1",
                "param_2[3]": "new_params_value_2",
                "param_2[5]": "new_params_value_3",
                "param_2[2]": "new_params_value_4",
                "param_2[4]": "new_params_value_6",
                "param_1[0xb]": "special_value_1",
                "param_1[10]": "special_value_2",
                "param_1[0xc]": "special_value_3"
            },
            "code": "\nvoid update_parameters_08003c94(uint *current_params,uint *new_params)\n\n{\n  uint current_value;\n  \n  current_value = *current_params;\n  if ((((current_params == DAT_08003d54) || (current_params == (uint *)0x40000000)) || (current_params == DAT_08003d58))\n     || (current_params == DAT_08003d5c)) {\n    current_value = new_params_value_1 | current_value & 0xffffff8f;\n  }\n  if (((current_params == DAT_08003d54) || (current_params == (uint *)0x40000000)) ||\n     ((current_params == DAT_08003d58 || (current_params == DAT_08003d5c)))) {\n    current_value = new_params_value_2 | current_value & 0xfffffcff;\n  }\n  *current_params = new_params_value_3 | current_value & 0xffffff7f;\n  special_value_1 = new_params_value_4;\n  special_value_2 = *new_params;\n  if (current_params == DAT_08003d54) {\n    special_value_3 = new_params_value_6;\n  }\n  current_params[5] = 1;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003c94",
            "calling": [
                "FUN_08003640",
                "FUN_080035a4"
            ],
            "imported": false,
            "current_name": "update_parameters_08003c94"
        },
        "FUN_08000978": {
            "renaming": {
                "FUN_08000978": "execute_function_with_swapped_params_08000978",
                "param_1": "param_to_swap_1",
                "param_2": "param_to_swap_2",
                "param_3": "param_to_execute_1",
                "param_4": "param_to_execute_2"
            },
            "code": "\nvoid execute_function_with_swapped_params_08000978(undefined4 param_to_swap_1,undefined4 param_to_swap_2,undefined4 param_to_execute_1,undefined4 param_to_execute_2)\n\n{\n  FUN_08000988(param_to_execute_1,param_to_execute_2,param_to_swap_1,param_to_swap_2);\n  return;\n}\n\n",
            "called": [
                "FUN_08000988"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000978",
            "calling": [
                "FUN_080009d4",
                "FUN_080009e8"
            ],
            "imported": false,
            "current_name": "execute_function_with_swapped_params_08000978"
        },
        "FUN_0800884c": {
            "renaming": {
                "FUN_0800884c": "memory_allocation_0800884c",
                "param_1": "memory_address",
                "param_2": "size",
                "puVar1": "data_pointer",
                "puVar2": "data_pointer_2",
                "iVar3": "result",
                "iVar4": "adjusted_size",
                "uVar5": "mask"
            },
            "code": "\nundefined4 memory_allocation_0800884c(undefined4 memory_address,int size)\n\n{\n  undefined *data_pointer;\n  undefined *data_pointer_2;\n  int result;\n  int adjusted_size;\n  uint mask;\n  \n  data_pointer = PTR_DAT_080088e0;\n  FUN_080090a8();\n  mask = *(uint *)(*(int *)(data_pointer + 8) + 4) & 0xfffffffc;\n  adjusted_size = ((0xfef - size) + mask & 0xfffff000) - 0x1000;\n  if (0xfff < adjusted_size) {\n    result = FUN_08009744(memory_address,0);\n    if (result == *(int *)(data_pointer + 8) + mask) {\n      result = FUN_08009744(memory_address,-adjusted_size);\n      data_pointer_2 = PTR_DAT_080088e4;\n      if (result != -1) {\n        result = *(int *)PTR_DAT_080088e4;\n        *(uint *)(*(int *)(data_pointer + 8) + 4) = mask - adjusted_size | 1;\n        *(int *)data_pointer_2 = result - adjusted_size;\n        FUN_080090b4(memory_address);\n        return 1;\n      }\n      adjusted_size = FUN_08009744(memory_address,0);\n      data_pointer_2 = PTR_DAT_080088e4;\n      mask = adjusted_size - *(int *)(data_pointer + 8);\n      if (0xf < (int)mask) {\n        result = *(int *)PTR_DAT_080088e8;\n        *(uint *)(*(int *)(data_pointer + 8) + 4) = mask | 1;\n        *(int *)data_pointer_2 = adjusted_size - result;\n      }\n    }\n  }\n  FUN_080090b4(memory_address);\n  return 0;\n}\n\n",
            "called": [
                "FUN_08009744",
                "FUN_080090a8",
                "FUN_080090b4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800884c",
            "calling": [
                "FUN_080088ec"
            ],
            "imported": false,
            "current_name": "memory_allocation_0800884c"
        },
        "FUN_0800901c": {
            "renaming": {
                "FUN_0800901c": "find_byte_sequence_0800901c",
                "param_1": "data_pointer",
                "param_2": "data_length",
                "param_3": "byte_sequence",
                "puVar1": "data_pointer_aligned",
                "uVar2": "byte_sequence_mask",
                "uVar3": "data_xor_masked",
                "puVar4": "data_pointer_aligned_loop",
                "uVar5": "byte_to_find",
                "bVar6": "end_of_byte_sequence_reached"
            },
            "code": "\nuint * find_byte_sequence_0800901c(uint *data_pointer,uint data_length,uint *byte_sequence)\n\n{\n  uint *data_pointer_aligned;\n  uint byte_sequence_mask;\n  uint data_xor_masked;\n  uint *data_pointer_aligned_loop;\n  uint byte_to_find;\n  bool end_of_byte_sequence_reached;\n  \n  byte_to_find = data_length & 0xff;\n  data_pointer_aligned = data_pointer;\n  if (((uint)data_pointer & 3) == 0) {\nLAB_0800904a:\n    data_pointer = byte_sequence;\n    if ((uint *)0x3 < byte_sequence) {\n      byte_sequence_mask = (data_length & 0xff) << 8 | byte_to_find;\n      data_pointer_aligned_loop = data_pointer_aligned;\n      do {\n        data_xor_masked = *data_pointer_aligned_loop ^ (byte_sequence_mask | byte_sequence_mask << 0x10);\n        data_pointer_aligned = data_pointer_aligned_loop + 1;\n        if ((data_xor_masked + 0xfefefeff & ~data_xor_masked & 0x80808080) != 0) goto LAB_08009050;\n        byte_sequence = byte_sequence + -1;\n        data_pointer = byte_sequence;\n        data_pointer_aligned_loop = data_pointer_aligned;\n      } while ((uint *)0x3 < byte_sequence);\n    }\n    data_pointer_aligned_loop = data_pointer_aligned;\n    byte_sequence = data_pointer;\n    if (data_pointer != (uint *)0x0) {\nLAB_08009050:\n      data_pointer = data_pointer_aligned_loop;\n      if (*(byte *)data_pointer != byte_to_find) {\n        byte_sequence = (uint *)((int)byte_sequence + (int)data_pointer);\n        do {\n          data_pointer = (uint *)((int)data_pointer + 1);\n          if (byte_sequence == data_pointer) goto LAB_0800906c;\n        } while (*(byte *)data_pointer != byte_to_find);\n      }\n    }\n  }\n  else {\n    data_pointer_aligned_loop = (uint *)((int)byte_sequence + -1);\n    if (byte_sequence == (uint *)0x0) {\nLAB_0800906c:\n      data_pointer = (uint *)0x0;\n    }\n    else if (*(byte *)data_pointer != byte_to_find) {\n      data_pointer_aligned = (uint *)((int)data_pointer + 1);\n      do {\n        data_pointer = data_pointer_aligned;\n        data_pointer_aligned = data_pointer;\n        byte_sequence = data_pointer_aligned_loop;\n        if (((uint)data_pointer & 3) == 0) goto LAB_0800904a;\n        end_of_byte_sequence_reached = data_pointer_aligned_loop == (uint *)0x0;\n        data_pointer_aligned_loop = (uint *)((int)data_pointer_aligned_loop + -1);\n        if (end_of_byte_sequence_reached) goto LAB_0800906c;\n        data_pointer_aligned = (uint *)((int)data_pointer + 1);\n      } while (*(byte *)data_pointer != byte_to_find);\n    }\n  }\n  return data_pointer;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800901c",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "find_byte_sequence_0800901c"
        },
        "FUN_0800177c": {
            "renaming": {
                "FUN_0800177c": "set_flag_if_parameter_is_four_0800177c",
                "param_1": "parameter"
            },
            "code": "\nvoid set_flag_if_parameter_is_four_0800177c(int parameter)\n\n{\n  if (parameter == 4) {\n    *DAT_080017b0 = *DAT_080017b0 | 4;\n  }\n  else {\n    *DAT_080017b0 = *DAT_080017b0 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800177c",
            "calling": [
                "FUN_080052a0"
            ],
            "imported": false,
            "current_name": "set_flag_if_parameter_is_four_0800177c"
        },
        "FUN_080017b4": {
            "renaming": {
                "FUN_080017b4": "initialize_program_080017b4"
            },
            "code": "\nvoid initialize_program_080017b4(void)\n\n{\n  FUN_08004f78(0);\n  return;\n}\n\n",
            "called": [
                "FUN_08004f78"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080017b4",
            "calling": [
                "FUN_08005704"
            ],
            "imported": false,
            "current_name": "initialize_program_080017b4"
        },
        "FUN_08005598": {
            "renaming": {
                "FUN_08005598": "initialize_memory_08005598"
            },
            "code": "\nvoid initialize_memory_08005598(void)\n\n{\n  int iVar1;\n  \n  *(undefined4 *)PTR_DAT_080055e8 = DAT_080055ec;\n  *(undefined4 *)(PTR_DAT_080055e8 + 4) = 0x1c200;\n  *(undefined4 *)(PTR_DAT_080055e8 + 8) = 0;\n  *(undefined4 *)(PTR_DAT_080055e8 + 0xc) = 0;\n  *(undefined4 *)(PTR_DAT_080055e8 + 0x10) = 0;\n  *(undefined4 *)(PTR_DAT_080055e8 + 0x14) = 0xc;\n  *(undefined4 *)(PTR_DAT_080055e8 + 0x18) = 0;\n  *(undefined4 *)(PTR_DAT_080055e8 + 0x1c) = 0;\n  iVar1 = FUN_0800438a(PTR_DAT_080055e8);\n  if (iVar1 != 0) {\n    FUN_08005674(PTR_s____src_main_c_080055f0,0x1ed);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_0800438a",
                "FUN_08005674"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005598",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "initialize_memory_08005598"
        },
        "FUN_08001030": {
            "renaming": {
                "FUN_08001030": "check_for_null_termination_08001030",
                "in_CY": "last_char"
            },
            "code": "\nbool check_for_null_termination_08001030(void)\n\n{\n  char last_char;\n  \n  FUN_08000fc8();\n  return last_char == '\\0';\n}\n\n",
            "called": [
                "FUN_08000fc8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001030",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "check_for_null_termination_08001030"
        },
        "FUN_080011ec": {
            "renaming": {
                "FUN_080011ec": "get_concatenated_values_080011ec",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "condition1",
                "param_4": "condition2",
                "uVar1": "concatenated_values"
            },
            "code": "\nundefined8 get_concatenated_values_080011ec(int value1,int value2,int condition1,int condition2)\n\n{\n  undefined8 concatenated_values;\n  \n  if ((condition2 == 0) && (condition1 == 0)) {\n    if (value2 != 0 || value1 != 0) {\n      value2 = -1;\n      value1 = -1;\n    }\n    return CONCAT44(value2,value1);\n  }\n  concatenated_values = FUN_0800121c();\n  return concatenated_values;\n}\n\n",
            "called": [
                "FUN_0800121c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080011ec",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "get_concatenated_values_080011ec"
        },
        "FUN_08004424": {
            "renaming": {
                "FUN_08004424": "FUNC_08004424"
            },
            "code": "\nvoid FUNC_08004424(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08004424",
            "calling": [
                "FUN_0800438a"
            ],
            "imported": false,
            "current_name": "FUNC_08004424"
        },
        "FUN_08004f3c": {
            "renaming": {
                "FUN_08004f3c": "print_hexadecimal_08004f3c",
                "param_1": "memory_address",
                "param_2": "data"
            },
            "code": "\nvoid print_hexadecimal_08004f3c(undefined4 memory_address,undefined2 data)\n\n{\n  FUN_08004436(PTR_DAT_08004f5c,memory_address,data,0x32);\n  return;\n}\n\n",
            "called": [
                "FUN_08004436"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f3c",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "print_hexadecimal_08004f3c"
        },
        "FUN_08009adc": {
            "renaming": {
                "FUN_08009adc": "allocate_memory_block_08009adc",
                "param_1": "memory_pool",
                "param_2": "block",
                "param_3": "size",
                "puVar1": "header",
                "piVar2": "prev_block",
                "iVar3": "tmp",
                "piVar4": "curr_block",
                "uVar5": "block_size",
                "iVar6": "tmp2",
                "uVar7": "prev_block_size",
                "piVar8": "new_block",
                "uVar9": "block_size_aligned",
                "uVar10": "prev_block_size_aligned",
                "uVar11": "new_block_size_aligned",
                "iVar12": "end_of_block"
            },
            "code": "\nint * allocate_memory_block_08009adc(undefined4 *memory_pool,int *block,uint size)\n\n{\n  undefined *header;\n  int *prev_block;\n  int tmp;\n  int *curr_block;\n  uint block_size;\n  int tmp2;\n  uint prev_block_size;\n  int *new_block;\n  uint block_size_aligned;\n  uint prev_block_size_aligned;\n  uint new_block_size_aligned;\n  int end_of_block;\n  \n  if (block == (int *)0x0) {\n    curr_block = (int *)FUN_08008af8(memory_pool,size);\n    return curr_block;\n  }\n  FUN_080090a8();\n  header = PTR_DAT_08009e38;\n  prev_block_size = block[-1];\n  prev_block_size_aligned = prev_block_size & 0xfffffffc;\n  curr_block = block + -2;\n  if (size + 0xb < 0x17) {\n    block_size_aligned = 0x10;\n  }\n  else {\n    block_size_aligned = size + 0xb & 0xfffffff8;\n    if ((int)block_size_aligned < 0) goto LAB_08009b8e;\n  }\n  if (block_size_aligned < size) {\nLAB_08009b8e:\n    *memory_pool = 0xc;\n    return (int *)0x0;\n  }\n  end_of_block = (int)curr_block + prev_block_size_aligned;\n  new_block_size_aligned = prev_block_size_aligned;\n  if ((int)prev_block_size_aligned < (int)block_size_aligned) {\n    if (*(int *)(PTR_DAT_08009e38 + 8) == end_of_block) {\n      end_of_block = (*(uint *)(*(int *)(PTR_DAT_08009e38 + 8) + 4) & 0xfffffffc) + prev_block_size_aligned;\n      if ((int)(block_size_aligned + 0x10) <= end_of_block) {\n        *(uint *)(PTR_DAT_08009e38 + 8) = (int)curr_block + block_size_aligned;\n        *(uint *)((int)curr_block + block_size_aligned + 4) = end_of_block - block_size_aligned | 1;\n        block[-1] = block_size_aligned | block[-1] & 1U;\n        FUN_080090b4(memory_pool);\n        return block;\n      }\n      if (-1 < (int)(prev_block_size << 0x1f)) {\n        prev_block = (int *)((int)curr_block - block[-2]);\n        prev_block_size = prev_block[1] & 0xfffffffc;\n        if ((int)(block_size_aligned + 0x10) <= (int)(end_of_block + prev_block_size)) {\n          tmp2 = prev_block[3];\n          curr_block = prev_block + 2;\n          tmp = *curr_block;\n          prev_block_size_aligned = prev_block_size_aligned - 4;\n          *(int *)(tmp + 0xc) = tmp2;\n          *(int *)(tmp2 + 8) = tmp;\n          if (prev_block_size_aligned < 0x25) {\n            tmp = *block;\n            new_block = curr_block;\n            if (0x13 < prev_block_size_aligned) {\n              prev_block[2] = tmp;\n              prev_block[3] = block[1];\n              tmp = block[2];\n              if (prev_block_size_aligned < 0x1c) {\n                block = block + 2;\n                new_block = prev_block + 4;\n              }\n              else {\n                prev_block[4] = tmp;\n                prev_block[5] = block[3];\n                tmp = block[4];\n                if (prev_block_size_aligned == 0x24) {\n                  prev_block[6] = tmp;\n                  prev_block[7] = block[5];\n                  tmp = block[6];\n                  block = block + 6;\n                  new_block = prev_block + 8;\n                }\n                else {\n                  block = block + 4;\n                  new_block = prev_block + 6;\n                }\n              }\n            }\n            *new_block = tmp;\n            new_block[1] = block[1];\n            new_block[2] = block[2];\n          }\n          else {\n            FUN_08009a18(curr_block,block);\n          }\n          *(uint *)(header + 8) = (int)prev_block + block_size_aligned;\n          *(uint *)((int)prev_block + block_size_aligned + 4) = (end_of_block + prev_block_size) - block_size_aligned | 1;\n          prev_block[1] = block_size_aligned | prev_block[1] & 1U;\n          FUN_080090b4(memory_pool);\n          return curr_block;\n        }\nLAB_08009bb0:\n        new_block_size_aligned = prev_block_size_aligned + prev_block_size;\n        if ((int)block_size_aligned <= (int)new_block_size_aligned) {\n          tmp2 = prev_block[3];\n          new_block = prev_block + 2;\n          tmp = *new_block;\n          *(int *)(tmp + 0xc) = tmp2;\n          end_of_block = (int)prev_block + new_block_size_aligned;\n          *(int *)(tmp2 + 8) = tmp;\n          curr_block = prev_block;\n          if (prev_block_size_aligned - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          FUN_08009a18(new_block,block);\n          block = new_block;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(end_of_block + 4) & 0xfffffffe) + end_of_block + 4) << 0x1f) {\n        block_size = *(uint *)(end_of_block + 4) & 0xfffffffc;\n        new_block_size_aligned = prev_block_size_aligned + block_size;\n        if ((int)new_block_size_aligned < (int)block_size_aligned) {\n          if ((int)(prev_block_size << 0x1f) < 0) goto LAB_08009b36;\n          prev_block = (int *)((int)curr_block - block[-2]);\n          prev_block_size = prev_block[1] & 0xfffffffc;\n          new_block_size_aligned = block_size + prev_block_size + prev_block_size_aligned;\n          if ((int)new_block_size_aligned < (int)block_size_aligned) goto LAB_08009bb0;\n          tmp = *(int *)(end_of_block + 8);\n          end_of_block = *(int *)(end_of_block + 0xc);\n          *(int *)(tmp + 0xc) = end_of_block;\n          *(int *)(end_of_block + 8) = tmp;\n          new_block = prev_block + 2;\n          tmp = *new_block;\n          tmp2 = prev_block[3];\n          *(int *)(tmp + 0xc) = tmp2;\n          end_of_block = (int)prev_block + new_block_size_aligned;\n          *(int *)(tmp2 + 8) = tmp;\n          curr_block = prev_block;\n          if (0x24 < prev_block_size_aligned - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          prev_block_size_aligned = prev_block_size_aligned - 4;\n          tmp = *block;\n          prev_block = new_block;\n          if (0x13 < prev_block_size_aligned) {\n            curr_block[2] = tmp;\n            curr_block[3] = block[1];\n            tmp = block[2];\n            if (prev_block_size_aligned < 0x1c) {\n              block = block + 2;\n              prev_block = curr_block + 4;\n            }\n            else {\n              curr_block[4] = tmp;\n              curr_block[5] = block[3];\n              tmp = block[4];\n              if (prev_block_size_aligned == 0x24) {\n                curr_block[6] = tmp;\n                curr_block[7] = block[5];\n                tmp = block[6];\n                block = block + 6;\n                prev_block = curr_block + 8;\n              }\n              else {\n                block = block + 4;\n                prev_block = curr_block + 6;\n              }\n            }\n          }\n          *prev_block = tmp;\n          prev_block[1] = block[1];\n          prev_block[2] = block[2];\n          block = new_block;\n        }\n        else {\n          tmp = *(int *)(end_of_block + 8);\n          tmp2 = *(int *)(end_of_block + 0xc);\n          *(int *)(tmp + 0xc) = tmp2;\n          end_of_block = (int)curr_block + new_block_size_aligned;\n          *(int *)(tmp2 + 8) = tmp;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(prev_block_size << 0x1f)) {\n        prev_block = (int *)((int)curr_block - block[-2]);\n        prev_block_size = prev_block[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    prev_block = (int *)FUN_08008af8(memory_pool,size);\n    if (prev_block != (int *)0x0) {\n      if ((int *)((block[-1] & 0xfffffffeU) + (int)curr_block) == prev_block + -2) {\n        new_block_size_aligned = prev_block_size_aligned + (prev_block[-1] & 0xfffffffcU);\n        end_of_block = (int)curr_block + new_block_size_aligned;\n        goto LAB_08009c00;\n      }\n      prev_block_size_aligned = prev_block_size_aligned - 4;\n      if (prev_block_size_aligned < 0x25) {\n        end_of_block = *block;\n        curr_block = block;\n        new_block = prev_block;\n        if (0x13 < prev_block_size_aligned) {\n          *prev_block = end_of_block;\n          prev_block[1] = block[1];\n          if (prev_block_size_aligned < 0x1c) {\n            end_of_block = block[2];\n            curr_block = block + 2;\n            new_block = prev_block + 2;\n          }\n          else {\n            prev_block[2] = block[2];\n            prev_block[3] = block[3];\n            if (prev_block_size_aligned == 0x24) {\n              prev_block[4] = block[4];\n              prev_block[5] = block[5];\n              end_of_block = block[6];\n              curr_block = block + 6;\n              new_block = prev_block + 6;\n            }\n            else {\n              end_of_block = block[4];\n              curr_block = block + 4;\n              new_block = prev_block + 4;\n            }\n          }\n        }\n        *new_block = end_of_block;\n        new_block[1] = curr_block[1];\n        new_block[2] = curr_block[2];\n      }\n      else {\n        FUN_08009a18(prev_block,block);\n      }\n      FUN_080088ec(memory_pool,block);\n    }\n    FUN_080090b4(memory_pool);\n    block = prev_block;\n  }\n  else {\nLAB_08009c00:\n    if (new_block_size_aligned - block_size_aligned < 0x10) {\n      curr_block[1] = curr_block[1] & 1U | new_block_size_aligned;\n      *(uint *)(end_of_block + 4) = *(uint *)(end_of_block + 4) | 1;\n    }\n    else {\n      curr_block[1] = curr_block[1] & 1U | block_size_aligned;\n      *(uint *)((int)curr_block + block_size_aligned + 4) = new_block_size_aligned - block_size_aligned | 1;\n      *(uint *)(end_of_block + 4) = *(uint *)(end_of_block + 4) | 1;\n      FUN_080088ec(memory_pool,(int)curr_block + block_size_aligned + 8);\n    }\n    FUN_080090b4(memory_pool);\n  }\n  return block;\n}\n\n",
            "called": [
                "FUN_08009a18",
                "FUN_080088ec",
                "FUN_08008af8",
                "FUN_080090a8",
                "FUN_080090b4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009adc",
            "calling": [
                "FUN_080097cc"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_08009adc"
        },
        "FUN_08003696": {
            "renaming": {
                "FUN_08003696": "FUNC_08003696"
            },
            "code": "\nvoid FUNC_08003696(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003696",
            "calling": [
                "FUN_08003640"
            ],
            "imported": false,
            "current_name": "FUNC_08003696"
        },
        "FUN_08002640": {
            "renaming": {
                "FUN_08002640": "process_data_08002640",
                "param_1": "data_ptr",
                "param_2": "flag",
                "param_3": "type",
                "param_4": "param",
                "param_5": "limit",
                "param_6": "offset",
                "iVar1": "result",
                "uVar2": "status"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nundefined4\nprocess_data_08002640(uint **data_ptr,byte flag,undefined2 type,short param,uint limit,int offset)\n\n{\n  int result;\n  undefined4 status;\n  \n  **data_ptr = **data_ptr | 0x100;\n  do {\n    if ((~(*data_ptr)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_0800270a;\n    }\n  } while ((limit == 0xffffffff) ||\n          ((limit != 0 && (result = FUN_080015a0(), (uint)(result - offset) <= limit))));\n  data_ptr[0xc] = (uint *)0x0;\n  *(undefined *)((int)data_ptr + 0x3d) = 0x20;\n  *(undefined *)((int)data_ptr + 0x3e) = 0;\n  *(undefined *)(data_ptr + 0xf) = 0;\n  result = 3;\nLAB_0800270a:\n  if (result == 0) {\n    (*data_ptr)[4] = flag & 0xfe;\n    result = FUN_08002ad8(data_ptr,DAT_080027f0,limit,offset);\n    if (result == 0) {\n      result = FUN_08002bb4(data_ptr,limit,offset,(*data_ptr)[6]);\n      if (result == 0) {\n        if (param == 1) {\n          (*data_ptr)[4] = (uint)(byte)type;\n        }\n        else {\n          (*data_ptr)[4] = (uint)(byte)((ushort)type >> 8);\n          result = FUN_08002bb4(data_ptr,limit,offset);\n          if (result != 0) {\n            if (data_ptr[0x10] == (uint *)0x4) {\n              **data_ptr = **data_ptr | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*data_ptr)[4] = (uint)(byte)type;\n        }\n        status = 0;\n      }\n      else if (data_ptr[0x10] == (uint *)0x4) {\n        **data_ptr = **data_ptr | 0x200;\n        status = 1;\n      }\n      else {\n        status = 3;\n      }\n    }\n    else if (data_ptr[0x10] == (uint *)0x4) {\n      status = 1;\n    }\n    else {\n      status = 3;\n    }\n  }\n  else {\n    status = 3;\n  }\n  return status;\n}\n\n",
            "called": [
                "FUN_080015a0",
                "FUN_08002ad8",
                "FUN_08002bb4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002640",
            "calling": [
                "FUN_08001ccc"
            ],
            "imported": false,
            "current_name": "process_data_08002640"
        },
        "FUN_080008fc": {
            "renaming": {
                "FUN_080008fc": "compare_values_and_return_result_080008fc",
                "param_1": "value_1",
                "param_2": "value_2",
                "param_3": "value_3",
                "param_4": "value_4",
                "uVar1": "xor_result",
                "bVar2": "are_values_equal",
                "bVar3": "is_value_4_smaller_than_value_2",
                "return": "result"
            },
            "code": "\nuint compare_values_and_return_result_080008fc(uint value_1,uint value_2,uint value_3,uint value_4)\n\n{\n  uint xor_result;\n  bool are_values_equal;\n  bool is_value_4_smaller_than_value_2;\n  \n  if (((int)(value_2 << 1) >> 0x15 == -1 || (int)(value_4 << 1) >> 0x15 == -1) &&\n     ((((int)(value_2 << 1) >> 0x15 == -1 && ((value_1 | value_2 << 0xc) != 0)) ||\n      (((int)(value_4 << 1) >> 0x15 == -1 && ((value_3 | value_4 << 0xc) != 0)))))) {\n    result 1;\n  }\n  are_values_equal = (value_1 | value_2 << 1) == 0;\n  if (are_values_equal) {\n    are_values_equal = (value_3 | value_4 << 1) == 0;\n  }\n  if (!are_values_equal) {\n    are_values_equal = value_2 == value_4;\n  }\n  if (are_values_equal) {\n    are_values_equal = value_1 == value_3;\n  }\n  if (!are_values_equal) {\n    xor_result = value_2 ^ value_4;\n    are_values_equal = xor_result == 0;\n    if (-1 < (int)xor_result) {\n      are_values_equal = value_2 == value_4;\n    }\n    is_value_4_smaller_than_value_2 = -1 < (int)xor_result && value_4 <= value_2;\n    if (are_values_equal) {\n      is_value_4_smaller_than_value_2 = value_3 <= value_1;\n    }\n    value_4 = (int)value_4 >> 0x1f;\n    if (!is_value_4_smaller_than_value_2) {\n      value_4 = ~value_4;\n    }\n    result value_4 | 1;\n  }\n  result 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080008fc",
            "calling": [
                "FUN_08000988"
            ],
            "imported": false,
            "current_name": "compare_values_and_return_result_080008fc"
        },
        "FUN_08000988": {
            "renaming": {
                "FUN_08000988": "execute_and_return_param_08000988",
                "param_1": "input_param",
                "return": "output_param"
            },
            "code": "\nundefined4 execute_and_return_param_08000988(undefined4 input_param)\n\n{\n  FUN_080008fc();\n  output_param input_param;\n}\n\n",
            "called": [
                "FUN_080008fc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000988",
            "calling": [
                "FUN_08000998",
                "FUN_08000978",
                "FUN_080009ac",
                "FUN_080009c0"
            ],
            "imported": false,
            "current_name": "execute_and_return_param_08000988"
        },
        "FUN_08001714": {
            "renaming": {
                "FUN_08001714": "initialize_application_08001714",
                "param_1": "application_config"
            },
            "code": "\nvoid initialize_application_08001714(undefined4 application_config)\n\n{\n  FUN_080015b4(application_config);\n  return;\n}\n\n",
            "called": [
                "FUN_080015b4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001714",
            "calling": [
                "FUN_080014f0"
            ],
            "imported": false,
            "current_name": "initialize_application_08001714"
        },
        "FUN_08005dfc": {
            "renaming": {
                "FUN_08005dfc": "clear_string_08005dfc",
                "param_1": "string",
                "param_2": "string_length",
                "param_3": "unused_param",
                "param_4": "unused_param",
                "local_80": "string_ptr",
                "local_78": "max_string_length",
                "uStack_74": "constant_value",
                "local_70": "string_ptr_copy",
                "local_6c": "min_string_length",
                "uStack_8": "unused_param",
                "uStack_4": "unused_param"
            },
            "code": "\nvoid clear_string_08005dfc(undefined *string,undefined4 string_length,undefined4 unused_param,undefined4 unused_param)\n\n{\n  undefined *string_ptr [2];\n  undefined4 max_string_length;\n  undefined4 constant_value;\n  undefined *string_ptr_copy;\n  undefined4 min_string_length;\n  undefined4 unused_param;\n  undefined4 unused_param;\n  \n  min_string_length = 0x7fffffff;\n  max_string_length = 0x7fffffff;\n  constant_value = DAT_08005e3c;\n  string_ptr[0] = string;\n  string_ptr_copy = string;\n  unused_param = unused_param;\n  unused_param = unused_param;\n  FUNC_08005e9c(*(undefined4 *)PTR_PTR_DAT_08005e38,string_ptr,string_length,&unused_param);\n  *string_ptr[0] = 0;\n  return;\n}\n\n",
            "called": [
                "FUN_08005e9c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005dfc",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "clear_string_08005dfc"
        },
        "FUN_080078c0": {
            "renaming": {
                "FUN_080078c0": "calculate_quotient_080078c0",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar1": "carry",
                "puVar2": "dividend_ptr",
                "iVar3": "temp_dividend",
                "iVar4": "divisor_length",
                "iVar5": "dividend_length",
                "uVar6": "quotient",
                "puVar7": "divisor_ptr",
                "puVar8": "quotient_ptr",
                "puVar9": "divisor_last_ptr",
                "uVar10": "temp_result",
                "puVar11": "divisor_ptr_temp",
                "puVar12": "divisor_ptr_next"
            },
            "code": "\nuint calculate_quotient_080078c0(int dividend,int divisor)\n\n{\n  uint carry;\n  uint *dividend_ptr;\n  int temp_dividend;\n  int divisor_length;\n  int dividend_length;\n  uint quotient;\n  uint *divisor_ptr;\n  uint *quotient_ptr;\n  uint *divisor_last_ptr;\n  uint temp_result;\n  uint *divisor_ptr_temp;\n  uint *divisor_ptr_next;\n  \n  divisor_length = *(int *)(divisor + 0x10);\n  if (*(int *)(dividend + 0x10) < divisor_length) {\n    return 0;\n  }\n  dividend_length = divisor_length + -1;\n  divisor_ptr = (uint *)(divisor + 0x14);\n  quotient_ptr = (uint *)(dividend + 0x14);\n  quotient = quotient_ptr[dividend_length] / (divisor_ptr[dividend_length] + 1);\n  divisor_last_ptr = divisor_ptr + dividend_length;\n  if (quotient != 0) {\n    carry = 0;\n    temp_dividend = 0;\n    dividend_ptr = quotient_ptr;\n    divisor_ptr_temp = divisor_ptr;\n    do {\n      divisor_ptr_next = divisor_ptr_temp + 1;\n      carry = quotient * (*divisor_ptr_temp & 0xffff) + carry;\n      temp_result = quotient * (*divisor_ptr_temp >> 0x10) + (carry >> 0x10);\n      carry = (temp_dividend - (carry & 0xffff)) + (*dividend_ptr & 0xffff);\n      temp_dividend = ((*dividend_ptr >> 0x10) - (temp_result & 0xffff)) + ((int)carry >> 0x10);\n      *dividend_ptr = carry & 0xffff | temp_dividend * 0x10000;\n      temp_dividend = temp_dividend >> 0x10;\n      carry = temp_result >> 0x10;\n      dividend_ptr = dividend_ptr + 1;\n      divisor_ptr_temp = divisor_ptr_next;\n    } while (divisor_ptr_next <= divisor_last_ptr);\n    if (quotient_ptr[dividend_length] == 0) {\n      if ((quotient_ptr < quotient_ptr + divisor_length + -2) && (quotient_ptr[divisor_length + -2] == 0)) {\n        dividend_ptr = quotient_ptr + divisor_length + -3;\n        do {\n          dividend_length = dividend_length + -1;\n          if (dividend_ptr <= quotient_ptr) break;\n          carry = *dividend_ptr;\n          dividend_ptr = dividend_ptr + -1;\n        } while (carry == 0);\n      }\n      *(int *)(dividend + 0x10) = dividend_length;\n    }\n  }\n  divisor_length = FUN_080094f8();\n  if (-1 < divisor_length) {\n    divisor_length = 0;\n    quotient = quotient + 1;\n    dividend_ptr = quotient_ptr;\n    do {\n      divisor_ptr_temp = divisor_ptr + 1;\n      carry = (divisor_length - (*divisor_ptr & 0xffff)) + (*dividend_ptr & 0xffff);\n      divisor_length = ((*dividend_ptr >> 0x10) - (*divisor_ptr >> 0x10)) + ((int)carry >> 0x10);\n      *dividend_ptr = carry & 0xffff | divisor_length * 0x10000;\n      divisor_length = divisor_length >> 0x10;\n      dividend_ptr = dividend_ptr + 1;\n      divisor_ptr = divisor_ptr_temp;\n    } while (divisor_ptr_temp <= divisor_last_ptr);\n    if (quotient_ptr[dividend_length] == 0) {\n      if ((quotient_ptr < quotient_ptr + dividend_length + -1) && (quotient_ptr[dividend_length + -1] == 0)) {\n        divisor_ptr = quotient_ptr + dividend_length + -2;\n        do {\n          dividend_length = dividend_length + -1;\n          if (divisor_ptr <= quotient_ptr) break;\n          carry = *divisor_ptr;\n          divisor_ptr = divisor_ptr + -1;\n        } while (carry == 0);\n      }\n      *(int *)(dividend + 0x10) = dividend_length;\n    }\n  }\n  return quotient;\n}\n\n",
            "called": [
                "FUN_080094f8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078c0",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "calculate_quotient_080078c0"
        },
        "thunk_FUN_08005838": {
            "renaming": {
                "thunk_FUN_08005838": "calculate_result_thunk_08005838",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "difference",
                "uVar2": "high_32_bits",
                "uVar3": "flags",
                "uVar4": "result",
                "uVar5": "positive_input_2",
                "uVar6": "concatenated_values"
            },
            "code": "\nuint calculate_result_thunk_08005838(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  int difference;\n  undefined4 high_32_bits;\n  uint flags;\n  uint result;\n  uint positive_input_2;\n  undefined8 concatenated_values;\n  \n  concatenated_values = CONCAT44(DAT_080059bc,DAT_080059b8);\n  result = input_4 & 0x7fffffff;\n  if ((DAT_080059e8 < (result | (-input_3 | input_3) >> 0x1f)) ||\n     (positive_input_2 = input_2 & 0x7fffffff, DAT_080059e8 < (positive_input_2 | (-input_1 | input_1) >> 0x1f))) {\n    result = FUN_0800015c(input_3,input_4,input_1,input_2);\n    return result;\n  }\n  if ((input_4 + 0xc0100000 | input_3) == 0) {\n    result = FUN_080059f0();\n    return result;\n  }\n  flags = (int)input_4 >> 0x1e & 2U | input_2 >> 0x1f;\n  if ((positive_input_2 | input_1) == 0) {\n    if (flags == 2) {\n      return DAT_080059b0;\n    }\n    result = DAT_080059a0;\n    if (flags != 3) {\n      return input_1;\n    }\n  }\n  else {\n    if ((result | input_3) != 0) {\n      if (result == DAT_080059e8) {\n        if (positive_input_2 == result) {\n          if (flags == 2) {\n            return DAT_080059e0;\n          }\n          if (flags == 3) {\n            return DAT_080059d8;\n          }\n          if (flags == 1) {\n            return DAT_080059d0;\n          }\n          return DAT_080059c8;\n        }\n        if (flags == 2) {\n          return DAT_080059b0;\n        }\n        if (flags == 3) {\n          return DAT_080059a0;\n        }\n        if (flags == 1) {\n          return 0;\n        }\n        return 0;\n      }\n      if (positive_input_2 != DAT_080059e8) {\n        difference = (int)(positive_input_2 - result) >> 0x14;\n        if (difference < 0x3d) {\n          if (((int)input_4 < 0) && (difference + 0x3c < 0 != SCARRY4(difference,0x3c))) {\n            concatenated_values = 0;\n          }\n          else {\n            FUN_0800071c(input_1,input_2,input_3,input_4,input_4);\n            FUNC_08005d0c();\n            concatenated_values = FUN_080059f0();\n          }\n        }\n        high_32_bits = (undefined4)((ulonglong)concatenated_values >> 0x20);\n        result = (uint)concatenated_values;\n        if (flags == 1) {\n          return result;\n        }\n        if (flags == 2) {\n          concatenated_values = FUN_08000158(result,high_32_bits,DAT_080059a8,DAT_080059ac);\n          result = FUN_08000158(DAT_080059b0,DAT_080059b4,(int)concatenated_values,(int)((ulonglong)concatenated_values >> 0x20))\n          ;\n          return result;\n        }\n        if (flags == 0) {\n          return result;\n        }\n        concatenated_values = FUN_08000158(result,high_32_bits,DAT_080059a8,DAT_080059ac);\n        result = FUN_08000158((int)concatenated_values,(int)((ulonglong)concatenated_values >> 0x20),DAT_080059b0,DAT_080059b4);\n        return result;\n      }\n    }\n    result = DAT_080059c0;\n    if (-1 < (int)input_2) {\n      result = DAT_080059b8;\n    }\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_08005838"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005834",
            "calling": [
                "FUN_08004d78",
                "FUN_08004bd8"
            ],
            "imported": false,
            "current_name": "calculate_result_thunk_08005838"
        },
        "FUN_080003f4": {
            "renaming": {
                "FUN_080003f4": "count_leading_zeroes_and_shift_left_080003f4",
                "param_1": "input_number",
                "uVar1": "output_high",
                "uVar2": "abs_input_number",
                "uVar3": "shift_amount",
                "iVar4": "leading_zero_count",
                "uVar5": "total_bits",
                "uVar6": "input_number_sign_bit",
                "in_r12": "unused_register",
                "bVar7": "leading_zero_count_less_than_zero",
                "bVar8": "leading_zero_count_equal_to_zero",
                "bVar9": "total_bits_greater_than_32"
            },
            "code": "\nulonglong count_leading_zeroes_and_shift_left_080003f4(uint input_number)\n\n{\n  uint output_high;\n  uint abs_input_number;\n  uint shift_amount;\n  int leading_zero_count;\n  uint total_bits;\n  uint input_number_sign_bit;\n  uint unused_register;\n  bool leading_zero_count_less_than_zero;\n  bool leading_zero_count_equal_to_zero;\n  bool total_bits_greater_than_32;\n  \n  if (input_number == 0) {\n    return 0;\n  }\n  input_number_sign_bit = input_number & 0x80000000;\n  abs_input_number = input_number;\n  if ((int)input_number_sign_bit < 0) {\n    abs_input_number = -input_number;\n  }\n  output_high = 0;\n  leading_zero_count = count_leading_zeroes(abs_input_number);\n  total_bits = leading_zero_count + 0x15;\n  total_bits_greater_than_32 = SBORROW4(total_bits,0x20);\n  shift_amount = leading_zero_count - 0xb;\n  leading_zero_count_less_than_zero = (int)shift_amount < 0;\n  leading_zero_count_equal_to_zero = shift_amount == 0;\n  if ((int)total_bits < 0x20) {\n    total_bits_greater_than_32 = SCARRY4(shift_amount,0xc);\n    leading_zero_count = leading_zero_count + 1;\n    leading_zero_count_less_than_zero = leading_zero_count < 0;\n    leading_zero_count_equal_to_zero = leading_zero_count == 0;\n    shift_amount = total_bits;\n    if (!leading_zero_count_equal_to_zero && leading_zero_count_less_than_zero == total_bits_greater_than_32) {\n      output_high = abs_input_number << (total_bits & 0xff);\n      abs_input_number = abs_input_number >> (0xcU - leading_zero_count & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (leading_zero_count_equal_to_zero || leading_zero_count_less_than_zero != total_bits_greater_than_32) {\n    unused_register = 0x20 - shift_amount;\n  }\n  abs_input_number = abs_input_number << (shift_amount & 0xff);\n  if (leading_zero_count_equal_to_zero || leading_zero_count_less_than_zero != total_bits_greater_than_32) {\n    abs_input_number = abs_input_number | 0U >> (unused_register & 0xff);\n  }\n  if (leading_zero_count_equal_to_zero || leading_zero_count_less_than_zero != total_bits_greater_than_32) {\n    output_high = 0 << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if ((int)total_bits < 0x433) {\n    return CONCAT44(abs_input_number + (0x432 - total_bits) * 0x100000 | input_number_sign_bit,output_high);\n  }\n  shift_amount = ~(0x432 - total_bits);\n  if (0x1e < (int)shift_amount) {\n    return CONCAT44(input_number,abs_input_number >> (shift_amount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zero_count = shift_amount - 0x13;\n  if (leading_zero_count == 0 || leading_zero_count < 0 != SCARRY4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(input_number_sign_bit | abs_input_number >> (shift_amount & 0xff),\n                    output_high >> (shift_amount & 0xff) | abs_input_number << (0x20 - shift_amount & 0xff));\n  }\n  return CONCAT44(input_number,output_high >> (0x20 - (0xcU - leading_zero_count) & 0xff) | abs_input_number << (0xcU - leading_zero_count & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080003f4",
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "count_leading_zeroes_and_shift_left_080003f4"
        },
        "FUN_080079e8": {
            "renaming": {
                "FUN_080079e8": "convert_float_to_char_080079e8",
                "param_1": "value",
                "param_2": "param2",
                "param_3": "sign",
                "param_4": "exponent",
                "param_5": "numDigits",
                "param_6": "precision",
                "param_7": "outDigits",
                "param_8": "outSign",
                "param_9": "outExponent",
                "cVar1": "digitChar",
                "bVar2": "carry",
                "uVar3": "result",
                "uVar4": "temp",
                "uVar5": "temp2",
                "uVar6": "temp3",
                "uVar7": "temp4",
                "uVar8": "temp5",
                "iVar9": "index",
                "iVar10": "offset",
                "iVar13": "shift",
                "iVar19": "tempIndex",
                "bVar20": "isNegative",
                "uVar21": "tempResult",
                "uVar22": "tempResult2",
                "uVar23": "tempResult3",
                "local_80": "outValue",
                "local_7c": "absExponent",
                "local_74": "numDigits",
                "local_70": "leadingZeros",
                "local_68": "outExponent",
                "local_64": "isZero",
                "local_60": "outDigitsLength",
                "local_5c": "trailingZeros",
                "local_58": "numLeadingZeros",
                "local_54": "isInfinite",
                "local_48": "tempExponent",
                "uStack_44": "tempExponent2",
                "local_38": "minDigits",
                "local_34": "tempDigits",
                "local_30": "tempDigitsLength",
                "local_2c": "tempArray"
            },
            "code": "\nchar * convertFloatToChar_080079e8(int value,undefined4 param2,uint sign,uint exponent,uint numDigits,\n                   uint precision,int *outDigits,uint *outSign,char **outExponent)\n\n{\n  char digitChar;\n  byte carry;\n  undefined4 result;\n  uint temp;\n  uint temp2;\n  uint temp3;\n  undefined4 temp4;\n  undefined4 temp5;\n  int index;\n  int offset;\n  undefined4 uVar11;\n  uint uVar12;\n  int shift;\n  char *pdigitChar4;\n  char *pdigitChar5;\n  undefined4 *puVar16;\n  undefined4 uVar17;\n  char *pdigitChar8;\n  int tempIndex;\n  bool isNegative;\n  undefined8 tempResult;\n  undefined8 tempResult2;\n  undefined8 tempResult3;\n  uint outValue;\n  uint absExponent;\n  uint numDigits;\n  int leadingZeros;\n  uint outExponent;\n  uint isZero;\n  int outDigitsLength;\n  int trailingZeros;\n  uint numLeadingZeros;\n  int isInfinite;\n  uint tempExponent;\n  uint tempExponent2;\n  uint minDigits;\n  uint tempDigits;\n  int tempDigitsLength;\n  int tempArray [2];\n  \n  index = *(int *)(value + 0x40);\n  if (index != 0) {\n    uVar12 = *(uint *)(value + 0x44);\n    *(uint *)(index + 4) = uVar12;\n    *(int *)(index + 8) = 1 << (uVar12 & 0xff);\n    FUN_0800910c(value,index);\n    *(undefined4 *)(value + 0x40) = 0;\n  }\n  isNegative = (int)exponent < 0;\n  uVar12 = exponent;\n  if (isNegative) {\n    uVar12 = exponent & 0x7fffffff;\n  }\n  *outSign = (uint)isNegative;\n  absExponent = exponent;\n  if (isNegative) {\n    absExponent = uVar12;\n  }\n  temp = absExponent;\n  if ((DAT_08007bf8 & ~uVar12) == 0) {\n    *outDigits = 9999;\n    if ((sign == 0) && ((uVar12 & 0xfffff) == 0)) {\n      if (outExponent == (char **)0x0) {\n        return PTR_s_Infinity_08007c08;\n      }\n      pdigitChar5 = PTR_s_Infinity_08007c08 + 8;\n      pdigitChar8 = PTR_s_Infinity_08007c08;\n    }\n    else {\n      if (outExponent == (char **)0x0) {\n        return PTR_DAT_08007c0c;\n      }\n      pdigitChar5 = PTR_DAT_08007c0c + 3;\n      pdigitChar8 = PTR_DAT_08007c0c;\n    }\n    *outExponent = pdigitChar5;\n    return pdigitChar8;\n  }\n  tempResult = FUN_08000998(sign,absExponent,0,0);\n  outDigitsLength = (int)tempResult;\n  if (outDigitsLength != 0) {\n    *outDigits = 1;\n    if (outExponent != (char **)0x0) {\n      pdigitChar8 = PTR_DAT_08007bfc + -1;\n      *outExponent = PTR_DAT_08007bfc;\n      return pdigitChar8;\n    }\n    return PTR_DAT_08007c10;\n  }\n  result = FUN_08009630(value,(int)((ulonglong)tempResult >> 0x20),sign,absExponent,tempArray,&tempDigitsLength)\n  ;\n  index = tempDigitsLength;\n  if (uVar12 >> 0x14 == 0) {\n    shift = tempArray[0] + tempDigitsLength;\n    offset = shift + 0x432;\n    if (offset < 0x21) {\n      uVar12 = sign << (0x20U - offset & 0xff);\n    }\n    else {\n      uVar12 = sign >> (shift + 0x412U & 0xff) | uVar12 << (0x40U - offset & 0xff);\n    }\n    tempResult = FUN_080003d4(uVar12);\n    shift = shift + -1;\n    outDigitsLength = 1;\n    temp2 = (int)((ulonglong)tempResult >> 0x20) + 0xfe100000;\n    uVar12 = (uint)tempResult;\n  }\n  else {\n    shift = (uVar12 >> 0x14) - 0x3ff;\n    temp2 = absExponent & 0xfffff | 0x3ff00000;\n    uVar12 = sign;\n  }\n  tempResult = FUN_08000158(uVar12,temp2,0,DAT_08007c00);\n  tempResult = FUN_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),DAT_08007be0,DAT_08007be4);\n  tempResult = FUN_0800015c((int)tempResult,(int)((ulonglong)tempResult >> 0x20),DAT_08007be8,DAT_08007bec);\n  tempResult2 = FUN_080003f4(shift);\n  tempResult2 = FUN_080004c8((int)tempResult2,(int)((ulonglong)tempResult2 >> 0x20),DAT_08007bf0,DAT_08007bf4);\n  tempResult = FUN_0800015c((int)tempResult,(int)((ulonglong)tempResult >> 0x20),(int)tempResult2,\n                        (int)((ulonglong)tempResult2 >> 0x20));\n  temp5 = (undefined4)((ulonglong)tempResult >> 0x20);\n  numDigits = FUN_0800119c();\n  offset = FUN_080009ac((int)tempResult,temp5,0,0);\n  if (offset != 0) {\n    tempResult2 = FUN_080003f4(numDigits);\n    offset = FUN_08000998((int)tempResult2,(int)((ulonglong)tempResult2 >> 0x20),(int)tempResult,temp5);\n    if (offset == 0) {\n      numDigits = numDigits - 1;\n    }\n  }\n  if (numDigits < 0x17) {\n    isInfinite = FUN_080009e8(*(undefined4 *)(PTR_DAT_08007c04 + numDigits * 8),\n                            *(undefined4 *)((int)(PTR_DAT_08007c04 + numDigits * 8) + 4),sign,\n                            absExponent);\n    if (isInfinite != 0) {\n      numDigits = numDigits - 1;\n      isInfinite = 0;\n    }\n  }\n  else {\n    isInfinite = 1;\n  }\n  offset = (index - shift) + -1;\n  if (offset < 0) {\n    leadingZeros = 1 - (index - shift);\n    offset = 0;\n  }\n  else {\n    leadingZeros = 0;\n  }\n  if ((int)numDigits < 0) {\n    numLeadingZeros = 0;\n    leadingZeros = leadingZeros - numDigits;\n    trailingZeros = -numDigits;\n  }\n  else {\n    offset = offset + numDigits;\n    numLeadingZeros = numDigits;\n    trailingZeros = 0;\n  }\n  if (9 < numDigits) {\n    minDigits = 0xffffffff;\n    isNegative = true;\n    outExponent = 0xffffffff;\n    isZero = 1;\n    numDigits = 0;\n    precision = 0;\n    goto LAB_08007c24;\n  }\n  isNegative = (int)numDigits < 6;\n  if (!isNegative) {\n    numDigits = numDigits - 4;\n  }\n  switch(numDigits) {\n  case 2:\n    isZero = 0;\n    break;\n  case 3:\n    isZero = 0;\n    goto LAB_08008300;\n  case 4:\n    isZero = 1;\n    break;\n  case 5:\n    isZero = 1;\nLAB_08008300:\n    minDigits = numDigits + precision;\n    outExponent = minDigits + 1;\n    uVar12 = outExponent;\n    if ((int)outExponent < 1) {\n      uVar12 = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(value + 0x44) = 0;\n    pdigitChar8 = (char *)FUN_080090c0(value,0);\n    minDigits = 0xffffffff;\n    outExponent = 0xffffffff;\n    precision = 0;\n    *(char **)(value + 0x40) = pdigitChar8;\n    isZero = 1;\n    goto LAB_08007e36;\n  }\n  if ((int)precision < 1) {\n    minDigits = 1;\n    precision = 1;\n    outExponent = 1;\nLAB_08007c24:\n    *(undefined4 *)(value + 0x44) = 0;\n    temp2 = minDigits;\n  }\n  else {\n    minDigits = precision;\n    outExponent = precision;\n    uVar12 = precision;\nLAB_08008314:\n    *(undefined4 *)(value + 0x44) = 0;\n    temp2 = outExponent;\n    if (0x17 < (int)uVar12) {\n      shift = 4;\n      index = 1;\n      do {\n        tempIndex = index;\n        shift = shift * 2;\n        index = tempIndex + 1;\n      } while (shift + 0x14U <= uVar12);\n      *(int *)(value + 0x44) = tempIndex;\n    }\n  }\n  pdigitChar8 = (char *)FUN_080090c0(value);\n  *(char **)(value + 0x40) = pdigitChar8;\n  if ((temp2 < 0xf) && (isNegative)) {\n    if ((int)numDigits < 1) {\n      if (numDigits == 0) {\n        index = 2;\n        outValue = sign;\n      }\n      else {\n        tempResult = FUN_080004c8(sign,absExponent,\n                              *(undefined4 *)(PTR_DAT_080086cc + (-numDigits & 0xf) * 8),\n                              *(undefined4 *)((int)(PTR_DAT_080086cc + (-numDigits & 0xf) * 8) + 4));\n        absExponent = (uint)((ulonglong)tempResult >> 0x20);\n        outValue = (uint)tempResult;\n        shift = (int)-numDigits >> 4;\n        if (shift == 0) {\n          index = 2;\n        }\n        else {\n          isNegative = false;\n          index = 2;\n          puVar16 = (undefined4 *)PTR_DAT_080086d0;\n          do {\n            if (shift << 0x1f < 0) {\n              tempResult = FUN_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),*puVar16,puVar16[1]\n                                   );\n              isNegative = true;\n              index = index + 1;\n            }\n            shift = shift >> 1;\n            puVar16 = puVar16 + 2;\n          } while (shift != 0);\n          if (isNegative) {\n            outValue = (uint)tempResult;\n            absExponent = (uint)((ulonglong)tempResult >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      uVar12 = (int)numDigits >> 4;\n      tempResult = *(undefined8 *)(PTR_DAT_08007ec4 + (numDigits & 0xf) * 8);\n      if ((int)(uVar12 << 0x1b) < 0) {\n        tempResult2 = FUN_0800071c(sign,absExponent,*(undefined4 *)(PTR_DAT_08007ec8 + 0x20),\n                              *(undefined4 *)(PTR_DAT_08007ec8 + 0x24));\n        tempExponent2 = (uint)((ulonglong)tempResult2 >> 0x20);\n        tempExponent = (uint)tempResult2;\n        index = 3;\n        uVar12 = uVar12 & 0xf;\n        puVar16 = (undefined4 *)PTR_DAT_08007ec8;\n      }\n      else {\n        index = 2;\n        tempExponent2 = absExponent;\n        puVar16 = (undefined4 *)PTR_DAT_08007ec8;\n        tempExponent = sign;\n      }\n      while( true ) {\n        temp5 = (undefined4)((ulonglong)tempResult >> 0x20);\n        if (uVar12 == 0) break;\n        if ((int)(uVar12 << 0x1f) < 0) {\n          tempResult = FUN_080004c8((int)tempResult,temp5,*puVar16,puVar16[1]);\n          index = index + 1;\n        }\n        uVar12 = (int)uVar12 >> 1;\n        puVar16 = puVar16 + 2;\n      }\n      tempResult = FUN_0800071c(tempExponent,tempExponent2,(int)tempResult,temp5);\n      outValue = (uint)tempResult;\n      absExponent = (uint)((ulonglong)tempResult >> 0x20);\n    }\n    tempResult = CONCAT44(absExponent,outValue);\n    if ((isInfinite != 0) && (shift = FUN_080009ac(outValue,absExponent,0,DAT_08007ecc), shift != 0)) {\n      if (outExponent == 0) {\n        tempResult = FUN_080003f4(index);\n        tempResult = FUN_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),outValue,absExponent);\n        tempResult = FUN_0800015c((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,DAT_080086d4);\n        temp5 = (undefined4)tempResult;\n        index = (int)((ulonglong)tempResult >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)minDigits) {\n        tempResult = FUN_080004c8(outValue,absExponent,0,DAT_0800880c);\n        tempResult2 = FUN_080003f4(index + 1);\n        tempResult2 = FUN_080004c8((int)tempResult2,(int)((ulonglong)tempResult2 >> 0x20),(int)tempResult,\n                              (int)((ulonglong)tempResult >> 0x20));\n        tempResult2 = FUN_0800015c((int)tempResult2,(int)((ulonglong)tempResult2 >> 0x20),0,DAT_08008810);\n        temp5 = (undefined4)tempResult2;\n        tempExponent = minDigits;\n        tempDigits = numDigits - 1;\n        index = (int)((ulonglong)tempResult2 >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    tempResult2 = FUN_080003f4(index);\n    tempResult2 = FUN_080004c8((int)tempResult2,(int)((ulonglong)tempResult2 >> 0x20),outValue,absExponent);\n    tempResult2 = FUN_0800015c((int)tempResult2,(int)((ulonglong)tempResult2 >> 0x20),0,DAT_08007ed0);\n    temp5 = (undefined4)tempResult2;\n    index = (int)((ulonglong)tempResult2 >> 0x20) + -0x3400000;\n    if (outExponent != 0) {\n      tempDigits = numDigits;\n      tempExponent = outExponent;\nLAB_08007cfa:\n      absExponent = (uint)((ulonglong)tempResult >> 0x20);\n      outValue = (uint)tempResult;\n      digitChar = FUN_0800119c(outValue,absExponent);\n      digitChar = digitChar + '0';\n      uVar11 = *(undefined4 *)(PTR_DAT_08007ec4 + tempExponent * 8 + -8);\n      temp4 = *(undefined4 *)(PTR_DAT_08007ec4 + tempExponent * 8 + -4);\n      tempResult = FUN_080003f4();\n      tempResult = FUN_08000158(outValue,absExponent,(int)tempResult,(int)((ulonglong)tempResult >> 0x20));\n      uVar17 = (undefined4)((ulonglong)tempResult >> 0x20);\n      pdigitChar5 = pdigitChar8 + 1;\n      if (isZero == 0) {\n        tempResult2 = FUN_080004c8(temp5,index,uVar11,temp4);\n        temp5 = (undefined4)((ulonglong)tempResult2 >> 0x20);\n        *pdigitChar8 = digitChar;\n        if (tempExponent != 1) {\n          pdigitChar4 = pdigitChar5;\n          do {\n            tempResult = FUN_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,DAT_080086d8);\n            digitChar = FUN_0800119c();\n            tempResult3 = FUN_080003f4();\n            tempResult = FUN_08000158((int)tempResult,(int)((ulonglong)tempResult >> 0x20),(int)tempResult3,\n                                  (int)((ulonglong)tempResult3 >> 0x20));\n            pdigitChar5 = pdigitChar4 + 1;\n            *pdigitChar4 = digitChar + '0';\n            pdigitChar4 = pdigitChar5;\n          } while (pdigitChar5 != pdigitChar8 + tempExponent);\n        }\n        uVar11 = (undefined4)((ulonglong)tempResult >> 0x20);\n        tempResult3 = FUN_0800015c((int)tempResult2,temp5,0,DAT_080086dc);\n        index = FUN_080009ac((int)tempResult3,(int)((ulonglong)tempResult3 >> 0x20),(int)tempResult,uVar11);\n        if (index == 0) {\n          tempResult2 = FUN_08000158(0,DAT_08008814,(int)tempResult2,temp5);\n          index = FUN_080009e8((int)tempResult2,(int)((ulonglong)tempResult2 >> 0x20),(int)tempResult,uVar11);\n          pdigitChar4 = pdigitChar5;\n          if (index == 0) goto LAB_08007e36;\n          do {\n            pdigitChar5 = pdigitChar4;\n            pdigitChar4 = pdigitChar5 + -1;\n          } while (pdigitChar5[-1] == '0');\n          goto LAB_08008784;\n        }\n        numDigits = tempDigits;\n        digitChar = pdigitChar5[-1];\n      }\n      else {\n        tempResult2 = FUN_0800071c(0,DAT_08007ed4,uVar11,temp4);\n        tempResult2 = FUN_08000158((int)tempResult2,(int)((ulonglong)tempResult2 >> 0x20),temp5,index);\n        temp5 = (undefined4)((ulonglong)tempResult2 >> 0x20);\n        *pdigitChar8 = digitChar;\n        index = FUN_080009e8((int)tempResult2,temp5,(int)tempResult,uVar17);\n        if (index != 0) {\nLAB_08008784:\n          numDigits = tempDigits;\n          goto LAB_08008294;\n        }\n        tempResult3 = FUN_08000158(0,DAT_08007ecc,(int)tempResult,uVar17);\n        index = FUN_080009e8((int)tempResult2,temp5,(int)tempResult3,(int)((ulonglong)tempResult3 >> 0x20));\n        if (index == 0) {\n          if (tempExponent != 1) {\n            pdigitChar4 = pdigitChar5;\n            do {\n              tempResult2 = FUN_080004c8((int)tempResult2,(int)((ulonglong)tempResult2 >> 0x20),0,DAT_08007ed8);\n              temp5 = (undefined4)((ulonglong)tempResult2 >> 0x20);\n              tempResult = FUN_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,DAT_08007ed8);\n              digitChar = FUN_0800119c();\n              tempResult3 = FUN_080003f4();\n              tempResult = FUN_08000158((int)tempResult,(int)((ulonglong)tempResult >> 0x20),(int)tempResult3,\n                                    (int)((ulonglong)tempResult3 >> 0x20));\n              uVar11 = (undefined4)((ulonglong)tempResult >> 0x20);\n              digitChar = digitChar + '0';\n              pdigitChar5 = pdigitChar4 + 1;\n              *pdigitChar4 = digitChar;\n              index = FUN_080009ac((int)tempResult,uVar11,(int)tempResult2,temp5);\n              if (index != 0) {\n                numDigits = tempDigits;\n                goto LAB_08008294;\n              }\n              tempResult3 = FUN_08000158(0,DAT_08007ecc,(int)tempResult,uVar11);\n              index = FUN_080009ac((int)tempResult3,(int)((ulonglong)tempResult3 >> 0x20),(int)tempResult2,temp5);\n              if (index != 0) goto LAB_08008798;\n              pdigitChar4 = pdigitChar5;\n            } while (pdigitChar5 != pdigitChar8 + tempExponent);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        numDigits = tempDigits;\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    tempResult = FUN_08000158(outValue,absExponent,0,DAT_080086c8);\n    uVar11 = (undefined4)((ulonglong)tempResult >> 0x20);\n    uVar12 = FUN_080009e8((int)tempResult,uVar11,temp5,index);\n    if (uVar12 == 0) {\n      index = FUN_080009ac((int)tempResult,uVar11,temp5,index + -0x80000000);\n      temp2 = uVar12;\n      pdigitChar5 = pdigitChar8;\n      if (index == 0) goto LAB_08007e36;\n      goto LAB_080084f0;\n    }\n    outExponent = 0;\n    uVar12 = 0;\nLAB_08008406:\n    *pdigitChar8 = '1';\n    numDigits = numDigits + 1;\n    pdigitChar5 = pdigitChar8 + 1;\n    temp2 = outExponent;\nLAB_08008416:\n    FUN_0800910c(value,temp2);\n    if (uVar12 == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pdigitChar5 = pdigitChar8;\n    if ((-1 < tempArray[0]) && ((int)numDigits < 0xf)) {\n      temp5 = *(undefined4 *)(PTR_DAT_08007ec4 + numDigits * 8);\n      uVar11 = *(undefined4 *)((int)(PTR_DAT_08007ec4 + numDigits * 8) + 4);\n      if ((-1 < (int)precision) || (0 < (int)outExponent)) {\n        FUN_0800071c(sign,temp,temp5,uVar11);\n        carry = FUN_0800119c();\n        tempResult = FUN_080003f4();\n        tempResult = FUN_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),temp5,uVar11);\n        tempResult = FUN_08000158(sign,temp,(int)tempResult,(int)((ulonglong)tempResult >> 0x20));\n        *pdigitChar8 = carry + 0x30;\n        pdigitChar5 = pdigitChar8 + 1;\n        if (outExponent != 1) {\n          tempResult = FUN_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,DAT_08007ed8);\n          index = FUN_08000998((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,0);\n          while (index == 0) {\n            uVar17 = (undefined4)((ulonglong)tempResult >> 0x20);\n            FUN_0800071c((int)tempResult,uVar17,temp5,uVar11);\n            carry = FUN_0800119c();\n            tempResult2 = FUN_080003f4();\n            tempResult2 = FUN_080004c8((int)tempResult2,(int)((ulonglong)tempResult2 >> 0x20),temp5,uVar11);\n            tempResult = FUN_08000158((int)tempResult,uVar17,(int)tempResult2,(int)((ulonglong)tempResult2 >> 0x20));\n            pdigitChar4 = pdigitChar5 + 1;\n            *pdigitChar5 = carry + 0x30;\n            pdigitChar5 = pdigitChar4;\n            if (outExponent == (int)pdigitChar4 - (int)pdigitChar8) goto LAB_08007f3a;\n            tempResult = FUN_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,DAT_080081f8);\n            index = FUN_08000998((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        tempResult = FUN_0800015c((int)tempResult,(int)((ulonglong)tempResult >> 0x20));\n        uVar17 = (undefined4)((ulonglong)tempResult >> 0x20);\n        index = FUN_080009e8((int)tempResult,uVar17,temp5,uVar11);\n        if ((index == 0) &&\n           ((index = FUN_08000998((int)tempResult,uVar17,temp5,uVar11), index == 0 || ((carry & 1) == 0)\n            ))) goto LAB_08008294;\n        digitChar = pdigitChar5[-1];\nLAB_08007f7c:\n        while (pdigitChar4 = pdigitChar5 + -1, digitChar == '9') {\n          if (pdigitChar8 == pdigitChar4) {\n            *pdigitChar8 = '0';\n            digitChar = pdigitChar5[-1];\n            numDigits = numDigits + 1;\n            pdigitChar4 = pdigitChar8;\n            break;\n          }\n          digitChar = pdigitChar5[-2];\n          pdigitChar5 = pdigitChar4;\n        }\n        *pdigitChar4 = digitChar + '\\x01';\n        goto LAB_08008294;\n      }\n      if (outExponent == 0) {\n        tempResult = FUN_080004c8(temp5,uVar11,0,DAT_080086c8);\n        index = FUN_080009d4((int)tempResult,(int)((ulonglong)tempResult >> 0x20),sign,temp);\n        uVar12 = outExponent;\n        temp2 = outExponent;\n        if (index == 0) goto LAB_08008406;\n      }\n      else {\n        uVar12 = 0;\n        temp2 = 0;\n      }\nLAB_080084f0:\n      numDigits = ~precision;\n      pdigitChar8 = pdigitChar5;\n      goto LAB_08008416;\n    }\n    index = trailingZeros;\n    if (isZero == 0) {\n      outDigitsLength = leadingZeros;\n      uVar12 = isZero;\n    }\n    else {\n      if ((int)numDigits < 2) {\n        if (outDigitsLength == 0) {\n          outDigitsLength = leadingZeros;\n          leadingZeros = leadingZeros + (0x36 - tempDigitsLength);\n          offset = offset + (0x36 - tempDigitsLength);\n        }\n        else {\n          outDigitsLength = leadingZeros;\n          leadingZeros = leadingZeros + tempArray[0] + 0x433;\n          offset = offset + tempArray[0] + 0x433;\n        }\n      }\n      else {\n        shift = outExponent - 1;\n        if (trailingZeros < shift) {\n          numLeadingZeros = numLeadingZeros + (shift - trailingZeros);\n          index = 0;\n          trailingZeros = shift;\n        }\n        else {\n          index = trailingZeros - shift;\n        }\n        if ((int)outExponent < 0) {\n          outDigitsLength = leadingZeros - outExponent;\n        }\n        else {\n          offset = offset + outExponent;\n          outDigitsLength = leadingZeros;\n          leadingZeros = leadingZeros + outExponent;\n        }\n      }\n      uVar12 = FUN_08009244(value,1);\n    }\n    if ((0 < outDigitsLength) && (0 < offset)) {\n      shift = outDigitsLength;\n      if (offset <= outDigitsLength) {\n        shift = offset;\n      }\n      offset = offset - shift;\n      leadingZeros = leadingZeros - shift;\n      outDigitsLength = outDigitsLength - shift;\n    }\n    if (trailingZeros != 0) {\n      if (isZero == 0) {\n        result = FUN_080093a4(value,result,trailingZeros);\n      }\n      else {\n        temp5 = result;\n        if (index != 0) {\n          uVar12 = FUN_080093a4(value,uVar12,index);\n          temp5 = FUN_08009258(value,uVar12,result);\n          FUN_0800910c(value,result);\n          result = temp5;\n          if (trailingZeros - index == 0) goto LAB_08008062;\n        }\n        result = FUN_080093a4(value,temp5,trailingZeros - index);\n      }\n    }\nLAB_08008062:\n    temp2 = FUN_08009244(value,1);\n    if (numLeadingZeros == 0) {\n      if (((int)numDigits < 2) && (sign == 0)) {\nLAB_0800835a:\n        if ((temp & 0xfffff) == 0) {\n          temp = temp & 0x7ff00000;\n          if (temp != 0) {\n            offset = offset + 1;\n            leadingZeros = leadingZeros + 1;\n            temp = 1;\n          }\n        }\n        else {\n          temp = 0;\n        }\n        isNegative = numLeadingZeros != 0;\n        temp3 = sign;\n        numLeadingZeros = temp;\n        if (isNegative) goto LAB_080082d4;\n      }\n      index = 1;\n    }\n    else {\n      tempResult = FUN_080093a4(value,temp2);\n      temp2 = (uint)tempResult;\n      if (((int)numDigits < 2) && (sign == 0)) goto LAB_0800835a;\n      numLeadingZeros = 0;\n      temp3 = (uint)((ulonglong)tempResult >> 0x20);\nLAB_080082d4:\n      index = FUN_080091a4(*(undefined4 *)(temp2 + *(int *)(temp2 + 0x10) * 4 + 0x10),temp3);\n      index = 0x20 - index;\n    }\n    temp = index + offset & 0x1f;\n    if (temp == 0) {\n      index = 0x1c;\nLAB_08008096:\n      offset = offset + index;\n      leadingZeros = leadingZeros + index;\n      outDigitsLength = outDigitsLength + index;\n    }\n    else {\n      if (4 < (int)(0x20 - temp)) {\n        index = 0x1c - temp;\n        goto LAB_08008096;\n      }\n      if (0x20 - temp != 4) {\n        index = 0x3c - temp;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < leadingZeros) {\n      result = FUN_08009444(value,result,leadingZeros);\n    }\n    if (0 < offset) {\n      temp2 = FUN_08009444(value,temp2,offset);\n    }\n    pdigitChar4 = pdigitChar8;\n    if ((isInfinite != 0) && (index = FUN_080094f8(result,temp2), index < 0)) {\n      numDigits = numDigits - 1;\n      result = FUN_08009120(value,result,10,0);\n      if (isZero == 0) {\n        if ((0 < (int)minDigits) || ((int)numDigits < 3)) {\n          outExponent = minDigits;\n          goto LAB_0800820a;\n        }\n      }\n      else {\n        uVar12 = FUN_08009120(value,uVar12,10,0);\n        if ((0 < (int)minDigits) || ((int)numDigits < 3)) {\n          outExponent = minDigits;\n          goto LAB_080080de;\n        }\n      }\n      outExponent = minDigits;\nLAB_080084e8:\n      if (outExponent == 0) {\n        outExponent = FUN_08009120(value,temp2,5);\n        index = FUN_080094f8(result,outExponent);\n        temp2 = outExponent;\n        if (0 < index) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)outExponent < 1) && (2 < (int)numDigits)) goto LAB_080084e8;\n    if (isZero == 0) {\nLAB_0800820a:\n      while( true ) {\n        tempIndex = FUN_080078c0(result,temp2);\n        tempIndex = tempIndex + 0x30;\n        pdigitChar5 = pdigitChar4 + 1;\n        *pdigitChar4 = (char)tempIndex;\n        if ((int)outExponent <= (int)pdigitChar5 - (int)pdigitChar8) break;\n        result = FUN_08009120(value,result,10,0);\n        pdigitChar4 = pdigitChar5;\n      }\n      outValue = 0;\n    }\n    else {\nLAB_080080de:\n      outValue = uVar12;\n      if (0 < outDigitsLength) {\n        outValue = FUN_08009444(value,uVar12,outDigitsLength);\n      }\n      uVar12 = outValue;\n      if (numLeadingZeros != 0) {\n        index = FUN_080090c0(value,*(undefined4 *)(outValue + 4));\n        FUN_08001084(index + 0xc,outValue + 0xc,(*(int *)(outValue + 0x10) + 2) * 4);\n        uVar12 = FUN_08009444(value,index,1);\n      }\nLAB_08008108:\n      index = FUN_080078c0(result,temp2);\n      shift = FUN_080094f8(result,outValue);\n      offset = FUN_08009530(value,temp2,uVar12);\n      tempIndex = index + 0x30;\n      if (*(int *)(offset + 0xc) == 0) {\n        temp = FUN_080094f8(result);\n        FUN_0800910c(value,offset);\n        if (((temp != 0) || (numDigits != 0)) || (temp = numDigits, (sign & 1) != 0))\n        goto LAB_0800815a;\n        if (tempIndex != 0x39) {\n          if (0 < shift) {\nLAB_0800874c:\n            tempIndex = index + 0x31;\n          }\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pdigitChar5 = pdigitChar4 + 1;\n        digitChar = '9';\n        *pdigitChar4 = '9';\n        goto LAB_08008268;\n      }\n      FUN_0800910c(value,offset);\n      temp = 1;\nLAB_0800815a:\n      if ((shift < 0) || (((shift == 0 && (numDigits == 0)) && ((sign & 1) == 0)))) {\n        if (0 < (int)temp) {\n          result = FUN_08009444(value,result,1);\n          shift = FUN_080094f8(result,temp2);\n          if ((0 < shift) || ((shift == 0 && (index << 0x1f < 0)))) {\n            if (tempIndex != 0x39) goto LAB_0800874c;\n            goto LAB_08008752;\n          }\n        }\nLAB_080085a4:\n        pdigitChar5 = pdigitChar4 + 1;\n        *pdigitChar4 = (char)tempIndex;\n        goto LAB_08008274;\n      }\n      pdigitChar5 = pdigitChar4 + 1;\n      if (0 < (int)temp) {\n        if (tempIndex == 0x39) goto LAB_08008752;\n        *pdigitChar4 = (char)index + '1';\n        goto LAB_08008274;\n      }\n      *pdigitChar4 = (char)tempIndex;\n      if (pdigitChar8 + (outExponent - 1) != pdigitChar4) {\n        result = FUN_08009120(value,result,10,0);\n        pdigitChar4 = pdigitChar5;\n        if (outValue == uVar12) {\n          outValue = FUN_08009120(value,outValue,10,0);\n          uVar12 = outValue;\n        }\n        else {\n          outValue = FUN_08009120(value,outValue,10,0);\n          uVar12 = FUN_08009120(value,uVar12,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    result = FUN_08009444(value,result,1);\n    index = FUN_080094f8(result,temp2);\n    digitChar = pdigitChar5[-1];\n    if ((0 < index) || ((index == 0 && (tempIndex << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pdigitChar4 = pdigitChar5 + -1;\n        if (digitChar != '9') goto code_r0x08008270;\n        if (pdigitChar8 == pdigitChar4) {\n          *pdigitChar8 = '1';\n          numDigits = numDigits + 1;\n          goto LAB_08008274;\n        }\n        digitChar = pdigitChar5[-2];\n        pdigitChar5 = pdigitChar4;\n      } while( true );\n    }\n    while (digitChar == '0') {\n      digitChar = pdigitChar5[-2];\n      pdigitChar5 = pdigitChar5 + -1;\n    }\nLAB_08008274:\n    FUN_0800910c(value,temp2);\n    if (uVar12 == 0) goto LAB_08008294;\n    if ((outValue != 0) && (outValue != uVar12)) {\n      FUN_0800910c(value);\n    }\n  }\n  FUN_0800910c(value,uVar12);\nLAB_08008294:\n  FUN_0800910c(value,result);\n  *pdigitChar5 = '\\0';\n  *outDigits = numDigits + 1;\n  if (outExponent == (char **)0x0) {\n    return pdigitChar8;\n  }\n  *outExponent = pdigitChar5;\n  return pdigitChar8;\ncode_r0x08008270:\n  *pdigitChar4 = digitChar + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "called": [
                "FUN_08009258",
                "FUN_080003f4",
                "FUN_0800910c",
                "FUN_08009120",
                "FUN_080004c8",
                "FUN_080009ac",
                "FUN_0800119c",
                "FUN_080078c0",
                "FUN_08009630",
                "FUN_080093a4",
                "FUN_08009444",
                "FUN_080003d4",
                "FUN_0800015c",
                "FUN_080009d4",
                "FUN_08009244",
                "FUN_08001084",
                "FUN_08000158",
                "FUN_08000998",
                "FUN_080094f8",
                "FUN_08009530",
                "FUN_080090c0",
                "FUN_0800071c",
                "FUN_080009e8",
                "FUN_080091a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080079e8",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "convert_float_to_char_080079e8"
        },
        "FUN_0800166c": {
            "renaming": {
                "FUN_0800166c": "bitwise_shift_and_combine_0800166c",
                "param_1": "input_shift_amount",
                "param_2": "input_bits",
                "param_3": "output_bits",
                "uVar1": "shift_amount"
            },
            "code": "\nuint bitwise_shift_and_combine_0800166c(uint input_shift_amount,uint input_bits,uint output_bits)\n\n{\n  uint shift_amount;\n  \n  input_shift_amount = input_shift_amount & 7;\n  shift_amount = 7 - input_shift_amount;\n  if (3 < shift_amount) {\n    shift_amount = 4;\n  }\n  if (input_shift_amount + 4 < 7) {\n    input_shift_amount = 0;\n  }\n  else {\n    input_shift_amount = input_shift_amount - 3;\n  }\n  return output_bits & ~(-1 << (input_shift_amount & 0xff)) |\n         (~(-1 << (shift_amount & 0xff)) & input_bits) << (input_shift_amount & 0xff);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800166c",
            "calling": [
                "FUN_0800172a"
            ],
            "imported": false,
            "current_name": "bitwise_shift_and_combine_0800166c"
        },
        "FUN_0800360c": {
            "renaming": {
                "FUN_0800360c": "set_flags_0800360c",
                "param_1": "ptr_arr"
            },
            "code": "\nundefined4 set_flags_0800360c(uint **ptr_arr)\n\n{\n  (*ptr_arr)[3] = (*ptr_arr)[3] | 1;\n  **ptr_arr = **ptr_arr | 1;\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800360c",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "set_flags_0800360c"
        },
        "FUN_08005d68": {
            "renaming": {
                "FUN_08005d68": "fill_buffer_with_value_08005d68",
                "param_1": "buffer",
                "param_2": "value",
                "param_3": "buffer_size",
                "puVar1": "buffer_ptr",
                "puVar2": "temp_buffer_ptr",
                "uVar3": "remaining_buffer_size",
                "uVar4": "value_32",
                "bVar5": "is_remaining_buffer_size_zero"
            },
            "code": "\nvoid fill_buffer_with_value_08005d68(undefined4 *buffer,undefined value,uint buffer_size)\n\n{\n  undefined4 *buffer_ptr;\n  undefined4 *temp_buffer_ptr;\n  uint remaining_buffer_size;\n  undefined4 value_32;\n  bool is_remaining_buffer_size_zero;\n  \n  if (((uint)buffer & 3) != 0) {\n    remaining_buffer_size = buffer_size - 1;\n    buffer_ptr = buffer;\n    if (buffer_size == 0) {\n      return;\n    }\n    while( true ) {\n      buffer = (undefined4 *)((int)buffer_ptr + 1);\n      *(undefined *)buffer_ptr = value;\n      buffer_size = remaining_buffer_size;\n      if (((uint)buffer & 3) == 0) break;\n      is_remaining_buffer_size_zero = remaining_buffer_size == 0;\n      remaining_buffer_size = remaining_buffer_size - 1;\n      buffer_ptr = buffer;\n      if (is_remaining_buffer_size_zero) {\n        return;\n      }\n    }\n  }\n  if (3 < buffer_size) {\n    value_32 = CONCAT22(CONCAT11(value,value),CONCAT11(value,value));\n    remaining_buffer_size = buffer_size;\n    buffer_ptr = buffer;\n    if (0xf < buffer_size) {\n      remaining_buffer_size = buffer_size - 0x10;\n      buffer_ptr = buffer + 4;\n      do {\n        buffer_ptr[-4] = value_32;\n        buffer_ptr[-3] = value_32;\n        buffer_ptr[-2] = value_32;\n        buffer_ptr[-1] = value_32;\n        buffer_ptr = buffer_ptr + 4;\n      } while (buffer_ptr != (undefined4 *)((int)buffer + (remaining_buffer_size & 0xfffffff0) + 0x20));\n      buffer_size = buffer_size & 0xf;\n      buffer = buffer + ((remaining_buffer_size >> 4) + 1) * 4;\n      remaining_buffer_size = buffer_size;\n      buffer_ptr = buffer;\n      if (buffer_size < 4) goto LAB_08005de4;\n    }\n    do {\n      buffer_size = buffer_size - 4;\n      *buffer = value_32;\n      buffer = buffer + 1;\n    } while (3 < buffer_size);\n    buffer = (undefined4 *)((int)buffer_ptr + (remaining_buffer_size - 4 & 0xfffffffc) + 4);\n    buffer_size = remaining_buffer_size & 3;\n  }\nLAB_08005de4:\n  if (buffer_size != 0) {\n    buffer_ptr = buffer;\n    do {\n      temp_buffer_ptr = (undefined4 *)((int)buffer_ptr + 1);\n      *(undefined *)buffer_ptr = value;\n      buffer_ptr = temp_buffer_ptr;\n    } while ((undefined4 *)(buffer_size + (int)buffer) != temp_buffer_ptr);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d68",
            "calling": [
                "FUN_08004f60",
                "FUN_08009980"
            ],
            "imported": false,
            "current_name": "fill_buffer_with_value_08005d68"
        },
        "FUN_080017c4": {
            "renaming": {
                "FUN_080017c4": "update_bits_080017c4",
                "param_1": "bits_to_update",
                "param_2": "bitmask",
                "uVar1": "mask_1",
                "uVar2": "mask_2",
                "uVar3": "bit_shift",
                "uVar4": "bitwise_and",
                "uVar5": "bitmask_value",
                "puVar6": "bits_to_update_ptr",
                "iVar7": "bits_to_update_index",
                "local_10": "updated_bits",
                "local_c": "bit_index"
            },
            "code": "\nvoid update_bits_080017c4(uint *bits_to_update,uint *bitmask)\n\n{\n  uint mask_1;\n  uint mask_2;\n  uint bit_shift;\n  uint bitwise_and;\n  uint bitmask_value;\n  uint *bits_to_update_ptr;\n  int bits_to_update_index;\n  uint updated_bits;\n  uint bit_index;\n  \n  updated_bits = 0;\n  bit_index = 0;\n  do {\n    if (0xf < bit_index) {\n      return;\n    }\n    bit_shift = 1 << (bit_index & 0xff);\n    bitwise_and = *bitmask & bit_shift;\n    if (bitwise_and == bit_shift) {\n      bitmask_value = bitmask[1];\n      if (bitmask_value == 0x12) {\n        updated_bits = bitmask[3] + 0xc;\n      }\n      else if (bitmask_value < 0x13) {\n        if (bitmask_value == 2) {\n          updated_bits = bitmask[3] + 8;\n        }\n        else if (bitmask_value < 3) {\n          if (bitmask_value == 0) goto LAB_08001882;\n          if (bitmask_value == 1) {\n            updated_bits = bitmask[3];\n          }\n        }\n        else if (bitmask_value == 3) {\n          updated_bits = 0;\n        }\n        else if (bitmask_value == 0x11) {\n          updated_bits = bitmask[3] + 4;\n        }\n      }\n      else if (((bitmask_value == DAT_08001a4c) ||\n               (((mask_1 = DAT_08001a54, mask_2 = DAT_08001a50, DAT_08001a4c < bitmask_value &&\n                 (mask_1 = DAT_08001a60, mask_2 = DAT_08001a5c, bitmask_value == DAT_08001a58)) ||\n                (bitmask_value == mask_2)))) || (bitmask_value == mask_1)) {\nLAB_08001882:\n        if (bitmask[2] == 0) {\n          updated_bits = 4;\n        }\n        else if (bitmask[2] == 1) {\n          updated_bits = 8;\n          bits_to_update[4] = bit_shift;\n        }\n        else {\n          updated_bits = 8;\n          bits_to_update[5] = bit_shift;\n        }\n      }\n      if (bitwise_and < 0x100) {\n        bit_shift = bit_index << 2;\n        bits_to_update_ptr = bits_to_update;\n      }\n      else {\n        bits_to_update_ptr = bits_to_update + 1;\n        bit_shift = (bit_index - 8) * 4;\n      }\n      *bits_to_update_ptr = *bits_to_update_ptr & ~(0xf << (bit_shift & 0xff)) | updated_bits << (bit_shift & 0xff);\n      if ((bitmask[1] & 0x10000000) != 0) {\n        *(uint *)(DAT_08001a64 + 0x18) = *(uint *)(DAT_08001a64 + 0x18) | 1;\n        if (bits_to_update == DAT_08001a6c) {\n          bits_to_update_index = 0;\n        }\n        else if (bits_to_update == DAT_08001a70) {\n          bits_to_update_index = 1;\n        }\n        else if (bits_to_update == DAT_08001a74) {\n          bits_to_update_index = 2;\n        }\n        else if (bits_to_update == DAT_08001a78) {\n          bits_to_update_index = 3;\n        }\n        else {\n          bits_to_update_index = 4;\n        }\n        *(uint *)(DAT_08001a68 + ((bit_index >> 2) + 2) * 4) =\n             bits_to_update_index << ((bit_index & 3) << 2) |\n             ~(0xf << ((bit_index & 3) << 2)) & *(uint *)(DAT_08001a68 + ((bit_index >> 2) + 2) * 4);\n        if ((bitmask[1] & 0x10000) == 0) {\n          *DAT_08001a7c = ~bitwise_and & *DAT_08001a7c;\n        }\n        else {\n          *DAT_08001a7c = bitwise_and | *DAT_08001a7c;\n        }\n        if ((bitmask[1] & 0x20000) == 0) {\n          DAT_08001a7c[1] = ~bitwise_and & DAT_08001a7c[1];\n        }\n        else {\n          DAT_08001a7c[1] = bitwise_and | DAT_08001a7c[1];\n        }\n        if ((bitmask[1] & 0x100000) == 0) {\n          DAT_08001a7c[2] = ~bitwise_and & DAT_08001a7c[2];\n        }\n        else {\n          DAT_08001a7c[2] = bitwise_and | DAT_08001a7c[2];\n        }\n        if ((bitmask[1] & 0x200000) == 0) {\n          DAT_08001a7c[3] = ~bitwise_and & DAT_08001a7c[3];\n        }\n        else {\n          DAT_08001a7c[3] = bitwise_and | DAT_08001a7c[3];\n        }\n      }\n    }\n    bit_index = bit_index + 1;\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080017c4",
            "calling": [
                "FUN_080055f4",
                "FUN_08005680"
            ],
            "imported": false,
            "current_name": "update_bits_080017c4"
        },
        "FUN_080035a4": {
            "renaming": {
                "FUN_080035a4": "check_and_process_data_080035a4",
                "param_1": "data_ptr",
                "uVar1": "return_value"
            },
            "code": "\nundefined4 check_and_process_data_080035a4(undefined4 *data_ptr)\n\n{\n  undefined4 return_value;\n  \n  if (data_ptr == (undefined4 *)0x0) {\n    return_value = 1;\n  }\n  else {\n    if (*(char *)((int)data_ptr + 0x3d) == '\\0') {\n      *(undefined *)(data_ptr + 0xf) = 0;\n      FUNC_080035fa(data_ptr);\n    }\n    *(undefined *)((int)data_ptr + 0x3d) = 2;\n    FUN_08003c94(*data_ptr,data_ptr + 1);\n    *(undefined *)((int)data_ptr + 0x3d) = 1;\n    return_value = 0;\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_080035fa",
                "FUN_08003c94"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035a4",
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "imported": false,
            "current_name": "check_and_process_data_080035a4"
        },
        "FUN_080041ea": {
            "renaming": {
                "FUN_080041ea": "update_bits_080041ea",
                "param_1": "base_address",
                "param_2": "bit_position",
                "param_3": "new_value"
            },
            "code": "\nvoid update_bits_080041ea(int base_address,uint bit_position,int new_value)\n\n{\n  *(uint *)(base_address + 0x20) = *(uint *)(base_address + 0x20) & ~(1 << (bit_position & 0xff));\n  *(uint *)(base_address + 0x20) = *(uint *)(base_address + 0x20) | new_value << (bit_position & 0xff);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041ea",
            "calling": [
                "FUN_080036a8"
            ],
            "imported": false,
            "current_name": "update_bits_080041ea"
        },
        "FUN_08004ae0": {
            "renaming": {
                "FUN_08004ae0": "decode_and_assign_values_08004ae0",
                "param_1": "output_values",
                "local_2c": "buffer",
                "local_2b": "unused_byte_1",
                "local_2a": "byte_1",
                "local_29": "byte_2",
                "local_28": "byte_3",
                "local_27": "byte_4",
                "local_26": "byte_5",
                "local_25": "byte_6",
                "local_24": "byte_7",
                "local_23": "byte_8",
                "local_22": "byte_9",
                "local_21": "byte_10",
                "local_20": "byte_11",
                "local_1f": "unused_byte_2",
                "local_1e": "value_7",
                "local_1c": "value_5",
                "local_1a": "value_4",
                "local_18": "value_3",
                "local_16": "value_2",
                "local_14": "value_1"
            },
            "code": "\nvoid decode_and_assign_values_08004ae0(undefined4 *output_values)\n\n{\n  undefined4 uVar1;\n  undefined buffer;\n  undefined unused_byte_1;\n  undefined byte_1;\n  undefined byte_2;\n  undefined byte_3;\n  undefined byte_4;\n  undefined byte_5;\n  undefined byte_6;\n  undefined byte_7;\n  undefined byte_8;\n  undefined byte_9;\n  undefined byte_10;\n  undefined byte_11;\n  undefined unused_byte_2;\n  short value_7;\n  short value_5;\n  short value_4;\n  short value_3;\n  short value_2;\n  short value_1;\n  \n  (**(code **)PTR_DAT_08004bd4)(0xd0,0x3b,&buffer,0xe);\n  value_1 = CONCAT11(byte_1,byte_2);\n  value_2 = CONCAT11(byte_3,byte_4);\n  value_3 = CONCAT11(byte_5,byte_6);\n  value_4 = CONCAT11(byte_7,byte_8);\n  value_5 = CONCAT11(byte_9,byte_10);\n  value_7 = CONCAT11(byte_11,unused_byte_2);\n  uVar1 = FUN_08000c10((int)CONCAT11(buffer,unused_byte_1));\n  *output_values = uVar1;\n  uVar1 = FUN_08000c10((int)value_1);\n  output_values[1] = uVar1;\n  uVar1 = FUN_08000c10((int)value_2);\n  output_values[2] = uVar1;\n  uVar1 = FUN_08000c10((int)value_3);\n  output_values[3] = uVar1;\n  uVar1 = FUN_08000c10((int)value_4);\n  output_values[4] = uVar1;\n  uVar1 = FUN_08000c10((int)value_5);\n  output_values[5] = uVar1;\n  uVar1 = FUN_08000c10((int)value_7);\n  output_values[6] = uVar1;\n  return;\n}\n\n",
            "called": [
                "FUN_08000c10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ae0",
            "calling": [
                "FUN_080049cc",
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "decode_and_assign_values_08004ae0"
        },
        "FUN_08001044": {
            "renaming": {
                "FUN_08001044": "check_num_validity_08001044",
                "param_1": "num",
                "uVar1": "shift_amount"
            },
            "code": "\nuint check_num_validity_08001044(uint num)\n\n{\n  uint shift_amount;\n  \n  if (((num & 0x80000000) != 0) || (num << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shift_amount = 0x9e - ((num << 1) >> 0x18);\n  if (-1 < (int)shift_amount) {\n    return (num << 8 | 0x80000000) >> (shift_amount & 0xff);\n  }\n  if ((shift_amount == 0xffffff9f) && ((num & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001044",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "check_num_validity_08001044"
        },
        "FUN_08009444": {
            "renaming": {
                "FUN_08009444": "decode_bits_to_array_08009444",
                "param_1": "ptr",
                "param_2": "array",
                "param_3": "bit_count",
                "iVar1": "index",
                "iVar2": "array_length",
                "iVar3": "bits_to_decode",
                "uVar4": "first_value",
                "iVar5": "array_offset",
                "iVar6": "temp_index",
                "puVar7": "current_word",
                "puVar8": "source_word",
                "puVar9": "current_word_ptr",
                "puVar10": "source_word_ptr",
                "puVar11": "source_end_ptr",
                "iVar12": "word_index",
                "iVar13": "decoded_length",
                "uVar14": "remaining_bits"
            },
            "code": "\nvoid decode_bits_to_array_08009444(int ptr,undefined4 *array,uint bit_count)\n\n{\n  int index;\n  int array_length;\n  int bits_to_decode;\n  undefined4 first_value;\n  int array_offset;\n  int temp_index;\n  uint *current_word;\n  uint *source_word;\n  uint *source_word_ptr;\n  uint *source_end_ptr;\n  int word_index;\n  int decoded_length;\n  uint remaining_bits;\n  uint *current_word_ptr;\n  \n  array_offset = array[4];\n  word_index = (int)bit_count >> 5;\n  decoded_length = word_index + array_offset + 1;\n  bits_to_decode = array[1];\n  array_length = array[2];\n  if ((int)array[2] < decoded_length) {\n    do {\n      temp_index = array_length * 2;\n      index = array_length * -2;\n      bits_to_decode = bits_to_decode + 1;\n      array_length = temp_index;\n    } while (decoded_length != temp_index && decoded_length + index < 0 == SBORROW4(decoded_length,temp_index));\n  }\n  array_length = FUN_080090c0(ptr,bits_to_decode);\n  current_word = (uint *)(array_length + 0x14);\n  if (0 < word_index) {\n    source_end_ptr = current_word + word_index;\n    source_word = current_word;\n    do {\n      current_word_ptr = source_word + 1;\n      *source_word = 0;\n      current_word = source_end_ptr;\n      source_word = current_word_ptr;\n    } while (current_word_ptr != source_end_ptr);\n  }\n  bits_to_decode = array[4];\n  source_word = array + 5;\n  bit_count = bit_count & 0x1f;\n  if (bit_count == 0) {\n    current_word = current_word + -1;\n    source_end_ptr = source_word;\n    do {\n      current_word_ptr = source_end_ptr + 1;\n      current_word = current_word + 1;\n      *current_word = *source_end_ptr;\n      source_end_ptr = current_word_ptr;\n    } while (current_word_ptr < source_word + bits_to_decode);\n  }\n  else {\n    remaining_bits = 0;\n    source_end_ptr = source_word;\n    do {\n      current_word_ptr = current_word;\n      *current_word_ptr = *source_end_ptr << bit_count | remaining_bits;\n      source_word_ptr = source_end_ptr + 1;\n      remaining_bits = *source_end_ptr >> (0x20 - bit_count & 0xff);\n      current_word = current_word_ptr + 1;\n      source_end_ptr = source_word_ptr;\n    } while (source_word_ptr < source_word + bits_to_decode);\n    current_word_ptr[1] = remaining_bits;\n    if (remaining_bits != 0) {\n      decoded_length = word_index + array_offset + 2;\n    }\n  }\n  array_offset = *(int *)(ptr + 0x4c);\n  bits_to_decode = array[1];\n  first_value = *(undefined4 *)(array_offset + bits_to_decode * 4);\n  *(int *)(array_length + 0x10) = decoded_length + -1;\n  *array = first_value;\n  *(undefined4 **)(array_offset + bits_to_decode * 4) = array;\n  return;\n}\n\n",
            "called": [
                "FUN_080090c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009444",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "decode_bits_to_array_08009444"
        },
        "FUN_080015fc": {
            "renaming": {
                "FUN_080015fc": "get_bits_from_uint_080015fc"
            },
            "code": "\nuint get_bits_from_uint_080015fc(void)\n\n{\n  return *(uint *)(DAT_08001614 + 0xc) >> 8 & 7;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015fc",
            "calling": [
                "FUN_0800172a"
            ],
            "imported": false,
            "current_name": "get_bits_from_uint_080015fc"
        },
        "FUN_08004436": {
            "renaming": {
                "FUN_08004436": "parse_input_08004436",
                "param_1": "input_data",
                "param_2": "input_string",
                "param_3": "input_length",
                "param_4": "timeout",
                "iVar1": "start_time",
                "iVar2": "elapsed_time",
                "uVar3": "return_code",
                "local_58": "current_char"
            },
            "code": "\nundefined4 parse_input_08004436(uint **input_data,ushort *input_string,short input_length,uint timeout)\n\n{\n  int start_time;\n  int elapsed_time;\n  undefined4 return_code;\n  ushort *current_char;\n  \n  if (*(char *)((int)input_data + 0x39) == ' ') {\n    if ((input_string == (ushort *)0x0) || (input_length == 0)) {\n      return_code = 1;\n    }\n    else if (*(char *)(input_data + 0xe) == '\\x01') {\n      return_code = 2;\n    }\n    else {\n      *(undefined *)(input_data + 0xe) = 1;\n      input_data[0xf] = (uint *)0x0;\n      *(undefined *)((int)input_data + 0x39) = 0x21;\n      start_time = FUN_080015a0();\n      *(short *)(input_data + 9) = input_length;\n      *(short *)((int)input_data + 0x26) = input_length;\n      current_char = input_string;\n      while (*(short *)((int)input_data + 0x26) != 0) {\n        *(short *)((int)input_data + 0x26) = *(short *)((int)input_data + 0x26) + -1;\n        if (input_data[2] == (uint *)0x1000) {\n          do {\n            if ((**input_data & 0x80) == 0x80) {\n              elapsed_time = 0;\n              goto LAB_0800454c;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (elapsed_time = FUN_080015a0(), (uint)(elapsed_time - start_time) <= timeout))));\n          (*input_data)[3] = (*input_data)[3] & 0xfffffe5f;\n          (*input_data)[5] = (*input_data)[5] & 0xfffffffe;\n          *(undefined *)((int)input_data + 0x39) = 0x20;\n          *(undefined *)((int)input_data + 0x3a) = 0x20;\n          *(undefined *)(input_data + 0xe) = 0;\n          elapsed_time = 3;\nLAB_0800454c:\n          if (elapsed_time != 0) {\n            return 3;\n          }\n          (*input_data)[1] = *current_char & 0x1ff;\n          if (input_data[4] == (uint *)0x0) {\n            current_char = current_char + 1;\n          }\n          else {\n            current_char = (ushort *)((int)current_char + 1);\n          }\n        }\n        else {\n          do {\n            if ((**input_data & 0x80) == 0x80) {\n              elapsed_time = 0;\n              goto LAB_08004614;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (elapsed_time = FUN_080015a0(), (uint)(elapsed_time - start_time) <= timeout))));\n          (*input_data)[3] = (*input_data)[3] & 0xfffffe5f;\n          (*input_data)[5] = (*input_data)[5] & 0xfffffffe;\n          *(undefined *)((int)input_data + 0x39) = 0x20;\n          *(undefined *)((int)input_data + 0x3a) = 0x20;\n          *(undefined *)(input_data + 0xe) = 0;\n          elapsed_time = 3;\nLAB_08004614:\n          if (elapsed_time != 0) {\n            return 3;\n          }\n          (*input_data)[1] = (uint)*(byte *)current_char;\n          current_char = (ushort *)((int)current_char + 1);\n        }\n      }\n      do {\n        if ((**input_data & 0x40) == 0x40) {\n          start_time = 0;\n          goto LAB_080046c6;\n        }\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (elapsed_time = FUN_080015a0(), (uint)(elapsed_time - start_time) <= timeout))));\n      (*input_data)[3] = (*input_data)[3] & 0xfffffe5f;\n      (*input_data)[5] = (*input_data)[5] & 0xfffffffe;\n      *(undefined *)((int)input_data + 0x39) = 0x20;\n      *(undefined *)((int)input_data + 0x3a) = 0x20;\n      *(undefined *)(input_data + 0xe) = 0;\n      start_time = 3;\nLAB_080046c6:\n      if (start_time == 0) {\n        *(undefined *)((int)input_data + 0x39) = 0x20;\n        *(undefined *)(input_data + 0xe) = 0;\n        return_code = 0;\n      }\n      else {\n        return_code = 3;\n      }\n    }\n  }\n  else {\n    return_code = 2;\n  }\n  return return_code;\n}\n\n",
            "called": [
                "FUN_080015a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004436",
            "calling": [
                "FUN_08004f3c"
            ],
            "imported": false,
            "current_name": "parse_input_08004436"
        },
        "FUN_08000110": {
            "renaming": {
                "FUN_08000110": "check_and_return_function_08000110",
                "param_1": "input_parameter"
            },
            "code": "\nundefined * check_and_return_function_08000110(undefined *input_parameter)\n\n{\n  if (*PTR_DAT_08000128 == '\\0') {\n    if (DAT_0800012c != 0) {\n      input_parameter = PTR_FUN_08000130;\n    }\n    *PTR_DAT_08000128 = 1;\n  }\n  return input_parameter;\n}\n\n",
            "called": [
                "FUN_08009e68"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000110",
            "calling": [],
            "imported": false,
            "current_name": "check_and_return_function_08000110"
        },
        "FUN_08003504": {
            "renaming": {
                "FUN_08003504": "get_pointer_value_08003504"
            },
            "code": "\nundefined4 get_pointer_value_08003504(void)\n\n{\n  return *(undefined4 *)PTR_DAT_08003514;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003504",
            "calling": [
                "FUN_080052a0",
                "FUN_08003518",
                "FUN_08003540"
            ],
            "imported": false,
            "current_name": "get_pointer_value_08003504"
        },
        "FUN_08000aa4": {
            "renaming": {
                "FUN_08000aa4": "floating_point_addition_08000aa4",
                "param_1": "mantissa_1",
                "param_2": "mantissa_2",
                "param_3": "exponent",
                "param_4": "sign",
                "iVar1": "exponent_difference",
                "uVar2": "mantissa_2_complement",
                "uVar3": "mantissa_1_normalized",
                "uVar4": "mantissa_1_shifted",
                "uVar5": "shift_amount",
                "uVar6": "exponent_sum",
                "iVar7": "mantissa_1_leading_bit",
                "bVar8": "comparison_result"
            },
            "code": "\nuint floating_point_addition_08000aa4(uint mantissa_1,uint mantissa_2,undefined4 exponent,uint sign)\n\n{\n  int exponent_difference;\n  uint mantissa_2_complement;\n  uint mantissa_1_normalized;\n  uint mantissa_1_shifted;\n  uint shift_amount;\n  uint exponent_sum;\n  int mantissa_1_leading_bit;\n  bool comparison_result;\n  \n  mantissa_2_complement = mantissa_2 ^ 0x80000000;\n  mantissa_1_shifted = mantissa_1 << 1;\n  comparison_result = mantissa_1_shifted == 0;\n  if (!comparison_result) {\n    sign = mantissa_2 << 1;\n    comparison_result = sign == 0;\n  }\n  if (!comparison_result) {\n    comparison_result = mantissa_1_shifted == sign;\n  }\n  mantissa_1_leading_bit = (int)mantissa_1_shifted >> 0x18;\n  if (!comparison_result) {\n    comparison_result = mantissa_1_leading_bit == -1;\n  }\n  if (!comparison_result) {\n    comparison_result = (int)sign >> 0x18 == -1;\n  }\n  if (comparison_result) {\n    exponent_difference = (int)(mantissa_2 << 1) >> 0x18;\n    if (mantissa_1_leading_bit == -1 || exponent_difference == -1) {\n      mantissa_1_shifted = mantissa_2_complement;\n      if (mantissa_1_leading_bit == -1) {\n        mantissa_1_shifted = mantissa_1;\n      }\n      if (mantissa_1_leading_bit != -1 || exponent_difference != -1) {\n        mantissa_2_complement = mantissa_1_shifted;\n      }\n      comparison_result = (mantissa_1_shifted & 0x7fffff) == 0;\n      if (comparison_result) {\n        comparison_result = (mantissa_2_complement & 0x7fffff) == 0;\n      }\n      if (comparison_result) {\n        comparison_result = mantissa_1_shifted == mantissa_2_complement;\n      }\n      if (!comparison_result) {\n        mantissa_1_shifted = mantissa_1_shifted | 0x400000;\n      }\n      return mantissa_1_shifted;\n    }\n    if (((mantissa_1 ^ mantissa_2_complement) & 0x7fffffff) != 0) {\n      if (mantissa_1_shifted == 0) {\n        mantissa_1 = mantissa_2_complement;\n      }\n      return mantissa_1;\n    }\n    if (mantissa_1 != mantissa_2_complement) {\n      return 0;\n    }\n    if ((mantissa_1_shifted & 0xff000000) == 0) {\n      mantissa_2_complement = mantissa_1 << 1;\n      if ((mantissa_1 & 0x80000000) != 0) {\n        mantissa_2_complement = mantissa_2_complement | 0x80000000;\n      }\n      return mantissa_2_complement;\n    }\n    if (mantissa_1_shifted < 0xfe000000) {\n      return mantissa_1 + 0x800000;\n    }\n    mantissa_1 = mantissa_1 & 0x80000000;\nLAB_08000bde:\n    return mantissa_1 | 0x7f800000;\n  }\n  mantissa_1_shifted = mantissa_1_shifted >> 0x18;\n  sign = sign >> 0x18;\n  exponent_sum = sign - mantissa_1_shifted;\n  comparison_result = exponent_sum != 0;\n  shift_amount = mantissa_1_shifted;\n  if (comparison_result && mantissa_1_shifted <= sign) {\n    shift_amount = mantissa_1_shifted + exponent_sum;\n  }\n  if (comparison_result && mantissa_1_shifted <= sign) {\n    mantissa_2_complement = mantissa_2_complement ^ mantissa_1;\n  }\n  if (comparison_result && mantissa_1_shifted <= sign) {\n    mantissa_1 = mantissa_1 ^ mantissa_2_complement;\n  }\n  if (comparison_result && mantissa_1_shifted <= sign) {\n    mantissa_2_complement = mantissa_2_complement ^ mantissa_1;\n  }\n  if (sign < mantissa_1_shifted) {\n    exponent_sum = -exponent_sum;\n  }\n  if (0x19 < exponent_sum) {\n    return mantissa_1;\n  }\n  mantissa_1_shifted = mantissa_1 & 0xffffff | 0x800000;\n  if ((mantissa_1 & 0x80000000) != 0) {\n    mantissa_1_shifted = -mantissa_1_shifted;\n  }\n  mantissa_1_normalized = mantissa_2_complement & 0xffffff | 0x800000;\n  if ((mantissa_2_complement & 0x80000000) != 0) {\n    mantissa_1_normalized = -mantissa_1_normalized;\n  }\n  if (shift_amount == exponent_sum) {\n    mantissa_1_normalized = mantissa_1_normalized ^ 0x800000;\n    if (shift_amount == 0) {\n      mantissa_1_shifted = mantissa_1_shifted ^ 0x800000;\n      shift_amount = 1;\n    }\n    else {\n      exponent_sum = exponent_sum - 1;\n    }\n  }\n  mantissa_1_shifted = mantissa_1_shifted + ((int)mantissa_1_normalized >> (exponent_sum & 0xff));\n  mantissa_1_normalized = mantissa_1_normalized << (0x20 - exponent_sum & 0xff);\n  mantissa_1 = mantissa_1_shifted & 0x80000000;\n  if ((int)mantissa_1_shifted < 0) {\n    comparison_result = mantissa_1_normalized != 0;\n    mantissa_1_normalized = -mantissa_1_normalized;\n    mantissa_1_shifted = -mantissa_1_shifted - (uint)comparison_result;\n  }\n  if (mantissa_1_shifted < 0x800000) {\n    mantissa_2_complement = mantissa_1_normalized & 0x80000000;\n    mantissa_1_normalized = mantissa_1_normalized << 1;\n    mantissa_1_shifted = mantissa_1_shifted * 2 + (uint)(mantissa_2_complement != 0);\n    mantissa_2_complement = shift_amount - 2;\n    if ((mantissa_1_shifted & 0x800000) == 0) {\n      mantissa_1_leading_bit = count_leading_zeroes(mantissa_1_shifted);\n      exponent_sum = mantissa_1_leading_bit - 8;\n      mantissa_1_shifted = mantissa_1_shifted << (exponent_sum & 0xff);\n      if ((int)mantissa_2_complement < (int)exponent_sum) {\n        mantissa_1_shifted = mantissa_1_shifted >> (-(mantissa_2_complement - exponent_sum) & 0xff);\n      }\n      else {\n        mantissa_1_shifted = mantissa_1_shifted + (mantissa_2_complement - exponent_sum) * 0x800000;\n      }\n      return mantissa_1_shifted | mantissa_1;\n    }\n  }\n  else {\n    mantissa_2_complement = shift_amount - 1;\n    if (0xffffff < mantissa_1_shifted) {\n      mantissa_2_complement = mantissa_1_shifted & 1;\n      mantissa_1_shifted = mantissa_1_shifted >> 1;\n      mantissa_1_normalized = (uint)(mantissa_2_complement != 0) << 0x1f | mantissa_1_normalized >> 1;\n      mantissa_2_complement = shift_amount;\n      if (0xfd < shift_amount) goto LAB_08000bde;\n    }\n  }\n  mantissa_1_shifted = mantissa_1_shifted + mantissa_2_complement * 0x800000 + (uint)(0x7fffffff < mantissa_1_normalized);\n  if (mantissa_1_normalized == 0x80000000) {\n    mantissa_1_shifted = mantissa_1_shifted & 0xfffffffe;\n  }\n  return mantissa_1_shifted | mantissa_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000aa4",
            "calling": [
                "FUN_08004bd8",
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "floating_point_addition_08000aa4"
        },
        "FUN_08004ee8": {
            "renaming": {
                "FUN_08004ee8": "execute_data_transfer_08004ee8",
                "param_1": "source_address",
                "param_2": "destination_address",
                "param_3": "data_size",
                "param_4": "transfer_type"
            },
            "code": "\nvoid execute_data_transfer_08004ee8(undefined source_address,undefined destination_address,undefined4 data_size,undefined2 transfer_type)\n\n{\n  FUN_08001f6c(PTR_DAT_08004f28,source_address,destination_address,1,data_size,transfer_type,*(undefined4 *)PTR_DAT_08004f24);\n  return;\n}\n\n",
            "called": [
                "FUN_08001f6c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ee8",
            "calling": [],
            "imported": false,
            "current_name": "execute_data_transfer_08004ee8"
        },
        "FUN_080094f8": {
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1",
                "param_2": "array2",
                "iVar1": "array_difference",
                "puVar2": "ptr_array2",
                "iVar3": "array2_offset",
                "puVar4": "ptr_array1"
            },
            "code": "\nint compare_arrays_080094f8(int array1,int array2)\n\n{\n  int array_difference;\n  uint *ptr_array2;\n  int array2_offset;\n  uint *ptr_array1;\n  \n  array2_offset = *(int *)(array2 + 0x10);\n  array_difference = *(int *)(array1 + 0x10) - array2_offset;\n  if (array_difference == 0) {\n    ptr_array2 = (uint *)(array2 + 0x14 + array2_offset * 4);\n    ptr_array1 = (uint *)(array1 + 0x14) + array2_offset;\n    do {\n      ptr_array1 = ptr_array1 + -1;\n      ptr_array2 = ptr_array2 + -1;\n      if (*ptr_array1 != *ptr_array2) {\n        if (*ptr_array2 <= *ptr_array1) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1 + 0x14) < ptr_array1);\n  }\n  return array_difference;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080094f8",
            "calling": [
                "FUN_080078c0",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "compare_arrays_080094f8"
        },
        "FUN_08000998": {
            "renaming": {
                "FUN_08000998": "check_if_in_zr_is_not_null_08000998",
                "in_ZR": "input_character"
            },
            "code": "\nbool check_if_in_ZR_is_not_null_08000998(void)\n\n{\n  char input_character;\n  \n  FUN_08000988();\n  return input_character != '\\0';\n}\n\n",
            "called": [
                "FUN_08000988"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000998",
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "check_if_in_zr_is_not_null_08000998"
        },
        "FUN_08000aa8": {
            "renaming": {
                "FUN_08000aa8": "float32_to_float32_08000aa8",
                "param_1": "input_float",
                "param_2": "rounding_precision",
                "param_3": "rounding_mode",
                "param_4": "exception_flags",
                "iVar1": "sign_bit",
                "uVar2": "mantissa_bits",
                "uVar3": "input_bits",
                "uVar4": "shift_amount",
                "uVar5": "distance",
                "iVar6": "exponent_bits",
                "bVar7": "is_zero"
            },
            "code": "\nuint float32_to_float32_08000aa8(uint input_float,uint rounding_precision,undefined4 rounding_mode,uint exception_flags)\n\n{\n  int sign_bit;\n  uint mantissa_bits;\n  uint input_bits;\n  uint shift_amount;\n  uint distance;\n  int exponent_bits;\n  bool is_zero;\n  \n  input_bits = input_float << 1;\n  is_zero = input_bits == 0;\n  if (!is_zero) {\n    exception_flags = rounding_precision << 1;\n    is_zero = exception_flags == 0;\n  }\n  if (!is_zero) {\n    is_zero = input_bits == exception_flags;\n  }\n  exponent_bits = (int)input_bits >> 0x18;\n  if (!is_zero) {\n    is_zero = exponent_bits == -1;\n  }\n  if (!is_zero) {\n    is_zero = (int)exception_flags >> 0x18 == -1;\n  }\n  if (is_zero) {\n    sign_bit = (int)(rounding_precision << 1) >> 0x18;\n    if (exponent_bits == -1 || sign_bit == -1) {\n      input_bits = rounding_precision;\n      if (exponent_bits == -1) {\n        input_bits = input_float;\n      }\n      if (exponent_bits != -1 || sign_bit != -1) {\n        rounding_precision = input_bits;\n      }\n      is_zero = (input_bits & 0x7fffff) == 0;\n      if (is_zero) {\n        is_zero = (rounding_precision & 0x7fffff) == 0;\n      }\n      if (is_zero) {\n        is_zero = input_bits == rounding_precision;\n      }\n      if (!is_zero) {\n        input_bits = input_bits | 0x400000;\n      }\n      return input_bits;\n    }\n    if (((input_float ^ rounding_precision) & 0x7fffffff) != 0) {\n      if (input_bits == 0) {\n        input_float = rounding_precision;\n      }\n      return input_float;\n    }\n    if (input_float != rounding_precision) {\n      return 0;\n    }\n    if ((input_bits & 0xff000000) == 0) {\n      input_bits = input_float << 1;\n      if ((input_float & 0x80000000) != 0) {\n        input_bits = input_bits | 0x80000000;\n      }\n      return input_bits;\n    }\n    if (input_bits < 0xfe000000) {\n      return input_float + 0x800000;\n    }\n    input_float = input_float & 0x80000000;\nLAB_08000bde:\n    return input_float | 0x7f800000;\n  }\n  input_bits = input_bits >> 0x18;\n  exception_flags = exception_flags >> 0x18;\n  distance = exception_flags - input_bits;\n  is_zero = distance != 0;\n  shift_amount = input_bits;\n  if (is_zero && input_bits <= exception_flags) {\n    shift_amount = input_bits + distance;\n  }\n  if (is_zero && input_bits <= exception_flags) {\n    rounding_precision = rounding_precision ^ input_float;\n  }\n  if (is_zero && input_bits <= exception_flags) {\n    input_float = input_float ^ rounding_precision;\n  }\n  if (is_zero && input_bits <= exception_flags) {\n    rounding_precision = rounding_precision ^ input_float;\n  }\n  if (exception_flags < input_bits) {\n    distance = -distance;\n  }\n  if (0x19 < distance) {\n    return input_float;\n  }\n  input_bits = input_float & 0xffffff | 0x800000;\n  if ((input_float & 0x80000000) != 0) {\n    input_bits = -input_bits;\n  }\n  mantissa_bits = rounding_precision & 0xffffff | 0x800000;\n  if ((rounding_precision & 0x80000000) != 0) {\n    mantissa_bits = -mantissa_bits;\n  }\n  if (shift_amount == distance) {\n    mantissa_bits = mantissa_bits ^ 0x800000;\n    if (shift_amount == 0) {\n      input_bits = input_bits ^ 0x800000;\n      shift_amount = 1;\n    }\n    else {\n      distance = distance - 1;\n    }\n  }\n  input_bits = input_bits + ((int)mantissa_bits >> (distance & 0xff));\n  mantissa_bits = mantissa_bits << (0x20 - distance & 0xff);\n  input_float = input_bits & 0x80000000;\n  if ((int)input_bits < 0) {\n    is_zero = mantissa_bits != 0;\n    mantissa_bits = -mantissa_bits;\n    input_bits = -input_bits - (uint)is_zero;\n  }\n  if (input_bits < 0x800000) {\n    distance = mantissa_bits & 0x80000000;\n    mantissa_bits = mantissa_bits << 1;\n    input_bits = input_bits * 2 + (uint)(distance != 0);\n    distance = shift_amount - 2;\n    if ((input_bits & 0x800000) == 0) {\n      exponent_bits = count_leading_zeroes(input_bits);\n      shift_amount = exponent_bits - 8;\n      input_bits = input_bits << (shift_amount & 0xff);\n      if ((int)distance < (int)shift_amount) {\n        input_bits = input_bits >> (-(distance - shift_amount) & 0xff);\n      }\n      else {\n        input_bits = input_bits + (distance - shift_amount) * 0x800000;\n      }\n      return input_bits | input_float;\n    }\n  }\n  else {\n    distance = shift_amount - 1;\n    if (0xffffff < input_bits) {\n      distance = input_bits & 1;\n      input_bits = input_bits >> 1;\n      mantissa_bits = (uint)(distance != 0) << 0x1f | mantissa_bits >> 1;\n      distance = shift_amount;\n      if (0xfd < shift_amount) goto LAB_08000bde;\n    }\n  }\n  input_bits = input_bits + distance * 0x800000 + (uint)(0x7fffffff < mantissa_bits);\n  if (mantissa_bits == 0x80000000) {\n    input_bits = input_bits & 0xfffffffe;\n  }\n  return input_bits | input_float;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000aa8",
            "calling": [
                "FUN_080049cc",
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "float32_to_float32_08000aa8"
        },
        "FUN_080009ac": {
            "renaming": {
                "FUN_080009ac": "check_null_termination_080009ac",
                "in_CY": "input_char"
            },
            "code": "\nbool check_null_termination_080009ac(void)\n\n{\n  char input_char;\n  \n  FUN_08000988();\n  return input_char == '\\0';\n}\n\n",
            "called": [
                "FUN_08000988"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009ac",
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "check_null_termination_080009ac"
        },
        "FUN_08000fc8": {
            "renaming": {
                "FUN_08000fc8": "swap_parameters_08000fc8",
                "param_1": "first_parameter",
                "param_2": "second_parameter"
            },
            "code": "\nvoid swap_parameters_08000fc8(undefined4 first_parameter,undefined4 second_parameter)\n\n{\n  FUN_08000fd0(second_parameter,first_parameter);\n  return;\n}\n\n",
            "called": [
                "FUN_08000fd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000fc8",
            "calling": [
                "FUN_08001030"
            ],
            "imported": false,
            "current_name": "swap_parameters_08000fc8"
        },
        "FUN_08001cb8": {
            "renaming": {
                "FUN_08001cb8": "FUNC_08001cb8"
            },
            "code": "\nvoid FUNC_08001cb8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08001cb8",
            "calling": [
                "FUN_08001ab0"
            ],
            "imported": false,
            "current_name": "FUNC_08001cb8"
        },
        "FUN_0800438a": {
            "renaming": {
                "FUN_0800438a": "initialize_device_0800438a",
                "param_1": "device_ptr",
                "uVar1": "result",
                "param_1[0xf]": "device_config_3"
            },
            "code": "\nundefined4 initialize_device_0800438a(int *device_ptr)\n\n{\n  undefined4 result;\n  \n  if (device_ptr == (int *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)device_ptr + 0x39) == '\\0') {\n      *(undefined *)(device_ptr + 0xe) = 0;\n      FUNC_08004424(device_ptr);\n    }\n    *(undefined *)((int)device_ptr + 0x39) = 0x24;\n    *(uint *)(*device_ptr + 0xc) = *(uint *)(*device_ptr + 0xc) & 0xffffdfff;\n    FUN_080046ec(device_ptr);\n    *(uint *)(*device_ptr + 0x10) = *(uint *)(*device_ptr + 0x10) & 0xffffb7ff;\n    *(uint *)(*device_ptr + 0x14) = *(uint *)(*device_ptr + 0x14) & 0xffffffd5;\n    *(uint *)(*device_ptr + 0xc) = *(uint *)(*device_ptr + 0xc) | 0x2000;\n    device_config_3 = 0;\n    *(undefined *)((int)device_ptr + 0x39) = 0x20;\n    *(undefined *)((int)device_ptr + 0x3a) = 0x20;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_08004424",
                "FUN_080046ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800438a",
            "calling": [
                "FUN_08005598"
            ],
            "imported": false,
            "current_name": "initialize_device_0800438a"
        },
        "FUN_080014f0": {
            "renaming": {
                "FUN_080014f0": "initialize_system_080014f0"
            },
            "code": "\nundefined4 initialize_system_080014f0(void)\n\n{\n  *DAT_08001518 = *DAT_08001518 | 0x10;\n  FUN_08001714(3);\n  FUN_0800151c(0xf);\n  FUNC_08002d8a();\n  return 0;\n}\n\n",
            "called": [
                "FUN_08002d8a",
                "FUN_0800151c",
                "FUN_08001714"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080014f0",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "initialize_system_080014f0"
        },
        "FUN_08003908": {
            "renaming": {
                "FUN_08003908": "update_flags_08003908",
                "param_1": "flags_ptr",
                "param_2": "data_ptr",
                "param_3": "data_type",
                "uVar1": "result"
            },
            "code": "\nundefined4 update_flags_08003908(int *flags_ptr,int data_ptr,undefined4 data_type)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(flags_ptr + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(flags_ptr + 0xf) = 1;\n    *(undefined *)((int)flags_ptr + 0x3d) = 2;\n    switch(data_type) {\n    case 0:\n      FUN_08003d60(*flags_ptr,data_ptr);\n      *(uint *)(*flags_ptr + 0x18) = *(uint *)(*flags_ptr + 0x18) | 8;\n      *(uint *)(*flags_ptr + 0x18) = *(uint *)(*flags_ptr + 0x18) & 0xfffffffb;\n      *(uint *)(*flags_ptr + 0x18) = *(uint *)(data_ptr + 0x10) | *(uint *)(*flags_ptr + 0x18);\n      break;\n    case 4:\n      FUN_08003e38(*flags_ptr,data_ptr);\n      *(uint *)(*flags_ptr + 0x18) = *(uint *)(*flags_ptr + 0x18) | 0x800;\n      *(uint *)(*flags_ptr + 0x18) = *(uint *)(*flags_ptr + 0x18) & 0xfffffbff;\n      *(uint *)(*flags_ptr + 0x18) = *(int *)(data_ptr + 0x10) << 8 | *(uint *)(*flags_ptr + 0x18);\n      break;\n    case 8:\n      FUN_08003f18(*flags_ptr,data_ptr);\n      *(uint *)(*flags_ptr + 0x1c) = *(uint *)(*flags_ptr + 0x1c) | 8;\n      *(uint *)(*flags_ptr + 0x1c) = *(uint *)(*flags_ptr + 0x1c) & 0xfffffffb;\n      *(uint *)(*flags_ptr + 0x1c) = *(uint *)(data_ptr + 0x10) | *(uint *)(*flags_ptr + 0x1c);\n      break;\n    case 0xc:\n      FUN_08003ff8(*flags_ptr,data_ptr);\n      *(uint *)(*flags_ptr + 0x1c) = *(uint *)(*flags_ptr + 0x1c) | 0x800;\n      *(uint *)(*flags_ptr + 0x1c) = *(uint *)(*flags_ptr + 0x1c) & 0xfffffbff;\n      *(uint *)(*flags_ptr + 0x1c) = *(int *)(data_ptr + 0x10) << 8 | *(uint *)(*flags_ptr + 0x1c);\n    }\n    *(undefined *)((int)flags_ptr + 0x3d) = 1;\n    *(undefined *)(flags_ptr + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_08003f18",
                "FUN_08003d60",
                "FUN_08003ff8",
                "FUN_08003e38"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003908",
            "calling": [
                "FUN_080053b0"
            ],
            "imported": false,
            "current_name": "update_flags_08003908"
        },
        "FUN_08004f60": {
            "renaming": {
                "FUN_08004f60": "initialize_memory_08004f60"
            },
            "code": "\nvoid initialize_memory_08004f60(void)\n\n{\n  FUN_08005d68(PTR_DAT_08004f74,0,0x40);\n  return;\n}\n\n",
            "called": [
                "FUN_08005d68"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f60",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "initialize_memory_08004f60"
        },
        "FUN_080009c0": {
            "renaming": {
                "FUN_080009c0": "check_cy_zr_bool_080009c0",
                "in_CY": "is_CY_true",
                "in_ZR": "is_ZR_true"
            },
            "code": "\nbool check_CY_ZR_bool_080009c0(void)\n\n{\n  undefined is_ZR_true;\n  undefined is_CY_true;\n  \n  FUN_08000988();\n  return !(bool)is_CY_true || (bool)is_ZR_true;\n}\n\n",
            "called": [
                "FUN_08000988"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009c0",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "check_cy_zr_bool_080009c0"
        },
        "FUN_08001170": {
            "renaming": {
                "FUN_08001170": "check_params_08001170",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "return": "valid_params"
            },
            "code": "\nundefined4 check_params_08001170(uint value1,int value2,uint value3,int value4)\n\n{\n  if ((((value2 << 1) >> 0x15 != -1) || ((value1 | value2 << 0xc) == 0)) &&\n     (((value4 << 1) >> 0x15 != -1 || ((value3 | value4 << 0xc) == 0)))) {\n    valid_params 0;\n  }\n  valid_params 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001170",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "check_params_08001170"
        },
        "FUN_08003f18": {
            "renaming": {
                "FUN_08003f18": "update_parameters_08003f18",
                "param_1": "param_address",
                "param_2": "param_values",
                "uVar1": "first_param_value",
                "uVar2": "second_param_value",
                "local_10": "third_param_value"
            },
            "code": "\nvoid update_parameters_08003f18(int param_address,uint *param_values)\n\n{\n  uint first_param_value;\n  uint second_param_value;\n  uint third_param_value;\n  \n  *(uint *)(param_address + 0x20) = *(uint *)(param_address + 0x20) & 0xfffffeff;\n  third_param_value = *(uint *)(param_address + 4);\n  first_param_value = *param_values;\n  second_param_value = param_values[2] << 8 | *(uint *)(param_address + 0x20) & 0xfffffdff;\n  if (param_address == DAT_08003ff4) {\n    second_param_value = (param_values[3] << 8 | second_param_value & 0xfffff7ff) & 0xfffffbff;\n    third_param_value = param_values[6] << 4 | param_values[5] << 4 | third_param_value & 0xffffcfff;\n  }\n  *(uint *)(param_address + 4) = third_param_value;\n  *(uint *)(param_address + 0x1c) = first_param_value | *(uint *)(param_address + 0x1c) & 0xffffff8c;\n  *(uint *)(param_address + 0x3c) = param_values[1];\n  *(uint *)(param_address + 0x20) = second_param_value;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f18",
            "calling": [
                "FUN_08003908"
            ],
            "imported": false,
            "current_name": "update_parameters_08003f18"
        },
        "FUN_080097cc": {
            "renaming": {
                "FUN_080097cc": "decompress_data_080097cc",
                "param_1": "output_buffer",
                "param_2": "input_buffer",
                "param_3": "compressed_data_info",
                "iVar1": "input_buffer_pos",
                "uVar2": "compressed_data_size",
                "iVar3": "output_buffer_pos",
                "iVar4": "compressed_data_offset",
                "uVar5": "max_compressed_data_size",
                "uVar6": "compressed_chunk_size",
                "puVar7": "compressed_data_chunk",
                "puVar8": "compressed_data_chunk_pos",
                "uVar9": "current_compressed_data_byte"
            },
            "code": "\nundefined4 decompress_data_080097cc(undefined4 *output_buffer,int *input_buffer,int *compressed_data_info)\n\n{\n  int input_buffer_pos;\n  uint compressed_data_size;\n  int output_buffer_pos;\n  int compressed_data_offset;\n  uint max_compressed_data_size;\n  uint compressed_chunk_size;\n  undefined4 *compressed_data_chunk;\n  undefined4 *compressed_data_chunk_pos;\n  undefined4 current_compressed_data_byte;\n  \n  if (compressed_data_info[2] != 0) {\n    input_buffer_pos = *input_buffer;\n    max_compressed_data_size = input_buffer[2];\n    compressed_data_chunk_pos = (undefined4 *)*compressed_data_info;\n    do {\n      do {\n        compressed_data_chunk = compressed_data_chunk_pos + 2;\n        current_compressed_data_byte = *compressed_data_chunk_pos;\n        compressed_chunk_size = compressed_data_chunk_pos[1];\n        compressed_data_chunk_pos = compressed_data_chunk;\n      } while (compressed_chunk_size == 0);\n      compressed_data_size = compressed_chunk_size;\n      if ((max_compressed_data_size <= compressed_chunk_size) && (compressed_data_size = max_compressed_data_size, (*(ushort *)(input_buffer + 3) & 0x480) != 0)) {\n        compressed_data_offset = input_buffer_pos - input_buffer[4];\n        max_compressed_data_size = (input_buffer[5] * 3) / 2;\n        compressed_data_size = compressed_chunk_size + 1 + compressed_data_offset;\n        if (max_compressed_data_size < compressed_data_size) {\n          max_compressed_data_size = compressed_data_size;\n        }\n        if ((int)((uint)*(ushort *)(input_buffer + 3) << 0x15) < 0) {\n          output_buffer_pos = FUN_08008af8(output_buffer,max_compressed_data_size);\n          if (output_buffer_pos == 0) {\nLAB_08009896:\n            *output_buffer = 0xc;\n            *(ushort *)(input_buffer + 3) = *(ushort *)(input_buffer + 3) | 0x40;\n            compressed_data_info[1] = 0;\n            compressed_data_info[2] = 0;\n            return 0xffffffff;\n          }\n          FUN_08001084(output_buffer_pos,input_buffer[4],compressed_data_offset);\n          *(ushort *)(input_buffer + 3) = *(ushort *)(input_buffer + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          output_buffer_pos = FUN_08009adc(output_buffer);\n          if (output_buffer_pos == 0) {\n            FUN_080088ec(output_buffer,input_buffer[4]);\n            goto LAB_08009896;\n          }\n        }\n        input_buffer_pos = output_buffer_pos + compressed_data_offset;\n        input_buffer[5] = max_compressed_data_size;\n        input_buffer[4] = output_buffer_pos;\n        *input_buffer = input_buffer_pos;\n        input_buffer[2] = max_compressed_data_size - compressed_data_offset;\n        compressed_data_size = compressed_chunk_size;\n      }\n      FUN_08009a18(input_buffer_pos,current_compressed_data_byte,compressed_data_size);\n      compressed_data_offset = compressed_data_info[2];\n      max_compressed_data_size = input_buffer[2] - compressed_data_size;\n      input_buffer_pos = *input_buffer + compressed_data_size;\n      input_buffer[2] = max_compressed_data_size;\n      *input_buffer = input_buffer_pos;\n      compressed_data_info[2] = compressed_data_offset - compressed_chunk_size;\n    } while (compressed_data_offset - compressed_chunk_size != 0);\n  }\n  compressed_data_info[1] = 0;\n  return 0;\n}\n\n",
            "called": [
                "FUN_08009a18",
                "FUN_08001084",
                "FUN_08009adc",
                "FUN_080088ec",
                "FUN_08008af8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080097cc",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "decompress_data_080097cc"
        },
        "FUN_08001f6c": {
            "renaming": {
                "FUN_08001f6c": "decode_and_process_data_08001f6c",
                "param_1": "data",
                "param_5": "input_data",
                "iVar1": "initial_value",
                "uVar2": "data_value",
                "cVar3": "char_value",
                "uVar4": "temp_value",
                "iVar5": "loop_counter",
                "uVar6": "result",
                "puVar7": "pointer_value",
                "bVar8": "bool_value"
            },
            "code": "\nundefined4\ndecode_and_process_data_08001f6c(uint **data,undefined2 param_2,undefined2 param_3,undefined2 param_4,uint *input_data,\n            undefined2 param_6,uint param_7)\n\n{\n  int initial_value;\n  uint data_value;\n  char char_value;\n  uint temp_value;\n  int loop_counter;\n  undefined4 result;\n  uint *pointer_value;\n  bool bool_value;\n  \n  initial_value = FUN_080015a0();\n  data_value = DAT_080021e0;\n  if (*(char *)((int)data + 0x3d) == ' ') {\n    do {\n      if ((data_value >> 0x10 & 0xff) == 1) {\n        temp_value = data_value & ~(*data)[5] & 0xffff;\n        bool_value = temp_value == 0;\n        if (bool_value) {\n          temp_value = 1;\n        }\n        char_value = (char)temp_value;\n        if (!bool_value) {\n          char_value = '\\0';\n        }\n      }\n      else {\n        temp_value = data_value & ~(*data)[6] & 0xffff;\n        bool_value = temp_value == 0;\n        if (bool_value) {\n          temp_value = 1;\n        }\n        char_value = (char)temp_value;\n        if (!bool_value) {\n          char_value = '\\0';\n        }\n      }\n      if (char_value != '\\x01') {\n        loop_counter = 0;\n        goto LAB_08002040;\n      }\n      loop_counter = FUN_080015a0();\n    } while ((uint)(loop_counter - initial_value) < 0x1a);\n    data[0xc] = (uint *)0x0;\n    *(undefined *)((int)data + 0x3d) = 0x20;\n    *(undefined *)((int)data + 0x3e) = 0;\n    *(undefined *)(data + 0xf) = 0;\n    loop_counter = 3;\nLAB_08002040:\n    if (loop_counter == 0) {\n      if (*(char *)(data + 0xf) == '\\x01') {\n        result = 2;\n      }\n      else {\n        *(undefined *)(data + 0xf) = 1;\n        if ((**data & 1) != 1) {\n          **data = **data | 1;\n        }\n        **data = **data & 0xfffff7ff;\n        *(undefined *)((int)data + 0x3d) = 0x22;\n        *(undefined *)((int)data + 0x3e) = 0x40;\n        data[0x10] = (uint *)0x0;\n        data[9] = input_data;\n        *(undefined2 *)((int)data + 0x2a) = param_6;\n        data[0xb] = DAT_080021e4;\n        *(undefined2 *)(data + 10) = *(undefined2 *)((int)data + 0x2a);\n        loop_counter = FUN_080027f4(data,param_2,param_3,param_4,param_7,initial_value);\n        if (loop_counter == 0) {\n          if (*(short *)(data + 10) == 0) {\n            **data = **data | 0x200;\n          }\n          else if (*(short *)(data + 10) == 1) {\n            **data = **data & 0xfffffbff;\n            disableIRQinterrupts();\n            **data = **data | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (*(short *)(data + 10) == 2) {\n            **data = **data | 0x800;\n            disableIRQinterrupts();\n            **data = **data & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            **data = **data | 0x400;\n          }\n          while (data_value = DAT_080024bc, *(short *)(data + 10) != 0) {\n            if (*(ushort *)(data + 10) < 4) {\n              if (*(short *)(data + 10) == 1) {\n                loop_counter = FUN_08002ca8(data,param_7,initial_value);\n                if (loop_counter != 0) {\n                  if (data[0x10] == (uint *)0x20) {\n                    return 3;\n                  }\n                  return 1;\n                }\n                data_value = (*data)[4];\n                pointer_value = data[9];\n                data[9] = (uint *)((int)pointer_value + 1);\n                *(char *)pointer_value = (char)data_value;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              }\n              else if (*(short *)(data + 10) == 2) {\n                do {\n                  if ((data_value >> 0x10 & 0xff) == 1) {\n                    temp_value = data_value & ~(*data)[5] & 0xffff;\n                    bool_value = temp_value == 0;\n                    if (bool_value) {\n                      temp_value = 1;\n                    }\n                    char_value = (char)temp_value;\n                    if (!bool_value) {\n                      char_value = '\\0';\n                    }\n                  }\n                  else {\n                    temp_value = data_value & ~(*data)[6] & 0xffff;\n                    bool_value = temp_value == 0;\n                    if (bool_value) {\n                      temp_value = 1;\n                    }\n                    char_value = (char)temp_value;\n                    if (!bool_value) {\n                      char_value = '\\0';\n                    }\n                  }\n                  if (char_value != '\\0') {\n                    loop_counter = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((param_7 == 0xffffffff) ||\n                        ((param_7 != 0 && (loop_counter = FUN_080015a0(), (uint)(loop_counter - initial_value) <= param_7)\n                         )));\n                data[0xc] = (uint *)0x0;\n                *(undefined *)((int)data + 0x3d) = 0x20;\n                *(undefined *)((int)data + 0x3e) = 0;\n                *(undefined *)(data + 0xf) = 0;\n                loop_counter = 3;\nLAB_080022fa:\n                if (loop_counter != 0) {\n                  return 3;\n                }\n                disableIRQinterrupts();\n                **data = **data | 0x200;\n                data_value = (*data)[4];\n                pointer_value = data[9];\n                data[9] = (uint *)((int)pointer_value + 1);\n                *(char *)pointer_value = (char)data_value;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n                enableIRQinterrupts();\n                data_value = (*data)[4];\n                pointer_value = data[9];\n                data[9] = (uint *)((int)pointer_value + 1);\n                *(char *)pointer_value = (char)data_value;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              }\n              else {\n                do {\n                  if ((data_value >> 0x10 & 0xff) == 1) {\n                    temp_value = data_value & ~(*data)[5] & 0xffff;\n                    bool_value = temp_value == 0;\n                    if (bool_value) {\n                      temp_value = 1;\n                    }\n                    char_value = (char)temp_value;\n                    if (!bool_value) {\n                      char_value = '\\0';\n                    }\n                  }\n                  else {\n                    temp_value = data_value & ~(*data)[6] & 0xffff;\n                    bool_value = temp_value == 0;\n                    if (bool_value) {\n                      temp_value = 1;\n                    }\n                    char_value = (char)temp_value;\n                    if (!bool_value) {\n                      char_value = '\\0';\n                    }\n                  }\n                  if (char_value != '\\0') {\n                    loop_counter = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((param_7 == 0xffffffff) ||\n                        ((param_7 != 0 && (loop_counter = FUN_080015a0(), (uint)(loop_counter - initial_value) <= param_7)\n                         )));\n                data[0xc] = (uint *)0x0;\n                *(undefined *)((int)data + 0x3d) = 0x20;\n                *(undefined *)((int)data + 0x3e) = 0;\n                *(undefined *)(data + 0xf) = 0;\n                loop_counter = 3;\nLAB_08002418:\n                if (loop_counter != 0) {\n                  return 3;\n                }\n                **data = **data & 0xfffffbff;\n                disableIRQinterrupts();\n                data_value = (*data)[4];\n                pointer_value = data[9];\n                data[9] = (uint *)((int)pointer_value + 1);\n                *(char *)pointer_value = (char)data_value;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n                data_value = DAT_080024bc;\n                do {\n                  if ((data_value >> 0x10 & 0xff) == 1) {\n                    temp_value = data_value & ~(*data)[5] & 0xffff;\n                    bool_value = temp_value == 0;\n                    if (bool_value) {\n                      temp_value = 1;\n                    }\n                    char_value = (char)temp_value;\n                    if (!bool_value) {\n                      char_value = '\\0';\n                    }\n                  }\n                  else {\n                    temp_value = data_value & ~(*data)[6] & 0xffff;\n                    bool_value = temp_value == 0;\n                    if (bool_value) {\n                      temp_value = 1;\n                    }\n                    char_value = (char)temp_value;\n                    if (!bool_value) {\n                      char_value = '\\0';\n                    }\n                  }\n                  if (char_value != '\\0') {\n                    loop_counter = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((param_7 == 0xffffffff) ||\n                        ((param_7 != 0 && (loop_counter = FUN_080015a0(), (uint)(loop_counter - initial_value) <= param_7)\n                         )));\n                data[0xc] = (uint *)0x0;\n                *(undefined *)((int)data + 0x3d) = 0x20;\n                *(undefined *)((int)data + 0x3e) = 0;\n                *(undefined *)(data + 0xf) = 0;\n                loop_counter = 3;\nLAB_0800250a:\n                if (loop_counter != 0) {\n                  return 3;\n                }\n                **data = **data | 0x200;\n                data_value = (*data)[4];\n                pointer_value = data[9];\n                data[9] = (uint *)((int)pointer_value + 1);\n                *(char *)pointer_value = (char)data_value;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n                enableIRQinterrupts();\n                data_value = (*data)[4];\n                pointer_value = data[9];\n                data[9] = (uint *)((int)pointer_value + 1);\n                *(char *)pointer_value = (char)data_value;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              }\n            }\n            else {\n              loop_counter = FUN_08002ca8(data,param_7,initial_value);\n              if (loop_counter != 0) {\n                if (data[0x10] == (uint *)0x20) {\n                  return 3;\n                }\n                return 1;\n              }\n              data_value = (*data)[4];\n              pointer_value = data[9];\n              data[9] = (uint *)((int)pointer_value + 1);\n              *(char *)pointer_value = (char)data_value;\n              *(short *)(data + 10) = *(short *)(data + 10) + -1;\n              *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              if (((*data)[5] & 4) == 4) {\n                data_value = (*data)[4];\n                pointer_value = data[9];\n                data[9] = (uint *)((int)pointer_value + 1);\n                *(char *)pointer_value = (char)data_value;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              }\n            }\n          }\n          *(undefined *)((int)data + 0x3d) = 0x20;\n          *(undefined *)((int)data + 0x3e) = 0;\n          *(undefined *)(data + 0xf) = 0;\n          result = 0;\n        }\n        else if (data[0x10] == (uint *)0x4) {\n          *(undefined *)(data + 0xf) = 0;\n          result = 1;\n        }\n        else {\n          *(undefined *)(data + 0xf) = 0;\n          result = 3;\n        }\n      }\n    }\n    else {\n      result = 2;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_080015a0",
                "FUN_08002ca8",
                "FUN_080027f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001f6c",
            "calling": [
                "FUN_08004ee8"
            ],
            "imported": false,
            "current_name": "decode_and_process_data_08001f6c"
        },
        "FUN_08002ad8": {
            "renaming": {
                "FUN_08002ad8": "check_and_set_flag_08002ad8",
                "param_1": "ptr_arr",
                "param_2": "flag_value",
                "param_3": "max_iterations",
                "param_4": "target_value",
                "iVar1": "result",
                "cVar2": "flag_char",
                "uVar3": "flag_mask",
                "bVar4": "flag_set",
                "param_1[0x10]": "ptr_val1",
                "param_1[0xc]": "ptr_val2"
            },
            "code": "\nundefined4 check_and_set_flag_08002ad8(uint **ptr_arr,uint flag_value,uint max_iterations,int target_value)\n\n{\n  int result;\n  char flag_char;\n  uint flag_mask;\n  bool flag_set;\n  \n  do {\n    if ((flag_value >> 0x10 & 0xff) == 1) {\n      flag_mask = flag_value & ~(*ptr_arr)[5] & 0xffff;\n      flag_set = flag_mask != 0;\n      if (flag_set) {\n        flag_mask = 1;\n      }\n      flag_char = (char)flag_mask;\n      if (!flag_set) {\n        flag_char = '\\0';\n      }\n    }\n    else {\n      flag_mask = flag_value & ~(*ptr_arr)[6] & 0xffff;\n      flag_set = flag_mask != 0;\n      if (flag_set) {\n        flag_mask = 1;\n      }\n      flag_char = (char)flag_mask;\n      if (!flag_set) {\n        flag_char = '\\0';\n      }\n    }\n    if (flag_char == '\\0') {\n      return 0;\n    }\n    if (((*ptr_arr)[5] & 0x400) == 0x400) {\n      **ptr_arr = **ptr_arr | 0x200;\n      (*ptr_arr)[5] = 0xfffffbff;\n      ptr_val1 = (uint *)0x4;\n      ptr_val2 = (uint *)0x0;\n      *(undefined *)((int)ptr_arr + 0x3d) = 0x20;\n      *(undefined *)(ptr_arr + 0xf) = 0;\n      return 1;\n    }\n  } while ((max_iterations == 0xffffffff) ||\n          ((max_iterations != 0 && (result = FUN_080015a0(), (uint)(result - target_value) <= max_iterations))));\n  ptr_val2 = (uint *)0x0;\n  *(undefined *)((int)ptr_arr + 0x3d) = 0x20;\n  *(undefined *)(ptr_arr + 0xf) = 0;\n  return 3;\n}\n\n",
            "called": [
                "FUN_080015a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ad8",
            "calling": [
                "FUN_08002640",
                "FUN_080027f4"
            ],
            "imported": false,
            "current_name": "check_and_set_flag_08002ad8"
        },
        "FUN_08000fd0": {
            "renaming": {
                "FUN_08000fd0": "concatenate_32_bit_integers_08000fd0",
                "param_1": "first_integer",
                "param_2": "second_integer",
                "CONCAT44": "concatenate_64_bit_integers"
            },
            "code": "\nundefined8 concatenate_32_bit_integers_08000fd0(undefined4 first_integer,undefined4 second_integer)\n\n{\n  FUN_08000f68();\n  return concatenate_64_bit_integers(second_integer,first_integer);\n}\n\n",
            "called": [
                "FUN_08000f68"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000fd0",
            "calling": [
                "FUN_08000ff4",
                "FUN_08000fc8"
            ],
            "imported": false,
            "current_name": "concatenate_32_bit_integers_08000fd0"
        },
        "FUN_08003d60": {
            "renaming": {
                "FUN_08003d60": "set_flags_08003d60",
                "param_1": "flag_address",
                "param_2": "flag_values",
                "uVar1": "flag_value_1",
                "uVar2": "flag_value_2",
                "local_10": "local_flags",
                "param_2[2]": "flag_value_3",
                "param_2[3]": "flag_value_4",
                "param_2[6]": "flag_value_5",
                "param_2[5]": "flag_value_6"
            },
            "code": "\nvoid set_flags_08003d60(int flag_address,uint *flag_values)\n\n{\n  uint flag_value_1;\n  uint flag_value_2;\n  uint local_flags;\n  \n  *(uint *)(flag_address + 0x20) = *(uint *)(flag_address + 0x20) & 0xfffffffe;\n  local_flags = *(uint *)(flag_address + 4);\n  flag_value_1 = *flag_values;\n  flag_value_2 = flag_value_3 | *(uint *)(flag_address + 0x20) & 0xfffffffd;\n  if (flag_address == DAT_08003e34) {\n    flag_value_2 = (flag_value_4 | flag_value_2 & 0xfffffff7) & 0xfffffffb;\n    local_flags = flag_value_5 | flag_value_6 | local_flags & 0xfffffcff;\n  }\n  *(uint *)(flag_address + 4) = local_flags;\n  *(uint *)(flag_address + 0x18) = flag_value_1 | *(uint *)(flag_address + 0x18) & 0xffffff8c;\n  *(uint *)(flag_address + 0x34) = flag_values[1];\n  *(uint *)(flag_address + 0x20) = flag_value_2;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003d60",
            "calling": [
                "FUN_08003908"
            ],
            "imported": false,
            "current_name": "set_flags_08003d60"
        },
        "FUN_08009e68": {
            "renaming": {
                "FUN_08009e68": "FUNC_08009e68"
            },
            "code": "\nvoid FUNC_08009e68(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08009e68",
            "calling": [
                "FUN_08000110",
                "FUN_08000134",
                "FUN_08005d20"
            ],
            "imported": false,
            "current_name": "FUNC_08009e68"
        },
        "FUN_08003518": {
            "renaming": {
                "FUN_08003518": "shifted_result_from_08003504_08003518",
                "uVar1": "result_from_FUN_08003504"
            },
            "code": "\nuint shifted_result_from_08003504_08003518(void)\n\n{\n  uint result_from_FUN_08003504;\n  \n  result_from_FUN_08003504 = FUN_08003504();\n  return result_from_FUN_08003504 >> PTR_DAT_0800353c[*(uint *)(DAT_08003538 + 4) >> 8 & 7];\n}\n\n",
            "called": [
                "FUN_08003504"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003518",
            "calling": [
                "FUN_08001ab0",
                "FUN_080046ec"
            ],
            "imported": false,
            "current_name": "shifted_result_from_08003504_08003518"
        },
        "FUN_08001618": {
            "renaming": {
                "FUN_08001618": "write_to_memory_08001618",
                "param_1": "byte_offset",
                "param_2": "data"
            },
            "code": "\nvoid write_to_memory_08001618(byte byte_offset,uint data)\n\n{\n  if ((char)byte_offset < '\\0') {\n    *(char *)((byte_offset & 0xf) + DAT_08001664 + 0x14) = (char)((data & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)byte_offset + DAT_08001668 + 0x300) = (char)((data & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001618",
            "calling": [
                "FUN_0800172a",
                "FUN_080016d0"
            ],
            "imported": false,
            "current_name": "write_to_memory_08001618"
        },
        "FUN_080091a4": {
            "renaming": {
                "FUN_080091a4": "find_most_significant_bit_position_080091a4",
                "param_1": "input_number",
                "iVar1": "most_significant_bit_position",
                "(int)param_1": "signed_input_number"
            },
            "code": "\nint find_most_significant_bit_position_080091a4(uint input_number)\n\n{\n  int most_significant_bit_position;\n  \n  if ((input_number & 0xffff0000) == 0) {\n    input_number = input_number << 0x10;\n    most_significant_bit_position = 0x10;\n  }\n  else {\n    most_significant_bit_position = 0;\n  }\n  if ((input_number & 0xff000000) == 0) {\n    input_number = input_number << 8;\n    most_significant_bit_position = most_significant_bit_position + 8;\n  }\n  if ((input_number & 0xf0000000) == 0) {\n    input_number = input_number << 4;\n    most_significant_bit_position = most_significant_bit_position + 4;\n  }\n  if ((input_number & 0xc0000000) == 0) {\n    input_number = input_number << 2;\n    most_significant_bit_position = most_significant_bit_position + 2;\n  }\n  if (-1 < signed_input_number) {\n    if ((int)(input_number << 1) < 0) {\n      return most_significant_bit_position + 1;\n    }\n    most_significant_bit_position = 0x20;\n  }\n  return most_significant_bit_position;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091a4",
            "calling": [
                "FUN_08009630",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "find_most_significant_bit_position_080091a4"
        },
        "FUN_08004f78": {
            "renaming": {
                "FUN_08004f78": "process_audio_data_08004f78",
                "uVar1": "temp_variable_1",
                "iVar2": "temp_variable_2",
                "uVar3": "temp_variable_3",
                "uVar4": "temp_variable_4",
                "uVar5": "temp_variable_5",
                "local_11": "audio_data_byte"
            },
            "code": "\nvoid process_audio_data_08004f78(void)\n\n{\n  undefined4 temp_variable_1;\n  int temp_variable_2;\n  undefined4 temp_variable_3;\n  uint temp_variable_4;\n  undefined8 temp_variable_5;\n  byte audio_data_byte;\n  \n  FUN_08004ae0(PTR_DAT_080051e0);\n  FUN_08004bd8(PTR_DAT_080051e0,PTR_DAT_080051e4);\n  FUN_08004f60();\n  temp_variable_5 = FUN_08000418(*(undefined4 *)PTR_DAT_080051e4);\n  FUN_08005dfc(PTR_DAT_080051ec,PTR_s_Pitch___f_080051e8,(int)temp_variable_5,(int)((ulonglong)temp_variable_5 >> 0x20))\n  ;\n  temp_variable_1 = FUN_08005e40(PTR_DAT_080051ec);\n  FUN_08004f3c(PTR_DAT_080051ec,temp_variable_1);\n  temp_variable_1 = FUN_08000aa4(*(undefined4 *)PTR_DAT_080051f0,*(undefined4 *)PTR_DAT_080051e4);\n  *(undefined4 *)PTR_DAT_080051f4 = temp_variable_1;\n  temp_variable_1 = FUN_08000cb8(*(undefined4 *)PTR_DAT_080051f8,*(undefined4 *)PTR_DAT_080051f4);\n  *(undefined4 *)PTR_DAT_080051fc = temp_variable_1;\n  temp_variable_1 = FUN_08000cb8(*(undefined4 *)PTR_DAT_08005200,*(undefined4 *)PTR_DAT_080051f4);\n  temp_variable_1 = FUN_08000aa8(temp_variable_1,*(undefined4 *)PTR_DAT_08005204);\n  *(undefined4 *)PTR_DAT_08005204 = temp_variable_1;\n  temp_variable_1 = FUN_08000c10(*PTR_DAT_08005208);\n  temp_variable_2 = FUN_08000ff4(temp_variable_1,*(undefined4 *)PTR_DAT_08005204);\n  if (temp_variable_2 == 0) {\n    temp_variable_1 = FUN_08000c10(*PTR_DAT_0800520c);\n    temp_variable_2 = FUN_08001030(temp_variable_1,*(undefined4 *)PTR_DAT_08005204);\n    if (temp_variable_2 != 0) {\n      temp_variable_1 = FUN_08000c08(*PTR_DAT_0800520c);\n      *(undefined4 *)PTR_DAT_08005204 = temp_variable_1;\n    }\n  }\n  else {\n    temp_variable_1 = FUN_08000c08(*PTR_DAT_08005208);\n    *(undefined4 *)PTR_DAT_08005204 = temp_variable_1;\n  }\n  temp_variable_4 = *(uint *)PTR_DAT_08005210;\n  temp_variable_1 = FUN_08000aa4(*(undefined4 *)PTR_DAT_080051f4,*(undefined4 *)PTR_DAT_08005214);\n  temp_variable_1 = FUN_08000cb8(temp_variable_4 ^ 0x80000000,temp_variable_1);\n  *(undefined4 *)PTR_DAT_08005218 = temp_variable_1;\n  temp_variable_1 = FUN_08000aa8(*(undefined4 *)PTR_DAT_080051fc,*(undefined4 *)PTR_DAT_08005204);\n  temp_variable_1 = FUN_08000aa8(temp_variable_1,*(undefined4 *)PTR_DAT_08005218);\n  temp_variable_3 = FUN_08000c10(*PTR_DAT_08005208);\n  temp_variable_2 = FUN_08001030(temp_variable_1,temp_variable_3);\n  if (temp_variable_2 == 0) {\n    temp_variable_3 = FUN_08000c10(*PTR_DAT_0800520c);\n    temp_variable_2 = FUN_08000ff4(temp_variable_1,temp_variable_3);\n    if (temp_variable_2 == 0) {\n      audio_data_byte = FUN_08001044(temp_variable_1);\n    }\n    else {\n      audio_data_byte = *PTR_DAT_0800520c;\n    }\n  }\n  else {\n    audio_data_byte = *PTR_DAT_08005208;\n  }\n  *(undefined4 *)PTR_DAT_08005214 = *(undefined4 *)PTR_DAT_080051f4;\n  temp_variable_2 = FUN_08001030(*(undefined4 *)PTR_DAT_080051f4,0);\n  FUN_08001a80(DAT_0800521c,2,temp_variable_2 != 0);\n  temp_variable_2 = FUN_08001030(*(undefined4 *)PTR_DAT_080051f4,0);\n  FUN_08001a80(DAT_0800521c,4,temp_variable_2 == 0);\n  temp_variable_2 = FUN_08001030(*(undefined4 *)PTR_DAT_080051f4,0);\n  FUN_08001a80(DAT_0800521c,8,temp_variable_2 != 0);\n  temp_variable_2 = FUN_08001030(*(undefined4 *)PTR_DAT_080051f4,0);\n  FUN_08001a80(DAT_0800521c,0x10,temp_variable_2 == 0);\n  *(uint *)(*(int *)PTR_DAT_08005220 + 0x34) = (uint)audio_data_byte;\n  *(uint *)(*(int *)PTR_DAT_08005220 + 0x40) = (uint)audio_data_byte;\n  return;\n}\n\n",
            "called": [
                "FUN_08004ae0",
                "FUN_08000418",
                "FUN_08004f60",
                "FUN_08000aa8",
                "FUN_08001a80",
                "FUN_08000ff4",
                "FUN_08001030",
                "FUN_08000cb8",
                "FUN_08001044",
                "FUN_08000aa4",
                "FUN_08005dfc",
                "FUN_08004bd8",
                "FUN_08000c10",
                "FUN_08000c08",
                "FUN_08005e40",
                "FUN_08004f3c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f78",
            "calling": [
                "FUN_080036f8",
                "FUN_080017b4"
            ],
            "imported": false,
            "current_name": "process_audio_data_08004f78"
        },
        "FUN_080015a0": {
            "renaming": {
                "FUN_080015a0": "get_pointer_value_080015a0"
            },
            "code": "\nundefined4 get_pointer_value_080015a0(void)\n\n{\n  return *(undefined4 *)PTR_DAT_080015b0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015a0",
            "calling": [
                "FUN_08002d98",
                "FUN_08002640",
                "FUN_08004436",
                "FUN_08001ccc",
                "FUN_08002c2e",
                "FUN_08001f6c",
                "FUN_080027f4",
                "FUN_08002ca8",
                "FUN_08002ad8",
                "FUN_08004f2c",
                "FUN_08003260",
                "FUN_08002bb4"
            ],
            "imported": false,
            "current_name": "get_pointer_value_080015a0"
        },
        "FUN_08002d98": {
            "renaming": {
                "FUN_08002d98": "check_flags_08002d98",
                "param_1": "flags",
                "iVar1": "start_time",
                "iVar2": "current_time",
                "uVar3": "result",
                "bVar4": "is_bit_set"
            },
            "code": "\nundefined4 check_flags_08002d98(uint *flags)\n\n{\n  int start_time;\n  int current_time;\n  undefined4 result;\n  bool is_bit_set;\n  \n  if ((*flags & 1) != 0) {\n    if (((DAT_08002ffc[1] & 0xc) == 4) ||\n       (((DAT_08002ffc[1] & 0xc) == 8 && ((DAT_08002ffc[1] & 0x10000) == 0x10000)))) {\n      if (((*DAT_08002ffc & 0x20000) != 0) && (flags[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      if (flags[1] == 0x10000) {\n        *DAT_08002ffc = *DAT_08002ffc | 0x10000;\n      }\n      else if (flags[1] == 0) {\n        *DAT_08002ffc = *DAT_08002ffc & 0xfffeffff;\n        *DAT_08002ffc = *DAT_08002ffc & 0xfffbffff;\n      }\n      else if (flags[1] == 0x50000) {\n        *DAT_08002ffc = *DAT_08002ffc | 0x40000;\n        *DAT_08002ffc = *DAT_08002ffc | 0x10000;\n      }\n      else {\n        *DAT_08002ffc = *DAT_08002ffc & 0xfffeffff;\n        *DAT_08002ffc = *DAT_08002ffc & 0xfffbffff;\n      }\n      if (flags[1] == 0) {\n        start_time = FUN_080015a0();\n        while ((*DAT_08002ffc & 0x20000) != 0) {\n          current_time = FUN_080015a0();\n          if (100 < (uint)(current_time - start_time)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        start_time = FUN_080015a0();\n        while ((*DAT_08002ffc & 0x20000) == 0) {\n          current_time = FUN_080015a0();\n          if (100 < (uint)(current_time - start_time)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*flags & 2) != 0) {\n    if (((DAT_08002ffc[1] & 0xc) == 0) ||\n       (((DAT_08002ffc[1] & 0xc) == 8 && ((DAT_08002ffc[1] & 0x10000) == 0)))) {\n      if (((*DAT_08002ffc & 2) != 0) && (flags[4] != 1)) {\n        return 1;\n      }\n      *DAT_08002ffc = flags[5] << 3 | *DAT_08002ffc & 0xffffff07;\n    }\n    else if (flags[4] == 0) {\n      *DAT_08003000 = 0;\n      start_time = FUN_080015a0();\n      while ((*DAT_08002ffc & 2) != 0) {\n        current_time = FUN_080015a0();\n        if (2 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      *DAT_08003000 = 1;\n      start_time = FUN_080015a0();\n      while ((*DAT_08002ffc & 2) == 0) {\n        current_time = FUN_080015a0();\n        if (2 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n      *DAT_08002ffc = flags[5] << 3 | *DAT_08002ffc & 0xffffff07;\n    }\n  }\n  if ((*flags & 8) != 0) {\n    if (flags[6] == 0) {\n      *DAT_08003004 = 0;\n      start_time = FUN_080015a0();\n      while ((DAT_08003254[9] & 2) != 0) {\n        current_time = FUN_080015a0();\n        if (2 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      *DAT_08003004 = 1;\n      start_time = FUN_080015a0();\n      while ((DAT_08002ffc[9] & 2) == 0) {\n        current_time = FUN_080015a0();\n        if (2 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n      FUN_08003568(1);\n    }\n  }\n  if ((*flags & 4) != 0) {\n    is_bit_set = (DAT_08003254[7] & 0x10000000) == 0;\n    if (is_bit_set) {\n      DAT_08003254[7] = DAT_08003254[7] | 0x10000000;\n    }\n    if ((*DAT_08003258 & 0x100) == 0) {\n      *DAT_08003258 = *DAT_08003258 | 0x100;\n      start_time = FUN_080015a0();\n      while ((*DAT_08003258 & 0x100) == 0) {\n        current_time = FUN_080015a0();\n        if (100 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    if (flags[3] == 1) {\n      DAT_08003254[8] = DAT_08003254[8] | 1;\n    }\n    else if (flags[3] == 0) {\n      DAT_08003254[8] = DAT_08003254[8] & 0xfffffffe;\n      DAT_08003254[8] = DAT_08003254[8] & 0xfffffffb;\n    }\n    else if (flags[3] == 5) {\n      DAT_08003254[8] = DAT_08003254[8] | 4;\n      DAT_08003254[8] = DAT_08003254[8] | 1;\n    }\n    else {\n      DAT_08003254[8] = DAT_08003254[8] & 0xfffffffe;\n      DAT_08003254[8] = DAT_08003254[8] & 0xfffffffb;\n    }\n    if (flags[3] == 0) {\n      start_time = FUN_080015a0();\n      while ((DAT_08003254[8] & 2) != 0) {\n        current_time = FUN_080015a0();\n        if (5000 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      start_time = FUN_080015a0();\n      while ((DAT_08003254[8] & 2) == 0) {\n        current_time = FUN_080015a0();\n        if (5000 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    if (is_bit_set) {\n      DAT_08003254[7] = DAT_08003254[7] & 0xefffffff;\n    }\n  }\n  if (flags[7] == 0) {\nLAB_0800324a:\n    result = 0;\n  }\n  else if ((DAT_08003254[1] & 0xc) == 8) {\n    result = 1;\n  }\n  else if (flags[7] == 2) {\n    *DAT_0800325c = 0;\n    start_time = FUN_080015a0();\n    do {\n      if ((*DAT_08003254 & 0x2000000) == 0) {\n        if (flags[8] == 0x10000) {\n          DAT_08003254[1] = flags[2] | DAT_08003254[1] & 0xfffdffff;\n        }\n        DAT_08003254[1] = flags[9] | flags[8] | DAT_08003254[1] & 0xffc2ffff;\n        *DAT_0800325c = 1;\n        start_time = FUN_080015a0();\n        while ((*DAT_08003254 & 0x2000000) == 0) {\n          current_time = FUN_080015a0();\n          if (2 < (uint)(current_time - start_time)) {\n            return 3;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      current_time = FUN_080015a0();\n    } while ((uint)(current_time - start_time) < 3);\n    result = 3;\n  }\n  else {\n    *DAT_0800325c = 0;\n    start_time = FUN_080015a0();\n    do {\n      if ((*DAT_08003254 & 0x2000000) == 0) goto LAB_0800324a;\n      current_time = FUN_080015a0();\n    } while ((uint)(current_time - start_time) < 3);\n    result = 3;\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_08003568",
                "FUN_080015a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d98",
            "calling": [
                "FUN_080052a0"
            ],
            "imported": false,
            "current_name": "check_flags_08002d98"
        },
        "FUN_0800172a": {
            "renaming": {
                "FUN_0800172a": "send_data_to_server_0800172a",
                "param_1": "data",
                "param_2": "server_address",
                "param_3": "port",
                "uVar1": "connection"
            },
            "code": "\nvoid send_data_to_server_0800172a(char data,undefined4 server_address,undefined4 port)\n\n{\n  undefined4 connection;\n  \n  connection = FUN_080015fc();\n  connection = FUN_0800166c(connection,server_address,port);\n  FUN_08001618((int)data,connection);\n  return;\n}\n\n",
            "called": [
                "FUN_08001618",
                "FUN_080015fc",
                "FUN_0800166c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800172a",
            "calling": [
                "FUN_080052a0",
                "FUN_0800151c"
            ],
            "imported": false,
            "current_name": "send_data_to_server_0800172a"
        },
        "FUN_080009d4": {
            "renaming": {
                "FUN_080009d4": "check_cy_zr_080009d4",
                "in_ZR": "is_zero",
                "in_CY": "is_carry"
            },
            "code": "\nbool check_CY_ZR_080009d4(void)\n\n{\n  undefined is_zero;\n  undefined is_carry;\n  \n  FUN_08000978();\n  return !(bool)is_carry || (bool)is_zero;\n}\n\n",
            "called": [
                "FUN_08000978"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009d4",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "check_cy_zr_080009d4"
        },
        "FUN_08002d8a": {
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "code": "\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08002d8a",
            "calling": [
                "FUN_080014f0"
            ],
            "imported": false,
            "current_name": "FUNC_08002d8a"
        },
        "FUN_08005780": {
            "renaming": {
                "FUN_08005780": "set_flags_and_values_08005780"
            },
            "code": "\nvoid set_flags_and_values_08005780(void)\n\n{\n  *DAT_080057dc = *DAT_080057dc | 1;\n  DAT_080057dc[1] = DAT_080057e0 & DAT_080057dc[1];\n  *DAT_080057dc = *DAT_080057dc & 0xfef6ffff;\n  *DAT_080057dc = *DAT_080057dc & 0xfffbffff;\n  DAT_080057dc[1] = DAT_080057dc[1] & 0xff80ffff;\n  DAT_080057dc[2] = 0x9f0000;\n  *(undefined4 *)(DAT_080057e4 + 8) = 0x8000000;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005780",
            "calling": [
                "FUN_080057e8"
            ],
            "imported": false,
            "current_name": "set_flags_and_values_08005780"
        },
        "FUN_08009744": {
            "renaming": {
                "FUN_08009744": "find_matching_value_08009744",
                "param_1": "output_value",
                "param_2": "search_value",
                "puVar1": "pointer_to_output_value",
                "iVar2": "search_result"
            },
            "code": "\nvoid find_matching_value_08009744(int *output_value,undefined4 search_value)\n\n{\n  undefined *pointer_to_output_value;\n  int search_result;\n  \n  pointer_to_output_value = PTR_DAT_08009764;\n  *(undefined4 *)PTR_DAT_08009764 = 0;\n  search_result = FUN_08005728(search_value);\n  if ((search_result == -1) && (*(int *)pointer_to_output_value != 0)) {\n    *output_value = *(int *)pointer_to_output_value;\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08005728"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009744",
            "calling": [
                "FUN_08008af8",
                "FUN_0800884c"
            ],
            "imported": false,
            "current_name": "find_matching_value_08009744"
        },
        "FUN_08003640": {
            "renaming": {
                "FUN_08003640": "check_and_process_data_08003640",
                "param_1": "data_ptr",
                "uVar1": "return_value"
            },
            "code": "\nundefined4 check_and_process_data_08003640(undefined4 *data_ptr)\n\n{\n  undefined4 return_value;\n  \n  if (data_ptr == (undefined4 *)0x0) {\n    return_value = 1;\n  }\n  else {\n    if (*(char *)((int)data_ptr + 0x3d) == '\\0') {\n      *(undefined *)(data_ptr + 0xf) = 0;\n      FUNC_08003696(data_ptr);\n    }\n    *(undefined *)((int)data_ptr + 0x3d) = 2;\n    FUN_08003c94(*data_ptr,data_ptr + 1);\n    *(undefined *)((int)data_ptr + 0x3d) = 1;\n    return_value = 0;\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_08003696",
                "FUN_08003c94"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003640",
            "calling": [
                "FUN_080053b0"
            ],
            "imported": false,
            "current_name": "check_and_process_data_08003640"
        },
        "FUN_08009980": {
            "renaming": {
                "FUN_08009980": "allocate_and_initialize_memory_08009980",
                "param_1": "memory_address",
                "param_2": "num_columns",
                "param_3": "num_rows",
                "puVar1": "allocated_memory",
                "uVar2": "memory_size",
                "puVar3": "memory_end"
            },
            "code": "\nundefined4 * allocate_and_initialize_memory_08009980(undefined4 memory_address,int num_columns,int num_rows)\n\n{\n  undefined4 *allocated_memory;\n  uint memory_size;\n  undefined4 *memory_end;\n  \n  allocated_memory = (undefined4 *)FUN_08008af8(memory_address,num_rows * num_columns);\n  if (allocated_memory == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  memory_size = (allocated_memory[-1] & 0xfffffffc) - 4;\n  if (memory_size < 0x25) {\n    memory_end = allocated_memory;\n    if (0x13 < memory_size) {\n      *allocated_memory = 0;\n      allocated_memory[1] = 0;\n      if (0x1b < memory_size) {\n        allocated_memory[2] = 0;\n        allocated_memory[3] = 0;\n        if (memory_size == 0x24) {\n          allocated_memory[4] = 0;\n          allocated_memory[5] = 0;\n          memory_end = allocated_memory + 6;\n        }\n        else {\n          memory_end = allocated_memory + 4;\n        }\n        *memory_end = 0;\n        memory_end[1] = 0;\n        memory_end[2] = 0;\n        return allocated_memory;\n      }\n      memory_end = allocated_memory + 2;\n    }\n    *memory_end = 0;\n    memory_end[1] = 0;\n    memory_end[2] = 0;\n    return allocated_memory;\n  }\n  FUN_08005d68(allocated_memory,0);\n  return allocated_memory;\n}\n\n",
            "called": [
                "FUN_08005d68",
                "FUN_08008af8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009980",
            "calling": [
                "FUN_080090c0"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_memory_08009980"
        },
        "FUN_08005e9c": {
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n/* WARNING: Could not reconcile some variable overlaps */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  int iVar8;\n  int *piVar9;\n  undefined4 uVar10;\n  int **ppiVar11;\n  undefined uVar12;\n  ushort uVar13;\n  int **ppiVar14;\n  byte **ppbVar15;\n  int *piVar16;\n  int **ppiVar17;\n  char *pcVar18;\n  uint uVar19;\n  undefined *puVar20;\n  int *piVar21;\n  int *piVar22;\n  int *piVar23;\n  int *piVar24;\n  int *piVar25;\n  byte *pbVar26;\n  int *piVar27;\n  int *piVar28;\n  undefined4 *puVar29;\n  byte *pbVar30;\n  bool bVar31;\n  longlong lVar32;\n  undefined8 uVar33;\n  undefined8 uVar34;\n  undefined4 local_188;\n  int *piStack_184;\n  int **local_180;\n  undefined *puStack_17c;\n  int **local_178;\n  undefined4 *local_16c;\n  int *local_168;\n  byte *local_164;\n  int *local_160;\n  int *local_15c;\n  int **local_158;\n  int **local_154;\n  undefined8 local_150;\n  int *local_148;\n  int *local_144;\n  int *local_140;\n  int **local_13c;\n  int *local_138;\n  int *local_134;\n  int *local_130;\n  uint local_12c;\n  undefined4 local_128;\n  undefined4 local_124;\n  undefined4 local_120;\n  undefined *local_11c;\n  int *local_118;\n  int *local_114;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  int *local_100;\n  int *local_fc;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0;\n  undefined auStack_ec [4];\n  char local_e8;\n  undefined local_e7;\n  char local_e6 [6];\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int *local_d4;\n  int *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  local_16c = param_1;\n  local_160 = param_2;\n  local_154 = param_4;\n  ppiVar2 = (int **)FUN_08008ad4();\n  local_114 = *ppiVar2;\n  local_118 = (int *)FUN_08005e40(local_114);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar3 = FUN_08008af8(local_16c,0x40);\n    *local_160 = iVar3;\n    local_160[4] = iVar3;\n    if (iVar3 == 0) {\n      *local_16c = 0xc;\n      return (byte *)0xffffffff;\n    }\n    local_160[5] = 0x40;\n  }\n  local_128 = 0;\n  local_138 = (int *)0x0;\n  local_12c = 0;\n  local_d4 = (int *)0x0;\n  local_d0 = (int *)0x0;\n  local_11c = (undefined *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  local_124 = 0;\n  local_120 = 0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = local_164 + (int)piVar27;\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    piVar25 = (int *)0x0;\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    puVar29 = local_16c;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    switch(piVar24) {\n    case (int *)0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (piVar24 == (int *)0x0) goto LAB_08006216;\n      piVar16 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_158 = (int **)0x1;\n      piVar23 = (int *)&local_8c;\n      piVar22 = piVar16;\n      local_8c = (char)piVar24;\n      goto LAB_08006298;\n    case (int *)0x23:\n      piVar25 = (int *)((uint)piVar25 | 1);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x27:\n      iVar3 = FUN_08008ad4(local_16c);\n      local_110 = *(int **)(iVar3 + 4);\n      piVar24 = (int *)FUN_08005e40(local_110);\n      local_104 = piVar24;\n      iVar3 = FUN_08008ad4(puVar29);\n      local_108 = *(byte **)(iVar3 + 8);\n      if (piVar24 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 0x400);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2a:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2b:\n      local_f5 = 0x2b;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x2d:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\nLAB_08006602:\n      piVar25 = (int *)((uint)piVar25 | 4);\n      goto LAB_08005f4a;\n    case (int *)0x2e:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x2a) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (piVar24 + -0xc < (int *)0xa) {\n        piVar27 = (int *)((int)(piVar24 + -0xc) + (int)piVar27 * 10);\n        piVar24 = (int *)(uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case (int *)0x30:\n      piVar25 = (int *)((uint)piVar25 | 0x80);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x31:\n    case (int *)0x32:\n    case (int *)0x33:\n    case (int *)0x34:\n    case (int *)0x35:\n    case (int *)0x36:\n    case (int *)0x37:\n    case (int *)0x38:\n    case (int *)0x39:\n      goto switchD_08005f58_caseD_31;\n    case (int *)0x41:\n    case (int *)0x45:\n    case (int *)0x46:\n    case (int *)0x47:\n    case (int *)0x61:\n    case (int *)0x65:\n    case (int *)0x66:\n    case (int *)0x67:\n      puVar29 = (undefined4 *)((int)local_154 + 7U & 0xfffffff8);\n      uVar10 = *puVar29;\n      local_12c = puVar29[1];\n      local_168 = (int *)(local_12c & 0x7fffffff);\n      local_154 = (int **)(puVar29 + 2);\n      local_128 = uVar10;\n      iVar3 = FUN_08001170(uVar10,local_168,0xffffffff,DAT_08006724);\n      if ((iVar3 == 0) &&\n         (iVar3 = FUN_080009c0(uVar10,local_168,0xffffffff,DAT_08006724), iVar3 == 0)) {\n        iVar3 = FUN_080009ac(local_128,local_12c,local_124,local_120);\n        piVar23 = (int *)PTR_DAT_08006728;\n        piVar27 = (int *)PTR_DAT_0800672c;\n        if (iVar3 == 0) {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (piVar24 < (int *)0x48) {\n          piVar23 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar25 = (int *)((uint)piVar25 & 0xffffff7f);\n        local_158 = (int **)0x3;\n        local_13c = (int **)0x0;\n        piVar22 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      piVar22 = (int *)FUN_08001170(local_128,local_12c,local_128,local_12c);\n      if (piVar22 != (int *)0x0) {\n        piVar23 = (int *)PTR_DAT_08007898;\n        piVar27 = (int *)PTR_DAT_0800789c;\n        if ((int)local_12c < 0) {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        goto LAB_08006524;\n      }\n      piVar16 = piVar27;\n      if (piVar24 == (int *)0x61) {\n        uVar12 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar12,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          piVar25 = (int *)((uint)piVar25 | 2);\n        }\n        else {\n          param_3 = (int *)FUN_08008af8(local_16c,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar13 = *(ushort *)(local_160 + 3) | 0x40;\n            *(ushort *)(local_160 + 3) = uVar13;\n            goto LAB_0800604e;\n          }\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          piVar25 = (int *)((uint)piVar25 | 2);\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        piVar27 = piVar16;\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = (int *)0x2d;\n          uVar19 = local_12c + 0x80000000;\n          piVar16 = piVar27;\n        }\n        else {\n          local_144 = (int *)0x0;\n          uVar19 = local_12c;\n        }\n        local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n        local_158 = (int **)local_128;\n        if (piVar24 == (int *)0x61) {\n          uVar33 = FUN_080096e0(local_128,uVar19,&local_f0);\n          local_150 = FUN_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = FUN_08000998((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                               local_120);\n          if (iVar3 != 0) {\n            local_f0 = (int *)0x1;\n          }\n          local_158 = (int **)PTR_s_0123456789abcdef_08007888;\n          local_13c = ppiVar2;\n          local_138 = piVar28;\n          local_134 = piVar24;\n          local_130 = piVar16;\n          local_100 = piVar25;\n          local_fc = param_3;\n          puVar20 = PTR_s_0123456789abcdef_08007888;\n          uVar33 = local_150;\n          goto LAB_080072ba;\n        }\n        piVar27 = piVar16;\n        if (piVar24 == (int *)0x41) {\n          uVar33 = FUN_080096e0(local_128,uVar19,&local_f0);\n          local_150 = FUN_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = FUN_08000998((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                               local_120);\n          if (iVar3 == 0) {\n            local_158 = (int **)PTR_s_0123456789ABCDEF_0800739c;\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar16;\n            local_100 = piVar25;\n            local_fc = param_3;\n            puVar20 = PTR_s_0123456789ABCDEF_0800739c;\n            uVar33 = local_150;\n          }\n          else {\n            local_f0 = (int *)0x1;\n            local_158 = (int **)PTR_s_0123456789ABCDEF_08007894;\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar16;\n            local_100 = piVar25;\n            local_fc = param_3;\n            puVar20 = PTR_s_0123456789ABCDEF_08007894;\n            uVar33 = local_150;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (piVar24 == (int *)0x41) {\n          uVar12 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = (int *)((uint)piVar25 | 0x100);\n        local_148 = piVar22;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar16 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if (((uint)piVar24 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar16 = (int *)0x1;\n            local_148 = piVar27;\n          }\n          goto LAB_0800724a;\n        }\n        uVar19 = local_12c;\n        local_144 = piVar22;\n        if ((int)local_12c < 0) goto LAB_08007414;\n      }\n      local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n      piStack_184 = piVar27;\n      local_158 = (int **)local_128;\n      if (piVar24 == (int *)0x66) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)FUN_080079e8(local_16c,local_180,local_128,uVar19);\n        piVar22 = (int *)((int)piVar23 + (int)piVar27);\n        local_150._0_4_ = piVar27;\nLAB_0800764c:\n        if ((*(byte *)piVar23 == 0x30) &&\n           (iVar3 = FUN_08000998(local_158,uVar19,local_124,local_120), iVar3 == 0)) {\n          local_f0 = (int *)(1 - (int)(int *)local_150);\n        }\n        piVar22 = (int *)((int)piVar22 + (int)local_f0);\n      }\n      else if (piVar24 == (int *)0x46) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)FUN_080079e8(local_16c,local_180,local_128,uVar19);\n        local_150._0_4_ = piVar27;\nLAB_08007760:\n        piVar22 = (int *)((int)piVar23 + (int)(int *)local_150);\n        if (piVar24 == (int *)0x46) goto LAB_0800764c;\n      }\n      else {\n        local_178 = &local_e0;\n        local_150._0_4_ = piVar27;\n        if (local_168 == (int *)0x45) {\n          local_150._0_4_ = (int *)((int)piVar27 + 1);\n        }\n        local_188 = 2;\n        piStack_184 = (int *)local_150;\n        local_180 = &local_f0;\n        puStack_17c = auStack_ec;\n        piVar23 = (int *)FUN_080079e8(local_16c,local_180,local_128,uVar19);\n        piVar16 = local_e0;\n        if (piVar24 == (int *)0x67) {\n          if (((uint)piVar25 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (piVar24 == (int *)0x47) {\n          if (((uint)piVar25 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar22 = (int *)((int)(int *)local_150 + (int)piVar23);\n      }\n      iVar3 = FUN_08000998(local_158,uVar19,local_124,local_120);\n      piVar16 = piVar22;\n      if (iVar3 == 0) {\n        for (; piVar16 = local_e0, local_e0 < piVar22; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)piVar16 - (int)piVar23);\n      goto LAB_08006cb0;\n    case (int *)0x43:\n    case (int *)0x63:\n      piVar16 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar22 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (int **)0x1;\n      local_8c = SUB41(piVar27,0);\n      piVar23 = (int *)&local_8c;\n      goto LAB_08006298;\n    case (int *)0x44:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_08006102;\n    case (int *)0x4c:\n      piVar25 = (int *)((uint)piVar25 | 8);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x4f:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n    case (int *)0x6f:\n      if (((uint)piVar25 & 0x20) == 0) {\n        ppiVar14 = local_154 + 1;\n        if (((uint)piVar25 & 0x10) == 0) {\n          if (((uint)piVar25 & 0x40) == 0) {\n            if (((uint)piVar25 & 0x200) == 0) goto LAB_08006be2;\n            piVar22 = (int *)(uint)*(byte *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n          else {\n            piVar22 = (int *)(uint)*(ushort *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar22 = *local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\n        ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar22 = *ppiVar14;\n        piVar16 = ppiVar14[1];\n        local_154 = ppiVar14 + 2;\n      }\n      iVar3 = 0;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n      break;\n    case (int *)0x53:\n    case (int *)0x73:\n      local_f5 = 0;\n      piVar22 = *local_154;\n      ppiVar14 = local_154 + 1;\n      if (piVar22 == (int *)0x0) {\n        piVar16 = piVar22;\n        piVar23 = (int *)PTR_s__null__08007084;\n        local_168 = piVar27;\n        local_158 = (int **)piVar27;\n        local_154 = ppiVar14;\n        local_148 = piVar22;\n        local_13c = (int **)piVar22;\n        local_134 = piVar22;\n        local_130 = piVar22;\n        if ((int *)0x5 < piVar27) {\n          local_158 = (int **)0x6;\n          local_168 = (int *)local_158;\n        }\n        goto LAB_08006538;\n      }\n      piVar23 = piVar22;\n      if (piVar27 == (int *)0xffffffff) {\n        local_158 = (int **)FUN_08005e40(piVar22);\n      }\n      else {\n        local_148 = (int *)FUN_0800901c(piVar22,0,piVar27);\n        if (local_148 == (int *)0x0) {\n          piVar16 = (int *)(uint)local_f5;\n          piVar22 = local_148;\n          local_168 = piVar27;\n          local_158 = (int **)piVar27;\n          local_154 = ppiVar14;\n          local_13c = (int **)local_148;\n          local_134 = local_148;\n          local_130 = local_148;\n          goto LAB_08006538;\n        }\n        local_158 = (int **)((int)local_148 - (int)piVar22);\n      }\n      local_148 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      piVar16 = (int *)(uint)local_f5;\n      piVar22 = (int *)0x0;\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      local_154 = ppiVar14;\n      goto LAB_08006538;\n    case (int *)0x55:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      iVar3 = 1;\n      local_154 = ppiVar14 + 2;\n      break;\n    case (int *)0x58:\n      local_11c = PTR_s_0123456789ABCDEF_08006730;\n      if (((uint)piVar25 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_080061be;\n    case (int *)0x64:\n    case (int *)0x69:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bcc:\n        piVar22 = *local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(int)*(short *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bcc;\n        piVar22 = (int *)(int)*(char *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\nLAB_08006102:\n      if ((int)piVar16 < 0) {\n        bVar31 = piVar22 != (int *)0x0;\n        piVar22 = (int *)-(int)piVar22;\n        piVar16 = (int *)(-(int)piVar16 - (uint)bVar31);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar3 = 1;\n        iVar8 = 1;\n        piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n        if (((uint)piVar22 | (uint)piVar16) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      piVar21 = piVar25;\n      if (piVar16 != (int *)0x0 || (int *)0x9 < piVar22) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case (int *)0x68:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x68) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar25 = (int *)((uint)piVar25 | 0x200);\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        piVar25 = (int *)((uint)piVar25 | 0x40);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x6a:\n    case (int *)0x71:\n      piVar25 = (int *)((uint)piVar25 | 0x20);\n    case (int *)0x74:\n    case (int *)0x7a:\nswitchD_08005f58_caseD_74:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case (int *)0x6e:\n      ppiVar14 = local_154 + 1;\n      ppbVar15 = (byte **)*local_154;\n      local_154 = ppiVar14;\n      if (((uint)piVar25 & 0x20) != 0) {\n        *ppbVar15 = local_164;\n        ppbVar15[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) != 0) {\n          *(short *)ppbVar15 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if (((uint)piVar25 & 0x200) != 0) {\n          *(char *)ppbVar15 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar15 = local_164;\n      goto LAB_0800620e;\n    case (int *)0x70:\n      local_f4 = 0x7830;\n      local_11c = PTR_s_0123456789abcdef_08006434;\n      piVar22 = *local_154;\n      piVar25 = (int *)((uint)piVar25 | 2);\n      piVar16 = (int *)0x0;\n      iVar3 = 2;\n      piVar24 = (int *)0x78;\n      local_154 = local_154 + 1;\n      break;\n    case (int *)0x75:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bf2:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(uint)*(ushort *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bf2;\n        piVar22 = (int *)(uint)*(byte *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      break;\n    case (int *)0x78:\n      local_11c = PTR_s_0123456789abcdef_08006434;\n      if (((uint)piVar25 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar14 = local_154 + 1;\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) == 0) {\n          if (((uint)piVar25 & 0x200) == 0) goto LAB_08006bbc;\n          piVar22 = (int *)(uint)*(byte *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n        else {\n          piVar22 = (int *)(uint)*(ushort *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        local_154 = ppiVar14;\n      }\nLAB_080061be:\n      if ((((uint)piVar25 & 1) != 0) && (((uint)piVar22 | (uint)piVar16) != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 2);\n        local_f4 = CONCAT11((char)piVar24,0x30);\n      }\n      iVar3 = 2;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      if (iVar3 != 1) goto LAB_08006136;\nLAB_08006980:\n      piVar21 = piVar25;\n      if (piVar16 == (int *)0x0 && piVar22 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar32 = CONCAT44(piVar16,piVar22);\n      piVar23 = (int *)(&bStack_2a + 2);\n      piVar22 = (int *)0x0;\n      pbVar26 = local_108;\n      local_168 = piVar23;\n      local_158 = ppiVar2;\n      local_150._0_4_ = piVar25;\n      local_148 = piVar24;\n      do {\n        iVar3 = (int)((ulonglong)lVar32 >> 0x20);\n        uVar19 = (uint)lVar32;\n        cVar6 = '\\n';\n        FUN_080011ec(uVar19,iVar3,10,0);\n        *(byte *)((int)piVar23 + -1) = cVar6 + 0x30;\n        piVar22 = (int *)((int)piVar22 + 1);\n        piVar23 = (int *)((int)piVar23 + -1);\n        if ((((((uint)piVar25 & 0x400) != 0) && (piVar22 == (int *)(uint)*pbVar26)) &&\n            (piVar22 != (int *)0xff)) && (iVar3 != 0 || 9 < uVar19)) {\n          piVar23 = (int *)((int)piVar23 - (int)local_104);\n          FUN_08009768(piVar23,local_110,local_104);\n          piVar22 = (int *)(uint)pbVar26[1];\n          if (piVar22 != (int *)0x0) {\n            pbVar26 = pbVar26 + 1;\n            piVar22 = (int *)0x0;\n          }\n        }\n        lVar32 = FUN_080011ec(uVar19,iVar3,10,0);\n      } while (lVar32 != 0);\n      piVar24 = local_148;\n      piVar25 = (int *)local_150;\n      ppiVar2 = local_158;\n      local_158 = (int **)((int)local_168 - (int)piVar23);\n      local_138 = piVar22;\n      local_108 = pbVar26;\n    }\n    else {\n      piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n      iVar8 = iVar3;\n      if (((uint)piVar22 | (uint)piVar16) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar3 == 0) {\n            local_158 = (int **)((uint)piVar25 & 1);\n            if (local_158 == (int **)0x0) {\n              piVar23 = (int *)(&bStack_2a + 2);\n              piVar25 = piVar21;\n            }\n            else {\n              piVar23 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n              piVar25 = piVar21;\n            }\n          }\n          else {\n            piVar23 = (int *)(&bStack_2a + 2);\n            piVar25 = piVar21;\n            local_158 = (int **)piVar27;\n          }\n        }\n        else {\n          piVar25 = piVar21;\n          if (iVar3 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar22 + '0';\n          piVar23 = (int *)(&bStack_2a + 1);\n          local_158 = (int **)0x1;\n          piVar25 = piVar21;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar3 = iVar8;\n        piVar25 = piVar21;\n        if (iVar8 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar3 == 2) {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = (int *)((uint)piVar22 >> 4 | (int)piVar16 << 0x1c);\n            piVar16 = (int *)((uint)piVar16 >> 4);\n            piVar23 = (int *)((int)piVar23 + -1);\n            *(undefined *)piVar23 = local_11c[(uint)piVar22 & 0xf];\n            piVar22 = piVar21;\n          } while (((uint)piVar21 | (uint)piVar16) != 0);\n        }\n        else {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = piVar23;\n            piVar9 = (int *)((uint)piVar22 >> 3 | (int)piVar16 << 0x1d);\n            piVar16 = (int *)((uint)piVar16 >> 3);\n            iVar3 = ((uint)piVar22 & 7) + 0x30;\n            *(byte *)((int)piVar21 + -1) = (byte)iVar3;\n            piVar23 = (int *)((int)piVar21 + -1);\n            piVar22 = piVar9;\n          } while (((uint)piVar9 | (uint)piVar16) != 0);\n          if ((((uint)piVar25 & 1) != 0) && (iVar3 != 0x30)) {\n            piVar23 = (int *)((int)piVar21 + -2);\n            *(byte *)((int)piVar21 + -2) = 0x30;\n            local_158 = (int **)(&bStack_2a + (2 - (int)piVar23));\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (int **)(&bStack_2a + (2 - (int)piVar23));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  piVar28 = local_160;\n  if (local_d0 == (int *)0x0) {\nLAB_0800604a:\n    uVar13 = *(ushort *)(local_160 + 3);\n  }\n  else {\n    FUN_080097cc(local_16c,local_160,&local_d8);\n    uVar13 = *(ushort *)(piVar28 + 3);\n  }\nLAB_0800604e:\n  if ((uVar13 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (piVar24 == (int *)0x6c) {\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    piVar25 = (int *)((uint)piVar25 | 0x20);\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    piVar25 = (int *)((uint)piVar25 | 0x10);\n  }\n  goto LAB_08005f4a;\n  while( true ) {\n    iVar8 = FUN_08000998((int)uVar33,uVar10,local_124,local_120);\n    if (iVar8 != 0) break;\nLAB_080072ba:\n    piVar22 = param_3;\n    piVar16 = (int *)((int)piVar16 + -1);\n    uVar33 = FUN_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,DAT_080073a0);\n    iVar3 = FUN_0800119c();\n    uVar34 = FUN_080003f4();\n    uVar33 = FUN_08000158((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar34,\n                          (int)((ulonglong)uVar34 >> 0x20));\n    uVar10 = (undefined4)((ulonglong)uVar33 >> 0x20);\n    param_3 = (int *)((int)piVar22 + 1);\n    *(undefined *)piVar22 = puVar20[iVar3];\n    if (piVar16 == (int *)0xffffffff) break;\n  }\n  piVar23 = local_fc;\n  piVar25 = local_100;\n  piVar27 = local_130;\n  piVar24 = local_134;\n  piVar28 = local_138;\n  ppiVar2 = local_13c;\n  local_13c = (int **)piVar16;\n  local_134 = piVar22;\n  local_150 = uVar33;\n  iVar8 = FUN_080009e8((int)uVar33,uVar10,0,DAT_080073a4);\n  if (iVar8 == 0) {\n    iVar8 = FUN_08000998((int *)local_150,local_150._4_4_,0,DAT_080073a4);\n    if ((iVar8 != 0) && (iVar3 << 0x1f < 0)) goto LAB_0800748a;\n    if (-1 < (int)local_13c) {\n      piVar16 = (int *)((byte *)((int)local_13c + 1) + (int)param_3);\n      piVar22 = param_3;\n      do {\n        param_3 = (int *)((int)piVar22 + 1);\n        *(byte *)piVar22 = 0x30;\n        piVar22 = param_3;\n      } while (piVar16 != param_3);\n    }\n  }\n  else {\nLAB_0800748a:\n    bVar1 = *(byte *)((int)local_158 + 0xf);\n    bVar7 = *(byte *)piVar22;\n    piVar22 = param_3;\n    local_e0 = local_134;\n    while (bVar1 == bVar7) {\n      *(byte *)((int)piVar22 + -1) = 0x30;\n      bVar7 = *(byte *)((int)local_e0 + -1);\n      piVar22 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar7 == 0x39) {\n      bVar7 = *(byte *)((int)local_158 + 10);\n    }\n    else {\n      bVar7 = bVar7 + 1;\n    }\n    *(byte *)((int)piVar22 + -1) = bVar7;\n  }\n  local_138 = (int *)((int)param_3 - (int)piVar23);\nLAB_08006cb0:\n  local_134 = local_f0;\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0 + 3) < 0 == SCARRY4((int)local_f0,3)) &&\n       ((int)local_f0 <= (int)piVar27)) {\n      if ((int)local_f0 < (int)local_138) {\n        local_158 = (int **)((int)local_138 + (int)local_118);\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (int **)((int)local_158 + (1 - (int)local_f0));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        piVar24 = (int *)0x67;\n      }\n      else {\n        if ((int)piVar25 << 0x1f < 0) {\n          local_158 = (int **)((int)local_f0 + (int)local_118);\n        }\n        else {\n          local_158 = (int **)local_f0;\n        }\n        if (-1 < (int)piVar25 << 0x15) {\n          piVar24 = (int *)0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074fc;\n        }\n        piVar24 = (int *)0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    piVar24 = (int *)((int)piVar24 + -2);\n    local_168 = (int *)((uint)piVar24 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8 = (char)piVar24;\n    if (local_168 == (int *)0x41) {\n      local_e8 = local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0 + -1);\n    if ((int)piVar27 < 0) {\n      local_e7 = 0x2d;\n      local_f0 = (int *)(1 - (int)local_f0);\n    }\n    else {\n      local_e7 = 0x2b;\n      local_f0 = piVar27;\n    }\n    if ((int)local_f0 < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e6[0] = 0x30;\n        pcVar18 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar18 = (char)local_f0 + '0';\n      pcVar18 = pcVar18 + 1;\n    }\n    else {\n      pbVar30 = abStack_dc + 3;\n      pbVar26 = pbVar30;\n      do {\n        pbVar5 = pbVar26;\n        piVar22 = (int *)((ulonglong)DAT_08007890 * ZEXT48(local_f0) >> 0x23);\n        pbVar5[-1] = (char)local_f0 + (char)piVar22 * -10 + 0x30;\n        pbVar26 = pbVar5 + -1;\n        local_f0 = piVar22;\n      } while ((int *)0x9 < piVar22);\n      uVar19 = (uint)(piVar22 + 0xc) & 0xff;\n      pbVar5[-2] = (byte)uVar19;\n      if (pbVar5 + -2 < pbVar30) {\n        pbVar5 = pbVar26;\n        puVar20 = (undefined *)((int)&local_e8 + 2);\n        while( true ) {\n          *puVar20 = (char)uVar19;\n          if (pbVar30 == pbVar5) break;\n          uVar19 = (uint)*pbVar5;\n          pbVar5 = pbVar5 + 1;\n          puVar20 = puVar20 + 1;\n        }\n        pcVar18 = (char *)(((int)&local_188 * 2 - (int)pbVar26) + 0x152);\n      }\n      else {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar18 + -(int)&local_e8);\n    local_158 = (int **)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)piVar25 << 0x1f < 0)) {\n      local_158 = (int **)((int)local_158 + (int)local_118);\n    }\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    piVar25 = (int *)((uint)piVar25 & 0xfffffbff | 0x100);\n    local_f0 = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0 < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_168 = (int *)0x1;\n        local_158 = (int **)0x1;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (int **)((byte *)((int)local_118 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      piVar25 = local_140;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_158 = (int **)local_f0;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (int **)((byte *)((int)local_f0 + (int)local_118) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)piVar25 << 0x15) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      uVar19 = (uint)*local_108;\n      while (uVar19 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar19) goto LAB_08007524;\n          uVar4 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar19);\n          if (uVar4 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = (int *)((int)local_130 + 1);\n          uVar19 = uVar4;\n          if (uVar4 == 0xff) goto LAB_08007524;\n        }\n        local_13c = (int **)((int)local_13c + 1);\n      }\nLAB_08007524:\n      local_158 = (int **)((int)local_158 + (int)local_104 * (int)((int)local_130 + (int)local_13c))\n      ;\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      piVar25 = local_140;\n    }\n  }\n  if (local_144 == (int *)0x0) {\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = local_144;\nLAB_08006538:\n    if (piVar16 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar16 = (int *)0x2d;\n    piVar22 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n  }\nLAB_08006298:\n  piVar27 = local_160;\n  puVar29 = local_16c;\n  local_150._0_4_ = (int *)((uint)piVar25 & 2);\n  if ((int *)local_150 != (int *)0x0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  local_144 = (int *)((uint)piVar25 & 0x84);\n  if ((local_144 == (int *)0x0) &&\n     (piVar21 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar21)) {\n    if (0x10 < (int)piVar21) {\n      piVar16 = (int *)0x10;\n      local_100 = piVar24;\n      do {\n        piVar9 = piVar21;\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)PTR_s__0000000000000000Infinity_08006438;\n        ppiVar2[1] = piVar16;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n          piVar24 = local_100;\n        }\n        else {\n          local_140 = piVar16;\n          iVar3 = FUN_080097cc(puVar29,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = local_140;\n          piVar24 = local_100;\n        }\n        piVar21 = piVar9 + -4;\n        local_100 = piVar24;\n      } while (0x10 < (int)piVar21);\n      piVar21 = piVar9 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar21);\n    *ppiVar2 = (int *)PTR_s__0000000000000000Infinity_08006438;\n    ppiVar2[1] = piVar21;\n    if ((int)local_d4 < 8) {\n      piVar16 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar16 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar16 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 1);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((int *)local_150 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 2);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  puVar20 = PTR_s_0000000000000000Infinity_08006a54;\n  if ((local_144 == (int *)0x80) &&\n     (piVar16 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar16)) {\n    if (0x10 < (int)piVar16) {\n      do {\n        while( true ) {\n          piVar21 = piVar16;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)puVar20;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = FUN_080097cc(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = piVar21 + -4;\n          if ((int)(piVar21 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar16 = piVar21 + -4;\n      } while (0x10 < (int)(piVar21 + -4));\nLAB_08006882:\n      piVar16 = piVar21 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar16);\n    *ppiVar2 = (int *)puVar20;\n    ppiVar2[1] = piVar16;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  puVar20 = PTR_s_0000000000000000Infinity_0800643c;\n  piVar22 = (int *)((int)piVar22 - (int)local_158);\n  if (0 < (int)piVar22) {\n    piVar16 = (int *)PTR_s_0000000000000000Infinity_08007088;\n    if (0x10 < (int)piVar22) {\n      do {\n        while( true ) {\n          piVar16 = piVar22;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)puVar20;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = FUN_080097cc(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar22 = piVar16 + -4;\n          if ((int)(piVar16 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar22 = piVar16 + -4;\n      } while (0x10 < (int)(piVar16 + -4));\nLAB_080063d2:\n      piVar22 = piVar16 + -4;\n      piVar16 = (int *)puVar20;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar22);\n    *ppiVar2 = piVar16;\n    ppiVar2[1] = piVar22;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_d0;\n  if (((uint)piVar25 & 0x100) == 0) {\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)local_158);\n    *ppiVar2 = piVar23;\n    ppiVar2[1] = (int *)local_158;\n    if ((int)local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else if ((int)piVar24 < 0x66) {\n    local_158 = (int **)((int)local_d0 + 1);\n    piVar27 = (int *)((int)local_d4 + 1);\n    ppiVar14 = ppiVar2 + 2;\n    local_d0 = (int *)local_158;\n    if (((int)local_138 < 2) && (((uint)piVar25 & 1) == 0)) {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)piVar27 < 8) {\n        local_150._0_4_ = (int *)((int)local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = piVar27;\n        iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        local_150._0_4_ = (int *)((int)local_d4 + 1);\n        ppiVar14 = local_cc;\n        local_158 = (int **)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = piVar27;\n      if (7 < (int)piVar27) {\n        iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar14 = local_cc;\n        local_158 = (int **)local_d0;\n      }\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_158 = (int **)((int)local_158 + (int)local_118);\n      *ppiVar14 = local_114;\n      ppiVar14[1] = local_118;\n      local_d0 = (int *)local_158;\n      if ((int)local_d4 < 8) {\n        ppiVar17 = ppiVar14 + 2;\n      }\n      else {\n        iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar17 = local_cc;\n      }\n      piVar24 = local_d4;\n      local_150._0_4_ = (int *)((int)local_d4 + 1);\n      piVar22 = (int *)((int)local_138 + -1);\n      ppiVar11 = ppiVar17 + 2;\n      local_158 = (int **)local_d0;\n      local_144 = (int *)local_150;\n      iVar3 = FUN_08000998(local_128,local_12c,local_124,local_120);\n      piVar27 = local_160;\n      puVar29 = local_16c;\n      puVar20 = PTR_s_0000000000000000Infinity_08006d94;\n      if (iVar3 == 0) {\n        local_158 = (int **)((int)local_158 + (int)piVar22);\n        *ppiVar17 = (int *)((int)piVar23 + 1);\n        ppiVar17[1] = piVar22;\n        local_d0 = (int *)local_158;\n        if ((int)(int *)local_150 < 8) {\n          local_150._0_4_ = (int *)((int)piVar24 + 2);\n          ppiVar14 = ppiVar11;\n          ppiVar2 = ppiVar17 + 4;\n        }\n        else {\nLAB_08006d9c:\n          local_158 = (int **)local_d0;\n          local_d4 = (int *)local_150;\n          iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          local_150._0_4_ = (int *)((int)local_d4 + 1);\n          local_158 = (int **)local_d0;\n          ppiVar14 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar14 = ppiVar17;\n        ppiVar2 = ppiVar11;\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)local_158;\n          piVar24 = (int *)PTR_s_0000000000000000Infinity_0800788c;\n          local_d4 = local_144;\n          if (0x10 < (int)piVar22) {\n            while( true ) {\n              local_d0 = local_d0 + 4;\n              *ppiVar17 = (int *)puVar20;\n              ppiVar17[1] = (int *)0x10;\n              if ((int)local_d4 < 8) {\n                ppiVar17 = ppiVar17 + 2;\n              }\n              else {\n                iVar3 = FUN_080097cc(puVar29,piVar27,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar17 = local_cc;\n              }\n              piVar22 = piVar22 + -4;\n              if ((int)piVar22 < 0x11) break;\n              local_d4 = (int *)((int)local_d4 + 1);\n            }\n            local_150._0_4_ = (int *)((int)local_d4 + 1);\n            ppiVar11 = ppiVar17 + 2;\n            piVar24 = (int *)puVar20;\n            local_158 = (int **)local_d0;\n          }\n          *ppiVar17 = piVar24;\n          ppiVar17[1] = piVar22;\n          local_158 = (int **)((int)local_158 + (int)piVar22);\n          local_d0 = (int *)local_158;\n          if (7 < (int)(int *)local_150) goto LAB_08006d9c;\n          local_150._0_4_ = (int *)((int)(int *)local_150 + 1);\n          ppiVar2 = ppiVar11 + 2;\n          ppiVar14 = ppiVar11;\n        }\n      }\n    }\n    ppiVar14[1] = local_10c;\n    local_d0 = (int *)((int)local_158 + (int)local_10c);\n    local_d4 = (int *)local_150;\n    *ppiVar14 = (int *)&local_e8;\n    piVar27 = local_d0;\n    if (7 < (int)(int *)local_150) {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else {\n    iVar3 = FUN_08000998(local_128,local_12c,local_124,local_120);\n    if (iVar3 == 0) {\n      if ((int)local_f0 < 1) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)piVar27 + 1);\n        *ppiVar2 = (int *)PTR_DAT_08006d98;\n        ppiVar2[1] = (int *)0x1;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0 != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)local_d0 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          puVar29 = local_16c;\n          puVar20 = PTR_s_0000000000000000Infinity_0800788c;\n          if ((int)local_f0 < 0) {\n            piVar27 = (int *)-(int)local_f0;\n            if ((int)(local_f0 + 4) < 0 != SCARRY4((int)local_f0,0x10)) {\n              do {\n                local_d4 = (int *)((int)local_d4 + 1);\n                local_d0 = local_d0 + 4;\n                *ppiVar2 = (int *)puVar20;\n                ppiVar2[1] = (int *)0x10;\n                if ((int)local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar3 = FUN_080097cc(puVar29,local_160,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)local_d0 + (int)piVar27);\n            *ppiVar2 = (int *)puVar20;\n            ppiVar2[1] = piVar27;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = (int *)((int)local_d0 + (int)local_138);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar24 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar24 = local_138;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar24);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = piVar24;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        puVar20 = PTR_s_0000000000000000Infinity_08006d94;\n        piVar22 = local_134;\n        if (-1 < (int)piVar24) {\n          piVar22 = (int *)((int)local_134 - (int)piVar24);\n        }\n        piVar24 = (int *)PTR_s_0000000000000000Infinity_0800788c;\n        if (0 < (int)piVar22) {\n          for (; 0x10 < (int)piVar22; piVar22 = piVar22 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = piVar27 + 4;\n            *ppiVar2 = (int *)puVar20;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n            piVar24 = (int *)puVar20;\n          }\n          local_d4 = (int *)((int)local_d4 + 1);\n          piVar27 = (int *)((int)piVar27 + (int)piVar22);\n          *ppiVar2 = piVar24;\n          ppiVar2[1] = piVar22;\n          local_d0 = piVar27;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar22 = local_104;\n        piVar24 = local_160;\n        puVar29 = local_16c;\n        puVar20 = PTR_s_0000000000000000Infinity_08007398;\n        piVar16 = (int *)((int)local_134 + (int)piVar23);\n        if (((uint)piVar25 & 0x400) != 0) {\n          local_158 = (int **)((int)piVar23 + (int)local_138);\n          pbVar26 = local_108;\n          local_150._0_4_ = piVar28;\n          local_144 = piVar25;\n          local_140 = piVar23;\n          if (local_130 == (int *)0x0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != (int **)0x0) goto LAB_0800717e;\n          pbVar26 = pbVar26 + -1;\n          local_130 = (int *)((int)local_130 + -1);\n          do {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)piVar27 + (int)piVar22);\n            *ppiVar2 = local_110;\n            ppiVar2[1] = piVar22;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = (int *)(uint)*pbVar26;\n            piVar28 = (int *)((int)local_158 - (int)piVar16);\n            if ((int)piVar27 <= (int)(int *)((int)local_158 - (int)piVar16)) {\n              piVar28 = piVar27;\n            }\n            if (0 < (int)piVar28) {\n              local_d0 = (int *)((int)local_d0 + (int)piVar28);\n              local_d4 = (int *)((int)local_d4 + 1);\n              *ppiVar2 = piVar16;\n              ppiVar2[1] = piVar28;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar27 = (int *)(uint)*pbVar26;\n              }\n            }\n            piVar25 = piVar27;\n            if (-1 < (int)piVar28) {\n              piVar25 = (int *)((int)piVar27 - (int)piVar28);\n            }\n            if (0 < (int)piVar25) {\n              for (; 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n                while( true ) {\n                  local_d4 = (int *)((int)local_d4 + 1);\n                  local_d0 = local_d0 + 4;\n                  *ppiVar2 = (int *)puVar20;\n                  ppiVar2[1] = (int *)0x10;\n                  if ((int)local_d4 < 8) break;\n                  iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  piVar25 = piVar25 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar25 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = (int *)((int)local_d4 + 1);\n              local_d0 = (int *)((int)local_d0 + (int)piVar25);\n              *ppiVar2 = (int *)puVar20;\n              ppiVar2[1] = piVar25;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = local_cc;\n              }\n            }\n            piVar16 = (int *)((int)piVar16 + (int)piVar27);\n            piVar27 = local_d0;\n            if (local_130 != (int *)0x0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == (int **)0x0) {\n              piVar23 = local_140;\n              piVar25 = local_144;\n              piVar28 = (int *)local_150;\n              local_108 = pbVar26;\n              if ((int *)((int)local_140 + (int)local_138) <= piVar16) {\n                piVar16 = (int *)((int)local_140 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = (int **)((int)local_13c + -1);\n          } while( true );\n        }\n        if (((int)local_f0 < (int)local_138) || (((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)piVar27 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar24 = (int *)((int)local_138 - (int)local_f0);\n        piVar22 = (int *)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16);\n        if ((int)piVar24 <= (int)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16)) {\n          piVar22 = piVar24;\n        }\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar22);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar16;\n          ppiVar2[1] = piVar22;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar24 = (int *)((int)local_138 - (int)local_f0);\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        puVar20 = PTR_s_0000000000000000Infinity_08007088;\n        if (-1 < (int)piVar22) {\n          piVar24 = (int *)((int)piVar24 - (int)piVar22);\n        }\n        piVar22 = (int *)PTR_s_0000000000000000Infinity_0800788c;\n        if (0 < (int)piVar24) {\n          for (; local_d0 = piVar27, 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)puVar20;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n            piVar22 = (int *)puVar20;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_d0 = (int *)((int)piVar27 + 1);\n      *ppiVar2 = (int *)PTR_DAT_08006a50;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0 < (int)local_138) || (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)local_118);\n        *ppiVar2 = local_114;\n        ppiVar2[1] = local_118;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        puVar20 = PTR_s_0000000000000000Infinity_08006a54;\n        piVar24 = (int *)((int)local_138 + -1);\n        piVar27 = local_d0;\n        piVar22 = (int *)PTR_s_0000000000000000Infinity_0800788c;\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)puVar20;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar22 = (int *)puVar20;\n          }\nLAB_08007014:\n          local_d0 = (int *)((int)local_d0 + (int)piVar24);\n          *ppiVar2 = piVar22;\n          ppiVar2[1] = piVar24;\njoined_r0x08006a1c:\n          local_d4 = (int *)((int)local_d4 + 1);\n          if (7 < (int)local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  piVar24 = local_160;\n  puVar29 = local_16c;\n  if ((((uint)piVar25 & 4) != 0) &&\n     (piVar25 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar25)) {\n    for (; local_d0 = piVar27, 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n      while( true ) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)PTR_s__0000000000000000Infinity_08006720;\n        ppiVar2[1] = (int *)0x10;\n        if ((int)local_d4 < 8) break;\n        iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        piVar25 = piVar25 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar25 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar25);\n    *ppiVar2 = (int *)PTR_s__0000000000000000Infinity_08006720;\n    ppiVar2[1] = piVar25;\n    piVar27 = local_d0;\n    if ((7 < (int)local_d4) &&\n       (iVar3 = FUN_080097cc(local_16c,local_160,&local_d8), piVar27 = local_d0, iVar3 != 0))\n    goto LAB_0800603e;\n  }\n  piVar24 = local_15c;\n  if ((int)local_15c < (int)local_168) {\n    piVar24 = local_168;\n  }\n  local_164 = local_164 + (int)piVar24;\n  if ((piVar27 == (int *)0x0) || (iVar3 = FUN_080097cc(local_16c,local_160,&local_d8), iVar3 == 0))\n  {\n    local_d4 = (int *)0x0;\n    if (local_148 != (int *)0x0) {\n      FUN_080088ec(local_16c,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    FUN_080088ec(local_16c,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  piVar16 = piVar24 + -0xc;\n  piVar22 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar22 + 1);\n    piVar24 = (int *)(uint)*(byte *)piVar22;\n    local_15c = (int *)((int)piVar16 + (int)local_15c * 10);\n    piVar16 = piVar24 + -0xc;\n    piVar22 = piVar28;\n  } while (piVar16 < (int *)0xa);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "called": [
                "FUN_080096e0",
                "FUN_080003f4",
                "FUN_080004c8",
                "FUN_080009ac",
                "FUN_0800119c",
                "FUN_080009c0",
                "FUN_0800901c",
                "FUN_080088ec",
                "FUN_08008af8",
                "FUN_080097cc",
                "FUN_08009768",
                "FUN_08000158",
                "FUN_08000998",
                "FUN_08008ad4",
                "FUN_080011ec",
                "FUN_08001170",
                "FUN_08005e40",
                "FUN_080009e8",
                "FUN_080079e8"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08005e9c",
            "calling": [
                "FUN_08005dfc"
            ],
            "imported": false,
            "current_name": "FUNC_08005e9c"
        },
        "FUN_08000134": {
            "renaming": {
                "FUN_08000134": "concatenate_64bit_pointers_08000134",
                "param_1": "pointer_1",
                "param_2": "pointer_2"
            },
            "code": "\nundefined8 concatenate_64bit_pointers_08000134(undefined *pointer_1,undefined *pointer_2)\n\n{\n  if (DAT_08000144 != 0) {\n    pointer_1 = PTR_FUN_0800014c;\n    pointer_2 = PTR_DAT_08000148;\n  }\n  return CONCAT44(pointer_2,pointer_1);\n}\n\n",
            "called": [
                "FUN_08009e68"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000134",
            "calling": [
                "FUN_08005d20"
            ],
            "imported": false,
            "current_name": "concatenate_64bit_pointers_08000134"
        },
        "FUN_08005704": {
            "renaming": {
                "FUN_08005704": "initialize_application_08005704"
            },
            "code": "\nvoid initialize_application_08005704(void)\n\n{\n  FUN_0800157c();\n  FUN_080017b4();\n  return;\n}\n\n",
            "called": [
                "FUN_080017b4",
                "FUN_0800157c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005704",
            "calling": [],
            "imported": false,
            "current_name": "initialize_application_08005704"
        },
        "FUN_08000418": {
            "renaming": {
                "FUN_08000418": "reverse_bits_and_shift_left_08000418",
                "param_1": "input",
                "param_2": "unused_param_1",
                "param_3": "unused_param_2",
                "param_4": "byte_mask",
                "uVar1": "msb_bit",
                "uVar2": "shifted_input",
                "uVar3": "output_hi",
                "uVar4": "shift_amount",
                "uVar5": "shifted_input",
                "uVar7": "leading_zeroes",
                "iVar6": "bit_index",
                "bVar8": "is_shift_amount_zero",
                "bVar9": "is_byte_mask_zero_or_ff",
                "bVar10": "is_shift_amount_negative"
            },
            "code": "\nulonglong reverse_bits_and_shift_left_08000418(uint input,undefined4 unused_param_1,undefined4 unused_param_2,uint byte_mask)\n\n{\n  uint msb_bit;\n  uint shifted_input;\n  uint output_hi;\n  uint shift_amount;\n  uint shifted_input;\n  int bit_index;\n  uint leading_zeroes;\n  uint in_r12;\n  bool is_shift_amount_zero;\n  bool is_byte_mask_zero_or_ff;\n  bool is_shift_amount_negative;\n  \n  shifted_input = input << 1;\n  is_byte_mask_zero_or_ff = shifted_input == 0;\n  msb_bit = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shift_amount = (uint)((int)shifted_input >> 3) >> 1;\n  output_hi = msb_bit | shift_amount;\n  input = input << 0x1d;\n  if (!is_byte_mask_zero_or_ff) {\n    byte_mask = shifted_input & 0xff000000;\n    is_byte_mask_zero_or_ff = byte_mask == 0;\n  }\n  if (!is_byte_mask_zero_or_ff) {\n    is_byte_mask_zero_or_ff = byte_mask == 0xff000000;\n  }\n  if (!is_byte_mask_zero_or_ff) {\n    return CONCAT44(output_hi,input) ^ 0x3800000000000000;\n  }\n  if ((shifted_input & 0xffffff) == 0) {\n    return CONCAT44(output_hi,input);\n  }\n  if (byte_mask == 0xff000000) {\n    return CONCAT44(output_hi,input) | 0x8000000000000;\n  }\n  shifted_input = input;\n  shifted_input = shift_amount;\n  if (shift_amount == 0) {\n    shifted_input = 0;\n    shifted_input = input;\n  }\n  bit_index = count_leading_zeroes(shifted_input);\n  if (shift_amount == 0) {\n    bit_index = bit_index + 0x20;\n  }\n  leading_zeroes = bit_index - 0xb;\n  is_shift_amount_negative = SBORROW4(leading_zeroes,0x20);\n  shift_amount = bit_index - 0x2b;\n  is_byte_mask_zero_or_ff = (int)shift_amount < 0;\n  is_shift_amount_zero = shift_amount == 0;\n  if ((int)leading_zeroes < 0x20) {\n    is_shift_amount_negative = SCARRY4(shift_amount,0xc);\n    bit_index = bit_index + -0x1f;\n    is_byte_mask_zero_or_ff = bit_index < 0;\n    is_shift_amount_zero = bit_index == 0;\n    shift_amount = leading_zeroes;\n    if (!is_shift_amount_zero && is_byte_mask_zero_or_ff == is_shift_amount_negative) {\n      shifted_input = shifted_input << (leading_zeroes & 0xff);\n      shifted_input = shifted_input >> (0xcU - bit_index & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_shift_amount_zero || is_byte_mask_zero_or_ff != is_shift_amount_negative) {\n    in_r12 = 0x20 - shift_amount;\n  }\n  shifted_input = shifted_input << (shift_amount & 0xff);\n  if (is_shift_amount_zero || is_byte_mask_zero_or_ff != is_shift_amount_negative) {\n    shifted_input = shifted_input | shifted_input >> (in_r12 & 0xff);\n  }\n  if (is_shift_amount_zero || is_byte_mask_zero_or_ff != is_shift_amount_negative) {\n    shifted_input = shifted_input << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if ((int)leading_zeroes < 0x381) {\n    return CONCAT44(shifted_input + (0x380 - leading_zeroes) * 0x100000 | msb_bit,shifted_input);\n  }\n  shift_amount = ~(0x380 - leading_zeroes);\n  if (0x1e < (int)shift_amount) {\n    return CONCAT44(output_hi,shifted_input >> (shift_amount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  bit_index = shift_amount - 0x13;\n  if (bit_index == 0 || bit_index < 0 != SCARRY4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(msb_bit | shifted_input >> (shift_amount & 0xff),\n                    shifted_input >> (shift_amount & 0xff) | shifted_input << (0x20 - shift_amount & 0xff));\n  }\n  return CONCAT44(output_hi,shifted_input >> (0x20 - (0xcU - bit_index) & 0xff) | shifted_input << (0xcU - bit_index & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000418",
            "calling": [
                "FUN_08004d78",
                "FUN_08004bd8",
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "reverse_bits_and_shift_left_08000418"
        },
        "FUN_08002ca8": {
            "renaming": {
                "FUN_08002ca8": "check_memory_access_08002ca8",
                "param_1": "memory_access_info",
                "param_2": "access_size",
                "param_3": "access_offset",
                "iVar1": "bytes_remaining"
            },
            "code": "\nundefined4 check_memory_access_08002ca8(int *memory_access_info,uint access_size,int access_offset)\n\n{\n  int bytes_remaining;\n  \n  while( true ) {\n    if ((*(uint *)(*memory_access_info + 0x14) & 0x40) == 0x40) {\n      return 0;\n    }\n    if ((*(uint *)(*memory_access_info + 0x14) & 0x10) == 0x10) break;\n    if ((access_size == 0) || (bytes_remaining = FUN_080015a0(), access_size < (uint)(bytes_remaining - access_offset))) {\n      memory_access_info[0x10] = memory_access_info[0x10] | 0x20;\n      *(undefined *)((int)memory_access_info + 0x3d) = 0x20;\n      *(undefined *)(memory_access_info + 0xf) = 0;\n      return 3;\n    }\n  }\n  *(undefined4 *)(*memory_access_info + 0x14) = 0xffffffef;\n  memory_access_info[0x10] = 0;\n  memory_access_info[0xc] = 0;\n  *(undefined *)((int)memory_access_info + 0x3d) = 0x20;\n  *(undefined *)(memory_access_info + 0xf) = 0;\n  return 1;\n}\n\n",
            "called": [
                "FUN_080015a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ca8",
            "calling": [
                "FUN_08001f6c"
            ],
            "imported": false,
            "current_name": "check_memory_access_08002ca8"
        },
        "FUN_08003a94": {
            "renaming": {
                "FUN_08003a94": "process_input_08003a94",
                "param_1": "input_data",
                "param_2": "input_commands",
                "uVar1": "result",
                "uVar2": "command",
                "param_2[1]": "command_param_1",
                "param_2[2]": "command_param_2",
                "param_2[3]": "command_param_3"
            },
            "code": "\nundefined4 process_input_08003a94(int *input_data,uint *input_commands)\n\n{\n  undefined4 result;\n  uint command;\n  \n  if (*(char *)(input_data + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(input_data + 0xf) = 1;\n    *(undefined *)((int)input_data + 0x3d) = 2;\n    *(uint *)(*input_data + 8) = *(uint *)(*input_data + 8) & 0xffff0088;\n    command = *input_commands;\n    if (command == 0x40) {\n      FUN_080040a0(*input_data,command_param_1,command_param_3);\n      FUN_0800416a(*input_data,0x40);\n    }\n    else if (command < 0x41) {\n      if (command == 0x10) {\n        FUN_0800416a(*input_data,0x10);\n      }\n      else if (command < 0x11) {\n        if (command == 0) {\n          FUN_0800416a(*input_data,0);\n        }\n      }\n      else if (command == 0x20) {\n        FUN_0800416a(*input_data,0x20);\n      }\n      else if (command == 0x30) {\n        FUN_0800416a(*input_data,0x30);\n      }\n    }\n    else if (command == 0x70) {\n      FUN_080041a8(*input_data,command_param_2,command_param_1,command_param_3);\n      *(uint *)(*input_data + 8) = *(uint *)(*input_data + 8) & 0xffffff88 | 0x77;\n    }\n    else if (command < 0x71) {\n      if (command == 0x50) {\n        FUN_080040a0(*input_data,command_param_1,command_param_3);\n        FUN_0800416a(*input_data,0x50);\n      }\n      else if (command == 0x60) {\n        FUN_08004104(*input_data,command_param_1,command_param_3);\n        FUN_0800416a(*input_data,0x60);\n      }\n    }\n    else if (command == 0x1000) {\n      *(uint *)(*input_data + 8) = *(uint *)(*input_data + 8) & 0xfffffff8;\n    }\n    else if (command == 0x2000) {\n      FUN_080041a8(*input_data,command_param_2,command_param_1,command_param_3);\n      *(uint *)(*input_data + 8) = *(uint *)(*input_data + 8) | 0x4000;\n    }\n    *(undefined *)((int)input_data + 0x3d) = 1;\n    *(undefined *)(input_data + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_0800416a",
                "FUN_080040a0",
                "FUN_08004104",
                "FUN_080041a8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a94",
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "imported": false,
            "current_name": "process_input_08003a94"
        },
        "FUN_0800416a": {
            "renaming": {
                "FUN_0800416a": "set_permissions_0800416a",
                "param_1": "file_descriptor",
                "param_2": "permission_bits",
                "uint": "unsigned_integer"
            },
            "code": "\nvoid set_permissions_0800416a(int file_descriptor,ushort permission_bits)\n\n{\n  *(unsigned_integer *)(file_descriptor + 8) = *(unsigned_integer *)(file_descriptor + 8) & 0xffffff8f | (unsigned_integer)(permission_bits | 7);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800416a",
            "calling": [
                "FUN_08003a94"
            ],
            "imported": false,
            "current_name": "set_permissions_0800416a"
        },
        "FUN_080055f4": {
            "renaming": {
                "FUN_080055f4": "set_flags_and_call_functions_080055f4",
                "local_18": "buffer_size",
                "local_14": "value_1",
                "local_c": "value_2"
            },
            "code": "\nvoid set_flags_and_call_functions_080055f4(void)\n\n{\n  undefined4 buffer_size;\n  undefined4 value_1;\n  undefined4 value_2;\n  \n  *(uint *)(DAT_0800566c + 0x18) = *(uint *)(DAT_0800566c + 0x18) | 0x20;\n  *(uint *)(DAT_0800566c + 0x18) = *(uint *)(DAT_0800566c + 0x18) | 4;\n  *(uint *)(DAT_0800566c + 0x18) = *(uint *)(DAT_0800566c + 0x18) | 8;\n  FUN_08001a80(DAT_08005670,0x1e,0,*(uint *)(DAT_0800566c + 0x18) & 8);\n  buffer_size = 0x1e;\n  value_1 = 1;\n  value_2 = 2;\n  FUN_080017c4(DAT_08005670,&buffer_size);\n  return;\n}\n\n",
            "called": [
                "FUN_08001a80",
                "FUN_080017c4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080055f4",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "set_flags_and_call_functions_080055f4"
        },
        "FUN_080059f0": {
            "renaming": {
                "FUN_080059f0": "calculate_hash_080059f0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "unused1",
                "param_4": "unused2",
                "uVar1": "hash_part1",
                "uVar2": "hash_part2",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "temp4",
                "uVar7": "input2_unsigned",
                "uVar9": "concatenated_input",
                "uVar10": "temp5",
                "uVar11": "result"
            },
            "code": "\nulonglong calculate_hash_080059f0(int input1,uint input2,undefined4 unused1,undefined4 unused2)\n\n{\n  undefined4 hash_part1;\n  undefined4 hash_part2;\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  undefined4 temp4;\n  uint input2_unsigned;\n  int iVar8;\n  undefined8 concatenated_input;\n  undefined8 temp5;\n  ulonglong result;\n  \n  concatenated_input = CONCAT44(input2,input1);\n  input2_unsigned = input2 & 0x7fffffff;\n  if (DAT_08005cd8 < (int)input2_unsigned) {\n    if ((input2_unsigned == DAT_08005cdc || (int)input2_unsigned < (int)DAT_08005cdc) &&\n       ((input2_unsigned != DAT_08005cdc || (input1 == 0)))) {\n      hash_part1 = DAT_08005ce4;\n      if (0 < (int)input2) {\n        hash_part1 = DAT_08005ce0;\n      }\n      return CONCAT44(hash_part1,DAT_08005ce8);\n    }\n    result = FUN_0800015c(input1,input2,input1,input2,unused2);\n  }\n  else {\n    if (DAT_08005cec < (int)input2_unsigned) {\n      concatenated_input = FUNC_08005d0c();\n      temp2 = (undefined4)((ulonglong)concatenated_input >> 0x20);\n      hash_part1 = (undefined4)concatenated_input;\n      if (DAT_08005cfc < (int)input2_unsigned) {\n        if (DAT_08005d00 < (int)input2_unsigned) {\n          concatenated_input = FUN_0800071c(0,DAT_08005d08,hash_part1,temp2);\n          iVar8 = 3;\n        }\n        else {\n          concatenated_input = FUN_08000158(hash_part1,temp2,0,DAT_08005d04);\n          temp5 = FUN_080004c8(hash_part1,temp2,0,DAT_08005d04);\n          temp5 = FUN_0800015c((int)temp5,(int)((ulonglong)temp5 >> 0x20),0,DAT_08005cf8);\n          concatenated_input = FUN_0800071c((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),(int)temp5,\n                               (int)((ulonglong)temp5 >> 0x20));\n          iVar8 = 2;\n        }\n      }\n      else if (DAT_08005cfc + -0xd0000 < (int)input2_unsigned) {\n        concatenated_input = FUN_08000158(hash_part1,temp2,0,DAT_08005cf8);\n        temp5 = FUN_0800015c(hash_part1,temp2,0,DAT_08005cf8);\n        concatenated_input = FUN_0800071c((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),(int)temp5,\n                             (int)((ulonglong)temp5 >> 0x20));\n        iVar8 = 1;\n      }\n      else {\n        concatenated_input = FUN_0800015c(hash_part1,temp2,hash_part1,temp2);\n        concatenated_input = FUN_08000158((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),0,DAT_08005cf8);\n        temp5 = FUN_0800015c(hash_part1,temp2,0,0x40000000);\n        concatenated_input = FUN_0800071c((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),(int)temp5,\n                             (int)((ulonglong)temp5 >> 0x20));\n        iVar8 = 0;\n      }\n    }\n    else {\n      if ((int)input2_unsigned <= DAT_08005cec + -0x1bc0000) {\n        temp5 = FUN_0800015c(input1,input2,DAT_08005cd0,DAT_08005cd4,unused2);\n        iVar8 = FUN_080009e8((int)temp5,(int)((ulonglong)temp5 >> 0x20),0,DAT_08005cf8);\n        if (iVar8 != 0) {\n          return CONCAT44(input2,input1);\n        }\n      }\n      iVar8 = -1;\n    }\n    temp4 = (undefined4)((ulonglong)concatenated_input >> 0x20);\n    temp3 = (undefined4)concatenated_input;\n    concatenated_input = FUN_080004c8(temp3,temp4,temp3,temp4);\n    hash_part2 = (undefined4)((ulonglong)concatenated_input >> 0x20);\n    hash_part1 = (undefined4)concatenated_input;\n    concatenated_input = FUN_080004c8(hash_part1,hash_part2,hash_part1,hash_part2);\n    temp1 = (undefined4)((ulonglong)concatenated_input >> 0x20);\n    temp2 = (undefined4)concatenated_input;\n    concatenated_input = FUN_080004c8(temp2,temp1,DAT_08005c78,DAT_08005c7c);\n    concatenated_input = FUN_0800015c((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),DAT_08005c80,DAT_08005c84);\n    concatenated_input = FUN_080004c8((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),temp2,temp1);\n    concatenated_input = FUN_0800015c((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),DAT_08005c88,DAT_08005c8c);\n    concatenated_input = FUN_080004c8((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),temp2,temp1);\n    concatenated_input = FUN_0800015c((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),DAT_08005c90,DAT_08005c94);\n    concatenated_input = FUN_080004c8((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),temp2,temp1);\n    concatenated_input = FUN_0800015c((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),DAT_08005c98,DAT_08005c9c);\n    concatenated_input = FUN_080004c8((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),temp2,temp1);\n    concatenated_input = FUN_0800015c((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),DAT_08005ca0,DAT_08005ca4);\n    concatenated_input = FUN_080004c8((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),hash_part1,hash_part2);\n    temp5 = FUN_080004c8(temp2,temp1,DAT_08005ca8,DAT_08005cac);\n    temp5 = FUN_08000158((int)temp5,(int)((ulonglong)temp5 >> 0x20),DAT_08005cb0,DAT_08005cb4);\n    temp5 = FUN_080004c8((int)temp5,(int)((ulonglong)temp5 >> 0x20),temp2,temp1);\n    temp5 = FUN_08000158((int)temp5,(int)((ulonglong)temp5 >> 0x20),DAT_08005cb8,DAT_08005cbc);\n    temp5 = FUN_080004c8((int)temp5,(int)((ulonglong)temp5 >> 0x20),temp2,temp1);\n    temp5 = FUN_08000158((int)temp5,(int)((ulonglong)temp5 >> 0x20),DAT_08005cc0,DAT_08005cc4);\n    temp5 = FUN_080004c8((int)temp5,(int)((ulonglong)temp5 >> 0x20),temp2,temp1);\n    temp5 = FUN_08000158((int)temp5,(int)((ulonglong)temp5 >> 0x20),DAT_08005cc8,DAT_08005ccc);\n    temp5 = FUN_080004c8((int)temp5,(int)((ulonglong)temp5 >> 0x20),temp2,temp1);\n    concatenated_input = FUN_0800015c((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),(int)temp5,\n                         (int)((ulonglong)temp5 >> 0x20));\n    concatenated_input = FUN_080004c8((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),temp3,temp4);\n    hash_part1 = (undefined4)((ulonglong)concatenated_input >> 0x20);\n    if (iVar8 == -1) {\n      result = FUN_08000158(temp3,temp4,(int)concatenated_input,hash_part1);\n      return result;\n    }\n    concatenated_input = FUN_08000158((int)concatenated_input,hash_part1,*(undefined4 *)(PTR_DAT_08005cf0 + iVar8 * 8),\n                         *(undefined4 *)((int)(PTR_DAT_08005cf0 + iVar8 * 8) + 4));\n    concatenated_input = FUN_08000158((int)concatenated_input,(int)((ulonglong)concatenated_input >> 0x20),temp3,temp4);\n    result = FUN_08000158(*(undefined4 *)(PTR_DAT_08005cf4 + iVar8 * 8),\n                          *(undefined4 *)((int)(PTR_DAT_08005cf4 + iVar8 * 8) + 4),(int)concatenated_input,\n                          (int)((ulonglong)concatenated_input >> 0x20));\n    if ((int)input2 < 0) {\n      return result & 0xffffffff | (ulonglong)((int)(result >> 0x20) + 0x80000000) << 0x20;\n    }\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_08005d0c",
                "FUN_0800015c",
                "FUN_08000158",
                "FUN_080004c8",
                "FUN_0800071c",
                "FUN_080009e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080059f0",
            "calling": [
                "FUN_08005838"
            ],
            "imported": false,
            "current_name": "calculate_hash_080059f0"
        },
        "FUN_080053b0": {
            "renaming": {
                "FUN_080053b0": "initialize_and_configure_device_080053b0",
                "local_58": "config_value_1",
                "local_54": "config_value_2",
                "local_50": "config_value_3",
                "local_4c": "config_value_4",
                "local_48": "config_value_5",
                "local_44": "config_value_6",
                "local_40": "config_value_7",
                "local_3c": "config_value_8",
                "local_38": "config_value_9",
                "local_34": "config_value_10",
                "local_30": "config_value_11",
                "local_2c": "config_value_12",
                "local_28": "config_value_13",
                "local_24": "config_value_14",
                "local_20": "config_value_15",
                "local_1c": "config_value_16",
                "local_18": "config_values_array"
            },
            "code": "\nvoid initialize_and_configure_device_080053b0(void)\n\n{\n  int iVar1;\n  undefined4 config_value_1;\n  undefined4 config_value_2;\n  undefined4 config_value_3;\n  undefined4 config_value_4;\n  undefined4 config_value_5;\n  undefined4 config_value_6;\n  undefined4 config_value_7;\n  undefined4 config_value_8;\n  undefined4 config_value_9;\n  undefined4 config_value_10;\n  undefined4 config_value_11;\n  undefined4 config_value_12;\n  undefined4 config_value_13;\n  undefined4 config_value_14;\n  undefined4 config_value_15;\n  undefined4 config_value_16;\n  undefined4 config_values_array [4];\n  \n  *(undefined4 *)PTR_DAT_080054f4 = DAT_080054f8;\n  *(undefined4 *)(PTR_DAT_080054f4 + 4) = 0x708;\n  *(undefined4 *)(PTR_DAT_080054f4 + 8) = 0;\n  *(undefined4 *)(PTR_DAT_080054f4 + 0xc) = 100;\n  *(undefined4 *)(PTR_DAT_080054f4 + 0x10) = 0;\n  *(undefined4 *)(PTR_DAT_080054f4 + 0x14) = 0;\n  *(undefined4 *)(PTR_DAT_080054f4 + 0x18) = 0;\n  iVar1 = FUN_080035a4(PTR_DAT_080054f4);\n  if (iVar1 != 0) {\n    FUN_08005674(PTR_s____src_main_c_080054fc,399);\n  }\n  config_values_array[0] = 0x1000;\n  iVar1 = FUN_08003a94(PTR_DAT_080054f4,config_values_array);\n  if (iVar1 != 0) {\n    FUN_08005674(PTR_s____src_main_c_080054fc,0x194);\n  }\n  iVar1 = FUN_08003640(PTR_DAT_080054f4);\n  if (iVar1 != 0) {\n    FUN_08005674(PTR_s____src_main_c_080054fc,0x198);\n  }\n  config_value_15 = 0;\n  config_value_16 = 0;\n  iVar1 = FUN_080042de(PTR_DAT_080054f4,&config_value_15);\n  if (iVar1 != 0) {\n    FUN_08005674(PTR_s____src_main_c_080054fc,0x19f);\n  }\n  config_value_8 = 0x60;\n  config_value_9 = 0;\n  config_value_10 = 0;\n  config_value_11 = 0;\n  config_value_12 = 0;\n  config_value_13 = 0;\n  config_value_14 = 0;\n  iVar1 = FUN_08003908(PTR_DAT_080054f4,&config_value_8,0);\n  if (iVar1 != 0) {\n    FUN_08005674(PTR_s____src_main_c_080054fc,0x1ab);\n  }\n  iVar1 = FUN_08003908(PTR_DAT_080054f4,&config_value_8,0xc);\n  if (iVar1 != 0) {\n    FUN_08005674(PTR_s____src_main_c_080054fc,0x1b0);\n  }\n  config_value_1 = 0;\n  config_value_2 = 0;\n  config_value_3 = 0;\n  config_value_4 = 0;\n  config_value_5 = 0;\n  config_value_6 = 0x2000;\n  config_value_7 = 0;\n  iVar1 = FUN_0800422e(PTR_DAT_080054f4,&config_value_1);\n  if (iVar1 != 0) {\n    FUN_08005674(PTR_s____src_main_c_080054fc,0x1bc);\n  }\n  FUN_08005680(PTR_DAT_080054f4);\n  return;\n}\n\n",
            "called": [
                "FUN_08003640",
                "FUN_08003a94",
                "FUN_080042de",
                "FUN_08005674",
                "FUN_0800422e",
                "FUN_08005680",
                "FUN_080035a4",
                "FUN_08003908"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053b0",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "initialize_and_configure_device_080053b0"
        },
        "FUN_08009e74": {
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08009e74",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_08009e74"
        },
        "FUN_0800088a": {
            "renaming": {
                "FUN_0800088a": "binary_to_double_0800088a",
                "param_1": "binary_high",
                "param_2": "binary_low",
                "param_3": "exponent_high",
                "param_4": "exponent_low",
                "uVar1": "bit",
                "unaff_r4": "mask",
                "uVar2": "shifted_mask",
                "uVar3": "result",
                "in_r12": "constant",
                "bVar4": "is_zero"
            },
            "code": "\nulonglong binary_to_double_0800088a(uint binary_high,uint binary_low,uint exponent_high,uint exponent_low)\n\n{\n  uint bit;\n  uint mask;\n  uint shifted_mask;\n  uint result;\n  uint constant;\n  bool is_zero;\n  \n  shifted_mask = constant & exponent_low >> 0x14;\n  result = binary_low;\n  if (mask != constant || shifted_mask != constant) {\n    if (mask == constant) {\n      if (((binary_high | binary_low << 0xc) == 0) && (binary_high = exponent_high, result = exponent_low, shifted_mask != constant)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((binary_low ^ exponent_low) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (shifted_mask == constant) {\n      binary_high = exponent_high;\n      result = exponent_low;\n      if ((exponent_high | exponent_low << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((binary_low ^ exponent_low) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      is_zero = (binary_high | binary_low << 1) == 0;\n      if (!is_zero) {\n        is_zero = (exponent_high | exponent_low << 1) == 0;\n      }\n      if (!is_zero) {\n        if (mask == 0) {\n          result = binary_low & 0x80000000;\n          do {\n            bit = binary_high & 0x80000000;\n            binary_high = binary_high << 1;\n            binary_low = binary_low * 2 + (uint)(bit != 0);\n          } while ((binary_low & 0x100000) == 0);\n          binary_low = binary_low | result;\n          if (shifted_mask != 0) {\n            return CONCAT44(binary_low,binary_high);\n          }\n        }\n        do {\n          result = exponent_high & 0x80000000;\n          exponent_high = exponent_high << 1;\n          exponent_low = exponent_low * 2 + (uint)(result != 0);\n        } while ((exponent_low & 0x100000) == 0);\n        return CONCAT44(binary_low,binary_high);\n      }\n      if ((binary_high | binary_low << 1) != 0) goto LAB_080006fc;\n      if ((exponent_high | exponent_low << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(result,binary_high) | 0x7ff8000000000000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800088a",
            "calling": [
                "FUN_0800071c"
            ],
            "imported": false,
            "current_name": "binary_to_double_0800088a"
        },
        "FUN_080016d0": {
            "renaming": {
                "FUN_080016d0": "check_param_and_set_values_080016d0",
                "param_1": "input_param",
                "bVar1": "is_valid_input"
            },
            "code": "\nbool check_param_and_set_values_080016d0(int input_param)\n\n{\n  bool is_valid_input;\n  \n  is_valid_input = input_param - 1U < 0x1000000;\n  if (is_valid_input) {\n    DAT_08001710[1] = input_param + -1;\n    FUN_08001618(0xffffffff,0xf);\n    DAT_08001710[2] = 0;\n    *DAT_08001710 = 7;\n  }\n  return !is_valid_input;\n}\n\n",
            "called": [
                "FUN_08001618"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080016d0",
            "calling": [
                "FUN_08001762"
            ],
            "imported": false,
            "current_name": "check_param_and_set_values_080016d0"
        },
        "FUN_08001ccc": {
            "renaming": {
                "FUN_08001ccc": "parse_input_08001ccc",
                "param_1": "input_data",
                "uVar1": "data_mask",
                "iVar2": "start_time",
                "cVar3": "result",
                "uVar4": "temp_mask",
                "iVar5": "loop_index",
                "uVar6": "return_val",
                "puVar7": "data_ptr",
                "bVar8": "is_zero"
            },
            "code": "\nundefined4\nparse_input_08001ccc(uint **input_data,undefined2 param_2,undefined2 param_3,undefined2 param_4,uint *param_5,\n            undefined2 param_6,undefined4 param_7)\n\n{\n  uint data_mask;\n  int start_time;\n  char result;\n  uint temp_mask;\n  int loop_index;\n  undefined4 return_val;\n  uint *data_ptr;\n  bool is_zero;\n  \n  start_time = FUN_080015a0();\n  data_mask = DAT_08001f64;\n  if (*(char *)((int)input_data + 0x3d) == ' ') {\n    do {\n      if ((data_mask >> 0x10 & 0xff) == 1) {\n        temp_mask = data_mask & ~(*input_data)[5] & 0xffff;\n        is_zero = temp_mask == 0;\n        if (is_zero) {\n          temp_mask = 1;\n        }\n        result = (char)temp_mask;\n        if (!is_zero) {\n          result = '\\0';\n        }\n      }\n      else {\n        temp_mask = data_mask & ~(*input_data)[6] & 0xffff;\n        is_zero = temp_mask == 0;\n        if (is_zero) {\n          temp_mask = 1;\n        }\n        result = (char)temp_mask;\n        if (!is_zero) {\n          result = '\\0';\n        }\n      }\n      if (result != '\\x01') {\n        loop_index = 0;\n        goto LAB_08001d9c;\n      }\n      loop_index = FUN_080015a0();\n    } while ((uint)(loop_index - start_time) < 0x1a);\n    input_data[0xc] = (uint *)0x0;\n    *(undefined *)((int)input_data + 0x3d) = 0x20;\n    *(undefined *)((int)input_data + 0x3e) = 0;\n    *(undefined *)(input_data + 0xf) = 0;\n    loop_index = 3;\nLAB_08001d9c:\n    if (loop_index == 0) {\n      if (*(char *)(input_data + 0xf) == '\\x01') {\n        return_val = 2;\n      }\n      else {\n        *(undefined *)(input_data + 0xf) = 1;\n        if ((**input_data & 1) != 1) {\n          **input_data = **input_data | 1;\n        }\n        **input_data = **input_data & 0xfffff7ff;\n        *(undefined *)((int)input_data + 0x3d) = 0x21;\n        *(undefined *)((int)input_data + 0x3e) = 0x40;\n        input_data[0x10] = (uint *)0x0;\n        input_data[9] = param_5;\n        *(undefined2 *)((int)input_data + 0x2a) = param_6;\n        input_data[0xb] = DAT_08001f68;\n        *(undefined2 *)(input_data + 10) = *(undefined2 *)((int)input_data + 0x2a);\n        loop_index = FUN_08002640(input_data,param_2,param_3,param_4,param_7,start_time);\n        if (loop_index == 0) {\n          while (*(short *)(input_data + 10) != 0) {\n            loop_index = FUN_08002bb4(input_data,param_7,start_time);\n            if (loop_index != 0) {\n              if (input_data[0x10] == (uint *)0x4) {\n                **input_data = **input_data | 0x200;\n                return 1;\n              }\n              return 3;\n            }\n            data_ptr = input_data[9];\n            input_data[9] = (uint *)((int)data_ptr + 1);\n            (*input_data)[4] = (uint)*(byte *)data_ptr;\n            *(short *)(input_data + 10) = *(short *)(input_data + 10) + -1;\n            *(short *)((int)input_data + 0x2a) = *(short *)((int)input_data + 0x2a) + -1;\n            if ((((*input_data)[5] & 4) == 4) && (*(short *)(input_data + 10) != 0)) {\n              data_ptr = input_data[9];\n              input_data[9] = (uint *)((int)data_ptr + 1);\n              (*input_data)[4] = (uint)*(byte *)data_ptr;\n              *(short *)(input_data + 10) = *(short *)(input_data + 10) + -1;\n              *(short *)((int)input_data + 0x2a) = *(short *)((int)input_data + 0x2a) + -1;\n            }\n          }\n          start_time = FUN_08002c2e(input_data,param_7,start_time);\n          if (start_time == 0) {\n            **input_data = **input_data | 0x200;\n            *(undefined *)((int)input_data + 0x3d) = 0x20;\n            *(undefined *)((int)input_data + 0x3e) = 0;\n            *(undefined *)(input_data + 0xf) = 0;\n            return_val = 0;\n          }\n          else if (input_data[0x10] == (uint *)0x4) {\n            **input_data = **input_data | 0x200;\n            return_val = 1;\n          }\n          else {\n            return_val = 3;\n          }\n        }\n        else if (input_data[0x10] == (uint *)0x4) {\n          *(undefined *)(input_data + 0xf) = 0;\n          return_val = 1;\n        }\n        else {\n          *(undefined *)(input_data + 0xf) = 0;\n          return_val = 3;\n        }\n      }\n    }\n    else {\n      return_val = 2;\n    }\n  }\n  else {\n    return_val = 2;\n  }\n  return return_val;\n}\n\n",
            "called": [
                "FUN_08002640",
                "FUN_08002c2e",
                "FUN_080015a0",
                "FUN_08002bb4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001ccc",
            "calling": [
                "FUN_08004ea4"
            ],
            "imported": false,
            "current_name": "parse_input_08001ccc"
        },
        "FUN_0800157c": {
            "renaming": {
                "FUN_0800157c": "add_byte_to_uint_0800157c"
            },
            "code": "\nvoid add_byte_to_uint_0800157c(void)\n\n{\n  *(uint *)PTR_DAT_0800159c = *(int *)PTR_DAT_0800159c + (uint)(byte)*PTR_DAT_08001598;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800157c",
            "calling": [
                "FUN_08005704"
            ],
            "imported": false,
            "current_name": "add_byte_to_uint_0800157c"
        },
        "FUN_08000e20": {
            "renaming": {
                "FUN_08000e20": "floating_point_operation_08000e20",
                "param_1": "float_a",
                "param_2": "float_b",
                "param_3": "precision",
                "param_4": "rounding_mode",
                "uVar1": "shifted_b",
                "uVar2": "shifted_a",
                "iVar3": "shift_distance",
                "uVar4": "shifted_distance",
                "iVar5": "shift_distance_plus_127",
                "uVar6": "result",
                "bVar7": "flag",
                "bVar8": "flag2",
                "bVar9": "overflow_flag"
            },
            "code": "\nuint floating_point_operation_08000e20(uint float_a,uint float_b,undefined4 precision,uint rounding_mode)\n\n{\n  uint shifted_b;\n  uint shifted_a;\n  int shift_distance;\n  uint shifted_distance;\n  int shift_distance_plus_127;\n  uint result;\n  bool flag;\n  bool flag2;\n  bool overflow_flag;\n  \n  shifted_a = float_a >> 0x17 & 0xff;\n  flag = shifted_a == 0;\n  if (!flag) {\n    rounding_mode = float_b >> 0x17 & 0xff;\n    flag = rounding_mode == 0;\n  }\n  if (!flag) {\n    flag = shifted_a == 0xff;\n  }\n  if (!flag) {\n    flag = rounding_mode == 0xff;\n  }\n  if (flag) {\n    rounding_mode = float_b >> 0x17 & 0xff;\n    result = float_a;\n    if (shifted_a == 0xff) {\n      if (((float_a & 0x7fffff) != 0) || (result = float_b, rounding_mode == 0xff)) {\nLAB_08000e16:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (rounding_mode == 0xff) {\n        result = float_b;\n        if ((float_b & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (float_a ^ float_b) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      flag = (float_a & 0x7fffffff) == 0;\n      if (!flag) {\n        flag = (float_b & 0x7fffffff) == 0;\n      }\n      if (!flag) {\n        flag = shifted_a == 0;\n        result = float_a & 0x80000000;\n        while( true ) {\n          if (flag) {\n            float_a = float_a << 1;\n            flag = (float_a & 0x800000) == 0;\n          }\n          if (!flag) break;\n          shifted_a = shifted_a - 1;\n        }\n        float_a = float_a | result;\n        flag = rounding_mode == 0;\n        result = float_b & 0x80000000;\n        while( true ) {\n          if (flag) {\n            float_b = float_b << 1;\n            flag = (float_b & 0x800000) == 0;\n          }\n          if (!flag) break;\n          rounding_mode = rounding_mode - 1;\n        }\n        float_b = float_b | result;\n        goto LAB_08000e38;\n      }\n      if ((float_a & 0x7fffffff) == 0) {\n        if ((float_b & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    float_a = float_a ^ float_b;\n  }\n  else {\nLAB_08000e38:\n    shift_distance = shifted_a - rounding_mode;\n    if (float_b << 9 == 0) {\n      float_a = (float_a ^ float_b) & 0x80000000 | float_a & 0x7fffff;\n      overflow_flag = SCARRY4(shift_distance,0x7f);\n      shift_distance_plus_127 = shift_distance + 0x7f;\n      flag = shift_distance_plus_127 < 0;\n      flag2 = shift_distance_plus_127 == 0;\n      if (!flag2 && flag == overflow_flag) {\n        overflow_flag = SBORROW4(0xff,shift_distance_plus_127);\n        flag = 0xff - shift_distance_plus_127 < 0;\n        flag2 = shift_distance_plus_127 == 0xff;\n      }\n      if (!flag2 && flag == overflow_flag) {\n        float_a = float_a | shift_distance_plus_127 * 0x800000;\n      }\n      if (!flag2 && flag == overflow_flag) {\n        return float_a;\n      }\n      float_a = float_a | 0x800000;\n      shifted_a = 0;\n      flag2 = SBORROW4(shift_distance_plus_127,1);\n      shifted_distance = shift_distance + 0x7e;\n      flag = shifted_distance == 0;\n      result = shifted_distance;\n    }\n    else {\n      shifted_b = (float_b << 9) >> 4 | 0x10000000;\n      shifted_a = (float_a << 9) >> 4 | 0x10000000;\n      float_a = (float_a ^ float_b) & 0x80000000;\n      flag = shifted_b <= shifted_a;\n      if (!flag) {\n        shifted_a = shifted_a << 1;\n      }\n      shifted_distance = shift_distance + 0x7d + (uint)flag;\n      result = 0x800000;\n      do {\n        if (shifted_b <= shifted_a) {\n          shifted_a = shifted_a - shifted_b;\n          float_a = float_a | result;\n        }\n        flag = shifted_b >> 1 <= shifted_a;\n        if (flag) {\n          shifted_a = shifted_a - (shifted_b >> 1);\n        }\n        if (flag) {\n          float_a = float_a | result >> 1;\n        }\n        flag = shifted_b >> 2 <= shifted_a;\n        if (flag) {\n          shifted_a = shifted_a - (shifted_b >> 2);\n        }\n        if (flag) {\n          float_a = float_a | result >> 2;\n        }\n        flag = shifted_b >> 3 <= shifted_a;\n        if (flag) {\n          shifted_a = shifted_a - (shifted_b >> 3);\n        }\n        if (flag) {\n          float_a = float_a | result >> 3;\n        }\n        shifted_a = shifted_a * 0x10;\n        flag = shifted_a == 0;\n        if (!flag) {\n          result = result >> 4;\n          flag = result == 0;\n        }\n      } while (!flag);\n      flag2 = SBORROW4(shifted_distance,0xfd);\n      flag = shifted_distance == 0xfd;\n      result = shifted_distance - 0xfd;\n      if (shifted_distance < 0xfe) {\n        float_a = float_a + shifted_distance * 0x800000 + (uint)(shifted_b <= shifted_a);\n        if (shifted_a - shifted_b == 0) {\n          float_a = float_a & 0xfffffffe;\n        }\n        return float_a;\n      }\n    }\n    if (flag || (int)result < 0 != flag2) {\n      flag = (int)(shifted_distance + 0x19) < 0;\n      if (shifted_distance == 0xffffffe7 || flag != SCARRY4(shifted_distance,0x19)) {\n        float_a = float_a & 0x80000000;\n      }\n      if (shifted_distance == 0xffffffe7 || flag != SCARRY4(shifted_distance,0x19)) {\n        return float_a;\n      }\n      result = (float_a << 1) >> (-shifted_distance & 0xff);\n      shifted_distance = float_a << (shifted_distance + 0x20 & 0xff);\n      result = ((uint)((float_a & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((shifted_a | shifted_distance << 1) == 0) {\n        result = result & ~(shifted_distance >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return float_a & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000e20",
            "calling": [
                "FUN_08004d78",
                "FUN_080049cc"
            ],
            "imported": false,
            "current_name": "floating_point_operation_08000e20"
        },
        "FUN_0800121c": {
            "renaming": {
                "FUN_0800121c": "calculate_division_0800121c",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "param_5": "result",
                "uVar1": "temp",
                "uVar2": "quotient1",
                "uVar4": "quotient2",
                "uVar5": "remainder1",
                "uVar6": "shift",
                "uVar7": "temp1",
                "uVar8": "temp2",
                "uVar11": "quotient3",
                "uVar12": "divisor1",
                "uVar13": "remainder2",
                "bVar14": "carry",
                "uVar15": "returnValue",
                "puVar3": "result1",
                "puVar9": "result2",
                "puVar10": "leadingZeroes"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 calculate_division_0800121c(uint dividend,uint divisor,uint quotient,uint remainder,uint *result)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  ulonglong temp;\n  uint quotient1;\n  uint *result1;\n  uint quotient2;\n  uint remainder1;\n  uint shift;\n  uint temp1;\n  uint temp2;\n  uint *result2;\n  uint *leadingZeroes;\n  uint quotient3;\n  uint divisor1;\n  uint remainder2;\n  bool carry;\n  undefined8 returnValue;\n  \n  if (remainder == 0) {\n    if (divisor < quotient) {\n      shift = count_leading_zeroes(quotient);\n      if (shift != 0) {\n        quotient = quotient << (shift & 0xff);\n        divisor = dividend >> (0x20 - shift & 0xff) | divisor << (shift & 0xff);\n        dividend = dividend << (shift & 0xff);\n      }\n      divisor1 = quotient >> 0x10;\n      temp2 = divisor / divisor1;\n      quotient3 = temp2 * (quotient & 0xffff);\n      temp1 = dividend >> 0x10 | (divisor - divisor1 * temp2) * 0x10000;\n      quotient2 = temp2;\n      if (temp1 <= quotient3 && quotient3 - temp1 != 0) {\n        carry = CARRY4(quotient,temp1);\n        temp1 = quotient + temp1;\n        quotient2 = temp2 - 1;\n        if ((carry == false) && (temp1 <= quotient3 && quotient3 - temp1 != 0)) {\n          quotient2 = temp2 - 2;\n          temp1 = temp1 + quotient;\n        }\n      }\n      quotient1 = (temp1 - quotient3) / divisor1;\n      remainder1 = quotient1 * (quotient & 0xffff);\n      temp2 = dividend & 0xffff | ((temp1 - quotient3) - divisor1 * quotient1) * 0x10000;\n      temp1 = quotient1;\n      if (temp2 <= remainder1 && remainder1 - temp2 != 0) {\n        carry = CARRY4(quotient,temp2);\n        temp2 = quotient + temp2;\n        temp1 = quotient1 - 1;\n        if ((carry == false) && (temp2 <= remainder1 && remainder1 - temp2 != 0)) {\n          temp1 = quotient1 - 2;\n          temp2 = temp2 + quotient;\n        }\n      }\n      result1 = (uint *)(temp1 | quotient2 << 0x10);\n      result2 = (uint *)0x0;\n      temp2 = temp2 - remainder1;\n    }\n    else {\n      if (quotient == 0) {\n                    /* WARNING: Could not recover jumptable at 0x08001302. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x8001302);\n        returnValue = (*UNRECOVERED_JUMPTABLE)();\n        return returnValue;\n      }\n      shift = count_leading_zeroes(quotient);\n      if (shift == 0) {\n        result2 = (uint *)0x1;\n        divisor = divisor - quotient;\n        divisor1 = quotient >> 0x10;\n        quotient1 = quotient & 0xffff;\n      }\n      else {\n        quotient = quotient << (shift & 0xff);\n        quotient2 = divisor >> (0x20 - shift & 0xff);\n        divisor1 = quotient >> 0x10;\n        quotient3 = quotient2 / divisor1;\n        quotient1 = quotient & 0xffff;\n        remainder1 = quotient3 * quotient1;\n        temp2 = dividend >> (0x20 - shift & 0xff) | divisor << (shift & 0xff);\n        temp1 = temp2 >> 0x10 | (quotient2 - divisor1 * quotient3) * 0x10000;\n        dividend = dividend << (shift & 0xff);\n        quotient2 = quotient3;\n        if (temp1 <= remainder1 && remainder1 - temp1 != 0) {\n          carry = CARRY4(quotient,temp1);\n          temp1 = quotient + temp1;\n          quotient2 = quotient3 - 1;\n          if ((carry == false) && (temp1 <= remainder1 && remainder1 - temp1 != 0)) {\n            quotient2 = quotient3 - 2;\n            temp1 = temp1 + quotient;\n          }\n        }\n        quotient3 = (temp1 - remainder1) / divisor1;\n        remainder2 = quotient3 * quotient1;\n        divisor = temp2 & 0xffff | ((temp1 - remainder1) - divisor1 * quotient3) * 0x10000;\n        temp1 = quotient3;\n        if (divisor <= remainder2 && remainder2 - divisor != 0) {\n          carry = CARRY4(quotient,divisor);\n          divisor = quotient + divisor;\n          temp1 = quotient3 - 1;\n          if ((carry == false) && (divisor <= remainder2 && remainder2 - divisor != 0)) {\n            temp1 = quotient3 - 2;\n            divisor = divisor + quotient;\n          }\n        }\n        divisor = divisor - remainder2;\n        result2 = (uint *)(temp1 | quotient2 << 0x10);\n      }\n      quotient3 = divisor / divisor1;\n      temp1 = quotient1 * quotient3;\n      temp2 = dividend >> 0x10 | (divisor - divisor1 * quotient3) * 0x10000;\n      quotient2 = quotient3;\n      if (temp2 <= temp1 && temp1 - temp2 != 0) {\n        carry = CARRY4(quotient,temp2);\n        temp2 = quotient + temp2;\n        quotient2 = quotient3 - 1;\n        if ((carry == false) && (temp2 <= temp1 && temp1 - temp2 != 0)) {\n          quotient2 = quotient3 - 2;\n          temp2 = temp2 + quotient;\n        }\n      }\n      quotient3 = (temp2 - temp1) / divisor1;\n      quotient1 = quotient1 * quotient3;\n      temp2 = dividend & 0xffff | ((temp2 - temp1) - divisor1 * quotient3) * 0x10000;\n      temp1 = quotient3;\n      if (temp2 <= quotient1 && quotient1 - temp2 != 0) {\n        carry = CARRY4(quotient,temp2);\n        temp2 = quotient + temp2;\n        temp1 = quotient3 - 1;\n        if ((carry == false) && (temp2 <= quotient1 && quotient1 - temp2 != 0)) {\n          temp1 = quotient3 - 2;\n          temp2 = temp2 + quotient;\n        }\n      }\n      temp2 = temp2 - quotient1;\n      result1 = (uint *)(temp1 | quotient2 << 0x10);\n    }\n    if (result != (uint *)0x0) {\n      *result = temp2 >> (shift & 0xff);\n      result[1] = 0;\n    }\n  }\n  else {\n    result2 = result;\n    if (divisor < remainder) {\n      result1 = result;\n      if (result != (uint *)0x0) {\n        *result = dividend;\n        result[1] = divisor;\n        return 0;\n      }\n    }\n    else {\n      leadingZeroes = (uint *)count_leading_zeroes(remainder);\n      if (leadingZeroes == (uint *)0x0) {\n        if ((remainder < divisor) || (result1 = leadingZeroes, quotient <= dividend)) {\n          carry = dividend < quotient;\n          dividend = dividend - quotient;\n          divisor = (divisor - remainder) - (uint)carry;\n          result1 = (uint *)0x1;\n        }\n        result2 = leadingZeroes;\n        if (result != (uint *)0x0) {\n          *result = dividend;\n          result[1] = divisor;\n        }\n      }\n      else {\n        temp2 = 0x20 - (int)leadingZeroes;\n        quotient1 = quotient >> (temp2 & 0xff) | remainder << ((uint)leadingZeroes & 0xff);\n        shift = divisor >> (temp2 & 0xff);\n        remainder1 = quotient1 >> 0x10;\n        quotient3 = shift / remainder1;\n        divisor1 = quotient3 * (quotient1 & 0xffff);\n        quotient2 = divisor << ((uint)leadingZeroes & 0xff) | dividend >> (temp2 & 0xff);\n        temp1 = quotient2 >> 0x10 | (shift - remainder1 * quotient3) * 0x10000;\n        quotient = quotient << ((uint)leadingZeroes & 0xff);\n        dividend = dividend << ((uint)leadingZeroes & 0xff);\n        shift = quotient3;\n        if (temp1 <= divisor1 && divisor1 - temp1 != 0) {\n          carry = CARRY4(quotient1,temp1);\n          temp1 = quotient1 + temp1;\n          shift = quotient3 - 1;\n          if ((carry == false) && (temp1 <= divisor1 && divisor1 - temp1 != 0)) {\n            shift = quotient3 - 2;\n            temp1 = temp1 + quotient1;\n          }\n        }\n        quotient3 = (temp1 - divisor1) / remainder1;\n        remainder2 = quotient3 * (quotient1 & 0xffff);\n        temp1 = quotient2 & 0xffff | ((temp1 - divisor1) - remainder1 * quotient3) * 0x10000;\n        quotient2 = quotient3;\n        if (temp1 <= remainder2 && remainder2 - temp1 != 0) {\n          carry = CARRY4(quotient1,temp1);\n          temp1 = quotient1 + temp1;\n          quotient2 = quotient3 - 1;\n          if ((carry == false) && (temp1 <= remainder2 && remainder2 - temp1 != 0)) {\n            quotient2 = quotient3 - 2;\n            temp1 = temp1 + quotient1;\n          }\n        }\n        result1 = (uint *)(quotient2 | shift << 0x10);\n        temp = ZEXT48(result1) * (ulonglong)quotient;\n        if (CONCAT44(temp1 - remainder2,dividend) < temp) {\n          result1 = (uint *)((int)result1 + -1);\n          temp = temp - CONCAT44(quotient1,quotient);\n        }\n        if (result != (uint *)0x0) {\n          shift = ((temp1 - remainder2) - (int)(temp >> 0x20)) - (uint)(dividend < (uint)temp);\n          *result = shift << (temp2 & 0xff) | dividend - (uint)temp >> ((uint)leadingZeroes & 0xff);\n          result[1] = shift >> ((uint)leadingZeroes & 0xff);\n          result2 = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(result2,result1);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800121c",
            "calling": [
                "FUN_080011ec"
            ],
            "imported": false,
            "current_name": "calculate_division_0800121c"
        },
        "FUN_08005d14": {
            "renaming": {
                "FUN_08005d14": "get_pointer_value_08005d14"
            },
            "code": "\nundefined4 get_pointer_value_08005d14(void)\n\n{\n  return *(undefined4 *)PTR_PTR_DAT_08005d1c;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d14",
            "calling": [
                "FUN_08005728"
            ],
            "imported": false,
            "current_name": "get_pointer_value_08005d14"
        },
        "FUN_080015b4": {
            "renaming": {
                "FUN_080015b4": "set_bits_in_address_080015b4",
                "param_1": "bit_field_value"
            },
            "code": "\nvoid set_bits_in_address_080015b4(uint bit_field_value)\n\n{\n  *(uint *)(DAT_080015f8 + 0xc) =\n       *(uint *)(DAT_080015f8 + 0xc) & 0xf8ff | (bit_field_value & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015b4",
            "calling": [
                "FUN_08001714"
            ],
            "imported": false,
            "current_name": "set_bits_in_address_080015b4"
        },
        "FUN_080036f8": {
            "renaming": {
                "FUN_080036f8": "process_data_080036f8",
                "param_1": "data_ptr"
            },
            "code": "\nvoid process_data_080036f8(int *data_ptr)\n\n{\n  if (((*(uint *)(*data_ptr + 0x10) & 2) == 2) && ((*(uint *)(*data_ptr + 0xc) & 2) == 2)) {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xfffffffd;\n    *(undefined *)(data_ptr + 7) = 1;\n    if ((*(uint *)(*data_ptr + 0x18) & 3) == 0) {\n      FUNC_08003c4a(data_ptr);\n      FUNC_08003c6e(data_ptr);\n    }\n    else {\n      FUNC_08003c5c(data_ptr);\n    }\n    *(undefined *)(data_ptr + 7) = 0;\n  }\n  if (((*(uint *)(*data_ptr + 0x10) & 4) == 4) && ((*(uint *)(*data_ptr + 0xc) & 4) == 4)) {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xfffffffb;\n    *(undefined *)(data_ptr + 7) = 2;\n    if ((*(uint *)(*data_ptr + 0x18) & 0x300) == 0) {\n      FUNC_08003c4a(data_ptr);\n      FUNC_08003c6e(data_ptr);\n    }\n    else {\n      FUNC_08003c5c(data_ptr);\n    }\n    *(undefined *)(data_ptr + 7) = 0;\n  }\n  if (((*(uint *)(*data_ptr + 0x10) & 8) == 8) && ((*(uint *)(*data_ptr + 0xc) & 8) == 8)) {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xfffffff7;\n    *(undefined *)(data_ptr + 7) = 4;\n    if ((*(uint *)(*data_ptr + 0x1c) & 3) == 0) {\n      FUNC_08003c4a(data_ptr);\n      FUNC_08003c6e(data_ptr);\n    }\n    else {\n      FUNC_08003c5c(data_ptr);\n    }\n    *(undefined *)(data_ptr + 7) = 0;\n  }\n  if (((*(uint *)(*data_ptr + 0x10) & 0x10) == 0x10) && ((*(uint *)(*data_ptr + 0xc) & 0x10) == 0x10))\n  {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xffffffef;\n    *(undefined *)(data_ptr + 7) = 8;\n    if ((*(uint *)(*data_ptr + 0x1c) & 0x300) == 0) {\n      FUNC_08003c4a(data_ptr);\n      FUNC_08003c6e(data_ptr);\n    }\n    else {\n      FUNC_08003c5c(data_ptr);\n    }\n    *(undefined *)(data_ptr + 7) = 0;\n  }\n  if (((*(uint *)(*data_ptr + 0x10) & 1) == 1) && ((*(uint *)(*data_ptr + 0xc) & 1) == 1)) {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xfffffffe;\n    FUN_08004f78(data_ptr);\n  }\n  if (((*(uint *)(*data_ptr + 0x10) & 0x80) == 0x80) && ((*(uint *)(*data_ptr + 0xc) & 0x80) == 0x80))\n  {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xffffff7f;\n    FUNC_08004378(data_ptr);\n  }\n  if (((*(uint *)(*data_ptr + 0x10) & 0x40) == 0x40) && ((*(uint *)(*data_ptr + 0xc) & 0x40) == 0x40))\n  {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xffffffbf;\n    FUNC_08003c80(data_ptr);\n  }\n  if (((*(uint *)(*data_ptr + 0x10) & 0x20) == 0x20) && ((*(uint *)(*data_ptr + 0xc) & 0x20) == 0x20))\n  {\n    *(undefined4 *)(*data_ptr + 0x10) = 0xffffffdf;\n    FUNC_08004366(data_ptr);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08003c6e",
                "FUN_08003c4a",
                "FUN_08004378",
                "FUN_08003c80",
                "FUN_08004f78",
                "FUN_08004366",
                "FUN_08003c5c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036f8",
            "calling": [
                "FUN_08005714"
            ],
            "imported": false,
            "current_name": "process_data_080036f8"
        },
        "FUN_080041a8": {
            "renaming": {
                "FUN_080041a8": "update_data_080041a8",
                "param_1": "data_address",
                "param_2": "value_1",
                "param_3": "value_2",
                "param_4": "value_3"
            },
            "code": "\nvoid update_data_080041a8(int data_address,uint value_1,uint value_2,int value_3)\n\n{\n  *(uint *)(data_address + 8) = value_1 | value_3 << 8 | value_2 | *(uint *)(data_address + 8) & 0xffff00ff;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041a8",
            "calling": [
                "FUN_08003a94"
            ],
            "imported": false,
            "current_name": "update_data_080041a8"
        },
        "FUN_080004c8": {
            "renaming": {
                "FUN_080004c8": "multiply_and_add_080004c8",
                "param_1": "x1",
                "param_2": "x2",
                "param_3": "y1",
                "param_4": "y2",
                "uVar1": "low_product",
                "lVar2": "high_product",
                "uVar3": "high_x",
                "uVar4": "high_y",
                "iVar5": "exponent_sum",
                "uVar6": "mantissa_difference",
                "unaff_r5": "unused",
                "uVar7": "mantissa",
                "uVar8": "low_product_temp",
                "bVar9": "is_zero",
                "bVar10": "overflowed",
                "bVar11": "underflowed",
                "uVar12": "product"
            },
            "code": "\nulonglong multiply_and_add_080004c8(undefined4 x1,uint x2,uint y1,uint y2)\n\n{\n  ulonglong low_product;\n  longlong high_product;\n  uint high_x;\n  uint high_y;\n  int exponent_sum;\n  uint mantissa_difference;\n  uint unused;\n  uint mantissa;\n  uint low_product_temp;\n  bool is_zero;\n  bool overflowed;\n  bool underflowed;\n  ulonglong product;\n  \n  product = CONCAT44(x2,x1);\n  mantissa = 0x7ff;\n  high_y = x2 >> 0x14 & 0x7ff;\n  is_zero = high_y == 0;\n  if (!is_zero) {\n    unused = y2 >> 0x14 & 0x7ff;\n    is_zero = unused == 0;\n  }\n  if (!is_zero) {\n    is_zero = high_y == 0x7ff;\n  }\n  if (!is_zero) {\n    is_zero = unused == 0x7ff;\n  }\n  if (is_zero) {\n    product = FUN_080006a4();\n  }\n  high_x = (uint)(product >> 0x20);\n  exponent_sum = high_y + unused;\n  high_y = high_x ^ y2;\n  high_x = high_x & ~(mantissa << 0x15);\n  y2 = y2 & ~(mantissa << 0x15);\n  is_zero = ((uint)product | high_x << 0xc) == 0;\n  if (!is_zero) {\n    is_zero = (y1 | y2 << 0xc) == 0;\n  }\n  high_x = high_x | 0x100000;\n  y2 = y2 | 0x100000;\n  if (is_zero) {\n    y1 = (uint)product | y1;\n    y2 = (high_y & 0x80000000 | high_x) ^ y2;\n    high_y = mantissa >> 1;\n    underflowed = SBORROW4(exponent_sum,high_y);\n    mantissa_difference = exponent_sum - high_y;\n    is_zero = mantissa_difference == 0;\n    high_x = mantissa_difference;\n    if (!is_zero && (int)high_y <= exponent_sum) {\n      underflowed = SBORROW4(mantissa,mantissa_difference);\n      high_x = mantissa - mantissa_difference;\n      is_zero = mantissa == mantissa_difference;\n    }\n    if (!is_zero && (int)high_x < 0 == underflowed) {\n      y2 = y2 | mantissa_difference * 0x100000;\n    }\n    if (!is_zero && (int)high_x < 0 == underflowed) {\n      return CONCAT44(y2,y1);\n    }\n    y2 = y2 | 0x100000;\n    mantissa = 0;\n    underflowed = SBORROW4(mantissa_difference,1);\n    mantissa_difference = mantissa_difference - 1;\n    is_zero = mantissa_difference == 0;\n    high_y = mantissa_difference;\n  }\n  else {\n    low_product = (product & 0xffffffff) * (ulonglong)y1;\n    product = (product & 0xffffffff) * (ulonglong)y2 +\n             (ulonglong)high_x * (ulonglong)y1 + (low_product >> 0x20);\n    low_product_temp = (uint)product;\n    high_product = (ulonglong)high_x * (ulonglong)y2 + (product >> 0x20);\n    mantissa = (uint)high_product;\n    high_x = (uint)((ulonglong)high_product >> 0x20);\n    if ((int)low_product != 0) {\n      low_product_temp = low_product_temp | 1;\n    }\n    mantissa_difference = (exponent_sum + -0x3ff) - (uint)(high_x < 0x200);\n    if (high_x < 0x200) {\n      is_zero = (low_product_temp & 0x80000000) != 0;\n      low_product_temp = low_product_temp << 1;\n      high_product = CONCAT44(high_x * 2 + (uint)(CARRY4(mantissa,mantissa) || CARRY4(mantissa * 2,(uint)is_zero)),\n                       mantissa * 2 + (uint)is_zero);\n    }\n    y2 = high_y & 0x80000000 | (int)((ulonglong)high_product >> 0x20) << 0xb | (uint)high_product >> 0x15;\n    y1 = (uint)high_product << 0xb | low_product_temp >> 0x15;\n    mantissa = low_product_temp * 0x800;\n    overflowed = 0xfc < mantissa_difference;\n    underflowed = SBORROW4(mantissa_difference,0xfd);\n    high_x = mantissa_difference - 0xfd;\n    is_zero = high_x == 0;\n    high_y = high_x;\n    if (overflowed && !is_zero) {\n      overflowed = 0x6ff < high_x;\n      underflowed = SBORROW4(high_x,0x700);\n      high_y = mantissa_difference - 0x7fd;\n      is_zero = high_x == 0x700;\n    }\n    if (!overflowed || is_zero) {\n      is_zero = 0x7fffffff < mantissa;\n      if (mantissa == 0x80000000) {\n        is_zero = (low_product_temp >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(y2 + mantissa_difference * 0x100000 + (uint)CARRY4(y1,(uint)is_zero),y1 + is_zero\n                     );\n    }\n  }\n  if (!is_zero && (int)high_y < 0 == underflowed) {\n    return (ulonglong)(y2 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  overflowed = SCARRY4(mantissa_difference,0x36);\n  is_zero = (int)(mantissa_difference + 0x36) < 0;\n  underflowed = mantissa_difference == 0xffffffca;\n  if (underflowed || is_zero != overflowed) {\n    y1 = 0;\n  }\n  if (underflowed || is_zero != overflowed) {\n    y2 = y2 & 0x80000000;\n  }\n  if (underflowed || is_zero != overflowed) {\n    return CONCAT44(y2,y1);\n  }\n  high_y = -mantissa_difference;\n  high_x = high_y - 0x20;\n  if (0x1f < (int)high_y) {\n    mantissa_difference = y1 >> (high_x & 0xff) | y2 << (0x20 - high_x & 0xff);\n    high_y = (y2 >> (high_x & 0xff) & ~((y2 & 0x80000000) >> (high_x & 0xff))) -\n            ((int)mantissa_difference >> 0x1f);\n    if ((mantissa | y1 << (0x20 - high_x & 0xff) | mantissa_difference << 1) == 0) {\n      high_y = high_y & ~(mantissa_difference >> 0x1f);\n    }\n    return CONCAT44(y2,high_y) & 0x80000000ffffffff;\n  }\n  exponent_sum = high_y - 0x14;\n  if (exponent_sum == 0 || exponent_sum < 0 != SCARRY4(high_x,0xc)) {\n    low_product_temp = y1 << (mantissa_difference + 0x20 & 0xff);\n    high_x = y1 >> (high_y & 0xff) | y2 << (mantissa_difference + 0x20 & 0xff);\n    mantissa_difference = high_x + -((int)low_product_temp >> 0x1f);\n    if ((mantissa | low_product_temp << 1) == 0) {\n      mantissa_difference = mantissa_difference & ~(low_product_temp >> 0x1f);\n    }\n    return CONCAT44((y2 & 0x80000000) +\n                    ((y2 & 0x7fffffff) >> (high_y & 0xff)) +\n                    (uint)CARRY4(high_x,-((int)low_product_temp >> 0x1f)),mantissa_difference);\n  }\n  high_y = 0xc - exponent_sum;\n  mantissa_difference = y1 << (high_y & 0xff);\n  high_y = y1 >> (0x20 - high_y & 0xff) | y2 << (high_y & 0xff);\n  high_x = high_y + -((int)mantissa_difference >> 0x1f);\n  if ((mantissa | mantissa_difference << 1) == 0) {\n    high_x = high_x & ~(mantissa_difference >> 0x1f);\n  }\n  return CONCAT44((y2 & 0x80000000) + (uint)CARRY4(high_y,-((int)mantissa_difference >> 0x1f)),high_x);\n}\n\n",
            "called": [
                "FUN_080006a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004c8",
            "calling": [
                "FUN_080096e0",
                "FUN_08004d78",
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "multiply_and_add_080004c8"
        },
        "FUN_08008ad4": {
            "renaming": {
                "FUN_08008ad4": "get_default_value_08008ad4",
                "puVar1": "default_value"
            },
            "code": "\nundefined * get_default_value_08008ad4(void)\n\n{\n  undefined *default_value;\n  \n  default_value = *(undefined **)(*(int *)PTR_PTR_DAT_08008ae8 + 0x34);\n  if (*(undefined **)(*(int *)PTR_PTR_DAT_08008ae8 + 0x34) == (undefined *)0x0) {\n    default_value = PTR_DAT_08008aec;\n  }\n  return default_value + 0xf0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ad4",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "get_default_value_08008ad4"
        },
        "FUN_080009e8": {
            "renaming": {
                "FUN_080009e8": "check_if_null_terminated_080009e8",
                "in_CY": "input_character"
            },
            "code": "\nbool check_if_null_terminated_080009e8(void)\n\n{\n  char input_character;\n  \n  FUN_08000978();\n  return input_character == '\\0';\n}\n\n",
            "called": [
                "FUN_08000978"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009e8",
            "calling": [
                "FUN_080059f0",
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "check_if_null_terminated_080009e8"
        },
        "FUN_08005674": {
            "renaming": {
                "FUN_08005674": "infinite_loop_08005674"
            },
            "code": "\nvoid infinite_loop_08005674(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005674",
            "calling": [
                "FUN_08005348",
                "FUN_08005598",
                "FUN_080052a0",
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "imported": false,
            "current_name": "infinite_loop_08005674"
        },
        "FUN_08003c4a": {
            "renaming": {
                "FUN_08003c4a": "FUNC_08003c4a"
            },
            "code": "\nvoid FUNC_08003c4a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003c4a",
            "calling": [
                "FUN_080036f8"
            ],
            "imported": false,
            "current_name": "FUNC_08003c4a"
        },
        "FUN_08009630": {
            "renaming": {
                "FUN_08009630": "decode_and_convert_08009630",
                "param_1": "input_buffer",
                "param_2": "input_length",
                "param_3": "optional_offset",
                "param_4": "optional_value",
                "param_5": "output_offset",
                "param_6": "output_length",
                "iVar1": "result_pointer",
                "uVar2": "result_length",
                "iVar3": "temp_result_1",
                "iVar4": "temp_result_2",
                "uVar5": "temp_value_1",
                "uVar6": "temp_value_2",
                "uVar7": "temp_value_3",
                "local_20": "temp_buffer_1",
                "local_1c": "temp_buffer_2"
            },
            "code": "\nint decode_and_convert_08009630(undefined4 input_buffer,undefined4 input_length,uint optional_offset,uint optional_value,int *output_offset,\n                int *output_length)\n\n{\n  int result_pointer;\n  uint result_length;\n  int temp_result_1;\n  int temp_result_2;\n  uint temp_value_1;\n  uint temp_value_2;\n  undefined8 temp_value_3;\n  uint temp_buffer_1;\n  uint temp_buffer_2;\n  \n  result_pointer = FUN_080090c0(input_buffer,1);\n  temp_value_2 = (optional_value << 1) >> 0x15;\n  temp_buffer_2 = optional_value & 0xfffff;\n  if (temp_value_2 != 0) {\n    temp_buffer_2 = temp_buffer_2 | 0x100000;\n  }\n  if (optional_offset == 0) {\n    temp_result_1 = FUN_080091e4(&temp_buffer_2);\n    temp_result_2 = 1;\n    result_length = temp_result_1 + 0x20;\n    *(undefined4 *)(result_pointer + 0x10) = 1;\n    *(uint *)(result_pointer + 0x14) = temp_buffer_2;\n  }\n  else {\n    temp_buffer_1 = optional_offset;\n    result_length = FUN_080091e4(&temp_buffer_1);\n    if (result_length == 0) {\n      *(uint *)(result_pointer + 0x14) = temp_buffer_1;\n    }\n    else {\n      temp_value_1 = temp_buffer_2 << (0x20 - result_length & 0xff);\n      temp_buffer_2 = temp_buffer_2 >> (result_length & 0xff);\n      *(uint *)(result_pointer + 0x14) = temp_value_1 | temp_buffer_1;\n    }\n    if (temp_buffer_2 == 0) {\n      temp_result_2 = 1;\n    }\n    else {\n      temp_result_2 = 2;\n    }\n    *(uint *)(result_pointer + 0x18) = temp_buffer_2;\n    *(int *)(result_pointer + 0x10) = temp_result_2;\n  }\n  if (temp_value_2 == 0) {\n    *output_offset = result_length - 0x432;\n    temp_value_3 = FUN_080091a4(*(undefined4 *)(result_pointer + temp_result_2 * 4 + 0x10));\n    *output_length = (int)((ulonglong)temp_value_3 >> 0x20) * 0x20 - (int)temp_value_3;\n    return result_pointer;\n  }\n  *output_offset = (temp_value_2 - 0x433) + result_length;\n  *output_length = 0x35 - result_length;\n  return result_pointer;\n}\n\n",
            "called": [
                "FUN_080091e4",
                "FUN_080090c0",
                "FUN_080091a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009630",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "decode_and_convert_08009630"
        },
        "FUN_08004104": {
            "renaming": {
                "FUN_08004104": "update_parameters_08004104",
                "param_1": "object_address",
                "param_2": "new_value",
                "param_3": "bitmask"
            },
            "code": "\nvoid update_parameters_08004104(int object_address,int new_value,int bitmask)\n\n{\n  *(uint *)(object_address + 0x20) = *(uint *)(object_address + 0x20) & 0xffffffef;\n  *(uint *)(object_address + 0x18) = bitmask << 0xc | *(uint *)(object_address + 0x18) & 0xffff0fff;\n  *(uint *)(object_address + 0x20) = new_value << 4 | *(uint *)(object_address + 0x20) & 0xffffff5f;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004104",
            "calling": [
                "FUN_08003a94"
            ],
            "imported": false,
            "current_name": "update_parameters_08004104"
        },
        "FUN_08000ff4": {
            "renaming": {
                "FUN_08000ff4": "check_null_termination_08000ff4",
                "in_CY": "input_char"
            },
            "code": "\nbool check_null_termination_08000ff4(void)\n\n{\n  char input_char;\n  \n  FUN_08000fd0();\n  return input_char == '\\0';\n}\n\n",
            "called": [
                "FUN_08000fd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000ff4",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "check_null_termination_08000ff4"
        },
        "FUN_08005714": {
            "renaming": {
                "FUN_08005714": "initialize_pointer_08005714"
            },
            "code": "\nvoid initialize_pointer_08005714(void)\n\n{\n  FUN_080036f8(PTR_DAT_08005724);\n  return;\n}\n\n",
            "called": [
                "FUN_080036f8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005714",
            "calling": [],
            "imported": false,
            "current_name": "initialize_pointer_08005714"
        },
        "FUN_08005d0c": {
            "renaming": {
                "FUN_08005d0c": "FUNC_08005d0c"
            },
            "code": "\nvoid FUNC_08005d0c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08005d0c",
            "calling": [
                "FUN_08005838",
                "FUN_080059f0"
            ],
            "imported": false,
            "current_name": "FUNC_08005d0c"
        },
        "FUN_08005e40": {
            "renaming": {
                "FUN_08005e40": "find_first_set_bit_index_08005e40",
                "param_1": "input",
                "iVar1": "byte_offset",
                "puVar2": "word_ptr",
                "uVar4": "word",
                "count_leading_zeroes": "clz"
            },
            "code": "\nint find_first_set_bit_index_08005e40(uint input)\n\n{\n  int byte_offset;\n  uint *word_ptr;\n  int iVar3;\n  uint word;\n  \n  word_ptr = (uint *)(input & 0xfffffffc);\n  byte_offset = -(input & 3);\n  word = *word_ptr;\n  if ((input & 3) != 0) {\n    word = word | 0xffffffffU >> ((byte_offset + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    word_ptr = word_ptr + 1;\n    word = word + 0xfefefeff & ~word & 0x80808080;\n    if (word != 0) break;\n    word = *word_ptr;\n    byte_offset = byte_offset + 4;\n  }\n  iVar3 = clz(word & -word);\n  return byte_offset + (0x1fU - iVar3 >> 3);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e40",
            "calling": [
                "FUN_08005e9c",
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "find_first_set_bit_index_08005e40"
        },
        "FUN_08005d20": {
            "renaming": {
                "FUN_08005d20": "execute_functions_08005d20",
                "puVar1": "function_pointer",
                "iVar2": "iteration_counter",
                "ppcVar3": "function_array",
                "iVar4": "function_count"
            },
            "code": "\nvoid execute_functions_08005d20(void)\n\n{\n  undefined *function_pointer;\n  int iteration_counter;\n  code **function_array;\n  int function_count;\n  \n  function_count = (int)PTR_DAT_08005d58 - (int)PTR_DAT_08005d5c >> 2;\n  if (function_count != 0) {\n    iteration_counter = 0;\n    function_array = (code **)PTR_DAT_08005d5c;\n    do {\n      iteration_counter = iteration_counter + 1;\n      (**function_array)();\n      function_array = function_array + 1;\n    } while (function_count != iteration_counter);\n  }\n  function_array = (code **)PTR_DAT_08005d64;\n  function_pointer = PTR_DAT_08005d60;\n  FUNC_08009e68();\n  function_count = (int)function_pointer - (int)function_array >> 2;\n  if (function_count != 0) {\n    iteration_counter = 0;\n    do {\n      iteration_counter = iteration_counter + 1;\n      (**function_array)();\n      function_array = function_array + 1;\n    } while (function_count != iteration_counter);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08000134",
                "FUN_08009e68",
                "FUN_080078a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d20",
            "calling": [
                "FUN_080057e8"
            ],
            "imported": false,
            "current_name": "execute_functions_08005d20"
        },
        "FUN_08001a80": {
            "renaming": {
                "FUN_08001a80": "set_ushort_in_memory_08001a80",
                "param_1": "memory_address",
                "param_2": "ushort_value",
                "param_3": "is_shifted",
                "uint": "unsigned_int"
            },
            "code": "\nvoid set_ushort_in_memory_08001a80(int memory_address,ushort ushort_value,char is_shifted)\n\n{\n  if (is_shifted == '\\0') {\n    *(unsigned_int *)(memory_address + 0x10) = (unsigned_int)ushort_value << 0x10;\n  }\n  else {\n    *(unsigned_int *)(memory_address + 0x10) = (unsigned_int)ushort_value;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001a80",
            "calling": [
                "FUN_080055f4",
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "set_ushort_in_memory_08001a80"
        },
        "FUN_08005838": {
            "renaming": {
                "FUN_08005838": "calculate_result_08005838",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "difference",
                "uVar2": "result_upper",
                "uVar3": "bitwise_or",
                "uVar4": "result",
                "uVar5": "input2_unsigned",
                "uVar6": "concatenated_values"
            },
            "code": "\nuint calculate_result_08005838(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int difference;\n  undefined4 result_upper;\n  uint bitwise_or;\n  uint result;\n  uint input2_unsigned;\n  undefined8 concatenated_values;\n  \n  concatenated_values = CONCAT44(DAT_080059bc,DAT_080059b8);\n  result = input4 & 0x7fffffff;\n  if ((DAT_080059e8 < (result | (-input3 | input3) >> 0x1f)) ||\n     (input2_unsigned = input2 & 0x7fffffff, DAT_080059e8 < (input2_unsigned | (-input1 | input1) >> 0x1f))) {\n    result = FUN_0800015c(input3,input4,input1,input2);\n    return result;\n  }\n  if ((input4 + 0xc0100000 | input3) == 0) {\n    result = FUN_080059f0();\n    return result;\n  }\n  bitwise_or = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n  if ((input2_unsigned | input1) == 0) {\n    if (bitwise_or == 2) {\n      return DAT_080059b0;\n    }\n    result = DAT_080059a0;\n    if (bitwise_or != 3) {\n      return input1;\n    }\n  }\n  else {\n    if ((result | input3) != 0) {\n      if (result == DAT_080059e8) {\n        if (input2_unsigned == result) {\n          if (bitwise_or == 2) {\n            return DAT_080059e0;\n          }\n          if (bitwise_or == 3) {\n            return DAT_080059d8;\n          }\n          if (bitwise_or == 1) {\n            return DAT_080059d0;\n          }\n          return DAT_080059c8;\n        }\n        if (bitwise_or == 2) {\n          return DAT_080059b0;\n        }\n        if (bitwise_or == 3) {\n          return DAT_080059a0;\n        }\n        if (bitwise_or == 1) {\n          return 0;\n        }\n        return 0;\n      }\n      if (input2_unsigned != DAT_080059e8) {\n        difference = (int)(input2_unsigned - result) >> 0x14;\n        if (difference < 0x3d) {\n          if (((int)input4 < 0) && (difference + 0x3c < 0 != SCARRY4(difference,0x3c))) {\n            concatenated_values = 0;\n          }\n          else {\n            FUN_0800071c(input1,input2,input3,input4,input4);\n            FUNC_08005d0c();\n            concatenated_values = FUN_080059f0();\n          }\n        }\n        result_upper = (undefined4)((ulonglong)concatenated_values >> 0x20);\n        result = (uint)concatenated_values;\n        if (bitwise_or == 1) {\n          return result;\n        }\n        if (bitwise_or == 2) {\n          concatenated_values = FUN_08000158(result,result_upper,DAT_080059a8,DAT_080059ac);\n          result = FUN_08000158(DAT_080059b0,DAT_080059b4,(int)concatenated_values,(int)((ulonglong)concatenated_values >> 0x20))\n          ;\n          return result;\n        }\n        if (bitwise_or == 0) {\n          return result;\n        }\n        concatenated_values = FUN_08000158(result,result_upper,DAT_080059a8,DAT_080059ac);\n        result = FUN_08000158((int)concatenated_values,(int)((ulonglong)concatenated_values >> 0x20),DAT_080059b0,DAT_080059b4);\n        return result;\n      }\n    }\n    result = DAT_080059c0;\n    if (-1 < (int)input2) {\n      result = DAT_080059b8;\n    }\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_08005d0c",
                "FUN_0800015c",
                "FUN_08000158",
                "FUN_080059f0",
                "FUN_0800071c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005838",
            "calling": [
                "thunk_FUN_08005838"
            ],
            "imported": false,
            "current_name": "calculate_result_08005838"
        },
        "FUN_080090a8": {
            "renaming": {
                "FUN_080090a8": "initialize_data_080090a8"
            },
            "code": "\nvoid initialize_data_080090a8(void)\n\n{\n  FUNC_08008af0(PTR_DAT_080090b0);\n  return;\n}\n\n",
            "called": [
                "FUN_08008af0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090a8",
            "calling": [
                "FUN_08009adc",
                "FUN_080088ec",
                "FUN_08008af8",
                "FUN_0800884c"
            ],
            "imported": false,
            "current_name": "initialize_data_080090a8"
        },
        "FUN_08004e74": {
            "renaming": {
                "FUN_08004e74": "check_initialized_08004e74",
                "param_1": "input_value",
                "uVar1": "result"
            },
            "code": "\nundefined4 check_initialized_08004e74(undefined4 input_value)\n\n{\n  undefined4 result;\n  \n  if (*(int *)PTR_DAT_08004ea0 == 0) {\n    result = FUN_08004e6c(1,input_value,0);\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_08004e6c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e74",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "check_initialized_08004e74"
        },
        "FUN_080096e0": {
            "renaming": {
                "FUN_080096e0": "decode_float_080096e0",
                "param_1": "mantissa",
                "param_2": "exponent",
                "param_3": "status",
                "param_4": "rounding_mode",
                "iVar1": "max_exponent",
                "iVar2": "exponent_adjustment",
                "uVar3": "abs_exponent",
                "uVar4": "decoded_float"
            },
            "code": "\nundefined8 decode_float_080096e0(uint mantissa,uint exponent,int *status,undefined4 rounding_mode)\n\n{\n  int max_exponent;\n  int exponent_adjustment;\n  uint abs_exponent;\n  undefined8 decoded_float;\n  \n  max_exponent = DAT_08009740;\n  decoded_float = CONCAT44(exponent,mantissa);\n  exponent_adjustment = 0;\n  abs_exponent = exponent & 0x7fffffff;\n  *status = 0;\n  if (((int)abs_exponent <= max_exponent) && ((abs_exponent | mantissa) != 0)) {\n    if (abs_exponent < 0x100000) {\n      decoded_float = FUN_080004c8(mantissa,exponent,0,DAT_0800973c,rounding_mode);\n      exponent_adjustment = -0x36;\n      abs_exponent = (uint)((ulonglong)decoded_float >> 0x20) & 0x7fffffff;\n    }\n    mantissa = (uint)decoded_float;\n    exponent = (uint)((ulonglong)decoded_float >> 0x20) & 0x800fffff | 0x3fe00000;\n    *status = ((int)abs_exponent >> 0x14) + -0x3fe + exponent_adjustment;\n  }\n  return CONCAT44(exponent,mantissa);\n}\n\n",
            "called": [
                "FUN_080004c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080096e0",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "decode_float_080096e0"
        },
        "FUN_0800910c": {
            "renaming": {
                "FUN_0800910c": "update_value_at_index_0800910c",
                "param_1": "data_structure_start",
                "param_2": "value_and_index",
                "iVar1": "data_structure_offset"
            },
            "code": "\nvoid update_value_at_index_0800910c(int data_structure_start,undefined4 *value_and_index)\n\n{\n  int data_structure_offset;\n  \n  if (value_and_index != (undefined4 *)0x0) {\n    data_structure_offset = *(int *)(data_structure_start + 0x4c);\n    *value_and_index = *(undefined4 *)(data_structure_offset + value_and_index[1] * 4);\n    *(undefined4 **)(data_structure_offset + value_and_index[1] * 4) = value_and_index;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800910c",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "update_value_at_index_0800910c"
        },
        "FUN_080052a0": {
            "renaming": {
                "FUN_080052a0": "calculate_and_print_checksum_080052a0",
                "local_44": "checksum_mask",
                "local_40": "checksum_shift",
                "local_3c": "checksum_constant",
                "local_38": "unused_variable",
                "local_34": "unused_variable_2",
                "local_30": "checksum_seed",
                "local_2c": "checksum_multiplier",
                "local_28": "unused_variable_3",
                "local_20": "unused_variable_4",
                "local_14": "unused_variable_5",
                "local_10": "unused_variable_6",
                "local_c": "unused_variable_7"
            },
            "code": "\nvoid calculate_and_print_checksum_080052a0(void)\n\n{\n  longlong lVar1;\n  int iVar2;\n  ulonglong uVar3;\n  undefined4 checksum_mask;\n  undefined4 checksum_shift;\n  undefined4 checksum_constant;\n  undefined4 unused_variable;\n  undefined4 unused_variable_2;\n  undefined4 checksum_seed;\n  undefined4 checksum_multiplier;\n  undefined4 unused_variable_3;\n  undefined4 unused_variable_4;\n  undefined4 unused_variable_5;\n  undefined4 unused_variable_6;\n  undefined4 unused_variable_7;\n  \n  checksum_seed = 1;\n  checksum_multiplier = 0x10000;\n  unused_variable_3 = 0;\n  unused_variable_4 = 1;\n  unused_variable_5 = 2;\n  unused_variable_6 = 0x10000;\n  unused_variable_7 = 0x1c0000;\n  iVar2 = FUN_08002d98(&checksum_seed);\n  if (iVar2 != 0) {\n    FUN_08005674(PTR_s____src_main_c_08005340,0x151);\n  }\n  checksum_mask = 0xf;\n  checksum_shift = 2;\n  checksum_constant = 0x80;\n  unused_variable = 0;\n  unused_variable_2 = 0;\n  iVar2 = FUN_08003260(&checksum_mask,2);\n  if (iVar2 != 0) {\n    FUN_08005674(PTR_s____src_main_c_08005340,0x15e);\n  }\n  uVar3 = FUN_08003504();\n  lVar1 = (ulonglong)DAT_08005344 * (uVar3 & 0xffffffff);\n  FUN_08001762((uint)((ulonglong)lVar1 >> 0x26),(int)(uVar3 >> 0x20),(int)lVar1);\n  FUN_0800177c(4);\n  FUN_0800172a(0xffffffff,0,0);\n  return;\n}\n\n",
            "called": [
                "FUN_08002d98",
                "FUN_0800177c",
                "FUN_08001762",
                "FUN_08005674",
                "FUN_08003260",
                "FUN_0800172a",
                "FUN_08003504"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052a0",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "calculate_and_print_checksum_080052a0"
        },
        "FUN_08009120": {
            "renaming": {
                "FUN_08009120": "multiply_and_add_08009120",
                "param_1": "input_array",
                "param_2": "output_array",
                "param_3": "multiplier",
                "param_4": "carry",
                "puVar1": "result_array",
                "uVar2": "temp_result",
                "iVar3": "output_array_length",
                "puVar4": "output_array_ptr",
                "iVar5": "counter"
            },
            "code": "\nundefined4 * multiply_and_add_08009120(int input_array,undefined4 *output_array,int multiplier,uint carry)\n\n{\n  undefined4 *result_array;\n  uint temp_result;\n  int output_array_length;\n  uint *output_array_ptr;\n  int counter;\n  \n  counter = 0;\n  output_array_length = output_array[4];\n  output_array_ptr = output_array + 5;\n  do {\n    counter = counter + 1;\n    carry = multiplier * (*output_array_ptr & 0xffff) + carry;\n    temp_result = multiplier * (*output_array_ptr >> 0x10) + (carry >> 0x10);\n    *output_array_ptr = (carry & 0xffff) + temp_result * 0x10000;\n    carry = temp_result >> 0x10;\n    output_array_ptr = output_array_ptr + 1;\n  } while (counter < output_array_length);\n  result_array = output_array;\n  if (carry != 0) {\n    if ((int)output_array[2] <= output_array_length) {\n      result_array = (undefined4 *)FUN_080090c0(input_array,output_array[1] + 1);\n      FUN_08001084(result_array + 3,output_array + 3,(output_array[4] + 2) * 4);\n      counter = *(int *)(input_array + 0x4c);\n      *output_array = *(undefined4 *)(counter + output_array[1] * 4);\n      *(undefined4 **)(counter + output_array[1] * 4) = output_array;\n    }\n    result_array[output_array_length + 5] = carry;\n    result_array[4] = output_array_length + 1;\n  }\n  return result_array;\n}\n\n",
            "called": [
                "FUN_08001084",
                "FUN_080090c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009120",
            "calling": [
                "FUN_080093a4",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "multiply_and_add_08009120"
        },
        "FUN_08001084": {
            "renaming": {
                "FUN_08001084": "copy_memory_08001084",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "size",
                "puVar1": "destination_ptr",
                "puVar2": "destination_ptr_temp",
                "puVar3": "source_ptr",
                "uVar4": "size_temp",
                "uVar5": "size_remaining",
                "bVar6": "size_check"
            },
            "code": "\nundefined4 * copy_memory_08001084(undefined4 *destination,undefined4 *source,uint size)\n\n{\n  undefined4 *destination_ptr;\n  undefined4 *destination_ptr_temp;\n  undefined4 *source_ptr;\n  uint size_temp;\n  uint size_remaining;\n  bool size_check;\n  \n  destination_ptr_temp = destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (size < 8) {\n      size_remaining = size - 4;\n      if (3 < size) {\n        do {\n          destination_ptr = source;\n          source_ptr = destination_ptr_temp;\n          size_check = size_remaining != 0;\n          size_remaining = size_remaining - 1;\n          *(undefined *)source_ptr = *(undefined *)destination_ptr;\n          destination_ptr_temp = (undefined4 *)((int)source_ptr + 1);\n          source = (undefined4 *)((int)destination_ptr + 1);\n        } while (size_check);\n        *(undefined *)(undefined4 *)((int)source_ptr + 1) =\n             *(undefined *)(undefined4 *)((int)destination_ptr + 1);\n        *(undefined *)((int)source_ptr + 2) = *(undefined *)((int)destination_ptr + 2);\n        *(undefined *)((int)source_ptr + 3) = *(undefined *)((int)destination_ptr + 3);\n        return destination;\n      }\n      goto LAB_08001108;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      size_remaining = 4 - ((uint)destination & 3);\n      size = size - size_remaining;\n      destination_ptr = destination;\n      source_ptr = source;\n      if (((uint)destination & 1) != 0) {\n        source_ptr = (undefined4 *)((int)source + 1);\n        destination_ptr = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *(undefined *)source;\n      }\n      destination_ptr_temp = destination_ptr;\n      source = source_ptr;\n      if ((size_remaining & 2) != 0) {\n        source = (undefined4 *)((int)source_ptr + 2);\n        destination_ptr_temp = (undefined4 *)((int)destination_ptr + 2);\n        *(undefined2 *)destination_ptr = *(undefined2 *)source_ptr;\n      }\n    }\n  }\n  while (0x3f < size) {\n    *destination_ptr_temp = *source;\n    destination_ptr_temp[1] = source[1];\n    destination_ptr_temp[2] = source[2];\n    destination_ptr_temp[3] = source[3];\n    destination_ptr_temp[4] = source[4];\n    destination_ptr_temp[5] = source[5];\n    destination_ptr_temp[6] = source[6];\n    destination_ptr_temp[7] = source[7];\n    destination_ptr_temp[8] = source[8];\n    destination_ptr_temp[9] = source[9];\n    destination_ptr_temp[10] = source[10];\n    destination_ptr_temp[0xb] = source[0xb];\n    destination_ptr_temp[0xc] = source[0xc];\n    destination_ptr_temp[0xd] = source[0xd];\n    destination_ptr_temp[0xe] = source[0xe];\n    destination_ptr_temp[0xf] = source[0xf];\n    destination_ptr_temp = destination_ptr_temp + 0x10;\n    source = source + 0x10;\n    size = size - 0x40;\n  }\n  size_temp = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n      *destination_ptr_temp = *source;\n      destination_ptr_temp[1] = source[1];\n      destination_ptr_temp[2] = source[2];\n      destination_ptr_temp[3] = source[3];\n      destination_ptr_temp = destination_ptr_temp + 4;\n      source = source + 4;\n      size_check = 0xf < size_temp;\n      size_temp = size_temp - 0x10;\n    } while (size_check);\n  }\n  size_remaining = size_temp + 0xc;\n  source_ptr = destination_ptr_temp;\n  destination_ptr = source;\n  if (0xfffffff3 < size_temp) {\n    do {\n      source = destination_ptr + 1;\n      *source_ptr = *destination_ptr;\n      size_check = 3 < size_remaining;\n      size_remaining = size_remaining - 4;\n      destination_ptr_temp = source_ptr + 1;\n      source_ptr = source_ptr + 1;\n      destination_ptr = source;\n    } while (size_check);\n  }\nLAB_08001108:\n  if (size_remaining + 4 != 0) {\n    destination_ptr = destination_ptr_temp;\n    source_ptr = source;\n    if ((size_remaining & 1) != 0) {\n      source_ptr = (undefined4 *)((int)source + 1);\n      destination_ptr = (undefined4 *)((int)destination_ptr_temp + 1);\n      *(undefined *)destination_ptr_temp = *(undefined *)source;\n    }\n    if ((size_remaining + 4 & 2) != 0) {\n      *(undefined2 *)destination_ptr = *(undefined2 *)source_ptr;\n    }\n  }\n  return destination;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001084",
            "calling": [
                "FUN_08009120",
                "FUN_080079e8",
                "FUN_080097cc"
            ],
            "imported": false,
            "current_name": "copy_memory_08001084"
        },
        "FUN_08005680": {
            "renaming": {
                "FUN_08005680": "initialize_data_08005680",
                "param_1": "data_ptr",
                "local_18": "data_size",
                "local_14": "data_value_1",
                "local_c": "data_value_2"
            },
            "code": "\nvoid initialize_data_08005680(int *data_ptr)\n\n{\n  undefined4 data_size;\n  undefined4 data_value_1;\n  undefined4 data_value_2;\n  \n  if (*data_ptr == DAT_080056b4) {\n    data_size = 0x900;\n    data_value_1 = 2;\n    data_value_2 = 2;\n    FUN_080017c4(DAT_080056b8,&data_size);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_080017c4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005680",
            "calling": [
                "FUN_080053b0"
            ],
            "imported": false,
            "current_name": "initialize_data_08005680"
        },
        "FUN_08003260": {
            "renaming": {
                "FUN_08003260": "update_memory_08003260",
                "param_1": "memory_location",
                "param_2": "memory_size",
                "uVar3": "memory_value",
                "uVar4": "return_value",
                "iVar1": "initial_value",
                "iVar2": "current_value"
            },
            "code": "\nundefined4 update_memory_08003260(uint *memory_location,uint memory_size)\n\n{\n  int initial_value;\n  int current_value;\n  uint memory_value;\n  undefined4 return_value;\n  \n  if (((*DAT_08003430 & 7) < memory_size) &&\n     (*DAT_08003430 = memory_size | *DAT_08003430 & 0xfffffff8, memory_size != (*DAT_08003430 & 7))) {\n    return_value = 1;\n  }\n  else {\n    if ((*memory_location & 2) != 0) {\n      DAT_08003434[1] = memory_location[2] | DAT_08003434[1] & 0xffffff0f;\n    }\n    if ((*memory_location & 1) == 0) {\nLAB_08003394:\n      if ((memory_size < (*DAT_08003430 & 7)) &&\n         (*DAT_08003430 = memory_size | *DAT_08003430 & 0xfffffff8, memory_size != (*DAT_08003430 & 7))) {\n        return_value = 1;\n      }\n      else {\n        if ((*memory_location & 4) != 0) {\n          DAT_08003434[1] = memory_location[3] | DAT_08003434[1] & 0xfffff8ff;\n        }\n        if ((*memory_location & 8) != 0) {\n          DAT_08003434[1] = memory_location[4] << 3 | DAT_08003434[1] & 0xffffc7ff;\n        }\n        memory_value = FUN_08003440();\n        *(uint *)PTR_DAT_0800343c = memory_value >> PTR_DAT_08003438[DAT_08003434[1] >> 4 & 0xf];\n        FUN_0800151c(0xf);\n        return_value = 0;\n      }\n    }\n    else {\n      if (memory_location[1] == 1) {\n        if ((*DAT_08003434 & 0x20000) == 0) {\n          return 1;\n        }\n      }\n      else if ((memory_location[1] != 2) && ((*DAT_08003434 & 2) == 0)) {\n        return 1;\n      }\n      DAT_08003434[1] = memory_location[1] | DAT_08003434[1] & 0xfffffffc;\n      initial_value = FUN_080015a0();\n      if (memory_location[1] == 1) {\n        do {\n          if ((DAT_08003434[1] & 0xc) == 4) goto LAB_08003394;\n          current_value = FUN_080015a0();\n        } while ((uint)(current_value - initial_value) < 0x1389);\n        return_value = 3;\n      }\n      else if (memory_location[1] == 2) {\n        do {\n          if ((DAT_08003434[1] & 0xc) == 8) goto LAB_08003394;\n          current_value = FUN_080015a0();\n        } while ((uint)(current_value - initial_value) < 0x1389);\n        return_value = 3;\n      }\n      else {\n        do {\n          if ((DAT_08003434[1] & 0xc) == 0) goto LAB_08003394;\n          current_value = FUN_080015a0();\n        } while ((uint)(current_value - initial_value) < 0x1389);\n        return_value = 3;\n      }\n    }\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_080015a0",
                "FUN_08003440",
                "FUN_0800151c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003260",
            "calling": [
                "FUN_080052a0"
            ],
            "imported": false,
            "current_name": "update_memory_08003260"
        },
        "FUN_08001ab0": {
            "renaming": {
                "FUN_08001ab0": "calculate_checksum_08001ab0",
                "param_1": "checksum_array",
                "uVar1": "random_number",
                "cVar2": "is_valid",
                "uVar3": "result",
                "uVar4": "temp",
                "bVar5": "is_zero"
            },
            "code": "\nundefined4 calculate_checksum_08001ab0(uint **checksum_array)\n\n{\n  uint random_number;\n  char is_valid;\n  undefined4 result;\n  uint temp;\n  bool is_zero;\n  \n  if (checksum_array == (uint **)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)checksum_array + 0x3d) == '\\0') {\n      *(undefined *)(checksum_array + 0xf) = 0;\n      FUNC_08001cb8(checksum_array);\n    }\n    *(undefined *)((int)checksum_array + 0x3d) = 0x24;\n    **checksum_array = **checksum_array & 0xfffffffe;\n    random_number = FUN_08003518();\n    if (DAT_08001ca4 < checksum_array[1]) {\n      temp = random_number;\n      if (random_number <= DAT_08001cac) {\n        temp = 1;\n      }\n      is_valid = (char)temp;\n      if (DAT_08001cac < random_number) {\n        is_valid = '\\0';\n      }\n    }\n    else {\n      temp = random_number;\n      if (random_number <= DAT_08001ca8) {\n        temp = 1;\n      }\n      is_valid = (char)temp;\n      if (DAT_08001ca8 < random_number) {\n        is_valid = '\\0';\n      }\n    }\n    if (is_valid == '\\0') {\n      temp = (uint)((ulonglong)DAT_08001cb0 * (ulonglong)random_number >> 0x32);\n      (*checksum_array)[1] = temp;\n      if (DAT_08001ca4 < checksum_array[1]) {\n        temp = (uint)((ulonglong)DAT_08001cb4 * (ulonglong)(temp * 300) >> 0x26);\n      }\n      (*checksum_array)[8] = temp + 1;\n      if (DAT_08001ca4 < checksum_array[1]) {\n        if (checksum_array[2] == (uint *)0x0) {\n          temp = (random_number - 1) / (uint)((int)checksum_array[1] * 3) + 1 & 0xfff;\n          is_zero = temp == 0;\n          if (is_zero) {\n            temp = 1;\n          }\n          is_valid = (char)temp;\n          if (!is_zero) {\n            is_valid = '\\0';\n          }\n        }\n        else {\n          temp = (random_number - 1) / (uint)((int)checksum_array[1] * 0x19) + 1 & 0xfff;\n          is_zero = temp == 0;\n          if (is_zero) {\n            temp = 1;\n          }\n          is_valid = (char)temp;\n          if (!is_zero) {\n            is_valid = '\\0';\n          }\n        }\n        if (is_valid == '\\0') {\n          if (checksum_array[2] == (uint *)0x0) {\n            random_number = (random_number - 1) / (uint)((int)checksum_array[1] * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            random_number = (random_number - 1) / (uint)((int)checksum_array[1] * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          random_number = 1;\n        }\n      }\n      else {\n        random_number = (random_number - 1) / (uint)((int)checksum_array[1] << 1) + 1 & 0xfff;\n        if (random_number < 4) {\n          random_number = 4;\n        }\n      }\n      (*checksum_array)[7] = random_number;\n      **checksum_array = (uint)checksum_array[8] | (uint)checksum_array[7];\n      (*checksum_array)[2] = (uint)checksum_array[3] | (uint)checksum_array[4];\n      (*checksum_array)[3] = (uint)checksum_array[6] | (uint)checksum_array[5];\n      **checksum_array = **checksum_array | 1;\n      checksum_array[0x10] = (uint *)0x0;\n      *(undefined *)((int)checksum_array + 0x3d) = 0x20;\n      checksum_array[0xc] = (uint *)0x0;\n      *(undefined *)((int)checksum_array + 0x3e) = 0;\n      result = 0;\n    }\n    else {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_08003518",
                "FUN_08001cb8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001ab0",
            "calling": [
                "FUN_08005348"
            ],
            "imported": false,
            "current_name": "calculate_checksum_08001ab0"
        },
        "FUN_08003540": {
            "renaming": {
                "FUN_08003540": "shift_value_based_on_bit_position_08003540",
                "uVar1": "function_result"
            },
            "code": "\nuint shift_value_based_on_bit_position_08003540(void)\n\n{\n  uint function_result;\n  \n  function_result = FUN_08003504();\n  return function_result >> PTR_DAT_08003564[*(uint *)(DAT_08003560 + 4) >> 0xb & 7];\n}\n\n",
            "called": [
                "FUN_08003504"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003540",
            "calling": [
                "FUN_080046ec"
            ],
            "imported": false,
            "current_name": "shift_value_based_on_bit_position_08003540"
        },
        "FUN_08009244": {
            "renaming": {
                "FUN_08009244": "set_parameter_08009244",
                "param_1": "parameter_list",
                "param_2": "parameter_value",
                "iVar1": "parameter_index"
            },
            "code": "\nvoid set_parameter_08009244(undefined4 parameter_list,undefined4 parameter_value)\n\n{\n  int parameter_index;\n  \n  parameter_index = FUN_080090c0(parameter_list,1);\n  *(undefined4 *)(parameter_index + 0x10) = 1;\n  *(undefined4 *)(parameter_index + 0x14) = parameter_value;\n  return;\n}\n\n",
            "called": [
                "FUN_080090c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009244",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "set_parameter_08009244"
        },
        "FUN_08003c5c": {
            "renaming": {
                "FUN_08003c5c": "FUNC_08003c5c"
            },
            "code": "\nvoid FUNC_08003c5c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003c5c",
            "calling": [
                "FUN_080036f8"
            ],
            "imported": false,
            "current_name": "FUNC_08003c5c"
        },
        "FUN_08004e6c": {
            "renaming": {
                "FUN_08004e6c": "execute_software_interrupt_08004e6c"
            },
            "code": "\nvoid execute_software_interrupt_08004e6c(void)\n\n{\n  software_interrupt(0x3f);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e6c",
            "calling": [
                "FUN_08004e74"
            ],
            "imported": false,
            "current_name": "execute_software_interrupt_08004e6c"
        },
        "FUN_08001762": {
            "renaming": {
                "FUN_08001762": "process_data_08001762",
                "param_1": "input_data",
                "uVar1": "processed_data"
            },
            "code": "\nundefined4 process_data_08001762(undefined4 input_data)\n\n{\n  undefined4 processed_data;\n  \n  processed_data = FUN_080016d0(input_data);\n  return processed_data;\n}\n\n",
            "called": [
                "FUN_080016d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001762",
            "calling": [
                "FUN_080052a0",
                "FUN_0800151c"
            ],
            "imported": false,
            "current_name": "process_data_08001762"
        },
        "FUN_08000158": {
            "renaming": {
                "FUN_08000158": "binary_fraction_arithmetic_08000158",
                "param_1": "numerator1",
                "param_2": "numerator2",
                "param_3": "denominator1",
                "param_4": "denominator2",
                "iVar1": "shifted_denominator2",
                "bVar2": "lsb",
                "uVar3": "numerator_sum1",
                "uVar4": "numerator_sum2",
                "uVar5": "shifted_numerator2",
                "uVar6": "numerator1_temp",
                "uVar7": "shifted_numerator1",
                "iVar8": "shift_amount",
                "uVar9": "numerator1_shifted",
                "uVar10": "denominator_shifted",
                "uVar11": "difference",
                "uVar12": "shifted_numerator_sum",
                "bVar13": "is_numerator1_negative",
                "bVar14": "is_condition_met",
                "bVar15": "is_shift_amount_negative"
            },
            "code": "\nulonglong binary_fraction_arithmetic_08000158(uint numerator1,uint numerator2,uint denominator1,uint denominator2)\n\n{\n  int shifted_denominator2;\n  byte lsb;\n  uint numerator_sum1;\n  uint numerator_sum2;\n  uint shifted_numerator2;\n  uint numerator1_temp;\n  uint shifted_numerator1;\n  int shift_amount;\n  uint numerator1_shifted;\n  uint denominator_shifted;\n  uint difference;\n  uint shifted_numerator_sum;\n  bool is_numerator1_negative;\n  bool is_condition_met;\n  bool is_shift_amount_negative;\n  \n  numerator1_temp = denominator2 ^ 0x80000000;\n  numerator1_shifted = numerator2 << 1;\n  denominator2 = denominator2 << 1;\n  is_numerator1_negative = ((numerator2 ^ numerator1_temp) & 0x7fffffff) == 0;\n  is_condition_met = is_numerator1_negative && numerator1 == denominator1;\n  if (!is_numerator1_negative || numerator1 != denominator1) {\n    is_condition_met = (numerator1_shifted | numerator1) == 0;\n  }\n  if (!is_condition_met) {\n    is_condition_met = (denominator2 | denominator1) == 0;\n  }\n  shift_amount = (int)numerator1_shifted >> 0x15;\n  if (!is_condition_met) {\n    is_condition_met = shift_amount == -1;\n  }\n  shifted_denominator2 = (int)denominator2 >> 0x15;\n  if (!is_condition_met) {\n    is_condition_met = shifted_denominator2 == -1;\n  }\n  if (is_condition_met) {\n    if (shift_amount == -1 || shifted_denominator2 == -1) {\n      numerator1_shifted = numerator1_temp;\n      difference = denominator1;\n      if (shift_amount == -1) {\n        numerator1_shifted = numerator2;\n        difference = numerator1;\n      }\n      if (shift_amount != -1 || shifted_denominator2 != -1) {\n        denominator1 = difference;\n        numerator1_temp = numerator1_shifted;\n      }\n      is_condition_met = (difference | numerator1_shifted << 0xc) == 0;\n      if (is_condition_met) {\n        is_condition_met = (denominator1 | numerator1_temp << 0xc) == 0;\n      }\n      if (is_condition_met) {\n        is_condition_met = numerator1_shifted == numerator1_temp;\n      }\n      if (!is_condition_met) {\n        numerator1_shifted = numerator1_shifted | 0x80000;\n      }\n      return CONCAT44(numerator1_shifted,difference);\n    }\n    if (((numerator2 ^ numerator1_temp) & 0x7fffffff) != 0 || numerator1 != denominator1) {\n      if ((numerator1_shifted | numerator1) == 0) {\n        numerator1 = denominator1;\n        numerator2 = numerator1_temp;\n      }\n      return CONCAT44(numerator2,numerator1);\n    }\n    if (numerator2 != numerator1_temp) {\n      return 0;\n    }\n    if (numerator1_shifted >> 0x15 == 0) {\n      is_condition_met = (numerator1 & 0x80000000) != 0;\n      numerator1_temp = numerator2 * 2 + (uint)is_condition_met;\n      if (CARRY4(numerator2,numerator2) || CARRY4(numerator2 * 2,(uint)is_condition_met)) {\n        numerator1_temp = numerator1_temp | 0x80000000;\n      }\n      return CONCAT44(numerator1_temp,numerator1 << 1);\n    }\n    if (numerator1_shifted < 0xffc00000) {\n      return CONCAT44(numerator2 + 0x100000,numerator1);\n    }\n    numerator2 = numerator2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(numerator2 | 0x7ff00000) << 0x20;\n  }\n  numerator1_shifted = numerator1_shifted >> 0x15;\n  denominator2 = denominator2 >> 0x15;\n  difference = denominator2 - numerator1_shifted;\n  is_condition_met = difference != 0;\n  if (denominator2 < numerator1_shifted) {\n    difference = -difference;\n  }\n  denominator_shifted = numerator1;\n  shifted_numerator1 = numerator2;\n  if (is_condition_met && numerator1_shifted <= denominator2) {\n    numerator1_shifted = numerator1_shifted + difference;\n    denominator_shifted = denominator1;\n    shifted_numerator1 = numerator1_temp;\n    denominator1 = numerator1;\n    numerator1_temp = numerator2;\n  }\n  if (0x36 < difference) {\n    return CONCAT44(shifted_numerator1,denominator_shifted);\n  }\n  numerator_sum2 = shifted_numerator1 & 0xfffff | 0x100000;\n  if ((shifted_numerator1 & 0x80000000) != 0) {\n    is_condition_met = denominator_shifted != 0;\n    denominator_shifted = -denominator_shifted;\n    numerator_sum2 = -numerator_sum2 - (uint)is_condition_met;\n  }\n  shifted_numerator1 = numerator1_temp & 0xfffff | 0x100000;\n  if ((numerator1_temp & 0x80000000) != 0) {\n    is_condition_met = denominator1 != 0;\n    denominator1 = -denominator1;\n    shifted_numerator1 = -shifted_numerator1 - (uint)is_condition_met;\n  }\n  if (numerator1_shifted == difference) {\n    shifted_numerator1 = shifted_numerator1 ^ 0x100000;\n    if (numerator1_shifted == 0) {\n      numerator_sum2 = numerator_sum2 ^ 0x100000;\n      numerator1_shifted = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  numerator1_temp = -difference + 0x20;\n  if ((int)difference < 0x21) {\n    shifted_numerator_sum = denominator1 << (numerator1_temp & 0xff);\n    denominator1 = denominator1 >> (difference & 0xff);\n    numerator_sum1 = denominator_shifted + denominator1;\n    shifted_numerator2 = shifted_numerator1 << (numerator1_temp & 0xff);\n    numerator1_temp = numerator_sum1 + shifted_numerator2;\n    numerator_sum2 = numerator_sum2 + CARRY4(denominator_shifted,denominator1) + ((int)shifted_numerator1 >> (difference & 0xff)) +\n            (uint)CARRY4(numerator_sum1,shifted_numerator2);\n  }\n  else {\n    shifted_numerator_sum = shifted_numerator1 << (-difference + 0x40 & 0xff);\n    if (denominator1 != 0) {\n      shifted_numerator_sum = shifted_numerator_sum | 2;\n    }\n    shifted_numerator1 = (int)shifted_numerator1 >> (difference - 0x20 & 0xff);\n    numerator1_temp = denominator_shifted + shifted_numerator1;\n    numerator_sum2 = numerator_sum2 + ((int)shifted_numerator1 >> 0x1f) + (uint)CARRY4(denominator_shifted,shifted_numerator1);\n  }\n  numerator2 = numerator_sum2 & 0x80000000;\n  difference = numerator_sum2;\n  if ((int)numerator_sum2 < 0) {\n    is_condition_met = shifted_numerator_sum == 0;\n    shifted_numerator_sum = -shifted_numerator_sum;\n    difference = -numerator1_temp;\n    numerator1_temp = -(uint)!is_condition_met - numerator1_temp;\n    difference = -(uint)(is_condition_met <= difference) - numerator_sum2;\n  }\n  if (0xfffff < difference) {\n    denominator_shifted = numerator1_shifted - 1;\n    if (0x1fffff < difference) {\n      denominator_shifted = difference & 1;\n      difference = difference >> 1;\n      lsb = (byte)numerator1_temp;\n      numerator1_temp = (uint)(denominator_shifted != 0) << 0x1f | numerator1_temp >> 1;\n      shifted_numerator_sum = (uint)(lsb & 1) << 0x1f | shifted_numerator_sum >> 1;\n      denominator_shifted = numerator1_shifted;\n      if (0xffbfffff < numerator1_shifted * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    is_condition_met = 0x7fffffff < shifted_numerator_sum;\n    if (shifted_numerator_sum == 0x80000000) {\n      is_condition_met = (numerator1_temp & 1) != 0;\n    }\n    return CONCAT44(difference + denominator_shifted * 0x100000 + (uint)CARRY4(numerator1_temp,(uint)is_condition_met) | numerator2,\n                    numerator1_temp + is_condition_met);\n  }\n  is_numerator1_negative = (shifted_numerator_sum & 0x80000000) != 0;\n  shifted_numerator_sum = shifted_numerator_sum << 1;\n  denominator_shifted = numerator1_temp * 2;\n  is_condition_met = CARRY4(numerator1_temp,numerator1_temp);\n  numerator1_temp = numerator1_temp * 2 + (uint)is_numerator1_negative;\n  difference = difference * 2 + (uint)(is_condition_met || CARRY4(denominator_shifted,(uint)is_numerator1_negative));\n  denominator_shifted = numerator1_shifted - 2;\n  if ((difference & 0x100000) != 0) goto LAB_08000268;\n  shifted_numerator1 = numerator1_temp;\n  numerator1_shifted = difference;\n  if (difference == 0) {\n    shifted_numerator1 = 0;\n    numerator1_shifted = numerator1_temp;\n  }\n  shift_amount = count_leading_zeroes(numerator1_shifted);\n  if (difference == 0) {\n    shift_amount = shift_amount + 0x20;\n  }\n  difference = shift_amount - 0xb;\n  is_shift_amount_negative = SBORROW4(difference,0x20);\n  numerator1_temp = shift_amount - 0x2b;\n  is_condition_met = (int)numerator1_temp < 0;\n  is_numerator1_negative = numerator1_temp == 0;\n  if ((int)difference < 0x20) {\n    is_shift_amount_negative = SCARRY4(numerator1_temp,0xc);\n    shift_amount = shift_amount + -0x1f;\n    is_condition_met = shift_amount < 0;\n    is_numerator1_negative = shift_amount == 0;\n    numerator1_temp = difference;\n    if (!is_numerator1_negative && is_condition_met == is_shift_amount_negative) {\n      shifted_numerator1 = numerator1_shifted << (difference & 0xff);\n      numerator1_shifted = numerator1_shifted >> (0xcU - shift_amount & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_numerator1_negative || is_condition_met != is_shift_amount_negative) {\n    shifted_numerator_sum = 0x20 - numerator1_temp;\n  }\n  numerator1_shifted = numerator1_shifted << (numerator1_temp & 0xff);\n  if (is_numerator1_negative || is_condition_met != is_shift_amount_negative) {\n    numerator1_shifted = numerator1_shifted | shifted_numerator1 >> (shifted_numerator_sum & 0xff);\n  }\n  if (is_numerator1_negative || is_condition_met != is_shift_amount_negative) {\n    shifted_numerator1 = shifted_numerator1 << (numerator1_temp & 0xff);\n  }\nLAB_080002e0:\n  if ((int)difference <= (int)denominator_shifted) {\n    return CONCAT44(numerator1_shifted + (denominator_shifted - difference) * 0x100000 | numerator2,shifted_numerator1);\n  }\n  numerator1_temp = ~(denominator_shifted - difference);\n  if ((int)numerator1_temp < 0x1f) {\n    shift_amount = numerator1_temp - 0x13;\n    if (shift_amount != 0 && shift_amount < 0 == SCARRY4(numerator1_temp - 0x1f,0xc)) {\n      return CONCAT44(numerator_sum2,shifted_numerator1 >> (0x20 - (0xcU - shift_amount) & 0xff) | numerator1_shifted << (0xcU - shift_amount & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    numerator1_temp = numerator1_temp + 1;\n    return CONCAT44(numerator2 | numerator1_shifted >> (numerator1_temp & 0xff),\n                    shifted_numerator1 >> (numerator1_temp & 0xff) | numerator1_shifted << (0x20 - numerator1_temp & 0xff));\n  }\n  return CONCAT44(numerator_sum2,numerator1_shifted >> (numerator1_temp - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000158",
            "calling": [
                "FUN_08005838",
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "binary_fraction_arithmetic_08000158"
        },
        "FUN_08009768": {
            "renaming": {
                "FUN_08009768": "copy_string_08009768",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "num_bytes",
                "cVar1": "current_char",
                "puVar2": "src_ptr",
                "puVar3": "dest_ptr",
                "uVar4": "current_word"
            },
            "code": "\nvoid copy_string_08009768(uint *dest,uint *src,uint num_bytes)\n\n{\n  char current_char;\n  uint *src_ptr;\n  uint *dest_ptr;\n  uint current_word;\n  \n  if (((((uint)dest | (uint)src) & 3) == 0) &&\n     (dest_ptr = dest, src_ptr = src, 3 < num_bytes)) {\n    do {\n      src = src_ptr + 1;\n      current_word = *src_ptr;\n      dest = dest_ptr;\n      if ((current_word + 0xfefefeff & ~current_word & 0x80808080) != 0) goto LAB_0800979c;\n      num_bytes = num_bytes - 4;\n      dest = dest_ptr + 1;\n      *dest_ptr = current_word;\n      dest_ptr = dest;\n      src_ptr = src;\n    } while (3 < num_bytes);\n  }\n  src_ptr = src;\n  if (num_bytes != 0) {\nLAB_0800979c:\n    current_char = *(char *)src_ptr;\n    *(char *)dest = current_char;\n    while( true ) {\n      dest = (uint *)((int)dest + 1);\n      num_bytes = num_bytes - 1;\n      if (current_char == '\\0') break;\n      if (num_bytes == 0) {\n        return;\n      }\n      src_ptr = (uint *)((int)src_ptr + 1);\n      current_char = *(char *)src_ptr;\n      *(char *)dest = current_char;\n    }\n    if (num_bytes != 0) {\n      src_ptr = dest;\n      do {\n        dest_ptr = (uint *)((int)src_ptr + 1);\n        *(char *)src_ptr = '\\0';\n        src_ptr = dest_ptr;\n      } while (dest_ptr != (uint *)(num_bytes + (int)dest));\n    }\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009768",
            "calling": [
                "FUN_08005e9c"
            ],
            "imported": false,
            "current_name": "copy_string_08009768"
        },
        "FUN_08003ff8": {
            "renaming": {
                "FUN_08003ff8": "update_data_structure_08003ff8",
                "param_1": "data_structure_address",
                "param_2": "input_data_array",
                "local_c": "data_value",
                "iVar1": "input_data_value_1",
                "iVar2": "input_data_value_2"
            },
            "code": "\nvoid update_data_structure_08003ff8(int data_structure_address,int *input_data_array)\n\n{\n  int input_data_value_1;\n  int input_data_value_2;\n  uint data_value;\n  \n  *(uint *)(data_structure_address + 0x20) = *(uint *)(data_structure_address + 0x20) & 0xffffefff;\n  data_value = *(uint *)(data_structure_address + 4);\n  input_data_value_1 = *input_data_array;\n  input_data_value_2 = input_data_array[2];\n  if (data_structure_address == DAT_0800409c) {\n    data_value = input_data_array[5] << 6 | data_value & 0xffffbfff;\n  }\n  *(uint *)(data_structure_address + 4) = data_value;\n  *(uint *)(data_structure_address + 0x1c) = input_data_value_1 << 8 | *(uint *)(data_structure_address + 0x1c) & 0xffff8cff;\n  *(int *)(data_structure_address + 0x40) = input_data_array[1];\n  *(uint *)(data_structure_address + 0x20) = input_data_value_2 << 0xc | *(uint *)(data_structure_address + 0x20) & 0xffffdfff;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ff8",
            "calling": [
                "FUN_08003908"
            ],
            "imported": false,
            "current_name": "update_data_structure_08003ff8"
        },
        "FUN_08004ea4": {
            "renaming": {
                "FUN_08004ea4": "execute_function_08004ea4",
                "param_1": "function_pointer",
                "param_2": "input_data",
                "param_3": "data_size",
                "param_4": "data_type"
            },
            "code": "\nvoid execute_function_08004ea4(undefined function_pointer,undefined input_data,undefined4 data_size,undefined2 data_type)\n\n{\n  FUN_08001ccc(PTR_DAT_08004ee4,function_pointer,input_data,1,data_size,data_type,*(undefined4 *)PTR_DAT_08004ee0);\n  return;\n}\n\n",
            "called": [
                "FUN_08001ccc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ea4",
            "calling": [],
            "imported": false,
            "current_name": "execute_function_08004ea4"
        },
        "FUN_080040a0": {
            "renaming": {
                "FUN_080040a0": "set_flags_and_values_080040a0",
                "param_1": "struct_ptr",
                "param_2": "flags",
                "param_3": "value",
                "uVar1": "old_flags"
            },
            "code": "\nvoid set_flags_and_values_080040a0(int struct_ptr,uint flags,int value)\n\n{\n  uint old_flags;\n  \n  old_flags = *(uint *)(struct_ptr + 0x20);\n  *(uint *)(struct_ptr + 0x20) = *(uint *)(struct_ptr + 0x20) & 0xfffffffe;\n  *(uint *)(struct_ptr + 0x18) = value << 4 | *(uint *)(struct_ptr + 0x18) & 0xffffff0f;\n  *(uint *)(struct_ptr + 0x20) = flags | old_flags & 0xfffffff5;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040a0",
            "calling": [
                "FUN_08003a94"
            ],
            "imported": false,
            "current_name": "set_flags_and_values_080040a0"
        },
        "FUN_08009a18": {
            "renaming": {
                "FUN_08009a18": "copy_memory_08009a18",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "num_bytes",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr",
                "iVar3": "loop_counter",
                "puVar4": "dest_byte_ptr",
                "puVar5": "src_byte_ptr",
                "uVar6": "temp_var",
                "uVar7": "remaining_bytes"
            },
            "code": "\nvoid copy_memory_08009a18(undefined4 *dest,undefined4 *src,uint num_bytes)\n\n{\n  undefined4 *dest_ptr;\n  undefined4 *src_ptr;\n  int loop_counter;\n  undefined *dest_byte_ptr;\n  undefined4 *src_byte_ptr;\n  uint temp_var;\n  uint remaining_bytes;\n  \n  if ((src < dest) && (src_ptr = (undefined4 *)((int)src + num_bytes), dest < src_ptr)) {\n    dest_byte_ptr = (undefined *)((int)dest + num_bytes);\n    if (num_bytes != 0) {\n      do {\n        src_ptr = (undefined4 *)((int)src_ptr + -1);\n        dest_byte_ptr = dest_byte_ptr + -1;\n        *dest_byte_ptr = *(undefined *)src_ptr;\n      } while (src != src_ptr);\n    }\n  }\n  else {\n    remaining_bytes = num_bytes;\n    if (0xf < num_bytes) {\n      if ((((uint)dest | (uint)src) & 3) != 0) goto LAB_08009abc;\n      src_ptr = src + 4;\n      dest_ptr = dest + 4;\n      do {\n        src_byte_ptr = src_ptr + 4;\n        dest_ptr[-4] = src_ptr[-4];\n        dest_ptr[-3] = src_ptr[-3];\n        dest_ptr[-2] = src_ptr[-2];\n        dest_ptr[-1] = src_ptr[-1];\n        src_ptr = src_byte_ptr;\n        dest_ptr = dest_ptr + 4;\n      } while (src_byte_ptr != (undefined4 *)((int)src + (num_bytes - 0x10 & 0xfffffff0) + 0x20));\n      loop_counter = (num_bytes - 0x10 >> 4) + 1;\n      remaining_bytes = num_bytes & 0xf;\n      src = src + loop_counter * 4;\n      dest = dest + loop_counter * 4;\n      if (3 < remaining_bytes) {\n        src_ptr = dest + -1;\n        temp_var = remaining_bytes;\n        dest_ptr = src;\n        do {\n          temp_var = temp_var - 4;\n          src_ptr = src_ptr + 1;\n          *src_ptr = *dest_ptr;\n          dest_ptr = dest_ptr + 1;\n        } while (3 < temp_var);\n        loop_counter = (remaining_bytes - 4 & 0xfffffffc) + 4;\n        dest = (undefined4 *)((int)dest + loop_counter);\n        src = (undefined4 *)((int)src + loop_counter);\n        remaining_bytes = num_bytes & 3;\n      }\n    }\n    num_bytes = remaining_bytes;\n    if (remaining_bytes != 0) {\nLAB_08009abc:\n      dest_byte_ptr = (undefined *)((int)dest + -1);\n      src_ptr = src;\n      do {\n        dest_ptr = (undefined4 *)((int)src_ptr + 1);\n        dest_byte_ptr = dest_byte_ptr + 1;\n        *dest_byte_ptr = *(undefined *)src_ptr;\n        src_ptr = dest_ptr;\n      } while (dest_ptr != (undefined4 *)(num_bytes + (int)src));\n      return;\n    }\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009a18",
            "calling": [
                "FUN_08009adc",
                "FUN_080097cc"
            ],
            "imported": false,
            "current_name": "copy_memory_08009a18"
        },
        "FUN_0800119c": {
            "renaming": {
                "FUN_0800119c": "signed_int_div_by_power_of2_0800119c",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar1": "quotient",
                "iVar2": "temp",
                "uVar3": "shift"
            },
            "code": "\nuint signedIntDivByPowerOf2_0800119c(uint dividend,uint divisor)\n\n{\n  uint quotient;\n  int temp;\n  uint shift;\n  \n  temp = divisor * 2 + 0x200000;\n  if (divisor * 2 < 0xffe00000) {\n    if (-1 < temp) {\n      return 0;\n    }\n    quotient = temp >> 0x15;\n    shift = -quotient - 0x3e1;\n    if (quotient < 0xfffffc20 && shift != 0) {\n      quotient = (divisor << 0xb | 0x80000000 | dividend >> 0x15) >> (shift & 0xff);\n      if ((divisor & 0x80000000) != 0) {\n        quotient = -quotient;\n      }\n      return quotient;\n    }\n  }\n  else if ((dividend | divisor << 0xc) != 0) {\n    return 0;\n  }\n  divisor = divisor & 0x80000000;\n  if (divisor == 0) {\n    divisor = 0x7fffffff;\n  }\n  return divisor;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800119c",
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "signed_int_div_by_power_of2_0800119c"
        },
        "FUN_08005728": {
            "renaming": {
                "FUN_08005728": "check_memory_availability_08005728",
                "param_1": "memory_needed",
                "puVar1": "result_ptr",
                "auStack_18": "stack_buffer",
                "local_14": "memory_needed_copy",
                "local_c": "return_value"
            },
            "code": "\nundefined4 check_memory_availability_08005728(int memory_needed)\n\n{\n  undefined4 *result_ptr;\n  undefined stack_buffer [4];\n  int memory_needed_copy;\n  undefined4 return_value;\n  \n  if (*(int *)PTR_DAT_08005778 == 0) {\n    *(undefined **)PTR_DAT_08005778 = PTR_DAT_0800577c;\n  }\n  return_value = *(undefined4 *)PTR_DAT_08005778;\n  if (stack_buffer < (undefined *)(memory_needed + *(int *)PTR_DAT_08005778)) {\n    memory_needed_copy = memory_needed;\n    result_ptr = (undefined4 *)FUN_08005d14();\n    *result_ptr = 0xc;\n    return_value = 0xffffffff;\n  }\n  else {\n    *(int *)PTR_DAT_08005778 = memory_needed + *(int *)PTR_DAT_08005778;\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_08005d14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005728",
            "calling": [
                "FUN_08009744"
            ],
            "imported": false,
            "current_name": "check_memory_availability_08005728"
        },
        "FUN_080090b4": {
            "renaming": {
                "FUN_080090b4": "initialize_data_080090b4"
            },
            "code": "\nvoid initialize_data_080090b4(void)\n\n{\n  FUNC_08008af4(PTR_DAT_080090bc);\n  return;\n}\n\n",
            "called": [
                "FUN_08008af4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090b4",
            "calling": [
                "FUN_08009adc",
                "FUN_080088ec",
                "FUN_08008af8",
                "FUN_0800884c"
            ],
            "imported": false,
            "current_name": "initialize_data_080090b4"
        },
        "FUN_0800422e": {
            "renaming": {
                "FUN_0800422e": "decode_data_0800422e",
                "param_1": "data_array",
                "param_2": "encoded_data",
                "uVar1": "result",
                "param_2[6]": "mask_1",
                "param_2[5]": "mask_2",
                "param_2[4]": "mask_3",
                "param_2[1]": "mask_5",
                "param_2[2]": "mask_6",
                "param_2[3]": "mask_7"
            },
            "code": "\nundefined4 decode_data_0800422e(int *data_array,uint *encoded_data)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(data_array + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(data_array + 0xf) = 1;\n    *(uint *)(*data_array + 0x44) =\n         mask_1 |\n         (mask_1 |\n         (mask_2 |\n         (mask_3 |\n         (*encoded_data | (mask_5 | (mask_6 | mask_7 & 0xfffffcff) & 0xfffffbff) & 0xfffff7ff\n         ) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    *(undefined *)(data_array + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800422e",
            "calling": [
                "FUN_080053b0"
            ],
            "imported": false,
            "current_name": "decode_data_0800422e"
        },
        "FUN_08008af4": {
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008af4",
            "calling": [
                "FUN_080098c0",
                "FUN_080090b4"
            ],
            "imported": false,
            "current_name": "FUNC_08008af4"
        },
        "FUN_08003e38": {
            "renaming": {
                "FUN_08003e38": "update_parameters_08003e38",
                "param_1": "param_address",
                "param_2": "param_values",
                "iVar1": "input_value",
                "uVar2": "updated_value",
                "local_10": "local_value",
                "param_2[2]": "shifted_value_1",
                "param_2[3]": "shifted_value_2",
                "param_2[5]": "shifted_value_3",
                "param_2[6]": "shifted_value_4"
            },
            "code": "\nvoid update_parameters_08003e38(int param_address,int *param_values)\n\n{\n  int input_value;\n  uint updated_value;\n  uint local_value;\n  \n  *(uint *)(param_address + 0x20) = *(uint *)(param_address + 0x20) & 0xffffffef;\n  local_value = *(uint *)(param_address + 4);\n  input_value = *param_values;\n  updated_value = shifted_value_1 << 4 | *(uint *)(param_address + 0x20) & 0xffffffdf;\n  if (param_address == DAT_08003f14) {\n    updated_value = (shifted_value_2 << 4 | updated_value & 0xffffff7f) & 0xffffffbf;\n    local_value = shifted_value_4 << 2 | shifted_value_3 << 2 | local_value & 0xfffff3ff;\n  }\n  *(uint *)(param_address + 4) = local_value;\n  *(uint *)(param_address + 0x18) = input_value << 8 | *(uint *)(param_address + 0x18) & 0xffff8cff;\n  *(int *)(param_address + 0x38) = param_values[1];\n  *(uint *)(param_address + 0x20) = updated_value;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003e38",
            "calling": [
                "FUN_08003908"
            ],
            "imported": false,
            "current_name": "update_parameters_08003e38"
        },
        "FUN_08008af0": {
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008af0",
            "calling": [
                "FUN_080098c0",
                "FUN_080090a8"
            ],
            "imported": false,
            "current_name": "FUNC_08008af0"
        },
        "FUN_0800151c": {
            "renaming": {
                "FUN_0800151c": "check_and_set_param_0800151c",
                "param_1": "input_param",
                "iVar1": "result",
                "uVar2": "output"
            },
            "code": "\nundefined4 check_and_set_param_0800151c(uint input_param)\n\n{\n  int result;\n  undefined4 output;\n  \n  result = FUN_08001762((int)((ulonglong)*(uint *)PTR_DAT_08001570 /\n                            (1000 / (ulonglong)(byte)*PTR_DAT_08001574)));\n  if (result == 0) {\n    if (input_param < 0x10) {\n      FUN_0800172a(0xffffffff,input_param,0);\n      *(uint *)PTR_DAT_08001578 = input_param;\n      output = 0;\n    }\n    else {\n      output = 1;\n    }\n  }\n  else {\n    output = 1;\n  }\n  return output;\n}\n\n",
            "called": [
                "FUN_08001762",
                "FUN_0800172a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800151c",
            "calling": [
                "FUN_080014f0",
                "FUN_08003260"
            ],
            "imported": false,
            "current_name": "check_and_set_param_0800151c"
        },
        "FUN_080006a4": {
            "renaming": {
                "FUN_080006a4": "calculate_double_precision_080006a4",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "uVar1": "bit1",
                "unaff_r4": "bit2",
                "uVar2": "bit3",
                "uVar3": "bit4",
                "in_r12": "mask",
                "bVar4": "isZero"
            },
            "code": "\nulonglong calculate_double_precision_080006a4(uint num1,uint num2,uint num3,uint num4)\n\n{\n  uint bit1;\n  uint bit2;\n  uint bit3;\n  uint bit4;\n  uint mask;\n  bool isZero;\n  \n  bit3 = mask & num4 >> 0x14;\n  if (bit2 != mask && bit3 != mask) {\n    isZero = (num1 | num2 << 1) == 0;\n    if (!isZero) {\n      isZero = (num3 | num4 << 1) == 0;\n    }\n    if (isZero) {\n      return (ulonglong)((num2 ^ num4) & 0x80000000) << 0x20;\n    }\n    if (bit2 == 0) {\n      bit4 = num2 & 0x80000000;\n      do {\n        bit1 = num1 & 0x80000000;\n        num1 = num1 << 1;\n        num2 = num2 * 2 + (uint)(bit1 != 0);\n      } while ((num2 & 0x100000) == 0);\n      num2 = num2 | bit4;\n      if (bit3 != 0) {\n        return CONCAT44(num2,num1);\n      }\n    }\n    do {\n      bit3 = num3 & 0x80000000;\n      num3 = num3 << 1;\n      num4 = num4 * 2 + (uint)(bit3 != 0);\n    } while ((num4 & 0x100000) == 0);\n    return CONCAT44(num2,num1);\n  }\n  isZero = (num1 | num2 << 1) == 0;\n  if (isZero) {\n    num2 = num4;\n    num1 = num3;\n  }\n  if (!isZero) {\n    isZero = (num3 | num4 << 1) == 0;\n  }\n  bit4 = num2;\n  if (((!isZero) && ((bit2 != mask || ((num1 | num2 << 0xc) == 0)))) &&\n     ((bit3 != mask || (num1 = num3, bit4 = num4, (num3 | num4 << 0xc) == 0)))) {\n    return (ulonglong)((num2 ^ num4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(bit4,num1) | 0x7ff8000000000000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080006a4",
            "calling": [
                "FUN_080004c8"
            ],
            "imported": false,
            "current_name": "calculate_double_precision_080006a4"
        },
        "FUN_08000f68": {
            "renaming": {
                "FUN_08000f68": "binary_operation_08000f68",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_negative",
                "uVar2": "input_1_times_2",
                "uVar3": "input_2_times_2",
                "uVar4": "bitwise_or_result",
                "bVar5": "is_zero"
            },
            "code": "\nuint binary_operation_08000f68(uint input_1,uint input_2)\n\n{\n  bool is_negative;\n  uint input_1_times_2;\n  uint input_2_times_2;\n  uint bitwise_or_result;\n  bool is_zero;\n  \n  input_1_times_2 = input_1 * 2;\n  input_2_times_2 = input_2 * 2;\n  if (((int)input_1_times_2 >> 0x18 == -1 || (int)input_2_times_2 >> 0x18 == -1) &&\n     ((((int)input_1_times_2 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)input_2_times_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  bitwise_or_result = input_1_times_2 | input_2 & 0x7fffffff;\n  is_zero = bitwise_or_result == 0;\n  if (!is_zero) {\n    bitwise_or_result = input_1 ^ input_2;\n    is_zero = bitwise_or_result == 0;\n  }\n  is_negative = -1 < (int)bitwise_or_result;\n  if (is_negative) {\n    input_1 = input_1_times_2 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_negative && input_2_times_2 <= input_1_times_2) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative || input_2_times_2 > input_1_times_2) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f68",
            "calling": [
                "FUN_08000fd0"
            ],
            "imported": false,
            "current_name": "binary_operation_08000f68"
        },
        "FUN_08009258": {
            "renaming": {
                "FUN_08009258": "calculate_polynomial_hash_08009258",
                "param_1": "hash",
                "param_2": "string1",
                "param_3": "string2",
                "puVar1": "multiplier_ptr",
                "puVar2": "current_char_ptr",
                "iVar3": "hash_table_ptr",
                "uVar4": "temp_hash",
                "puVar5": "string1_ptr",
                "uVar6": "string2_ptr",
                "puVar7": "last_char_ptr",
                "puVar14": "hash_table_entry_ptr",
                "puVar15": "string1_entry_ptr",
                "puVar16": "current_string1_entry_ptr",
                "puVar17": "hash_table_end_ptr",
                "puVar18": "hash_table_start_ptr",
                "iVar9": "min_length",
                "iVar10": "max_length",
                "uVar11": "string2_end_ptr",
                "iVar12": "string1_length",
                "iVar13": "string1_ptr"
            },
            "code": "\nvoid calculate_polynomial_hash_08009258(undefined4 hash,int string1,int string2)\n\n{\n  uint *multiplier_ptr;\n  uint *current_char_ptr;\n  int hash_table_ptr;\n  uint temp_hash;\n  uint *string1_ptr;\n  uint string2_ptr;\n  uint *last_char_ptr;\n  uint uVar8;\n  int min_length;\n  int max_length;\n  uint string2_end_ptr;\n  int string1_length;\n  int string1_ptr;\n  uint *hash_table_entry_ptr;\n  uint *string1_entry_ptr;\n  uint *current_string1_entry_ptr;\n  uint *hash_table_end_ptr;\n  uint *hash_table_start_ptr;\n  \n  string1_length = *(int *)(string1 + 0x10);\n  min_length = *(int *)(string2 + 0x10);\n  max_length = min_length;\n  string1_ptr = string1;\n  if (string1_length < min_length) {\n    max_length = string1_length;\n    string1_length = min_length;\n    string1_ptr = string2;\n    string2 = string1;\n  }\n  min_length = string1_length + max_length;\n  hash_table_ptr = *(int *)(string1_ptr + 4);\n  if (*(int *)(string1_ptr + 8) < min_length) {\n    hash_table_ptr = hash_table_ptr + 1;\n  }\n  hash_table_ptr = FUN_080090c0(hash,hash_table_ptr);\n  hash_table_start_ptr = (uint *)(hash_table_ptr + 0x14);\n  hash_table_end_ptr = hash_table_start_ptr + min_length;\n  for (string1_ptr = hash_table_start_ptr; string1_ptr < hash_table_end_ptr; string1_ptr = string1_ptr + 1) {\n    *string1_ptr = 0;\n  }\n  string2_ptr = string2 + 0x14;\n  string2_end_ptr = string2_ptr + max_length * 4;\n  string1_ptr = (uint *)(string1_ptr + 0x14);\n  if (string2_ptr < string2_end_ptr) {\n    last_char_ptr = (uint *)(string2_ptr + ((string2_end_ptr - string2) - 0x15 & 0xfffffffc));\n    current_string1_entry_ptr = (uint *)(string2 + 0x10);\n    do {\n      while( true ) {\n        current_string1_entry_ptr = current_string1_entry_ptr + 1;\n        string2_ptr = *current_string1_entry_ptr & 0xffff;\n        if (string2_ptr != 0) break;\n        string2_ptr = *current_string1_entry_ptr >> 0x10;\n        if (string2_ptr == 0) goto LAB_080092d2;\nLAB_0800932c:\n        uVar8 = *hash_table_start_ptr;\n        temp_hash = 0;\n        multiplier_ptr = string1_ptr;\n        hash_table_entry_ptr = hash_table_start_ptr;\n        string2_end_ptr = uVar8;\n        do {\n          string1_entry_ptr = hash_table_entry_ptr;\n          temp_hash = temp_hash + string2_ptr * *(ushort *)multiplier_ptr + (string2_end_ptr >> 0x10);\n          *string1_entry_ptr = uVar8 & 0xffff | temp_hash * 0x10000;\n          current_char_ptr = multiplier_ptr + 1;\n          string2_end_ptr = string1_entry_ptr[1];\n          uVar8 = string2_ptr * (*multiplier_ptr >> 0x10) + (string2_end_ptr & 0xffff) + (temp_hash >> 0x10);\n          temp_hash = uVar8 >> 0x10;\n          multiplier_ptr = current_char_ptr;\n          hash_table_entry_ptr = string1_entry_ptr + 1;\n        } while (current_char_ptr < string1_ptr + string1_length);\n        string1_entry_ptr[1] = uVar8;\n        hash_table_start_ptr = hash_table_start_ptr + 1;\n        if (last_char_ptr == current_string1_entry_ptr) goto LAB_0800937a;\n      }\n      string2_end_ptr = 0;\n      multiplier_ptr = hash_table_start_ptr;\n      hash_table_entry_ptr = string1_ptr;\n      do {\n        current_char_ptr = multiplier_ptr;\n        string1_entry_ptr = hash_table_entry_ptr + 1;\n        uVar8 = string2_ptr * (*hash_table_entry_ptr & 0xffff) + (*current_char_ptr & 0xffff) + string2_end_ptr;\n        temp_hash = string2_ptr * (*hash_table_entry_ptr >> 0x10) + (*current_char_ptr >> 0x10) + (uVar8 >> 0x10);\n        string2_end_ptr = temp_hash >> 0x10;\n        *current_char_ptr = uVar8 & 0xffff | temp_hash * 0x10000;\n        multiplier_ptr = current_char_ptr + 1;\n        hash_table_entry_ptr = string1_entry_ptr;\n      } while (string1_entry_ptr < string1_ptr + string1_length);\n      current_char_ptr[1] = string2_end_ptr;\n      string2_ptr = *current_string1_entry_ptr >> 0x10;\n      if (string2_ptr != 0) goto LAB_0800932c;\nLAB_080092d2:\n      hash_table_start_ptr = hash_table_start_ptr + 1;\n    } while (last_char_ptr != current_string1_entry_ptr);\n  }\nLAB_0800937a:\n  if (0 < min_length) {\n    string2_ptr = hash_table_end_ptr[-1];\n    hash_table_end_ptr = hash_table_end_ptr + -1;\n    while ((string2_ptr == 0 && (min_length = min_length + -1, min_length != 0))) {\n      hash_table_end_ptr = hash_table_end_ptr + -1;\n      string2_ptr = *hash_table_end_ptr;\n    }\n  }\n  *(int *)(hash_table_ptr + 0x10) = min_length;\n  return;\n}\n\n",
            "called": [
                "FUN_080090c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009258",
            "calling": [
                "FUN_080093a4",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "calculate_polynomial_hash_08009258"
        },
        "FUN_08000c08": {
            "renaming": {
                "FUN_08000c08": "leading_zeros_to_float_08000c08",
                "param_1": "input_number",
                "iVar1": "leading_zeros_count",
                "uVar2": "shift_amount",
                "iVar3": "float_bits",
                "uVar4": "sign_bit",
                "count_leading_zeroes": "count_leading_zeros"
            },
            "code": "\nuint leading_zeros_to_float_08000c08(uint input_number)\n\n{\n  int leading_zeros_count;\n  uint shift_amount;\n  int float_bits;\n  uint sign_bit;\n  \n  if (input_number == 0) {\n    return 0;\n  }\n  leading_zeros_count = count_leading_zeros(input_number);\n  shift_amount = leading_zeros_count - 8;\n  float_bits = shift_amount * -0x800000 + 0x4a800000;\n  if (7 < leading_zeros_count) {\n    sign_bit = 0 << (shift_amount & 0xff);\n    shift_amount = float_bits + (input_number << (shift_amount & 0xff)) +\n            (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < sign_bit);\n    if (sign_bit == 0x80000000) {\n      shift_amount = shift_amount & 0xfffffffe;\n    }\n    return shift_amount;\n  }\n  sign_bit = input_number << (leading_zeros_count + 0x18U & 0xff);\n  shift_amount = float_bits + ((input_number >> (0x20 - (leading_zeros_count + 0x18U) & 0xff)) - ((int)sign_bit >> 0x1f));\n  if ((sign_bit & 0x7fffffff) == 0) {\n    shift_amount = shift_amount & ~(sign_bit >> 0x1f);\n  }\n  return shift_amount;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c08",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "leading_zeros_to_float_08000c08"
        },
        "FUN_08003c6e": {
            "renaming": {
                "FUN_08003c6e": "FUNC_08003c6e"
            },
            "code": "\nvoid FUNC_08003c6e(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003c6e",
            "calling": [
                "FUN_080036f8"
            ],
            "imported": false,
            "current_name": "FUNC_08003c6e"
        },
        "FUN_080042de": {
            "renaming": {
                "FUN_080042de": "check_flag_080042de",
                "param_1": "flag_data",
                "param_2": "flag_mask",
                "uVar1": "result"
            },
            "code": "\nundefined4 check_flag_080042de(int *flag_data,uint *flag_mask)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(flag_data + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(flag_data + 0xf) = 1;\n    *(undefined *)((int)flag_data + 0x3d) = 2;\n    *(uint *)(*flag_data + 4) = *(uint *)(*flag_data + 4) & 0xffffff8f;\n    *(uint *)(*flag_data + 4) = *flag_mask | *(uint *)(*flag_data + 4);\n    *(uint *)(*flag_data + 8) = *(uint *)(*flag_data + 8) & 0xffffff7f;\n    *(uint *)(*flag_data + 8) = flag_mask[1] | *(uint *)(*flag_data + 8);\n    *(undefined *)((int)flag_data + 0x3d) = 1;\n    *(undefined *)(flag_data + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042de",
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "imported": false,
            "current_name": "check_flag_080042de"
        },
        "FUN_08004366": {
            "renaming": {
                "FUN_08004366": "FUNC_08004366"
            },
            "code": "\nvoid FUNC_08004366(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08004366",
            "calling": [
                "FUN_080036f8"
            ],
            "imported": false,
            "current_name": "FUNC_08004366"
        },
        "FUN_08009530": {
            "renaming": {
                "FUN_08009530": "compare_and_update_08009530",
                "param_1": "param_a",
                "param_2": "array_a",
                "param_3": "array_b",
                "param_4": "param_b",
                "iVar1": "result",
                "iVar5": "index",
                "puVar2": "array_b_ptr",
                "uVar3": "array_a_length",
                "uVar4": "carry",
                "iVar12": "carry_extended",
                "puVar6": "result_array_ptr",
                "puVar7": "array_a_ptr",
                "puVar8": "array_a_end_ptr",
                "puVar9": "array_b_start_ptr",
                "puVar10": "array_b_end_ptr",
                "puVar11": "array_b_limit_ptr",
                "puVar13": "array_a_start_ptr",
                "uVar14": "array_a_count"
            },
            "code": "\nvoid compare_and_update_08009530(undefined4 param_a,uint *array_a,uint *array_b,undefined4 param_b)\n\n{\n  int result;\n  uint *array_b_ptr;\n  uint array_a_length;\n  uint carry;\n  int index;\n  uint *result_array_ptr;\n  uint *array_a_ptr;\n  uint *array_b_start_ptr;\n  uint *array_b_end_ptr;\n  uint *array_b_limit_ptr;\n  int carry_extended;\n  uint *array_a_start_ptr;\n  uint array_a_count;\n  uint *array_a_end_ptr;\n  \n  array_b_ptr = (uint *)array_b[4];\n  index = array_a[4] - (int)array_b_ptr;\n  array_b_limit_ptr = array_a + 5;\n  array_a_start_ptr = array_b + 5;\n  array_a_ptr = array_b_limit_ptr;\n  array_b_start_ptr = array_a;\n  if (index == 0) {\n    result_array_ptr = array_b_limit_ptr + (int)array_b_ptr;\n    array_b_ptr = array_a_start_ptr + (int)array_b_ptr;\n    while( true ) {\n      result_array_ptr = result_array_ptr + -1;\n      array_b_ptr = array_b_ptr + -1;\n      if (*result_array_ptr != *array_b_ptr) break;\n      if (result_array_ptr <= array_b_limit_ptr) {\n        index = FUN_080090c0(param_a,0,result_array_ptr,array_b_ptr,param_b);\n        *(undefined4 *)(index + 0x10) = 1;\n        *(undefined4 *)(index + 0x14) = 0;\n        return;\n      }\n    }\n    if (*array_b_ptr <= *result_array_ptr) goto LAB_08009578;\n  }\n  else if (-1 < index) {\n    index = 0;\n    result_array_ptr = array_b;\n    goto LAB_08009578;\n  }\n  index = 1;\n  result_array_ptr = array_b_limit_ptr;\n  array_b_ptr = array_a;\n  array_a_ptr = array_a_start_ptr;\n  array_b_start_ptr = array_b;\n  array_b = array_a;\n  array_a_start_ptr = array_b_limit_ptr;\nLAB_08009578:\n  result = FUN_080090c0(param_a,array_b_start_ptr[1],result_array_ptr,array_b_ptr,param_b);\n  carry_extended = 0;\n  array_a_count = array_b_start_ptr[4];\n  array_a_length = array_b[4];\n  *(int *)(result + 0xc) = index;\n  array_b_limit_ptr = array_a_ptr + array_a_count;\n  array_b_ptr = (uint *)(result + 0x14);\n  array_b_start_ptr = array_a_start_ptr;\n  do {\n    array_a_end_ptr = array_a_ptr + 1;\n    array_b_end_ptr = array_b_start_ptr + 1;\n    carry = ((*array_a_ptr & 0xffff) + carry_extended) - (*array_b_start_ptr & 0xffff);\n    carry_extended = ((*array_a_ptr >> 0x10) - (*array_b_start_ptr >> 0x10)) + ((int)carry >> 0x10);\n    carry = carry & 0xffff | carry_extended * 0x10000;\n    result_array_ptr = array_b_ptr + 1;\n    *array_b_ptr = carry;\n    carry_extended = carry_extended >> 0x10;\n    array_b_ptr = result_array_ptr;\n    array_a_ptr = array_a_end_ptr;\n    array_b_start_ptr = array_b_end_ptr;\n  } while (array_b_end_ptr < array_a_start_ptr + array_a_length);\n  array_b_ptr = array_a_end_ptr;\n  array_a_ptr = result_array_ptr;\n  if (array_a_end_ptr < array_b_limit_ptr) {\n    do {\n      array_b_start_ptr = array_b_ptr + 1;\n      array_a_length = (*array_b_ptr & 0xffff) + carry_extended;\n      carry_extended = ((int)array_a_length >> 0x10) + (*array_b_ptr >> 0x10);\n      carry = array_a_length & 0xffff | carry_extended * 0x10000;\n      *array_a_ptr = carry;\n      carry_extended = carry_extended >> 0x10;\n      array_b_ptr = array_b_start_ptr;\n      array_a_ptr = array_a_ptr + 1;\n    } while (array_b_start_ptr < array_b_limit_ptr);\n    result_array_ptr = (uint *)((int)result_array_ptr + ((int)array_b_limit_ptr + ~(uint)array_a_end_ptr & 0xfffffffc) + 4);\n  }\n  result_array_ptr = result_array_ptr + -1;\n  while (carry == 0) {\n    result_array_ptr = result_array_ptr + -1;\n    array_a_count = array_a_count - 1;\n    carry = *result_array_ptr;\n  }\n  *(uint *)(result + 0x10) = array_a_count;\n  return;\n}\n\n",
            "called": [
                "FUN_080090c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009530",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "compare_and_update_08009530"
        },
        "FUN_08008af8": {
            "renaming": {
                "FUN_08008af8": "allocate_memory_08008af8",
                "param_1": "ptr_size",
                "param_2": "size",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "puVar3": "ptr3",
                "uVar4": "var1",
                "uVar5": "var2",
                "puVar6": "ptr4",
                "iVar7": "var3",
                "puVar8": "ptr5",
                "uVar9": "var4",
                "uVar10": "var5",
                "puVar11": "ptr6",
                "puVar12": "ptr7",
                "puVar13": "ptr8",
                "uVar14": "var6",
                "uVar15": "var7",
                "iVar16": "var8",
                "puVar17": "ptr9",
                "puVar18": "ptr10"
            },
            "code": "\nint * allocate_memory_08008af8(undefined4 *ptr_size,uint size)\n\n{\n  undefined *ptr1;\n  undefined *ptr2;\n  undefined *ptr3;\n  uint var1;\n  uint var2;\n  uint *ptr4;\n  int var3;\n  undefined *ptr5;\n  uint var4;\n  uint var5;\n  undefined4 *ptr6;\n  undefined *ptr7;\n  undefined *ptr8;\n  uint var6;\n  uint var7;\n  int var8;\n  undefined4 *ptr9;\n  undefined4 *ptr10;\n  \n  var6 = size + 0xb;\n  if (var6 < 0x17) {\n    if (0x10 < size) goto LAB_08008c7a;\n    FUN_080090a8();\n    var7 = 0x10;\n    var3 = 0x18;\n    var6 = 2;\nLAB_08008b18:\n    ptr5 = PTR_DAT_08008e4c + var3;\n    ptr7 = *(undefined **)(ptr5 + 4);\n    if ((ptr7 != ptr5 + -8) || (ptr7 = *(undefined **)(ptr5 + 0xc), ptr5 != ptr7)) {\n      var3 = *(int *)(ptr7 + 0xc);\n      ptr5 = ptr7 + (*(uint *)(ptr7 + 4) & 0xfffffffc);\n      var6 = *(uint *)(ptr5 + 4);\nLAB_08008b34:\n      var8 = *(int *)(ptr7 + 8);\n      *(int *)(var8 + 0xc) = var3;\n      *(int *)(var3 + 8) = var8;\n      *(uint *)(ptr5 + 4) = var6 | 1;\n      FUN_080090b4(ptr_size);\n      return (int *)(ptr7 + 8);\n    }\n    var6 = var6 + 2;\n  }\n  else {\n    var7 = var6 & 0xfffffff8;\n    if (((int)var7 < 0) || (var7 < size)) {\nLAB_08008c7a:\n      *ptr_size = 0xc;\n      return (int *)0x0;\n    }\n    FUN_080090a8();\n    if (var7 < 0x1f8) {\n      var6 = var6 >> 3;\n      var3 = var7 + 8;\n      goto LAB_08008b18;\n    }\n    var1 = var6 >> 9;\n    if (var1 == 0) {\n      var3 = 0x200;\n      var4 = 0x40;\n      var1 = 0x3f;\n    }\n    else if (var1 < 5) {\n      var4 = (var6 >> 6) + 0x39;\n      var1 = (var6 >> 6) + 0x38;\n      var3 = var4 * 8;\n    }\n    else if (var1 < 0x15) {\n      var4 = var1 + 0x5c;\n      var1 = var1 + 0x5b;\n      var3 = var4 * 8;\n    }\n    else if (var1 < 0x55) {\n      var4 = (var6 >> 0xc) + 0x6f;\n      var1 = (var6 >> 0xc) + 0x6e;\n      var3 = var4 * 8;\n    }\n    else if (var1 < 0x155) {\n      var4 = (var6 >> 0xf) + 0x78;\n      var1 = (var6 >> 0xf) + 0x77;\n      var3 = var4 * 8;\n    }\n    else if (var1 < 0x555) {\n      var4 = (var6 >> 0x12) + 0x7d;\n      var1 = (var6 >> 0x12) + 0x7c;\n      var3 = var4 * 8;\n    }\n    else {\n      var3 = 0x3f8;\n      var4 = 0x7f;\n      var1 = 0x7e;\n    }\n    for (ptr7 = *(undefined **)(PTR_DAT_08008e4c + var3 + 4); var6 = var4,\n        PTR_DAT_08008e4c + var3 + -8 != ptr7; ptr7 = *(undefined **)(ptr7 + 0xc)) {\n      var8 = (*(uint *)(ptr7 + 4) & 0xfffffffc) - var7;\n      var6 = var1;\n      if (0xf < var8) break;\n      if (-1 < var8) {\n        ptr5 = ptr7 + (*(uint *)(ptr7 + 4) & 0xfffffffc);\n        var6 = *(uint *)(ptr5 + 4);\n        var3 = *(int *)(ptr7 + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  ptr5 = PTR_PTR_DAT_08008e60;\n  ptr7 = PTR_DAT_08008e4c;\n  ptr8 = *(undefined **)(PTR_DAT_08008e4c + 0x10);\n  if (ptr8 == PTR_PTR_DAT_08008e60) {\n    var1 = *(uint *)(PTR_DAT_08008e4c + 4);\n    var4 = 1 << ((int)var6 >> 2 & 0xffU);\n    if (var4 <= var1) goto LAB_08008c06;\n  }\n  else {\n    var4 = *(uint *)(ptr8 + 4);\n    var5 = var4 & 0xfffffffc;\n    var1 = var5 - var7;\n    if (0xf < (int)var1) {\n      ptr3 = ptr8 + var7;\n      *(uint *)(ptr8 + 4) = var7 | 1;\n      *(undefined **)(ptr7 + 0x10) = ptr3;\n      *(undefined **)(ptr7 + 0x14) = ptr3;\n      *(undefined **)(ptr3 + 8) = ptr5;\n      *(undefined **)(ptr3 + 0xc) = ptr5;\n      *(uint *)(ptr3 + 4) = var1 | 1;\n      *(uint *)(ptr8 + var5) = var1;\n      FUN_080090b4(ptr_size);\n      return (int *)(ptr8 + 8);\n    }\n    *(undefined **)(PTR_DAT_08008e4c + 0x10) = PTR_PTR_DAT_08008e60;\n    *(undefined **)(ptr7 + 0x14) = ptr5;\n    if (-1 < (int)var1) {\n      *(uint *)(ptr8 + var5 + 4) = *(uint *)(ptr8 + var5 + 4) | 1;\n      FUN_080090b4(ptr_size);\n      return (int *)(ptr8 + 8);\n    }\n    if (var5 < 0x200) {\n      var3 = (var4 >> 3) + 1;\n      var8 = *(int *)(ptr7 + var3 * 8);\n      var1 = 1 << ((int)(var4 >> 3) >> 2 & 0xffU) | *(uint *)(ptr7 + 4);\n      *(int *)(ptr8 + 8) = var8;\n      *(undefined **)(ptr8 + 0xc) = ptr7 + var3 * 8 + -8;\n      *(uint *)(ptr7 + 4) = var1;\n      *(undefined **)(ptr7 + var3 * 8) = ptr8;\n      *(undefined **)(var8 + 0xc) = ptr8;\n    }\n    else {\n      var1 = var4 >> 9;\n      if (var1 < 5) {\n        var3 = ((var4 >> 6) + 0x39) * 8;\n        var8 = (var4 >> 6) + 0x38;\n      }\n      else if (var1 < 0x15) {\n        var3 = (var1 + 0x5c) * 8;\n        var8 = var1 + 0x5b;\n      }\n      else if (var1 < 0x55) {\n        var3 = ((var4 >> 0xc) + 0x6f) * 8;\n        var8 = (var4 >> 0xc) + 0x6e;\n      }\n      else if (var1 < 0x155) {\n        var3 = ((var4 >> 0xf) + 0x78) * 8;\n        var8 = (var4 >> 0xf) + 0x77;\n      }\n      else if (var1 < 0x555) {\n        var3 = ((var4 >> 0x12) + 0x7d) * 8;\n        var8 = (var4 >> 0x12) + 0x7c;\n      }\n      else {\n        var3 = 0x3f8;\n        var8 = 0x7e;\n      }\n      ptr3 = *(undefined **)(ptr7 + var3);\n      ptr1 = ptr7 + var3 + -8;\n      if (ptr1 == ptr3) {\n        var1 = 1 << (var8 >> 2 & 0xffU) | *(uint *)(ptr7 + 4);\n        *(uint *)(ptr7 + 4) = var1;\n      }\n      else {\n        do {\n          if ((*(uint *)(ptr3 + 4) & 0xfffffffc) <= var5) break;\n          ptr3 = *(undefined **)(ptr3 + 8);\n        } while (ptr1 != ptr3);\n        ptr1 = *(undefined **)(ptr3 + 0xc);\n        var1 = *(uint *)(ptr7 + 4);\n      }\n      *(undefined **)(ptr8 + 8) = ptr3;\n      *(undefined **)(ptr8 + 0xc) = ptr1;\n      *(undefined **)(ptr1 + 8) = ptr8;\n      *(undefined **)(ptr3 + 0xc) = ptr8;\n    }\n    var4 = 1 << ((int)var6 >> 2 & 0xffU);\n    if (var4 <= var1) {\nLAB_08008c06:\n      if ((var4 & var1) == 0) {\n        var6 = var6 & 0xfffffffc;\n        do {\n          var4 = var4 << 1;\n          var6 = var6 + 4;\n        } while ((var4 & var1) == 0);\n      }\n      do {\n        ptr9 = (undefined4 *)(ptr7 + var6 * 8);\n        var1 = var6;\n        ptr10 = ptr9;\n        do {\n          for (ptr6 = (undefined4 *)ptr10[3]; ptr10 != ptr6;\n              ptr6 = (undefined4 *)ptr6[3]) {\n            var5 = ptr6[1] & 0xfffffffc;\n            var2 = var5 - var7;\n            if (0xf < (int)var2) {\n              var8 = ptr6[2];\n              var3 = ptr6[3];\n              ptr8 = (undefined *)(var7 + (int)ptr6);\n              ptr6[1] = var7 | 1;\n              *(int *)(var8 + 0xc) = var3;\n              *(int *)(var3 + 8) = var8;\n              *(undefined **)(ptr7 + 0x10) = ptr8;\n              *(undefined **)(ptr7 + 0x14) = ptr8;\n              *(undefined **)(ptr8 + 8) = ptr5;\n              *(undefined **)(ptr8 + 0xc) = ptr5;\n              *(uint *)(ptr8 + 4) = var2 | 1;\n              *(uint *)((int)ptr6 + var5) = var2;\n              FUN_080090b4(ptr_size);\n              return ptr6 + 2;\n            }\n            if (-1 < (int)var2) {\n              var3 = ptr6[3];\n              var8 = ptr6[2];\n              *(uint *)((int)ptr6 + var5 + 4) = *(uint *)((int)ptr6 + var5 + 4) | 1;\n              *(int *)(var8 + 0xc) = var3;\n              *(int *)(var3 + 8) = var8;\n              FUN_080090b4(ptr_size);\n              return ptr6 + 2;\n            }\n          }\n          var1 = var1 + 1;\n          ptr10 = ptr10 + 2;\n        } while ((var1 & 3) != 0);\n        do {\n          var5 = var6 & 3;\n          ptr10 = ptr9 + -2;\n          var6 = var6 - 1;\n          if (var5 == 0) {\n            var5 = *(uint *)(ptr7 + 4) & ~var4;\n            *(uint *)(ptr7 + 4) = var5;\n            goto LAB_08008f24;\n          }\n          ptr9 = (undefined4 *)*ptr9;\n        } while (ptr9 == ptr10);\n        var5 = *(uint *)(ptr7 + 4);\nLAB_08008f24:\n        var4 = var4 * 2;\n        if ((var5 <= var4 && var4 - var5 != 0) || (var6 = var1, var4 == 0)) break;\n        for (; (var4 & var5) == 0; var4 = var4 << 1) {\n          var6 = var6 + 4;\n        }\n      } while( true );\n    }\n  }\n  ptr5 = PTR_DAT_08008e64;\n  ptr8 = *(undefined **)(ptr7 + 8);\n  var6 = *(uint *)(ptr8 + 4) & 0xfffffffc;\n  if ((var7 <= var6) && (var1 = var6 - var7, 0xf < (int)var1)) goto LAB_08008dac;\n  if (*(int *)PTR_DAT_08008e64 == -1) {\n    var1 = var7 + *(int *)PTR_DAT_08008e50 + 0x10;\n  }\n  else {\n    var1 = var7 + *(int *)PTR_DAT_08008e50 + 0x100f & 0xfffff000;\n  }\n  ptr1 = (undefined *)FUN_08009744(ptr_size,var1);\n  ptr4 = (uint *)PTR_DAT_08009018;\n  ptr3 = PTR_DAT_08008e54;\n  if (ptr1 == (undefined *)0xffffffff) {\nLAB_08008ed8:\n    ptr8 = *(undefined **)(ptr7 + 8);\n    var6 = *(uint *)(ptr8 + 4);\n  }\n  else {\n    ptr2 = ptr8 + var6;\n    if (ptr2 < ptr1 || ptr2 == ptr1) {\n      var4 = *(int *)PTR_DAT_08008e54 + var1;\n      *(uint *)PTR_DAT_08008e54 = var4;\n      ptr4 = (uint *)ptr3;\n      if ((ptr2 != ptr1) || (((uint)ptr2 & 0xfff) != 0)) goto LAB_08008d02;\n      *(uint *)(*(int *)(ptr7 + 8) + 4) = var6 + var1 | 1;\n    }\n    else {\n      if (ptr8 != ptr7) goto LAB_08008ed8;\n      var4 = *(int *)PTR_DAT_08009018 + var1;\n      *(uint *)PTR_DAT_08009018 = var4;\nLAB_08008d02:\n      if (*(int *)ptr5 == -1) {\n        *(undefined **)ptr5 = ptr1;\n      }\n      else {\n        *ptr4 = (uint)(ptr1 + (var4 - (int)ptr2));\n      }\n      var4 = (uint)ptr1 & 7;\n      if (var4 == 0) {\n        var3 = 0x1000;\n      }\n      else {\n        ptr1 = ptr1 + (8 - var4);\n        var3 = 0x1008 - var4;\n      }\n      var3 = var3 - ((uint)(ptr1 + var1) & 0xfff);\n      var8 = FUN_08009744(ptr_size,var3);\n      if (var8 == -1) {\n        var1 = 1;\n        var3 = 0;\n      }\n      else {\n        var1 = (var8 - (int)ptr1) + var3 | 1;\n      }\n      var4 = *ptr4 + var3;\n      *(undefined **)(ptr7 + 8) = ptr1;\n      *ptr4 = var4;\n      *(uint *)(ptr1 + 4) = var1;\n      if (ptr8 != ptr7) {\n        if (var6 < 0x10) {\n          *(undefined4 *)(ptr1 + 4) = 1;\n          goto LAB_08008eee;\n        }\n        var6 = var6 - 0xc & 0xfffffff8;\n        *(uint *)(ptr8 + 4) = *(uint *)(ptr8 + 4) & 1 | var6;\n        *(undefined4 *)(ptr8 + var6 + 4) = 5;\n        *(undefined4 *)(ptr8 + var6 + 8) = 5;\n        if (0xf < var6) {\n          FUN_080088ec(ptr_size,ptr8 + 8);\n          var4 = *ptr4;\n        }\n      }\n    }\n    ptr5 = PTR_DAT_08008e5c;\n    ptr8 = *(undefined **)(ptr7 + 8);\n    var1 = *(uint *)PTR_DAT_08008e5c;\n    if (*(uint *)PTR_DAT_08008e58 < var4) {\n      *(uint *)PTR_DAT_08008e58 = var4;\n    }\n    var6 = *(uint *)(ptr8 + 4);\n    if (var1 < var4) {\n      *(uint *)ptr5 = var4;\n    }\n  }\n  var1 = (var6 & 0xfffffffc) - var7;\n  if ((var7 <= (var6 & 0xfffffffc)) && (0xf < (int)var1)) {\nLAB_08008dac:\n    *(uint *)(ptr8 + 4) = var7 | 1;\n    *(undefined **)(ptr7 + 8) = ptr8 + var7;\n    *(uint *)(ptr8 + var7 + 4) = var1 | 1;\n    FUN_080090b4(ptr_size);\n    return (int *)(ptr8 + 8);\n  }\nLAB_08008eee:\n  FUN_080090b4(ptr_size);\n  return (int *)0x0;\n}\n\n",
            "called": [
                "FUN_08009744",
                "FUN_080088ec",
                "FUN_080090a8",
                "FUN_080090b4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008af8",
            "calling": [
                "FUN_08009980",
                "FUN_08009adc",
                "FUN_08005e9c",
                "FUN_080097cc"
            ],
            "imported": false,
            "current_name": "allocate_memory_08008af8"
        },
        "FUN_08002bb4": {
            "renaming": {
                "FUN_08002bb4": "check_flag_set_08002bb4",
                "param_1": "flag_ptr",
                "param_2": "flag_length",
                "param_3": "offset",
                "iVar1": "result"
            },
            "code": "\nundefined4 check_flag_set_08002bb4(int *flag_ptr,uint flag_length,int offset)\n\n{\n  int result;\n  \n  while( true ) {\n    if ((*(uint *)(*flag_ptr + 0x14) & 0x80) == 0x80) {\n      return 0;\n    }\n    result = FUN_08002d3c(flag_ptr);\n    if (result != 0) break;\n    if ((flag_length != 0xffffffff) &&\n       ((flag_length == 0 || (result = FUN_080015a0(), flag_length < (uint)(result - offset))))) {\n      flag_ptr[0x10] = flag_ptr[0x10] | 0x20;\n      flag_ptr[0xc] = 0;\n      *(undefined *)((int)flag_ptr + 0x3d) = 0x20;\n      *(undefined *)(flag_ptr + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "called": [
                "FUN_080015a0",
                "FUN_08002d3c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002bb4",
            "calling": [
                "FUN_08002640",
                "FUN_08001ccc",
                "FUN_080027f4"
            ],
            "imported": false,
            "current_name": "check_flag_set_08002bb4"
        },
        "FUN_08002d3c": {
            "renaming": {
                "FUN_08002d3c": "check_bitfield_08002d3c",
                "param_1": "input_array",
                "bVar1": "is_bit_set",
                "param_1[0x10]": "status",
                "param_1[0xc]": "counter"
            },
            "code": "\nbool check_bitfield_08002d3c(int *input_array)\n\n{\n  bool is_bit_set;\n  \n  is_bit_set = (*(uint *)(*input_array + 0x14) & 0x400) == 0x400;\n  if (is_bit_set) {\n    *(undefined4 *)(*input_array + 0x14) = 0xfffffbff;\n    status = 4;\n    counter = 0;\n    *(undefined *)((int)input_array + 0x3d) = 0x20;\n    *(undefined *)(input_array + 0xf) = 0;\n  }\n  return is_bit_set;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d3c",
            "calling": [
                "FUN_08002c2e",
                "FUN_08002bb4"
            ],
            "imported": false,
            "current_name": "check_bitfield_08002d3c"
        },
        "FUN_08004bd8": {
            "renaming": {
                "FUN_08004bd8": "process_data_08004bd8",
                "param_1": "data_pointer",
                "param_2": "output_parameter",
                "uVar1": "result_1",
                "uVar2": "result_2",
                "uVar3": "result_3"
            },
            "code": "\nvoid process_data_08004bd8(int data_pointer,undefined4 *output_parameter)\n\n{\n  undefined4 result_1;\n  undefined8 result_2;\n  undefined8 result_3;\n  \n  result_1 = FUN_08000aa4(*(undefined4 *)(data_pointer + 0x10),*(undefined4 *)(data_pointer + 0x1c));\n  result_2 = FUN_08000418(*(undefined4 *)PTR_DAT_08004d60);\n  result_3 = FUN_08000418(result_1);\n  result_3 = FUN_080004c8((int)result_3,(int)((ulonglong)result_3 >> 0x20),DAT_08004d40,DAT_08004d44);\n  result_2 = FUN_0800015c((int)result_2,(int)((ulonglong)result_2 >> 0x20),(int)result_3,\n                       (int)((ulonglong)result_3 >> 0x20));\n  result_1 = FUN_080009fc((int)result_2,(int)((ulonglong)result_2 >> 0x20));\n  *(undefined4 *)PTR_DAT_08004d60 = result_1;\n  result_2 = FUN_08000418(*(undefined4 *)(data_pointer + 4));\n  result_2 = FUN_0800071c((int)result_2,(int)((ulonglong)result_2 >> 0x20),0,DAT_08004d64);\n  result_3 = FUN_08000418(*(undefined4 *)(data_pointer + 8));\n  result_3 = FUN_0800071c((int)result_3,(int)((ulonglong)result_3 >> 0x20),0,DAT_08004d64);\n  result_2 = thunk_FUN_08005838((int)result_2,(int)((ulonglong)result_2 >> 0x20),(int)result_3,\n                             (int)((ulonglong)result_3 >> 0x20));\n  result_2 = FUN_080004c8((int)result_2,(int)((ulonglong)result_2 >> 0x20),0,DAT_08004d68);\n  result_2 = FUN_0800071c((int)result_2,(int)((ulonglong)result_2 >> 0x20),DAT_08004d48,DAT_08004d4c);\n  result_3 = FUN_08000418(*(undefined4 *)(data_pointer + 0x24));\n  result_2 = FUN_08000158((int)result_2,(int)((ulonglong)result_2 >> 0x20),(int)result_3,\n                       (int)((ulonglong)result_3 >> 0x20));\n  result_2 = FUN_0800015c((int)result_2,(int)((ulonglong)result_2 >> 0x20),0,DAT_08004d6c);\n  result_1 = FUN_080009fc((int)result_2,(int)((ulonglong)result_2 >> 0x20));\n  if (*PTR_DAT_08004d70 == '\\0') {\n    result_2 = FUN_08000418(*(undefined4 *)PTR_DAT_08004d60);\n    result_2 = FUN_080004c8((int)result_2,(int)((ulonglong)result_2 >> 0x20),DAT_08004d50,DAT_08004d54);\n    result_3 = FUN_08000418(result_1);\n    result_3 = FUN_080004c8((int)result_3,(int)((ulonglong)result_3 >> 0x20),DAT_08004d58,DAT_08004d5c);\n    result_2 = FUN_0800015c((int)result_2,(int)((ulonglong)result_2 >> 0x20),(int)result_3,\n                         (int)((ulonglong)result_3 >> 0x20));\n    result_1 = FUN_080009fc((int)result_2,(int)((ulonglong)result_2 >> 0x20));\n    *(undefined4 *)PTR_DAT_08004d60 = result_1;\n  }\n  else {\n    *(undefined4 *)PTR_DAT_08004d60 = result_1;\n    *PTR_DAT_08004d70 = 0;\n  }\n  *output_parameter = *(undefined4 *)PTR_DAT_08004d60;\n  return;\n}\n\n",
            "called": [
                "FUN_08000aa4",
                "FUN_0800015c",
                "FUN_08000418",
                "FUN_08000158",
                "FUN_080009fc",
                "thunk_FUN_08005838",
                "FUN_080004c8",
                "FUN_0800071c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004bd8",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "process_data_08004bd8"
        },
        "FUN_080090c0": {
            "renaming": {
                "FUN_080090c0": "get_or_create_entry_080090c0",
                "param_1": "entry_list",
                "param_2": "index",
                "puVar1": "entry",
                "iVar2": "entry_list_ptr"
            },
            "code": "\nundefined4 * get_or_create_entry_080090c0(int entry_list,uint index)\n\n{\n  undefined4 *entry;\n  int entry_list_ptr;\n  \n  entry_list_ptr = *(int *)(entry_list + 0x4c);\n  if (entry_list_ptr == 0) {\n    entry_list_ptr = FUN_08009980(entry_list,4,0x21);\n    *(int *)(entry_list + 0x4c) = entry_list_ptr;\n    if (entry_list_ptr == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  entry = *(undefined4 **)(entry_list_ptr + index * 4);\n  if (entry == (undefined4 *)0x0) {\n    entry_list_ptr = 1 << (index & 0xff);\n    entry = (undefined4 *)FUN_08009980(entry_list,1,(entry_list_ptr + 5) * 4);\n    if (entry == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    entry[1] = index;\n    entry[2] = entry_list_ptr;\n  }\n  else {\n    *(undefined4 *)(entry_list_ptr + index * 4) = *entry;\n  }\n  entry[3] = 0;\n  entry[4] = 0;\n  return entry;\n}\n\n",
            "called": [
                "FUN_08009980"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090c0",
            "calling": [
                "FUN_08009258",
                "FUN_08009444",
                "FUN_08009244",
                "FUN_08009120",
                "FUN_08009530",
                "FUN_08009630",
                "FUN_080093a4",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "get_or_create_entry_080090c0"
        },
        "FUN_080091e4": {
            "renaming": {
                "FUN_080091e4": "count_leading_zeros_080091e4",
                "param_1": "num",
                "uVar1": "leading_zeros",
                "uVar2": "temp_num"
            },
            "code": "\nuint count_leading_zeros_080091e4(uint *num)\n\n{\n  uint leading_zeros;\n  uint temp_num;\n  \n  temp_num = *num;\n  leading_zeros = temp_num & 7;\n  if (leading_zeros == 0) {\n    if ((temp_num & 0xffff) == 0) {\n      temp_num = temp_num >> 0x10;\n      leading_zeros = 0x10;\n    }\n    if ((temp_num & 0xff) == 0) {\n      temp_num = temp_num >> 8;\n      leading_zeros = leading_zeros + 8;\n    }\n    if ((temp_num & 0xf) == 0) {\n      temp_num = temp_num >> 4;\n      leading_zeros = leading_zeros + 4;\n    }\n    if ((temp_num & 3) == 0) {\n      temp_num = temp_num >> 2;\n      leading_zeros = leading_zeros + 2;\n    }\n    if (-1 < (int)(temp_num << 0x1f)) {\n      temp_num = temp_num >> 1;\n      if (temp_num == 0) {\n        return 0x20;\n      }\n      leading_zeros = leading_zeros + 1;\n    }\n    *num = temp_num;\n    return leading_zeros;\n  }\n  if (-1 < (int)(temp_num << 0x1f)) {\n    if ((int)(temp_num << 0x1e) < 0) {\n      *num = temp_num >> 1;\n      return 1;\n    }\n    *num = temp_num >> 2;\n    return 2;\n  }\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091e4",
            "calling": [
                "FUN_08009630"
            ],
            "imported": false,
            "current_name": "count_leading_zeros_080091e4"
        },
        "FUN_080009fc": {
            "renaming": {
                "FUN_080009fc": "floating_point_to_integer_080009fc",
                "param_1": "floating_point_value",
                "param_2": "rounding_mode",
                "uVar1": "integer_value",
                "uVar2": "shifted_rounding_mode",
                "uVar3": "shifted_rounding_mode_plus_1",
                "in_r12": "temp_variable",
                "bVar4": "is_zero",
                "bVar5": "is_small_value"
            },
            "code": "\nuint floating_point_to_integer_080009fc(uint floating_point_value,uint rounding_mode)\n\n{\n  uint integer_value;\n  uint shifted_rounding_mode;\n  uint shifted_rounding_mode_plus_1;\n  uint temp_variable;\n  bool is_zero;\n  bool is_small_value;\n  \n  shifted_rounding_mode = rounding_mode * 2;\n  is_small_value = shifted_rounding_mode < 0x70000000;\n  shifted_rounding_mode_plus_1 = shifted_rounding_mode + 0x90000000;\n  integer_value = shifted_rounding_mode_plus_1;\n  if (!is_small_value) {\n    temp_variable = shifted_rounding_mode + 0x8fe00000;\n    integer_value = temp_variable;\n  }\n  is_zero = integer_value == 0;\n  if (!is_small_value && shifted_rounding_mode_plus_1 >= 0x200000) {\n    is_zero = temp_variable == 0x1fc00000;\n  }\n  if (((is_small_value || shifted_rounding_mode_plus_1 < 0x200000) || 0x1fc00000 < temp_variable) || is_zero) {\n    if ((rounding_mode & 0x40000000) != 0) {\n      if (((int)shifted_rounding_mode >> 0x15 == -1) && ((floating_point_value | rounding_mode << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return rounding_mode & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(shifted_rounding_mode + 0x92e00000) < 0 != SCARRY4(shifted_rounding_mode_plus_1,0x2e00000)) {\n      return rounding_mode & 0x80000000;\n    }\n    shifted_rounding_mode = 0x18 - (shifted_rounding_mode + 0x92e00000 >> 0x15);\n    integer_value = floating_point_value >> (shifted_rounding_mode & 0xff);\n    if (floating_point_value << (0x20 - shifted_rounding_mode & 0xff) != 0) {\n      integer_value = integer_value | 1;\n    }\n    shifted_rounding_mode_plus_1 = rounding_mode & 0x1fffff | 0x100000;\n    floating_point_value = integer_value | shifted_rounding_mode_plus_1 << (0x20 - shifted_rounding_mode & 0xff);\n    shifted_rounding_mode_plus_1 = (shifted_rounding_mode_plus_1 >> (shifted_rounding_mode & 0xff)) << 1;\n  }\n  integer_value = (rounding_mode & 0x80000000 | floating_point_value >> 0x1d) + shifted_rounding_mode_plus_1 * 4 + (uint)(0x7fffffff < floating_point_value * 8);\n  if (floating_point_value * 8 == 0x80000000) {\n    integer_value = integer_value & 0xfffffffe;\n  }\n  return integer_value;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009fc",
            "calling": [
                "FUN_08004d78",
                "FUN_08004bd8"
            ],
            "imported": false,
            "current_name": "floating_point_to_integer_080009fc"
        },
        "FUN_08000cb8": {
            "renaming": {
                "FUN_08000cb8": "calculate_float_08000cb8",
                "param_1": "first_num",
                "param_2": "second_num",
                "uVar2": "result",
                "uVar3": "first_num_shifted",
                "uVar6": "shifted_result",
                "uVar8": "temp_result",
                "iVar4": "shifted_sum",
                "iVar5": "shifted_difference",
                "iVar7": "shift_amount",
                "bVar9": "is_zero",
                "bVar10": "is_negative"
            },
            "code": "\nuint calculate_float_08000cb8(uint first_num,uint second_num,undefined4 param_3,uint param_4)\n\n{\n  longlong lVar1;\n  uint result;\n  uint first_num_shifted;\n  int shifted_sum;\n  int shifted_difference;\n  uint shifted_result;\n  int shift_amount;\n  uint temp_result;\n  bool is_zero;\n  bool is_negative;\n  \n  first_num_shifted = first_num >> 0x17 & 0xff;\n  is_zero = first_num_shifted == 0;\n  if (!is_zero) {\n    param_4 = second_num >> 0x17 & 0xff;\n    is_zero = param_4 == 0;\n  }\n  if (!is_zero) {\n    is_zero = first_num_shifted == 0xff;\n  }\n  if (!is_zero) {\n    is_zero = param_4 == 0xff;\n  }\n  if (is_zero) {\n    param_4 = second_num >> 0x17 & 0xff;\n    if (first_num_shifted == 0xff || param_4 == 0xff) {\n      is_zero = first_num == 0 || first_num == 0x80000000;\n      result = second_num;\n      if (first_num != 0 && first_num != 0x80000000) {\n        is_zero = second_num == 0;\n        result = first_num;\n      }\n      if (!is_zero) {\n        is_zero = second_num == 0x80000000;\n      }\n      temp_result = result;\n      if (((is_zero) || ((first_num_shifted == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((param_4 == 0xff && (temp_result = second_num, (second_num & 0x7fffff) != 0)))) {\n        return temp_result | 0x7fc00000;\n      }\n      result = result ^ second_num;\n      goto LAB_08000e08;\n    }\n    is_zero = (first_num & 0x7fffffff) == 0;\n    if (!is_zero) {\n      is_zero = (second_num & 0x7fffffff) == 0;\n    }\n    if (is_zero) {\n      return (first_num ^ second_num) & 0x80000000;\n    }\n    is_zero = first_num_shifted == 0;\n    result = first_num & 0x80000000;\n    while( true ) {\n      if (is_zero) {\n        first_num = first_num << 1;\n        is_zero = (first_num & 0x800000) == 0;\n      }\n      if (!is_zero) break;\n      first_num_shifted = first_num_shifted - 1;\n    }\n    first_num = first_num | result;\n    is_zero = param_4 == 0;\n    result = second_num & 0x80000000;\n    while( true ) {\n      if (is_zero) {\n        second_num = second_num << 1;\n        is_zero = (second_num & 0x800000) == 0;\n      }\n      if (!is_zero) break;\n      param_4 = param_4 - 1;\n    }\n    second_num = second_num | result;\n  }\n  shifted_sum = first_num_shifted + param_4;\n  temp_result = first_num ^ second_num;\n  first_num_shifted = first_num << 9;\n  is_zero = first_num_shifted == 0;\n  if (!is_zero) {\n    second_num = second_num << 9;\n    is_zero = second_num == 0;\n  }\n  if (is_zero) {\n    if (first_num_shifted == 0) {\n      second_num = second_num << 9;\n    }\n    result = temp_result & 0x80000000 | first_num & 0x7fffff | second_num >> 9;\n    is_negative = SBORROW4(shifted_sum,0x7f);\n    shifted_difference = shifted_sum + -0x7f;\n    is_zero = shifted_difference == 0;\n    shift_amount = shifted_difference;\n    if (!is_zero && 0x7e < shifted_sum) {\n      is_negative = SBORROW4(0xff,shifted_difference);\n      shift_amount = 0xff - shifted_difference;\n      is_zero = shifted_difference == 0xff;\n    }\n    if (!is_zero && shift_amount < 0 == is_negative) {\n      result = result | shifted_difference * 0x800000;\n    }\n    if (!is_zero && shift_amount < 0 == is_negative) {\n      return result;\n    }\n    result = result | 0x800000;\n    shifted_result = 0;\n    is_negative = SBORROW4(shifted_difference,1);\n    temp_result = shifted_sum - 0x80;\n    is_zero = temp_result == 0;\n    first_num_shifted = temp_result;\n  }\n  else {\n    lVar1 = (ulonglong)(first_num_shifted >> 5 | 0x8000000) * (ulonglong)(second_num >> 5 | 0x8000000);\n    shifted_result = (uint)lVar1;\n    result = (uint)((ulonglong)lVar1 >> 0x20);\n    is_zero = result < 0x800000;\n    if (is_zero) {\n      result = result << 1;\n    }\n    if (is_zero) {\n      result = result | shifted_result >> 0x1f;\n      shifted_result = shifted_result << 1;\n    }\n    result = temp_result & 0x80000000 | result;\n    temp_result = (shifted_sum + -0x7f) - (uint)is_zero;\n    is_negative = SBORROW4(temp_result,0xfd);\n    is_zero = temp_result == 0xfd;\n    first_num_shifted = temp_result - 0xfd;\n    if (temp_result < 0xfe) {\n      result = result + temp_result * 0x800000 + (uint)(0x7fffffff < shifted_result);\n      if (shifted_result == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (is_zero || (int)first_num_shifted < 0 != is_negative) {\n    is_zero = (int)(temp_result + 0x19) < 0;\n    if (temp_result == 0xffffffe7 || is_zero != SCARRY4(temp_result,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (temp_result != 0xffffffe7 && is_zero == SCARRY4(temp_result,0x19)) {\n      first_num_shifted = (result << 1) >> (-temp_result & 0xff);\n      temp_result = result << (temp_result + 0x20 & 0xff);\n      first_num_shifted = ((uint)((result & 0x80000000) != 0) << 0x1f | first_num_shifted >> 1) + (uint)((byte)first_num_shifted & 1);\n      if ((shifted_result | temp_result << 1) == 0) {\n        first_num_shifted = first_num_shifted & ~(temp_result >> 0x1f);\n      }\n      return first_num_shifted;\n    }\n    return result;\n  }\nLAB_08000e08:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000cb8",
            "calling": [
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "calculate_float_08000cb8"
        },
        "FUN_080093a4": {
            "renaming": {
                "FUN_080093a4": "decompress_data_080093a4",
                "param_1": "data_address",
                "param_2": "compressed_data",
                "param_3": "compressed_size",
                "iVar1": "index",
                "iVar2": "size_in_words",
                "puVar3": "decompressed_data",
                "puVar4": "node"
            },
            "code": "\nundefined4 * decompress_data_080093a4(int data_address,undefined4 *compressed_data,uint compressed_size)\n\n{\n  int index;\n  int size_in_words;\n  undefined4 *decompressed_data;\n  undefined4 *node;\n  \n  if ((compressed_size & 3) != 0) {\n    compressed_data = (undefined4 *)\n              FUN_08009120(data_address,compressed_data,\n                           *(undefined4 *)(PTR_DAT_08009440 + ((compressed_size & 3) - 1) * 4),0);\n  }\n  size_in_words = (int)compressed_size >> 2;\n  if (size_in_words != 0) {\n    node = *(undefined4 **)(data_address + 0x48);\n    if (node == (undefined4 *)0x0) {\n      node = (undefined4 *)FUN_080090c0(data_address,1);\n      node[4] = 1;\n      node[5] = 0x271;\n      *(undefined4 **)(data_address + 0x48) = node;\n      *node = 0;\n    }\n    decompressed_data = compressed_data;\n    if (size_in_words << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    size_in_words = size_in_words >> 1;\n    decompressed_data = node;\n    if (size_in_words != 0) {\n      while( true ) {\n        node = (undefined4 *)*decompressed_data;\n        if (node == (undefined4 *)0x0) {\n          node = (undefined4 *)FUN_08009258(data_address,decompressed_data,decompressed_data);\n          *decompressed_data = node;\n          *node = 0;\n        }\n        decompressed_data = compressed_data;\n        if (-1 < size_in_words << 0x1f) break;\nLAB_080093d2:\n        compressed_data = (undefined4 *)FUN_08009258(data_address,decompressed_data,node);\n        if (decompressed_data == (undefined4 *)0x0) break;\n        index = *(int *)(data_address + 0x4c);\n        size_in_words = size_in_words >> 1;\n        *decompressed_data = *(undefined4 *)(index + decompressed_data[1] * 4);\n        *(undefined4 **)(index + decompressed_data[1] * 4) = decompressed_data;\n        decompressed_data = node;\n        if (size_in_words == 0) {\n          return compressed_data;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return compressed_data;\n}\n\n",
            "called": [
                "FUN_08009258",
                "FUN_08009120",
                "FUN_080090c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080093a4",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "decompress_data_080093a4"
        },
        "FUN_080098c0": {
            "renaming": {
                "FUN_080098c0": "update_data_080098c0",
                "param_1": "update_type",
                "param_2": "data",
                "param_3": "value_1",
                "param_4": "value_2",
                "puVar1": "global_ptr",
                "uVar2": "return_val",
                "uVar3": "bitmask",
                "uVar4": "index",
                "iVar5": "data_ptr",
                "iVar6": "global_data_ptr",
                "iVar7": "new_index"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 update_data_080098c0(int update_type,undefined4 data,undefined4 value_1,undefined4 value_2)\n\n{\n  undefined *global_ptr;\n  undefined4 return_val;\n  uint bitmask;\n  uint index;\n  int data_ptr;\n  int global_data_ptr;\n  int new_index;\n  \n  global_ptr = PTR_PTR_DAT_08009974;\n  FUNC_08008af0(*(undefined4 *)PTR_PTR_DAT_08009974);\n  global_data_ptr = *(int *)PTR_PTR_DAT_08009978;\n  data_ptr = *(int *)(global_data_ptr + 0x148);\n  if (data_ptr == 0) {\n    data_ptr = global_data_ptr + 0x14c;\n    *(int *)(global_data_ptr + 0x148) = data_ptr;\n  }\n  index = *(uint *)(data_ptr + 4);\n  if ((int)index < 0x20) {\n    new_index = index + 1;\n  }\n  else {\n    if (DAT_0800997c == 0) {\n      FUNC_08008af4(*(undefined4 *)global_ptr);\n      return 0xffffffff;\n    }\n    data_ptr = 400;\n    index = 0;\n    _DAT_00000190 = *(undefined4 *)(global_data_ptr + 0x148);\n    new_index = 1;\n    _DAT_00000194 = 0;\n    *(undefined4 *)(global_data_ptr + 0x148) = 400;\n    _DAT_00000318 = 0;\n    _DAT_0000031c = 0;\n  }\n  if (update_type != 0) {\n    global_data_ptr = data_ptr + index * 4;\n    *(undefined4 *)(global_data_ptr + 0x88) = value_1;\n    bitmask = 1 << (index & 0xff);\n    *(uint *)(data_ptr + 0x188) = *(uint *)(data_ptr + 0x188) | bitmask;\n    *(undefined4 *)(global_data_ptr + 0x108) = value_2;\n    if (update_type == 2) {\n      *(uint *)(data_ptr + 0x18c) = bitmask | *(uint *)(data_ptr + 0x18c);\n    }\n  }\n  *(int *)(data_ptr + 4) = new_index;\n  return_val = *(undefined4 *)global_ptr;\n  *(undefined4 *)(data_ptr + (index + 2) * 4) = data;\n  FUNC_08008af4(return_val);\n  return 0;\n}\n\n",
            "called": [
                "FUN_08008af0",
                "FUN_08008af4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080098c0",
            "calling": [
                "FUN_080078a0"
            ],
            "imported": false,
            "current_name": "update_data_080098c0"
        },
        "FUN_08003c80": {
            "renaming": {
                "FUN_08003c80": "FUNC_08003c80"
            },
            "code": "\nvoid FUNC_08003c80(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003c80",
            "calling": [
                "FUN_080036f8"
            ],
            "imported": false,
            "current_name": "FUNC_08003c80"
        },
        "FUN_0800015c": {
            "renaming": {
                "FUN_0800015c": "binary_arithmetic_operation_0800015c",
                "param_1": "operand1",
                "param_2": "operand1_high",
                "param_3": "operand2",
                "param_4": "operand2_high",
                "iVar1": "operand2_high_shifted",
                "iVar6": "operand1_high_shifted",
                "bVar2": "bit",
                "bVar13": "is_same_operand",
                "bVar14": "condition",
                "bVar15": "is_overflow",
                "uVar3": "operand1_and_operand2_low",
                "uVar4": "operand2_high_shifted",
                "uVar5": "operand2_low",
                "uVar7": "operand1_low",
                "uVar8": "operand1",
                "uVar9": "operand2",
                "uVar10": "difference",
                "uVar11": "carry",
                "uVar12": "result",
                "count_leading_zeroes": "leading_zeroes_count",
                "CARRY4": "has_overflowed",
                "CONCAT44": "concatenate_64_bits",
                "SBORROW4": "has_subtraction_overflowed",
                "SCARRY4": "has_shift_overflowed"
            },
            "code": "\nulonglong binary_arithmetic_operation_0800015c(uint operand1,uint operand1_high,uint operand2,uint operand2_high)\n\n{\n  int operand2_high_shifted;\n  byte bit;\n  uint operand1_and_operand2_low;\n  uint operand2_high_shifted;\n  uint operand2_low;\n  int operand1_high_shifted;\n  uint operand1_low;\n  uint operand1;\n  uint operand2;\n  uint difference;\n  uint carry;\n  uint result;\n  bool is_same_operand;\n  bool condition;\n  bool is_overflow;\n  \n  operand1_low = operand1_high << 1;\n  operand2 = operand2_high << 1;\n  is_same_operand = ((operand1_high ^ operand2_high) & 0x7fffffff) == 0;\n  condition = is_same_operand && operand1 == operand2;\n  if (!is_same_operand || operand1 != operand2) {\n    condition = (operand1_low | operand1) == 0;\n  }\n  if (!condition) {\n    condition = (operand2 | operand2) == 0;\n  }\n  operand1_high_shifted = (int)operand1_low >> 0x15;\n  if (!condition) {\n    condition = operand1_high_shifted == -1;\n  }\n  operand2_high_shifted = (int)operand2 >> 0x15;\n  if (!condition) {\n    condition = operand2_high_shifted == -1;\n  }\n  if (condition) {\n    if (operand1_high_shifted == -1 || operand2_high_shifted == -1) {\n      operand2 = operand2_high;\n      operand1_low = operand2;\n      if (operand1_high_shifted == -1) {\n        operand2 = operand1_high;\n        operand1_low = operand1;\n      }\n      if (operand1_high_shifted != -1 || operand2_high_shifted != -1) {\n        operand2 = operand1_low;\n        operand2_high = operand2;\n      }\n      condition = (operand1_low | operand2 << 0xc) == 0;\n      if (condition) {\n        condition = (operand2 | operand2_high << 0xc) == 0;\n      }\n      if (condition) {\n        condition = operand2 == operand2_high;\n      }\n      if (!condition) {\n        operand2 = operand2 | 0x80000;\n      }\n      return concatenate_64_bits(operand2,operand1_low);\n    }\n    if (((operand1_high ^ operand2_high) & 0x7fffffff) != 0 || operand1 != operand2) {\n      if ((operand1_low | operand1) == 0) {\n        operand1 = operand2;\n        operand1_high = operand2_high;\n      }\n      return concatenate_64_bits(operand1_high,operand1);\n    }\n    if (operand1_high != operand2_high) {\n      return 0;\n    }\n    if (operand1_low >> 0x15 == 0) {\n      condition = (operand1 & 0x80000000) != 0;\n      operand2 = operand1_high * 2 + (uint)condition;\n      if (has_overflowed(operand1_high,operand1_high) || has_overflowed(operand1_high * 2,(uint)condition)) {\n        operand2 = operand2 | 0x80000000;\n      }\n      return concatenate_64_bits(operand2,operand1 << 1);\n    }\n    if (operand1_low < 0xffc00000) {\n      return concatenate_64_bits(operand1_high + 0x100000,operand1);\n    }\n    operand1_high = operand1_high & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(operand1_high | 0x7ff00000) << 0x20;\n  }\n  operand1_low = operand1_low >> 0x15;\n  operand2 = operand2 >> 0x15;\n  difference = operand2 - operand1_low;\n  condition = difference != 0;\n  if (operand2 < operand1_low) {\n    difference = -difference;\n  }\n  operand1 = operand1;\n  operand2_low = operand1_high;\n  if (condition && operand1_low <= operand2) {\n    operand1_low = operand1_low + difference;\n    operand1 = operand2;\n    operand2_low = operand2_high;\n    operand2 = operand1;\n    operand2_high = operand1_high;\n  }\n  if (0x36 < difference) {\n    return concatenate_64_bits(operand2_low,operand1);\n  }\n  operand2 = operand2_low & 0xfffff | 0x100000;\n  if ((operand2_low & 0x80000000) != 0) {\n    condition = operand1 != 0;\n    operand1 = -operand1;\n    operand2 = -operand2 - (uint)condition;\n  }\n  operand2_low = operand2_high & 0xfffff | 0x100000;\n  if ((operand2_high & 0x80000000) != 0) {\n    condition = operand2 != 0;\n    operand2 = -operand2;\n    operand2_low = -operand2_low - (uint)condition;\n  }\n  if (operand1_low == difference) {\n    operand2_low = operand2_low ^ 0x100000;\n    if (operand1_low == 0) {\n      operand2 = operand2 ^ 0x100000;\n      operand1_low = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  result = -difference + 0x20;\n  if ((int)difference < 0x21) {\n    carry = operand2 << (result & 0xff);\n    operand2 = operand2 >> (difference & 0xff);\n    operand1_and_operand2_low = operand1 + operand2;\n    operand2_high_shifted = operand2_low << (result & 0xff);\n    result = operand1_and_operand2_low + operand2_high_shifted;\n    operand2 = operand2 + has_overflowed(operand1,operand2) + ((int)operand2_low >> (difference & 0xff)) +\n            (uint)has_overflowed(operand1_and_operand2_low,operand2_high_shifted);\n  }\n  else {\n    carry = operand2_low << (-difference + 0x40 & 0xff);\n    if (operand2 != 0) {\n      carry = carry | 2;\n    }\n    operand2_low = (int)operand2_low >> (difference - 0x20 & 0xff);\n    result = operand1 + operand2_low;\n    operand2 = operand2 + ((int)operand2_low >> 0x1f) + (uint)has_overflowed(operand1,operand2_low);\n  }\n  operand1_high = operand2 & 0x80000000;\n  difference = operand2;\n  if ((int)operand2 < 0) {\n    condition = carry == 0;\n    carry = -carry;\n    difference = -result;\n    result = -(uint)!condition - result;\n    difference = -(uint)(condition <= difference) - operand2;\n  }\n  if (0xfffff < difference) {\n    operand1 = operand1_low - 1;\n    if (0x1fffff < difference) {\n      operand2 = difference & 1;\n      difference = difference >> 1;\n      bit = (byte)result;\n      result = (uint)(operand2 != 0) << 0x1f | result >> 1;\n      carry = (uint)(bit & 1) << 0x1f | carry >> 1;\n      operand1 = operand1_low;\n      if (0xffbfffff < operand1_low * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    condition = 0x7fffffff < carry;\n    if (carry == 0x80000000) {\n      condition = (result & 1) != 0;\n    }\n    return concatenate_64_bits(difference + operand1 * 0x100000 + (uint)has_overflowed(result,(uint)condition) | operand1_high,\n                    result + condition);\n  }\n  is_same_operand = (carry & 0x80000000) != 0;\n  carry = carry << 1;\n  operand1 = result * 2;\n  condition = has_overflowed(result,result);\n  result = result * 2 + (uint)is_same_operand;\n  difference = difference * 2 + (uint)(condition || has_overflowed(operand1,(uint)is_same_operand));\n  operand1 = operand1_low - 2;\n  if ((difference & 0x100000) != 0) goto LAB_08000268;\n  operand2_low = result;\n  operand1_low = difference;\n  if (difference == 0) {\n    operand2_low = 0;\n    operand1_low = result;\n  }\n  operand1_high_shifted = leading_zeroes_count(operand1_low);\n  if (difference == 0) {\n    operand1_high_shifted = operand1_high_shifted + 0x20;\n  }\n  result = operand1_high_shifted - 0xb;\n  is_overflow = has_subtraction_overflowed(result,0x20);\n  difference = operand1_high_shifted - 0x2b;\n  condition = (int)difference < 0;\n  is_same_operand = difference == 0;\n  if ((int)result < 0x20) {\n    is_overflow = has_shift_overflowed(difference,0xc);\n    operand1_high_shifted = operand1_high_shifted + -0x1f;\n    condition = operand1_high_shifted < 0;\n    is_same_operand = operand1_high_shifted == 0;\n    difference = result;\n    if (!is_same_operand && condition == is_overflow) {\n      operand2_low = operand1_low << (result & 0xff);\n      operand1_low = operand1_low >> (0xcU - operand1_high_shifted & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_same_operand || condition != is_overflow) {\n    carry = 0x20 - difference;\n  }\n  operand1_low = operand1_low << (difference & 0xff);\n  if (is_same_operand || condition != is_overflow) {\n    operand1_low = operand1_low | operand2_low >> (carry & 0xff);\n  }\n  if (is_same_operand || condition != is_overflow) {\n    operand2_low = operand2_low << (difference & 0xff);\n  }\nLAB_080002e0:\n  if ((int)result <= (int)operand1) {\n    return concatenate_64_bits(operand1_low + (operand1 - result) * 0x100000 | operand1_high,operand2_low);\n  }\n  difference = ~(operand1 - result);\n  if ((int)difference < 0x1f) {\n    operand1_high_shifted = difference - 0x13;\n    if (operand1_high_shifted != 0 && operand1_high_shifted < 0 == has_shift_overflowed(difference - 0x1f,0xc)) {\n      return concatenate_64_bits(operand2,operand2_low >> (0x20 - (0xcU - operand1_high_shifted) & 0xff) | operand1_low << (0xcU - operand1_high_shifted & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    difference = difference + 1;\n    return concatenate_64_bits(operand1_high | operand1_low >> (difference & 0xff),\n                    operand2_low >> (difference & 0xff) | operand1_low << (0x20 - difference & 0xff));\n  }\n  return concatenate_64_bits(operand2,operand1_low >> (difference - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800015c",
            "calling": [
                "FUN_08005838",
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "binary_arithmetic_operation_0800015c"
        },
        "FUN_080027f4": {
            "renaming": {
                "FUN_080027f4": "verify_and_send_data_080027f4",
                "param_1": "data_ptr",
                "param_2": "data_type",
                "param_3": "data_value",
                "param_4": "is_value_16_bit",
                "param_5": "max_wait_time",
                "param_6": "start_time",
                "iVar1": "result",
                "uVar2": "return_value"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nundefined4\nverify_and_send_data_080027f4(uint **data_ptr,byte data_type,undefined2 data_value,short is_value_16_bit,uint max_wait_time,int start_time)\n\n{\n  int result;\n  undefined4 return_value;\n  \n  **data_ptr = **data_ptr | 0x400;\n  **data_ptr = **data_ptr | 0x100;\n  do {\n    if ((~(*data_ptr)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_080028d2;\n    }\n  } while ((max_wait_time == 0xffffffff) ||\n          ((max_wait_time != 0 && (result = FUN_080015a0(), (uint)(result - start_time) <= max_wait_time))));\n  data_ptr[0xc] = (uint *)0x0;\n  *(undefined *)((int)data_ptr + 0x3d) = 0x20;\n  *(undefined *)((int)data_ptr + 0x3e) = 0;\n  *(undefined *)(data_ptr + 0xf) = 0;\n  result = 3;\nLAB_080028d2:\n  if (result == 0) {\n    (*data_ptr)[4] = data_type & 0xfe;\n    result = FUN_08002ad8(data_ptr,DAT_08002ad4,max_wait_time,start_time);\n    if (result == 0) {\n      result = FUN_08002bb4(data_ptr,max_wait_time,start_time,(*data_ptr)[6]);\n      if (result == 0) {\n        if (is_value_16_bit == 1) {\n          (*data_ptr)[4] = (uint)(byte)data_value;\n        }\n        else {\n          (*data_ptr)[4] = (uint)(byte)((ushort)data_value >> 8);\n          result = FUN_08002bb4(data_ptr,max_wait_time,start_time);\n          if (result != 0) {\n            if (data_ptr[0x10] == (uint *)0x4) {\n              **data_ptr = **data_ptr | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*data_ptr)[4] = (uint)(byte)data_value;\n        }\n        result = FUN_08002bb4(data_ptr,max_wait_time,start_time);\n        if (result == 0) {\n          **data_ptr = **data_ptr | 0x100;\n          do {\n            if ((~(*data_ptr)[5] & 1) == 0) {\n              result = 0;\n              goto LAB_08002a90;\n            }\n          } while ((max_wait_time == 0xffffffff) ||\n                  ((max_wait_time != 0 && (result = FUN_080015a0(), (uint)(result - start_time) <= max_wait_time))));\n          data_ptr[0xc] = (uint *)0x0;\n          *(undefined *)((int)data_ptr + 0x3d) = 0x20;\n          *(undefined *)((int)data_ptr + 0x3e) = 0;\n          *(undefined *)(data_ptr + 0xf) = 0;\n          result = 3;\nLAB_08002a90:\n          if (result == 0) {\n            (*data_ptr)[4] = (uint)(data_type | 1);\n            result = FUN_08002ad8(data_ptr,DAT_08002ad4,max_wait_time,start_time);\n            if (result == 0) {\n              return_value = 0;\n            }\n            else if (data_ptr[0x10] == (uint *)0x4) {\n              return_value = 1;\n            }\n            else {\n              return_value = 3;\n            }\n          }\n          else {\n            return_value = 3;\n          }\n        }\n        else if (data_ptr[0x10] == (uint *)0x4) {\n          **data_ptr = **data_ptr | 0x200;\n          return_value = 1;\n        }\n        else {\n          return_value = 3;\n        }\n      }\n      else if (data_ptr[0x10] == (uint *)0x4) {\n        **data_ptr = **data_ptr | 0x200;\n        return_value = 1;\n      }\n      else {\n        return_value = 3;\n      }\n    }\n    else if (data_ptr[0x10] == (uint *)0x4) {\n      return_value = 1;\n    }\n    else {\n      return_value = 3;\n    }\n  }\n  else {\n    return_value = 3;\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_080015a0",
                "FUN_08002ad8",
                "FUN_08002bb4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080027f4",
            "calling": [
                "FUN_08001f6c"
            ],
            "imported": false,
            "current_name": "verify_and_send_data_080027f4"
        },
        "FUN_080003d4": {
            "renaming": {
                "FUN_080003d4": "bit_shift_concatenate_080003d4",
                "param_1": "input_num",
                "uVar1": "upper_bits",
                "uVar2": "shift_amount",
                "iVar3": "leading_zeroes",
                "uVar4": "shift_amount_plus",
                "in_r12": "remaining_bits",
                "bVar5": "shift_amount_negative",
                "bVar6": "shift_amount_zero",
                "bVar7": "shift_amount_overflow"
            },
            "code": "\nulonglong bit_shift_concatenate_080003d4(uint input_num)\n\n{\n  uint upper_bits;\n  uint shift_amount;\n  int leading_zeroes;\n  uint shift_amount_plus;\n  uint remaining_bits;\n  bool shift_amount_negative;\n  bool shift_amount_zero;\n  bool shift_amount_overflow;\n  \n  if (input_num == 0) {\n    return 0;\n  }\n  upper_bits = 0;\n  leading_zeroes = count_leading_zeroes(input_num);\n  shift_amount_plus = leading_zeroes + 0x15;\n  shift_amount_overflow = SBORROW4(shift_amount_plus,0x20);\n  shift_amount = leading_zeroes - 0xb;\n  shift_amount_negative = (int)shift_amount < 0;\n  shift_amount_zero = shift_amount == 0;\n  if ((int)shift_amount_plus < 0x20) {\n    shift_amount_overflow = SCARRY4(shift_amount,0xc);\n    leading_zeroes = leading_zeroes + 1;\n    shift_amount_negative = leading_zeroes < 0;\n    shift_amount_zero = leading_zeroes == 0;\n    shift_amount = shift_amount_plus;\n    if (!shift_amount_zero && shift_amount_negative == shift_amount_overflow) {\n      upper_bits = input_num << (shift_amount_plus & 0xff);\n      input_num = input_num >> (0xcU - leading_zeroes & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (shift_amount_zero || shift_amount_negative != shift_amount_overflow) {\n    remaining_bits = 0x20 - shift_amount;\n  }\n  input_num = input_num << (shift_amount & 0xff);\n  if (shift_amount_zero || shift_amount_negative != shift_amount_overflow) {\n    input_num = input_num | 0U >> (remaining_bits & 0xff);\n  }\n  if (shift_amount_zero || shift_amount_negative != shift_amount_overflow) {\n    upper_bits = 0 << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shift_amount_plus < 0x433) {\n    return CONCAT44(input_num + (0x432 - shift_amount_plus) * 0x100000,upper_bits);\n  }\n  shift_amount = ~(0x432 - shift_amount_plus);\n  if (0x1e < (int)shift_amount) {\n    return (ulonglong)(input_num >> (shift_amount - 0x1f & 0xff));\n  }\n  leading_zeroes = shift_amount - 0x13;\n  if (leading_zeroes == 0 || leading_zeroes < 0 != SCARRY4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(input_num >> (shift_amount & 0xff),\n                    upper_bits >> (shift_amount & 0xff) | input_num << (0x20 - shift_amount & 0xff));\n  }\n  return (ulonglong)(upper_bits >> (0x20 - (0xcU - leading_zeroes) & 0xff) | input_num << (0xcU - leading_zeroes & 0xff));\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080003d4",
            "calling": [
                "FUN_080079e8"
            ],
            "imported": false,
            "current_name": "bit_shift_concatenate_080003d4"
        },
        "FUN_08004d78": {
            "renaming": {
                "FUN_08004d78": "calculate_result_08004d78",
                "param_1": "inputs",
                "param_2": "output_1",
                "param_3": "output_2",
                "uVar1": "input_1_float",
                "uVar2": "input_2_float",
                "uVar3": "input_3_float",
                "uVar4": "temp_result_1",
                "uVar5": "temp_result_2"
            },
            "code": "\nvoid calculate_result_08004d78(undefined4 *inputs,undefined4 *output_1,undefined4 *output_2)\n\n{\n  undefined4 input_1_float;\n  undefined4 input_2_float;\n  undefined4 input_3_float;\n  undefined8 temp_result_1;\n  undefined8 temp_result_2;\n  \n  input_1_float = FUN_08000e20(*inputs,0x45800000);\n  input_2_float = FUN_08000e20(inputs[1],0x45800000);\n  input_3_float = FUN_08000e20(inputs[2],0x45800000);\n  temp_result_1 = FUN_08000418(input_2_float);\n  temp_result_2 = FUN_08000418(input_3_float);\n  temp_result_1 = thunk_FUN_08005838((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),(int)temp_result_2,\n                             (int)((ulonglong)temp_result_2 >> 0x20));\n  temp_result_1 = FUN_080004c8((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0,DAT_08004e68);\n  temp_result_1 = FUN_0800071c((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),DAT_08004e60,DAT_08004e64);\n  input_2_float = FUN_080009fc((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20));\n  temp_result_1 = FUN_08000418(input_1_float);\n  temp_result_2 = FUN_08000418(input_3_float);\n  temp_result_1 = thunk_FUN_08005838((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),(int)temp_result_2,\n                             (int)((ulonglong)temp_result_2 >> 0x20));\n  temp_result_1 = FUN_080004c8((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0,DAT_08004e68);\n  temp_result_1 = FUN_0800071c((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),DAT_08004e60,DAT_08004e64);\n  input_1_float = FUN_080009fc((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20));\n  *output_1 = input_2_float;\n  *output_2 = input_1_float;\n  return;\n}\n\n",
            "called": [
                "FUN_08000e20",
                "FUN_08000418",
                "thunk_FUN_08005838",
                "FUN_080009fc",
                "FUN_080004c8",
                "FUN_0800071c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d78",
            "calling": [
                "FUN_080049cc"
            ],
            "imported": false,
            "current_name": "calculate_result_08004d78"
        },
        "FUN_08000c10": {
            "renaming": {
                "FUN_08000c10": "calculate_integer_hash_08000c10",
                "param_1": "input_integer",
                "iVar1": "leading_zeroes_count",
                "uVar2": "shift_amount",
                "iVar4": "hash_value",
                "uVar3": "result",
                "uVar5": "overflow_check"
            },
            "code": "\nuint calculate_integer_hash_08000c10(uint input_integer)\n\n{\n  int leading_zeroes_count;\n  uint shift_amount;\n  uint result;\n  int hash_value;\n  uint overflow_check;\n  \n  result = input_integer & 0x80000000;\n  if ((int)result < 0) {\n    input_integer = -input_integer;\n  }\n  if (input_integer == 0) {\n    return 0;\n  }\n  leading_zeroes_count = count_leading_zeroes(input_integer);\n  shift_amount = leading_zeroes_count - 8;\n  hash_value = ((result | 0x4b000000) - 0x800000) + shift_amount * -0x800000;\n  if (7 < leading_zeroes_count) {\n    overflow_check = 0 << (shift_amount & 0xff);\n    result = hash_value + (input_integer << (shift_amount & 0xff)) +\n            (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < overflow_check);\n    if (overflow_check == 0x80000000) {\n      result = result & 0xfffffffe;\n    }\n    return result;\n  }\n  shift_amount = input_integer << (leading_zeroes_count + 0x18U & 0xff);\n  result = hash_value + ((input_integer >> (0x20 - (leading_zeroes_count + 0x18U) & 0xff)) - ((int)shift_amount >> 0x1f));\n  if ((shift_amount & 0x7fffffff) == 0) {\n    result = result & ~(shift_amount >> 0x1f);\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c10",
            "calling": [
                "FUN_08004ae0",
                "FUN_080049cc",
                "FUN_08004f78"
            ],
            "imported": false,
            "current_name": "calculate_integer_hash_08000c10"
        },
        "FUN_0800491c": {
            "renaming": {
                "FUN_0800491c": "initialize_memory_0800491c",
                "param_1": "memory_array",
                "local_13": "zero_byte",
                "local_12": "ten_byte",
                "local_11": "eight_byte_array"
            },
            "code": "\nvoid initialize_memory_0800491c(undefined4 *memory_array)\n\n{\n  undefined zero_byte;\n  undefined ten_byte;\n  undefined eight_byte_array [5];\n  \n  zero_byte = 0;\n  (**(code **)PTR_DAT_080049c8)(0xd0,0x6b,&zero_byte,1);\n  ten_byte = 0x10;\n  (**(code **)PTR_DAT_080049c8)(0xd0,0x1c,&ten_byte,1);\n  eight_byte_array[0] = 8;\n  (**(code **)PTR_DAT_080049c8)(0xd0,0x1b,eight_byte_array,1);\n  *memory_array = 0;\n  memory_array[1] = 0;\n  memory_array[2] = 0;\n  memory_array[3] = 0;\n  memory_array[4] = 0;\n  memory_array[5] = 0;\n  memory_array[6] = 0;\n  memory_array[7] = 0;\n  memory_array[8] = 0;\n  memory_array[9] = 0;\n  memory_array[10] = 0;\n  FUN_080049cc(memory_array);\n  return;\n}\n\n",
            "called": [
                "FUN_080049cc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800491c",
            "calling": [
                "FUN_08005224"
            ],
            "imported": false,
            "current_name": "initialize_memory_0800491c"
        },
        "FUN_080078a0": {
            "renaming": {
                "FUN_080078a0": "check_data_and_call_function_080078a0"
            },
            "code": "\nvoid check_data_and_call_function_080078a0(void)\n\n{\n  if (DAT_080078ac != 0) {\n    FUN_080098c0(0,PTR_LAB_08008818_1_080078b0,0);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_080098c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078a0",
            "calling": [
                "FUN_08005d20"
            ],
            "imported": false,
            "current_name": "check_data_and_call_function_080078a0"
        },
        "FUN_080057e8": {
            "renaming": {
                "FUN_080057e8": "copy_and_clear_memory_080057e8",
                "iVar1": "index",
                "puVar2": "dest_ptr",
                "UNRECOVERED_JUMPTABLE": "jump_table"
            },
            "code": "\nvoid copy_and_clear_memory_080057e8(void)\n\n{\n  int index;\n  undefined4 *dest_ptr;\n  code *jump_table;\n  \n  for (index = 0; dest_ptr = (undefined4 *)PTR_DAT_08005828,\n      PTR_DAT_08005820 + index < PTR_DAT_08005824; index = index + 4) {\n    *(undefined4 *)(PTR_DAT_08005820 + index) = *(undefined4 *)(DAT_0800581c + index);\n  }\n  for (; dest_ptr < PTR_DAT_0800582c; dest_ptr = dest_ptr + 1) {\n    *dest_ptr = 0;\n  }\n  FUN_08005780();\n  FUN_08005d20();\n  jump_table = (code *)0x800581a;\n  FUN_08005224();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jump_table)();\n  return;\n}\n\n",
            "called": [
                "FUN_08005224",
                "FUN_08005780",
                "FUN_08005d20"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080057e8",
            "calling": [],
            "imported": false,
            "current_name": "copy_and_clear_memory_080057e8"
        }
    },
    "used_tokens": 203590,
    "layers": [
        [
            "FUN_0800071c",
            "FUN_080036a8",
            "FUN_080088ec",
            "FUN_08005224",
            "FUN_08003440",
            "FUN_08004f2c",
            "FUN_08005348",
            "FUN_080046ec",
            "FUN_08005500",
            "FUN_08002c2e",
            "FUN_08003568",
            "FUN_080049cc",
            "FUN_08003c94",
            "FUN_08000978",
            "FUN_0800884c",
            "FUN_0800901c",
            "FUN_0800177c",
            "FUN_080017b4",
            "FUN_08005598",
            "FUN_08001030",
            "FUN_080011ec",
            "FUN_08004f3c",
            "FUN_08009adc",
            "FUN_08002640",
            "FUN_080008fc",
            "FUN_08000988",
            "FUN_08001714",
            "FUN_08005dfc",
            "FUN_080078c0",
            "thunk_FUN_08005838",
            "FUN_080003f4",
            "FUN_080079e8",
            "FUN_0800166c",
            "FUN_0800360c",
            "FUN_08005d68",
            "FUN_080017c4",
            "FUN_080035a4",
            "FUN_080041ea",
            "FUN_08004ae0",
            "FUN_08001044",
            "FUN_08009444",
            "FUN_080015fc",
            "FUN_08004436",
            "FUN_08000110",
            "FUN_08003504",
            "FUN_08000aa4",
            "FUN_08004ee8",
            "FUN_080094f8",
            "FUN_08000998",
            "FUN_08000aa8",
            "FUN_080009ac",
            "FUN_08000fc8",
            "FUN_0800438a",
            "FUN_080014f0",
            "FUN_08003908",
            "FUN_08004f60",
            "FUN_080009c0",
            "FUN_08001170",
            "FUN_08003f18",
            "FUN_080097cc",
            "FUN_08001f6c",
            "FUN_08002ad8",
            "FUN_08000fd0",
            "FUN_08003d60",
            "FUN_08003518",
            "FUN_08001618",
            "FUN_080091a4",
            "FUN_08004f78",
            "FUN_080015a0",
            "FUN_08002d98",
            "FUN_0800172a",
            "FUN_080009d4",
            "FUN_08005780",
            "FUN_08009744",
            "FUN_08003640",
            "FUN_08009980",
            "FUN_08000134",
            "FUN_08005704",
            "FUN_08000418",
            "FUN_08002ca8",
            "FUN_08003a94",
            "FUN_0800416a",
            "FUN_080055f4",
            "FUN_080059f0",
            "FUN_080053b0",
            "FUN_0800088a",
            "FUN_080016d0",
            "FUN_08001ccc",
            "FUN_0800157c",
            "FUN_08000e20",
            "FUN_0800121c",
            "FUN_08005d14",
            "FUN_080015b4",
            "FUN_080036f8",
            "FUN_080041a8",
            "FUN_080004c8",
            "FUN_08008ad4",
            "FUN_080009e8",
            "FUN_08005674",
            "FUN_08009630",
            "FUN_08004104",
            "FUN_08000ff4",
            "FUN_08005714",
            "FUN_08005e40",
            "FUN_08005d20",
            "FUN_08001a80",
            "FUN_08005838",
            "FUN_080090a8",
            "FUN_08004e74",
            "FUN_080096e0",
            "FUN_0800910c",
            "FUN_080052a0",
            "FUN_08009120",
            "FUN_08001084",
            "FUN_08005680",
            "FUN_08003260",
            "FUN_08001ab0",
            "FUN_08003540",
            "FUN_08009244",
            "FUN_08004e6c",
            "FUN_08001762",
            "FUN_08000158",
            "FUN_08009768",
            "FUN_08003ff8",
            "FUN_08004ea4",
            "FUN_080040a0",
            "FUN_08009a18",
            "FUN_0800119c",
            "FUN_08005728",
            "FUN_080090b4",
            "FUN_0800422e",
            "FUN_08003e38",
            "FUN_0800151c",
            "FUN_080006a4",
            "FUN_08000f68",
            "FUN_08009258",
            "FUN_08000c08",
            "FUN_080042de",
            "FUN_08009530",
            "FUN_08008af8",
            "FUN_08002bb4",
            "FUN_08002d3c",
            "FUN_08004bd8",
            "FUN_080090c0",
            "FUN_080091e4",
            "FUN_080009fc",
            "FUN_08000cb8",
            "FUN_080093a4",
            "FUN_080098c0",
            "FUN_0800015c",
            "FUN_080027f4",
            "FUN_080003d4",
            "FUN_08004d78",
            "FUN_08000c10",
            "FUN_0800491c",
            "FUN_080078a0",
            "FUN_080057e8"
        ]
    ],
    "locked_functions": []
}