{
    "functions": {
        "FUN_080006b4": {
            "renaming": {
                "FUN_080006b4": "readModbusData_080006b4",
                "this": "modbusInstance",
                "bVar1": "bufferOverflow",
                "iVar2": "character",
                "bVar3": "bufferIndex",
                "u8txenpin": "transmitEnablePin",
                "digitalWrite": "setPinState",
                "u8BufferSize": "bufferSize",
                "u8serno": "serialNumber",
                "port": "serialPort",
                "au8Buffer": "buffer",
                "u16InCnt": "inputCount",
                "u16errCnt": "errorCount"
            },
            "code": "int8_t __thiscall readModbusData_080006b4(Modbus *modbusInstance) {\n  bool bufferOverflow = false;\n  int character;\n  byte bufferIndex;\n  if (modbusInstance->u8txenpin > 1) {\n    digitalWrite((uint)modbusInstance->u8txenpin, 0);\n  }\n  modbusInstance->u8BufferSize = 0;\n  if (modbusInstance->u8serno < 4) {\n    while (character = (*(modbusInstance->port->super_Stream).super_Print._vptr_Print[2])(), character != 0) {\n      bufferIndex = modbusInstance->u8BufferSize;\n      character = (*(modbusInstance->port->super_Stream).super_Print._vptr_Print[3])();\n      modbusInstance->au8Buffer[bufferIndex] = (uint8_t)character;\n      bufferIndex = modbusInstance->u8BufferSize + 1;\n      modbusInstance->u8BufferSize = bufferIndex;\n      if (bufferIndex > 63) {\n        bufferOverflow = true;\n      }\n    }\n  }\n  if (bufferOverflow) {\n    modbusInstance->u16errCnt++;\n    return -3;\n  }\n  modbusInstance->u16InCnt++;\n  return modbusInstance->u8BufferSize;\n}",
            "called": [
                "digitalWrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080006b4",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "readModbusData_080006b4"
        },
        "FUN_080034da": {
            "renaming": {
                "FUN_080034da": "find_peripheral_by_pin_080034da",
                "pin": "target_pin",
                "map": "pin_map"
            },
            "code": "void * find_peripheral_by_pin_080034da(PinName_conflict target_pin, PinMap_conflict *pin_map) {\n  while (true) {\n    if (pin_map->pin == NC) {\n      return (void *)0x0;\n    }\n    if (pin_map->pin == target_pin) break;\n    pin_map++;\n  }\n  return pin_map->peripheral;\n}",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080034da",
            "calling": [
                "pinmap_find_peripheral",
                "pinmap_peripheral"
            ],
            "imported": false,
            "current_name": "find_peripheral_by_pin_080034da"
        },
        "FUN_080035fc": {
            "renaming": {
                "FUN_080035fc": "clear_timer_interrupt_flags_080035fc",
                "htim": "timer",
                "Instance": "instance",
                "PTR_DAT_08003718": "TIM2",
                "PTR_DAT_0800371c": "TIM4",
                "PTR_DAT_08003720": "TIM5",
                "PTR_DAT_08003724": "TIM6",
                "PTR_DAT_08003728": "TIM7",
                "PTR_DAT_0800372c": "TIM12",
                "PTR_DAT_08003730": "TIM13",
                "PTR_DAT_08003734": "TIM14",
                "PTR_DAT_08003738": "TIM15",
                "PTR_DAT_0800373c": "TIM16",
                "PTR_DAT_08003740": "TIM17",
                "PTR_DAT_08003744": "TIM18",
                "PTR_DAT_08003748": "TIM19",
                "DAT_0800374c": "TIMER_BASE_ADDRESS",
                "uint": "unsigned int",
                "&= 0xfffffffe": "&= 0xfffffffe",
                "&= 0xfffffffd": "&= 0xfffffffd",
                "&= 0xfffffffb": "&= 0xfffffffb",
                "&= 0xfffffff7": "&= 0xfffffff7",
                "&= 0xffffffef": "&= 0xffffffef",
                "&= 0xffffffdf": "&= 0xffffffdf",
                "&= 0xffffffbf": "&= 0xffffffbf",
                "&= 0xffffff7f": "&= 0xffffff7f",
                "&= 0xfffffeff": "&= 0xfffffeff"
            },
            "code": "void clear_timer_interrupt_flags_080035fc(TIM_HandleTypeDef *timer)\n{\n    if (timer->Instance == PTR_DAT_08003718) {\n        *(uint *)(DAT_0800374c + PTR_DAT_08003718_CLEAR_FLAG_OFFSET) &= 0xfffffffe;\n    }\n    if (timer->Instance == TIM3) {\n        *(uint *)(DAT_0800374c + TIM3_CLEAR_FLAG_OFFSET) &= 0xfffffffe;\n    }\n    if (timer->Instance == PTR_DAT_0800371c) {\n        *(uint *)(DAT_0800374c + PTR_DAT_0800371c_CLEAR_FLAG_OFFSET) &= 0xfffffffd;\n    }\n    if (timer->Instance == PTR_DAT_08003720) {\n        *(uint *)(DAT_0800374c + PTR_DAT_08003720_CLEAR_FLAG_OFFSET) &= 0xfffffffb;\n    }\n    if (timer->Instance == PTR_DAT_08003724) {\n        *(uint *)(DAT_0800374c + PTR_DAT_08003724_CLEAR_FLAG_OFFSET) &= 0xfffffff7;\n    }\n    if (timer->Instance == PTR_DAT_08003728) {\n        *(uint *)(DAT_0800374c + PTR_DAT_08003728_CLEAR_FLAG_OFFSET) &= 0xffffffef;\n    }\n    if (timer->Instance == PTR_DAT_0800372c) {\n        *(uint *)(DAT_0800374c + PTR_DAT_0800372c_CLEAR_FLAG_OFFSET) &= 0xffffffdf;\n    }\n    if (timer->Instance == PTR_DAT_08003730) {\n        *(uint *)(DAT_0800374c + PTR_DAT_08003730_CLEAR_FLAG_OFFSET) &= 0xfffffffd;\n    }\n    if (timer->Instance == PTR_DAT_08003734) {\n        *(uint *)(DAT_0800374c + PTR_DAT_08003734_CLEAR_FLAG_OFFSET) &= 0xfffeffff;\n    }\n    if (timer->Instance == PTR_DAT_08003738) {\n        *(uint *)(DAT_0800374c + PTR_DAT_08003738_CLEAR_FLAG_OFFSET) &= 0xfffdffff;\n    }\n    if (timer->Instance == PTR_DAT_0800373c) {\n        *(uint *)(DAT_0800374c + PTR_DAT_0800373c_CLEAR_FLAG_OFFSET) &= 0xfffbffff;\n    }\n    if (timer->Instance == PTR_DAT_08003740) {\n        *(uint *)(DAT_0800374c + PTR_DAT_08003740_CLEAR_FLAG_OFFSET) &= 0xffffffbf;\n    }\n    if (timer->Instance == PTR_DAT_08003744) {\n        *(uint *)(DAT_0800374c + PTR_DAT_08003744_CLEAR_FLAG_OFFSET) &= 0xffffff7f;\n    }\n    if (timer->Instance == PTR_DAT_08003748) {\n        *(uint *)(DAT_0800374c + PTR_DAT_08003748_CLEAR_FLAG_OFFSET) &= 0xfffffeff;\n    }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035fc",
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "imported": false,
            "current_name": "clear_timer_interrupt_flags_080035fc"
        },
        "FUN_08003dd0": {
            "renaming": {
                "FUN_08003dd0": "is_uart_transmit_complete_08003dd0",
                "obj": "serial_obj",
                "HVar1": "uart_state"
            },
            "code": "bool is_uart_transmit_complete_08003dd0(serial_t *serial_obj) {\n    HAL_UART_StateTypeDef uart_state = HAL_UART_GetState(*((UART_HandleTypeDef **) (PTR_uart_handlers_08003df0 + (uint)serial_obj->index * 4)));\n    return (uart_state & 0x22U) == 0x22;\n}",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003dd0",
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "imported": false,
            "current_name": "is_uart_transmit_complete_08003dd0"
        },
        "FUN_08000c8c": {
            "renaming": {
                "FUN_08000c8c": "configure_clocks_08000c8c",
                "RCC_OscInitStruct": "osc_init",
                "RCC_ClkInitStruct": "clk_init",
                "RCC_OscInitStruct.OscillatorType": "osc_init.OscillatorType",
                "RCC_OscInitStruct.HSEState": "osc_init.HSEState",
                "RCC_OscInitStruct.PLL.PLLState": "osc_init.PLL.PLLState",
                "RCC_OscInitStruct.PLL.PLLSource": "osc_init.PLL.PLLSource",
                "RCC_OscInitStruct.PLL.PLLM": "osc_init.PLL.PLLM",
                "RCC_OscInitStruct.PLL.PLLN": "osc_init.PLL.PLLN",
                "RCC_OscInitStruct.PLL.PLLP": "osc_init.PLL.PLLP",
                "RCC_OscInitStruct.PLL.PLLQ": "osc_init.PLL.PLLQ",
                "HAL_RCC_OscConfig": "HAL_RCC_OscConfig",
                "HAL_PWREx_EnableOverDrive": "HAL_PWREx_EnableOverDrive",
                "RCC_ClkInitStruct.ClockType": "clk_init.ClockType",
                "RCC_ClkInitStruct.SYSCLKSource": "clk_init.SYSCLKSource",
                "RCC_ClkInitStruct.AHBCLKDivider": "clk_init.AHBCLKDivider",
                "RCC_ClkInitStruct.APB1CLKDivider": "clk_init.APB1CLKDivider",
                "RCC_ClkInitStruct.APB2CLKDivider": "clk_init.APB2CLKDivider",
                "HAL_RCC_ClockConfig": "HAL_RCC_ClockConfig",
                "HAL_RCC_GetHCLKFreq": "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_Config": "HAL_SYSTICK_Config",
                "DAT_08000d30": "DAT_08000d30",
                "DAT_08000d34": "DAT_08000d34",
                "DAT_08000d38": "DAT_08000d38",
                "SysTick_IRQn": "SysTick_IRQn",
                "FLASH_LATENCY_5": "FLASH_LATENCY_5",
                "SYSTICK_RELOAD_VALUE": "SYSTICK_RELOAD_VALUE",
                "HAL_SYSTICK_CLKSourceConfig": "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority": "HAL_NVIC_SetPriority"
            },
            "code": "void configure_clocks_08000c8c(void)\n{\n  uint32_t hclk_freq;\n  RCC_OscInitTypeDef osc_init;\n  RCC_ClkInitTypeDef clk_init;\n\n  // Enable HSE and PLL\n  *(uint *)(DAT_08000d30 + 0x40) |= 0x10000000;\n  *DAT_08000d34 |= 0xc000;\n\n  // Configure PLL\n  osc_init.OscillatorType = RCC_OSCILLATORTYPE_HSE;\n  osc_init.HSEState = RCC_HSE_ON;\n  osc_init.PLL.PLLState = RCC_PLL_ON;\n  osc_init.PLL.PLLSource = RCC_PLLSOURCE_HSE;\n  osc_init.PLL.PLLM = 8;\n  osc_init.PLL.PLLN = 336;\n  osc_init.PLL.PLLP = RCC_PLLP_DIV2;\n  osc_init.PLL.PLLQ = 7;\n  HAL_RCC_OscConfig(&osc_init);\n\n  // Enable OverDrive\n  HAL_PWREx_EnableOverDrive();\n\n  // Configure Clocks\n  clk_init.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_HCLK\n                      |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  clk_init.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  clk_init.APB1CLKDivider = RCC_HCLK_DIV4;\n  clk_init.APB2CLKDivider = RCC_HCLK_DIV2;\n  HAL_RCC_ClockConfig(&clk_init, FLASH_LATENCY_5);\n\n  // Configure Systick\n  hclk_freq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config((uint)((uint64_t)SYSTICK_RELOAD_VALUE * (uint64_t)hclk_freq / (uint64_t)1000000));\n  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_SYSTICK_Config",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_OscConfig",
                "HAL_PWREx_EnableOverDrive",
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c8c",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "configure_clocks_08000c8c"
        },
        "FUN_08000a4e": {
            "renaming": {
                "FUN_08000a4e": "set_register_value_08000a4e",
                "this": "modbus",
                "regs": "registers",
                "u8size": "register_count",
                "uVar1": "register_address",
                "uVar2": "register_value",
                "au8Buffer": "buffer"
            },
            "code": "int8_t __thiscall Modbus::set_register_value_08000a4e(Modbus *modbus,uint16_t *registers,uint8_t register_count)\n{\n  uint16_t register_address;\n  uint16_t register_value;\n  register_address = makeWord(modbus->au8Buffer[2],modbus->au8Buffer[3]);\n  register_value = makeWord(modbus->au8Buffer[4],modbus->au8Buffer[5]);\n  registers[(uint8_t)register_address] = register_value;\n  modbus->u8BufferSize = '\\x06';\n  sendTxBuffer(modbus);\n  return '\b';\n}",
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a4e",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "set_register_value_08000a4e"
        },
        "FUN_08004774": {
            "renaming": {
                "FUN_08004774": "handleExternalInterrupt_08004774"
            },
            "code": "void handleExternalInterrupt_08004774(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(4);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004774",
            "calling": [],
            "imported": false,
            "current_name": "handleExternalInterrupt_08004774"
        },
        "FUN_08004658": {
            "renaming": {
                "FUN_08004658": "runProgram_08004658",
                "DAT_08004674": "serialEventFlag"
            },
            "code": "int runProgram_08004658(void)\n{\n    initVariant();\n    setup();\n    while(true)\n    {\n        loop();\n        if(DAT_08004674 != 0)\n        {\n            serialEventRun();\n        }\n    }\n}",
            "called": [
                "loop",
                "initVariant",
                "setup",
                "serialEventRun"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004658",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "runProgram_08004658"
        },
        "FUN_080034f4": {
            "renaming": {
                "FUN_080034f4": "find_peripheral_by_pin_080034f4",
                "pin": "pin_name",
                "map": "pin_map",
                "pvVar1": "peripheral"
            },
            "code": "void * find_peripheral_by_pin_080034f4(PinName_conflict pin, PinMap_conflict *map)\n{\n  void *peripheral;\n\n  if (pin != NC) {\n    peripheral = pinmap_find_peripheral(pin, map);\n    return peripheral;\n  }\n  return (void *)0x0;\n}",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080034f4",
            "calling": [
                "uart_debug_init",
                "uart_init",
                "dac_stop",
                "uart_debug_write",
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "find_peripheral_by_pin_080034f4"
        },
        "FUN_0800476a": {
            "renaming": {
                "FUN_0800476a": "handle_GPIO_EXTI_Interrupt_0800476a"
            },
            "code": "void handle_GPIO_EXTI_Interrupt_0800476a(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(2);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800476a",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_EXTI_Interrupt_0800476a"
        },
        "FUN_0800355e": {
            "renaming": {
                "FUN_0800355e": "check_valid_pin_0800355e",
                "pin": "pin_name",
                "map": "pin_map"
            },
            "code": "_Bool check_valid_pin_0800355e(PinName_conflict pin, PinMap_conflict *pin_map) {\n    if (pin == NC) {\n        return false;\n    }\n    while (true) {\n        if (pin_map->pin == NC) {\n            return false;\n        }\n        if (pin == pin_map->pin) {\n            break;\n        }\n        pin_map++;\n    }\n    return true;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800355e",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "check_valid_pin_0800355e"
        },
        "FUN_0800573c": {
            "renaming": {
                "FUN_0800573c": "read_file_0800573c",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "puVar1": "error_ptr",
                "iVar2": "read_result"
            },
            "code": "void read_file_0800573c(int* error_code, int file_descriptor, char* buffer, int buffer_size){\n  undefined* error_ptr;\n  int read_result;\n  error_ptr = PTR_errno_0800575c;\n  *(undefined4*)PTR_errno_0800575c = 0;\n  read_result = _read(file_descriptor, buffer, buffer_size);\n  if ((read_result == -1) && (*(int*)error_ptr != 0)) {\n    *error_code = *(int*)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800573c",
            "calling": [
                "__sread"
            ],
            "imported": false,
            "current_name": "read_file_0800573c"
        },
        "FUN_08003e54": {
            "renaming": {
                "FUN_08003e54": "receive_data_08003e54",
                "obj": "serial_object",
                "callback": "receive_callback",
                "bVar1": "index",
                "uVar2": "is_rx_active"
            },
            "code": "void receive_data_08003e54(serial_t *serial_object, _func_void_serial_t_ptr *receive_callback) {\\n\\\n  byte index;\\n\\\n  uint8_t is_rx_active;\\n\\\n  \\n\\\n  if (serial_object != NULL) {\\n\\\n    is_rx_active = serial_rx_active(serial_object);\\n\\\n    if (is_rx_active == 0) {\\n\\\n      index = serial_object->index;\\n\\\n      *(_func_void_serial_t_ptr **)(PTR_rx_callback_08003ea0 + (uint)index * 4) = receive_callback;\\n\\\n      *(serial_t **)(PTR_rx_callback_obj_08003ea4 + (uint)index * 4) = serial_object;\\n\\\n      HAL_NVIC_SetPriority(serial_object->irq, 0, 1);\\n\\\n      HAL_NVIC_EnableIRQ(serial_object->irq);\\n\\\n      HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08003ea8 + (uint)serial_object->index * 4), &serial_object->recv, 1);\\n\\\n    }\\n\\\n  }\\n\\\n}",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "HAL_NVIC_EnableIRQ",
                "serial_rx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003e54",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "receive_data_08003e54"
        },
        "FUN_08004fdc": {
            "renaming": {
                "FUN_08004fdc": "print_formatted_string_08004fdc",
                "__format": "format",
                "in_r1": "arg1",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "iVar1": "impure_ptr",
                "pcVar2": "format_string",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3"
            },
            "code": "int print_formatted_string_08004fdc(char *format, ...)\n{\n    int impure_ptr = *(int *)PTR__impure_ptr_08005008;\n    char *format_string = format;\n    undefined4 arg1 = in_r1;\n    undefined4 arg2 = in_r2;\n    undefined4 arg3 = in_r3;\n    if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n        __sinit(impure_ptr);\n    }\n    int result = _vfprint_r(impure_ptr, *(undefined4 *)(impure_ptr + 8), format_string, &arg1, format_string, &arg2);\n    return result;\n}",
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004fdc",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "print_formatted_string_08004fdc"
        },
        "FUN_080056d4": {
            "renaming": {
                "FUN_080056d4": "get_file_status_080056d4",
                "param_1": "status",
                "param_2": "file_descriptor",
                "param_3": "file_stats",
                "puVar1": "error_ptr",
                "iVar2": "fstat_result"
            },
            "code": "void get_file_status_080056d4(int *status, int file_descriptor, stat *file_stats)\n{\n  undefined *error_ptr;\n  int fstat_result;\n  error_ptr = errno_ptr;\n  *(undefined4 *)errno_ptr = 0;\n  fstat_result = _fstat(file_descriptor, file_stats);\n  if ((fstat_result == -1) && (*(int *)error_ptr != 0)) {\n    *status = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_fstat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080056d4",
            "calling": [
                "__swhatbuf_r"
            ],
            "imported": false,
            "current_name": "get_file_status_080056d4"
        },
        "FUN_080033d8": {
            "renaming": {
                "FUN_080033d8": "stop_and_deinit_dac_channel_080033d8",
                "PinName_conflict": "pin",
                "Channel": "channel",
                "DAC_HandleTypeDef": "dac_handle",
                "DacHandle": "dac_handle",
                "PTR_PinMap_DAC_08003408": "PTR_PinMap_DAC_08003408",
                "get_dac_channel": "get_dac_channel",
                "HAL_DAC_Stop": "HAL_DAC_Stop",
                "HAL_DAC_DeInit": "HAL_DAC_DeInit"
            },
            "code": "void stop_and_deinit_dac_channel_080033d8(PinName_conflict pin)\n{\n  uint32_t channel;\n  DAC_HandleTypeDef dac_handle;\n  dac_handle.Instance = (DAC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_DAC_08003408);\n  if ((dac_handle.Instance != (DAC_TypeDef *)0x0) && ((channel = get_dac_channel(pin), channel == 0 || (channel == 0x10)))) {\n    HAL_DAC_Stop(&dac_handle, channel);\n    HAL_DAC_DeInit(&dac_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_DAC_Stop",
                "HAL_DAC_DeInit",
                "get_dac_channel",
                "pinmap_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033d8",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "stop_and_deinit_dac_channel_080033d8"
        },
        "FUN_080029c8": {
            "renaming": {
                "FUN_080029c8": "set_uart_config_080029c8",
                "huart": "uart_handle",
                "Instance": "uart_instance",
                "CR1": "uart_control_register_1",
                "CR2": "uart_control_register_2",
                "CR3": "uart_control_register_3",
                "Init": "uart_init_structure",
                "StopBits": "stop_bits",
                "WordLength": "word_length",
                "Parity": "parity",
                "Mode": "mode",
                "OverSampling": "oversampling",
                "HwFlowCtl": "hardware_flow_control",
                "BaudRate": "baud_rate",
                "pUVar12": "uart_instance_pointer",
                "uVar1": "temp_value_1",
                "uVar2": "temp_value_2",
                "uVar3": "temp_value_3",
                "uVar4": "temp_value_4",
                "uVar5": "temp_value_5",
                "uVar6": "temp_value_6",
                "uVar7": "temp_value_7",
                "uVar8": "temp_value_8",
                "uVar9": "temp_value_9",
                "uVar10": "temp_value_10",
                "uVar11": "temp_value_11"
            },
            "code": "\nvoid set_uart_config_080029c8(UART_HandleTypeDef *uart_handle)\n\n{\n  ulonglong temp_value_1;\n  uint temp_value_2;\n  uint32_t temp_value_3;\n  uint32_t temp_value_4;\n  uint32_t temp_value_5;\n  uint32_t temp_value_6;\n  uint32_t temp_value_7;\n  uint32_t temp_value_8;\n  uint32_t temp_value_9;\n  uint32_t temp_value_10;\n  uint32_t temp_value_11;\n  USART_TypeDef *uart_instance_pointer;\n  \n  uart_handle->uart_instance->uart_control_register_2 = uart_handle->uart_instance->uart_control_register_2 & 0xffffcfff | (uart_handle->uart_init_structure).stop_bits;\n  uart_handle->uart_instance->uart_control_register_1 =\n       uart_handle->uart_instance->uart_control_register_1 & 0xffff69f3 |\n       (uart_handle->uart_init_structure).word_length | (uart_handle->uart_init_structure).parity | (uart_handle->uart_init_structure).mode |\n       (uart_handle->uart_init_structure).oversampling;\n  uart_handle->uart_instance->uart_control_register_3 = uart_handle->uart_instance->uart_control_register_3 & 0xfffffcff | (uart_handle->uart_init_structure).hardware_flow_control;\n  if ((uart_handle->uart_init_structure).oversampling == 0x8000) {\n    uart_instance_pointer = uart_handle->uart_instance;\n    if ((uart_instance_pointer != (USART_TypeDef *)0x40011000) && (uart_instance_pointer != (USART_TypeDef *)0x40011400)) {\n      temp_value_3 = HAL_RCC_GetPCLK1Freq();\n      temp_value_2 = DAT_08002d08;\n      temp_value_8 = (uart_handle->uart_init_structure).baud_rate;\n      temp_value_1 = (ulonglong)DAT_08002d08;\n      temp_value_4 = HAL_RCC_GetPCLK1Freq();\n      temp_value_9 = (uart_handle->uart_init_structure).baud_rate;\n      temp_value_5 = HAL_RCC_GetPCLK1Freq();\n      temp_value_10 = (uart_handle->uart_init_structure).baud_rate;\n      temp_value_6 = HAL_RCC_GetPCLK1Freq();\n      temp_value_11 = (uart_handle->uart_init_structure).baud_rate;\n      temp_value_7 = HAL_RCC_GetPCLK1Freq();\n      uart_instance_pointer->BRR = ((uint)((int)((ulonglong)temp_value_2 *\n                                   (ulonglong)\n                                   (((temp_value_6 * 0x19) / (temp_value_11 << 1) +\n                                    (uint)((ulonglong)temp_value_2 *\n                                           ((ulonglong)(temp_value_7 * 0x19) /\n                                           (ulonglong)((uart_handle->uart_init_structure).baud_rate << 1)) >> 0x25) * -100\n                                    ) * 8 + 0x32) >> 0x20) << 0x18) >> 0x1d) +\n                     ((uint)((ulonglong)temp_value_2 *\n                             (ulonglong)\n                             (((temp_value_4 * 0x19) / (temp_value_9 << 1) +\n                              (uint)((ulonglong)temp_value_2 *\n                                     ((ulonglong)(temp_value_5 * 0x19) / (ulonglong)(temp_value_10 << 1)) >> 0x25)\n                              * -100) * 8 + 0x32) >> 0x25) & 0xf8) * 2 +\n                     (uint)(temp_value_1 * ((ulonglong)(temp_value_3 * 0x19) / (ulonglong)(temp_value_8 << 1)) >> 0x25) *\n                     0x10;\n      return;\n    }\n    temp_value_3 = HAL_RCC_GetPCLK2Freq();\n    temp_value_2 = DAT_08002d08;\n    temp_value_8 = (uart_handle->uart_init_structure).baud_rate;\n    temp_value_1 = (ulonglong)DAT_08002d08;\n    temp_value_4 = HAL_RCC_GetPCLK2Freq();\n    temp_value_9 = (uart_handle->uart_init_structure).baud_rate;\n    temp_value_5 = HAL_RCC_GetPCLK2Freq();\n    temp_value_10 = (uart_handle->uart_init_structure).baud_rate;\n    temp_value_6 = HAL_RCC_GetPCLK2Freq();\n    temp_value_11 = (uart_handle->uart_init_structure).baud_rate;\n    temp_value_7 = HAL_RCC_GetPCLK2Freq();\n    uart_instance_pointer->BRR = ((uint)((int)((ulonglong)temp_value_2 *\n                                 (ulonglong)\n                                 (((temp_value_6 * 0x19) / (temp_value_11 << 1) +\n                                  (uint)((ulonglong)temp_value_2 *\n                                         ((ulonglong)(temp_value_7 * 0x19) /\n                                         (ulonglong)((uart_handle->uart_init_structure).baud_rate << 1)) >> 0x25) * -100)\n                                  * 8 + 0x32) >> 0x20) << 0x18) >> 0x1d) +\n                   ((uint)((ulonglong)temp_value_2 *\n                           (ulonglong)\n                           (((temp_value_4 * 0x19) / (temp_value_9 << 1) +\n                            (uint)((ulonglong)temp_value_2 *\n                                   ((ulonglong)(temp_value_5 * 0x19) / (ulonglong)(temp_value_10 << 1)) >> 0x25) *\n                            -100) * 8 + 0x32) >> 0x25) & 0xf8) * 2 +\n                   (uint)(temp_value_1 * ((ulonglong)(temp_value_3 * 0x19) / (ulonglong)(temp_value_8 << 1)) >> 0x25) *\n                   0x10;\n    return;\n  }\n  uart_instance_pointer = uart_handle->uart_instance;\n  if ((uart_instance_pointer != DAT_08002d04) && (uart_instance_pointer != (USART_TypeDef *)&DAT_08002d04[0x24].uart_control_register_2)) {\n    temp_value_3 = HAL_RCC_GetPCLK1Freq();\n    temp_value_2 = DAT_08002d08;\n    temp_value_8 = (uart_handle->uart_init_structure).baud_rate;\n    temp_value_1 = (ulonglong)DAT_08002d08;\n    temp_value_4 = HAL_RCC_GetPCLK1Freq();\n    temp_value_9 = (uart_handle->uart_init_structure).baud_rate;\n    temp_value_5 = HAL_RCC_GetPCLK1Freq();\n    temp_value_10 = (uart_handle->uart_init_structure).baud_rate;\n    temp_value_6 = HAL_RCC_GetPCLK1Freq();\n    temp_value_11 = (uart_handle->uart_init_structure).baud_rate;\n    temp_value_7 = HAL_RCC_GetPCLK1Freq();\n    uart_instance_pointer->BRR = ((uint)((int)((ulonglong)temp_value_2 *\n                                 (ulonglong)\n                                 (((temp_value_6 * 0x19) / (temp_value_11 << 2) +\n                                  (uint)((ulonglong)temp_value_2 *\n                                         ((ulonglong)(temp_value_7 * 0x19) /\n                                         (ulonglong)((uart_handle->uart_init_structure).baud_rate << 2)) >> 0x25) * -100)\n                                  * 0x10 + 0x32) >> 0x20) << 0x17) >> 0x1c) +\n                   ((uint)((ulonglong)temp_value_2 *\n                           (ulonglong)\n                           (((temp_value_4 * 0x19) / (temp_value_9 << 2) +\n                            (uint)((ulonglong)temp_value_2 *\n                                   ((ulonglong)(temp_value_5 * 0x19) / (ulonglong)(temp_value_10 << 2)) >> 0x25) *\n                            -100) * 0x10 + 0x32) >> 0x25) & 0xf0) +\n                   (uint)(temp_value_1 * ((ulonglong)(temp_value_3 * 0x19) / (ulonglong)(temp_value_8 << 2)) >> 0x25) *\n                   0x10;\n    return;\n  }\n  temp_value_3 = HAL_RCC_GetPCLK2Freq();\n  temp_value_2 = DAT_08002d08;\n  temp_value_8 = (uart_handle->uart_init_structure).baud_rate;\n  temp_value_1 = (ulonglong)DAT_08002d08;\n  temp_value_4 = HAL_RCC_GetPCLK2Freq();\n  temp_value_9 = (uart_handle->uart_init_structure).baud_rate;\n  temp_value_5 = HAL_RCC_GetPCLK2Freq();\n  temp_value_10 = (uart_handle->uart_init_structure).baud_rate;\n  temp_value_6 = HAL_RCC_GetPCLK2Freq();\n  temp_value_11 = (uart_handle->uart_init_structure).baud_rate;\n  temp_value_7 = HAL_RCC_GetPCLK2Freq();\n  uart_instance_pointer->BRR = ((uint)((int)((ulonglong)temp_value_2 *\n                               (ulonglong)\n                               (((temp_value_6 * 0x19) / (temp_value_11 << 2) +\n                                (uint)((ulonglong)temp_value_2 *\n                                       ((ulonglong)(temp_value_7 * 0x19) /\n                                       (ulonglong)((uart_handle->uart_init_structure).baud_rate << 2)) >> 0x25) * -100) *\n                                0x10 + 0x32) >> 0x20) << 0x17) >> 0x1c) +\n                 ((uint)((ulonglong)temp_value_2 *\n                         (ulonglong)\n                         (((temp_value_4 * 0x19) / (temp_value_9 << 2) +\n                          (uint)((ulonglong)temp_value_2 *\n                                 ((ulonglong)(temp_value_5 * 0x19) / (ulonglong)(temp_value_10 << 2)) >> 0x25) *\n                          -100) * 0x10 + 0x32) >> 0x25) & 0xf0) +\n                 (uint)(temp_value_1 * ((ulonglong)(temp_value_3 * 0x19) / (ulonglong)(temp_value_8 << 2)) >> 0x25) *\n                 0x10;\n  return;\n}\n\n",
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080029c8",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "set_uart_config_080029c8"
        },
        "FUN_08002488": {
            "renaming": {
                "FUN_08002488": "configureClocks_08002488",
                "RCC_ClkInitStruct_conflict": "clockInitStruct",
                "FLatency": "latency",
                "puVar1": "rccCfgrReg",
                "uVar2": "sysclkFreq",
                "uVar3": "tickNow",
                "uVar4": "sysclkSource"
            },
            "code": "HAL_StatusTypeDef configureClocks_08002488(RCC_ClkInitTypeDef_conflict *clockInitStruct, uint32_t latency) {\n    uint32_t *rccCfgrReg = (uint32_t *)0x40021000;\n    if (clockInitStruct == NULL) {\n        return HAL_ERROR;\n    }\n    if (((*rccCfgrReg & 0xf) < latency) && (*(volatile uint8_t *)rccCfgrReg = (uint8_t)latency, latency != (*rccCfgrReg & 0xf))) {\n        return HAL_ERROR;\n    }\n    if ((clockInitStruct->ClockType & RCC_CLOCKTYPE_AHB) != 0) {\n        if ((clockInitStruct->ClockType & RCC_CLOCKTYPE_APB1) != 0) {\n            rccCfgrReg[2] |= 0x1c00;\n        }\n        if ((clockInitStruct->ClockType & RCC_CLOCKTYPE_APB2) != 0) {\n            rccCfgrReg[2] |= 0xe000;\n        }\n        rccCfgrReg[2] = rccCfgrReg[2] & 0xffffff0f | clockInitStruct->AHBCLKDivider;\n    }\n    if ((clockInitStruct->ClockType & RCC_CLOCKTYPE_SYSCLK) != 0) {\n        uint32_t sysclkSource = clockInitStruct->SYSCLKSource;\n        if (sysclkSource == RCC_SYSCLKSOURCE_PLLCLK) {\n            if ((rccCfgrReg[0] & 0x20000) == 0) {\n                return HAL_ERROR;\n            }\n        }\n        else if (sysclkSource - RCC_SYSCLKSOURCE_HSE < 2) {\n            if ((rccCfgrReg[0] & 0x2000000) == 0) {\n                return HAL_ERROR;\n            }\n        }\n        else if ((rccCfgrReg[0] & 2) == 0) {\n            return HAL_ERROR;\n        }\n        rccCfgrReg[0] = sysclkSource | rccCfgrReg[0] & 0xfffffffc;\n        uint32_t tickStart = HAL_GetTick();\n        while ((rccCfgrReg[0] & 0xc) != clockInitStruct->SYSCLKSource * 4) {\n            uint32_t tickNow = HAL_GetTick();\n            if (5000 < tickNow - tickStart) {\n                return HAL_TIMEOUT;\n            }\n        }\n    }\n    if ((latency < (*rccCfgrReg & 0xf)) && (*(volatile uint8_t *)rccCfgrReg = (uint8_t)latency, latency != (*rccCfgrReg & 0xf))) {\n        return HAL_ERROR;\n    }\n    if ((clockInitStruct->ClockType & RCC_CLOCKTYPE_APB1) != 0) {\n        rccCfgrReg[2] = rccCfgrReg[2] & 0xffffe3ff | clockInitStruct->APB1CLKDivider;\n    }\n    if ((clockInitStruct->ClockType & RCC_CLOCKTYPE_APB2) != 0) {\n        rccCfgrReg[2] = rccCfgrReg[2] & 0xffff1fff | clockInitStruct->APB2CLKDivider << 3;\n    }\n    uint32_t sysclkFreq = HAL_RCC_GetSysClockFreq();\n    *(uint32_t *)SystemCoreClock = sysclkFreq >> AHBPrescTable[(rccCfgrReg[2] << 0x18) >> 0x1c];\n    HAL_InitTick(0xf);\n    return HAL_OK;\n}",
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick",
                "HAL_InitTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002488",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configureClocks_08002488"
        },
        "FUN_08004788": {
            "renaming": {
                "FUN_08004788": "handle_GPIO_EXTI_interrupt_08004788",
                "PTR_": "",
                "DAT_": "",
                "0x10": "pin_number"
            },
            "code": "void handle_GPIO_EXTI_interrupt_08004788(void)\n{\n    int pin_number = 0x10;\n    HAL_GPIO_EXTI_IRQHandler(pin_number);\n    return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004788",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_EXTI_interrupt_08004788"
        },
        "FUN_08004544": {
            "renaming": {
                "FUN_08004544::FUN_08004544": "IPAddress::IPAddress",
                "this": "this",
                "first_octet": "first",
                "second_octet": "second",
                "third_octet": "third",
                "fourth_octet": "fourth",
                "super_Printable": "super_Printable",
                "_vptr_Printable": "_vptr_Printable",
                "_address": "_address",
                "bytes": "bytes",
                "FUN_08004544": "IPAddress_08004544"
            },
            "code": "class IPAddress_08004544 {\npublic:\n    uint8_t first_octet;\n    uint8_t second_octet;\n    uint8_t third_octet;\n    uint8_t fourth_octet;\n\n    IPAddress_08004544(uint8_t first, uint8_t second, uint8_t third, uint8_t fourth) {\n        first_octet = first;\n        second_octet = second;\n        third_octet = third;\n        fourth_octet = fourth;\n    }\n};",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004544",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "IPAddress_08004544"
        },
        "FUN_08003cc8": {
            "renaming": {
                "FUN_08003cc8": "initialize_uart_debug_08003cc8",
                "PinName_conflict": "PinName",
                "pin": "pin_name",
                "obj": "serial_debug_ptr",
                "PVar1": "tx_pin_name",
                "pvVar2": "peripheral_ptr"
            },
            "code": "void initialize_uart_debug_08003cc8(void)\n{\n  PinName_conflict pin_name;\n  undefined *serial_debug_ptr;\n  PinName_conflict tx_pin_name;\n  void *peripheral_ptr;\n  \n  pin_name = *(PinName_conflict *)(PTR_digitalPin_08003d08 + 0x9a);\n  peripheral_ptr = pinmap_peripheral(pin_name,(PinMap_conflict *)PTR_PinMap_UART_TX_08003d0c);\n  if (peripheral_ptr != (void *)0x0) {\n    peripheral_ptr = pinmap_peripheral(pin_name,(PinMap_conflict *)PTR_PinMap_UART_TX_08003d0c);\n    tx_pin_name = pinmap_pin(peripheral_ptr,(PinMap_conflict *)PTR_PinMap_UART_RX_08003d10);\n    serial_debug_ptr = PTR_serial_debug_08003d14;\n    *(PinName_conflict *)(PTR_serial_debug_08003d14 + 0x5a) = tx_pin_name;\n    *(PinName_conflict *)(serial_debug_ptr + 0x58) = pin_name;\n    *(undefined4 *)(serial_debug_ptr + 0x48) = 0x2580;\n    *(undefined4 *)(serial_debug_ptr + 0x54) = 0;\n    *(undefined4 *)(serial_debug_ptr + 0x4c) = 0;\n    *(undefined4 *)(serial_debug_ptr + 0x50) = 0;\n    uart_init((serial_t *)serial_debug_ptr);\n  }\n  return;\n}",
            "called": [
                "pinmap_pin",
                "uart_init",
                "pinmap_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003cc8",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "initialize_uart_debug_08003cc8"
        },
        "FUN_08002d70": {
            "renaming": {
                "FUN_08002d70": "do_nothing_08002d70"
            },
            "code": "\nvoid do_nothing_08002d70(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d70",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_08002d70"
        },
        "FUN_08000fb4": {
            "renaming": {
                "FUN_08000fb4": "gpio_configure_pins_08000fb4",
                "GPIOx": "port",
                "GPIO_Init": "init",
                "puVar1": "mask",
                "puVar2": "value",
                "uVar3": "pin",
                "uVar4": "mask",
                "uVar5": "pin",
                "uVar6": "mask",
                "uVar7": "value",
                "uVar9": "pin",
                "iVar8": "otype_index",
                "iVar10": "af_index",
                "tmpreg": "value"
            },
            "code": "void gpio_configure_pins_08000fb4(GPIO_TypeDef *port, GPIO_InitTypeDef *init)\n{\n    uint32_t mask;\n    uint32_t value;\n    uint32_t pin;\n    uint8_t af_index;\n    uint8_t mode_index;\n    uint8_t pupd_index;\n    uint8_t otype_index;\n    uint8_t ospeed_index;\n    for (pin = 0; pin < 16; pin++) {\n        mask = 1 << pin;\n        if (mask & init->Pin) {\n            af_index = pin / 8;\n            mode_index = pin * 2;\n            pupd_index = mode_index;\n            otype_index = pin;\n            ospeed_index = mode_index;\n            if ((init->Mode == GPIO_MODE_AF_PP) || (init->Mode == GPIO_MODE_AF_OD)) {\n                port->AFR[af_index] = (port->AFR[af_index] & ~(0xf << ((pin & 7) * 4))) | (init->Alternate << ((pin & 7) * 4));\n            }\n            value = port->MODER;\n            mask = ~(3 << mode_index);\n            value = (value & mask) | ((init->Mode & 3) << mode_index);\n            port->MODER = value;\n            if (((init->Mode - 1 < 2) || (init->Mode == GPIO_MODE_ANALOG)) || (init->Mode == GPIO_MODE_AF_OD)) {\n                value = port->OSPEEDR;\n                value = (value & mask) | (init->Speed << ospeed_index);\n                port->OSPEEDR = value;\n                mask = 1 << otype_index;\n                value = port->OTYPER;\n                value = (value & ~mask) | ((init->Mode << 0x1b) >> 0x1f) << otype_index;\n                port->OTYPER = value;\n            }\n            value = port->PUPDR;\n            mask = ~(3 << pupd_index);\n            value = (value & mask) | (init->Pull << pupd_index);\n            port->PUPDR = value;\n            if ((init->Mode & GPIO_MODE_IT) != 0) {\n                EXTI->IMR |= (1 << pin);\n                if (init->Mode & GPIO_MODE_IT_RISING) {\n                    EXTI->RTSR |= (1 << pin);\n                }\n                if (init->Mode & GPIO_MODE_IT_FALLING) {\n                    EXTI->FTSR |= (1 << pin);\n                }\n            }\n        }\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000fb4",
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "imported": false,
            "current_name": "gpio_configure_pins_08000fb4"
        },
        "FUN_08001bfc": {
            "renaming": {
                "FUN_08001bfc": "I2C_HandleTransfer_08001bfc",
                "hi2c": "handle",
                "HVar1": "state",
                "pIVar2": "instance",
                "puVar3": "buffer_ptr",
                "tmpreg": "temp_reg",
                "DAT_08001cfc": "XFER_OPTIONS"
            },
            "code": "HAL_StatusTypeDef I2C_HandleTransfer_08001bfc(I2C_HandleTypeDef *handle)\n{\n  HAL_I2C_StateTypeDef state = handle->State;\n  I2C_TypeDef *instance = handle->Instance;\n  uint8_t *buffer_ptr;\n  uint32_t temp_reg;\n \n  instance->CR2 &= 0xfffff8ff;\n  instance->CR1 |= 1;\n  instance->CR1 &= 0xfffffbff;\n\n  if ((instance->CR2 & 0x800) != 0) {\n    if ((handle->State == HAL_I2C_STATE_BUSY_RX) || (handle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      handle->XferCount = (uint16_t)handle->hdmarx->Instance->NDTR;\n    }\n    else {\n      handle->XferCount = (uint16_t)handle->hdmatx->Instance->NDTR;\n    }\n  }\n  if (handle->XferCount != 0) {\n    if ((instance->SR1 & 4) != 0) {\n      buffer_ptr = handle->pBuffPtr;\n      handle->pBuffPtr = buffer_ptr + 1;\n      *buffer_ptr = (uint8_t)instance->DR;\n      handle->XferCount--;\n    }\n    if ((instance->SR1 & 0x40) != 0) {\n      buffer_ptr = handle->pBuffPtr;\n      handle->pBuffPtr = buffer_ptr + 1;\n      *buffer_ptr = (uint8_t)instance->DR;\n      handle->XferCount--;\n    }\n    handle->ErrorCode |= 4;\n  }\n  if (handle->ErrorCode == 0) {\n    if (((state == HAL_I2C_STATE_LISTEN) || (state == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (state == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      handle->XferOptions = DAT_08001cfc;\n      handle->PreviousState = 0;\n      handle->State = HAL_I2C_STATE_READY;\n      handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(handle);\n    }\n    else if ((handle->PreviousState == 0x22) || (state == HAL_I2C_STATE_BUSY_RX)) {\n      handle->PreviousState = 0;\n      handle->State = HAL_I2C_STATE_READY;\n      handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(handle);\n    }\n  }\n  else {\n    I2C_ITError(handle);\n  }\n  return HAL_OK;\n}",
            "called": [
                "I2C_ITError",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001bfc",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "I2C_HandleTransfer_08001bfc"
        },
        "FUN_08001718": {
            "renaming": {
                "FUN_08001718": "do_nothing_08001718"
            },
            "code": "\nvoid do_nothing_08001718(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001718",
            "calling": [
                "I2C_MasterTransmit_TXE",
                "I2C_MasterTransmit_BTF"
            ],
            "imported": false,
            "current_name": "do_nothing_08001718"
        },
        "FUN_08002d72": {
            "renaming": {
                "FUN_08002d72": "initialize_uart_08002d72",
                "*huart": "*uart",
                "HAL_UART_StateTypeDef": "HAL_StatusTypeDef",
                "huart": "uart",
                "gState": "global_state",
                "Lock": "lock",
                "HAL_UART_MspInit": "initialize_uart_gpio",
                "Instance": "instance",
                "CR1": "control_register_1",
                "UART_SetConfig": "configure_uart",
                "CR2": "control_register_2",
                "CR3": "control_register_3",
                "ErrorCode": "error_code",
                "RxState": "receive_state"
            },
            "code": "HAL_StatusTypeDef initialize_uart_08002d72(UART_HandleTypeDef *uart)\n{\n  if (uart != NULL) {\n    if (uart->gState == HAL_UART_STATE_RESET) {\n      uart->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(uart);\n    }\n    uart->gState = HAL_UART_STATE_BUSY;\n    uart->Instance->CR1 &= ~(1 << 13);\n    UART_SetConfig(uart);\n    uart->Instance->CR2 &= ~(1 << 11);\n    uart->Instance->CR3 &= ~(1 << 2);\n    uart->Instance->CR1 |= (1 << 13);\n    uart->ErrorCode = 0;\n    uart->gState = HAL_UART_STATE_READY;\n    uart->RxState = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d72",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_08002d72"
        },
        "FUN_080007f0": {
            "renaming": {
                "__thiscall Modbus::FUN_080007f0": "checkModbusRequest",
                "bVar1": "isSupportedFunction",
                "uVar2": "startingAddress",
                "uVar3": "numberOfRegisters",
                "uVar4": "i",
                "PTR_fctsupported_080008c8": "PTR_fctsupported_080008c8",
                "au8Buffer": "au8Buffer",
                "u8regsize": "u8regsize",
                "u16errCnt": "u16errCnt",
                "LAB_0800080a": "LAB_0800080a",
                "switchD_08000816_caseD_1": "switchD_08000816_caseD_1",
                "FUN_080007f0": "checkModbusRequest_080007f0"
            },
            "code": "uint8_t __thiscall Modbus::checkModbusRequest_080007f0(Modbus *this)\n{\n  bool isSupportedFunction = false;\n  uint8_t errorCode = 0;\n  uint8_t functionCode = this->au8Buffer[1];\n  uint16_t startingAddress = makeWord(this->au8Buffer[2], this->au8Buffer[3]);\n  uint16_t numberOfRegisters = makeWord(this->au8Buffer[4], this->au8Buffer[5]);\n\n  for (uint i = 0; i < 8; i++) {\n    if (PTR_fctsupported_080008c8[i] == functionCode) {\n      isSupportedFunction = true;\n      break;\n    }\n  }\n\n  if (!isSupportedFunction) {\n    return errorCode;\n  }\n\n  switch (functionCode) {\n    case 0x01:\n    case 0x02:\n    case 0x0f:\n      break;\n    case 0x03:\n    case 0x04:\n    case 0x10:\n      if (this->u8regsize < (uint8_t)(startingAddress + numberOfRegisters)) {\n        errorCode = 0x02;\n      }\n      break;\n    case 0x05:\n      if (this->u8regsize < startingAddress) {\n        errorCode = 0x02;\n      }\n      break;\n    case 0x06:\n      if (this->u8regsize < startingAddress) {\n        errorCode = 0x02;\n      }\n      break;\n    default:\n      break;\n  }\n\n  if (errorCode != 0) {\n    this->u16errCnt++;\n  }\n\n  return errorCode;\n}",
            "called": [
                "makeWord"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080007f0",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "checkModbusRequest_080007f0"
        },
        "FUN_0800477e": {
            "renaming": {
                "FUN_0800477e": "handleExternalInterrupt_0800477e",
                "DAT_08004100": "GPIO_PIN_8"
            },
            "code": "void handleExternalInterrupt_0800477e(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(DAT_08004100);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800477e",
            "calling": [],
            "imported": false,
            "current_name": "handleExternalInterrupt_0800477e"
        },
        "FUN_0800562a": {
            "renaming": {
                "FUN_0800562a": "write_to_file_0800562a",
                "param_1": "file_descriptor",
                "param_2": "buffer_address",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "void write_to_file_0800562a(int file_descriptor, int buffer_address, void* buffer, size_t buffer_size)\n{\n    uint16_t* ptr_buffer_size = (uint16_t*)(buffer_address + 0xc);\n    uint32_t file_offset = (*ptr_buffer_size << 0x17);\n    if ((int)file_offset < 0) {\n        int seek_result = _lseek_r(file_descriptor, (int)*(short *)(buffer_address + 0xe), 0, 2);\n        if (seek_result < 0) {\n            return;\n        }\n    }\n    *ptr_buffer_size = (*ptr_buffer_size & 0xefff);\n    _write_r(file_descriptor, (int)*(short *)(buffer_address + 0xe), buffer, buffer_size);\n    return;\n}",
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800562a",
            "calling": [],
            "imported": false,
            "current_name": "write_to_file_0800562a"
        },
        "FUN_080044d8": {
            "renaming": {
                "FUN_080044d8": "initialize_serial_080044d8",
                "__initialize_p": "should_initialize",
                "__priority": "priority",
                "PTR_Serial3_080044f8": "serial3",
                "DAT_080044f4": "SERIAL_8N1"
            },
            "code": "void initialize_serial_080044d8(int should_initialize, int priority) {\n    if (should_initialize != 1) {\n        return;\n    }\n    if (priority == 0xffff) {\n        HardwareSerial::HardwareSerial(&PTR_Serial3_080044f8, DAT_080044f4);\n    }\n    return;\n}",
            "called": [
                "HardwareSerial"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080044d8",
            "calling": [
                "_GLOBAL__sub_I_Serial3"
            ],
            "imported": false,
            "current_name": "initialize_serial_080044d8"
        },
        "FUN_08003df4": {
            "renaming": {
                "FUN_08003df4": "is_uart_transmitting_08003df4",
                "*obj": "*serial",
                "HVar1": "uart_state",
                "(UART_HandleTypeDef **) (PTR_uart_handlers_08003e14 + (uint)obj->index * 4)": "*(UART_HandleTypeDef **)(PTR_uart_handlers_08003e14 + (uint)serial->index * 4)"
            },
            "code": "bool is_uart_transmitting_08003df4(serial_t *serial) {\n  UART_HandleTypeDef *uart_handler = (UART_HandleTypeDef **) (PTR_uart_handlers_08003e14 + (uint)obj->index * 4);\n  HAL_UART_StateTypeDef uart_state = HAL_UART_GetState(uart_handler);\n  return (uart_state & 0x21U) == 0x21;\n}",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003df4",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "is_uart_transmitting_08003df4"
        },
        "FUN_08005400": {
            "renaming": {
                "FUN_08005400": "initialize_array_08005400",
                "param_1": "error_code",
                "piVar1": "array_ptr",
                "piVar2": "current_element_ptr",
                "iVar3": "global_impure_ptr",
                "ppiVar4": "array_of_arrays_ptr"
            },
            "code": "int * initialize_array_08005400(undefined4 *error_code)\n{\n  int *array_ptr;\n  int *current_element_ptr;\n  int global_impure_ptr = *(int *)PTR__global_impure_ptr_08005474;\n  if (*(int *)(global_impure_ptr + 0x18) == 0) {\n    __sinit(global_impure_ptr);\n  }\n  int **array_of_arrays_ptr = (int **)(global_impure_ptr + 0x48);\n  do {\n    current_element_ptr = array_of_arrays_ptr[2];\n    array_ptr = array_of_arrays_ptr[1];\n    while (array_ptr = (int *)((int)array_ptr + -1), -1 < (int)array_ptr) {\n      if (*(short *)(current_element_ptr + 3) == 0) {\n        *(undefined2 *)((int)current_element_ptr + 0xe) = 0xffff;\n        *(undefined2 *)(current_element_ptr + 3) = 1;\n        current_element_ptr[0x19] = 0;\n        *current_element_ptr = 0;\n        current_element_ptr[2] = 0;\n        current_element_ptr[1] = 0;\n        current_element_ptr[4] = 0;\n        current_element_ptr[5] = 0;\n        current_element_ptr[6] = 0;\n        memset(current_element_ptr + 0x17,0,8);\n        current_element_ptr[0xd] = 0;\n        current_element_ptr[0xe] = 0;\n        current_element_ptr[0x12] = 0;\n        current_element_ptr[0x13] = 0;\n        return current_element_ptr;\n      }\n      current_element_ptr = current_element_ptr + 0x1a;\n    }\n    if (*array_of_arrays_ptr == (int *)0x0) {\n      array_ptr = (int *)__sfmoreglue(error_code,4);\n      *array_of_arrays_ptr = array_ptr;\n      if (array_ptr == (int *)0x0) {\n        *error_code = 0xc;\n        return (int *)0x0;\n      }\n    }\n    array_of_arrays_ptr = (int **)*array_of_arrays_ptr;\n  } while( true );\n}",
            "called": [
                "memset",
                "__sfmoreglue",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005400",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_array_08005400"
        },
        "FUN_08003582": {
            "renaming": {
                "FUN_08003582": "find_non_null_ptr_08003582",
                "a": "ptr1",
                "b": "ptr2"
            },
            "code": "void * find_non_null_ptr_08003582(void *ptr1, void *ptr2)\n{\n  if (ptr1 != ptr2) {\n    if (ptr1 == NULL) {\n      return ptr2;\n    }\n    if (ptr2 == NULL) {\n      return ptr1;\n    }\n    ptr1 = NULL;\n  }\n  return ptr1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003582",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "find_non_null_ptr_08003582"
        },
        "FUN_08004792": {
            "renaming": {
                "FUN_08004792": "handle_gpio_exti_irq_08004792",
                "uVar1": "gpio_pin"
            },
            "code": "void handle_gpio_exti_irq_08004792(void)\n{\n  uint16_t gpio_pin = 0x20;\n  while (gpio_pin < 0x201) {\n    HAL_GPIO_EXTI_IRQHandler(gpio_pin);\n    gpio_pin = gpio_pin << 1;\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004792",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_irq_08004792"
        },
        "FUN_08005760": {
            "renaming": {
                "std::FUN_08005760": "abort_program",
                "FUN_08005760": "abort_program_08005760"
            },
            "code": "void abort_program_08005760(void)\n{\n    abort();\n}",
            "called": [
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005760",
            "calling": [
                "operator()"
            ],
            "imported": false,
            "current_name": "abort_program_08005760"
        },
        "FUN_08004678": {
            "renaming": {
                "FUN_08004678": "get_bit_position_of_pin_08004678",
                "pin": "pin",
                "uVar1": "current_pin",
                "uVar2": "bit_position"
            },
            "code": "uint8_t get_bit_position_of_pin_08004678(uint16_t pin)\n{\n    uint16_t current_pin = pin;\n    uint8_t bit_position = 0;\n    while (current_pin != 1)\n    {\n        current_pin = current_pin >> 1;\n        bit_position++;\n    }\n    return bit_position;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004678",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "get_bit_position_of_pin_08004678"
        },
        "FUN_08003900": {
            "renaming": {
                "FUN_08003900": "enable_i2c_listener_08003900",
                "hi2c": "i2c_handler",
                "piVar1": "i2c_object",
                "get_i2c_obj": "get_i2c_object",
                "isMaster": "is_master"
            },
            "code": "void enable_i2c_listener_08003900(I2C_HandleTypeDef *i2c_handler)\n{\n  i2c_t *i2c_object = get_i2c_object(i2c_handler);\n  if (i2c_object->is_master == false) {\n    HAL_I2C_EnableListen_IT(i2c_handler);\n  }\n  return;\n}",
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003900",
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "imported": false,
            "current_name": "enable_i2c_listener_08003900"
        },
        "FUN_08005768": {
            "renaming": {
                "std::ctype_byname<char>::FUN_08005768": "set_pointers_to_one",
                "PTR_id_080057fc": "id_080057fc",
                "PTR_id_08005800": "id_08005800",
                "PTR_id_08005804": "id_08005804",
                "PTR_id_08005808": "id_08005808",
                "PTR_id_0800580c": "id_0800580c",
                "PTR_id_08005810": "id_08005810",
                "PTR_id_08005814": "id_08005814",
                "PTR_id_08005818": "id_08005818",
                "PTR_id_0800581c": "id_0800581c",
                "PTR_id_08005820": "id_08005820",
                "PTR_id_08005824": "id_08005824",
                "PTR_id_08005828": "id_08005828",
                "FUN_08005768": "set_pointers_to_one_08005768"
            },
            "code": "void set_pointers_to_one_08005768(void)\n{\n    if (*PTR_id_080057fc < 0x80000000)\n    {\n        *PTR_id_080057fc = 1;\n    }\n    if (*PTR_id_08005800 < 0x80000000)\n    {\n        *PTR_id_08005800 = 1;\n    }\n    if (*PTR_id_08005804 < 0x80000000)\n    {\n        *PTR_id_08005804 = 1;\n    }\n    if (*PTR_id_08005808 < 0x80000000)\n    {\n        *PTR_id_08005808 = 1;\n    }\n    if (*PTR_id_0800580c < 0x80000000)\n    {\n        *PTR_id_0800580c = 1;\n    }\n    if (*PTR_id_08005810 < 0x80000000)\n    {\n        *PTR_id_08005810 = 1;\n    }\n    if (*PTR_id_08005814 < 0x80000000)\n    {\n        *PTR_id_08005814 = 1;\n    }\n    if (*PTR_id_08005818 < 0x80000000)\n    {\n        *PTR_id_08005818 = 1;\n    }\n    if (*PTR_id_0800581c < 0x80000000)\n    {\n        *PTR_id_0800581c = 1;\n    }\n    if (*PTR_id_08005820 < 0x80000000)\n    {\n        *PTR_id_08005820 = 1;\n    }\n    if (*PTR_id_08005824 < 0x80000000)\n    {\n        *PTR_id_08005824 = 1;\n    }\n    if (*PTR_id_08005828 < 0x80000000)\n    {\n        *PTR_id_08005828 = 1;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005768",
            "calling": [],
            "imported": false,
            "current_name": "set_pointers_to_one_08005768"
        },
        "FUN_08000f0c": {
            "renaming": {
                "FUN_08000f0c": "set_irq_enable_bit_08000f0c",
                "IRQn": "irq",
                "uVar1": "irq_num",
                "DAT_08000f28": "irq_enable_reg"
            },
            "code": "void set_irq_enable_bit_08000f0c(IRQn_Type_conflict irq)\n{\n  uint irq_num = (uint)irq;\n  if (irq_num >= 0) {\n    uint32_t* DAT_08000f28 = (uint32_t*)(DAT_08000f28 + ((irq_num >> 5) + 0x60) * 4);\n    uint32_t irq_enable_bit = 1 << (irq_num & 0x1f);\n    *DAT_08000f28 = irq_enable_bit;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f0c",
            "calling": [
                "UART4_IRQHandler",
                "USART2_IRQHandler",
                "UART7_IRQHandler",
                "USART3_IRQHandler",
                "USART6_IRQHandler",
                "USART1_IRQHandler",
                "UART5_IRQHandler",
                "UART8_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_irq_enable_bit_08000f0c"
        },
        "FUN_08000998": {
            "renaming": {
                "__thiscall Modbus::FUN_08000998": "readRegistersAndSendResponse",
                "this": "modbus",
                "regs": "registers",
                "u8size": "numRegisters",
                "bVar1": "bufferIndex",
                "uVar2": "newBufferIndex",
                "uVar3": "startAddress",
                "uVar4": "numRegistersToRead",
                "uVar5": "registerIndex",
                "uVar6": "nextBufferIndex",
                "FUN_08000998": "readRegistersAndSendResponse_08000998"
            },
            "code": "int8_t __thiscall Modbus::readRegistersAndSendResponse_08000998(Modbus *modbus, uint16_t *registers, uint8_t numRegisters)\n{\n    byte startAddressByte1 = modbus->au8Buffer[2];\n    byte startAddressByte2 = modbus->au8Buffer[3];\n    byte numRegistersByte1 = modbus->au8Buffer[4];\n    byte numRegistersByte2 = modbus->au8Buffer[5];\n    uint16_t startAddress = makeWord(startAddressByte1, startAddressByte2);\n    uint16_t numRegistersToRead = makeWord(numRegistersByte1, numRegistersByte2);\n    modbus->au8Buffer[2] = numRegistersByte1 << 1;\n    modbus->u8BufferSize = 3;\n    for (uint i = (uint)startAddress; i < (uint)startAddress + (uint)numRegistersToRead; i++) {\n        byte bufferIndex = modbus->u8BufferSize;\n        modbus->au8Buffer[bufferIndex] = (uint8_t)(registers[i] >> 8);\n        bufferIndex++;\n        modbus->au8Buffer[bufferIndex] = *(uint8_t *)(registers + i);\n        bufferIndex++;\n        modbus->u8BufferSize = bufferIndex;\n    }\n    uint8_t responseSize = modbus->u8BufferSize;\n    sendTxBuffer(modbus);\n    return responseSize + 2;\n}",
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000998",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "readRegistersAndSendResponse_08000998"
        },
        "FUN_08003f94": {
            "renaming": {
                "FUN_08003f94": "initialize_uart_08003f94",
                "huart": "uart_handle",
                "tmpval": "register_value"
            },
            "code": "void initialize_uart_08003f94(UART_HandleTypeDef *huart)\n{\n  uint32_t register_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f94",
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "initialize_uart_08003f94"
        },
        "FUN_080055d0": {
            "renaming": {
                "FUN_080055d0": "execute_signal_handler_080055d0",
                "__sig": "signal_number",
                "iVar1": "return_value",
                "_FUN_080055d0_r": "_execute_signal_handler_r"
            },
            "code": "int execute_signal_handler_080055d0(int signal_number) {\n  int return_value;\n  return_value = _execute_signal_handler_080055d0_r(*(undefined4 *)PTR__impure_ptr_080055dc, signal_number);\n  return return_value;\n}",
            "called": [
                "_raise_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080055d0",
            "calling": [
                "abort"
            ],
            "imported": false,
            "current_name": "execute_signal_handler_080055d0"
        },
        "FUN_080056f8": {
            "renaming": {
                "FUN_080056f8": "is_terminal_080056f8",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "puVar1": "error_pointer",
                "iVar2": "is_terminal_result"
            },
            "code": "void is_terminal_080056f8(int *error_code, int file_descriptor)\n{\n    undefined *error_pointer;\n    int is_terminal_080056f8_result;\n    error_pointer = PTR_errno_08005714;\n    *(undefined4 *)PTR_errno_08005714 = 0;\n    is_terminal_080056f8_result = _isatty(file_descriptor);\n    if ((is_terminal_080056f8_result == -1) && (*(int *)error_pointer != 0)) {\n        *error_code = *(int *)error_pointer;\n    }\n    return;\n}",
            "called": [
                "_isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080056f8",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "is_terminal_080056f8"
        },
        "FUN_080054b4": {
            "renaming": {
                "FUN_080054b4": "check_file_permission_080054b4",
                "param_1": "file_descriptor",
                "param_2": "file_info_address",
                "param_3": "permission_result",
                "param_4": "flag_result",
                "iVar1": "file_status",
                "uVar2": "permission_flag",
                "auStack_4c": "file_status_buffer",
                "local_48": "flag_value"
            },
            "code": "int check_file_permission_080054b4(int file_descriptor, int file_info_address, int* permission_result, unsigned int* flag_result)\n{\n  int file_status;\n  int permission_flag;\n  unsigned int flag_value;\n  if (*(short *)(file_info_address + 0xe) < 0 || (_fstat_r(file_descriptor, (int)*(short *)(file_info_address + 0xe), &file_status) < 0))\n  {\n    *flag_result = 0;\n    if ((int)((uint)*(ushort *)(file_info_address + 0xc) << 0x18) < 0)\n    {\n      permission_flag = 0x40;\n      goto LAB_080054f4;\n    }\n  }\n  else\n  {\n    flag_value = (unsigned int)((file_status & 0xf000) == 0x2000);\n    *flag_result = flag_value;\n  }\n  permission_flag = 0x400;\nLAB_080054f4:\n  *permission_result = permission_flag;\n  return 0;\n}",
            "called": [
                "_fstat_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080054b4",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_file_permission_080054b4"
        },
        "FUN_0800171a": {
            "renaming": {
                "FUN_0800171a": "i2c_data_transfer_0800171a",
                "*hi2c": "*handle",
                "HVar1": "state",
                "pbVar2": "buffer",
                "uVar3": "options",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_I2C_MODE_MEM": "HAL_I2C_MODE_MEM",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "HAL_I2C_STATE_BUSY_RX": "HAL_I2C_STATE_BUSY_RX",
                "HAL_I2C_MasterTxCpltCallback": "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback": "HAL_I2C_MemTxCpltCallback",
                "Instance": "handle->Instance",
                "XferSize": "handle->XferSize",
                "XferOptions": "handle->XferOptions",
                "PreviousState": "handle->PreviousState",
                "Mode": "handle->Mode",
                "MemaddSize": "handle->MemaddSize",
                "Memaddress": "handle->Memaddress",
                "EventCount": "handle->EventCount",
                "State": "handle->State",
                "CR2": "handle->Instance->CR2",
                "CR1": "handle->Instance->CR1",
                "pBuffPtr": "handle->pBuffPtr",
                "XferCount": "handle->XferCount",
                "DR": "handle->Instance->DR"
            },
            "code": "HAL_StatusTypeDef i2c_data_transfer_0800171a(I2C_HandleTypeDef *handle)\n{\n  HAL_I2C_StateTypeDef state;\n  uint32_t options;\n  byte *buffer;\n  state = handle->State;\n  options = handle->XferOptions;\n  if ((handle->XferSize == 0) && (state == HAL_I2C_STATE_BUSY_TX)) {\n    if ((options == 4) || ((options == 8 || (options == 0xffff0000)))) {\n      handle->Instance->CR2 = handle->Instance->CR2 & 0xfffff8ff;\n      handle->Instance->CR1 = handle->Instance->CR1 | 0x200;\n      handle->PreviousState = 0;\n      handle->State = HAL_I2C_STATE_READY;\n      if (handle->Mode == HAL_I2C_MODE_MEM) {\n        handle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(handle);\n      }\n      else {\n        handle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(handle);\n      }\n    }\n    else {\n      handle->Instance->CR2 = handle->Instance->CR2 & 0xfffff8ff;\n      handle->PreviousState = 0x11;\n      handle->Mode = HAL_I2C_MODE_NONE;\n      handle->State = HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(handle);\n    }\n  }\n  else if ((state == HAL_I2C_STATE_BUSY_TX) || ((handle->Mode == HAL_I2C_MODE_MEM && (state == HAL_I2C_STATE_BUSY_RX)))) {\n    if (handle->XferCount == 0) {\n      handle->Instance->CR2 = handle->Instance->CR2 & 0xfffffbff;\n    }\n    else if (handle->Mode == HAL_I2C_MODE_MEM) {\n      if (handle->EventCount == 0) {\n        if (handle->MemaddSize == 1) {\n          handle->Instance->DR = handle->Memaddress & 0xff;\n          handle->EventCount = handle->EventCount + 2;\n        }\n        else {\n          handle->Instance->DR = (handle->Memaddress << 0x10) >> 0x18;\n          handle->EventCount = handle->EventCount + 1;\n        }\n      }\n      else if (handle->EventCount == 1) {\n        handle->Instance->DR = handle->Memaddress & 0xff;\n        handle->EventCount = handle->EventCount + 1;\n      }\n      else if (handle->EventCount == 2) {\n        if (state == HAL_I2C_STATE_BUSY_RX) {\n          handle->Instance->CR1 = handle->Instance->CR1 | 0x100;\n        }\n        else if (state == HAL_I2C_STATE_BUSY_TX) {\n          buffer = handle->pBuffPtr;\n          handle->pBuffPtr = buffer + 1;\n          handle->Instance->DR = (uint)*buffer;\n          handle->XferCount = handle->XferCount - 1;\n        }\n      }\n    }\n    else {\n      buffer = handle->pBuffPtr;\n      handle->pBuffPtr = buffer + 1;\n      handle->Instance->DR = (uint)*buffer;\n      handle->XferCount = handle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800171a",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_data_transfer_0800171a"
        },
        "FUN_08004560": {
            "renaming": {
                "FUN_08004560": "initializeIPAddress_08004560",
                "__initialize_p": "shouldInitialize",
                "__priority": "priority"
            },
            "code": "void initializeIPAddress_08004560(int shouldInitialize, int priority) {\n    if (shouldInitialize == 1 && priority == 0xffff) {\n        IPAddress::IPAddress((IPAddress *)PTR_INADDR_NONE_08004588, '\\0', '\\0', '\\0', '\\0');\n        return;\n    }\n    return;\n}",
            "called": [
                "IPAddress"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004560",
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "imported": false,
            "current_name": "initializeIPAddress_08004560"
        },
        "FUN_08000a7a": {
            "renaming": {
                "FUN_08000a7a": "decode_Modbus_packet_08000a7a",
                "this": "modbus_instance",
                "regs": "register_array",
                "u8size": "packet_size",
                "uVar1": "starting_address",
                "uVar2": "num_data_points",
                "uVar3": "i",
                "uVar4": "bit_index",
                "uVar5": "bit_offset",
                "uVar6": "word_index",
                "uVar7": "byte_index",
                "au8Buffer": "packet_buffer",
                "makeWord": "combine_bytes",
                "ushort": "uint16_t",
                "int8_t": "int8_t",
                "uint8_t": "uint8_t",
                "uint16_t": "uint16_t",
                "sendTxBuffer": "send_transmit_buffer"
            },
            "code": "int8_t __thiscall decode_Modbus_packet_08000a7a(Modbus *modbus_instance, uint16_t *regs, uint8_t packet_size) {\n  uint16_t starting_address = makeWord(modbus_instance->au8Buffer[2], modbus_instance->au8Buffer[3]);\n  uint16_t num_data_points = makeWord(modbus_instance->au8Buffer[4], modbus_instance->au8Buffer[5]);\n  uint bit_index = 0;\n  uint byte_index = 7;\n  for (uint i = 0; i < num_data_points; i++) {\n    uint word_index = (i + starting_address) / 16;\n    uint bit_offset = (i + starting_address) % 16;\n    bool is_bit_set = ((int)(uint)modbus_instance->au8Buffer[byte_index] >> bit_index) & 1U;\n    if (!is_bit_set) {\n      regs[word_index] &= ~(1 << bit_offset);\n    }\n    else {\n      regs[word_index] |= (1 << bit_offset);\n    }\n    bit_index = (bit_index + 1) % 8;\n    if (bit_index == 0) {\n      byte_index++;\n    }\n  }\n  modbus_instance->u8BufferSize = 6;\n  sendTxBuffer(modbus_instance);\n  return 8;\n}",
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a7a",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "decode_Modbus_packet_08000a7a"
        },
        "FUN_08003474": {
            "renaming": {
                "FUN_08003474": "do_nothing_08003474"
            },
            "code": "\nvoid do_nothing_08003474(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003474",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "do_nothing_08003474"
        },
        "FUN_08004cb0": {
            "renaming": {
                "FUN_08004cb0": "encode_string_08004cb0",
                "param_1": "param_1",
                "param_2": "source",
                "param_3": "dest",
                "param_4": "param_4",
                "param_5": "encoder",
                "iVar1": "index",
                "uVar2": "max_length",
                "uVar3": "dest_length",
                "bVar4": "is_aligned"
            },
            "code": "undefined4 encode_string_08004cb0(\n        undefined4 param_1,\n        uint *source,\n        uint *dest,\n        undefined4 param_4,\n        code *encoder\n    ) {\n        int index;\n        uint max_length;\n        uint dest_length;\n        bool is_aligned;\n        \n        max_length = source[4];\n        if ((int)source[4] < (int)source[2]) {\n            max_length = source[2];\n        }\n        *dest = max_length;\n        if (*(char *)((int)source + 0x43) != \"\\0\") {\n            *dest = max_length + 1;\n        }\n        if ((int)(*source << 0x1a) < 0) {\n            *dest = *dest + 2;\n        }\n        index = *source & 6;\n        if (index == 0) {\n            for (; (int)index < (int)(source[3] - *dest); index++) {\n                int result = (*encoder)(param_1, param_4, (int)source + 0x19, 1);\n                if (result == -1) {\n                    return 0xffffffff;\n                }\n            }\n        }\n        dest_length = (uint)*(byte *)((int)source + 0x43);\n        if (dest_length != 0) {\n            dest_length = 1;\n        }\n        if ((int)(*source << 0x1a) < 0) {\n            *(undefined *)((int)source + dest_length + 0x43) = 0x30;\n            *(undefined *)((int)source + dest_length + 0x44) = *(undefined *)((int)source + 0x45);\n            dest_length += 2;\n        }\n        int result = (*encoder)(param_1, param_4, (int)source + 0x43, dest_length);\n        if (result != -1) {\n            uint source_length = source[3];\n            is_aligned = (*source & 6) == 4;\n            if (is_aligned) {\n                source_length = source_length - *dest;\n            }\n            if (is_aligned) {\n                source_length = source_length & ~((int)source_length >> 0x1f);\n            }\n            else {\n                source_length = 0;\n            }\n            if ((int)source[4] < (int)source[2]) {\n                source_length = source_length + (source[2] - source[4]);\n            }\n            uint i = 0;\n            while (true) {\n                if (source_length == i) {\n                    return 0;\n                }\n                int result = (*encoder)(param_1, param_4, (int)source + 0x1a, 1);\n                if (result == -1) {\n                    break;\n                }\n                i++;\n            }\n        }\n        return 0xffffffff;\n    }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004cb0",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "encode_string_08004cb0"
        },
        "FUN_08003594": {
            "renaming": {
                "FUN_08003594": "call_RTC_user_callback_08003594",
                "hrtc": "rtc_handle",
                "PTR_RTCUserCallback_080035a4": "rtc_user_callback_ptr",
                "PTR_callbackUserData_080035a8": "callback_user_data_ptr"
            },
            "code": "void call_RTC_user_callback_08003594(RTC_HandleTypeDef *rtc_handle)\n{\n  if (*(code **)PTR_RTCUserCallback_080035a4 != (code *)0x0) {\n    (**(code **)PTR_RTCUserCallback_080035a4)(*(undefined4 *)PTR_callbackUserData_080035a8);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003594",
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "imported": false,
            "current_name": "call_RTC_user_callback_08003594"
        },
        "FUN_08002940": {
            "renaming": {
                "FUN_08002940": "reset_uart_08002940",
                "*huart": "*uart_handle",
                "Instance": "instance",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "RxState": "receive_state",
                "HAL_UART_STATE_READY": "ready_state"
            },
            "code": "void reset_uart_08002940(UART_HandleTypeDef *uart_handle)\n{\n  uart_handle->Instance->CR1 &= ~(1 << 13);\n  uart_handle->Instance->CR3 &= ~(1 << 0);\n  uart_handle->RxState = HAL_UART_STATE_READY;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002940",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "reset_uart_08002940"
        },
        "FUN_08004204": {
            "renaming": {
                "FUN_08004204": "get_current_milli_seconds_08004204",
                "uVar1": "current_milli_seconds"
            },
            "code": "uint32_t get_current_milli_seconds_08004204(void)\n{\n  uint32_t current_milli_seconds;\n  current_milli_seconds = GetCurrentMilli();\n  return current_milli_seconds;\n}",
            "called": [
                "GetCurrentMilli"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004204",
            "calling": [
                "sendTxBuffer",
                "poll"
            ],
            "imported": false,
            "current_name": "get_current_milli_seconds_08004204"
        },
        "FUN_08003476": {
            "renaming": {
                "FUN_08003476": "handleSystemTick_08003476",
                "noOsSystickHandler": "handleNoOsSystick"
            },
            "code": "void handleSystemTick_08003476(void)\n{\n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  handleNoOsSystick();\n  return;\n}",
            "called": [
                "HAL_IncTick",
                "noOsSystickHandler",
                "HAL_SYSTICK_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003476",
            "calling": [],
            "imported": false,
            "current_name": "handleSystemTick_08003476"
        },
        "FUN_08004444": {
            "renaming": {
                "FUN_08004444": "set_rx_pin_08004444",
                "_rx": "rx_pin_number",
                "PVar1": "rx_pin",
                "PTR_digitalPin_0800445c": "PTR_digitalPin",
                "this": "serial"
            },
            "code": "void __thiscall HardwareSerial::set_rx_pin_08004444(HardwareSerial *serial, uint32_t rx_pin_number)\n{\n  PinName rx_pin;\n  if (rx_pin_number < 0x60) {\n    rx_pin = *(PinName *)(PTR_digitalPin_0800445c_0800445c + rx_pin_number * 2);\n  }\n  else {\n    rx_pin = NC;\n  }\n  (serial->_serial).pin_rx = rx_pin;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004444",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "set_rx_pin_08004444"
        },
        "FUN_080055e0": {
            "renaming": {
                "FUN_080055e0": "kill_process_and_handle_error_080055e0",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal",
                "puVar1": "error_ptr",
                "iVar2": "kill_result"
            },
            "code": "void kill_process_and_handle_error_080055e0(int *error_code, int process_id, int signal) {\n    undefined *error_ptr;\n    int kill_result;\n    error_ptr = PTR_errno_08005600;\n    *(undefined4 *)PTR_errno_08005600 = 0;\n    kill_result = _kill(process_id, signal);\n    if ((kill_result == -1) && (*(int *)error_ptr != 0)) {\n        *error_code = *(int *)error_ptr;\n    }\n    return;\n}",
            "called": [
                "_kill"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080055e0",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "kill_process_and_handle_error_080055e0"
        },
        "FUN_0800346c": {
            "renaming": {
                "FUN_0800346c": "get_current_tick_0800346c",
                "uVar1": "current_tick"
            },
            "code": "uint32_t get_current_tick_0800346c(void)\n{\n  uint32_t current_tick = HAL_GetTick();\n  return current_tick;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800346c",
            "calling": [
                "millis"
            ],
            "imported": false,
            "current_name": "get_current_tick_0800346c"
        },
        "FUN_080053a0": {
            "renaming": {
                "FUN_080053a0": "initialize_data_080053a0",
                "param_1": "data_ptr",
                "uVar1": "sfp_value",
                "iVar2": "is_current_ptr",
                "bVar3": "is_current_ptr",
                "PTR__global_impure_ptr_080053f8": "global_impure_ptr",
                "DAT_080053fc": "global_impure_ptr_value"
            },
            "code": "void initialize_data_080053a0(int data_ptr)\n{\n  bool is_global_ptr = *(int *)(data_ptr + 0x18) == 0;\n  if (is_global_ptr) {\n    *(int *)(data_ptr + 0x18) = 1;\n    *(int *)(data_ptr + 0x48) = 0;\n    *(int *)(data_ptr + 0x4c) = 0;\n    *(int *)(data_ptr + 0x50) = 0;\n    *(int *)(data_ptr + 0x28) = DAT_080053fc;\n    int is_current_ptr = data_ptr == PTR__global_impure_ptr_080053f8;\n    if (is_current_ptr) {\n      *(int *)(data_ptr + 0x18) = 1;\n    }\n    int sfp1 = __sfp();\n    *(int *)(data_ptr + 4) = sfp1;\n    int sfp2 = __sfp(data_ptr);\n    *(int *)(data_ptr + 8) = sfp2;\n    int sfp3 = __sfp(data_ptr);\n    *(int *)(data_ptr + 0xc) = sfp3;\n    std_isra_0(sfp1, 4, 0);\n    std_isra_0(sfp2, 9, 1);\n    std_isra_0(sfp3, 0x12, 2);\n  }\n}",
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053a0",
            "calling": [
                "__swbuf_r",
                "__swsetup_r",
                "_vfiprintf_r",
                "_fflush_r",
                "__sfp",
                "iprintf"
            ],
            "imported": false,
            "current_name": "initialize_data_080053a0"
        },
        "FUN_08003918": {
            "renaming": {
                "FUN_08003918": "handle_I2C_events_08003918",
                "PTR_i2c_handles_08003924": "i2c_handle_ptr"
            },
            "code": "void handle_I2C_events_08003918(void)\n{\n  I2C_HandleTypeDef *i2c_handle = *(I2C_HandleTypeDef **)PTR_i2c_handles_08003924;\n  HAL_I2C_EV_IRQHandler(i2c_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003918",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_events_08003918"
        },
        "FUN_0800201c": {
            "renaming": {
                "FUN_0800201c": "configure_RCC_Oscillator_0800201c",
                "RCC_OscInitStruct": "osc_init_conf",
                "puVar1": "ptr",
                "HVar2": "status",
                "uVar3": "start_time",
                "uVar4": "current_time",
                "bVar5": "flag",
                "tmpreg": "temp_reg"
            },
            "code": "\nHAL_StatusTypeDef configure_RCC_Oscillator_0800201c(RCC_OscInitTypeDef_conflict *osc_init_conf)\n\n{\n  uint *ptr;\n  HAL_StatusTypeDef status;\n  uint32_t start_time;\n  uint32_t current_time;\n  bool flag;\n  uint32_t temp_reg;\n  \n  ptr = DAT_080022d0;\n  if (osc_init_conf == (RCC_OscInitTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if ((osc_init_conf->OscillatorType & 1) != 0) {\n    if (((DAT_080022d0[2] & 0xc) == 4) ||\n       (((DAT_080022d0[2] & 0xc) == 8 && ((DAT_080022d0[1] & 0x400000) != 0)))) {\n      if (((*DAT_080022d0 & 0x20000) != 0) && (osc_init_conf->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (osc_init_conf->HSEState == 0x10000) {\n        *DAT_080022d0 = *DAT_080022d0 | 0x10000;\n      }\n      else if (osc_init_conf->HSEState == 0x50000) {\n        *DAT_080022d0 = *DAT_080022d0 | 0x40000;\n        *ptr = *ptr | 0x10000;\n      }\n      else {\n        *DAT_080022d0 = *DAT_080022d0 & 0xfffeffff;\n        *ptr = *ptr & 0xfffbffff;\n      }\n      if (osc_init_conf->HSEState == 0) {\n        start_time = HAL_GetTick();\n        while ((*DAT_080022d0 & 0x20000) != 0) {\n          current_time = HAL_GetTick();\n          if (100 < current_time - start_time) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        start_time = HAL_GetTick();\n        while ((*DAT_080022d0 & 0x20000) == 0) {\n          current_time = HAL_GetTick();\n          if (100 < current_time - start_time) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((osc_init_conf->OscillatorType & 2) != 0) {\n    if (((DAT_080022d0[2] & 0xc) == 0) ||\n       (((DAT_080022d0[2] & 0xc) == 8 && ((DAT_080022d0[1] & 0x400000) == 0)))) {\n      if (((*DAT_080022d0 & 2) != 0) && (osc_init_conf->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      *DAT_080022d0 = *DAT_080022d0 & 0xffffff07 | osc_init_conf->HSICalibrationValue << 3;\n    }\n    else if (osc_init_conf->HSIState == 0) {\n      *DAT_080022d4 = 0;\n      start_time = HAL_GetTick();\n      while ((*DAT_080022d0 & 2) != 0) {\n        current_time = HAL_GetTick();\n        if (2 < current_time - start_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_080022d4 = 1;\n      start_time = HAL_GetTick();\n      while ((*DAT_080022d0 & 2) == 0) {\n        current_time = HAL_GetTick();\n        if (2 < current_time - start_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_080022d0 = *DAT_080022d0 & 0xffffff07 | osc_init_conf->HSICalibrationValue << 3;\n    }\n  }\n  if ((osc_init_conf->OscillatorType & 8) != 0) {\n    if (osc_init_conf->LSIState == 0) {\n      *DAT_080022d8 = 0;\n      start_time = HAL_GetTick();\n      while ((DAT_080022d0[0x1d] & 2) != 0) {\n        current_time = HAL_GetTick();\n        if (2 < current_time - start_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_080022d8 = 1;\n      start_time = HAL_GetTick();\n      while ((DAT_080022d0[0x1d] & 2) == 0) {\n        current_time = HAL_GetTick();\n        if (2 < current_time - start_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((osc_init_conf->OscillatorType & 4) != 0) {\n    flag = (DAT_080022d0[0x10] & 0x10000000) == 0;\n    if (flag) {\n      DAT_080022d0[0x10] = DAT_080022d0[0x10] | 0x10000000;\n    }\n    if ((*DAT_080022dc & 0x100) == 0) {\n      *DAT_080022dc = *DAT_080022dc | 0x100;\n      start_time = HAL_GetTick();\n      while ((*DAT_080022dc & 0x100) == 0) {\n        current_time = HAL_GetTick();\n        if (2 < current_time - start_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    ptr = DAT_080022d0;\n    if (osc_init_conf->LSEState == 1) {\n      DAT_080022d0[0x1c] = DAT_080022d0[0x1c] | 1;\n    }\n    else if (osc_init_conf->LSEState == 5) {\n      DAT_080022d0[0x1c] = DAT_080022d0[0x1c] | 4;\n      ptr[0x1c] = ptr[0x1c] | 1;\n    }\n    else {\n      DAT_080022d0[0x1c] = DAT_080022d0[0x1c] & 0xfffffffe;\n      ptr[0x1c] = ptr[0x1c] & 0xfffffffb;\n    }\n    if (osc_init_conf->LSEState == 0) {\n      start_time = HAL_GetTick();\n      while ((DAT_080022d0[0x1c] & 2) != 0) {\n        current_time = HAL_GetTick();\n        if (5000 < current_time - start_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      start_time = HAL_GetTick();\n      while ((DAT_080022d0[0x1c] & 2) == 0) {\n        current_time = HAL_GetTick();\n        if (5000 < current_time - start_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (flag) {\n      DAT_080023ac[0x10] = DAT_080023ac[0x10] & 0xefffffff;\n    }\n  }\n  start_time = (osc_init_conf->PLL).PLLState;\n  if (start_time == 0) {\n    status = HAL_OK;\n  }\n  else if ((DAT_080023ac[2] & 0xc) == 8) {\n    status = HAL_ERROR;\n  }\n  else if (start_time == 2) {\n    *DAT_080023b0 = 0;\n    start_time = HAL_GetTick();\n    do {\n      if ((*DAT_080023ac & 0x2000000) == 0) {\n        DAT_080023ac[1] =\n             (osc_init_conf->PLL).PLLSource | (osc_init_conf->PLL).PLLM |\n             (osc_init_conf->PLL).PLLN << 6 |\n             (((osc_init_conf->PLL).PLLP >> 1) - 1) * 0x10000 |\n             (osc_init_conf->PLL).PLLQ << 0x18;\n        *DAT_080023b0 = 1;\n        start_time = HAL_GetTick();\n        do {\n          if ((*DAT_080023ac & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          current_time = HAL_GetTick();\n        } while (current_time - start_time < 3);\n        return HAL_TIMEOUT;\n      }\n      current_time = HAL_GetTick();\n    } while (current_time - start_time < 3);\n    status = HAL_TIMEOUT;\n  }\n  else {\n    *DAT_080023b0 = 0;\n    start_time = HAL_GetTick();\n    do {\n      if ((*DAT_080023ac & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      current_time = HAL_GetTick();\n    } while (current_time - start_time < 3);\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800201c",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configure_RCC_Oscillator_0800201c"
        },
        "FUN_080028d4": {
            "renaming": {
                "FUN_080028d4": "set_channel_state_080028d4",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "state",
                "CCER": "channel_enable_register",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "void set_channel_state_080028d4(TIM_TypeDef *timer, uint32_t channel, uint32_t state) {\n  uint32_t channel_mask = 4 << (channel & 0xff);\n  timer->CCER = (timer->CCER & ~channel_mask) | (state << (channel & 0xff));\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080028d4",
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "imported": false,
            "current_name": "set_channel_state_080028d4"
        },
        "FUN_0800293c": {
            "renaming": {
                "FUN_0800293c": "do_nothing_0800293c"
            },
            "code": "\nvoid do_nothing_0800293c(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800293c",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_0800293c"
        },
        "FUN_080040ec": {
            "renaming": {
                "FUN_080040ec": "send_uart_debug_message_080040ec",
                "file_UNUSED": "file",
                "ptr": "message",
                "len": "message_length",
                "sVar1": "bytes_sent",
                "uart_debugFUN_080040ec": "uart_debug_send_message"
            },
            "code": "size_t send_uart_debug_message_080040ec(int file, char *message, int message_length)\n{\n  size_t bytes_sent;\n  bytes_sent = uart_debug_send_message((uint8_t *)message, message_length);\n  return bytes_sent;\n}",
            "called": [
                "uart_debug_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040ec",
            "calling": [
                "_write_r"
            ],
            "imported": false,
            "current_name": "send_uart_debug_message_080040ec"
        },
        "FUN_08001460": {
            "renaming": {
                "FUN_08001460": "i2c_transfer_08001460",
                "hi2c": "handle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "options",
                "HVar1": "status",
                "pIVar2": "instance",
                "tmpreg": "unused"
            },
            "code": "HAL_StatusTypeDef i2c_transfer_08001460(I2C_HandleTypeDef *handle, uint8_t *data, uint16_t size, uint32_t options)\n{\n    HAL_StatusTypeDef status;\n    I2C_TypeDef *instance;\n\n    if (handle->State == HAL_I2C_STATE_LISTEN) {\n        if (data == NULL || size == 0) {\n            status = HAL_ERROR;\n        }\n        else if (handle->Lock == HAL_LOCKED) {\n            status = HAL_BUSY;\n        }\n        else {\n            handle->Lock = HAL_LOCKED;\n            instance = handle->Instance;\n            if ((instance->CR1 & 1) == 0) {\n                instance->CR1 |= 1;\n            }\n            instance->CR1 &= 0xfffff7ff;\n            handle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n            handle->Mode = HAL_I2C_MODE_SLAVE;\n            status = HAL_OK;\n            handle->ErrorCode = 0;\n            handle->pBuffPtr = data;\n            handle->XferCount = size;\n            handle->XferOptions = options;\n            handle->XferSize = handle->XferCount;\n            handle->Lock = HAL_UNLOCKED;\n            instance->CR2 |= 0x700;\n        }\n    }\n    else {\n        status = HAL_BUSY;\n    }\n    return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001460",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08001460"
        },
        "FUN_08004298": {
            "renaming": {
                "FUN_08004298": "wait_until_tx_buffer_is_empty_08004298",
                "this": "serial_object",
                "_written": "has_data_to_send",
                "_serial": "tx_buffer",
                "tx_head": "head",
                "tx_tail": "tail"
            },
            "code": "void __thiscall HardwareSerial::wait_until_tx_buffer_is_empty_08004298(HardwareSerial *serial_object)\n{\n  if (serial_object->has_data_to_send) {\n    do {\n    } while ((serial_object->tx_buffer).head != (serial_object->tx_buffer).tail);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004298",
            "calling": [],
            "imported": false,
            "current_name": "wait_until_tx_buffer_is_empty_08004298"
        },
        "FUN_08003880": {
            "renaming": {
                "FUN_08003880": "i2c_handle_slave_transmission_08003880",
                "hi2c": "i2c_handle",
                "TransferDirection": "transfer_direction",
                "AddrMatchCode": "address_match_code",
                "piVar1": "i2c_obj",
                "get_i2c_obj": "get_i2c_object",
                "i2cTxRxBufferSize": "tx_rx_buffer_size",
                "slaveMode": "slave_mode",
                "i2c_onSlaveTransmit": "i2c_on_slave_transmit",
                "i2cTxRxBuffer": "tx_rx_buffer"
            },
            "code": "void i2c_handle_slave_transmission_08003880(I2C_HandleTypeDef *hi2c, uint8_t transfer_direction, uint16_t address_match_code)\\n{\\n  i2c_t *i2c_obj;\\n  i2c_obj = get_i2c_obj(hi2c);\\n  if ((uint)address_match_code == (hi2c->Init).OwnAddress1) {\\n    if (transfer_direction == \"\\0\") {\\n      i2c_obj->tx_rx_buffer_size = \"\\0\";\\n      i2c_obj->slave_mode = \"\\0\";\\n      if (i2c_obj->i2c_on_slave_transmit != (_func_void *)0x0) {\\n        (*i2c_obj->i2c_on_slave_transmit)();\\n      }\\n      HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_obj->tx_rx_buffer, (ushort)i2c_obj->tx_rx_buffer_size, 8);\\n      return;\\n    }\\n    i2c_obj->slave_mode = \"\\x01\";\\n    HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_obj->tx_rx_buffer, 0x20, 8);\\n  }\\n  return;\\n}",
            "called": [
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003880",
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "imported": false,
            "current_name": "i2c_handle_slave_transmission_08003880"
        },
        "FUN_08003fd4": {
            "renaming": {
                "FUN_08003fd4": "handle_USART1_interrupt_08003fd4",
                "PTR_uart_handlers_08003fe8": "uart_handlers"
            },
            "code": "void handle_USART1_interrupt_08003fd4(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART1_IRQn);\n  HAL_UART_IRQHandler(*PTR_uart_handlers_08003fe8);\n  return;\n}",
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fd4",
            "calling": [],
            "imported": false,
            "current_name": "handle_USART1_interrupt_08003fd4"
        },
        "FUN_08002f4c": {
            "renaming": {
                "FUN_08002f4c": "resetUartState_08002f4c",
                "huart": "uart",
                "Instance": "instance",
                "CR1": "cr1",
                "gState": "g_state",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_UART_TxCpltCallback": "HAL_UART_TxCpltCallback",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef resetUartState_08002f4c(UART_HandleTypeDef *uart)\n{\n  uint32_t cr1 = uart->Instance->CR1 & 0xffffffbf;\n  uart->gState = HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(uart);\n  return HAL_OK;\n}",
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f4c",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "resetUartState_08002f4c"
        },
        "FUN_080035bc": {
            "renaming": {
                "FUN_080035bc": "initialize_system_080035bc",
                "puVar1": "system_data_ptr",
                "DAT_080035f0": "system_data_start_ptr",
                "DAT_080035f4": "system_data_end_ptr"
            },
            "code": "void initialize_system_080035bc(void)\n{\n  uint *system_data_ptr;\n\n  system_data_ptr = DAT_080035f0;\n  *DAT_080035f0 |= 1;\n  system_data_ptr[2] = 0;\n  *system_data_ptr &= 0xfef6ffff;\n  system_data_ptr[1] = DAT_080035f4;\n  *system_data_ptr &= 0xfffbffff;\n  system_data_ptr[3] = 0;\n  *(undefined4 *)(DAT_080035f4 + 8) = 0x8000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035bc",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "initialize_system_080035bc"
        },
        "FUN_08000c4c": {
            "renaming": {
                "FUN_08000c4c": "initializeModbusSlave_08000c4c"
            },
            "code": "void initializeModbusSlave_08000c4c(void)\n{\n  startForkserver(0);\n  Modbus::begin((Modbus *)PTR_slave_08000c60,0x4b00);\n  return;\n}",
            "called": [
                "begin",
                "startForkserver"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c4c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initializeModbusSlave_08000c4c"
        },
        "FUN_080025ec": {
            "renaming": {
                "FUN_080025ec": "get_HCLK_frequency_divider_080025ec",
                "uVar1": "hclk_freq",
                "DAT_08002604": "data_08002604",
                "PTR_APBPrescTable_08002608": "apb_prescaler_table",
                "apb_prescaler_index": "apb_prescaler_index",
                "apb_prescaler": "apb_prescaler"
            },
            "code": "uint32_t get_HCLK_frequency_divider_080025ec(void) {\n    uint32_t hclk_freq = HAL_RCC_GetHCLKFreq();\n    uint32_t apb_prescaler_index = ((*(int *)(DAT_08002604 + 8)) << 0x13) >> 0x1d;\n    uint32_t apb_prescaler = PTR_APBPrescTable_08002608[apb_prescaler_index];\n    return hclk_freq >> apb_prescaler;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025ec",
            "calling": [
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "get_HCLK_frequency_divider_080025ec"
        },
        "FUN_080037fc": {
            "renaming": {
                "FUN_080037fc": "handle_timer_interrupt_080037fc",
                "PTR_timer_handles_0800380c": "PTR_timer_handles_0800380c",
                "TIM_HandleTypeDef": "TIM_HandleTypeDef",
                "HAL_TIM_IRQHandler": "HAL_TIM_IRQHandler",
                "timer_handle_ptr": "timer_handle_ptr"
            },
            "code": "void handle_timer_interrupt_080037fc(void)\n{\n  TIM_HandleTypeDef *timer_handle_ptr = *(TIM_HandleTypeDef **)(PTR_timer_handles_0800380c + 0x18);\n  if (timer_handle_ptr != NULL) {\n    HAL_TIM_IRQHandler(timer_handle_ptr);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080037fc",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_080037fc"
        },
        "FUN_08004a60": {
            "renaming": {
                "FUN_08004a60": "write_to_stream_08004a60",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "iVar1": "write_count",
                "puVar2": "buffer_end",
                "iVar3": "buffer_index"
            },
            "code": "int write_to_stream_08004a60(undefined4 stream, undefined4 character, undefined *buffer, int buffer_size)\n{\n  int write_count = 0;\n  undefined *buffer_end = buffer + buffer_size;\n  int buffer_index = buffer_size;\n  do {\n    if (buffer == buffer_end) {\n      return 0;\n    }\n    write_count = __sfputc_r(stream, *buffer, character, buffer_size, buffer_index);\n    buffer_size = write_count + 1;\n    buffer = buffer + 1;\n  } while (buffer_size != 0);\n  return write_count;\n}",
            "called": [
                "__sfputc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a60",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_08004a60"
        },
        "FUN_080050d0": {
            "renaming": {
                "FUN_080050d0": "read_from_stream_and_set_flags_080050d0",
                "param_1": "read_status",
                "param_2": "stream",
                "uVar1": "result",
                "uVar2": "flags",
                "iVar3": "impure_ptr"
            },
            "code": "uint read_from_stream_and_set_flags_080050d0(undefined4 *read_status, undefined4 *stream) {\n  uint result;\n  ushort flags;\n  int impure_ptr = *(int *)PTR__impure_ptr_0800519c;\n  if (impure_ptr != 0 && *(int *)(impure_ptr + 0x18) == 0) {\n    __sinit(impure_ptr);\n  }\n  if (stream == (undefined4 *)PTR___sf_fake_stdin_080051a0) {\n    stream = *(undefined4 **)(impure_ptr + 4);\n  }\n  else if (stream == (undefined4 *)PTR___sf_fake_stdout_080051a4) {\n    stream = *(undefined4 **)(impure_ptr + 8);\n  }\n  else if (stream == (undefined4 *)PTR___sf_fake_stderr_080051a8) {\n    stream = *(undefined4 **)(impure_ptr + 0xc);\n  }\n  flags = *(ushort *)(stream + 3);\n  result = (uint)flags;\n  if (-1 < (int)(result << 0x1c)) {\n    if (-1 < (int)(result << 0x1b)) {\n      *read_status = 9;\n      goto LAB_08005100;\n    }\n    if ((int)(result << 0x1d) < 0) {\n      if ((undefined4 *)stream[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)stream[0xd] != stream + 0x11) {\n          _free_r(read_status);\n        }\n        stream[0xd] = 0;\n      }\n      *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xffdb;\n      stream[1] = 0;\n      *stream = stream[4];\n    }\n    *(ushort *)(stream + 3) = *(ushort *)(stream + 3) | 8;\n  }\n  if (stream[4] == 0 && ((flags & 0x280) != 0x200)) {\n    __smakebuf_r(read_status, stream);\n  }\n  flags = *(ushort *)(stream + 3);\n  result = flags & 1;\n  if ((flags & 1) == 0) {\n    if (-1 < (int)((uint)flags << 0x1e)) {\n      result = stream[5];\n    }\n    stream[2] = result;\n  }\n  else {\n    stream[2] = 0;\n    stream[6] = -stream[5];\n  }\n  if (stream[4] == 0) {\n    flags = *(ushort *)(stream + 3);\n    result = (int)(short)flags & 0x80;\n    if (result != 0) {\n      *(ushort *)(stream + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n",
            "called": [
                "__smakebuf_r",
                "_free_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080050d0",
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "read_from_stream_and_set_flags_080050d0"
        },
        "FUN_08004978": {
            "renaming": {
                "FUN_08004978": "allocate_memory_08004978",
                "param_1": "out_size",
                "param_2": "requested_size",
                "puVar1": "current_brk",
                "uVar2": "new_brk",
                "puVar3": "free_list",
                "iVar4": "padding_size",
                "uVar5": "free_block_size",
                "puVar6": "previous_free_block",
                "puVar7": "free_list",
                "uVar8": "aligned_size"
            },
            "code": "uint allocate_memory_08004978(uint *out_size, uint requested_size)\n{\n  uint aligned_size = (requested_size + 3 & 0xfffffffc) + 8;\n  if (aligned_size < 0xc) {\n    aligned_size = 0xc;\n  }\n  if (((int)aligned_size < 0) || (aligned_size < requested_size)) {\n    *out_size = 0xc;\n  }\n  else {\n    __malloc_lock();\n    void *current_brk = PTR___malloc_sbrk_start_08004a30;\n    uint *free_list = *(uint **)PTR___malloc_free_list_08004a2c;\n    uint *previous_free_block = *(uint **)PTR___malloc_free_list_08004a2c;\n    while (free_list != (uint *)0x0) {\n      uint free_block_size = *free_list - aligned_size;\n      if (-1 < (int)free_block_size) {\n        if (free_block_size < 0xc) {\n          if (previous_free_block == free_list) {\n            aligned_size = previous_free_block[1];\n          }\n          else {\n            aligned_size = free_list[1];\n          }\n          if (previous_free_block == free_list) {\n            *(uint *)PTR___malloc_free_list_08004a2c = aligned_size;\n            free_list = previous_free_block;\n          }\n          else {\n            previous_free_block[1] = aligned_size;\n          }\n        }\n        else {\n          *free_list = free_block_size;\n          *(uint *)((int)free_list + free_block_size) = aligned_size;\n          free_list = (uint *)((int)free_list + free_block_size);\n        }\n        goto LAB_080049dc;\n      }\n      previous_free_block = free_list;\n      free_list = (uint *)free_list[1];\n    }\n    if (*(int *)PTR___malloc_sbrk_start_08004a30 == 0) {\n      uint new_brk = _sbrk_r(out_size);\n      *(void **)current_brk = new_brk;\n    }\n    free_list = (uint *)_sbrk_r(out_size, aligned_size);\n    if ((free_list != (uint *)0xffffffff) &&\n       ((previous_free_block = (uint *)((int)free_list + 3U & 0xfffffffc), free_list == previous_free_block ||\n        (_sbrk_r(out_size,(int)previous_free_block - (int)free_list) != -1)))) {\n      *previous_free_block = aligned_size;\nLAB_080049dc:\n      __malloc_unlock(out_size);\n      aligned_size = (int)previous_free_block + 0xbU & 0xfffffff8;\n      int padding_size = aligned_size - (int)(previous_free_block + 1);\n      if (padding_size != 0) {\n        *(int *)((int)previous_free_block + padding_size) = -padding_size;\n        return aligned_size;\n      }\n      return aligned_size;\n    }\n    *out_size = 0xc;\n    __malloc_unlock(out_size);\n  }\n  return 0;\n}",
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004978",
            "calling": [
                "__sfmoreglue",
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08004978"
        },
        "FUN_08002d0c": {
            "renaming": {
                "FUN_08002d0c": "check_flag_status_08002d0c",
                "*huart": "*uart",
                "Flag": "flag",
                "Status": "status",
                "Tickstart": "start_time",
                "Timeout": "timeout",
                "uVar1": "current_time"
            },
            "code": "HAL_StatusTypeDef check_flag_status_08002d0c(UART_HandleTypeDef *uart, uint32_t flag, FlagStatus status, uint32_t start_time, uint32_t timeout) {\n\tuint32_t current_time;\n\twhile ((timeout == 0xffffffff) || ((timeout != 0) && ((current_time = HAL_GetTick()) - start_time <= timeout))) {\n\t\tif (((flag & ~uart->Instance->SR) == 0) != (bool)status) {\n\t\t\treturn HAL_OK;\n\t\t}\n\t}\n\tuart->Instance->CR1 &= 0xfffffe5f;\n\tuart->Instance->CR3 &= 0xfffffffe;\n\tuart->gState = HAL_UART_STATE_READY;\n\tuart->RxState = HAL_UART_STATE_READY;\n\tuart->Lock = HAL_UNLOCKED;\n\treturn HAL_TIMEOUT;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d0c",
            "calling": [
                "HAL_UART_Transmit"
            ],
            "imported": false,
            "current_name": "check_flag_status_08002d0c"
        },
        "FUN_0800404c": {
            "renaming": {
                "FUN_0800404c": "handle_usart6_interrupt_0800404c",
                "USART6_IRQn": "USART6_Interrupt",
                "*(UART_HandleTypeDef **)(PTR_uart_handlers_08004060 + 0x14)": "huart",
                "HAL_NVIC_ClearPendingIRQ": "clear_usart6_pending_irq",
                "HAL_UART_IRQHandler": "handle_uart_interrupt"
            },
            "code": "void handle_usart6_interrupt_0800404c(UART_HandleTypeDef **(UART_HandleTypeDef **)(PTR_uart_handlers_08004060 + 0x14))\n{\n  HAL_NVIC_ClearPendingIRQ(USART6_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004060 + 0x14));\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800404c",
            "calling": [],
            "imported": false,
            "current_name": "handle_usart6_interrupt_0800404c"
        },
        "FUN_08001902": {
            "renaming": {
                "FUN_08001902": "do_nothing_08001902"
            },
            "code": "\nvoid do_nothing_08001902(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001902",
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "imported": false,
            "current_name": "do_nothing_08001902"
        },
        "FUN_08001904": {
            "renaming": {
                "FUN_08001904": "readDataFromI2C_08001904",
                "*hi2c": "*i2c_handle",
                "puVar1": "buffer_pointer"
            },
            "code": "HAL_StatusTypeDef readDataFromI2C_08001904(I2C_HandleTypeDef *i2c_handle)\n{\n  uint8_t *buffer_pointer;\n  \n  if (i2c_handle->State == HAL_I2C_STATE_BUSY_RX) {\n    if (i2c_handle->XferCount < 4) {\n      if (i2c_handle->XferCount < 2) {\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffbff;\n        i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n        buffer_pointer = i2c_handle->pBuffPtr;\n        i2c_handle->pBuffPtr = buffer_pointer + 1;\n        *buffer_pointer = (uint8_t)i2c_handle->Instance->DR;\n        i2c_handle->XferCount = i2c_handle->XferCount - 1;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        i2c_handle->PreviousState = 0;\n        if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n          i2c_handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(i2c_handle);\n        }\n        else {\n          i2c_handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(i2c_handle);\n        }\n      }\n    }\n    else {\n      buffer_pointer = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = buffer_pointer + 1;\n      *buffer_pointer = (uint8_t)i2c_handle->Instance->DR;\n      i2c_handle->XferCount = i2c_handle->XferCount - 1;\n      if (i2c_handle->XferCount == 3) {\n        i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffffbff;\n      }\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001904",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "readDataFromI2C_08001904"
        },
        "FUN_08000c64": {
            "renaming": {
                "FUN_08000c64": "poll_modbus_slave_data_08000c64",
                "PTR_slave_08000c78": "modbus_slave_data_ptr",
                "PTR_au16data_08000c74": "modbus_data_array_ptr"
            },
            "code": "void poll_modbus_slave_data_08000c64(void)\n{\n  Modbus::poll((Modbus *)PTR_slave_08000c78,(uint16_t *)PTR_au16data_08000c74,16);\n  return;\n}",
            "called": [
                "poll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c64",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "poll_modbus_slave_data_08000c64"
        },
        "FUN_08002ffc": {
            "renaming": {
                "FUN_08002ffc": "handle_uart_data_08002ffc",
                "*huart": "huart",
                "HVar1": "status",
                "uVar2": "cr1_register",
                "pUVar3": "usart_instance",
                "uVar4": "cr3_register",
                "uVar5": "sr_register",
                "UART_Receive_IT": "UART_Receive_IT",
                "UART_Transmit_IT": "UART_Transmit_IT",
                "UART_EndTransmit_IT": "UART_EndTransmit_IT",
                "HAL_UART_ErrorCallback": "HAL_UART_ErrorCallback",
                "HAL_DMA_Abort_IT": "HAL_DMA_Abort_IT",
                "huart->hdmarx->XferAbortCallback": "huart->hdmatx->XferAbortCallback",
                "HAL_UART_ERROR_PE": "HAL_UART_ERROR_PE",
                "HAL_UART_ERROR_FE": "HAL_UART_ERROR_FE",
                "HAL_UART_ERROR_NE": "HAL_UART_ERROR_NE",
                "HAL_UART_ERROR_ORE": "HAL_UART_ERROR_ORE",
                "USART_SR_RXNE": "USART_SR_RXNE",
                "USART_SR_IDLE": "USART_SR_IDLE",
                "USART_CR1_IDLEIE": "USART_CR1_IDLEIE",
                "USART_CR1_PEIE": "USART_CR1_PEIE",
                "USART_SR_PE": "USART_SR_PE",
                "USART_SR_FE": "USART_SR_FE",
                "USART_SR_NE": "USART_SR_NE",
                "USART_SR_ORE": "USART_SR_ORE",
                "USART_CR3_EIE": "USART_CR3_EIE",
                "USART_CR1_TXEIE": "USART_CR1_TXEIE",
                "USART_SR_TXE": "USART_SR_TXE",
                "USART_CR1_TCIE": "USART_CR1_TCIE",
                "USART_SR_TC": "USART_SR_TC",
                "USART_CR3_RXFTCFG": "USART_CR3_RXFTCFG",
                "huart->ErrorCode": "error_code",
                "USART_TypeDef": "USART_TypeDef"
            },
            "code": "void handle_uart_data_08002ffc(UART_HandleTypeDef *huart) \n{\n  HAL_StatusTypeDef status;\n  uint32_t sr_register;\n  uint32_t cr1_register;\n  USART_TypeDef *usart_instance;\n  uint32_t cr3_register;\n  uint32_t error_code = huart->ErrorCode;\n  usart_instance = huart->Instance;\n  sr_register = usart_instance->SR;\n  cr1_register = usart_instance->CR1;\n  if (((sr_register & USART_SR_RXNE) == 0) && ((sr_register & USART_SR_IDLE) != 0) && ((cr1_register & USART_CR1_IDLEIE) != 0)) {\n    UART_Receive_IT(huart);\n    return;\n  }\n  if (((sr_register & USART_SR_RXNE) == 0) || ((cr3_register = usart_instance->CR3 & USART_CR3_EIE, cr3_register == 0 && ((cr1_register & (USART_CR1_PEIE | USART_CR1_RXNEIE)) == 0)))) {\n    if (((sr_register & USART_SR_TXE) != 0) && ((cr1_register & USART_CR1_TXEIE) != 0)) {\n      UART_Transmit_IT(huart);\n      return;\n    }\n    if (((sr_register & USART_SR_TC) != 0) && ((cr1_register & USART_CR1_TCIE) != 0)) {\n      UART_EndTransmit_IT(huart);\n      return;\n    }\n  }\n  else {\n    if (((sr_register & USART_SR_PE) != 0) && ((cr1_register & USART_CR1_PEIE) != 0)) {\n      error_code |= HAL_UART_ERROR_PE;\n    }\n    if (((sr_register & USART_SR_FE) != 0) && (cr3_register != 0)) {\n      error_code |= HAL_UART_ERROR_FE;\n    }\n    if (((sr_register & USART_SR_NE) != 0) && (cr3_register != 0)) {\n      error_code |= HAL_UART_ERROR_NE;\n    }\n    if (((sr_register & USART_SR_ORE) != 0) && (cr3_register != 0)) {\n      error_code |= HAL_UART_ERROR_ORE;\n    }\n    if (error_code != 0) {\n      if (((sr_register & USART_SR_IDLE) != 0) && ((cr1_register & USART_CR1_IDLEIE) != 0)) {\n        UART_Receive_IT(huart);\n      }\n      if (((error_code & HAL_UART_ERROR_ORE) == 0) && ((usart_instance->CR3 & USART_CR3_EIE) == 0)) {\n        HAL_UART_ErrorCallback(huart);\n        huart->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(huart);\n      usart_instance = huart->Instance;\n      if ((usart_instance->CR3 & USART_CR3_EIE) == 0) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      usart_instance->CR3 &= ~USART_CR3_RXFTCFG;\n      if (huart->hdmarx == NULL) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      huart->hdmarx->XferAbortCallback = huart->hdmatx->XferAbortCallback;\n      status = HAL_DMA_Abort_IT(huart->hdmarx);\n      if (status != HAL_OK) {\n        (*huart->hdmarx->XferAbortCallback)(huart->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "UART_EndRxTransfer",
                "HAL_UART_ErrorCallback",
                "UART_EndTransmit_IT",
                "UART_Transmit_IT",
                "UART_Receive_IT",
                "HAL_DMA_Abort_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ffc",
            "calling": [
                "UART4_IRQHandler",
                "USART2_IRQHandler",
                "UART7_IRQHandler",
                "USART3_IRQHandler",
                "USART6_IRQHandler",
                "USART1_IRQHandler",
                "UART5_IRQHandler",
                "UART8_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_uart_data_08002ffc"
        },
        "FUN_0800387c": {
            "renaming": {
                "FUN_0800387c": "get_i2c_struct_0800387c",
                "hi2c": "handle",
                "i2c_t": "i2c_s",
                "EventCount": "EventCount"
            },
            "code": "typedef struct i2c_s {uint32_t EventCount;} i2c_t;\ni2c_t * get_i2c_struct_0800387c(I2C_HandleTypeDef *handle)\n{\n  return (i2c_t *)&handle[-1].EventCount;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800387c",
            "calling": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "imported": false,
            "current_name": "get_i2c_struct_0800387c"
        },
        "FUN_0800351e": {
            "renaming": {
                "FUN_0800351e": "find_pin_for_peripheral_0800351e",
                "peripheral": "peripheral",
                "map": "map",
                "PVar1": "pin_name",
                "NC": "NC"
            },
            "code": "PinName_conflict find_pin_for_peripheral_0800351e(void *peripheral, PinMap_conflict *map)\n{\n  PinName_conflict pin_name;\n  if (peripheral != NULL) {\n    pin_name = pinmap_find_pin(peripheral, map);\n    return pin_name;\n  }\n  return NC;\n}",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800351e",
            "calling": [
                "uart_debug_init",
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "find_pin_for_peripheral_0800351e"
        },
        "FUN_080059f8": {
            "renaming": {
                "FUN_080059f8": "do_nothing_080059f8"
            },
            "code": "\nvoid do_nothing_080059f8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080059f8",
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux"
            ],
            "imported": false,
            "current_name": "do_nothing_080059f8"
        },
        "FUN_08002f66": {
            "renaming": {
                "FUN_08002f66": "receive_uart_data_08002f66",
                "*huart": "*uart_handle",
                "pbVar1": "rx_byte_ptr",
                "uVar2": "remaining_bytes",
                "puVar3": "rx_buffer_ptr",
                "huart->RxState": "uart_handle->RxState",
                "huart->Init": "uart_handle->Init",
                "huart->Instance->DR": "uart_handle->Instance->DR",
                "ushort": "uint16_t",
                "byte": "uint8_t",
                "HAL_UART_STATE_BUSY_RX": "HAL_UART_STATE_BUSY_RX",
                "HAL_BUSY": "HAL_BUSY",
                "UART_WORDLENGTH_9B": "UART_WORDLENGTH_9B",
                "UART_PARITY_NONE": "UART_PARITY_NONE",
                "HAL_OK": "HAL_OK",
                "uart_handle->pRxBuffPtr": "uart_handle->pRxBuffPtr",
                "& 0xff": " & 0xff",
                "& 0x7f": " & 0x7f",
                "huart->RxXferCount": "uart_handle->RxXferCount",
                "uart_handle->Instance->CR1": "uart_handle->Instance->CR1",
                "uart_handle->Instance->CR3": "uart_handle->Instance->CR3",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_UART_RxCpltCallback": "HAL_UART_RxCpltCallback"
            },
            "code": "HAL_StatusTypeDef receive_uart_data_08002f66(UART_HandleTypeDef *uart_handle)\n{\n  uint8_t *rx_buffer_ptr;\n  uint16_t remaining_bytes;\n  uint16_t data;\n  \n  if (uart_handle->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  \n  remaining_bytes = uart_handle->RxXferCount - 1;\n  data = uart_handle->Instance->DR;\n  \n  if ((uart_handle->Init).WordLength == UART_WORDLENGTH_9B) {\n    if ((uart_handle->Init).Parity == UART_PARITY_NONE) {\n      *(uint16_t *)uart_handle->pRxBuffPtr = (uint16_t)((data << 0x17) >> 0x17);\n      uart_handle->pRxBuffPtr += 2;\n    }\n    else {\n      *(uint16_t *)uart_handle->pRxBuffPtr = (uint16_t)data & 0xff;\n      uart_handle->pRxBuffPtr++;\n    }\n  }\n  else if ((uart_handle->Init).Parity == UART_PARITY_NONE) {\n    rx_buffer_ptr = uart_handle->pRxBuffPtr;\n    uart_handle->pRxBuffPtr++;\n    *rx_buffer_ptr = (uint8_t)data;\n  }\n  else {\n    rx_buffer_ptr = uart_handle->pRxBuffPtr;\n    uart_handle->pRxBuffPtr++;\n    *rx_buffer_ptr = (uint8_t)data & 0x7f;\n  }\n  \n  if (remaining_bytes != 0) {\n    uart_handle->RxXferCount = remaining_bytes;\n    return HAL_OK;\n  }\n  \n  uart_handle->Instance->CR1 &= 0xfffffedf;\n  uart_handle->Instance->CR3 &= 0xfffffffe;\n  uart_handle->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uart_handle);\n  return HAL_OK;\n}",
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f66",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_uart_data_08002f66"
        },
        "FUN_080034b6": {
            "renaming": {
                "FUN_080034b6": "set_gpio_pin_state_080034b6",
                "port": "gpio_port",
                "pin": "gpio_pin",
                "val": "gpio_pin_state"
            },
            "code": "void set_gpio_pin_state_080034b6(GPIO_TypeDef *gpio_port, uint32_t gpio_pin, uint32_t gpio_pin_state) {\n  if (gpio_pin_state == 0) {\n    HAL_GPIO_WritePin(gpio_port, (uint16_t)gpio_pin, GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpio_port, (uint16_t)gpio_pin, GPIO_PIN_SET);\n  return;\n}",
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080034b6",
            "calling": [
                "digitalWrite"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_080034b6"
        },
        "FUN_08003eac": {
            "renaming": {
                "FUN_08003eac": "transmit_serial_data_08003eac",
                "obj": "serial_obj",
                "callback": "tx_callback",
                "bVar1": "index",
                "PTR_tx_callback_08003ef4": "tx_callback_ptr",
                "PTR_tx_callback_obj_08003ef8": "serial_obj_ptr",
                "PTR_uart_handlers_08003efc": "uart_handler_ptr"
            },
            "code": "void transmit_serial_data_08003eac(serial_t *serial_obj, _func_int_serial_t_ptr *tx_callback) {\n\tif (serial_obj != NULL) {\n\t\tuint8_t index = serial_obj->index;\n\t\t_func_int_serial_t_ptr **PTR_tx_callback_08003ef4 = (void **) (PTR_tx_callback_08003ef4 + index * 4);\n\t\t*PTR_tx_callback_08003ef4 = tx_callback;\n\t\tserial_t **PTR_tx_callback_obj_08003ef8 = (serial_t **) (PTR_tx_callback_obj_08003ef8 + index * 4);\n\t\t*PTR_tx_callback_obj_08003ef8 = serial_obj;\n\t\tHAL_NVIC_SetPriority(serial_obj->irq, 0, 2);\n\t\tHAL_NVIC_EnableIRQ(serial_obj->irq);\n\t\tUART_HandleTypeDef **PTR_uart_handlers_08003efc = (UART_HandleTypeDef **) (PTR_uart_handlers_08003efc + index * 4);\n\t\tHAL_UART_Transmit_IT(*PTR_uart_handlers_08003efc, serial_obj->tx_buff + serial_obj->tx_tail, 1);\n\t}\n}",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003eac",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "transmit_serial_data_08003eac"
        },
        "FUN_08004064": {
            "renaming": {
                "FUN_08004064": "handle_UART7_interrupt_08004064",
                "PTR_uart_handlers_08004078": "uart_handlers_ptr_08004078",
                "UART7_IRQn": "UART7_Interrupt",
                "*(UART_HandleTypeDef **)(PTR_uart_handlers_08004078 + 0x18)": "uart_handler_ptr",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt"
            },
            "code": "void handle_UART7_interrupt_08004064(void)\n{\n  HAL_NVIC_ClearPendingIRQ(UART7_IRQn);\n  UART_HandleTypeDef* *(UART_HandleTypeDef **)(PTR_uart_handlers_08004078 + 0x18) = *(UART_HandleTypeDef **)(PTR_uart_handlers_08004078 + 0x18);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004078 + 0x18));\n  return;\n}",
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004064",
            "calling": [],
            "imported": false,
            "current_name": "handle_UART7_interrupt_08004064"
        },
        "FUN_08003e18": {
            "renaming": {
                "FUN_08003e18": "receive_serial_data_08003e18",
                "obj": "serial_object",
                "c": "received_data",
                "uVar1": "is_rx_active"
            },
            "code": "int receive_serial_data_08003e18(serial_t *serial_object, uchar *received_data) {\n  uint8_t is_rx_active;\n  \n  if (serial_object == NULL) {\n    return -1;\n  }\n  is_rx_active = serial_rx_active(serial_object);\n  if (is_rx_active == 0) {\n    *received_data = serial_object->recv;\n    HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08003e50 + (uint)serial_object->index * 4), &serial_object->recv, 1);\n    return 0;\n  }\n  return -1;\n}",
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003e18",
            "calling": [
                "_rx_complete_irq"
            ],
            "imported": false,
            "current_name": "receive_serial_data_08003e18"
        },
        "FUN_080040fc": {
            "renaming": {
                "FUN_080040fc": "set_errno_to_22_080040fc",
                "pid_UNUSED": "pid_unused",
                "sig_UNUSED": "sig_unused",
                "PTR_errno_08004108": "PTR_errno_08004108"
            },
            "code": "int set_errno_to_22_080040fc(int pid_unused, int sig_unused) {\n    *(undefined4 *)PTR_errno_08004108 = 0x16;\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040fc",
            "calling": [
                "_kill_r"
            ],
            "imported": false,
            "current_name": "set_errno_to_22_080040fc"
        },
        "FUN_08002dd0": {
            "renaming": {
                "FUN_08002dd0": "transmitThroughUART_08002dd0",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickstart"
            },
            "code": "HAL_StatusTypeDef transmitThroughUART_08002dd0(UART_HandleTypeDef *uartHandle, uint8_t *data, uint16_t size, uint32_t timeout)\n{\n  HAL_StatusTypeDef status;\n  uint32_t tickstart;\n  if (uartHandle->gState == HAL_UART_STATE_READY) {\n    if (data == NULL) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (uartHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n      tickstart = HAL_GetTick();\n      uartHandle->TxXferSize = size;\n      uartHandle->TxXferCount = size;\n      while (uartHandle->TxXferCount != 0) {\n        uartHandle->TxXferCount--;\n        if ((uartHandle->Init).WordLength == UART_WORDLENGTH_9B) {\n          status = UART_WaitOnFlagUntilTimeout(uartHandle, UART_FLAG_TXE, RESET, tickstart, timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = *(uint16_t *)data & 0x1FF;\n          if ((uartHandle->Init).Parity == UART_PARITY_NONE) {\n            data += 2;\n          }\n          else {\n            data++;\n          }\n        }\n        else {\n          status = UART_WaitOnFlagUntilTimeout(uartHandle, UART_FLAG_TXE, RESET, tickstart, timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = (uint32_t)*data;\n          data++;\n        }\n      }\n      status = UART_WaitOnFlagUntilTimeout(uartHandle, UART_FLAG_TC, RESET, tickstart, timeout);\n      if (status == HAL_OK) {\n        uartHandle->gState = HAL_UART_STATE_READY;\n        uartHandle->Lock = HAL_UNLOCKED;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002dd0",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "transmitThroughUART_08002dd0"
        },
        "FUN_08004860": {
            "renaming": {
                "FUN_08004860": "printToFile_08004860",
                "__stream": "file",
                "__format": "format",
                "iVar1": "result",
                "in_r2": "",
                "in_r3": "",
                "uStack_8": "",
                "uStack_4": "",
                "*PTR__impure_ptr_08004880": "",
                "_vFUN_08004860_r": "vfprintf",
                "&uStack_8": "args"
            },
            "code": "int printToFile_08004860(FILE *file, char *format, ...) {\n  int result;\n  va_list args;\n  va_start(args, format);\n  result = vfprintf(file, format, args);\n  va_end(args);\n  return result;\n}",
            "called": [
                "_vfiprintf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004860",
            "calling": [
                "__assert_func"
            ],
            "imported": false,
            "current_name": "printToFile_08004860"
        },
        "FUN_08004622": {
            "renaming": {
                "__thiscall Print::FUN_08004622": "printNumber",
                "this": "printObject",
                "n": "number",
                "base": "numberBase",
                "sVar1": "length",
                "FUN_08004622": "printNumber_08004622"
            },
            "code": "size_t __thiscall Print::printNumber_08004622(Print *this, ulong number, int base) {\n  size_t length;\n  if (base != 0) {\n    length = printNumber_08004622(this, number, (uint8_t)base);\n    return length;\n  }\n  length = (**this->_vptr_Print)(this, number & 0xff);\n  return length;\n}",
            "called": [
                "printNumber"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004622",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "printNumber_08004622"
        },
        "FUN_08003414": {
            "renaming": {
                "FUN_08003414": "stop_pwm_signal_08003414",
                "pin": "pin_name",
                "Channel": "channel",
                "uVar1": "function_code",
                "timHandle": "tim_handle",
                "PTR_PinMap_PWM_08003468": "PinMap_PWM_08003468"
            },
            "code": "void stop_pwm_signal_08003414(PinName_conflict pin)\n{\n  uint32_t channel;\n  uint32_t function_code;\n  TIM_HandleTypeDef tim_handle;\n  tim_handle.Instance = (TIM_TypeDef *)pinmap_peripheral(pin, (PinMap_conflict *)PTR_PTR_PinMap_PWM_08003468);\n  if ((tim_handle.Instance != (TIM_TypeDef *)0x0) && ((((channel = get_pwm_channel(pin), channel == 0 || (channel == 4)) || (channel == 8)) || ((channel == 0xc || (channel == 0x18)))))) {\n    function_code = pinmap_function(pin, (PinMap_conflict *)PTR_PTR_PinMap_PWM_08003468);\n    if ((function_code & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&tim_handle, channel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&tim_handle, channel);\n    }\n    HAL_TIM_PWM_DeInit(&tim_handle);\n  }\n  return;\n}",
            "called": [
                "get_pwm_channel",
                "HAL_TIM_PWM_DeInit",
                "pinmap_function",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop",
                "HAL_TIM_PWM_Stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003414",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "stop_pwm_signal_08003414"
        },
        "FUN_08005718": {
            "renaming": {
                "FUN_08005718": "seek_file_08005718",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "puVar1": "errno_ptr",
                "iVar2": "seek_result"
            },
            "code": "void seek_file_08005718(int *error_code, int file_descriptor, int offset, int whence) {\n    int seek_result = 0;\n    int *errno_ptr = PTR_errno_08005738;\n    *errno_ptr = 0;\n    seek_result = _lseek(file_descriptor, offset, whence);\n    if (seek_result == -1 && *errno_ptr != 0) {\n        *error_code = *errno_ptr;\n    }\n    return;\n}",
            "called": [
                "_lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005718",
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "imported": false,
            "current_name": "seek_file_08005718"
        },
        "FUN_080011c0": {
            "renaming": {
                "FUN_080011c0": "i2c_handle_mem_mode_080011c0",
                "*hi2c": "*i2c_handle",
                "hi2c->Mode": "i2c_handle->Mode",
                "hi2c->EventCount": "i2c_handle->EventCount",
                "hi2c->Instance->DR": "i2c_handle->Instance->DR",
                "hi2c->Devaddress": "i2c_handle->Devaddress",
                "(hi2c->Init).AddressingMode": "(i2c_handle->Init).AddressingMode",
                "hi2c->State": "i2c_handle->State",
                "HAL_I2C_MODE_MEM": "HAL_I2C_MODE_MEM",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef i2c_handle_mem_mode_080011c0(I2C_HandleTypeDef *i2c_handle) {\n    uint8_t dev_address = i2c_handle->Devaddress;\n    uint8_t addressing_mode = (i2c_handle->Init).AddressingMode;\n    uint8_t event_count = i2c_handle->EventCount;\n    uint8_t state = i2c_handle->State;\n    uint8_t instance_dr_value;\n\n    if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n        instance_dr_value = (event_count == 0) ? (dev_address & 0xFE) : (dev_address & 0xFF | 1);\n    } else if (addressing_mode == 0x4000) {\n        instance_dr_value = (state == HAL_I2C_STATE_BUSY_TX) ? (dev_address & 0xFE) : (dev_address & 0xFF | 1);\n    } else if (event_count == 0) {\n        instance_dr_value = ((dev_address << 0x10) >> 0x17 & 6) | 0xF0;\n    } else if (event_count == 1) {\n        instance_dr_value = ((dev_address << 0x10) >> 0x17 & 6) | 0xF1;\n    }\n\n    i2c_handle->Instance->DR = instance_dr_value;\n    return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080011c0",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_mem_mode_080011c0"
        },
        "FUN_080047f0": {
            "renaming": {
                "FUN_080047f0": "initialize_static_variables_080047f0"
            },
            "code": "void initialize_static_variables_080047f0(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047f0",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_080047f0"
        },
        "FUN_0800502c": {
            "renaming": {
                "FUN_0800502c": "send_data_0800502c",
                "param_1": "socket_fd",
                "param_2": "data",
                "param_3": "stream",
                "param_4": "param_4",
                "iVar1": "read_count",
                "uVar2": "return_code",
                "puVar3": "buffer_pointer"
            },
            "code": "uint send_data_0800502c(int socket_fd, uint data, int *stream, undefined4 param_4)\n{\n  int read_count;\n  uint return_code;\n  undefined *buffer_pointer;\n  if ((socket_fd != 0) && (*(int *)(socket_fd + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == (int *)DAT___sf_fake_stdin_080050c4) {\n    stream = *(int **)(socket_fd + 4);\n  }\n  else if (stream == (int *)DAT___sf_fake_stdout_080050c8) {\n    stream = *(int **)(socket_fd + 8);\n  }\n  else if (stream == (int *)DAT___sf_fake_stderr_080050cc) {\n    stream = *(int **)(socket_fd + 0xc);\n  }\n  stream[2] = stream[6];\n  return_code = (uint)*(ushort *)(stream + 3);\n  read_count = return_code << 0x1c;\n  if (((read_count < 0) && (return_code = stream[4], return_code != 0)) ||\n     (read_count = __swsetup_r(socket_fd, stream, read_count, return_code, param_4), read_count == 0)) {\n    read_count = *stream - stream[4];\n    data = data & 0xff;\n    if ((read_count < stream[5]) || (read_count = _fflush_r(socket_fd, stream), read_count == 0)) {\n      stream[2] = stream[2] + -1;\n      buffer_pointer = (undefined *)*stream;\n      *stream = (int)(buffer_pointer + 1);\n      *buffer_pointer = (char)data;\n      if (read_count + 1 != stream[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return data;\n        }\n        if (data != 10) {\n          return data;\n        }\n      }\n      read_count = _fflush_r(socket_fd, stream);\n      if (read_count == 0) {\n        return data;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "__swsetup_r",
                "_fflush_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800502c",
            "calling": [
                "__sfputc_r"
            ],
            "imported": false,
            "current_name": "send_data_0800502c"
        },
        "FUN_08000b54": {
            "renaming": {
                "__thiscall Modbus::FUN_08000b54": "processModbusRequest",
                "this": "modbus",
                "regs": "registers",
                "u8size": "num_registers",
                "uVar1": "exception_code",
                "u8exception": "exception_code",
                "uVar2": "port_byte",
                "uVar3": "current_time",
                "unaff_r5": "serial_byte",
                "au16regs": "registers",
                "u8regsize": "num_registers",
                "u8serno": "serial_number",
                "port": "port",
                "au8Buffer": "buffer",
                "u8id": "id",
                "getRxBuffer": "getRxBuffer",
                "validateRequest": "validateRequest",
                "millis": "millis",
                "u32timeOut": "timeout",
                "u16timeOut": "time_out",
                "process_FC1": "processReadRequest",
                "process_FC3": "processReadHoldingRegistersRequest",
                "process_FC5": "processWriteSingleCoilRequest",
                "process_FC6": "processWriteSingleRegisterRequest",
                "process_FC15": "processWriteMultipleCoilsRequest",
                "process_FC16": "processWriteMultipleRegistersRequest",
                "buildException": "buildException",
                "sendTxBuffer": "sendTxBuffer",
                "u8lastError": "last_error",
                "FUN_08000b54": "processModbusRequest_08000b54"
            },
            "code": "int8_t __thiscall processModbusRequest_08000b54(Modbus *modbus, uint16_t *registers, uint8_t num_registers)\n{\n    uint8_t exception_code;\n    uint8_t serial_byte;\n    uint8_t rx_buffer;\n    uint32_t current_time;\n    uint port_byte;\n    \n    modbus->registers = registers;\n    modbus->num_registers = num_registers;\n    \n    if (modbus->serial_number < 4) {\n        port_byte = (*(modbus->port->super_Stream).super_Print._vptr_Print[2])();\n        serial_byte = port_byte & 0xff;\n    }\n    \n    if (serial_byte == 0 || serial_byte < 8) {\n        exception_code = 0;\n    }\n    else {\n        rx_buffer = getRxBuffer(modbus);\n        modbus->last_error = rx_buffer;\n        \n        if (modbus->buffer[0] == modbus->id) {\n            exception_code = validateRequest(modbus);\n            \n            if (exception_code == 0) {\n                current_time = millis();\n                modbus->timeout = modbus->time_out + current_time;\n                modbus->last_error = 0;\n                \n                switch (modbus->buffer[1]) {\n                    case 0x01:\n                    case 0x02:\n                        exception_code = processReadRequest(modbus, registers, num_registers);\n                        break;\n                    case 0x03:\n                    case 0x04:\n                        exception_code = processReadHoldingRegistersRequest(modbus, registers, num_registers);\n                        break;\n                    case 0x05:\n                        exception_code = processWriteSingleCoilRequest(modbus, registers, num_registers);\n                        break;\n                    case 0x06:\n                        exception_code = processWriteSingleRegisterRequest(modbus, registers, num_registers);\n                        break;\n                    case 0x0f:\n                        exception_code = processWriteMultipleCoilsRequest(modbus, registers, num_registers);\n                        break;\n                    case 0x10:\n                        exception_code = processWriteMultipleRegistersRequest(modbus, registers, num_registers);\n                        break;\n                }\n            }\n            else {\n                if (exception_code != 0xff) {\n                    buildException(modbus, exception_code);\n                    sendTxBuffer(modbus);\n                }\n                modbus->last_error = exception_code;\n            }\n        }\n        else {\n            exception_code = 0;\n        }\n    }\n    \n    return exception_code;\n}",
            "called": [
                "process_FC5",
                "getRxBuffer",
                "validateRequest",
                "process_FC3",
                "millis",
                "sendTxBuffer",
                "process_FC1",
                "buildException",
                "process_FC6",
                "process_FC15",
                "process_FC16"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000b54",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "processModbusRequest_08000b54"
        },
        "FUN_08000d96": {
            "renaming": {
                "FUN_08000d96": "do_nothing_08000d96"
            },
            "code": "\nvoid do_nothing_08000d96(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000d96",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_08000d96"
        },
        "FUN_0800376e": {
            "renaming": {
                "FUN_0800376e": "handle_timer_interrupt_0800376e",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "get_timer_obj": "get_timer_object",
                "irqHandle": "irq_handler"
            },
            "code": "void handle_timer_interrupt_0800376e(TIM_HandleTypeDef *timer_handle)\n{\n  stimer_t *timer_obj = get_timer_object(timer_handle);\n  if (timer_obj->irq_handler != (_func_void_stimer_t_ptr *)0x0) {\n    (*timer_obj->irq_handler)(timer_obj);\n  }\n  return;\n}",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800376e",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_0800376e"
        },
        "FUN_08000d98": {
            "renaming": {
                "FUN_08000d98": "configureSysTick_08000d98",
                "TickPriority": "tickPriority",
                "uVar1": "configResult",
                "sysClock": "<unchanged>",
                "tickFreq": "<unchanged>"
            },
            "code": "HAL_StatusTypeDef configureSysTick_08000d98(uint32_t tickPriority)\n{\n  uint32_t sysClock = *(uint *)PTR_SystemCoreClock_08000ddc;\n  uint32_t tickFreq = (uint32_t)((uint64_t)sysClock / (1000 / (uint64_t)(byte)*PTR_uwTickFreq_08000dd8));\n  uint32_t configResult = HAL_SYSTICK_Config(tickFreq);\n  if (configResult != 0) {\n    return HAL_ERROR;\n  }\n  if (tickPriority > 0xf) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn, tickPriority, 0);\n  *(uint32_t *)PTR_uwTickPrio_08000de0 = tickPriority;\n  return HAL_OK;\n}",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000d98",
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "configureSysTick_08000d98"
        },
        "FUN_08003f48": {
            "renaming": {
                "FUN_08003f48": "transmit_data_08003f48",
                "huart": "uart_handle",
                "bVar1": "uart_index",
                "uVar2": "uart_index_uint",
                "iVar3": "callback_result",
                "iVar4": "callback_obj",
                "PTR_tx_callback_obj_08003f88": "PTR_tx_callback_obj",
                "PTR_tx_callback_08003f8c": "PTR_tx_callback",
                "PTR_uart_handlers_08003f90": "PTR_uart_handlers"
            },
            "code": "void transmit_data_08003f48(UART_HandleTypeDef *uart_handle)\n{\n  uint8_t uart_index = get_uart_index(uart_handle);\n  if(uart_index < 10)\n  {\n    int callback_obj = *(int *)(PTR_tx_callback_08003f8c_obj_08003f88_08003f88 + uart_index * 4);\n    code* callback = *(code **)(PTR_tx_callback_08003f8c_08003f8c + uart_index * 4);\n    int callback_result = (*callback)(callback_obj);\n    if(callback_result != -1)\n    {\n      uint8_t* data = (uint8_t *)(*(int *)(callback_obj + 0x68) + (uint)*(ushort *)(callback_obj + 0x6e));\n      uint8_t data_size = 1;\n      uint8_t* handler = *(UART_HandleTypeDef **)(PTR_uart_handlers_08003f90_08003f90 + (uint)*(byte *)(callback_obj + 0x44) * 4);\n      HAL_UART_Transmit_IT(handler, data, data_size);\n    }\n  }\n}\n",
            "called": [
                "uart_index",
                "HAL_UART_Transmit_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f48",
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "imported": false,
            "current_name": "transmit_data_08003f48"
        },
        "FUN_0800340c": {
            "renaming": {
                "FUN_0800340c": "disable_timer_clock_0800340c",
                "htim": "timer_handle"
            },
            "code": "void disable_timer_clock_0800340c(TIM_HandleTypeDef *timer_handle)\n{\n  timer_disable_clock(timer_handle);\n  return;\n}",
            "called": [
                "timer_disable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800340c",
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "imported": false,
            "current_name": "disable_timer_clock_0800340c"
        },
        "FUN_0800352e": {
            "renaming": {
                "FUN_0800352e": "findFunctionFromPin_0800352e",
                "pin": "requestedPin",
                "map": "pinFunctionMap",
                "NC": "NotConnected",
                "uint32_t": "unsigned int",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap",
                "*": "pointer",
                "->": "dereference",
                "requestedPin": "requestedPin",
                "pinFunctionMap": "pinFunctionMap",
                "NotConnected": "NotConnected",
                "unsigned int": "unsigned int",
                "PinName": "PinName",
                "PinMap": "PinMap",
                "function": "function"
            },
            "code": "uint32_t findFunctionFromPin_0800352e(PinName_conflict pin, PinMap_conflict *map)\n{\n  while( true ) {\n    if (map->pin == NC) {\n      return 0xffffffff;\n    }\n    if (map->pin == pin) break;\n    map = map + 1;\n  }\n  return map->function;\n}",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800352e",
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "imported": false,
            "current_name": "findFunctionFromPin_0800352e"
        },
        "FUN_0800582c": {
            "renaming": {
                "std::ctype_byname<wchar_t>::FUN_0800582c": "set_ctype_flags",
                "FUN_0800582c": "set_ctype_flags_0800582c"
            },
            "code": "void set_ctype_flags_0800582c() {\n  if (*(int *)PTR_id_080058c0 < 0) {\n    *(undefined4 *)PTR_id_080058c0 = 1;\n  }\n  if (*(int *)PTR_id_080058c4 < 0) {\n    *(undefined4 *)PTR_id_080058c4 = 1;\n  }\n  if (*(int *)PTR_id_080058c8 < 0) {\n    *(undefined4 *)PTR_id_080058c8 = 1;\n  }\n  if (*(int *)PTR_id_080058cc < 0) {\n    *(undefined4 *)PTR_id_080058cc = 1;\n  }\n  if (*(int *)PTR_id_080058d0 < 0) {\n    *(undefined4 *)PTR_id_080058d0 = 1;\n  }\n  if (*(int *)PTR_id_080058d4 < 0) {\n    *(undefined4 *)PTR_id_080058d4 = 1;\n  }\n  if (*(int *)PTR_id_080058d8 < 0) {\n    *(undefined4 *)PTR_id_080058d8 = 1;\n  }\n  if (*(int *)PTR_id_080058dc < 0) {\n    *(undefined4 *)PTR_id_080058dc = 1;\n  }\n  if (*(int *)PTR_id_080058e0 < 0) {\n    *(undefined4 *)PTR_id_080058e0 = 1;\n  }\n  if (*(int *)PTR_id_080058e4 < 0) {\n    *(undefined4 *)PTR_id_080058e4 = 1;\n  }\n  if (*(int *)PTR_id_080058e8 < 0) {\n    *(undefined4 *)PTR_id_080058e8 = 1;\n  }\n  if (*(int *)PTR_id_080058ec < 0) {\n    *(undefined4 *)PTR_id_080058ec = 1;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800582c",
            "calling": [],
            "imported": false,
            "current_name": "set_ctype_flags_0800582c"
        },
        "FUN_08001ab0": {
            "renaming": {
                "FUN_08001ab0": "i2c_handle_state_08001ab0",
                "*hi2c": "*handle",
                "HVar1": "status",
                "*puVar2": "*buffer_ptr",
                "*pIVar3": "*instance"
            },
            "code": "void i2c_handle_state_08001ab0(I2C_HandleTypeDef *handle)\n{\n    HAL_StatusTypeDef status;\n    uint8_t *buffer_ptr;\n    I2C_TypeDef *instance;\n    if ((byte)handle->State - 0x29 < 2) {\n        handle->PreviousState = 0;\n        handle->State = HAL_I2C_STATE_LISTEN;\n    }\n    else {\n        if ((handle->State != HAL_I2C_STATE_ABORT) && ((handle->Instance->CR2 & 0x800) == 0)) {\n            handle->State = HAL_I2C_STATE_READY;\n        }\n        handle->PreviousState = 0;\n        handle->Mode = HAL_I2C_MODE_NONE;\n    }\n    handle->Instance->CR1 = handle->Instance->CR1 & 0xfffff7ff;\n    instance = handle->Instance;\n    if ((instance->CR2 & 0x800) == 0) {\n        if (handle->State == HAL_I2C_STATE_ABORT) {\n            handle->State = HAL_I2C_STATE_READY;\n            handle->ErrorCode = 0;\n            if ((instance->SR1 & 0x40) != 0) {\n                buffer_ptr = handle->pBuffPtr;\n                handle->pBuffPtr = buffer_ptr + 1;\n                *buffer_ptr = (uint8_t)instance->DR;\n            }\n            handle->Instance->CR1 = handle->Instance->CR1 & 0xfffffffe;\n            HAL_I2C_AbortCpltCallback(handle);\n        }\n        else {\n            if ((instance->SR1 & 0x40) != 0) {\n                buffer_ptr = handle->pBuffPtr;\n                handle->pBuffPtr = buffer_ptr + 1;\n                *buffer_ptr = (uint8_t)instance->DR;\n            }\n            HAL_I2C_ErrorCallback(handle);\n        }\n    }\n    else {\n        instance->CR2 = instance->CR2 & 0xfffff7ff;\n        if (handle->hdmatx->State == HAL_DMA_STATE_READY) {\n            handle->hdmarx->XferAbortCallback = handle->hdmatx->XferAbortCallback;\n            status = HAL_DMA_Abort_IT(handle->hdmarx);\n            if (status != HAL_OK) {\n                if ((instance->SR1 & 0x40) != 0) {\n                    buffer_ptr = handle->pBuffPtr;\n                    handle->pBuffPtr = buffer_ptr + 1;\n                    *buffer_ptr = (uint8_t)instance->DR;\n                }\n                instance->CR1 = instance->CR1 & 0xfffffffe;\n                handle->State = HAL_I2C_STATE_READY;\n                (*handle->hdmarx->XferAbortCallback)(handle->hdmarx);\n            }\n        }\n        else {\n            handle->hdmatx->XferAbortCallback = handle->hdmarx->XferAbortCallback;\n            status = HAL_DMA_Abort_IT(handle->hdmatx);\n            if (status != HAL_OK) {\n                instance->CR1 = instance->CR1 & 0xfffffffe;\n                handle->State = HAL_I2C_STATE_READY;\n                (*handle->hdmatx->XferAbortCallback)(handle->hdmatx);\n            }\n        }\n    }\n    if ((handle->State == HAL_I2C_STATE_LISTEN) && ((handle->ErrorCode & 4) != 0)) {\n        handle->XferOptions = handle->PreviousState;\n        handle->PreviousState = 0;\n        handle->State = HAL_I2C_STATE_READY;\n        handle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_ListenCpltCallback(handle);\n    }\n    return;\n}",
            "called": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_DMA_Abort_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001ab0",
            "calling": [
                "I2C_Slave_STOPF",
                "HAL_I2C_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_state_08001ab0"
        },
        "FUN_08001f9c": {
            "renaming": {
                "FUN_08001f9c": "wait_for_flag_08001f9c",
                "uVar1": "start_time",
                "uVar2": "current_time",
                "tmpreg": "timeout_time",
                "DAT_08002014": "flag_reg",
                "DAT_0800200c": "control_reg"
            },
            "code": "HAL_StatusTypeDef wait_for_flag_08001f9c(void)\n{\n  uint32_t start_time;\n  uint32_t current_time;\n  uint32_t timeout_time;\n  uint32_t* DAT_08002014 = (uint32_t*)(DAT_08002014 + 4);\n  uint32_t* DAT_0800200c = (uint32_t*)(DAT_0800200c + 0x40);\n  *DAT_0800200c |= 0x10000000;\n  *DAT_08002010 = 1;\n  start_time = HAL_GetTick();\n  do {\n    if ((*DAT_08002014 & 0x10000) != 0) {\n      *DAT_08002018 = 1;\n      start_time = HAL_GetTick();\n      do {\n        if ((*DAT_08002014 & 0x20000) != 0) {\n          return HAL_OK;\n        }\n        current_time = HAL_GetTick();\n      } while (current_time - start_time < 0x3e9);\n      return HAL_TIMEOUT;\n    }\n    current_time = HAL_GetTick();\n  } while (current_time - start_time < 0x3e9);\n  return HAL_TIMEOUT;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001f9c",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "wait_for_flag_08001f9c"
        },
        "FUN_08000d8c": {
            "renaming": {
                "FUN_08000d8c": "wait_forever_08000d8c"
            },
            "code": "void wait_forever_08000d8c(void)\n{\n  while(true)\n  {\n    //Do nothing block with infinite loop\n  }\n}",
            "called": [
                "CAN2_SCE_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000d8c",
            "calling": [
                "CAN2_SCE_IRQHandler"
            ],
            "imported": false,
            "current_name": "wait_forever_08000d8c"
        },
        "FUN_08000d8e": {
            "renaming": {
                "FUN_08000d8e": "initialize_EVP_PKEY_CTX_08000d8e",
                "ctx": "context",
                "hw_config_FUN_08000d8e": "initialize_hardware"
            },
            "code": "int initialize_EVP_PKEY_CTX_08000d8e(EVP_PKEY_CTX *context) {\n  initialize_hardware();\n  return (int)context;\n}",
            "called": [
                "hw_config_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000d8e",
            "calling": [
                "premain"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_08000d8e"
        },
        "FUN_08004638": {
            "renaming": {
                "__thiscall Print::FUN_08004638": "print_value",
                "this": "print_obj",
                "b": "value",
                "base": "base",
                "sVar1": "size",
                "FUN_08004638": "print_value_08004638"
            },
            "code": "size_t print_value_08004638(Print *print_obj, uchar value, int base)\n{\n  size_t size;\n  size = print_value_08004638(print_obj, (uint)value, base);\n  return size;\n}",
            "called": [
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004638",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "print_value_08004638"
        },
        "FUN_08005604": {
            "renaming": {
                "FUN_08005604": "get_process_id_08005604"
            },
            "code": "__pid_t get_process_id_08005604(void)\n{\n  return 1;\n}",
            "called": [
                "_getpid"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005604",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "get_process_id_08005604"
        },
        "FUN_080008cc": {
            "renaming": {
                "FUN_080008cc": "update_buffer_080008cc",
                "this": "modbus_instance",
                "u8exception": "exception_code",
                "bVar1": "second_byte",
                "au8Buffer": "buffer",
                "u8id": "id",
                "u8BufferSize": "buffer_size"
            },
            "code": "void __thiscall Modbus::update_buffer_080008cc(Modbus *modbus_instance, uint8_t exception_code)\n{\n  byte second_byte = modbus_instance->buffer[1];\n  modbus_instance->buffer[0] = modbus_instance->id;\n  modbus_instance->buffer[1] = second_byte ^ 0x80;\n  modbus_instance->buffer[2] = exception_code;\n  modbus_instance->buffer_size = '\\x03';\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080008cc",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "update_buffer_080008cc"
        },
        "FUN_08004a84": {
            "renaming": {
                "FUN_08004a84": "improved_printf_08004a84",
                "param_1": "stream",
                "param_2": "format",
                "param_3": "arg_list",
                "param_4": "width_and_prec",
                "bVar1": "is_digit",
                "puVar2": "digits",
                "iVar3": "chars_written",
                "pvVar4": "ptr",
                "piVar5": "args",
                "pbVar6": "p",
                "pbVar7": "start",
                "unaff_r9": "saved_stream",
                "iVar8": "result",
                "local_8c": "args_ptr",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "type",
                "local_7c": "width",
                "local_74": "total_chars_written",
                "local_70": "current_arg_type",
                "local_6f": "space_char",
                "local_6e": "plus_char",
                "local_45": "sign_char",
                "local_30": "zero_char"
            },
            "code": "\nint improved_printf_08004a84(int stream,undefined *format,byte *arg_list,int *width_and_prec)\n\n{\n  bool is_digit;\n  undefined *digits;\n  int chars_written;\n  void *ptr;\n  int *args;\n  byte *p;\n  byte *start;\n  int saved_stream;\n  int result;\n  int *args_ptr;\n  uint flags;\n  int precision;\n  undefined4 type;\n  int width;\n  int total_chars_written;\n  byte current_arg_type;\n  undefined space_char;\n  undefined plus_char;\n  undefined sign_char;\n  undefined4 zero_char;\n  \n  args_ptr = width_and_prec;\n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (format == PTR___sf_fake_stdin_08004c90) {\n    format = *(undefined **)(stream + 4);\n  }\n  else if (format == PTR___sf_fake_stdout_08004c98) {\n    format = *(undefined **)(stream + 8);\n  }\n  else if (format == PTR___sf_fake_stderr_08004c9c) {\n    format = *(undefined **)(stream + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(format + 0xc) << 0x1c)) || (*(int *)(format + 0x10) == 0)) &&\n     (result = __swsetup_r(stream,format), result != 0)) {\n    return -1;\n  }\n  total_chars_written = 0;\n  space_char = 0x20;\n  plus_char = 0x30;\n  p = arg_list;\nLAB_08004ac6:\n  start = p;\n  if (*start != 0) goto LAB_08004b7c;\n  goto LAB_08004ad0;\nLAB_08004b7c:\n  p = start + 1;\n  if (*start != 0x25) goto LAB_08004ac6;\nLAB_08004ad0:\n  result = (int)start - (int)arg_list;\n  if (result != 0) {\n    chars_written = __sfputs_r(stream,format,arg_list,result);\n    if (chars_written == -1) {\nLAB_08004c70:\n      if ((int)((uint)*(ushort *)(format + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return total_chars_written;\n    }\n    total_chars_written = total_chars_written + result;\n  }\n  if (*start == 0) goto LAB_08004c70;\n  flags = 0;\n  width = 0;\n  precision = -1;\n  type = 0;\n  sign_char = 0;\n  zero_char = 0;\n  p = start + 1;\n  while( true ) {\n    ptr = memchr(PTR_s___0__08004c94,(uint)*p,5);\n    digits = PTR_DAT_08004ca0;\n    arg_list = p + 1;\n    if (ptr == (void *)0x0) break;\n    flags = 1 << ((int)ptr - (int)PTR_s___0__08004c94 & 0xffU) | flags;\n    p = arg_list;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    sign_char = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    sign_char = 0x2b;\n  }\n  if (*p == 0x2a) {\n    args = args_ptr + 1;\n    result = *args_ptr;\n    args_ptr = args;\n    if (-1 < result) goto LAB_08004ba0;\n    width = -result;\n    flags = flags | 2;\n  }\n  else {\n    is_digit = false;\n    result = width;\n    arg_list = p;\n    while( true ) {\n      if (9 < *arg_list - 0x30) break;\n      result = result * 10 + (*arg_list - 0x30);\n      is_digit = true;\n      arg_list = arg_list + 1;\n    }\n    if (is_digit) {\nLAB_08004ba0:\n      width = result;\n    }\n  }\n  if (*arg_list == 0x2e) {\n    if (arg_list[1] == 0x2a) {\n      precision = *args_ptr;\n      if (precision < 0) {\n        precision = -1;\n      }\n      arg_list = arg_list + 2;\n      args_ptr = args_ptr + 1;\n    }\n    else {\n      is_digit = false;\n      precision = 0;\n      result = 0;\n      while( true ) {\n        arg_list = arg_list + 1;\n        if (9 < *arg_list - 0x30) break;\n        result = result * 10 + (*arg_list - 0x30);\n        is_digit = true;\n      }\n      if (is_digit) {\n        precision = result;\n      }\n    }\n  }\n  ptr = memchr(PTR_DAT_08004ca0,(uint)*arg_list,3);\n  if (ptr != (void *)0x0) {\n    flags = flags | 0x40 << ((int)ptr - (int)digits & 0xffU);\n    arg_list = arg_list + 1;\n  }\n  current_arg_type = *arg_list;\n  arg_list = arg_list + 1;\n  ptr = memchr(PTR_s_efgEFG_08004ca4,(uint)current_arg_type,6);\n  if (ptr == (void *)0x0) {\n    result = _printf_i(stream,&flags,format,DAT_08004cac,&args_ptr);\n  }\n  else {\n    result = stream;\n    if (DAT_08004ca8 == 0) {\n      args_ptr = (int *)(((int)args_ptr + 7U & 0xfffffff8) + 8);\n      result = saved_stream;\n      goto LAB_08004c22;\n    }\n  }\n  if (result == -1) goto LAB_08004c70;\nLAB_08004c22:\n  total_chars_written = total_chars_written + result;\n  p = arg_list;\n  saved_stream = result;\n  goto LAB_08004ac6;\n}\n\n",
            "called": [
                "memchr",
                "__swsetup_r",
                "__sfputs_r",
                "_printf_i",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a84",
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "imported": false,
            "current_name": "improved_printf_08004a84"
        },
        "FUN_08005608": {
            "renaming": {
                "FUN_08005608": "read_and_update_data_08005608",
                "param_1": "file_descriptor",
                "param_2": "data_address",
                "iVar1": "bytes_read",
                "uVar2": "updated_data",
                "bVar3": "read_successful"
            },
            "code": "void read_and_update_data_08005608(int file_descriptor, int data_address){\n  int bytes_read = _read_r(file_descriptor, (int)*(short *)(data_address + 0xe));\n  bool read_successful = bytes_read >= 0;\n  uint updated_data = read_successful ? *(int *)(data_address + 0x54) + bytes_read : *(ushort *)(data_address + 0xc) & 0xffffefff;\n  if (read_successful) {\n    *(uint *)(data_address + 0x54) = updated_data;\n  }\n  else {\n    *(short *)(data_address + 0xc) = (short)updated_data;\n  }\n}",
            "called": [
                "_read_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005608",
            "calling": [],
            "imported": false,
            "current_name": "read_and_update_data_08005608"
        },
        "FUN_08002efa": {
            "renaming": {
                "FUN_08002efa": "receive_data_08002efa",
                "*huart": "*uart_handle",
                "*pData": "*data",
                "Size": "size",
                "RxState": "rx_state",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_BUSY": "HAL_BUSY",
                "pData == (uint8_t *)0x0": "data == NULL",
                "HAL_ERROR": "HAL_ERROR",
                "Size == 0": "size == 0",
                "huart->Lock": "uart_handle->lock",
                "pRxBuffPtr": "rx_buffer",
                "RxXferSize": "rx_transfer_size",
                "RxXferCount": "rx_transfer_count",
                "ErrorCode": "error_code",
                "HAL_UART_STATE_BUSY_RX": "HAL_UART_STATE_BUSY_RX",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "Instance": "instance",
                "CR3": "CR3",
                "CR1": "CR1",
                "|=": "|="
            },
            "code": "HAL_StatusTypeDef receive_data_08002efa(UART_HandleTypeDef *uart_handle, uint8_t *data, uint16_t size)\n{\n    if (uart_handle->rx_state != HAL_UART_STATE_READY) {\n        return HAL_BUSY;\n    }\n    if (data == NULL) {\n        return HAL_ERROR;\n    }\n    if (size == 0) {\n        return HAL_ERROR;\n    }\n    if (uart_handle->lock != HAL_LOCKED) {\n        uart_handle->rx_buffer = data;\n        uart_handle->rx_transfer_size = size;\n        uart_handle->rx_transfer_count = size;\n        uart_handle->error_code = 0;\n        uart_handle->rx_state = HAL_UART_STATE_BUSY_RX;\n        uart_handle->lock = HAL_UNLOCKED;\n        uart_handle->instance->CR3 |= 1;\n        uart_handle->instance->CR1 |= 0x120;\n        return HAL_OK;\n    }\n    return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002efa",
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "imported": false,
            "current_name": "receive_data_08002efa"
        },
        "FUN_0800268c": {
            "renaming": {
                "FUN_0800268c": "do_nothing_0800268c"
            },
            "code": "\nvoid do_nothing_0800268c(RTC_HandleTypeDef *hrtc)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800268c",
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_0800268c"
        },
        "FUN_080058f0": {
            "renaming": {
                "std::ctype_byname<wchar_t>::FUN_080058f0": "set_wchar_t_ctype_flags",
                "PTR_id_08005954": "ptr_id_1",
                "PTR_id_08005958": "ptr_id_2",
                "PTR_id_0800595c": "ptr_id_3",
                "PTR_id_08005960": "ptr_id_4",
                "PTR_id_08005964": "ptr_id_5",
                "PTR_id_08005968": "ptr_id_6",
                "PTR_id_0800596c": "ptr_id_7",
                "PTR_id_08005970": "ptr_id_8",
                "FUN_080058f0": "set_wchar_t_ctype_flags_080058f0"
            },
            "code": "void set_wchar_t_ctype_flags_080058f0() {\n    if (*(int *)PTR_id_08005954 < 0) {\n        *(undefined4 *)PTR_id_08005954 = 1;\n    }\n    if (*(int *)PTR_id_08005958 < 0) {\n        *(undefined4 *)PTR_id_08005958 = 1;\n    }\n    if (*(int *)PTR_id_0800595c < 0) {\n        *(undefined4 *)PTR_id_0800595c = 1;\n    }\n    if (*(int *)PTR_id_08005960 < 0) {\n        *(undefined4 *)PTR_id_08005960 = 1;\n    }\n    if (*(int *)PTR_id_08005964 < 0) {\n        *(undefined4 *)PTR_id_08005964 = 1;\n    }\n    if (*(int *)PTR_id_08005968 < 0) {\n        *(undefined4 *)PTR_id_08005968 = 1;\n    }\n    if (*(int *)PTR_id_0800596c < 0) {\n        *(undefined4 *)PTR_id_0800596c = 1;\n    }\n    if (*(int *)PTR_id_08005970 < 0) {\n        *(undefined4 *)PTR_id_08005970 = 1;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058f0",
            "calling": [],
            "imported": false,
            "current_name": "set_wchar_t_ctype_flags_080058f0"
        },
        "FUN_08001aac": {
            "renaming": {
                "FUN_08001aac": "do_nothing_08001aac"
            },
            "code": "\nvoid do_nothing_08001aac(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001aac",
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "imported": false,
            "current_name": "do_nothing_08001aac"
        },
        "FUN_080056b4": {
            "renaming": {
                "FUN_080056b4": "close_file_and_set_error_080056b4",
                "param_1": "error_code_ptr",
                "param_2": "file_descriptor",
                "puVar1": "error_ptr",
                "iVar2": "close_result"
            },
            "code": "void close_file_and_set_error_080056b4(int *error_code_ptr, int file_descriptor) {\n  undefined *error_ptr;\n  int close_result;\n  error_ptr = PTR_errno_080056d0;\n  *(undefined4 *)PTR_errno_080056d0 = 0;\n  close_result = _close(file_descriptor);\n  if ((close_result == -1) && (*(int *)error_ptr != 0)) {\n    *error_code_ptr = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080056b4",
            "calling": [
                "__sclose"
            ],
            "imported": false,
            "current_name": "close_file_and_set_error_080056b4"
        },
        "FUN_0800450a": {
            "renaming": {
                "FUN_0800450a": "printAddress_0800450a",
                "this": "ipAddress",
                "p": "printer",
                "iVar3": "i",
                "iVar4": "totalPrinted",
                "sVar1": "bytesPrinted",
                "sVar2": "dotPrinted"
            },
            "code": "size_t __thiscall IPAddress::printAddress_0800450a(IPAddress *this, Print *printer) {\n\tsize_t totalPrinted = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tsize_t bytesPrinted = printer->print((this->_address).bytes[i], 10);\n\t\tsize_t dotPrinted = printer->print('.');\n\t\ttotalPrinted += bytesPrinted + dotPrinted;\n\t}\n\ttotalPrinted += printer->print((this->_address).bytes[3], 10);\n\treturn totalPrinted;\n}",
            "called": [
                "print",
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800450a",
            "calling": [],
            "imported": false,
            "current_name": "printAddress_0800450a"
        },
        "FUN_0800377c": {
            "renaming": {
                "FUN_0800377c": "handle_timer_interrupts_0800377c",
                "PTR_timer_handles_08003794": "timer_handles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt",
                "timer_handle_1": "timerHandle1",
                "timer_handle_2": "timerHandle2"
            },
            "code": "void handle_timer_interrupts_0800377c(void)\n{\n    TIM_HandleTypeDef* timer_handle_1 = *(TIM_HandleTypeDef**)PTR_PTR_timer_handles_08003794_08003794;\n    TIM_HandleTypeDef* timer_handle_2 = *(TIM_HandleTypeDef**)(PTR_PTR_timer_handles_08003794_08003794 + 0x24);\n    if (timer_handle_1 != NULL) {\n        HAL_TIM_IRQHandler(timer_handle_1);\n    }\n    if (timer_handle_2 != NULL) {\n        HAL_TIM_IRQHandler(timer_handle_2);\n    }\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800377c",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupts_0800377c"
        },
        "FUN_08003fec": {
            "renaming": {
                "FUN_08003fec": "handle_UART_interrupt_08003fec",
                "PTR_uart_handlers_08004000": "PTR_uart_handlers",
                "USART2_IRQn": "UART_interrupt_number",
                "*(UART_HandleTypeDef **)(PTR_uart_handlers_08004000 + 4)": "uart_handler"
            },
            "code": "void handle_UART_interrupt_08003fec(UART_HandleTypeDef **(UART_HandleTypeDef **)(PTR_uart_handlers_08004000 + 4)) {\n  HAL_NVIC_ClearPendingIRQ(USART2_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004000 + 4));\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fec",
            "calling": [],
            "imported": false,
            "current_name": "handle_UART_interrupt_08003fec"
        },
        "FUN_0800268e": {
            "renaming": {
                "FUN_0800268e": "resetTimer_0800268e",
                "htim": "timer",
                "pTVar1": "timer_instance",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "HAL_TIM_STATE_RESET": "HAL_TIM_STATE_RESET",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIM_PWM_MspDeInit": "HAL_TIM_PWM_MspDeInit",
                "HAL_OK": "HAL_OK",
                "CCER": "CCER",
                "CR1": "CR1",
                "U": "U"
            },
            "code": "HAL_StatusTypeDef resetTimer_0800268e(TIM_HandleTypeDef *timer)\n{\n  TIM_TypeDef *timer_instance;\n  timer->State = HAL_TIM_STATE_BUSY;\n  timer_instance = timer->Instance;\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 &= ~(1U);\n  }\n  HAL_TIM_PWM_MspDeInit(timer);\n  timer->State = HAL_TIM_STATE_RESET;\n  timer->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}",
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800268e",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "resetTimer_0800268e"
        },
        "FUN_080008e2": {
            "renaming": {
                "__thiscall Modbus::FUN_080008e2": "decodeModbusMessage",
                "this": "modbus",
                "regs": "holdingRegs",
                "u8size": "numRegs",
                "uVar1": "startReg",
                "uVar2": "numBits",
                "uVar3": "i",
                "uVar4": "bitIndex",
                "uVar5": "numBytes",
                "FUN_080008e2": "decodeModbusMessage_080008e2"
            },
            "code": "int8_t __thiscall decodeModbusMessage_080008e2(Modbus *modbus, uint16_t *holdingRegs, uint8_t numRegs)\n{\n    uint16_t startReg = makeWord(modbus->au8Buffer[2], modbus->au8Buffer[3]);\n    uint16_t numBits = makeWord(modbus->au8Buffer[4], modbus->au8Buffer[5]);\n    uint8_t numBytes = numBits >> 3;\n    if ((numBits & 0x07) != 0) {\n        numBytes++;\n    }\n    modbus->au8Buffer[2] = numBytes;\n    modbus->u8BufferSize = 3;\n    uint8_t bitIndex = 0;\n    for (uint16_t i = 0; i < numBits; i++) {\n        uint16_t regIndex = (startReg + i) / 16;\n        uint8_t bitPos = (startReg + i) % 16;\n        bool bitValue = (holdingRegs[regIndex] >> bitPos) & 1;\n        if (bitValue) {\n            modbus->au8Buffer[modbus->u8BufferSize] |= (1 << bitIndex);\n        } else {\n            modbus->au8Buffer[modbus->u8BufferSize] &= ~(1 << bitIndex);\n        }\n        bitIndex++;\n        if (bitIndex > 7) {\n            bitIndex = 0;\n            modbus->u8BufferSize++;\n        }\n    }\n    if ((numBits & 0x07) != 0) {\n        modbus->u8BufferSize++;\n    }\n    uint8_t responseSize = modbus->u8BufferSize;\n    sendTxBuffer(modbus);\n    return responseSize + 2;\n}",
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080008e2",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "decodeModbusMessage_080008e2"
        },
        "FUN_080045c8": {
            "renaming": {
                "__thiscall Print::FUN_080045c8": "print_number",
                "this": "self",
                "n": "number",
                "base": "base",
                "cVar1": "digit",
                "sVar2": "length",
                "sVar3": "total_length",
                "uVar4": "remainder",
                "uVar5": "base_number",
                "uVar6": "quotient",
                "__s": "current_digit",
                "buf": "buffer",
                "FUN_080045c8": "print_number_080045c8"
            },
            "code": "size_t __thiscall Print::print_number_080045c8(Print *this, ulong number, uint8_t base) {\n  char digit;\n  size_t length;\n  size_t total_length;\n  uint base_number;\n  uint quotient;\n  uint remainder;\n  char buffer[33];\n\n  base_number = (uint)base;\n  buffer[32] = '\\0';\n  if (base_number < 2) {\n    base_number = 10;\n  }\n  char *current_digit = buffer + 0x20;\n  do {\n    quotient = number / base_number;\n    remainder = (number & 0xff) - ((int)(short)quotient * (int)(short)base_number & 0xffU) & 0xff;\n    current_digit--;\n    digit = (char)remainder;\n    if (remainder < 10) {\n      digit += '0';\n    }\n    else {\n      digit += '7';\n    }\n    *current_digit = digit;\n    number = quotient;\n  } while (quotient != 0);\n  if (current_digit == (char *)0x0) {\n    total_length = 0;\n  }\n  else {\n    length = strlen(current_digit);\n    total_length = (*this->_vptr_Print[1])(length, current_digit, length);\n  }\n  return total_length;\n}",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045c8",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "print_number_080045c8"
        },
        "FUN_08003d18": {
            "renaming": {
                "FUN_08003d18": "transmit_uart_data_08003d18",
                "data": "data_ptr",
                "size": "data_size",
                "pin": "pin_name",
                "HVar1": "status",
                "uVar2": "start_time",
                "pvVar3": "peripheral",
                "uVar4": "end_time",
                "uVar5": "index"
            },
            "code": "size_t transmit_uart_data_08003d18(uint8_t *data, uint32_t size) {\n    PinName_conflict pin_name;\n    HAL_StatusTypeDef status;\n    uint32_t start_time;\n    void *peripheral;\n    uint32_t index;\n\n    start_time = HAL_GetTick();\n    pin_name = *(PinName_conflict *)(PTR_digitalPin_08003dc0 + 0x9a);\n    peripheral = pinmap_peripheral(pin_name, (PinMap_conflict *)PTR_PinMap_UART_TX_08003dc4);\n    if (peripheral == (void *)0x0) {\n        return 0;\n    }\n    index = 0;\n    while ((index < 10 && ((*(int *)(PTR_uart_handlers_08003dc8 + index * 4) == 0 || (peripheral = pinmap_peripheral(pin_name, (PinMap_conflict *)PTR_PinMap_UART_TX_08003dc4), **(void ***)(PTR_uart_handlers_08003dc8 + index * 4) != peripheral))))) {\n        index = (index + 1) & 0xff;\n    }\n    if (9 < index) {\n        if ((9 < (byte)PTR_serial_debug_08003dcc[0x44]) && (uart_debug_init(), 9 < (byte)PTR_serial_debug_08003dcc[0x44])) {\n            return 0;\n        }\n        index = (uint)(byte)PTR_serial_debug_08003dcc[0x44];\n    }\n    do {\n        status = HAL_UART_Transmit(*(UART_HandleTypeDef **)(PTR_uart_handlers_08003dc8 + index * 4), data, (uint16_t)size, 1000);\n        if (status == HAL_OK) {\n            return size;\n        }\n        start_time = HAL_GetTick();\n    } while (start_time - HAL_GetTick() < 1000);\n    return 0;\n}",
            "called": [
                "uart_debug_init",
                "HAL_UART_Transmit",
                "HAL_GetTick",
                "pinmap_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003d18",
            "calling": [
                "_write"
            ],
            "imported": false,
            "current_name": "transmit_uart_data_08003d18"
        },
        "FUN_08004640": {
            "renaming": {
                "FUN_08004640": "concatenate_bytes_08004640",
                "h": "high_byte",
                "l": "low_byte"
            },
            "code": "uint16_t concatenate_bytes_08004640(uint8_t high_byte, uint8_t low_byte)\n{\n  return CONCAT11(high_byte, low_byte);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004640",
            "calling": [
                "process_FC5",
                "validateRequest",
                "process_FC3",
                "process_FC1",
                "process_FC6",
                "process_FC15",
                "process_FC16"
            ],
            "imported": false,
            "current_name": "concatenate_bytes_08004640"
        },
        "FUN_08000c7c": {
            "renaming": {
                "FUN_08000c7c": "initialize_static_variables_08000c7c"
            },
            "code": "void initialize_static_variables_08000c7c(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c7c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_08000c7c"
        },
        "FUN_08004760": {
            "renaming": {
                "FUN_08004760": "handle_GPIO_interrupt_08004760"
            },
            "code": "void handle_GPIO_interrupt_08004760(void)\n{\n  // Handle interrupt on GPIO pin 1\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004760",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_interrupt_08004760"
        },
        "FUN_080034ce": {
            "renaming": {
                "FUN_080034ce": "initialize_system_080034ce"
            },
            "code": "void initialize_system_080034ce(void)\n{\n  HAL_Init();\n  SystemClock_Config();\n  return;\n}",
            "called": [
                "SystemClock_Config",
                "HAL_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080034ce",
            "calling": [
                "init"
            ],
            "imported": false,
            "current_name": "initialize_system_080034ce"
        },
        "FUN_08003798": {
            "renaming": {
                "FUN_08003798": "handle_timer_interrupt_08003798",
                "PTR_timer_handles_080037a8": "PTR_timer_handles",
                "timer_handle": "timer_handle",
                "HAL_TIM_IRQHandler": "handle_timer_irq"
            },
            "code": "void handle_timer_interrupt_08003798(void)\n{\n  TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef **)(PTR_timer_handles_080037a8_080037a8 + 4);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003798",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08003798"
        },
        "FUN_080047fe": {
            "renaming": {
                "FUN_080047fe": "register_atexit_function_080047fe",
                "param_1": "func",
                "param_2": "arg",
                "__cxa_atexit": "__cxa_register_atexit"
            },
            "code": "void register_atexit_function_080047fe(void (*func)(void), void *arg) {\n  __cxa_atexit(arg, func);\n  return;\n}",
            "called": [
                "__cxa_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047fe",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "register_atexit_function_080047fe"
        },
        "FUN_08005974": {
            "renaming": {
                "std::ctype_byname<char>::FUN_08005974": "set_char_type_flags",
                "FUN_08005974": "set_char_type_flags_08005974"
            },
            "code": "void set_char_type_flags_08005974() {\\n\\\n  if (*(int *)PTR_id_080059d8 < 0) {\\n\\\n    *(undefined4 *)PTR_id_080059d8 = 1;\\n\\\n  }\\n\\\n  if (*(int *)PTR_id_080059dc < 0) {\\n\\\n    *(undefined4 *)PTR_id_080059dc = 1;\\n\\\n  }\\n\\\n  if (*(int *)PTR_id_080059e0 < 0) {\\n\\\n    *(undefined4 *)PTR_id_080059e0 = 1;\\n\\\n  }\\n\\\n  if (*(int *)PTR_id_080059e4 < 0) {\\n\\\n    *(undefined4 *)PTR_id_080059e4 = 1;\\n\\\n  }\\n\\\n  if (*(int *)PTR_id_080059e8 < 0) {\\n\\\n    *(undefined4 *)PTR_id_080059e8 = 1;\\n\\\n  }\\n\\\n  if (*(int *)PTR_id_080059ec < 0) {\\n\\\n    *(undefined4 *)PTR_id_080059ec = 1;\\n\\\n  }\\n\\\n  if (*(int *)PTR_id_080059f0 < 0) {\\n\\\n    *(undefined4 *)PTR_id_080059f0 = 1;\\n\\\n  }\\n\\\n  if (*(int *)PTR_id_080059f4 < 0) {\\n\\\n    *(undefined4 *)PTR_id_080059f4 = 1;\\n\\\n  }\\n\\\n  return;\\n\\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005974",
            "calling": [],
            "imported": false,
            "current_name": "set_char_type_flags_08005974"
        },
        "FUN_08001256": {
            "renaming": {
                "FUN_08001256": "i2c_transfer_08001256",
                "*hi2c": "*handle",
                "uVar1": "transfer_options",
                "pIVar2": "i2c_instance",
                "tmpreg": "cr1_reg",
                "tmpreg_1": "cr2_reg",
                "tmpreg_2": "event_count",
                "tmpreg_3": "transfer_count",
                "tmpreg_4": "previous_state",
                "tmpreg_5": "addressing_mode"
            },
            "code": "HAL_StatusTypeDef i2c_transfer_08001256(I2C_HandleTypeDef *handle)\n{\n  uint32_t transfer_options = handle->XferOptions;\n  I2C_TypeDef *i2c_instance = handle->Instance;\n  uint32_t cr1_reg = i2c_instance->CR1;\n  uint32_t cr2_reg = i2c_instance->CR2;\n  uint32_t event_count = handle->EventCount;\n  uint32_t transfer_count = handle->XferCount;\n  uint32_t previous_state = handle->PreviousState;\n  uint32_t addressing_mode = handle->Init.AddressingMode;\n\n  if ((handle->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((event_count != 0 || (handle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((event_count == 0) && ((addressing_mode == 0xc000))) {\n      cr1_reg |= 0x100;\n      handle->EventCount = event_count + 1;\n    }\n    else {\n      if (transfer_count == 0) {\n        cr1_reg |= 0x200;\n      }\n      else if (transfer_count == 1) {\n        if (transfer_options == 0xffff0000) {\n          cr1_reg &= 0xfffffbff;\n          if ((cr2_reg & 0x800) == 0) {\n            cr1_reg |= 0x200;\n          }\n          else {\n            cr1_reg &= 0xfffffbff;\n          }\n        }\n        else if (((transfer_options == 4) || (transfer_options == 8)) || (previous_state == 0x12)) {\n          cr1_reg &= 0xfffffbff;\n          cr1_reg |= 0x200;\n        }\n        else if (transfer_options == 2) {\n          cr1_reg |= 0x400;\n        }\n        else {\n          cr1_reg &= 0xfffffbff;\n        }\n      }\n      else if (transfer_count == 2) {\n        if (transfer_options == 2) {\n          cr1_reg |= 0x400;\n        }\n        else {\n          cr1_reg &= 0xfffffbff;\n          cr1_reg |= 0x800;\n        }\n        if ((cr2_reg & 0x800) != 0) {\n          cr2_reg |= 0x1000;\n        }\n      }\n      else {\n        cr1_reg |= 0x400;\n        if ((cr2_reg & 0x800) != 0) {\n          cr2_reg |= 0x1000;\n        }\n      }\n      handle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001256",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08001256"
        },
        "FUN_08004884": {
            "renaming": {
                "FUN_08004884": "initialize_global_objects_08004884",
                "puVar1": "preinit_array_end",
                "puVar2": "preinit_array_start",
                "puVar3": "global_dtors_aux_fini_array_entry",
                "iVar4": "preinit_array_size",
                "iVar5": "i"
            },
            "code": "void initialize_global_objects_08004884() {\n    undefined *preinit_array_end = PTR___preinit_array_end_080048bc;\n    int preinit_array_size = (int)PTR___preinit_array_end_080048c0 - (int)PTR___preinit_array_end_080048bc;\n    for (int i = 0; PTR___do_global_dtors_aux_fini_array_entry_080048c8, PTR___preinit_array_end_080048c4, i != preinit_array_size >> 2; i++) {\n        (**(code **)(preinit_array_end + i * 4))();\n    }\n    _init();\n    for (int i = 0; i != (int)PTR___do_global_dtors_aux_fini_array_entry_080048c8 - (int)PTR___preinit_array_end_080048c4 >> 2; i++) {\n        (**(code **)(PTR___preinit_array_end_080048c4 + i * 4))();\n    }\n    return;\n}",
            "called": [
                "premain",
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004884",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "initialize_global_objects_08004884"
        },
        "FUN_08004648": {
            "renaming": {
                "FUN_08004648": "initialize_EVP_PKEY_context_08004648",
                "ctx": "context"
            },
            "code": "void initialize_EVP_PKEY_context_08004648(EVP_PKEY_CTX *context)\n{\n  context = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(context);\n  return;\n}",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004648",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_context_08004648"
        },
        "FUN_08000600": {
            "renaming": {
                "__thiscall Modbus::FUN_08000600": "setModbusPort",
                "this": "modbus",
                "u32speed": "speed",
                "uVar1": "serialNumber",
                "iVar2": "returnValue",
                "port": "HardwareSerial *port",
                "u8serno": "modbus->serialNumber",
                "PTR_Serial3_08000668": "HardwareSerial *PTR_Serial3_08000668",
                "u8txenpin": "modbus->txEnablePin",
                "pinMode": "pinMode",
                "digitalWrite": "digitalWrite",
                "u8BufferSize": "modbus->bufferSize",
                "u8lastRec": "modbus->lastReceived",
                "u16errCnt": "modbus->errorCount",
                "u16OutCnt": "modbus->outgoingCount",
                "u16InCnt": "modbus->incomingCount",
                "FUN_08000600": "setModbusPort_08000600"
            },
            "code": "void __thiscall setModbusPort_08000600(Modbus *modbus, long speed)\n{\n  uint8_t serialNumber = modbus->serialNumber;\n  HardwareSerial *port;\n  if (serialNumber == '\\x02' || serialNumber == '\\x03' || serialNumber == '\\x01') {\n    port = (HardwareSerial *)PTR_Serial3_08000668;\n  }\n  else {\n    port = (HardwareSerial *)PTR_Serial3_08000668;\n  }\n  HardwareSerial::begin(port, speed, '\\x06');\n  if (modbus->txEnablePin > 1) {\n    pinMode((uint)modbus->txEnablePin, OUTPUT);\n    digitalWrite((uint)modbus->txEnablePin, LOW);\n  }\n  while ((*(port->super_Stream).super_Print._vptr_Print[3])() >= 0);\n  modbus->bufferSize = 0;\n  modbus->lastReceived = 0;\n  modbus->errorCount = 0;\n  modbus->outgoingCount = 0;\n  modbus->incomingCount = 0;\n}",
            "called": [
                "digitalWrite",
                "pinMode",
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000600",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "setModbusPort_08000600"
        },
        "FUN_080045be": {
            "renaming": {
                "FUN_080045be": "print_character_080045be",
                "this": "print_object",
                "c": "character",
                "sVar1": "character_size"
            },
            "code": "size_t __thiscall print_character_080045be(Print *print_object, char character) {\n\tsize_t character_size;\n\tcharacter_size = (**print_object->_vptr_Print)(print_object, (int)character);\n\treturn character_size;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045be",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "print_character_080045be"
        },
        "FUN_08004646": {
            "renaming": {
                "FUN_08004646": "do_nothing_08004646"
            },
            "code": "\nvoid do_nothing_08004646(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004646",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "do_nothing_08004646"
        },
        "FUN_0800407c": {
            "renaming": {
                "FUN_0800407c": "handle_UART8_interrupt_0800407c",
                "PTR_uart_handlers_08004090": "uart_handlers_ptr",
                "UART8_IRQn": "UART8_Interrupt",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt",
                "UART_HandleTypeDef": "UART_handle",
                "uart8_handle": "UART8_handle"
            },
            "code": "void handle_UART8_interrupt_0800407c(void)\n{\n  HAL_NVIC_ClearPendingIRQ(UART8_IRQn);\n  UART_HandleTypeDef *uart8_handle = *(UART_HandleTypeDef **)(PTR_uart_handlers_08004090 + 0x1c);\n  HAL_UART_IRQHandler(uart8_handle);\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800407c",
            "calling": [],
            "imported": false,
            "current_name": "handle_UART8_interrupt_0800407c"
        },
        "FUN_08000728": {
            "renaming": {
                "FUN_08000728": "calculateCRC_08000728",
                "this": "modbus",
                "u8length": "dataLength",
                "uVar2": "crc",
                "uVar3": "mask",
                "uVar4": "i",
                "bVar1": "j",
                "au8Buffer": "dataBuffer",
                "ushort": "uint16_t",
                "byte": "uint8_t"
            },
            "code": "uint16_t __thiscall Modbus::calculateCRC_08000728(Modbus *modbus, uint8_t dataLength) {\\n\"\n                      \"    uint16_t crc = 0xFFFF;\\n\"\n                      \"    for (uint8_t i = 0; i < dataLength; i++) {\\n\"\n                      \"        crc ^= modbus->dataBuffer[i];\\n\"\n                      \"        for (uint8_t j = 0; j < 8; j++) {\\n\"\n                      \"            uint16_t mask = -(crc & 1);\\n\"\n                      \"            crc = (crc >> 1) ^ (0xA001 & mask);\\n\"\n                      \"        }\\n\"\n                      \"    }\\n\"\n                      \"    return (crc << 8) | (crc >> 8);\\n\"\n                      \"}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000728",
            "calling": [
                "sendTxBuffer"
            ],
            "imported": false,
            "current_name": "calculateCRC_08000728"
        },
        "FUN_0800354a": {
            "renaming": {
                "FUN_0800354a": "find_pin_function_0800354a",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "function_address"
            },
            "code": "uint32_t find_pin_function_0800354a(PinName_conflict pin, PinMap_conflict *map)\n{\n  uint32_t function_address;\n  \n  if (pin == NC) {\n    return 0xffffffff;\n  }\n  function_address = pinmap_find_function(pin, map);\n  return function_address;\n}",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800354a",
            "calling": [
                "get_pwm_channel",
                "uart_init",
                "get_dac_channel",
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "find_pin_function_0800354a"
        },
        "FUN_0800124a": {
            "renaming": {
                "FUN_0800124a": "send_i2c_data_0800124a",
                "hi2c": "i2c_handle",
                "hi2c->Devaddress": "i2c_handle->Devaddress",
                "hi2c->Instance->DR": "i2c_handle->Instance->DR",
                "hi2c->Devaddress & 0xff": "dev_address",
                "HAL_StatusTypeDef": "HAL_StatusTypeDef",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "HAL_StatusTypeDef send_i2c_data_0800124a(I2C_HandleTypeDef *i2c_handle)\n{\n  uint8_t dev_address = i2c_handle->Devaddress & 0xff;\n  i2c_handle->Instance->DR = dev_address;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800124a",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "send_i2c_data_0800124a"
        },
        "FUN_08004094": {
            "renaming": {
                "FUN_08004094": "allocate_memory_08004094",
                "incr": "increment",
                "pcVar1": "current_address",
                "pcVar2": "new_address"
            },
            "code": "caddr_t allocate_memory_08004094(int increment) {\n  caddr_t current_address;\n  caddr_t new_address;\n  \n  if (*(int *)PTR_heap_end_080040c4 == 0) {\n    *(undefined **)PTR_heap_end_080040c4 = PTR__ebss_080040c8;\n  }\n  current_address = *(caddr_t *)PTR_heap_end_080040c4;\n  new_address = current_address + increment;\n  if (new_address <= &stack0x00000000) {\n    *(caddr_t *)PTR_heap_end_080040c4 = new_address;\n    return current_address;\n  }\n  *(undefined4 *)PTR_errno_080040cc = 0xc;\n  return (caddr_t)0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004094",
            "calling": [
                "_sbrk_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08004094"
        },
        "FUN_080033c8": {
            "renaming": {
                "FUN_080033c8": "clear_DAC_buffer_080033c8",
                "hdac": "dac_handle",
                "PTR_DAT_080033d4": "buffer_ptr",
                "DAT_080033d4": "buffer_value"
            },
            "code": "void clear_DAC_buffer_080033c8(DAC_HandleTypeDef *dac_handle)\n{\n  uint32_t *PTR_DAT_080033d4 = (uint32_t *)(DAT_080033d4 + 0x40);\n  uint32_t DAT_080033d4 = *PTR_DAT_080033d4 & 0xdfffffff;\n  *PTR_DAT_080033d4 = DAT_080033d4;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033c8",
            "calling": [
                "HAL_DAC_DeInit"
            ],
            "imported": false,
            "current_name": "clear_DAC_buffer_080033c8"
        },
        "FUN_080031fc": {
            "renaming": {
                "FUN_080031fc": "get_gpio_port_080031fc",
                "port_idx": "port_index",
                "pGVar1": "gpio_port",
                "tmpreg": "unused_tmpreg_1",
                "tmpreg_1": "unused_tmpreg_2",
                "tmpreg_2": "unused_tmpreg_3",
                "tmpreg_3": "unused_tmpreg_4",
                "tmpreg_4": "unused_tmpreg_5",
                "tmpreg_5": "unused_tmpreg_6",
                "tmpreg_6": "unused_tmpreg_7",
                "tmpreg_7": "unused_tmpreg_8",
                "tmpreg_8": "unused_tmpreg_9",
                "tmpreg_9": "unused_tmpreg_10",
                "tmpreg_10": "unused_tmpreg_11",
                "DAT_08003350": "gpio_port_register_base",
                "DAT_08003354": "gpio_port_0",
                "DAT_08003358": "gpio_port_1",
                "DAT_0800335c": "gpio_port_2",
                "DAT_08003360": "gpio_port_3",
                "DAT_08003364": "gpio_port_4",
                "DAT_08003368": "gpio_port_5",
                "DAT_0800336c": "gpio_port_6",
                "DAT_08003370": "gpio_port_7",
                "DAT_08003374": "gpio_port_8",
                "DAT_08003378": "gpio_port_9",
                "DAT_0800337c": "gpio_port_10"
            },
            "code": "GPIO_TypeDef* get_gpio_port_080031fc(uint32_t port_index) {\n    GPIO_TypeDef* gpio_port = NULL;\n    uint32_t* gpio_port_register = (uint32_t*)(DAT_08003350 + 0x30);\n    switch (port_index) {\n        case 0: {\n            *gpio_port_register |= 0x01;\n            gpio_port = DAT_08003354;\n            break;\n        }\n        case 1: {\n            *gpio_port_register |= 0x02;\n            gpio_port = DAT_08003358;\n            break;\n        }\n        case 2: {\n            *gpio_port_register |= 0x04;\n            gpio_port = DAT_0800335c;\n            break;\n        }\n        case 3: {\n            *gpio_port_register |= 0x08;\n            gpio_port = DAT_08003360;\n            break;\n        }\n        case 4: {\n            *gpio_port_register |= 0x10;\n            gpio_port = DAT_08003364;\n            break;\n        }\n        case 5: {\n            *gpio_port_register |= 0x20;\n            gpio_port = DAT_08003368;\n            break;\n        }\n        case 6: {\n            *gpio_port_register |= 0x40;\n            gpio_port = DAT_0800336c;\n            break;\n        }\n        case 7: {\n            *gpio_port_register |= 0x80;\n            gpio_port = DAT_08003370;\n            break;\n        }\n        case 8: {\n            *gpio_port_register |= 0x100;\n            gpio_port = DAT_08003374;\n            break;\n        }\n        case 9: {\n            *gpio_port_register |= 0x200;\n            gpio_port = DAT_08003378;\n            break;\n        }\n        case 10: {\n            *gpio_port_register |= 0x400;\n            gpio_port = DAT_0800337c;\n            break;\n        }\n    }\n    return gpio_port;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080031fc",
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "imported": false,
            "current_name": "get_gpio_port_080031fc"
        },
        "FUN_08005580": {
            "renaming": {
                "FUN_08005580": "execute_process_08005580",
                "param_1": "status",
                "param_2": "process_id",
                "param_3": "signal",
                "param_4": "flags",
                "_Var1": "pid",
                "uVar2": "result",
                "iVar3": "function_pointer",
                "pcVar4": "function_pointer",
                "*param_1": "*status",
                "*(undefined4 *)(iVar3 + param_2 * 4)": "process_table[process_id]",
                "_getpid_r": "getpid",
                "_kill_r": "kill"
            },
            "code": "int execute_process_08005580(int *status, uint32_t process_id, int signal, uint32_t flags) {\n  __pid_t pid;\n  int result;\n  code *function_pointer;\n  if (process_id > 31) {\n    *status = 22;\n    return -1;\n  }\n  function_pointer = process_table[process_id];\n  if (function_pointer == NULL) {\n    pid = getpid();\n    result = kill(pid, signal);\n    return result;\n  }\n  else if (function_pointer == (code *)1) {\n    return 0;\n  }\n  else if (function_pointer == (code *)-1) {\n    *status = 22;\n    return 1;\n  }\n  else {\n    process_table[process_id] = NULL;\n    (*function_pointer)(process_id);\n    return 0;\n  }\n}",
            "called": [
                "_kill_r",
                "_getpid_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005580",
            "calling": [
                "raise"
            ],
            "imported": false,
            "current_name": "execute_process_08005580"
        },
        "FUN_08000690": {
            "renaming": {
                "FUN_08000690": "initialize_modbus_08000690",
                "__initialize_p": "should_initialize",
                "__priority": "priority_level",
                "Modbus": "Modbus",
                "PTR_slave_080006b0": "PTR_slave_080006b0"
            },
            "code": "void initialize_modbus_08000690(int should_initialize, int priority_level)\n{\n    if (should_initialize != 1) {\n        return;\n    }\n    if (priority_level == 0xffff) {\n        Modbus modbus_instance((Modbus *)PTR_slave_080006b0, '\\x01', '\\0', '\\0');\n    }\n    return;\n}",
            "called": [
                "Modbus"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000690",
            "calling": [
                "_GLOBAL__sub_I__ZN6ModbusC2Ev"
            ],
            "imported": false,
            "current_name": "initialize_modbus_08000690"
        },
        "FUN_08004254": {
            "renaming": {
                "FUN_08004254": "read_next_byte_from_serial_buffer_08004254",
                "this": "serial",
                "uVar1": "tail_index"
            },
            "code": "int read_next_byte_from_serial_buffer_08004254(HardwareSerial *serial){\n  uint tail_index = (uint)(serial->_serial).rx_tail;\n  if ((serial->_serial).rx_head != tail_index) {\n    return (uint)(serial->_serial).rx_buff[tail_index];\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004254",
            "calling": [],
            "imported": false,
            "current_name": "read_next_byte_from_serial_buffer_08004254"
        },
        "FUN_080054fc": {
            "renaming": {
                "FUN_080054fc": "allocate_memory_080054fc",
                "param_1": "memory_pool",
                "param_2": "memory_block",
                "uVar1": "flags",
                "iVar2": "size",
                "local_18": "size",
                "local_14": "buffer",
                "*param_2": "*memory_block",
                "*(ushort *)(param_2 + 3)": "*(ushort *)(memory_block + 3)",
                "param_2[5]": "memory_block[5]",
                "param_2[4]": "memory_block[4]",
                "*(short *)((int)param_2 + 0xe)": "*(short *)((int)memory_block + 0xe)",
                "allocated_memory": "allocated_memory"
            },
            "code": "void allocate_memory_080054fc(int memory_pool, int *memory_block) {\n  ushort flags;\n  int size;\n  int *buffer;\n\n  if ((uint)*(ushort *)(memory_block + 3) << 0x1e > -1) {\n    buffer = memory_block;\n    size = memory_pool;\n    flags = __swhatbuf_r(memory_pool, memory_block, &size, &buffer);\n    int *allocated_memory = _malloc_r(memory_pool, size);\n    if (allocated_memory != 0) {\n      *(undefined4 *)(memory_pool + 0x28) = DAT_08005578;\n      *memory_block = allocated_memory;\n      *(ushort *)(memory_block + 3) = *(ushort *)(memory_block + 3) | 0x80;\n      memory_block[5] = size;\n      memory_block[4] = allocated_memory;\n      if ((buffer != (int *)0x0) && (_isatty_r(memory_pool, (int)*(short *)((int)memory_block + 0xe)) != 0)) {\n        *(ushort *)(memory_block + 3) = *(ushort *)(memory_block + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(memory_block + 3) = flags | *(ushort *)(memory_block + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(memory_block + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(memory_block + 3) = *(ushort *)(memory_block + 3) & 0xfffc | 2;\n  }\n  *memory_block = (int)memory_block + 0x47;\n  memory_block[4] = (int)memory_block + 0x47;\n  memory_block[5] = 1;\n  return;\n}",
            "called": [
                "__swhatbuf_r",
                "_malloc_r",
                "_isatty_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080054fc",
            "calling": [
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_080054fc"
        },
        "FUN_08001420": {
            "renaming": {
                "FUN_08001420": "transfer_byte_08001420",
                "hi2c": "i2c_handler",
                "pBuffPtr": "data_ptr",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "XferCount": "transfer_count",
                "pbVar1": "data_byte"
            },
            "code": "HAL_StatusTypeDef transfer_byte_08001420(I2C_HandleTypeDef *i2c_handler)\n{\n  byte *data_ptr;\n  if (i2c_handler->XferCount != 0) {\n    data_ptr = i2c_handler->pBuffPtr;\n    i2c_handler->pBuffPtr = data_ptr + 1;\n    i2c_handler->Instance->DR = (uint)*data_ptr;\n    i2c_handler->XferCount = i2c_handler->XferCount - 1;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001420",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "transfer_byte_08001420"
        },
        "FUN_080026ca": {
            "renaming": {
                "FUN_080026ca": "do_nothing_080026ca"
            },
            "code": "\nvoid do_nothing_080026ca(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026ca",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080026ca"
        },
        "FUN_08000de4": {
            "renaming": {
                "FUN_08000de4": "initializeSystem_08000de4",
                "puVar1": "ptr_dat_e14",
                "DAT_08000e14": "DAT_08000e14",
                "HAL_NVIC_SetPriorityGrouping": "HAL_NVIC_SetPriorityGrouping",
                "FUN_08000de4Tick": "initializeSystemTick",
                "HAL_MspInit": "HAL_MspInit",
                "HAL_OK": "HAL_OK",
                "*puVar1": "*ptr_dat_e14",
                "*DAT_08000e14": "*DAT_08000e14",
                "*puVar1 | 0x400": "*ptr_dat_e14 |= BIT_10",
                "*puVar1 | 0x100": "*ptr_dat_e14 |= BIT_8",
                "*DAT_08000e14 | 0x200": "*DAT_08000e14 |= BIT_9",
                "3": "NVIC_PRIORITYGROUP_4",
                "0xf": "0xf"
            },
            "code": "HAL_StatusTypeDef initializeSystem_08000de4(void)\n{\n  uint32_t *ptr_dat_e14;\n  ptr_dat_e14 = DAT_08000e14;\n  *DAT_08000e14 | 0x200;\n  *ptr_dat_e14 |= BIT_10;\n  *ptr_dat_e14 |= BIT_8;\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\n  initializeSystem_08000de4Tick(0xf);\n  HAL_MspInit();\n  return HAL_OK;\n}",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000de4",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "initializeSystem_08000de4"
        },
        "FUN_08003840": {
            "renaming": {
                "FUN_08003840": "handle_timer_interrupt_08003840",
                "PTR_timer_handles_08003850": "PTR_timer_handles",
                "TIM_HandleTypeDef": "Timer_HandleTypeDef",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt_request",
                "timer_handle": "current_timer_handle"
            },
            "code": "void handle_timer_interrupt_08003840(void)\n{\n  TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef**)(PTR_timer_handles_08003850_08003850 + 0x28);\n  if (timer_handle != NULL)\n  {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003840",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08003840"
        },
        "FUN_080026ce": {
            "renaming": {
                "FUN_080026ce": "processTimerEvent_080026ce",
                "htim": "timerHandle",
                "pTVar1": "timerInstance"
            },
            "code": "void processTimerEvent_080026ce(TIM_HandleTypeDef *timerHandle)\n{\n    TIM_TypeDef *timerInstance = timerHandle->Instance;\n    if (((timerInstance->SR & TIM_FLAG_CC1) != 0) && ((timerInstance->DIER & TIM_IT_CC1) != 0)) {\n        timerInstance->SR = ~(TIM_FLAG_CC1);\n        timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n        if ((timerInstance->CCMR1 & TIM_CCMR1_CC1S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n            HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(timerHandle);\n        }\n        timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n    if (((timerInstance->SR & TIM_FLAG_CC2) != 0) && ((timerInstance->DIER & TIM_IT_CC2) != 0)) {\n        timerInstance->SR = ~(TIM_FLAG_CC2);\n        timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n        if ((timerInstance->CCMR1 & TIM_CCMR1_CC2S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n            HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(timerHandle);\n        }\n        timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n    if (((timerInstance->SR & TIM_FLAG_CC3) != 0) && ((timerInstance->DIER & TIM_IT_CC3) != 0)) {\n        timerInstance->SR = ~(TIM_FLAG_CC3);\n        timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n        if ((timerInstance->CCMR2 & TIM_CCMR2_CC3S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n            HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(timerHandle);\n        }\n        timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n    if (((timerInstance->SR & TIM_FLAG_CC4) != 0) && ((timerInstance->DIER & TIM_IT_CC4) != 0)) {\n        timerInstance->SR = ~(TIM_FLAG_CC4);\n        timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n        if ((timerInstance->CCMR2 & TIM_CCMR2_CC4S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n            HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(timerHandle);\n        }\n        timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n    if (((timerInstance->SR & TIM_FLAG_UPDATE) != 0) && ((timerInstance->DIER & TIM_IT_UPDATE) != 0)) {\n        timerInstance->SR = ~(TIM_FLAG_UPDATE);\n        HAL_TIM_PeriodElapsedCallback(timerHandle);\n    }\n    if (((timerInstance->SR & TIM_FLAG_BREAK) != 0) && ((timerInstance->DIER & TIM_IT_BREAK) != 0)) {\n        timerInstance->SR = ~(TIM_FLAG_BREAK);\n        HAL_TIMEx_BreakCallback(timerHandle);\n    }\n    if (((timerInstance->SR & TIM_FLAG_TRIGGER) != 0) && ((timerInstance->DIER & TIM_IT_TRIGGER) != 0)) {\n        timerInstance->SR = ~(TIM_FLAG_TRIGGER);\n        HAL_TIM_TriggerCallback(timerHandle);\n    }\n    if (((timerInstance->SR & TIM_FLAG_COM) != 0) && ((timerInstance->DIER & TIM_IT_COM) != 0)) {\n        timerInstance->SR = ~(TIM_FLAG_COM);\n        HAL_TIMEx_CommutationCallback(timerHandle);\n    }\n}",
            "called": [
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026ce",
            "calling": [
                "TIM1_UP_TIM10_IRQHandler",
                "TIM5_IRQHandler",
                "TIM1_BRK_TIM9_IRQHandler",
                "TIM1_TRG_COM_TIM11_IRQHandler",
                "TIM2_IRQHandler",
                "TIM7_IRQHandler",
                "TIM8_UP_TIM13_IRQHandler",
                "TIM8_BRK_TIM12_IRQHandler",
                "TIM3_IRQHandler",
                "TIM8_TRG_COM_TIM14_IRQHandler",
                "TIM6_DAC_IRQHandler",
                "TIM4_IRQHandler"
            ],
            "imported": false,
            "current_name": "processTimerEvent_080026ce"
        },
        "FUN_080026cc": {
            "renaming": {
                "FUN_080026cc": "do_nothing_080026cc"
            },
            "code": "\nvoid do_nothing_080026cc(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026cc",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080026cc"
        },
        "FUN_08001f3c": {
            "renaming": {
                "FUN_08001f3c": "reset_I2C_08001f3c",
                "*hdma": "i2c_handler",
                "*hi2c": "i2c",
                "CR1": "control_register_1",
                "XferCount": "transfer_count",
                "hdmatx": "dma_tx_handler",
                "hdmarx": "dma_rx_handler",
                "State": "state",
                "HAL_I2C_STATE_ABORT": "HAL_I2C_STATE_ABORT",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "Mode": "mode",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "ErrorCode": "error_code",
                "Instance": "instance",
                "HAL_I2C_ErrorCallback": "error_callback",
                "HAL_I2C_AbortCpltCallback": "abort_callback"
            },
            "code": "void reset_I2C_08001f3c(I2C_HandleTypeDef *i2c_handler){\n  I2C_HandleTypeDef *i2c;\n  i2c = (I2C_HandleTypeDef *)i2c_handler->Parent;\n  i2c->Instance->CR1 &= ~(1 << 10);\n  i2c->XferCount = 0;\n  i2c->hdmatx->XferAbortCallback = NULL;\n  i2c->hdmarx->XferAbortCallback = NULL;\n  if (i2c->State != HAL_I2C_STATE_ABORT) {\n    i2c->State = HAL_I2C_STATE_READY;\n    i2c->Mode = HAL_I2C_MODE_NONE;\n    i2c->Instance->CR1 &= ~(1 << 0);\n    HAL_I2C_ErrorCallback(i2c);\n    return;\n  }\n  i2c->State = HAL_I2C_STATE_READY;\n  i2c->Mode = HAL_I2C_MODE_NONE;\n  i2c->ErrorCode = 0;\n  i2c->Instance->CR1 &= ~(1 << 0);\n  HAL_I2C_AbortCpltCallback(i2c);\n  return;\n}",
            "called": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AbortCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001f3c",
            "calling": [],
            "imported": false,
            "current_name": "reset_I2C_08001f3c"
        },
        "FUN_08000218": {
            "renaming": {
                "FUN_08000218": "count_string_length_08000218",
                "__s": "str",
                "pcVar3": "current_position",
                "pcVar2": "next_position",
                "cVar1": "current_char"
            },
            "code": "size_t count_string_length_08000218(char* str) {\n  char current_char;\n  char* current_position = str;\n  while (current_char = *current_position) {\n    current_position++;\n  }\n  return (size_t)(current_position - str);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000218",
            "calling": [
                "printNumber"
            ],
            "imported": false,
            "current_name": "count_string_length_08000218"
        },
        "FUN_0800339c": {
            "renaming": {
                "FUN_0800339c": "pwm_pinmap_function_0800339c",
                "pin": "pin_name",
                "uVar1": "function",
                "uVar2": "pwm_index",
                "PTR_PinMap_PWM_080033c4": "pwm_pinmap"
            },
            "code": "uint32_t pwm_pinmap_function_0800339c(PinName_conflict pin)\n{\n  uint32_t function;\n  uint32_t pwm_index;\n  PinMap_conflict *PTR_PinMap_PWM_080033c4 = (PinMap_conflict *)PTR_PinMap_PWM_080033c4;\n  function = pinmap_function(pin, PTR_PinMap_PWM_080033c4);\n  pwm_index = (function << 12) >> 27;\n  if (pwm_index == 3) {\n    return 8;\n  }\n  if (pwm_index == 4) {\n    return 12;\n  }\n  if (pwm_index == 2) {\n    return 4;\n  }\n  return 0;\n}",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800339c",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "pwm_pinmap_function_0800339c"
        },
        "FUN_08003968": {
            "renaming": {
                "FUN_08003968": "handle_i2c_error_interrupt_08003968",
                "PTR_i2c_handles_08003974": "i2c_handles_ptr"
            },
            "code": "void handle_i2c_error_interrupt_08003968(void)\n{\n  I2C_HandleTypeDef* i2c_handle_ptr = *(I2C_HandleTypeDef **)(PTR_i2c_handles_08003974 + 8);\n  HAL_I2C_ER_IRQHandler(i2c_handle_ptr);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003968",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_error_interrupt_08003968"
        },
        "FUN_0800557e": {
            "renaming": {
                "FUN_0800557e": "do_nothing_0800557e"
            },
            "code": "\nvoid do_nothing_0800557e(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800557e",
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "imported": false,
            "current_name": "do_nothing_0800557e"
        },
        "FUN_08000e60": {
            "renaming": {
                "FUN_08000e60": "setIRQPriority_08000e60",
                "IRQn": "irq_num",
                "PreemptPriority": "priority_value",
                "SubPriority": "subpriority_value",
                "uVar1": "irq_num",
                "uVar2": "priority_bits",
                "uVar3": "priority_shift",
                "priority_mask": "priority_mask",
                "shifted_priority": "shifted_priority",
                "subpriority_mask": "subpriority_mask",
                "masked_subpriority": "masked_subpriority"
            },
            "code": "void setIRQPriority_08000e60(IRQn_Type_conflict IRQn, uint32_t PreemptPriority, uint32_t SubPriority) {\n  uint32_t irq_num = (uint32_t)IRQn;\n  uint32_t priority_bits = (*(int *)(DAT_08000ebc + 0xc) << 0x15) >> 0x1d;\n  uint32_t priority_shift = 7 - priority_bits;\n  if (priority_shift > 3) {\n    priority_shift = 4;\n  }\n  if (priority_bits + 4 < 7) {\n    priority_bits = 0;\n  }\n  else {\n    priority_bits -= 3;\n  }\n  uint32_t priority_mask = (1 << (priority_shift & 0xff)) - 1U;\n  uint32_t shifted_priority = (PreemptPriority & priority_mask) << (priority_bits & 0xff);\n  uint32_t subpriority_mask = (1 << (priority_bits & 0xff)) - 1U;\n  uint32_t masked_subpriority = SubPriority & subpriority_mask;\n  if ((int)irq_num < 0) {\n    *(char *)(DAT_08000ec0 + (irq_num & 0xf)) = (char)(shifted_priority << 4);\n  }\n  else {\n    *(char *)(irq_num + 0xe000e400) = (char)(shifted_priority << 4);\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000e60",
            "calling": [
                "uart_attach_rx_callback",
                "uart_attach_tx_callback",
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "imported": false,
            "current_name": "setIRQPriority_08000e60"
        },
        "FUN_0800557c": {
            "renaming": {
                "FUN_0800557c": "do_nothing_0800557c"
            },
            "code": "\nvoid do_nothing_0800557c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800557c",
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "imported": false,
            "current_name": "do_nothing_0800557c"
        },
        "FUN_0800165a": {
            "renaming": {
                "FUN_0800165a": "i2c_handle_address_match_0800165a",
                "*hi2c": "*i2c_handle",
                "AddrMatchCode": "address_match_code",
                "hi2c->Instance->SR2": "i2c_handle->Instance->SR2",
                "hi2c->Init": "i2c_handle->Init",
                "(hi2c->Instance->SR2 & 4) == 0": "(i2c_handle->Instance->SR2 & 4) == 0",
                "HAL_I2C_AddrCallback": "HAL_I2C_AddrCallback",
                "HAL_StatusTypeDef": "HAL_StatusTypeDef"
            },
            "code": "HAL_StatusTypeDef i2c_handle_address_match_0800165a(I2C_HandleTypeDef *i2c_handle)\n{\n  uint16_t address_match_code;\n  if ((i2c_handle->Instance->SR2 & 0x80) == 0) {\n    address_match_code = *(uint16_t *)&(i2c_handle->Init).OwnAddress1;\n  }\n  else {\n    address_match_code = *(uint16_t *)&(i2c_handle->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2c_handle, (i2c_handle->Instance->SR2 & 4) == 0, address_match_code);\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800165a",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_address_match_0800165a"
        },
        "FUN_080037d4": {
            "renaming": {
                "FUN_080037d4": "handle_timer_interrupt_080037d4",
                "PTR_timer_handles_080037e4": "PTR_timer_handles",
                "timer_handle": "timer_handle"
            },
            "code": "void handle_timer_interrupt_080037d4(void)\n{\n  TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef **)(PTR_timer_handles_080037e4_080037e4 + 0x10);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080037d4",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_080037d4"
        },
        "FUN_08000b04": {
            "renaming": {
                "__thiscall Modbus::FUN_08000b04": "readRegisters",
                "this": "modbusInstance",
                "regs": "registerArray",
                "u8size": "registerCount",
                "bVar1": "bufferIndex",
                "bVar2": "registerCountByte",
                "uVar3": "bufferSize",
                "uVar4": "currentRegister",
                "uVar5": "i",
                "FUN_08000b04": "readRegisters_08000b04"
            },
            "code": "int8_t __thiscall Modbus::readRegisters_08000b04(Modbus *modbusInstance, uint16_t *registerArray, uint8_t registerCount) {\n  byte bufferIndex = modbusInstance->au8Buffer[3];\n  byte registerCountByte = modbusInstance->au8Buffer[5];\n  modbusInstance->au8Buffer[4] = '\\0';\n  modbusInstance->au8Buffer[5] = registerCountByte;\n  modbusInstance->u8BufferSize = '\\x06';\n  for (uint i = 0; i < registerCountByte; i++) {\n    uint16_t currentRegister = makeWord(modbusInstance->au8Buffer[i * 2 + 7], modbusInstance->au8Buffer[i * 2 + 8]);\n    registerArray[bufferIndex + i] = currentRegister;\n  }\n  uint8_t bufferSize = modbusInstance->u8BufferSize;\n  sendTxBuffer(modbusInstance);\n  return bufferSize + '\\x02';\n}",
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000b04",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "readRegisters_08000b04"
        },
        "FUN_0800262c": {
            "renaming": {
                "FUN_0800262c": "update_RTC_state_0800262c",
                "hrtc": "RTC_handle",
                "RTC_ISR": "RTC_ISR",
                "RTC_CR": "RTC_CR",
                "RTC_ISR_ALRAF": "RTC_ISR_ALRAF",
                "RTC_ISR_ALRBF": "RTC_ISR_ALRBF",
                "RTC_ISR_ALRAF_CLEAR": "RTC_ISR_ALRAF_CLEAR",
                "RTC_ISR_ALRBF_CLEAR": "RTC_ISR_ALRBF_CLEAR",
                "DAT_08002688": "DAT_08002688",
                "RTC_FLAG_INIT_VALUE": "RTC_FLAG_INIT_VALUE"
            },
            "code": "void update_RTC_state_0800262c(RTC_HandleTypeDef *RTC_handle)\n{\n    uint32_t RTC_ISR = RTC_handle->Instance->ISR;\n    uint32_t RTC_CR = RTC_handle->Instance->CR;\n\n    if ((RTC_ISR & RTC_ISR_ALRAF) && (RTC_CR & RTC_CR_ALRAE)) {\n        HAL_RTC_AlarmAEventCallback(RTC_handle);\n        RTC_handle->Instance->ISR = (RTC_ISR & 0xff) | RTC_ISR_ALRAF_CLEAR;\n    }\n\n    if ((RTC_ISR & RTC_ISR_ALRBF) && (RTC_CR & RTC_CR_ALRBE)) {\n        HAL_RTCEx_AlarmBEventCallback(RTC_handle);\n        RTC_handle->Instance->ISR = (RTC_ISR & 0xff) | RTC_ISR_ALRBF_CLEAR;\n    }\n\n    *(uint32_t *)(DAT_08002688 + 0x14) = RTC_FLAG_INIT_VALUE;\n    RTC_handle->State = HAL_RTC_STATE_READY;\n}\n",
            "called": [
                "HAL_RTCEx_AlarmBEventCallback",
                "HAL_RTC_AlarmAEventCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800262c",
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "imported": false,
            "current_name": "update_RTC_state_0800262c"
        },
        "FUN_080047a8": {
            "renaming": {
                "FUN_080047a8": "handle_gpio_exti_interrupts_080047a8",
                "uVar1": "interrupt_pin"
            },
            "code": "void handle_gpio_exti_interrupts_080047a8(void)\n{\n  uint16_t interrupt_pin = 0x400;\n  while(interrupt_pin < 0x8001)\n  {\n    HAL_GPIO_EXTI_IRQHandler(interrupt_pin);\n    interrupt_pin <<= 1;\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047a8",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_interrupts_080047a8"
        },
        "FUN_08004388": {
            "renaming": {
                "__thiscall HardwareSerial::FUN_08004388": "setSerialConfig",
                "this": "serial",
                "baud": "baudrate",
                "config": "config",
                "bVar1": "configMask",
                "iVar2": "databits",
                "_serial": "serialData",
                "PTR_s__home_bo__arduino15_packages_STM_08004440": "assertFile",
                "PTR___PRETTY_FUNTION___0800443c": "assertFunction",
                "PTR_s_databits__0_08004438": "assertMessage",
                "FUN_08004388": "setSerialConfig_08004388"
            },
            "code": "void setSerialConfig_08004388(HardwareSerial *serial, ulong baudrate, byte config) {\n  byte parity = 0;\n  byte stopbits = 0;\n  byte databits = 0;\n  byte configMask = config & 7;\n\n  if (configMask == 4) {\n    databits = 7;\n  }\n  else if (configMask == 6) {\n    databits = 8;\n  }\n  else if (configMask == 2) {\n    databits = 6;\n  }\n\n  if ((config & 0x30) == 0x30) {\n    parity = 0x06;\n    databits++;\n  }\n  else if ((config & 0x20) == 0) {\n    parity = 0;\n  }\n  else {\n    parity = 0x04;\n    databits++;\n  }\n\n  if ((config & 8) != 0) {\n    stopbits = 1;\n  }\n\n  if (databits == 8) {\n    databits = 0;\n  }\n  else if (databits == 9) {\n    databits = 1;\n  }\n  else {\n    return;\n  }\n\n  (serial->_serial).baudrate = baudrate;\n  (serial->_serial).databits = databits << 13;\n  (serial->_serial).parity = parity << 9;\n  (serial->_serial).stopbits = stopbits << 13;\n\n  uart_init((serial_t *)&serial->_serial);\n  uart_attach_rx_callback((serial_t *)&serial->_serial, PTR_s__home_bo__arduino15_packages_STM_08004434);\n}\n",
            "called": [
                "uart_init",
                "__assert_func",
                "uart_attach_rx_callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004388",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "setSerialConfig_08004388"
        },
        "FUN_080051ac": {
            "renaming": {
                "FUN_080051ac": "terminate_program_080051ac",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void terminate_program_080051ac(void)\n{\n    raise(SIGABRT);\n    exit(EXIT_FAILURE);\n}",
            "called": [
                "raise",
                "_exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080051ac",
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "imported": false,
            "current_name": "terminate_program_080051ac"
        },
        "FUN_080052cc": {
            "renaming": {
                "FUN_080052cc": "flush_if_buffer_nonempty_080052cc",
                "param_1": "file_descriptor",
                "param_2": "stream",
                "param_3": "buffer_size",
                "param_4": "flush_type",
                "uVar1": "result",
                "PTR___sf_fake_stdin_08005314": "PTR___sf_fake_stdin_08005314",
                "PTR___sf_fake_stdout_08005318": "PTR___sf_fake_stdout_08005318",
                "PTR___sf_fake_stderr_0800531c": "PTR___sf_fake_stderr_0800531c",
                "__sinit": "__sinit",
                "short": "short",
                "__sflush_r": "__sflush_r"
            },
            "code": "int flush_if_buffer_nonempty_080052cc(int file_descriptor, char* stream, int buffer_size, int flush_type) {\n    int result = 0;\n    int* stream_buffer_status = (int*)(stream + 0x10);\n    if (*stream_buffer_status != 0) {\n        if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n            __sinit();\n        }\n        if (stream == PTR___sf_fake_stdin_08005314) {\n            stream = *(char**)(file_descriptor + 4);\n        }\n        else if (stream == PTR___sf_fake_stdout_08005318) {\n            stream = *(char**)(file_descriptor + 8);\n        }\n        else if (stream == PTR___sf_fake_stderr_0800531c) {\n            stream = *(char**)(file_descriptor + 0xc);\n        }\n        short* stream_mode = (short*)(stream + 0xc);\n        if (*stream_mode != 0) {\n            result = __sflush_r(file_descriptor, stream, buffer_size, flush_type);\n        }\n    }\n    return result;\n}",
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052cc",
            "calling": [
                "__swbuf_r"
            ],
            "imported": false,
            "current_name": "flush_if_buffer_nonempty_080052cc"
        },
        "FUN_08002eb2": {
            "renaming": {
                "FUN_08002eb2": "transmitData_08002eb2",
                "*huart": "*uart",
                "*pData": "*data",
                "Size": "size",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_BUSY": "HAL_BUSY",
                "NULL": "NULL",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_LOCKED": "HAL_LOCKED",
                "*pTxBuffPtr": "*data",
                "TxXferSize": "size",
                "TxXferCount": "size",
                "ErrorCode": "0",
                "HAL_UART_STATE_BUSY_TX": "HAL_UART_STATE_BUSY_TX",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "Instance": "Instance",
                "CR1": "CR1",
                "|": "|=",
                "0x80": "0x80"
            },
            "code": "HAL_StatusTypeDef transmitData_08002eb2(UART_HandleTypeDef *uart, uint8_t *data, uint16_t size)\n{\n    if (uart->gState != HAL_UART_STATE_READY) {\n        return HAL_BUSY;\n    }\n    if (data == NULL) {\n        return HAL_ERROR;\n    }\n    if (size == 0) {\n        return HAL_ERROR;\n    }\n    if (uart->Lock != HAL_LOCKED) {\n        uart->pTxBuffPtr = data;\n        uart->TxXferSize = size;\n        uart->TxXferCount = size;\n        uart->ErrorCode = 0;\n        uart->gState = HAL_UART_STATE_BUSY_TX;\n        uart->Lock = HAL_UNLOCKED;\n        uart->Instance->CR1 |= 0x80;\n        return HAL_OK;\n    }\n    return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002eb2",
            "calling": [
                "HAL_UART_TxCpltCallback",
                "uart_attach_tx_callback"
            ],
            "imported": false,
            "current_name": "transmitData_08002eb2"
        },
        "FUN_08005478": {
            "renaming": {
                "FUN_08005478": "iterate_over_data_structure_08005478",
                "param_1": "base_address",
                "param_2": "function_pointer",
                "param_3": "arg_3",
                "param_4": "arg_4",
                "piVar3": "current_node",
                "iVar4": "node_data",
                "iVar6": "node_size",
                "uVar5": "result",
                "uVar1": "function_result",
                "iVar2": "node_data_size"
            },
            "code": "uint iterate_over_data_structure_08005478(int base_address, code* function_pointer, undefined4 arg_3, undefined4 arg_4) {\n  uint result = 0;\n  for (int* current_node = (int *)(base_address + 0x48); current_node != (int *)0x0; current_node = (int *)*current_node) {\n    int node_data = current_node[2];\n    int node_size = current_node[1];\n    while (node_size = node_size - 1, -1 < node_size) {\n      if ((1 < *(ushort *)(node_data + 0xc)) && (*(short *)(node_data + 0xe) + 1 != 0)) {\n        uint function_result = (*function_pointer)(base_address, node_data, arg_3, *(short *)(node_data + 0xe) + 1, arg_4);\n        result |= function_result;\n      }\n      node_data += 0x68;\n    }\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005478",
            "calling": [
                "_cleanup_r"
            ],
            "imported": false,
            "current_name": "iterate_over_data_structure_08005478"
        },
        "FUN_08000d3c": {
            "renaming": {
                "FUN_08000d3c": "initialize_system_08000d3c",
                "iVar1": "index",
                "puVar2": "completed_ptr",
                "UNRECOVERED_JUMPTABLE": "UNRECOVERED_JUMPTABLE"
            },
            "code": "void initialize_system_08000d3c(void)\n{\n  int index;\n  undefined4 *completed_ptr = (undefined4 *)PTR_completed_8667_08000d84;\n  undefined4 *dso_handle_ptr = (undefined4 *)PTR___dso_handle_08000d7c;\n  code *UNRECOVERED_JUMPTABLE;\n  for (index = 0; dso_handle_ptr + index < PTR_completed_8667_08000d80; index += 4) {\n    *(undefined4 *)(dso_handle_ptr + index) = *(undefined4 *)(PTR__sidata_08000d78 + index);\n  }\n  for (; completed_ptr < PTR__ebss_08000d88; completed_ptr++) {\n    *completed_ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  UNRECOVERED_JUMPTABLE = (code *)0x8000d72;\n  main();\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}",
            "called": [
                "__libc_init_array",
                "main",
                "SystemInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000d3c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_system_08000d3c"
        },
        "FUN_08003978": {
            "renaming": {
                "FUN_08003978": "configure_serial_port_08003978",
                "obj": "serial_port",
                "pUVar1": "USART1",
                "pUVar2": "USART2",
                "pUVar3": "USART3",
                "pUVar4": "UART4",
                "pUVar5": "UART5",
                "pUVar6": "USART6",
                "pUVar7": "UART7",
                "pUVar8": "UART8",
                "pUVar9": "peripheral_merged",
                "uVar11": "pin_function",
                "GPIO_InitStruct": "GPIO_init",
                "pGVar10": "GPIO_port",
                "tmpreg": "temp_reg_1",
                "tmpreg_1": "temp_reg_2",
                "tmpreg_2": "temp_reg_3",
                "tmpreg_3": "temp_reg_4",
                "tmpreg_4": "temp_reg_5",
                "tmpreg_5": "temp_reg_6",
                "tmpreg_6": "temp_reg_7",
                "tmpreg_7": "temp_reg_8"
            },
            "code": "\nvoid configure_serial_port_08003978(serial_t *serial_port)\n\n{\n  USART_TypeDef *USART1;\n  USART_TypeDef *USART2;\n  USART_TypeDef *USART3;\n  USART_TypeDef *UART4;\n  USART_TypeDef *UART5;\n  USART_TypeDef *USART6;\n  USART_TypeDef *UART7;\n  USART_TypeDef *UART8;\n  void *a;\n  void *b;\n  USART_TypeDef *peripheral_merged;\n  GPIO_TypeDef *GPIO_port;\n  uint32_t pin_function;\n  uint32_t temp_reg_1;\n  uint32_t temp_reg_2;\n  uint32_t temp_reg_3;\n  uint32_t temp_reg_4;\n  uint32_t temp_reg_5;\n  uint32_t temp_reg_6;\n  uint32_t temp_reg_7;\n  uint32_t temp_reg_8;\n  GPIO_InitTypeDef GPIO_init;\n  \n  if (serial_port != (serial_t *)0x0) {\n    a = pinmap_peripheral(serial_port->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08003c58);\n    b = pinmap_peripheral(serial_port->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08003c5c);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_UART_pin_has_08003c84);\n    }\n    else {\n      peripheral_merged = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      serial_port->uart = peripheral_merged;\n      UART8 = DAT_08003c7c;\n      UART7 = DAT_08003c78;\n      USART6 = DAT_08003c74;\n      UART5 = DAT_08003c70;\n      UART4 = DAT_08003c6c;\n      USART3 = DAT_08003c68;\n      USART2 = DAT_08003c64;\n      USART1 = DAT_08003c60;\n      if (peripheral_merged == (USART_TypeDef *)0x0) {\n        iprintf(PTR_s_ERROR__U_S_ART_pins_mismatch_08003c88);\n      }\n      else {\n        if (peripheral_merged == DAT_08003c60) {\n          DAT_08003c60[0xa93].CR2 = DAT_08003c60[0xa93].CR2 | 0x10;\n          USART1[0xa93].CR2 = USART1[0xa93].CR2 & 0xffffffef;\n          USART1[0xa94].CR3 = USART1[0xa94].CR3 | 0x10;\n          serial_port->index = '\\0';\n          serial_port->irq = USART1_IRQn;\n        }\n        else if (peripheral_merged == DAT_08003c64) {\n          DAT_08003c64[0x11dc].CR2 = DAT_08003c64[0x11dc].CR2 | 0x20000;\n          USART2[0x11dc].CR2 = USART2[0x11dc].CR2 & 0xfffdffff;\n          USART2[0x11dd].CR3 = USART2[0x11dd].CR3 | 0x20000;\n          serial_port->index = '\\x01';\n          serial_port->irq = USART2_IRQn;\n        }\n        else if (peripheral_merged == DAT_08003c68) {\n          DAT_08003c68[0x11b8].SR = DAT_08003c68[0x11b8].SR | 0x40000;\n          USART3[0x11b8].SR = USART3[0x11b8].SR & 0xfffbffff;\n          USART3[0x11b9].DR = USART3[0x11b9].DR | 0x40000;\n          serial_port->index = '\\x02';\n          serial_port->irq = USART3_IRQn;\n        }\n        else if (peripheral_merged == DAT_08003c6c) {\n          DAT_08003c6c[0x1193].CR1 = DAT_08003c6c[0x1193].CR1 | 0x80000;\n          UART4[0x1193].CR1 = UART4[0x1193].CR1 & 0xfff7ffff;\n          UART4[0x1194].CR2 = UART4[0x1194].CR2 | 0x80000;\n          serial_port->index = '\\x03';\n          serial_port->irq = UART4_IRQn;\n        }\n        else if (peripheral_merged == DAT_08003c70) {\n          DAT_08003c70[0x116e].GTPR = DAT_08003c70[0x116e].GTPR | 0x100000;\n          UART5[0x116e].GTPR = UART5[0x116e].GTPR & 0xffefffff;\n          UART5[0x1170].SR = UART5[0x1170].SR | 0x100000;\n          serial_port->index = '\\x04';\n          serial_port->irq = UART5_IRQn;\n        }\n        else if (peripheral_merged == DAT_08003c74) {\n          DAT_08003c74[0xa6f].SR = DAT_08003c74[0xa6f].SR | 0x20;\n          USART6[0xa6f].SR = USART6[0xa6f].SR & 0xffffffdf;\n          USART6[0xa70].DR = USART6[0xa70].DR | 0x20;\n          serial_port->index = '\\x05';\n          serial_port->irq = USART6_IRQn;\n        }\n        else if (peripheral_merged == DAT_08003c78) {\n          DAT_08003c78[0x1001].DR = DAT_08003c78[0x1001].DR | 0x40000000;\n          UART7[0x1001].DR = UART7[0x1001].DR & 0xbfffffff;\n          UART7[0x1002].BRR = UART7[0x1002].BRR | 0x40000000;\n          serial_port->index = '\\x06';\n          serial_port->irq = UART7_IRQn;\n        }\n        else if (peripheral_merged == DAT_08003c7c) {\n          DAT_08003c7c[0xfdc].CR2 = DAT_08003c7c[0xfdc].CR2 | 0x80000000;\n          UART8[0xfdc].CR2 = UART8[0xfdc].CR2 & 0x7fffffff;\n          UART8[0xfdd].CR3 = UART8[0xfdd].CR3 | 0x80000000;\n          serial_port->index = '\\a';\n          serial_port->irq = UART8_IRQn;\n        }\n        GPIO_port = set_GPIO_Port_Clock((uint)((int)serial_port->pin_rx << 0x18) >> 0x1c);\n        pin_function = pinmap_function(serial_port->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08003c5c);\n        GPIO_init.Pin = 1 << (serial_port->pin_rx & 0xfU) & 0xffff;\n        GPIO_init.Mode = (pin_function >> 3 & 1) << 4 | pin_function & 7;\n        GPIO_init.Pull = (pin_function << 0x1a) >> 0x1e;\n        GPIO_init.Alternate = (pin_function << 0x11) >> 0x19;\n        GPIO_init.Speed = 3;\n        HAL_GPIO_Init(GPIO_port,&GPIO_init);\n        GPIO_port = set_GPIO_Port_Clock((uint)((int)serial_port->pin_tx << 0x18) >> 0x1c);\n        pin_function = pinmap_function(serial_port->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08003c58);\n        GPIO_init.Pin = 1 << (serial_port->pin_tx & 0xfU) & 0xffff;\n        GPIO_init.Mode = (pin_function >> 3 & 1) << 4 | pin_function & 7;\n        GPIO_init.Pull = (pin_function << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(GPIO_port,&GPIO_init);\n        *(UART_HandleTypeDef **)(PTR_uart_handlers_08003c80 + (uint)serial_port->index * 4) = &serial_port->handle;\n        (serial_port->handle).Instance = serial_port->uart;\n        (serial_port->handle).Init.BaudRate = serial_port->baudrate;\n        (serial_port->handle).Init.WordLength = serial_port->databits;\n        (serial_port->handle).Init.StopBits = serial_port->stopbits;\n        (serial_port->handle).Init.Parity = serial_port->parity;\n        (serial_port->handle).Init.Mode = 0xc;\n        (serial_port->handle).Init.HwFlowCtl = 0;\n        (serial_port->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&serial_port->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init",
                "HAL_UART_Init",
                "pinmap_function",
                "set_GPIO_Port_Clock",
                "pinmap_peripheral",
                "pinmap_merge_peripheral",
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003978",
            "calling": [
                "uart_debug_init",
                "begin"
            ],
            "imported": false,
            "current_name": "configure_serial_port_08003978"
        },
        "FUN_08003854": {
            "renaming": {
                "FUN_08003854": "handle_timer_interrupt_08003854",
                "PTR_timer_handles_08003864": "PTR_timer_handles_08003864",
                "TIM_HandleTypeDef": "TIM_HandleTypeDef",
                "HAL_TIM_IRQHandler": "HAL_TIM_IRQHandler"
            },
            "code": "void handle_timer_interrupt_08003854(void)\n{\n    TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef**)(PTR_timer_handles_08003864 + 0x2c);\n    if (timer_handle != NULL) {\n        HAL_TIM_IRQHandler(timer_handle);\n    }\n    return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003854",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08003854"
        },
        "FUN_0800316c": {
            "renaming": {
                "FUN_0800316c": "clear_pin_from_map_0800316c",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "pin_index",
                "0x18": "PIN_INDEX_SHIFT",
                "0x1c": "PIN_INDEX_MASK",
                "0xfU": "PIN_MASK"
            },
            "code": "void clear_pin_from_map_0800316c(PinName_conflict pin, uint32_t *pin_map) {\n    uint32_t pin_index = (uint32_t)pin >> 28;\n    uint32_t pin_mask = ~(1 << ((uint32_t)pin & 0xf));\n    pin_map[pin_index] &= pin_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800316c",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "clear_pin_from_map_0800316c"
        },
        "FUN_080040d0": {
            "renaming": {
                "FUN_080040d0": "returnError_080040d0",
                "file_UNUSED": "fileDescriptor"
            },
            "code": "int returnError_080040d0(int fileDescriptor) {\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040d0",
            "calling": [
                "_close_r"
            ],
            "imported": false,
            "current_name": "returnError_080040d0"
        },
        "FUN_0800401c": {
            "renaming": {
                "FUN_0800401c": "handle_UART4_interrupt_0800401c",
                "PTR_uart_handlers_08004030": "uart_handlers_ptr"
            },
            "code": "void handle_UART4_interrupt_0800401c(void)\n{\n  HAL_NVIC_ClearPendingIRQ(UART4_IRQn);\n  UART_HandleTypeDef *uart4_handle_ptr = *(UART_HandleTypeDef **)(PTR_uart_handlers_08004030 + 0xc);\n  HAL_UART_IRQHandler(uart4_handle_ptr);\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800401c",
            "calling": [],
            "imported": false,
            "current_name": "handle_UART4_interrupt_0800401c"
        },
        "FUN_080040d6": {
            "renaming": {
                "FUN_080040d6": "set_file_mode_to_directory_080040d6",
                "file_UNUSED": "",
                "st": "file_stats"
            },
            "code": "int set_file_mode_to_directory_080040d6(stat *file_stats)\n{\n  file_stats->st_mode = 0x2000;\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040d6",
            "calling": [
                "_fstat_r"
            ],
            "imported": false,
            "current_name": "set_file_mode_to_directory_080040d6"
        },
        "FUN_08004a34": {
            "renaming": {
                "FUN_08004a34": "write_byte_to_stream_08004a34",
                "param_1": "stream",
                "param_2": "byte",
                "param_3": "buffer",
                "uVar1": "result",
                "pbVar2": "last_char",
                "next_char": "next_char"
            },
            "code": "unsigned int write_byte_to_stream_08004a34(unsigned int stream, char byte, char **buffer) {\n  unsigned int result;\n  char *last_char = buffer[2] - 1;\n  buffer[2] = last_char;\n  if (((int)last_char < 0) && (((int)last_char < (int)buffer[6] || (byte == 10)))) {\n    result = __swbuf_r();\n    return result;\n  }\n  char *next_char = *buffer;\n  *buffer = next_char + 1;\n  *next_char = byte;\n  return (unsigned int)byte;\n}",
            "called": [
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a34",
            "calling": [
                "__sfputs_r"
            ],
            "imported": false,
            "current_name": "write_byte_to_stream_08004a34"
        },
        "FUN_080002d0": {
            "renaming": {
                "FUN_080002d0": "divide_numbers_080002d0",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "quotient",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void divide_numbers_080002d0(int dividend, int divisor, int remainder, int quotient) {\n  if ((quotient == 0) && (remainder == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      divisor = -1;\n      dividend = -1;\n    }\n    __aeabi_idiv0(dividend, divisor);\n    return;\n  }\n  __udivmoddi4();\n  return;\n}",
            "called": [
                "__udivmoddi4",
                "__aeabi_idiv0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002d0",
            "calling": [
                "HAL_RCC_GetSysClockFreq"
            ],
            "imported": false,
            "current_name": "divide_numbers_080002d0"
        },
        "FUN_08003f00": {
            "renaming": {
                "FUN_08003f00": "get_uart_handler_index_08003f00",
                "huart": "uart_handler",
                "uVar1": "index",
                "PTR_uart_handlers_08003f20": "uart_handlers_array"
            },
            "code": "uint8_t get_uart_handler_index_08003f00(UART_HandleTypeDef *huart)\n{\n  uint8_t index = 0;\n  if (huart == NULL) {\n    index = 10;\n  }\n  else {\n    while(index < 10) {\n      if (huart == *(UART_HandleTypeDef **)(PTR_uart_handlers_08003f20 + index * 4)) {\n        break;\n      }\n      index++;\n    }\n  }\n  return index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f00",
            "calling": [
                "HAL_UART_RxCpltCallback",
                "HAL_UART_TxCpltCallback"
            ],
            "imported": false,
            "current_name": "get_uart_handler_index_08003f00"
        },
        "FUN_08004270": {
            "renaming": {
                "FUN_08004270": "readSerialBuffer_08004270",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "bufferSize",
                "bVar1": "currentByte",
                "uVar2": "tailIndex",
                "this": "serialInstance"
            },
            "code": "ssize_t __thiscall HardwareSerial::readSerialBuffer_08004270(HardwareSerial *serialInstance,int fileDescriptor,void *buffer,size_t bufferSize) {\n  byte currentByte;\n  ushort tailIndex;\n  \n  tailIndex = (serialInstance->_serial).rx_tail;\n  if ((uint)(serialInstance->_serial).rx_head != (uint)tailIndex) {\n    currentByte = (serialInstance->_serial).rx_buff[tailIndex];\n    (serialInstance->_serial).rx_tail = tailIndex + 1 & 0x3f;\n    return (uint)currentByte;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004270",
            "calling": [],
            "imported": false,
            "current_name": "readSerialBuffer_08004270"
        },
        "FUN_08005a04": {
            "renaming": {
                "FUN_08005a04": "do_nothing_08005a04"
            },
            "code": "\nvoid do_nothing_08005a04(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a04",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08005a04"
        },
        "FUN_080037e8": {
            "renaming": {
                "FUN_080037e8": "handle_timer_interrupt_080037e8",
                "PTR_timer_handles_080037f8": "PTR_timer_handles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt_request",
                "timer_handle": "timer_handle"
            },
            "code": "void handle_timer_interrupt_080037e8(void)\n{\n    TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef**)(PTR_timer_handles_080037f8_080037f8 + 0x14);\n    if (timer_handle != NULL) {\n        HAL_TIM_IRQHandler(timer_handle);\n    }\n    return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080037e8",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_080037e8"
        },
        "FUN_08001440": {
            "renaming": {
                "FUN_08001440": "receive_byte_08001440",
                "*hi2c": "*i2c_handle",
                "puVar1": "buffer_ptr",
                "hi2c->pBuffPtr": "i2c_handle->pBuffPtr",
                "hi2c->Instance->DR": "i2c_handle->Instance->DR",
                "hi2c->XferCount": "i2c_handle->XferCount"
            },
            "code": "HAL_StatusTypeDef receive_byte_08001440(I2C_HandleTypeDef *i2c_handle)\n{\n  uint8_t *buffer_ptr;\n  if (i2c_handle->XferCount != 0) {\n    buffer_ptr = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = buffer_ptr + 1;\n    *buffer_ptr = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->XferCount--;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001440",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_byte_08001440"
        },
        "FUN_08000230": {
            "renaming": {
                "FUN_08000230": "find_first_occurrence_08000230",
                "__s": "buffer",
                "__c": "value",
                "__n": "size",
                "bVar1": "byte_value",
                "cVar2": "char_0",
                "cVar3": "char_1",
                "cVar4": "char_2",
                "cVar5": "char_3",
                "pbVar6": "byte_pointer_1",
                "puVar7": "uint_pointer",
                "pbVar8": "byte_pointer_2",
                "uVar9": "byte_value_mask",
                "uVar10": "alignment_mask",
                "uVar11": "aligned_size",
                "uVar12": "compare_result_1",
                "uVar13": "compare_result_2",
                "bVar14": "compare_bit_0",
                "bVar15": "compare_bit_1",
                "bVar16": "compare_bit_2",
                "bVar17": "compare_bit_3"
            },
            "code": "void * find_first_occurrence_08000230(void * buffer, int value, size_t size)\n{\n    uint8_t * byte_buffer = (uint8_t *) buffer;\n    uint8_t byte_value = (uint8_t) value;\n\n    if ((int) size < 16)\n    {\n        while (size-- > 0)\n        {\n            if (*byte_buffer == byte_value)\n                return byte_buffer;\n            byte_buffer++;\n        }\n        return NULL;\n    }\n    else\n    {\n        uint32_t value_32 = (uint32_t) byte_value;\n        value_32 |= value_32 << 8;\n        value_32 |= value_32 << 16;\n\n        uint8_t * aligned_buffer = byte_buffer;\n        uint8_t * end_aligned_buffer = byte_buffer + (size & ~7);\n\n        while ((uintptr_t) aligned_buffer & 7)\n        {\n            if (*aligned_buffer == byte_value)\n                return aligned_buffer;\n            aligned_buffer++;\n        }\n\n        while (aligned_buffer < end_aligned_buffer)\n        {\n            uint32_t * aligned_buffer_32 = (uint32_t *) aligned_buffer;\n            uint32_t value_32_1 = *aligned_buffer_32 ^ value_32;\n            uint32_t value_32_2 = *(aligned_buffer_32 + 1) ^ value_32;\n            if (value_32_1 | value_32_2)\n            {\n                uint8_t * byte_buffer_1 = aligned_buffer + 1;\n                if (value_32_1 == 0)\n                    byte_buffer_1 = aligned_buffer + 5;\n                else if ((value_32_1 & 0xff) == 0)\n                    byte_buffer_1 = aligned_buffer + 2;\n                else if ((value_32_1 & 0xffff) == 0)\n                    byte_buffer_1 = aligned_buffer + 3;\n                else if ((value_32_1 & 0xffffff) == 0)\n                    byte_buffer_1 = aligned_buffer + 4;\n                return byte_buffer_1 - 1;\n            }\n            aligned_buffer += 4;\n        }\n\n        size &= 7;\n        while (size-- > 0)\n        {\n            if (*aligned_buffer == byte_value)\n                return aligned_buffer;\n            aligned_buffer++;\n        }\n        return NULL;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000230",
            "calling": [
                "_vfiprintf_r",
                "_printf_i"
            ],
            "imported": false,
            "current_name": "find_first_occurrence_08000230"
        },
        "FUN_080051bc": {
            "renaming": {
                "FUN_080051bc": "decode_080051bc",
                "param_1": "input_buffer",
                "param_2": "decode_params",
                "iVar1": "num_bytes_read",
                "piVar2": "decode_vars",
                "uVar3": "decode_flags",
                "uVar4": "decode_flag_bits",
                "iVar5": "num_bytes_processed",
                "pcVar6": "decode_func",
                "iVar7": "num_bytes_processed_copy",
                "uVar8": "input_buffer_copy",
                "bVar9": "is_decode_flag_set"
            },
            "code": "undefined4 decode_080051bc(uint *input_buffer, int *decode_080051bc_params)\n{\n  int num_bytes_read;\n  int *decode_080051bc_vars;\n  uint decode_080051bc_flags;\n  ushort decode_080051bc_flag_bits;\n  code *decode_080051bc_func;\n  int num_bytes_processed;\n  uint input_buffer_copy;\n  bool is_decode_080051bc_flag_set;\n\n  decode_080051bc_flag_bits = *(ushort *)(decode_080051bc_params + 3);\n  decode_080051bc_flags = (uint)decode_080051bc_flag_bits;\n  if ((int)(decode_080051bc_flags << 0x1c) < 0) {\n    decode_080051bc_vars = decode_080051bc_params + 4;\n    if (*decode_080051bc_vars != 0) {\n      num_bytes_processed = decode_080051bc_flags << 0x1e;\n      is_decode_080051bc_flag_set = num_bytes_processed == 0;\n      num_bytes_read = *decode_080051bc_params;\n      if (is_decode_080051bc_flag_set) {\n        num_bytes_processed = decode_080051bc_params[5];\n      }\n      *decode_080051bc_params = *decode_080051bc_vars;\n      if (!is_decode_080051bc_flag_set) {\n        num_bytes_processed = 0;\n      }\n      decode_080051bc_params[2] = num_bytes_processed;\n      for (num_bytes_read = num_bytes_read - *decode_080051bc_vars; num_bytes_read > 0; num_bytes_read = num_bytes_read - num_bytes_processed) {\n        num_bytes_processed = (*(code *)decode_080051bc_params[10])(input_buffer, decode_080051bc_params[8], *decode_080051bc_vars, num_bytes_read);\n        if (num_bytes_processed < 1) {\n          decode_080051bc_flag_bits = *(ushort *)(decode_080051bc_params + 3);\n          goto LAB_080052b2;\n        }\n        *decode_080051bc_vars = *decode_080051bc_vars + num_bytes_processed;\n      }\n    }\n  }\n  else if (((decode_080051bc_params[1] > 0) || (decode_080051bc_params[0x10] > 0)) &&\n          ((decode_080051bc_func = (code *)decode_080051bc_params[0xb]) != (code *)0x0)) {\n    input_buffer_copy = *input_buffer;\n    *input_buffer = 0;\n    if ((decode_080051bc_flag_bits & 0x1000) == 0) {\n      num_bytes_processed = (*decode_080051bc_func)(input_buffer, decode_080051bc_params[8], decode_080051bc_flags & 0x1000, 1);\n      if ((num_bytes_processed == -1) && ((input_buffer_copy = *input_buffer) != 0)) {\n        if ((input_buffer_copy != 0x1d) && (input_buffer_copy != 0x16)) {\n          *(ushort *)(decode_080051bc_params + 3) = *(ushort *)(decode_080051bc_params + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *input_buffer = input_buffer_copy;\n        return 0;\n      }\n    }\n    else {\n      num_bytes_processed = decode_080051bc_params[0x15];\n    }\n    if (((int)((uint)decode_080051bc_flag_bits << 0x1d) < 0) &&\n       ((num_bytes_processed = num_bytes_processed - decode_080051bc_params[1]) && (decode_080051bc_params[0xd] != 0))) {\n      num_bytes_processed = num_bytes_processed - decode_080051bc_params[0x10];\n    }\n    num_bytes_processed = (*(code *)decode_080051bc_params[0xb])(input_buffer, decode_080051bc_params[8], num_bytes_processed, 0);\n    decode_080051bc_flag_bits = *(ushort *)(decode_080051bc_params + 3);\n    if ((num_bytes_processed == -1) &&\n       ((0x1d < *input_buffer || (-1 < (int)((DAT_080052c8 >> (*input_buffer & 0xff)) << 0x1f)))) {\n      *(ushort *)(decode_080051bc_params + 3) = decode_080051bc_flag_bits | 0x40;\n      return 0xffffffff;\n    }\n    decode_080051bc_params[1] = 0;\n    *decode_080051bc_params = decode_080051bc_params[4];\n    if (((int)((uint)decode_080051bc_flag_bits << 0x13) < 0) && ((num_bytes_processed != -1 || (*input_buffer == 0)))) {\n      decode_080051bc_params[0x15] = num_bytes_processed;\n    }\n    decode_080051bc_vars = (int *)decode_080051bc_params[0xd];\n    *input_buffer = input_buffer_copy;\n    if (decode_080051bc_vars != (int *)0x0) {\n      if (decode_080051bc_vars != decode_080051bc_params + 0x11) {\n        _free_r(input_buffer);\n      }\n      decode_080051bc_params[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080051bc",
            "calling": [
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "decode_080051bc"
        },
        "FUN_08004034": {
            "renaming": {
                "FUN_08004034": "handle_UART5_interrupt_08004034",
                "UART5_IRQn": "UART5_Interrupt",
                "PTR_uart_handlers_08004048": "uart_handlers_ptr",
                "uart_handler": "current_uart_handler"
            },
            "code": "void handle_UART5_interrupt_08004034(void)\n{\n    HAL_NVIC_ClearPendingIRQ(UART5_IRQn);\n    UART_HandleTypeDef* uart_handler = *(UART_HandleTypeDef**)(PTR_uart_handlers_08004048 + 0x10);\n    HAL_UART_IRQHandler(uart_handler);\n    return;\n}",
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004034",
            "calling": [],
            "imported": false,
            "current_name": "handle_UART5_interrupt_08004034"
        },
        "FUN_08000f8c": {
            "renaming": {
                "FUN_08000f8c": "abort_dma_transfer_08000f8c",
                "hdma": "dma_handle",
                "hdma->State": "dma_handle->State",
                "hdma->ErrorCode": "dma_handle->ErrorCode",
                "hdma->Instance->CR": "dma_handle->Instance->CR",
                "HAL_DMA_STATE_BUSY": "HAL_DMA_STATE_BUSY",
                "HAL_DMA_STATE_ABORT": "HAL_DMA_STATE_ABORT",
                "0x80": "0x80",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef abort_dma_transfer_08000f8c(DMA_HandleTypeDef *dma_handle)\n{\n  if (dma_handle->State != HAL_DMA_STATE_BUSY) {\n    dma_handle->ErrorCode = 0x80;\n    return HAL_ERROR;\n  }\n  dma_handle->State = HAL_DMA_STATE_ABORT;\n  dma_handle->Instance->CR = dma_handle->Instance->CR & ~(1);\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f8c",
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "abort_dma_transfer_08000f8c"
        },
        "FUN_08001684": {
            "renaming": {
                "FUN_08001684": "resetI2C_08001684",
                "*hi2c": "*i2c",
                "hi2c->XferOptions": "i2c->transferOptions",
                "hi2c->State": "i2c->state",
                "hi2c->Instance": "i2c->instance",
                "hi2c->PreviousState": "i2c->previousState",
                "hi2c->Mode": "i2c->mode",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "DAT_08001714": "DAT_08001714",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "HAL_I2C_ListenCpltCallback": "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveTxCpltCallback": "HAL_I2C_SlaveTxCpltCallback"
            },
            "code": "HAL_StatusTypeDef resetI2C_08001684(I2C_HandleTypeDef *i2c)\n{\n    if (((i2c->transferOptions == 4) || (i2c->transferOptions == 8)) &&\n         (i2c->state == HAL_I2C_STATE_LISTEN)) {\n        i2c->transferOptions = DAT_08001714;\n        i2c->instance->CR2 = i2c->instance->CR2 & 0xfffff8ff;\n        i2c->instance->SR1 = 0xfffffbff;\n        i2c->instance->CR1 = i2c->instance->CR1 & 0xfffffbff;\n        i2c->previousState = 0;\n        i2c->state = HAL_I2C_STATE_READY;\n        i2c->mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_ListenCpltCallback(i2c);\n    }\n    else if (i2c->state == HAL_I2C_STATE_BUSY_TX) {\n        i2c->transferOptions = DAT_08001714;\n        i2c->previousState = 0x21;\n        i2c->state = HAL_I2C_STATE_READY;\n        i2c->mode = HAL_I2C_MODE_NONE;\n        i2c->instance->CR2 = i2c->instance->CR2 & 0xfffff8ff;\n        i2c->instance->SR1 = 0xfffffbff;\n        i2c->instance->CR1 = i2c->instance->CR1 & 0xfffffbff;\n        HAL_I2C_SlaveTxCpltCallback(i2c);\n    }\n    else {\n        i2c->instance->SR1 = 0xfffffbff;\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001684",
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "resetI2C_08001684"
        },
        "FUN_080001ac": {
            "renaming": {
                "FUN_080001ac": "checkInitializationStatus_080001ac",
                "*param_1": "*initializedPtr",
                "*PTR_completed_8667_080001c4": "*completedFlagPtr",
                "DAT_080001c8": "initializationValue",
                "PTR__init_080001cc": "initializationPtr"
            },
            "code": "undefined * checkInitializationStatus_080001ac(undefined *initializedPtr)\\n{\\n  if (*PTR_completed_8667_080001c4 == \"\\0\") {\\n    if (DAT_080001c8 != 0) {\\n      initializedPtr = PTR__init_080001cc;\\n    }\\n    *PTR_completed_8667_080001c4 = 1;\\n  }\\n  return initializedPtr;\\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001ac",
            "calling": [],
            "imported": false,
            "current_name": "checkInitializationStatus_080001ac"
        },
        "FUN_080040e0": {
            "renaming": {
                "FUN_080040e0": "count_unused_files_080040e0",
                "file_UNUSED": "file_unused"
            },
            "code": "int count_unused_files_080040e0(int file_unused)\n{\n    return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040e0",
            "calling": [
                "_isatty_r"
            ],
            "imported": false,
            "current_name": "count_unused_files_080040e0"
        },
        "FUN_08003868": {
            "renaming": {
                "FUN_08003868": "handle_timer_interrupt_08003868",
                "PTR_timer_handles_08003878": "PTR_timer_handles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "HandleTimerIRQ"
            },
            "code": "void handle_timer_interrupt_08003868(void)\n{\n  TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef **)(PTR_timer_handles_08003878_08003878 + 0x34);\n  if (timer_handle != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003868",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08003868"
        },
        "FUN_080048cc": {
            "renaming": {
                "FUN_080048cc": "memset_080048cc",
                "__s": "ptr",
                "__c": "value",
                "__n": "num",
                "puVar1": "p"
            },
            "code": "void * memset_080048cc(void * ptr, int value, size_t num) {\n  unsigned char *p = (unsigned char *)ptr;\n  for (size_t i = 0; i < num; i++) {\n    p[i] = (unsigned char)value;\n  }\n  return ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080048cc",
            "calling": [
                "std.isra.0",
                "__sfmoreglue",
                "__sfp"
            ],
            "imported": false,
            "current_name": "memset_080048cc"
        },
        "FUN_080040e4": {
            "renaming": {
                "FUN_080040e4": "calculate_file_size_080040e4",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "pointer",
                "dir_UNUSED": "directory"
            },
            "code": "int calculate_file_size_080040e4(int file_descriptor, int pointer, int directory){\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040e4",
            "calling": [
                "_lseek_r"
            ],
            "imported": false,
            "current_name": "calculate_file_size_080040e4"
        },
        "FUN_08003506": {
            "renaming": {
                "FUN_08003506": "find_pin_name_08003506",
                "peripheral": "peripheral_address",
                "map": "pin_map",
                "PinName_conflict": "PinName_conflict",
                "PinMap_conflict": "PinMap_conflict",
                "NC": "NC"
            },
            "code": "PinName_conflict find_pin_name_08003506(void *peripheral, PinMap_conflict *map) {\n    while (true) {\n        if (map->peripheral == (void *)0x0) {\n            return NC;\n        }\n        if (map->peripheral == peripheral) {\n            break;\n        }\n        map = map + 1;\n    }\n    return map->pin;\n}",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003506",
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "imported": false,
            "current_name": "find_pin_name_08003506"
        },
        "FUN_080025e0": {
            "renaming": {
                "FUN_080025e0": "getSystemCoreClockValue_080025e0",
                "*PTR_SystemCoreClock_080025e8": "systemCoreClockPtr"
            },
            "code": "uint32_t getSystemCoreClockValue_080025e0(void)\n{\n  uint32_t* *PTR_SystemCoreClock_080025e8 = (uint32_t*)PTR_SystemCoreClock_080025e8;\n  return **PTR_SystemCoreClock_080025e8;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025e0",
            "calling": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "getSystemCoreClockValue_080025e0"
        },
        "FUN_080040e8": {
            "renaming": {
                "FUN_080040e8": "count_lines_080040e8",
                "file_UNUSED": "file",
                "ptr_UNUSED": "buffer",
                "len_UNUSED": "buffer_length"
            },
            "code": "int count_lines_080040e8(int file, char *buffer, int buffer_length)\n{\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040e8",
            "calling": [
                "_read_r"
            ],
            "imported": false,
            "current_name": "count_lines_080040e8"
        },
        "FUN_08000a00": {
            "renaming": {
                "FUN_08000a00": "set_register_value_08000a00",
                "this": "modbus_obj",
                "regs": "regs",
                "u8size": "num_regs",
                "uVar1": "word_value",
                "uVar2": "bit_index",
                "uVar3": "register_index"
            },
            "code": "int8_t __thiscall Modbus::set_register_value_08000a00(Modbus *modbus_obj, uint16_t *regs, uint8_t num_regs)\n{\n    uint16_t word_value;\n    uint register_index;\n    uint bit_index;\n    \n    word_value = makeWord(modbus_obj->au8Buffer[2], modbus_obj->au8Buffer[3]);\n    register_index = ((uint)word_value << 20) >> 24;\n    bit_index = word_value & 0x0F;\n    \n    if (modbus_obj->au8Buffer[4] == 0xFF) {\n        regs[register_index] = (ushort)(1 << bit_index) | regs[register_index];\n    }\n    else {\n        regs[register_index] = regs[register_index] & ~(ushort)(1 << bit_index);\n    }\n    \n    modbus_obj->u8BufferSize = 6;\n    sendTxBuffer(modbus_obj);\n    \n    return 8;\n}",
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a00",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "set_register_value_08000a00"
        },
        "FUN_080047c0": {
            "renaming": {
                "__thiscall std::function<void()>::operator__": "functionWrapper::execute",
                "this": "wrapper",
                "function_void___": "funcBase",
                "super__Function_base": "funcBase",
                "_M_manager": "_manager",
                "_M_invoker": "invoker",
                "_Any_data": "data",
                "__throw_bad_function_call": "throwBadFunctionCall",
                "FUN_080047c0": "execute_080047c0"
            },
            "code": "void __thiscall functionWrapper::execute_080047c0(function_void___ *wrapper)\n{\n    if ((wrapper->funcBase)._M_manager != (_Manager_type)0x0) {\n        (*wrapper->invoker)((_Any_data *)wrapper);\n        return;\n    }\n    __throw_bad_function_call();\n}",
            "called": [
                "__throw_bad_function_call"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047c0",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "execute_080047c0"
        },
        "FUN_08005374": {
            "renaming": {
                "FUN_08005374": "_malloc_r_08005374",
                "param_1": "size",
                "param_2": "count",
                "puVar1": "result",
                "iVar2": "total_size"
            },
            "code": "_malloc_r_08005374 _malloc_r_08005374(int size, int count)\n{\n  int total_size = (count - 1) * 0x68;\n  undefined4 *result = (undefined4 *)_malloc_r_08005374(size, total_size + 0x74);\n  if (result != NULL)\n  {\n    *result = 0;\n    result[1] = count;\n    result[2] = result + 3;\n    memset(result + 3, 0, total_size + 0x68);\n  }\n  return result;\n}",
            "called": [
                "memset",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005374",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "_malloc_r_08005374"
        },
        "FUN_08004d9c": {
            "renaming": {
                "FUN_08004d9c": "print_formatted_output_08004d9c",
                "param_1": "stream",
                "param_2": "format",
                "param_3": "width",
                "param_4": "print_function",
                "param_5": "args",
                "bVar1": "format_char",
                "iVar2": "return_value",
                "puVar3": "arg_ptr",
                "pvVar4": "null_terminator_ptr",
                "iVar5": "print_result",
                "puVar6": "hex_chars",
                "uVar7": "format_flags",
                "uVar9": "arg_value",
                "uVar10": "dividend",
                "puVar11": "char_ptr",
                "__s": "format_str",
                "local_24": "width_values"
            },
            "code": "\nuint print_formatted_output_08004d9c(undefined4 stream,uint *format,undefined4 width,code *print_function,uint **args)\n\n{\n  byte format_char;\n  int return_value;\n  uint *arg_ptr;\n  void *null_terminator_ptr;\n  int print_result;\n  undefined *hex_chars;\n  uint format_flags;\n  uint **ppuVar8;\n  uint arg_value;\n  uint dividend;\n  undefined *char_ptr;\n  undefined *format_str;\n  uint width_values [2];\n  \n  format_char = *(byte *)(format + 6);\n  format_str = (undefined *)((int)format + 0x43);\n  if (format_char != 0x6e) {\n    if (format_char < 0x6f) {\n      if (format_char != 99) {\n        if (format_char < 100) {\n          if (format_char == 0) goto LAB_08004f56;\n          if (format_char != 0x58) goto LAB_08004dcc;\n          *(undefined *)((int)format + 0x45) = 0x58;\n          hex_chars = PTR_s_0123456789ABCDEF_08004fd8;\nLAB_08004ee6:\n          format_flags = *format;\n          arg_ptr = *args;\n          *args = arg_ptr + 1;\n          if (((format_flags & 0x80) == 0) && ((int)(format_flags << 0x19) < 0)) {\n            arg_value = (uint)*(ushort *)arg_ptr;\n          }\n          else {\n            arg_value = *arg_ptr;\n          }\n          if ((int)(format_flags << 0x1f) < 0) {\n            *format = format_flags | 0x20;\n          }\n          if (arg_value == 0) {\n            *format = *format & 0xffffffdf;\n          }\n          format_flags = 0x10;\nLAB_08004e7c:\n          *(undefined *)((int)format + 0x43) = 0;\n        }\n        else {\n          if ((format_char != 100) && (format_char != 0x69)) goto LAB_08004dcc;\n          arg_value = *format;\n          arg_ptr = *args;\n          if ((arg_value & 0x80) == 0) {\n            *args = arg_ptr + 1;\n            if ((arg_value & 0x40) == 0) goto LAB_08004dec;\n            arg_value = (uint)(short)*(ushort *)arg_ptr;\n          }\n          else {\n            *args = arg_ptr + 1;\nLAB_08004dec:\n            arg_value = *arg_ptr;\n          }\n          if ((int)arg_value < 0) {\n            arg_value = -arg_value;\n            *(undefined *)((int)format + 0x43) = 0x2d;\n          }\n          format_flags = 10;\n          hex_chars = PTR_s_0123456789ABCDEF_08004fd8;\n        }\n        dividend = format[1];\n        format[2] = dividend;\n        char_ptr = format_str;\n        if ((int)dividend < 0) {\n          if (arg_value != 0) goto LAB_08004f1a;\nLAB_08004fc8:\n          *(undefined *)((int)format + 0x42) = *hex_chars;\n          char_ptr = (undefined *)((int)format + 0x42);\n        }\n        else {\n          *format = *format & 0xfffffffb;\n          if (arg_value == 0) {\n            if (dividend != 0) goto LAB_08004fc8;\n          }\n          else {\nLAB_08004f1a:\n            do {\n              dividend = arg_value / format_flags;\n              char_ptr = char_ptr + -1;\n              *char_ptr = hex_chars[arg_value - format_flags * dividend];\n              arg_value = dividend;\n            } while (dividend != 0);\n          }\n        }\n        if (((format_flags == 8) && ((int)(*format << 0x1f) < 0)) && ((int)format[1] <= (int)format[4]))\n        {\n          char_ptr[-1] = 0x30;\n          char_ptr = char_ptr + -1;\n        }\n        format[4] = (int)format_str - (int)char_ptr;\n        format_str = char_ptr;\n        goto LAB_08004ec2;\n      }\n      arg_ptr = *args;\n      *args = arg_ptr + 1;\n      *(char *)((int)format + 0x42) = (char)*arg_ptr;\nLAB_08004e2c:\n      format_str = (undefined *)((int)format + 0x42);\n      arg_value = 1;\n    }\n    else {\n      if (format_char != 0x73) {\n        if (format_char < 0x74) {\n          if (format_char == 0x6f) {\nLAB_08004e52:\n            arg_value = *format;\n            arg_ptr = *args;\n            if ((arg_value & 0x80) == 0) {\n              *args = arg_ptr + 1;\n              if ((arg_value & 0x40) == 0) goto LAB_08004e60;\n              arg_value = (uint)*(ushort *)arg_ptr;\n            }\n            else {\n              *args = arg_ptr + 1;\nLAB_08004e60:\n              arg_value = *arg_ptr;\n            }\n            hex_chars = PTR_s_0123456789ABCDEF_08004fd8;\n            if (format_char == 0x6f) {\n              format_flags = 8;\n            }\n            else {\n              format_flags = 10;\n            }\n            goto LAB_08004e7c;\n          }\n          if (format_char == 0x70) {\n            *format = *format | 0x20;\nLAB_08004e12:\n            *(undefined *)((int)format + 0x45) = 0x78;\n            hex_chars = PTR_s_0123456789abcdef_08004fd4;\n            goto LAB_08004ee6;\n          }\n        }\n        else {\n          if (format_char == 0x75) goto LAB_08004e52;\n          if (format_char == 0x78) goto LAB_08004e12;\n        }\nLAB_08004dcc:\n        *(byte *)((int)format + 0x42) = format_char;\n        goto LAB_08004e2c;\n      }\n      arg_ptr = *args;\n      *args = arg_ptr + 1;\n      format_str = (undefined *)*arg_ptr;\n      null_terminator_ptr = memchr(format_str,0,format[1]);\n      if (null_terminator_ptr != (void *)0x0) {\n        format[1] = (int)null_terminator_ptr - (int)format_str;\n      }\n      arg_value = format[1];\n    }\n    format[4] = arg_value;\n    *(undefined *)((int)format + 0x43) = 0;\n    goto LAB_08004ec2;\n  }\n  arg_value = *format;\n  ppuVar8 = (uint **)*args;\n  format_flags = format[5];\n  if ((arg_value & 0x80) == 0) {\n    *args = (uint *)(ppuVar8 + 1);\n    arg_ptr = *ppuVar8;\n    if ((arg_value & 0x40) == 0) goto LAB_08004f42;\n    *(short *)arg_ptr = (short)format_flags;\n  }\n  else {\n    *args = (uint *)(ppuVar8 + 1);\n    arg_ptr = *ppuVar8;\nLAB_08004f42:\n    *arg_ptr = format_flags;\n  }\nLAB_08004f56:\n  format[4] = 0;\nLAB_08004ec2:\n  return_value = _printf_common(stream,format,width_values,width,print_function);\n  if ((return_value == -1) || (return_value = (*print_function)(stream,width,format_str,format[4]), return_value == -1)) {\nLAB_08004ed6:\n    arg_value = 0xffffffff;\n  }\n  else {\n    if ((int)(*format << 0x1e) < 0) {\n      for (return_value = 0; return_value < (int)(format[3] - width_values[0]); return_value = return_value + 1) {\n        print_result = (*print_function)(stream,width,(int)format + 0x19,1);\n        if (print_result == -1) goto LAB_08004ed6;\n      }\n    }\n    arg_value = format[3];\n    if ((int)format[3] < (int)width_values[0]) {\n      arg_value = width_values[0];\n    }\n  }\n  return arg_value;\n}\n\n",
            "called": [
                "memchr",
                "_printf_common"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d9c",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "print_formatted_output_08004d9c"
        },
        "FUN_08003750": {
            "renaming": {
                "FUN_08003750": "get_stimer_from_timer_handle_08003750",
                "htim": "timer_handle",
                "stimer_t": "stimer",
                ".Lock": "lock",
                "[-1]": "offset = -1"
            },
            "code": "stimer_t* get_stimer_from_timer_handle_08003750(TIM_HandleTypeDef* timer_handle) {\n    int offset = -1;\n    return (stimer_t*)&timer_handle[offset].Lock;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003750",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "imported": false,
            "current_name": "get_stimer_from_timer_handle_08003750"
        },
        "FUN_080014ec": {
            "renaming": {
                "FUN_080014ec": "listen_mode_handler_080014ec",
                "hi2c": "i2c_handle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transfer_options",
                "HVar1": "status",
                "pIVar2": "i2c_instance",
                "tmpreg": "tmp_reg"
            },
            "code": "HAL_StatusTypeDef listen_mode_handler_080014ec(I2C_HandleTypeDef *i2c_handle, uint8_t *data, uint16_t size, uint32_t transfer_options) {\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *i2c_instance;\n  uint32_t tmp_reg;\n  \n  if (i2c_handle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == NULL || size == 0 || i2c_handle->Lock == HAL_LOCKED) {\n      status = HAL_ERROR;\n    }\n    else {\n      i2c_handle->Lock = HAL_LOCKED;\n      i2c_instance = i2c_handle->Instance;\n      if ((i2c_instance->CR1 & 1) == 0) {\n        i2c_instance->CR1 |= 1;\n      }\n      i2c_handle->Instance->CR1 &= 0xfffff7ff;\n      i2c_handle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2c_handle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2c_handle->ErrorCode = 0;\n      i2c_handle->pBuffPtr = data;\n      i2c_handle->XferCount = size;\n      i2c_handle->XferOptions = transfer_options;\n      i2c_handle->XferSize = i2c_handle->XferCount;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      i2c_handle->Instance->CR2 |= 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080014ec",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "listen_mode_handler_080014ec"
        },
        "FUN_080048dc": {
            "renaming": {
                "FUN_080048dc": "allocate_memory_block_and_add_to_free_list_080048dc",
                "param_1": "error_code",
                "param_2": "block_size",
                "param_3": "param_3",
                "param_4": "param_4",
                "puVar1": "free_list_lock_ptr",
                "piVar2": "extra_block_ptr",
                "extraout_r1": "prev_block_ptr",
                "ppiVar3": "prev_block_ptr_ptr",
                "ppiVar4": "prev_free_list_ptr_ptr",
                "ppiVar5": "next_block_ptr_ptr",
                "ppiVar6": "current_block_ptr_ptr",
                "ppiVar7": "free_list_ptr_ptr",
                "bVar8": "is_current_block_in_free_list"
            },
            "code": "void allocate_memory_block_and_add_to_free_list_080048dc(undefined4 *error_code, int block_size, undefined4 param_3, undefined4 param_4)\n{\n  // Define variables with descriptive names\n  int **free_list_ptr;\n  int **prev_free_list_ptr;\n  int **current_block_ptr;\n  int **prev_block_ptr;\n  int **next_block_ptr;\n  bool is_current_block_in_free_list;\n\n  // Check if block_size is zero\n  if (block_size == 0) {\n    return;\n  }\n\n  // Calculate the block pointer\n  current_block_ptr = (int **)(block_size + -4);\n  if (*(int *)(block_size + -4) < 0) {\n    current_block_ptr = (int **)((int)current_block_ptr + *(int *)(block_size + -4));\n  }\n\n  // Acquire the lock for the free list\n  __malloc_lock();\n\n  // Get the current free list pointer\n  free_list_ptr = *(int ***)PTR___malloc_free_list_08004974;\n\n  // Check if the free list is empty\n  if (free_list_ptr == (int **)0x0) {\n    current_block_ptr[1] = (int *)0x0;\n    *(int ***)PTR___malloc_free_list_08004974 = current_block_ptr;\n    prev_block_ptr = (int **)extraout_r1;\n    prev_free_list_ptr = (int **)PTR___malloc_free_list_08004974;\n  }\n  else if (current_block_ptr < free_list_ptr) {\n    prev_block_ptr = (int **)*current_block_ptr;\n    prev_free_list_ptr = (int **)((int)current_block_ptr + (int)prev_block_ptr);\n    is_current_block_in_free_list = free_list_ptr == prev_free_list_ptr;\n    if (is_current_block_in_free_list) {\n      prev_block_ptr = (int **)*free_list_ptr;\n      free_list_ptr = (int **)free_list_ptr[1];\n    }\n    current_block_ptr[1] = (int *)free_list_ptr;\n    if (is_current_block_in_free_list) {\n      current_block_ptr = (int **)((int)current_block_ptr + (int)prev_block_ptr);\n      *current_block_ptr = (int *)current_block_ptr;\n    }\n    *(int ***)PTR___malloc_free_list_08004974 = current_block_ptr;\n  }\n  else {\n    do {\n      next_block_ptr = free_list_ptr;\n      prev_block_ptr = (int **)next_block_ptr[1];\n      if (prev_block_ptr == (int **)0x0) break;\n      free_list_ptr = prev_block_ptr;\n    } while (prev_block_ptr <= current_block_ptr);\n    prev_block_ptr = (int **)*next_block_ptr;\n    if ((int **)((int)next_block_ptr + (int)prev_block_ptr) == current_block_ptr) {\n      prev_block_ptr = (int **)((int)prev_block_ptr + (int)*current_block_ptr);\n      *next_block_ptr = (int *)prev_block_ptr;\n      if (prev_block_ptr == (int **)((int)next_block_ptr + (int)prev_block_ptr[1])) {\n        current_block_ptr = *prev_block_ptr;\n        prev_block_ptr = (int **)prev_block_ptr[1];\n        next_block_ptr[1] = (int *)prev_block_ptr;\n        prev_block_ptr = (int **)((int)prev_block_ptr + (int)current_block_ptr);\n        *next_block_ptr = (int *)prev_block_ptr;\n      }\n    }\n    else if (current_block_ptr < (int **)((int)next_block_ptr + (int)prev_block_ptr)) {\n      *error_code = 0xc;\n    }\n    else {\n      prev_block_ptr = (int **)((int)current_block_ptr + (int)*current_block_ptr);\n      is_current_block_in_free_list = prev_block_ptr == next_block_ptr;\n      if (is_current_block_in_free_list) {\n        prev_block_ptr = (int **)*prev_block_ptr;\n        next_block_ptr = (int **)prev_block_ptr[1];\n      }\n      current_block_ptr[1] = (int *)next_block_ptr;\n      if (is_current_block_in_free_list) {\n        prev_block_ptr = (int **)((int)prev_block_ptr + (int)*current_block_ptr);\n        *current_block_ptr = (int *)prev_block_ptr;\n      }\n      free_list_ptr[1] = (int *)current_block_ptr;\n    }\n  }\n\n  // Release the lock for the free list\n  __malloc_unlock(error_code, prev_block_ptr, prev_free_list_ptr, param_4);\n  return;\n}",
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080048dc",
            "calling": [
                "__swsetup_r",
                "__sflush_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_and_add_to_free_list_080048dc"
        },
        "FUN_08003754": {
            "renaming": {
                "FUN_08003754": "handle_timer_interrupt_08003754",
                "*htim": "*timer_handle",
                "psVar1": "timer_obj",
                "get_timer_obj": "get_timer_object",
                "irqHandleOC": "timer_interrupt_handler",
                "_func_void_stimer_t_ptr_uint32_t": "_func_void_stimer_t_ptr_uint32_t",
                "HAL_TIM_ACTIVE_CHANNEL_1": "HAL_TIM_ACTIVE_CHANNEL_1"
            },
            "code": "void handle_timer_interrupt_08003754(TIM_HandleTypeDef *timer_handle)\n{\n  stimer_t *timer_obj;\n  timer_obj = get_timer_object(timer_handle);\n  if ((timer_obj->timer_interrupt_handler != (_func_void_stimer_t_ptr_uint32_t *)0x0) &&\n     (timer_handle->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timer_obj->timer_interrupt_handler)(timer_obj,0);\n  }\n  return;\n}",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003754",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_08003754"
        },
        "FUN_08001578": {
            "renaming": {
                "FUN_08001578": "i2c_listen_mode_08001578",
                "*hi2c": "*handle",
                "pIVar1": "i2c_instance"
            },
            "code": "HAL_StatusTypeDef i2c_listen_mode_08001578(I2C_HandleTypeDef *handle)\n{\n  I2C_TypeDef *i2c_instance;\n  if (handle->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  handle->State = HAL_I2C_STATE_LISTEN;\n  i2c_instance = handle->Instance;\n  if ((i2c_instance->CR1 & 1) == 0) {\n    i2c_instance->CR1 = i2c_instance->CR1 | 1;\n  }\n  i2c_instance->CR1 |= 0x400;\n  i2c_instance->CR2 |= 0x300;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001578",
            "calling": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "imported": false,
            "current_name": "i2c_listen_mode_08001578"
        },
        "FUN_080035ac": {
            "renaming": {
                "FUN_080035ac": "trigger_RTC_alarm_080035ac",
                "PTR_RtcHandle_080035b8": "rtc_handle",
                "HAL_RTC_AlarmIRQHandler": "trigger_RTC_alarm_IRQ"
            },
            "code": "void trigger_RTC_alarm_080035ac(void)\n{\n  RTC_HandleTypeDef* PTR_RtcHandle_080035b8 = (RTC_HandleTypeDef*)PTR_RtcHandle_080035b8;\n  HAL_RTC_AlarmIRQHandler(PTR_RtcHandle_080035b8);\n  return;\n}",
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035ac",
            "calling": [],
            "imported": false,
            "current_name": "trigger_RTC_alarm_080035ac"
        },
        "FUN_08004844": {
            "renaming": {
                "FUN_08004844": "convertToLongLongIfZero_08004844",
                "param_1": "input",
                "param_2": "checkValue",
                "DAT_0800485c": "checkVariable"
            },
            "code": "unsigned long long convertToLongLongIfZero_08004844(unsigned int input, unsigned int checkValue) {\n    if (DAT_0800485c != 0) {\n        return (unsigned long long)input * 2;\n    }\n    return (unsigned long long)checkValue << 32;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004844",
            "calling": [
                "__aeabi_atexit"
            ],
            "imported": false,
            "current_name": "convertToLongLongIfZero_08004844"
        },
        "FUN_0800318c": {
            "renaming": {
                "FUN_0800318c": "get_gpio_from_port_0800318c",
                "port_idx": "port_index",
                "DAT_080031d0": "GPIO_PORTA",
                "DAT_080031f8": "GPIO_PORTB",
                "DAT_080031d4": "GPIO_PORTC",
                "DAT_080031d8": "GPIO_PORTD",
                "DAT_080031dc": "GPIO_PORTE",
                "DAT_080031e0": "GPIO_PORTF",
                "DAT_080031e4": "GPIO_PORTG",
                "DAT_080031e8": "GPIO_PORTH",
                "DAT_080031ec": "GPIO_PORTI",
                "DAT_080031f0": "GPIO_PORTJ",
                "DAT_080031f4": "GPIO_PORTK"
            },
            "code": "GPIO_TypeDef * get_gpio_from_port_0800318c(uint32_t port_index) {\n    switch(port_index) {\n        case 0:\n            return DAT_080031d0;\n        case 1:\n            return DAT_080031f8;\n        case 2:\n            return DAT_080031d4;\n        case 3:\n            return DAT_080031d8;\n        case 4:\n            return DAT_080031dc;\n        case 5:\n            return DAT_080031e0;\n        case 6:\n            return DAT_080031e4;\n        case 7:\n            return DAT_080031e8;\n        case 8:\n            return DAT_080031ec;\n        case 9:\n            return DAT_080031f0;\n        case 10:\n            return DAT_080031f4;\n        default:\n            return (GPIO_TypeDef *)0x0;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800318c",
            "calling": [
                "digitalWrite"
            ],
            "imported": false,
            "current_name": "get_gpio_from_port_0800318c"
        },
        "FUN_080001d0": {
            "renaming": {
                "FUN_080001d0": "execute_if_completed_080001d0",
                "PTR_completed_8667_08000210": "completed",
                "DAT_08000214": "code_ptr",
                "PTR_object_8672_0800020c": "object"
            },
            "code": "void execute_if_completed_080001d0(void)\n{\n    int* PTR_completed_8667_08000210 = (int*)PTR_PTR_completed_8667_08000210_8667_08000210;\n    code* DAT_08000214 = DAT_08000214;\n    if (DAT_08000204 == 0) {\n        if ((*PTR_completed_8667_08000210 != 0) && (DAT_08000214 != (code*)0x0)) {\n            (*DAT_08000214)();\n            return;\n        }\n        return;\n    }\n    if ((*PTR_completed_8667_08000210 != 0) && (DAT_08000214 != (code*)0x0)) {\n        (*DAT_08000214)(PTR_PTR_completed_8667_08000210_8667_08000210, PTR_PTR_object_8672_0800020c_8672_0800020c);\n        return;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001d0",
            "calling": [],
            "imported": false,
            "current_name": "execute_if_completed_080001d0"
        },
        "FUN_080047d0": {
            "renaming": {
                "FUN_080047d0": "handle_gpio_interrupt_080047d0",
                "GPIO_Pin": "pin_num",
                "bVar1": "pin_id",
                "PTR_gpio_irq_conf_080047ec": "irq_conf",
                "function_void___": "std::function<void()>"
            },
            "code": "void handle_gpio_interrupt_080047d0(uint16_t pin_num) {\n  uint8_t pin_id = get_pin_id(pin_num);\n  int* PTR_gpio_irq_conf_080047ec = PTR_gpio_PTR_gpio_irq_conf_080047ec_080047ec + pin_id * 0x14 + 0xc;\n  if (*PTR_gpio_irq_conf_080047ec != 0) {\n    std::function<void()> irq_handler = (std::function<void()> *)(PTR_gpio_PTR_gpio_irq_conf_080047ec_080047ec + pin_id * 0x14 + 4);\n    irq_handler();\n  }\n  return;\n}",
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047d0",
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_gpio_interrupt_080047d0"
        },
        "FUN_080040f8": {
            "renaming": {
                "FUN_080040f8": "loop_forever_080040f8",
                "status_UNUSED": "status"
            },
            "code": "void loop_forever_080040f8(int status_UNUSED)\n{\n  while(true) {\n    // Do nothing\n  }\n}",
            "called": [
                "_exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040f8",
            "calling": [
                "_exit",
                "abort"
            ],
            "imported": false,
            "current_name": "loop_forever_080040f8"
        },
        "FUN_0800500c": {
            "renaming": {
                "FUN_0800500c": "allocate_memory_0800500c",
                "param_1": "memory_address",
                "param_2": "size",
                "puVar1": "errno_ptr",
                "pcVar2": "allocated_memory"
            },
            "code": "void allocate_memory_0800500c(int *memory_address, int size)\n{\n  int *errno_ptr;\n  char *allocated_memory;\n  \n  errno_ptr = PTR_errno_08005028;\n  *(int *)PTR_errno_08005028 = 0;\n  allocated_memory = _sbrk(size);\n  if ((allocated_memory == (char *)0xffffffff) && (*(int *)errno_ptr != 0)) {\n    *memory_address = *(int *)errno_ptr;\n  }\n  return;\n}",
            "called": [
                "_sbrk"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800500c",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_0800500c"
        },
        "FUN_080023b4": {
            "renaming": {
                "FUN_080023b4": "calculate_divisor_080023b4",
                "DAT_0800247c": "PTR_data",
                "DAT_08002484": "PTR_divisor_type_4",
                "DAT_08002480": "PTR_divisor_type_8",
                "uVar1": "dividend_shift",
                "uVar2": "dividend",
                "divisor_type": "divisor_type",
                "divisor": "divisor",
                "divisor_shift": "divisor_shift"
            },
            "code": "uint32_t calculate_divisor_080023b4(void)\n{\n  uint divisor_type = *(uint *)(DAT_0800247c + 8) & 0xc;\n  uint divisor = 0;\n  if (divisor_type == 4) {\n    return DAT_08002484;\n  }\n  if (divisor_type != 8) {\n    return DAT_08002480;\n  }\n  uint uVar1 = *(uint *)(DAT_0800247c + 4) & 0x3f;\n  uint uVar2 = (uint)(*(int *)(DAT_0800247c + 4) << 0x11) >> 0x17;\n  if ((*(uint *)(DAT_0800247c + 4) & 0x400000) == 0) {\n    divisor = __aeabi_uldivmod(uVar2 * 16000000, (((uint)(uVar2 * 0x20 < uVar2) * -0x3f - (uint)(uVar2 * 0x7c0 < uVar2 * 0x1f)) * 8 + (uint)CARRY4(uVar2 * 0x3d08,uVar2)) * 0x400 | uVar2 * 0x3d09 >> 0x16, uVar1, 0);\n  }\n  else {\n    divisor = __aeabi_uldivmod(uVar2 * 8000000, (((uint)(uVar2 * 0x20 < uVar2) * -0x3f - (uint)(uVar2 * 0x7c0 < uVar2 * 0x1f)) * 8 + (uint)CARRY4(uVar2 * 0x3d08,uVar2)) * 0x200, uVar1, 0);\n  }\n  uint divisor_shift = ((((uint)(*(int *)(DAT_0800247c + 4) << 0xe) >> 0x1e) + 1) * 2);\n  return divisor / divisor_shift;\n}\n",
            "called": [
                "__aeabi_uldivmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080023b4",
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "calculate_divisor_080023b4"
        },
        "FUN_080011a4": {
            "renaming": {
                "FUN_080011a4": "update_GPIO_Pin_080011a4",
                "GPIO_Pin": "pin",
                "DAT_080011bc": "gpio_data"
            },
            "code": "void update_GPIO_Pin_080011a4(uint16_t pin) {\n  uint* DAT_080011bc = (uint*)(DAT_080011bc + 0x14);\n  if ((*DAT_080011bc & (uint)pin) != 0) {\n    *DAT_080011bc = (uint)pin;\n    HAL_GPIO_EXTI_Callback(pin);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080011a4",
            "calling": [
                "EXTI0_IRQHandler",
                "EXTI15_10_IRQHandler",
                "EXTI4_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI1_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI9_5_IRQHandler"
            ],
            "imported": false,
            "current_name": "update_GPIO_Pin_080011a4"
        },
        "FUN_08001e68": {
            "renaming": {
                "FUN_08001e68": "check_i2c_status_08001e68",
                "*hi2c": "*i2c_handle",
                "HVar1": "state",
                "*pIVar2": "*i2c_instance",
                "uVar3": "sr1",
                "uVar4": "cr2",
                "DAT_08001f38": "I2C_FLAG_BUSY",
                "HAL_I2C_MODE_SLAVE": "HAL_I2C_MODE_SLAVE",
                "HAL_I2C_MODE_MASTER": "HAL_I2C_MODE_MASTER",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "HAL_I2C_STATE_BUSY_TX_LISTEN",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "I2C_STATE_ADDR": "I2C_STATE_ADDR",
                "HAL_I2C_ERROR_BERR": "HAL_I2C_ERROR_BERR",
                "HAL_I2C_ERROR_ARLO": "HAL_I2C_ERROR_ARLO",
                "HAL_I2C_ERROR_AF": "HAL_I2C_ERROR_AF",
                "HAL_I2C_ERROR_OVR": "HAL_I2C_ERROR_OVR",
                "I2C_FLAG_BUSERR": "I2C_FLAG_BUSERR",
                "I2C_FLAG_ARLO": "I2C_FLAG_ARLO",
                "I2C_FLAG_AF": "I2C_FLAG_AF",
                "I2C_FLAG_OVR": "I2C_FLAG_OVR",
                "I2C_CR2_ITERREN": "I2C_CR2_ITERREN",
                "I2C_CR1_STOP": "I2C_CR1_STOP",
                "I2C_Slave_AF": "I2C_Slave_AF",
                "I2C_ITError": "I2C_ITError"
            },
            "code": "void check_i2c_status_08001e68(I2C_HandleTypeDef *i2c_handle) {\n  HAL_I2C_StateTypeDef state;\n  I2C_TypeDef *i2c_instance;\n  uint16_t sr1;\n  uint16_t cr2;\n\n  i2c_instance = i2c_handle->Instance;\n  sr1 = i2c_instance->SR1;\n  cr2 = i2c_instance->CR2;\n\n  if (((sr1 & I2C_FLAG_BUSERR) != 0) && ((cr2 & I2C_CR2_ITERREN) != 0)) {\n    i2c_handle->ErrorCode |= HAL_I2C_ERROR_BERR;\n    i2c_instance->SR1 = ~I2C_FLAG_BUSERR;\n  }\n\n  if (((sr1 & I2C_FLAG_ARLO) != 0) && ((cr2 & I2C_CR2_ITERREN) != 0)) {\n    i2c_handle->ErrorCode |= HAL_I2C_ERROR_ARLO;\n    i2c_instance->SR1 = ~I2C_FLAG_ARLO;\n  }\n\n  if (((sr1 & I2C_FLAG_AF) != 0) && ((cr2 & I2C_CR2_ITERREN) != 0)) {\n    state = i2c_handle->State;\n    if (((i2c_handle->Mode == HAL_I2C_MODE_SLAVE) && (i2c_handle->XferCount == 0)) && (((state == HAL_I2C_STATE_BUSY_TX) || (state == HAL_I2C_STATE_BUSY_TX_LISTEN)) || ((state == HAL_I2C_STATE_LISTEN) && (i2c_handle->PreviousState == I2C_STATE_ADDR)))) {\n      I2C_Slave_AF(i2c_handle);\n    }\n    else {\n      i2c_handle->ErrorCode |= HAL_I2C_ERROR_AF;\n      if (i2c_handle->Mode == HAL_I2C_MODE_MASTER) {\n        i2c_instance->CR1 |= I2C_CR1_STOP;\n      }\n      i2c_instance->SR1 = ~I2C_FLAG_AF;\n    }\n  }\n\n  if (((sr1 & I2C_FLAG_OVR) != 0) && ((cr2 & I2C_CR2_ITERREN) != 0)) {\n    i2c_handle->ErrorCode |= HAL_I2C_ERROR_OVR;\n    i2c_instance->SR1 = ~I2C_FLAG_OVR;\n  }\n\n  if (i2c_handle->ErrorCode != 0) {\n    I2C_ITError(i2c_handle);\n  }\n}",
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001e68",
            "calling": [
                "I2C1_ER_IRQHandler",
                "I2C2_ER_IRQHandler",
                "I2C3_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "check_i2c_status_08001e68"
        },
        "FUN_080019a0": {
            "renaming": {
                "FUN_080019a0": "receiveData_080019a0",
                "*hi2c": "*i2c",
                "puVar1": "data_ptr"
            },
            "code": "HAL_StatusTypeDef receiveData_080019a0(I2C_HandleTypeDef *i2c)\n{\n  uint8_t *data_ptr;\n  if (i2c->XferCount == 4) {\n    i2c->Instance->CR2 &= ~(1 << 10);\n    data_ptr = i2c->pBuffPtr;\n    i2c->pBuffPtr = data_ptr + 1;\n    *data_ptr = (uint8_t)i2c->Instance->DR;\n    i2c->XferCount--;\n  }\n  else if (i2c->XferCount == 3) {\n    i2c->Instance->CR2 &= ~(1 << 10);\n    i2c->Instance->CR1 &= ~(1 << 10);\n    data_ptr = i2c->pBuffPtr;\n    i2c->pBuffPtr = data_ptr + 1;\n    *data_ptr = (uint8_t)i2c->Instance->DR;\n    i2c->XferCount--;\n  }\n  else if (i2c->XferCount == 2) {\n    if (i2c->XferOptions - 1 < 2) {\n      i2c->Instance->CR1 &= ~(1 << 10);\n      i2c->Instance->CR1 |= 1 << 8;\n    }\n    else {\n      i2c->Instance->CR1 |= 1 << 9;\n    }\n    data_ptr = i2c->pBuffPtr;\n    i2c->pBuffPtr = data_ptr + 1;\n    *data_ptr = (uint8_t)i2c->Instance->DR;\n    i2c->XferCount--;\n    data_ptr = i2c->pBuffPtr;\n    i2c->pBuffPtr = data_ptr + 1;\n    *data_ptr = (uint8_t)i2c->Instance->DR;\n    i2c->XferCount--;\n    i2c->Instance->CR2 &= ~(1 << 8);\n    i2c->State = HAL_I2C_STATE_READY;\n    i2c->PreviousState = 0;\n    if (i2c->Mode == HAL_I2C_MODE_MEM) {\n      i2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(i2c);\n    }\n    else {\n      i2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(i2c);\n    }\n  }\n  else {\n    data_ptr = i2c->pBuffPtr;\n    i2c->pBuffPtr = data_ptr + 1;\n    *data_ptr = (uint8_t)i2c->Instance->DR;\n    i2c->XferCount--;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080019a0",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "receiveData_080019a0"
        },
        "FUN_08003f24": {
            "renaming": {
                "FUN_08003f24": "process_uart_data_08003f24",
                "huart": "uart_handle",
                "bVar1": "uart_index_value",
                "uVar2": "callback_index"
            },
            "code": "void process_uart_data_08003f24(UART_HandleTypeDef *uart_handle)\n{\n  uint8_t uart_index_value;\n  uint32_t callback_index;\n  \n  uart_index_value = get_uart_index(uart_handle);\n  callback_index = (uint32_t)uart_index_value;\n  if (callback_index < 10) {\n    (**(code **)(PTR_rx_callback_08003f40 + callback_index * 4))\n              (*(undefined4 *)(PTR_rx_callback_obj_08003f44 + callback_index * 4));\n  }\n  return;\n}",
            "called": [
                "uart_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f24",
            "calling": [
                "UART_Receive_IT"
            ],
            "imported": false,
            "current_name": "process_uart_data_08003f24"
        },
        "FUN_080046b4": {
            "renaming": {
                "FUN_080046b4": "initialize_gpio_irq_configuration_080046b4",
                "__initialize_p": "should_initialize",
                "__priority": "priority",
                "puVar1": "gpio_irq_conf_ptr"
            },
            "code": "void initialize_gpio_irq_configuration_080046b4(int should_initialize, int priority) {\n    undefined *gpio_irq_conf_ptr;\n    gpio_irq_conf_ptr = PTR_gpio_irq_conf_08004754;\n    if (should_initialize != 1) {\n        return;\n    }\n    if (priority == 0xffff) {\n        *PTR_gpio_irq_conf_08004754 = 6;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0xc) = 0;\n        gpio_irq_conf_ptr[0x14] = 7;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x20) = 0;\n        gpio_irq_conf_ptr[0x28] = 8;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x34) = 0;\n        gpio_irq_conf_ptr[0x3c] = 9;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x48) = 0;\n        gpio_irq_conf_ptr[0x50] = 10;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x5c) = 0;\n        gpio_irq_conf_ptr[100] = 0x17;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x70) = 0;\n        gpio_irq_conf_ptr[0x78] = 0x17;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x84) = 0;\n        gpio_irq_conf_ptr[0x8c] = 0x17;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x98) = 0;\n        gpio_irq_conf_ptr[0xa0] = 0x17;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0xac) = 0;\n        gpio_irq_conf_ptr[0xb4] = 0x17;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0xc0) = 0;\n        gpio_irq_conf_ptr[200] = 0x28;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0xd4) = 0;\n        gpio_irq_conf_ptr[0xdc] = 0x28;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0xe8) = 0;\n        gpio_irq_conf_ptr[0xf0] = 0x28;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0xfc) = 0;\n        gpio_irq_conf_ptr[0x104] = 0x28;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x110) = 0;\n        gpio_irq_conf_ptr[0x118] = 0x28;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x124) = 0;\n        gpio_irq_conf_ptr[300] = 0x28;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x138) = 0;\n        __aeabi_atexit(0, DAT_0800475c, PTR___dso_handle_08004758);\n    }\n    return;\n}",
            "called": [
                "__aeabi_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080046b4",
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "imported": false,
            "current_name": "initialize_gpio_irq_configuration_080046b4"
        },
        "FUN_0800160c": {
            "renaming": {
                "FUN_0800160c": "do_nothing_0800160c"
            },
            "code": "\nvoid do_nothing_0800160c(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800160c",
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "do_nothing_0800160c"
        },
        "FUN_0800160e": {
            "renaming": {
                "FUN_0800160e": "transferData_0800160e",
                "hi2c": "i2c_handle",
                "HVar1": "current_state",
                "puVar2": "buffer_pointer"
            },
            "code": "HAL_StatusTypeDef transferData_0800160e(I2C_HandleTypeDef *i2c_handle)\n{\n  HAL_I2C_StateTypeDef current_state;\n  uint8_t *buffer_pointer;\n  current_state = i2c_handle->State;\n  if (i2c_handle->XferCount != 0) {\n    buffer_pointer = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = buffer_pointer + 1;\n    *buffer_pointer = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->XferCount = i2c_handle->XferCount - 1;\n    if ((i2c_handle->XferCount == 0) && (current_state == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffffbff;\n      i2c_handle->PreviousState = 0x22;\n      i2c_handle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(i2c_handle);\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800160e",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "transferData_0800160e"
        },
        "FUN_0800293e": {
            "renaming": {
                "FUN_0800293e": "do_nothing_0800293e"
            },
            "code": "\nvoid do_nothing_0800293e(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800293e",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_0800293e"
        },
        "FUN_08000e18": {
            "renaming": {
                "FUN_08000e18": "update_uwTick_08000e18",
                "PTR_uwTick_08000e28": "uwTick",
                "PTR_uwTickFreq_08000e2c": "uwTickFreq"
            },
            "code": "void update_uwTick_08000e18(void)\n{\n  uint8_t tickFreq = *PTR_PTR_PTR_uwTick_08000e28Freq_08000e2c_08000e2c;\n  uint32_t* PTR_uwTick_08000e28 = (uint32_t*)PTR_PTR_uwTick_08000e28_08000e28;\n  *PTR_uwTick_08000e28 = tickFreq + *PTR_uwTick_08000e28;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000e18",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "update_uwTick_08000e18"
        },
        "FUN_08003486": {
            "renaming": {
                "FUN_08003486": "init_gpio_pin_08003486",
                "pin": "pin_name",
                "mode": "pin_mode",
                "pull": "pin_pull",
                "GPIOx": "gpio_port",
                "GPIO_InitStructure": "gpio_init_struct"
            },
            "code": "void init_gpio_pin_08003486(PinName_conflict pin, uint32_t mode, uint32_t pull) {\n  GPIO_TypeDef *gpio_port;\n  GPIO_InitTypeDef gpio_init_struct;\n  gpio_port = set_gpio_port_clock((uint)((int)pin << 0x18) >> 0x1c);\n  gpio_init_struct.Pin = 1 << ((int)pin & 0xfU) & 0xffff;\n  gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;\n  gpio_init_struct.Mode = mode;\n  gpio_init_struct.Pull = pull;\n  HAL_GPIO_Init(gpio_port, &gpio_init_struct);\n  return;\n}",
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003486",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "init_gpio_pin_08003486"
        },
        "FUN_08005662": {
            "renaming": {
                "FUN_08005662": "seek_file_and_update_flags_08005662",
                "param_1": "file_descriptor",
                "param_2": "buffer",
                "iVar1": "seek_result",
                "uVar2": "flags",
                "bVar3": "seek_failed"
            },
            "code": "void seek_file_and_update_flags_08005662(int file_descriptor, int* buffer) {\n  int seek_result = _lseek_r(file_descriptor, (int)*(short *)(buffer + 0xe));\n  bool seek_failed = seek_result == -1;\n  ushort flags = *(ushort *)(buffer + 0xc);\n  if (seek_failed) {\n    flags &= 0xefff;\n  }\n  else {\n    *(int *)(buffer + 0x54) = seek_result;\n    flags |= 0x1000;\n  }\n  *(ushort *)(buffer + 0xc) = flags;\n}\n",
            "called": [
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005662",
            "calling": [],
            "imported": false,
            "current_name": "seek_file_and_update_flags_08005662"
        },
        "FUN_080042ac": {
            "renaming": {
                "FUN_080042ac": "receiveSerialData_080042ac",
                "obj": "serial_obj",
                "iVar1": "received_byte",
                "uVar2": "next_rx_head",
                "c": "received_char"
            },
            "code": "void receiveSerialData_080042ac(serial_t_conflict *serial_obj) {\n  int received_byte;\n  ushort next_rx_head;\n  uchar received_char;\n  received_byte = uart_getc((serial_t *)serial_obj, &received_char);\n  if ((received_byte == 0) && ((next_rx_head = serial_obj->rx_head + 1 & 0x3f) != serial_obj->rx_tail)) {\n    serial_obj->rx_buff[serial_obj->rx_head] = received_char;\n    serial_obj->rx_head = next_rx_head;\n  }\n  return;\n}",
            "called": [
                "uart_getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042ac",
            "calling": [],
            "imported": false,
            "current_name": "receiveSerialData_080042ac"
        },
        "FUN_08001864": {
            "renaming": {
                "FUN_08001864": "i2c_data_transfer_08001864",
                "*hi2c": "*i2c_handle",
                "uVar1": "transfer_options",
                "pbVar2": "data_buffer"
            },
            "code": "HAL_StatusTypeDef i2c_data_transfer_08001864(I2C_HandleTypeDef *i2c_handle)\n{\n  uint32_t transfer_options = i2c_handle->XferOptions;\n  if (i2c_handle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (i2c_handle->XferCount == 0) {\n      if (((transfer_options == 4) || (transfer_options == 8)) || (transfer_options == 0xffff0000)) {\n        i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n        i2c_handle->PreviousState = 0;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n          i2c_handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(i2c_handle);\n        }\n        else {\n          i2c_handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(i2c_handle);\n        }\n      }\n      else {\n        i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n        i2c_handle->PreviousState = 0x11;\n        i2c_handle->Mode = HAL_I2C_MODE_NONE;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(i2c_handle);\n      }\n    }\n    else {\n      uint8_t *data_buffer = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = data_buffer + 1;\n      i2c_handle->Instance->DR = (uint)*data_buffer;\n      i2c_handle->XferCount = i2c_handle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001864",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_data_transfer_08001864"
        },
        "FUN_08000f2c": {
            "renaming": {
                "FUN_08000f2c": "set_clock_source_08000f2c",
                "CLKSource": "clk_source",
                "DAT_08000f48": "clock_settings"
            },
            "code": "void set_clock_source_08000f2c(uint32_t clk_source) {\n  if (clk_source != 4) {\n    *DAT_08000f48 = *DAT_08000f48 & 0xfffffffb;\n    return;\n  }\n  *DAT_08000f48 = *DAT_08000f48 | 4;\n  return;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f2c",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_clock_source_08000f2c"
        },
        "FUN_08000ec4": {
            "renaming": {
                "FUN_08000ec4": "set_interrupt_flag_08000ec4",
                "IRQn": "irq_num",
                "uVar1": "irq_index",
                "DAT_08000edc": "flag_base_address",
                "PTR_08000ee0": "unused_ptr"
            },
            "code": "void set_interrupt_flag_08000ec4(IRQn_Type_conflict irq_num) {\n  uint32_t irq_index = (uint32_t)irq_num;\n  if (irq_index >= 0) {\n    uint32_t* flag_ptr = (uint32_t*)(DAT_08000edc + (irq_index >> 5) * 4);\n    *flag_ptr = 1 << (irq_index & 0x1f);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000ec4",
            "calling": [
                "uart_attach_rx_callback",
                "uart_attach_tx_callback"
            ],
            "imported": false,
            "current_name": "set_interrupt_flag_08000ec4"
        },
        "FUN_08004338": {
            "renaming": {
                "FUN_08004338": "checkSerial3Availability_08004338",
                "DAT_0800435c": "serial3Enabled",
                "PTR_Serial3_08004360": "serial3"
            },
            "code": "void checkSerial3Availability_08004338(void)\n{\n  if (DAT_0800435c) {\n    HardwareSerial::available(PTR_Serial3_08004360);\n  }\n  return;\n}",
            "called": [
                "available"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004338",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "checkSerial3Availability_08004338"
        },
        "FUN_08003928": {
            "renaming": {
                "FUN_08003928": "handle_i2c_errors_08003928",
                "PTR_i2c_handles_08003934": "i2c_handles_ptr"
            },
            "code": "void handle_i2c_errors_08003928(void)\n{\n  I2C_HandleTypeDef* i2c_handle = *(I2C_HandleTypeDef**)PTR_i2c_handles_08003934;\n  HAL_I2C_ER_IRQHandler(i2c_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003928",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_errors_08003928"
        },
        "FUN_0800468c": {
            "renaming": {
                "FUN_0800468c": "free_gpio_irq_configurations_0800468c",
                "param_1": "list_start",
                "puVar1": "current_node",
                "puVar2": "previous_node"
            },
            "code": "void free_gpio_irq_configurations_0800468c(void *list_start)\n{\n  undefined *current_node;\n  undefined *previous_node;\n  \n  current_node = PTR___malloc_free_list_080046ac;\n  while (previous_node = current_node, previous_node != PTR_gpio_irq_conf_080046b0) {\n    current_node = previous_node + -0x14;\n    if (*(code **)(previous_node + -8) != (code *)0x0) {\n      (**(code **)(previous_node + -8))(previous_node + -0x10,previous_node + -0x10,3);\n    }\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800468c",
            "calling": [],
            "imported": false,
            "current_name": "free_gpio_irq_configurations_0800468c"
        },
        "FUN_080005e0": {
            "renaming": {
                "FUN_080005e0": "read_memory_080005e0",
                "a0": "address",
                "a1": "value",
                "a2": "size"
            },
            "code": "uint32_t read_memory_080005e0(uint32_t address, uint32_t value, int32_t size)\n{\n  software_interrupt(0x3f);\n  return address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080005e0",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "read_memory_080005e0"
        },
        "FUN_0800311c": {
            "renaming": {
                "FUN_0800311c": "reset_uart_transfer_counts_0800311c",
                "hdma": "dma_handle",
                "huart": "uart_handle",
                "RxXferCount": "receive_transfer_count",
                "TxXferCount": "transmit_transfer_count",
                "HAL_UART_ErrorCallback": "handle_uart_error"
            },
            "code": "void reset_uart_transfer_counts_0800311c(DMA_HandleTypeDef *dma_handle)\n{\n  UART_HandleTypeDef *uart_handle;\n  uart_handle = (UART_HandleTypeDef *)dma_handle->Parent;\n  uart_handle->RxXferCount = 0;\n  uart_handle->TxXferCount = 0;\n  HAL_UART_ErrorCallback(uart_handle);\n  return;\n}",
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800311c",
            "calling": [],
            "imported": false,
            "current_name": "reset_uart_transfer_counts_0800311c"
        },
        "FUN_0800420c": {
            "renaming": {
                "FUN_0800420c": "calculateNewTailIndex_0800420c",
                "obj": "serialObject",
                "iVar3": "newTailIndex",
                "uVar1": "tailIndexAsUShort",
                "uVar2": "tailIndexAsUint16_t"
            },
            "code": "int calculateNewTailIndex_0800420c(serial_t_conflict *serialObject) {\n    int newTailIndex = serialObject->tx_tail + 1;\n    ushort tailIndexAsUShort = (ushort)newTailIndex;\n    uint16_t tailIndexAsUint16_t = tailIndexAsUShort & 0x7f;\n    if (newTailIndex == 0) {\n        tailIndexAsUint16_t = -(-tailIndexAsUShort & 0x7f);\n    }\n    serialObject->tx_tail = tailIndexAsUint16_t;\n    if (serialObject->tx_head != serialObject->tx_tail) {\n        return 0;\n    }\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800420c",
            "calling": [],
            "imported": false,
            "current_name": "calculateNewTailIndex_0800420c"
        },
        "FUN_080005e4": {
            "renaming": {
                "FUN_080005e4": "executeAFLCall_080005e4",
                "ticks": "numTicks",
                "uVar1": "result",
                "PTR_noHyperCall_080005fc": "noHyperCall"
            },
            "code": "uint32_t executeAFLCall_080005e4(int ticks)\n{\n  uint32_t result;\n  if (*PTR_noHyperCall_080005fc != 0) {\n    return 0;\n  }\n  result = aflCall(1, ticks, 0);\n  return result;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080005e4",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "executeAFLCall_080005e4"
        },
        "FUN_0800076c": {
            "renaming": {
                "FUN_0800076c": "sendModbusRequest_0800076c",
                "Modbus": "modbus",
                "u8BufferSize": "bufferSize",
                "calcCRC": "calculateCRC",
                "au8Buffer": "buffer",
                "u8txenpin": "transmitEnablePin",
                "digitalWrite": "digitalWrite",
                "u8serno": "serialNumber",
                "port": "port",
                "super_Stream": "superStream",
                "_vptr_Print": "virtualPointerPrint",
                "u8OutCnt": "outgoingMessageCount",
                "u16timeOut": "timeoutValue",
                "u32timeOut": "timeout",
                "u16OutCnt": "outgoingMessageCount"
            },
            "code": "void __thiscall sendModbusRequest_0800076c(Modbus *modbus)\n{\n    byte bufferLength;\n    uint16_t crcValue;\n    int printResult;\n    uint bufferIndex;\n    \n    bufferLength = modbus->bufferSize;\n    crcValue = calculateCRC(modbus, bufferLength);\n    modbus->buffer[bufferLength] = (uint8_t)((uint)crcValue >> 8);\n    bufferIndex = bufferLength + 1 & 0xff;\n    modbus->buffer[bufferIndex] = (uint8_t)crcValue;\n    modbus->bufferSize = (char)bufferIndex + 1;\n    \n    if (modbus->transmitEnablePin > 1) {\n        digitalWrite((uint)modbus->transmitEnablePin, HIGH);\n    }\n    \n    if (modbus->serialNumber < 4) {\n        printResult = (*(modbus->port->stream->print->_vptr->write))(modbus->port->stream->print, modbus->buffer, (uint)modbus->bufferSize);\n    }\n    \n    if (modbus->transmitEnablePin > 1) {\n        digitalWrite((uint)modbus->transmitEnablePin, LOW);\n    }\n    \n    if (modbus->serialNumber < 4) {\n        do {\n            printResult = (*(modbus->port->stream->print->_vptr->available))();\n        } while (printResult < 0);\n    }\n    \n    modbus->bufferSize = 0;\n    modbus->timeout = millis() + modbus->timeoutValue;\n    modbus->outgoingMessageCount++;\n}",
            "called": [
                "digitalWrite",
                "millis",
                "calcCRC"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800076c",
            "calling": [
                "process_FC5",
                "process_FC3",
                "process_FC1",
                "process_FC6",
                "poll",
                "process_FC15",
                "process_FC16"
            ],
            "imported": false,
            "current_name": "sendModbusRequest_0800076c"
        },
        "FUN_080015b6": {
            "renaming": {
                "FUN_080015b6": "do_nothing_080015b6"
            },
            "code": "\nvoid do_nothing_080015b6(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015b6",
            "calling": [
                "I2C_MasterTransmit_TXE",
                "I2C_MasterTransmit_BTF"
            ],
            "imported": false,
            "current_name": "do_nothing_080015b6"
        },
        "FUN_08004460": {
            "renaming": {
                "__thiscall HardwareSerial::FUN_08004460": "setTxPinOfHardwareSerial",
                "this": "serial",
                "_tx": "txPinIndex",
                "PVar1": "txPin",
                "PTR_digitalPin_08004478": "digitalPinPtr_08004478",
                "FUN_08004460": "setTxPinOfHardwareSerial_08004460"
            },
            "code": "void setTxPinOfHardwareSerial_08004460(HardwareSerial *serial, uint32_t txPinIndex) {\n  PinName txPin;\n  if (txPinIndex < 0x60) {\n    txPin = *(PinName *)(PTR_digitalPin_08004478 + txPinIndex * 2);\n  }\n  else {\n    txPin = NC;\n  }\n  (serial->_serial).pin_tx = txPin;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004460",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "setTxPinOfHardwareSerial_08004460"
        },
        "FUN_080015b8": {
            "renaming": {
                "FUN_080015b8": "do_nothing_080015b8"
            },
            "code": "\nvoid do_nothing_080015b8(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015b8",
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "imported": false,
            "current_name": "do_nothing_080015b8"
        },
        "FUN_08001198": {
            "renaming": {
                "FUN_08001198": "set_GPIO_PinState_08001198",
                "GPIOx": "GPIO",
                "GPIO_Pin": "Pin",
                "PinState": "PinState"
            },
            "code": "void set_GPIO_PinState_08001198(GPIO_TypeDef *GPIO, uint16_t Pin, GPIO_PinState PinState) {\n    if (PinState == GPIO_PIN_RESET) {\n        GPIO->BSRR = (uint)Pin << 0x10;\n    } else {\n        GPIO->BSRR = (uint)Pin;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001198",
            "calling": [
                "digital_io_write"
            ],
            "imported": false,
            "current_name": "set_GPIO_PinState_08001198"
        },
        "FUN_080044fc": {
            "renaming": {
                "FUN_080044fc": "initialize_static_data_080044fc"
            },
            "code": "void initialize_static_data_080044fc()\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080044fc",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_080044fc"
        },
        "FUN_08003138": {
            "renaming": {
                "FUN_08003138": "is_pin_high_08003138",
                "pin": "pin_name",
                "map": "pin_map",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "_Bool is_pin_high_08003138(PinName_conflict pin, uint32_t *map) {\n    uint32_t shifted_pin = (uint)((int)pin << 0x18) >> 0x1c;\n    uint32_t shifted_map = map[shifted_pin];\n    uint32_t masked_map = shifted_map >> ((int)pin & 0xfU);\n    uint32_t pin_state = masked_map & 1;\n    return (_Bool)pin_state;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003138",
            "calling": [
                "digitalWrite",
                "pinMode"
            ],
            "imported": false,
            "current_name": "is_pin_high_08003138"
        },
        "FUN_08000300": {
            "renaming": {
                "FUN_08000300": "multiply_and_divide_08000300",
                "param_1": "multiplier_low",
                "param_2": "multiplier_high",
                "param_3": "multiplicand_low",
                "param_4": "multiplicand_high",
                "param_5": "remainder_and_quotient",
                "uVar1": "product",
                "puVar2": "quotient_low",
                "puVar4": "quotient_high",
                "uVar3": "temp",
                "uVar5": "temp1",
                "uVar6": "temp2",
                "uVar7": "temp3",
                "uVar8": "temp4",
                "uVar9": "temp5",
                "uVar10": "temp6",
                "uVar11": "temp7",
                "uVar12": "temp8",
                "bVar13": "carry_flag"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080005aa) */\n\nulonglong multiply_and_divide_08000300(uint multiplier_low,uint multiplier_high,uint multiplicand_low,uint multiplicand_high,uint *remainder_and_quotient)\n\n{\n  ulonglong product;\n  uint *quotient_low;\n  uint temp;\n  uint *quotient_high;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  uint temp8;\n  bool carry_flag;\n  \n  if (multiplicand_high == 0) {\n    if (multiplier_high < multiplicand_low) {\n      temp8 = count_leading_zeroes(multiplicand_low);\n      if (temp8 != 0) {\n        multiplicand_low = multiplicand_low << (temp8 & 0xff);\n        multiplier_high = multiplier_low >> (0x20 - temp8 & 0xff) | multiplier_high << (temp8 & 0xff);\n        multiplier_low = multiplier_low << (temp8 & 0xff);\n      }\n      temp6 = multiplicand_low >> 0x10;\n      temp4 = multiplier_high / temp6;\n      temp3 = multiplier_low >> 0x10 | (multiplier_high - temp6 * temp4) * 0x10000;\n      temp2 = temp4 * (multiplicand_low & 0xffff);\n      temp1 = temp4;\n      if (temp3 <= temp2 && temp2 - temp3 != 0) {\n        carry_flag = CARRY4(temp3,multiplicand_low);\n        temp3 = temp3 + multiplicand_low;\n        temp1 = temp4 - 1;\n        if ((carry_flag == false) && (temp3 <= temp2 && temp2 - temp3 != 0)) {\n          temp1 = temp4 - 2;\n          temp3 = temp3 + multiplicand_low;\n        }\n      }\n      temp4 = (temp3 - temp2) / temp6;\n      temp3 = multiplier_low & 0xffff | ((temp3 - temp2) - temp6 * temp4) * 0x10000;\n      temp6 = temp4 * (multiplicand_low & 0xffff);\n      temp2 = temp4;\n      if (temp3 <= temp6 && temp6 - temp3 != 0) {\n        carry_flag = CARRY4(temp3,multiplicand_low);\n        temp3 = temp3 + multiplicand_low;\n        temp2 = temp4 - 1;\n        if ((carry_flag == false) && (temp3 <= temp6 && temp6 - temp3 != 0)) {\n          temp2 = temp4 - 2;\n          temp3 = temp3 + multiplicand_low;\n        }\n      }\n      temp3 = temp3 - temp6;\n      quotient_low = (uint *)(temp2 | temp1 << 0x10);\n      quotient_high = (uint *)0x0;\n    }\n    else {\n      if (multiplicand_low == 0) {\n        multiplicand_low = 1 / 0;\n      }\n      temp8 = count_leading_zeroes(multiplicand_low);\n      if (temp8 == 0) {\n        multiplier_high = multiplier_high - multiplicand_low;\n        temp3 = multiplicand_low >> 0x10;\n        temp7 = multiplicand_low & 0xffff;\n        quotient_high = (uint *)0x1;\n      }\n      else {\n        multiplicand_low = multiplicand_low << (temp8 & 0xff);\n        temp3 = multiplicand_low >> 0x10;\n        temp1 = multiplier_high >> (0x20 - temp8 & 0xff);\n        temp5 = multiplier_low >> (0x20 - temp8 & 0xff) | multiplier_high << (temp8 & 0xff);\n        temp2 = temp1 / temp3;\n        temp7 = multiplicand_low & 0xffff;\n        temp6 = temp5 >> 0x10 | (temp1 - temp3 * temp2) * 0x10000;\n        temp4 = temp2 * temp7;\n        multiplier_low = multiplier_low << (temp8 & 0xff);\n        temp1 = temp2;\n        if (temp6 <= temp4 && temp4 - temp6 != 0) {\n          carry_flag = CARRY4(temp6,multiplicand_low);\n          temp6 = temp6 + multiplicand_low;\n          temp1 = temp2 - 1;\n          if ((carry_flag == false) && (temp6 <= temp4 && temp4 - temp6 != 0)) {\n            temp1 = temp2 - 2;\n            temp6 = temp6 + multiplicand_low;\n          }\n        }\n        temp = (temp6 - temp4) / temp3;\n        multiplier_high = temp5 & 0xffff | ((temp6 - temp4) - temp3 * temp) * 0x10000;\n        temp4 = temp * temp7;\n        temp2 = temp;\n        if (multiplier_high <= temp4 && temp4 - multiplier_high != 0) {\n          carry_flag = CARRY4(multiplier_high,multiplicand_low);\n          multiplier_high = multiplier_high + multiplicand_low;\n          temp2 = temp - 1;\n          if ((carry_flag == false) && (multiplier_high <= temp4 && temp4 - multiplier_high != 0)) {\n            temp2 = temp - 2;\n            multiplier_high = multiplier_high + multiplicand_low;\n          }\n        }\n        multiplier_high = multiplier_high - temp4;\n        quotient_high = (uint *)(temp2 | temp1 << 0x10);\n      }\n      temp6 = multiplier_high / temp3;\n      temp4 = multiplier_low >> 0x10 | (multiplier_high - temp3 * temp6) * 0x10000;\n      temp2 = temp7 * temp6;\n      temp1 = temp6;\n      if (temp4 <= temp2 && temp2 - temp4 != 0) {\n        carry_flag = CARRY4(temp4,multiplicand_low);\n        temp4 = temp4 + multiplicand_low;\n        temp1 = temp6 - 1;\n        if ((carry_flag == false) && (temp4 <= temp2 && temp2 - temp4 != 0)) {\n          temp1 = temp6 - 2;\n          temp4 = temp4 + multiplicand_low;\n        }\n      }\n      temp6 = (temp4 - temp2) / temp3;\n      temp3 = multiplier_low & 0xffff | ((temp4 - temp2) - temp3 * temp6) * 0x10000;\n      temp7 = temp7 * temp6;\n      temp2 = temp6;\n      if (temp3 <= temp7 && temp7 - temp3 != 0) {\n        carry_flag = CARRY4(temp3,multiplicand_low);\n        temp3 = temp3 + multiplicand_low;\n        temp2 = temp6 - 1;\n        if ((carry_flag == false) && (temp3 <= temp7 && temp7 - temp3 != 0)) {\n          temp2 = temp6 - 2;\n          temp3 = temp3 + multiplicand_low;\n        }\n      }\n      temp3 = temp3 - temp7;\n      quotient_low = (uint *)(temp2 | temp1 << 0x10);\n    }\n    if (remainder_and_quotient != (uint *)0x0) {\n      *remainder_and_quotient = temp3 >> (temp8 & 0xff);\n      remainder_and_quotient[1] = 0;\n      return CONCAT44(quotient_high,quotient_low);\n    }\n  }\n  else if (multiplier_high < multiplicand_high) {\n    quotient_low = remainder_and_quotient;\n    quotient_high = remainder_and_quotient;\n    if (remainder_and_quotient != (uint *)0x0) {\n      *remainder_and_quotient = multiplier_low;\n      remainder_and_quotient[1] = multiplier_high;\n      return 0;\n    }\n  }\n  else {\n    quotient_high = (uint *)count_leading_zeroes(multiplicand_high);\n    if (quotient_high != (uint *)0x0) {\n      temp4 = 0x20 - (int)quotient_high;\n      temp1 = multiplicand_low >> (temp4 & 0xff) | multiplicand_high << ((uint)quotient_high & 0xff);\n      temp5 = temp1 >> 0x10;\n      temp8 = multiplier_high >> (temp4 & 0xff);\n      temp7 = multiplier_low >> (temp4 & 0xff) | multiplier_high << ((uint)quotient_high & 0xff);\n      temp6 = temp8 / temp5;\n      temp3 = temp7 >> 0x10 | (temp8 - temp5 * temp6) * 0x10000;\n      temp2 = temp6 * (temp1 & 0xffff);\n      multiplicand_low = multiplicand_low << ((uint)quotient_high & 0xff);\n      multiplier_low = multiplier_low << ((uint)quotient_high & 0xff);\n      temp8 = temp6;\n      if (temp3 <= temp2 && temp2 - temp3 != 0) {\n        carry_flag = CARRY4(temp3,temp1);\n        temp3 = temp3 + temp1;\n        temp8 = temp6 - 1;\n        if ((carry_flag == false) && (temp3 <= temp2 && temp2 - temp3 != 0)) {\n          temp8 = temp6 - 2;\n          temp3 = temp3 + temp1;\n        }\n      }\n      temp6 = (temp3 - temp2) / temp5;\n      temp3 = temp7 & 0xffff | ((temp3 - temp2) - temp5 * temp6) * 0x10000;\n      temp5 = temp6 * (temp1 & 0xffff);\n      temp2 = temp6;\n      if (temp3 <= temp5 && temp5 - temp3 != 0) {\n        carry_flag = CARRY4(temp3,temp1);\n        temp3 = temp3 + temp1;\n        temp2 = temp6 - 1;\n        if ((carry_flag == false) && (temp3 <= temp5 && temp5 - temp3 != 0)) {\n          temp2 = temp6 - 2;\n          temp3 = temp3 + temp1;\n        }\n      }\n      temp2 = temp2 | temp8 << 0x10;\n      product = (ulonglong)temp2 * (ulonglong)multiplicand_low;\n      if (CONCAT44(temp3 - temp5,multiplier_low) < product) {\n        product = product - CONCAT44(temp1,multiplicand_low);\n        temp2 = temp2 - 1;\n      }\n      if (remainder_and_quotient != (uint *)0x0) {\n        temp8 = ((temp3 - temp5) - (int)(product >> 0x20)) - (uint)(multiplier_low < (uint)product);\n        *remainder_and_quotient = temp8 << (temp4 & 0xff) | multiplier_low - (uint)product >> ((uint)quotient_high & 0xff);\n        remainder_and_quotient[1] = temp8 >> ((uint)quotient_high & 0xff);\n      }\n      return (ulonglong)temp2;\n    }\n    if ((multiplicand_high < multiplier_high) || (quotient_low = quotient_high, multiplicand_low <= multiplier_low)) {\n      carry_flag = multiplier_low < multiplicand_low;\n      multiplier_low = multiplier_low - multiplicand_low;\n      multiplier_high = (multiplier_high - multiplicand_high) - (uint)carry_flag;\n      quotient_low = (uint *)0x1;\n    }\n    if (remainder_and_quotient != (uint *)0x0) {\n      *remainder_and_quotient = multiplier_low;\n      remainder_and_quotient[1] = multiplier_high;\n      return ZEXT48(quotient_low);\n    }\n  }\n  return CONCAT44(quotient_high,quotient_low);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000300",
            "calling": [
                "__aeabi_uldivmod"
            ],
            "imported": false,
            "current_name": "multiply_and_divide_08000300"
        },
        "FUN_080005dc": {
            "renaming": {
                "FUN_080005dc": "do_nothing_080005dc"
            },
            "code": "\nvoid do_nothing_080005dc(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080005dc",
            "calling": [
                "__aeabi_uldivmod"
            ],
            "imported": false,
            "current_name": "do_nothing_080005dc"
        },
        "FUN_08003810": {
            "renaming": {
                "FUN_08003810": "handle_timer_events_08003810",
                "PTR_timer_handles_08003828": "PTR_timer_handles",
                "timer_handle_1": "timer_handle_1",
                "timer_handle_2": "timer_handle_2"
            },
            "code": "void handle_timer_events_08003810(void)\n{\n  TIM_HandleTypeDef *timer_handle_1 = *(TIM_HandleTypeDef **)(PTR_timer_handles_08003828_08003828 + 0x1c);\n  TIM_HandleTypeDef *timer_handle_2 = *(TIM_HandleTypeDef **)(PTR_timer_handles_08003828_08003828 + 0x30);\n  if (timer_handle_1 != NULL) {\n    HAL_TIM_IRQHandler(timer_handle_1);\n  }\n  if (timer_handle_2 != NULL) {\n    HAL_TIM_IRQHandler(timer_handle_2);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003810",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_events_08003810"
        },
        "FUN_08002848": {
            "renaming": {
                "FUN_08002848": "updateChannelStateOfTimer_08002848",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "channelState",
                "CCER": "channelControlRegister",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void updateChannelStateOfTimer_08002848(TIM_TypeDef *timer, uint32_t channel, uint32_t channelState) {\n  uint32_t channelBit = channel & 0xff;\n  uint32_t mask = ~(1 << channelBit);\n  timer->CCER = (timer->CCER & mask) | (channelState << channelBit);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002848",
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "imported": false,
            "current_name": "updateChannelStateOfTimer_08002848"
        },
        "FUN_08003938": {
            "renaming": {
                "FUN_08003938": "handle_I2C_event_08003938",
                "*PTR_i2c_handles_08003944": "*i2c_handles_ptr",
                "i2c_handle_ptr": "i2c_handle",
                "HAL_I2C_EV_IRQHandler": "handle_I2C_event_interrupt"
            },
            "code": "void handle_I2C_event_08003938(void)\n{\n  I2C_HandleTypeDef* i2c_handle_ptr = *(I2C_HandleTypeDef **)(PTR_i2c_handles_08003944 + 4);\n  HAL_I2C_EV_IRQHandler(i2c_handle_ptr);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003938",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_event_08003938"
        },
        "FUN_0800312c": {
            "renaming": {
                "FUN_0800312c": "get_uart_rx_state_0800312c",
                "*huart": "*uart_handle",
                "huart": "uart_handle",
                "RxState": "rx_state",
                "gState": "g_state"
            },
            "code": "HAL_UART_StateTypeDef get_uart_rx_state_0800312c(UART_HandleTypeDef *uart_handle)\n{\n  HAL_UART_StateTypeDef rx_state = uart_handle->RxState;\n  HAL_UART_StateTypeDef g_state = uart_handle->gState;\n  return rx_state | g_state;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800312c",
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "imported": false,
            "current_name": "get_uart_rx_state_0800312c"
        },
        "FUN_080028f0": {
            "renaming": {
                "FUN_080028f0": "halt_timer_channel_080028f0",
                "htim": "timer_handle",
                "Channel": "channel",
                "pTVar1": "timer_instance",
                "Instance": "timer_instance->Instance",
                "CCER": "timer_instance->CCER",
                "BDTR": "timer_instance->BDTR",
                "CR1": "timer_instance->CR1",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef halt_timer_channel_080028f0(TIM_HandleTypeDef *timer_handle, uint32_t channel)\n{\n  TIM_TypeDef *timer_instance;\n  TIM_CCxNChannelCmd(timer_handle->Instance, channel, 0);\n  timer_instance = timer_handle->Instance;\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->BDTR &= 0xffff7fff;\n  }\n  timer_instance = timer_handle->Instance;\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 &= 0xfffffffe;\n  }\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080028f0",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "halt_timer_channel_080028f0"
        },
        "FUN_08000e30": {
            "renaming": {
                "FUN_08000e30": "get_uwTick_08000e30",
                "PTR_uwTick_08000e38": "PTR_uwTick"
            },
            "code": "uint32_t get_uwTick_08000e30(void)\n{\n    uint32_t* ptr_uwTick = (uint32_t*) PTR_uwTick_08000e38_08000e38;\n    return *ptr_uwTick;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000e30",
            "calling": [
                "GetCurrentMilli",
                "HAL_UART_Transmit",
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig",
                "HAL_PWREx_EnableOverDrive",
                "UART_WaitOnFlagUntilTimeout",
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "get_uwTick_08000e30"
        },
        "FUN_08000f56": {
            "renaming": {
                "FUN_08000f56": "reset_DAC_state_08000f56",
                "hdac": "dac_handle",
                "State": "current_state",
                "HAL_DAC_StateTypeDef": "DAC_state",
                "HAL_DAC_MspDeInit": "deinitialize_DAC_Msp",
                "ErrorCode": "error_code",
                "HAL_UNLOCKED": "unlocked_state"
            },
            "code": "HAL_StatusTypeDef reset_DAC_state_08000f56(DAC_HandleTypeDef *dac_handle)\n{\n  if (dac_handle != (DAC_HandleTypeDef *)0x0) {\n    dac_handle->State = HAL_DAC_STATE_BUSY;\n    HAL_DAC_MspDeInit(dac_handle);\n    dac_handle->ErrorCode = 0;\n    dac_handle->State = HAL_DAC_STATE_RESET;\n    dac_handle->Lock = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_DAC_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f56",
            "calling": [
                "dac_stop"
            ],
            "imported": false,
            "current_name": "reset_DAC_state_08000f56"
        },
        "FUN_0800295c": {
            "renaming": {
                "FUN_0800295c": "transmitData_0800295c",
                "huart": "uart",
                "uVar1": "dataLength",
                "pbVar2": "dataPtr"
            },
            "code": "HAL_StatusTypeDef transmitData_0800295c(UART_HandleTypeDef *uart)\n{\n  uint16_t dataLength;\n  byte *dataPtr;\n  \n  if (uart->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  \n  dataLength = (uart->Init).WordLength;\n  if (dataLength == 0x1000) {\n    uart->Instance->DR = *(ushort *)uart->pTxBuffPtr & 0x1ff;\n    if ((uart->Init).Parity == 0) {\n      uart->pTxBuffPtr = uart->pTxBuffPtr + 2;\n    }\n    else {\n      uart->pTxBuffPtr = uart->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    dataPtr = uart->pTxBuffPtr;\n    uart->pTxBuffPtr = dataPtr + 1;\n    uart->Instance->DR = (uint)*dataPtr;\n  }\n  \n  dataLength = uart->TxXferCount - 1;\n  uart->TxXferCount = dataLength;\n  if (dataLength == 0) {\n    uart->Instance->CR1 &= 0xffffff7f;\n    uart->Instance->CR1 |= 0x40;\n    return HAL_OK;\n  }\n  else {\n    return HAL_OK;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800295c",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "transmitData_0800295c"
        },
        "FUN_08003380": {
            "renaming": {
                "FUN_08003380": "determine_dac_pin_functionality_08003380",
                "pin": "pin_name",
                "uVar1": "pin_function",
                "PTR_PinMap_DAC_08003398": "PinMap_DAC",
                "PinMap_conflict": "PinMap"
            },
            "code": "uint32_t determine_dac_pin_functionality_08003380(PinName_conflict pin) {\n  uint32_t pin_function = pinmap_function(pin, (PinMap_conflict*)PTR_PTR_PinMap_DAC_08003398_08003398);\n  if ((pin_function << 0xc) >> 0x1b != 2) {\n    return 0;\n  }\n  return 0x10;\n}",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003380",
            "calling": [
                "dac_stop"
            ],
            "imported": false,
            "current_name": "determine_dac_pin_functionality_08003380"
        },
        "FUN_08005686": {
            "renaming": {
                "FUN_08005686": "close_file_descriptor_08005686",
                "param_1": "file_descriptor",
                "param_2": "buffer_address",
                "_close_r": "_close_r",
                "*(short *)(param_2 + 0xe)": "buffer",
                "file_descriptor": "file_descriptor",
                "file_descriptor_as_int": "file_descriptor_as_int"
            },
            "code": "void close_file_descriptor_08005686(undefined4 file_descriptor, int buffer_address)\n{\n    short* buffer = (short*)(buffer_address + 0xe);\n    int file_descriptor_as_int = (int)*buffer;\n    _close_r(file_descriptor, file_descriptor_as_int);\n    return;\n}",
            "called": [
                "_close_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005686",
            "calling": [],
            "imported": false,
            "current_name": "close_file_descriptor_08005686"
        },
        "FUN_08004110": {
            "renaming": {
                "FUN_08004110": "configure_output_pin_08004110",
                "ulPin": "pin_number",
                "ulMode": "mode",
                "_Var1": "is_configured",
                "PinName_conflict": "PinName",
                "PTR_digitalPin_080041a8": "digitalPin_080041a8",
                "NC": "NC",
                "is_pin_configured": "is_pin_configured",
                "PTR_g_anOutputPinConfigured_080041ac": "g_anOutputPinConfigured_080041ac",
                "pin_in_pinmap": "pin_in_pinmap",
                "PinMap_conflict": "PinMap",
                "PTR_PinMap_DAC_080041b0": "PinMap_DAC_080041b0",
                "dac_stop": "dac_stop",
                "PTR_PinMap_PWM_080041b4": "PinMap_PWM_080041b4",
                "pwm_stop": "pwm_stop",
                "reset_pin_configured": "reset_pin_configured",
                "switch": "switch",
                "digital_io_init": "digital_io_init",
                "set_pin_configured": "set_pin_configured",
                "PTR_g_digPinConfigured_080041b8": "g_digPinConfigured_080041b8"
            },
            "code": "void configure_output_pin_08004110(uint32_t pin_number, uint32_t mode)\n{\n  _Bool is_configured;\n  PinName pin;\n  if (pin_number < 0x60) {\n    pin = *(PinName *)(PTR_digitalPin_080041a8 + pin_number * 2);\n  }\n  else {\n    pin = NC;\n  }\n  if (pin != NC) {\n    is_configured = is_pin_configured(pin, (uint32_t *)PTR_g_anOutputPinConfigured_080041ac);\n    if (is_configured) {\n      if (pin_in_pinmap(pin, (PinMap_conflict *)PTR_PinMap_DAC_080041b0)) {\n        dac_stop(pin);\n      }\n      else if (pin_in_pinmap(pin, (PinMap_conflict *)PTR_PinMap_PWM_080041b4)) {\n        pwm_stop(pin);\n      }\n      reset_pin_configured(pin, (uint32_t *)PTR_g_anOutputPinConfigured_080041ac);\n    }\n    switch (mode) {\n    case 0:\n      digital_io_init(pin, 0, 0);\n      break;\n    case 1:\n      digital_io_init(pin, 1, 0);\n      break;\n    case 2:\n      digital_io_init(pin, 0, 1);\n      break;\n    case 3:\n      digital_io_init(pin, 0, 2);\n      break;\n    }\n    set_pin_configured(pin, (uint32_t *)PTR_g_digPinConfigured_080041b8);\n  }\n  return;\n}",
            "called": [
                "pin_in_pinmap",
                "digital_io_init",
                "set_pin_configured",
                "reset_pin_configured",
                "dac_stop",
                "is_pin_configured",
                "pwm_stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004110",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "configure_output_pin_08004110"
        },
        "FUN_08005320": {
            "renaming": {
                "FUN_08005320": "walk_directory_tree_08005320",
                "param_1": "reentrancy_structure",
                "_fwalk_reent": "_fwalk_reent",
                "DAT_08005328": "directory_tree"
            },
            "code": "void walk_directory_tree_08005320(void* reentrancy_structure)\n{\n  _fwalk_reent(reentrancy_structure, DAT_08005328);\n  return;\n}",
            "called": [
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005320",
            "calling": [],
            "imported": false,
            "current_name": "walk_directory_tree_08005320"
        },
        "FUN_08000ee0": {
            "renaming": {
                "FUN_08000ee0": "calculate_ticks_08000ee0",
                "TicksNumb": "ticks_count",
                "puVar1": "ticks_ptr",
                "DAT_08000f04": "ticks_ptr",
                "DAT_08000f08": "other_ptr"
            },
            "code": "uint32_t calculate_ticks_08000ee0(uint32_t ticks_count)\n{\n  undefined4 *DAT_08000f04;\n  DAT_08000f04 = DAT_08000f04;\n  if (ticks_count - 1 < 0x1000000) {\n    DAT_08000f04[1] = ticks_count - 1;\n    *(undefined *)(DAT_08000f08 + 0x23) = 0xf0;\n    DAT_08000f04[2] = 0;\n    *DAT_08000f04 = 7;\n    return 0;\n  }\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000ee0",
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "imported": false,
            "current_name": "calculate_ticks_08000ee0"
        },
        "FUN_080015ba": {
            "renaming": {
                "FUN_080015ba": "do_nothing_080015ba"
            },
            "code": "\nvoid do_nothing_080015ba(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015ba",
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "imported": false,
            "current_name": "do_nothing_080015ba"
        },
        "FUN_08000f4c": {
            "renaming": {
                "FUN_08000f4c": "do_nothing_08000f4c"
            },
            "code": "\nvoid do_nothing_08000f4c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f4c",
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08000f4c"
        },
        "FUN_080015bc": {
            "renaming": {
                "FUN_080015bc": "transmitData_080015bc",
                "*hi2c": "*i2c",
                "HVar1": "currState",
                "pbVar2": "dataPtr"
            },
            "code": "HAL_StatusTypeDef transmitData_080015bc(I2C_HandleTypeDef *hi2c)\n{\n  HAL_I2C_StateTypeDef currState;\n  byte *dataPtr;\n  currState = hi2c->State;\n  if (hi2c->XferCount != 0) {\n    dataPtr = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = dataPtr + 1;\n    hi2c->Instance->DR = (uint)*dataPtr;\n    hi2c->XferCount = hi2c->XferCount - 1;\n    if ((hi2c->XferCount == 0) && (currState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n      hi2c->PreviousState = 0x21;\n      hi2c->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(hi2c);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015bc",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "transmitData_080015bc"
        },
        "FUN_08000f4e": {
            "renaming": {
                "FUN_08000f4e": "handle_systick_interrupt_08000f4e"
            },
            "code": "void handle_systick_interrupt_08000f4e(void)\n{\n  HAL_SYSTICK_Callback();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f4e",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "handle_systick_interrupt_08000f4e"
        },
        "FUN_08003948": {
            "renaming": {
                "FUN_08003948": "handle_i2c_error_interrupt_08003948",
                "PTR_i2c_handles_08003954": "i2c_handles_ptr"
            },
            "code": "void handle_i2c_error_interrupt_08003948(void)\n{\n  I2C_HandleTypeDef* i2c_handle_ptr = *(I2C_HandleTypeDef **)(PTR_i2c_handles_08003954 + 4);\n  HAL_I2C_ER_IRQHandler(i2c_handle_ptr);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003948",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_error_interrupt_08003948"
        },
        "FUN_0800458c": {
            "renaming": {
                "FUN_0800458c": "initialize_static_variables_0800458c"
            },
            "code": "void initialize_static_variables_0800458c(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800458c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_0800458c"
        },
        "FUN_0800066c": {
            "renaming": {
                "FUN_0800066c": "set_modbus_config_0800066c",
                "this": "modbus",
                "u8id": "id",
                "u8serno": "serial_number",
                "u8txenpin": "tx_enable_pin",
                "u16timeOut": "timeout"
            },
            "code": "void __thiscall set_modbus_config_0800066c(Modbus *modbus, uint8_t id, uint8_t serial_number, uint8_t tx_enable_pin) {\n  modbus->id = id;\n  if (serial_number > 3) {\n    serial_number = 0;\n  }\n  modbus->serial_number = serial_number;\n  modbus->tx_enable_pin = tx_enable_pin;\n  modbus->timeout = 1000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800066c",
            "calling": [
                "Modbus"
            ],
            "imported": false,
            "current_name": "set_modbus_config_0800066c"
        },
        "FUN_080042e8": {
            "renaming": {
                "__thiscall HardwareSerial::FUN_080042e8": "writeByte",
                "this": "serial",
                "c": "byteToWrite",
                "_written": "isWritten",
                "_serial": "serial->_serial",
                "tx_head": "serial->_serial.tx_head",
                "tx_tail": "serial->_serial.tx_tail",
                "tx_buff": "serial->_serial.tx_buff",
                "serial_tx_active": "serial_tx_active",
                "uart_attach_tx_callback": "uart_attach_tx_callback",
                "FUN_080042e8": "writeByte_080042e8"
            },
            "code": "size_t __thiscall HardwareSerial::writeByte_080042e8(HardwareSerial *serial,uint8_t byteToWrite)\\n\\\n{\\n\\\n  bool isWritten;\\n\\\n  uint txHead;\\n\\\n  byte newTxHead;\\n\\\n  byte txTail;\\n\\\n  int nextTxHead;\\n\\\n  uint8_t txActive;\\n\\\n  isWritten = true;\\n\\\n  txHead = (uint)(serial->_serial).tx_head;\\n\\\n  nextTxHead = txHead + 1;\\n\\\n  newTxHead = (byte)nextTxHead;\\n\\\n  txTail = (byte)(serial->_serial).tx_tail;\\n\\\n  if (nextTxHead == 0) {\\n\\\n    newTxHead = -(-newTxHead & 0x7f);\\n\\\n  }\\n\\\n  while (txTail == (ushort)newTxHead) {\\n\\\n  }\\n\\\n  (serial->_serial).tx_buff[txHead] = byteToWrite;\\n\\\n  (serial->_serial).tx_head = (ushort)newTxHead;\\n\\\n  txActive = serial_tx_active((serial_t *)&serial->_serial);\\n\\\n  if (txActive == \"\\0\") {\\n\\\n    uart_attach_tx_callback((serial_t *)&serial->_serial,DAT_08004334);\\n\\\n  }\\n\\\n  return 1;\\n\\\n}",
            "called": [
                "serial_tx_active",
                "uart_attach_tx_callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042e8",
            "calling": [],
            "imported": false,
            "current_name": "writeByte_080042e8"
        },
        "FUN_080038d0": {
            "renaming": {
                "FUN_080038d0": "handle_i2c_slave_receive_080038d0",
                "hi2c": "i2c_handle",
                "piVar1": "i2c_object",
                "uVar2": "data_length",
                "get_i2c_obj": "get_i2c_object",
                "i2c_onSlaveReceive": "slave_receive_callback",
                "_func_void_uint8_t_ptr_int": "NULL",
                "slaveMode": "slave_mode_enabled",
                "handle": "handle",
                "XferSize": "XferSize",
                "i2cTxRxBuffer": "tx_rx_buffer",
                "HAL_I2C_EnableListen_IT": "HAL_I2C_EnableListen_IT"
            },
            "code": "void handle_i2c_slave_receive_080038d0(I2C_HandleTypeDef *i2c_handle)\n{\n  i2c_obj_t *i2c_object;\n  uint8_t data_length;\n  i2c_object = get_i2c_object(i2c_handle);\n  if (((i2c_object->slave_receive_callback != NULL) && (i2c_object->slave_mode_enabled == true)) && ((data_length = 0x20 - *(uint8_t *)&(i2c_object->handle).XferSize & 0xff) != 0)) {\n    (*i2c_object->slave_receive_callback)(i2c_object->tx_rx_buffer,data_length);\n  }\n  HAL_I2C_EnableListen_IT(i2c_handle);\n  return;\n}",
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080038d0",
            "calling": [
                "I2C_ITError",
                "I2C_Slave_STOPF",
                "I2C_Slave_AF"
            ],
            "imported": false,
            "current_name": "handle_i2c_slave_receive_080038d0"
        },
        "FUN_0800410c": {
            "renaming": {
                "FUN_0800410c": "get_process_id_0800410c"
            },
            "code": "__pid_t get_process_id_0800410c(void)\n{\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800410c",
            "calling": [
                "_getpid_r"
            ],
            "imported": false,
            "current_name": "get_process_id_0800410c"
        },
        "FUN_0800260c": {
            "renaming": {
                "FUN_0800260c": "get_HCLK_frequency_divider_0800260c",
                "uVar1": "HCLK_freq",
                "DAT_08002624": "data_08002624",
                "APB_prescaler_index": "APB_prescaler_index",
                "PTR_APBPrescTable_08002628": "APB_prescaler_table",
                "HCLK_freq_divider": "HCLK_freq_divider"
            },
            "code": "uint32_t get_HCLK_frequency_divider_0800260c(void)\n{\n  uint32_t HCLK_freq = HAL_RCC_GetHCLKFreq();\n  uint32_t APB_prescaler_index = (uint)(*(int *)(DAT_08002624 + 8) << 0x10) >> 0x1d;\n  uint32_t HCLK_freq_divider = PTR_APBPrescTable_08002628[APB_prescaler_index];\n  return HCLK_freq / HCLK_freq_divider;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800260c",
            "calling": [
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "get_HCLK_frequency_divider_0800260c"
        },
        "FUN_08004240": {
            "renaming": {
                "FUN_08004240": "calculateAvailableSpaceInRxBuffer_08004240",
                "this": "serialObject",
                "_serial": "serial",
                "rx_head": "head",
                "rx_tail": "tail",
                "availableSpace": "availableSpace"
            },
            "code": "int __thiscall calculateAvailableSpaceInRxBuffer_08004240(HardwareSerial *serialObject)\n{\n  uint32_t head = (serialObject->_serial).rx_head;\n  uint32_t tail = (serialObject->_serial).rx_tail;\n  uint32_t availableSpace = (head + 0x40) - tail & 0x3f;\n  return availableSpace;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004240",
            "calling": [
                "serialEventRun"
            ],
            "imported": false,
            "current_name": "calculateAvailableSpaceInRxBuffer_08004240"
        },
        "FUN_080026c8": {
            "renaming": {
                "FUN_080026c8": "do_nothing_080026c8"
            },
            "code": "\nvoid do_nothing_080026c8(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026c8",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080026c8"
        },
        "FUN_08005690": {
            "renaming": {
                "FUN_08005690": "write_to_file_08005690",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "data",
                "param_4": "data_size",
                "puVar1": "errno_ptr",
                "iVar2": "write_result"
            },
            "code": "void write_to_file_08005690(int *error_code, int file_descriptor, char *data, int data_size) {\n  undefined *errno_ptr = PTR_errno_080056b0;\n  *(undefined4 *)PTR_errno_080056b0 = 0;\n  int write_result = _write(file_descriptor, data, data_size);\n  if ((write_result == -1) && (*(int *)errno_ptr != 0)) {\n    *error_code = *(int *)errno_ptr;\n  }\n  return;\n}",
            "called": [
                "_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005690",
            "calling": [
                "__swrite"
            ],
            "imported": false,
            "current_name": "write_to_file_08005690"
        },
        "FUN_080041bc": {
            "renaming": {
                "FUN_080041bc": "write_digital_pin_080041bc",
                "ulPin": "pin_number",
                "ulVal": "pin_value",
                "_Var1": "is_pin_configured_flag",
                "port": "gpio_port",
                "uVar2": "pin_config_value"
            },
            "code": "void write_digital_pin_080041bc(uint32_t pin_number, uint32_t pin_value)\n{\n  bool is_pin_configured_flag;\n  GPIO_TypeDef *gpio_port;\n  uint32_t pin_config_value;\n\n  if (pin_number < 0x60) {\n    pin_config_value = (uint32_t)*(short *)(PTR_digitalPin_080041fc + pin_number * 2);\n  }\n  else {\n    pin_config_value = 0xffffffff;\n  }\n  if ((pin_config_value != 0xffffffff) && (is_pin_configured_flag = is_pin_configured((PinName_conflict)pin_config_value,(uint32_t *)PTR_g_digPinConfigured_08004200), is_pin_configured_flag)) {\n    gpio_port = get_GPIO_Port((pin_config_value << 0x18) >> 0x1c);\n    digital_io_write(gpio_port, 1 << (pin_config_value & 0xf) & 0xffff, pin_value);\n  }\n  return;\n}",
            "called": [
                "get_GPIO_Port",
                "digital_io_write",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041bc",
            "calling": [
                "getRxBuffer",
                "sendTxBuffer",
                "begin"
            ],
            "imported": false,
            "current_name": "write_digital_pin_080041bc"
        },
        "FUN_08004364": {
            "renaming": {
                "__thiscall HardwareSerial::FUN_08004364": "initializeSerial",
                "this": "serial",
                "ctx": "context",
                "(this->_serial).rx_buff": "serial->rx_buffer",
                "(this->_serial).rx_head": "serial->rx_head",
                "(this->_serial).rx_tail": "serial->rx_tail",
                "(this->_serial).tx_buff": "serial->tx_buffer",
                "(this->_serial).tx_head": "serial->tx_head",
                "(this->_serial).tx_tail": "serial->tx_tail",
                "FUN_08004364": "initializeSerial_08004364"
            },
            "code": "int initializeSerial_08004364(HardwareSerial *serial, EVP_PKEY_CTX *context){\n    serial->rx_buffer = serial->_rx_buffer;\n    serial->rx_head = 0;\n    serial->rx_tail = 0;\n    serial->tx_buffer = serial->_tx_buffer;\n    serial->tx_head = 0;\n    serial->tx_tail = 0;\n    return (int)serial;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004364",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "initializeSerial_08004364"
        },
        "FUN_08000682": {
            "renaming": {
                "FUN_08000682::FUN_08000682": "initialize",
                "this": "instance",
                "u8id": "id",
                "u8serno": "serial_number",
                "u8txenpin": "tx_enable_pin",
                "FUN_08000682": "initialize_08000682"
            },
            "code": "initialize_08000682* initialize_08000682(initialize_08000682* instance, uint8_t id, uint8_t serial_number, uint8_t tx_enable_pin) {\n  init(instance, id, serial_number, tx_enable_pin);\n  return instance;\n}",
            "called": [
                "init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000682",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_08000682"
        },
        "FUN_08004004": {
            "renaming": {
                "FUN_08004004": "handle_USART3_interrupt_08004004",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_USART3_interrupt",
                "USART3_IRQn": "USART3_interrupt_number",
                "PTR_uart_handlers_08004018": "uart_handlers_pointer",
                "UART_HandleTypeDef": "UART_handler_type",
                "DAT_0800401c": "unused_data",
                "HAL_UART_IRQHandler": "handle_UART_interrupt"
            },
            "code": "void handle_USART3_interrupt_08004004(void)\n{\n  clear_pending_USART3_interrupt();\n  if (uart_handler_initialized()) {\n    handle_UART_interrupt(get_UART_handler());\n  }\n  return;\n}",
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004004",
            "calling": [],
            "imported": false,
            "current_name": "handle_USART3_interrupt_08004004"
        },
        "FUN_08000e3c": {
            "renaming": {
                "FUN_08000e3c": "setPriorityGroup_08000e3c",
                "PriorityGroup": "priorityGroup",
                "DAT_08000e5c": "dataAddress",
                "PTR_": "ptr_"
            },
            "code": "void setPriorityGroup_08000e3c(uint32_t priorityGroup) {\n    uint32_t* priorityReg = (uint32_t*)(DAT_08000e5c + 0xc);\n    uint32_t maskedValue = *(uint32_t*)(DAT_08000e5c + 0xc) & 0xf8ff;\n    uint32_t newValue = (priorityGroup & 7) << 8 | maskedValue | 0x5fa0000;\n    *priorityReg = newValue;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000e3c",
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "setPriorityGroup_08000e3c"
        },
        "FUN_080037ac": {
            "renaming": {
                "FUN_080037ac": "handle_timer_interrupt_080037ac",
                "PTR_timer_handles_080037bc": "PTR_timer_handles_080037bc",
                "TIM_HandleTypeDef": "TIM_HandleTypeDef",
                "HAL_TIM_IRQHandler": "HAL_TIM_IRQHandler"
            },
            "code": "void handle_timer_interrupt_080037ac(void)\n{\n  TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef**)(PTR_timer_handles_080037bc + 8);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080037ac",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_080037ac"
        },
        "FUN_08002864": {
            "renaming": {
                "FUN_08002864": "DeactivateChannel_08002864",
                "*htim": "timerHandle",
                "Channel": "channel",
                "bVar1": "isInstanceSR",
                "*pTVar2": "timerInstance"
            },
            "code": "HAL_StatusTypeDef DeactivateChannel_08002864(TIM_HandleTypeDef *timerHandle, uint32_t channel) {\n  bool isInstanceSR;\n  TIM_TypeDef *timerInstance;\n  TIM_CCxChannelCmd(timerHandle->Instance, channel, 0);\n  timerInstance = timerHandle->Instance;\n  if (timerInstance == PTR_DAT_080028d0) {\n    isInstanceSR = true;\n  }\n  else if (timerInstance == (TIM_TypeDef *)&PTR_DAT_080028d0[0xc].SR) {\n    isInstanceSR = true;\n  }\n  else {\n    isInstanceSR = false;\n  }\n  if (((isInstanceSR) && ((timerInstance->CCER & 0x1111) == 0)) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->BDTR &= 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 &= 0xfffffffe;\n  }\n  timerHandle->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002864",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "DeactivateChannel_08002864"
        },
        "FUN_0800459a": {
            "renaming": {
                "__thiscall Print::FUN_0800459a": "printBuffer",
                "this": "print_obj",
                "buffer": "buffer",
                "size": "size",
                "sVar2": "buffer_size",
                "pPVar1": "print_obj",
                "FUN_0800459a": "printBuffer_0800459a"
            },
            "code": "size_t Print::printBuffer_0800459a(Print *this, uint8_t *buffer, size_t size)\n{\n  Print *print_obj;\n  size_t buffer_size = 0;\n  print_obj = this;\n  while( true ) {\n    if (size == 0) {\n      return buffer_size;\n    }\n    print_obj = (Print *)(**this->_vptr_Print)(print_obj,(uint)*buffer);\n    if (print_obj == (Print *)0x0) break;\n    buffer_size = buffer_size + 1;\n    buffer = buffer + 1;\n    size = size - 1;\n  }\n  return buffer_size;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800459a",
            "calling": [],
            "imported": false,
            "current_name": "printBuffer_0800459a"
        },
        "FUN_08003958": {
            "renaming": {
                "FUN_08003958": "handle_i2c_event_08003958",
                "PTR_i2c_handles_08003964": "PTR_i2c_handles",
                "i2c_handle_ptr": "i2c_handle"
            },
            "code": "void handle_i2c_event_08003958(void)\n{\n  I2C_HandleTypeDef *i2c_handle_ptr = *(I2C_HandleTypeDef **)(PTR_i2c_handles_08003964_08003964 + 8);\n  HAL_I2C_EV_IRQHandler(i2c_handle_ptr);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003958",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_event_08003958"
        },
        "FUN_0800532c": {
            "renaming": {
                "std_isra_0": "initialize_data",
                "param_1": "data_array",
                "param_2": "data_value_1",
                "param_3": "data_value_2",
                "uVar1": "u_variable",
                "FUN_0800532c": "initialize_data_0800532c"
            },
            "code": "void initialize_data_0800532c(undefined4 *data_array, undefined2 data_value_1, undefined2 data_value_2) {\n  data_array[0] = 0;\n  data_array[1] = 0;\n  data_array[2] = 0;\n  *(undefined2 *)(data_array + 3) = data_value_1;\n  data_array[0x19] = 0;\n  *(undefined2 *)((int)data_array + 0xe) = data_value_2;\n  data_array[4] = 0;\n  data_array[5] = 0;\n  data_array[6] = 0;\n  memset(data_array + 0x17, 0, 8);\n  data_array[9] = PTR_DAT_08005364;\n  data_array[10] = PTR_DAT_08005368;\n  data_array[0xb] = PTR_DAT_0800536c;\n  undefined4 uVar1 = PTR_DAT_08005370;\n  data_array[8] = data_array;\n  data_array[0xc] = uVar1;\n  return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800532c",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_data_0800532c"
        },
        "FUN_0800314e": {
            "renaming": {
                "FUN_0800314e": "set_pin_state_0800314e",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "pin_index"
            },
            "code": "void set_pin_state_0800314e(PinName_conflict pin, uint32_t *pin_map) {\n  uint pin_index = (uint)((int)pin << 0x18) >> 0x1c;\n  pin_map[pin_index] |= 1 << ((int)pin & 0xfU);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800314e",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "set_pin_state_0800314e"
        },
        "FUN_0800447c": {
            "renaming": {
                "FUN_0800447c::FUN_0800447c": "initialize_uart",
                "this": "uart_instance",
                "peripheral": "peripheral",
                "PVar1": "rx_pin",
                "extraout_r1": "extra_out_r1",
                "ctx": "ctx",
                "extraout_r1_00": "extra_out_r1_00",
                "FUN_0800447c": "initialize_uart_0800447c"
            },
            "code": "initialize_uart_0800447c * __thiscall initialize_uart_0800447c(initialize_uart_0800447c *uart_instance,void *peripheral)\n{\n  PinName_conflict rx_pin;\n  EVP_PKEY_CTX *extra_out_r1;\n  EVP_PKEY_CTX *ctx;\n  EVP_PKEY_CTX *extra_out_r1_00;\n  \n  (uart_instance->super_Stream).super_Print.write_error = 0;\n  (uart_instance->super_Stream)._timeout = 1000;\n  (uart_instance->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)write_ptr;\n  \n  if (uart_instance == (initialize_uart_0800447c *)serial3_ptr) {\n    setRx(uart_instance,0x4c);\n    setTx(uart_instance,0x4d);\n    ctx = extra_out_r1_00;\n  }\n  else {\n    rx_pin = pinmap_pin(peripheral,(PinMap_conflict *)rx_pin_ptr);\n    (uart_instance->_serial).pin_rx = rx_pin;\n    rx_pin = pinmap_pin(peripheral,(PinMap_conflict *)tx_pin_ptr);\n    (uart_instance->_serial).pin_tx = rx_pin;\n    ctx = extra_out_r1;\n  }\n  init(uart_instance,ctx);\n  return uart_instance;\n}",
            "called": [
                "pinmap_pin",
                "setRx",
                "setTx",
                "init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800447c",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_uart_0800447c"
        },
        "FUN_08004808": {
            "renaming": {
                "FUN_08004808": "print_assertion_failed_08004808",
                "param_1": "stream",
                "param_2": "file",
                "param_3": "expression",
                "param_4": "line",
                "puVar1": "value",
                "puVar2": "function",
                "PTR_s__08004840": "assertion_failed_message",
                "PTR_s___function__08004838": "null_expression_message",
                "PTR_s_assertion___s__failed__file___s__0800483c": "message",
                "PTR__impure_ptr_08004834": "impure_ptr"
            },
            "code": "void print_assertion_failed_08004808(FILE *stream, const char *file, int line, const char *function, const char *expression, const char *value)\n{\n    const char *PTR_s__08004840 = \"Assertion failed: %s, file %s, line %d.\\n\";\n    const char *PTR_s___function__08004838 = \"Assertion failed: %s, file %s, line %d.\\n\";\n    const char *PTR_s_assertion___s__failed__file___s__0800483c = (expression != NULL) ? PTR_s__08004840 : PTR_s___function__08004838;\n    fprintf(stream, PTR_s_assertion___s__failed__file___s__0800483c, expression, file, line);\n    if (value != NULL) {\n        fprintf(stream, \"Value was: %s\\n\", value);\n    }\n    abort();\n}",
            "called": [
                "abort",
                "fiprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004808",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "print_assertion_failed_08004808"
        },
        "FUN_08000f72": {
            "renaming": {
                "FUN_08000f72": "disable_dac_channel_08000f72",
                "hdac": "dac_handle",
                "Channel": "channel",
                "Instance": "instance",
                "CR": "control_register",
                "State": "state"
            },
            "code": "HAL_StatusTypeDef disable_dac_channel_08000f72(DAC_HandleTypeDef *dac_handle, uint32_t channel) {\n    uint32_t mask = ~(1 << (channel & 0xff));\n    dac_handle->Instance->CR &= mask;\n    dac_handle->State = HAL_DAC_STATE_READY;\n    return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f72",
            "calling": [
                "dac_stop"
            ],
            "imported": false,
            "current_name": "disable_dac_channel_08000f72"
        },
        "FUN_08001d00": {
            "renaming": {
                "FUN_08001d00": "i2c_handler_08001d00",
                "*hi2c": "*handle",
                "I2C_TypeDef *pIVar1": "I2C_TypeDef *instance",
                "uint uVar2": "uint32_t sr1",
                "uint uVar3": "uint32_t sr2",
                "uint uVar4": "uint32_t cr2"
            },
            "code": "void i2c_handler_08001d00(I2C_HandleTypeDef *handle)\n{\n  I2C_TypeDef *instance;\n  uint32_t sr1;\n  uint32_t sr2;\n  uint32_t cr2;\n  instance = handle->Instance;\n  sr2 = instance->SR2;\n  sr1 = instance->SR1;\n  cr2 = instance->CR2;\n  if ((handle->Mode == HAL_I2C_MODE_MASTER) || (handle->Mode == HAL_I2C_MODE_MEM)) {\n    if (((sr1 & 0x10001) == 0) || ((cr2 & 0x200) == 0)) {\n      if (((sr1 & 0x0004) == 0) || ((cr2 & 0x200) == 0)) {\n        if (((sr1 & 0x0002) != 0) && ((cr2 & 0x200) != 0)) {\n          I2C_Master_ADDR(handle);\n        }\n      }\n      else {\n        I2C_Master_ADD10(handle);\n      }\n    }\n    else {\n      I2C_Master_SB(handle);\n    }\n    if ((sr2 & 0x0001) == 0) {\n      if ((((sr1 & 0x0040) != 0) && ((cr2 & 0x400) != 0)) && ((sr1 & 0x0008) == 0)) {\n        I2C_MasterReceive_RXNE(handle);\n        return;\n      }\n      if (((sr1 & 0x0008) != 0) && ((cr2 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(handle);\n        return;\n      }\n    }\n    else {\n      if ((((sr1 & 0x0080) != 0) && ((cr2 & 0x400) != 0)) && ((sr1 & 0x0008) == 0)) {\n        I2C_MasterTransmit_TXE(handle);\n        return;\n      }\n      if (((sr1 & 0x0008) != 0) && ((cr2 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(handle);\n        return;\n      }\n    }\n  }\n  else {\n    if (((sr1 & 0x0002) != 0) && ((cr2 & 0x200) != 0)) {\n      I2C_Slave_ADDR(handle);\n      return;\n    }\n    if (((sr1 & 0x0010) != 0) && ((cr2 & 0x200) != 0)) {\n      I2C_Slave_STOPF(handle);\n      return;\n    }\n    if ((sr2 & 0x0001) == 0) {\n      if ((((sr1 & 0x0040) != 0) && ((cr2 & 0x400) != 0)) && ((sr1 & 0x0008) == 0)) {\n        I2C_SlaveReceive_RXNE(handle);\n        return;\n      }\n      if (((sr1 & 0x0008) != 0) && ((cr2 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(handle);\n      }\n    }\n    else {\n      if ((((sr1 & 0x0080) != 0) && ((cr2 & 0x400) != 0)) && ((sr1 & 0x0008) == 0)) {\n        I2C_SlaveTransmit_TXE(handle);\n        return;\n      }\n      if (((sr1 & 0x0008) != 0) && ((cr2 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(handle);\n        return;\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Master_ADD10",
                "I2C_SlaveReceive_BTF",
                "I2C_Slave_STOPF",
                "I2C_Master_ADDR",
                "I2C_SlaveTransmit_TXE",
                "I2C_MasterTransmit_TXE",
                "I2C_Master_SB",
                "I2C_SlaveTransmit_BTF",
                "I2C_Slave_ADDR",
                "I2C_MasterReceive_RXNE",
                "I2C_MasterTransmit_BTF",
                "I2C_MasterReceive_BTF"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001d00",
            "calling": [
                "I2C3_EV_IRQHandler",
                "I2C2_EV_IRQHandler",
                "I2C1_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handler_08001d00"
        },
        "FUN_080037c0": {
            "renaming": {
                "FUN_080037c0": "handle_timer_interrupt_080037c0",
                "PTR_timer_handles_080037d0": "PTR_timer_handles",
                "timer_handle_ptr": "timer_handle",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt_request"
            },
            "code": "void handle_timer_interrupt_080037c0(void)\n{\n  TIM_HandleTypeDef *timer_handle_ptr = *(TIM_HandleTypeDef **)(PTR_timer_handles_080037d0_080037d0 + 0xc);\n  if (timer_handle_ptr != NULL)\n  {\n    HAL_TIM_IRQHandler(timer_handle_ptr);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080037c0",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_080037c0"
        },
        "FUN_0800382c": {
            "renaming": {
                "FUN_0800382c": "handle_timer_interrupt_0800382c",
                "PTR_timer_handles_0800383c": "PTR_timer_handles_0800383c",
                "TIM_HandleTypeDef": "TIM_HandleTypeDef",
                "HAL_TIM_IRQHandler": "HAL_TIM_IRQHandler",
                "timer_handle": "timer_handle"
            },
            "code": "void handle_timer_interrupt_0800382c(void)\n{\n  TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef **)(PTR_timer_handles_0800383c + 0x20);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800382c",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_0800382c"
        }
    },
    "used_tokens": 220043,
    "layers": [
        [
            "FUN_080006b4",
            "FUN_080034da",
            "FUN_080035fc",
            "FUN_08003dd0",
            "FUN_08000c8c",
            "FUN_08000a4e",
            "FUN_08004774",
            "FUN_08004658",
            "FUN_080034f4",
            "FUN_0800476a",
            "FUN_0800355e",
            "FUN_0800573c",
            "FUN_08003e54",
            "FUN_080056d4",
            "FUN_080033d8",
            "FUN_08002488",
            "FUN_08004788",
            "FUN_08004544",
            "FUN_08003cc8",
            "FUN_08000fb4",
            "FUN_08001bfc",
            "FUN_08002d72",
            "FUN_080007f0",
            "FUN_0800477e",
            "FUN_0800562a",
            "FUN_080044d8",
            "FUN_08003df4",
            "FUN_08005400",
            "FUN_08003582",
            "FUN_08004792",
            "FUN_08004678",
            "FUN_08003900",
            "FUN_08005768",
            "FUN_08000f0c",
            "FUN_08000998",
            "FUN_08003f94",
            "FUN_080056f8",
            "FUN_080054b4",
            "FUN_0800171a",
            "FUN_08004560",
            "FUN_08000a7a",
            "FUN_08004cb0",
            "FUN_08003594",
            "FUN_08002940",
            "FUN_08004204",
            "FUN_08003476",
            "FUN_08004444",
            "FUN_080055e0",
            "FUN_0800346c",
            "FUN_080053a0",
            "FUN_08003918",
            "FUN_080028d4",
            "FUN_08001460",
            "FUN_08004298",
            "FUN_08003880",
            "FUN_08003fd4",
            "FUN_08002f4c",
            "FUN_080035bc",
            "FUN_08000c4c",
            "FUN_080025ec",
            "FUN_080037fc",
            "FUN_08004a60",
            "FUN_080050d0",
            "FUN_08004978",
            "FUN_08002d0c",
            "FUN_0800404c",
            "FUN_08001904",
            "FUN_08000c64",
            "FUN_08002ffc",
            "FUN_0800387c",
            "FUN_0800351e",
            "FUN_08002f66",
            "FUN_080034b6",
            "FUN_08003eac",
            "FUN_08004064",
            "FUN_08003e18",
            "FUN_080040fc",
            "FUN_08002dd0",
            "FUN_08003414",
            "FUN_08005718",
            "FUN_080011c0",
            "FUN_080047f0",
            "FUN_0800502c",
            "FUN_08000b54",
            "FUN_0800376e",
            "FUN_08000d98",
            "FUN_08003f48",
            "FUN_0800340c",
            "FUN_0800352e",
            "FUN_0800582c",
            "FUN_08001ab0",
            "FUN_08001f9c",
            "FUN_08000d8c",
            "FUN_08005604",
            "FUN_080008cc",
            "FUN_08005608",
            "FUN_08002efa",
            "FUN_080058f0",
            "FUN_080056b4",
            "FUN_0800450a",
            "FUN_0800377c",
            "FUN_08003fec",
            "FUN_0800268e",
            "FUN_080008e2",
            "FUN_080045c8",
            "FUN_08003d18",
            "FUN_08004640",
            "FUN_08000c7c",
            "FUN_08004760",
            "FUN_080034ce",
            "FUN_08003798",
            "FUN_080047fe",
            "FUN_08005974",
            "FUN_08001256",
            "FUN_08004884",
            "FUN_08004648",
            "FUN_080045be",
            "FUN_0800407c",
            "FUN_08000728",
            "FUN_0800354a",
            "FUN_0800124a",
            "FUN_08004094",
            "FUN_080033c8",
            "FUN_080031fc",
            "FUN_08005580",
            "FUN_08000690",
            "FUN_08004254",
            "FUN_080054fc",
            "FUN_08001420",
            "FUN_08003840",
            "FUN_080026ce",
            "FUN_08001f3c",
            "FUN_08000218",
            "FUN_0800339c",
            "FUN_08003968",
            "FUN_08000e60",
            "FUN_0800165a",
            "FUN_080037d4",
            "FUN_08000b04",
            "FUN_0800262c",
            "FUN_080047a8",
            "FUN_08004388",
            "FUN_080051ac",
            "FUN_080052cc",
            "FUN_08002eb2",
            "FUN_08005478",
            "FUN_08000d3c",
            "FUN_08003854",
            "FUN_0800316c",
            "FUN_080040d0",
            "FUN_0800401c",
            "FUN_080040d6",
            "FUN_08004a34",
            "FUN_080002d0",
            "FUN_08003f00",
            "FUN_08004270",
            "FUN_080037e8",
            "FUN_08001440",
            "FUN_08000230",
            "FUN_080051bc",
            "FUN_08004034",
            "FUN_08000f8c",
            "FUN_08001684",
            "FUN_080001ac",
            "FUN_080040e0",
            "FUN_08003868",
            "FUN_080048cc",
            "FUN_080040e4",
            "FUN_08003506",
            "FUN_080025e0",
            "FUN_080040e8",
            "FUN_08000a00",
            "FUN_08005374",
            "FUN_08003750",
            "FUN_080014ec",
            "FUN_080048dc",
            "FUN_08003754",
            "FUN_08001578",
            "FUN_080035ac",
            "FUN_08004844",
            "FUN_0800318c",
            "FUN_080001d0",
            "FUN_080047d0",
            "FUN_080040f8",
            "FUN_0800500c",
            "FUN_080023b4",
            "FUN_080011a4",
            "FUN_08001e68",
            "FUN_080019a0",
            "FUN_08003f24",
            "FUN_080046b4",
            "FUN_0800160e",
            "FUN_08000e18",
            "FUN_08003486",
            "FUN_08005662",
            "FUN_080042ac",
            "FUN_08001864",
            "FUN_08000f2c",
            "FUN_08000ec4",
            "FUN_08004338",
            "FUN_08003928",
            "FUN_0800468c",
            "FUN_080005e0",
            "FUN_0800311c",
            "FUN_0800420c",
            "FUN_080005e4",
            "FUN_0800076c",
            "FUN_08004460",
            "FUN_08001198",
            "FUN_080044fc",
            "FUN_08003138",
            "FUN_08003810",
            "FUN_08002848",
            "FUN_08003938",
            "FUN_0800312c",
            "FUN_080028f0",
            "FUN_08000e30",
            "FUN_08000f56",
            "FUN_0800295c",
            "FUN_08003380",
            "FUN_08005686",
            "FUN_08004110",
            "FUN_08005320",
            "FUN_08000ee0",
            "FUN_080015bc",
            "FUN_08000f4e",
            "FUN_08003948",
            "FUN_0800458c",
            "FUN_0800066c",
            "FUN_080042e8",
            "FUN_080038d0",
            "FUN_0800410c",
            "FUN_0800260c",
            "FUN_08004240",
            "FUN_08005690",
            "FUN_080041bc",
            "FUN_08004364",
            "FUN_08004004",
            "FUN_08000e3c",
            "FUN_080037ac",
            "FUN_08002864",
            "FUN_0800459a",
            "FUN_08003958",
            "FUN_0800314e",
            "FUN_08004808",
            "FUN_08000f72",
            "FUN_08001d00",
            "FUN_080037c0",
            "FUN_0800382c"
        ],
        [
            "FUN_08004fdc",
            "FUN_08005760",
            "FUN_080055d0",
            "FUN_080040ec",
            "FUN_08004860",
            "FUN_08004622",
            "FUN_08000d8e",
            "FUN_08004638",
            "FUN_08000600",
            "FUN_08000de4",
            "FUN_080047c0",
            "FUN_08000682",
            "FUN_0800532c",
            "FUN_0800447c"
        ],
        [
            "FUN_080029c8",
            "FUN_0800201c",
            "FUN_08004a84",
            "FUN_08003978",
            "FUN_08004d9c",
            "FUN_08000300"
        ]
    ],
    "locked_functions": []
}