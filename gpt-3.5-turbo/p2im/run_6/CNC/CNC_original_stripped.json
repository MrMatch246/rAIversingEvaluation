{
    "functions": {
        "FUN_0800192c": {
            "renaming": {
                "FUN_0800192c": "check_limits_enabled_0800192c",
                "PTR_settings_08001954": "settings",
                "PTR_limits_enabled_08001958": "limits_enabled"
            },
            "code": "void check_limits_enabled_0800192c(void)\n{\n  if ((PTR_settings_08001954[0x28] & 8) == 0) {\n    *PTR_limits_enabled_08001958 = 0;\n  }\n  else {\n    *PTR_limits_enabled_08001958 = 1;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800192c",
            "calling": [
                "grbl_main",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "check_limits_enabled_0800192c"
        },
        "FUN_08006950": {
            "renaming": {
                "FUN_08006950": "set_priority_group_08006950",
                "PriorityGroup": "priority_group",
                "reg_value": "reg_value",
                "PriorityGroupTmp": "priority_group_tmp",
                "DAT_08006994": "DAT_08006994",
                "uint": "uint32_t",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void set_priority_group_08006950(uint32_t priority_group) {\n    uint32_t reg_value;\n    uint32_t priority_group_tmp;\n    uint32_t* ptr = (uint32_t*)(DAT_08006994 + 0xc);\n    uint32_t mask = 0xf8ff;\n    uint32_t shift = (priority_group & 7) << 8;\n    uint32_t value = 0x5fa0000;\n    *ptr = (*ptr & mask) | shift | value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006950",
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "imported": false,
            "current_name": "set_priority_group_08006950"
        },
        "FUN_08008ba0": {
            "renaming": {
                "FUN_08008ba0": "calculate_08008ba0",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result",
                "iVar2": "tempVar",
                "uVar3": "tempVar2"
            },
            "code": "uint calculate_08008ba0(uint input1, uint input2) {\n  uint result;\n  int tempVar;\n  uint tempVar2;\n  \n  tempVar = input2 * 2 + 0x200000;\n  if (input2 * 2 < 0xffe00000) {\n    if (-1 < tempVar) {\n      return 0;\n    }\n    tempVar2 = -tempVar >> 0x15;\n    tempVar2 = tempVar2 - 0x3e1;\n    if (tempVar2 != 0 && tempVar2 < 0xfffffc20) {\n      tempVar2 = (input2 << 0xb | 0x80000000 | input1 >> 0x15) >> (tempVar2 & 0xff);\n      if ((input2 & 0x80000000) != 0) {\n        tempVar2 = -tempVar2;\n      }\n      return tempVar2;\n    }\n  }\n  else if ((input1 | input2 << 0xc) != 0) {\n    return 0;\n  }\n  input2 = input2 & 0x80000000;\n  if (input2 == 0) {\n    input2 = 0x7fffffff;\n  }\n  return input2;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ba0",
            "calling": [
                "calculate_trapezoid_for_block",
                "lround",
                "__kernel_cos",
                "__ieee754_rem_pio2",
                "plan_buffer_line",
                "gc_execute_line",
                "__kernel_rem_pio2",
                "__kernel_sin"
            ],
            "imported": false,
            "current_name": "calculate_08008ba0"
        },
        "FUN_08005a5c": {
            "renaming": {
                "FUN_08005a5c": "do_nothing_08005a5c"
            },
            "code": "\nvoid do_nothing_08005a5c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a5c",
            "calling": [
                "HAL_DeInit"
            ],
            "imported": false,
            "current_name": "do_nothing_08005a5c"
        },
        "FUN_08005b90": {
            "renaming": {
                "FUN_08005b90": "clear_bit_at_position_08005b90",
                "DAT_08005ba8": "data_pointer",
                "PTR_": "ptr_",
                "uint": "uint32_t",
                "mask": "bit_mask"
            },
            "code": "void clear_bit_at_position_08005b90(void)\n{\n  uint32_t* ptr = (uint32_t*)(DAT_08005ba8 + 4);\n  uint32_t mask = 0xfffffffb;\n  *ptr &= mask;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b90",
            "calling": [],
            "imported": false,
            "current_name": "clear_bit_at_position_08005b90"
        },
        "FUN_080071d0": {
            "renaming": {
                "FUN_080071d0": "configure_GPIO_pin_080071d0",
                "GPIOx": "GPIO_port",
                "GPIO_Pin": "pin",
                "uVar1": "bit",
                "uVar2": "bit_in_pin",
                "tmp": "dat_position",
                "iocurrent": "dat_ptr",
                "ioposition": "dat_position_in_array",
                "position": "position",
                "DAT_08007308": "dat_08007308",
                "DAT_0800730c": "dat_0800730c"
            },
            "code": "void configure_GPIO_pin_080071d0(GPIO_TypeDef *GPIOx, uint32_t pin)\n{\n    uint32_t position;\n    for (position = 0; position < 16; position++) {\n        uint32_t bit = 1 << position;\n        if (pin & bit) {\n            uint32_t bit_position = position % 8;\n            GPIOx->MODER &= ~(3 << (bit_position * 2));\n            GPIOx->AFR[position / 8] &= ~(0xf << (bit_position * 4));\n            GPIOx->OSPEEDR &= ~(3 << (bit_position * 2));\n            GPIOx->OTYPER &= ~(1 << position);\n            GPIOx->PUPDR &= ~(3 << (bit_position * 2));\n            uint32_t dat_position = (position / 4) + 2;\n            uint32_t* dat_ptr = (uint32_t*) 0x08007308 + dat_position;\n            *dat_ptr &= ~(0xf << ((position % 4) * 4));\n            uint32_t* DAT_0800730c = (uint32_t*) 0x0800730c;\n            *DAT_0800730c = ~bit & *DAT_0800730c;\n            *(DAT_0800730c + 1) = ~bit & *(DAT_0800730c + 1);\n            *(DAT_0800730c + 2) = ~bit & *(DAT_0800730c + 2);\n            *(DAT_0800730c + 3) = ~bit & *(DAT_0800730c + 3);\n        }\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080071d0",
            "calling": [],
            "imported": false,
            "current_name": "configure_GPIO_pin_080071d0"
        },
        "FUN_08008e60": {
            "renaming": {
                "FUN_08008e60": "calculate_hash_08008e60",
                "param_1": "first_value",
                "param_2": "second_value",
                "uVar1": "result",
                "uVar2": "temp_first_value",
                "iVar3": "leading_zeroes_count",
                "uVar4": "shift_count",
                "iVar5": "mask",
                "uVar6": "temp_shifted_value",
                "count_leading_zeroes": "count_leading_zeroes",
                "DAT_5b000000": "mask",
                "DAT_4b000000": "mask",
                "0x800000": "0x800000",
                "0x18U": "0x18U",
                "0x20": "0x20",
                "0x1f": "0x1f",
                "0x7fffffff": "0x7fffffff",
                "0x80000000": "0x80000000"
            },
            "code": "uint calculate_hash_08008e60(uint first_value, uint second_value)\n{\n  uint result;\n  uint temp_first_value;\n  uint temp_second_value;\n  int leading_zeroes_count;\n  uint shift_count;\n  uint temp_shifted_value;\n  uint DAT_5b000000;\n  uint is_overflowed;\n\n  if ((first_value | second_value) == 0) {\n    return first_value;\n  }\n\n  temp_first_value = first_value;\n  temp_second_value = second_value;\n\n  if (second_value == 0) {\n    temp_first_value = 0;\n    temp_second_value = first_value;\n  }\n\n  DAT_5b000000 = 0x5b000000;\n\n  if (second_value == 0) {\n    DAT_5b000000 = 0x4b000000;\n  }\n\n  leading_zeroes_count = count_leading_zeroes(temp_second_value);\n  shift_count = leading_zeroes_count - 8;\n  DAT_5b000000 = DAT_5b000000 + (-0x800000 + shift_count * -0x800000);\n\n  if (leading_zeroes_count < 8) {\n    temp_shifted_value = temp_second_value << ((leading_zeroes_count + 0x18U) & 0xff);\n    result = DAT_5b000000 + ((temp_second_value >> (0x20 - (leading_zeroes_count + 0x18U) & 0xff)) - ((int)temp_shifted_value >> 0x1f));\n\n    if ((temp_first_value | temp_shifted_value << 1) == 0) {\n      result = result & ~(temp_shifted_value >> 0x1f);\n    }\n\n    return result;\n  }\n\n  temp_shifted_value = temp_first_value << (shift_count & 0xff);\n  is_overflowed = (uint)(0x7fffffff < temp_shifted_value);\n  result = DAT_5b000000 + (temp_second_value << (shift_count & 0xff)) + (temp_first_value >> (0x20 - shift_count & 0xff)) + is_overflowed;\n\n  if (temp_shifted_value == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e60",
            "calling": [],
            "imported": false,
            "current_name": "calculate_hash_08008e60"
        },
        "FUN_08005984": {
            "renaming": {
                "FUN_08005984": "getTicks_08005984",
                "ticks": "ticks",
                "uVar1": "result",
                "PTR_noHyperCall_080059b0": "PTR_noHyperCall_080059b0",
                "aflCall": "aflCall"
            },
            "code": "uint32_t getTicks_08005984(uint32_t ticks) { \n  uint32_t result; \n  if (*(int *)PTR_noHyperCall_080059b0 == 0) { \n    result = aflCall(1, ticks, 0); \n  } \n  else { \n    result = 0; \n  } \n  return result; \n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005984",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "getTicks_08005984"
        },
        "FUN_080082c8": {
            "renaming": {
                "FUN_080082c8": "calculate_double_precision_080082c8",
                "param_1": "x1",
                "param_2": "x2",
                "param_3": "y1",
                "param_4": "y2",
                "iVar1": "shift1",
                "iVar6": "shift2",
                "bVar2": "bit",
                "bVar13": "condition1",
                "bVar14": "condition2",
                "bVar15": "condition3",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar7": "x2_shifted",
                "uVar8": "x1_or_y1",
                "uVar9": "result_high",
                "uVar10": "shift_diff",
                "uVar11": "carry",
                "uVar12": "result_low"
            },
            "code": "\nulonglong calculate_double_precision_080082c8(uint x1,uint x2,uint y1,uint y2)\n\n{\n  int shift1;\n  byte bit;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shift2;\n  uint x2_shifted;\n  uint x1_or_y1;\n  uint result_high;\n  uint shift_diff;\n  uint carry;\n  uint result_low;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  \n  temp2 = x2 ^ 0x80000000;\n  x2_shifted = x2 << 1;\n  result_high = y2 << 1;\n  condition1 = ((temp2 ^ y2) & 0x7fffffff) == 0;\n  condition2 = condition1 && x1 == y1;\n  if (!condition1 || x1 != y1) {\n    condition2 = (x2_shifted | x1) == 0;\n  }\n  if (!condition2) {\n    condition2 = (result_high | y1) == 0;\n  }\n  shift2 = (int)x2_shifted >> 0x15;\n  if (!condition2) {\n    condition2 = shift2 == -1;\n  }\n  shift1 = (int)result_high >> 0x15;\n  if (!condition2) {\n    condition2 = shift1 == -1;\n  }\n  if (condition2) {\n    if (shift2 == -1 || shift1 == -1) {\n      result_high = y2;\n      x2_shifted = y1;\n      if (shift2 == -1) {\n        result_high = temp2;\n        x2_shifted = x1;\n      }\n      if (shift2 != -1 || shift1 != -1) {\n        y1 = x2_shifted;\n        y2 = result_high;\n      }\n      condition2 = (x2_shifted | result_high << 0xc) == 0;\n      if (condition2) {\n        condition2 = (y1 | y2 << 0xc) == 0;\n      }\n      if (condition2) {\n        condition2 = result_high == y2;\n      }\n      if (!condition2) {\n        result_high = result_high | 0x80000;\n      }\n      return CONCAT44(result_high,x2_shifted);\n    }\n    if (((temp2 ^ y2) & 0x7fffffff) != 0 || x1 != y1) {\n      if ((x2_shifted | x1) == 0) {\n        x1 = y1;\n        temp2 = y2;\n      }\n      return CONCAT44(temp2,x1);\n    }\n    if (temp2 != y2) {\n      return 0;\n    }\n    if (x2_shifted >> 0x15 == 0) {\n      condition2 = (x1 & 0x80000000) != 0;\n      result_high = x2 * 2 + (uint)condition2;\n      if (CARRY4(temp2,temp2) || CARRY4(x2 * 2,(uint)condition2)) {\n        result_high = result_high | 0x80000000;\n      }\n      return CONCAT44(result_high,x1 << 1);\n    }\n    if (x2_shifted < 0xffc00000) {\n      return CONCAT44(temp2 + 0x100000,x1);\n    }\n    temp2 = temp2 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(temp2 | 0x7ff00000) << 0x20;\n  }\n  x2_shifted = x2_shifted >> 0x15;\n  result_high = result_high >> 0x15;\n  shift_diff = result_high - x2_shifted;\n  condition2 = shift_diff != 0;\n  if (result_high < x2_shifted) {\n    shift_diff = -shift_diff;\n  }\n  x1_or_y1 = x1;\n  result_low = temp2;\n  if (condition2 && x2_shifted <= result_high) {\n    x2_shifted = x2_shifted + shift_diff;\n    x1_or_y1 = y1;\n    result_low = y2;\n    y1 = x1;\n    y2 = temp2;\n  }\n  if (0x36 < shift_diff) {\n    return CONCAT44(result_low,x1_or_y1);\n  }\n  result_high = result_low & 0xfffff | 0x100000;\n  if ((result_low & 0x80000000) != 0) {\n    condition2 = x1_or_y1 != 0;\n    x1_or_y1 = -x1_or_y1;\n    result_high = -result_high - (uint)condition2;\n  }\n  temp2 = y2 & 0xfffff | 0x100000;\n  if ((y2 & 0x80000000) != 0) {\n    condition2 = y1 != 0;\n    y1 = -y1;\n    temp2 = -temp2 - (uint)condition2;\n  }\n  if (x2_shifted == shift_diff) {\n    temp2 = temp2 ^ 0x100000;\n    if (x2_shifted == 0) {\n      result_high = result_high ^ 0x100000;\n      x2_shifted = 1;\n    }\n    else {\n      shift_diff = shift_diff - 1;\n    }\n  }\n  result_low = -shift_diff + 0x20;\n  if ((int)shift_diff < 0x21) {\n    carry = y1 << (result_low & 0xff);\n    y1 = y1 >> (shift_diff & 0xff);\n    temp1 = x1_or_y1 + y1;\n    temp3 = temp2 << (result_low & 0xff);\n    result_low = temp1 + temp3;\n    result_high = result_high + CARRY4(x1_or_y1,y1) + ((int)temp2 >> (shift_diff & 0xff)) +\n            (uint)CARRY4(temp1,temp3);\n  }\n  else {\n    carry = temp2 << (-shift_diff + 0x40 & 0xff);\n    if (y1 != 0) {\n      carry = carry | 2;\n    }\n    temp2 = (int)temp2 >> (shift_diff - 0x20 & 0xff);\n    result_low = x1_or_y1 + temp2;\n    result_high = result_high + ((int)temp2 >> 0x1f) + (uint)CARRY4(x1_or_y1,temp2);\n  }\n  temp2 = result_high & 0x80000000;\n  shift_diff = result_high;\n  if ((int)result_high < 0) {\n    condition2 = carry == 0;\n    carry = -carry;\n    shift_diff = -result_low;\n    result_low = -(uint)!condition2 - result_low;\n    shift_diff = -(uint)(condition2 <= shift_diff) - result_high;\n  }\n  if (0xfffff < shift_diff) {\n    x1_or_y1 = x2_shifted - 1;\n    if (0x1fffff < shift_diff) {\n      result_high = shift_diff & 1;\n      shift_diff = shift_diff >> 1;\n      bit = (byte)result_low;\n      result_low = (uint)(result_high != 0) << 0x1f | result_low >> 1;\n      carry = (uint)(bit & 1) << 0x1f | carry >> 1;\n      x1_or_y1 = x2_shifted;\n      if (0xffbfffff < x2_shifted * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    condition2 = 0x7fffffff < carry;\n    if (carry == 0x80000000) {\n      condition2 = (result_low & 1) != 0;\n    }\n    return CONCAT44(shift_diff + x1_or_y1 * 0x100000 + (uint)CARRY4(result_low,(uint)condition2) | temp2,\n                    result_low + condition2);\n  }\n  condition1 = (carry & 0x80000000) != 0;\n  carry = carry << 1;\n  x1_or_y1 = result_low * 2;\n  condition2 = CARRY4(result_low,result_low);\n  result_low = result_low * 2 + (uint)condition1;\n  shift_diff = shift_diff * 2 + (uint)(condition2 || CARRY4(x1_or_y1,(uint)condition1));\n  x1_or_y1 = x2_shifted - 2;\n  if (x2_shifted - 1 != 0 && 0xfffff < shift_diff) goto LAB_080083e0;\n  temp1 = result_low;\n  x2_shifted = shift_diff;\n  if (shift_diff == 0) {\n    temp1 = 0;\n    x2_shifted = result_low;\n  }\n  shift2 = count_leading_zeroes(x2_shifted);\n  if (shift_diff == 0) {\n    shift2 = shift2 + 0x20;\n  }\n  result_low = shift2 - 0xb;\n  condition3 = SBORROW4(result_low,0x20);\n  shift_diff = shift2 - 0x2b;\n  condition2 = (int)shift_diff < 0;\n  condition1 = shift_diff == 0;\n  if ((int)result_low < 0x20) {\n    condition3 = SCARRY4(shift_diff,0xc);\n    shift2 = shift2 + -0x1f;\n    condition2 = shift2 < 0;\n    condition1 = shift2 == 0;\n    shift_diff = result_low;\n    if (!condition1 && condition2 == condition3) {\n      temp1 = x2_shifted << (result_low & 0xff);\n      x2_shifted = x2_shifted >> (0xcU - shift2 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (condition1 || condition2 != condition3) {\n    carry = 0x20 - shift_diff;\n  }\n  x2_shifted = x2_shifted << (shift_diff & 0xff);\n  if (condition1 || condition2 != condition3) {\n    x2_shifted = x2_shifted | temp1 >> (carry & 0xff);\n  }\n  if (condition1 || condition2 != condition3) {\n    temp1 = temp1 << (shift_diff & 0xff);\n  }\nLAB_08008458:\n  if ((int)result_low <= (int)x1_or_y1) {\n    return CONCAT44(x2_shifted + (x1_or_y1 - result_low) * 0x100000 | temp2,temp1);\n  }\n  shift_diff = ~(x1_or_y1 - result_low);\n  if ((int)shift_diff < 0x1f) {\n    shift2 = shift_diff - 0x13;\n    if (shift2 != 0 && shift2 < 0 == SCARRY4(shift_diff - 0x1f,0xc)) {\n      return CONCAT44(result_high,temp1 >> (0x20 - (0xcU - shift2) & 0xff) | x2_shifted << (0xcU - shift2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shift_diff = shift_diff + 1;\n    return CONCAT44(temp2 | x2_shifted >> (shift_diff & 0xff),\n                    temp1 >> (shift_diff & 0xff) | x2_shifted << (0x20 - shift_diff & 0xff));\n  }\n  return CONCAT44(result_high,x2_shifted >> (shift_diff - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080082c8",
            "calling": [],
            "imported": false,
            "current_name": "calculate_double_precision_080082c8"
        },
        "FUN_08006718": {
            "renaming": {
                "FUN_08006718": "initialize_RCC_Oscillator_08006718",
                "RCC_OscInitStruct": "RCC_OscInitStruct",
                "*DAT_080068b8": "oscillator_config",
                "count_leading_zeroes": "RCC_count_leading_zeroes",
                "RCC_PLLSOURCE_MASK": "0x00400000",
                "RCC_PLLM_MASK": "0x0000003F",
                "RCC_PLLN_MASK": "0x00007FC0",
                "RCC_PLLP_MASK": "0x00030000",
                "RCC_PLLQ_MASK": "0x0F000000",
                "RCC_PLLSOURCE_SHIFT": "22",
                "RCC_PLLN_SHIFT": "6",
                "RCC_PLLP_OFFSET": "0x10000",
                "RCC_PLLQ_SHIFT": "24",
                "RCC_OSCILLATORTYPE_HSE_BYPASS": "0x40000",
                "RCC_OSCILLATORTYPE_HSE": "0x100000",
                "RCC_OSCILLATORTYPE_HSI": "0x1",
                "RCC_HSICAL_CALIBRATION_MASK": "0x000000F8",
                "RCC_HSICAL_CALIBRATION_SHIFT": "3",
                "RCC_OSCILLATORTYPE_LSE_BYPASS": "0x4",
                "RCC_OSCILLATORTYPE_LSE": "0x20000",
                "RCC_LSE_BYPASS": "0x4",
                "RCC_LSE_ON": "0x1",
                "RCC_LSI_ON": "0x1",
                "RCC_PLL_ON": "0x1000000",
                "RCC_PLL_OFF": "0x2",
                "RCC_HSE_ON": "0x1",
                "RCC_HSE_BYPASS": "0x5",
                "RCC_HSE_OFF": "0x0",
                "RCC_HSI_ON": "0x1",
                "RCC_HSI_OFF": "0x0",
                "RCC_LSE_OFF": "0x0",
                "RCC_LSI_OFF": "0x0"
            },
            "code": "void initialize_RCC_Oscillator_08006718(RCC_OscInitTypeDef *RCC_OscInitStruct) {\n    uint32_t *DAT_080068b8 = *DAT_080068b8;\n    RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;\n    \n    if ((*DAT_080068b8 & RCC_OSCILLATORTYPE_HSE_BYPASS) == RCC_OSCILLATORTYPE_HSE_BYPASS) {\n        RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;\n    }\n    else if ((*DAT_080068b8 & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE) {\n        RCC_OscInitStruct->HSEState = RCC_HSE_ON;\n    }\n    else {\n        RCC_OscInitStruct->HSEState = RCC_HSE_OFF;\n    }\n    \n    if ((*DAT_080068b8 & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI) {\n        RCC_OscInitStruct->HSIState = RCC_HSI_ON;\n    }\n    else {\n        RCC_OscInitStruct->HSIState = RCC_HSI_OFF;\n    }\n    \n    uint32_t hsi_calibration_value = (*DAT_080068b8 & RCC_HSICAL_CALIBRATION_MASK) >> RCC_HSICAL_CALIBRATION_SHIFT;\n    RCC_OscInitStruct->HSICalibrationValue = hsi_calibration_value;\n    \n    if ((DAT_080068b8[0x1c] & RCC_LSE_BYPASS) == RCC_LSE_BYPASS) {\n        RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;\n    }\n    else if ((DAT_080068b8[0x1c] & RCC_LSE_ON) == RCC_LSE_ON) {\n        RCC_OscInitStruct->LSEState = RCC_LSE_ON;\n    }\n    else {\n        RCC_OscInitStruct->LSEState = RCC_LSE_OFF;\n    }\n    \n    if ((DAT_080068b8[0x1d] & RCC_LSI_ON) == RCC_LSI_ON) {\n        RCC_OscInitStruct->LSIState = RCC_LSI_ON;\n    }\n    else {\n        RCC_OscInitStruct->LSIState = RCC_LSI_OFF;\n    }\n    \n    if ((*DAT_080068b8 & RCC_PLL_ON) == RCC_PLL_ON) {\n        RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;\n    }\n    else {\n        RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;\n    }\n    \n    RCC_OscInitStruct->PLL.PLLSource = (DAT_080068b8[1] & RCC_PLLSOURCE_MASK) >> RCC_PLLSOURCE_SHIFT;\n    RCC_OscInitStruct->PLL.PLLM = DAT_080068b8[1] & RCC_PLLM_MASK;\n    RCC_OscInitStruct->PLL.PLLN = (DAT_080068b8[1] & RCC_PLLN_MASK) >> RCC_PLLN_SHIFT;\n    RCC_OscInitStruct->PLL.PLLP = ((DAT_080068b8[1] & RCC_PLLP_MASK) + RCC_PLLP_OFFSET) * 2;\n    RCC_OscInitStruct->PLL.PLLQ = (DAT_080068b8[1] & RCC_PLLQ_MASK) >> RCC_PLLQ_SHIFT;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006718",
            "calling": [],
            "imported": false,
            "current_name": "initialize_RCC_Oscillator_08006718"
        },
        "FUN_08007a10": {
            "renaming": {
                "FUN_08007a10": "set_timer_flag_08007a10",
                "tim": "timer",
                "DAT_40000000": "timer1",
                "DAT_08007a68": "timer2",
                "DAT_08007a6c": "timer3",
                "uint": "unsigned int",
                "DAT_08007a64": "flag_address"
            },
            "code": "void set_timer_flag_08007a10(TIM_TypeDef *timer) {\n  if (timer == (TIM_TypeDef *)&DAT_40000000) {\n    *(uint *)(DAT_08007a64 + 0x40) |= 1;\n  }\n  else if (timer == DAT_08007a68) {\n    *(uint *)(DAT_08007a64 + 0x40) |= 2;\n  }\n  else if (timer == DAT_08007a6c) {\n    *(uint *)(DAT_08007a64 + 0x40) |= 4;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007a10",
            "calling": [
                "g540_timer_init",
                "step_timer_init"
            ],
            "imported": false,
            "current_name": "set_timer_flag_08007a10"
        },
        "FUN_0800856c": {
            "renaming": {
                "FUN_0800856c": "reverse_and_shift_bits_0800856c",
                "param_1": "input_value",
                "uVar1": "shifted_value1",
                "uVar2": "abs_input_value",
                "uVar3": "shift_amount",
                "iVar4": "leading_zeroes",
                "uVar5": "shift_amount2",
                "uVar6": "is_negative",
                "in_r12": "mask",
                "bVar7": "is_shift_negative",
                "bVar8": "is_shift_zero",
                "bVar9": "is_carry_set"
            },
            "code": "ulonglong reverse_and_shift_bits_0800856c(uint input_value)\n{\n    uint abs_input_value = input_value & 0x7fffffff;\n    if (abs_input_value == 0) {\n        return 0;\n    }\n    uint leading_zeroes = count_leading_zeroes(abs_input_value);\n    uint shift_amount = leading_zeroes + 21;\n    bool is_shift_negative = shift_amount < 0;\n    bool is_shift_zero = shift_amount == 0;\n    if (shift_amount < 32) {\n        shift_amount = is_shift_negative || is_shift_zero ? 0 : shift_amount;\n        uint shifted_value1 = abs_input_value << (shift_amount & 0xff);\n        uint shifted_value2 = abs_input_value >> ((0x1c - leading_zeroes) & 0xff);\n        return ((ulonglong)shifted_value1 << 32) | shifted_value2;\n    }\n    else if (shift_amount < 1075) {\n        uint mask = is_shift_negative || is_shift_zero ? 0 : ~(0x1f - (shift_amount - 32));\n        uint shifted_value = abs_input_value << (shift_amount & 0xff);\n        return ((ulonglong)shifted_value << 32) | (0U >> (mask & 0xff));\n    }\n    else {\n        uint shift_amount2 = ~(shift_amount - 1074);\n        if (shift_amount2 > 30) {\n            return ((ulonglong)input_value) & 0x80000000ffffffff;\n        }\n        else {\n            uint shifted_value1 = input_value >> (shift_amount2 & 0xff);\n            uint shifted_value2 = input_value << ((0x20 - shift_amount2) & 0xff);\n            return ((ulonglong)shifted_value1 << 32) | shifted_value2;\n        }\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800856c",
            "calling": [
                "calculate_trapezoid_for_block",
                "__ieee754_rem_pio2",
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "reverse_and_shift_bits_0800856c"
        },
        "FUN_08008b00": {
            "renaming": {
                "FUN_08008b00": "convert_double_to_float_08008b00",
                "param_1": "float_value"
            },
            "code": "undefined4 convert_double_to_float_08008b00(undefined4 float_value)\n{\n  __nedf2();\n  return float_value;\n}",
            "called": [
                "__nedf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b00",
            "calling": [
                "__aeabi_dcmplt",
                "__aeabi_cdrcmple",
                "__aeabi_dcmpeq",
                "__aeabi_dcmple"
            ],
            "imported": false,
            "current_name": "convert_double_to_float_08008b00"
        },
        "FUN_0800585c": {
            "renaming": {
                "FUN_0800585c": "wake_up_if_asleep_0800585c",
                "PTR_sys_08005878": "PTR_sys_status"
            },
            "code": "void wake_up_if_asleep_0800585c(void)\n{\n  if (PTR_sys_08005878[1] == '\\x02') {\n    PTR_sys_08005878[1] = 3;\n    st_wake_up();\n  }\n  return;\n}",
            "called": [
                "st_wake_up"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800585c",
            "calling": [
                "mc_go_home",
                "protocol_execute_runtime",
                "mc_line"
            ],
            "imported": false,
            "current_name": "wake_up_if_asleep_0800585c"
        },
        "FUN_08008cd0": {
            "renaming": {
                "FUN_08008cd0": "calculate_float_08008cd0",
                "param_1": "float_bits_a",
                "param_2": "float_bits_b",
                "param_3": "unused",
                "param_4": "unused_2",
                "iVar1": "exponent_diff",
                "uVar2": "sign_and_mantissa_a",
                "uVar3": "sign_and_mantissa_b",
                "uVar4": "result_sign_and_mantissa",
                "uVar5": "shift_amount",
                "uVar6": "shifted_mantissa_diff",
                "iVar7": "exponent_a",
                "bVar8": "comparison_result"
            },
            "code": "\nuint calculate_float_08008cd0(uint float_bits_a,uint float_bits_b,undefined4 unused,uint unused_2)\n\n{\n  int exponent_diff;\n  uint sign_and_mantissa_a;\n  uint sign_and_mantissa_b;\n  uint result_sign_and_mantissa;\n  uint shift_amount;\n  uint shifted_mantissa_diff;\n  int exponent_a;\n  bool comparison_result;\n  \n  sign_and_mantissa_a = float_bits_a ^ 0x80000000;\n  result_sign_and_mantissa = float_bits_a << 1;\n  comparison_result = result_sign_and_mantissa == 0;\n  if (!comparison_result) {\n    unused_2 = float_bits_b << 1;\n    comparison_result = unused_2 == 0;\n  }\n  if (!comparison_result) {\n    comparison_result = result_sign_and_mantissa == unused_2;\n  }\n  exponent_a = (int)result_sign_and_mantissa >> 0x18;\n  if (!comparison_result) {\n    comparison_result = exponent_a == -1;\n  }\n  if (!comparison_result) {\n    comparison_result = (int)unused_2 >> 0x18 == -1;\n  }\n  if (comparison_result) {\n    exponent_diff = (int)(float_bits_b << 1) >> 0x18;\n    if (exponent_a == -1 || exponent_diff == -1) {\n      result_sign_and_mantissa = float_bits_b;\n      if (exponent_a == -1) {\n        result_sign_and_mantissa = sign_and_mantissa_a;\n      }\n      if (exponent_a != -1 || exponent_diff != -1) {\n        float_bits_b = result_sign_and_mantissa;\n      }\n      comparison_result = (result_sign_and_mantissa & 0x7fffff) == 0;\n      if (comparison_result) {\n        comparison_result = (float_bits_b & 0x7fffff) == 0;\n      }\n      if (comparison_result) {\n        comparison_result = result_sign_and_mantissa == float_bits_b;\n      }\n      if (!comparison_result) {\n        result_sign_and_mantissa = result_sign_and_mantissa | 0x400000;\n      }\n      return result_sign_and_mantissa;\n    }\n    if (((float_bits_a ^ float_bits_b) & 0x7fffffff) != 0) {\n      if (result_sign_and_mantissa == 0) {\n        sign_and_mantissa_a = float_bits_b;\n      }\n      return sign_and_mantissa_a;\n    }\n    if (sign_and_mantissa_a != float_bits_b) {\n      return 0;\n    }\n    if ((result_sign_and_mantissa & 0xff000000) == 0) {\n      float_bits_a = float_bits_a << 1;\n      if ((sign_and_mantissa_a & 0x80000000) != 0) {\n        float_bits_a = float_bits_a | 0x80000000;\n      }\n      return float_bits_a;\n    }\n    if (result_sign_and_mantissa < 0xfe000000) {\n      return sign_and_mantissa_a + 0x800000;\n    }\n    sign_and_mantissa_a = sign_and_mantissa_a & 0x80000000;\nLAB_08008e12:\n    return sign_and_mantissa_a | 0x7f800000;\n  }\n  result_sign_and_mantissa = result_sign_and_mantissa >> 0x18;\n  unused_2 = unused_2 >> 0x18;\n  shifted_mantissa_diff = unused_2 - result_sign_and_mantissa;\n  comparison_result = shifted_mantissa_diff != 0;\n  shift_amount = result_sign_and_mantissa;\n  if (comparison_result && result_sign_and_mantissa <= unused_2) {\n    shift_amount = result_sign_and_mantissa + shifted_mantissa_diff;\n  }\n  if (comparison_result && result_sign_and_mantissa <= unused_2) {\n    float_bits_b = float_bits_b ^ sign_and_mantissa_a;\n  }\n  if (comparison_result && result_sign_and_mantissa <= unused_2) {\n    sign_and_mantissa_a = sign_and_mantissa_a ^ float_bits_b;\n  }\n  if (comparison_result && result_sign_and_mantissa <= unused_2) {\n    float_bits_b = float_bits_b ^ sign_and_mantissa_a;\n  }\n  if (unused_2 < result_sign_and_mantissa) {\n    shifted_mantissa_diff = -shifted_mantissa_diff;\n  }\n  if (0x19 < shifted_mantissa_diff) {\n    return sign_and_mantissa_a;\n  }\n  result_sign_and_mantissa = sign_and_mantissa_a & 0xffffff | 0x800000;\n  if ((sign_and_mantissa_a & 0x80000000) != 0) {\n    result_sign_and_mantissa = -result_sign_and_mantissa;\n  }\n  sign_and_mantissa_b = float_bits_b & 0xffffff | 0x800000;\n  if ((float_bits_b & 0x80000000) != 0) {\n    sign_and_mantissa_b = -sign_and_mantissa_b;\n  }\n  if (shift_amount == shifted_mantissa_diff) {\n    sign_and_mantissa_b = sign_and_mantissa_b ^ 0x800000;\n    if (shift_amount == 0) {\n      result_sign_and_mantissa = result_sign_and_mantissa ^ 0x800000;\n      shift_amount = 1;\n    }\n    else {\n      shifted_mantissa_diff = shifted_mantissa_diff - 1;\n    }\n  }\n  result_sign_and_mantissa = result_sign_and_mantissa + ((int)sign_and_mantissa_b >> (shifted_mantissa_diff & 0xff));\n  sign_and_mantissa_b = sign_and_mantissa_b << (0x20 - shifted_mantissa_diff & 0xff);\n  sign_and_mantissa_a = result_sign_and_mantissa & 0x80000000;\n  if ((int)result_sign_and_mantissa < 0) {\n    comparison_result = sign_and_mantissa_b != 0;\n    sign_and_mantissa_b = -sign_and_mantissa_b;\n    result_sign_and_mantissa = -result_sign_and_mantissa - (uint)comparison_result;\n  }\n  if (result_sign_and_mantissa < 0x800000) {\n    shifted_mantissa_diff = sign_and_mantissa_b & 0x80000000;\n    sign_and_mantissa_b = sign_and_mantissa_b << 1;\n    result_sign_and_mantissa = result_sign_and_mantissa * 2 + (uint)(shifted_mantissa_diff != 0);\n    shifted_mantissa_diff = shift_amount - 2;\n    if (shift_amount - 1 == 0 || result_sign_and_mantissa < 0x800000) {\n      exponent_a = count_leading_zeroes(result_sign_and_mantissa);\n      shift_amount = exponent_a - 8;\n      result_sign_and_mantissa = result_sign_and_mantissa << (shift_amount & 0xff);\n      if ((int)shifted_mantissa_diff < (int)shift_amount) {\n        result_sign_and_mantissa = result_sign_and_mantissa >> (-(shifted_mantissa_diff - shift_amount) & 0xff);\n      }\n      else {\n        result_sign_and_mantissa = result_sign_and_mantissa + (shifted_mantissa_diff - shift_amount) * 0x800000;\n      }\n      return result_sign_and_mantissa | sign_and_mantissa_a;\n    }\n  }\n  else {\n    shifted_mantissa_diff = shift_amount - 1;\n    if (0xffffff < result_sign_and_mantissa) {\n      shifted_mantissa_diff = result_sign_and_mantissa & 1;\n      result_sign_and_mantissa = result_sign_and_mantissa >> 1;\n      sign_and_mantissa_b = (uint)(shifted_mantissa_diff != 0) << 0x1f | sign_and_mantissa_b >> 1;\n      shifted_mantissa_diff = shift_amount;\n      if (0xfd < shift_amount) goto LAB_08008e12;\n    }\n  }\n  result_sign_and_mantissa = result_sign_and_mantissa + shifted_mantissa_diff * 0x800000 + (uint)(0x7fffffff < sign_and_mantissa_b);\n  if (sign_and_mantissa_b == 0x80000000) {\n    result_sign_and_mantissa = result_sign_and_mantissa & 0xfffffffe;\n  }\n  return result_sign_and_mantissa | sign_and_mantissa_a;\n}\n\n",
            "called": [
                "__addsf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008cd0",
            "calling": [],
            "imported": false,
            "current_name": "calculate_float_08008cd0"
        },
        "FUN_0800597c": {
            "renaming": {
                "FUN_0800597c": "read_hardware_0800597c",
                "a0": "hardware_address",
                "a1": "data",
                "a2": "error_code",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "uint32_t read_hardware_0800597c(uint32_t hardware_address, uint32_t data, int32_t error_code)\n{\n  software_interrupt(HARDWARE_READ);\n  return hardware_address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800597c",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "read_hardware_0800597c"
        },
        "FUN_08009314": {
            "renaming": {
                "FUN_08009314": "wait_forever_08009314"
            },
            "code": "void wait_forever_08009314(void)\n{\n  while( true )\n  {\n    // Do nothing, just wait forever\n  }\n}",
            "called": [
                "DMA1_Stream3_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009314",
            "calling": [
                "DMA1_Stream3_IRQHandler"
            ],
            "imported": false,
            "current_name": "wait_forever_08009314"
        },
        "FUN_08009798": {
            "renaming": {
                "FUN_08009798": "calculate_double_from_integer_08009798",
                "__x": "input_integer",
                "in_r1": "shifted_integer",
                "iVar1": "shifted_integer",
                "in_d0": "result"
            },
            "code": "double calculate_double_from_integer_08009798(int input_integer) {\n  int shifted_integer = ((uint)(input_integer << 1) >> 0x15) - 0x3ff;\n  if (shifted_integer < 0x14) {\n    if (shifted_integer < 0) {\n      return 0.0;\n    }\n  }\n  else {\n    if (shifted_integer < 0x34) {\n      return 0.0;\n    }\n    if (shifted_integer != 0x400) {\n      return 0.0;\n    }\n    double result = (double)__aeabi_dadd();\n    return result;\n  }\n  return 0.0;\n}",
            "called": [
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009798",
            "calling": [
                "protocol_execute_line",
                "gc_execute_line",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "calculate_double_from_integer_08009798"
        },
        "FUN_08008cd8": {
            "renaming": {
                "FUN_08008cd8": "calculate_float_08008cd8",
                "param_1": "float_bits_1",
                "param_2": "float_bits_2",
                "param_3": "shift_value",
                "param_4": "exponent_mask",
                "iVar1": "exponent_bits",
                "uVar2": "normalized_1",
                "uVar3": "normalized_2",
                "uVar4": "mantissa_1",
                "uVar5": "shifted_exponent",
                "uVar6": "difference",
                "iVar7": "exponent_bits_2",
                "bVar8": "is_equal"
            },
            "code": "\nuint calculate_float_08008cd8(uint float_bits_1,uint float_bits_2,undefined4 shift_value,uint exponent_mask)\n\n{\n  int exponent_bits;\n  uint normalized_1;\n  uint normalized_2;\n  uint mantissa_1;\n  uint shifted_exponent;\n  uint difference;\n  int exponent_bits_2;\n  bool is_equal;\n  \n  normalized_1 = float_bits_2 ^ 0x80000000;\n  mantissa_1 = float_bits_1 << 1;\n  is_equal = mantissa_1 == 0;\n  if (!is_equal) {\n    exponent_mask = float_bits_2 << 1;\n    is_equal = exponent_mask == 0;\n  }\n  if (!is_equal) {\n    is_equal = mantissa_1 == exponent_mask;\n  }\n  exponent_bits_2 = (int)mantissa_1 >> 0x18;\n  if (!is_equal) {\n    is_equal = exponent_bits_2 == -1;\n  }\n  if (!is_equal) {\n    is_equal = (int)exponent_mask >> 0x18 == -1;\n  }\n  if (is_equal) {\n    exponent_bits = (int)(float_bits_2 << 1) >> 0x18;\n    if (exponent_bits_2 == -1 || exponent_bits == -1) {\n      mantissa_1 = normalized_1;\n      if (exponent_bits_2 == -1) {\n        mantissa_1 = float_bits_1;\n      }\n      if (exponent_bits_2 != -1 || exponent_bits != -1) {\n        normalized_1 = mantissa_1;\n      }\n      is_equal = (mantissa_1 & 0x7fffff) == 0;\n      if (is_equal) {\n        is_equal = (normalized_1 & 0x7fffff) == 0;\n      }\n      if (is_equal) {\n        is_equal = mantissa_1 == normalized_1;\n      }\n      if (!is_equal) {\n        mantissa_1 = mantissa_1 | 0x400000;\n      }\n      return mantissa_1;\n    }\n    if (((float_bits_1 ^ normalized_1) & 0x7fffffff) != 0) {\n      if (mantissa_1 == 0) {\n        float_bits_1 = normalized_1;\n      }\n      return float_bits_1;\n    }\n    if (float_bits_1 != normalized_1) {\n      return 0;\n    }\n    if ((mantissa_1 & 0xff000000) == 0) {\n      normalized_1 = float_bits_1 << 1;\n      if ((float_bits_1 & 0x80000000) != 0) {\n        normalized_1 = normalized_1 | 0x80000000;\n      }\n      return normalized_1;\n    }\n    if (mantissa_1 < 0xfe000000) {\n      return float_bits_1 + 0x800000;\n    }\n    float_bits_1 = float_bits_1 & 0x80000000;\nLAB_08008e12:\n    return float_bits_1 | 0x7f800000;\n  }\n  mantissa_1 = mantissa_1 >> 0x18;\n  exponent_mask = exponent_mask >> 0x18;\n  difference = exponent_mask - mantissa_1;\n  is_equal = difference != 0;\n  shifted_exponent = mantissa_1;\n  if (is_equal && mantissa_1 <= exponent_mask) {\n    shifted_exponent = mantissa_1 + difference;\n  }\n  if (is_equal && mantissa_1 <= exponent_mask) {\n    normalized_1 = normalized_1 ^ float_bits_1;\n  }\n  if (is_equal && mantissa_1 <= exponent_mask) {\n    float_bits_1 = float_bits_1 ^ normalized_1;\n  }\n  if (is_equal && mantissa_1 <= exponent_mask) {\n    normalized_1 = normalized_1 ^ float_bits_1;\n  }\n  if (exponent_mask < mantissa_1) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return float_bits_1;\n  }\n  mantissa_1 = float_bits_1 & 0xffffff | 0x800000;\n  if ((float_bits_1 & 0x80000000) != 0) {\n    mantissa_1 = -mantissa_1;\n  }\n  normalized_2 = normalized_1 & 0xffffff | 0x800000;\n  if ((normalized_1 & 0x80000000) != 0) {\n    normalized_2 = -normalized_2;\n  }\n  if (shifted_exponent == difference) {\n    normalized_2 = normalized_2 ^ 0x800000;\n    if (shifted_exponent == 0) {\n      mantissa_1 = mantissa_1 ^ 0x800000;\n      shifted_exponent = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  mantissa_1 = mantissa_1 + ((int)normalized_2 >> (difference & 0xff));\n  normalized_2 = normalized_2 << (0x20 - difference & 0xff);\n  float_bits_1 = mantissa_1 & 0x80000000;\n  if ((int)mantissa_1 < 0) {\n    is_equal = normalized_2 != 0;\n    normalized_2 = -normalized_2;\n    mantissa_1 = -mantissa_1 - (uint)is_equal;\n  }\n  if (mantissa_1 < 0x800000) {\n    normalized_1 = normalized_2 & 0x80000000;\n    normalized_2 = normalized_2 << 1;\n    mantissa_1 = mantissa_1 * 2 + (uint)(normalized_1 != 0);\n    normalized_1 = shifted_exponent - 2;\n    if (shifted_exponent - 1 == 0 || mantissa_1 < 0x800000) {\n      exponent_bits_2 = count_leading_zeroes(mantissa_1);\n      difference = exponent_bits_2 - 8;\n      mantissa_1 = mantissa_1 << (difference & 0xff);\n      if ((int)normalized_1 < (int)difference) {\n        mantissa_1 = mantissa_1 >> (-(normalized_1 - difference) & 0xff);\n      }\n      else {\n        mantissa_1 = mantissa_1 + (normalized_1 - difference) * 0x800000;\n      }\n      return mantissa_1 | float_bits_1;\n    }\n  }\n  else {\n    normalized_1 = shifted_exponent - 1;\n    if (0xffffff < mantissa_1) {\n      normalized_1 = mantissa_1 & 1;\n      mantissa_1 = mantissa_1 >> 1;\n      normalized_2 = (uint)(normalized_1 != 0) << 0x1f | normalized_2 >> 1;\n      normalized_1 = shifted_exponent;\n      if (0xfd < shifted_exponent) goto LAB_08008e12;\n    }\n  }\n  mantissa_1 = mantissa_1 + normalized_1 * 0x800000 + (uint)(0x7fffffff < normalized_2);\n  if (normalized_2 == 0x80000000) {\n    mantissa_1 = mantissa_1 & 0xfffffffe;\n  }\n  return mantissa_1 | float_bits_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008cd8",
            "calling": [
                "intersection_distance",
                "report_realtime_status",
                "mc_arc",
                "plan_buffer_line",
                "mc_dwell",
                "max_allowable_speed",
                "gc_execute_line",
                "estimate_acceleration_distance"
            ],
            "imported": false,
            "current_name": "calculate_float_08008cd8"
        },
        "FUN_08007930": {
            "renaming": {
                "FUN_08007930": "debounce_handler_08007930",
                "puVar1": "debounce_ptr",
                "uVar2": "input_bits",
                "uVar3": "bits_changed",
                "iVar4": "debounce_state",
                "off_bits": "off_bits",
                "on_bits": "on_bits",
                "state": "debounce_state",
                "db": "debounce_control"
            },
            "code": "void debounce_handler_08007930(void)\n{\n  uint32_t input_bits;\n  uint debounce_state;\n  uint32_t off_bits;\n  uint32_t on_bits;\n  DEBOUNCE_CTRL *debounce_control = PTR_debounce_080079b8;\n  \n  if (*(int *)PTR_debounce_ready_080079bc != 0) {\n    debounce_state = *(int *)(PTR_debounce_080079b8 + 0x14);\n    input_bits = debounce_input();\n    *(uint32_t *)(debounce_control + debounce_state * 4) = input_bits;\n    if (debounce_control[0x14] == 3) {\n      debounce_state = 0;\n    }\n    else {\n      debounce_state = debounce_control[0x14] + 1;\n    }\n    debounce_control[0x14] = debounce_state;\n    input_bits = debounce_rd();\n    if (input_bits != debounce_control[0x10]) {\n      off_bits = debounce_control[0x10];\n      on_bits = ~off_bits & input_bits;\n      if (on_bits != 0) {\n        debounce_on_handler(on_bits);\n      }\n      off_bits = ~input_bits & off_bits;\n      if (off_bits != 0) {\n        debounce_off_handler(off_bits);\n      }\n      debounce_control[0x10] = input_bits;\n    }\n  }\n  return;\n}",
            "called": [
                "debounce_on_handler",
                "debounce_input",
                "debounce_rd",
                "debounce_off_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007930",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "debounce_handler_08007930"
        },
        "FUN_080082ba": {
            "renaming": {
                "FUN_080082ba": "do_nothing_080082ba"
            },
            "code": "\nvoid do_nothing_080082ba(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080082ba",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "do_nothing_080082ba"
        },
        "FUN_08000188": {
            "renaming": {
                "FUN_08000188": "is_initialization_required_08000188",
                "param_1": "initialization_data",
                "PTR_completed_8911_080001a0": "is_completed",
                "DAT_080001a4": "initialization_flag",
                "PTR__init_080001a8": "unused_initialization_data"
            },
            "code": "bool is_initialization_required_08000188(bool* PTR_completed_8911_080001a0, int* DAT_080001a4, void* initialization_data) {\n  if (*PTR_completed_8911_080001a0 == false) {\n    if (*DAT_080001a4 != 0) {\n      initialization_data = initialization_data;\n    }\n    *PTR_completed_8911_080001a0 = true;\n  }\n  return initialization_data;\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000188",
            "calling": [
                "__libc_fini_array"
            ],
            "imported": false,
            "current_name": "is_initialization_required_08000188"
        },
        "FUN_080082d0": {
            "renaming": {
                "FUN_080082d0": "calculate_double_precision_float_080082d0",
                "param_1": "lower_word_1",
                "param_2": "upper_word_1",
                "param_3": "lower_word_2",
                "param_4": "upper_word_2",
                "iVar1": "shift_right_amount_2",
                "bVar2": "lsb_bit",
                "uVar3": "sum_lower_words",
                "uVar4": "sum_upper_words",
                "uVar5": "shifted_upper_word_2",
                "uVar6": "shifted_upper_word_1",
                "uVar7": "shifted_lower_word_2",
                "iVar8": "shift_right_amount_1",
                "uVar9": "normalized_upper_word_1",
                "uVar10": "normalized_upper_word_difference",
                "uVar11": "normalized_sum_upper_words",
                "uVar12": "normalized_lower_word_difference",
                "bVar13": "upper_words_equal",
                "bVar14": "normalized_sum_upper_words_less_than_normalized_difference",
                "bVar15": "normalized_difference_negative"
            },
            "code": "\nulonglong calculate_double_precision_float_080082d0(uint lower_word_1,uint upper_word_1,uint lower_word_2,uint upper_word_2)\n\n{\n  int shift_right_amount_2;\n  byte lsb_bit;\n  uint sum_lower_words;\n  uint sum_upper_words;\n  uint shifted_upper_word_2;\n  uint shifted_upper_word_1;\n  uint shifted_lower_word_2;\n  int shift_right_amount_1;\n  uint normalized_upper_word_1;\n  uint normalized_upper_word_difference;\n  uint normalized_sum_upper_words;\n  uint normalized_lower_word_difference;\n  bool upper_words_equal;\n  bool normalized_sum_upper_words_less_than_normalized_difference;\n  bool normalized_difference_negative;\n  \n  shifted_upper_word_1 = upper_word_2 ^ 0x80000000;\n  normalized_upper_word_1 = upper_word_1 << 1;\n  upper_word_2 = upper_word_2 << 1;\n  upper_words_equal = ((upper_word_1 ^ shifted_upper_word_1) & 0x7fffffff) == 0;\n  normalized_sum_upper_words_less_than_normalized_difference = upper_words_equal && lower_word_1 == lower_word_2;\n  if (!upper_words_equal || lower_word_1 != lower_word_2) {\n    normalized_sum_upper_words_less_than_normalized_difference = (normalized_upper_word_1 | lower_word_1) == 0;\n  }\n  if (!normalized_sum_upper_words_less_than_normalized_difference) {\n    normalized_sum_upper_words_less_than_normalized_difference = (upper_word_2 | lower_word_2) == 0;\n  }\n  shift_right_amount_1 = (int)normalized_upper_word_1 >> 0x15;\n  if (!normalized_sum_upper_words_less_than_normalized_difference) {\n    normalized_sum_upper_words_less_than_normalized_difference = shift_right_amount_1 == -1;\n  }\n  shift_right_amount_2 = (int)upper_word_2 >> 0x15;\n  if (!normalized_sum_upper_words_less_than_normalized_difference) {\n    normalized_sum_upper_words_less_than_normalized_difference = shift_right_amount_2 == -1;\n  }\n  if (normalized_sum_upper_words_less_than_normalized_difference) {\n    if (shift_right_amount_1 == -1 || shift_right_amount_2 == -1) {\n      normalized_upper_word_1 = shifted_upper_word_1;\n      normalized_sum_upper_words = lower_word_2;\n      if (shift_right_amount_1 == -1) {\n        normalized_upper_word_1 = upper_word_1;\n        normalized_sum_upper_words = lower_word_1;\n      }\n      if (shift_right_amount_1 != -1 || shift_right_amount_2 != -1) {\n        lower_word_2 = normalized_sum_upper_words;\n        shifted_upper_word_1 = normalized_upper_word_1;\n      }\n      normalized_sum_upper_words_less_than_normalized_difference = (normalized_sum_upper_words | normalized_upper_word_1 << 0xc) == 0;\n      if (normalized_sum_upper_words_less_than_normalized_difference) {\n        normalized_sum_upper_words_less_than_normalized_difference = (lower_word_2 | shifted_upper_word_1 << 0xc) == 0;\n      }\n      if (normalized_sum_upper_words_less_than_normalized_difference) {\n        normalized_sum_upper_words_less_than_normalized_difference = normalized_upper_word_1 == shifted_upper_word_1;\n      }\n      if (!normalized_sum_upper_words_less_than_normalized_difference) {\n        normalized_upper_word_1 = normalized_upper_word_1 | 0x80000;\n      }\n      return CONCAT44(normalized_upper_word_1,normalized_sum_upper_words);\n    }\n    if (((upper_word_1 ^ shifted_upper_word_1) & 0x7fffffff) != 0 || lower_word_1 != lower_word_2) {\n      if ((normalized_upper_word_1 | lower_word_1) == 0) {\n        lower_word_1 = lower_word_2;\n        upper_word_1 = shifted_upper_word_1;\n      }\n      return CONCAT44(upper_word_1,lower_word_1);\n    }\n    if (upper_word_1 != shifted_upper_word_1) {\n      return 0;\n    }\n    if (normalized_upper_word_1 >> 0x15 == 0) {\n      normalized_sum_upper_words_less_than_normalized_difference = (lower_word_1 & 0x80000000) != 0;\n      shifted_upper_word_1 = upper_word_1 * 2 + (uint)normalized_sum_upper_words_less_than_normalized_difference;\n      if (CARRY4(upper_word_1,upper_word_1) || CARRY4(upper_word_1 * 2,(uint)normalized_sum_upper_words_less_than_normalized_difference)) {\n        shifted_upper_word_1 = shifted_upper_word_1 | 0x80000000;\n      }\n      return CONCAT44(shifted_upper_word_1,lower_word_1 << 1);\n    }\n    if (normalized_upper_word_1 < 0xffc00000) {\n      return CONCAT44(upper_word_1 + 0x100000,lower_word_1);\n    }\n    upper_word_1 = upper_word_1 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(upper_word_1 | 0x7ff00000) << 0x20;\n  }\n  normalized_upper_word_1 = normalized_upper_word_1 >> 0x15;\n  upper_word_2 = upper_word_2 >> 0x15;\n  normalized_sum_upper_words = upper_word_2 - normalized_upper_word_1;\n  normalized_sum_upper_words_less_than_normalized_difference = normalized_sum_upper_words != 0;\n  if (upper_word_2 < normalized_upper_word_1) {\n    normalized_sum_upper_words = -normalized_sum_upper_words;\n  }\n  normalized_upper_word_difference = lower_word_1;\n  shifted_lower_word_2 = upper_word_1;\n  if (normalized_sum_upper_words_less_than_normalized_difference && normalized_upper_word_1 <= upper_word_2) {\n    normalized_upper_word_1 = normalized_upper_word_1 + normalized_sum_upper_words;\n    normalized_upper_word_difference = lower_word_2;\n    shifted_lower_word_2 = shifted_upper_word_1;\n    lower_word_2 = lower_word_1;\n    shifted_upper_word_1 = upper_word_1;\n  }\n  if (0x36 < normalized_sum_upper_words) {\n    return CONCAT44(shifted_lower_word_2,normalized_upper_word_difference);\n  }\n  sum_upper_words = shifted_lower_word_2 & 0xfffff | 0x100000;\n  if ((shifted_lower_word_2 & 0x80000000) != 0) {\n    normalized_sum_upper_words_less_than_normalized_difference = normalized_upper_word_difference != 0;\n    normalized_upper_word_difference = -normalized_upper_word_difference;\n    sum_upper_words = -sum_upper_words - (uint)normalized_sum_upper_words_less_than_normalized_difference;\n  }\n  shifted_lower_word_2 = shifted_upper_word_1 & 0xfffff | 0x100000;\n  if ((shifted_upper_word_1 & 0x80000000) != 0) {\n    normalized_sum_upper_words_less_than_normalized_difference = lower_word_2 != 0;\n    lower_word_2 = -lower_word_2;\n    shifted_lower_word_2 = -shifted_lower_word_2 - (uint)normalized_sum_upper_words_less_than_normalized_difference;\n  }\n  if (normalized_upper_word_1 == normalized_sum_upper_words) {\n    shifted_lower_word_2 = shifted_lower_word_2 ^ 0x100000;\n    if (normalized_upper_word_1 == 0) {\n      sum_upper_words = sum_upper_words ^ 0x100000;\n      normalized_upper_word_1 = 1;\n    }\n    else {\n      normalized_sum_upper_words = normalized_sum_upper_words - 1;\n    }\n  }\n  shifted_upper_word_1 = -normalized_sum_upper_words + 0x20;\n  if ((int)normalized_sum_upper_words < 0x21) {\n    normalized_lower_word_difference = lower_word_2 << (shifted_upper_word_1 & 0xff);\n    lower_word_2 = lower_word_2 >> (normalized_sum_upper_words & 0xff);\n    sum_lower_words = normalized_upper_word_difference + lower_word_2;\n    shifted_upper_word_2 = shifted_lower_word_2 << (shifted_upper_word_1 & 0xff);\n    shifted_upper_word_1 = sum_lower_words + shifted_upper_word_2;\n    sum_upper_words = sum_upper_words + CARRY4(normalized_upper_word_difference,lower_word_2) + ((int)shifted_lower_word_2 >> (normalized_sum_upper_words & 0xff)) +\n            (uint)CARRY4(sum_lower_words,shifted_upper_word_2);\n  }\n  else {\n    normalized_lower_word_difference = shifted_lower_word_2 << (-normalized_sum_upper_words + 0x40 & 0xff);\n    if (lower_word_2 != 0) {\n      normalized_lower_word_difference = normalized_lower_word_difference | 2;\n    }\n    shifted_lower_word_2 = (int)shifted_lower_word_2 >> (normalized_sum_upper_words - 0x20 & 0xff);\n    shifted_upper_word_1 = normalized_upper_word_difference + shifted_lower_word_2;\n    sum_upper_words = sum_upper_words + ((int)shifted_lower_word_2 >> 0x1f) + (uint)CARRY4(normalized_upper_word_difference,shifted_lower_word_2);\n  }\n  upper_word_1 = sum_upper_words & 0x80000000;\n  normalized_sum_upper_words = sum_upper_words;\n  if ((int)sum_upper_words < 0) {\n    normalized_sum_upper_words_less_than_normalized_difference = normalized_lower_word_difference == 0;\n    normalized_lower_word_difference = -normalized_lower_word_difference;\n    normalized_sum_upper_words = -shifted_upper_word_1;\n    shifted_upper_word_1 = -(uint)!normalized_sum_upper_words_less_than_normalized_difference - shifted_upper_word_1;\n    normalized_sum_upper_words = -(uint)(normalized_sum_upper_words_less_than_normalized_difference <= normalized_sum_upper_words) - sum_upper_words;\n  }\n  if (0xfffff < normalized_sum_upper_words) {\n    normalized_upper_word_difference = normalized_upper_word_1 - 1;\n    if (0x1fffff < normalized_sum_upper_words) {\n      normalized_upper_word_difference = normalized_sum_upper_words & 1;\n      normalized_sum_upper_words = normalized_sum_upper_words >> 1;\n      lsb_bit = (byte)shifted_upper_word_1;\n      shifted_upper_word_1 = (uint)(normalized_upper_word_difference != 0) << 0x1f | shifted_upper_word_1 >> 1;\n      normalized_lower_word_difference = (uint)(lsb_bit & 1) << 0x1f | normalized_lower_word_difference >> 1;\n      normalized_upper_word_difference = normalized_upper_word_1;\n      if (0xffbfffff < normalized_upper_word_1 * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    normalized_sum_upper_words_less_than_normalized_difference = 0x7fffffff < normalized_lower_word_difference;\n    if (normalized_lower_word_difference == 0x80000000) {\n      normalized_sum_upper_words_less_than_normalized_difference = (shifted_upper_word_1 & 1) != 0;\n    }\n    return CONCAT44(normalized_sum_upper_words + normalized_upper_word_difference * 0x100000 + (uint)CARRY4(shifted_upper_word_1,(uint)normalized_sum_upper_words_less_than_normalized_difference) | upper_word_1,\n                    shifted_upper_word_1 + normalized_sum_upper_words_less_than_normalized_difference);\n  }\n  upper_words_equal = (normalized_lower_word_difference & 0x80000000) != 0;\n  normalized_lower_word_difference = normalized_lower_word_difference << 1;\n  normalized_upper_word_difference = shifted_upper_word_1 * 2;\n  normalized_sum_upper_words_less_than_normalized_difference = CARRY4(shifted_upper_word_1,shifted_upper_word_1);\n  shifted_upper_word_1 = shifted_upper_word_1 * 2 + (uint)upper_words_equal;\n  normalized_sum_upper_words = normalized_sum_upper_words * 2 + (uint)(normalized_sum_upper_words_less_than_normalized_difference || CARRY4(normalized_upper_word_difference,(uint)upper_words_equal));\n  normalized_upper_word_difference = normalized_upper_word_1 - 2;\n  if (normalized_upper_word_1 - 1 != 0 && 0xfffff < normalized_sum_upper_words) goto LAB_080083e0;\n  shifted_lower_word_2 = shifted_upper_word_1;\n  normalized_upper_word_1 = normalized_sum_upper_words;\n  if (normalized_sum_upper_words == 0) {\n    shifted_lower_word_2 = 0;\n    normalized_upper_word_1 = shifted_upper_word_1;\n  }\n  shift_right_amount_1 = count_leading_zeroes(normalized_upper_word_1);\n  if (normalized_sum_upper_words == 0) {\n    shift_right_amount_1 = shift_right_amount_1 + 0x20;\n  }\n  normalized_sum_upper_words = shift_right_amount_1 - 0xb;\n  normalized_difference_negative = SBORROW4(normalized_sum_upper_words,0x20);\n  shifted_upper_word_1 = shift_right_amount_1 - 0x2b;\n  normalized_sum_upper_words_less_than_normalized_difference = (int)shifted_upper_word_1 < 0;\n  upper_words_equal = shifted_upper_word_1 == 0;\n  if ((int)normalized_sum_upper_words < 0x20) {\n    normalized_difference_negative = SCARRY4(shifted_upper_word_1,0xc);\n    shift_right_amount_1 = shift_right_amount_1 + -0x1f;\n    normalized_sum_upper_words_less_than_normalized_difference = shift_right_amount_1 < 0;\n    upper_words_equal = shift_right_amount_1 == 0;\n    shifted_upper_word_1 = normalized_sum_upper_words;\n    if (!upper_words_equal && normalized_sum_upper_words_less_than_normalized_difference == normalized_difference_negative) {\n      shifted_lower_word_2 = normalized_upper_word_1 << (normalized_sum_upper_words & 0xff);\n      normalized_upper_word_1 = normalized_upper_word_1 >> (0xcU - shift_right_amount_1 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (upper_words_equal || normalized_sum_upper_words_less_than_normalized_difference != normalized_difference_negative) {\n    normalized_lower_word_difference = 0x20 - shifted_upper_word_1;\n  }\n  normalized_upper_word_1 = normalized_upper_word_1 << (shifted_upper_word_1 & 0xff);\n  if (upper_words_equal || normalized_sum_upper_words_less_than_normalized_difference != normalized_difference_negative) {\n    normalized_upper_word_1 = normalized_upper_word_1 | shifted_lower_word_2 >> (normalized_lower_word_difference & 0xff);\n  }\n  if (upper_words_equal || normalized_sum_upper_words_less_than_normalized_difference != normalized_difference_negative) {\n    shifted_lower_word_2 = shifted_lower_word_2 << (shifted_upper_word_1 & 0xff);\n  }\nLAB_08008458:\n  if ((int)normalized_sum_upper_words <= (int)normalized_upper_word_difference) {\n    return CONCAT44(normalized_upper_word_1 + (normalized_upper_word_difference - normalized_sum_upper_words) * 0x100000 | upper_word_1,shifted_lower_word_2);\n  }\n  shifted_upper_word_1 = ~(normalized_upper_word_difference - normalized_sum_upper_words);\n  if ((int)shifted_upper_word_1 < 0x1f) {\n    shift_right_amount_1 = shifted_upper_word_1 - 0x13;\n    if (shift_right_amount_1 != 0 && shift_right_amount_1 < 0 == SCARRY4(shifted_upper_word_1 - 0x1f,0xc)) {\n      return CONCAT44(sum_upper_words,shifted_lower_word_2 >> (0x20 - (0xcU - shift_right_amount_1) & 0xff) | normalized_upper_word_1 << (0xcU - shift_right_amount_1 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shifted_upper_word_1 = shifted_upper_word_1 + 1;\n    return CONCAT44(upper_word_1 | normalized_upper_word_1 >> (shifted_upper_word_1 & 0xff),\n                    shifted_lower_word_2 >> (shifted_upper_word_1 & 0xff) | normalized_upper_word_1 << (0x20 - shifted_upper_word_1 & 0xff));\n  }\n  return CONCAT44(sum_upper_words,normalized_upper_word_1 >> (shifted_upper_word_1 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080082d0",
            "calling": [
                "__ieee754_atan2",
                "mc_arc",
                "cos",
                "__ieee754_sqrt",
                "sin",
                "__ieee754_hypot",
                "report_realtime_status",
                "__kernel_cos",
                "__ieee754_rem_pio2",
                "plan_buffer_line",
                "atan",
                "__kernel_rem_pio2",
                "__kernel_sin"
            ],
            "imported": false,
            "current_name": "calculate_double_precision_float_080082d0"
        },
        "FUN_08008e70": {
            "renaming": {
                "FUN_08008e70": "calculate_quotient_08008e70",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar1": "quotient",
                "uVar2": "dividend_copy",
                "uVar4": "shift",
                "uVar5": "sign_mask",
                "uVar7": "dividend_shifted",
                "iVar3": "leading_zeroes",
                "iVar6": "offset",
                "bVar8": "dividend_is_nonzero"
            },
            "code": "uint calculate_quotient_08008e70(uint dividend, uint divisor)\n{\n  uint quotient = 0;\n  uint sign_mask = divisor & 0x80000000;\n  if (sign_mask < 0) {\n    bool dividend_is_nonzero = dividend != 0;\n    dividend = -dividend;\n    divisor = -divisor - (uint)dividend_is_nonzero;\n  }\n  uint dividend_copy = dividend;\n  uint divisor_copy = divisor;\n  if (divisor == 0) {\n    dividend_copy = 0;\n    divisor_copy = dividend;\n  }\n  sign_mask = sign_mask | 0x5b000000;\n  if (divisor == 0) {\n    sign_mask = sign_mask + 0xf0000000;\n  }\n  int leading_zeroes = count_leading_zeroes(divisor_copy);\n  uint shift = leading_zeroes - 8;\n  int offset = (sign_mask - 0x800000) + shift * -0x800000;\n  if (leading_zeroes < 8) {\n    uint remainder = divisor_copy << (leading_zeroes + 0x18U & 0xff);\n    uint quotient_copy = offset + ((divisor_copy >> (0x20 - (leading_zeroes + 0x18U) & 0xff)) - ((int)remainder >> 0x1f));\n    if ((dividend_copy | remainder << 1) == 0) {\n      quotient_copy = quotient_copy & ~(remainder >> 0x1f);\n    }\n    quotient = quotient_copy;\n  }\n  else {\n    uint dividend_shifted = dividend_copy << (shift & 0xff);\n    quotient = offset + (divisor_copy << (shift & 0xff)) + (dividend_copy >> (0x20 - shift & 0xff)) + (uint)(0x7fffffff < dividend_shifted);\n    if (dividend_shifted == 0x80000000) {\n      quotient = quotient & 0xfffffffe;\n    }\n  }\n  return quotient;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e70",
            "calling": [],
            "imported": false,
            "current_name": "calculate_quotient_08008e70"
        },
        "FUN_08009318": {
            "renaming": {
                "FUN_08009318": "calculate_08009318",
                "__x": "input",
                "in_r0": "input_bits",
                "in_r1": "input_bits2",
                "uVar1": "exponent",
                "uVar2": "exponent_bits",
                "uVar3": "sum",
                "in_d0": "result",
                "extraout_d0": "result",
                "extraout_d0_00": "result",
                "extraout_d0_01": "result",
                "DAT_08009400": "1.0",
                "DAT_08009404": "1.0",
                "DAT_08009408": "0xffffffffU"
            },
            "code": "double calculate_08009318(double input)\\n\\\n{\\n\\\n  uint32_t exponent_bits = (input_bits << 1) >> 0x15;\\n\\\n  uint32_t exponent = exponent_bits - 0x3ff;\\n\\\n  double result;\\n\\\n  \\n\\\n  if ((int)exponent < 0x14) {\\n\\\n    if ((int)exponent < 0) {\\n\\\n      double sum = input + DAT_08009400;\\n\\\n      result = (sum > 0.0) ? (sum - DAT_08009400) : input;\\n\\\n    }\\n\\\n    else if ((input_bits & (1 << (52 - exponent)) | input_bits2) != 0) {\\n\\\n      double sum = input + DAT_08009400;\\n\\\n      result = (sum > 0.0) ? (sum - DAT_08009400) : input;\\n\\\n    }\\n\\\n  }\\n\\\n  else if ((int)exponent < 0x34) {\\n\\\n    if ((DAT_08009408 >> (exponent_bits - 0x413 & 0xff) & input_bits) != 0) {\\n\\\n      double sum = input + DAT_08009400;\\n\\\n      result = (sum > 0.0) ? (sum - DAT_08009400) : input;\\n\\\n    }\\n\\\n  }\\n\\\n  else if (exponent == 0x400) {\\n\\\n    result = (double)(input + DAT_08009400);\\n\\\n  }\\n\\\n  return result;\\n\\\n}",
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009318",
            "calling": [
                "calculate_trapezoid_for_block",
                "homing_cycle",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "calculate_08009318"
        },
        "FUN_080018cc": {
            "renaming": {
                "FUN_080018cc": "set_bit_in_register_080018cc",
                "x": "bit_value",
                "DAT_080018f8": "register_base_address"
            },
            "code": "void set_bit_in_register_080018cc(uint32_t bit_value)\n{\n  uint32_t* register_ptr = (uint32_t*)(DAT_080018f8 + 0x14);\n  uint32_t current_value = *register_ptr;\n  uint32_t mask = 0xfffffaaf;\n  uint32_t masked_current_value = current_value & mask;\n  uint32_t new_value = masked_current_value | bit_value;\n  *register_ptr = new_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080018cc",
            "calling": [
                "homing_cycle"
            ],
            "imported": false,
            "current_name": "set_bit_in_register_080018cc"
        },
        "FUN_080079e0": {
            "renaming": {
                "FUN_080079e0": "set_interrupt_enable_bit_080079e0",
                "IRQn": "interrupt_number",
                "DAT_08007a0c": "interrupt_enable_register"
            },
            "code": "void set_interrupt_enable_bit_080079e0(IRQn_Type interrupt_number)\n{\n    uint32_t* DAT_08007a0c = (uint32_t*)(DAT_08007a0c + ((uint32_t)interrupt_number >> 5) * 4);\n    uint32_t interrupt_enable_bit = 1 << (interrupt_number & 0x1fU);\n    *DAT_08007a0c = interrupt_enable_bit;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080079e0",
            "calling": [
                "enable_tim_interrupt"
            ],
            "imported": false,
            "current_name": "set_interrupt_enable_bit_080079e0"
        },
        "FUN_08006a58": {
            "renaming": {
                "FUN_08006a58": "set_irq_enabled_08006a58",
                "IRQn": "irq",
                "DAT_08006a88": "irq_reg_base"
            },
            "code": "void set_irq_enabled_08006a58(IRQn_Type irq)\n{\n    int* irq_reg = (int*)(DAT_08006a88 + (((uint)(int)irq >> 5) + 0x40) * 4);\n    int irq_bit = 1 << (irq & 0x1fU);\n    *irq_reg = irq_bit;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006a58",
            "calling": [
                "HAL_NVIC_SetPendingIRQ"
            ],
            "imported": false,
            "current_name": "set_irq_enabled_08006a58"
        },
        "FUN_08005a84": {
            "renaming": {
                "FUN_08005a84": "get_uwTick_value_08005a84",
                "PTR_uwTick_08005a94": "PTR_uwTick",
                "*PTR_uwTick_08005a94": "*ptr_uwTick"
            },
            "code": "uint32_t get_uwTick_value_08005a84(void)\n{\n    uint32_t* ptr_uwTick = (uint32_t*)PTR_uwTick_08005a94_08005a94;\n    return *PTR_uwTick_08005a94_08005a94;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a84",
            "calling": [
                "HAL_Delay",
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig",
                "get_current_usecs",
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "get_uwTick_value_08005a84"
        },
        "FUN_08008b10": {
            "renaming": {
                "FUN_08008b10": "check_if_not_zero_08008b10",
                "in_ZR": "input_char"
            },
            "code": "bool check_if_not_zero_08008b10(char input_char)\n{\n  __aeabi_cdcmpeq();\n  return input_char != '\\0';\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b10",
            "calling": [
                "__ieee754_rem_pio2",
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "check_if_not_zero_08008b10"
        },
        "FUN_08004e30": {
            "renaming": {
                "FUN_08004e30": "update_settings_08004e30",
                "parameter": "param",
                "value": "val",
                "uVar1": "undefined_var1",
                "uVar2": "undefined_var2",
                "iVar3": "int_var",
                "uVar4": "undefined4_var",
                "in_r1": "input_r1"
            },
            "code": "\nuint8_t update_settings_08004e30(int param,float val)\n\n{\n  undefined undefined_var1;\n  undefined2 undefined_var2;\n  int int_var;\n  undefined4 undefined4_var;\n  uint input_r1;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 extraout_r1_03;\n  undefined4 extraout_r1_04;\n  undefined4 extraout_r1_05;\n  undefined4 extraout_r1_06;\n  \n  switch(param) {\n  case 0:\n  case 1:\n  case 2:\n    int_var = __aeabi_fcmple(val,input_r1,0);\n    if (int_var != 0) {\n      return '\\b';\n    }\n    *(uint *)(PTR_settings_080051a8 + param * 4) = input_r1;\n    break;\n  case 3:\n    int_var = __aeabi_fcmplt(input_r1,DAT_080051ac);\n    if (int_var != 0) {\n      return '\\t';\n    }\n    undefined4_var = __aeabi_f2d(input_r1);\n    round((double)CONCAT44(param,input_r1));\n    undefined_var1 = __aeabi_d2uiz(undefined4_var,extraout_r1);\n    PTR_settings_080051a8[0xd] = undefined_var1;\n    break;\n  case 4:\n    *(uint *)(PTR_settings_080051a8 + 0x10) = input_r1;\n    break;\n  case 5:\n    *(uint *)(PTR_settings_080051a8 + 0x14) = input_r1;\n    break;\n  case 6:\n    undefined4_var = __aeabi_f2d(input_r1);\n    trunc((double)CONCAT44(param,input_r1));\n    undefined_var2 = __aeabi_d2uiz(undefined4_var,extraout_r1_00);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x18) = undefined_var2;\n    break;\n  case 7:\n    undefined4_var = __aeabi_f2d(input_r1);\n    round((double)CONCAT44(param,input_r1));\n    undefined_var1 = __aeabi_d2uiz(undefined4_var,extraout_r1_01);\n    PTR_settings_080051a8[0x3c] = undefined_var1;\n    break;\n  case 8:\n    undefined4_var = __aeabi_fmul(input_r1,DAT_080051b0);\n    undefined4_var = __aeabi_fmul(undefined4_var,DAT_080051b0);\n    *(undefined4 *)(PTR_settings_080051a8 + 0x20) = undefined4_var;\n    break;\n  case 9:\n    *(uint *)(PTR_settings_080051a8 + 0x24) = input_r1 & 0x7fffffff;\n    break;\n  case 10:\n    *(uint *)(PTR_settings_080051a8 + 0x1c) = input_r1;\n    break;\n  case 0xb:\n    undefined4_var = __aeabi_f2d(input_r1);\n    round((double)CONCAT44(param,input_r1));\n    undefined_var1 = __aeabi_d2uiz(undefined4_var,extraout_r1_02);\n    PTR_settings_080051a8[0x3e] = undefined_var1;\n    break;\n  case 0xc:\n    undefined4_var = __aeabi_f2d(input_r1);\n    round((double)CONCAT44(param,input_r1));\n    undefined_var1 = __aeabi_d2uiz(undefined4_var,extraout_r1_03);\n    PTR_settings_080051a8[0x3d] = undefined_var1;\n    break;\n  case 0xd:\n    int_var = __aeabi_fcmpeq(input_r1,0);\n    if (int_var == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 1;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xfe;\n    }\n    break;\n  case 0xe:\n    int_var = __aeabi_fcmpeq(input_r1,0);\n    if (int_var == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 2;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xfd;\n    }\n    break;\n  case 0xf:\n    int_var = __aeabi_fcmpeq(input_r1,0);\n    if (int_var == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 4;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xfb;\n    }\n    break;\n  case 0x10:\n    int_var = __aeabi_fcmpeq(input_r1,0);\n    if (int_var == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 8;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xf7;\n    }\n    limits_init();\n    break;\n  case 0x11:\n    int_var = __aeabi_fcmpeq(input_r1,0);\n    if (int_var == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 0x10;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xef;\n    }\n    break;\n  case 0x12:\n    undefined4_var = __aeabi_f2d(input_r1);\n    trunc((double)CONCAT44(param,input_r1));\n    undefined_var2 = __aeabi_d2uiz(undefined4_var,extraout_r1_04);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x2a) = undefined_var2;\n    break;\n  case 0x13:\n    *(uint *)(PTR_settings_080051a8 + 0x2c) = input_r1;\n    break;\n  case 0x14:\n    *(uint *)(PTR_settings_080051a8 + 0x30) = input_r1;\n    break;\n  case 0x15:\n    undefined4_var = __aeabi_f2d(input_r1);\n    round((double)CONCAT44(param,input_r1));\n    undefined_var2 = __aeabi_d2uiz(undefined4_var,extraout_r1_05);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x34) = undefined_var2;\n    break;\n  case 0x16:\n    *(uint *)(PTR_settings_080051a8 + 0x38) = input_r1;\n    break;\n  case 0x17:\n    undefined4_var = __aeabi_f2d(input_r1);\n    trunc((double)CONCAT44(param,input_r1));\n    undefined_var2 = __aeabi_d2uiz(undefined4_var,extraout_r1_06);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x1a) = undefined_var2;\n    break;\n  default:\n    return '\\x06';\n  }\n  write_global_settings();\n  return '\\0';\n}\n\n",
            "called": [
                "__aeabi_fcmple",
                "round",
                "__aeabi_fcmpeq",
                "__aeabi_fmul",
                "limits_init",
                "__aeabi_d2uiz",
                "trunc",
                "__aeabi_f2d",
                "__aeabi_fcmplt",
                "write_global_settings"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e30",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "update_settings_08004e30"
        },
        "FUN_0800736c": {
            "renaming": {
                "FUN_0800736c": "toggle_gpio_pin_0800736c",
                "GPIOx": "gpio",
                "GPIO_Pin": "pin",
                "ODR": "output_data_register"
            },
            "code": "void toggle_gpio_pin_0800736c(GPIO_TypeDef *gpio, uint16_t pin) {\n  gpio->ODR ^= (uint)pin;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800736c",
            "calling": [],
            "imported": false,
            "current_name": "toggle_gpio_pin_0800736c"
        },
        "FUN_08008c30": {
            "renaming": {
                "FUN_08008c30": "calculate_float_bits_08008c30",
                "param_1": "mantissa",
                "param_2": "normalized_exponent",
                "uVar1": "result",
                "uVar2": "shift_amount",
                "uVar3": "normalized_exponent",
                "in_r12": "denormalized_exponent",
                "bVar4": "is_zero",
                "bVar5": "is_small_exponent"
            },
            "code": "uint calculate_float_bits_08008c30(uint float_bits, uint exponent_bits)\n{\n  uint shifted_exponent = exponent_bits * 2;\n  bool is_small_exponent = shifted_exponent < 0x70000000;\n  uint biased_exponent = shifted_exponent + 0x90000000;\n  uint result = biased_exponent;\n  if (!is_small_exponent) {\n    uint denormalized_exponent = shifted_exponent + 0x8fe00000;\n    result = denormalized_exponent;\n  }\n  bool is_zero = result == 0;\n  if (!is_small_exponent && biased_exponent >= 0x200000) {\n    is_zero = denormalized_exponent == 0x1fc00000;\n  }\n  if (((is_small_exponent || biased_exponent < 0x200000) || 0x1fc00000 < denormalized_exponent) || is_zero) {\n    if ((exponent_bits & 0x40000000) != 0) {\n      if (((int)shifted_exponent >> 0x15 == -1) && ((float_bits | exponent_bits << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return exponent_bits & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(shifted_exponent + 0x92e00000) < 0 != SCARRY4(biased_exponent,0x2e00000)) {\n      return exponent_bits & 0x80000000;\n    }\n    uint shift_amount = 0x18 - (shifted_exponent + 0x92e00000 >> 0x15);\n    uint mantissa = float_bits >> (shift_amount & 0xff);\n    if (float_bits << (0x20 - shift_amount & 0xff) != 0) {\n      mantissa = mantissa | 1;\n    }\n    uint normalized_exponent = exponent_bits & 0x1fffff | 0x100000;\n    float_bits = mantissa | normalized_exponent << (0x20 - shift_amount & 0xff);\n    normalized_exponent = (normalized_exponent >> (shift_amount & 0xff)) << 1;\n  }\n  result = (exponent_bits & 0x80000000 | float_bits >> 0x1d) + normalized_exponent * 4 + (uint)(0x7fffffff < float_bits * 8);\n  if (float_bits * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008c30",
            "calling": [
                "homing_cycle",
                "report_realtime_status",
                "report_gcode_parameters",
                "mc_arc",
                "plan_buffer_line",
                "to_millimeters",
                "max_allowable_speed",
                "gc_execute_line",
                "read_float",
                "report_gcode_modes"
            ],
            "imported": false,
            "current_name": "calculate_float_bits_08008c30"
        },
        "FUN_080082d4": {
            "renaming": {
                "FUN_080082d4": "calculate_double_precision_float_080082d4",
                "param_1": "left_fractional",
                "param_2": "left_exponent",
                "param_3": "right_fractional",
                "param_4": "right_exponent",
                "iVar1": "right_exponent_shifted",
                "bVar2": "right_fractional_bit_0",
                "uVar3": "left_fractional_added",
                "uVar4": "right_fractional_added",
                "uVar5": "left_fractional_normalized",
                "iVar6": "left_exponent_shifted",
                "uVar7": "left_exponent_shifted_normalized",
                "uVar8": "left_fractional_sign",
                "uVar9": "left_fractional_unsigned",
                "uVar10": "fractional_difference",
                "uVar11": "fractional_sum",
                "uVar12": "fractional_sum_normalized",
                "bVar13": "fractional_sum_sign",
                "bVar14": "fractional_sum_overflow",
                "bVar15": "fractional_difference_negative"
            },
            "code": "\nulonglong calculate_double_precision_float_080082d4(uint left_fractional,uint left_exponent,uint right_fractional,uint right_exponent)\n\n{\n  int right_exponent_shifted;\n  byte right_fractional_bit_0;\n  uint left_fractional_added;\n  uint right_fractional_added;\n  uint left_fractional_normalized;\n  int left_exponent_shifted;\n  uint left_exponent_shifted_normalized;\n  uint left_fractional_sign;\n  uint left_fractional_unsigned;\n  uint fractional_difference;\n  uint fractional_sum;\n  uint fractional_sum_normalized;\n  bool fractional_sum_sign;\n  bool fractional_sum_overflow;\n  bool fractional_difference_negative;\n  \n  left_exponent_shifted_normalized = left_exponent << 1;\n  left_fractional_unsigned = right_exponent << 1;\n  fractional_sum_sign = ((left_exponent ^ right_exponent) & 0x7fffffff) == 0;\n  fractional_sum_overflow = fractional_sum_sign && left_fractional == right_fractional;\n  if (!fractional_sum_sign || left_fractional != right_fractional) {\n    fractional_sum_overflow = (left_exponent_shifted_normalized | left_fractional) == 0;\n  }\n  if (!fractional_sum_overflow) {\n    fractional_sum_overflow = (left_fractional_unsigned | right_fractional) == 0;\n  }\n  left_exponent_shifted = (int)left_exponent_shifted_normalized >> 0x15;\n  if (!fractional_sum_overflow) {\n    fractional_sum_overflow = left_exponent_shifted == -1;\n  }\n  right_exponent_shifted = (int)left_fractional_unsigned >> 0x15;\n  if (!fractional_sum_overflow) {\n    fractional_sum_overflow = right_exponent_shifted == -1;\n  }\n  if (fractional_sum_overflow) {\n    if (left_exponent_shifted == -1 || right_exponent_shifted == -1) {\n      left_fractional_unsigned = right_exponent;\n      left_exponent_shifted_normalized = right_fractional;\n      if (left_exponent_shifted == -1) {\n        left_fractional_unsigned = left_exponent;\n        left_exponent_shifted_normalized = left_fractional;\n      }\n      if (left_exponent_shifted != -1 || right_exponent_shifted != -1) {\n        right_fractional = left_exponent_shifted_normalized;\n        right_exponent = left_fractional_unsigned;\n      }\n      fractional_sum_overflow = (left_exponent_shifted_normalized | left_fractional_unsigned << 0xc) == 0;\n      if (fractional_sum_overflow) {\n        fractional_sum_overflow = (right_fractional | right_exponent << 0xc) == 0;\n      }\n      if (fractional_sum_overflow) {\n        fractional_sum_overflow = left_fractional_unsigned == right_exponent;\n      }\n      if (!fractional_sum_overflow) {\n        left_fractional_unsigned = left_fractional_unsigned | 0x80000;\n      }\n      return CONCAT44(left_fractional_unsigned,left_exponent_shifted_normalized);\n    }\n    if (((left_exponent ^ right_exponent) & 0x7fffffff) != 0 || left_fractional != right_fractional) {\n      if ((left_exponent_shifted_normalized | left_fractional) == 0) {\n        left_fractional = right_fractional;\n        left_exponent = right_exponent;\n      }\n      return CONCAT44(left_exponent,left_fractional);\n    }\n    if (left_exponent != right_exponent) {\n      return 0;\n    }\n    if (left_exponent_shifted_normalized >> 0x15 == 0) {\n      fractional_sum_overflow = (left_fractional & 0x80000000) != 0;\n      left_fractional_unsigned = left_exponent * 2 + (uint)fractional_sum_overflow;\n      if (CARRY4(left_exponent,left_exponent) || CARRY4(left_exponent * 2,(uint)fractional_sum_overflow)) {\n        left_fractional_unsigned = left_fractional_unsigned | 0x80000000;\n      }\n      return CONCAT44(left_fractional_unsigned,left_fractional << 1);\n    }\n    if (left_exponent_shifted_normalized < 0xffc00000) {\n      return CONCAT44(left_exponent + 0x100000,left_fractional);\n    }\n    left_exponent = left_exponent & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(left_exponent | 0x7ff00000) << 0x20;\n  }\n  left_exponent_shifted_normalized = left_exponent_shifted_normalized >> 0x15;\n  left_fractional_unsigned = left_fractional_unsigned >> 0x15;\n  fractional_difference = left_fractional_unsigned - left_exponent_shifted_normalized;\n  fractional_sum_overflow = fractional_difference != 0;\n  if (left_fractional_unsigned < left_exponent_shifted_normalized) {\n    fractional_difference = -fractional_difference;\n  }\n  left_fractional_sign = left_fractional;\n  left_fractional_normalized = left_exponent;\n  if (fractional_sum_overflow && left_exponent_shifted_normalized <= left_fractional_unsigned) {\n    left_exponent_shifted_normalized = left_exponent_shifted_normalized + fractional_difference;\n    left_fractional_sign = right_fractional;\n    left_fractional_normalized = right_exponent;\n    right_fractional = left_fractional;\n    right_exponent = left_exponent;\n  }\n  if (0x36 < fractional_difference) {\n    return CONCAT44(left_fractional_normalized,left_fractional_sign);\n  }\n  left_fractional_unsigned = left_fractional_normalized & 0xfffff | 0x100000;\n  if ((left_fractional_normalized & 0x80000000) != 0) {\n    fractional_sum_overflow = left_fractional_sign != 0;\n    left_fractional_sign = -left_fractional_sign;\n    left_fractional_unsigned = -left_fractional_unsigned - (uint)fractional_sum_overflow;\n  }\n  left_fractional_normalized = right_exponent & 0xfffff | 0x100000;\n  if ((right_exponent & 0x80000000) != 0) {\n    fractional_sum_overflow = right_fractional != 0;\n    right_fractional = -right_fractional;\n    left_fractional_normalized = -left_fractional_normalized - (uint)fractional_sum_overflow;\n  }\n  if (left_exponent_shifted_normalized == fractional_difference) {\n    left_fractional_normalized = left_fractional_normalized ^ 0x100000;\n    if (left_exponent_shifted_normalized == 0) {\n      left_fractional_unsigned = left_fractional_unsigned ^ 0x100000;\n      left_exponent_shifted_normalized = 1;\n    }\n    else {\n      fractional_difference = fractional_difference - 1;\n    }\n  }\n  fractional_sum_normalized = -fractional_difference + 0x20;\n  if ((int)fractional_difference < 0x21) {\n    fractional_sum = right_fractional << (fractional_sum_normalized & 0xff);\n    right_fractional = right_fractional >> (fractional_difference & 0xff);\n    left_fractional_added = left_fractional_sign + right_fractional;\n    right_fractional_added = left_fractional_normalized << (fractional_sum_normalized & 0xff);\n    fractional_sum_normalized = left_fractional_added + right_fractional_added;\n    left_fractional_unsigned = left_fractional_unsigned + CARRY4(left_fractional_sign,right_fractional) + ((int)left_fractional_normalized >> (fractional_difference & 0xff)) +\n            (uint)CARRY4(left_fractional_added,right_fractional_added);\n  }\n  else {\n    fractional_sum = left_fractional_normalized << (-fractional_difference + 0x40 & 0xff);\n    if (right_fractional != 0) {\n      fractional_sum = fractional_sum | 2;\n    }\n    left_fractional_normalized = (int)left_fractional_normalized >> (fractional_difference - 0x20 & 0xff);\n    fractional_sum_normalized = left_fractional_sign + left_fractional_normalized;\n    left_fractional_unsigned = left_fractional_unsigned + ((int)left_fractional_normalized >> 0x1f) + (uint)CARRY4(left_fractional_sign,left_fractional_normalized);\n  }\n  left_exponent = left_fractional_unsigned & 0x80000000;\n  fractional_difference = left_fractional_unsigned;\n  if ((int)left_fractional_unsigned < 0) {\n    fractional_sum_overflow = fractional_sum == 0;\n    fractional_sum = -fractional_sum;\n    fractional_difference = -fractional_sum_normalized;\n    fractional_sum_normalized = -(uint)!fractional_sum_overflow - fractional_sum_normalized;\n    fractional_difference = -(uint)(fractional_sum_overflow <= fractional_difference) - left_fractional_unsigned;\n  }\n  if (0xfffff < fractional_difference) {\n    left_fractional_sign = left_exponent_shifted_normalized - 1;\n    if (0x1fffff < fractional_difference) {\n      left_fractional_unsigned = fractional_difference & 1;\n      fractional_difference = fractional_difference >> 1;\n      right_fractional_bit_0 = (byte)fractional_sum_normalized;\n      fractional_sum_normalized = (uint)(left_fractional_unsigned != 0) << 0x1f | fractional_sum_normalized >> 1;\n      fractional_sum = (uint)(right_fractional_bit_0 & 1) << 0x1f | fractional_sum >> 1;\n      left_fractional_sign = left_exponent_shifted_normalized;\n      if (0xffbfffff < left_exponent_shifted_normalized * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    fractional_sum_overflow = 0x7fffffff < fractional_sum;\n    if (fractional_sum == 0x80000000) {\n      fractional_sum_overflow = (fractional_sum_normalized & 1) != 0;\n    }\n    return CONCAT44(fractional_difference + left_fractional_sign * 0x100000 + (uint)CARRY4(fractional_sum_normalized,(uint)fractional_sum_overflow) | left_exponent,\n                    fractional_sum_normalized + fractional_sum_overflow);\n  }\n  fractional_sum_sign = (fractional_sum & 0x80000000) != 0;\n  fractional_sum = fractional_sum << 1;\n  left_fractional_sign = fractional_sum_normalized * 2;\n  fractional_sum_overflow = CARRY4(fractional_sum_normalized,fractional_sum_normalized);\n  fractional_sum_normalized = fractional_sum_normalized * 2 + (uint)fractional_sum_sign;\n  fractional_difference = fractional_difference * 2 + (uint)(fractional_sum_overflow || CARRY4(left_fractional_sign,(uint)fractional_sum_sign));\n  left_fractional_sign = left_exponent_shifted_normalized - 2;\n  if (left_exponent_shifted_normalized - 1 != 0 && 0xfffff < fractional_difference) goto LAB_080083e0;\n  left_fractional_normalized = fractional_sum_normalized;\n  left_exponent_shifted_normalized = fractional_difference;\n  if (fractional_difference == 0) {\n    left_fractional_normalized = 0;\n    left_exponent_shifted_normalized = fractional_sum_normalized;\n  }\n  left_exponent_shifted = count_leading_zeroes(left_exponent_shifted_normalized);\n  if (fractional_difference == 0) {\n    left_exponent_shifted = left_exponent_shifted + 0x20;\n  }\n  fractional_sum_normalized = left_exponent_shifted - 0xb;\n  fractional_difference_negative = SBORROW4(fractional_sum_normalized,0x20);\n  fractional_difference = left_exponent_shifted - 0x2b;\n  fractional_sum_overflow = (int)fractional_difference < 0;\n  fractional_sum_sign = fractional_difference == 0;\n  if ((int)fractional_sum_normalized < 0x20) {\n    fractional_difference_negative = SCARRY4(fractional_difference,0xc);\n    left_exponent_shifted = left_exponent_shifted + -0x1f;\n    fractional_sum_overflow = left_exponent_shifted < 0;\n    fractional_sum_sign = left_exponent_shifted == 0;\n    fractional_difference = fractional_sum_normalized;\n    if (!fractional_sum_sign && fractional_sum_overflow == fractional_difference_negative) {\n      left_fractional_normalized = left_exponent_shifted_normalized << (fractional_sum_normalized & 0xff);\n      left_exponent_shifted_normalized = left_exponent_shifted_normalized >> (0xcU - left_exponent_shifted & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (fractional_sum_sign || fractional_sum_overflow != fractional_difference_negative) {\n    fractional_sum = 0x20 - fractional_difference;\n  }\n  left_exponent_shifted_normalized = left_exponent_shifted_normalized << (fractional_difference & 0xff);\n  if (fractional_sum_sign || fractional_sum_overflow != fractional_difference_negative) {\n    left_exponent_shifted_normalized = left_exponent_shifted_normalized | left_fractional_normalized >> (fractional_sum & 0xff);\n  }\n  if (fractional_sum_sign || fractional_sum_overflow != fractional_difference_negative) {\n    left_fractional_normalized = left_fractional_normalized << (fractional_difference & 0xff);\n  }\nLAB_08008458:\n  if ((int)fractional_sum_normalized <= (int)left_fractional_sign) {\n    return CONCAT44(left_exponent_shifted_normalized + (left_fractional_sign - fractional_sum_normalized) * 0x100000 | left_exponent,left_fractional_normalized);\n  }\n  fractional_difference = ~(left_fractional_sign - fractional_sum_normalized);\n  if ((int)fractional_difference < 0x1f) {\n    left_exponent_shifted = fractional_difference - 0x13;\n    if (left_exponent_shifted != 0 && left_exponent_shifted < 0 == SCARRY4(fractional_difference - 0x1f,0xc)) {\n      return CONCAT44(left_fractional_unsigned,left_fractional_normalized >> (0x20 - (0xcU - left_exponent_shifted) & 0xff) | left_exponent_shifted_normalized << (0xcU - left_exponent_shifted & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    fractional_difference = fractional_difference + 1;\n    return CONCAT44(left_exponent | left_exponent_shifted_normalized >> (fractional_difference & 0xff),\n                    left_fractional_normalized >> (fractional_difference & 0xff) | left_exponent_shifted_normalized << (0x20 - fractional_difference & 0xff));\n  }\n  return CONCAT44(left_fractional_unsigned,left_exponent_shifted_normalized >> (fractional_difference - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080082d4",
            "calling": [
                "scalbn",
                "__ieee754_atan2",
                "round",
                "ceil",
                "mc_arc",
                "floor",
                "__ieee754_sqrt",
                "__ieee754_hypot",
                "__kernel_cos",
                "trunc",
                "__ieee754_rem_pio2",
                "__aeabi_drsub",
                "atan",
                "__kernel_rem_pio2",
                "__kernel_sin"
            ],
            "imported": false,
            "current_name": "calculate_double_precision_float_080082d4"
        },
        "FUN_08007bf0": {
            "renaming": {
                "FUN_08007bf0": "update_timer_08007bf0",
                "ticks": "new_ticks",
                "saved": "current_ticks",
                "TIMx": "timer"
            },
            "code": "void update_timer_08007bf0(uint32_t new_ticks)\n{\n  uint32_t current_ticks;\n  TIM_TypeDef *timer;\n  \n  current_ticks = _DAT_4000002c;\n  _DAT_4000002c = new_ticks;\n  if (new_ticks <= _DAT_40000024) {\n    _DAT_40000024 = new_ticks;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007bf0",
            "calling": [
                "set_step_events_per_minute"
            ],
            "imported": false,
            "current_name": "update_timer_08007bf0"
        },
        "FUN_08008590": {
            "renaming": {
                "synchronize_08008590": "calculate_synchronization",
                "param_1": "input_value",
                "param_2": "unused_param_1",
                "param_3": "unused_param_2",
                "param_4": "input_mask",
                "uVar1": "upper_bits",
                "uVar2": "output_value_lower",
                "uVar3": "output_value_upper",
                "uVar4": "shift_amount",
                "uVar5": "doubled_input",
                "uVar7": "leading_zeroes",
                "iVar6": "count",
                "bVar8": "is_count_zero",
                "bVar9": "is_mask_valid",
                "bVar10": "is_shift_valid",
                "in_r12": "unused_param_3",
                "FUN_08008590": "calculate_synchronization_08008590"
            },
            "code": "\nulonglong calculate_synchronization_08008590(uint input_value,undefined4 unused_param_1,undefined4 unused_param_2,uint input_mask)\n\n{\n  uint upper_bits;\n  uint output_value_lower;\n  uint output_value_upper;\n  uint shift_amount;\n  uint doubled_input;\n  int count;\n  uint leading_zeroes;\n  uint unused_param_3;\n  bool is_count_zero;\n  bool is_mask_valid;\n  bool is_shift_valid;\n  \n  doubled_input = input_value << 1;\n  is_mask_valid = doubled_input == 0;\n  upper_bits = (uint)((input_value & 0x80000000) != 0) << 0x1f;\n  shift_amount = (uint)((int)doubled_input >> 3) >> 1;\n  output_value_upper = upper_bits | shift_amount;\n  input_value = input_value << 0x1d;\n  if (!is_mask_valid) {\n    input_mask = doubled_input & 0xff000000;\n    is_mask_valid = input_mask == 0;\n  }\n  if (!is_mask_valid) {\n    is_mask_valid = input_mask == 0xff000000;\n  }\n  if (!is_mask_valid) {\n    return CONCAT44(output_value_upper,input_value) ^ 0x3800000000000000;\n  }\n  if ((doubled_input & 0xffffff) == 0) {\n    return CONCAT44(output_value_upper,input_value);\n  }\n  if (input_mask == 0xff000000) {\n    return CONCAT44(output_value_upper,input_value) | 0x8000000000000;\n  }\n  output_value_lower = input_value;\n  doubled_input = shift_amount;\n  if (shift_amount == 0) {\n    output_value_lower = 0;\n    doubled_input = input_value;\n  }\n  count = count_leading_zeroes(doubled_input);\n  if (shift_amount == 0) {\n    count = count + 0x20;\n  }\n  leading_zeroes = count - 0xb;\n  is_shift_valid = SBORROW4(leading_zeroes,0x20);\n  shift_amount = count - 0x2b;\n  is_mask_valid = (int)shift_amount < 0;\n  is_count_zero = shift_amount == 0;\n  if ((int)leading_zeroes < 0x20) {\n    is_shift_valid = SCARRY4(shift_amount,0xc);\n    count = count + -0x1f;\n    is_mask_valid = count < 0;\n    is_count_zero = count == 0;\n    shift_amount = leading_zeroes;\n    if (!is_count_zero && is_mask_valid == is_shift_valid) {\n      output_value_lower = doubled_input << (leading_zeroes & 0xff);\n      doubled_input = doubled_input >> (0xcU - count & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (is_count_zero || is_mask_valid != is_shift_valid) {\n    unused_param_3 = 0x20 - shift_amount;\n  }\n  doubled_input = doubled_input << (shift_amount & 0xff);\n  if (is_count_zero || is_mask_valid != is_shift_valid) {\n    doubled_input = doubled_input | output_value_lower >> (unused_param_3 & 0xff);\n  }\n  if (is_count_zero || is_mask_valid != is_shift_valid) {\n    output_value_lower = output_value_lower << (shift_amount & 0xff);\n  }\nLAB_08008458:\n  if ((int)leading_zeroes < 0x381) {\n    return CONCAT44(doubled_input + (0x380 - leading_zeroes) * 0x100000 | upper_bits,output_value_lower);\n  }\n  shift_amount = ~(0x380 - leading_zeroes);\n  if (0x1e < (int)shift_amount) {\n    return CONCAT44(output_value_upper,doubled_input >> (shift_amount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  count = shift_amount - 0x13;\n  if (count == 0 || count < 0 != SCARRY4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(upper_bits | doubled_input >> (shift_amount & 0xff),\n                    output_value_lower >> (shift_amount & 0xff) | doubled_input << (0x20 - shift_amount & 0xff));\n  }\n  return CONCAT44(output_value_upper,output_value_lower >> (0x20 - (0xcU - count) & 0xff) | doubled_input << (0xcU - count & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008590",
            "calling": [
                "protocol_execute_line",
                "homing_cycle",
                "mc_arc",
                "mc_dwell",
                "max_allowable_speed",
                "read_float",
                "report_gcode_modes",
                "settings_store_global_setting",
                "calculate_trapezoid_for_block",
                "report_realtime_status",
                "report_gcode_parameters",
                "plan_buffer_line",
                "to_millimeters",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "calculate_synchronization_08008590"
        },
        "FUN_08007ad0": {
            "renaming": {
                "FUN_08007ad0": "initialize_timer_08007ad0",
                "TIMx": "timer",
                "_DAT_40000000": "timer_CR1",
                "_DAT_40000004": "timer_CR2",
                "_DAT_40000008": "timer_SMCR",
                "_DAT_4000000c": "timer_DIER",
                "_DAT_40000010": "timer_CCMR1",
                "_DAT_40000018": "timer_CCMR2",
                "_DAT_4000001c": "timer_CCER",
                "_DAT_40000020": "timer_CNT",
                "_DAT_40000024": "timer_PSC",
                "_DAT_40000028": "APB1_CLOCK",
                "_DAT_4000002c": "timer_ARR",
                "_DAT_40000034": "timer_RCR",
                "_DAT_40000038": "timer_BDTR",
                "_DAT_4000003c": "timer_DCR",
                "PTR_SystemCoreClock_08007b68": "SYS_CLOCK_PTR"
            },
            "code": "void initialize_timer_08007ad0(TIM_TypeDef *timer){\\n\\\n  enable_tim_clock(timer);\\n\\\n  timer->CR1 = 0;\\n\\\n  timer->CR2 = 0;\\n\\\n  timer->SMCR = 0;\\n\\\n  timer->DIER = 0;\\n\\\n  timer->CCMR1 = 0;\\n\\\n  timer->CCMR2 = 0;\\n\\\n  timer->CCER = 0;\\n\\\n  timer->CNT = 0;\\n\\\n  timer->PSC = (uint)((ulonglong)_DAT_40000028 * (ulonglong)*((uint *)PTR_SystemCoreClock_08007b68) >> 0x38) - 1;\\n\\\n  timer->ARR = 0;\\n\\\n  timer->RCR = 0;\\n\\\n  timer->BDTR = 0;\\n\\\n  timer->DCR = 0;\\n\\\n  enable_tim_interrupt(timer,0,0);\\n\\\n}",
            "called": [
                "enable_tim_interrupt",
                "enable_tim_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ad0",
            "calling": [
                "timers_init"
            ],
            "imported": false,
            "current_name": "initialize_timer_08007ad0"
        },
        "FUN_080005b4": {
            "renaming": {
                "FUN_080005b4": "FUNC_080005b4"
            },
            "code": "\nuint8_t FUNC_080005b4(char *line)\n\n{\n  undefined *puVar1;\n  undefined uVar2;\n  uint8_t uVar3;\n  int iVar4;\n  float fVar5;\n  undefined4 uVar6;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 extraout_r1_03;\n  undefined4 extraout_r1_04;\n  uint uVar7;\n  float fVar8;\n  float value_00;\n  float seconds;\n  undefined8 extraout_d0;\n  undefined8 extraout_d0_00;\n  undefined8 extraout_d0_01;\n  undefined8 extraout_d0_02;\n  undefined8 extraout_d0_03;\n  undefined8 uVar9;\n  undefined8 extraout_d0_04;\n  undefined8 extraout_d0_05;\n  float extraout_s2;\n  float extraout_s2_00;\n  float extraout_s2_01;\n  float extraout_s2_02;\n  float extraout_s2_03;\n  float extraout_s2_04;\n  float extraout_s2_05;\n  float extraout_s3;\n  float extraout_s3_00;\n  float extraout_s3_01;\n  float extraout_s3_02;\n  float extraout_s3_03;\n  float extraout_s3_04;\n  float extraout_s3_05;\n  undefined4 in_stack_ffffff48;\n  undefined4 in_stack_ffffff4c;\n  float coord_data_2 [3];\n  float coord_data_1 [3];\n  float coord_data [3];\n  float offset [3];\n  float target [3];\n  float value;\n  char letter;\n  uint8_t char_counter;\n  float y;\n  float x;\n  uint8_t isclockwise;\n  float h_x2_div_d;\n  uint8_t i_3;\n  uint8_t i_2;\n  uint8_t i_1;\n  uint8_t i;\n  uint8_t l;\n  float r;\n  float p;\n  uint8_t group_number;\n  uint8_t non_modal_action;\n  uint8_t absolute_override;\n  float inverse_feed_rate;\n  uint8_t axis_words;\n  uint16_t modal_group_words;\n  int int_value;\n  \n  if (PTR_sys_08000808[1] == '\\x06') {\n    uVar3 = '\\f';\n  }\n  else {\n    char_counter = '\\0';\n    modal_group_words = 0;\n    axis_words = '\\0';\n    inverse_feed_rate = DAT_0800080c;\n    absolute_override = '\\0';\n    non_modal_action = '\\0';\n    memset(target,0,0xc);\n    memset(offset,0,0xc);\n    *PTR_gc_08000810 = 0;\n    group_number = '\\0';\n    while (iVar4 = next_statement(&letter,&value,line,&char_counter), iVar4 != 0) {\n      uVar6 = __aeabi_f2d(value);\n      trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n      int_value = __aeabi_d2iz(uVar6,extraout_r1);\n      if (letter == 'G') {\n        switch(int_value) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 0x50:\n          group_number = '\\x02';\n          break;\n        case 4:\n        case 10:\n        case 0x1c:\n        case 0x1e:\n        case 0x35:\n        case 0x5c:\n          group_number = '\\x01';\n          break;\n        case 0x11:\n        case 0x12:\n        case 0x13:\n          group_number = '\\x03';\n          break;\n        case 0x14:\n        case 0x15:\n          group_number = '\\a';\n          break;\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n          group_number = '\\t';\n          break;\n        case 0x5a:\n        case 0x5b:\n          group_number = '\\x04';\n          break;\n        case 0x5d:\n        case 0x5e:\n          group_number = '\\x06';\n        }\n        switch(int_value) {\n        case 0:\n          PTR_gc_08000ca0[1] = 0;\n          break;\n        case 1:\n          PTR_gc_08000ca0[1] = 1;\n          break;\n        case 2:\n          PTR_gc_08000ca0[1] = 2;\n          break;\n        case 3:\n          PTR_gc_08000ca0[1] = 3;\n          break;\n        case 4:\n          non_modal_action = '\\x01';\n          break;\n        default:\n          *PTR_gc_08000ca0 = 3;\n          break;\n        case 10:\n          non_modal_action = '\\x02';\n          break;\n        case 0x11:\n          select_plane('\\0','\\x01','\\x02');\n          break;\n        case 0x12:\n          select_plane('\\x02','\\0','\\x01');\n          break;\n        case 0x13:\n          select_plane('\\x01','\\x02','\\0');\n          break;\n        case 0x14:\n          PTR_gc_08000ca0[3] = 1;\n          break;\n        case 0x15:\n          PTR_gc_08000ca0[3] = 0;\n          break;\n        case 0x1c:\n        case 0x1e:\n          uVar6 = __aeabi_fmul(value,DAT_08000ca4);\n          uVar6 = __aeabi_f2d(uVar6);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          int_value = __aeabi_d2iz(uVar6,extraout_r1_00);\n          switch(int_value) {\n          case 0x118:\n            non_modal_action = '\\x03';\n            break;\n          case 0x119:\n            non_modal_action = '\\x04';\n            break;\n          default:\n            *PTR_gc_08000ca0 = 3;\n            break;\n          case 300:\n            non_modal_action = '\\x05';\n            break;\n          case 0x12d:\n            non_modal_action = '\\x06';\n          }\n          break;\n        case 0x35:\n          absolute_override = '\\x01';\n          break;\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n          PTR_gc_08000ca0[0x1c] = (char)int_value + -0x36;\n          break;\n        case 0x50:\n          PTR_gc_08000ca0[1] = 4;\n          break;\n        case 0x5a:\n          PTR_gc_08000ca0[4] = 1;\n          break;\n        case 0x5b:\n          PTR_gc_08000ca0[4] = 0;\n          break;\n        case 0x5c:\n          uVar6 = __aeabi_fmul(value,DAT_08000ca4);\n          uVar6 = __aeabi_f2d(uVar6);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          int_value = __aeabi_d2iz(uVar6,extraout_r1_01);\n          if (int_value == 0x398) {\n            non_modal_action = '\\a';\n          }\n          else if (int_value == 0x399) {\n            non_modal_action = '\\b';\n          }\n          else {\n            *PTR_gc_08000ca0 = 3;\n          }\n          break;\n        case 0x5d:\n          PTR_gc_08000ca0[2] = 1;\n          break;\n        case 0x5e:\n          PTR_gc_08000ca0[2] = 0;\n        }\n      }\n      else if (letter == 'M') {\n        if (int_value == 0x1e) {\nLAB_08000b96:\n          group_number = '\\x05';\n        }\n        else if (int_value < 0x1f) {\n          if (int_value < 3) {\n            if (-1 < int_value) goto LAB_08000b96;\n          }\n          else if (int_value - 3U < 3) {\n            group_number = '\\b';\n          }\n        }\n        switch(int_value) {\n        case 0:\n          PTR_gc_08000ca0[5] = 1;\n          break;\n        case 1:\n          break;\n        case 2:\n        case 0x1e:\n          PTR_gc_08000ca0[5] = 2;\n          break;\n        case 3:\n          PTR_gc_08000ca0[6] = 1;\n          break;\n        case 4:\n          PTR_gc_08000ca0[6] = 0xff;\n          break;\n        case 5:\n          PTR_gc_08000ca0[6] = 0;\n          break;\n        default:\n          *PTR_gc_08000ca0 = 3;\n          break;\n        case 7:\n          PTR_gc_08000ca0[7] = 2;\n          break;\n        case 8:\n          PTR_gc_08000ca0[7] = 1;\n          break;\n        case 9:\n          PTR_gc_08000ca0[7] = 0;\n        }\n      }\n      if (group_number != '\\0') {\n        if (((int)(uint)modal_group_words >> group_number & 1U) == 0) {\n          modal_group_words = modal_group_words | (ushort)(1 << group_number);\n        }\n        else {\n          *PTR_gc_08000ca0 = 5;\n        }\n        group_number = '\\0';\n      }\n    }\n    if (*PTR_gc_08000ff0 == '\\0') {\n      p = 0.0;\n      r = 0.0;\n      l = '\\0';\n      char_counter = '\\0';\nswitchD_08000d18_caseD_47:\n      iVar4 = next_statement(&letter,&value,line,&char_counter);\n      if (iVar4 != 0) {\n        fVar8 = (float)extraout_d0;\n        switch(letter) {\n        case 'F':\n          iVar4 = __aeabi_fcmple(value,0);\n          if (iVar4 != 0) {\n            *PTR_gc_08000ff0 = 6;\n          }\n          if (PTR_gc_08000ff0[2] == '\\0') {\n            fVar8 = value;\n            to_millimeters(value_00);\n            *(float *)(PTR_gc_08000ff0 + 8) = fVar8;\n          }\n          else {\n            fVar8 = value;\n            to_millimeters(value_00);\n            inverse_feed_rate = fVar8;\n          }\n          break;\n        case 'G':\n        case 'M':\n        case 'N':\n          break;\n        default:\n          *PTR_gc_08000ff0 = 3;\n          break;\n        case 'I':\n        case 'J':\n        case 'K':\n          uVar7 = (uint)(byte)letter;\n          fVar5 = value;\n          to_millimeters(fVar8);\n          offset[uVar7 - 0x49] = fVar5;\n          break;\n        case 'L':\n          uVar6 = __aeabi_f2d(value);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          l = __aeabi_d2uiz(uVar6,extraout_r1_02);\n          break;\n        case 'P':\n          p = value;\n          break;\n        case 'R':\n          fVar5 = value;\n          to_millimeters(fVar8);\n          r = fVar5;\n          break;\n        case 'S':\n          iVar4 = __aeabi_fcmplt(value,0);\n          if (iVar4 != 0) {\n            *PTR_gc_08000ff0 = 6;\n          }\n          break;\n        case 'T':\n          iVar4 = __aeabi_fcmplt(value,0);\n          if (iVar4 != 0) {\n            *PTR_gc_08000ff0 = 6;\n          }\n          uVar6 = __aeabi_f2d(value);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          uVar2 = __aeabi_d2uiz(uVar6,extraout_r1_03);\n          PTR_gc_08000ff0[0x18] = uVar2;\n          break;\n        case 'X':\n          target[0] = value;\n          to_millimeters(fVar8);\n          axis_words = axis_words | 1;\n          break;\n        case 'Y':\n          target[1] = value;\n          to_millimeters(fVar8);\n          axis_words = axis_words | 2;\n          break;\n        case 'Z':\n          target[2] = value;\n          to_millimeters(fVar8);\n          axis_words = axis_words | 4;\n        }\n        goto switchD_08000d18_caseD_47;\n      }\n      if (*PTR_gc_08000ff0 == '\\0') {\n        uVar9 = extraout_d0;\n        fVar8 = extraout_s2;\n        fVar5 = extraout_s3;\n        if (PTR_sys_08000ff4[1] != '\\a') {\n          spindle_run(PTR_gc_08000ff0[6]);\n          coolant_run(PTR_gc_08000ff0[7]);\n          uVar9 = extraout_d0_00;\n          fVar8 = extraout_s2_00;\n          fVar5 = extraout_s3_00;\n        }\n        if ((modal_group_words & 0x200) != 0) {\n          uVar3 = settings_read_coord_data(PTR_gc_08000ff0[0x1c],coord_data);\n          puVar1 = PTR_gc_08000ff0;\n          if (uVar3 == '\\0') {\n            return '\\n';\n          }\n          *(float *)(PTR_gc_08000ff0 + 0x20) = coord_data[0];\n          *(float *)(puVar1 + 0x24) = coord_data[1];\n          *(float *)(puVar1 + 0x28) = coord_data[2];\n          uVar9 = extraout_d0_01;\n          fVar8 = extraout_s2_01;\n          fVar5 = extraout_s3_01;\n        }\n        switch(non_modal_action) {\n        case '\\x01':\n          iVar4 = __aeabi_fcmplt(p,0);\n          if (iVar4 == 0) {\n            if (PTR_sys_08000ff4[1] != '\\a') {\n              mc_dwell(seconds);\n            }\n          }\n          else {\n            *PTR_gc_08000ff0 = 6;\n          }\n          break;\n        case '\\x02':\n          uVar6 = __aeabi_f2d(p);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          int_value = __aeabi_d2iz(uVar6,extraout_r1_04);\n          if ((((l == '\\x02') || (l == '\\x14')) && (-1 < int_value)) && (int_value < 7)) {\n            if ((axis_words == '\\0') && (l == '\\x02')) {\n              *PTR_gc_08000ff0 = 6;\n            }\n            else {\n              if (int_value < 1) {\n                int_value = (int)(byte)PTR_gc_08001304[0x1c];\n              }\n              else {\n                int_value = int_value + -1;\n              }\n              uVar3 = settings_read_coord_data((uint8_t)int_value,coord_data_2);\n              if (uVar3 == '\\0') {\n                return '\\n';\n              }\n              for (i = '\\0'; i < 3; i = i + '\\x01') {\n                if (((int)(uint)axis_words >> i & 1U) != 0) {\n                  if (l == '\\x14') {\n                    uVar7 = (uint)i;\n                    fVar8 = (float)__aeabi_fsub(*(undefined4 *)(PTR_gc_08001304 + (i + 2) * 4 + 4),\n                                                target[i]);\n                    coord_data_2[uVar7] = fVar8;\n                  }\n                  else {\n                    coord_data_2[i] = target[i];\n                  }\n                }\n              }\n              settings_write_coord_data((uint8_t)int_value,coord_data_2);\n              puVar1 = PTR_gc_08001304;\n              if (int_value == (uint)(byte)PTR_gc_08001304[0x1c]) {\n                *(float *)(PTR_gc_08001304 + 0x20) = coord_data_2[0];\n                *(float *)(puVar1 + 0x24) = coord_data_2[1];\n                *(float *)(puVar1 + 0x28) = coord_data_2[2];\n              }\n            }\n          }\n          else {\n            *PTR_gc_08000ff0 = 3;\n          }\n          axis_words = '\\0';\n          break;\n        case '\\x03':\n        case '\\x05':\n          if (axis_words != '\\0') {\n            for (i_1 = '\\0'; i_1 < 3; i_1 = i_1 + '\\x01') {\n              if (((int)(uint)axis_words >> i_1 & 1U) == 0) {\n                target[i_1] = *(float *)(PTR_gc_08001304 + (i_1 + 2) * 4 + 4);\n              }\n              else if (PTR_gc_08001304[4] == '\\0') {\n                uVar7 = (uint)i_1;\n                fVar8 = (float)__addsf3(target[i_1],\n                                        *(undefined4 *)(PTR_gc_08001304 + (i_1 + 2) * 4 + 4));\n                target[uVar7] = fVar8;\n                uVar9 = extraout_d0_03;\n                fVar8 = extraout_s2_03;\n                fVar5 = extraout_s3_03;\n              }\n              else {\n                fVar8 = target[i_1];\n                uVar6 = __addsf3(*(undefined4 *)(PTR_gc_08001304 + (i_1 + 8) * 4),\n                                 *(undefined4 *)(PTR_gc_08001304 + (i_1 + 10) * 4 + 4));\n                uVar7 = (uint)i_1;\n                fVar8 = (float)__addsf3(fVar8,uVar6);\n                target[uVar7] = fVar8;\n                uVar9 = extraout_d0_02;\n                fVar8 = extraout_s2_02;\n                fVar5 = extraout_s3_02;\n              }\n            }\n            mc_line((float)uVar9,(float)((ulonglong)uVar9 >> 0x20),fVar8,fVar5,SUB41(target[0],0));\n          }\n          if (non_modal_action == '\\x05') {\n            uVar3 = settings_read_coord_data('\\a',coord_data_1);\n            uVar9 = extraout_d0_04;\n            fVar8 = extraout_s2_04;\n            fVar5 = extraout_s3_04;\n            if (uVar3 == '\\0') {\n              return '\\n';\n            }\n          }\n          else {\n            uVar3 = settings_read_coord_data('\\x06',coord_data_1);\n            uVar9 = extraout_d0_05;\n            fVar8 = extraout_s2_05;\n            fVar5 = extraout_s3_05;\n            if (uVar3 == '\\0') {\n              return '\\n';\n            }\n          }\n          mc_line((float)uVar9,(float)((ulonglong)uVar9 >> 0x20),fVar8,fVar5,\n                  SUB41(coord_data_1[0],0));\n          puVar1 = PTR_gc_08001304;\n          *(float *)(PTR_gc_08001304 + 0xc) = coord_data_1[0];\n          *(float *)(puVar1 + 0x10) = coord_data_1[1];\n          *(float *)(puVar1 + 0x14) = coord_data_1[2];\n          axis_words = '\\0';\n          break;\n        case '\\x04':\n        case '\\x06':\n          if (non_modal_action == '\\x06') {\n            settings_write_coord_data('\\a',DAT_0800130c);\n          }\n          else {\n            settings_write_coord_data('\\x06',DAT_0800130c);\n          }\n          break;\n        case '\\a':\n          if (axis_words == '\\0') {\n            *PTR_gc_08001304 = 6;\n          }\n          else {\n            for (i_2 = '\\0'; i_2 < 3; i_2 = i_2 + '\\x01') {\n              if (((int)(uint)axis_words >> i_2 & 1U) != 0) {\n                uVar6 = __aeabi_fsub(*(undefined4 *)(PTR_gc_08001304 + (i_2 + 2) * 4 + 4),\n                                     *(undefined4 *)(PTR_gc_08001304 + (i_2 + 8) * 4));\n                uVar7 = (uint)i_2;\n                uVar6 = __aeabi_fsub(uVar6,target[i_2]);\n                *(undefined4 *)(PTR_gc_08001304 + (uVar7 + 10) * 4 + 4) = uVar6;\n              }\n            }\n          }\n          axis_words = '\\0';\n          break;\n        case '\\b':\n          memset(DAT_08001310,0,0xc);\n        }\n        if (((modal_group_words & 4) != 0) || (axis_words != '\\0')) {\n          if ((PTR_gc_08001574[2] != '\\0') &&\n             ((iVar4 = __aeabi_fcmplt(inverse_feed_rate,0), iVar4 != 0 &&\n              (PTR_gc_08001574[1] != '\\x04')))) {\n            *PTR_gc_08001574 = 6;\n          }\n          if (((absolute_override != '\\0') && (PTR_gc_08001574[1] != '\\0')) &&\n             (PTR_gc_08001574[1] != '\\x01')) {\n            *PTR_gc_08001574 = 6;\n          }\n          if (*PTR_gc_08001574 != '\\0') {\n            return *PTR_gc_08001574;\n          }\n          for (i_3 = '\\0'; puVar1 = PTR_gc_08001840, i_3 < 3; i_3 = i_3 + '\\x01') {\n            if (((int)(uint)axis_words >> i_3 & 1U) == 0) {\n              target[i_3] = *(float *)(PTR_gc_08001574 + (i_3 + 2) * 4 + 4);\n            }\n            else if (absolute_override == '\\0') {\n              if (PTR_gc_08001574[4] == '\\0') {\n                uVar7 = (uint)i_3;\n                fVar8 = (float)__addsf3(target[i_3],\n                                        *(undefined4 *)(PTR_gc_08001574 + (i_3 + 2) * 4 + 4));\n                target[uVar7] = fVar8;\n              }\n              else {\n                fVar8 = target[i_3];\n                uVar6 = __addsf3(*(undefined4 *)(PTR_gc_08001574 + (i_3 + 8) * 4),\n                                 *(undefined4 *)(PTR_gc_08001574 + (i_3 + 10) * 4 + 4));\n                uVar7 = (uint)i_3;\n                fVar8 = (float)__addsf3(fVar8,uVar6);\n                target[uVar7] = fVar8;\n              }\n            }\n          }\n          if ((byte)PTR_gc_08001574[1] < 5) {\n                    /* WARNING: Could not recover jumptable at 0x08001474. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n            uVar3 = (*(code *)(&switchD_08001474::switchdataD_08001478)[(byte)PTR_gc_08001574[1]])()\n            ;\n            return uVar3;\n          }\n          if (*PTR_gc_08001840 != '\\0') {\n            return *PTR_gc_08001840;\n          }\n          *(float *)(PTR_gc_08001840 + 0xc) = target[0];\n          *(float *)(puVar1 + 0x10) = target[1];\n          *(float *)(puVar1 + 0x14) = target[2];\n        }\n        if (PTR_gc_08001840[5] != '\\0') {\n          plan_synchronize();\n          PTR_sys_08001848[0x10] = 0;\n          if (PTR_gc_08001840[5] == '\\x02') {\n            mc_reset();\n          }\n          else {\n            PTR_gc_08001840[5] = 0;\n          }\n        }\n        uVar3 = *PTR_gc_08001840;\n      }\n      else {\n        uVar3 = *PTR_gc_08000ff0;\n      }\n    }\n    else {\n      uVar3 = *PTR_gc_08000ff0;\n    }\n  }\n  return uVar3;\n}\n\n",
            "called": [
                "next_statement",
                "memset",
                "__truncdfsf2",
                "mc_arc",
                "__aeabi_d2iz",
                "mc_dwell",
                "mc_line",
                "__addsf3",
                "__aeabi_fcmpeq",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "hypot",
                "__aeabi_fcmplt",
                "__divdf3",
                "settings_read_coord_data",
                "settings_write_coord_data",
                "plan_synchronize",
                "__aeabi_fcmple",
                "spindle_run",
                "__aeabi_fsub",
                "select_plane",
                "sqrt",
                "coolant_run",
                "__aeabi_fmul",
                "trunc",
                "to_millimeters",
                "mc_reset"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080005b4",
            "calling": [
                "protocol_execute_line",
                "protocol_execute_startup"
            ],
            "imported": false,
            "current_name": "FUNC_080005b4"
        },
        "FUN_080039a0": {
            "renaming": {
                "FUN_080039a0": "resetProtocolAndReportInitMessage_080039a0",
                "PTR_buttons_enabled_080039b8": "PTR_buttons_enabled_080039b8",
                "protocol_reset_line_buffer": "protocol_reset_line_buffer",
                "report_init_message": "report_init_message"
            },
            "code": "void resetProtocolAndReportInitMessage_080039a0(void)\n{\n  protocol_reset_line_buffer();\n  report_init_message();\n  *(undefined4 *)PTR_buttons_enabled_080039b8 = 1;\n  return;\n}",
            "called": [
                "protocol_reset_line_buffer",
                "report_init_message"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080039a0",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "resetProtocolAndReportInitMessage_080039a0"
        },
        "FUN_08009204": {
            "renaming": {
                "FUN_08009204": "compare_and_concat_08009204",
                "param_1": "input_integer",
                "param_2": "input_float",
                "__cmpsf2": "compare_floats",
                "CONCAT44": "concatenate_values"
            },
            "code": "float32_t compare_and_concat_08009204(uint32_t param_1, float32_t param_2)\n{\n  __cmpsf2();\n  return CONCAT44(param_2, param_1);\n}",
            "called": [
                "__cmpsf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009204",
            "calling": [
                "__aeabi_fcmple",
                "__aeabi_cfrcmple",
                "__aeabi_fcmpeq",
                "__aeabi_fcmplt"
            ],
            "imported": false,
            "current_name": "compare_and_concat_08009204"
        },
        "FUN_080029d8": {
            "renaming": {
                "FUN_080029d8": "calculate_entry_speed_080029d8",
                "previous": "previous_block",
                "current": "current_block",
                "next": "next_block",
                "iVar1": "comparison_result",
                "uVar2": "max_speed_flag",
                "fVar3": "max_allowable_velocity",
                "acceleration": "acceleration",
                "acceleration_00": "acceleration",
                "target_velocity": "target_velocity",
                "target_velocity_00": "target_velocity",
                "distance": "max_allowable_distance",
                "distance_00": "distance_to_next_block"
            },
            "code": "void calculate_entry_speed_080029d8(block_t *previous_block, block_t *current_block, block_t *next_block)\n{\n  int comparison_result;\n  uint32_t max_speed_flag;\n  float acceleration;\n  float max_allowable_velocity;\n  float target_velocity;\n  float max_allowable_distance;\n  float distance_to_next_block;\n  \n  if (((current_block != NULL) && (next_block != NULL)) &&\n     (comparison_result = __aeabi_fcmpeq(current_block->entry_speed,current_block->max_entry_speed), comparison_result == 0)) {\n    if ((current_block->nominal_length_flag == 0) &&\n       (comparison_result = __aeabi_fcmpgt(current_block->max_entry_speed,next_block->entry_speed), comparison_result != 0)) {\n      max_allowable_velocity = current_block->max_entry_speed;\n      max_speed_flag = *(uint32_t *)(PTR_settings_08002a90 + 0x20) ^ 0x80000000;\n      max_allowable_speed(acceleration,target_velocity,max_allowable_distance);\n      comparison_result = __aeabi_fcmplt(max_allowable_velocity,max_speed_flag);\n      if (comparison_result == 0) {\n        max_allowable_velocity = (float)(*(uint32_t *)(PTR_settings_08002a90 + 0x20) ^ 0x80000000);\n        max_allowable_speed(acceleration,target_velocity,distance_to_next_block);\n      }\n      current_block->entry_speed = max_allowable_velocity;\n    }\n    else {\n      current_block->entry_speed = current_block->max_entry_speed;\n    }\n    current_block->recalculate_flag = 1;\n  }\n  return;\n}",
            "called": [
                "__aeabi_fcmpeq",
                "__aeabi_fcmplt",
                "max_allowable_speed",
                "__aeabi_fcmpgt"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080029d8",
            "calling": [
                "planner_reverse_pass"
            ],
            "imported": false,
            "current_name": "calculate_entry_speed_080029d8"
        },
        "FUN_08007c5e": {
            "renaming": {
                "FUN_08007c5e": "set_timer_ticks_08007c5e",
                "ticks": "new_ticks",
                "TIMx": "timer",
                "_DAT_40000038": "timer_ARR"
            },
            "code": "void set_timer_ticks_08007c5e(TIM_TypeDef *timer, uint32_t ticks)\n{\n  timer->ARR = ticks;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007c5e",
            "calling": [
                "st_wake_up"
            ],
            "imported": false,
            "current_name": "set_timer_ticks_08007c5e"
        },
        "FUN_08005760": {
            "renaming": {
                "FUN_08005760": "write_step_at_settings_offset_08005760",
                "PTR_settings_08005774": "settings_offset",
                "*PTR_settings_08005774": "settings_offset",
                "PTR_settings_08005774 + 0x18": "settings_offset + 0x18",
                "*(ushort *)(PTR_settings_08005774 + 0x18)": "step_value",
                "uint": "uint16_t"
            },
            "code": "void write_step_at_settings_offset_08005760(void)\n{\n    uint16_t* PTR_settings_08005774 = (uint16_t*)(PTR_settings_08005774 + 0x18);\n    uint16_t *(ushort *)(PTR_settings_08005774 + 0x18) = *PTR_settings_08005774;\n    step_wr(*(ushort *)(PTR_settings_08005774 + 0x18));\n    return;\n}",
            "called": [
                "step_wr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005760",
            "calling": [
                "TIM2_IRQHandler"
            ],
            "imported": false,
            "current_name": "write_step_at_settings_offset_08005760"
        },
        "FUN_080078d0": {
            "renaming": {
                "FUN_080078d0": "do_nothing_080078d0"
            },
            "code": "\nvoid do_nothing_080078d0(uint32_t bits)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078d0",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_080078d0"
        },
        "FUN_08008b24": {
            "renaming": {
                "FUN_08008b24": "is_end_of_string_08008b24",
                "in_CY": "current_char"
            },
            "code": "bool is_end_of_string_08008b24(void)\n{\n  char current_char;\n  __aeabi_cdcmpeq();\n  return current_char == '\\0';\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b24",
            "calling": [
                "__ieee754_hypot",
                "sqrt",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "is_end_of_string_08008b24"
        },
        "FUN_08002814": {
            "renaming": {
                "FUN_08002814": "do_nothing_08002814"
            },
            "code": "\nvoid do_nothing_08002814(uint16_t ms)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002814",
            "calling": [
                "limits_go_home",
                "report_alarm_message",
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "do_nothing_08002814"
        },
        "FUN_0800587c": {
            "renaming": {
                "FUN_0800587c": "update_sys_if_flag_is_3_0800587c",
                "PTR_sys_0800589c": "flag_array"
            },
            "code": "void update_sys_if_flag_is_3_0800587c(void)\n{\n  if (PTR_sys_0800589c[1] == '\\x03') {\n    PTR_sys_0800589c[1] = 4;\n    PTR_sys_0800589c[0x10] = 0;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800587c",
            "calling": [
                "protocol_execute_runtime"
            ],
            "imported": false,
            "current_name": "update_sys_if_flag_is_3_0800587c"
        },
        "FUN_08008a02": {
            "renaming": {
                "FUN_08008a02": "calculate_result_08008a02",
                "param_1": "input_val_1",
                "param_2": "input_val_2",
                "param_3": "input_val_3",
                "param_4": "input_val_4",
                "uVar1": "temp_val_1",
                "unaff_r4": "temp_val_4",
                "uVar2": "temp_val_2",
                "uVar3": "temp_val_3",
                "in_r12": "temp_val_5",
                "bVar4": "check_val_1"
            },
            "code": "ulonglong calculate_result_08008a02(uint input_val_1, uint input_val_2, uint input_val_3, uint input_val_4)\n{\n  uint temp_val_1;\n  uint temp_val_2;\n  uint temp_val_3;\n  uint temp_val_4;\n  uint temp_val_5;\n  bool check_val_1;\n  \n  temp_val_2 = input_val_4 >> 0x14;\n  temp_val_3 = input_val_2;\n  if (input_val_3 != input_val_4 || temp_val_2 != input_val_4) {\n    if (input_val_3 == input_val_4) {\n      if (((input_val_1 | input_val_2 << 0xc) == 0) && (input_val_1 = input_val_3, temp_val_3 = input_val_4, temp_val_2 != input_val_4)) {\n        goto LAB_08008874;\n      }\n    }\n    else if (temp_val_2 == input_val_4) {\n      input_val_1 = input_val_3;\n      temp_val_3 = input_val_4;\n      if ((input_val_3 | input_val_4 << 0xc) == 0) {\n        goto LAB_08008838;\n      }\n    }\n    else {\n      check_val_1 = (input_val_1 | input_val_2 << 1) == 0;\n      if (!check_val_1) {\n        check_val_1 = (input_val_3 | input_val_4 << 1) == 0;\n      }\n      if (!check_val_1) {\n        if (input_val_3 == 0) {\n          temp_val_3 = input_val_2 & 0x80000000;\n          do {\n            temp_val_1 = input_val_1 & 0x80000000;\n            input_val_1 = input_val_1 << 1;\n            input_val_2 = input_val_2 * 2 + (uint)(temp_val_1 != 0);\n          } while ((input_val_2 & 0x100000) == 0);\n          input_val_2 = input_val_2 | temp_val_3;\n          if (temp_val_2 != 0) {\n            return CONCAT44(input_val_2,input_val_1);\n          }\n        }\n        do {\n          temp_val_3 = input_val_3 & 0x80000000;\n          input_val_3 = input_val_3 << 1;\n          input_val_4 = input_val_4 * 2 + (uint)(temp_val_3 != 0);\n        } while ((input_val_4 & 0x100000) == 0);\n        return CONCAT44(input_val_2,input_val_1);\n      }\n      if ((input_val_1 | input_val_2 << 1) != 0) goto LAB_08008874;\n      if ((input_val_3 | input_val_4 << 1) != 0) goto LAB_08008838;\n    }\n  }\n  return CONCAT44(temp_val_3,input_val_1) | 0x7ff8000000000000;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a02",
            "calling": [
                "__divdf3"
            ],
            "imported": false,
            "current_name": "calculate_result_08008a02"
        },
        "FUN_0800369c": {
            "renaming": {
                "FUN_0800369c": "print_string_0800369c",
                "s": "string_to_print",
                "local_c": "byte_pointer"
            },
            "code": "void print_string_0800369c(char *string_to_print)\\n{\\n  uint8_t *byte_pointer;\\n  byte_pointer = (uint8_t *)string_to_print;\\n  while (*byte_pointer != \"\\0\") {\\n    serial_write(*byte_pointer);\\n    byte_pointer++;\\n  }\\n  return;\\n}",
            "called": [
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800369c",
            "calling": [
                "protocol_execute_startup",
                "report_startup_line"
            ],
            "imported": false,
            "current_name": "print_string_0800369c"
        },
        "FUN_08005a98": {
            "renaming": {
                "FUN_08005a98": "delay_until_08005a98",
                "Delay": "target_time",
                "uVar1": "current_time",
                "uVar2": "new_time",
                "timingdelay": "N/A"
            },
            "code": "void delay_until_08005a98(uint32_t target_time)\n{\n  uint32_t current_time;\n  current_time = HAL_GetTick();\n  while (current_time < target_time)\n  {\n    current_time = HAL_GetTick();\n  }\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a98",
            "calling": [
                "_delay_ms"
            ],
            "imported": false,
            "current_name": "delay_until_08005a98"
        },
        "FUN_08008cdc": {
            "renaming": {
                "FUN_08008cdc": "calculate_float_08008cdc",
                "param_1": "float_1",
                "param_2": "float_2",
                "param_3": "undefined",
                "param_4": "float_3",
                "iVar1": "integer_1",
                "uVar2": "unsigned_int_1",
                "uVar3": "unsigned_int_2",
                "uVar4": "unsigned_int_3",
                "uVar5": "unsigned_int_4",
                "iVar6": "integer_2",
                "bVar7": "boolean_1"
            },
            "code": "\nuint calculate_float_08008cdc(uint float_1,uint float_2,undefined4 undefined,uint float_3)\n\n{\n  int integer_1;\n  uint unsigned_int_1;\n  uint unsigned_int_2;\n  uint unsigned_int_3;\n  uint unsigned_int_4;\n  int integer_2;\n  bool boolean_1;\n  \n  unsigned_int_2 = float_1 << 1;\n  boolean_1 = unsigned_int_2 == 0;\n  if (!boolean_1) {\n    float_3 = float_2 << 1;\n    boolean_1 = float_3 == 0;\n  }\n  if (!boolean_1) {\n    boolean_1 = unsigned_int_2 == float_3;\n  }\n  integer_2 = (int)unsigned_int_2 >> 0x18;\n  if (!boolean_1) {\n    boolean_1 = integer_2 == -1;\n  }\n  if (!boolean_1) {\n    boolean_1 = (int)float_3 >> 0x18 == -1;\n  }\n  if (boolean_1) {\n    integer_1 = (int)(float_2 << 1) >> 0x18;\n    if (integer_2 == -1 || integer_1 == -1) {\n      unsigned_int_2 = float_2;\n      if (integer_2 == -1) {\n        unsigned_int_2 = float_1;\n      }\n      if (integer_2 != -1 || integer_1 != -1) {\n        float_2 = unsigned_int_2;\n      }\n      boolean_1 = (unsigned_int_2 & 0x7fffff) == 0;\n      if (boolean_1) {\n        boolean_1 = (float_2 & 0x7fffff) == 0;\n      }\n      if (boolean_1) {\n        boolean_1 = unsigned_int_2 == float_2;\n      }\n      if (!boolean_1) {\n        unsigned_int_2 = unsigned_int_2 | 0x400000;\n      }\n      return unsigned_int_2;\n    }\n    if (((float_1 ^ float_2) & 0x7fffffff) != 0) {\n      if (unsigned_int_2 == 0) {\n        float_1 = float_2;\n      }\n      return float_1;\n    }\n    if (float_1 != float_2) {\n      return 0;\n    }\n    if ((unsigned_int_2 & 0xff000000) == 0) {\n      unsigned_int_2 = float_1 << 1;\n      if ((float_1 & 0x80000000) != 0) {\n        unsigned_int_2 = unsigned_int_2 | 0x80000000;\n      }\n      return unsigned_int_2;\n    }\n    if (unsigned_int_2 < 0xfe000000) {\n      return float_1 + 0x800000;\n    }\n    float_1 = float_1 & 0x80000000;\nLAB_08008e12:\n    return float_1 | 0x7f800000;\n  }\n  unsigned_int_2 = unsigned_int_2 >> 0x18;\n  float_3 = float_3 >> 0x18;\n  unsigned_int_4 = float_3 - unsigned_int_2;\n  boolean_1 = unsigned_int_4 != 0;\n  unsigned_int_3 = unsigned_int_2;\n  if (boolean_1 && unsigned_int_2 <= float_3) {\n    unsigned_int_3 = unsigned_int_2 + unsigned_int_4;\n  }\n  if (boolean_1 && unsigned_int_2 <= float_3) {\n    float_2 = float_2 ^ float_1;\n  }\n  if (boolean_1 && unsigned_int_2 <= float_3) {\n    float_1 = float_1 ^ float_2;\n  }\n  if (boolean_1 && unsigned_int_2 <= float_3) {\n    float_2 = float_2 ^ float_1;\n  }\n  if (float_3 < unsigned_int_2) {\n    unsigned_int_4 = -unsigned_int_4;\n  }\n  if (0x19 < unsigned_int_4) {\n    return float_1;\n  }\n  unsigned_int_2 = float_1 & 0xffffff | 0x800000;\n  if ((float_1 & 0x80000000) != 0) {\n    unsigned_int_2 = -unsigned_int_2;\n  }\n  unsigned_int_1 = float_2 & 0xffffff | 0x800000;\n  if ((float_2 & 0x80000000) != 0) {\n    unsigned_int_1 = -unsigned_int_1;\n  }\n  if (unsigned_int_3 == unsigned_int_4) {\n    unsigned_int_1 = unsigned_int_1 ^ 0x800000;\n    if (unsigned_int_3 == 0) {\n      unsigned_int_2 = unsigned_int_2 ^ 0x800000;\n      unsigned_int_3 = 1;\n    }\n    else {\n      unsigned_int_4 = unsigned_int_4 - 1;\n    }\n  }\n  unsigned_int_2 = unsigned_int_2 + ((int)unsigned_int_1 >> (unsigned_int_4 & 0xff));\n  unsigned_int_1 = unsigned_int_1 << (0x20 - unsigned_int_4 & 0xff);\n  float_1 = unsigned_int_2 & 0x80000000;\n  if ((int)unsigned_int_2 < 0) {\n    boolean_1 = unsigned_int_1 != 0;\n    unsigned_int_1 = -unsigned_int_1;\n    unsigned_int_2 = -unsigned_int_2 - (uint)boolean_1;\n  }\n  if (unsigned_int_2 < 0x800000) {\n    unsigned_int_4 = unsigned_int_1 & 0x80000000;\n    unsigned_int_1 = unsigned_int_1 << 1;\n    unsigned_int_2 = unsigned_int_2 * 2 + (uint)(unsigned_int_4 != 0);\n    unsigned_int_4 = unsigned_int_3 - 2;\n    if (unsigned_int_3 - 1 == 0 || unsigned_int_2 < 0x800000) {\n      integer_2 = count_leading_zeroes(unsigned_int_2);\n      unsigned_int_3 = integer_2 - 8;\n      unsigned_int_2 = unsigned_int_2 << (unsigned_int_3 & 0xff);\n      if ((int)unsigned_int_4 < (int)unsigned_int_3) {\n        unsigned_int_2 = unsigned_int_2 >> (-(unsigned_int_4 - unsigned_int_3) & 0xff);\n      }\n      else {\n        unsigned_int_2 = unsigned_int_2 + (unsigned_int_4 - unsigned_int_3) * 0x800000;\n      }\n      return unsigned_int_2 | float_1;\n    }\n  }\n  else {\n    unsigned_int_4 = unsigned_int_3 - 1;\n    if (0xffffff < unsigned_int_2) {\n      unsigned_int_4 = unsigned_int_2 & 1;\n      unsigned_int_2 = unsigned_int_2 >> 1;\n      unsigned_int_1 = (uint)(unsigned_int_4 != 0) << 0x1f | unsigned_int_1 >> 1;\n      unsigned_int_4 = unsigned_int_3;\n      if (0xfd < unsigned_int_3) goto LAB_08008e12;\n    }\n  }\n  unsigned_int_2 = unsigned_int_2 + unsigned_int_4 * 0x800000 + (uint)(0x7fffffff < unsigned_int_1);\n  if (unsigned_int_1 == 0x80000000) {\n    unsigned_int_2 = unsigned_int_2 & 0xfffffffe;\n  }\n  return unsigned_int_2 | float_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008cdc",
            "calling": [
                "intersection_distance",
                "report_realtime_status",
                "__aeabi_frsub",
                "mc_arc",
                "plan_buffer_line",
                "max_allowable_speed",
                "gc_execute_line",
                "printFloat",
                "estimate_acceleration_distance"
            ],
            "imported": false,
            "current_name": "calculate_float_08008cdc"
        },
        "FUN_080044e8": {
            "renaming": {
                "FUN_080044e8": "printCoordinateData_080044e8",
                "uVar1": "readResult",
                "fVar2": "currentCoordValue",
                "uVar3": "tempValue",
                "coord_data": "coordData",
                "i": "i",
                "coord_select": "coordSelect"
            },
            "code": "void printCoordinateData_080044e8(void)\n{\n  uint8_t readResult;\n  float currentCoordValue;\n  float nextCoordValue;\n  float coordData[3];\n  uint8_t i;\n  uint8_t coordSelect = 0;\n  while (true)\n  {\n    if (coordSelect > 7)\n    {\n      printPgmString(PTR_s__G92__080046c8);\n      currentCoordValue = nextCoordValue;\n      for (i = 0; i < 3; i++)\n      {\n        if ((PTR_settings_080046bc[0x28] & 1) == 0)\n        {\n          printFloat(currentCoordValue);\n        }\n        else\n        {\n          float tempValue = __aeabi_f2d(*(undefined4 *)(PTR_gc_080046cc + (i + 10) * 4 + 4));\n          tempValue = __muldf3((int)tempValue,(int)((ulonglong)tempValue >> 0x20),DAT_08004690,DAT_08004694);\n          currentCoordValue = (float)__truncdfsf2((int)tempValue,(int)((ulonglong)tempValue >> 0x20));\n          printFloat(currentCoordValue);\n        }\n        if (i < 2)\n        {\n          printPgmString(PTR_DAT_080046c0);\n          currentCoordValue = nextCoordValue;\n        }\n        else\n        {\n          printPgmString(PTR_DAT_080046c4);\n          currentCoordValue = nextCoordValue;\n        }\n      }\n      return;\n    }\n    readResult = settings_read_coord_data(coordSelect, coordData);\n    if (readResult == 0) break;\n    printPgmString(PTR_DAT_08004698);\n    currentCoordValue = extraout_s0;\n    switch (coordSelect)\n    {\n      case 0:\n        printPgmString(PTR_DAT_0800469c);\n        currentCoordValue = extraout_s0_00;\n        break;\n      case 1:\n        printPgmString(PTR_DAT_080046a0);\n        currentCoordValue = extraout_s0_01;\n        break;\n      case 2:\n        printPgmString(PTR_DAT_080046a4);\n        currentCoordValue = extraout_s0_02;\n        break;\n      case 3:\n        printPgmString(PTR_DAT_080046a8);\n        currentCoordValue = extraout_s0_03;\n        break;\n      case 4:\n        printPgmString(PTR_DAT_080046ac);\n        currentCoordValue = extraout_s0_04;\n        break;\n      case 5:\n        printPgmString(PTR_DAT_080046b0);\n        currentCoordValue = extraout_s0_05;\n        break;\n      case 6:\n        printPgmString(PTR_DAT_080046b4);\n        currentCoordValue = extraout_s0_06;\n        break;\n      case 7:\n        printPgmString(PTR_DAT_080046b8);\n        currentCoordValue = extraout_s0_07;\n        break;\n    }\n    for (i = 0; i < 3; i++)\n    {\n      if ((PTR_settings_080046bc[0x28] & 1) == 0)\n      {\n        printFloat(currentCoordValue);\n      }\n      else\n      {\n        float tempValue = __aeabi_f2d(coordData[i]);\n        tempValue = __muldf3((int)tempValue,(int)((ulonglong)tempValue >> 0x20),DAT_08004690,DAT_08004694);\n        currentCoordValue = (float)__truncdfsf2((int)tempValue,(int)((ulonglong)tempValue >> 0x20));\n        printFloat(currentCoordValue);\n      }\n      if (i < 2)\n      {\n        printPgmString(PTR_DAT_080046c0);\n        nextCoordValue = extraout_s0_08;\n      }\n      else\n      {\n        printPgmString(PTR_DAT_080046c4);\n        nextCoordValue = extraout_s0_09;\n      }\n    }\n    coordSelect++;\n  }\n  report_status_message('\\n');\n  return;\n}",
            "called": [
                "settings_read_coord_data",
                "report_status_message",
                "__aeabi_f2d",
                "__truncdfsf2",
                "__muldf3",
                "printPgmString",
                "printFloat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080044e8",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "printCoordinateData_080044e8"
        },
        "FUN_08006c9c": {
            "renaming": {
                "FUN_08006c9c": "calculate_ticks_08006c9c",
                "ticks": "num_of_ticks",
                "bVar1": "is_valid_ticks",
                "DAT_08006cdc": "data_pointer"
            },
            "code": "uint32_t calculate_ticks_08006c9c(uint32_t num_of_ticks)\n{\n  bool is_valid_ticks = num_of_ticks - 1 < 0x1000000;\n  if (is_valid_ticks) {\n    DAT_08006cdc[1] = num_of_ticks - 1;\n    NVIC_SetPriority(SysTick_IRQn,0xf);\n    DAT_08006cdc[2] = 0;\n    *DAT_08006cdc = 7;\n  }\n  return (uint)!is_valid_ticks;\n}",
            "called": [
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c9c",
            "calling": [
                "HAL_SYSTICK_Config"
            ],
            "imported": false,
            "current_name": "calculate_ticks_08006c9c"
        },
        "FUN_0800a5a0": {
            "renaming": {
                "FUN_0800a5a0": "FUNC_0800a5a0"
            },
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nuint FUNC_0800a5a0(int param_1,undefined8 *param_2,int param_3,int param_4,int param_5,\n                      int param_6)\n\n{\n  undefined4 *puVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  undefined4 extraout_r1;\n  int iVar5;\n  uint *puVar6;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 uVar7;\n  uint **ppuVar8;\n  int iVar9;\n  int iVar10;\n  undefined4 *puVar11;\n  undefined4 uVar12;\n  uint uVar13;\n  uint *puVar14;\n  int iVar15;\n  int iVar16;\n  undefined8 *puVar17;\n  undefined8 *puVar18;\n  undefined8 *puVar19;\n  undefined4 *puVar20;\n  undefined8 *puVar21;\n  undefined4 uVar22;\n  int iVar23;\n  undefined4 *puVar24;\n  bool bVar25;\n  undefined8 uVar26;\n  undefined8 uVar27;\n  undefined8 uVar28;\n  undefined8 uVar29;\n  ulonglong uVar30;\n  undefined4 in_stack_fffffd78;\n  int local_280;\n  int local_26c;\n  uint *local_260 [2];\n  uint local_258 [20];\n  undefined8 uStack_208;\n  undefined4 local_168;\n  undefined4 uStack_164;\n  undefined8 local_160;\n  undefined8 uStack_c8;\n  \n  uVar29 = CONCAT44(param_5,param_5);\n  iVar16 = *(int *)(PTR_init_jk_0800a894 + param_5 * 4);\n  iVar9 = param_4 + -1;\n  local_260[1] = (uint *)param_2;\n  if (param_3 + 0x14 < 0 == SCARRY4(param_3,0x14)) {\n    local_26c = (int)((longlong)DAT_0800a898 * (longlong)(param_3 + -3) >> 0x22) -\n                (param_3 + -3 >> 0x1f);\n    iVar10 = (local_26c + 1) * -0x18;\n  }\n  else {\n    iVar10 = -0x18;\n    local_26c = 0;\n  }\n  param_3 = param_3 + iVar10;\n  iVar10 = local_26c - iVar9;\n  if (-1 < iVar16 + iVar9) {\n    iVar23 = iVar16 + iVar9 + 1 + iVar10;\n    puVar19 = &uStack_208;\n    do {\n      while (iVar10 < 0) {\n        iVar10 = iVar10 + 1;\n        *(undefined4 *)puVar19 = 0;\n        *(undefined4 *)((int)puVar19 + 4) = 0;\n        puVar19 = puVar19 + 1;\n        if (iVar10 == iVar23) goto LAB_0800a626;\n      }\n      uVar27 = __aeabi_i2d(*(undefined4 *)(param_6 + iVar10 * 4));\n      iVar10 = iVar10 + 1;\n      *puVar19 = uVar27;\n      puVar19 = puVar19 + 1;\n    } while (iVar10 != iVar23);\n  }\nLAB_0800a626:\n  puVar11 = (undefined4 *)(param_1 + -8);\n  if (-1 < iVar16) {\n    puVar17 = &uStack_208 + param_4;\n    iVar23 = iVar16 + param_4;\n    iVar10 = iVar9;\n    puVar19 = &uStack_c8;\n    do {\n      if (iVar9 < 0) {\n        uVar27 = 0;\n      }\n      else {\n        uVar27 = 0;\n        puVar24 = puVar11;\n        puVar21 = puVar17;\n        do {\n          puVar20 = puVar24 + 2;\n          uVar26 = __muldf3(*puVar20,puVar24[3],*(undefined4 *)(puVar21 + -1),\n                            *(undefined4 *)((int)puVar21 + -4));\n          uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                                (int)((ulonglong)uVar26 >> 0x20));\n          puVar24 = puVar20;\n          puVar21 = puVar21 + -1;\n        } while (puVar20 != puVar11 + param_4 * 2);\n      }\n      iVar10 = iVar10 + 1;\n      *puVar19 = uVar27;\n      puVar17 = puVar17 + 1;\n      puVar19 = puVar19 + 1;\n    } while (iVar10 != iVar23);\n  }\n  local_260[0] = local_258 + iVar16 + -1;\n  local_280 = iVar16;\n  do {\n    iVar23 = *(int *)(&uStack_c8 + local_280);\n    uVar27 = CONCAT44(*(undefined4 *)((int)&uStack_c8 + local_280 * 8 + 4),iVar23);\n    iVar10 = local_280;\n    if (0 < local_280) {\n      puVar19 = &uStack_c8 + local_280;\n      puVar6 = local_258;\n      do {\n        uVar7 = (undefined4)((ulonglong)uVar27 >> 0x20);\n        __muldf3((int)uVar27,uVar7,0,DAT_0800a89c);\n        __aeabi_d2iz();\n        uVar26 = __aeabi_i2d();\n        uVar3 = (undefined4)((ulonglong)uVar26 >> 0x20);\n        uVar28 = __muldf3((int)uVar26,uVar3,0,DAT_0800a8a0);\n        __subdf3((int)uVar27,uVar7,(int)uVar28,(int)((ulonglong)uVar28 >> 0x20));\n        uVar2 = __aeabi_d2iz();\n        puVar17 = puVar19 + -1;\n        uVar7 = *(undefined4 *)puVar17;\n        uVar12 = *(undefined4 *)((int)puVar19 + -4);\n        *puVar6 = uVar2;\n        uVar27 = __aeabi_dadd((int)uVar26,uVar3,uVar7,uVar12);\n        iVar23 = (int)uVar27;\n        puVar19 = puVar17;\n        puVar6 = puVar6 + 1;\n      } while (puVar17 != &uStack_c8);\n    }\n    scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),iVar23);\n    __muldf3();\n    floor((double)CONCAT44(iVar10,in_stack_fffffd78));\n    uVar27 = __muldf3();\n    uVar27 = __subdf3(iVar23,extraout_r1,(int)uVar27,(int)((ulonglong)uVar27 >> 0x20));\n    uVar2 = __aeabi_d2iz();\n    uVar26 = __aeabi_i2d();\n    uVar27 = __subdf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                      (int)((ulonglong)uVar26 >> 0x20));\n    uVar7 = (undefined4)((ulonglong)uVar27 >> 0x20);\n    uVar3 = (undefined4)uVar27;\n    if (param_3 < 1) {\n      if (param_3 == 0) {\n        iVar23 = (int)local_258[iVar10 + -1] >> 0x17;\n        goto joined_r0x0800a8b8;\n      }\n      iVar23 = __aeabi_dcmpge(uVar3,uVar7,0,DAT_0800ac3c);\n      if (iVar23 != 0) {\n        uVar2 = uVar2 + 1;\n        if (iVar10 < 1) {\n          uVar27 = __subdf3(0,DAT_0800ac38,uVar3,uVar7);\n          iVar23 = 2;\n          goto LAB_0800a7a4;\n        }\n        iVar23 = 2;\n        goto LAB_0800a8c8;\n      }\n    }\n    else {\n      iVar5 = (int)local_258[iVar10 + -1] >> (0x18U - param_3 & 0xff);\n      uVar13 = local_258[iVar10 + -1] - (iVar5 << (0x18U - param_3 & 0xff));\n      iVar23 = (int)uVar13 >> (0x17U - param_3 & 0xff);\n      local_258[iVar10 + -1] = uVar13;\n      uVar2 = uVar2 + iVar5;\njoined_r0x0800a8b8:\n      if (0 < iVar23) {\n        uVar2 = uVar2 + 1;\n        if (iVar10 < 1) {\n          uVar13 = 0;\n        }\n        else {\nLAB_0800a8c8:\n          uVar13 = local_258[0];\n          if (local_258[0] == 0) {\n            if (iVar10 != 1) {\n              puVar6 = local_258;\n              iVar5 = 1;\n              do {\n                puVar6 = puVar6 + 1;\n                uVar13 = *puVar6;\n                if (uVar13 != 0) {\n                  iVar15 = iVar5 + 1;\n                  goto LAB_0800a8e2;\n                }\n                iVar5 = iVar5 + 1;\n              } while (iVar5 != iVar10);\n            }\n          }\n          else {\n            iVar15 = 1;\n            iVar5 = 0;\nLAB_0800a8e2:\n            local_258[iVar5] = 0x1000000 - uVar13;\n            if (iVar15 < iVar10) {\n              uVar13 = local_258[iVar15];\n              puVar6 = local_258 + iVar15;\n              while( true ) {\n                puVar14 = puVar6 + 1;\n                *puVar6 = 0xffffff - uVar13;\n                if (puVar14 == local_258 + iVar10) break;\n                uVar13 = *puVar14;\n                puVar6 = puVar14;\n              }\n            }\n            uVar13 = 1;\n          }\n        }\n        if (0 < param_3) {\n          if (param_3 == 1) {\n            local_258[iVar10 + -1] = local_258[iVar10 + -1] & 0x7fffff;\n          }\n          else if (param_3 == 2) {\n            local_258[iVar10 + -1] = local_258[iVar10 + -1] & 0x3fffff;\n          }\n        }\n        if (iVar23 == 2) {\n          uVar27 = __subdf3(0,DAT_0800ac38,uVar3,uVar7);\n          if (uVar13 != 0) {\n            uVar3 = 0;\n            scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),0);\n            uVar27 = __subdf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar3,extraout_r1_00);\n          }\n        }\n      }\n    }\nLAB_0800a7a4:\n    iVar15 = (int)uVar27;\n    iVar5 = __aeabi_dcmpeq(iVar15,(int)((ulonglong)uVar27 >> 0x20),0,0);\n    if (iVar5 == 0) {\n      scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),iVar15);\n      iVar9 = __aeabi_dcmpge();\n      if (iVar9 == 0) {\n        iVar5 = iVar10;\n        uVar13 = __aeabi_d2iz(iVar15,extraout_r1_02);\n        local_258[iVar5] = uVar13;\n        iVar10 = iVar5;\n      }\n      else {\n        __muldf3(iVar15,extraout_r1_02,0,DAT_0800ade8);\n        uVar13 = __aeabi_d2iz();\n        uVar27 = __aeabi_i2d();\n        uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0,DAT_0800ade4);\n        __subdf3(iVar15,extraout_r1_02,(int)uVar27,(int)((ulonglong)uVar27 >> 0x20));\n        iVar9 = iVar10;\n        uVar4 = __aeabi_d2iz();\n        iVar5 = iVar10 + 1;\n        local_258[iVar10] = uVar4;\n        local_258[iVar5] = uVar13;\n        iVar10 = iVar9;\n      }\n      goto LAB_0800a9f6;\n    }\n    iVar5 = iVar10 + -1;\n    if (iVar16 <= iVar5) {\n      uVar13 = 0;\n      puVar6 = local_258 + iVar10 + 0x3fffffff;\n      do {\n        puVar14 = puVar6 + -1;\n        uVar13 = uVar13 | *puVar6;\n        puVar6 = puVar14;\n      } while (puVar14 != local_260[0]);\n      if (uVar13 != 0) break;\n    }\n    if (local_258[iVar16 + -1] == 0) {\n      local_280 = 1;\n      ppuVar8 = local_260 + iVar16;\n      do {\n        puVar6 = *ppuVar8;\n        local_280 = local_280 + 1;\n        ppuVar8 = ppuVar8 + -1;\n      } while (puVar6 == (uint *)0x0);\n      local_280 = iVar10 + local_280;\n    }\n    else {\n      local_280 = iVar10 + 1;\n    }\n    iVar23 = iVar10 + 1;\n    puVar24 = (undefined4 *)(param_6 + (iVar23 + local_26c + 0x3fffffff) * 4);\n    puVar19 = &uStack_208 + iVar10 + param_4;\n    puVar17 = &uStack_c8 + iVar23;\n    do {\n      puVar24 = puVar24 + 1;\n      uVar27 = __aeabi_i2d(*puVar24);\n      *puVar19 = uVar27;\n      puVar21 = puVar19 + 1;\n      if (iVar9 < 0) {\n        uVar26 = 0;\n      }\n      else {\n        uVar26 = 0;\n        puVar20 = puVar11;\n        while( true ) {\n          puVar19 = puVar19 + -1;\n          puVar1 = puVar20 + 2;\n          uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),*puVar1,puVar20[3]);\n          uVar26 = __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar27,\n                                (int)((ulonglong)uVar27 >> 0x20));\n          if (puVar1 == puVar11 + param_4 * 2) break;\n          uVar27 = *puVar19;\n          puVar20 = puVar1;\n        }\n      }\n      *puVar17 = uVar26;\n      iVar23 = iVar23 + 1;\n      puVar19 = puVar21;\n      puVar17 = puVar17 + 1;\n    } while (iVar23 <= local_280);\n  } while( true );\n  if (local_258[iVar5] == 0) {\n    puVar6 = local_258 + iVar10 + 0x3ffffffe;\n    do {\n      uVar13 = *puVar6;\n      iVar5 = iVar5 + -1;\n      puVar6 = puVar6 + -1;\n    } while (uVar13 == 0);\n  }\nLAB_0800a9f6:\n  uVar3 = 0;\n  scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),0);\n  uVar27 = CONCAT44(extraout_r1_01,uVar3);\n  if (iVar5 < 0) {\n    if (2 < param_5) {\n      if (param_5 == 3) {\n        puVar19 = (undefined8 *)&local_168;\n        uVar29 = 0;\nLAB_0800abe4:\n        if (iVar23 == 0) {\n          uVar3 = *(undefined4 *)(puVar19 + 1);\n          uVar7 = *(undefined4 *)((int)puVar19 + 0xc);\n          *local_260[1] = local_168;\n          *(undefined4 *)((int)local_260[1] + 4) = uStack_164;\n          *(undefined8 *)((int)local_260[1] + 0x10) = uVar29;\n          *(undefined4 *)((int)local_260[1] + 8) = uVar3;\n          *(undefined4 *)((int)local_260[1] + 0xc) = uVar7;\n          return uVar2 & 7;\n        }\n        iVar9 = *(int *)((int)puVar19 + 4);\n        *(int *)((int)local_260[1] + 0x10) = (int)uVar29;\n        iVar16 = *(int *)((int)puVar19 + 0xc);\n        *(undefined4 *)((int)local_260[1] + 8) = *(undefined4 *)(puVar19 + 1);\n        *(int *)((int)local_260[1] + 0x14) = (int)((ulonglong)uVar29 >> 0x20) + -0x80000000;\n        uVar3 = *(undefined4 *)puVar19;\n        *(int *)((int)local_260[1] + 4) = iVar9 + -0x80000000;\n        *(int *)((int)local_260[1] + 0xc) = iVar16 + -0x80000000;\n        *local_260[1] = uVar3;\n        return uVar2 & 7;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (param_5 < 1) {\n      if (param_5 != 0) goto LAB_0800ab0e;\nLAB_0800aafc:\n      iVar9 = (int)((ulonglong)uVar29 >> 0x20);\n      if (iVar23 != 0) {\n        iVar9 = iVar9 + -0x80000000;\n      }\n      *local_260[1] = (int)uVar29;\n      *(int *)((int)local_260[1] + 4) = iVar9;\nLAB_0800ab0e:\n      return uVar2 & 7;\n    }\n    uVar29 = 0;\n  }\n  else {\n    puVar17 = &uStack_c8 + iVar5;\n    puVar6 = local_258 + iVar5 + 1;\n    puVar19 = &uStack_c8 + iVar5 + 1;\n    do {\n      uVar3 = (undefined4)((ulonglong)uVar27 >> 0x20);\n      puVar6 = puVar6 + -1;\n      uVar26 = __aeabi_i2d(*puVar6);\n      uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar27,uVar3);\n      puVar19 = puVar19 + -1;\n      *puVar19 = uVar26;\n      uVar27 = __muldf3((int)uVar27,uVar3,0,DAT_0800ac40);\n    } while (puVar6 != local_258);\n    puVar19 = (undefined8 *)&local_168;\n    iVar9 = 0;\n    uVar3 = DAT_0800ac30;\n    uVar7 = DAT_0800ac34;\n    do {\n      DAT_0800ac30 = uVar3;\n      DAT_0800ac34 = uVar7;\n      if (iVar16 < 0) {\n        uVar27 = 0;\n      }\n      else {\n        uVar27 = 0;\n        iVar10 = 0;\n        puVar21 = puVar17;\n        puVar11 = (undefined4 *)PTR_DAT_0800ac44;\n        while( true ) {\n          uVar26 = __muldf3(*(undefined4 *)puVar21,*(undefined4 *)((int)puVar21 + 4),uVar3,uVar7);\n          uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                                (int)((ulonglong)uVar26 >> 0x20));\n          iVar10 = iVar10 + 1;\n          if ((iVar16 < iVar10) || (iVar9 < iVar10)) break;\n          uVar3 = *puVar11;\n          uVar7 = puVar11[1];\n          puVar21 = puVar21 + 1;\n          puVar11 = puVar11 + 2;\n        }\n      }\n      bVar25 = iVar9 != iVar5;\n      puVar19[iVar9] = uVar27;\n      puVar17 = puVar17 + -1;\n      iVar9 = iVar9 + 1;\n      uVar3 = DAT_0800ac30;\n      uVar7 = DAT_0800ac34;\n    } while (bVar25);\n    if (2 < param_5) {\n      if (param_5 == 3) {\n        if (iVar5 != 0) {\n          puVar17 = puVar19 + iVar5;\n          uVar29 = *puVar17;\n          do {\n            uVar7 = (undefined4)((ulonglong)uVar29 >> 0x20);\n            uVar3 = (undefined4)uVar29;\n            uVar12 = *(undefined4 *)(puVar17 + -1);\n            uVar22 = *(undefined4 *)((int)puVar17 + -4);\n            uVar29 = __aeabi_dadd(uVar3,uVar7,uVar12,uVar22);\n            uVar27 = __subdf3(uVar12,uVar22,(int)uVar29,(int)((ulonglong)uVar29 >> 0x20));\n            uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar3,uVar7);\n            *puVar17 = uVar27;\n            puVar17 = puVar17 + -1;\n            *puVar17 = uVar29;\n          } while (puVar19 != puVar17);\n          if (1 < iVar5) {\n            puVar21 = puVar19 + iVar5;\n            uVar29 = *puVar21;\n            puVar17 = puVar21;\n            do {\n              uVar7 = (undefined4)((ulonglong)uVar29 >> 0x20);\n              uVar3 = (undefined4)uVar29;\n              uVar12 = *(undefined4 *)(puVar17 + -1);\n              uVar22 = *(undefined4 *)((int)puVar17 + -4);\n              uVar29 = __aeabi_dadd(uVar3,uVar7,uVar12,uVar22);\n              uVar27 = __subdf3(uVar12,uVar22,(int)uVar29,(int)((ulonglong)uVar29 >> 0x20));\n              uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar3,uVar7);\n              *puVar17 = uVar27;\n              puVar17 = puVar17 + -1;\n              *puVar17 = uVar29;\n            } while (&local_160 != puVar17);\n            uVar29 = 0;\n            puVar18 = puVar19 + 2;\n            puVar17 = puVar21 + 1;\n            do {\n              puVar21 = puVar17 + -1;\n              uVar29 = __aeabi_dadd((int)uVar29,(int)((ulonglong)uVar29 >> 0x20),\n                                    *(undefined4 *)puVar21,*(undefined4 *)((int)puVar17 + -4));\n              puVar17 = puVar21;\n            } while (puVar18 != puVar21);\n            goto LAB_0800abe4;\n          }\n        }\n        uVar29 = 0;\n        goto LAB_0800abe4;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (param_5 < 1) {\n      if (param_5 != 0) goto LAB_0800ab0e;\n      puVar17 = puVar19 + iVar5 + 1;\n      do {\n        puVar21 = puVar17 + -1;\n        uVar29 = __aeabi_dadd((int)uVar29,(int)((ulonglong)uVar29 >> 0x20),*(undefined4 *)puVar21,\n                              *(undefined4 *)((int)puVar17 + -4));\n        puVar17 = puVar21;\n      } while (puVar19 != puVar21);\n      goto LAB_0800aafc;\n    }\n    uVar29 = 0;\n    puVar17 = puVar19 + iVar5 + 1;\n    do {\n      puVar21 = puVar17 + -1;\n      uVar29 = __aeabi_dadd((int)uVar29,(int)((ulonglong)uVar29 >> 0x20),*(undefined4 *)puVar21,\n                            *(undefined4 *)((int)puVar17 + -4));\n      puVar17 = puVar21;\n    } while (puVar19 != puVar21);\n  }\n  iVar9 = (int)((ulonglong)uVar29 >> 0x20);\n  uVar3 = (undefined4)uVar29;\n  if (iVar23 == 0) {\n    *(undefined8 *)local_260[1] = uVar29;\n    uVar30 = __subdf3(local_168,uStack_164,uVar3,iVar9);\n    if (iVar5 < 1) goto LAB_0800ad26;\nLAB_0800ad04:\n    iVar9 = 1;\n    puVar19 = (undefined8 *)&local_168;\n    do {\n      uVar30 = __aeabi_dadd((int)uVar30,(int)(uVar30 >> 0x20),*(undefined4 *)(puVar19 + 1),\n                            *(undefined4 *)((int)puVar19 + 0xc));\n      iVar9 = iVar9 + 1;\n      puVar19 = puVar19 + 1;\n    } while (iVar9 <= iVar5);\n    if (iVar23 == 0) goto LAB_0800ad26;\n  }\n  else {\n    *local_260[1] = uVar3;\n    *(int *)((int)local_260[1] + 4) = iVar9 + -0x80000000;\n    uVar30 = __subdf3(local_168,uStack_164,uVar3,iVar9);\n    if (0 < iVar5) goto LAB_0800ad04;\n  }\n  uVar30 = uVar30 & 0xffffffff | (ulonglong)((int)(uVar30 >> 0x20) + 0x80000000) << 0x20;\nLAB_0800ad26:\n  *(ulonglong *)((int)local_260[1] + 8) = uVar30;\n  return uVar2 & 7;\n}\n\n",
            "called": [
                "floor",
                "scalbn",
                "__muldf3",
                "__aeabi_dadd",
                "__aeabi_dcmpeq",
                "__aeabi_d2iz",
                "__aeabi_i2d",
                "__subdf3",
                "__aeabi_dcmpge"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0800a5a0",
            "calling": [
                "__ieee754_rem_pio2"
            ],
            "imported": false,
            "current_name": "FUNC_0800a5a0"
        },
        "FUN_0800195c": {
            "renaming": {
                "FUN_0800195c": "check_sys_status_0800195c",
                "PTR_sys_08001990": "sys_status"
            },
            "code": "void check_sys_status_0800195c(void)\n{\n    if ((PTR_sys_08001990[1] != '\\x06') && ((PTR_sys_08001990[2] & 0x20) == 0)) {\n        mc_reset();\n        PTR_sys_08001990[2] |= 0x40;\n    }\n    return;\n}",
            "called": [
                "mc_reset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800195c",
            "calling": [
                "debounce_on_handler"
            ],
            "imported": false,
            "current_name": "check_sys_status_0800195c"
        },
        "FUN_08009214": {
            "renaming": {
                "FUN_08009214": "check_char_not_null_08009214",
                "in_ZR": "input_char"
            },
            "code": "bool check_char_not_null_08009214(char input_char)\n{\n  __aeabi_cfcmpeq();\n  return input_char != '\\0';\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009214",
            "calling": [
                "planner_forward_pass_kernel",
                "planner_reverse_pass_kernel",
                "mc_arc",
                "gc_execute_line",
                "read_float",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "check_char_not_null_08009214"
        },
        "FUN_08004dd2": {
            "renaming": {
                "FUN_08004dd2": "read_settings_from_eeprom_08004dd2",
                "bVar1": "eeprom_value",
                "iVar2": "result",
                "version": "version",
                "PTR_settings_08004e2c": "settings",
                "memcpy_from_eeprom_with_checksum": "memcpy_from_eeprom_with_checksum",
                "settings_reset": "reset_settings",
                "SETTINGS_SIZE": "SETTINGS_SIZE"
            },
            "code": "uint8_t read_settings_from_eeprom_08004dd2(void)\n{\n  byte version;\n  byte eeprom_value;\n  int result;\n  \n  version = eeprom_get_char(0);\n  if (version == 5) {\n    result = memcpy_from_eeprom_with_checksum(PTR_settings_08004e2c, 1, SETTINGS_SIZE);\n    if (result == 0) {\n      return 0;\n    }\n  }\n  else {\n    if (version > 4) {\n      return 0;\n    }\n    result = memcpy_from_eeprom_with_checksum(PTR_settings_08004e2c, 1, 0x28);\n    if (result == 0) {\n      return 0;\n    }\n    reset_PTR_settings_08004e2c(false);\n  }\n  return 1;\n}",
            "called": [
                "settings_reset",
                "memcpy_from_eeprom_with_checksum",
                "eeprom_get_char"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004dd2",
            "calling": [
                "settings_init"
            ],
            "imported": false,
            "current_name": "read_settings_from_eeprom_08004dd2"
        },
        "FUN_08008244": {
            "renaming": {
                "FUN_08008244": "do_nothing_08008244"
            },
            "code": "\nvoid do_nothing_08008244(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008244",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "do_nothing_08008244"
        },
        "FUN_08005778": {
            "renaming": {
                "FUN_08005778": "execute_step_08005778",
                "PTR_saved_step_bits_0800578c": "PTR_saved_step_bits",
                "step_wr": "write_step"
            },
            "code": "void execute_step_08005778(void)\n{\n  uint16_t* step_bits = (uint16_t*)PTR_saved_step_bits_0800578c_0800578c;\n  uint16_t step_value = *step_bits;\n  step_wr(step_value);\n  return;\n}",
            "called": [
                "step_wr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005778",
            "calling": [
                "TIM2_IRQHandler"
            ],
            "imported": false,
            "current_name": "execute_step_08005778"
        },
        "FUN_080028bc": {
            "renaming": {
                "FUN_080028bc": "calculateAcceleration_080028bc",
                "initial_rate": "initialSpeed",
                "target_rate": "targetSpeed",
                "acceleration": "time",
                "in_r0": "unusedVariable1",
                "in_r1": "speedDifference",
                "in_r2": "unusedVariable2",
                "uVar1": "speedDifferenceSquared",
                "uVar2": "timeSquared",
                "fVar3": "acceleration"
            },
            "code": "float calculateAcceleration_080028bc(float initialSpeed, float targetSpeed, float time) {\n  float speedDifferenceSquared = pow(targetSpeed - initialSpeed, 2);\n  float timeSquared = pow(time, 2);\n  float acceleration = speedDifferenceSquared / (2 * timeSquared);\n  return acceleration;\n}",
            "called": [
                "__addsf3",
                "__aeabi_fmul",
                "__aeabi_fsub",
                "__aeabi_fdiv"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080028bc",
            "calling": [
                "calculate_trapezoid_for_block"
            ],
            "imported": false,
            "current_name": "calculateAcceleration_080028bc"
        },
        "FUN_08006628": {
            "renaming": {
                "FUN_08006628": "get_system_core_clock_frequency_08006628",
                "uVar1": "sys_clock_freq",
                "uVar2": "leading_zeroes",
                "PTR_SystemCoreClock_0800667c": "system_core_clock_ptr",
                "PTR_APBAHBPrescTable_08006678": "apb_ahb_presc_table",
                "DAT_08006674": "system_core_clock_ptr"
            },
            "code": "uint32_t get_system_core_clock_frequency_08006628(void)\n{\n  uint32_t sys_clock_freq = HAL_RCC_GetSysClockFreq();\n  uint leading_zeroes = count_leading_zeroes(0xf000000);\n  uint PTR_APBAHBPrescTable_08006678_index = (*(uint *)(PTR_SystemCoreClock_0800667c + 8) & 0xf0) >> (leading_zeroes & 0xff);\n  *(uint32_t *)PTR_SystemCoreClock_0800667c = sys_clock_freq >> PTR_APBAHBPrescTable_08006678[PTR_APBAHBPrescTable_08006678_index];\n  return *(uint32_t *)PTR_SystemCoreClock_0800667c;\n}",
            "called": [
                "HAL_RCC_GetSysClockFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006628",
            "calling": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "imported": false,
            "current_name": "get_system_core_clock_frequency_08006628"
        },
        "FUN_080078e2": {
            "renaming": {
                "FUN_080078e2": "do_nothing_080078e2"
            },
            "code": "\nvoid do_nothing_080078e2(uint32_t bits)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078e2",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_080078e2"
        },
        "FUN_08008b38": {
            "renaming": {
                "FUN_08008b38": "check_for_equality_08008b38",
                "in_CY": "is_CY_zero",
                "in_ZR": "is_ZR_nonzero"
            },
            "code": "bool check_for_equality_08008b38(void)\n{\n  bool is_CY_zero, is_ZR_nonzero;\n  is_CY_zero = __aeabi_cdcmpeq();\n  is_ZR_nonzero = !is_CY_zero;\n  return is_CY_zero || is_ZR_nonzero;\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b38",
            "calling": [],
            "imported": false,
            "current_name": "check_for_equality_08008b38"
        },
        "FUN_0800738e": {
            "renaming": {
                "FUN_0800738e": "process_GPIO_Pin_0800738e",
                "GPIO_Pin": "pin",
                "DAT_080073bc": "data_offset"
            },
            "code": "void process_GPIO_Pin_0800738e(uint16_t pin) {\n  uint32_t* data = (uint32_t*)(DAT_080073bc + 0x14);\n  uint32_t mask = *data;\n  if ((pin & mask) != 0) {\n    *data = pin;\n    HAL_GPIO_EXTI_Callback(pin);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800738e",
            "calling": [],
            "imported": false,
            "current_name": "process_GPIO_Pin_0800738e"
        },
        "FUN_08002828": {
            "renaming": {
                "FUN_08002828": "do_nothing_08002828"
            },
            "code": "\nvoid do_nothing_08002828(uint32_t us)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002828",
            "calling": [
                "homing_cycle"
            ],
            "imported": false,
            "current_name": "do_nothing_08002828"
        },
        "FUN_080053a0": {
            "renaming": {
                "FUN_080053a0": "update_step_direction_080053a0",
                "pbVar1": "current_block",
                "iVar2": "iteration_result",
                "plan_get_current_block": "get_current_block",
                "st_go_idle": "go_idle",
                "set_step_events_per_minute": "set_events_per_minute",
                "plan_discard_current_block": "discard_current_block"
            },
            "code": "\nvoid update_step_direction_080053a0(void)\n\n{\n  block_t *current_block;\n  int iteration_result;\n  \n  dirn_wr((uint)*(ushort *)PTR_dirn_bits_080055f0);\n  *(undefined2 *)PTR_saved_step_bits_080055f8 = *(undefined2 *)PTR_step_bits_080055f4;\n  if (*(int *)PTR_current_block_080055fc == 0) {\n    current_block = get_current_block();\n    *(block_t **)PTR_current_block_080055fc = current_block;\n    if (*(int *)PTR_current_block_080055fc == 0) {\n      go_idle();\n      PTR_sys_08005600[2] = PTR_sys_08005600[2] | 4;\n    }\n    else {\n      if (PTR_sys_08005600[1] == '\\x03') {\n        *(undefined4 *)(PTR_st_08005604 + 0x1c) =\n             *(undefined4 *)(*(int *)PTR_current_block_080055fc + 0x28);\n        set_events_per_minute(*(uint32_t *)(PTR_st_08005604 + 0x1c));\n        *(undefined4 *)(PTR_st_08005604 + 0x18) = DAT_08005608;\n      }\n      *(int *)(PTR_st_08005604 + 0x20) =\n           (*(int *)(*(int *)PTR_current_block_080055fc + 0x30) >> 1) +\n           *(int *)(*(int *)PTR_current_block_080055fc + 0x30);\n      *(int *)PTR_st_08005604 = -(*(int *)(*(int *)PTR_current_block_080055fc + 0x10) >> 1);\n      *(undefined4 *)(PTR_st_08005604 + 4) = *(undefined4 *)PTR_st_08005604;\n      *(undefined4 *)(PTR_st_08005604 + 8) = *(undefined4 *)PTR_st_08005604;\n      *(undefined4 *)(PTR_st_08005604 + 0xc) =\n           *(undefined4 *)(*(int *)PTR_current_block_080055fc + 0x10);\n      *(undefined4 *)(PTR_st_08005604 + 0x10) = 0;\n    }\n  }\n  if (*(int *)PTR_current_block_080055fc != 0) {\n    *(undefined2 *)PTR_dirn_bits_080055f0 = **(undefined2 **)PTR_current_block_080055fc;\n    *(undefined2 *)PTR_step_bits_080055f4 = 0;\n    *(int *)PTR_st_08005604 =\n         *(int *)(*(int *)PTR_current_block_080055fc + 4) + *(int *)PTR_st_08005604;\n    if (0 < *(int *)PTR_st_08005604) {\n      *(ushort *)PTR_step_bits_080055f4 = *(ushort *)PTR_step_bits_080055f4 | 0x10;\n      *(int *)PTR_st_08005604 = *(int *)PTR_st_08005604 - *(int *)(PTR_st_08005604 + 0xc);\n      if ((*(ushort *)PTR_dirn_bits_080055f0 & 0x20) == 0) {\n        *(int *)(PTR_sys_08005600 + 4) = *(int *)(PTR_sys_08005600 + 4) + 1;\n      }\n      else {\n        *(int *)(PTR_sys_08005600 + 4) = *(int *)(PTR_sys_08005600 + 4) + -1;\n      }\n    }\n    *(int *)(PTR_st_08005604 + 4) =\n         *(int *)(*(int *)PTR_current_block_080055fc + 8) + *(int *)(PTR_st_08005604 + 4);\n    if (0 < *(int *)(PTR_st_08005604 + 4)) {\n      *(ushort *)PTR_step_bits_080055f4 = *(ushort *)PTR_step_bits_080055f4 | 0x440;\n      *(int *)(PTR_st_08005604 + 4) =\n           *(int *)(PTR_st_08005604 + 4) - *(int *)(PTR_st_08005604 + 0xc);\n      if ((*(ushort *)PTR_dirn_bits_080055f0 & 0x80) == 0) {\n        *(int *)(PTR_sys_08005600 + 8) = *(int *)(PTR_sys_08005600 + 8) + 1;\n      }\n      else {\n        *(int *)(PTR_sys_08005600 + 8) = *(int *)(PTR_sys_08005600 + 8) + -1;\n      }\n    }\n    *(int *)(PTR_st_08005604 + 8) =\n         *(int *)(*(int *)PTR_current_block_080055fc + 0xc) + *(int *)(PTR_st_08005604 + 8);\n    if (0 < *(int *)(PTR_st_08005604 + 8)) {\n      *(ushort *)PTR_step_bits_080055f4 = *(ushort *)PTR_step_bits_080055f4 | 0x100;\n      *(int *)(PTR_st_08005604 + 8) =\n           *(int *)(PTR_st_08005604 + 8) - *(int *)(PTR_st_08005604 + 0xc);\n      if ((*(ushort *)PTR_dirn_bits_080055f0 & 0x200) == 0) {\n        *(int *)(PTR_sys_08005600 + 0xc) = *(int *)(PTR_sys_08005600 + 0xc) + 1;\n      }\n      else {\n        *(int *)(PTR_sys_08005600 + 0xc) = *(int *)(PTR_sys_08005600 + 0xc) + -1;\n      }\n    }\n    *(int *)(PTR_st_08005604 + 0x10) = *(int *)(PTR_st_08005604 + 0x10) + 1;\n    if (*(uint *)(PTR_st_08005604 + 0x10) < *(uint *)(*(int *)PTR_current_block_080055fc + 0x10)) {\n      if (PTR_sys_08005600[1] == '\\x04') {\n        iteration_result = iterate_trapezoid_cycle_counter();\n        if (iteration_result != 0) {\n          if (*(uint *)(*(int *)PTR_current_block_080055fc + 0x30) <\n              *(uint *)(PTR_st_08005604 + 0x1c)) {\n            *(int *)(PTR_st_08005604 + 0x1c) =\n                 *(int *)(PTR_st_08005604 + 0x1c) -\n                 *(int *)(*(int *)PTR_current_block_080055fc + 0x30);\n            set_events_per_minute(*(uint32_t *)(PTR_st_08005604 + 0x1c));\n          }\n          else {\n            go_idle();\n            PTR_sys_08005600[2] = PTR_sys_08005600[2] | 4;\n          }\n        }\n      }\n      else if (*(uint *)(PTR_st_08005748 + 0x10) <\n               *(uint *)(*(int *)PTR_current_block_0800574c + 0x34)) {\n        iteration_result = iterate_trapezoid_cycle_counter();\n        if (iteration_result != 0) {\n          *(int *)(PTR_st_08005748 + 0x1c) =\n               *(int *)(PTR_st_08005748 + 0x1c) +\n               *(int *)(*(int *)PTR_current_block_0800574c + 0x30);\n          if (*(uint *)(*(int *)PTR_current_block_0800574c + 0x3c) <=\n              *(uint *)(PTR_st_08005748 + 0x1c)) {\n            *(undefined4 *)(PTR_st_08005748 + 0x1c) =\n                 *(undefined4 *)(*(int *)PTR_current_block_0800574c + 0x3c);\n          }\n          set_events_per_minute(*(uint32_t *)(PTR_st_08005748 + 0x1c));\n        }\n      }\n      else if (*(uint *)(PTR_st_08005748 + 0x10) <\n               *(uint *)(*(int *)PTR_current_block_0800574c + 0x38)) {\n        if (*(int *)(PTR_st_08005748 + 0x1c) != *(int *)(*(int *)PTR_current_block_0800574c + 0x3c))\n        {\n          *(undefined4 *)(PTR_st_08005748 + 0x1c) =\n               *(undefined4 *)(*(int *)PTR_current_block_0800574c + 0x3c);\n          set_events_per_minute(*(uint32_t *)(PTR_st_08005748 + 0x1c));\n        }\n      }\n      else if (*(int *)(PTR_st_08005748 + 0x10) ==\n               *(int *)(*(int *)PTR_current_block_0800574c + 0x38)) {\n        if (*(int *)(PTR_st_08005748 + 0x1c) == *(int *)(*(int *)PTR_current_block_0800574c + 0x3c))\n        {\n          *(undefined4 *)(PTR_st_08005748 + 0x18) = DAT_08005750;\n        }\n        else {\n          *(int *)(PTR_st_08005748 + 0x18) = 420000 - *(int *)(PTR_st_08005748 + 0x18);\n        }\n      }\n      else {\n        iteration_result = iterate_trapezoid_cycle_counter();\n        if (iteration_result != 0) {\n          if (*(uint *)(PTR_st_08005748 + 0x20) < *(uint *)(PTR_st_08005748 + 0x1c)) {\n            *(int *)(PTR_st_08005748 + 0x1c) =\n                 *(int *)(PTR_st_08005748 + 0x1c) -\n                 *(int *)(*(int *)PTR_current_block_0800574c + 0x30);\n          }\n          else {\n            *(uint *)(PTR_st_08005748 + 0x1c) = *(uint *)(PTR_st_08005748 + 0x1c) >> 1;\n          }\n          if (*(uint *)(PTR_st_08005748 + 0x1c) <\n              *(uint *)(*(int *)PTR_current_block_0800574c + 0x2c)) {\n            *(undefined4 *)(PTR_st_08005748 + 0x1c) =\n                 *(undefined4 *)(*(int *)PTR_current_block_0800574c + 0x2c);\n          }\n          set_events_per_minute(*(uint32_t *)(PTR_st_08005748 + 0x1c));\n        }\n      }\n    }\n    else {\n      *(undefined2 *)PTR_step_bits_08005754 = 0;\n      *(undefined4 *)PTR_current_block_0800574c = 0;\n      discard_current_block();\n    }\n  }\n  *(ushort *)PTR_step_bits_08005754 =\n       *(ushort *)PTR_step_bits_08005754 ^ *(ushort *)(PTR_settings_08005758 + 0x18);\n  *(ushort *)PTR_dirn_bits_0800575c =\n       *(ushort *)PTR_dirn_bits_0800575c ^ *(ushort *)(PTR_settings_08005758 + 0x1a);\n  return;\n}\n\n",
            "called": [
                "iterate_trapezoid_cycle_counter",
                "plan_discard_current_block",
                "st_go_idle",
                "plan_get_current_block",
                "dirn_wr",
                "set_step_events_per_minute"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053a0",
            "calling": [
                "TIM2_IRQHandler"
            ],
            "imported": false,
            "current_name": "update_step_direction_080053a0"
        },
        "FUN_080092c4": {
            "renaming": {
                "FUN_080092c4": "initialize_system_080092c4",
                "iVar1": "index",
                "puVar2": "completed_ptr",
                "UNRECOVERED_JUMPTABLE": "UNRECOVERED_JUMPTABLE",
                "PTR_completed_8911_0800930c": "PTR_completed_8911_0800930c",
                "PTR_SystemCoreClock_08009304": "PTR_SystemCoreClock_08009304",
                "PTR_completed_8911_08009308": "PTR_completed_8911_08009308",
                "PTR___fini_array_end_08009300": "PTR___fini_array_end_08009300",
                "PTR__ebss_08009310": "PTR__ebss_08009310",
                "SystemInit": "SystemInit",
                "__libc_init_array": "__libc_init_array",
                "main": "main"
            },
            "code": "void initialize_system_080092c4(void)\n{\n  int index;\n  undefined4 *completed_ptr = (undefined4 *)PTR_completed_8911_0800930c;\n  undefined4 *clock_ptr = (undefined4 *)PTR_SystemCoreClock_08009304;\n  undefined4 *ebss_ptr = (undefined4 *)PTR__ebss_08009310;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (index = 0; clock_ptr + index < (undefined4 *)PTR_completed_8911_08009308; index += 4) {\n    *(undefined4 *)(clock_ptr + index) = *(undefined4 *)(PTR___fini_array_end_08009300 + index);\n  }\n  \n  for (; completed_ptr < ebss_ptr; completed_ptr++) {\n    *completed_ptr = 0;\n  }\n  \n  SystemInit();\n  __libc_init_array();\n  UNRECOVERED_JUMPTABLE = (code *)0x80092fa;\n  main();\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}",
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080092c4",
            "calling": [],
            "imported": false,
            "current_name": "initialize_system_080092c4"
        },
        "FUN_0800770e": {
            "renaming": {
                "FUN_0800770e": "do_nothing_0800770e"
            },
            "code": "\nvoid do_nothing_0800770e(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800770e",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800770e"
        },
        "FUN_08008250": {
            "renaming": {
                "FUN_08008250": "print_byte_08008250",
                "data": "byte_to_print"
            },
            "code": "void print_byte_08008250(uint8_t byte_to_print)\n{\n  usart_putc(byte_to_print);\n  return;\n}",
            "called": [
                "usart_putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008250",
            "calling": [
                "printString",
                "printInteger",
                "print_uint32_base10",
                "print_base2",
                "printPgmString",
                "printFloat"
            ],
            "imported": false,
            "current_name": "print_byte_08008250"
        },
        "FUN_0800184c": {
            "renaming": {
                "FUN_0800184c": "validate_input_0800184c",
                "letter": "current_char",
                "float_ptr": "float_value",
                "line": "input_string",
                "char_counter": "char_index",
                "iVar1": "result"
            },
            "code": "int validate_input_0800184c(char *current_char, float *float_value, char *input_string, uint8_t *char_index)\n{\n  int result;\n  \n  if (input_string[*char_index] == \"\\0\") {\n    result = 0;\n  }\n  else {\n    *current_char = input_string[*char_index];\n    if (((byte)*current_char < 0x41) || (0x5a < (byte)*current_char)) {\n      *PTR_gc_080018c8 = 2;\n      result = 0;\n    }\n    else {\n      *char_index = *char_index + \"\\x01\";\n      result = read_float(input_string, char_index, float_value);\n      if (result == 0) {\n        *PTR_gc_080018c8 = 1;\n        result = 0;\n      }\n      else {\n        result = 1;\n      }\n    }\n  }\n  return result;\n}",
            "called": [
                "read_float"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800184c",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "validate_input_0800184c"
        },
        "FUN_08001f00": {
            "renaming": {
                "FUN_08001f00": "move_in_arc_08001f00",
                "position": "start_pos",
                "target": "end_pos",
                "axis_0": "start_axis_0",
                "axis_1": "start_axis_1",
                "axis_linear": "linear_axis",
                "feed_rate": "travel_speed",
                "invert_feed_rate": "inverse_feed_rate",
                "radius": "arc_radius",
                "isclockwise": "clockwise",
                "uVar1": "linear_distance",
                "bVar11": "start_axis_0_byte",
                "r_axis0": "center_to_start_axis_0",
                "r_axis1": "center_to_start_axis_1",
                "uVar2": "center_to_target_axis_0",
                "uVar3": "center_to_target_axis_1",
                "uVar4": "r_axis1_mul_center_to_target_axis_0",
                "uVar5": "r_axis0_mul_center_to_target_axis_1",
                "uVar8": "atan2_arg_1",
                "uVar9": "atan2_arg_2",
                "sin_T": "sin_theta",
                "cos_T": "cos_theta",
                "linear_per_segment": "linear_travel_per_segment",
                "segments": "num_segments",
                "millimeters_of_travel": "travel_distance",
                "rt_axis1": "r_axis_1",
                "rt_axis0": "r_axis_0",
                "center_axis1": "center_axis_1",
                "center_axis0": "center_axis_0",
                "count": "segment_count",
                "i": "segment_index",
                "angular_travel": "theta",
                "arc_target": "arc_end",
                "fVar7": "new_center_axis_0",
                "z": "new_center_axis_1",
                "feed_rate_00": "travel_speed_0",
                "feed_rate_01": "travel_speed_1",
                "in_stack_00000009": "unused_stack_var",
                "in_stack_00000010": "segment_length",
                "in_stack_00000014": "is_counter_clockwise",
                "in_stack_ffffff78": "distance_squared_axis_linear",
                "in_stack_ffffff7c": "distance_squared_offset",
                "in_stack_ffffff80": "start_axis_0_and_offset"
            },
            "code": "\nvosegment_indexd move_in_arc_08001f00(float *start_pos,float *end_pos,float *offset,usegment_indexnt8_t start_axis_0,usegment_indexnt8_t start_axis_1,\n           usegment_indexnt8_t linear_axis,float travel_speed,usegment_indexnt8_t inverse_feed_rate,float arc_radius,\n           usegment_indexnt8_t clockwise)\n\n{\n  usegment_indexnt linear_distance;\n  undefsegment_indexned4 center_to_target_axis_0;\n  undefsegment_indexned4 center_to_target_axis_1;\n  undefsegment_indexned4 r_axis1_mul_center_to_target_axis_0;\n  undefsegment_indexned4 r_axis0_mul_center_to_target_axis_1;\n  segment_indexnt segment_indexVar6;\n  float new_center_axis_0;\n  undefsegment_indexned4 extraout_r1;\n  undefsegment_indexned4 extraout_r1_00;\n  undefsegment_indexned4 extraout_r1_01;\n  undefsegment_indexned4 extraout_r1_02;\n  undefsegment_indexned8 extraout_d0;\n  undefsegment_indexned8 extraout_d0_00;\n  undefsegment_indexned8 extraout_d0_01;\n  float extraout_s2;\n  float new_center_axis_1;\n  float extraout_s2_00;\n  float extraout_s3;\n  float travel_speed_0;\n  float extraout_s3_00;\n  float travel_speed_1;\n  undefsegment_indexned8 atan2_arg_1;\n  undefsegment_indexned8 atan2_arg_2;\n  undefsegment_indexned3 unused_stack_var;\n  undefsegment_indexned4 segment_length;\n  char is_counter_clockwise;\n  usegment_indexnt distance_squared_axis_linear;\n  undefsegment_indexned4 distance_squared_offset;\n  undefsegment_indexned3 start_axis_0_and_offset;\n  usegment_indexnt linear_distance0;\n  byte start_axis_0_byte;\n  float arc_end [3];\n  float r_axsegment_indexssegment_index;\n  float sin_thetasegment_index;\n  float cos_thetasegment_index;\n  float sin_theta;\n  float cos_theta;\n  float linear_travel_per_segment;\n  float theta_per_segment;\n  usegment_indexnt16_t num_segments;\n  float travel_distance;\n  float r_axis_1;\n  float r_axis_0;\n  float lsegment_indexnear_travel;\n  float center_axis_1;\n  float center_axis_0;\n  segment_indexnt8_t segment_count;\n  usegment_indexnt16_t segment_index;\n  float theta;\n  float center_to_start_axis_1;\n  float center_to_start_axis_0;\n  \n  linear_distance0 = CONCAT13(start_axis_0,start_axis_0_and_offset);\n  center_axis_0 = (float)__addsf3(travel_speed,start_pos[start_axis_0],offset[start_axis_0]);\n  center_axis_1 = (float)__addsf3(start_pos[start_axis_1],offset[start_axis_1]);\n  linear_distance = __aeabsegment_index_fsub(end_pos[linear_axis],start_pos[linear_axis]);\n  start_axis_0_byte = (byte)(linear_distance0 >> 0x18);\n  center_to_start_axis_0 = (float)((usegment_indexnt)offset[start_axis_0_byte] ^ 0x80000000);\n  center_to_start_axis_1 = (float)((usegment_indexnt)offset[start_axis_1] ^ 0x80000000);\n  center_to_target_axis_0 = __aeabsegment_index_fsub(end_pos[start_axis_0_byte],center_axis_0);\n  center_to_target_axis_1 = __aeabsegment_index_fsub(end_pos[start_axis_1],center_axis_1);\n  r_axis1_mul_center_to_target_axis_0 = __aeabsegment_index_fmul(center_to_start_axis_0,center_to_target_axis_1);\n  r_axis0_mul_center_to_target_axis_1 = __aeabsegment_index_fmul(center_to_start_axis_1,center_to_target_axis_0);\n  r_axis1_mul_center_to_target_axis_0 = __aeabsegment_index_fsub(r_axis1_mul_center_to_target_axis_0,r_axis0_mul_center_to_target_axis_1);\n  atan2_arg_1 = __aeabsegment_index_f2d(r_axis1_mul_center_to_target_axis_0);\n  center_to_target_axis_0 = __aeabsegment_index_fmul(center_to_start_axis_0,center_to_target_axis_0);\n  center_to_target_axis_1 = __aeabsegment_index_fmul(center_to_start_axis_1,center_to_target_axis_1);\n  center_to_target_axis_0 = __addsf3(center_to_target_axis_0,center_to_target_axis_1);\n  atan2_arg_2 = __aeabsegment_index_f2d(center_to_target_axis_0);\n  atan2_arg_1 = atan2((segment_indexnt)atan2_arg_1,(segment_indexnt)((ulonglong)atan2_arg_1 >> 0x20),(segment_indexnt)atan2_arg_2,\n                (segment_indexnt)((ulonglong)atan2_arg_2 >> 0x20));\n  theta = (float)__truncdfsf2((segment_indexnt)atan2_arg_1,(segment_indexnt)((ulonglong)atan2_arg_1 >> 0x20));\n  segment_indexf (is_counter_clockwise == '\\0') {\n    segment_indexVar6 = __aeabsegment_index_fcmple(theta,0);\n    segment_indexf (segment_indexVar6 != 0) {\n      atan2_arg_1 = __aeabsegment_index_f2d(theta);\n      atan2_arg_1 = __aeabsegment_index_dadd((segment_indexnt)atan2_arg_1,(segment_indexnt)((ulonglong)atan2_arg_1 >> 0x20),DAT_08002240,DAT_08002244);\n      theta = (float)__truncdfsf2((segment_indexnt)atan2_arg_1,(segment_indexnt)((ulonglong)atan2_arg_1 >> 0x20));\n    }\n  }\n  else {\n    segment_indexVar6 = __aeabsegment_index_fcmpge(theta,0);\n    segment_indexf (segment_indexVar6 != 0) {\n      atan2_arg_1 = __aeabsegment_index_f2d(theta);\n      atan2_arg_1 = __subdf3((segment_indexnt)atan2_arg_1,(segment_indexnt)((ulonglong)atan2_arg_1 >> 0x20),DAT_08002240,DAT_08002244);\n      theta = (float)__truncdfsf2((segment_indexnt)atan2_arg_1,(segment_indexnt)((ulonglong)atan2_arg_1 >> 0x20));\n    }\n  }\n  center_to_target_axis_0 = __aeabsegment_index_fmul(theta,segment_length);\n  center_to_target_axis_0 = __aeabsegment_index_f2d(center_to_target_axis_0);\n  __aeabsegment_index_f2d(linear_distance & 0x7fffffff);\n  hypot((double)CONCAT44(distance_squared_offset,distance_squared_axis_linear),(double)CONCAT44(offset,linear_distance0));\n  center_to_target_axis_0 = __truncdfsf2(center_to_target_axis_0,extraout_r1);\n  segment_indexVar6 = __aeabsegment_index_fcmpeq(center_to_target_axis_0,0);\n  segment_indexf (segment_indexVar6 == 0) {\n    center_to_target_axis_0 = __aeabsegment_index_fdsegment_indexv(center_to_target_axis_0,*(undefsegment_indexned4 *)(PTR_settsegment_indexngs_08002248 + 0x1c));\n    center_to_target_axis_0 = __aeabsegment_index_f2d(center_to_target_axis_0);\n    floor((double)CONCAT44(distance_squared_offset,distance_squared_axis_linear));\n    num_segments = __aeabsegment_index_d2usegment_indexnew_center_axis_1(center_to_target_axis_0,extraout_r1_00);\n    segment_indexf (clockwise != '\\0') {\n      center_to_target_axis_0 = __floatssegment_indexsf(num_segments);\n      __aeabsegment_index_fmul(_inverse_feed_rate,center_to_target_axis_0);\n    }\n    center_to_target_axis_0 = __floatssegment_indexsf(num_segments);\n    sin_theta = (float)__aeabsegment_index_fdsegment_indexv(theta,center_to_target_axis_0);\n    center_to_target_axis_0 = __floatssegment_indexsf(num_segments);\n    linear_travel_per_segment = (float)__aeabsegment_index_fdsegment_indexv(linear_distance,center_to_target_axis_0);\n    atan2_arg_1 = __aeabsegment_index_f2d(sin_theta);\n    atan2_arg_1 = __muldf3((segment_indexnt)atan2_arg_1,(segment_indexnt)((ulonglong)atan2_arg_1 >> 0x20),0,DAT_0800224c);\n    atan2_arg_2 = __aeabsegment_index_f2d(sin_theta);\n    atan2_arg_1 = __muldf3((segment_indexnt)atan2_arg_1,(segment_indexnt)((ulonglong)atan2_arg_1 >> 0x20),(segment_indexnt)atan2_arg_2,\n                     (segment_indexnt)((ulonglong)atan2_arg_2 >> 0x20));\n    atan2_arg_1 = __subdf3(0,DAT_08002250,(segment_indexnt)atan2_arg_1,(segment_indexnt)((ulonglong)atan2_arg_1 >> 0x20));\n    cos_theta = (float)__truncdfsf2((segment_indexnt)atan2_arg_1,(segment_indexnt)((ulonglong)atan2_arg_1 >> 0x20));\n    segment_count = '\\0';\n    theta_per_segment = sin_theta;\n    arc_end[linear_axis] = start_pos[linear_axis];\n    atan2_arg_1 = extraout_d0;\n    new_center_axis_0 = extraout_s2;\n    travel_speed_1 = extraout_s3;\n    for (segment_index = 1; segment_index < num_segments; segment_index = segment_index + 1) {\n      segment_indexf ((segment_indexnt)segment_count < (segment_indexnt)(usegment_indexnt)(byte)PTR_settsegment_indexngs_08002248[0x3e]) {\n        center_to_target_axis_0 = __aeabsegment_index_fmul(center_to_start_axis_0,sin_theta);\n        center_to_target_axis_1 = __aeabsegment_index_fmul(center_to_start_axis_1,cos_theta);\n        new_center_axis_0 = (float)__addsf3(center_to_target_axis_0,center_to_target_axis_1);\n        center_to_target_axis_0 = __aeabsegment_index_fmul(center_to_start_axis_0,cos_theta);\n        center_to_target_axis_1 = __aeabsegment_index_fmul(center_to_start_axis_1,sin_theta);\n        center_to_start_axis_0 = (float)__aeabsegment_index_fsub(center_to_target_axis_0,center_to_target_axis_1);\n        segment_count = segment_count + '\\x01';\n        center_to_start_axis_1 = new_center_axis_0;\n      }\n      else {\n        center_to_target_axis_0 = __floatssegment_indexsf(segment_index);\n        center_to_target_axis_0 = __aeabsegment_index_fmul(center_to_target_axis_0,theta_per_segment);\n        center_to_target_axis_0 = __aeabsegment_index_f2d(center_to_target_axis_0);\n        cos((double)CONCAT44(distance_squared_offset,distance_squared_axis_linear));\n        center_to_target_axis_0 = __truncdfsf2(center_to_target_axis_0,extraout_r1_01);\n        center_to_target_axis_1 = __floatssegment_indexsf(segment_index);\n        center_to_target_axis_1 = __aeabsegment_index_fmul(center_to_target_axis_1,theta_per_segment);\n        center_to_target_axis_1 = __aeabsegment_index_f2d(center_to_target_axis_1);\n        ssegment_indexn((double)CONCAT44(distance_squared_offset,distance_squared_axis_linear));\n        center_to_target_axis_1 = __truncdfsf2(center_to_target_axis_1,extraout_r1_02);\n        r_axis1_mul_center_to_target_axis_0 = __aeabsegment_index_fmul((usegment_indexnt)offset[linear_distance0 >> 0x18] ^ 0x80000000,center_to_target_axis_0);\n        r_axis0_mul_center_to_target_axis_1 = __aeabsegment_index_fmul(offset[start_axis_1],center_to_target_axis_1);\n        center_to_start_axis_0 = (float)__addsf3(r_axis1_mul_center_to_target_axis_0,r_axis0_mul_center_to_target_axis_1);\n        center_to_target_axis_1 = __aeabsegment_index_fmul((usegment_indexnt)offset[linear_distance0 >> 0x18] ^ 0x80000000,center_to_target_axis_1);\n        center_to_target_axis_0 = __aeabsegment_index_fmul(offset[start_axis_1],center_to_target_axis_0);\n        center_to_start_axis_1 = (float)__aeabsegment_index_fsub(center_to_target_axis_1,center_to_target_axis_0);\n        segment_count = '\\0';\n      }\n      linear_distance = linear_distance0 >> 0x18;\n      new_center_axis_0 = (float)__addsf3(center_axis_0,center_to_start_axis_0);\n      arc_end[linear_distance] = new_center_axis_0;\n      new_center_axis_0 = (float)__addsf3(center_axis_1,center_to_start_axis_1);\n      arc_end[start_axis_1] = new_center_axis_0;\n      new_center_axis_0 = (float)__addsf3(arc_end[linear_axis],linear_travel_per_segment);\n      arc_end[linear_axis] = new_center_axis_0;\n      distance_squared_axis_linear = (usegment_indexnt)clockwise;\n      mc_lsegment_indexne((float)extraout_d0_00,(float)((ulonglong)extraout_d0_00 >> 0x20),new_center_axis_1,travel_speed_0,\n              SUB41(arc_end[0],0));\n      segment_indexf (*PTR_sys_08002404 != '\\0') {\n        return;\n      }\n      atan2_arg_1 = extraout_d0_01;\n      new_center_axis_0 = extraout_s2_00;\n      travel_speed_1 = extraout_s3_00;\n    }\n    mc_lsegment_indexne((float)atan2_arg_1,(float)((ulonglong)atan2_arg_1 >> 0x20),new_center_axis_0,travel_speed_1,SUB41(*end_pos,0));\n  }\n  return;\n}\n\n",
            "called": [
                "__aeabi_fcmple",
                "__aeabi_fcmpge",
                "atan2",
                "__truncdfsf2",
                "__aeabi_fsub",
                "__aeabi_dadd",
                "__muldf3",
                "cos",
                "__aeabi_fdiv",
                "mc_line",
                "__subdf3",
                "floor",
                "__addsf3",
                "sin",
                "__aeabi_fmul",
                "__aeabi_fcmpeq",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "hypot",
                "__floatsisf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001f00",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "move_in_arc_08001f00"
        },
        "FUN_08005ad4": {
            "renaming": {
                "FUN_08005ad4": "get_top_bits_of_first_dat_08005ad4",
                "*DAT_08005ae8": "*first_dat_ptr"
            },
            "code": "uint32_t get_top_bits_of_first_dat_08005ad4(void) {\n    uint32_t *DAT_08005ae8 = DAT_08005ae8;\n    uint32_t top_bits = *DAT_08005ae8 >> 0x10;\n    return top_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005ad4",
            "calling": [],
            "imported": false,
            "current_name": "get_top_bits_of_first_dat_08005ad4"
        },
        "FUN_08005b3c": {
            "renaming": {
                "FUN_08005b3c": "set_flag_for_data_08005b3c",
                "DAT_08005b54": "data_start_ptr",
                "PTR_": "ptr_",
                "current_value": "current_value",
                "flag_value": "flag_value",
                "data_ptr": "data_ptr"
            },
            "code": "void set_flag_for_data_08005b3c()\n{\n    uint* data_ptr = (uint*)(DAT_08005b54 + 4);\n    uint current_value = *data_ptr;\n    uint flag_value = 2;\n    *data_ptr = current_value | flag_value;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b3c",
            "calling": [],
            "imported": false,
            "current_name": "set_flag_for_data_08005b3c"
        },
        "FUN_08006ce0": {
            "renaming": {
                "FUN_08006ce0": "set_NVIC_priority_group_08006ce0",
                "PriorityGroup": "priority_group"
            },
            "code": "void set_NVIC_priority_group_08006ce0(uint32_t priority_group)\n{\n  NVIC_SetPriorityGrouping(priority_group);\n  return;\n}",
            "called": [
                "NVIC_SetPriorityGrouping"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ce0",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "set_NVIC_priority_group_08006ce0"
        },
        "FUN_08006d4a": {
            "renaming": {
                "FUN_08006d4a": "disable_interrupt_08006d4a",
                "IRQn": "interrupt_number"
            },
            "code": "void disable_interrupt_08006d4a(IRQn_Type interrupt_number)\n{\n  NVIC_DisableIRQ(interrupt_number);\n  return;\n}",
            "called": [
                "NVIC_DisableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d4a",
            "calling": [],
            "imported": false,
            "current_name": "disable_interrupt_08006d4a"
        },
        "FUN_08008894": {
            "renaming": {
                "FUN_08008894": "calculate_double_precision_floating_point_08008894",
                "param_1": "sign_bit",
                "param_2": "exponent_and_mantissa_high",
                "param_3": "mantissa_low",
                "param_4": "rounding_mode",
                "uVar1": "mask",
                "uVar2": "mask",
                "uVar3": "exponent_difference",
                "uVar4": "shift_amount",
                "uVar5": "mask",
                "uVar6": "shift_amount",
                "uVar7": "significand",
                "iVar8": "exponent_difference",
                "uVar9": "biased_exponent",
                "unaff_r5": "biased_exponent",
                "uVar10": "biased_exponent_and_mantissa_high",
                "uVar11": "mantissa",
                "uVar12": "difference",
                "uVar13": "max_exponent",
                "bVar14": "condition",
                "bVar15": "condition",
                "bVar16": "condition"
            },
            "code": "\nulonglong calculate_double_precision_floating_point_08008894(undefined4 sign_bit,uint exponent_and_mantissa_high,uint mantissa_low,uint rounding_mode)\n\n{\n  uint mask;\n  uint mask;\n  uint exponent_difference;\n  uint shift_amount;\n  uint mask;\n  uint shift_amount;\n  uint significand;\n  int exponent_difference;\n  uint biased_exponent;\n  uint biased_exponent;\n  uint biased_exponent_and_mantissa_high;\n  uint mantissa;\n  uint difference;\n  uint max_exponent;\n  bool condition;\n  bool condition;\n  bool condition;\n  ulonglong mask7;\n  \n  mask7 = CONCAT44(exponent_and_mantissa_high,sign_bit);\n  max_exponent = 0x7ff;\n  significand = exponent_and_mantissa_high >> 0x14 & 0x7ff;\n  condition = significand == 0;\n  if (!condition) {\n    biased_exponent = rounding_mode >> 0x14 & 0x7ff;\n    condition = biased_exponent == 0;\n  }\n  if (!condition) {\n    condition = significand == 0x7ff;\n  }\n  if (!condition) {\n    condition = biased_exponent == 0x7ff;\n  }\n  if (condition) {\n    mask7 = calculate_result_08008a02();\n  }\n  biased_exponent = (uint)(mask7 >> 0x20);\n  mantissa = (uint)mask7;\n  exponent_difference = significand - biased_exponent;\n  if ((mantissa_low | rounding_mode << 0xc) == 0) {\n    significand = (biased_exponent ^ rounding_mode) & 0x80000000 | biased_exponent & 0xfffff;\n    condition = SCARRY4(exponent_difference,max_exponent >> 1);\n    biased_exponent = exponent_difference + (max_exponent >> 1);\n    condition = (int)biased_exponent < 0;\n    condition = biased_exponent == 0;\n    if (!condition && condition == condition) {\n      condition = SBORROW4(max_exponent,biased_exponent);\n      condition = (int)(max_exponent - biased_exponent) < 0;\n      condition = max_exponent == biased_exponent;\n    }\n    if (!condition && condition == condition) {\n      significand = significand | biased_exponent * 0x100000;\n    }\n    if (!condition && condition == condition) {\n      return mask7 & 0xffffffff | (ulonglong)significand << 0x20;\n    }\n    significand = significand | 0x100000;\n    max_exponent = 0;\n    condition = SBORROW4(biased_exponent,1);\n    biased_exponent = biased_exponent - 1;\n    condition = biased_exponent == 0;\n    exponent_difference = biased_exponent;\n  }\n  else {\n    exponent_difference = (rounding_mode << 0xc) >> 4 | 0x10000000 | mantissa_low >> 0x18;\n    max_exponent = mantissa_low << 8;\n    biased_exponent_and_mantissa_high = (biased_exponent << 0xc) >> 4 | 0x10000000 | mantissa >> 0x18;\n    mantissa = mantissa * 0x100;\n    significand = (biased_exponent ^ rounding_mode) & 0x80000000;\n    condition = exponent_difference <= biased_exponent_and_mantissa_high;\n    if (biased_exponent_and_mantissa_high == exponent_difference) {\n      condition = max_exponent <= mantissa;\n    }\n    exponent_difference = exponent_difference + (uint)condition;\n    biased_exponent = exponent_difference + 0x3fd;\n    if (condition == false) {\n      exponent_difference = exponent_difference >> 1;\n      max_exponent = (uint)((mantissa_low >> 0x18 & 1) != 0) << 0x1f | max_exponent >> 1;\n    }\n    difference = mantissa - max_exponent;\n    biased_exponent_and_mantissa_high = (biased_exponent_and_mantissa_high - exponent_difference) - (uint)(mantissa < max_exponent);\n    shift_amount = exponent_difference >> 1;\n    mask = (uint)((exponent_difference & 1) != 0) << 0x1f | max_exponent >> 1;\n    mantissa = 0x100000;\n    exponent_difference = 0x80000;\n    while( true ) {\n      condition = mask <= difference;\n      if (shift_amount < biased_exponent_and_mantissa_high || biased_exponent_and_mantissa_high - shift_amount < (uint)condition) {\n        difference = difference - mask;\n        mantissa = mantissa | exponent_difference;\n        biased_exponent_and_mantissa_high = (biased_exponent_and_mantissa_high - shift_amount) - (uint)!condition;\n      }\n      mask = shift_amount >> 1;\n      mask = (uint)((shift_amount & 1) != 0) << 0x1f | mask >> 1;\n      condition = mask <= difference;\n      condition = biased_exponent_and_mantissa_high - mask < (uint)condition;\n      max_exponent = biased_exponent_and_mantissa_high;\n      if (mask < biased_exponent_and_mantissa_high || condition) {\n        difference = difference - mask;\n        max_exponent = (biased_exponent_and_mantissa_high - mask) - (uint)!condition;\n      }\n      if (mask < biased_exponent_and_mantissa_high || condition) {\n        mantissa = mantissa | exponent_difference >> 1;\n      }\n      biased_exponent_and_mantissa_high = shift_amount >> 2;\n      mask = (uint)((mask & 1) != 0) << 0x1f | mask >> 1;\n      condition = mask <= difference;\n      condition = max_exponent - biased_exponent_and_mantissa_high < (uint)condition;\n      mask = max_exponent;\n      if (biased_exponent_and_mantissa_high < max_exponent || condition) {\n        difference = difference - mask;\n        mask = (max_exponent - biased_exponent_and_mantissa_high) - (uint)!condition;\n      }\n      if (biased_exponent_and_mantissa_high < max_exponent || condition) {\n        mantissa = mantissa | exponent_difference >> 2;\n      }\n      shift_amount = shift_amount >> 3;\n      mask = (uint)((biased_exponent_and_mantissa_high & 1) != 0) << 0x1f | mask >> 1;\n      condition = mask <= difference;\n      condition = mask - shift_amount < (uint)condition;\n      biased_exponent_and_mantissa_high = mask;\n      if (shift_amount < mask || condition) {\n        difference = difference - mask;\n        biased_exponent_and_mantissa_high = (mask - shift_amount) - (uint)!condition;\n      }\n      if (shift_amount < mask || condition) {\n        mantissa = mantissa | exponent_difference >> 3;\n      }\n      max_exponent = biased_exponent_and_mantissa_high | difference;\n      if (max_exponent == 0) break;\n      biased_exponent_and_mantissa_high = biased_exponent_and_mantissa_high << 4 | difference >> 0x1c;\n      difference = difference << 4;\n      shift_amount = shift_amount & 0xfffffff8 | mask >> 0x1d;\n      mask = (mask >> 1) << 3;\n      exponent_difference = exponent_difference >> 4;\n      if (exponent_difference == 0) {\n        shift_amount = shift_amount;\n        if ((significand & 0x100000) != 0) goto LAB_080089b2;\n        significand = significand | mantissa;\n        mantissa = 0;\n        exponent_difference = 0x80000000;\n      }\n    }\n    if ((significand & 0x100000) == 0) {\n      significand = significand | mantissa;\n      mantissa = 0;\n    }\nLAB_080089b2:\n    condition = 0xfc < biased_exponent;\n    condition = SBORROW4(biased_exponent,0xfd);\n    shift_amount = exponent_difference + 0x300;\n    condition = shift_amount == 0;\n    exponent_difference = shift_amount;\n    if (condition && !condition) {\n      condition = 0x6ff < shift_amount;\n      condition = SBORROW4(shift_amount,0x700);\n      exponent_difference = exponent_difference - 0x400;\n      condition = shift_amount == 0x700;\n    }\n    if (!condition || condition) {\n      condition = shift_amount <= biased_exponent_and_mantissa_high;\n      if (biased_exponent_and_mantissa_high == shift_amount) {\n        condition = mask <= difference;\n      }\n      if (biased_exponent_and_mantissa_high == shift_amount && difference == mask) {\n        condition = (mantissa & 1) != 0;\n      }\n      return CONCAT44(significand + biased_exponent * 0x100000 + (uint)CARRY4(mantissa,(uint)condition),mantissa + condition);\n    }\n  }\n  if (!condition && (int)exponent_difference < 0 == condition) {\n    return (ulonglong)(significand & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  condition = SCARRY4(biased_exponent,0x36);\n  condition = (int)(biased_exponent + 0x36) < 0;\n  condition = biased_exponent == 0xffffffca;\n  if (condition || condition != condition) {\n    mantissa = 0;\n  }\n  if (condition || condition != condition) {\n    significand = significand & 0x80000000;\n  }\n  if (condition || condition != condition) {\n    return CONCAT44(significand,mantissa);\n  }\n  exponent_difference = -biased_exponent;\n  biased_exponent_and_mantissa_high = exponent_difference - 0x20;\n  if (0x1f < (int)exponent_difference) {\n    exponent_difference = mantissa >> (biased_exponent_and_mantissa_high & 0xff) | significand << (0x20 - biased_exponent_and_mantissa_high & 0xff);\n    biased_exponent = (significand >> (biased_exponent_and_mantissa_high & 0xff) & ~((significand & 0x80000000) >> (biased_exponent_and_mantissa_high & 0xff))) -\n            ((int)exponent_difference >> 0x1f);\n    if ((max_exponent | mantissa << (0x20 - biased_exponent_and_mantissa_high & 0xff) | exponent_difference << 1) == 0) {\n      biased_exponent = biased_exponent & ~(exponent_difference >> 0x1f);\n    }\n    return CONCAT44(significand,biased_exponent) & 0x80000000ffffffff;\n  }\n  exponent_difference = exponent_difference - 0x14;\n  if (exponent_difference != 0 && exponent_difference < 0 == SCARRY4(biased_exponent_and_mantissa_high,0xc)) {\n    biased_exponent = 0xc - exponent_difference;\n    exponent_difference = mantissa << (biased_exponent & 0xff);\n    mantissa = mantissa >> (0x20 - biased_exponent & 0xff) | significand << (biased_exponent & 0xff);\n    biased_exponent = mantissa + -((int)exponent_difference >> 0x1f);\n    if ((max_exponent | exponent_difference << 1) == 0) {\n      biased_exponent = biased_exponent & ~(exponent_difference >> 0x1f);\n    }\n    return CONCAT44((significand & 0x80000000) + (uint)CARRY4(mantissa,-((int)exponent_difference >> 0x1f)),biased_exponent);\n  }\n  biased_exponent_and_mantissa_high = mantissa << (biased_exponent + 0x20 & 0xff);\n  mantissa = mantissa >> (exponent_difference & 0xff) | significand << (biased_exponent + 0x20 & 0xff);\n  biased_exponent = mantissa + -((int)biased_exponent_and_mantissa_high >> 0x1f);\n  if ((max_exponent | biased_exponent_and_mantissa_high << 1) == 0) {\n    biased_exponent = biased_exponent & ~(biased_exponent_and_mantissa_high >> 0x1f);\n  }\n  return CONCAT44((significand & 0x80000000) +\n                  ((significand & 0x7fffffff) >> (exponent_difference & 0xff)) +\n                  (uint)CARRY4(mantissa,-((int)biased_exponent_and_mantissa_high >> 0x1f)),biased_exponent);\n}\n\n",
            "called": [
                "FUN_08008a02"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008894",
            "calling": [
                "__ieee754_sqrt",
                "__ieee754_atan2",
                "sqrt",
                "homing_cycle",
                "plan_buffer_line",
                "gc_execute_line",
                "atan"
            ],
            "imported": false,
            "current_name": "calculate_double_precision_floating_point_08008894"
        },
        "FUN_08000374": {
            "renaming": {
                "FUN_08000374": "write_to_eeprom_08000374",
                "destination": "start_address",
                "source": "data",
                "size": "data_size",
                "local_1c": "remaining_size",
                "local_18": "current_char",
                "local_14": "current_address",
                "checksum": "checksum"
            },
            "code": "void write_to_eeprom_08000374(uint destination, char *source, uint size) {\n  uint remaining_size = size;\n  uchar *current_char = (uchar *)source;\n  uint current_address = destination;\n  uchar checksum = 0;\n  if (*(int *)PTR_eeprom_ready_080003e8 == 0) {\n    eeprom_init();\n    current_char = (uchar *)source;\n    current_address = destination;\n  }\n  for (; remaining_size != 0; remaining_size--) {\n    checksum = (checksum != 0) + *current_char;\n    eeprom_put_char(current_address, *current_char);\n    current_char++;\n    current_address++;\n  }\n  eeprom_put_char(current_address, checksum);\n  return;\n}",
            "called": [
                "eeprom_put_char",
                "eeprom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000374",
            "calling": [
                "settings_write_coord_data",
                "settings_store_startup_line",
                "write_global_settings"
            ],
            "imported": false,
            "current_name": "write_to_eeprom_08000374"
        },
        "FUN_080037fc": {
            "renaming": {
                "FUN_080037fc": "print_unsigned_long_080037fc",
                "n": "number",
                "local_c": "absolute_number"
            },
            "code": "void print_unsigned_long_080037fc(long number) {\n    unsigned long absolute_number = number < 0 ? -number : number;\n    if (number < 0) {\n        serial_write('-');\n    }\n    print_uint32_base10(absolute_number);\n}",
            "called": [
                "print_uint32_base10",
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080037fc",
            "calling": [
                "report_grbl_settings",
                "report_startup_line",
                "report_gcode_modes"
            ],
            "imported": false,
            "current_name": "print_unsigned_long_080037fc"
        },
        "FUN_08007dd8": {
            "renaming": {
                "FUN_08007dd8": "disable_timer_interrupt_08007dd8",
                "puVar1": "timer_control_register",
                "TIMx": "N/A",
                "DAT_08007e04": "timer_control_register",
                "*DAT_08007e04": "*timer_control_register",
                "puVar1[8]": "timer_control_register[8]"
            },
            "code": "void disable_timer_interrupt_08007dd8(void)\n{\n  uint32_t *DAT_08007e04 = DAT_08007e04;\n  *DAT_08007e04 &= 0xfffffffe;\n  DAT_08007e04[8] &= 0xffffffef;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007dd8",
            "calling": [],
            "imported": false,
            "current_name": "disable_timer_interrupt_08007dd8"
        },
        "FUN_0800a1bc": {
            "renaming": {
                "FUN_0800a1bc": "multiply_add_0800a1bc",
                "param_1": "a",
                "param_2": "b",
                "uVar1": "result",
                "uVar2": "shifted_b",
                "iVar3": "temp",
                "uVar4": "sum",
                "uVar5": "high_divisor",
                "uVar6": "factor",
                "uVar7": "mask",
                "uVar8": "high",
                "uVar9": "diff"
            },
            "code": "uint multiply_add_0800a1bc(uint a, uint b)\n{\n  uint result;\n  uint mask = 0x7fffffff;\n  uint factor = 0x80000000;\n  if ((DAT_0800a340 & ~b) == 0)\n  {\n    result = a + b;\n  }\n  else if ((int)b < 1)\n  {\n    if ((b & mask | a) == 0)\n    {\n      result = a;\n    }\n    else if (b != 0)\n    {\n      uint diff = a - b;\n      uint high = (uint)((ulonglong)diff >> 32);\n      result = (uint)((ulonglong)diff / high);\n    }\n    else\n    {\n      do\n      {\n        uint shifted_a = a << 0x15;\n        uint shifted_b = b - 0x15;\n        uint high = a >> 0xb;\n        a = shifted_a;\n        b = shifted_b;\n      } while (high == 0);\n      result = a;\n    }\n  }\n  else\n  {\n    uint shifted_b = b >> 0x14;\n    uint high = b;\n    if (shifted_b != 0)\n    {\n      do\n      {\n        factor >>= 1;\n        high <<= 1;\n      } while (shifted_b != 0);\n      high |= a >> (32 - (int)__builtin_clz(high));\n      a <<= (int)__builtin_clz(high) + 1;\n    }\n    else\n    {\n      high = a >> 31;\n      a <<= 1;\n    }\n    result = 0;\n    for (int i = 0; i < 0x16; i++)\n    {\n      factor >>= 1;\n      uint sum = result + factor;\n      if ((int)high < (int)sum)\n      {\n        high -= factor;\n      }\n      else\n      {\n        result = sum;\n        high -= sum;\n      }\n      high <<= 1;\n      result <<= 1;\n      result |= (uint)((int)high >> 31);\n    }\n    if ((high | a) != 0)\n    {\n      result++;\n    }\n  }\n  return result;\n}",
            "called": [
                "__aeabi_dadd",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a1bc",
            "calling": [
                "__ieee754_hypot",
                "sqrt"
            ],
            "imported": false,
            "current_name": "multiply_add_0800a1bc"
        },
        "FUN_0800525c": {
            "renaming": {
                "FUN_0800525c": "direction_control_0800525c",
                "direction": "new_direction",
                "PTR_current_direction_080052a8": "current_direction",
                "plan_synchronize": "synchronize_plans",
                "spindle_stop": "stop_spindle",
                "spindle_rev": "spindle_reverse",
                "spindle_fwd": "spindle_forward",
                "spindle_on": "turn_on_spindle"
            },
            "code": "void direction_control_0800525c(int8_t new_direction) {\\n  if ((int)new_direction != (uint)(byte)*PTR_PTR_current_direction_080052a8_080052a8) {\\n    plan_synchronize();\\n    if (new_direction == \"\\0\") {\\n      spindle_stop();\\n    }\\n    else {\\n      if (new_direction < \"\\x01\") {\\n        spindle_reverse();\\n      }\\n      else {\\n        spindle_forward();\\n      }\\n      spindle_turn_on();\\n    }\\n    *PTR_PTR_current_direction_080052a8_080052a8 = new_direction;\\n  }\\n  return;\\n}",
            "called": [
                "plan_synchronize",
                "spindle_stop",
                "spindle_fwd",
                "spindle_on",
                "spindle_rev"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800525c",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "direction_control_0800525c"
        },
        "FUN_080073d4": {
            "renaming": {
                "FUN_080073d4": "set_bit_in_short_array_080073d4",
                "n": "bit_index",
                "*((n >> 4) * 0x400 + 0x4002001a)": "short_array_offset",
                "*(short *)((n >> 4) * 0x400 + 0x4002001a)": "short_array_offset",
                "(short)(1 << (n & 0xfU))": "bit_mask",
                "(n & 0xfU)": "bit_index & 0xfU",
                "*(short *)((n >> 4) * 0x400 + 0x4002001a) = (short)(1 << (n & 0xfU))": "*short_array_ptr = (short)bit_mask"
            },
            "code": "void set_bit_in_short_array_080073d4(int bit_index)\n{\n    int short_array_offset = (bit_index >> 4) * 0x400 + 0x4002001a;\n    short* short_array_ptr = (short*)short_array_offset;\n    int bit_mask = 1 << (bit_index & 0xfU);\n    *short_array_ptr = (short)bit_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073d4",
            "calling": [
                "debounce_off_handler"
            ],
            "imported": false,
            "current_name": "set_bit_in_short_array_080073d4"
        },
        "FUN_080085e4": {
            "renaming": {
                "FUN_080085e4": "calculate_double_precision_product_080085e4",
                "param_1": "multiplicand",
                "param_2": "multiplier",
                "bVar1": "least_significant_bit",
                "uVar2": "least_significant_word_of_result",
                "uVar3": "most_significant_word_of_result",
                "uVar4": "temp_word",
                "iVar5": "shift_amount",
                "uVar6": "shift_amount",
                "iVar7": "shift_amount",
                "uVar8": "sign_bit",
                "uVar9": "temp_word",
                "bVar10": "carry_bit",
                "bVar11": "carry_bit",
                "bVar12": "borrow_bit"
            },
            "code": "\nulonglong calculate_double_precision_product_080085e4(uint multiplicand,uint multiplier)\n\n{\n  byte least_significant_bit;\n  uint least_significant_word_of_result;\n  uint most_significant_word_of_result;\n  uint temp_word;\n  int shift_amount;\n  uint shift_amount;\n  int shift_amount;\n  uint sign_bit;\n  uint temp_word;\n  bool carry_bit;\n  bool carry_bit;\n  bool borrow_bit;\n  \n  if ((multiplicand | multiplier) == 0) {\n    return CONCAT44(multiplier,multiplicand);\n  }\n  sign_bit = multiplier & 0x80000000;\n  most_significant_word_of_result = multiplier;\n  if ((int)sign_bit < 0) {\n    carry_bit = multiplicand != 0;\n    multiplicand = -multiplicand;\n    most_significant_word_of_result = -multiplier - (uint)carry_bit;\n  }\n  shift_amount = 0x432;\n  temp_word = most_significant_word_of_result >> 0x16;\n  if (temp_word != 0) {\n    shift_amount = 3;\n    if (most_significant_word_of_result >> 0x19 != 0) {\n      shift_amount = 6;\n    }\n    if (most_significant_word_of_result >> 0x1c != 0) {\n      shift_amount = shift_amount + 3;\n    }\n    temp_word = shift_amount - ((int)most_significant_word_of_result >> 0x1f);\n    temp_word = multiplicand << (0x20 - temp_word & 0xff);\n    multiplicand = multiplicand >> (temp_word & 0xff) | most_significant_word_of_result << (0x20 - temp_word & 0xff);\n    most_significant_word_of_result = most_significant_word_of_result >> (temp_word & 0xff);\n    shift_amount = temp_word + 0x432;\n  }\n  if (0xfffff < most_significant_word_of_result) {\n    if (0x1fffff < most_significant_word_of_result) {\n      temp_word = most_significant_word_of_result & 1;\n      most_significant_word_of_result = most_significant_word_of_result >> 1;\n      least_significant_bit = (byte)multiplicand;\n      multiplicand = (uint)(temp_word != 0) << 0x1f | multiplicand >> 1;\n      temp_word = (uint)(least_significant_bit & 1) << 0x1f | temp_word >> 1;\n      shift_amount = shift_amount + 1;\n      if (0xffbfffff < (uint)(shift_amount * 0x200000)) {\n        return (ulonglong)(sign_bit | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_080083e0:\n    carry_bit = 0x7fffffff < temp_word;\n    if (temp_word == 0x80000000) {\n      carry_bit = (multiplicand & 1) != 0;\n    }\n    return CONCAT44(most_significant_word_of_result + shift_amount * 0x100000 + (uint)CARRY4(multiplicand,(uint)carry_bit) | sign_bit,\n                    multiplicand + carry_bit);\n  }\n  carry_bit = (temp_word & 0x80000000) != 0;\n  temp_word = temp_word << 1;\n  temp_word = multiplicand * 2;\n  carry_bit = CARRY4(multiplicand,multiplicand);\n  multiplicand = multiplicand * 2 + (uint)carry_bit;\n  most_significant_word_of_result = most_significant_word_of_result * 2 + (uint)(carry_bit || CARRY4(temp_word,(uint)carry_bit));\n  carry_bit = shift_amount != 0;\n  shift_amount = shift_amount + -1;\n  if (carry_bit && 0xfffff < most_significant_word_of_result) goto LAB_080083e0;\n  least_significant_word_of_result = multiplicand;\n  temp_word = most_significant_word_of_result;\n  if (most_significant_word_of_result == 0) {\n    least_significant_word_of_result = 0;\n    temp_word = multiplicand;\n  }\n  shift_amount = count_leading_zeroes(temp_word);\n  if (most_significant_word_of_result == 0) {\n    shift_amount = shift_amount + 0x20;\n  }\n  shift_amount = shift_amount - 0xb;\n  borrow_bit = SBORROW4(shift_amount,0x20);\n  most_significant_word_of_result = shift_amount - 0x2b;\n  carry_bit = (int)most_significant_word_of_result < 0;\n  carry_bit = most_significant_word_of_result == 0;\n  if ((int)shift_amount < 0x20) {\n    borrow_bit = SCARRY4(most_significant_word_of_result,0xc);\n    shift_amount = shift_amount + -0x1f;\n    carry_bit = shift_amount < 0;\n    carry_bit = shift_amount == 0;\n    most_significant_word_of_result = shift_amount;\n    if (!carry_bit && carry_bit == borrow_bit) {\n      least_significant_word_of_result = temp_word << (shift_amount & 0xff);\n      temp_word = temp_word >> (0xcU - shift_amount & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (carry_bit || carry_bit != borrow_bit) {\n    temp_word = 0x20 - most_significant_word_of_result;\n  }\n  temp_word = temp_word << (most_significant_word_of_result & 0xff);\n  if (carry_bit || carry_bit != borrow_bit) {\n    temp_word = temp_word | least_significant_word_of_result >> (temp_word & 0xff);\n  }\n  if (carry_bit || carry_bit != borrow_bit) {\n    least_significant_word_of_result = least_significant_word_of_result << (most_significant_word_of_result & 0xff);\n  }\nLAB_08008458:\n  if ((int)shift_amount <= shift_amount) {\n    return CONCAT44(temp_word + (shift_amount - shift_amount) * 0x100000 | sign_bit,least_significant_word_of_result);\n  }\n  most_significant_word_of_result = ~(shift_amount - shift_amount);\n  if ((int)most_significant_word_of_result < 0x1f) {\n    shift_amount = most_significant_word_of_result - 0x13;\n    if (shift_amount != 0 && shift_amount < 0 == SCARRY4(most_significant_word_of_result - 0x1f,0xc)) {\n      return CONCAT44(multiplier,least_significant_word_of_result >> (0x20 - (0xcU - shift_amount) & 0xff) |\n                              temp_word << (0xcU - shift_amount & 0xff)) & 0x80000000ffffffff;\n    }\n    most_significant_word_of_result = most_significant_word_of_result + 1;\n    return CONCAT44(sign_bit | temp_word >> (most_significant_word_of_result & 0xff),\n                    least_significant_word_of_result >> (most_significant_word_of_result & 0xff) | temp_word << (0x20 - most_significant_word_of_result & 0xff));\n  }\n  return CONCAT44(multiplier,temp_word >> (most_significant_word_of_result - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085e4",
            "calling": [],
            "imported": false,
            "current_name": "calculate_double_precision_product_080085e4"
        },
        "FUN_08006dfe": {
            "renaming": {
                "FUN_08006dfe": "clear_pending_interrupt_08006dfe",
                "IRQn": "interrupt"
            },
            "code": "void clear_pending_interrupt_08006dfe(IRQn_Type interrupt)\n{\n  NVIC_ClearPendingIRQ(interrupt);\n  return;\n}",
            "called": [
                "NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006dfe",
            "calling": [],
            "imported": false,
            "current_name": "clear_pending_interrupt_08006dfe"
        },
        "FUN_08006d66": {
            "renaming": {
                "FUN_08006d66": "reset_system_08006d66"
            },
            "code": "void reset_system_08006d66(void)\n{\n  NVIC_SystemReset();\n  return;\n}",
            "called": [
                "NVIC_SystemReset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d66",
            "calling": [],
            "imported": false,
            "current_name": "reset_system_08006d66"
        },
        "FUN_08006e88": {
            "renaming": {
                "FUN_08006e88": "configure_GPIO_pins_08006e88",
                "GPIOx": "GPIO_port",
                "GPIO_Init": "GPIO_Init",
                "uVar1": "alternate_function",
                "uVar2": "pin_mask",
                "uVar3": "pin_value",
                "temp": "temp",
                "iocurrent": "iocurrent",
                "ioposition": "ioposition",
                "position": "position",
                "DAT_0800719c": "DAT_0800719c",
                "DAT_080071a0": "DAT_080071a0",
                "DAT_080071a4": "DAT_080071a4",
                "DAT_080071a8": "DAT_080071a8",
                "DAT_080071ac": "DAT_080071ac",
                "DAT_080071b0": "DAT_080071b0",
                "DAT_080071b4": "DAT_080071b4",
                "DAT_080071b8": "DAT_080071b8",
                "DAT_080071bc": "DAT_080071bc",
                "DAT_080071c0": "DAT_080071c0",
                "DAT_080071c4": "DAT_080071c4",
                "DAT_080071c8": "DAT_080071c8",
                "*DAT_080071cc": "*DAT_080071cc"
            },
            "code": "void configure_GPIO_pins_08006e88(GPIO_TypeDef *GPIO_port, GPIO_InitTypeDef *GPIO_Init) {\n    uint32_t pin_mask, alternate_function;\n    uint32_t position;\n\n    for (position = 0; position < 0x10; position++) {\n        pin_mask = 1 << position;\n        if ((GPIO_Init->Pin & pin_mask) == pin_mask) {\n            if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) {\n                alternate_function = GPIO_Init->Alternate;\n                uint32_t afr_index = position >> 3;\n                uint32_t afr_shift = (position & 7) << 2;\n                GPIO_port->AFR[afr_index] = (GPIO_port->AFR[afr_index] & ~(0xf << afr_shift)) | (alternate_function << afr_shift);\n            }\n            uint32_t moder_index = (position & 0x7f) << 1;\n            GPIO_port->MODER = (GPIO_port->MODER & ~(3 << moder_index)) | ((GPIO_Init->Mode & 3) << moder_index);\n            if (((GPIO_Init->Mode == GPIO_MODE_INPUT) || (GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))) {\n                uint32_t ospeedr_index = (position & 0x7f) << 1;\n                GPIO_port->OSPEEDR = (GPIO_port->OSPEEDR & ~(3 << ospeedr_index)) | (GPIO_Init->Speed << ospeedr_index);\n                uint32_t otyper_index = position & 0xff;\n                GPIO_port->OTYPER = (GPIO_port->OTYPER & ~(1 << otyper_index)) | ((GPIO_Init->Mode >> 4 & 1) << otyper_index);\n            }\n            uint32_t pupdr_index = (position & 0x7f) << 1;\n            GPIO_port->PUPDR = (GPIO_port->PUPDR & ~(3 << pupdr_index)) | (GPIO_Init->Pull << pupdr_index);\n            if ((GPIO_Init->Mode & GPIO_MODE_IT_RISING_FALLING) != 0) {\n                uint32_t exticr_index = ((position >> 2) + 2) * 4;\n                uint32_t exticr_shift = (position & 3) << 2;\n                uint32_t port_index = 10;\n                if (GPIO_port == GPIOA) {\n                    port_index = 0;\n                }\n                else if (GPIO_port == GPIOB) {\n                    port_index = 1;\n                }\n                else if (GPIO_port == GPIOC) {\n                    port_index = 2;\n                }\n                else if (GPIO_port == GPIOD) {\n                    port_index = 3;\n                }\n                else if (GPIO_port == GPIOE) {\n                    port_index = 4;\n                }\n                else if (GPIO_port == GPIOF) {\n                    port_index = 5;\n                }\n                else if (GPIO_port == GPIOG) {\n                    port_index = 6;\n                }\n                else if (GPIO_port == GPIOH) {\n                    port_index = 7;\n                }\n                else if (GPIO_port == GPIOI) {\n                    port_index = 8;\n                }\n                uint32_t exticr_value = port_index << exticr_shift;\n                uint32_t exticr_mask = ~(0xf << exticr_shift);\n                uint32_t exticr_address = 0x40013c08 + exticr_index;\n                *(uint32_t *)exticr_address = (*(uint32_t *)exticr_address & exticr_mask) | exticr_value;\n                uint32_t mask = ~pin_mask;\n                uint32_t rising_mask = (GPIO_Init->Mode & GPIO_MODE_IT_RISING) ? pin_mask : 0;\n                uint32_t falling_mask = (GPIO_Init->Mode & GPIO_MODE_IT_FALLING) ? pin_mask : 0;\n                EXTI->RTSR = (EXTI->RTSR & mask) | rising_mask;\n                EXTI->FTSR = (EXTI->FTSR & mask) | falling_mask;\n            }\n        }\n    }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e88",
            "calling": [
                "gpio_init",
                "HAL_RCC_MCOConfig"
            ],
            "imported": false,
            "current_name": "configure_GPIO_pins_08006e88"
        },
        "FUN_0800b4f0": {
            "renaming": {
                "FUN_0800b4f0": "call_global_destructors_0800b4f0",
                "iVar1": "num_destructors",
                "ppcVar2": "destructor_ptr"
            },
            "code": "void call_global_destructors_0800b4f0()\n{\n  int num_destructors = ((int)PTR___fini_array_end_0800b514 - (int)PTR___do_global_dtors_aux_fini_array_entry_0800b518) >> 2;\n  if (num_destructors != 0) {\n    code** destructor_ptr = (code**)(PTR___do_global_dtors_aux_fini_array_entry_0800b518 + ((int)PTR___fini_array_end_0800b514 - (int)PTR___do_global_dtors_aux_fini_array_entry_0800b518) - 4);\n    do {\n      num_destructors--;\n      (**destructor_ptr)();\n      destructor_ptr--;\n    } while (num_destructors != 0);\n  }\n  _fini();\n  return;\n}",
            "called": [
                "frame_dummy",
                "_fini",
                "__do_global_dtors_aux"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b4f0",
            "calling": [],
            "imported": false,
            "current_name": "call_global_destructors_0800b4f0"
        },
        "FUN_080001e0": {
            "renaming": {
                "FUN_080001e0": "do_nothing_080001e0"
            },
            "code": "\nvoid do_nothing_080001e0(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001e0",
            "calling": [
                "coolant_run"
            ],
            "imported": false,
            "current_name": "do_nothing_080001e0"
        },
        "FUN_080036f0": {
            "renaming": {
                "FUN_080036f0": "print_binary_080036f0",
                "n": "input",
                "bits": "num_bits",
                "data": "bit",
                "i": "index",
                "mask": "mask"
            },
            "code": "void print_binary_080036f0(uint input, int num_bits) {\n  uint32_t mask = 1 << (num_bits - 1);\n  for (int i = 0; i < num_bits; i++) {\n    uint8_t bit = (mask & input) ? '1' : '0';\n    serial_write(bit);\n    mask >>= 1;\n  }\n}",
            "called": [
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036f0",
            "calling": [
                "print_uint16_base2",
                "print_uint8_base2"
            ],
            "imported": false,
            "current_name": "print_binary_080036f0"
        },
        "FUN_08005c74": {
            "renaming": {
                "FUN_08005c74": "set_flags_and_values_08005c74",
                "DAT_08005ce4": "data_ptr"
            },
            "code": "void set_flags_and_values_08005c74(void)\n{\n  unsigned int* DAT_08005ce4 = DAT_08005ce4;\n  *DAT_08005ce4 |= 0x81;\n  DAT_08005ce4[2] = 0;\n  *DAT_08005ce4 &= 0xfaf6ffff;\n  DAT_08005ce4[1] = 0;\n  DAT_08005ce4[1] |= DAT_08005ce4[5];\n  DAT_08005ce4[33] = 0;\n  DAT_08005ce4[33] |= 0x20003000;\n  *DAT_08005ce4 &= 0xfffbffff;\n  DAT_08005ce4[3] = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005c74",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_and_values_08005c74"
        },
        "FUN_08002edc": {
            "renaming": {
                "synchronize_08002edc": "synchronize_planner",
                "planner_reverse_pass": "reverse_pass_planner",
                "planner_forward_pass": "forward_pass_planner",
                "synchronize_08002edc_trapezoids": "synchronize_trapezoids_planner",
                "FUN_08002edc": "synchronize_planner_08002edc"
            },
            "code": "void synchronize_planner_08002edc(void)\n{\n  reverse_pass_planner();\n  forward_pass_planner();\n  synchronize_trapezoids_planner();\n  return;\n}",
            "called": [
                "planner_forward_pass",
                "planner_recalculate_trapezoids",
                "planner_reverse_pass"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002edc",
            "calling": [
                "plan_cycle_reinitialize",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "synchronize_planner_08002edc"
        },
        "FUN_0800375c": {
            "renaming": {
                "FUN_0800375c": "print_binary_0800375c",
                "n": "num"
            },
            "code": "void print_binary_0800375c(uint16_t num)\n{\n    print_base2((uint)num,0x10);\n    return;\n}",
            "called": [
                "print_base2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800375c",
            "calling": [
                "report_grbl_settings"
            ],
            "imported": false,
            "current_name": "print_binary_0800375c"
        },
        "FUN_08009990": {
            "renaming": {
                "FUN_08009990": "calculate_result_08009990",
                "param_1": "first_param",
                "param_2": "second_param",
                "param_3": "third_param",
                "param_4": "fourth_param",
                "param_5": "fifth_param",
                "iVar1": "difference",
                "unaff_r4": "register_4",
                "uVar2": "quotient",
                "uVar3": "absolute_third_param",
                "uVar4": "absolute_fourth_param",
                "uVar5": "result",
                "uVar6": "fourth_param_sign_bit",
                "uVar7": "second_param_sign_bit",
                "uVar8": "sum",
                "uVar9": "fourth_param_msb",
                "uVar10": "absolute_fourth_param_double"
            },
            "code": "void calculate_result_08009990(uint first_param, uint second_param, uint third_param, uint fourth_param, double fifth_param)\n{\n  int difference;\n  uint absolute_third_param;\n  uint absolute_fourth_param;\n  uint fourth_param_sign_bit;\n  uint second_param_sign_bit;\n  uint sum;\n  uint fourth_param_msb;\n  uint quotient;\n  double absolute_fourth_param_double;\n  if(DAT_08009b18 < ((fourth_param & 0x7fffffff) | (-third_param | third_param) >> 0x1f) || DAT_08009b18 < ((second_param & 0x7fffffff) | (-first_param | first_param) >> 0x1f))\n  {\n    __aeabi_dadd(third_param, fourth_param, first_param, second_param);\n  }\n  else\n  {\n    absolute_third_param = third_param & 0x7fffffff;\n    absolute_fourth_param = fourth_param & 0x7fffffff;\n    fourth_param_sign_bit = fourth_param >> 0x1f;\n    second_param_sign_bit = second_param >> 0x1f;\n    sum = fourth_param + 0xc0100000 | third_param;\n    fourth_param_msb = (int)fourth_param >> 0x1e & 2U | second_param_sign_bit;\n    if((absolute_fourth_param | first_param) != 0 && (absolute_third_param | third_param) != 0 && absolute_third_param != DAT_08009b18 && absolute_fourth_param != DAT_08009b18)\n    {\n      difference = (int)(absolute_fourth_param - absolute_third_param) >> 0x14;\n      if(difference < 0x3d00000 && (-1 < (int)fourth_param || (difference + 0x3c < 0 == SCARRY4(difference, 0x3c))))\n      {\n        __divdf3(first_param, second_param, third_param, fourth_param);\n        absolute_fourth_param_double = fabs((double) CONCAT44(unaff_r4, fourth_param));\n        atan(absolute_fourth_param_double);\n      }\n      if(fourth_param_msb == 1)\n      {\n        uVar5 = __subdf3();\n        __subdf3(DAT_08009af0, DAT_08009af4, (int)uVar5, (int)((ulonglong)uVar5 >> 0x20));\n      }\n      else if(fourth_param_msb == 2)\n      {\n        uVar5 = __subdf3();\n        __subdf3(DAT_08009af0, DAT_08009af4, (int)((ulonglong)uVar5 >> 0x20), (int)uVar5);\n      }\n      else if(fourth_param_msb != 0)\n      {\n        uVar5 = __subdf3();\n        __subdf3((int)uVar5, (int)((ulonglong)uVar5 >> 0x20), DAT_08009af0, DAT_08009af4);\n      }\n    }\n    else if(sum == 0)\n    {\n      atan(fifth_param);\n      return;\n    }\n  }\n  return;\n}",
            "called": [
                "__aeabi_dadd",
                "fabs",
                "atan",
                "__subdf3",
                "__divdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009990",
            "calling": [
                "atan2"
            ],
            "imported": false,
            "current_name": "calculate_result_08009990"
        },
        "FUN_08005b58": {
            "renaming": {
                "FUN_08005b58": "clear_bit_in_uint32_t_08005b58",
                "DAT_08005b70": "data_pointer"
            },
            "code": "void clear_bit_in_uint32_t_08005b58(void)\n{\n  uint32_t* ptr_data = (uint32_t*)(DAT_08005b70 + 4);\n  uint32_t mask = 0xfffffffd;\n  *ptr_data &= mask;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b58",
            "calling": [],
            "imported": false,
            "current_name": "clear_bit_in_uint32_t_08005b58"
        },
        "FUN_08007e58": {
            "renaming": {
                "FUN_08007e58": "is_bit_set_in_usart_status_register_08007e58",
                "usart": "usart_instance",
                "*DAT_08007e80": "*DAT_USART_STATUS_REGISTER",
                "(uint)": "bool",
                "& 0x20": "& BIT_5_MASK"
            },
            "code": "bool is_bit_set_in_usart_status_register_08007e58(void)\n{\n\tUSART_TypeDef *usart_instance = PTR_USART;\n\tuint8_t usart_status_register_value = *DAT_08007e80;\n\treturn (usart_status_register_value & BIT_5_MASK) != 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e58",
            "calling": [
                "serial_read"
            ],
            "imported": false,
            "current_name": "is_bit_set_in_usart_status_register_08007e58"
        },
        "FUN_080059f8": {
            "renaming": {
                "FUN_080059f8": "resetPeripheralRegisters_080059f8",
                "DAT_08005a4c": "ptr_dat_08005a4c"
            },
            "code": "HAL_StatusTypeDef resetPeripheralRegisters_080059f8(void)\n{\n    uint32_t* DAT_08005a4c = (uint32_t*)DAT_08005a4c;\n    DAT_08005a4c[5] = 0xFFFFFFFF;\n    DAT_08005a4c[5] = 0;\n    DAT_08005a4c[6] = 0xFFFFFFFF;\n    DAT_08005a4c[6] = 0;\n    DAT_08005a4c[4] = 0xFFFFFFFF;\n    DAT_08005a4c[4] = 0;\n    DAT_08005a4c[5] = 0xFFFFFFFF;\n    DAT_08005a4c[5] = 0;\n    DAT_08005a4c[6] = 0xFFFFFFFF;\n    DAT_08005a4c[6] = 0;\n    HAL_MspDeInit();\n    return HAL_OK;\n}",
            "called": [
                "HAL_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080059f8",
            "calling": [],
            "imported": false,
            "current_name": "resetPeripheralRegisters_080059f8"
        },
        "FUN_08009194": {
            "renaming": {
                "FUN_08009194": "calculate_result_08009194",
                "param_1": "num1",
                "param_2": "num2",
                "uVar2": "double_num1",
                "uVar3": "double_num2",
                "uVar4": "result",
                "bVar1": "is_negative1",
                "bVar5": "is_zero"
            },
            "code": "uint calculate_result_08009194(uint num1, uint num2)\n{\n  bool is_negative1 = false;\n  bool is_negative2 = false;\n  uint double_num1 = num1 * 2;\n  uint double_num2 = num2 * 2;\n  uint result = 0;\n  bool is_zero = false;\n  \n  if (((int)double_num1 >> 0x18 == -1 || (int)double_num2 >> 0x18 == -1) &&\n     ((((int)double_num1 >> 0x18 == -1 && ((num1 & 0x7fffff) != 0)) ||\n      (((int)double_num2 >> 0x18 == -1 && ((num2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  \n  result = double_num1 | num2 & 0x7fffffff;\n  is_zero = result == 0;\n  if (!is_zero) {\n    result = num1 ^ num2;\n    is_zero = result == 0;\n  }\n  is_negative1 = -1 < (int)result;\n  if (is_negative1) {\n    result = double_num1 + num2 * -2;\n    is_zero = result == 0;\n  }\n  if ((is_negative1 && double_num2 <= double_num1) && !is_zero) {\n    result = (int)num2 >> 0x1f;\n  }\n  if (!is_negative1 || double_num2 > double_num1) {\n    result = ~((int)num2 >> 0x1f);\n  }\n  if (!is_zero) {\n    result = result | 1;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009194",
            "calling": [],
            "imported": false,
            "current_name": "calculate_result_08009194"
        },
        "FUN_08003f34": {
            "renaming": {
                "FUN_08003f34": "process_input_line_08003f34",
                "PTR_iscomment_08004028": "is_in_comment_ptr",
                "PTR_char_counter_08004020": "char_counter",
                "PTR_line_08004024": "line_buffer",
                "PTR_sys_0800401c": "sys_ptr"
            },
            "code": "void process_input_line_08003f34(void)\\n{\\n    byte current_char;\\n    uint8_t status_code;\\n    byte is_in_comment;\\n    uint8_t PTR_char_counter_08004020;\\n    while (true) {\\n        while (true) {\\n            current_char = serial_read();\\n            if (current_char == 0xff) {\\n                return;\\n            }\\n            if ((current_char == 10) || (current_char == 0xd)) {\\n                break;\\n            }\\n            if (*PTR_iscomment_08004028 == \"\\0\") {\\n                if ((0x20 < current_char) && (current_char != 0x2f)) {\\n                    if (current_char == 0x28) {\\n                        *PTR_iscomment_08004028 = 1;\\n                    }\\n                    else if (PTR_char_counter_08004020 == -1) {\\n                        report_status_message(\"\\r\");\\n                        protocol_reset_PTR_line_08004024();\\n                    }\\n                    else if ((current_char < 0x61) || (0x7a < current_char)) {\\n                        byte current_counter = PTR_char_counter_08004020;\\n                        PTR_char_counter_08004020 = current_counter + 1;\\n                        PTR_line_08004024[current_counter] = current_char;\\n                    }\\n                    else {\\n                        byte current_counter = PTR_char_counter_08004020;\\n                        PTR_char_counter_08004020 = current_counter + 1;\\n                        PTR_line_08004024[current_counter] = current_char - 0x20;\\n                    }\\n                }\\n            }\\n            else if (current_char == 0x29) {\\n                *PTR_iscomment_08004028 = 0;\\n            }\\n        }\\n        protocol_execute_runtime();\\n        if (*PTR_sys_0800401c != \"\\0\") {\\n            break;\\n        }\\n        if (PTR_char_counter_08004020 == \"\\0\") {\\n            report_status_message(\"\\0\");\\n        }\\n        else {\\n            PTR_line_08004024[(byte)PTR_char_counter_08004020] = 0;\\n            status_code = protocol_execute_line(PTR_line_08004024);\\n            report_status_message(status_code);\\n        }\\n        protocol_reset_PTR_line_08004024();\\n    }\\n    return;\\n}",
            "called": [
                "protocol_reset_line_buffer",
                "protocol_execute_line",
                "report_status_message",
                "serial_read",
                "protocol_execute_runtime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f34",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "process_input_line_08003f34"
        },
        "FUN_080095b8": {
            "renaming": {
                "FUN_080095b8": "calculate_significant_digits_080095b8",
                "__x": "input",
                "in_r0": "fraction_bits",
                "in_r1": "exponent_bits",
                "uVar1": "rounding_bit",
                "uVar2": "exponent_bits_shifted",
                "uVar3": "normalized_fraction",
                "uVar5": "exponent",
                "lVar4": "sign",
                "PTR_0800a0e8": "CARRY4",
                "DAT_0800a0ec": "0xffffffff",
                "0x100000": "0b100000000000000000000",
                "0x14": "20",
                "0x1e": "30",
                "0x34": "52",
                "0x413": "1043",
                "0x433": "1075",
                "false": "0",
                "__aeabi_d2iz": "some_library_function"
            },
            "code": "long calculate_significant_digits_080095b8(double input)\n{\n  uint exponent_bits;\n  uint fraction_bits;\n  uint exponent;\n  long sign;\n  uint normalized_fraction;\n  uint rounding_bit;\n  uint significand;\n  \n  exponent_bits = (in_r1 << 1) >> 0x15;\n  exponent = exponent_bits - 0x3ff;\n  if ((int)in_r1 < 0) {\n    sign = -1;\n  }\n  else {\n    sign = 1;\n  }\n  normalized_fraction = in_r1 & 0xfffff | 0x100000;\n  if ((int)exponent < 0x14) {\n    if ((int)exponent < 0) {\n      if (exponent != DAT_0800a0ec) {\n        sign = 0;\n      }\n      return sign;\n    }\n    normalized_fraction = normalized_fraction + (0x80000 >> (exponent & 0xff)) >> (0x14 - exponent & 0xff);\n  }\n  else {\n    if (0x1e < exponent) {\n      sign = __aeabi_d2iz();\n      return sign;\n    }\n    if ((int)exponent < 0x34) {\n      rounding_bit = 0x80000000 >> (exponent_bits - 0x413 & 0xff);\n      if (PTR_0800a0e8(rounding_bit,in_r0) != false) {\n        normalized_fraction = normalized_fraction + 1;\n      }\n      normalized_fraction = normalized_fraction << (exponent_bits - 0x413 & 0xff);\n      if (exponent != 0x14) {\n        normalized_fraction = normalized_fraction | rounding_bit + in_r0 >> (0x34 - exponent & 0xff);\n      }\n    }\n    else {\n      normalized_fraction = normalized_fraction << (exponent_bits - 0x413 & 0xff) | in_r0 << (exponent_bits - 0x433 & 0xff);\n    }\n  }\n  return normalized_fraction * sign;\n}",
            "called": [
                "__aeabi_d2iz"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080095b8",
            "calling": [
                "homing_cycle",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "calculate_significant_digits_080095b8"
        },
        "FUN_08007e4c": {
            "renaming": {
                "FUN_08007e4c": "do_nothing_08007e4c"
            },
            "code": "\nvoid do_nothing_08007e4c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e4c",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08007e4c"
        },
        "FUN_08006cf6": {
            "renaming": {
                "FUN_08006cf6": "set_priority_08006cf6",
                "IRQn": "irq",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "uVar1": "priority_group",
                "prioritygroup": "priority_group",
                "NVIC_GetPriorityGrouping": "NVIC_GetPriorityGrouping",
                "NVIC_EncodePriority": "NVIC_EncodePriority",
                "NVIC_SetPriority": "NVIC_SetPriority"
            },
            "code": "void set_priority_08006cf6(IRQn_Type irq, uint32_t preempt_priority, uint32_t sub_priority)\n{\n  uint32_t priority_group;\n  uint32_t encoded_priority;\n  \n  priority_group = NVIC_GetPriorityGrouping();\n  encoded_priority = NVIC_EncodePriority(priority_group, preempt_priority, sub_priority);\n  NVIC_SetPriority(irq, encoded_priority);\n  return;\n}",
            "called": [
                "NVIC_GetPriorityGrouping",
                "NVIC_EncodePriority",
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006cf6",
            "calling": [
                "enable_tim_interrupt"
            ],
            "imported": false,
            "current_name": "set_priority_08006cf6"
        },
        "FUN_08002ef0": {
            "renaming": {
                "FUN_08002ef0": "copy_block_from_head_to_tail_08002ef0",
                "uVar1": "next_block_idx",
                "*PTR_block_buffer_tail_08002f1c": "*block_buffer_tail",
                "*PTR_block_buffer_head_08002f18": "*block_buffer_head",
                "*PTR_next_buffer_head_08002f20": "*next_buffer_head"
            },
            "code": "void copy_block_from_head_to_tail_08002ef0(void)\n{\n  uint8_t next_block_idx;\n  *PTR_block_buffer_tail_08002f1c = *PTR_block_buffer_head_08002f18;\n  next_block_idx = next_block_index(*PTR_block_buffer_head_08002f18);\n  *PTR_next_buffer_head_08002f20 = next_block_idx;\n  return;\n}",
            "called": [
                "next_block_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ef0",
            "calling": [
                "plan_init"
            ],
            "imported": false,
            "current_name": "copy_block_from_head_to_tail_08002ef0"
        },
        "FUN_08006e7c": {
            "renaming": {
                "FUN_08006e7c": "do_nothing_08006e7c"
            },
            "code": "\nvoid do_nothing_08006e7c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e7c",
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08006e7c"
        },
        "FUN_08001d4c": {
            "renaming": {
                "FUN_08001d4c": "wake_up_and_home_08001d4c",
                "homing_rate": "rate1",
                "homing_rate_00": "rate2",
                "extraout_s0": "temp_rate",
                "homing_rate_01": "rate3",
                "extraout_s0_00": "temp_delay",
                "n_cycle": "cycle_count"
            },
            "code": "void wake_up_and_home_08001d4c(void)\\n{\\n  char cycle_count;\\n  float rate1;\\n  float rate2;\\n  float temp_rate;\\n  float rate3;\\n  float temp_delay;\\n  int8_t n_cycle;\\n  st_wake_up();\\n  homing_cycle(\"\\x04\", \"\\x01\", false, rate1);\\n  homing_cycle(\"\\x03\", \"\\x01\", false, rate2);\\n  delay_ms(*(uint16_t *)(PTR_settings_08001dd8 + 0x34));\\n  n_cycle = 2;\\n  rate3 = temp_rate;\\n  while (cycle_count = n_cycle - 1, n_cycle != 0)\\n  {\\n    homing_cycle(\"\\a\", \"\\0\", true, rate3);\\n    delay_ms(*(uint16_t *)(PTR_settings_08001dd8 + 0x34));\\n    rate3 = temp_rate;\\n    n_cycle = cycle_count;\\n    if (cycle_count > 0)\\n    {\\n      homing_cycle(\"\\a\", \"\\x01\", false, temp_rate);\\n      delay_ms(*(uint16_t *)(PTR_settings_08001dd8 + 0x34));\\n      rate3 = temp_delay;\\n    }\\n  }\\n  st_go_idle();\\n  return;\\n}",
            "called": [
                "st_wake_up",
                "homing_cycle",
                "st_go_idle",
                "delay_ms"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001d4c",
            "calling": [
                "mc_go_home"
            ],
            "imported": false,
            "current_name": "wake_up_and_home_08001d4c"
        },
        "FUN_08000268": {
            "renaming": {
                "FUN_08000268": "calculateElapsedTime_08000268",
                "uVar1": "currentTick",
                "DAT_0800029c": "PTR_DAT_0800029c",
                "DAT_08000298": "PTR_DAT_08000298",
                "uVar2": "elapsedTime",
                "uVar3": "timeOffset",
                "uVar4": "product"
            },
            "code": "uint64_t calculateElapsedTime_08000268(void)\n{\n    uint32_t currentTick = HAL_GetTick();\n    uint32_t elapsedTime = (currentTick + 1) * 1000;\n    uint32_t timeOffset = *(uint *)(DAT_08000298 + 8) >> 3;\n    uint32_t product = (uint32_t)((uint64_t)(DAT_0800029c) * (uint64_t)(timeOffset) >> 33);\n    return (uint64_t)(elapsedTime - product);\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000268",
            "calling": [
                "_delay_us"
            ],
            "imported": false,
            "current_name": "calculateElapsedTime_08000268"
        },
        "FUN_0800918c": {
            "renaming": {
                "FUN_0800918c": "calculate_result_0800918c",
                "param_1": "a",
                "param_2": "b",
                "uVar2": "a_times_2",
                "uVar3": "b_times_2",
                "uVar4": "result",
                "bVar1": "is_overflow",
                "bVar5": "is_result_zero"
            },
            "code": "uint calculate_result_0800918c(uint a, uint b) {\n  bool is_overflow;\n  uint a_times_2 = a * 2;\n  uint b_times_2 = b * 2;\n  if (((int)a_times_2 >> 0x18 == -1 || (int)b_times_2 >> 0x18 == -1) && ((((int)a_times_2 >> 0x18 == -1 && ((a & 0x7fffff) != 0)) || (((int)b_times_2 >> 0x18 == -1 && ((b & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  uint result = a_times_2 | b & 0x7fffffff;\n  bool is_result_zero = result == 0;\n  if (!is_result_zero) {\n    result = a ^ b;\n    is_result_zero = result == 0;\n  }\n  is_overflow = -1 < (int)result;\n  if (is_overflow) {\n    a = a_times_2 + b * -2;\n    is_result_zero = a == 0;\n  }\n  if (is_overflow && b_times_2 <= a_times_2 && !is_result_zero) {\n    a = (int)b >> 0x1f;\n  }\n  if (!is_overflow || b_times_2 > a_times_2) {\n    a = ~((int)b >> 0x1f);\n  }\n  if (!is_result_zero) {\n    a = a | 1;\n  }\n  return a;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800918c",
            "calling": [],
            "imported": false,
            "current_name": "calculate_result_0800918c"
        },
        "FUN_08003778": {
            "renaming": {
                "FUN_08003778": "print_number_in_serial_08003778",
                "n": "number",
                "local_1c": "remainder",
                "uStack_15": "digit",
                "buf": "buffer",
                "i": "digit_index",
                "uVar1": "quotient"
            },
            "code": "void print_number_in_serial_08003778(ulong number)\n{\n  uint digit_index;\n  ulong remainder;\n  uint8_t digit;\n  uchar buffer[10];\n\n  digit_index = 0;\n  remainder = number;\n  if (number == 0) {\n    serial_write('0');\n  }\n  else {\n    while (remainder != 0) {\n      uint quotient = remainder * 0x4ec4ec4f >> 0x23;\n      digit = (char)remainder + (char)(quotient * -10) + '0';\n      buffer[digit_index] = digit;\n      digit_index++;\n      remainder = quotient;\n    }\n    while (digit_index != 0) {\n      digit_index--;\n      serial_write(buffer[digit_index]);\n    }\n  }\n}",
            "called": [
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003778",
            "calling": [
                "printInteger"
            ],
            "imported": false,
            "current_name": "print_number_in_serial_08003778"
        },
        "FUN_0800b3dc": {
            "renaming": {
                "FUN_0800b3dc": "get_impure_ptr_value_0800b3dc",
                "PTR__impure_ptr_0800b3e4": "impure_ptr"
            },
            "code": "int get_impure_ptr_value_0800b3dc() {\n    return *(int *)PTR__impure_ptr_0800b3e4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b3dc",
            "calling": [
                "sqrt",
                "hypot"
            ],
            "imported": false,
            "current_name": "get_impure_ptr_value_0800b3dc"
        },
        "FUN_080046d0": {
            "renaming": {
                "FUN_080046d0": "printData_080046d0",
                "bVar1": "byteValue1",
                "cVar2": "charValue1",
                "n": "floatValue1",
                "n_00": "floatValue2",
                "uVar3": "undefinedValue1"
            },
            "code": "void printData_080046d0() {\\n    byte dataLength = (byte)PTR_gc_08004890[1];\\n    if (dataLength > 4) {\\n        printPgmString(PTR_DAT_080048a8);\\n        int value = (byte)PTR_gc_08004890[0x1c] + 0x36;\\n        printInteger(value);\\n        if (PTR_gc_08004890[0x19] == \"\\0\") {\\n            if (PTR_gc_08004890[0x1a] == 1) {\\n                printPgmString(PTR_DAT_080048ac);\\n            }\\n            else {\\n                printPgmString(PTR_DAT_080048b0);\\n            }\\n        }\\n        else {\\n            printPgmString(PTR_DAT_080048b4);\\n        }\\n        if (PTR_gc_08004890[3] == \"\\0\") {\\n            printPgmString(PTR_DAT_080048bc);\\n        }\\n        else {\\n            printPgmString(PTR_DAT_080048b8);\\n        }\\n        if (PTR_gc_08004890[4] == \"\\0\") {\\n            printPgmString(PTR_DAT_080048c4);\\n        }\\n        else {\\n            printPgmString(PTR_DAT_080048c0);\\n        }\\n        if (PTR_gc_08004890[2] == \"\\0\") {\\n            printPgmString(PTR_DAT_080048cc);\\n        }\\n        else {\\n            printPgmString(PTR_DAT_080048c8);\\n        }\\n        byte bVar1 = PTR_gc_08004890[5];\\n        if (bVar1 == 2) {\\n            printPgmString(PTR_DAT_080048d8);\\n        }\\n        else if (bVar1 < 3) {\\n            if (bVar1 == 0) {\\n                printPgmString(PTR_DAT_080048d0);\\n            }\\n            else if (bVar1 == 1) {\\n                printPgmString(PTR_DAT_080048d4);\\n            }\\n        }\\n        char cVar2 = PTR_gc_08004890[6];\\n        if (cVar2 == 1) {\\n            printPgmString(PTR_DAT_080048dc);\\n        }\\n        else if (cVar2 < 2) {\\n            if (cVar2 == -1) {\\n                printPgmString(PTR_DAT_080048e0);\\n            }\\n            else if (cVar2 == 0) {\\n                printPgmString(PTR_DAT_080048e4);\\n            }\\n        }\\n        byte bVar2 = PTR_gc_08004890[7];\\n        if (bVar2 == 2) {\\n            printPgmString(PTR_DAT_080048f0);\\n        }\\n        else if (bVar2 < 3) {\\n            if (bVar2 == 0) {\\n                printPgmString(PTR_DAT_080048e8);\\n            }\\n            else if (bVar2 == 1) {\\n                printPgmString(PTR_DAT_080048ec);\\n            }\\n        }\\n        printPgmString(PTR_DAT_080048f4);\\n        uint8_t value2 = (uint8_t)PTR_gc_08004890[0x18];\\n        printInteger(value2);\\n        printPgmString(PTR_DAT_080048f8);\\n        if (PTR_gc_08004890[3] == \"\\0\") {\\n            float value3 = 0.0;\\n            printFloat(value3);\\n        }\\n        else {\\n            float value4 = (float)(*(int*)(PTR_gc_08004890 + 8)) * 0.00000011920929;\\n            printFloat(value4);\\n        }\\n        printPgmString(PTR_DAT_080048fc);\\n    }\\n    else {\\n        (*(code *)(&switchD_080046de::switchdataD_080046e4)[dataLength])();\\n    }\\n}",
            "called": [
                "printInteger",
                "__aeabi_f2d",
                "__truncdfsf2",
                "__muldf3",
                "printPgmString",
                "printFloat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080046d0",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "printData_080046d0"
        },
        "FUN_08006d72": {
            "renaming": {
                "FUN_08006d72": "configureSysTick_08006d72",
                "TicksNumb": "ticksNumber",
                "uVar1": "configStatus"
            },
            "code": "uint32_t configureSysTick_08006d72(uint32_t ticksNumber)\n{\n  uint32_t configStatus;\n  configStatus = SysTick_Config(ticksNumber);\n  return configStatus;\n}",
            "called": [
                "SysTick_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d72",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "configureSysTick_08006d72"
        },
        "FUN_0800756c": {
            "renaming": {
                "FUN_0800756c": "set_bit_and_clear_other_bits_0800756c",
                "DAT_080075bc": "data_ptr",
                "DAT_080075c0": "data_value_1",
                "DAT_080075c4": "other_data_ptr"
            },
            "code": "void set_bit_and_clear_other_bits_0800756c(void)\n{\n  unsigned int* DAT_080075bc = DAT_080075bc;\n  unsigned int current_value = *DAT_080075bc;\n  unsigned int new_value = current_value | 1;\n  DAT_080075bc[2] = 0;\n  new_value &= 0xfef6ffff;\n  DAT_080075bc[1] = DAT_080075c0;\n  new_value &= 0xfffbffff;\n  DAT_080075bc[3] = 0;\n  unsigned int* DAT_080075c4 = (unsigned int*)(DAT_080075c4 + 8);\n  *DAT_080075c4 = 0x8000000;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800756c",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "set_bit_and_clear_other_bits_0800756c"
        },
        "FUN_0800691c": {
            "renaming": {
                "FUN_0800691c": "check_and_set_callback_0800691c",
                "DAT_0800693c": "PTR_DATA_START",
                "DAT_08006940": "PTR_DATA_END"
            },
            "code": "void check_and_set_callback_0800691c(void)\n{\n  uint* ptr = (uint*)(DAT_0800693c + 0xc);\n  if ((*ptr & 0x80) == 0x80) {\n    HAL_RCC_CCSCallback();\n    *DAT_08006940 = 0x80;\n  }\n  return;\n}",
            "called": [
                "HAL_RCC_CCSCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800691c",
            "calling": [],
            "imported": false,
            "current_name": "check_and_set_callback_0800691c"
        },
        "FUN_080001f8": {
            "renaming": {
                "FUN_080001f8": "stop_coolant_flow_080001f8",
                "PTR_current_coolant_mode_0800020c": "current_coolant_mode"
            },
            "code": "void stop_coolant_flow_080001f8(void)\n{\n  *PTR_current_coolant_mode_0800020c = 0;\n  coolant_stop();\n  return;\n}",
            "called": [
                "coolant_stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001f8",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "stop_coolant_flow_080001f8"
        },
        "FUN_08002f74": {
            "renaming": {
                "FUN_08002f74": "get_next_block_08002f74",
                "pbVar1": "next_block",
                "*PTR_block_buffer_head_08002fa0": "block_buffer_head",
                "*PTR_block_buffer_tail_08002fa4": "block_buffer_tail",
                "NULL": "NULL",
                "block_t": "block_t",
                "uint": "uint32_t",
                "byte": "uint8_t",
                "PTR_block_buffer_08002fa8": "block_buffer",
                "block_index": "block_index",
                "buffer_offset": "buffer_offset"
            },
            "code": "block_t* get_next_block_08002f74(void)\n{\n    block_t* next_block;\n    if (*PTR_*PTR_PTR_block_buffer_08002fa8_head_08002fa0_08002fa0 == *PTR_*PTR_PTR_block_buffer_08002fa8_tail_08002fa4_08002fa4)\n    {\n        next_block = NULL;\n    }\n    else\n    {\n        uint8_t block_index = (uint8_t)*PTR_*PTR_PTR_block_buffer_08002fa8_tail_08002fa4_08002fa4;\n        uint32_t buffer_offset = PTR_PTR_block_buffer_08002fa8_08002fa8 + block_index*0x40;\n        next_block = (block_t*)buffer_offset;\n    }\n    return next_block;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f74",
            "calling": [
                "plan_synchronize",
                "step_period_isr"
            ],
            "imported": false,
            "current_name": "get_next_block_08002f74"
        },
        "FUN_0800b3e8": {
            "renaming": {
                "FUN_0800b3e8": "initialize_crypto_library_0800b3e8",
                "param_1": "context",
                "iVar1": "i",
                "ppcVar2": "preinit_array",
                "iVar3": "preinit_array_size",
                "PTR___preinit_array_end_0800b420": "preinit_array_start",
                "PTR___preinit_array_end_0800b424": "preinit_array_end",
                "PTR___preinit_array_end_0800b42c": "global_dtors_array_start",
                "PTR___do_global_dtors_aux_fini_array_entry_0800b428": "global_dtors_array_end"
            },
            "code": "void initialize_crypto_library_0800b3e8(EVP_PKEY_CTX *context)\n{\n  int preinit_array_size = (int)PTR___PTR___preinit_array_end_0800b424_0800b420 - (int)PTR___PTR___preinit_array_end_0800b424_0800b424 >> 2;\n  if (preinit_array_size != 0) {\n    int i = 0;\n    code **preinit_array = (code **)PTR___PTR___preinit_array_end_0800b424_0800b424;\n    do {\n      i = i + 1;\n      context = (EVP_PKEY_CTX *)(**preinit_array)();\n      preinit_array = preinit_array + 1;\n    } while (preinit_array_size != i);\n  }\n  code **global_dtors_array = (code **)PTR___PTR___preinit_array_end_0800b424_0800b42c;\n  int global_dtors_array_size = (int)PTR___do_global_dtors_aux_fini_array_entry_0800b428 - (int)PTR___PTR___preinit_array_end_0800b424_0800b42c;\n  _init(context);\n  global_dtors_array_size = global_dtors_array_size >> 2;\n  if (global_dtors_array_size != 0) {\n    int i = 0;\n    do {\n      i = i + 1;\n      (**global_dtors_array)();\n      global_dtors_array = global_dtors_array + 1;\n    } while (global_dtors_array_size != i);\n  }\n  return;\n}",
            "called": [
                "_init",
                "register_fini",
                "frame_dummy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b3e8",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "initialize_crypto_library_0800b3e8"
        },
        "FUN_080096e8": {
            "renaming": {
                "FUN_080096e8": "synchronize_080096e8",
                "__x": "input",
                "in_r0": "unused",
                "in_r1": "absolute_input",
                "dVar2": "result",
                "local_28": "remainder",
                "uStack_24": "unused",
                "local_20": "unused",
                "uStack_1c": "unused",
                "DAT_08009790": "MAX_INT_1",
                "DAT_08009794": "MAX_INT_2",
                "__subdf3": "subtraction",
                "__ieee754_rem_pio2": "calculate_quadrant",
                "__kernel_cos": "cosine",
                "__kernel_synchronize_080096e8": "synchronize",
                "__kernel_sin": "sine"
            },
            "code": "double synchronize_080096e8(double input)\n{\n  uint absolute_input = (uint)(input < 0 ? -input : input);\n  if (DAT_08009790 < (int)(absolute_input & 0x7fffffff)) {\n    if (DAT_08009794 < (int)(absolute_input & 0x7fffffff)) {\n      return (double)(__subdf3());\n    }\n    else {\n      uint remainder = 0;\n      uint quadrant = __ieee754_rem_pio2((int)input, absolute_input, &remainder);\n      quadrant &= 3;\n      if (quadrant == 1) {\n        return (double)__kernel_cos(remainder, 0, 0, 0);\n      }\n      else if (quadrant == 2 || quadrant == 0) {\n        return (double)__kernel_synchronize_080096e8(remainder, 0, 0, 0, 1);\n      }\n      else {\n        return (double)__kernel_sin(remainder, 0, 0, 0);\n      }\n    }\n  }\n  return (double)__kernel_synchronize_080096e8((int)input, absolute_input, 0, 0, 0);\n}\n",
            "called": [
                "__kernel_cos",
                "__ieee754_rem_pio2",
                "__subdf3",
                "__kernel_sin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080096e8",
            "calling": [
                "mc_arc"
            ],
            "imported": false,
            "current_name": "synchronize_080096e8"
        },
        "FUN_08006a18": {
            "renaming": {
                "FUN_08006a18": "is_IRQ_enabled_08006a18",
                "IRQn": "irq_number",
                "DAT_08006a54": "irq_table",
                "uint": "uint32_t",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "uint32_t is_IRQ_enabled_08006a18(IRQn_Type IRQn)\n{\n    uint32_t *irq_ptr = (uint32_t *)(DAT_08006a54 + (((uint32_t)IRQn >> 5) + 0x40) * 4);\n    uint32_t irq_mask = 1U << (IRQn & 0x1fU);\n    return ((*irq_ptr & irq_mask) != 0);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006a18",
            "calling": [
                "HAL_NVIC_GetPendingIRQ"
            ],
            "imported": false,
            "current_name": "is_IRQ_enabled_08006a18"
        },
        "FUN_08002c18": {
            "renaming": {
                "FUN_08002c18": "calculate_acceleration_distance_08002c18",
                "block": "block_data",
                "entry_factor": "entry_rate",
                "exit_factor": "exit_rate",
                "uVar1": "unsigned_variable_1",
                "uVar2": "unsigned_variable_2",
                "iVar3": "integer_variable_3",
                "iVar4": "integer_variable_4",
                "uVar5": "unsigned_variable_5",
                "in_r1": "input_register_1",
                "extraout_r1": "extra_output_register_1",
                "extraout_r1_00": "extra_output_register_1_00",
                "extraout_r1_01": "extra_output_register_1_01",
                "extraout_r1_02": "extra_output_register_1_02",
                "extraout_r1_03": "extra_output_register_1_03",
                "in_r2": "input_register_2",
                "acceleration": "acceleration_distance",
                "acceleration_00": "acceleration_distance_00",
                "acceleration_01": "acceleration_distance_01",
                "distance": "distance",
                "uVar6": "unsigned_variable_6",
                "in_stack_ffffffc8": "stack_input_variable_ffffffc8",
                "decelerate_steps": "deceleration_steps",
                "acceleration_per_minute": "acceleration_distance_per_minute",
                "plateau_steps": "plateau_steps",
                "accelerate_steps": "acceleration_steps",
                "DAT_08002e04": "data_08002e04",
                "__floatunsisf": "convert_unsigned_int_to_float",
                "__aeabi_fmul": "multiply_floats",
                "__aeabi_f2d": "convert_float_to_double",
                "ceil": "round_up",
                "__aeabi_d2uiz": "convert_double_to_unsigned_int",
                "estimate_acceleration_distance": "calculate_acceleration_distance",
                "__floatsisf": "convert_int_to_float",
                "__aeabi_d2iz": "convert_double_to_int",
                "floor": "round_down",
                "intersection_distance": "calculate_intersection_distance"
            },
            "code": "void calculate_acceleration_distance_08002c18(block_t *block, float entry_rate, float exit_rate) {\n    float initial_rate = entry_rate * block->nominal_rate;\n    float final_rate = block->nominal_rate * exit_rate;\n    float rate_delta = final_rate - initial_rate;\n    float acceleration_distance = (rate_delta * 50) / (block->nominal_rate * 60);\n    float acceleration_steps = ceil(initial_rate);\n    float deceleration_steps = floor(final_rate);\n    float plateau_steps = block->step_event_count - acceleration_steps - deceleration_steps;\n    if (plateau_steps < 0) {\n        float distance = (-rate_delta * block->step_event_count * block->step_event_count) / (4 * block->nominal_rate);\n        acceleration_steps = sqrt((-rate_delta) / (2 * acceleration_distance));\n        plateau_steps = 0;\n    }\n    block->accelerate_until = acceleration_steps;\n    block->decelerate_after = acceleration_steps + plateau_steps;\n}",
            "called": [
                "intersection_distance",
                "floor",
                "__floatunsisf",
                "ceil",
                "__aeabi_fmul",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "__muldf3",
                "__aeabi_d2iz",
                "__floatsisf",
                "__aeabi_i2d",
                "estimate_acceleration_distance"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c18",
            "calling": [
                "planner_recalculate_trapezoids"
            ],
            "imported": false,
            "current_name": "calculate_acceleration_distance_08002c18"
        },
        "FUN_08006ac0": {
            "renaming": {
                "FUN_08006ac0": "getIRQStatus_08006ac0",
                "IRQn": "irq",
                "DAT_08006afc": "irqData"
            },
            "code": "uint32_t getIRQStatus_08006ac0(IRQn_Type irq)\n{\n    uint32_t irqStatus = (*(uint32_t *)(DAT_08006afc + (((uint32_t)irq >> 5) + 0x80) * 4)) & (1 << (irq & 0x1f));\n    return (irqStatus != 0);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ac0",
            "calling": [
                "HAL_NVIC_GetActive"
            ],
            "imported": false,
            "current_name": "getIRQStatus_08006ac0"
        },
        "FUN_080001ec": {
            "renaming": {
                "FUN_080001ec": "do_nothing_080001ec"
            },
            "code": "\nvoid do_nothing_080001ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001ec",
            "calling": [
                "coolant_stop"
            ],
            "imported": false,
            "current_name": "do_nothing_080001ec"
        },
        "FUN_08005a50": {
            "renaming": {
                "FUN_08005a50": "do_nothing_08005a50"
            },
            "code": "\nvoid do_nothing_08005a50(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a50",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_08005a50"
        },
        "FUN_08002ba8": {
            "renaming": {
                "synchronize_08002ba8": "synchronize_blocks",
                "previous": "previous_block",
                "next": "next_block",
                "block": "blocks",
                "block_index": "block_index",
                "PTR_block_buffer_tail_08002c0c": "PTR_block_buffer_tail_08002c0c",
                "block_t": "block_t",
                "PTR_block_buffer_head_08002c14": "PTR_block_buffer_head_08002c14",
                "PTR_block_buffer_08002c10": "PTR_block_buffer_08002c10",
                "uint": "uint",
                "next_block_index": "next_block_index",
                "synchronize_08002ba8_kernel": "synchronize_blocks_kernel",
                "FUN_08002ba8": "synchronize_blocks_08002ba8"
            },
            "code": "void synchronize_blocks_08002ba8(void)\n{\n  block_t *previous_block;\n  block_t *next_block;\n  block_t *blocks[3];\n  uint8_t block_index;\n  block_index = *PTR_block_buffer_tail_08002c0c;\n  blocks[1] = NULL;\n  blocks[2] = NULL;\n  while (previous_block = blocks[1], block_index != *PTR_block_buffer_head_08002c14) {\n    blocks[1] = blocks[2];\n    next_block = (block_t *)(PTR_block_buffer_08002c10 + (uint)block_index * 0x40);\n    synchronize_blocks_08002ba8_kernel(previous_block, blocks[2], next_block);\n    block_index = next_block_index(block_index);\n    blocks[2] = next_block;\n  }\n  synchronize_blocks_08002ba8_kernel(blocks[1], blocks[2], NULL);\n  return;\n}",
            "called": [
                "planner_forward_pass_kernel",
                "next_block_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ba8",
            "calling": [
                "planner_recalculate"
            ],
            "imported": false,
            "current_name": "synchronize_blocks_08002ba8"
        },
        "FUN_0800919c": {
            "renaming": {
                "FUN_0800919c": "calculate_result_0800919c",
                "param_1": "first_operand",
                "param_2": "second_operand",
                "uVar2": "first_operand_shifted",
                "uVar3": "second_operand_shifted",
                "uVar4": "result",
                "bVar1": "is_result_negative",
                "bVar5": "is_result_zero"
            },
            "code": "uint calculate_result_0800919c(uint first_operand, uint second_operand) {\n  bool is_first_operand_negative = ((int)first_operand >> 0x18 == -1);\n  bool is_second_operand_negative = ((int)second_operand >> 0x18 == -1);\n  uint first_operand_shifted = first_operand * 2;\n  uint second_operand_shifted = second_operand * 2;\n  if ((is_first_operand_negative || is_second_operand_negative) && (((is_first_operand_negative && ((first_operand & 0x7fffff) != 0)) || ((is_second_operand_negative && ((second_operand & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  uint result = first_operand_shifted | second_operand & 0x7fffffff;\n  bool is_result_zero = (result == 0);\n  if (!is_result_zero) {\n    result = first_operand ^ second_operand;\n    is_result_zero = (result == 0);\n  }\n  bool is_result_negative = (-1 < (int)result);\n  if (is_result_negative) {\n    result = first_operand_shifted + second_operand * -2;\n    is_result_zero = (result == 0);\n  }\n  if ((is_result_negative && second_operand_shifted <= first_operand_shifted) && !is_result_zero) {\n    result = (int)second_operand >> 0x1f;\n  }\n  if (!is_result_negative || second_operand_shifted > first_operand_shifted) {\n    result = ~((int)second_operand >> 0x1f);\n  }\n  if (!is_result_zero) {\n    result = result | 1;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800919c",
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "imported": false,
            "current_name": "calculate_result_0800919c"
        },
        "FUN_0800b2cc": {
            "renaming": {
                "FUN_0800b2cc": "calculate_0800b2cc",
                "__x": "input",
                "in_d0": "result"
            },
            "code": "double calculate_0800b2cc(double input) {\n  double result;\n  // perform calculations here\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2cc",
            "calling": [
                "__ieee754_atan2",
                "__ieee754_rem_pio2",
                "atan"
            ],
            "imported": false,
            "current_name": "calculate_0800b2cc"
        },
        "FUN_0800854c": {
            "renaming": {
                "FUN_0800854c": "calculate_shifted_value_0800854c",
                "param_1": "input_value",
                "uVar1": "shifted_value",
                "uVar2": "shift_amount",
                "iVar3": "leading_zeroes_count",
                "uVar4": "shift_amount_2",
                "in_r12": "remaining_bits",
                "bVar5": "is_shift_amount_less_than_11",
                "bVar6": "is_shift_amount_equal_to_11",
                "bVar7": "is_shift_amount_negative"
            },
            "code": "ulonglong calculate_shifted_value_0800854c(uint input_value)\n{\n  uint leading_zeroes_count = count_leading_zeroes(input_value);\n  uint shift_amount = leading_zeroes_count + 21;\n  bool is_shift_amount_negative = SBORROW4(shift_amount,0x20);\n  uint shifted_value = 0;\n  bool is_shift_amount_less_than_11 = (int)(leading_zeroes_count - 11) < 0;\n  bool is_shift_amount_equal_to_11 = leading_zeroes_count == 11;\n  if ((int)shift_amount < 0x20) {\n    is_shift_amount_negative = SCARRY4(leading_zeroes_count,0xc);\n    leading_zeroes_count++;\n    is_shift_amount_less_than_11 = leading_zeroes_count < 0;\n    is_shift_amount_equal_to_11 = leading_zeroes_count == 0;\n    shift_amount = shift_amount;\n    if (!is_shift_amount_equal_to_11 && is_shift_amount_less_than_11 == is_shift_amount_negative) {\n      shifted_value = input_value << (shift_amount & 0xff);\n      input_value = input_value >> (0xcU - leading_zeroes_count & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (is_shift_amount_equal_to_11 || is_shift_amount_less_than_11 != is_shift_amount_negative) {\n    uint remaining_bits = 0x20 - leading_zeroes_count;\n    input_value = input_value << (leading_zeroes_count & 0xff);\n    if (is_shift_amount_equal_to_11 || is_shift_amount_less_than_11 != is_shift_amount_negative) {\n      input_value |= 0U >> (remaining_bits & 0xff);\n    }\n    if (is_shift_amount_equal_to_11 || is_shift_amount_less_than_11 != is_shift_amount_negative) {\n      shifted_value = 0 << (leading_zeroes_count & 0xff);\n    }\n  }\nLAB_08008458:\n  if ((int)shift_amount < 0x433) {\n    return CONCAT44(input_value + (0x432 - shift_amount) * 0x100000,shifted_value);\n  }\n  uint inverse_shift_amount = ~(0x432 - shift_amount);\n  if (0x1e < (int)inverse_shift_amount) {\n    return (ulonglong)(input_value >> (inverse_shift_amount - 0x1f & 0xff));\n  }\n  int shift_amount_difference = inverse_shift_amount - 0x13;\n  if (shift_amount_difference == 0 || shift_amount_difference < 0 != SCARRY4(inverse_shift_amount - 0x1f,0xc)) {\n    inverse_shift_amount++;\n    return CONCAT44(input_value >> (inverse_shift_amount & 0xff),shifted_value >> (inverse_shift_amount & 0xff) | input_value << (0x20 - inverse_shift_amount & 0xff));\n  }\n  return (ulonglong)(shifted_value >> (0x20 - (0xcU - shift_amount_difference) & 0xff) | input_value << (0xcU - shift_amount_difference & 0xff));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800854c",
            "calling": [
                "homing_cycle"
            ],
            "imported": false,
            "current_name": "calculate_shifted_value_0800854c"
        },
        "FUN_08008e44": {
            "renaming": {
                "FUN_08008e44": "convert_to_new_format_08008e44",
                "param_1": "input",
                "iVar1": "leading_zeroes",
                "uVar2": "temp1",
                "iVar4": "temp2",
                "uVar5": "temp3",
                "uVar3": "output"
            },
            "code": "uint convert_to_new_format_08008e44(uint input)\n{\n    int leading_zeroes;\n    uint sign_bit;\n    uint output;\n    uint temp1;\n    uint temp2;\n    uint temp3;\n    sign_bit = input & 0x80000000;\n    if ((int)sign_bit < 0)\n    {\n        input = -input;\n    }\n    if (input == 0)\n    {\n        return 0;\n    }\n    leading_zeroes = count_leading_zeroes(input);\n    temp1 = leading_zeroes - 8;\n    temp2 = ((sign_bit | 0x4b000000) - 0x800000) + temp1 * -0x800000;\n    if (leading_zeroes > 7)\n    {\n        temp3 = 0 << (temp1 & 0xff);\n        output = temp2 + (input << (temp1 & 0xff)) + (0U >> (0x20 - temp1 & 0xff)) + (uint)(0x7fffffff < temp3);\n        if (temp3 == 0x80000000)\n        {\n            output = output & 0xfffffffe;\n        }\n        return output;\n    }\n    temp1 = input << (leading_zeroes + 0x18U & 0xff);\n    output = temp2 + ((input >> (0x20 - (leading_zeroes + 0x18U) & 0xff)) - ((int)temp1 >> 0x1f));\n    if ((temp1 & 0x7fffffff) == 0)\n    {\n        output = output & ~(temp1 >> 0x1f);\n    }\n    return output;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e44",
            "calling": [
                "calculate_trapezoid_for_block",
                "gc_set_current_position",
                "report_realtime_status",
                "mc_go_home",
                "plan_cycle_reinitialize",
                "mc_arc",
                "plan_buffer_line",
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "convert_to_new_format_08008e44"
        },
        "FUN_0800733e": {
            "renaming": {
                "FUN_0800733e": "set_GPIO_pin_state_0800733e",
                "GPIOx": "GPIO_port",
                "GPIO_Pin": "pin_number",
                "PinState": "pin_state"
            },
            "code": "void set_GPIO_pin_state_0800733e(GPIO_TypeDef *GPIO_port, uint16_t pin_number, GPIO_PinState pin_state)\n{\n    if (pin_state == GPIO_PIN_RESET) {\n        GPIO_port->BSRRH = pin_number;\n    }\n    else {\n        GPIO_port->BSRRL = pin_number;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800733e",
            "calling": [
                "gpio_init"
            ],
            "imported": false,
            "current_name": "set_GPIO_pin_state_0800733e"
        },
        "FUN_08005aec": {
            "renaming": {
                "FUN_08005aec": "get_first_twelve_bits_of_dat_08005aec",
                "*DAT_08005b00": "data_ptr",
                "return": "return",
                "&": "&",
                "0xfff": "0xfff",
                "uint32_t": "uint32_t",
                "first_twelve_bits": "first_twelve_bits"
            },
            "code": "uint32_t get_first_twelve_bits_of_dat_08005aec(void)\n{\n    uint32_t* *DAT_08005b00 = DAT_08005b00;\n    uint32_t first_twelve_bits = **DAT_08005b00 & 0xfff;\n    return first_twelve_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005aec",
            "calling": [],
            "imported": false,
            "current_name": "get_first_twelve_bits_of_dat_08005aec"
        },
        "FUN_08005b74": {
            "renaming": {
                "FUN_08005b74": "set_flag_on_dat_08005b8c_08005b74",
                "PTR_08005b8c": "ptr_to_dat_08005b8c",
                "DAT_08005b8c": "dat_08005b8c"
            },
            "code": "void set_flag_on_dat_08005b8c_08005b74(void)\n{\n  uint32_t* PTR_08005b8c_plus_4 = (uint32_t*)(DAT_08005b8c + 4);\n  *PTR_08005b8c_plus_4 |= 4;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b74",
            "calling": [],
            "imported": false,
            "current_name": "set_flag_on_dat_08005b8c_08005b74"
        },
        "FUN_0800583c": {
            "renaming": {
                "FUN_0800583c": "set_current_step_0800583c",
                "step_wr": "step_write",
                "st_wake_up": "step_wake_up",
                "st_go_idle": "step_go_idle",
                "(uint)*(ushort *)(PTR_settings_08005858 + 0x18)": "*(uint16_t *)(PTR_settings_08005858 + 0x18)"
            },
            "code": "void set_current_step_0800583c(void)\n{\n  uint16_t current_step = (uint)*(ushort *)(PTR_settings_08005858 + 0x18);\n  step_write(current_step);\n  step_wake_up();\n  step_go_idle();\n  return;\n}",
            "called": [
                "st_wake_up",
                "st_go_idle",
                "step_wr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800583c",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "set_current_step_0800583c"
        },
        "FUN_08001e98": {
            "renaming": {
                "FUN_08001e98": "execute_buffered_plan_08001e98",
                "x": "x_pos",
                "y": "y_pos",
                "z": "z_pos",
                "feed_rate": "feed_rate",
                "invert_feed_rate": "invert_feed_rate",
                "uVar1": "buffer_status",
                "x_00": "x_buffered_pos",
                "y_00": "y_buffered_pos",
                "z_00": "z_buffered_pos",
                "feed_rate_00": "buffered_feed_rate"
            },
            "code": "void execute_buffered_plan_08001e98(float x_pos, float y_pos, float z_pos, float feed_rate, uint8_t invert_feed_rate) {\\n  uint8_t buffer_status;\\n  float x_buffered_pos;\\n  float y_buffered_pos;\\n  float z_buffered_pos;\\n  float buffered_feed_rate;\\n  if (buffer_pointer[1] != \"\\a\") {\\n    do {\\n      execute_runtime_protocol();\\n      if (*buffer_pointer != \"\\0\") {\\n        return;\\n      }\\n      buffer_status = check_full_buffer();\\n    } while (buffer_status != \"\\0\");\\n    buffer_line(x_buffered_pos, y_buffered_pos, z_buffered_pos, buffered_feed_rate, invert_feed_rate);\\n    if (buffer_pointer[1] == \"\\0\") {\\n      buffer_pointer[1] = 2;\\n    }\\n    if (buffer_pointer[0x10] != \"\\0\") {\\n      start_cycle();\\n    }\\n  }\\n  return;\\n}",
            "called": [
                "plan_check_full_buffer",
                "plan_buffer_line",
                "st_cycle_start",
                "protocol_execute_runtime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001e98",
            "calling": [
                "mc_go_home",
                "mc_arc",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "execute_buffered_plan_08001e98"
        },
        "FUN_080069e4": {
            "renaming": {
                "FUN_080069e4": "set_irq_enabled_080069e4",
                "IRQn": "irq",
                "DAT_08006a14": "irq_reg_base"
            },
            "code": "void set_irq_enabled_080069e4(IRQn_Type irq) {\n    int* irq_reg = (int*)(DAT_08006a14 + (((uint)(int)irq >> 5) + 0x20) * 4);\n    *irq_reg = 1 << (irq & 0x1fU);\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080069e4",
            "calling": [
                "HAL_NVIC_DisableIRQ"
            ],
            "imported": false,
            "current_name": "set_irq_enabled_080069e4"
        },
        "FUN_0800b2d4": {
            "renaming": {
                "FUN_0800b2d4": "set_sign_bit_0800b2d4",
                "__value": "value",
                "in_r1": "sign_bit_mask"
            },
            "code": "int set_sign_bit_0800b2d4(double value) {\n  uint32_t sign_bit_mask = 0x80000000;\n  uint32_t exponent_mask = 0x7f800000;\n  uint32_t exponent_bits = (*(uint32_t*)&value & exponent_mask) >> 23;\n  uint32_t result = sign_bit_mask | (exponent_bits >> 8);\n  return (int)result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2d4",
            "calling": [
                "hypot"
            ],
            "imported": false,
            "current_name": "set_sign_bit_0800b2d4"
        },
        "FUN_08008e3c": {
            "renaming": {
                "FUN_08008e3c": "calculate_hash_08008e3c",
                "param_1": "input",
                "iVar1": "leading_zeroes",
                "uVar2": "shift_amount",
                "iVar3": "multiplier",
                "uVar4": "shifted_input",
                "left_shift": "left_shift",
                "shifted_zeroes": "shifted_zeroes",
                "carry": "carry",
                "result": "result",
                "right_shift": "right_shift",
                "shifted_input_signed": "shifted_input_signed"
            },
            "code": "uint calculate_hash_08008e3c(uint input)\n{\n    if (input == 0) {\n        return 0;\n    }\n    int leading_zeroes = count_leading_zeroes(input);\n    int shift_amount = leading_zeroes - 8;\n    int multiplier = shift_amount * -0x800000 + 0x4a800000;\n    if (leading_zeroes > 7) {\n        int left_shift = shift_amount & 0xff;\n        uint shifted_input = input << left_shift;\n        uint shifted_zeroes = 0U >> (0x20 - left_shift & 0xff);\n        uint carry = (uint)(0x7fffffff < (0 << left_shift));\n        uint result = multiplier + shifted_input + shifted_zeroes + carry;\n        if ((0 << left_shift) == 0x80000000) {\n            result = result & 0xfffffffe;\n        }\n        return result;\n    }\n    uint shifted_input = input << (leading_zeroes + 0x18U & 0xff);\n    int right_shift = 0x20 - (leading_zeroes + 0x18U & 0xff);\n    uint shifted_input_signed = (uint)((int)shifted_input >> 0x1f);\n    uint result = multiplier + ((input >> right_shift) - shifted_input_signed);\n    if ((shifted_input & 0x7fffffff) == 0) {\n        result = result & ~(shifted_input >> 0x1f);\n    }\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e3c",
            "calling": [
                "calculate_trapezoid_for_block",
                "read_float"
            ],
            "imported": false,
            "current_name": "calculate_hash_08008e3c"
        },
        "FUN_08009654": {
            "renaming": {
                "FUN_08009654": "calculateAddition_08009654",
                "__x": "input",
                "in_r1": "exponent",
                "iVar1": "shift",
                "in_d0": "result"
            },
            "code": "double calculateAddition_08009654(double input) {\n  int exponent;\n  int shift;\n  double result;\n  exponent = ((uint)(input << 1) >> 0x15) - 0x3ff;\n  if (((0x13 < exponent) && (0x33 < exponent)) && (exponent == 0x400)) {\n    result = (double)__aeabi_dadd();\n  }\n  return result;\n}",
            "called": [
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009654",
            "calling": [
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "calculateAddition_08009654"
        },
        "FUN_08007bc2": {
            "renaming": {
                "FUN_08007bc2": "clear_timers_08007bc2",
                "TIMx": "timer",
                "_DAT_40000000": "GPIOA_BASE",
                "_DAT_4000000c": "GPIOC_BASE"
            },
            "code": "void clear_timers_08007bc2(void)\n{\n  TIM_TypeDef *timer;\n  _DAT_40000000 = _DAT_40000000 & 0xfffffffe;\n  _DAT_4000000c = _DAT_4000000c & 0xfffffff8;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007bc2",
            "calling": [
                "st_go_idle"
            ],
            "imported": false,
            "current_name": "clear_timers_08007bc2"
        },
        "FUN_08009410": {
            "renaming": {
                "synchronize_08009410": "synchronize",
                "__x": "input",
                "in_r0": "register_0",
                "in_r1": "register_1",
                "dVar2": "output",
                "local_28": "local_variable_1",
                "uStack_24": "local_variable_2",
                "local_20": "local_variable_3",
                "uStack_1c": "local_variable_4",
                "DAT_080094b4": "data_1",
                "DAT_080094b8": "data_2",
                "__subdf3": "subtraction",
                "__ieee754_rem_pio2": "remainder",
                "__kernel_sin": "sine",
                "__kernel_synchronize_08009410": "kernel_synchronize",
                "FUN_08009410": "synchronize_08009410"
            },
            "code": "double synchronize_08009410(double input)\n{\n  uint input_integer = (uint)input & 0x7fffffff;\n  double output;\n  if (DAT_080094b4 < input_integer) {\n    if (DAT_080094b8 < input_integer) {\n      output = (double)__subdf3();\n    }\n    else {\n      uint remainder = __ieee754_rem_pio2(in_r0, input_integer, &local_28);\n      remainder &= 3;\n      if (remainder == 1) {\n        output = (double)__kernel_sin(local_28, uStack_24, local_20, uStack_1c, 1);\n      }\n      else if (remainder == 2 || remainder == 0) {\n        output = (double)__kernel_synchronize_08009410(local_28, uStack_24, local_20, uStack_1c);\n      }\n      else {\n        output = (double)__kernel_sin(local_28, uStack_24, local_20, uStack_1c, 1);\n      }\n    }\n  }\n  else {\n    output = (double)__kernel_synchronize_08009410(in_r0, input_integer, 0, 0);\n  }\n  return output;\n}",
            "called": [
                "__kernel_cos",
                "__ieee754_rem_pio2",
                "__subdf3",
                "__kernel_sin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009410",
            "calling": [
                "mc_arc"
            ],
            "imported": false,
            "current_name": "synchronize_08009410"
        },
        "FUN_080035ec": {
            "renaming": {
                "FUN_080035ec": "set_xyz_080035ec",
                "x": "x_coord",
                "y": "y_coord",
                "z": "z_coord"
            },
            "code": "void set_xyz_080035ec(int32_t x_coord, int32_t y_coord, int32_t z_coord)\n{\n  *(int32_t *)PTR_pl_08003614 = x_coord;\n  *(int32_t *)(PTR_pl_08003614 + 4) = y_coord;\n  *(int32_t *)(PTR_pl_08003614 + 8) = z_coord;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035ec",
            "calling": [
                "sys_sync_current_position"
            ],
            "imported": false,
            "current_name": "set_xyz_080035ec"
        },
        "FUN_08006c70": {
            "renaming": {
                "FUN_08006c70": "synchronize_data_08006c70",
                "DAT_08006c94": "PTR_data",
                "DAT_08006c98": "data_mask",
                "PTR_": "ptr_",
                "DAT_": "data_",
                "FUN_": "synchronize_"
            },
            "code": "void synchronize_data_08006c70()\n{\n    DataSynchronizationBarrier(0xf);\n    uint* ptr = (uint*)(DAT_08006c94 + 0xc);\n    uint mask = *ptr & 0x700;\n    *ptr = DAT_08006c98 | mask;\n    DataSynchronizationBarrier(0xf);\n    while(true)\n    {\n        // Do nothing block with infinite loop\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c70",
            "calling": [
                "HAL_NVIC_SystemReset"
            ],
            "imported": false,
            "current_name": "synchronize_data_08006c70"
        },
        "FUN_080068bc": {
            "renaming": {
                "FUN_080068bc": "set_clock_init_080068bc",
                "RCC_ClkInitStruct": "clock_init_struct",
                "pFLatency": "flash_latency",
                "DAT_08006914": "SYSCLKSource_Address",
                "DAT_08006918": "Flash_Latency_Address"
            },
            "code": "void set_clock_init_080068bc(RCC_ClkInitTypeDef *clock_init_struct, uint32_t *flash_latency) {\n    clock_init_struct->ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_SYSCLK;\n    clock_init_struct->SYSCLKSource = *(uint32_t *)(DAT_08006914 + 8) & RCC_SYSCLKSOURCE_PLLCLK;\n    clock_init_struct->AHBCLKDivider = *(uint32_t *)(DAT_08006914 + 8) & RCC_SYSCLK_DIV1;\n    clock_init_struct->APB1CLKDivider = *(uint32_t *)(DAT_08006914 + 8) & RCC_HCLK_DIV2;\n    clock_init_struct->APB2CLKDivider = *(uint32_t *)(DAT_08006914 + 8) >> 3 & RCC_HCLK_DIV1;\n    *flash_latency = *DAT_08006918 & FLASH_LATENCY_4;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080068bc",
            "calling": [],
            "imported": false,
            "current_name": "set_clock_init_080068bc"
        },
        "FUN_08006944": {
            "renaming": {
                "FUN_08006944": "do_nothing_08006944"
            },
            "code": "\nvoid do_nothing_08006944(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006944",
            "calling": [
                "HAL_RCC_NMI_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08006944"
        },
        "FUN_08006d98": {
            "renaming": {
                "FUN_08006d98": "decode_priority_and_get_preempt_sub_priority_08006d98",
                "IRQn": "irq_number",
                "PriorityGroup": "priority_group",
                "pPreemptPriority": "preempt_priority",
                "pSubPriority": "sub_priority",
                "Priority": "priority"
            },
            "code": "void decode_priority_and_get_preempt_sub_priority_08006d98(IRQn_Type irq_number, uint32_t priority_group, \\\n                        uint32_t *preempt_priority, uint32_t *sub_priority)\\n\\\n    {\\n\\\n        uint32_t priority;\\n\\\n        priority = NVIC_GetPriority(irq_number);\\n\\\n        NVIC_DecodePriority(priority, priority_group, preempt_priority, sub_priority);\\n\\\n        return;\\n\\\n    }",
            "called": [
                "NVIC_DecodePriority",
                "NVIC_GetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d98",
            "calling": [],
            "imported": false,
            "current_name": "decode_priority_and_get_preempt_sub_priority_08006d98"
        },
        "FUN_08005a68": {
            "renaming": {
                "FUN_08005a68": "increment_uwTick_08005a68",
                "PTR_uwTick_08005a80": "uwTick_ptr"
            },
            "code": "void increment_uwTick_08005a68(void)\n{\n  int* PTR_uwTick_08005a80 = (int *)PTR_uwTick_08005a80;\n  *PTR_uwTick_08005a80 = *PTR_uwTick_08005a80 + 1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a68",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "increment_uwTick_08005a68"
        },
        "FUN_080079c0": {
            "renaming": {
                "FUN_080079c0": "initialize_debounce_array_080079c0",
                "PTR_debounce_080079d8": "debounce_array",
                "PTR_debounce_ready_080079dc": "ready_flag"
            },
            "code": "void initialize_debounce_array_080079c0()\n{\n  memset(PTR_debounce_080079d8, 0, 0x18);\n  *(int*)PTR_debounce_ready_080079dc = 1;\n  return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080079c0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_debounce_array_080079c0"
        },
        "FUN_0800b2e0": {
            "renaming": {
                "FUN_0800b2e0": "handle_exception_0800b2e0",
                "__exc": "__exception_ptr"
            },
            "code": "int handle_exception_0800b2e0(exception *__exception_ptr) {\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2e0",
            "calling": [
                "sqrt",
                "hypot"
            ],
            "imported": false,
            "current_name": "handle_exception_0800b2e0"
        },
        "FUN_08002908": {
            "renaming": {
                "FUN_08002908": "calculate_distance_08002908",
                "in_r0": "initial_velocity",
                "in_r1": "final_velocity",
                "in_r2": "acceleration",
                "in_r3": "time",
                "uVar1": "two_a_times_d",
                "uVar2": "v_i_squared",
                "fVar3": "distance"
            },
            "code": "float calculate_distance_08002908(float initial_velocity, float final_velocity, float acceleration, float time) {\n  float distance;\n  float initial_velocity_squared = initial_velocity * initial_velocity;\n  float final_velocity_squared = final_velocity * final_velocity;\n  float acceleration_times_distance = acceleration * time * time;\n  distance = (final_velocity_squared - initial_velocity_squared) / (2 * acceleration) + acceleration_times_distance / 2;\n  return distance;\n}",
            "called": [
                "__addsf3",
                "__aeabi_fmul",
                "__aeabi_fsub",
                "__aeabi_fdiv"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002908",
            "calling": [
                "calculate_trapezoid_for_block"
            ],
            "imported": false,
            "current_name": "calculate_distance_08002908"
        },
        "FUN_08007c40": {
            "renaming": {
                "FUN_08007c40": "set_timer_ticks_08007c40",
                "ticks": "ticks",
                "TIMx": "timer",
                "_DAT_40000034": "timer_ARR"
            },
            "code": "void set_timer_ticks_08007c40(TIM_TypeDef* timer, uint32_t ticks) {\n    timer->ARR = ticks;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007c40",
            "calling": [
                "st_wake_up"
            ],
            "imported": false,
            "current_name": "set_timer_ticks_08007c40"
        },
        "FUN_080094c0": {
            "renaming": {
                "FUN_080094c0": "calculate_080094c0",
                "__x": "input",
                "in_r0": "mantissa",
                "in_r1": "mantissa",
                "uVar1": "exponent_diff",
                "uVar2": "exponent",
                "uVar3": "sum",
                "in_d0": "result",
                "extraout_d0": "result2",
                "extraout_d0_00": "result3",
                "extraout_d0_01": "result1",
                "DAT_080095a8": "value1",
                "DAT_080095ac": "value2",
                "DAT_080095b0": "mask",
                "PTR_DAT_080095ac": "value2_ptr"
            },
            "code": "double calculate_080094c0(double input)\n{\n    uint exponent = (mantissa << 1) >> 0x15;\n    uint exponent_diff = exponent - 0x3ff;\n    if ((int)exponent_diff < 0x14) {\n        if ((int)exponent_diff < 0) {\n            uint sum = add(mantissa, DAT_080095a8, PTR_DAT_080095ac);\n            int cmp = compare(sum);\n            return result1;\n        }\n        else if ((mantissa & DAT_080095b0 >> (exponent_diff & 0xff) | mantissa) != 0) {\n            uint sum = add(mantissa, DAT_080095a8, PTR_DAT_080095ac);\n            int cmp = compare(sum);\n            return result2;\n        }\n    }\n    else if ((int)exponent_diff < 0x34) {\n        if ((0xffffffffU >> (exponent - 0x413 & 0xff) & mantissa) != 0) {\n            uint sum = add(mantissa, DAT_080095a8, PTR_DAT_080095ac);\n            int cmp = compare(sum);\n            return result3;\n        }\n    }\n    else if (exponent_diff == 0x400) {\n        return (double)add();\n    }\n    return 0.0;\n}",
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080094c0",
            "calling": [
                "calculate_trapezoid_for_block",
                "mc_arc",
                "mc_dwell",
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "calculate_080094c0"
        },
        "FUN_08008eec": {
            "renaming": {
                "FUN_08008eec": "calculate_float_08008eec",
                "param_1": "first_float",
                "param_2": "second_float",
                "param_3": "third_float",
                "param_4": "fourth_float",
                "lVar1": "long_value",
                "uVar2": "result",
                "uVar3": "shifted_first",
                "uVar6": "multiplied_value",
                "uVar8": "modified_first",
                "bVar9": "condition_1",
                "bVar10": "condition_2",
                "iVar4": "sum_of_shifted",
                "iVar5": "modified_sum",
                "iVar7": "difference_of_sum"
            },
            "code": "\nuint calculate_float_08008eec(uint first_float,uint second_float,undefined4 third_float,uint fourth_float)\n\n{\n  longlong long_value;\n  uint result;\n  uint shifted_first;\n  int sum_of_shifted;\n  int modified_sum;\n  uint multiplied_value;\n  int difference_of_sum;\n  uint modified_first;\n  bool condition_1;\n  bool condition_2;\n  \n  shifted_first = first_float >> 0x17 & 0xff;\n  condition_1 = shifted_first == 0;\n  if (!condition_1) {\n    fourth_float = second_float >> 0x17 & 0xff;\n    condition_1 = fourth_float == 0;\n  }\n  if (!condition_1) {\n    condition_1 = shifted_first == 0xff;\n  }\n  if (!condition_1) {\n    condition_1 = fourth_float == 0xff;\n  }\n  if (condition_1) {\n    fourth_float = second_float >> 0x17 & 0xff;\n    if (shifted_first == 0xff || fourth_float == 0xff) {\n      condition_1 = first_float == 0 || first_float == 0x80000000;\n      result = second_float;\n      if (first_float != 0 && first_float != 0x80000000) {\n        condition_1 = second_float == 0;\n        result = first_float;\n      }\n      if (!condition_1) {\n        condition_1 = second_float == 0x80000000;\n      }\n      modified_first = result;\n      if (((condition_1) || ((shifted_first == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((fourth_float == 0xff && (modified_first = second_float, (second_float & 0x7fffff) != 0)))) {\n        return modified_first | 0x7fc00000;\n      }\n      result = result ^ second_float;\n      goto LAB_0800903c;\n    }\n    condition_1 = (first_float & 0x7fffffff) == 0;\n    if (!condition_1) {\n      condition_1 = (second_float & 0x7fffffff) == 0;\n    }\n    if (condition_1) {\n      return (first_float ^ second_float) & 0x80000000;\n    }\n    condition_1 = shifted_first == 0;\n    result = first_float & 0x80000000;\n    while( true ) {\n      if (condition_1) {\n        first_float = first_float << 1;\n        condition_1 = (first_float & 0x800000) == 0;\n      }\n      if (!condition_1) break;\n      shifted_first = shifted_first - 1;\n    }\n    first_float = first_float | result;\n    condition_1 = fourth_float == 0;\n    result = second_float & 0x80000000;\n    while( true ) {\n      if (condition_1) {\n        second_float = second_float << 1;\n        condition_1 = (second_float & 0x800000) == 0;\n      }\n      if (!condition_1) break;\n      fourth_float = fourth_float - 1;\n    }\n    second_float = second_float | result;\n  }\n  sum_of_shifted = shifted_first + fourth_float;\n  modified_first = first_float ^ second_float;\n  shifted_first = first_float << 9;\n  condition_1 = shifted_first == 0;\n  if (!condition_1) {\n    second_float = second_float << 9;\n    condition_1 = second_float == 0;\n  }\n  if (condition_1) {\n    if (shifted_first == 0) {\n      second_float = second_float << 9;\n    }\n    result = modified_first & 0x80000000 | first_float & 0x7fffff | second_float >> 9;\n    condition_2 = SBORROW4(sum_of_shifted,0x7f);\n    modified_sum = sum_of_shifted + -0x7f;\n    condition_1 = modified_sum == 0;\n    difference_of_sum = modified_sum;\n    if (!condition_1 && 0x7e < sum_of_shifted) {\n      condition_2 = SBORROW4(0xff,modified_sum);\n      difference_of_sum = 0xff - modified_sum;\n      condition_1 = modified_sum == 0xff;\n    }\n    if (!condition_1 && difference_of_sum < 0 == condition_2) {\n      result = result | modified_sum * 0x800000;\n    }\n    if (!condition_1 && difference_of_sum < 0 == condition_2) {\n      return result;\n    }\n    result = result | 0x800000;\n    multiplied_value = 0;\n    condition_2 = SBORROW4(modified_sum,1);\n    modified_first = sum_of_shifted - 0x80;\n    condition_1 = modified_first == 0;\n    shifted_first = modified_first;\n  }\n  else {\n    long_value = (ulonglong)(shifted_first >> 5 | 0x8000000) * (ulonglong)(second_float >> 5 | 0x8000000);\n    multiplied_value = (uint)long_value;\n    result = (uint)((ulonglong)long_value >> 0x20);\n    condition_1 = result < 0x800000;\n    if (condition_1) {\n      result = result << 1;\n    }\n    if (condition_1) {\n      result = result | multiplied_value >> 0x1f;\n      multiplied_value = multiplied_value << 1;\n    }\n    result = modified_first & 0x80000000 | result;\n    modified_first = (sum_of_shifted + -0x7f) - (uint)condition_1;\n    condition_2 = SBORROW4(modified_first,0xfd);\n    condition_1 = modified_first == 0xfd;\n    shifted_first = modified_first - 0xfd;\n    if (modified_first < 0xfe) {\n      result = result + modified_first * 0x800000 + (uint)(0x7fffffff < multiplied_value);\n      if (multiplied_value == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (condition_1 || (int)shifted_first < 0 != condition_2) {\n    condition_1 = (int)(modified_first + 0x19) < 0;\n    if (modified_first == 0xffffffe7 || condition_1 != SCARRY4(modified_first,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (modified_first != 0xffffffe7 && condition_1 == SCARRY4(modified_first,0x19)) {\n      shifted_first = (result << 1) >> (-modified_first & 0xff);\n      modified_first = result << (modified_first + 0x20 & 0xff);\n      shifted_first = ((uint)((result & 0x80000000) != 0) << 0x1f | shifted_first >> 1) + (uint)((byte)shifted_first & 1);\n      if ((multiplied_value | modified_first << 1) == 0) {\n        shifted_first = shifted_first & ~(modified_first >> 0x1f);\n      }\n      return shifted_first;\n    }\n    return result;\n  }\nLAB_0800903c:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008eec",
            "calling": [
                "homing_cycle",
                "mc_arc",
                "mc_dwell",
                "max_allowable_speed",
                "read_float",
                "printFloat",
                "estimate_acceleration_distance",
                "settings_store_global_setting",
                "intersection_distance",
                "calculate_trapezoid_for_block",
                "mc_go_home",
                "plan_cycle_reinitialize",
                "plan_buffer_line",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "calculate_float_08008eec"
        },
        "FUN_08006b54": {
            "renaming": {
                "FUN_08006b54": "get_interrupt_priority_level_08006b54",
                "IRQn": "irq",
                "bVar1": "priority_level",
                "WWDG_IRQn": "watchdog_interrupt",
                "DAT_08006b98": "interrupt_priority_levels_base_address",
                "DAT_08006b9c": "interrupt_priority_levels_base_address"
            },
            "code": "uint32_t get_interrupt_priority_level_08006b54(IRQn_Type irq)\n{\n    byte priority_level;\n    if (irq < WWDG_IRQn) {\n        priority_level = *(byte *)(((byte)irq & 0xf) + DAT_08006b98 + 0x14);\n    }\n    else {\n        priority_level = *(byte *)(irq + DAT_08006b98 + 0x300);\n    }\n    return (uint)(priority_level >> 4);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b54",
            "calling": [
                "HAL_NVIC_GetPriority"
            ],
            "imported": false,
            "current_name": "get_interrupt_priority_level_08006b54"
        },
        "FUN_08007e84": {
            "renaming": {
                "FUN_08007e84": "get_USART_data_08007e84",
                "usart": "USART_instance"
            },
            "code": "char get_USART_data_08007e84(void)\n{\n  USART_TypeDef *USART_instance = (USART_TypeDef *)(DAT_08007ea0 + 4);\n  return (char)*((undefined4 *)USART_instance);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e84",
            "calling": [
                "serial_read"
            ],
            "imported": false,
            "current_name": "get_USART_data_08007e84"
        },
        "FUN_080057e4": {
            "renaming": {
                "FUN_080057e4": "disable_stepper_motor_if_necessary_080057e4",
                "PTR_settings_0800580c": "settings_array",
                "PTR_sys_08005810": "sys_array"
            },
            "code": "void disable_stepper_motor_if_necessary_080057e4(void)\n{\n  step_isr_disable();\n  if ((PTR_settings_0800580c[0x3c] != -1) || ((PTR_sys_08005810[2] & 0x20) != 0)) {\n    stepper_motor_disable();\n  }\n  return;\n}",
            "called": [
                "stepper_motor_disable",
                "step_isr_disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080057e4",
            "calling": [
                "limits_go_home",
                "step_period_isr",
                "st_init",
                "mc_reset"
            ],
            "imported": false,
            "current_name": "disable_stepper_motor_if_necessary_080057e4"
        },
        "FUN_08006d8a": {
            "renaming": {
                "FUN_08006d8a": "getPriorityGrouping_08006d8a",
                "uVar1": "priorityGrouping"
            },
            "code": "uint32_t getPriorityGrouping_08006d8a(void)\n{\n  uint32_t priorityGrouping = NVIC_GetPriorityGrouping();\n  return priorityGrouping;\n}",
            "called": [
                "NVIC_GetPriorityGrouping"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d8a",
            "calling": [],
            "imported": false,
            "current_name": "getPriorityGrouping_08006d8a"
        },
        "FUN_0800b2e8": {
            "renaming": {
                "FUN_0800b2e8": "calculatePower_0800b2e8",
                "__x": "base",
                "__n": "exponent",
                "in_r1": "countShifts",
                "in_r2": "exponentCopy",
                "uVar1": "resultExponent",
                "iVar2": "exponentCopy",
                "uVar3": "resultMantissa1",
                "dVar4": "resultMantissa2",
                "uVar5": "resultShifted"
            },
            "code": "double calculatePower_0800b2e8(double base, int exponent)\n{\n  uint countShifts;\n  int exponentCopy;\n  uint resultShifted;\n  int resultExponent;\n  uint resultMantissa1;\n  double resultMantissa2;\n  double result;\n  \n  resultExponent = (countShifts = base << 1) >> 0x15;\n  if (resultExponent == 0) {\n    if ((exponent | countShifts & 0x7fffffff) == 0) {\n      return resultMantissa2;\n    }\n    resultShifted = __muldf3(exponent,countShifts,0,DAT_0800b3c8);\n    if (exponentCopy < DAT_0800b3cc) goto LAB_0800b34a;\n    resultExponent = ((uint)((int)(resultShifted >> 0x20) << 1) >> 0x15) - 0x36;\n    resultMantissa2 = result;\n  }\n  else if (resultExponent == 0x7ff) {\n    resultMantissa2 = (double)__aeabi_dadd(exponent,countShifts,exponent);\n    return resultMantissa2;\n  }\n  resultMantissa1 = (uint)(resultShifted >> 0x20);\n  exponentCopy = resultExponent + exponent;\n  if (exponentCopy < 0x7ff) {\n    if (0 < exponentCopy) {\n      return resultMantissa2;\n    }\n    if (exponentCopy + 0x35 < 0 == SCARRY4(exponentCopy,0x35)) {\n      resultMantissa2 = (double)__muldf3((int)resultShifted,resultMantissa1 & 0x800fffff | (exponentCopy + 0x36) * 0x100000,0,DAT_0800b3d8);\n      return resultMantissa2;\n    }\n    if (exponent < 0xc351) {\n      resultShifted = resultShifted & 0x8000000000000000 | (ulonglong)DAT_0800b3d0 | 0x1a56e1f00000000;\nLAB_0800b34a:\n      resultMantissa2 = (double)__muldf3((int)resultShifted,(int)(resultShifted >> 0x20),DAT_0800b3b8,DAT_0800b3bc);\n      return resultMantissa2;\n    }\n  }\n  resultMantissa2 = (double)__muldf3(DAT_0800b3d4,resultMantissa1 & 0x80000000 | 0x7e37e43c,DAT_0800b3c0,DAT_0800b3c4);\n  return resultMantissa2;\n}",
            "called": [
                "__muldf3",
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2e8",
            "calling": [
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "calculatePower_0800b2e8"
        },
        "FUN_08005220": {
            "renaming": {
                "FUN_08005220": "do_nothing_08005220"
            },
            "code": "\nvoid do_nothing_08005220(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005220",
            "calling": [
                "spindle_run"
            ],
            "imported": false,
            "current_name": "do_nothing_08005220"
        },
        "FUN_08007520": {
            "renaming": {
                "FUN_08007520": "clear_gpio_if_bit_is_set_08007520",
                "bits": "bits",
                "gpio_clr": "gpio_clear"
            },
            "code": "void clear_gpio_if_bit_is_set_08007520(uint32_t bits)\n{\n  if ((bits & 1) != 0) {\n    gpio_clear(0x3e);\n  }\n  return;\n}",
            "called": [
                "gpio_clr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007520",
            "calling": [
                "debounce_isr"
            ],
            "imported": false,
            "current_name": "clear_gpio_if_bit_is_set_08007520"
        },
        "FUN_08007884": {
            "renaming": {
                "FUN_08007884": "read_gpio_pins_08007884",
                "iVar1": "pin1",
                "iVar2": "pin2",
                "iVar3": "pin3",
                "iVar4": "pin4",
                "iVar5": "pin5",
                "uVar6": "result"
            },
            "code": "uint32_t read_gpio_pins_08007884(void)\n{\n    int pin1 = gpio_rd(0x36);\n    int pin2 = gpio_rd(0x37);\n    int pin3 = gpio_rd(0x38);\n    int pin4 = gpio_rd(0x39);\n    int pin5 = gpio_rd(0xf);\n    uint32_t result = gpio_rd(0);\n    result |= pin1 << 4;\n    result |= pin2 << 3;\n    result |= pin3 << 2;\n    result |= pin4 << 1;\n    result |= pin5 << 7;\n    return result;\n}",
            "called": [
                "gpio_rd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007884",
            "calling": [
                "debounce_isr"
            ],
            "imported": false,
            "current_name": "read_gpio_pins_08007884"
        },
        "FUN_08004250": {
            "renaming": {
                "synchronize_08004250": "print_settings",
                "n": "x_step_mm",
                "n_00": "y_step_mm",
                "n_01": "z_step_mm",
                "n_02": "step_pulse_usec",
                "n_03": "default_feed_mm_min",
                "n_04": "step_idle_delay_msec",
                "n_05": "acceleration_mm_sec_2",
                "n_06": "junction_deviation_mm",
                "n_07": "homing_feed_mm_min",
                "n_08": "homing_seek_mm_min",
                "n_09": "homing_pull_off_mm",
                "uint": "unsigned_int",
                "printPgmString": "print_program_string",
                "printFloat": "print_float",
                "printInteger": "print_integer",
                "print_uint16_base2": "print_unsigned_int_16_base_2",
                "FUN_08004250": "print_settings_08004250"
            },
            "code": "\nvoid print_settings_08004250(void)\n\n{\n  float x_step_mm;\n  float y_step_mm;\n  float z_step_mm;\n  float step_pulse_usec;\n  float default_feed_mm_min;\n  float step_idle_delay_msec;\n  float acceleration_mm_sec_2;\n  float junction_deviation_mm;\n  float homing_feed_mm_min;\n  float homing_seek_mm_min;\n  float homing_pull_off_mm;\n  \n  print_program_string(PTR_DAT_08004470);\n  print_float(x_step_mm);\n  print_program_string(PTR_s___x__step_mm___1__08004478);\n  print_float(y_step_mm);\n  print_program_string(PTR_s___y__step_mm___2__0800447c);\n  print_float(z_step_mm);\n  print_program_string(PTR_s___z__step_mm___3__08004480);\n  print_integer((unsigned_int)(byte)PTR_settix_step_mmgs_08004474[0xd]);\n  print_program_string(PTR_s___step_pulse__usec___4__08004484);\n  print_float(step_pulse_usec);\n  print_program_string(PTR_s___default_feed__mm_mix_step_mm___5__08004488);\n  print_float(default_feed_mm_min);\n  print_program_string(PTR_s___default_seek__mm_mix_step_mm___6__0800448c);\n  print_integer((unsigned_int)*(ushort *)(PTR_settix_step_mmgs_08004474 + 0x18));\n  print_program_string(PTR_s___step_port_ix_step_mmvert_mask__ix_step_mmt__08004490);\n  print_unsigned_int_16_base_2(*(unsigned_int16_t *)(PTR_settix_step_mmgs_08004474 + 0x18));\n  print_program_string(PTR_s____7__08004494);\n  print_integer((unsigned_int)(byte)PTR_settix_step_mmgs_08004474[0x3c]);\n  print_program_string(PTR_s___step_idle_delay__msec___8__08004498);\n  step_idle_delay_msec = (float)__aeabi_fdiv(*(ux_step_mmdefix_step_mmed4 *)(PTR_settix_step_mmgs_08004474 + 0x20),DAT_0800449c);\n  print_float(step_idle_delay_msec);\n  print_program_string(PTR_s___acceleratiox_step_mm__mm_sec_2___9__080044a0);\n  print_float(acceleration_mm_sec_2);\n  print_program_string(PTR_s___jux_step_mmctiox_step_mm_deviatiox_step_mm__mm___10__080044a4);\n  print_float(junction_deviation_mm);\n  print_program_string(PTR_s___arc__mm_segmex_step_mmt___11__080044a8);\n  print_integer((unsigned_int)(byte)PTR_settix_step_mmgs_08004474[0x3e]);\n  print_program_string(PTR_s___x_step_mm_arc_correctiox_step_mm__ix_step_mmt___12__080044ac);\n  print_integer((unsigned_int)(byte)PTR_settix_step_mmgs_08004474[0x3d]);\n  print_program_string(PTR_s___x_step_mm_decimals__ix_step_mmt___13__080044b0);\n  print_integer((unsigned_int)((PTR_settix_step_mmgs_08004474[0x28] & 1) != 0));\n  print_program_string(PTR_s___report_ix_step_mmches__bool___14__080044b4);\n  print_integer((unsigned_int)((PTR_settix_step_mmgs_08004474[0x28] & 2) != 0));\n  print_program_string(PTR_s___auto_start__bool___15__080044b8);\n  print_integer((unsigned_int)((PTR_settix_step_mmgs_08004474[0x28] & 4) != 0));\n  print_program_string(PTR_s___ix_step_mmvert_step_ex_step_mmable__bool___16__080044bc);\n  print_integer((unsigned_int)((PTR_settix_step_mmgs_08004474[0x28] & 8) != 0));\n  print_program_string(PTR_s___hard_limits__bool___17__080044c0);\n  print_integer((unsigned_int)((PTR_settix_step_mmgs_08004474[0x28] & 0x10) != 0));\n  print_program_string(PTR_s___homix_step_mmg_cycle__bool___18__080044c4);\n  print_integer((unsigned_int)*(ushort *)(PTR_settix_step_mmgs_08004474 + 0x2a));\n  print_program_string(PTR_s___homix_step_mmg_dir_ix_step_mmvert_mask__ix_step_mmt__080044c8);\n  print_unsigned_int_16_base_2(*(unsigned_int16_t *)(PTR_settix_step_mmgs_08004474 + 0x2a));\n  print_program_string(PTR_s____19__080044cc);\n  print_float(homing_feed_mm_min);\n  print_program_string(PTR_s___homix_step_mmg_feed__mm_mix_step_mm___20__080044d0);\n  print_float(homing_seek_mm_min);\n  print_program_string(PTR_s___homix_step_mmg_seek__mm_mix_step_mm___21__080044d4);\n  print_integer((unsigned_int)*(ushort *)(PTR_settix_step_mmgs_08004474 + 0x34));\n  print_program_string(PTR_s___homix_step_mmg_deboux_step_mmce__msec___22__080044d8);\n  print_float(homing_pull_off_mm);\n  print_program_string(PTR_s___homix_step_mmg_pull_off__mm___23__080044dc);\n  print_integer((unsigned_int)*(ushort *)(PTR_settix_step_mmgs_08004474 + 0x1a));\n  print_program_string(PTR_s___dir_port_ix_step_mmvert_mask__ix_step_mmt__080044e0);\n  print_unsigned_int_16_base_2(*(unsigned_int16_t *)(PTR_settix_step_mmgs_08004474 + 0x1a));\n  print_program_string(PTR_DAT_080044e4);\n  returx_step_mm;\n}\n\n",
            "called": [
                "printInteger",
                "printPgmString",
                "__aeabi_fdiv",
                "print_uint16_base2",
                "printFloat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004250",
            "calling": [
                "protocol_execute_line",
                "settings_init"
            ],
            "imported": false,
            "current_name": "print_settings_08004250"
        },
        "FUN_08006dc4": {
            "renaming": {
                "FUN_08006dc4": "set_pending_interrupt_08006dc4",
                "IRQn": "interrupt_number"
            },
            "code": "void set_pending_interrupt_08006dc4(IRQn_Type interrupt_number)\n{\n  NVIC_SetPendingIRQ(interrupt_number);\n  return;\n}",
            "called": [
                "NVIC_SetPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006dc4",
            "calling": [],
            "imported": false,
            "current_name": "set_pending_interrupt_08006dc4"
        },
        "FUN_08007402": {
            "renaming": {
                "FUN_08007402": "set_bit_in_short_array_08007402",
                "n": "bit_index",
                "*(short *)((n >> 4) * 0x400 + 0x40020018)": "*array",
                "(short)(1 << (n & 0xfU))": "bit_mask"
            },
            "code": "void set_bit_in_short_array_08007402(int bit_index)\n{\n    short* array = (short*)((bit_index >> 4) * 0x400 + 0x40020018);\n    short bit_mask = (short)(1 << (bit_index & 0xf));\n    *array = bit_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007402",
            "calling": [
                "debounce_on_handler"
            ],
            "imported": false,
            "current_name": "set_bit_in_short_array_08007402"
        },
        "FUN_08002870": {
            "renaming": {
                "FUN_08002870": "increment_block_index_08002870",
                "block_index": "block_index",
                "local_9": "incremented_index"
            },
            "code": "uint8_t increment_block_index_08002870(uint8_t block_index) {\n  uint8_t incremented_index;\n  incremented_index = block_index + 1;\n  if (incremented_index == 18) {\n    incremented_index = 0;\n  }\n  return incremented_index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002870",
            "calling": [
                "plan_discard_current_block",
                "plan_reset_buffer",
                "planner_forward_pass",
                "planner_recalculate_trapezoids",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "increment_block_index_08002870"
        },
        "FUN_08000210": {
            "renaming": {
                "FUN_08000210": "turnOffCoolant_08000210",
                "coolant_mist_off": "turnOffMist",
                "coolant_flood_off": "turnOffFlood"
            },
            "code": "void turnOffCoolant_08000210() {\n  turnOffMist();\n  turnOffFlood();\n  return;\n}",
            "called": [
                "coolant_mist_off",
                "coolant_flood_off"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000210",
            "calling": [
                "coolant_init",
                "coolant_run",
                "mc_reset"
            ],
            "imported": false,
            "current_name": "turnOffCoolant_08000210"
        },
        "FUN_08008a64": {
            "renaming": {
                "FUN_08008a64": "check_collision_08008a64",
                "param_1": "x1",
                "param_2": "y1",
                "param_3": "x2",
                "param_4": "y2",
                "bVar2": "is_horizontal_collision",
                "bVar3": "is_vertical_collision",
                "uVar1": "delta_x",
                "uVar2": "delta_y"
            },
            "code": "uint check_collision_08008a64(uint x1, uint y1, uint x2, uint y2)\n{\n    bool is_horizontal_collision = (x1 == x2);\n    bool is_vertical_collision = (y1 == y2);\n    bool is_collision = (is_horizontal_collision && is_vertical_collision);\n    if (!is_collision)\n    {\n        uint delta_x = x1 > x2 ? x1 - x2 : x2 - x1;\n        uint delta_y = y1 > y2 ? y1 - y2 : y2 - y1;\n        is_collision = (delta_x <= 1 && delta_y <= 1);\n    }\n    return is_collision ? 1 : 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a64",
            "calling": [],
            "imported": false,
            "current_name": "check_collision_08008a64"
        },
        "FUN_08005900": {
            "renaming": {
                "FUN_08005900": "process_data_08005900",
                "data": "input",
                "rc": "result",
                "PTR_sys_08005978": "sys_data"
            },
            "code": "int process_data_08005900(uint8_t input) {\n    int result;\n    if (input == '~') {\n        PTR_sys_08005978[2] |= 2;\n        result = 1;\n    } else if (input < 0x7f) {\n        if (input == '?') {\n            PTR_sys_08005978[2] |= 1;\n            result = 1;\n        } else if (input < 0x40) {\n            if (input == '\\x18') {\n                mc_reset();\n                result = 1;\n            } else if (input == '!') {\n                PTR_sys_08005978[2] |= 8;\n                result = 1;\n            }\n        }\n    }\n    return result;\n}",
            "called": [
                "mc_reset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005900",
            "calling": [
                "serial_read"
            ],
            "imported": false,
            "current_name": "process_data_08005900"
        },
        "FUN_08002638": {
            "renaming": {
                "FUN_08002638": "parse_float_from_line_08002638",
                "line": "input_string",
                "char_counter": "current_char_index",
                "float_ptr": "output_float",
                "bVar1": "current_digit_numeric_value",
                "bVar2": "is_negative",
                "bVar3": "has_decimal",
                "puVar4": "next_char_ptr",
                "puVar5": "current_char_ptr",
                "iVar6": "return_value",
                "uVar7": "temporary_double",
                "fval": "temporary_float",
                "isdecimal": "unused_isdecimal",
                "ndigit": "num_digits",
                "exp": "exponent",
                "intval": "integer_part",
                "isnegative": "unused_isnegative",
                "c": "current_char",
                "ptr": "unused_ptr"
            },
            "code": "int parse_float_from_line_08002638(char *line, uint8_t *char_counter, float *float_ptr)\n{\n    uint8_t num_digits = 0;\n    int8_t exponent = 0;\n    uint32_t integer_part = 0;\n    float float_part = 0;\n    bool is_negative = false;\n    bool has_decimal = false;\n    char *current_char = line + *char_counter;\n    char current_digit = *current_char;\n    if (current_digit == '-') {\n        is_negative = true;\n        current_char++;\n        current_digit = *current_char;\n    }\n    else if (current_digit == '+') {\n        current_char++;\n        current_digit = *current_char;\n    }\n    while (current_digit != '\\0') {\n        if (current_digit == '.') {\n            has_decimal = true;\n        }\n        else if (isdigit(current_digit)) {\n            num_digits++;\n            if (num_digits < 9) {\n                integer_part = (uint32_t)(current_digit - '0') + integer_part * 10;\n                if (has_decimal) {\n                    exponent--;\n                }\n            }\n            else if (!has_decimal) {\n                exponent++;\n            }\n            else {\n                float_part = integer_part;\n                while (exponent < 0) {\n                    float_part /= 10.0;\n                    exponent += 1;\n                }\n                while (exponent > 0) {\n                    float_part *= 10.0;\n                    exponent -= 1;\n                }\n                break;\n            }\n        }\n        else {\n            break;\n        }\n        current_char++;\n        current_digit = *current_char;\n    }\n    if (is_negative) {\n        *float_ptr = -float_part;\n    }\n    else {\n        *float_ptr = float_part;\n    }\n    *char_counter = ((char)current_char - (char)line) + 0xff;\n    return num_digits > 0;\n}",
            "called": [
                "__floatunsisf",
                "__aeabi_fcmpeq",
                "__aeabi_fmul",
                "__aeabi_f2d",
                "__truncdfsf2",
                "__muldf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002638",
            "calling": [
                "protocol_execute_line",
                "next_statement"
            ],
            "imported": false,
            "current_name": "parse_float_from_line_08002638"
        },
        "FUN_08005bac": {
            "renaming": {
                "FUN_08005bac": "set_dat_08005bc0_to_1_08005bac",
                "*DAT_08005bc0": "dat_pointer"
            },
            "code": "void set_dat_08005bc0_to_1_08005bac(void)\n{\n  **DAT_08005bc0 = 1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bac",
            "calling": [],
            "imported": false,
            "current_name": "set_dat_08005bc0_to_1_08005bac"
        },
        "FUN_080051b4": {
            "renaming": {
                "FUN_080051b4": "readAndReportCoordinates_080051b4",
                "uVar1": "global_settings",
                "coord_data": "coordinate_data",
                "i": "index",
                "read_global_settings": "readGlobalSettings",
                "report_status_message": "reportStatusMessage",
                "settings_reset": "resetSettings",
                "report_grbl_settings": "reportGrblSettings",
                "settings_read_coord_data": "readCoordinateData"
            },
            "code": "void readAndReportCoordinates_080051b4()\n{\n    uint8_t global_settings = readGlobalSettings();\n    if (global_settings == 0)\n    {\n        reportStatusMessage('\\n');\n        resetSettings(true);\n        reportGrblSettings();\n    }\n    for (uint8_t i = 0; i < 8; i++)\n    {\n        float coordinate_data[3];\n        uint8_t read_status = readCoordinateData(i, coordinate_data);\n        if (read_status == 0)\n        {\n            reportStatusMessage('\\n');\n        }\n    }\n}",
            "called": [
                "settings_read_coord_data",
                "settings_reset",
                "read_global_settings",
                "report_status_message",
                "report_grbl_settings"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080051b4",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "readAndReportCoordinates_080051b4"
        },
        "FUN_080098d0": {
            "renaming": {
                "synchronize_080098d0": "synchronize",
                "__x": "input",
                "cVar1": "versionChar",
                "iVar2": "mathError",
                "puVar3": "errnoVal",
                "piVar4": "errnoVal",
                "dVar5": "output",
                "extraout_d0": "output",
                "extraout_d0_00": "output",
                "extraout_d0_01": "output",
                "extraout_d0_02": "output",
                "extraout_d0_03": "output",
                "local_50": "localArray",
                "local_38": "localDouble",
                "local_30": "unordered",
                "__ieee754_synchronize_080098d0": "__ieee754_synchronize",
                "PTR___fdlib_version_08009988": "PTR___fdlib_version_08009988",
                "__unorddf2": "__unorddf2",
                "__aeabi_dcmplt": "__aeabi_dcmplt",
                "PTR_DAT_0800998c": "PTR_DAT_0800998c",
                "matherr": "matherr",
                "exception": "exception",
                "FUN_080098d0": "synchronize_080098d0"
            },
            "code": "double synchronize_080098d0(double input)\n{\n    double output;\n    char versionChar;\n    int mathError;\n    int errnoVal;\n    undefined localArray[24];\n    undefined8 localDouble;\n    int unordered;\n    output = (double)__ieee754_synchronize_080098d0_080098d0();\n    versionChar = *PTR___fdlib_version_08009988;\n    unordered = __unorddf2();\n    if (versionChar == -1 || unordered != 0 || __aeabi_dcmplt() == 0) {\n        return output;\n    }\n    localArray._0_4_ = 1;\n    localArray._4_4_ = PTR_DAT_0800998c;\n    if (versionChar == '\\0') {\n        localDouble = 0.0;\n        mathError = matherr((exception *)localArray);\n        if (mathError != 0) {\n            goto joined_r0x0800997a;\n        }\n    }\n    else {\n        localDouble = (double)__divdf3(0,0,0,0);\n        if (versionChar != '\\x02') {\n            goto joined_r0x0800996c;\n        }\n    }\n    errnoVal = *__errno();\n    *puVar3 = 0x21;\njoined_r0x0800997a:\n    if (unordered != 0) {\n        errnoVal = *__errno();\n        dVar5 = extraout_d0_03;\n    }\n    return output;\n}\n",
            "called": [
                "__ieee754_sqrt",
                "__aeabi_dcmplt",
                "__errno",
                "matherr",
                "__unorddf2",
                "__divdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080098d0",
            "calling": [
                "homing_cycle",
                "plan_buffer_line",
                "max_allowable_speed",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "synchronize_080098d0"
        },
        "FUN_08005c30": {
            "renaming": {
                "FUN_08005c30": "check_ticks_08005c30",
                "ticks": "input_ticks",
                "is_valid_ticks": "valid_ticks",
                "DAT_08005c70": "ptr_dat_08005c70",
                "PTR_DAT_08005c70": "ptr_dat_08005c70",
                "SysTick_IRQn": "systick_irqn"
            },
            "code": "uint32_t check_ticks_08005c30(uint32_t ticks)\n{\n  bool is_valid_ticks;\n  is_valid_ticks = (ticks - 1) < 0x1000000;\n  if (is_valid_ticks) {\n    PTR_DAT_08005c70[1] = ticks - 1;\n    NVIC_SetPriority(SysTick_IRQn, 0xf);\n    PTR_DAT_08005c70[2] = 0;\n    *PTR_DAT_08005c70 = 7;\n  }\n  return (uint32_t)!is_valid_ticks;\n}",
            "called": [
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005c30",
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "check_ticks_08005c30"
        },
        "FUN_0800b51c": {
            "renaming": {
                "FUN_0800b51c": "do_nothing_0800b51c"
            },
            "code": "\nvoid do_nothing_0800b51c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b51c",
            "calling": [
                "__register_exitproc"
            ],
            "imported": false,
            "current_name": "do_nothing_0800b51c"
        },
        "FUN_0800056c": {
            "renaming": {
                "FUN_0800056c": "calculate_value_0800056c",
                "value": "input",
                "in_r0": "input_int",
                "uVar1": "input_double",
                "PTR_gc_080005b0": "gc_pointer",
                "DAT_080005a8": "multiplier",
                "DAT_080005ac": "addend"
            },
            "code": "float calculate_value_0800056c(float input)\\n{\\n  if (PTR_gc_080005b0[3] != \"\\0\") {\\n    double input_double = (double)input;\\n    double result_double = input_double * DAT_080005a8 + DAT_080005ac;\\n    float result_float = (float)result_double;\\n    return result_float;\\n  }\\n  return input;\\n}",
            "called": [
                "__aeabi_f2d",
                "__truncdfsf2",
                "__muldf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800056c",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "calculate_value_0800056c"
        },
        "FUN_08002f24": {
            "renaming": {
                "FUN_08002f24": "resetPlanBufferAndSetToZero_08002f24",
                "PTR_pl_08002f3c": "planBuffer"
            },
            "code": "void resetPlanBufferAndSetToZero_08002f24(void)\n{\n  resetPlanBuffer();\n  memset(PTR_pl_08002f3c,0,sizeof(PTR_pl_08002f3c));\n  return;\n}",
            "called": [
                "memset",
                "plan_reset_buffer"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f24",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "resetPlanBufferAndSetToZero_08002f24"
        },
        "FUN_0800981c": {
            "renaming": {
                "synchronize_0800981c": "synchronize",
                "__x": "x",
                "__y": "y",
                "puVar2": "fdlib_version",
                "iVar3": "is_finite",
                "puVar4": "errno_ptr",
                "dVar5": "result",
                "extraout_d0": "sync_result",
                "extraout_d0_00": "sync_result_2",
                "extraout_d0_01": "sync_result_3",
                "extraout_d0_02": "sync_result_3",
                "extraout_d0_03": "sync_result_4",
                "in_stack_ffffffb0": "stack_int",
                "in_stack_ffffffb4": "stack_char",
                "FUN_0800981c": "synchronize_0800981c"
            },
            "code": "double synchronize_0800981c(double x, double y) {\n  char version;\n  undefined *fdlib_version;\n  int is_finite;\n  undefined4 *errno_ptr;\n  double result;\n  double sync_result;\n  double sync_result_2;\n  double sync_result_3;\n  double sync_result_4;\n  int stack_int;\n  char *stack_char;\n  fdlib_version = PTR___fdlib_version_080098cc;\n  sync_result = (double) __ieee754_synchronize_0800981c_0800981c();\n  if (*fdlib_version != -1 && (is_finite = finite((double)CONCAT44(stack_char,stack_int)), result = sync_result, is_finite == 0) && (is_finite = finite((double)CONCAT44(stack_char,stack_int)), result = sync_result_2, is_finite != 0) && (is_finite = finite((double)CONCAT44(stack_char,stack_int)), result = sync_result_3, is_finite != 0 && ((version = *fdlib_version, version != '\\0' && version == '\\x02') || (is_finite = matherr((exception *)&stack_int), result = sync_result_4, is_finite == 0)))) {\n    errno_ptr = (undefined4 *)__errno();\n    *errno_ptr = 0x22;\n    result = sync_result_3;\n  }\n  return result;\n}",
            "called": [
                "finite",
                "__ieee754_hypot",
                "__errno",
                "matherr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800981c",
            "calling": [
                "mc_arc",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "synchronize_0800981c"
        },
        "FUN_080059b4": {
            "renaming": {
                "FUN_080059b4": "initializeSystem_080059b4",
                "DAT_080059f4": "PTR_GPIOC_CRH",
                "HAL_SYSTICK_Config": "Not Renamed",
                "HAL_NVIC_SetPriorityGrouping": "Not Renamed",
                "HAL_MspInit": "Not Renamed",
                "HAL_OK": "Not Renamed",
                "GPIOC_CRH_CNF13_1": "GPIOC_CRH_CNF13_Input_Pullup",
                "GPIOC_CRH_MODE13_1": "GPIOC_CRH_MODE13_Output_50MHz",
                "GPIOC_CRH_MODE13_0": "GPIOC_CRH_MODE13_Output_10MHz",
                "GPIO_BSRR_BS13": "GPIO_BSRR_Set_Bit_13",
                "RCC_APB2ENR_IOPCEN": "RCC_APB2ENR_Enable_GPIOC_Clock",
                "RCC_APB2ENR_AFIOEN": "RCC_APB2ENR_Enable_AFIO_Clock",
                "RCC_CFGR_ADCPRE_0": "RCC_CFGR_ADCPRE_Divide_By_2",
                "RCC_CFGR_ADCPRE_1": "RCC_CFGR_ADCPRE_Divide_By_4",
                "RCC_CFGR_ADCPRE_DIV8": "RCC_CFGR_ADCPRE_Divide_By_8",
                "RCC_APB2ENR_ADC1EN": "RCC_APB2ENR_Enable_ADC1_Clock",
                "ADC_CR2_CAL": "ADC_CR2_Calibrate",
                "ADC_CR2_JEXTSEL_2": "ADC_CR2_External_Trigger_Select_Bit_2",
                "ADC_CR2_JEXTSEL_1": "ADC_CR2_External_Trigger_Select_Bit_1",
                "ADC_CR2_JEXTSEL_0": "ADC_CR2_External_Trigger_Select_Bit_0",
                "ADC_CR2_JEXTTRIG": "ADC_CR2_External_Trigger_Enable_For_Injected_Conversion",
                "ADC_CR1_SCAN": "ADC_CR1_Scan_Mode",
                "ADC_JSQR_JSQ4_0": "ADC_JSQR_Injected_Channel_4_Select_Bit_0",
                "ADC_JSQR_JSQ4_1": "ADC_JSQR_Injected_Channel_4_Select_Bit_1",
                "ADC_JSQR_JSQ4_2": "ADC_JSQR_Injected_Channel_4_Select_Bit_2",
                "ADC_JSQR_JSQ4_3": "ADC_JSQR_Injected_Channel_4_Select_Bit_3",
                "ADC_CR2_ADON": "ADC_CR2_Enable_ADC"
            },
            "code": "HAL_StatusTypeDef initializeSystem_080059b4(void)\n{\n  *DAT_080059f4 = *DAT_080059f4 | GPIOC_CRH_CNF13_1 | GPIOC_CRH_MODE13_1 | GPIOC_CRH_MODE13_0;\n  *PTR_GPIOC_BSRR = GPIO_BSRR_BS13;\n  *PTR_RCC_APB2ENR |= RCC_APB2ENR_IOPCEN | RCC_APB2ENR_AFIOEN;\n  *PTR_RCC_CFGR &= ~(RCC_CFGR_ADCPRE_0 | RCC_CFGR_ADCPRE_1);\n  *PTR_RCC_CFGR |= RCC_CFGR_ADCPRE_DIV8;\n  *PTR_RCC_APB2ENR |= RCC_APB2ENR_ADC1EN;\n  *PTR_ADC1_CR2 |= ADC_CR2_CAL;\n  while((*PTR_ADC1_CR2 & ADC_CR2_CAL) != 0);\n  *PTR_ADC1_CR2 |= ADC_CR2_JEXTSEL_2 | ADC_CR2_JEXTSEL_1 | ADC_CR2_JEXTSEL_0 | ADC_CR2_JEXTTRIG;\n  *PTR_ADC1_CR1 |= ADC_CR1_SCAN;\n  *PTR_ADC1_JSQR = ADC_JSQR_JSQ4_0 | ADC_JSQR_JSQ4_1 | ADC_JSQR_JSQ4_2 | ADC_JSQR_JSQ4_3;\n  *PTR_ADC1_CR2 |= ADC_CR2_ADON;\n  return HAL_OK;\n}",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_SYSTICK_Config",
                "HAL_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080059b4",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initializeSystem_080059b4"
        },
        "FUN_08006c04": {
            "renaming": {
                "FUN_08006c04": "calculate_priority_levels_08006c04",
                "Priority": "priority",
                "PriorityGroup": "priority_group",
                "pPreemptPriority": "preempt_priority",
                "pSubPriority": "sub_priority",
                "SubPriorityBits": "sub_priority_bits",
                "PreemptPriorityBits": "preempt_priority_bits",
                "PriorityGroupTmp": "priority_group_tmp",
                "uVar1": "group_bits",
                "uVar2": "group_shift",
                "uVar3": "group_offset"
            },
            "code": "void calculate_priority_levels_08006c04(uint32_t priority, uint32_t priority_group, uint32_t *preempt_priority, uint32_t *sub_priority)\n{\n  uint32_t sub_priority_bits;\n  uint32_t preempt_priority_bits;\n  uint32_t priority_group_tmp;\n  uint32_t group_shift = 7 - (priority_group & 7);\n  uint32_t group_offset = (priority_group + 4) > 7 ? (priority_group - 3) : 0;\n  *preempt_priority = ((1 << group_shift) - 1) & (priority >> group_offset);\n  *sub_priority = (1 << group_offset) - 1 & priority;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c04",
            "calling": [
                "HAL_NVIC_GetPriority"
            ],
            "imported": false,
            "current_name": "calculate_priority_levels_08006c04"
        },
        "FUN_08002e08": {
            "renaming": {
                "FUN_08002e08": "calculate_trapezoid_for_all_blocks_08002e08",
                "pbVar1": "current_block",
                "uVar2": "current_entry_speed",
                "next": "next_block",
                "block_index": "block_index",
                "PTR_block_buffer_tail_08002ed0": "block_buffer_tail",
                "PTR_block_buffer_head_08002ed8": "block_buffer_head",
                "PTR_block_buffer_08002ed4": "block_buffer",
                "block_t": "block",
                "__aeabi_fdiv": "divide_floats",
                "recalculate_flag": "recalculate_flag",
                "entry_speed": "entry_speed",
                "nominal_speed": "nominal_speed",
                "next_block_index": "get_next_block_index"
            },
            "code": "void calculate_trapezoid_for_all_blocks_08002e08(void)\n{\n  block_t *current_block;\n  block_t *next_block;\n  uint8_t block_index;\n  \n  block_index = *PTR_PTR_block_buffer_08002ed4_tail_08002ed0;\n  next_block = NULL;\n  while (block_index != *PTR_PTR_block_buffer_08002ed4_head_08002ed8) {\n    current_block = (block_t *)(PTR_block_buffer_08002ed4 + (uint)block_index * 0x40);\n    if ((next_block != NULL) && ((next_block->recalculate_flag != 0 || (current_block->recalculate_flag != 0)))) {\n      __aeabi_fdiv(next_block->entry_speed,next_block->nominal_speed);\n      float current_entry_speed = __aeabi_fdiv(current_block->entry_speed,current_block->nominal_speed);\n      calculate_trapezoid_for_block(next_block, current_entry_speed, (float)((unsigned long long)current_entry_speed >> 0x20));\n      next_block->recalculate_flag = 0;\n    }\n    block_index = next_block_index(block_index);\n    next_block = current_block;\n  }\n  __aeabi_fdiv(next_block->entry_speed,next_block->nominal_speed);\n  calculate_trapezoid_for_block(next_block, 0, 0);\n  next_block->recalculate_flag = 0;\n  return;\n}",
            "called": [
                "calculate_trapezoid_for_block",
                "next_block_index",
                "__aeabi_fdiv"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e08",
            "calling": [
                "planner_recalculate"
            ],
            "imported": false,
            "current_name": "calculate_trapezoid_for_all_blocks_08002e08"
        },
        "FUN_08005bc4": {
            "renaming": {
                "FUN_08005bc4": "clear_data_08005bc4",
                "DAT_08005bd8": "data_pointer"
            },
            "code": "void clear_data_08005bc4(void)\n{\n  *DAT_08005bd8 = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bc4",
            "calling": [],
            "imported": false,
            "current_name": "clear_data_08005bc4"
        },
        "FUN_08006680": {
            "renaming": {
                "FUN_08006680": "get_AHB_clock_frequency_08006680",
                "uVar1": "hclk_freq",
                "uVar2": "leading_zeroes",
                "result": "prescaler_index",
                "result_1": "N/A",
                "PTR_APBAHBPrescTable_080066c8": "prescaler_table",
                "DAT_080066c4": "data_ptr"
            },
            "code": "uint32_t get_AHB_clock_frequency_08006680(void)\n{\n  uint32_t hclk_freq = HAL_RCC_GetHCLKFreq();\n  uint leading_zeroes = count_leading_zeroes(0x380000);\n  uint32_t prescaler_index = (*(uint *)(DAT_080066c4 + 8) & 0x1c00) >> (leading_zeroes & 0xff);\n  return hclk_freq >> PTR_APBAHBPrescTable_080066c8[prescaler_index];\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006680",
            "calling": [
                "set_baud_rate"
            ],
            "imported": false,
            "current_name": "get_AHB_clock_frequency_08006680"
        },
        "FUN_08000340": {
            "renaming": {
                "FUN_08000340": "write_to_eeprom_08000340",
                "addr": "address",
                "new_value": "value",
                "PTR_eeprom_ready_0800036c": "eeprom_ready",
                "eeprom_init": "initialize_eeprom",
                "PTR_eeprom_data_08000370": "eeprom_data"
            },
            "code": "void write_to_eeprom_08000340(uint address, uchar value) {\n  if (*PTR_eeprom_ready_0800036c == 0) {\n    initialize_eeprom();\n  }\n  PTR_eeprom_data_08000370[address & 0x3ff] = value;\n  return;\n}",
            "called": [
                "eeprom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000340",
            "calling": [
                "memcpy_to_eeprom_with_checksum",
                "write_global_settings"
            ],
            "imported": false,
            "current_name": "write_to_eeprom_08000340"
        },
        "FUN_08004bf4": {
            "renaming": {
                "FUN_08004bf4": "write_coord_data_to_eeprom_08004bf4",
                "coord_select": "coord_index",
                "coord_data": "coord_data",
                "addr": "eeprom_addr",
                "memcpy_to_eeprom_with_checksum": "memcpy_to_eeprom_with_checksum"
            },
            "code": "void write_coord_data_to_eeprom_08004bf4(uint8_t coord_index, float *coord_data) {\n  uint16_t eeprom_addr = (coord_index * 13) + 512;\n  memcpy_to_eeprom_with_checksum(eeprom_addr, (char *)coord_data, 12);\n  return;\n}",
            "called": [
                "memcpy_to_eeprom_with_checksum"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004bf4",
            "calling": [
                "settings_read_coord_data",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "write_coord_data_to_eeprom_08004bf4"
        },
        "FUN_08004d7c": {
            "renaming": {
                "FUN_08004d7c": "read_coordinate_data_08004d7c",
                "coord_select": "coord_index",
                "coord_data": "coord_data",
                "iVar1": "read_result",
                "addr": "N/A",
                "memcpy_from_eeprom_with_checksum": "memcpy_from_eeprom_with_checksum",
                "memset": "memset",
                "settings_write_coord_data": "settings_write_coord_data"
            },
            "code": "bool read_coordinate_data_08004d7c(uint8_t coord_index, float *coord_data)\n{\n    int read_result = memcpy_from_eeprom_with_checksum((char *)coord_data, (uint16_t)(coord_index * 13 + 512), 12);\n    if (read_result == 0) {\n        memset(coord_data, 0, 12);\n        settings_write_coord_data(coord_index, coord_data);\n    }\n    return read_result != 0;\n}\n",
            "called": [
                "settings_write_coord_data",
                "memset",
                "memcpy_from_eeprom_with_checksum"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d7c",
            "calling": [
                "gc_init",
                "report_gcode_parameters",
                "gc_execute_line",
                "settings_init"
            ],
            "imported": false,
            "current_name": "read_coordinate_data_08004d7c"
        },
        "FUN_08009278": {
            "renaming": {
                "FUN_08009278": "convert_to_int_08009278",
                "param_1": "input_num",
                "uVar1": "shift_amount",
                "uVar2": "difference",
                "PTR_": "new_",
                "DAT_": "old_"
            },
            "code": "uint convert_to_int_08009278(uint input_num)\n{\n    uint multiplier = 2;\n    uint max_input_num = 0x7f000000;\n    uint output_num = 0;\n    uint shift_amount = 0;\n    uint difference = 0;\n    uint max_multiplier = 0x9f;\n    uint subtractor = 0x9e;\n    uint max_subtractor = 0xffffff9f;\n    uint sign_bit = 0x80000000;\n    uint max_positive_num = 0x7fffffff;\n    \n    if (input_num * multiplier < max_input_num) {\n        return 0;\n    }\n    \n    shift_amount = (input_num * multiplier) >> 0x18;\n    difference = subtractor - shift_amount;\n    \n    if (shift_amount < max_multiplier && difference != 0) {\n        output_num = (input_num << 8 | sign_bit) >> (difference & 0xff);\n        \n        if ((input_num & sign_bit) != 0) {\n            output_num = -output_num;\n        }\n        \n        return output_num;\n    }\n    \n    if (difference == max_subtractor && (input_num & 0x7fffff) != 0) {\n        return 0;\n    }\n    \n    if ((input_num & sign_bit) == 0) {\n        input_num = max_positive_num;\n    }\n    \n    return input_num;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009278",
            "calling": [
                "protocol_execute_line",
                "printFloat"
            ],
            "imported": false,
            "current_name": "convert_to_int_08009278"
        },
        "FUN_080004fc": {
            "renaming": {
                "FUN_080004fc": "convert_to_gc_080004fc",
                "x": "x_coordinate",
                "y": "y_coordinate",
                "z": "z_coordinate",
                "uVar1": "ratio",
                "PTR_settings_08000564": "settings_ptr",
                "PTR_gc_08000568": "gc_ptr"
            },
            "code": "void convert_to_gc_080004fc(float x, float y, float z)\n{\n  float x_ratio = x / *(float *)PTR_settings_08000564;\n  *(float *)(PTR_gc_08000568 + 0xc) = x_ratio;\n  float y_ratio = y / *(float *)(PTR_settings_08000564 + 4);\n  *(float *)(PTR_gc_08000568 + 0x10) = y_ratio;\n  float z_ratio = z / *(float *)(PTR_settings_08000564 + 8);\n  *(float *)(PTR_gc_08000568 + 0x14) = z_ratio;\n  return;\n}",
            "called": [
                "__aeabi_fdiv",
                "__floatsisf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004fc",
            "calling": [
                "sys_sync_current_position"
            ],
            "imported": false,
            "current_name": "convert_to_gc_080004fc"
        },
        "FUN_08000220": {
            "renaming": {
                "FUN_08000220": "synchronize_coolant_mode_08000220",
                "mode": "new_mode",
                "*PTR_current_coolant_mode_08000264": "*current_coolant_mode_ptr",
                "COOLANT_MODE_FLOOD": "1",
                "COOLANT_MODE_MIST": "2"
            },
            "code": "void synchronize_coolant_mode_08000220(uint8_t new_mode)\n{\n  if (new_mode != *PTR_current_coolant_mode_08000264) {\n    plan_synchronize();\n    if (new_mode == COOLANT_MODE_FLOOD) {\n      coolant_flood_on();\n    }\n    else if (new_mode == COOLANT_MODE_MIST) {\n      coolant_mist_on();\n    }\n    else {\n      coolant_stop();\n    }\n    *PTR_current_coolant_mode_08000264 = new_mode;\n  }\n  return;\n}",
            "called": [
                "plan_synchronize",
                "coolant_stop",
                "coolant_mist_on",
                "coolant_flood_on"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000220",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "synchronize_coolant_mode_08000220"
        },
        "FUN_08005238": {
            "renaming": {
                "FUN_08005238": "reset_spindle_direction_08005238",
                "PTR_current_direction_0800524c": "current_direction_ptr",
                "spindle_stop": "stop_spindle"
            },
            "code": "void reset_spindle_direction_08005238(void)\n{\n  *PTR_current_direction_0800524c = 0;\n  stop_spindle();\n  return;\n}",
            "called": [
                "spindle_stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005238",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "reset_spindle_direction_08005238"
        },
        "FUN_08007da8": {
            "renaming": {
                "FUN_08007da8": "enable_timer_interrupt_08007da8",
                "puVar1": "control_register",
                "TIMx": "timer"
            },
            "code": "void enable_timer_interrupt_08007da8(TIM_TypeDef *timer){\n    uint *control_register = DAT_08007dd4;\n    control_register[8] |= 0x10;\n    *control_register |= 1;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007da8",
            "calling": [
                "timers_init"
            ],
            "imported": false,
            "current_name": "enable_timer_interrupt_08007da8"
        },
        "FUN_08004148": {
            "renaming": {
                "FUN_08004148": "print_alarm_message_08004148",
                "alarm_code": "alarm_code",
                "PTR_s_ALARM__08004190": "alarm_header",
                "PTR_s_Abort_during_cycle_08004198": "abort_message",
                "PTR_s_Hard_limit_08004194": "hard_limit_message",
                "PTR_s___MPos__0800419c": "mpos_message",
                "delay_ms": "delay_ms"
            },
            "code": "void print_alarm_message_08004148(int8_t alarm_code)\n{\n  printPgmString(PTR_s_ALARM__08004190);\n  if (alarm_code == -2) {\n    printPgmString(PTR_s_Abort_during_cycle_08004198);\n  }\n  else if (alarm_code == -1) {\n    printPgmString(PTR_s_Hard_limit_08004194);\n  }\n  printPgmString(PTR_s___MPos__0800419c);\n  delay_ms(500);\n  return;\n}",
            "called": [
                "printPgmString",
                "delay_ms"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004148",
            "calling": [
                "protocol_execute_runtime"
            ],
            "imported": false,
            "current_name": "print_alarm_message_08004148"
        },
        "FUN_08004940": {
            "renaming": {
                "FUN_08004940": "printCurrentAndWorkPosition_08004940",
                "uVar1": "float_to_int",
                "fVar2": "float_division_result",
                "extraout_s0": "float_division_result",
                "extraout_s0_00": "float_multiplication_result",
                "extraout_s0_01": "float_subtraction_result",
                "extraout_s0_02": "float_subtraction_result",
                "uVar3": "float_to_double",
                "uVar4": "float_to_double",
                "print_position": "print_position",
                "current_position": "current_position",
                "i": "loop_counter"
            },
            "code": "void printCurrentAndWorkPosition_08004940(void)\n{\n  // Initialize variables\n  float current_position[3];\n  float print_position[3];\n  uint8_t i;\n  // Get current position\n  current_position[0] = *(float *)(PTR_sys_08004b88 + 4);\n  current_position[1] = *(float *)(PTR_sys_08004b88 + 8);\n  current_position[2] = *(float *)(PTR_sys_08004b88 + 0xc);\n  // Check if switch case is needed\n  if ((byte)PTR_sys_08004b88[1] < 8) {\n    // Call switch case\n    (*(code *)(&switchD_0800495e::switchdataD_08004964)[(byte)PTR_sys_08004b88[1]])();\n    return;\n  }\n  // Print current position\n  printPgmString(PTR_s__MPos__08004ba8);\n  for (i = 0; i < 3; i++) {\n    float current_position_float = (float)current_position[i];\n    float settings_float = *(float *)(PTR_settings_08004bac + (uint)i * 4);\n    float print_position_float = current_position_float / settings_float;\n    print_position[i] = print_position_float;\n    if ((PTR_settings_08004bac[0x28] & 1) != 0) {\n      print_position_float = (print_position_float * DAT_08004b80) + DAT_08004b84;\n      print_position[i] = print_position_float;\n    }\n    printFloat(print_position_float);\n    printPgmString(PTR_DAT_08004bb0);\n  }\n  // Print work position\n  printPgmString(PTR_s_WPos__08004bb4);\n  for (i = 0; i < 3; i++) {\n    if ((PTR_settings_08004bac[0x28] & 1) == 0) {\n      float print_position_float = print_position[i];\n      float gc_i8_float = *(float *)(PTR_gc_08004bb8 + (i + 8) * 4);\n      float gc_i10_float = *(float *)(PTR_gc_08004bb8 + (i + 10) * 4 + 4);\n      print_position_float = print_position_float - (gc_i8_float + gc_i10_float);\n      print_position[i] = print_position_float;\n    }\n    else {\n      float print_position_float = print_position[i];\n      float gc_i8_float = *(float *)(PTR_gc_08004bb8 + (i + 8) * 4);\n      float gc_i10_float = *(float *)(PTR_gc_08004bb8 + (i + 10) * 4 + 4);\n      float print_position_double = (double)print_position_float;\n      float gc_i8_i10_double = (double)(gc_i8_float + gc_i10_float);\n      print_position_double = print_position_double - (gc_i8_i10_double * DAT_08004b80) - DAT_08004b84;\n      print_position_float = (float)print_position_double;\n      print_position[i] = print_position_float;\n    }\n    printFloat(print_position_float);\n    if (i < 2) {\n      printPgmString(PTR_DAT_08004bb0);\n    }\n  }\n  printPgmString(PTR_DAT_08004bbc);\n}\n",
            "called": [
                "__addsf3",
                "__aeabi_f2d",
                "__truncdfsf2",
                "__aeabi_fsub",
                "__muldf3",
                "printPgmString",
                "__floatsisf",
                "__aeabi_fdiv",
                "__subdf3",
                "printFloat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004940",
            "calling": [
                "protocol_execute_runtime"
            ],
            "imported": false,
            "current_name": "printCurrentAndWorkPosition_08004940"
        },
        "FUN_08008a74": {
            "renaming": {
                "FUN_08008a74": "is_same_or_zero_08008a74",
                "param_1": "a",
                "param_2": "b",
                "param_3": "c",
                "param_4": "d",
                "uVar1": "xor",
                "bVar2": "is_zero",
                "bVar3": "is_greater_xor"
            },
            "code": "uint is_same_or_zero_08008a74(uint a, uint b, uint c, uint d) {\n  bool is_zero = (a | (b << 1)) == 0 && (c | (d << 1)) == 0;\n  bool is_same = b == d && a == c;\n  if (is_zero || is_same) {\n    return is_zero ? 1 : 0;\n  }\n  uint xor = b ^ d;\n  bool is_same_xor = xor == 0 && b == d;\n  bool is_greater_xor = xor >= 0 && d <= b;\n  int shift = (int)d >> 0x1f;\n  if (!is_same_xor && !is_greater_xor) {\n    shift = ~shift;\n  }\n  return shift | 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a74",
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "imported": false,
            "current_name": "is_same_or_zero_08008a74"
        },
        "FUN_08002fd4": {
            "renaming": {
                "FUN_08002fd4": "execute_protocol_block_08002fd4",
                "pbVar1": "current_block"
            },
            "code": "void execute_protocol_block_08002fd4(void)\\n{\\n  block_t *current_block;\\n  while ((current_block = plan_get_current_block(), current_block != (block_t *)0x0 || (PTR_sys_08003000[1] == \"\\x03\"))) {\\n    protocol_execute_runtime();\\n    if (*PTR_sys_08003000 != \"\\0\") {\\n      return;\\n    }\\n  }\\n  return;\\n}",
            "called": [
                "plan_get_current_block",
                "protocol_execute_runtime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fd4",
            "calling": [
                "coolant_run",
                "mc_go_home",
                "spindle_run",
                "mc_dwell",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "execute_protocol_block_08002fd4"
        },
        "FUN_08002408": {
            "renaming": {
                "FUN_08002408": "calculate_delay_in_ms_08002408",
                "seconds": "delay_in_seconds",
                "ms": "milliseconds",
                "in_r0": "in_reg0",
                "uVar1": "multiplier",
                "uVar2": "subtractor",
                "extraout_r1": "extraout_reg1",
                "extraout_r1_00": "extraout_reg1_00",
                "in_stack_ffffffe0": "stack_var",
                "i": "loop_counter"
            },
            "code": "void calculate_delay_in_ms_08002408(float seconds)\n{\n  uint16_t milliseconds;\n  undefined4 in_reg0;\n  undefined4 multiplier;\n  undefined4 subtractor;\n  undefined4 extraout_reg1;\n  undefined4 extraout_reg1_00;\n  undefined4 stack_var;\n  uint16_t loop_counter;\n  \n  multiplier = __aeabi_fmul(seconds,in_reg0,DAT_080024b8);\n  multiplier = __aeabi_f2d(multiplier);\n  floor((double)CONCAT44(in_reg0,stack_var));\n  loop_counter = __aeabi_d2uiz(multiplier,extraout_reg1);\n  plan_synchronize();\n  subtractor = __aeabi_fmul(in_reg0,DAT_080024bc);\n  subtractor = __floatsisf((uint)loop_counter * 0x32);\n  subtractor = __aeabi_fsub(subtractor,subtractor);\n  subtractor = __aeabi_f2d(subtractor);\n  floor((double)CONCAT44(in_reg0,stack_var));\n  milliseconds = __aeabi_d2uiz(subtractor,extraout_reg1_00);\n  delay_ms(milliseconds);\n  while ((loop_counter != 0 && (protocol_execute_runtime(), *PTR_sys_080024c0 == \"\\0\"))) {\n    _delay_ms(0x32);\n    loop_counter = loop_counter - 1;\n  }\n  return;\n}",
            "called": [
                "floor",
                "plan_synchronize",
                "__aeabi_fmul",
                "_delay_ms",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "__aeabi_fsub",
                "__floatsisf",
                "protocol_execute_runtime",
                "delay_ms"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002408",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "calculate_delay_in_ms_08002408"
        },
        "FUN_08002a94": {
            "renaming": {
                "synchronize_08002a94": "synchronize_blocks",
                "next": "next_block",
                "previous": "previous_block",
                "block": "blocks",
                "block_index": "block_index",
                "PTR_block_buffer_head_08002af0": "PTR_block_buffer_head_08002af0",
                "PTR_block_buffer_tail_08002af8": "PTR_block_buffer_tail_08002af8",
                "prev_block_index": "prev_block_index",
                "PTR_block_buffer_08002af4": "PTR_block_buffer_08002af4",
                "synchronize_08002a94_kernel": "synchronize_blocks_kernel",
                "current_block": "current_block",
                "FUN_08002a94": "synchronize_blocks_08002a94"
            },
            "code": "void synchronize_blocks_08002a94(void)\n{\n  block_t *current_block;\n  block_t *previous_block;\n  block_t *next_block;\n  block_t *blocks[3];\n  uint8_t block_index;\n  \n  block_index = *PTR_block_buffer_head_08002af0;\n  blocks[0] = NULL;\n  blocks[1] = NULL;\n  while (block_index != *PTR_block_buffer_tail_08002af8) {\n    block_index = prev_block_index(block_index);\n    blocks[2] = blocks[1];\n    previous_block = (block_t *)(PTR_block_buffer_08002af4 + (uint)block_index * 0x40);\n    synchronize_blocks_08002a94_kernel(previous_block, blocks[1], blocks[0]);\n    blocks[0] = previous_block;\n    blocks[1] = blocks[2];\n  }\n  return;\n}",
            "called": [
                "planner_reverse_pass_kernel",
                "prev_block_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a94",
            "calling": [
                "planner_recalculate"
            ],
            "imported": false,
            "current_name": "synchronize_blocks_08002a94"
        },
        "FUN_08003618": {
            "renaming": {
                "FUN_08003618": "updateBlock_08003618",
                "step_events_remaining": "remainingStepEvents",
                "puVar2": "blockBufferPtr",
                "bVar1": "bufferByte",
                "uVar3": "blockFloat1",
                "uVar4": "blockFloat2",
                "block": "currentBlock"
            },
            "code": "void updateBlock_08003618(int32_t remainingStepEvents) {\n  byte bufferByte;\n  undefined *blockBufferPtr;\n  undefined4 blockFloat1;\n  undefined4 blockFloat2;\n  block_t *currentBlock;\n  \n  blockBufferPtr = PTR_block_buffer_08003698;\n  bufferByte = *PTR_block_buffer_tail_08003694;\n  blockFloat2 = *(undefined4 *)(PTR_block_buffer_08003698 + (uint)bufferByte * 0x40 + 0x20);\n  blockFloat1 = __floatsisf(remainingStepEvents);\n  blockFloat1 = __aeabi_fmul(blockFloat2, blockFloat1);\n  blockFloat2 = __floatsisf(*(undefined4 *)(blockBufferPtr + (uint)bufferByte * 0x40 + 0x10));\n  blockFloat1 = __aeabi_fdiv(blockFloat1, blockFloat2);\n  *(undefined4 *)(blockBufferPtr + (uint)bufferByte * 0x40 + 0x20) = blockFloat1;\n  *(int32_t *)(blockBufferPtr + (uint)bufferByte * 0x40 + 0x10) = remainingStepEvents;\n  *(undefined4 *)(blockBufferPtr + (uint)bufferByte * 0x40 + 0x18) = 0;\n  *(undefined4 *)(blockBufferPtr + (uint)bufferByte * 0x40 + 0x1c) = 0;\n  blockBufferPtr[(uint)bufferByte * 0x40 + 0x25] = 0;\n  blockBufferPtr[(uint)bufferByte * 0x40 + 0x24] = 1;\n  planner_recalculate();\n  return;\n}",
            "called": [
                "planner_recalculate",
                "__aeabi_fmul",
                "__aeabi_fdiv",
                "__floatsisf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003618",
            "calling": [
                "st_cycle_reinitialize"
            ],
            "imported": false,
            "current_name": "updateBlock_08003618"
        },
        "FUN_0800522c": {
            "renaming": {
                "FUN_0800522c": "do_nothing_0800522c"
            },
            "code": "\nvoid do_nothing_0800522c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800522c",
            "calling": [
                "spindle_run"
            ],
            "imported": false,
            "current_name": "do_nothing_0800522c"
        },
        "FUN_0800af78": {
            "renaming": {
                "FUN_0800af78": "calculate_polynomial_0800af78",
                "__x": "input_value",
                "puVar1": "ptr",
                "in_r0": "int_value",
                "uVar2": "result_1",
                "uVar3": "result_2",
                "in_r1": "uint_value",
                "uVar4": "mul_result_1",
                "uVar5": "mul_result_2",
                "extraout_r1": "extra_mul_result",
                "uVar6": "abs_uint_value",
                "iVar7": "switch_case_value",
                "in_d0": "output_value",
                "dVar8": "add_result",
                "extraout_d0": "add_result_2",
                "uVar9": "mul_result_3",
                "uVar10": "mul_result_4",
                "uVar11": "mul_uint_result"
            },
            "code": "\ndouble calculate_polynomial_0800af78(double input_value)\n\n{\n  undefined *ptr;\n  int int_value;\n  undefined4 result_1;\n  undefined4 result_2;\n  uint uint_value;\n  undefined4 mul_result_1;\n  undefined4 mul_result_2;\n  undefined4 extra_mul_result;\n  uint abs_uint_value;\n  int switch_case_value;\n  double output_value;\n  double add_result;\n  double add_result_2;\n  undefined8 mul_result_3;\n  undefined8 mul_result_4;\n  undefined4 in_stack_ffffffd0;\n  uint mul_uint_result;\n  \n  abs_uint_value = uint_value & 0x7fffffff;\n  if (DAT_0800b298 < (int)abs_uint_value) {\n    if ((abs_uint_value != DAT_0800b29c && (int)DAT_0800b29c <= (int)abs_uint_value) ||\n       ((abs_uint_value == DAT_0800b29c && (int_value != 0)))) {\n      add_result = (double)__aeabi_dadd();\n      return add_result;\n    }\n  }\n  else {\n    if (DAT_0800b2ac < (int)abs_uint_value) {\n      fabs((double)CONCAT44(uint_value,in_stack_ffffffd0));\n      if (DAT_0800b2bc < (int)abs_uint_value) {\n        if ((int)abs_uint_value < DAT_0800b2c0) {\n          mul_result_3 = __subdf3();\n          mul_result_4 = __muldf3(int_value,extra_mul_result,0,DAT_0800b2c4);\n          mul_result_4 = __aeabi_dadd((int)mul_result_4,(int)((ulonglong)mul_result_4 >> 0x20),0,DAT_0800b2b8);\n          mul_result_3 = __divdf3((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),(int)mul_result_4,\n                           (int)((ulonglong)mul_result_4 >> 0x20));\n          mul_uint_result = (uint)((ulonglong)mul_result_3 >> 0x20);\n          int_value = (int)mul_result_3;\n          switch_case_value = 2;\n        }\n        else {\n          mul_result_3 = __divdf3(0,DAT_0800b2c8,int_value,extra_mul_result);\n          mul_uint_result = (uint)((ulonglong)mul_result_3 >> 0x20);\n          int_value = (int)mul_result_3;\n          switch_case_value = 3;\n        }\n      }\n      else if (DAT_0800b2bc + -0xd0000 < (int)abs_uint_value) {\n        mul_result_3 = __subdf3();\n        mul_result_4 = __aeabi_dadd(int_value,extra_mul_result,0,DAT_0800b2b8);\n        mul_result_3 = __divdf3((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),(int)mul_result_4,\n                         (int)((ulonglong)mul_result_4 >> 0x20));\n        mul_uint_result = (uint)((ulonglong)mul_result_3 >> 0x20);\n        int_value = (int)mul_result_3;\n        switch_case_value = 1;\n      }\n      else {\n        mul_result_3 = __aeabi_dadd();\n        mul_result_3 = __subdf3((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),0,DAT_0800b2b8);\n        mul_result_4 = __aeabi_dadd(int_value,extra_mul_result,0,0x40000000);\n        mul_result_3 = __divdf3((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),(int)mul_result_4,\n                         (int)((ulonglong)mul_result_4 >> 0x20));\n        mul_uint_result = (uint)((ulonglong)mul_result_3 >> 0x20);\n        int_value = (int)mul_result_3;\n        switch_case_value = 0;\n      }\n    }\n    else {\n      mul_uint_result = uint_value;\n      if ((int)abs_uint_value <= DAT_0800b2ac + -0x1bc0000) {\n        mul_result_3 = __aeabi_dadd(int_value,uint_value,DAT_0800b290,DAT_0800b294);\n        switch_case_value = __aeabi_dcmpgt((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),0,DAT_0800b2b8);\n        if (switch_case_value != 0) {\n          return add_result_2;\n        }\n      }\n      switch_case_value = -1;\n    }\n    mul_result_3 = __muldf3(int_value,mul_uint_result,int_value);\n    mul_result_1 = (undefined4)((ulonglong)mul_result_3 >> 0x20);\n    result_1 = (undefined4)mul_result_3;\n    mul_result_3 = __muldf3(result_1,mul_result_1,result_1,mul_result_1);\n    mul_result_2 = (undefined4)((ulonglong)mul_result_3 >> 0x20);\n    result_2 = (undefined4)mul_result_3;\n    mul_result_3 = __muldf3(result_2,mul_result_2,DAT_0800b238,DAT_0800b23c);\n    mul_result_3 = __aeabi_dadd((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),DAT_0800b240,DAT_0800b244);\n    mul_result_3 = __muldf3((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),result_2,mul_result_2);\n    mul_result_3 = __aeabi_dadd((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),DAT_0800b248,DAT_0800b24c);\n    mul_result_3 = __muldf3((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),result_2,mul_result_2);\n    mul_result_3 = __aeabi_dadd((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),DAT_0800b250,DAT_0800b254);\n    mul_result_3 = __muldf3((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),result_2,mul_result_2);\n    mul_result_3 = __aeabi_dadd((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),DAT_0800b258,DAT_0800b25c);\n    mul_result_3 = __muldf3((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),result_2,mul_result_2);\n    mul_result_3 = __aeabi_dadd((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),DAT_0800b260,DAT_0800b264);\n    mul_result_3 = __muldf3((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),result_1,mul_result_1);\n    result_1 = (undefined4)((ulonglong)mul_result_3 >> 0x20);\n    mul_result_4 = __muldf3(result_2,mul_result_2,DAT_0800b268,DAT_0800b26c);\n    mul_result_4 = __subdf3((int)mul_result_4,(int)((ulonglong)mul_result_4 >> 0x20),DAT_0800b270,DAT_0800b274);\n    mul_result_4 = __muldf3((int)mul_result_4,(int)((ulonglong)mul_result_4 >> 0x20),result_2,mul_result_2);\n    mul_result_4 = __subdf3((int)mul_result_4,(int)((ulonglong)mul_result_4 >> 0x20),DAT_0800b278,DAT_0800b27c);\n    mul_result_4 = __muldf3((int)mul_result_4,(int)((ulonglong)mul_result_4 >> 0x20),result_2,mul_result_2);\n    mul_result_4 = __subdf3((int)mul_result_4,(int)((ulonglong)mul_result_4 >> 0x20),DAT_0800b280,DAT_0800b284);\n    mul_result_4 = __muldf3((int)mul_result_4,(int)((ulonglong)mul_result_4 >> 0x20),result_2,mul_result_2);\n    mul_result_4 = __subdf3((int)mul_result_4,(int)((ulonglong)mul_result_4 >> 0x20),DAT_0800b288,DAT_0800b28c);\n    mul_result_4 = __muldf3((int)mul_result_4,(int)((ulonglong)mul_result_4 >> 0x20),result_2,mul_result_2);\n    result_2 = (undefined4)((ulonglong)mul_result_4 >> 0x20);\n    if (switch_case_value == -1) {\n      mul_result_3 = __aeabi_dadd((int)mul_result_3,result_1,(int)mul_result_4,result_2);\n      mul_result_3 = __muldf3((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),int_value,mul_uint_result);\n      add_result = (double)__subdf3(int_value,mul_uint_result,(int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20));\n      return add_result;\n    }\n    mul_result_3 = __aeabi_dadd((int)mul_result_3,result_1,(int)mul_result_4,result_2);\n    ptr = PTR_calculate_polynomial_0800af78hi_0800b2b0;\n    mul_result_3 = __muldf3((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),int_value,mul_uint_result);\n    mul_result_3 = __subdf3((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),\n                     *(undefined4 *)(PTR_calculate_polynomial_0800af78lo_0800b2b4 + switch_case_value * 8),\n                     *(undefined4 *)((int)(PTR_calculate_polynomial_0800af78lo_0800b2b4 + switch_case_value * 8) + 4));\n    mul_result_3 = __subdf3((int)mul_result_3,(int)((ulonglong)mul_result_3 >> 0x20),int_value,mul_uint_result);\n    output_value = (double)__subdf3(*(undefined4 *)(ptr + switch_case_value * 8),\n                             *(undefined4 *)((int)(ptr + switch_case_value * 8) + 4),(int)mul_result_3,\n                             (int)((ulonglong)mul_result_3 >> 0x20));\n    if ((int)uint_value < 0) {\n      return output_value;\n    }\n  }\n  return output_value;\n}\n\n",
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dadd",
                "__muldf3",
                "fabs",
                "__subdf3",
                "__divdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800af78",
            "calling": [
                "__ieee754_atan2"
            ],
            "imported": false,
            "current_name": "calculate_polynomial_0800af78"
        },
        "FUN_08005b20": {
            "renaming": {
                "FUN_08005b20": "clear_least_significant_bit_of_uint_pointer_08005b20",
                "DAT_08005b38": "PTR_DAT_08005b38",
                "uint": "unsigned_int",
                "uint_pointer": "unsigned_int_pointer"
            },
            "code": "void clear_least_significant_bit_of_uint_pointer_08005b20(void)\n{\n  uint* uint_pointer = (uint *)(DAT_08005b38 + 4);\n  *uint_pointer = *uint_pointer & 0xfffffffe;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b20",
            "calling": [],
            "imported": false,
            "current_name": "clear_least_significant_bit_of_uint_pointer_08005b20"
        },
        "FUN_08007d08": {
            "renaming": {
                "FUN_08007d08": "initialize_timer_08007d08",
                "pTVar1": "timer",
                "TIMx": "TIMER_INSTANCE",
                "DAT_08007d9c": "TIMER_INSTANCE",
                "DAT_08007da4": "TIM_PRESCALER_DIV",
                "PTR_SystemCoreClock_08007da0": "SYSTEM_CORE_CLOCK",
                "uint": "uint32_t",
                "ulonglong": "uint64_t",
                "enable_tim_clock": "enable_timer_clock",
                "0x80": "TIM_COUNTER_ENABLE",
                "0x6800": "TIM_CCMR1_OC1_PWM_MODE",
                "199": "TIM_ARR_VALUE",
                "100": "TIM_CCR2_VALUE"
            },
            "code": "void initialize_timer_08007d08(void)\n{\n  TIM_TypeDef *timer;\n  uint32_t prescaler_value = (uint32_t)TIM_CLOCK_FREQ * (uint32_t)PTR_SystemCoreClock_08007da0 / DAT_08007da4 - 1;\n  timer = DAT_08007d9c;\n  enable_tim_clock(timer);\n  timer->CR1 = TIM_COUNTER_ENABLE;\n  timer->CR2 = 0;\n  timer->SMCR = 0;\n  timer->DIER = 0;\n  timer->SR = 0;\n  timer->CCMR1 = TIM_CCMR1_OC1_PWM_MODE;\n  timer->CCMR2 = 0;\n  timer->CCER = 0;\n  timer->CNT = 0;\n  timer->PSC = prescaler_value;\n  timer->ARR = TIM_ARR_VALUE;\n  timer->CCR1 = 0;\n  timer->CCR2 = TIM_CCR2_VALUE;\n  timer->CCR3 = 0;\n  timer->CCR4 = 0;\n  timer->DCR = 0;\n  timer->DMAR = 0;\n  timer->EGR = 1;\n  return;\n}\n",
            "called": [
                "enable_tim_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007d08",
            "calling": [
                "timers_init"
            ],
            "imported": false,
            "current_name": "initialize_timer_08007d08"
        },
        "FUN_080091fc": {
            "renaming": {
                "FUN_080091fc": "compare_floats_080091fc",
                "param_1": "first_float",
                "param_2": "second_float"
            },
            "code": "void compare_floats_080091fc(float first_float, float second_float)\n{\n  __aeabi_cfcmpeq(second_float, first_float);\n  return;\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091fc",
            "calling": [
                "__aeabi_fcmpge",
                "__aeabi_fcmpgt"
            ],
            "imported": false,
            "current_name": "compare_floats_080091fc"
        },
        "FUN_080058a0": {
            "renaming": {
                "FUN_080058a0": "initialize_plan_cycle_if_current_block_exists_080058a0",
                "PTR_current_block_080058f0": "current_block_ptr",
                "PTR_sys_080058fc": "sys_ptr",
                "PTR_st_080058f4": "st_ptr",
                "DAT_080058f8": "sys_data"
            },
            "code": "void initialize_plan_cycle_if_current_block_exists_080058a0(void)\n{\n    if (*PTR_current_block_080058f0 == 0) {\n        PTR_sys_080058fc[1] = 0;\n    }\n    else {\n        int current_block_offset = *(int *)(*PTR_current_block_080058f0 + 0x10);\n        int st_offset = *(int *)(PTR_st_080058f4 + 0x10);\n        plan_cycle_reinitialize(current_block_offset - st_offset);\n        *(uint32_t *)(PTR_st_080058f4 + 0x1c) = 0;\n        set_step_events_per_minute(*(uint32_t *)(PTR_st_080058f4 + 0x1c));\n        *(uint32_t *)(PTR_st_080058f4 + 0x18) = DAT_080058f8;\n        *(uint32_t *)(PTR_st_080058f4 + 0x10) = 0;\n        PTR_sys_080058fc[1] = 2;\n    }\n}",
            "called": [
                "plan_cycle_reinitialize",
                "set_step_events_per_minute"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058a0",
            "calling": [
                "protocol_execute_runtime"
            ],
            "imported": false,
            "current_name": "initialize_plan_cycle_if_current_block_exists_080058a0"
        },
        "FUN_08008a6c": {
            "renaming": {
                "FUN_08008a6c": "CheckParams_08008a6c",
                "param_1": "a",
                "param_2": "b",
                "param_3": "c",
                "param_4": "d",
                "uVar1": "xor_bd",
                "bVar2": "is_a_zero",
                "bVar3": "is_bd_negative"
            },
            "code": "uint CheckParams_08008a6c(uint a, uint b, uint c, uint d)\n{\n    bool is_a_zero = (a | (b << 1)) == 0;\n    bool is_c_zero = (c | (d << 1)) == 0;\n    bool are_b_and_d_equal = b == d;\n    bool are_a_and_c_equal = a == c;\n    if ((int)(b << 1) >> 0x15 == -1 || (int)(d << 1) >> 0x15 == -1)\n    {\n        if (((int)(b << 1) >> 0x15 == -1 && !is_a_zero) || ((int)(d << 1) >> 0x15 == -1 && !is_c_zero))\n        {\n            return 1;\n        }\n    }\n    else if (!is_a_zero && !is_c_zero && !are_b_and_d_equal && !are_a_and_c_equal)\n    {\n        uint xor_bd = b ^ d;\n        bool is_bd_zero = xor_bd == 0;\n        bool is_bd_negative = -1 < (int)xor_bd;\n        if (is_bd_zero || (is_bd_negative && d <= b))\n        {\n            return (int)d >> 0x1f | 1;\n        }\n    }\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a6c",
            "calling": [],
            "imported": false,
            "current_name": "CheckParams_08008a6c"
        },
        "FUN_080036c6": {
            "renaming": {
                "FUN_080036c6": "print_string_080036c6",
                "s": "string_to_print",
                "local_c": "string_pointer"
            },
            "code": "void print_string_080036c6(char *string_to_print)\n{\n  uint8_t *string_pointer;\n  string_pointer = (uint8_t *)string_to_print;\n  while (*string_pointer != '\\0') {\n    serial_write(*string_pointer);\n    string_pointer++;\n  }\n  return;\n}",
            "called": [
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036c6",
            "calling": [
                "report_feedback_message",
                "report_init_message",
                "report_alarm_message",
                "report_grbl_help",
                "report_realtime_status",
                "report_gcode_parameters",
                "report_status_message",
                "report_grbl_settings",
                "report_startup_line",
                "report_gcode_modes"
            ],
            "imported": false,
            "current_name": "print_string_080036c6"
        },
        "FUN_08008190": {
            "renaming": {
                "FUN_08008190": "initialize_USART_08008190",
                "usart_00": "usartPtr",
                "DAT_08008240": "usart1",
                "val": "val",
                "usart": "usart",
                "enable_usart_clock": "enable_usart_clock",
                "set_baud_rate": "set_baud_rate",
                "CR1": "CR1",
                "CR2": "CR2",
                "CR3": "CR3",
                "SR": "SR",
                "GTPR": "GTPR"
            },
            "code": "void initialize_USART_08008190(void)\n{\n  USART_TypeDef *usartPtr;\n  uint32_t val;\n  USART_TypeDef *usart;\n  usartPtr = DAT_08008240;\n  enable_usart_clock(usartPtr);\n  usartPtr->CR1 &= ~(1 << 13);\n  usartPtr->CR1 = (usartPtr->CR1 & 0xffff400c) | 0xc;\n  usartPtr->CR2 &= ~(1 << 11);\n  usartPtr->CR3 &= ~(0x1f << 12);\n  usartPtr->SR &= ~(0x3ff);\n  set_baud_rate(usartPtr,0x1c200);\n  usartPtr->GTPR = usartPtr->GTPR;\n  usartPtr->CR1 |= (1 << 13);\n  return;\n}",
            "called": [
                "enable_usart_clock",
                "set_baud_rate"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008190",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_USART_08008190"
        },
        "FUN_080074c8": {
            "renaming": {
                "FUN_080074c8": "check_and_handle_input_080074c8",
                "bits": "input_bits",
                "limits_isr": "handle_limits_isr",
                "buttons_isr": "handle_buttons_isr"
            },
            "code": "void check_and_handle_input_080074c8(uint32_t input_bits)\n{\n  if ((input_bits & 1) != 0) {\n    gpio_set(0x3e);\n  }\n  if ((*(int *)PTR_limits_enabled_08007518 != 0) && ((input_bits & 0x1e) != 0)) {\n    handle_limits_isr();\n  }\n  if ((*(int *)PTR_buttons_enabled_0800751c != 0) && ((input_bits & 0x80) != 0)) {\n    handle_buttons_isr(input_bits);\n  }\n  return;\n}",
            "called": [
                "buttons_isr",
                "limits_isr",
                "gpio_set"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080074c8",
            "calling": [
                "debounce_isr"
            ],
            "imported": false,
            "current_name": "check_and_handle_input_080074c8"
        },
        "FUN_0800b430": {
            "renaming": {
                "FUN_0800b430": "memset_custom_0800b430",
                "__s": "dest",
                "__c": "value",
                "__n": "num",
                "uVar1": "value_uint",
                "puVar2": "dest_uint",
                "puVar3": "dest_aligned",
                "puVar4": "dest_next",
                "uVar5": "remaining",
                "bVar6": "end"
            },
            "code": "void * memset_custom_0800b430(void *dest, int value, size_t num)\n{\n    uint *dest_uint = (uint *)dest;\n    if (((uint)dest & 3) != 0) {\n        size_t remaining = num - 1;\n        uint *dest_aligned = (uint *)dest;\n        if (num == 0) {\n            return dest;\n        }\n        while (true) {\n            dest_uint = (uint *)((int)dest_aligned + 1);\n            *(char *)dest_aligned = (char)value;\n            num = remaining;\n            if (((uint)dest_uint & 3) == 0) break;\n            bool end = remaining == 0;\n            remaining = remaining - 1;\n            dest_aligned = dest_uint;\n            if (end) {\n                return dest;\n            }\n        }\n    }\n    if (3 < num) {\n        uint value_uint = value & 0xffU | (value & 0xffU) << 8;\n        value_uint = value_uint | value_uint << 0x10;\n        if (0xf < num) {\n            uint *dest_aligned = dest_uint + 4;\n            do {\n                dest_aligned[-4] = value_uint;\n                dest_aligned[-3] = value_uint;\n                dest_aligned[-2] = value_uint;\n                dest_aligned[-1] = value_uint;\n                dest_aligned = dest_aligned + 4;\n            } while (dest_aligned != (uint *)((int)dest_uint + (num - 0x10 & 0xfffffff0) + 0x20));\n            size_t remaining = num & 0xc;\n            dest_uint = dest_uint + ((num - 0x10 >> 4) + 1) * 4;\n            num = num & 0xf;\n            if (remaining == 0) {\n                goto end;\n            }\n        }\n        uint *dest_aligned = (uint *)((num - 4 & 0xfffffffc) + 4 + (int)dest_uint);\n        do {\n            uint *dest_next = dest_uint + 1;\n            *dest_uint = value_uint;\n            dest_uint = dest_next;\n        } while (dest_aligned != dest_next);\n        num = num & 3;\n        dest_uint = dest_aligned;\n    }\nend:\n    if (num != 0) {\n        uint *dest_aligned = dest_uint;\n        do {\n            uint *dest_next = (uint *)((int)dest_aligned + 1);\n            *(char *)dest_aligned = (char)value;\n            dest_aligned = dest_next;\n        } while ((uint *)(num + (int)dest_uint) != dest_next);\n    }\n    return dest;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b430",
            "calling": [
                "settings_read_coord_data",
                "homing_cycle",
                "mc_go_home",
                "gc_init",
                "grbl_main",
                "eeprom_init",
                "debounce_init",
                "plan_init",
                "gc_execute_line",
                "st_reset"
            ],
            "imported": false,
            "current_name": "memset_custom_0800b430"
        },
        "FUN_08004030": {
            "renaming": {
                "FUN_08004030": "printErrorMessage_08004030",
                "status_code": "errorCode",
                "PTR__etext_08004108": "errorMessage_Unknown",
                "PTR_s_error__0800410c": "errorMessage_Generic",
                "PTR_s_Bad_number_format_08004110": "errorMessage_BadNumberFormat",
                "PTR_s_Expected_command_letter_08004114": "errorMessage_ExpectedCommandLetter",
                "PTR_s_Unsupported_statement_08004118": "errorMessage_UnsupportedStatement",
                "PTR_s_Invalid_radius_0800411c": "errorMessage_InvalidRadius",
                "PTR_s_Modal_group_violation_08004120": "errorMessage_ModalGroupViolation",
                "PTR_s_Invalid_statement_08004124": "errorMessage_InvalidStatement",
                "PTR_s_Setting_disabled_08004128": "errorMessage_SettingDisabled",
                "PTR_s_Value___0_0_0800412c": "errorMessage_Value0_0",
                "PTR_s_Value___3_usec_08004130": "errorMessage_Value3_usec",
                "PTR_s_EEPROM_read_fail__Using_defaults_08004134": "errorMessage_EEPROMReadFail",
                "PTR_s_Busy_or_queued_08004138": "errorMessage_BusyOrQueued",
                "PTR_s_Alarm_lock_0800413c": "errorMessage_AlarmLock",
                "PTR_s_Line_overflow_08004140": "errorMessage_LineOverflow",
                "PTR_DAT_08004144": "errorMessage_End"
            },
            "code": "void printErrorMessage_08004030(uint8_t errorCode)\n{\n    if (errorCode == '\\0') {\n        printPgmString(PTR__etext_08004108);\n    }\n    else {\n        printPgmString(PTR_s_error__0800410c);\n        switch(errorCode) {\n            case errorCode_BadNumberFormat:\n                printPgmString(PTR_s_Bad_number_format_08004110);\n                break;\n            case errorCode_ExpectedCommandLetter:\n                printPgmString(PTR_s_Expected_command_letter_08004114);\n                break;\n            case errorCode_UnsupportedStatement:\n                printPgmString(PTR_s_Unsupported_statement_08004118);\n                break;\n            case errorCode_InvalidRadius:\n                printPgmString(PTR_s_Invalid_radius_0800411c);\n                break;\n            case errorCode_ModalGroupViolation:\n                printPgmString(PTR_s_Modal_group_violation_08004120);\n                break;\n            case errorCode_InvalidStatement:\n                printPgmString(PTR_s_Invalid_statement_08004124);\n                break;\n            case errorCode_SettingDisabled:\n                printPgmString(PTR_s_Setting_disabled_08004128);\n                break;\n            case errorCode_Value0_0:\n                printPgmString(PTR_s_Value___0_0_0800412c);\n                break;\n            case errorCode_Value3_usec:\n                printPgmString(PTR_s_Value___3_usec_08004130);\n                break;\n            case errorCode_EEPROMReadFail:\n                printPgmString(PTR_s_EEPROM_read_fail__Using_defaults_08004134);\n                break;\n            case errorCode_BusyOrQueued:\n                printPgmString(PTR_s_Busy_or_queued_08004138);\n                break;\n            case errorCode_AlarmLock:\n                printPgmString(PTR_s_Alarm_lock_0800413c);\n                break;\n            case errorCode_LineOverflow:\n                printPgmString(PTR_s_Line_overflow_08004140);\n        }\n        printPgmString(PTR_DAT_08004144);\n    }\n}",
            "called": [
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004030",
            "calling": [
                "protocol_execute_line",
                "gc_init",
                "report_gcode_parameters",
                "protocol_execute_startup",
                "protocol_process",
                "settings_init"
            ],
            "imported": false,
            "current_name": "printErrorMessage_08004030"
        },
        "FUN_08005360": {
            "renaming": {
                "FUN_08005360": "calculate_result_08005360",
                "DAT_0800539c": "previous_constant",
                "PTR_st_08005398": "memory_address",
                "previous_sum": "previous_sum",
                "current_sum": "current_sum",
                "previous_value": "previous_constant",
                "current_value": "current_value"
            },
            "code": "int calculate_result_08005360(void)\n{\n  int sum = previous_sum + current_sum;\n  uint previous_value = DAT_0800539c;\n  uint current_value = *(uint *)(PTR_st_08005398 + 0x18);\n  if (DAT_0800539c < current_value) {\n    sum -= 420000;\n  }\n  return (uint)(previous_value < current_value);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005360",
            "calling": [
                "step_period_isr"
            ],
            "imported": false,
            "current_name": "calculate_result_08005360"
        },
        "FUN_08003980": {
            "renaming": {
                "FUN_08003980": "initialize_counters_08003980",
                "PTR_char_counter_08003998": "char_counter",
                "PTR_iscomment_0800399c": "is_comment"
            },
            "code": "void initialize_counters_08003980(void)\n{\n  *PTR_char_counter_08003998 = 0;\n  *PTR_iscomment_0800399c = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003980",
            "calling": [
                "protocol_init",
                "protocol_process"
            ],
            "imported": false,
            "current_name": "initialize_counters_08003980"
        },
        "FUN_08006de0": {
            "renaming": {
                "FUN_08006de0": "get_pending_interrupt_08006de0",
                "IRQn": "interrupt",
                "uVar1": "pending_interrupt"
            },
            "code": "uint32_t get_pending_interrupt_08006de0(IRQn_Type interrupt)\n{\n  uint32_t pending_interrupt = NVIC_GetPendingIRQ(interrupt);\n  return pending_interrupt;\n}",
            "called": [
                "NVIC_GetPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006de0",
            "calling": [],
            "imported": false,
            "current_name": "get_pending_interrupt_08006de0"
        },
        "FUN_08007540": {
            "renaming": {
                "synchronize_08007540": "synchronize_system",
                "HAL_Init": "initialize_HAL",
                "SystemClock_Config": "configure_SystemClock",
                "gpio_init": "initialize_gpio",
                "timers_init": "initialize_timers",
                "debounce_init": "initialize_debounce",
                "usart_init": "initialize_usart",
                "startForkserver": "start_forkserver",
                "grbl_synchronize_08007540": "synchronize_grbl_system",
                "FUN_08007540": "synchronize_system_08007540"
            },
            "code": "int synchronize_system_08007540() {\n  initialize_HAL();\n  configure_SystemClock();\n  initialize_gpio();\n  initialize_timers();\n  initialize_debounce();\n  initialize_usart();\n  start_forkserver(0);\n  synchronize_grbl_system();\n  return 0;\n}",
            "called": [
                "grbl_main",
                "timers_init",
                "gpio_init",
                "HAL_Init",
                "debounce_init",
                "SystemClock_Config",
                "startForkserver",
                "usart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007540",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "synchronize_system_08007540"
        },
        "FUN_080052dc": {
            "renaming": {
                "FUN_080052dc": "update_value_080052dc",
                "x": "new_value",
                "val": "current_value",
                "PTR_DAT_08005308": "data_pointer",
                "DAT_08005308": "data_offset"
            },
            "code": "void update_value_080052dc(uint32_t new_value)\n{\n  uint32_t current_value;\n  uint32_t mask = 0xfffff55f;\n\n  current_value = *(uint32_t *)(DAT_08005308 + 0x14);\n  *(uint32_t *)(DAT_08005308 + 0x14) = (new_value | (current_value & mask));\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052dc",
            "calling": [
                "step_period_isr"
            ],
            "imported": false,
            "current_name": "update_value_080052dc"
        },
        "FUN_080064ec": {
            "renaming": {
                "FUN_080064ec": "calculate_pll_frequency_080064ec",
                "pllp": "pllp",
                "pllm": "pllm",
                "sysclockfreq": "sysclockfreq",
                "pllvco": "pllvco",
                "uVar1": "config_value_1",
                "uVar2": "divisor",
                "result_6": "result_6",
                "result_7": "result_7",
                "result_4": "result_4",
                "result_5": "result_5",
                "result_2": "result_2",
                "result_3": "result_3",
                "result": "result",
                "result_1": "result_1",
                "DAT_0800661c": "pll_config_address",
                "DAT_08006620": "default_pll_frequency_1",
                "DAT_08006624": "default_pll_frequency_2"
            },
            "code": "uint32_t calculate_pll_frequency_080064ec(void)\n{\n  uint32_t pllp;\n  uint32_t pllm;\n  uint32_t sysclockfreq;\n  uint32_t pllvco;\n  \n  uint32_t pll_config_1 = *(uint *)(DAT_0800661c + 8);\n  uint32_t pll_config_2 = *(uint *)(DAT_0800661c + 4);\n  \n  if ((pll_config_1 & 0xc) == 8) {\n    uint32_t div = pll_config_2 & 0x3f;\n    uint32_t shift_amount = count_leading_zeroes(0x200);\n    \n    if ((pll_config_2 & 0x400000) >> (shift_amount & 0xff) == 0) {\n      shift_amount = count_leading_zeroes(0x3fe0000);\n      pllvco = ((pll_config_2 & 0x7fc0) >> (shift_amount & 0xff)) * (DAT_08006620 / div);\n    }\n    else {\n      shift_amount = count_leading_zeroes(0x3fe0000);\n      pllvco = ((pll_config_2 & 0x7fc0) >> (shift_amount & 0xff)) * (DAT_08006624 / div);\n    }\n    shift_amount = count_leading_zeroes(0xc000);\n    return pllvco / (((pll_config_2 & 0x30000) >> (shift_amount & 0xff)) + 1) * 2;\n  }\n  else if (pll_config_1 < 9) {\n    if (pll_config_1 == 0) {\n      return DAT_08006620;\n    }\n    else if (pll_config_1 == 4) {\n      return DAT_08006624;\n    }\n  }\n  return DAT_08006620;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064ec",
            "calling": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "imported": false,
            "current_name": "calculate_pll_frequency_080064ec"
        },
        "FUN_08006ba0": {
            "renaming": {
                "FUN_08006ba0": "calculate_priority_08006ba0",
                "PriorityGroup": "priority_group",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "SubPriorityBits": "sub_priority_bits",
                "PreemptPriorityBits": "preempt_priority_bits",
                "PriorityGroupTmp": "priority_group_tmp",
                "uVar1": "priority_group_value",
                "uVar2": "priority_group_bits"
            },
            "code": "uint32_t calculate_priority_08006ba0(uint32_t priority_group, uint32_t preempt_priority, uint32_t sub_priority) {\n  uint32_t sub_priority_bits;\n  uint32_t preempt_priority_bits;\n  uint32_t priority_group_tmp;\n  uint32_t priority_group_mask = 7;\n  uint32_t priority_group_offset = 3;\n  uint32_t preempt_priority_offset = 4;\n  uint32_t priority_group_value = priority_group & priority_group_mask;\n  uint32_t priority_group_bits = priority_group_mask - priority_group_value;\n  if (priority_group_bits > 3) {\n    priority_group_bits = priority_group_offset;\n  }\n  if (priority_group_value + preempt_priority_offset < priority_group_mask) {\n    priority_group_value = 0;\n  }\n  else {\n    priority_group_value -= priority_group_offset;\n  }\n  return sub_priority & ((1 << (priority_group_value & 0xff)) - 1U) | ((1 << (priority_group_bits & 0xff)) - 1U & preempt_priority) << (priority_group_value & 0xff);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ba0",
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "imported": false,
            "current_name": "calculate_priority_08006ba0"
        },
        "FUN_080003ec": {
            "renaming": {
                "FUN_080003ec": "read_data_from_eeprom_080003ec",
                "destination": "destination_buffer",
                "source": "source_address",
                "size": "data_size",
                "cVar1": "current_char",
                "local_1c": "remaining_size",
                "local_18": "current_address",
                "local_14": "current_destination",
                "data": "data",
                "checksum": "checksum"
            },
            "code": "int read_data_from_eeprom_080003ec(char *destination, uint source_address, uint size) {\\n  char current_char;\\n  uint remaining_size;\\n  uint current_address;\\n  char *current_destination;\\n  uchar data;\\n  uchar checksum;\\n  checksum = \"\\0\";\\n  remaining_size = size;\\n  current_address = source_address;\\n  current_destination = destination;\\n  if (*(int *)PTR_eeprom_ready_08000470 == 0) {\\n    eeprom_init();\\n    current_address = source_address;\\n    current_destination = destination;\\n  }\\n  for (; remaining_size != 0; remaining_size = remaining_size - 1) {\\n    current_char = eeprom_get_char(current_address);\\n    checksum = current_char + (checksum != \"\\0\");\\n    *current_destination = current_char;\\n    current_address = current_address + 1;\\n    current_destination = current_destination + 1;\\n  }\\n  current_char = eeprom_get_char(current_address);\\n  return (uint)((uint)checksum == (int)current_char);\\n}",
            "called": [
                "eeprom_get_char",
                "eeprom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080003ec",
            "calling": [
                "settings_read_coord_data",
                "read_global_settings",
                "settings_read_startup_line"
            ],
            "imported": false,
            "current_name": "read_data_from_eeprom_080003ec"
        },
        "FUN_08002896": {
            "renaming": {
                "FUN_08002896": "get_block_index_08002896",
                "block_index": "block_num",
                "local_9": "new_block_num"
            },
            "code": "uint8_t get_block_index_08002896(uint8_t block_num) {\\n  uint8_t new_block_num;\\n  if (block_num == \"\\0\") {\\n    new_block_num = \"\\x12\";\\n  }\\n  else {\\n    new_block_num = block_num;\\n  }\\n  return new_block_num + 0xff;\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002896",
            "calling": [
                "planner_reverse_pass"
            ],
            "imported": false,
            "current_name": "get_block_index_08002896"
        },
        "FUN_0800a348": {
            "renaming": {
                "FUN_0800a348": "calculate_distance_0800a348",
                "param_1": "x1",
                "param_2": "y1",
                "param_3": "x2",
                "param_4": "y2",
                "uVar2": "high_bits",
                "uVar3": "low_bits",
                "uVar4": "absolute_value_y1",
                "uVar5": "product_1",
                "uVar6": "product_2",
                "uVar7": "product_3",
                "local_30": "result_high_bits",
                "uStack_2c": "result_low_bits"
            },
            "code": "\nundefined4 calculate_distance_0800a348(undefined4 x1,uint y1,undefined4 x2,undefined4 y2)\n\n{\n  int iVar1;\n  undefined4 high_bits;\n  undefined4 low_bits;\n  uint absolute_value_y1;\n  undefined8 product_1;\n  undefined8 product_2;\n  undefined8 product_3;\n  longlong lVar8;\n  undefined4 result_high_bits;\n  undefined4 result_low_bits;\n  undefined4 local_28;\n  undefined4 uStack_24;\n  \n  absolute_value_y1 = y1 & 0x7fffffff;\n  if (absolute_value_y1 < 0x3e400000) {\n    iVar1 = __aeabi_d2iz();\n    if (iVar1 == 0) {\n      return 0;\n    }\n    product_1 = __muldf3(x1,y1,x1,y1);\n    low_bits = (undefined4)((ulonglong)product_1 >> 0x20);\n    high_bits = (undefined4)product_1;\n    product_2 = __muldf3(high_bits,low_bits,DAT_0800a558,DAT_0800a55c);\n    product_2 = __aeabi_dadd((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a560,DAT_0800a564);\n    product_2 = __muldf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),high_bits,low_bits);\n    product_2 = __subdf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a568,DAT_0800a56c);\n    product_2 = __muldf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),high_bits,low_bits);\n    product_2 = __aeabi_dadd((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a570,DAT_0800a574);\n    product_2 = __muldf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),high_bits,low_bits);\n    product_2 = __subdf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a578,DAT_0800a57c);\n    product_2 = __muldf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),high_bits,low_bits);\n    product_2 = __aeabi_dadd((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a580,DAT_0800a584);\n    product_2 = __muldf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),high_bits,low_bits);\n  }\n  else {\n    product_1 = __muldf3(x1,y1,x1,y1);\n    low_bits = (undefined4)((ulonglong)product_1 >> 0x20);\n    high_bits = (undefined4)product_1;\n    product_2 = __muldf3(high_bits,low_bits,DAT_0800a558,DAT_0800a55c);\n    product_2 = __aeabi_dadd((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a560,DAT_0800a564);\n    product_2 = __muldf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),high_bits,low_bits);\n    product_2 = __subdf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a568,DAT_0800a56c);\n    product_2 = __muldf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),high_bits,low_bits);\n    product_2 = __aeabi_dadd((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a570,DAT_0800a574);\n    product_2 = __muldf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),high_bits,low_bits);\n    product_2 = __subdf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a578,DAT_0800a57c);\n    product_2 = __muldf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),high_bits,low_bits);\n    product_2 = __aeabi_dadd((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a580,DAT_0800a584);\n    product_2 = __muldf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),high_bits,low_bits);\n    if (DAT_0800a590 < (int)absolute_value_y1) {\n      if (DAT_0800a594 < (int)absolute_value_y1) {\n        lVar8 = (ulonglong)DAT_0800a598 << 0x20;\n        iVar1 = DAT_0800a59c;\n      }\n      else {\n        lVar8 = __subdf3(0,DAT_0800a58c,0,absolute_value_y1 - 0x200000);\n        iVar1 = absolute_value_y1 - 0x200000;\n      }\n      uStack_24 = (undefined4)((ulonglong)lVar8 >> 0x20);\n      local_28 = (undefined4)lVar8;\n      product_1 = __muldf3(high_bits,low_bits,0,DAT_0800a588);\n      product_1 = __subdf3((int)product_1,(int)((ulonglong)product_1 >> 0x20),0,iVar1);\n      product_2 = __muldf3(high_bits,low_bits,(int)product_2,(int)((ulonglong)product_2 >> 0x20));\n      product_3 = __muldf3(x1,y1,x2,y2);\n      product_2 = __subdf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),(int)product_3,\n                       (int)((ulonglong)product_3 >> 0x20));\n      product_1 = __subdf3((int)product_1,(int)((ulonglong)product_1 >> 0x20),(int)product_2,\n                       (int)((ulonglong)product_2 >> 0x20));\n      high_bits = __subdf3(local_28,uStack_24,(int)product_1,(int)((ulonglong)product_1 >> 0x20));\n      return high_bits;\n    }\n  }\n  result_low_bits = (undefined4)((ulonglong)product_2 >> 0x20);\n  result_high_bits = (undefined4)product_2;\n  high_bits = (undefined4)((ulonglong)product_1 >> 0x20);\n  product_2 = __muldf3((int)product_1,high_bits,0,DAT_0800a588);\n  product_1 = __muldf3((int)product_1,high_bits,result_high_bits,result_low_bits);\n  product_3 = __muldf3(x1,y1,x2,y2);\n  product_1 = __subdf3((int)product_1,(int)((ulonglong)product_1 >> 0x20),(int)product_3,\n                   (int)((ulonglong)product_3 >> 0x20));\n  product_1 = __subdf3((int)product_2,(int)((ulonglong)product_2 >> 0x20),(int)product_1,\n                   (int)((ulonglong)product_1 >> 0x20));\n  high_bits = __subdf3(0,DAT_0800a58c,(int)product_1,(int)((ulonglong)product_1 >> 0x20));\n  return high_bits;\n}\n\n",
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__aeabi_d2iz",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a348",
            "calling": [
                "sin",
                "cos"
            ],
            "imported": false,
            "current_name": "calculate_distance_0800a348"
        },
        "FUN_080001ac": {
            "renaming": {
                "FUN_080001ac": "concatenate_080001ac",
                "*param_1": "param1",
                "*param_2": "param2",
                "DAT_080001bc": "DAT_initialized",
                "PTR__init_080001c4": "PTR_init",
                "PTR_object_8916_080001c0": "PTR_object"
            },
            "code": "typedef unsigned long long uint64_t;\n\nuint64_t concatenate_080001ac(uint64_t param1, uint64_t param2) {\n  if (DAT_080001bc) {\n    param1 = PTR__init_080001c4;\n    param2 = PTR_object_8916_080001c0;\n  }\n  return ((uint64_t)param2 << 32) | param1;\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001ac",
            "calling": [
                "__libc_init_array",
                "__libc_fini_array"
            ],
            "imported": false,
            "current_name": "concatenate_080001ac"
        },
        "FUN_08003740": {
            "renaming": {
                "FUN_08003740": "print_binary_08003740",
                "n": "number"
            },
            "code": "void print_binary_08003740(uint8_t number){\n  print_base2((uint)number, 8);\n  return;\n}",
            "called": [
                "print_base2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003740",
            "calling": [],
            "imported": false,
            "current_name": "print_binary_08003740"
        },
        "FUN_08000478": {
            "renaming": {
                "FUN_08000478": "set_axis_values_08000478",
                "axis_0": "x_axis",
                "axis_1": "y_axis",
                "axis_2": "z_axis"
            },
            "code": "void set_axis_values_08000478(uint8_t x_axis, uint8_t y_axis, uint8_t z_axis) {\n  PTR_gc_080004a8[0x19] = x_axis;\n  PTR_gc_080004a8[0x1a] = y_axis;\n  PTR_gc_080004a8[0x1b] = z_axis;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000478",
            "calling": [
                "gc_init",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "set_axis_values_08000478"
        },
        "FUN_08006d2e": {
            "renaming": {
                "FUN_08006d2e": "enable_interrupt_08006d2e",
                "IRQn": "interrupt"
            },
            "code": "void enable_interrupt_08006d2e(IRQn_Type interrupt)\n{\n    NVIC_EnableIRQ(interrupt);\n    return;\n}",
            "called": [
                "NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d2e",
            "calling": [],
            "imported": false,
            "current_name": "enable_interrupt_08006d2e"
        },
        "FUN_08007e1c": {
            "renaming": {
                "FUN_08007e1c": "wait_until_usart_ready_and_send_char_08007e1c",
                "c": "character_to_send",
                "usart": "usart_register",
                "DAT_08007e48": "DAT_GPIOA_ODR"
            },
            "code": "void wait_until_usart_ready_and_send_char_08007e1c(char character_to_send)\n{\n  USART_TypeDef *usart_register = PTR_USART1;\n  \n  do {\n  } while ((*DAT_08007e48 & 0x80) == 0);\n  DAT_08007e48[1] = (uint)(byte)character_to_send;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e1c",
            "calling": [
                "__io_putchar",
                "serial_write"
            ],
            "imported": false,
            "current_name": "wait_until_usart_ready_and_send_char_08007e1c"
        },
        "FUN_0800adf0": {
            "renaming": {
                "FUN_0800adf0": "calculate_result_0800adf0",
                "param_1": "base",
                "param_2": "exponent",
                "param_3": "arg1",
                "param_4": "arg2",
                "param_5": "flag",
                "iVar1": "int_part",
                "uVar2": "result_low",
                "uVar3": "result_high",
                "uVar4": "temp_high",
                "uVar5": "temp_low",
                "uVar6": "temp_arg1",
                "uVar7": "temp_result",
                "uVar8": "temp_mul_result",
                "DAT_0800af40": "constant_1",
                "DAT_0800af44": "constant_2",
                "DAT_0800af48": "constant_3",
                "DAT_0800af4c": "constant_4",
                "DAT_0800af50": "constant_5",
                "DAT_0800af54": "constant_6",
                "DAT_0800af58": "constant_7",
                "DAT_0800af5c": "constant_8",
                "DAT_0800af60": "constant_9",
                "DAT_0800af64": "constant_10",
                "DAT_0800af68": "constant_11",
                "DAT_0800af6c": "constant_12",
                "DAT_0800af70": "constant_13"
            },
            "code": "undefined4 calculate_result_0800adf0(undefined4 base, uint exponent, undefined4 arg1, undefined4 arg2, int flag)\n{\n  int int_part;\n  undefined4 result_high;\n  undefined4 result_low;\n  undefined4 temp_high;\n  undefined4 temp_low;\n  undefined4 temp_arg1;\n  undefined4 temp_arg2;\n  undefined8 temp_result;\n  undefined8 temp_mul_result;\n  undefined8 temp_sub_result;\n  undefined8 temp_add_result;\n\n  if (((exponent & 0x7fffffff) < 0x3e400000) && (int_part = __aeabi_d2iz(), int_part == 0)) {\n    return base;\n  }\n  temp_result = __muldf3(base, exponent, base);\n  result_high = (undefined4)((ulonglong)temp_result >> 0x20);\n  result_low = (undefined4)temp_result;\n  temp_result = __muldf3(base, exponent, result_low, result_high);\n  temp_high = (undefined4)((ulonglong)temp_result >> 0x20);\n  temp_low = (undefined4)temp_result;\n  temp_result = __muldf3(result_low, result_high, DAT_0800af40, DAT_0800af44);\n  temp_result = __subdf3((int)temp_result, (int)((ulonglong)temp_result >> 0x20), DAT_0800af48, DAT_0800af4c);\n  temp_mul_result = __muldf3((int)temp_result, (int)((ulonglong)temp_result >> 0x20), result_low, result_high);\n  temp_add_result = __aeabi_dadd((int)temp_mul_result, (int)((ulonglong)temp_mul_result >> 0x20), DAT_0800af50, DAT_0800af54);\n  temp_mul_result = __muldf3((int)temp_add_result, (int)((ulonglong)temp_add_result >> 0x20), result_low, result_high);\n  temp_sub_result = __subdf3((int)temp_mul_result, (int)((ulonglong)temp_mul_result >> 0x20), DAT_0800af58, DAT_0800af5c);\n  temp_mul_result = __muldf3((int)temp_sub_result, (int)((ulonglong)temp_sub_result >> 0x20), result_low, result_high);\n  temp_add_result = __aeabi_dadd((int)temp_mul_result, (int)((ulonglong)temp_mul_result >> 0x20), DAT_0800af60, DAT_0800af64);\n  temp_arg1 = (undefined4)((ulonglong)temp_add_result >> 0x20);\n  if (flag != 0) {\n    temp_result = __muldf3(arg1, arg2, 0, DAT_0800af70);\n    temp_mul_result = __muldf3(temp_low, temp_high, (int)temp_add_result, temp_arg1);\n    temp_sub_result = __subdf3((int)temp_result, (int)((ulonglong)temp_result >> 0x20), (int)temp_mul_result, (int)((ulonglong)temp_mul_result >> 0x20));\n    temp_mul_result = __muldf3((int)temp_sub_result, (int)((ulonglong)temp_sub_result >> 0x20), result_low, result_high);\n    temp_sub_result = __subdf3((int)temp_mul_result, (int)((ulonglong)temp_mul_result >> 0x20), arg1, arg2);\n    temp_result = __muldf3(temp_low, temp_high, DAT_0800af68, DAT_0800af6c);\n    temp_add_result = __aeabi_dadd((int)temp_sub_result, (int)((ulonglong)temp_sub_result >> 0x20), (int)temp_result, (int)((ulonglong)temp_result >> 0x20));\n    temp_arg1 = __subdf3(base, exponent, (int)temp_add_result, (int)((ulonglong)temp_add_result >> 0x20));\n    return temp_arg1;\n  }\n  temp_mul_result = __muldf3(temp_low, temp_high, (int)temp_add_result, temp_arg1);\n  temp_sub_result = __subdf3((int)temp_mul_result, (int)((ulonglong)temp_mul_result >> 0x20), DAT_0800af68, DAT_0800af6c);\n  temp_mul_result = __muldf3((int)temp_sub_result, (int)((ulonglong)temp_sub_result >> 0x20), result_low, result_high);\n  temp_arg1 = __aeabi_dadd((int)temp_mul_result, (int)((ulonglong)temp_mul_result >> 0x20), base, exponent);\n  return temp_arg1;\n}",
            "called": [
                "__aeabi_dadd",
                "__muldf3",
                "__aeabi_d2iz",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800adf0",
            "calling": [
                "sin",
                "cos"
            ],
            "imported": false,
            "current_name": "calculate_result_0800adf0"
        },
        "FUN_08003a74": {
            "renaming": {
                "FUN_08003a74": "process_realtime_status_08003a74",
                "PTR_sys_08003b90": "sys_settings",
                "PTR_settings_08003b94": "sys_configuration",
                "bVar1": "status_byte",
                "rt_exec": "rt_exec"
            },
            "code": "void process_realtime_status_08003a74(void)\\n{\\n  byte status_byte;\\n  uint8_t rt_exec;\\n  \\n  if (PTR_sys_08003b90[2] != \"\\0\") {\\n    status_byte = PTR_sys_08003b90[2];\\n    if ((status_byte & 0x60) != 0) {\\n      PTR_sys_08003b90[1] = 6;\\n      if ((status_byte & 0x40) == 0) {\\n        report_alarm_message(-2);\\n      }\\n      else {\\n        report_alarm_message(-1);\\n        report_feedback_message(\"\\x01\");\\n        PTR_sys_08003b90[2] &= 0xef;\\n        do {\\n        } while ((PTR_sys_08003b90[2] & 0x10) == 0);\\n      }\\n      PTR_sys_08003b90[2] &= 0x9f;\\n    }\\n    if ((status_byte & 0x10) == 0) {\\n      if ((status_byte & 1) != 0) {\\n        report_realtime_status();\\n        PTR_sys_08003b90[2] &= 0xfe;\\n      }\\n      if ((status_byte & 8) != 0) {\\n        feed_hold();\\n        PTR_sys_08003b90[2] &= 0xf7;\\n      }\\n      if ((status_byte & 4) != 0) {\\n        cycle_reinitialize();\\n        PTR_sys_08003b90[2] &= 0xfb;\\n      }\\n      if ((status_byte & 2) != 0) {\\n        cycle_start();\\n        if ((PTR_sys_08003b90[0x28] & 2) != 0) {\\n          PTR_sys_08003b90[0x10] = 1;\\n        }\\n        PTR_sys_08003b90[2] &= 0xfd;\\n      }\\n    }\\n    else {\\n      *PTR_sys_08003b90 = 1;\\n    }\\n  }\\n  return;\\n}",
            "called": [
                "report_feedback_message",
                "st_feed_hold",
                "report_alarm_message",
                "report_realtime_status",
                "st_cycle_reinitialize",
                "st_cycle_start"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a74",
            "calling": [
                "plan_synchronize",
                "mc_go_home",
                "grbl_main",
                "mc_dwell",
                "mc_line",
                "protocol_process"
            ],
            "imported": false,
            "current_name": "process_realtime_status_08003a74"
        },
        "FUN_08005cec": {
            "renaming": {
                "FUN_08005cec": "configure_rcc_oscillator_08005cec",
                "RCC_OscInitStruct": "osc_init",
                "uVar1": "start_time",
                "uVar2": "current_time",
                "uVar3": "leading_zeroes_1",
                "uVar4": "leading_zeroes_2",
                "uVar5": "leading_zeroes_3",
                "result": "result_0",
                "HAL_GetTick": "get_tick"
            },
            "code": "\nHAL_StatusTypeDef configure_RCC_Oscillator_08005cec(RCC_OscInitTypeDef *osc_init)\n\n{\n  uint32_t start_time;\n  uint32_t current_time;\n  uint leading_zeroes_1;\n  uint leading_zeroes_2;\n  uint leading_zeroes_3;\n  uint32_t result_0_2;\n  uint32_t result_0_3;\n  uint32_t result_0_4;\n  uint32_t result_0_5;\n  uint32_t result_0_6;\n  uint32_t result_0_7;\n  uint32_t result_0;\n  uint32_t result_0_1;\n  uint32_t timeout;\n  \n  if ((osc_init->OscillatorType & 1) != 0) {\n    if (((DAT_08005fac[2] & 0xc) == 4) ||\n       (((DAT_08005fac[2] & 0xc) == 8 && ((DAT_08005fac[1] & 0x400000) == 0x400000)))) {\n      if (((*DAT_08005fac & 0x20000) != 0) && (osc_init->HSEState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      *DAT_08005fb0 = 0;\n      start_time = get_tick();\n      while ((*DAT_08005fac & 0x20000) != 0) {\n        current_time = get_tick();\n        if (start_time + 5000 <= current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_08005fb0 = (char)osc_init->HSEState;\n      if (osc_init->HSEState == 1) {\n        start_time = get_tick();\n        while ((*DAT_08005fac & 0x20000) == 0) {\n          current_time = get_tick();\n          if (start_time + 5000 <= current_time) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        start_time = get_tick();\n        while ((*DAT_08005fac & 0x20000) != 0) {\n          current_time = get_tick();\n          if (start_time + 5000 <= current_time) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((osc_init->OscillatorType & 2) != 0) {\n    if (((DAT_08005fac[2] & 0xc) == 0) ||\n       (((DAT_08005fac[2] & 0xc) == 8 && ((DAT_08005fac[1] & 0x400000) == 0)))) {\n      if (((*DAT_08005fac & 2) != 0) && (osc_init->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else if (osc_init->HSIState == 0) {\n      *DAT_08005fb4 = 0;\n      start_time = get_tick();\n      while ((*DAT_08005fac & 2) != 0) {\n        current_time = get_tick();\n        if (start_time + 100 <= current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005fb4 = 1;\n      start_time = get_tick();\n      while ((*DAT_08005fac & 2) == 0) {\n        current_time = get_tick();\n        if (start_time + 100 <= current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n      leading_zeroes_1 = count_leading_zeroes(0x1f000000);\n      *DAT_08005fac =\n           osc_init->HSICalibrationValue << (leading_zeroes_1 & 0xff) | *DAT_08005fac & 0xffffff07;\n    }\n  }\n  if ((osc_init->OscillatorType & 8) != 0) {\n    if (osc_init->LSIState == 0) {\n      *DAT_08005fb8 = 0;\n      start_time = get_tick();\n      while ((DAT_08005fac[0x1d] & 2) != 0) {\n        current_time = get_tick();\n        if (start_time + 100 <= current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005fb8 = 1;\n      start_time = get_tick();\n      while ((DAT_08005fac[0x1d] & 2) == 0) {\n        current_time = get_tick();\n        if (start_time + 100 <= current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((osc_init->OscillatorType & 4) != 0) {\n    DAT_08005fac[0x10] = DAT_08005fac[0x10] | 0x10000000;\n    *DAT_08005fbc = *DAT_08005fbc | 0x100;\n    start_time = get_tick();\n    while ((*DAT_08005fbc & 0x100) == 0) {\n      current_time = get_tick();\n      if (start_time + 100 <= current_time) {\n        return HAL_TIMEOUT;\n      }\n    }\n    *DAT_08005fc0 = 0;\n    start_time = get_tick();\n    while ((DAT_08006180[0x1c] & 2) != 0) {\n      current_time = get_tick();\n      if (start_time + 5000 <= current_time) {\n        return HAL_TIMEOUT;\n      }\n    }\n    *DAT_08006184 = (char)osc_init->LSEState;\n    if (osc_init->LSEState == 1) {\n      start_time = get_tick();\n      while ((DAT_08006180[0x1c] & 2) == 0) {\n        current_time = get_tick();\n        if (start_time + 5000 <= current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      start_time = get_tick();\n      while ((DAT_08006180[0x1c] & 2) != 0) {\n        current_time = get_tick();\n        if (start_time + 5000 <= current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((osc_init->PLL).PLLState != 0) {\n    if ((DAT_08006180[2] & 0xc) == 8) {\n      return HAL_ERROR;\n    }\n    if ((osc_init->PLL).PLLState == 2) {\n      *DAT_08006188 = 0;\n      start_time = get_tick();\n      while ((*DAT_08006180 & 0x2000000) != 0) {\n        current_time = get_tick();\n        if (start_time + 100 <= current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n      leading_zeroes_1 = count_leading_zeroes(0x3fe0000);\n      leading_zeroes_2 = count_leading_zeroes(0xc000);\n      leading_zeroes_3 = count_leading_zeroes(0xf0);\n      DAT_08006180[1] =\n           (osc_init->PLL).PLLQ << (leading_zeroes_3 & 0xff) |\n           (osc_init->PLL).PLLM | (osc_init->PLL).PLLN << (leading_zeroes_1 & 0xff) |\n           ((osc_init->PLL).PLLP >> 1) - 1 << (leading_zeroes_2 & 0xff) |\n           (osc_init->PLL).PLLSource | 0x20000000;\n      *DAT_08006188 = 1;\n      start_time = get_tick();\n      while ((*DAT_08006180 & 0x2000000) == 0) {\n        current_time = get_tick();\n        if (start_time + 100 <= current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08006188 = 0;\n      start_time = get_tick();\n      while ((*DAT_08006180 & 0x2000000) != 0) {\n        current_time = get_tick();\n        if (start_time + 100 <= current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cec",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configure_rcc_oscillator_08005cec"
        },
        "FUN_08006b00": {
            "renaming": {
                "FUN_08006b00": "setInterruptPriority_08006b00",
                "IRQn": "interruptNumber",
                "priority": "interruptPriority",
                "WWDG_IRQn": "WWDGInterruptNumber",
                "DAT_08006b4c": "PTR_DAT_08006b4c",
                "DAT_08006b50": "PTR_DAT_08006b50"
            },
            "code": "void setInterruptPriority_08006b00(IRQn_Type IRQn, uint32_t priority) {\n  if (IRQn < WWDG_IRQn) {\n    uint32_t regAddr = ((uint32_t)&NVIC->IPR[IRQn >> 2]) + ((IRQn & 0x03) << 3);\n    *(volatile uint8_t *)regAddr = (priority << 4) & 0xFF;\n  }\n  else {\n    *(volatile uint8_t *)((uint32_t)&NVIC->IPR[IRQn - 32] + 0x300) = (priority << 4) & 0xFF;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b00",
            "calling": [
                "HAL_NVIC_SetPriority",
                "SysTick_Config"
            ],
            "imported": false,
            "current_name": "setInterruptPriority_08006b00"
        },
        "FUN_0800b4d0": {
            "renaming": {
                "FUN_0800b4d0": "initialize_if_not_done_before_0800b4d0",
                "DAT_0800b4dc": "is_initialized",
                "DAT_0800b4e0": "cleanup"
            },
            "code": "void initialize_if_not_done_before_0800b4d0()\n{\n  if (DAT_0800b4dc != 0) {\n    atexit(DAT_0800b4e0);\n    return;\n  }\n  return;\n}",
            "called": [
                "atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b4d0",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "initialize_if_not_done_before_0800b4d0"
        },
        "FUN_08007f54": {
            "renaming": {
                "FUN_08007f54": "set_baud_rate_08007f54",
                "USART_TypeDef": "usart",
                "baud": "baud_rate",
                "uVar1": "mantissa",
                "uVar2": "pclk_freq",
                "uVar3": "pclk_freq",
                "uVar4": "pclk_freq",
                "DAT_08008184": "USART1",
                "DAT_08008188": "USART6",
                "PTR_0800818c": "over8"
            },
            "code": "void set_baud_rate_08007f54(USART_TypeDef *usart, int baud_rate) {\n  if ((usart->CR1 & USART_CR1_UE) == 0) {\n    uint32_t pclk_freq = (usart == DAT_08008184 || usart == DAT_08008188) ? HAL_RCC_GetPCLK2Freq() : HAL_RCC_GetPCLK1Freq();\n    uint32_t PTR_0800818c = (usart->CR1 & USART_CR1_OVER8) ? 8 : 16;\n    uint32_t mantissa = pclk_freq / (PTR_0800818c * baud_rate);\n    uint32_t fraction = ((pclk_freq * 2) / (PTR_0800818c * baud_rate)) - (mantissa * 2);\n    usart->BRR = (mantissa << 4) | (fraction >> 1);\n  }\n}",
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f54",
            "calling": [
                "usart_init"
            ],
            "imported": false,
            "current_name": "set_baud_rate_08007f54"
        },
        "FUN_08003b98": {
            "renaming": {
                "FUN_08003b98": "execute_gcode_08003b98",
                "*line": "gcode_line",
                "bVar1": "first_char",
                "uVar2": "return_value",
                "iVar3": "read_float_result",
                "uVar4": "float_to_double_result",
                "extraout_r1": "extraout_r1",
                "uVar5": "loop_counter",
                "value_00": "value_00",
                "in_stack_ffffffe0": "in_stack_ffffffe0",
                "value": "value",
                "parameter": "parameter",
                "char_counter": "char_counter",
                "helper_var": "helper_var",
                "PTR_sys_08003f2c": "sys_var_08003f2c",
                "PTR_settings_08003f30": "settings_var_08003f30",
                "mc_reset": "mc_reset",
                "report_feedback_message": "report_feedback_message",
                "report_grbl_help": "report_grbl_help",
                "execute_gc_line": "execute_gc_line",
                "report_gcode_parameters": "report_gcode_parameters",
                "report_grbl_settings": "report_grbl_settings",
                "report_gcode_modes": "report_gcode_modes",
                "mc_go_home": "mc_go_home",
                "protocol_execute_startup": "protocol_execute_startup",
                "settings_read_startup_line": "settings_read_startup_line",
                "report_startup_line": "report_startup_line",
                "settings_store_global_setting": "settings_store_global_setting",
                "settings_store_startup_line": "settings_store_startup_line"
            },
            "code": "uint8_t execute_gcode_08003b98(char *gcode_line) {\n  uint8_t return_value;\n  uint8_t char_counter = 0;\n  uint8_t helper_var = 0;\n  char first_char = gcode_line[0];\n  if (first_char != '$') {\n    return_value = execute_gc_line(gcode_line);\n    return return_value;\n  }\n  helper_var = gcode_line[1];\n  if (helper_var == 0) {\n    report_grbl_help();\n    return 0;\n  }\n  if ((helper_var < 0x23) || (helper_var > 0x58)) {\n    goto default_case;\n  }\n  switch (helper_var) {\n    case 0x23:\n      char_counter = 2;\n      if (gcode_line[char_counter] != 0) {\n        return 3;\n      }\n      report_gcode_parameters();\n      break;\n    case 0x24:\n      char_counter = 2;\n      if (gcode_line[char_counter] != 0) {\n        return 3;\n      }\n      report_grbl_settings();\n      break;\n    case 0x43:\n      char_counter = 2;\n      if (gcode_line[char_counter] != 0) {\n        return 3;\n      }\n      if (PTR_sys_08003f2c[1] == 7) {\n        mc_reset();\n        report_feedback_message(5);\n      }\n      else {\n        if (PTR_sys_08003f2c[1] != 0) {\n          return 11;\n        }\n        PTR_sys_08003f2c[1] = 7;\n        report_feedback_message(4);\n      }\n      break;\n    case 0x47:\n      char_counter = 2;\n      if (gcode_line[char_counter] != 0) {\n        return 3;\n      }\n      report_gcode_modes();\n      break;\n    case 0x48:\n      if ((PTR_settings_08003f30[0x28] & 0x10) == 0) {\n        return 7;\n      }\n      if ((PTR_sys_08003f2c[1] != 0) && (PTR_sys_08003f2c[1] != 6)) {\n        return 11;\n      }\n      mc_go_home();\n      if (PTR_sys_08003f2c[0] == 0) {\n        protocol_execute_startup();\n      }\n      break;\n    case 0x4e:\n      char_counter = 2;\n      if (gcode_line[char_counter] == 0) {\n        for (helper_var = 0; helper_var < 2; helper_var++) {\n          return_value = settings_read_startup_line(helper_var, gcode_line);\n          if (return_value == 0) {\n            report_status_message('\\n');\n          }\n          else {\n            report_startup_line(helper_var, gcode_line);\n          }\n        }\n        return 0;\n      }\n      helper_var = 1;\n      default:\n      if (read_float(gcode_line, &char_counter, &helper_var) == 0) {\n        return 1;\n      }\n      char_counter++;\n      if (gcode_line[char_counter - 1] != '=') {\n        return 3;\n      }\n      if (helper_var == 0) {\n        if (read_float(gcode_line, &char_counter, &value) == 0) {\n          return 1;\n        }\n        if (gcode_line[char_counter] == 0) {\n          int int_value = (int)__aeabi_f2iz(parameter);\n          return_value = settings_store_global_setting(int_value, value_00);\n          return return_value;\n        }\n        else {\n          return 3;\n        }\n      }\n      else {\n        while (gcode_line[char_counter] != 0) {\n          gcode_line[char_counter - 2] = gcode_line[char_counter];\n          char_counter++;\n        }\n        helper_var = 2;\n        return_value = execute_gc_line(gcode_line);\n        if (return_value != 0) {\n          return return_value;\n        }\n        double double_value = (double)__aeabi_f2d(parameter);\n        double truncated_value = trunc(double_value);\n        helper_var = (uint8_t)__aeabi_d2uiz(truncated_value, in_stack_ffffffe0);\n        settings_store_startup_line(helper_var, gcode_line);\n      }\n      break;\n    case 0x58:\n      char_counter = 2;\n      if (gcode_line[char_counter] != 0) {\n        return 3;\n      }\n      if (PTR_sys_08003f2c[1] == 6) {\n        report_feedback_message(3);\n        PTR_sys_08003f2c[1] = 0;\n      }\n  }\n  return 0;\n}",
            "called": [
                "report_feedback_message",
                "settings_store_startup_line",
                "report_status_message",
                "__aeabi_f2iz",
                "protocol_execute_startup",
                "settings_read_startup_line",
                "report_gcode_modes",
                "settings_store_global_setting",
                "read_float",
                "report_grbl_help",
                "mc_go_home",
                "report_gcode_parameters",
                "__aeabi_d2uiz",
                "trunc",
                "__aeabi_f2d",
                "report_grbl_settings",
                "mc_reset",
                "gc_execute_line",
                "report_startup_line"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003b98",
            "calling": [
                "protocol_process"
            ],
            "imported": false,
            "current_name": "execute_gcode_08003b98"
        },
        "FUN_080024c4": {
            "renaming": {
                "FUN_080024c4": "initialize_printing_080024c4",
                "invert_feed_rate": "inverted_feed_rate",
                "uVar1": "direction_float",
                "uVar2": "z_direction_float",
                "z": "z_position",
                "feed_rate": "feed_rate",
                "z_dir": "z_direction",
                "y_dir": "y_direction",
                "x_dir": "x_direction",
                "PTR_sys_080025d8": "sys_080025d8",
                "PTR_limits_enabled_080025dc": "limits_enabled_080025dc",
                "limits_go_home": "limits_go_home",
                "protocol_execute_runtime": "protocol_execute_runtime",
                "DAT_080025e0": "current_position",
                "sys_sync_current_position": "sys_sync_current_position",
                "PTR_settings_080025e4": "settings_080025e4",
                "mc_line": "mc_line",
                "st_cycle_start": "st_cycle_start",
                "plan_synchronize": "plan_synchronize"
            },
            "code": "void initialize_printing_080024c4()\n{\n    uint8_t inverted_feed_rate;\n    undefined4 x_direction_float;\n    undefined4 y_direction_float;\n    undefined4 z_direction_float;\n    float z_position;\n    float feed_rate;\n    int8_t x_direction;\n    int8_t y_direction;\n    int8_t z_direction;\n\n    PTR_sys_080025d8[1] = 5;\n    *(undefined4 *)PTR_limits_enabled_080025dc = 0;\n    limits_go_home();\n    protocol_execute_runtime();\n\n    if (*PTR_sys_080025d8 == '\\0') {\n        memset(DAT_080025e0, 0, 0xc);\n        sys_sync_DAT_080025e0();\n        PTR_sys_080025d8[1] = 0;\n\n        if ((*(ushort *)(PTR_settings_080025e4 + 0x2a) & 0x20) == 0) {\n            x_direction = -1;\n        }\n        else {\n            x_direction = 1;\n        }\n\n        if ((*(ushort *)(PTR_settings_080025e4 + 0x2a) & 0x80) == 0) {\n            y_direction = -1;\n        }\n        else {\n            y_direction = 1;\n        }\n\n        if ((*(ushort *)(PTR_settings_080025e4 + 0x2a) & 0x200) == 0) {\n            z_direction = -1;\n        }\n        else {\n            z_direction = 1;\n        }\n\n        x_direction_float = __floatsisf((int)x_direction);\n        inverted_feed_rate = __aeabi_fmul(x_direction_float, *(undefined4 *)(PTR_settings_080025e4 + 0x38));\n        y_direction_float = __floatsisf((int)y_direction);\n        __aeabi_fmul(y_direction_float, *(undefined4 *)(PTR_settings_080025e4 + 0x38));\n        z_direction_float = __floatsisf((int)z_direction);\n        mc_line((float)z_direction_float, (float)((ulonglong)z_direction_float >> 0x20), z_position, feed_rate, inverted_feed_rate);\n        st_cycle_start();\n        plan_synchronize();\n        sys_sync_DAT_080025e0();\n\n        if ((PTR_settings_080025e4[0x28] & 8) != 0) {\n            *(undefined4 *)PTR_limits_enabled_080025dc = 1;\n        }\n    }\n    return;\n}",
            "called": [
                "sys_sync_current_position",
                "plan_synchronize",
                "limits_go_home",
                "memset",
                "__aeabi_fmul",
                "st_cycle_start",
                "__floatsisf",
                "mc_line",
                "protocol_execute_runtime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080024c4",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "initialize_printing_080024c4"
        },
        "FUN_08002f40": {
            "renaming": {
                "FUN_08002f40": "update_block_tail_index_if_not_empty_08002f40",
                "uVar1": "next_index"
            },
            "code": "void update_block_tail_index_if_not_empty_08002f40(void)\n{\n  uint8_t next_index;\n  if (*PTR_block_buffer_head_08002f6c != *PTR_block_buffer_tail_08002f70) {\n    next_index = next_block_index(*PTR_block_buffer_tail_08002f70);\n    *PTR_block_buffer_tail_08002f70 = next_index;\n  }\n  return;\n}",
            "called": [
                "next_block_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f40",
            "calling": [
                "step_period_isr"
            ],
            "imported": false,
            "current_name": "update_block_tail_index_if_not_empty_08002f40"
        },
        "FUN_08009054": {
            "renaming": {
                "FUN_08009054": "float_converter_08009054",
                "param_1": "float_bits_1",
                "param_2": "float_bits_2",
                "param_3": "float_bits_3",
                "param_4": "float_bits_4",
                "uVar1": "mask",
                "uVar2": "exp1",
                "iVar3": "exp_diff",
                "uVar4": "exp_sum",
                "iVar5": "sum_is_negative",
                "uVar6": "result_bits",
                "bVar7": "condition",
                "bVar8": "overflowed",
                "bVar9": "carry"
            },
            "code": "\nuint float_converter_08009054(uint float_bits_1,uint float_bits_2,undefined4 float_bits_3,uint float_bits_4)\n\n{\n  uint mask;\n  uint exp1;\n  int exp_diff;\n  uint exp_sum;\n  int sum_is_negative;\n  uint result_bits;\n  bool condition;\n  bool overflowed;\n  bool carry;\n  \n  exp1 = float_bits_1 >> 0x17 & 0xff;\n  condition = exp1 == 0;\n  if (!condition) {\n    float_bits_4 = float_bits_2 >> 0x17 & 0xff;\n    condition = float_bits_4 == 0;\n  }\n  if (!condition) {\n    condition = exp1 == 0xff;\n  }\n  if (!condition) {\n    condition = float_bits_4 == 0xff;\n  }\n  if (condition) {\n    float_bits_4 = float_bits_2 >> 0x17 & 0xff;\n    result_bits = float_bits_1;\n    if (exp1 == 0xff) {\n      if (((float_bits_1 & 0x7fffff) != 0) || (result_bits = float_bits_2, float_bits_4 == 0xff)) {\nLAB_0800904a:\n        return result_bits | 0x7fc00000;\n      }\n    }\n    else {\n      if (float_bits_4 == 0xff) {\n        result_bits = float_bits_2;\n        if ((float_bits_2 & 0x7fffff) == 0) {\nLAB_08009000:\n          return (float_bits_1 ^ float_bits_2) & 0x80000000;\n        }\n        goto LAB_0800904a;\n      }\n      condition = (float_bits_1 & 0x7fffffff) == 0;\n      if (!condition) {\n        condition = (float_bits_2 & 0x7fffffff) == 0;\n      }\n      if (!condition) {\n        condition = exp1 == 0;\n        result_bits = float_bits_1 & 0x80000000;\n        while( true ) {\n          if (condition) {\n            float_bits_1 = float_bits_1 << 1;\n            condition = (float_bits_1 & 0x800000) == 0;\n          }\n          if (!condition) break;\n          exp1 = exp1 - 1;\n        }\n        float_bits_1 = float_bits_1 | result_bits;\n        condition = float_bits_4 == 0;\n        result_bits = float_bits_2 & 0x80000000;\n        while( true ) {\n          if (condition) {\n            float_bits_2 = float_bits_2 << 1;\n            condition = (float_bits_2 & 0x800000) == 0;\n          }\n          if (!condition) break;\n          float_bits_4 = float_bits_4 - 1;\n        }\n        float_bits_2 = float_bits_2 | result_bits;\n        goto LAB_0800906c;\n      }\n      if ((float_bits_1 & 0x7fffffff) == 0) {\n        if ((float_bits_2 & 0x7fffffff) != 0) goto LAB_08009000;\n        goto LAB_0800904a;\n      }\n    }\n    float_bits_1 = float_bits_1 ^ float_bits_2;\n  }\n  else {\nLAB_0800906c:\n    exp_diff = exp1 - float_bits_4;\n    if (float_bits_2 << 9 == 0) {\n      float_bits_1 = (float_bits_1 ^ float_bits_2) & 0x80000000 | float_bits_1 & 0x7fffff;\n      carry = SCARRY4(exp_diff,0x7f);\n      sum_is_negative = exp_diff + 0x7f;\n      condition = sum_is_negative < 0;\n      overflowed = sum_is_negative == 0;\n      if (!overflowed && condition == carry) {\n        carry = SBORROW4(0xff,sum_is_negative);\n        condition = 0xff - sum_is_negative < 0;\n        overflowed = sum_is_negative == 0xff;\n      }\n      if (!overflowed && condition == carry) {\n        float_bits_1 = float_bits_1 | sum_is_negative * 0x800000;\n      }\n      if (!overflowed && condition == carry) {\n        return float_bits_1;\n      }\n      float_bits_1 = float_bits_1 | 0x800000;\n      exp1 = 0;\n      overflowed = SBORROW4(sum_is_negative,1);\n      exp_sum = exp_diff + 0x7e;\n      condition = exp_sum == 0;\n      result_bits = exp_sum;\n    }\n    else {\n      mask = (float_bits_2 << 9) >> 4 | 0x10000000;\n      exp1 = (float_bits_1 << 9) >> 4 | 0x10000000;\n      float_bits_1 = (float_bits_1 ^ float_bits_2) & 0x80000000;\n      condition = mask <= exp1;\n      if (!condition) {\n        exp1 = exp1 << 1;\n      }\n      exp_sum = exp_diff + 0x7d + (uint)condition;\n      result_bits = 0x800000;\n      do {\n        if (mask <= exp1) {\n          exp1 = exp1 - mask;\n          float_bits_1 = float_bits_1 | result_bits;\n        }\n        condition = mask >> 1 <= exp1;\n        if (condition) {\n          exp1 = exp1 - (mask >> 1);\n        }\n        if (condition) {\n          float_bits_1 = float_bits_1 | result_bits >> 1;\n        }\n        condition = mask >> 2 <= exp1;\n        if (condition) {\n          exp1 = exp1 - (mask >> 2);\n        }\n        if (condition) {\n          float_bits_1 = float_bits_1 | result_bits >> 2;\n        }\n        condition = mask >> 3 <= exp1;\n        if (condition) {\n          exp1 = exp1 - (mask >> 3);\n        }\n        if (condition) {\n          float_bits_1 = float_bits_1 | result_bits >> 3;\n        }\n        exp1 = exp1 * 0x10;\n        condition = exp1 == 0;\n        if (!condition) {\n          result_bits = result_bits >> 4;\n          condition = result_bits == 0;\n        }\n      } while (!condition);\n      overflowed = SBORROW4(exp_sum,0xfd);\n      condition = exp_sum == 0xfd;\n      result_bits = exp_sum - 0xfd;\n      if (exp_sum < 0xfe) {\n        float_bits_1 = float_bits_1 + exp_sum * 0x800000 + (uint)(mask <= exp1);\n        if (exp1 - mask == 0) {\n          float_bits_1 = float_bits_1 & 0xfffffffe;\n        }\n        return float_bits_1;\n      }\n    }\n    if (condition || (int)result_bits < 0 != overflowed) {\n      condition = (int)(exp_sum + 0x19) < 0;\n      if (exp_sum == 0xffffffe7 || condition != SCARRY4(exp_sum,0x19)) {\n        float_bits_1 = float_bits_1 & 0x80000000;\n      }\n      if (exp_sum == 0xffffffe7 || condition != SCARRY4(exp_sum,0x19)) {\n        return float_bits_1;\n      }\n      result_bits = (float_bits_1 << 1) >> (-exp_sum & 0xff);\n      exp_sum = float_bits_1 << (exp_sum + 0x20 & 0xff);\n      result_bits = ((uint)((float_bits_1 & 0x80000000) != 0) << 0x1f | result_bits >> 1) + (uint)((byte)result_bits & 1);\n      if ((exp1 | exp_sum << 1) == 0) {\n        result_bits = result_bits & ~(exp_sum >> 0x1f);\n      }\n      return result_bits;\n    }\n  }\n  return float_bits_1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009054",
            "calling": [
                "intersection_distance",
                "gc_set_current_position",
                "homing_cycle",
                "report_realtime_status",
                "plan_cycle_reinitialize",
                "planner_recalculate_trapezoids",
                "mc_arc",
                "plan_buffer_line",
                "report_grbl_settings",
                "estimate_acceleration_distance"
            ],
            "imported": false,
            "current_name": "float_converter_08009054"
        },
        "FUN_080025e8": {
            "renaming": {
                "FUN_080025e8": "check_spindle_and_coolant_stop_080025e8",
                "PTR_sys_08002634": "spindle_coolant_params",
                "PTR_sys_08002634[2]": "spindle_coolant_flags",
                "PTR_sys_08002634[1]": "spindle_coolant_param_1",
                "byte": "byte_t"
            },
            "code": "void check_spindle_and_coolant_stop_080025e8(void)\n{\n  int PTR_sys_08002634[2] = PTR_sys_08002634[2];\n  if ((PTR_sys_08002634[2] & 0x10) == 0) {\n    PTR_sys_08002634[2] |= 0x10;\n    spindle_stop();\n    coolant_stop();\n    if ((byte)PTR_sys_08002634[1] - 3 < 3) {\n      PTR_sys_08002634[2] |= 0x20;\n      st_go_idle();\n    }\n  }\n  return;\n}",
            "called": [
                "spindle_stop",
                "st_go_idle",
                "coolant_stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025e8",
            "calling": [
                "protocol_execute_line",
                "buttons_isr",
                "serial_rx_hook",
                "limits_isr",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "check_spindle_and_coolant_stop_080025e8"
        },
        "FUN_080001c8": {
            "renaming": {
                "FUN_080001c8": "do_nothing_080001c8"
            },
            "code": "\nvoid do_nothing_080001c8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001c8",
            "calling": [
                "coolant_run"
            ],
            "imported": false,
            "current_name": "do_nothing_080001c8"
        },
        "FUN_08005ac4": {
            "renaming": {
                "FUN_08005ac4": "get_constant_value_08005ac4",
                "": "",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "uint32_t get_constant_value_08005ac4(void)\n{\n  uint32_t constant_value = 0x1000000;\n  return constant_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005ac4",
            "calling": [],
            "imported": false,
            "current_name": "get_constant_value_08005ac4"
        },
        "FUN_08005250": {
            "renaming": {
                "FUN_08005250": "turn_off_spindle_08005250",
                "spindle_off": "spindle_turn_off"
            },
            "code": "void turn_off_spindle_08005250(void)\n{\n  spindle_off();\n  return;\n}",
            "called": [
                "spindle_off"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005250",
            "calling": [
                "spindle_init",
                "spindle_run",
                "mc_reset"
            ],
            "imported": false,
            "current_name": "turn_off_spindle_08005250"
        },
        "FUN_08007430": {
            "renaming": {
                "FUN_08007430": "infinite_loop_08007430"
            },
            "code": "void infinite_loop_08007430(void)\n{\n  while(true)\n  {\n    // Do nothing\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007430",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "infinite_loop_08007430"
        },
        "FUN_08008640": {
            "renaming": {
                "FUN_08008640": "calculate_double_precision_product_08008640",
                "param_1": "first_uint_parameter",
                "param_2": "second_uint_parameter",
                "param_3": "third_uint_parameter",
                "param_4": "fourth_uint_parameter",
                "uVar1": "lower_product_bits",
                "lVar2": "intermediate_product",
                "uVar3": "first_product_bits",
                "uVar4": "second_product_bits",
                "iVar5": "sum_of_bits_20_to_30",
                "uVar6": "difference_of_bits_20_to_30",
                "uVar7": "bitmask",
                "uVar8": "product_bits_31_to_63",
                "bVar9": "is_zero",
                "bVar10": "is_negative",
                "bVar11": "has_overflow",
                "uVar12": "concatenated_parameters"
            },
            "code": "\nulonglong calculate_double_precision_product_08008640(undefined4 first_uint_parameter,uint second_uint_parameter,uint third_uint_parameter,uint fourth_uint_parameter)\n\n{\n  ulonglong lower_product_bits;\n  longlong intermediate_product;\n  uint first_product_bits;\n  uint second_product_bits;\n  int sum_of_bits_20_to_30;\n  uint difference_of_bits_20_to_30;\n  uint unaff_r5;\n  uint bitmask;\n  uint product_bits_31_to_63;\n  bool is_zero;\n  bool is_negative;\n  bool has_overflow;\n  ulonglong concatenated_parameters;\n  \n  concatenated_parameters = CONCAT44(second_uint_parameter,first_uint_parameter);\n  bitmask = 0x7ff;\n  second_product_bits = second_uint_parameter >> 0x14 & 0x7ff;\n  is_zero = second_product_bits == 0;\n  if (!is_zero) {\n    unaff_r5 = fourth_uint_parameter >> 0x14 & 0x7ff;\n    is_zero = unaff_r5 == 0;\n  }\n  if (!is_zero) {\n    is_zero = second_product_bits == 0x7ff;\n  }\n  if (!is_zero) {\n    is_zero = unaff_r5 == 0x7ff;\n  }\n  if (is_zero) {\n    concatenated_parameters = synchronize_0800881c();\n  }\n  first_product_bits = (uint)(concatenated_parameters >> 0x20);\n  sum_of_bits_20_to_30 = second_product_bits + unaff_r5;\n  second_product_bits = first_product_bits ^ fourth_uint_parameter;\n  first_product_bits = first_product_bits & ~(bitmask << 0x15);\n  fourth_uint_parameter = fourth_uint_parameter & ~(bitmask << 0x15);\n  is_zero = ((uint)concatenated_parameters | first_product_bits << 0xc) == 0;\n  if (!is_zero) {\n    is_zero = (third_uint_parameter | fourth_uint_parameter << 0xc) == 0;\n  }\n  first_product_bits = first_product_bits | 0x100000;\n  fourth_uint_parameter = fourth_uint_parameter | 0x100000;\n  if (is_zero) {\n    third_uint_parameter = (uint)concatenated_parameters | third_uint_parameter;\n    fourth_uint_parameter = (second_product_bits & 0x80000000 | first_product_bits) ^ fourth_uint_parameter;\n    second_product_bits = bitmask >> 1;\n    has_overflow = SBORROW4(sum_of_bits_20_to_30,second_product_bits);\n    difference_of_bits_20_to_30 = sum_of_bits_20_to_30 - second_product_bits;\n    is_zero = difference_of_bits_20_to_30 == 0;\n    first_product_bits = difference_of_bits_20_to_30;\n    if (!is_zero && (int)second_product_bits <= sum_of_bits_20_to_30) {\n      has_overflow = SBORROW4(bitmask,difference_of_bits_20_to_30);\n      first_product_bits = bitmask - difference_of_bits_20_to_30;\n      is_zero = bitmask == difference_of_bits_20_to_30;\n    }\n    if (!is_zero && (int)first_product_bits < 0 == has_overflow) {\n      fourth_uint_parameter = fourth_uint_parameter | difference_of_bits_20_to_30 * 0x100000;\n    }\n    if (!is_zero && (int)first_product_bits < 0 == has_overflow) {\n      return CONCAT44(fourth_uint_parameter,third_uint_parameter);\n    }\n    fourth_uint_parameter = fourth_uint_parameter | 0x100000;\n    bitmask = 0;\n    has_overflow = SBORROW4(difference_of_bits_20_to_30,1);\n    difference_of_bits_20_to_30 = difference_of_bits_20_to_30 - 1;\n    is_zero = difference_of_bits_20_to_30 == 0;\n    second_product_bits = difference_of_bits_20_to_30;\n  }\n  else {\n    lower_product_bits = (concatenated_parameters & 0xffffffff) * (ulonglong)third_uint_parameter;\n    concatenated_parameters = (concatenated_parameters & 0xffffffff) * (ulonglong)fourth_uint_parameter +\n             (ulonglong)first_product_bits * (ulonglong)third_uint_parameter + (lower_product_bits >> 0x20);\n    product_bits_31_to_63 = (uint)concatenated_parameters;\n    intermediate_product = (ulonglong)first_product_bits * (ulonglong)fourth_uint_parameter + (concatenated_parameters >> 0x20);\n    bitmask = (uint)intermediate_product;\n    first_product_bits = (uint)((ulonglong)intermediate_product >> 0x20);\n    if ((int)lower_product_bits != 0) {\n      product_bits_31_to_63 = product_bits_31_to_63 | 1;\n    }\n    difference_of_bits_20_to_30 = (sum_of_bits_20_to_30 + -0x3ff) - (uint)(first_product_bits < 0x200);\n    if (first_product_bits < 0x200) {\n      is_zero = (product_bits_31_to_63 & 0x80000000) != 0;\n      product_bits_31_to_63 = product_bits_31_to_63 << 1;\n      intermediate_product = CONCAT44(first_product_bits * 2 + (uint)(CARRY4(bitmask,bitmask) || CARRY4(bitmask * 2,(uint)is_zero)),\n                       bitmask * 2 + (uint)is_zero);\n    }\n    fourth_uint_parameter = second_product_bits & 0x80000000 | (int)((ulonglong)intermediate_product >> 0x20) << 0xb | (uint)intermediate_product >> 0x15;\n    third_uint_parameter = (uint)intermediate_product << 0xb | product_bits_31_to_63 >> 0x15;\n    bitmask = product_bits_31_to_63 * 0x800;\n    is_negative = 0xfc < difference_of_bits_20_to_30;\n    has_overflow = SBORROW4(difference_of_bits_20_to_30,0xfd);\n    first_product_bits = difference_of_bits_20_to_30 - 0xfd;\n    is_zero = first_product_bits == 0;\n    second_product_bits = first_product_bits;\n    if (is_negative && !is_zero) {\n      is_negative = 0x6ff < first_product_bits;\n      has_overflow = SBORROW4(first_product_bits,0x700);\n      second_product_bits = difference_of_bits_20_to_30 - 0x7fd;\n      is_zero = first_product_bits == 0x700;\n    }\n    if (!is_negative || is_zero) {\n      is_zero = 0x7fffffff < bitmask;\n      if (bitmask == 0x80000000) {\n        is_zero = (product_bits_31_to_63 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(fourth_uint_parameter + difference_of_bits_20_to_30 * 0x100000 + (uint)CARRY4(third_uint_parameter,(uint)is_zero),third_uint_parameter + is_zero\n                     );\n    }\n  }\n  if (!is_zero && (int)second_product_bits < 0 == has_overflow) {\n    return (ulonglong)(fourth_uint_parameter & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  is_negative = SCARRY4(difference_of_bits_20_to_30,0x36);\n  is_zero = (int)(difference_of_bits_20_to_30 + 0x36) < 0;\n  has_overflow = difference_of_bits_20_to_30 == 0xffffffca;\n  if (has_overflow || is_zero != is_negative) {\n    third_uint_parameter = 0;\n  }\n  if (has_overflow || is_zero != is_negative) {\n    fourth_uint_parameter = fourth_uint_parameter & 0x80000000;\n  }\n  if (has_overflow || is_zero != is_negative) {\n    return CONCAT44(fourth_uint_parameter,third_uint_parameter);\n  }\n  second_product_bits = -difference_of_bits_20_to_30;\n  first_product_bits = second_product_bits - 0x20;\n  if (0x1f < (int)second_product_bits) {\n    difference_of_bits_20_to_30 = third_uint_parameter >> (first_product_bits & 0xff) | fourth_uint_parameter << (0x20 - first_product_bits & 0xff);\n    second_product_bits = (fourth_uint_parameter >> (first_product_bits & 0xff) & ~((fourth_uint_parameter & 0x80000000) >> (first_product_bits & 0xff))) -\n            ((int)difference_of_bits_20_to_30 >> 0x1f);\n    if ((bitmask | third_uint_parameter << (0x20 - first_product_bits & 0xff) | difference_of_bits_20_to_30 << 1) == 0) {\n      second_product_bits = second_product_bits & ~(difference_of_bits_20_to_30 >> 0x1f);\n    }\n    return CONCAT44(fourth_uint_parameter,second_product_bits) & 0x80000000ffffffff;\n  }\n  sum_of_bits_20_to_30 = second_product_bits - 0x14;\n  if (sum_of_bits_20_to_30 == 0 || sum_of_bits_20_to_30 < 0 != SCARRY4(first_product_bits,0xc)) {\n    product_bits_31_to_63 = third_uint_parameter << (difference_of_bits_20_to_30 + 0x20 & 0xff);\n    first_product_bits = third_uint_parameter >> (second_product_bits & 0xff) | fourth_uint_parameter << (difference_of_bits_20_to_30 + 0x20 & 0xff);\n    difference_of_bits_20_to_30 = first_product_bits + -((int)product_bits_31_to_63 >> 0x1f);\n    if ((bitmask | product_bits_31_to_63 << 1) == 0) {\n      difference_of_bits_20_to_30 = difference_of_bits_20_to_30 & ~(product_bits_31_to_63 >> 0x1f);\n    }\n    return CONCAT44((fourth_uint_parameter & 0x80000000) +\n                    ((fourth_uint_parameter & 0x7fffffff) >> (second_product_bits & 0xff)) +\n                    (uint)CARRY4(first_product_bits,-((int)product_bits_31_to_63 >> 0x1f)),difference_of_bits_20_to_30);\n  }\n  second_product_bits = 0xc - sum_of_bits_20_to_30;\n  difference_of_bits_20_to_30 = third_uint_parameter << (second_product_bits & 0xff);\n  second_product_bits = third_uint_parameter >> (0x20 - second_product_bits & 0xff) | fourth_uint_parameter << (second_product_bits & 0xff);\n  first_product_bits = second_product_bits + -((int)difference_of_bits_20_to_30 >> 0x1f);\n  if ((bitmask | difference_of_bits_20_to_30 << 1) == 0) {\n    first_product_bits = first_product_bits & ~(difference_of_bits_20_to_30 >> 0x1f);\n  }\n  return CONCAT44((fourth_uint_parameter & 0x80000000) + (uint)CARRY4(second_product_bits,-((int)difference_of_bits_20_to_30 >> 0x1f)),first_product_bits);\n}\n\n",
            "called": [
                "FUN_0800881c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008640",
            "calling": [
                "scalbn",
                "homing_cycle",
                "mc_arc",
                "read_float",
                "report_gcode_modes",
                "__ieee754_sqrt",
                "calculate_trapezoid_for_block",
                "__ieee754_hypot",
                "report_realtime_status",
                "report_gcode_parameters",
                "__kernel_cos",
                "__ieee754_rem_pio2",
                "plan_buffer_line",
                "to_millimeters",
                "atan",
                "__kernel_rem_pio2",
                "__kernel_sin"
            ],
            "imported": false,
            "current_name": "calculate_double_precision_product_08008640"
        },
        "FUN_08007310": {
            "renaming": {
                "FUN_08007310": "get_gpio_pin_state_08007310",
                "GPIOx": "gpio",
                "GPIO_Pin": "pin",
                "bitstatus": "state"
            },
            "code": "GPIO_PinState get_gpio_pin_state_08007310(GPIO_TypeDef *gpio, uint16_t pin) {\n\tGPIO_PinState state = (uint32_t)pin & gpio->IDR;\n\treturn state != 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007310",
            "calling": [],
            "imported": false,
            "current_name": "get_gpio_pin_state_08007310"
        },
        "FUN_08007436": {
            "renaming": {
                "FUN_08007436": "initialize_clocks_08007436",
                "HVar1": "status",
                "RCC_OscInitStruct": "osc_init",
                "RCC_ClkInitStruct": "clk_init",
                "DAT_080074c0": "ptr_dat_080074c0_40",
                "DAT_080074c4": "ptr_dat_080074c4"
            },
            "code": "void initialize_clocks_08007436(void)\n{\n  HAL_StatusTypeDef status;\n  RCC_OscInitTypeDef osc_init;\n  RCC_ClkInitTypeDef clk_init;\n  uint32_t *DAT_080074c0 = (uint32_t *)(DAT_080074c0 + 0x40);\n  uint32_t *DAT_080074c4 = (uint32_t *)(DAT_080074c4);\n  *DAT_080074c0 |= 0x10000000;\n  *DAT_080074c4 |= 0xc000;\n  osc_init.OscillatorType = RCC_OSCILLATORTYPE_HSE;\n  osc_init.HSEState = RCC_HSE_ON;\n  osc_init.PLL.PLLState = RCC_PLL_ON;\n  osc_init.PLL.PLLSource = RCC_PLLSOURCE_HSE;\n  osc_init.PLL.PLLM = 8;\n  osc_init.PLL.PLLN = 336;\n  osc_init.PLL.PLLP = RCC_PLLP_DIV2;\n  osc_init.PLL.PLLQ = 7;\n  status = HAL_RCC_OscConfig(&osc_init);\n  if (status != HAL_OK) {\n    Error_Handler();\n  }\n  clk_init.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  clk_init.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  clk_init.APB1CLKDivider = RCC_HCLK_DIV4;\n  clk_init.APB2CLKDivider = RCC_HCLK_DIV2;\n  status = HAL_RCC_ClockConfig(&clk_init, FLASH_LATENCY_5);\n  if (status != HAL_OK) {\n    Error_Handler();\n  }\n  return;\n}",
            "called": [
                "HAL_RCC_OscConfig",
                "Error_Handler",
                "HAL_RCC_ClockConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007436",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_clocks_08007436"
        },
        "FUN_08005814": {
            "renaming": {
                "FUN_08005814": "initialize_game_08005814",
                "PTR_st_08005834": "game_data",
                "PTR_current_block_08005838": "current_block",
                "set_step_events_per_minute": "set_events_per_minute",
                "undefined4": "int"
            },
            "code": "void initialize_game_08005814() {\n\tmemset(PTR_st_08005834, 0, sizeof(PTR_st_08005834));\n\tset_events_per_minute(800);\n\t*(int *)PTR_current_block_08005838 = 0;\n\treturn;\n}",
            "called": [
                "memset",
                "set_step_events_per_minute"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005814",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "initialize_game_08005814"
        },
        "FUN_08005bdc": {
            "renaming": {
                "FUN_08005bdc": "set_irq_priority_08005bdc",
                "IRQn_Type": "IRQn",
                "IRQn": "irq",
                "priority": "priority",
                "WWDG_IRQn": "WWDG_IRQn",
                "DAT_08005c28": "DAT_08005c28",
                "DAT_08005c2c": "DAT_08005c2c"
            },
            "code": "void set_irq_priority_08005bdc(IRQn_Type irq, uint32_t priority)\n{\n  if (irq < WWDG_IRQn) {\n    uint32_t* priority_reg = (uint32_t*)(((uint32_t)&NVIC->IP[irq]) + 0x14);\n    *priority_reg = (priority & 0xFF) << 4;\n  }\n  else {\n    uint32_t* priority_reg = (uint32_t*)(((uint32_t)&NVIC->IP[irq - WWDG_IRQn]) + 0xC00);\n    *priority_reg = (priority & 0xFF) << 4;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bdc",
            "calling": [
                "SysTick_Config"
            ],
            "imported": false,
            "current_name": "set_irq_priority_08005bdc"
        },
        "FUN_080085d4": {
            "renaming": {
                "FUN_080085d4": "calculate_double_precision_080085d4",
                "param_1": "input1",
                "param_2": "input2",
                "uVar2": "temp1",
                "uVar3": "shift_amount",
                "uVar4": "temp2",
                "iVar5": "leading_zeros",
                "uVar6": "shift_amount_minus_11",
                "iVar7": "shift_amount_plus_0x432",
                "uVar8": "temp2_shifted",
                "bVar9": "is_negative",
                "bVar10": "is_greater_than_one",
                "bVar11": "is_negative_overflowed",
                "bVar1": "temp1_least_significant_byte",
                "result1": "result1",
                "result2": "result2",
                "carry": "carry"
            },
            "code": "ulonglong calculate_double_precision_080085d4(uint input1, uint input2)\n{\n  uint shift_amount, leading_zeros, temp1, temp2, result1, result2;\n  bool is_negative, carry, is_greater_than_one;\n\n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2, input1);\n  }\n\n  shift_amount = 0x432;\n  temp2 = input2 >> 0x16;\n  if (temp2 != 0) {\n    shift_amount = 3;\n    if (input2 >> 0x19 != 0) {\n      shift_amount = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      shift_amount += 3;\n    }\n    shift_amount -= ((int)input2 >> 0x1f);\n    result1 = input1 << (0x20 - shift_amount);\n    input1 = input1 >> (shift_amount & 0xff) | input2 << (0x20 - shift_amount & 0xff);\n    input2 = input2 >> (shift_amount & 0xff);\n    shift_amount += 0x432;\n  }\n\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      is_greater_than_one = (input2 & 1) != 0;\n      input2 = input2 >> 1;\n      is_negative = (byte)input1 & 1;\n      input1 = (uint)(is_greater_than_one) << 0x1f | input1 >> 1;\n      result2 = (uint)(is_negative) << 0x1f | temp2 >> 1;\n      shift_amount += 1;\n      if (0xffbfffff < (uint)(shift_amount * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\n    else {\n      goto LAB_080083e0;\n    }\n  }\n\n  is_negative = (temp2 & 0x80000000) != 0;\n  temp2 = temp2 << 1;\n  temp1 = input1 * 2;\n  carry = CARRY4(input1, input1);\n  input1 = input1 * 2 + (uint)is_negative;\n  input2 = input2 * 2 + (uint)(carry || CARRY4(temp1, (uint)is_negative));\n  is_greater_than_one = shift_amount != 0;\n  shift_amount -= 1;\n  if (is_greater_than_one && 0xfffff < input2) {\n    goto LAB_080083e0;\n  }\n\n  temp1 = input1;\n  temp2 = input2;\n  if (input2 == 0) {\n    temp1 = 0;\n    temp2 = input1;\n  }\n\n  leading_zeros = count_leading_zeroes(temp2);\n  if (input2 == 0) {\n    leading_zeros += 0x20;\n  }\n  shift_amount = leading_zeros - 0xb;\n  is_negative = SBORROW4(shift_amount, 0x20);\n  is_greater_than_one = shift_amount == 0;\n  if ((int)shift_amount < 0x20) {\n    is_negative = SCARRY4(shift_amount, 0xc);\n    leading_zeros -= 0x1f;\n    is_greater_than_one = leading_zeros < 0;\n    shift_amount = leading_zeros;\n    if (!is_greater_than_one && is_negative == SBORROW4(shift_amount, 0xc)) {\n      result1 = temp2 << (shift_amount & 0xff);\n      temp2 = temp2 >> (0xcU - leading_zeros & 0xff);\n      goto LAB_08008458;\n    }\n  }\n\n  if (is_greater_than_one || is_negative != SBORROW4(shift_amount, 0xc)) {\n    temp1 = 0x20 - shift_amount;\n  }\n  result2 = temp2 << (shift_amount & 0xff);\n  if (is_greater_than_one || is_negative != SBORROW4(shift_amount, 0xc)) {\n    result2 |= temp1 >> (temp1 & 0xff);\n  }\n  if (is_greater_than_one || is_negative != SBORROW4(shift_amount, 0xc)) {\n    result1 = temp1 << (shift_amount & 0xff);\n  }\n\nLAB_08008458:\n  if ((int)leading_zeros <= shift_amount) {\n    return CONCAT44(result2 + (shift_amount - leading_zeros) * 0x100000, result1);\n  }\n  temp2 = ~(shift_amount - leading_zeros);\n  if ((int)temp2 < 0x1f) {\n    shift_amount = temp2 - 0x13;\n    if (shift_amount != 0 && shift_amount < 0 == SCARRY4(temp2 - 0x1f, 0xc)) {\n      return (ulonglong)(result1 >> (0x20 - (0xcU - shift_amount) & 0xff) | result2 << (0xcU - shift_amount & 0xff));\n    }\n    temp2 += 1;\n    return CONCAT44(result2 >> (temp2 & 0xff), result1 >> (temp2 & 0xff) | result2 << (0x20 - temp2 & 0xff));\n  }\n  return (ulonglong)(result2 >> (temp2 - 0x1f & 0xff));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085d4",
            "calling": [],
            "imported": false,
            "current_name": "calculate_double_precision_080085d4"
        },
        "FUN_08006e70": {
            "renaming": {
                "FUN_08006e70": "handle_systick_interrupt_08006e70"
            },
            "code": "void handle_systick_interrupt_08006e70(void)\n{\n  HAL_SYSTICK_Callback();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e70",
            "calling": [],
            "imported": false,
            "current_name": "handle_systick_interrupt_08006e70"
        },
        "FUN_080002f0": {
            "renaming": {
                "FUN_080002f0": "initialize_eeprom_data_080002f0",
                "PTR_eeprom_data_08000308": "eeprom_data",
                "PTR_eeprom_ready_0800030c": "eeprom_ready"
            },
            "code": "void initialize_eeprom_data_080002f0(void)\n{\n  memset(PTR_eeprom_data_08000308,0xff,4);\n  *PTR_eeprom_ready_0800030c = 1;\n  return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002f0",
            "calling": [
                "eeprom_put_char",
                "memcpy_to_eeprom_with_checksum",
                "memcpy_from_eeprom_with_checksum",
                "eeprom_get_char"
            ],
            "imported": false,
            "current_name": "initialize_eeprom_data_080002f0"
        },
        "FUN_080073c0": {
            "renaming": {
                "FUN_080073c0": "do_nothing_080073c0"
            },
            "code": "\nvoid do_nothing_080073c0(uint16_t GPIO_Pin)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073c0",
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080073c0"
        },
        "FUN_0800778c": {
            "renaming": {
                "FUN_0800778c": "initialize_GPIO_pins_0800778c",
                "puVar1": "gpio_info_ptr",
                "GPIO_InitStruct": "GPIO_InitStruct",
                "gpio": "gpio_info",
                "i": "i"
            },
            "code": "void initialize_GPIO_pins_0800778c(void)\n{\n  uint32_t *gpio_info_ptr;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  GPIO_INFO *gpio_info;\n  int i;\n  for (i = 0; i < 0x11; i++) {\n    gpio_info_ptr = (uint32_t *)(PTR_gpio_info_0800784c + i * 0x18);\n    *(uint32_t *)(DAT_08007850 + 0x30) = *(uint32_t *)(DAT_08007850 + 0x30) | 1 << (*gpio_info_ptr >> 4 & 0xff);\n    GPIO_InitStruct.Pin = 1 << (*gpio_info_ptr & 0xf);\n    GPIO_InitStruct.Mode = gpio_info_ptr[1];\n    GPIO_InitStruct.Pull = gpio_info_ptr[2];\n    GPIO_InitStruct.Speed = gpio_info_ptr[3];\n    GPIO_InitStruct.Alternate = gpio_info_ptr[4];\n    HAL_GPIO_Init((GPIO_TypeDef *)(((*gpio_info_ptr >> 4) + 0x100080) * 0x400),&GPIO_InitStruct);\n    if (-1 < (int)gpio_info_ptr[5]) {\n      HAL_GPIO_WritePin((GPIO_TypeDef *)(((*gpio_info_ptr >> 4) + 0x100080) * 0x400),\n                        (uint16_t)(1 << (*gpio_info_ptr & 0xf)),(GPIO_PinState)gpio_info_ptr[5]);\n    }\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_Init",
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800778c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_GPIO_pins_0800778c"
        },
        "FUN_080001d4": {
            "renaming": {
                "FUN_080001d4": "do_nothing_080001d4"
            },
            "code": "\nvoid do_nothing_080001d4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001d4",
            "calling": [
                "coolant_stop"
            ],
            "imported": false,
            "current_name": "do_nothing_080001d4"
        },
        "FUN_08001ddc": {
            "renaming": {
                "FUN_08001ddc": "run_cnc_machine_08001ddc",
                "serial_init": "initialize_serial_communication",
                "settings_init": "initialize_settings",
                "st_init": "initialize_stepper_motors",
                "PTR_sys_08001e90": "sys_status",
                "memset": "memset",
                "PTR_settings_08001e94": "settings",
                "serial_reset_read_buffer": "reset_serial_read_buffer",
                "plan_init": "initialize_motion_planner",
                "gc_init": "initialize_gcode_interpreter",
                "protocol_init": "initialize_protocol",
                "spindle_init": "initialize_spindle",
                "coolant_init": "initialize_coolant_system",
                "limits_init": "initialize_limit_switches",
                "st_reset": "reset_stepper_motors",
                "sys_sync_current_position": "sync_current_position",
                "protocol_execute_startup": "execute_startup_protocol",
                "protocol_execute_runtime": "execute_runtime_protocol",
                "protocol_process": "process_protocol"
            },
            "code": "int run_cnc_machine_08001ddc(void)\n{\n  initialize_serial_communication();\n  initialize_PTR_settings_08001e94();\n  initialize_stepper_motors();\n  memset(PTR_sys_08001e90,0,sizeof(PTR_sys_08001e90));\n  PTR_sys_08001e90[0] = 1;\n  PTR_sys_08001e90[1] = 1;\n  do {\n    if (PTR_sys_08001e90[0] != 0) {\n      reset_serial_read_buffer();\n      initialize_motion_planner();\n      initialize_gcode_interpreter();\n      initialize_spindle();\n      initialize_coolant_system();\n      initialize_limit_switches();\n      reset_stepper_motors();\n      sync_current_position();\n      PTR_sys_08001e90[0] = 0;\n      PTR_sys_08001e90[2] = 0;\n      if ((PTR_settings_08001e94[0x28] & 2) != 0) {\n        PTR_sys_08001e90[0x10] = 1;\n      }\n      if ((PTR_sys_08001e90[1] == 1) && ((PTR_settings_08001e94[0x28] & 0x10) != 0)) {\n        PTR_sys_08001e90[1] = 6;\n      }\n      if (PTR_sys_08001e90[1] == 6) {\n        report_feedback_message('\\x02');\n      }\n      else {\n        PTR_sys_08001e90[1] = 0;\n        execute_startup_protocol();\n      }\n    }\n    execute_runtime_protocol();\n    process_protocol();\n  } while( true );\n}",
            "called": [
                "sys_sync_current_position",
                "report_feedback_message",
                "coolant_init",
                "spindle_init",
                "memset",
                "gc_init",
                "st_init",
                "protocol_execute_startup",
                "serial_init",
                "protocol_execute_runtime",
                "protocol_init",
                "limits_init",
                "serial_reset_read_buffer",
                "plan_init",
                "protocol_process",
                "st_reset",
                "settings_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001ddc",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "run_cnc_machine_08001ddc"
        },
        "FUN_080069b4": {
            "renaming": {
                "FUN_080069b4": "set_irq_priority_080069b4",
                "IRQn": "irq",
                "DAT_080069e0": "irq_reg_base",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "void set_irq_priority_080069b4(IRQn_Type irq)\n{\n  int* irq_reg = (int*)(DAT_080069e0 + ((uint)(int)irq >> 5) * 4);\n  int irq_bit = 1 << (irq & 0x1fU);\n  *irq_reg = irq_bit;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080069b4",
            "calling": [
                "HAL_NVIC_EnableIRQ"
            ],
            "imported": false,
            "current_name": "set_irq_priority_080069b4"
        },
        "FUN_0800b4e4": {
            "renaming": {
                "FUN_0800b4e4": "register_exit_proc_0800b4e4",
                "__func": "func_ptr",
                "iVar1": "exit_proc_id"
            },
            "code": "int register_exit_proc_0800b4e4(__func *func_ptr)\n{\n  int exit_proc_id;\n  exit_proc_id = __register_exitproc(0, func_ptr, 0);\n  return exit_proc_id;\n}",
            "called": [
                "__register_exitproc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b4e4",
            "calling": [
                "register_fini"
            ],
            "imported": false,
            "current_name": "register_exit_proc_0800b4e4"
        },
        "FUN_08007720": {
            "renaming": {
                "FUN_08007720": "wait_forever_08007720"
            },
            "code": "void wait_forever_08007720(void)\n{\n  while(true)\n  {\n    // Do nothing\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007720",
            "calling": [],
            "imported": false,
            "current_name": "wait_forever_08007720"
        },
        "FUN_08009228": {
            "renaming": {
                "FUN_08009228": "is_end_of_string_08009228",
                "in_CY": "input_char"
            },
            "code": "bool is_end_of_string_08009228(void)\n{\n  char input_char;\n  __aeabi_cfcmpeq();\n  return input_char == '\\0';\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009228",
            "calling": [
                "planner_forward_pass_kernel",
                "planner_reverse_pass_kernel",
                "plan_buffer_line",
                "gc_execute_line",
                "printFloat",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "is_end_of_string_08009228"
        },
        "FUN_08007c7c": {
            "renaming": {
                "FUN_08007c7c": "process_tim_interrupts_08007c7c",
                "_DAT_40000010": "PTR_NVIC_ICER",
                "_DAT_4000000c": "PTR_NVIC_ISER",
                "TIMx": "tim_reg",
                "step_delay_isr": "process_delay_isr",
                "step_pulse_isr": "process_pulse_isr",
                "step_period_isr": "process_period_isr"
            },
            "code": "void process_tim_interrupts_08007c7c(void)\n{\n  TIM_TypeDef *tim_reg = PTR_TIM2;\n  if (((_DAT_4000000c & 2) != 0) && ((tim_reg->SR & 2) != 0)) {\n    _DAT_40000010 |= 2;\n    step_delay_isr();\n  }\n  if (((_DAT_4000000c & 4) != 0) && ((tim_reg->SR & 4) != 0)) {\n    _DAT_40000010 |= 4;\n    step_pulse_isr();\n  }\n  if (((_DAT_4000000c & 1) != 0) && ((tim_reg->SR & 1) != 0)) {\n    _DAT_40000010 |= 1;\n    step_period_isr();\n  }\n  return;\n}",
            "called": [
                "step_period_isr",
                "step_pulse_isr",
                "step_delay_isr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007c7c",
            "calling": [],
            "imported": false,
            "current_name": "process_tim_interrupts_08007c7c"
        },
        "FUN_08007726": {
            "renaming": {
                "FUN_08007726": "infinite_loop_08007726"
            },
            "code": "void infinite_loop_08007726(void)\n{\n  while( true ) {\n    // Do nothing\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007726",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_08007726"
        },
        "FUN_08007b70": {
            "renaming": {
                "FUN_08007b70": "enable_timer_08007b70",
                "TIMx": "timer",
                "enable": "enable",
                "_DAT_40000034": "timer->CR1",
                "_DAT_40000038": "timer->CR2",
                "_DAT_4000000c": "timer->DIER",
                "_DAT_40000000": "timer->CR1"
            },
            "code": "void enable_timer_08007b70(TIM_TypeDef *timer){\n  uint32_t enable = 1;\n  if (_DAT_40000034 != 0) {\n    enable = 3;\n  }\n  if (_DAT_40000038 != 0) {\n    enable |= 4;\n  }\n  _DAT_4000000c |= enable;\n  _DAT_40000034 |= 1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007b70",
            "calling": [
                "st_wake_up"
            ],
            "imported": false,
            "current_name": "enable_timer_08007b70"
        },
        "FUN_08004d2c": {
            "renaming": {
                "FUN_08004d2c": "readLineFromEEPROM_08004d2c",
                "n": "lineNumber",
                "line": "lineBuffer",
                "iVar1": "result",
                "addr": "address",
                "memcpy_from_eeprom_with_checksum": "memcpyFromEEPROMWithChecksum",
                "settings_store_startup_line": "storeStartupLine"
            },
            "code": "bool readLineFromEEPROM_08004d2c(uint8_t lineNumber, char *lineBuffer) {\n    uint16_t address = (uint16_t)(lineNumber * 0x101 + 0x300);\n    int result = memcpyFromEEPROMWithChecksum(lineBuffer, address, 0x100);\n    if (result == 0) {\n        *lineBuffer = '\\0';\n        storeStartupLine(lineNumber, lineBuffer);\n    }\n    return result != 0;\n}",
            "called": [
                "settings_store_startup_line",
                "memcpy_from_eeprom_with_checksum"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d2c",
            "calling": [
                "protocol_execute_line",
                "protocol_execute_startup"
            ],
            "imported": false,
            "current_name": "readLineFromEEPROM_08004d2c"
        },
        "FUN_08003004": {
            "renaming": {
                "FUN_08003004": "calculate_inverse_minute_08003004",
                "feed_rate": "feedRate",
                "invert_feed_rate": "invertFeedRate",
                "puVar1": "pointer1",
                "uVar2": "variable2",
                "uVar3": "variable3",
                "lVar4": "variable4",
                "lVar5": "variable5",
                "lVar6": "variable6",
                "uVar7": "variable7",
                "uVar8": "variable8",
                "uVar9": "variable9",
                "uVar10": "variable10",
                "fVar11": "variable11",
                "in_r1": "variable12",
                "extraout_r1": "extraOutput1",
                "extraout_r1_00": "extraOutput2",
                "extraout_r1_01": "extraOutput3",
                "extraout_r1_02": "extraOutput4",
                "extraout_r1_03": "extraOutput5",
                "extraout_r1_04": "extraOutput6",
                "in_r2": "variable13",
                "uVar12": "variable14",
                "in_r3": "variable15",
                "puVar13": "pointer2",
                "iVar14": "variable16",
                "uVar15": "variable17",
                "fVar16": "variable18",
                "extraout_d0": "extraOutput7",
                "extraout_d0_00": "extraOutput8",
                "extraout_d0_01": "extraOutput9",
                "extraout_d0_02": "extraOutput10",
                "extraout_d0_03": "extraOutput11",
                "extraout_d0_04": "extraOutput12",
                "extraout_s2": "extraOutput13",
                "extraout_s2_00": "extraOutput14",
                "extraout_s2_01": "extraOutput15",
                "extraout_s2_02": "extraOutput16",
                "extraout_s2_03": "extraOutput17",
                "extraout_s2_04": "extraOutput18",
                "uVar17": "variable19",
                "uVar18": "variable20",
                "uVar19": "variable21",
                "in_stack_00000000": "variable22",
                "unit_vec": "unitVector",
                "delta_mm": "deltaMillimeters",
                "v_allowable": "vAllowable",
                "sin_theta_d2": "sinThetaDiv2",
                "cos_theta": "cosTheta",
                "inverse_millimeters": "inverseMillimeters",
                "vmax_junction": "vmaxJunction",
                "inverse_minute": "inverseMinute"
            },
            "code": "\nvoid calculateInverseMinute_08003004(float x,float y,float z,float feedRate,uint8_t invertFeedRate)\n\n{\n  undefined *pointer1;\n  uint8_t variable2;\n  undefined4 variable3;\n  long variable4;\n  long variable5;\n  long variable6;\n  undefined4 variable7;\n  undefined4 variable8;\n  undefined4 variable9;\n  undefined4 variable10;\n  float variable11;\n  undefined4 variable12;\n  undefined4 extraOutput1;\n  undefined4 extraOutput2;\n  undefined4 extraOutput3;\n  undefined4 extraOutput4;\n  undefined4 extraOutput5;\n  undefined4 extraOutput6;\n  undefined4 variable13;\n  uint variable14;\n  undefined4 variable15;\n  ushort *pointer2;\n  int variable16;\n  uint variable17;\n  float variable18;\n  undefined8 extraOutput7;\n  undefined8 extraOutput8;\n  undefined8 extraOutput9;\n  undefined8 extraOutput10;\n  undefined8 extraOutput11;\n  undefined8 extraOutput12;\n  float extraOutput13;\n  float extraOutput14;\n  float extraOutput15;\n  float extraOutput16;\n  float extraOutput17;\n  float extraOutput18;\n  undefined8 variable19;\n  undefined8 variable20;\n  undefined8 variable21;\n  char variable22;\n  float unitVector [3];\n  float deltaMillimeters [3];\n  int32_t target [3];\n  float vAllowable;\n  float sinThetaDiv2;\n  float cosTheta;\n  float inverseMillimeters;\n  block_t *block;\n  float vmaxJunction;\n  float inverseMinute;\n  \n  pointer2 = (ushort *)\n            (PTR_block_buffer_08003234 + (uint)(byte)*PTR_block_buffer_head_08003230 * 0x40);\n  variable3 = __aeabi_fmul(x,*(undefined4 *)PTR_settings_08003238,invertFeedRate);\n  __aeabi_f2d(variable3);\n  variable4 = lround((double)CONCAT44(variable13,variable15));\n  variable3 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003238 + 4),variable12);\n  __aeabi_f2d(variable3);\n  variable5 = lround((double)CONCAT44(variable13,variable15));\n  variable3 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003238 + 8),variable13);\n  __aeabi_f2d(variable3);\n  variable6 = lround((double)CONCAT44(variable13,variable15));\n  *pointer2 = 0;\n  if (variable4 < *(int *)PTR_pl_0800323c) {\n    *pointer2 = *pointer2 | 0x20;\n  }\n  if (variable5 < *(int *)(PTR_pl_0800323c + 4)) {\n    *pointer2 = *pointer2 | 0x880;\n  }\n  if (variable6 < *(int *)(PTR_pl_0800323c + 8)) {\n    *pointer2 = *pointer2 | 0x200;\n  }\n  variable16 = variable4 - *(int *)PTR_pl_0800323c;\n  if (variable16 < 0) {\n    variable16 = -variable16;\n  }\n  *(int *)(pointer2 + 2) = variable16;\n  variable16 = variable5 - *(int *)(PTR_pl_0800323c + 4);\n  if (variable16 < 0) {\n    variable16 = -variable16;\n  }\n  *(int *)(pointer2 + 4) = variable16;\n  variable16 = variable6 - *(int *)(PTR_pl_0800323c + 8);\n  if (variable16 < 0) {\n    variable16 = -variable16;\n  }\n  *(int *)(pointer2 + 6) = variable16;\n  variable14 = *(uint *)(pointer2 + 6);\n  if (*(uint *)(pointer2 + 6) < *(uint *)(pointer2 + 4)) {\n    variable14 = *(uint *)(pointer2 + 4);\n  }\n  variable17 = *(uint *)(pointer2 + 2);\n  if (*(uint *)(pointer2 + 2) < variable14) {\n    variable17 = variable14;\n  }\n  *(uint *)(pointer2 + 8) = variable17;\n  if (*(int *)(pointer2 + 8) != 0) {\n    variable3 = __floatsisf(variable4 - *(int *)PTR_pl_0800323c);\n    variable3 = __aeabi_fdiv(variable3,*(undefined4 *)PTR_settings_08003238);\n    variable7 = __floatsisf(variable5 - *(int *)(PTR_pl_0800323c + 4));\n    variable7 = __aeabi_fdiv(variable7,*(undefined4 *)(PTR_settings_08003238 + 4));\n    variable8 = __floatsisf(variable6 - *(int *)(PTR_pl_0800323c + 8));\n    variable8 = __aeabi_fdiv(variable8,*(undefined4 *)(PTR_settings_08003238 + 8));\n    variable9 = __aeabi_fmul(variable3,variable3);\n    variable10 = __aeabi_fmul(variable7,variable7);\n    variable9 = __addsf3(variable9,variable10);\n    variable10 = __aeabi_fmul(variable8,variable8);\n    variable9 = __addsf3(variable9,variable10);\n    variable9 = __aeabi_f2d(variable9);\n    sqrt((double)CONCAT44(variable13,variable15));\n    variable9 = __truncdfsf2(variable9,extraOutput1);\n    *(undefined4 *)(pointer2 + 0x10) = variable9;\n    variable9 = __aeabi_fdiv(0x3f800000,*(undefined4 *)(pointer2 + 0x10));\n    if (variable22 == '\\0') {\n      inverseMinute = (float)__aeabi_fmul(variable15,variable9);\n    }\n    else {\n      inverseMinute = (float)__aeabi_fdiv(0x3f800000,variable15);\n    }\n    variable10 = __aeabi_fmul(*(undefined4 *)(pointer2 + 0x10),inverseMinute);\n    *(undefined4 *)(pointer2 + 10) = variable10;\n    variable10 = __floatsisf(*(undefined4 *)(pointer2 + 8));\n    variable10 = __aeabi_fmul(variable10,inverseMinute);\n    variable10 = __aeabi_f2d(variable10);\n    ceil((double)CONCAT44(variable13,variable15));\n    variable10 = __aeabi_d2uiz(variable10,extraOutput2);\n    *(undefined4 *)(pointer2 + 0x1e) = variable10;\n    variable10 = __floatsisf(*(undefined4 *)(pointer2 + 8));\n    variable10 = __aeabi_fmul(variable10,variable9);\n    variable10 = __aeabi_fmul(variable10,*(undefined4 *)(PTR_settings_08003560 + 0x20));\n    variable10 = __aeabi_fdiv(variable10,DAT_08003564);\n    variable10 = __aeabi_f2d(variable10);\n    ceil((double)CONCAT44(variable13,variable15));\n    variable10 = __aeabi_d2iz(variable10,extraOutput3);\n    *(undefined4 *)(pointer2 + 0x18) = variable10;\n    variable3 = __aeabi_fmul(variable3,variable9);\n    variable7 = __aeabi_fmul(variable7,variable9);\n    variable8 = __aeabi_fmul(variable8,variable9);\n    vmaxJunction = 0.0;\n    variable19 = extraOutput7;\n    variable18 = extraOutput13;\n    if ((*PTR_block_buffer_head_08003568 != *PTR_block_buffer_tail_0800356c) &&\n       (variable16 = __aeabi_fcmpgt(*(undefined4 *)(PTR_pl_08003570 + 0x18),0), variable19 = extraOutput8,\n       variable18 = extraOutput14, variable16 != 0)) {\n      variable9 = __aeabi_fmul(*(uint *)(PTR_pl_08003570 + 0xc) ^ 0x80000000,variable3);\n      variable10 = __aeabi_fmul(*(undefined4 *)(PTR_pl_08003570 + 0x10),variable7);\n      variable9 = __aeabi_fsub(variable9,variable10);\n      variable10 = __aeabi_fmul(*(undefined4 *)(PTR_pl_08003570 + 0x14),variable8);\n      variable9 = __aeabi_fsub(variable9,variable10);\n      variable19 = __aeabi_f2d(variable9);\n      variable16 = __aeabi_dcmplt((int)variable19,(int)((ulonglong)variable19 >> 0x20),DAT_08003550,DAT_08003554\n                             );\n      variable19 = extraOutput9;\n      variable18 = extraOutput15;\n      if (variable16 != 0) {\n        variable16 = __aeabi_fcmplt(*(undefined4 *)(PTR_pl_08003570 + 0x18),\n                                *(undefined4 *)(pointer2 + 10));\n        if (variable16 == 0) {\n          vmaxJunction = *(float *)(pointer2 + 10);\n        }\n        else {\n          vmaxJunction = *(float *)(PTR_pl_08003570 + 0x18);\n        }\n        variable19 = __aeabi_f2d(variable9);\n        variable16 = __aeabi_dcmpgt((int)variable19,(int)((ulonglong)variable19 >> 0x20),DAT_08003558,\n                                DAT_0800355c);\n        variable19 = extraOutput10;\n        variable18 = extraOutput16;\n        if (variable16 != 0) {\n          variable19 = __aeabi_f2d(variable9);\n          variable19 = __subdf3(0,DAT_08003574,(int)variable19,(int)((ulonglong)variable19 >> 0x20));\n          variable9 = __muldf3((int)variable19,(int)((ulonglong)variable19 >> 0x20),0,DAT_08003578);\n          sqrt((double)CONCAT44(variable13,variable15));\n          variable9 = __truncdfsf2(variable9,extraOutput4);\n          variable19 = __aeabi_f2d(vmaxJunction);\n          variable10 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003560 + 0x20),\n                                *(undefined4 *)(PTR_settings_08003560 + 0x24));\n          variable10 = __aeabi_fmul(variable10,variable9);\n          variable20 = __aeabi_f2d(variable10);\n          variable21 = __aeabi_f2d(variable9);\n          variable21 = __subdf3(0,DAT_08003574,(int)variable21,(int)((ulonglong)variable21 >> 0x20));\n          variable10 = __divdf3((int)variable20,(int)((ulonglong)variable20 >> 0x20),(int)variable21,\n                            (int)((ulonglong)variable21 >> 0x20));\n          sqrt((double)CONCAT44(variable13,variable15));\n          variable16 = __aeabi_dcmplt((int)variable19,(int)((ulonglong)variable19 >> 0x20),variable10,extraOutput5\n                                 );\n          variable19 = extraOutput11;\n          variable18 = extraOutput17;\n          if (variable16 == 0) {\n            variable10 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003560 + 0x20),\n                                  *(undefined4 *)(PTR_settings_08003560 + 0x24));\n            variable10 = __aeabi_fmul(variable10,variable9);\n            variable19 = __aeabi_f2d(variable10);\n            variable20 = __aeabi_f2d(variable9);\n            variable20 = __subdf3(0,DAT_08003574,(int)variable20,(int)((ulonglong)variable20 >> 0x20));\n            variable9 = __divdf3((int)variable19,(int)((ulonglong)variable19 >> 0x20),(int)variable20,\n                             (int)((ulonglong)variable20 >> 0x20));\n            sqrt((double)CONCAT44(variable13,variable15));\n            vmaxJunction = (float)__truncdfsf2(variable9,extraOutput6);\n            variable19 = extraOutput12;\n            variable18 = extraOutput18;\n          }\n        }\n      }\n    }\n    *(float *)(pointer2 + 0xe) = vmaxJunction;\n    variable11 = (float)(*(uint *)(PTR_settings_08003560 + 0x20) ^ 0x80000000);\n    max_allowable_speed((float)variable19,(float)((ulonglong)variable19 >> 0x20),variable18);\n    variable16 = __aeabi_fcmplt(vmaxJunction,variable11);\n    variable18 = variable11;\n    if (variable16 != 0) {\n      variable18 = vmaxJunction;\n    }\n    *(float *)(pointer2 + 0xc) = variable18;\n    variable16 = __aeabi_fcmpge(variable11,*(undefined4 *)(pointer2 + 10));\n    if (variable16 == 0) {\n      *(undefined *)((int)pointer2 + 0x25) = 0;\n    }\n    else {\n      *(undefined *)((int)pointer2 + 0x25) = 1;\n    }\n    *(undefined *)(pointer2 + 0x12) = 1;\n    pointer1 = PTR_pl_080035e0;\n    *(undefined4 *)(PTR_pl_080035e0 + 0xc) = variable3;\n    *(undefined4 *)(pointer1 + 0x10) = variable7;\n    *(undefined4 *)(pointer1 + 0x14) = variable8;\n    *(undefined4 *)(PTR_pl_080035e0 + 0x18) = *(undefined4 *)(pointer2 + 10);\n    *PTR_block_buffer_head_080035e8 = *PTR_next_buffer_head_080035e4;\n    variable2 = next_block_index(*PTR_block_buffer_head_080035e8);\n    *PTR_next_buffer_head_080035e4 = variable2;\n    pointer1 = PTR_pl_080035e0;\n    *(long *)PTR_pl_080035e0 = variable4;\n    *(long *)(pointer1 + 4) = variable5;\n    *(long *)(pointer1 + 8) = variable6;\n    planner_recalculate();\n  }\n  return;\n}\n\n",
            "called": [
                "planner_recalculate",
                "__aeabi_fcmpge",
                "ceil",
                "lround",
                "__truncdfsf2",
                "__aeabi_fsub",
                "__muldf3",
                "__aeabi_d2iz",
                "__aeabi_fdiv",
                "max_allowable_speed",
                "__subdf3",
                "__aeabi_fcmpgt",
                "__addsf3",
                "sqrt",
                "__aeabi_dcmplt",
                "__aeabi_dcmpgt",
                "__aeabi_fmul",
                "next_block_index",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "__aeabi_fcmplt",
                "__floatsisf",
                "__divdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003004",
            "calling": [
                "mc_line"
            ],
            "imported": false,
            "current_name": "calculate_inverse_minute_08003004"
        },
        "FUN_080066cc": {
            "renaming": {
                "FUN_080066cc": "get_HCLK_freq_divider_080066cc",
                "uVar1": "HCLK_freq",
                "uVar2": "leading_zeroes",
                "PTR_APBAHBPrescTable_08006714": "APBAHB_presc_table",
                "DAT_08006710": "DAT_08006710_ptr",
                "result": "unused_result",
                "result_1": "unused_result_1"
            },
            "code": "uint32_t get_HCLK_freq_divider_080066cc(void)\n{\n  uint32_t HCLK_freq = HAL_RCC_GetHCLKFreq();\n  uint leading_zeroes = count_leading_zeroes(0x70000);\n  uint32_t* PTR_APBAHBPrescTable_08006714 = PTR_APBAHBPrescTable_08006714;\n  uint32_t* DAT_08006710 = (uint32_t*)DAT_08006710;\n  uint32_t APBAHB_presc = (*(DAT_08006710 + 8) & 0xe000) >> (leading_zeroes & 0xff);\n  return HCLK_freq >> PTR_APBAHBPrescTable_08006714[APBAHB_presc];\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080066cc",
            "calling": [
                "set_baud_rate"
            ],
            "imported": false,
            "current_name": "get_HCLK_freq_divider_080066cc"
        },
        "FUN_080018fc": {
            "renaming": {
                "FUN_080018fc": "set_bits_080018fc",
                "x": "input",
                "*(uint32_t *)(DAT_08001928 + 0x14)": "ptr",
                "*(uint *)(DAT_08001928 + 0x14)": "current_value",
                "0xfffff55f": "mask",
                "x | *(uint *)(DAT_08001928 + 0x14) & 0xfffff55f": "new_value"
            },
            "code": "void set_bits_080018fc(uint32_t input) \n{\n  uint32_t* *(uint32_t *)(DAT_08001928 + 0x14) = (uint32_t *)(DAT_08001928 + 0x14);\n  uint32_t mask = 0xfffff55f;\n  uint32_t *(uint *)(DAT_08001928 + 0x14) = *(uint *)(DAT_08001928 + 0x14);\n  uint32_t x | *(uint *)(DAT_08001928 + 0x14) & 0xfffff55f = (input | (*(uint *)(DAT_08001928 + 0x14) & mask));\n  **(uint32_t *)(DAT_08001928 + 0x14) = x | *(uint *)(DAT_08001928 + 0x14) & 0xfffff55f;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080018fc",
            "calling": [
                "homing_cycle"
            ],
            "imported": false,
            "current_name": "set_bits_080018fc"
        },
        "FUN_080039bc": {
            "renaming": {
                "FUN_080039bc": "read_and_execute_startup_lines_080039bc",
                "uVar1": "read_result",
                "n": "line_number",
                "PTR_line_08003a14": "startup_line",
                "settings_read_startup_line": "settings_read_startup_line",
                "report_status_message": "report_status_message",
                "printString": "printString",
                "gc_execute_line": "execute_startup_line"
            },
            "code": "void read_and_execute_startup_lines_080039bc(void)\n{\n  uint8_t read_result;\n  uint8_t line_number;\n\n  for (line_number = 0; line_number < 2; line_number++) {\n    read_result = settings_read_PTR_line_08003a14(line_number, PTR_line_08003a14);\n    if (read_result == 0) {\n      report_status_message('\\n');\n    }\n    else if (*PTR_line_08003a14 != 0) {\n      printString(PTR_line_08003a14);\n      read_result = execute_PTR_line_08003a14(PTR_line_08003a14);\n      report_status_message(read_result);\n    }\n  }\n  return;\n}",
            "called": [
                "printString",
                "report_status_message",
                "settings_read_startup_line",
                "gc_execute_line"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080039bc",
            "calling": [
                "protocol_execute_line",
                "grbl_main"
            ],
            "imported": false,
            "current_name": "read_and_execute_startup_lines_080039bc"
        },
        "FUN_0800618c": {
            "renaming": {
                "FUN_0800618c": "configureClocks_0800618c",
                "RCC_ClkInitStruct": "clkInitStruct",
                "FLatency": "latency",
                "DAT_08006400": "RCC_CFGR",
                "DAT_08006404": "RCC_CR",
                "HAL_GetTick": "HAL_GetTick()",
                "RCC_ClkInitStruct->ClockType": "clkInitStruct->ClockType",
                "RCC_ClkInitStruct->SYSCLKSource": "clkInitStruct->SYSCLKSource",
                "HAL_RCC_GetHCLKFreq()": "__HAL_RCC_GET_HCLK_FREQ()",
                "SysTick_Config": "__HAL_RCC_SYSTICK_CONFIG()",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_TIMEOUT": "HAL_TIMEOUT",
                "CLOCKSWITCH_TIMEOUT_VALUE": "CLOCKSWITCH_TIMEOUT_VALUE"
            },
            "code": "HAL_StatusTypeDef configureClocks_0800618c(RCC_ClkInitTypeDef *clkInitStruct, uint32_t latency)\n{\n  uint32_t tickStart;\n\n  if ((*DAT_08006400 & 0xF) < latency)\n  {\n    *DAT_08006400 &= 0xFFFFFFF0U;\n    *DAT_08006400 |= latency & 0xFU;\n    if ((*DAT_08006400 & 0xF) != latency)\n    {\n      return HAL_ERROR;\n    }\n    tickStart = HAL_GetTick();\n    if (clkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)\n    {\n      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)\n      {\n        if ((HAL_GetTick() - tickStart) > CLOCKSWITCH_TIMEOUT_VALUE)\n        {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else\n    {\n      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)\n      {\n        if ((HAL_GetTick() - tickStart) > CLOCKSWITCH_TIMEOUT_VALUE)\n        {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  __HAL_RCC_HCLK_CONFIG(clkInitStruct->AHBCLKDivider);\n  __HAL_RCC_PCLK1_CONFIG(clkInitStruct->APB1CLKDivider);\n  __HAL_RCC_PCLK2_CONFIG(clkInitStruct->APB2CLKDivider);\n  return HAL_OK;\n}",
            "called": [
                "HAL_GetTick",
                "SysTick_Config",
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800618c",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configureClocks_0800618c"
        },
        "FUN_08006998": {
            "renaming": {
                "FUN_08006998": "getBitsFromData_08006998",
                "DAT_080069b0": "PTR_data"
            },
            "code": "uint32_t getBitsFromData_08006998(void)\n{\n  uint32_t data = *(uint *)(DAT_080069b0 + 0xc);\n  uint32_t bits = (data >> 8) & 7;\n  return bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006998",
            "calling": [
                "HAL_NVIC_GetPriorityGrouping",
                "HAL_NVIC_SetPriority"
            ],
            "imported": false,
            "current_name": "getBitsFromData_08006998"
        },
        "FUN_080004ac": {
            "renaming": {
                "FUN_080004ac": "initialize_gc_plane_080004ac",
                "PTR_gc_080004f0": "gc_plane",
                "PTR_settings_080004f4": "settings",
                "select_plane": "select_plane",
                "settings_read_coord_data": "read_coord_data",
                "DAT_080004f8": "data",
                "uVar1": "coord_data_status",
                "report_status_message": "print_status_message"
            },
            "code": "void initialize_gc_plane_080004ac(void)\n{\n    uint8_t coord_DAT_080004f8_status;\n    memset(PTR_gc_080004f0, 0, sizeof(PTR_gc_080004f0));\n    *(undefined4 *)(PTR_gc_080004f0 + 8) = *(undefined4 *)(PTR_settings_080004f4 + 0x10);\n    select_plane(0, 1, 2);\n    PTR_gc_080004f0[4] = 1;\n    coord_DAT_080004f8_status = read_coord_DAT_080004f8(PTR_gc_080004f0[0x1c], DAT_080004f8);\n    if (coord_DAT_080004f8_status == 0)\n    {\n        print_status_message('\\n');\n    }\n}",
            "called": [
                "settings_read_coord_data",
                "memset",
                "report_status_message",
                "select_plane"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004ac",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "initialize_gc_plane_080004ac"
        },
        "FUN_080078f4": {
            "renaming": {
                "FUN_080078f4": "calculate_state_080078f4",
                "i": "index",
                "state": "state",
                "PTR_debounce_0800792c": "PTR_debounce_0800792c"
            },
            "code": "uint32_t calculate_state_080078f4(void)\n{\n  int index;\n  uint32_t state = 0;\n  for (index = 0; index < 4; index++) {\n    state |= *(uint *)(PTR_debounce_0800792c + index * 4);\n  }\n  return state;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078f4",
            "calling": [
                "homing_cycle",
                "debounce_isr"
            ],
            "imported": false,
            "current_name": "calculate_state_080078f4"
        },
        "FUN_080041a0": {
            "renaming": {
                "FUN_080041a0": "printMessage_080041a0",
                "message_code": "messageCode",
                "PTR_DAT_0800420c": "messageHeader",
                "PTR_s_Reset_to_continue_08004210": "resetMessage",
                "PTR_s___H____X__to_unlock_08004214": "unlockMessage",
                "PTR_s_Caution__Unlocked_08004218": "cautionMessage",
                "PTR_s_Enabled_0800421c": "enabledMessage",
                "PTR_s_Disabled_08004220": "disabledMessage",
                "PTR_DAT_08004224": "messageFooter"
            },
            "code": "void printMessage_080041a0(uint8_t messageCode) {\n  printPgmString(PTR_DAT_0800420c);\n  switch(messageCode) {\n    case RESET:\n      printPgmString(PTR_s_Reset_to_continue_08004210);\n      break;\n    case UNLOCK:\n      printPgmString(PTR_s___H____X__to_unlock_08004214);\n      break;\n    case CAUTION:\n      printPgmString(PTR_s_Caution__Unlocked_08004218);\n      break;\n    case ENABLED:\n      printPgmString(PTR_s_Enabled_0800421c);\n      break;\n    case DISABLED:\n      printPgmString(PTR_s_Disabled_08004220);\n      break;\n  }\n  printPgmString(PTR_DAT_08004224);\n  return;\n}",
            "called": [
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041a0",
            "calling": [
                "protocol_execute_line",
                "grbl_main",
                "protocol_execute_runtime"
            ],
            "imported": false,
            "current_name": "printMessage_080041a0"
        },
        "FUN_08008bf0": {
            "renaming": {
                "FUN_08008bf0": "calculate_shift_amount_08008bf0",
                "param_1": "numerator",
                "param_2": "denominator",
                "iVar1": "intermediate_value",
                "uVar2": "shifted_numerator"
            },
            "code": "uint calculate_shift_amount_08008bf0(uint numerator,uint denominator)\n{\n  int intermediate_value;\n  uint shifted_numerator;\n  \n  if ((denominator & 0x80000000) != 0) {\n    return 0;\n  }\n  intermediate_value = denominator * 2 + 0x200000;\n  if (denominator * 2 < 0xffe00000) {\n    if (-1 < intermediate_value) {\n      return 0;\n    }\n    shifted_numerator = -(intermediate_value >> 0x15) - 0x3e1;\n    if (-1 < (int)shifted_numerator) {\n      return (denominator << 0xb | 0x80000000 | numerator >> 0x15) >> (shifted_numerator & 0xff);\n    }\n  }\n  else if ((numerator | denominator << 0xc) != 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008bf0",
            "calling": [
                "calculate_trapezoid_for_block",
                "protocol_execute_line",
                "homing_cycle",
                "mc_arc",
                "plan_buffer_line",
                "mc_dwell",
                "gc_execute_line",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "calculate_shift_amount_08008bf0"
        },
        "FUN_0800771a": {
            "renaming": {
                "FUN_0800771a": "infinite_loop_0800771a"
            },
            "code": "void infinite_loop_0800771a(void)\n{\n  while(true) {\n    // Do nothing\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800771a",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_0800771a"
        },
        "FUN_08003a18": {
            "renaming": {
                "FUN_08003a18": "check_button_press_08003a18",
                "buttons": "button_state",
                "PTR_sys_08003a70": "button_state",
                "|=": "|=",
                "&": "&",
                "mc_reset": "mc_reset"
            },
            "code": "void check_button_press_08003a18(uint32_t buttons)\n{\n    if (!(buttons & 0x80)) {\n        if (!(buttons & 0x40)) {\n            if (buttons & 0x20) {\n                PTR_sys_08003a70[2] |= 2;\n            }\n        }\n        else {\n            PTR_sys_08003a70[2] |= 8;\n        }\n    }\n    else {\n        mc_reset();\n    }\n    return;\n}",
            "called": [
                "mc_reset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a18",
            "calling": [
                "debounce_on_handler"
            ],
            "imported": false,
            "current_name": "check_button_press_08003a18"
        },
        "FUN_08005790": {
            "renaming": {
                "FUN_08005790": "enable_stepper_motor_if_mode_is_three_08005790",
                "PTR_sys_080057d4": "mode_ptr",
                "PTR_step_bits_080057dc": "step_bits_ptr",
                "PTR_settings_080057d8": "settings_ptr",
                "PTR_dirn_bits_080057e0": "dirn_bits_ptr",
                "set_step_pulse_delay": "set_step_pulse_delay",
                "set_step_pulse_time": "set_step_pulse_time",
                "step_isr_enable": "enable_step_isr"
            },
            "code": "void enable_stepper_motor_if_mode_is_three_08005790() {\n  enable_stepper_motor();\n  if (PTR_sys_080057d4[1] == '\\x03') {\n    *(undefined2 *)PTR_step_bits_080057dc = *(undefined2 *)(PTR_settings_080057d8 + 0x18);\n    *(undefined2 *)PTR_dirn_bits_080057e0 = *(undefined2 *)(PTR_settings_080057d8 + 0x1a);\n    set_step_pulse_delay(0x69);\n    set_step_pulse_time(((byte)PTR_settings_080057d8[0xd] + 5) * 0x15);\n    enable_step_isr();\n  }\n  return;\n}",
            "called": [
                "set_step_pulse_time",
                "stepper_motor_enable",
                "step_isr_enable",
                "set_step_pulse_delay"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005790",
            "calling": [
                "limits_go_home",
                "st_init",
                "st_cycle_start"
            ],
            "imported": false,
            "current_name": "enable_stepper_motor_if_mode_is_three_08005790"
        },
        "FUN_08007732": {
            "renaming": {
                "FUN_08007732": "do_nothing_08007732"
            },
            "code": "\nvoid do_nothing_08007732(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007732",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08007732"
        },
        "FUN_08001994": {
            "renaming": {
                "FUN_08001994": "stepper_motor_control_08001994",
                "cycle_mask": "step_mask",
                "pos_dir": "direction",
                "invert_pin": "is_inverted",
                "homing_rate": "homing_speed",
                "uVar1": "step_mode",
                "uVar2": "step_delay_float",
                "uVar3": "step_delay",
                "iVar4": "step_rate",
                "uVar5": "min_step_time",
                "extraout_r1": "unused_variable",
                "extraout_r1_00": "unused_variable",
                "extraout_r1_01": "unused_variable",
                "uVar6": "unused_variable",
                "uVar7": "unused_variable",
                "uVar8": "unused_variable",
                "in_r3": "unused_variable",
                "in_stack_ffffff9c": "unused_variable",
                "cVar9": "is_not_inverted",
                "steps": "step_sizes",
                "step_bits0": "unused_variable",
                "dt_min": "unused_variable",
                "delta_rate": "unused_variable",
                "ds": "unused_variable",
                "step_event_count": "unused_variable",
                "limit_state": "limit_switch_state",
                "step_bits": "current_step_bits",
                "trap_counter": "trap_count",
                "step_rate": "current_step_rate",
                "step_delay": "delay_between_steps",
                "counter_z": "step_counter_z",
                "counter_y": "step_counter_y",
                "counter_x": "step_counter_x",
                "dirn_bits": "direction_bits",
                "dt": "step_delay_min",
                "dist": "step_distance"
            },
            "code": "\nvoid stepper_motor_control_08001994(uint8_t step_mask,int8_t direction,_Bool is_inverted,float homing_speed)\n\n{\n  ushort step_mode;\n  undefined4 step_delay_float;\n  undefined4 step_delay;\n  int step_rate;\n  uint min_step_time;\n  undefined4 unused_variable;\n  undefined4 unused_variable;\n  undefined4 unused_variable;\n  uint32_t unused_variable;\n  undefined4 unused_variable;\n  uint32_t unused_variable;\n  undefined8 unused_variable;\n  undefined unused_variable;\n  char is_not_inverted;\n  uint32_t step_sizes [3];\n  uint16_t unused_variable;\n  uint32_t unused_variable;\n  uint32_t unused_variable;\n  float unused_variable;\n  uint32_t unused_variable;\n  uint32_t limit_switch_state;\n  uint16_t current_step_bits;\n  uint32_t trap_count;\n  uint32_t current_step_rate;\n  uint32_t delay_between_steps;\n  int32_t step_counter_z;\n  int32_t step_counter_y;\n  int32_t step_counter_x;\n  uint16_t direction_bits;\n  uint32_t step_delay_min;\n  uint8_t step_distance;\n  \n  is_not_inverted = !is_inverted;\n  memset(step_sizes,0,0xc);\n  step_distance = (step_mask & 1) != 0;\n  if ((bool)step_distance) {\n    __aeabi_f2d(*(undefined4 *)PTR_settings_08001c90);\n    step_sizes[0] = lround((double)CONCAT17(step_mask,\n                                       CONCAT16(direction,CONCAT15(is_not_inverted,CONCAT14(unused_variable,\n                                                                                unused_variable)))));\n  }\n  if ((step_mask & 2) != 0) {\n    step_distance = step_distance + '\\x01';\n    __aeabi_f2d(*(undefined4 *)(PTR_settings_08001c90 + 4));\n    step_sizes[1] = lround((double)CONCAT17(step_mask,\n                                       CONCAT16(direction,CONCAT15(is_not_inverted,CONCAT14(unused_variable,\n                                                                                unused_variable)))));\n  }\n  if ((step_mask & 4) != 0) {\n    step_distance = step_distance + '\\x01';\n    __aeabi_f2d(*(undefined4 *)(PTR_settings_08001c90 + 8));\n    step_sizes[2] = lround((double)CONCAT17(step_mask,\n                                       CONCAT16(direction,CONCAT15(is_not_inverted,CONCAT14(unused_variable,\n                                                                                unused_variable)))));\n  }\n  unused_variable = step_sizes[2];\n  if (step_sizes[2] < step_sizes[1]) {\n    unused_variable = step_sizes[1];\n  }\n  unused_variable = step_sizes[0];\n  if (step_sizes[0] < unused_variable) {\n    unused_variable = unused_variable;\n  }\n  unused_variable = __floatunsidf(unused_variable);\n  step_delay_float = __floatunsidf(step_distance);\n  sqrt((double)CONCAT17(step_mask,\n                        CONCAT16(direction,CONCAT15(is_not_inverted,CONCAT14(unused_variable,unused_variable)))));\n  unused_variable = __divdf3((int)unused_variable,(int)((ulonglong)unused_variable >> 0x20),step_delay_float,unused_variable);\n  step_delay_float = __truncdfsf2((int)unused_variable,(int)((ulonglong)unused_variable >> 0x20));\n  step_delay = __aeabi_fmul(*(undefined4 *)(PTR_settings_08001c90 + 0x20),step_delay_float);\n  step_delay = __aeabi_fdiv(step_delay,DAT_08001c94);\n  step_delay = __aeabi_f2d(step_delay);\n  ceil((double)CONCAT17(step_mask,\n                        CONCAT16(direction,CONCAT15(is_not_inverted,CONCAT14(unused_variable,unused_variable)))));\n  step_rate = __aeabi_d2uiz(step_delay,unused_variable);\n  step_delay = __floatunsidf(step_distance);\n  sqrt((double)CONCAT17(step_mask,\n                        CONCAT16(direction,CONCAT15(is_not_inverted,CONCAT14(unused_variable,unused_variable)))));\n  unused_variable = __aeabi_f2d(unused_variable);\n  unused_variable = __muldf3(step_delay,unused_variable,(int)unused_variable,(int)((ulonglong)unused_variable >> 0x20));\n  step_delay = __truncdfsf2((int)unused_variable,(int)((ulonglong)unused_variable >> 0x20));\n  step_delay_float = __aeabi_fmul(step_delay_float,step_delay);\n  step_delay_float = __aeabi_fdiv(DAT_08001c98,step_delay_float);\n  __aeabi_f2d(step_delay_float);\n  min_step_time = lround((double)CONCAT17(step_mask,\n                                  CONCAT16(direction,CONCAT15(is_not_inverted,CONCAT14(unused_variable,step_delay))\n                                          )));\n  step_delay_min = DAT_08001c9c;\n  if (min_step_time < DAT_08001c9c) {\n    step_delay_min = min_step_time;\n  }\n  step_mode = *(ushort *)(PTR_settings_08001c90 + 0x18);\n  direction_bits = *(ushort *)(PTR_settings_08001c90 + 0x1a) ^\n              *(ushort *)(PTR_settings_08001c90 + 0x2a) & 0xaa0;\n  if (direction == '\\0') {\n    direction_bits = direction_bits ^ 0xaa0;\n  }\n  dirn_wr((uint)direction_bits);\n  step_wr((uint)step_mode);\n  step_counter_z = -(unused_variable >> 1);\n  delay_between_steps = step_delay_min - (byte)PTR_settings_08001c90[0xd];\n  current_step_rate = 0;\n  trap_count = 10000;\n  step_counter_y = step_counter_z;\n  step_counter_x = step_counter_z;\n  while( true ) {\n    limit_switch_state = debounce_rd();\n    if (is_not_inverted != '\\0') {\n      limit_switch_state = limit_switch_state ^ 0x1e;\n    }\n    current_step_bits = step_mode;\n    if (((step_mask & 1) != 0) && (step_counter_x = step_counter_x + step_sizes[0], 0 < step_counter_x)) {\n      if ((limit_switch_state & 0x10) == 0) {\n        step_mask = step_mask & 0xfe;\n      }\n      else {\n        current_step_bits = step_mode ^ 0x10;\n      }\n      step_counter_x = step_counter_x - unused_variable;\n    }\n    if (((step_mask & 2) != 0) && (step_counter_y = step_counter_y + step_sizes[1], 0 < step_counter_y)) {\n      if ((limit_switch_state & 8) == 0) {\n        step_mask = step_mask & 0xfd;\n      }\n      else {\n        current_step_bits = current_step_bits ^ 0x440;\n      }\n      step_counter_y = step_counter_y - unused_variable;\n    }\n    if (((step_mask & 4) != 0) && (step_counter_z = step_counter_z + step_sizes[2], 0 < step_counter_z)) {\n      if ((limit_switch_state & 4) == 0) {\n        step_mask = step_mask & 0xfb;\n      }\n      else {\n        current_step_bits = current_step_bits ^ 0x100;\n      }\n      step_counter_z = step_counter_z - unused_variable;\n    }\n    if ((step_mask == 0) || ((PTR_sys_08001d40[2] & 0x10) != 0)) break;\n    step_wr((uint)current_step_bits);\n    delay_us((uint)(byte)PTR_settings_08001d44[0xd]);\n    step_wr((uint)step_mode);\n    delay_us(delay_between_steps);\n    if ((min_step_time < step_delay_min) && (trap_count = step_delay_min + trap_count, 20000 < trap_count)) {\n      trap_count = trap_count - 20000;\n      current_step_rate = step_rate + current_step_rate;\n      step_delay_min = DAT_08001d48 / current_step_rate;\n      if (DAT_08001d48 / current_step_rate < min_step_time) {\n        step_delay_min = min_step_time;\n      }\n      delay_between_steps = step_delay_min - (byte)PTR_settings_08001d44[0xd];\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "__floatunsidf",
                "memset",
                "dirn_wr",
                "ceil",
                "lround",
                "__truncdfsf2",
                "step_wr",
                "__muldf3",
                "__aeabi_fdiv",
                "delay_us",
                "debounce_rd",
                "sqrt",
                "__aeabi_fmul",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "__divdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001994",
            "calling": [
                "limits_go_home"
            ],
            "imported": false,
            "current_name": "stepper_motor_control_08001994"
        },
        "FUN_08007854": {
            "renaming": {
                "FUN_08007854": "get_bit_at_position_08007854",
                "n": "num",
                "*(uint *)((n >> 4) * 0x400 + 0x40020010)": "*(uint32_t*)((num >> 4) * 0x400 + 0x40020010)",
                "n & 0xfU": "pos & 0xfU",
                "return *(uint *)((n >> 4) * 0x400 + 0x40020010) >> (n & 0xfU) & 1;": "return value;"
            },
            "code": "int get_bit_at_position_08007854(uint32_t num, uint32_t pos) {\n    uint32_t* ptr = (uint32_t*)((num >> 4) * 0x400 + 0x40020010);\n    uint32_t value = *ptr >> (pos & 0xfU) & 1;\n    return value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007854",
            "calling": [
                "debounce_input"
            ],
            "imported": false,
            "current_name": "get_bit_at_position_08007854"
        },
        "FUN_08004900": {
            "renaming": {
                "FUN_08004900": "printLineWithNumber_08004900",
                "n": "lineNumber",
                "line": "line",
                "PTR_DAT_08004934": "PTR_LINE_NUMBER_LABEL",
                "PTR_DAT_08004938": "PTR_LINE_CONTENT_LABEL",
                "PTR_DAT_0800493c": "PTR_LINE_END_LABEL"
            },
            "code": "void printLineWithNumber_08004900(uint8_t lineNumber, char *line)\n{\n  printPgmString(PTR_DAT_08004934);\n  printInteger((uint)lineNumber);\n  printPgmString(PTR_DAT_08004938);\n  printString(line);\n  printPgmString(PTR_DAT_0800493c);\n  return;\n}",
            "called": [
                "printInteger",
                "printString",
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004900",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "printLineWithNumber_08004900"
        },
        "FUN_08005318": {
            "renaming": {
                "FUN_08005318": "do_nothing_08005318"
            },
            "code": "\nvoid do_nothing_08005318(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005318",
            "calling": [
                "st_wake_up"
            ],
            "imported": false,
            "current_name": "do_nothing_08005318"
        },
        "FUN_08004228": {
            "renaming": {
                "FUN_08004228": "printHelpMessage_08004228",
                "PTR_s__Grbl_0_8c______for_help__08004238": "helpMessage"
            },
            "code": "void printHelpMessage_08004228(void)\n{\n  printPgmString(PTR_s__Grbl_0_8c______for_help__08004238);\n  return;\n}",
            "called": [
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004228",
            "calling": [
                "protocol_init"
            ],
            "imported": false,
            "current_name": "printHelpMessage_08004228"
        },
        "FUN_08009b24": {
            "renaming": {
                "FUN_08009b24": "calculate_distance_08009b24",
                "param_1": "x1",
                "param_2": "y1",
                "param_3": "x2",
                "param_4": "y2",
                "uVar1": "default_value",
                "iVar2": "is_negative",
                "uVar3": "result",
                "iVar4": "int_result",
                "uVar5": "x1_times_x2",
                "iVar6": "x2_int",
                "uVar7": "y1_times_y2",
                "local_3c": "shift_amount",
                "uVar8": "x1_low",
                "uVar9": "x1_high",
                "uVar10": "y2_squared",
                "uVar11": "y1_times_y2_times_2",
                "uVar12": "x1_plus_x2",
                "uVar13": "y1_minus_y2"
            },
            "code": "\nuint calculate_distance_08009b24(uint x1,uint y1,uint x2,uint y2)\n\n{\n  undefined4 default_value;\n  int is_negative;\n  uint result;\n  int int_result;\n  undefined4 x1_times_x2;\n  int x2_int;\n  uint y1_times_y2;\n  undefined4 x1_low;\n  undefined4 x1_high;\n  undefined8 y2_squared;\n  undefined8 y1_times_y2_times_2;\n  undefined8 x1_plus_x2;\n  undefined8 y1_minus_y2;\n  int shift_amount;\n  \n  default_value = DAT_08009d70;\n  y1 = y1 & 0x7fffffff;\n  y2 = y2 & 0x7fffffff;\n  result = x1;\n  y1_times_y2 = y1;\n  if (y1 < y2) {\n    result = x2;\n    x2 = x1;\n    y1_times_y2 = y2;\n    y2 = y1;\n  }\n  if (0x3c00000 < (int)(y1_times_y2 - y2)) {\n    result = __aeabi_dadd(result,y1_times_y2,x2,y2);\n    return result;\n  }\n  if (DAT_08009d68 < (int)y1_times_y2) {\n    if (DAT_08009d74 < (int)y1_times_y2) {\n      if ((y1_times_y2 & 0xfffff | result) != 0) {\n        result = __aeabi_dadd(result,y1_times_y2,x2,y2);\n      }\n      if ((y2 ^ 0x7ff00000 | x2) != 0) {\n        return result;\n      }\n      return x2;\n    }\n    y1_times_y2 = y1_times_y2 + 0xda800000;\n    y2 = y2 + 0xda800000;\n    shift_amount = 600;\n  }\n  else {\n    shift_amount = 0;\n  }\n  y1_times_y2_times_2 = CONCAT44(y1_times_y2,result);\n  y2_squared = CONCAT44(y2,x2);\n  if ((int)y2 <= DAT_08009d6c) {\n    if ((int)y2 < 0x100000) {\n      if ((y2 | x2) == 0) {\n        return result;\n      }\n      y2_squared = __muldf3(x2,y2,0,DAT_08009d70);\n      y1_times_y2_times_2 = __muldf3(result,y1_times_y2,0,default_value);\n      shift_amount = shift_amount + -0x3fe;\n    }\n    else {\n      y1_times_y2 = y1_times_y2 + 0x25800000;\n      y1_times_y2_times_2 = CONCAT44(y1_times_y2,result);\n      y2 = y2 + 0x25800000;\n      y2_squared = CONCAT44(y2,x2);\n      shift_amount = shift_amount + -600;\n    }\n  }\n  x1_high = (undefined4)((ulonglong)y1_times_y2_times_2 >> 0x20);\n  x1_low = (undefined4)y1_times_y2_times_2;\n  x2_int = (int)((ulonglong)y2_squared >> 0x20);\n  x1_times_x2 = (undefined4)y2_squared;\n  y2_squared = __subdf3(x1_low,x1_high,x1_times_x2,x2_int);\n  int_result = (int)((ulonglong)y2_squared >> 0x20);\n  default_value = (undefined4)y2_squared;\n  is_negative = __aeabi_dcmplt(x1_times_x2,x2_int,default_value,int_result);\n  if (is_negative == 0) {\n    y2_squared = __muldf3(0,y2,0);\n    y1_times_y2_times_2 = __muldf3(default_value,int_result + -0x80000000,default_value,int_result);\n    x1_plus_x2 = __aeabi_dadd(x1_low,x1_high,x1_low,x1_high);\n    x1_plus_x2 = __subdf3((int)x1_plus_x2,(int)((ulonglong)x1_plus_x2 >> 0x20),0,y1_times_y2 + 0x100000);\n    x1_plus_x2 = __muldf3((int)x1_plus_x2,(int)((ulonglong)x1_plus_x2 >> 0x20),x1_times_x2,x2_int);\n    y1_minus_y2 = __subdf3(x1_times_x2,x2_int,0,y2);\n    y1_minus_y2 = __muldf3((int)y1_minus_y2,(int)((ulonglong)y1_minus_y2 >> 0x20),0,y1_times_y2 + 0x100000);\n    x1_plus_x2 = __aeabi_dadd((int)x1_plus_x2,(int)((ulonglong)x1_plus_x2 >> 0x20),(int)y1_minus_y2,\n                          (int)((ulonglong)y1_minus_y2 >> 0x20));\n    y1_times_y2_times_2 = __subdf3((int)y1_times_y2_times_2,(int)((ulonglong)y1_times_y2_times_2 >> 0x20),(int)x1_plus_x2,\n                      (int)((ulonglong)x1_plus_x2 >> 0x20));\n    __subdf3((int)y2_squared,(int)((ulonglong)y2_squared >> 0x20),(int)y1_times_y2_times_2,\n             (int)((ulonglong)y1_times_y2_times_2 >> 0x20));\n    y2_squared = __ieee754_sqrt();\n  }\n  else {\n    y2_squared = __muldf3(0,y1_times_y2,0,y1_times_y2);\n    y1_times_y2_times_2 = __muldf3(x1_times_x2,x2_int + -0x80000000,x1_times_x2,x2_int);\n    x1_plus_x2 = __aeabi_dadd(x1_low,x1_high,0,y1_times_y2);\n    y1_minus_y2 = __subdf3(x1_low,x1_high,0,y1_times_y2);\n    x1_plus_x2 = __muldf3((int)x1_plus_x2,(int)((ulonglong)x1_plus_x2 >> 0x20),(int)y1_minus_y2,\n                      (int)((ulonglong)y1_minus_y2 >> 0x20));\n    y1_times_y2_times_2 = __subdf3((int)y1_times_y2_times_2,(int)((ulonglong)y1_times_y2_times_2 >> 0x20),(int)x1_plus_x2,\n                      (int)((ulonglong)x1_plus_x2 >> 0x20));\n    __subdf3((int)y2_squared,(int)((ulonglong)y2_squared >> 0x20),(int)y1_times_y2_times_2,\n             (int)((ulonglong)y1_times_y2_times_2 >> 0x20));\n    y2_squared = __ieee754_sqrt();\n  }\n  result = (uint)y2_squared;\n  if (shift_amount != 0) {\n    result = __muldf3(result,(int)((ulonglong)y2_squared >> 0x20),0,shift_amount * 0x100000 + 0x3ff00000);\n  }\n  return result;\n}\n\n",
            "called": [
                "__ieee754_sqrt",
                "__aeabi_dcmplt",
                "__muldf3",
                "__aeabi_dadd",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009b24",
            "calling": [
                "hypot"
            ],
            "imported": false,
            "current_name": "calculate_distance_08009b24"
        },
        "FUN_080076c8": {
            "renaming": {
                "FUN_080076c8": "set_bit_at_position_080076c8",
                "n": "position",
                "PTR_": "data_ptr",
                "DAT_": "original_data",
                "bit_mask": "bit_mask",
                "updated_data": "updated_data"
            },
            "code": "void set_bit_at_position_080076c8(int position)\n{\n    uint* PTR_ = (uint*)((position >> 4) * 0x400 + 0x40020014);\n    uint DAT_ = *PTR_;\n    uint bit_mask = 1 << (position & 0xfU);\n    uint updated_data = DAT_ ^ bit_mask;\n    *PTR_ = updated_data;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080076c8",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_080076c8"
        },
        "FUN_0800530c": {
            "renaming": {
                "FUN_0800530c": "do_nothing_0800530c"
            },
            "code": "\nvoid do_nothing_0800530c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800530c",
            "calling": [
                "st_go_idle"
            ],
            "imported": false,
            "current_name": "do_nothing_0800530c"
        },
        "FUN_08006a8c": {
            "renaming": {
                "FUN_08006a8c": "set_irq_priority_08006a8c",
                "IRQn": "irq",
                "DAT_08006abc": "irq_register_base",
                "PTR_08006abc": "irq_register_pointer"
            },
            "code": "void set_irq_priority_08006a8c(IRQn_Type irq)\n{\n    int* irq_reg = (int*)(DAT_08006abc + (((uint)(int)irq >> 5) + 0x60) * 4);\n    int irq_bit = 1 << (irq & 0x1fU);\n    *irq_reg = irq_bit;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006a8c",
            "calling": [
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "imported": false,
            "current_name": "set_irq_priority_08006a8c"
        },
        "FUN_0800772c": {
            "renaming": {
                "FUN_0800772c": "infinite_loop_0800772c"
            },
            "code": "void infinite_loop_0800772c(void)\n{\n  while( true )\n  {\n    //Do nothing\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800772c",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_0800772c"
        },
        "FUN_0800283a": {
            "renaming": {
                "FUN_0800283a": "set_current_position_0800283a",
                "PTR_sys_08002868": "PTR_sys",
                "plan_set_current_position": "set_plan_current_position",
                "gc_set_current_position": "set_gc_current_position"
            },
            "code": "void set_current_position_0800283a(int32_t x, int32_t y, int32_t z)\n{\n  plan_set_current_position_0800283a(x, y, z);\n  gc_set_current_position_0800283a(x, y, z);\n  return;\n}",
            "called": [
                "gc_set_current_position",
                "plan_set_current_position"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800283a",
            "calling": [
                "mc_go_home",
                "grbl_main"
            ],
            "imported": false,
            "current_name": "set_current_position_0800283a"
        },
        "FUN_0800881c": {
            "renaming": {
                "FUN_0800881c": "binary_operation_0800881c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "mask4",
                "unaff_r4": "temp1",
                "uVar2": "temp5",
                "uVar3": "temp3",
                "in_r12": "mask",
                "bVar4": "condition1",
                "mask2": "mask2",
                "mask3": "mask3",
                "mask4": "mask4",
                "mask5": "mask5"
            },
            "code": "ulonglong binary_operation_0800881c(uint param1, uint param2, uint param3, uint param4)\n{\n    uint temp1, temp2, temp3, temp4;\n    bool condition1, condition2, condition3;\n\n    temp1 = param1;\n    temp2 = param2;\n    temp3 = param3;\n    temp4 = param4;\n\n    uint mask = 0x80000000;\n    uint mask2 = 0x100000;\n\n    uint temp5 = in_r12 & param4 >> 0x14;\n    if(unaff_r4 != in_r12 && temp5 != in_r12)\n    {\n        condition1 = (param1 | param2 << 1) == 0;\n        if(!condition1)\n        {\n            condition1 = (param3 | param4 << 1) == 0;\n        }\n        if(condition1)\n        {\n            return (ulonglong)((param2 ^ param4) & mask) << 0x20;\n        }\n        if(unaff_r4 == 0)\n        {\n            uint mask3 = 0x80000000;\n            do\n            {\n                uint mask4 = param1 & mask3;\n                param1 = param1 << 1;\n                param2 = param2 * 2 + (uint)(mask4 != 0);\n            } while((param2 & mask2) == 0);\n            param2 = param2 | mask3;\n            if(temp5 != 0)\n            {\n                return CONCAT44(param2,param1);\n            }\n        }\n        do\n        {\n            uint mask5 = param3 & mask3;\n            param3 = param3 << 1;\n            param4 = param4 * 2 + (uint)(mask5 != 0);\n        } while((param4 & mask2) == 0);\n        return CONCAT44(param2,param1);\n    }\n    condition1 = (param1 | param2 << 1) == 0;\n    if(condition1)\n    {\n        param2 = param4;\n        param1 = param3;\n    }\n    if(!condition1)\n    {\n        condition2 = (param3 | param4 << 1) == 0;\n    }\n    temp3 = param2;\n    if((!condition2) && ((unaff_r4 != in_r12 || ((param1 | param2 << 0xc) == 0))) && ((temp5 != in_r12 || (param1 = param3, temp3 = param4, (param3 | param4 << 0xc) == 0))))\n    {\n        return (ulonglong)((param2 ^ param4) & mask | 0x7ff00000) << 0x20;\n    }\n    return CONCAT44(temp3,param1) | 0x7ff8000000000000;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800881c",
            "calling": [
                "__muldf3"
            ],
            "imported": false,
            "current_name": "binary_operation_0800881c"
        },
        "FUN_08004bc0": {
            "renaming": {
                "FUN_08004bc0": "writeLineToEEPROM_08004bc0",
                "n": "lineNumber",
                "line": "line",
                "addr": "address",
                "memcpy_to_eeprom_with_checksum": "memcpy_to_eeprom_with_checksum"
            },
            "code": "void writeLineToEEPROM_08004bc0(uint8_t lineNumber, char *line) {\n  uint16_t address = (uint16_t)(lineNumber * 0x101 + 0x300);\n  memcpy_to_eeprom_with_checksum(address, line, 0x100);\n  return;\n}",
            "called": [
                "memcpy_to_eeprom_with_checksum"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004bc0",
            "calling": [
                "protocol_execute_line",
                "settings_read_startup_line"
            ],
            "imported": false,
            "current_name": "writeLineToEEPROM_08004bc0"
        },
        "FUN_08008b4c": {
            "renaming": {
                "FUN_08008b4c": "isNotCYOrZR_08008b4c",
                "in_CY": "is_CY_Greater_than_ZR",
                "in_ZR": "is_ZR_Greater_than_CY"
            },
            "code": "bool isNotCYOrZR_08008b4c(void)\n{\n  bool is_CY_Greater_than_ZR = __aeabi_cdrcmple();\n  return !is_CY_Greater_than_ZR || is_CY_Greater_than_ZR;\n}",
            "called": [
                "__aeabi_cdrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b4c",
            "calling": [
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "isNotCYOrZR_08008b4c"
        },
        "FUN_08004c2a": {
            "renaming": {
                "FUN_08004c2a": "save_settings_to_eeprom_08004c2a",
                "PTR_settings_08004c44": "settings_buffer"
            },
            "code": "void save_settings_to_eeprom_08004c2a(void) \\n\\\n{\\n\\\n  eeprom_put_char(0, 5);\\n\\\n  memcpy_to_eeprom_with_checksum(1, PTR_settings_08004c44, 64);\\n\\\n  return;\\n\\\n}",
            "called": [
                "eeprom_put_char",
                "memcpy_to_eeprom_with_checksum"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c2a",
            "calling": [
                "settings_reset",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "save_settings_to_eeprom_08004c2a"
        },
        "FUN_0800826a": {
            "renaming": {
                "FUN_0800826a": "send_char_to_usart_0800826a",
                "ch": "character"
            },
            "code": "int send_char_to_usart_0800826a(int character) {\n  usart_putc((char)character);\n  return 0;\n}",
            "called": [
                "usart_putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800826a",
            "calling": [],
            "imported": false,
            "current_name": "send_char_to_usart_0800826a"
        },
        "FUN_08008b60": {
            "renaming": {
                "FUN_08008b60": "isEndOfString_08008b60",
                "in_CY": "currentChar"
            },
            "code": "bool isEndOfString_08008b60(void)\n{\n  char currentChar;\n  __aeabi_cdrcmple();\n  return currentChar == '\\0';\n}",
            "called": [
                "__aeabi_cdrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b60",
            "calling": [
                "floor",
                "ceil",
                "plan_buffer_line",
                "atan"
            ],
            "imported": false,
            "current_name": "isEndOfString_08008b60"
        },
        "FUN_08005324": {
            "renaming": {
                "FUN_08005324": "set_step_period_based_on_steps_per_minute_08005324",
                "steps_per_minute": "steps_per_minute",
                "ticks_00": "ticks_for_one_step",
                "local_14": "steps_per_minute_adjusted",
                "ticks": "ticks",
                "DAT_08005358": "DAT_08005358",
                "PTR_st_0800535c": "PTR_st_0800535c"
            },
            "code": "void set_step_period_based_on_steps_per_minute_08005324(uint32_t steps_per_minute)\n{\n  uint ticks_for_one_step;\n  uint32_t steps_per_minute_adjusted;\n  uint32_t ticks;\n  \n  steps_per_minute_adjusted = steps_per_minute;\n  if (steps_per_minute < 800) {\n    steps_per_minute_adjusted = 800;\n  }\n  ticks_for_one_step = DAT_08005358 / steps_per_minute_adjusted;\n  *(uint *)(PTR_st_0800535c + 0x14) = ticks_for_one_step;\n  set_step_period(ticks_for_one_step);\n  return;\n}",
            "called": [
                "set_step_period"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005324",
            "calling": [
                "step_period_isr",
                "st_cycle_reinitialize",
                "st_reset"
            ],
            "imported": false,
            "current_name": "set_step_period_based_on_steps_per_minute_08005324"
        },
        "FUN_08000310": {
            "renaming": {
                "FUN_08000310": "get_eeprom_data_08000310",
                "addr": "address",
                "PTR_eeprom_ready_08000338": "eeprom_ready",
                "eeprom_init": "initialize_eeprom",
                "PTR_eeprom_data_0800033c": "eeprom_data"
            },
            "code": "char get_eeprom_data_08000310(uint address) {\n  if (*PTR_eeprom_ready_08000338 == 0) {\n    initialize_eeprom();\n  }\n  return PTR_eeprom_data_0800033c[address & 0x3ff];\n}",
            "called": [
                "eeprom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000310",
            "calling": [
                "read_global_settings",
                "memcpy_from_eeprom_with_checksum"
            ],
            "imported": false,
            "current_name": "get_eeprom_data_08000310"
        },
        "FUN_08005208": {
            "renaming": {
                "FUN_08005208": "do_nothing_08005208"
            },
            "code": "\nvoid do_nothing_08005208(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005208",
            "calling": [
                "spindle_run"
            ],
            "imported": false,
            "current_name": "do_nothing_08005208"
        },
        "FUN_08007a70": {
            "renaming": {
                "FUN_08007a70": "set_timer_interrupt_priority_08007a70",
                "tim": "timer",
                "pre": "preemption_priority",
                "sub": "sub_priority",
                "irq": "interrupt_number"
            },
            "code": "void set_timer_interrupt_priority_08007a70(TIM_TypeDef *timer, uint32_t preemption_priority, uint32_t sub_priority)\n{\n    uint32_t interrupt_number;\n    if (timer == (TIM_TypeDef *)&PTR_40000000) {\n        interrupt_number = TIM2_IRQn;\n    }\n    else if (timer == PTR_08007ac8) {\n        interrupt_number = TIM3_IRQn;\n    }\n    else {\n        if (timer != PTR_08007acc) {\n            return;\n        }\n        interrupt_number = TIM4_IRQn;\n    }\n    HAL_NVIC_SetPriority((IRQn_Type)interrupt_number, preemption_priority, sub_priority);\n    NVIC_EnableIRQ((IRQn_Type)interrupt_number);\n    return;\n}",
            "called": [
                "NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007a70",
            "calling": [
                "step_timer_init"
            ],
            "imported": false,
            "current_name": "set_timer_interrupt_priority_08007a70"
        },
        "FUN_0800b5b0": {
            "renaming": {
                "FUN_0800b5b0": "get_context_address_0800b5b0",
                "ctx": "context_pointer"
            },
            "code": "int get_context_address_0800b5b0(EVP_PKEY_CTX *context_pointer) {\n  return (int)context_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b5b0",
            "calling": [
                "__libc_init_array",
                "frame_dummy",
                "__do_global_dtors_aux"
            ],
            "imported": false,
            "current_name": "get_context_address_0800b5b0"
        },
        "FUN_08002978": {
            "renaming": {
                "FUN_08002978": "calculate_final_velocity_08002978",
                "acceleration": "acceleration",
                "target_velocity": "target_velocity",
                "distance": "distance",
                "in_r0": "unused_variable_1",
                "uVar1": "acceleration_squared",
                "uVar2": "distance_times_two",
                "in_r1": "acceleration",
                "extraout_r1": "unused_variable_2",
                "in_r2": "distance",
                "fVar3": "final_velocity",
                "in_stack_ffffffe0": "unused_variable_3"
            },
            "code": "float calculate_final_velocity_08002978(float acceleration, float target_velocity, float distance) {\n  float acceleration_squared = acceleration * acceleration;\n  float distance_times_two = distance * 2;\n  float velocity_difference_squared = target_velocity * target_velocity - acceleration_squared * distance_times_two;\n  float final_velocity = sqrt(velocity_difference_squared);\n  return final_velocity;\n}",
            "called": [
                "__addsf3",
                "sqrt",
                "__aeabi_fmul",
                "__aeabi_f2d",
                "__aeabi_fsub",
                "__truncdfsf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002978",
            "calling": [
                "planner_forward_pass_kernel",
                "planner_reverse_pass_kernel",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "calculate_final_velocity_08002978"
        },
        "FUN_08009d78": {
            "renaming": {
                "FUN_08009d78": "calculate_trigonometric_function_08009d78",
                "param_1": "input_value",
                "param_2": "input_precision",
                "param_3": "output_value",
                "uVar1": "upper_word_1",
                "uVar2": "lower_word_1",
                "uVar3": "upper_word_2",
                "extraout_r1": "lower_word_2",
                "uVar4": "upper_word_3",
                "uVar5": "lower_word_3",
                "uVar6": "upper_word_4",
                "uVar7": "lower_word_4",
                "uVar8": "unsigned_precision",
                "iVar9": "result",
                "uVar10": "double_precision_1",
                "uVar11": "double_precision_2",
                "uVar12": "double_precision_3",
                "local_50": "upper_word_5",
                "uStack_4c": "lower_word_5",
                "local_40": "double_precision_4",
                "local_38": "double_precision_5",
                "local_30": "double_precision_6",
                "in_stack_ffffffa8": "input_value_2",
                "in_stack_ffffffac": "input_value_1"
            },
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint calculate_trigonometric_function_08009d78(undefined4 input_value,uint input_precision,undefined8 *output_value)\n\n{\n  undefined4 upper_word_1;\n  undefined4 lower_word_1;\n  undefined4 upper_word_2;\n  undefined4 lower_word_2;\n  undefined4 upper_word_3;\n  undefined4 lower_word_3;\n  undefined4 upper_word_4;\n  undefined4 lower_word_4;\n  uint unsigned_precision;\n  int result;\n  undefined8 double_precision_1;\n  undefined8 double_precision_2;\n  undefined8 double_precision_3;\n  undefined4 input_value_2;\n  undefined4 input_value_1;\n  undefined4 upper_word_5;\n  undefined4 lower_word_5;\n  undefined8 double_precision_4;\n  undefined8 double_precision_5;\n  undefined8 double_precision_6;\n  \n  unsigned_precision = input_precision & 0x7fffffff;\n  if ((int)unsigned_precision <= DAT_08009fb0) {\n    *(undefined4 *)output_value = input_value;\n    *(uint *)((int)output_value + 4) = input_precision;\n    *(undefined4 *)(output_value + 1) = 0;\n    *(undefined4 *)((int)output_value + 0xc) = 0;\n    return 0;\n  }\n  if ((int)unsigned_precision <= DAT_08009fb4) {\n    if ((int)input_precision < 1) {\n      double_precision_1 = __aeabi_dadd(input_value,input_precision,DAT_08009f88,DAT_08009f8c);\n      lower_word_1 = (undefined4)((ulonglong)double_precision_1 >> 0x20);\n      upper_word_1 = (undefined4)double_precision_1;\n      if (unsigned_precision != DAT_0800a1b8) {\n        double_precision_1 = __aeabi_dadd(upper_word_1,lower_word_1,DAT_0800a1b0,DAT_0800a1b4);\n        *output_value = double_precision_1;\n        double_precision_1 = __subdf3(upper_word_1,lower_word_1);\n        double_precision_1 = __aeabi_dadd((int)double_precision_1,(int)((ulonglong)double_precision_1 >> 0x20),DAT_0800a1b0,DAT_0800a1b4\n                             );\n        output_value[1] = double_precision_1;\n        return -1;\n      }\n      double_precision_1 = __aeabi_dadd(upper_word_1,lower_word_1,DAT_0800a190,DAT_0800a194);\n      upper_word_1 = (undefined4)((ulonglong)double_precision_1 >> 0x20);\n      double_precision_2 = __aeabi_dadd((int)double_precision_1,upper_word_1,DAT_0800a198,DAT_0800a19c);\n      *output_value = double_precision_2;\n      double_precision_1 = __subdf3((int)double_precision_1,upper_word_1);\n      double_precision_1 = __aeabi_dadd((int)double_precision_1,(int)((ulonglong)double_precision_1 >> 0x20),DAT_0800a198,DAT_0800a19c);\n      output_value[1] = double_precision_1;\n      return -1;\n    }\n    double_precision_1 = __subdf3();\n    lower_word_1 = (undefined4)((ulonglong)double_precision_1 >> 0x20);\n    upper_word_1 = (undefined4)double_precision_1;\n    if (unsigned_precision != DAT_08009fb8) {\n      double_precision_1 = __subdf3(upper_word_1,lower_word_1,DAT_08009f90,DAT_08009f94);\n      *output_value = double_precision_1;\n      double_precision_1 = __subdf3(upper_word_1,lower_word_1);\n      double_precision_1 = __subdf3((int)double_precision_1,(int)((ulonglong)double_precision_1 >> 0x20),DAT_08009f90,DAT_08009f94);\n      output_value[1] = double_precision_1;\n      return 1;\n    }\n    double_precision_1 = __subdf3(upper_word_1,lower_word_1,DAT_08009f98,DAT_08009f9c);\n    upper_word_1 = (undefined4)((ulonglong)double_precision_1 >> 0x20);\n    double_precision_2 = __subdf3((int)double_precision_1,upper_word_1,DAT_08009fa0,DAT_08009fa4);\n    *output_value = double_precision_2;\n    double_precision_1 = __subdf3((int)double_precision_1,upper_word_1);\n    double_precision_1 = __subdf3((int)double_precision_1,(int)((ulonglong)double_precision_1 >> 0x20),DAT_08009fa0,DAT_08009fa4);\n    output_value[1] = double_precision_1;\n    return 1;\n  }\n  if (DAT_08009fbc < (int)unsigned_precision) {\n    if (DAT_08009fc0 < (int)unsigned_precision) {\n      double_precision_1 = __subdf3(input_value,input_precision,input_value,input_precision);\n      output_value[1] = double_precision_1;\n      *output_value = double_precision_1;\n      return 0;\n    }\n    result = ((int)unsigned_precision >> 0x14) + -0x416;\n    __aeabi_d2iz();\n    double_precision_4 = __aeabi_i2d();\n    double_precision_1 = __subdf3(input_value,unsigned_precision + result * -0x100000,(int)double_precision_4,\n                      (int)((ulonglong)double_precision_4 >> 0x20));\n    double_precision_1 = __muldf3((int)double_precision_1,(int)((ulonglong)double_precision_1 >> 0x20),0,DAT_08009fc4);\n    __aeabi_d2iz();\n    double_precision_5 = __aeabi_i2d();\n    double_precision_1 = __subdf3((int)double_precision_1,(int)((ulonglong)double_precision_1 >> 0x20));\n    double_precision_6 = __muldf3((int)double_precision_1,(int)((ulonglong)double_precision_1 >> 0x20),0,DAT_08009fc4);\n    __aeabi_dcmpeq((int)double_precision_6,(int)((ulonglong)double_precision_6 >> 0x20),0,0);\n    result = __kernel_rem_pio2(&double_precision_4,output_value,result);\n    if (-1 < (int)input_precision) {\n      return result;\n    }\n    *(int *)((int)output_value + 4) = *(int *)((int)output_value + 4) + -0x80000000;\n    *(int *)((int)output_value + 0xc) = *(int *)((int)output_value + 0xc) + -0x80000000;\n    return -result;\n  }\n  fabs((double)CONCAT44(input_value_1,input_value_2));\n  double_precision_1 = __muldf3();\n  __aeabi_dadd((int)double_precision_1,(int)((ulonglong)double_precision_1 >> 0x20),0,DAT_08009fcc);\n  result = __aeabi_d2iz();\n  double_precision_1 = __aeabi_i2d();\n  upper_word_3 = (undefined4)((ulonglong)double_precision_1 >> 0x20);\n  upper_word_1 = (undefined4)double_precision_1;\n  double_precision_1 = __muldf3(upper_word_1,upper_word_3,DAT_08009f88,DAT_08009f8c);\n  double_precision_1 = __subdf3(input_value,lower_word_2,(int)double_precision_1,(int)((ulonglong)double_precision_1 >> 0x20));\n  lower_word_3 = (undefined4)((ulonglong)double_precision_1 >> 0x20);\n  lower_word_1 = (undefined4)double_precision_1;\n  double_precision_2 = __muldf3(upper_word_1,upper_word_3,DAT_08009f90,DAT_08009f94);\n  if ((0x1f < result) || (*(uint *)(PTR_npio2_hw_08009fd0 + (result + -1) * 4) == unsigned_precision)) {\n    double_precision_3 = __subdf3(lower_word_1,lower_word_3,(int)double_precision_2,(int)((ulonglong)double_precision_2 >> 0x20));\n    if ((int)((unsigned_precision >> 0x14) - ((uint)((int)((ulonglong)double_precision_3 >> 0x20) << 1) >> 0x15)) < 0x11)\n    goto LAB_0800a0ce;\n    double_precision_2 = __muldf3(upper_word_1,upper_word_3,DAT_0800a190,DAT_0800a194);\n    upper_word_4 = (undefined4)((ulonglong)double_precision_2 >> 0x20);\n    double_precision_1 = __subdf3(lower_word_1,lower_word_3,(int)double_precision_2,upper_word_4);\n    lower_word_4 = (undefined4)((ulonglong)double_precision_1 >> 0x20);\n    upper_word_2 = (undefined4)double_precision_1;\n    double_precision_3 = __subdf3(lower_word_1,lower_word_3,upper_word_2,lower_word_4);\n    double_precision_2 = __subdf3((int)double_precision_3,(int)((ulonglong)double_precision_3 >> 0x20),(int)double_precision_2,upper_word_4);\n    double_precision_3 = __muldf3(upper_word_1,upper_word_3,DAT_0800a198,DAT_0800a19c);\n    double_precision_2 = __subdf3((int)double_precision_3,(int)((ulonglong)double_precision_3 >> 0x20),(int)double_precision_2,\n                      (int)((ulonglong)double_precision_2 >> 0x20));\n    double_precision_3 = __subdf3(upper_word_2,lower_word_4,(int)double_precision_2,(int)((ulonglong)double_precision_2 >> 0x20));\n    if ((int)(((int)unsigned_precision >> 0x14) - ((uint)((int)((ulonglong)double_precision_3 >> 0x20) << 1) >> 0x15)) < 0x32\n       ) goto LAB_0800a0ce;\n    double_precision_2 = __muldf3(upper_word_1,upper_word_3,DAT_0800a1a0,DAT_0800a1a4);\n    lower_word_1 = (undefined4)((ulonglong)double_precision_2 >> 0x20);\n    double_precision_1 = __subdf3(upper_word_2,lower_word_4,(int)double_precision_2,lower_word_1);\n    double_precision_3 = __subdf3(upper_word_2,lower_word_4);\n    double_precision_2 = __subdf3((int)double_precision_3,(int)((ulonglong)double_precision_3 >> 0x20),(int)double_precision_2,lower_word_1);\n    double_precision_3 = __muldf3(upper_word_1,upper_word_3,DAT_0800a1a8,DAT_0800a1ac);\n    double_precision_2 = __subdf3((int)double_precision_3,(int)((ulonglong)double_precision_3 >> 0x20),(int)double_precision_2,\n                      (int)((ulonglong)double_precision_2 >> 0x20));\n  }\n  double_precision_3 = __subdf3((int)double_precision_1,(int)((ulonglong)double_precision_1 >> 0x20),(int)double_precision_2,\n                    (int)((ulonglong)double_precision_2 >> 0x20));\nLAB_0800a0ce:\n  lower_word_5 = (undefined4)((ulonglong)double_precision_1 >> 0x20);\n  upper_word_5 = (undefined4)double_precision_1;\n  *output_value = double_precision_3;\n  double_precision_1 = __subdf3(upper_word_5,lower_word_5);\n  double_precision_1 = __subdf3((int)double_precision_1,(int)((ulonglong)double_precision_1 >> 0x20),(int)double_precision_2,\n                    (int)((ulonglong)double_precision_2 >> 0x20));\n  output_value[1] = double_precision_1;\n  if ((int)input_precision < 0) {\n    *(int *)output_value = (int)double_precision_3;\n    *(int *)((int)output_value + 4) = (int)((ulonglong)double_precision_3 >> 0x20) + -0x80000000;\n    *(int *)(output_value + 1) = (int)double_precision_1;\n    *(int *)((int)output_value + 0xc) = (int)((ulonglong)double_precision_1 >> 0x20) + -0x80000000;\n    result = -result;\n  }\n  return result;\n}\n\n",
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__aeabi_dcmpeq",
                "__aeabi_d2iz",
                "fabs",
                "__subdf3",
                "__aeabi_i2d",
                "__kernel_rem_pio2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009d78",
            "calling": [
                "sin",
                "cos"
            ],
            "imported": false,
            "current_name": "calculate_trigonometric_function_08009d78"
        },
        "FUN_08003826": {
            "renaming": {
                "FUN_08003826": "print_float_as_string_08003826",
                "n": "number",
                "in_r0": "integer_part",
                "iVar1": "is_negative",
                "local_24": "number",
                "uVar2": "rounded",
                "uVar4": "digit",
                "uStack_1d": "index",
                "buf": "buffer",
                "a": "integer_part",
                "i": "index",
                "decimals": "decimal_places"
            },
            "code": "void print_float_as_string_08003826(float number) {\\n\\\n    uint integer_part;\\n\\\n    int is_negative = __aeabi_fcmplt(number, 0);\\n\\\n    if (is_negative) {\\n\\\n        serial_write(\"-\");\\n\\\n        number = -number;\\n\\\n    }\\n\\\n    uint decimal_places = PTR_settings_08003970[0x3d];\\n\\\n    for (uint i = 1; i < decimal_places; i++) {\\n\\\n        number = __aeabi_fmul(number, DAT_08003974);\\n\\\n    }\\n\\\n    if (decimal_places != 0) {\\n\\\n        number = __aeabi_fmul(number, DAT_08003978);\\n\\\n    }\\n\\\n    float rounded = __addsf3(number, 0x3f000000);\\n\\\n    integer_part = __aeabi_f2iz(rounded);\\n\\\n    uint8_t index = 0;\\n\\\n    uchar buffer[10];\\n\\\n    buffer[decimal_places] = \".\";\\n\\\n    for (; integer_part != 0; integer_part /= 10) {\\n\\\n        if (index == decimal_places) {\\n\\\n            index++;\\n\\\n        }\\n\\\n        uint8_t digit = integer_part % 10;\\n\\\n        buffer[index++] = digit + \"0\";\\n\\\n    }\\n\\\n    while (index < decimal_places) {\\n\\\n        buffer[index++] = \"0\";\\n\\\n    }\\n\\\n    if (index == decimal_places) {\\n\\\n        buffer[index] = \"0\";\\n\\\n        index += 2;\\n\\\n    }\\n\\\n    for (; index != 0; index--) {\\n\\\n        serial_write(buffer[index - 1]);\\n\\\n    }\\n\\\n}",
            "called": [
                "__addsf3",
                "__aeabi_fmul",
                "__aeabi_f2iz",
                "serial_write",
                "__aeabi_fcmplt"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003826",
            "calling": [
                "report_realtime_status",
                "report_gcode_parameters",
                "report_grbl_settings",
                "report_gcode_modes"
            ],
            "imported": false,
            "current_name": "print_float_as_string_08003826"
        },
        "FUN_0800923c": {
            "renaming": {
                "FUN_0800923c": "check_if_zero_or_nan_0800923c",
                "in_CY": "is_nan",
                "in_ZR": "is_zero"
            },
            "code": "bool check_if_zero_or_nan_0800923c(void)\n{\n  bool is_nan = __aeabi_cfcmpeq();\n  return !is_nan || is_zero;\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800923c",
            "calling": [
                "mc_arc",
                "gc_execute_line",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "check_if_zero_or_nan_0800923c"
        },
        "FUN_08002afc": {
            "renaming": {
                "FUN_08002afc": "update_entry_speed_if_previous_is_slower_08002afc",
                "previous": "previous_block",
                "current": "current_block",
                "next": "next_block",
                "iVar1": "is_previous_slower",
                "uVar2": "max_speed",
                "fVar3": "current_speed",
                "acceleration": "acceleration",
                "acceleration_00": "acceleration_00",
                "target_velocity": "target_velocity",
                "target_velocity_00": "target_velocity_00",
                "distance": "distance",
                "distance_00": "distance_00",
                "entry_speed": "entry_speed",
                "PTR_settings_08002ba4": "PTR_settings_08002ba4",
                "max_allowable_speed": "max_allowable_speed"
            },
            "code": "void update_entry_speed_if_previous_is_slower_08002afc(block_t *previous_block, block_t *current_block, block_t *next_block) {\n  int is_previous_slower;\n  uint max_speed;\n  float acceleration, acceleration_00, target_velocity, target_velocity_00, distance, distance_00, current_speed, new_speed;\n  \n  if (previous_block != NULL && !previous_block->nominal_length_flag && (is_previous_slower = (previous_block->entry_speed < current_block->entry_speed))) {\n    current_speed = current_block->entry_speed;\n    max_speed = *(uint *)(PTR_settings_08002ba4 + 0x20) ^ 0x80000000;\n    max_allowable_speed(acceleration, target_velocity, distance);\n    if (current_speed >= max_speed) {\n      new_speed = current_speed;\n    }\n    else {\n      max_allowable_speed(acceleration_00, target_velocity_00, distance_00);\n      new_speed = (float)max_speed;\n    }\n    if (new_speed != current_speed) {\n      current_block->entry_speed = new_speed;\n      current_block->recalculate_flag = 1;\n    }\n  }\n}",
            "called": [
                "__aeabi_fcmpeq",
                "__aeabi_fcmplt",
                "max_allowable_speed"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002afc",
            "calling": [
                "planner_forward_pass"
            ],
            "imported": false,
            "current_name": "update_entry_speed_if_previous_is_slower_08002afc"
        },
        "FUN_08004c48": {
            "renaming": {
                "FUN_08004c48": "initialize_settings_08004c48",
                "reset_all": "reset",
                "PTR_settings_08004d0c": "settings",
                "DAT_08004d10": "default_setting_1",
                "DAT_08004d14": "default_setting_2",
                "DAT_08004d18": "default_setting_3",
                "DAT_08004d1c": "default_setting_5",
                "DAT_08004d20": "default_setting_6",
                "DAT_08004d24": "default_setting_8",
                "DAT_08004d28": "default_setting_4"
            },
            "code": "void initialize_settings_08004c48(_Bool reset_all)\n{\n    if (reset_all) {\n        PTR_settings_08004d0c[0] = DAT_08004d10;\n        PTR_settings_08004d0c[1] = DAT_08004d14;\n        PTR_settings_08004d0c[2] = DAT_08004d18;\n        PTR_settings_08004d0c[13] = 10;\n        PTR_settings_08004d0c[16] = DAT_08004d28;\n        PTR_settings_08004d0c[20] = DAT_08004d1c;\n        PTR_settings_08004d0c[26] = DAT_08004d20;\n        PTR_settings_08004d0c[28] = default_setting_7;\n        PTR_settings_08004d0c[29] = 0;\n        PTR_settings_08004d0c[29] |= 2;\n        PTR_settings_08004d0c[29] |= 0x10;\n        PTR_settings_08004d0c[43] = DAT_08004d24;\n    }\n    PTR_settings_08004d0c[40] = 0;\n    PTR_settings_08004d0c[40] |= 2;\n    PTR_settings_08004d0c[40] |= 0x10;\n    PTR_settings_08004d0c[42] = 0;\n    PTR_settings_08004d0c[44] = DAT_08004d28;\n    PTR_settings_08004d0c[48] = DAT_08004d14;\n    PTR_settings_08004d0c[52] = 100;\n    PTR_settings_08004d0c[56] = 0x3f800000;\n    PTR_settings_08004d0c[60] = 0x19;\n    PTR_settings_08004d0c[61] = 3;\n    PTR_settings_08004d0c[62] = 0x19;\n    write_global_PTR_settings_08004d0c();\n}\n",
            "called": [
                "write_global_settings"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c48",
            "calling": [
                "read_global_settings",
                "settings_init"
            ],
            "imported": false,
            "current_name": "initialize_settings_08004c48"
        },
        "FUN_080002a0": {
            "renaming": {
                "FUN_080002a0": "delay_in_milliseconds_080002a0",
                "_ms": "milliseconds_to_delay"
            },
            "code": "void delay_in_milliseconds_080002a0(uint milliseconds_to_delay) \n{\n  HAL_Delay(milliseconds_to_delay);\n  return;\n}",
            "called": [
                "HAL_Delay"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002a0",
            "calling": [
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "delay_in_milliseconds_080002a0"
        },
        "FUN_08009250": {
            "renaming": {
                "FUN_08009250": "is_not_CY_or_ZR_08009250",
                "in_CY": "is_CY",
                "in_ZR": "is_ZR"
            },
            "code": "bool is_not_CY_or_ZR_08009250(void)\n{\n  bool is_CY = __aeabi_cfrcmple();\n  bool is_ZR = (bool)in_ZR;\n  return !is_CY || is_ZR;\n}",
            "called": [
                "__aeabi_cfrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009250",
            "calling": [
                "mc_arc",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "is_not_CY_or_ZR_08009250"
        },
        "FUN_0800640c": {
            "renaming": {
                "FUN_0800640c": "configure_RCC_MCO_0800640c",
                "RCC_MCOx": "MCO_pin",
                "RCC_MCOSource": "MCO_source",
                "RCC_MCODiv": "MCO_divider",
                "GPIO_InitStruct": "GPIO_config",
                "DAT_080064b0": "MCO_registers",
                "DAT_080064b4": "GPIOA_pin8",
                "DAT_080064b8": "GPIOA_pin9"
            },
            "code": "void configure_RCC_MCO_0800640c(uint32_t MCO_pin, uint32_t MCO_source, uint32_t MCO_divider) {\n  GPIO_InitTypeDef GPIO_InitStruct;\n  if (MCO_pin == 0) {\n    *(uint *)(DAT_080064b0 + 0x30) |= 1;\n    GPIO_InitStruct.Pin = GPIO_PIN_8;\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\n    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;\n    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n    *(uint32_t *)(DAT_080064b0 + 8) = MCO_divider | MCO_source | *(uint *)(DAT_080064b0 + 8) & 0xf89fffff;\n  }\n  else {\n    *(uint *)(DAT_080064b0 + 0x30) |= 4;\n    GPIO_InitStruct.Pin = GPIO_PIN_9;\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\n    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;\n    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n    *(uint32_t *)(DAT_080064b0 + 8) = MCO_source | MCO_divider << 3 | *(uint *)(DAT_080064b0 + 8) & 0x7ffffff;\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800640c",
            "calling": [],
            "imported": false,
            "current_name": "configure_RCC_MCO_0800640c"
        },
        "FUN_0800773e": {
            "renaming": {
                "FUN_0800773e": "do_nothing_0800773e"
            },
            "code": "\nvoid do_nothing_0800773e(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800773e",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800773e"
        },
        "FUN_08008af0": {
            "renaming": {
                "FUN_08008af0": "compare_double_values_08008af0",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "unused_double_param1",
                "param_4": "unused_double_param2",
                "__aeabi_cdcmpeq": "compare_double_values_using_eabi"
            },
            "code": "void compare_double_values_08008af0(double value1, double value2) {\n  __aeabi_cdcmpeq(value1, value2);\n  return;\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008af0",
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "imported": false,
            "current_name": "compare_double_values_08008af0"
        },
        "FUN_08006e1a": {
            "renaming": {
                "FUN_08006e1a": "get_active_interrupt_08006e1a",
                "IRQn": "interrupt_number",
                "uVar1": "active_interrupt"
            },
            "code": "uint32_t get_active_interrupt_08006e1a(IRQn_Type interrupt_number)\n{\n  uint32_t active_interrupt;\n  active_interrupt = NVIC_GetActive(interrupt_number);\n  return active_interrupt;\n}",
            "called": [
                "NVIC_GetActive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e1a",
            "calling": [],
            "imported": false,
            "current_name": "get_active_interrupt_08006e1a"
        },
        "FUN_080052ac": {
            "renaming": {
                "FUN_080052ac": "set_bit_080052ac",
                "x": "value",
                "DAT_080052d8": "data_ptr",
                "PTR_080052d8": "mask_ptr",
                "val": "mask"
            },
            "code": "void set_bit_080052ac(uint32_t value) {\n  uint32_t* DAT_080052d8 = (uint32_t*)(DAT_080052d8 + 0x14);\n  uint32_t* PTR_080052d8 = (uint32_t*)(DAT_080052d8 + 0x14);\n  uint32_t mask = 0xfffffaaf;\n  *DAT_080052d8 = value | (*PTR_080052d8 & mask);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052ac",
            "calling": [
                "st_init",
                "step_pulse_isr",
                "step_delay_isr"
            ],
            "imported": false,
            "current_name": "set_bit_080052ac"
        },
        "FUN_080064bc": {
            "renaming": {
                "FUN_080064bc": "set_dat_ptr_to_one_080064bc",
                "DAT_080064d0": "data_pointer"
            },
            "code": "void set_dat_ptr_to_one_080064bc(void)\n{\n  *DAT_080064d0 = 1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064bc",
            "calling": [],
            "imported": false,
            "current_name": "set_dat_ptr_to_one_080064bc"
        },
        "FUN_08008286": {
            "renaming": {
                "FUN_08008286": "read_serial_data_08008286",
                "PTR_08000400": "usart_data_ready",
                "PTR_08000404": "usart_read",
                "PTR_08000408": "usart_tstc",
                "DAT_0800040c": "serial_rx_hook",
                "iVar1": "has_data",
                "data": "received_data",
                "c": "hook_result"
            },
            "code": "uint8_t read_serial_data_08008286(void)\n{\n  uint8_t received_data;\n  int has_data;\n  uint8_t hook_result;\n  \n  has_data = PTR_08000400();\n  if (has_data) {\n    received_data = PTR_08000404();\n    hook_result = DAT_0800040c(received_data);\n    if (hook_result == 0) {\n      return received_data;\n    }\n  }\n  return 0xff;\n}",
            "called": [
                "serial_rx_hook",
                "usart_tstc",
                "usart_getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008286",
            "calling": [
                "protocol_process"
            ],
            "imported": false,
            "current_name": "read_serial_data_08008286"
        },
        "FUN_0800b5bc": {
            "renaming": {
                "FUN_0800b5bc": "do_nothing_0800b5bc"
            },
            "code": "\nvoid do_nothing_0800b5bc(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b5bc",
            "calling": [
                "__libc_fini_array"
            ],
            "imported": false,
            "current_name": "do_nothing_0800b5bc"
        },
        "FUN_08008b74": {
            "renaming": {
                "FUN_08008b74": "is_valid_input_08008b74",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4"
            },
            "code": "int is_valid_input_08008b74(uint32_t input1, int input2, uint32_t input3, int input4)\n{\n  int is_input2_valid = ((input2 << 1) >> 0x15 != -1) || ((input1 | input2 << 0xc) == 0);\n  int is_input4_valid = ((input4 << 1) >> 0x15 != -1 || ((input3 | input4 << 0xc) == 0));\n  if (is_input2_valid && is_input4_valid) {\n    return 1;\n  }\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b74",
            "calling": [
                "sqrt"
            ],
            "imported": false,
            "current_name": "is_valid_input_08008b74"
        },
        "FUN_0800b524": {
            "renaming": {
                "FUN_0800b524": "add_to_global_array_0800b524",
                "param_1": "value",
                "param_2": "array_ptr",
                "param_3": "array_size",
                "param_4": "flag",
                "puVar1": "recursive_mutex",
                "uVar2": "ret_val",
                "uVar3": "bitmask",
                "iVar4": "global_impure_ptr",
                "iVar5": "global_array_ptr",
                "uVar6": "global_array_size",
                "PTR___atexit_recursive_mutex_0800b5ac": "recursive_mutex",
                "PTR__global_impure_ptr_0800b5a8": "global_impure_ptr"
            },
            "code": "int add_to_global_array_0800b524(int value, int* array_ptr, int array_size, int flag) {\n  \n  // Acquire recursive lock\n  __retarget_lock_acquire_recursive(*PTR___atexit_recursive_mutex_0800b5ac);\n  \n  // Get the global array and its size\n  int* global_array_ptr = *(int**)PTR__global_impure_ptr_0800b5a8;\n  int global_array_size = *(global_array_ptr + 328);\n  \n  // If the global array is full, release the lock and return an error\n  if (global_array_size >= 32) {\n    __retarget_lock_release_recursive(*PTR___atexit_recursive_mutex_0800b5ac);\n    return -1;\n  }\n  \n  // Add the value to the global array and update the size\n  int index = global_array_size;\n  *(global_array_ptr + 328) = index + 1;\n  *(global_array_ptr + (index + 2)) = value;\n  *(global_array_ptr + (index * 4 + 392)) = array_ptr;\n  *(global_array_ptr + (index * 4 + 264)) = flag;\n  \n  // Release the lock and return success\n  __retarget_lock_release_recursive(*PTR___atexit_recursive_mutex_0800b5ac);\n  return 0;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b524",
            "calling": [
                "atexit"
            ],
            "imported": false,
            "current_name": "add_to_global_array_0800b524"
        },
        "FUN_08005214": {
            "renaming": {
                "FUN_08005214": "do_nothing_08005214"
            },
            "code": "\nvoid do_nothing_08005214(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005214",
            "calling": [
                "spindle_stop"
            ],
            "imported": false,
            "current_name": "do_nothing_08005214"
        },
        "FUN_08009818": {
            "renaming": {
                "FUN_08009818": "calculate_trigonometric_function_08009818",
                "param_1": "numerator1",
                "param_2": "numerator2",
                "param_3": "denominator1",
                "param_4": "denominator2",
                "param_5": "angle",
                "iVar1": "difference",
                "unaff_r4": "unaffected_register4",
                "uVar2": "sign_bits",
                "uVar3": "positive_denominator1",
                "uVar4": "positive_denominator2",
                "uVar5": "difference",
                "DAT_08009af0": "maximum_value1",
                "DAT_08009af4": "maximum_value2",
                "DAT_08009b18": "maximum_denominator",
                "__aeabi_dadd": "addition",
                "__divdf3": "division",
                "__subdf3": "subtraction",
                "atan": "arctangent",
                "fabs": "absolute_value",
                "CONCAT44": "concatenation_of_44_bits",
                "SCARRY4": "4_bit_signed_carry"
            },
            "code": "void calculate_trigonometric_function_08009818(uint32_t numerator1, uint32_t numerator2, uint32_t denominator1, uint32_t denominator2, double angle)\n{\n    uint32_t positive_denominator1 = denominator1 & 0x7fffffff;\n    uint32_t positive_denominator2 = denominator2 & 0x7fffffff;\n    if((DAT_08009b18 < (positive_denominator2 | (-denominator1 | denominator1) >> 0x1f)) || (DAT_08009b18 < (positive_denominator1 | (-numerator1 | numerator1) >> 0x1f))) {\n        __aeabi_dadd(denominator1, denominator2, numerator1, numerator2);\n    }\n    else {\n        if((denominator2 + 0xc0100000 | denominator1) == 0) {\n            atan(angle);\n            return;\n        }\n        uint32_t sign_bits = (int)denominator2 >> 0x1e & 2U | numerator2 >> 0x1f;\n        if((((positive_denominator1 | numerator1) != 0) && ((positive_denominator2 | denominator2) != 0)) && (positive_denominator2 != DAT_08009b18) && (positive_denominator1 != DAT_08009b18)) {\n            int32_t difference = (int32_t)(positive_denominator2 - positive_denominator1) >> 0x14;\n            if((int32_t)(positive_denominator2 - positive_denominator1) < 0x3d00000 && ((-1 < (int32_t)denominator2 || (difference + 0x3c < 0 == SCARRY4(difference, 0x3c))))) {\n                __divdf3(numerator1, numerator2, denominator1, denominator2);\n                double absolute_value = fabs((double)CONCAT44(unaff_r4, denominator2));\n                atan(absolute_value);\n            }\n            if(sign_bits != 1) {\n                if(sign_bits == 2) {\n                    uint64_t difference = __subdf3();\n                    __subdf3(DAT_08009af0, DAT_08009af4, (int32_t)difference, (int32_t)(difference >> 0x20));\n                }\n                else if(sign_bits != 0) {\n                    uint64_t difference = __subdf3();\n                    __subdf3((int32_t)difference, (int32_t)(difference >> 0x20), DAT_08009af0, DAT_08009af4);\n                }\n            }\n        }\n    }\n    return;\n}",
            "called": [
                "__ieee754_atan2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009818",
            "calling": [
                "mc_arc"
            ],
            "imported": false,
            "current_name": "calculate_trigonometric_function_08009818"
        },
        "FUN_08007ea4": {
            "renaming": {
                "FUN_08007ea4": "set_USART_flags_08007ea4",
                "usart": "usart_instance",
                "DAT_08007f38": "USART1",
                "DAT_08007f40": "USART2",
                "DAT_08007f44": "USART3",
                "DAT_08007f48": "UART4",
                "DAT_08007f4c": "UART5",
                "DAT_08007f50": "USART6",
                "usart_flags": "usart_flags_ptr",
                "usart_error_flags": "usart_error_flags_ptr"
            },
            "code": "void set_USART_flags_08007ea4(USART_TypeDef *usart)\n{\n    uint32_t *usart_flags = (uint32_t *)(DAT_08007f3c + 0x40);\n    uint32_t *usart_error_flags = (uint32_t *)(DAT_08007f3c + 0x44);\n\n    if (usart == DAT_08007f38) {\n        *usart_error_flags |= 0x10;\n    }\n    else if (usart == DAT_08007f40) {\n        *usart_flags |= 0x20000;\n    }\n    else if (usart == DAT_08007f44) {\n        *usart_flags |= 0x40000;\n    }\n    else if (usart == DAT_08007f48) {\n        *usart_flags |= 0x80000;\n    }\n    else if (usart == DAT_08007f4c) {\n        *usart_flags |= 0x100000;\n    }\n    else if (usart == DAT_08007f50) {\n        *usart_error_flags |= 0x20;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ea4",
            "calling": [
                "usart_init"
            ],
            "imported": false,
            "current_name": "set_USART_flags_08007ea4"
        },
        "FUN_08007756": {
            "renaming": {
                "FUN_08007756": "poll_gpio_and_debounce_08007756",
                "uVar1": "current_ticks",
                "ticks": "N/A",
                "gpio_toggle": "toggle_gpio",
                "HAL_GetTick": "get_current_ticks",
                "HAL_IncTick": "increment_system_tick",
                "0x3c": "PTR_GPIO_PIN",
                "0x1ff": "MASK_GPIO_TOGGLE",
                "0xf": "MASK_DEBOUNCE_ISR"
            },
            "code": "void poll_gpio_and_debounce_08007756(void)\n{\n  uint32_t current_ticks;\n  current_ticks = HAL_GetTick();\n  if ((current_ticks & 0x1ff) == 0)\n  {\n    gpio_toggle(PTR_GPIO_PIN);\n  }\n  if ((current_ticks & 0xf) == 0)\n  {\n    debounce_isr();\n  }\n  HAL_IncTick();\n  return;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_IncTick",
                "gpio_toggle",
                "debounce_isr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007756",
            "calling": [],
            "imported": false,
            "current_name": "poll_gpio_and_debounce_08007756"
        },
        "FUN_0800b520": {
            "renaming": {
                "FUN_0800b520": "do_nothing_0800b520"
            },
            "code": "\nvoid do_nothing_0800b520(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b520",
            "calling": [
                "__register_exitproc"
            ],
            "imported": false,
            "current_name": "do_nothing_0800b520"
        },
        "FUN_0800774a": {
            "renaming": {
                "FUN_0800774a": "do_nothing_0800774a"
            },
            "code": "\nvoid do_nothing_0800774a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800774a",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800774a"
        },
        "FUN_0800423c": {
            "renaming": {
                "FUN_0800423c": "printGrblSettings_0800423c",
                "PTR_s_____view_Grbl_settings______view_0800424": "view_Grbl_settings"
            },
            "code": "void printGrblSettings_0800423c() {\n  printPgmString(PTR_s_____view_Grbl_settings______view_0800424);\n  return;\n}",
            "called": [
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800423c",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "printGrblSettings_0800423c"
        },
        "FUN_080064d4": {
            "renaming": {
                "FUN_080064d4": "clear_data_080064d4",
                "DAT_080064e8": "data_pointer"
            },
            "code": "void clear_data_080064d4(void)\n{\n  *DAT_080064e8 = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064d4",
            "calling": [],
            "imported": false,
            "current_name": "clear_data_080064d4"
        },
        "FUN_08006e38": {
            "renaming": {
                "FUN_08006e38": "set_clock_source_08006e38",
                "CLKSource": "clk_source",
                "*DAT_08006e6c": "*data_pointer"
            },
            "code": "void set_clock_source_08006e38(uint32_t clk_source) {\n  if (clk_source == 4) {\n    *DAT_08006e6c = *DAT_08006e6c | 4;\n  }\n  else {\n    *DAT_08006e6c = *DAT_08006e6c & 0xfffffffb;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e38",
            "calling": [],
            "imported": false,
            "current_name": "set_clock_source_08006e38"
        },
        "FUN_08009264": {
            "renaming": {
                "FUN_08009264": "isStringEmpty_08009264",
                "in_CY": "inputChar"
            },
            "code": "bool isStringEmpty_08009264(void)\\n{\\n  char inputChar;\\n  __aeabi_cfrcmple();\\n  return inputChar == \"\\0\";\\n}",
            "called": [
                "__aeabi_cfrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009264",
            "calling": [
                "planner_reverse_pass_kernel",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "isStringEmpty_08009264"
        },
        "FUN_08007e08": {
            "renaming": {
                "FUN_08007e08": "initialize_timers_08007e08",
                "step_timer_init": "initialize_step_timer",
                "g540_timer_init": "initialize_g540_timer",
                "g540_timer_start": "start_g540_timer"
            },
            "code": "void initialize_timers_08007e08(void)\n{\n  initialize_step_timer();\n  initialize_g540_timer();\n  start_g540_timer();\n  return;\n}",
            "called": [
                "g540_timer_start",
                "g540_timer_init",
                "step_timer_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e08",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_timers_08007e08"
        },
        "FUN_08002fac": {
            "renaming": {
                "FUN_08002fac": "is_buffer_tail_equal_to_next_head_08002fac",
                "*PTR_block_buffer_tail_08002fcc": "*block_buffer_tail",
                "*PTR_next_buffer_head_08002fd0": "*next_buffer_head_pointer"
            },
            "code": "bool is_buffer_tail_equal_to_next_head_08002fac(void)\n{\n    uint8_t buffer_tail = *PTR_block_buffer_tail_08002fcc;\n    uint8_t next_buffer_head = *PTR_next_buffer_head_08002fd0;\n    return buffer_tail == next_buffer_head;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fac",
            "calling": [
                "mc_line"
            ],
            "imported": false,
            "current_name": "is_buffer_tail_equal_to_next_head_08002fac"
        },
        "FUN_08005b04": {
            "renaming": {
                "FUN_08005b04": "set_flag_on_08005b04",
                "DAT_08005b1c": "flag_data"
            },
            "code": "void set_flag_on_08005b04(void)\n{\n    uint32_t* flag_ptr = (uint32_t*)(DAT_08005b1c + 4);\n    *flag_ptr |= 1;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b04",
            "calling": [],
            "imported": false,
            "current_name": "set_flag_on_08005b04"
        },
        "FUN_080002b6": {
            "renaming": {
                "FUN_080002b6": "wait_for_microseconds_080002b6",
                "_us": "microseconds",
                "uVar1": "current_microseconds",
                "bVar2": "timeout_reached",
                "uVar3": "start_microseconds",
                "uVar4": "current_usecs",
                "timeout": "timeout_microseconds"
            },
            "code": "void wait_for_microseconds_080002b6(uint microseconds)\n{\n  uint current_microseconds;\n  bool timeout_reached;\n  uint64_t start_microseconds = get_current_usecs();\n  do {\n    current_microseconds = (uint)(get_current_usecs() >> 0x20);\n    uint64_t timeout_microseconds = start_microseconds + microseconds;\n    timeout_reached = timeout_microseconds._4_4_ <= current_microseconds;\n    if (current_microseconds == timeout_microseconds._4_4_) {\n      timeout_reached = (uint)timeout_microseconds <= (uint)get_current_usecs();\n    }\n  } while (!timeout_reached);\n}",
            "called": [
                "get_current_usecs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002b6",
            "calling": [],
            "imported": false,
            "current_name": "wait_for_microseconds_080002b6"
        },
        "FUN_080075c8": {
            "renaming": {
                "FUN_080075c8": "calculateSystemCoreClock_080075c8",
                "uVar1": "systemClockConfig",
                "pllm": "pllmValue",
                "pllsource": "N/A",
                "pllp": "pllpValue",
                "tmp": "N/A",
                "pllvco": "pllvco",
                "PTR_SystemCoreClock_080076b8": "systemCoreClockAddress",
                "DAT_080076b4": "systemClockConfigAddress",
                "PTR_AHBPrescTable_080076c4": "ahbPrescaler"
            },
            "code": "void calculateSystemCoreClock_080075c8(void)\n{\n  uint systemClockConfig = *(uint *)(DAT_080076b4 + 8) & 0xc;\n  if (systemClockConfig == 8) {\n    uint32_t pllm = *(uint *)(DAT_080076b4 + 4) & 0x3f;\n    if ((*(uint *)(DAT_080076b4 + 4) >> 0x16 & 1) == 0) {\n      uint32_t pllvco = (*(uint *)(DAT_080076b4 + 4) >> 6 & 0x1ff) * (pllmValue / pllm);\n      *(uint *)PTR_SystemCoreClock_080076b8 = pllvco / (((*(uint *)(DAT_080076b4 + 4) >> 0x10 & 3) + 1) * 2);\n    }\n    else {\n      uint32_t pllvco = (*(uint *)(DAT_080076b4 + 4) >> 6 & 0x1ff) * (pllpValue / pllm);\n      *(uint *)PTR_SystemCoreClock_080076b8 = pllvco / (((*(uint *)(DAT_080076b4 + 4) >> 0x10 & 3) + 1) * 2);\n    }\n  }\n  else if (systemClockConfig == 0) {\n    *(uint *)PTR_SystemCoreClock_080076b8 = pllmValue;\n  }\n  else if (systemClockConfig == 4) {\n    *(uint *)PTR_SystemCoreClock_080076b8 = pllpValue;\n  }\n  else {\n    *(uint *)PTR_SystemCoreClock_080076b8 = pllmValue;\n  }\n  *(uint *)PTR_SystemCoreClock_080076b8 = *(uint *)PTR_SystemCoreClock_080076b8 >> PTR_AHBPrescTable_080076c4[*(uint *)(DAT_080076b4 + 8) >> 4 & 0xf];\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080075c8",
            "calling": [],
            "imported": false,
            "current_name": "calculateSystemCoreClock_080075c8"
        }
    },
    "used_tokens": 275126,
    "layers": [
        [
            "FUN_0800192c",
            "FUN_08006950",
            "FUN_08008ba0",
            "FUN_08005b90",
            "FUN_080071d0",
            "FUN_08008e60",
            "FUN_08005984",
            "FUN_08006718",
            "FUN_08007a10",
            "FUN_0800856c",
            "FUN_08008b00",
            "FUN_0800585c",
            "FUN_0800597c",
            "FUN_08009314",
            "FUN_08009798",
            "FUN_08007930",
            "FUN_08000188",
            "FUN_08008e70",
            "FUN_08009318",
            "FUN_080018cc",
            "FUN_080079e0",
            "FUN_08006a58",
            "FUN_08005a84",
            "FUN_08008b10",
            "FUN_0800736c",
            "FUN_08008c30",
            "FUN_08007bf0",
            "FUN_08008590",
            "FUN_08007ad0",
            "FUN_080039a0",
            "FUN_08009204",
            "FUN_080029d8",
            "FUN_08007c5e",
            "FUN_08005760",
            "FUN_08008b24",
            "FUN_0800587c",
            "FUN_08008a02",
            "FUN_0800369c",
            "FUN_08005a98",
            "FUN_080044e8",
            "FUN_08006c9c",
            "FUN_0800195c",
            "FUN_08009214",
            "FUN_08004dd2",
            "FUN_08005778",
            "FUN_080028bc",
            "FUN_08006628",
            "FUN_08008b38",
            "FUN_0800738e",
            "FUN_080092c4",
            "FUN_08008250",
            "FUN_0800184c",
            "FUN_08005ad4",
            "FUN_08005b3c",
            "FUN_08006ce0",
            "FUN_08006d4a",
            "FUN_08000374",
            "FUN_080037fc",
            "FUN_08007dd8",
            "FUN_0800a1bc",
            "FUN_0800525c",
            "FUN_080073d4",
            "FUN_08006dfe",
            "FUN_08006d66",
            "FUN_08006e88",
            "FUN_0800b4f0",
            "FUN_080036f0",
            "FUN_08005c74",
            "FUN_0800375c",
            "FUN_08009990",
            "FUN_08005b58",
            "FUN_08007e58",
            "FUN_080059f8",
            "FUN_08009194",
            "FUN_08003f34",
            "FUN_080095b8",
            "FUN_08006cf6",
            "FUN_08002ef0",
            "FUN_08001d4c",
            "FUN_08000268",
            "FUN_0800918c",
            "FUN_08003778",
            "FUN_0800b3dc",
            "FUN_080046d0",
            "FUN_08006d72",
            "FUN_0800756c",
            "FUN_0800691c",
            "FUN_080001f8",
            "FUN_08002f74",
            "FUN_0800b3e8",
            "FUN_08006a18",
            "FUN_08002c18",
            "FUN_08006ac0",
            "FUN_0800919c",
            "FUN_0800b2cc",
            "FUN_0800854c",
            "FUN_08008e44",
            "FUN_0800733e",
            "FUN_08005aec",
            "FUN_08005b74",
            "FUN_0800583c",
            "FUN_08001e98",
            "FUN_080069e4",
            "FUN_0800b2d4",
            "FUN_08008e3c",
            "FUN_08009654",
            "FUN_08007bc2",
            "FUN_080035ec",
            "FUN_08006c70",
            "FUN_080068bc",
            "FUN_08006d98",
            "FUN_08005a68",
            "FUN_080079c0",
            "FUN_0800b2e0",
            "FUN_08002908",
            "FUN_08007c40",
            "FUN_080094c0",
            "FUN_08006b54",
            "FUN_08007e84",
            "FUN_080057e4",
            "FUN_08006d8a",
            "FUN_0800b2e8",
            "FUN_08007520",
            "FUN_08007884",
            "FUN_08004250",
            "FUN_08006dc4",
            "FUN_08007402",
            "FUN_08002870",
            "FUN_08000210",
            "FUN_08008a64",
            "FUN_08005900",
            "FUN_08002638",
            "FUN_08005bac",
            "FUN_080051b4",
            "FUN_08005c30",
            "FUN_0800056c",
            "FUN_08002f24",
            "FUN_080059b4",
            "FUN_08006c04",
            "FUN_08002e08",
            "FUN_08005bc4",
            "FUN_08006680",
            "FUN_08000340",
            "FUN_08004bf4",
            "FUN_08004d7c",
            "FUN_08009278",
            "FUN_080004fc",
            "FUN_08000220",
            "FUN_08005238",
            "FUN_08007da8",
            "FUN_08004148",
            "FUN_08004940",
            "FUN_08008a74",
            "FUN_08002fd4",
            "FUN_08002408",
            "FUN_08003618",
            "FUN_08005b20",
            "FUN_08007d08",
            "FUN_080091fc",
            "FUN_080058a0",
            "FUN_08008a6c",
            "FUN_080036c6",
            "FUN_08008190",
            "FUN_080074c8",
            "FUN_0800b430",
            "FUN_08004030",
            "FUN_08005360",
            "FUN_08003980",
            "FUN_08006de0",
            "FUN_080052dc",
            "FUN_080064ec",
            "FUN_08006ba0",
            "FUN_080003ec",
            "FUN_08002896",
            "FUN_080001ac",
            "FUN_08003740",
            "FUN_08000478",
            "FUN_08006d2e",
            "FUN_08007e1c",
            "FUN_0800adf0",
            "FUN_08003a74",
            "FUN_08006b00",
            "FUN_0800b4d0",
            "FUN_08007f54",
            "FUN_08003b98",
            "FUN_080024c4",
            "FUN_08002f40",
            "FUN_080025e8",
            "FUN_08005ac4",
            "FUN_08005250",
            "FUN_08007430",
            "FUN_08007310",
            "FUN_08007436",
            "FUN_08005814",
            "FUN_08005bdc",
            "FUN_080085d4",
            "FUN_08006e70",
            "FUN_080002f0",
            "FUN_0800778c",
            "FUN_08001ddc",
            "FUN_080069b4",
            "FUN_0800b4e4",
            "FUN_08007720",
            "FUN_08009228",
            "FUN_08007c7c",
            "FUN_08007726",
            "FUN_08007b70",
            "FUN_08004d2c",
            "FUN_080066cc",
            "FUN_080018fc",
            "FUN_080039bc",
            "FUN_0800618c",
            "FUN_08006998",
            "FUN_080004ac",
            "FUN_080078f4",
            "FUN_080041a0",
            "FUN_08008bf0",
            "FUN_0800771a",
            "FUN_08003a18",
            "FUN_08005790",
            "FUN_08007854",
            "FUN_08004900",
            "FUN_08004228",
            "FUN_080076c8",
            "FUN_08006a8c",
            "FUN_0800772c",
            "FUN_0800283a",
            "FUN_0800881c",
            "FUN_08004bc0",
            "FUN_08008b4c",
            "FUN_08004c2a",
            "FUN_0800826a",
            "FUN_08008b60",
            "FUN_08005324",
            "FUN_08000310",
            "FUN_08007a70",
            "FUN_0800b5b0",
            "FUN_08002978",
            "FUN_08003826",
            "FUN_0800923c",
            "FUN_08002afc",
            "FUN_08004c48",
            "FUN_080002a0",
            "FUN_08009250",
            "FUN_0800640c",
            "FUN_08008af0",
            "FUN_08006e1a",
            "FUN_080052ac",
            "FUN_080064bc",
            "FUN_08008286",
            "FUN_08008b74",
            "FUN_0800b524",
            "FUN_08009818",
            "FUN_08007ea4",
            "FUN_08007756",
            "FUN_0800423c",
            "FUN_080064d4",
            "FUN_08006e38",
            "FUN_08009264",
            "FUN_08007e08",
            "FUN_08002fac",
            "FUN_08005b04",
            "FUN_080002b6",
            "FUN_080075c8"
        ],
        [
            "FUN_08002edc",
            "FUN_080096e8",
            "FUN_08002ba8",
            "FUN_08009410",
            "FUN_080098d0",
            "FUN_0800981c",
            "FUN_08002a94",
            "FUN_08007540"
        ],
        [
            "FUN_080082c8",
            "FUN_08008cd0",
            "FUN_08008cd8",
            "FUN_080082d0",
            "FUN_08004e30",
            "FUN_080082d4",
            "FUN_08008590",
            "FUN_080005b4",
            "FUN_08008cdc",
            "FUN_0800a5a0",
            "FUN_080053a0",
            "FUN_08001f00",
            "FUN_08008894",
            "FUN_080085e4",
            "FUN_08008eec",
            "FUN_0800af78",
            "FUN_0800a348",
            "FUN_08005cec",
            "FUN_08009054",
            "FUN_08008640",
            "FUN_08003004",
            "FUN_08001994",
            "FUN_08009b24",
            "FUN_08009d78"
        ],
        [
            "FUN_08004250"
        ]
    ],
    "locked_functions": []
}