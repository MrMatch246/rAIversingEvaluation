{
    "functions": {
        "FUN_0800192c": {
            "renaming": {
                "FUN_0800192c": "check_data_integrity_0800192c",
                "PTR_DAT_08001954": "data_array",
                "PTR_DAT_08001958": "integrity_flag"
            },
            "code": "void check_data_integrity_0800192c(void)\n{\n    int data_PTR_DAT_08001958 = PTR_DAT_08001954[0x28] & 8;\n    if (data_PTR_DAT_08001958 == 0) {\n        *(int *)PTR_DAT_08001958 = 0;\n    }\n    else {\n        *(int *)PTR_DAT_08001958 = 1;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800192c",
            "calling": [
                "FUN_08004e30",
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "check_data_integrity_0800192c"
        },
        "FUN_08006950": {
            "renaming": {
                "FUN_08006950": "update_register_value_08006950",
                "param_1": "register_value",
                "DAT_08006994": "register_address",
                "register_ptr": "register_pointer",
                "masked_value": "value_mask",
                "shifted_value": "value_shifted",
                "final_value": "value_final"
            },
            "code": "void update_register_value_08006950(uint register_value) {\n    uint* register_ptr = (uint*)(DAT_08006994 + 0xc);\n    uint masked_value = register_value & 7;\n    uint shifted_value = masked_value << 8;\n    uint final_value = shifted_value | 0x5fa0000;\n    *register_ptr = (*register_ptr & 0xf8ff) | final_value;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006950",
            "calling": [
                "FUN_08006ce0"
            ],
            "imported": false,
            "current_name": "update_register_value_08006950"
        },
        "FUN_08008ba0": {
            "renaming": {
                "FUN_08008ba0": "calculate_08008ba0",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar1": "quotient",
                "iVar2": "temp",
                "uVar3": "temp1"
            },
            "code": "uint calculate_08008ba0(uint dividend, uint divisor)\n{\n    uint quotient;\n    int temp;\n    uint temp1;\n    \n    temp = divisor * 2 + 0x200000;\n    if (divisor * 2 < 0xffe00000) {\n        if (-1 < temp) {\n            return 0;\n        }\n        quotient = temp >> 0x15;\n        temp1 = -quotient - 0x3e1;\n        if (quotient < 0xfffffc20 && temp1 != 0) {\n            quotient = (divisor << 0xb | 0x80000000 | dividend >> 0x15) >> (temp1 & 0xff);\n            if ((divisor & 0x80000000) != 0) {\n                quotient = -quotient;\n            }\n            return quotient;\n        }\n    }\n    else if ((dividend | divisor << 0xc) != 0) {\n        return 0;\n    }\n    divisor = divisor & 0x80000000;\n    if (divisor == 0) {\n        divisor = 0x7fffffff;\n    }\n    return divisor;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ba0",
            "calling": [
                "FUN_0800a348",
                "FUN_080005b4",
                "FUN_08009d78",
                "FUN_0800a5a0",
                "FUN_08003004",
                "FUN_0800adf0",
                "FUN_080095b8",
                "FUN_08002c18"
            ],
            "imported": false,
            "current_name": "calculate_08008ba0"
        },
        "FUN_08005a5c": {
            "renaming": {
                "FUN_08005a5c": "do_nothing_08005a5c"
            },
            "code": "\nvoid do_nothing_08005a5c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a5c",
            "calling": [
                "FUN_080059f8"
            ],
            "imported": false,
            "current_name": "do_nothing_08005a5c"
        },
        "FUN_08005984": {
            "renaming": {
                "FUN_08005984": "print_system_call_if_not_null_08005984",
                "param_1": "arg1",
                "uVar1": "result",
                "PTR_DAT_080059b0": "ptr",
                "print_system_call_info_0800597c": "print_system_call_info"
            },
            "code": "int print_system_call_if_not_null_08005984(int arg1) {\n  int* PTR_DAT_080059b0 = (int*)PTR_DAT_080059b0;\n  if (*PTR_DAT_080059b0 != 0) {\n    return 0;\n  }\n  else {\n    return print_system_call_info_0800597c(1, arg1, 0);\n  }\n}",
            "called": [
                "FUN_0800597c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005984",
            "calling": [
                "FUN_08007540"
            ],
            "imported": false,
            "current_name": "print_system_call_if_not_null_08005984"
        },
        "FUN_08007a10": {
            "renaming": {
                "FUN_08007a10": "set_flag_08007a10",
                "param_1": "flag_value",
                "DAT_08007a64": "flag_ptr",
                "uint": "unsigned int"
            },
            "code": "void set_flag_08007a10(int flag_value) {\n    uint* DAT_08007a64 = (uint*)(DAT_08007a64 + 0x40);\n    if (flag_value == 0x40000000) {\n        *DAT_08007a64 |= 1;\n    } else if (flag_value == DAT_08007a68) {\n        *DAT_08007a64 |= 2;\n    } else if (flag_value == DAT_08007a6c) {\n        *DAT_08007a64 |= 4;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007a10",
            "calling": [
                "FUN_08007ad0",
                "FUN_08007d08"
            ],
            "imported": false,
            "current_name": "set_flag_08007a10"
        },
        "FUN_0800856c": {
            "renaming": {
                "FUN_0800856c": "calculate_0800856c",
                "param_1": "num",
                "uVar1": "count",
                "uVar2": "abs_num",
                "uVar3": "shift_amount",
                "iVar4": "count_leading_zeroes_result",
                "uVar5": "shift_amount_2",
                "uVar6": "is_negative",
                "bVar7": "count_leading_zeroes_negative",
                "bVar8": "count_leading_zeroes_zero",
                "bVar9": "shift_amount_2_carry",
                "in_r12": "shift_amount_3",
                "shift_amount_5": "shift_amount_5",
                "shift_amount_6": "shift_amount_6",
                "shifted_num": "shifted_num",
                "shifted_num_2": "shifted_num_2",
                "shifted_num_3": "shifted_num_3",
                "shifted_num_4": "shifted_num_4",
                "shifted_num_5": "shifted_num_5",
                "count_leading_zeroes": "count_leading_zeroes"
            },
            "code": "ulonglong calculate_0800856c(uint num)\n{\n    uint count = 0;\n    while (num > 0)\n    {\n        count++;\n        num >>= 1;\n    }\n    return (64 - count);\n}\n\nulonglong calculate_0800856c(uint num)\n{\n    if (num == 0)\n    {\n        return 0;\n    }\n    uint is_negative = num & 0x80000000;\n    uint abs_num = (is_negative < 0) ? -num : num;\n    uint shift_amount = calculate_0800856c(abs_num) + 0x15;\n    if (shift_amount < 0x20)\n    {\n        uint shift_amount_2 = (shift_amount < 0xb) ? 0xb : shift_amount;\n        uint shifted_num = abs_num << (shift_amount & 0xff);\n        uint shifted_num_2 = abs_num >> ((0x20 - shift_amount_2) & 0xff);\n        return ((shifted_num_2 | shifted_num) | is_negative);\n    }\n    uint shift_amount_3 = (shift_amount < 0x433) ? (0x432 - shift_amount) * 0x100000 : 0;\n    uint shifted_num_3 = abs_num << (shift_amount & 0xff);\n    uint shifted_num_4 = (shift_amount < 0x433) ? (shifted_num_3 | shift_amount_3) : abs_num;\n    if (shift_amount >= 0x20)\n    {\n        uint shift_amount_5 = 0x20 - (shift_amount - 0x1f);\n        return ((shifted_num_4 >> shift_amount_5) | (is_negative | (shifted_num_4 << (0x20 - shift_amount_5))));\n    }\n    uint shift_amount_6 = shift_amount - 0x13;\n    if (shift_amount_6 > 0 && (shift_amount_6 < 0x1e) && ((shift_amount - 0x1f) - shift_amount_6 < 0xc))\n    {\n        shift_amount_6++;\n        uint shifted_num_5 = (shifted_num_4 >> (shift_amount_6 & 0xff)) | (shifted_num_4 << (0x20 - shift_amount_6 & 0xff));\n        uint shifted_num_6 = (shift_amount_6 < 0x20) ? (is_negative | (shifted_num_4 >> (shift_amount_6 & 0xff))) : num;\n        return (shifted_num_5 | shifted_num_6);\n    }\n    return (num | (shifted_num_4 >> (0x20 - (0xc - shift_amount_6) & 0xff)));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800856c",
            "calling": [
                "FUN_08009d78",
                "FUN_0800a5a0",
                "FUN_08002c18"
            ],
            "imported": false,
            "current_name": "calculate_0800856c"
        },
        "FUN_08008b00": {
            "renaming": {
                "FUN_08008b00": "check_collision_and_return_result_08008b00",
                "param_1": "result"
            },
            "code": "void check_collision_and_return_result_08008b00(int result) {\n  check_collision();\n  return result;\n}",
            "called": [
                "FUN_08008a74"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b00",
            "calling": [
                "FUN_08008b24",
                "FUN_08008af0",
                "FUN_08008b10"
            ],
            "imported": false,
            "current_name": "check_collision_and_return_result_08008b00"
        },
        "FUN_0800585c": {
            "renaming": {
                "FUN_0800585c": "set_flags_if_second_element_is_two_0800585c",
                "PTR_DAT_08005878": "PTR_data",
                "set_flags_based_on_data_08005790": "set_flags_based_on_data"
            },
            "code": "void set_flags_if_second_element_is_two_0800585c(void)\n{\n  if (PTR_DAT_08005878[1] == '\\x02') {\n    PTR_DAT_08005878[1] = 3;\n    set_flags_based_on_data_08005790();\n  }\n  return;\n}",
            "called": [
                "FUN_08005790"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800585c",
            "calling": [
                "FUN_08001e98",
                "FUN_080024c4",
                "FUN_08003a74"
            ],
            "imported": false,
            "current_name": "set_flags_if_second_element_is_two_0800585c"
        },
        "FUN_0800597c": {
            "renaming": {
                "FUN_0800597c": "print_system_call_info_0800597c",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void print_system_call_info_0800597c(void)\n{\n\tsoftware_interrupt(SYSTEM_CALL_INTERRUPT);\n\treturn;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800597c",
            "calling": [
                "FUN_08005984"
            ],
            "imported": false,
            "current_name": "print_system_call_info_0800597c"
        },
        "FUN_08009798": {
            "renaming": {
                "FUN_08009798": "calculate_08009798",
                "param_1": "numerator",
                "param_2": "denominator",
                "param_3": "param_3",
                "param_4": "param_4",
                "uVar1": "exponent",
                "uVar2": "shifted_denominator",
                "lVar3": "result",
                "DAT_08009814": "denominator_shift_constant"
            },
            "code": "longlong calculate_08009798(uint numerator, uint denominator, undefined4 param_3, undefined4 param_4)\n{\n  uint shifted_denominator = (denominator << 1) >> 0x15;\n  uint exponent = shifted_denominator - 0x3ff;\n  if ((int)exponent < 0x14) {\n    if ((int)exponent < 0) {\n      return ((ulonglong)denominator & 0x80000000) << 0x20;\n    }\n    longlong shifted_numerator = (ulonglong)(numerator & ~(DAT_08009814 >> (exponent & 0xff))) << 0x20;\n    return shifted_numerator;\n  }\n  else {\n    if ((int)exponent < 0x34) {\n      uint mask = ~(0xffffffffU >> (shifted_denominator - 0x413 & 0xff));\n      longlong masked_numerator = numerator & mask;\n      return CONCAT44(denominator, masked_numerator);\n    }\n    if (exponent != 0x400) {\n      return CONCAT44(denominator, numerator);\n    }\n    longlong result = calculate_double_precision_080082d4(numerator, denominator, numerator, denominator, param_4);\n    return result;\n  }\n}",
            "called": [
                "FUN_080082d4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009798",
            "calling": [
                "FUN_080005b4",
                "FUN_08004e30",
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "calculate_08009798"
        },
        "FUN_08008cd8": {
            "renaming": {
                "FUN_08008cd8": "calculate_float_08008cd8",
                "param_1": "float_bits_1",
                "param_2": "float_bits_2",
                "param_3": "float_bits_3",
                "param_4": "float_bits_4",
                "iVar1": "leading_zeroes_count",
                "uVar2": "float_bits_2_complement",
                "uVar3": "float_bits_3_complement",
                "uVar4": "float_bits_1_extended",
                "uVar6": "difference",
                "iVar7": "MSB_float_bits_1_extended",
                "bVar8": "comparison_result"
            },
            "code": "\nuint calculate_float_08008cd8(uint float_bits_1,uint float_bits_2,undefined4 float_bits_3,uint float_bits_4)\n\n{\n  int leading_zeroes_count;\n  uint float_bits_2_complement;\n  uint float_bits_3_complement;\n  uint float_bits_1_extended;\n  uint uVar5;\n  uint difference;\n  int MSB_float_bits_1_extended;\n  bool comparison_result;\n  \n  float_bits_2_complement = float_bits_2 ^ 0x80000000;\n  float_bits_1_extended = float_bits_1 << 1;\n  comparison_result = float_bits_1_extended == 0;\n  if (!comparison_result) {\n    float_bits_4 = float_bits_2 << 1;\n    comparison_result = float_bits_4 == 0;\n  }\n  if (!comparison_result) {\n    comparison_result = float_bits_1_extended == float_bits_4;\n  }\n  MSB_float_bits_1_extended = (int)float_bits_1_extended >> 0x18;\n  if (!comparison_result) {\n    comparison_result = MSB_float_bits_1_extended == -1;\n  }\n  if (!comparison_result) {\n    comparison_result = (int)float_bits_4 >> 0x18 == -1;\n  }\n  if (comparison_result) {\n    leading_zeroes_count = (int)(float_bits_2 << 1) >> 0x18;\n    if (MSB_float_bits_1_extended == -1 || leading_zeroes_count == -1) {\n      float_bits_1_extended = float_bits_2_complement;\n      if (MSB_float_bits_1_extended == -1) {\n        float_bits_1_extended = float_bits_1;\n      }\n      if (MSB_float_bits_1_extended != -1 || leading_zeroes_count != -1) {\n        float_bits_2_complement = float_bits_1_extended;\n      }\n      comparison_result = (float_bits_1_extended & 0x7fffff) == 0;\n      if (comparison_result) {\n        comparison_result = (float_bits_2_complement & 0x7fffff) == 0;\n      }\n      if (comparison_result) {\n        comparison_result = float_bits_1_extended == float_bits_2_complement;\n      }\n      if (!comparison_result) {\n        float_bits_1_extended = float_bits_1_extended | 0x400000;\n      }\n      return float_bits_1_extended;\n    }\n    if (((float_bits_1 ^ float_bits_2_complement) & 0x7fffffff) != 0) {\n      if (float_bits_1_extended == 0) {\n        float_bits_1 = float_bits_2_complement;\n      }\n      return float_bits_1;\n    }\n    if (float_bits_1 != float_bits_2_complement) {\n      return 0;\n    }\n    if ((float_bits_1_extended & 0xff000000) == 0) {\n      float_bits_2_complement = float_bits_1 << 1;\n      if ((float_bits_1 & 0x80000000) != 0) {\n        float_bits_2_complement = float_bits_2_complement | 0x80000000;\n      }\n      return float_bits_2_complement;\n    }\n    if (float_bits_1_extended < 0xfe000000) {\n      return float_bits_1 + 0x800000;\n    }\n    float_bits_1 = float_bits_1 & 0x80000000;\nLAB_08008e12:\n    return float_bits_1 | 0x7f800000;\n  }\n  float_bits_1_extended = float_bits_1_extended >> 0x18;\n  float_bits_4 = float_bits_4 >> 0x18;\n  difference = float_bits_4 - float_bits_1_extended;\n  comparison_result = difference != 0;\n  uVar5 = float_bits_1_extended;\n  if (comparison_result && float_bits_1_extended <= float_bits_4) {\n    uVar5 = float_bits_1_extended + difference;\n  }\n  if (comparison_result && float_bits_1_extended <= float_bits_4) {\n    float_bits_2_complement = float_bits_2_complement ^ float_bits_1;\n  }\n  if (comparison_result && float_bits_1_extended <= float_bits_4) {\n    float_bits_1 = float_bits_1 ^ float_bits_2_complement;\n  }\n  if (comparison_result && float_bits_1_extended <= float_bits_4) {\n    float_bits_2_complement = float_bits_2_complement ^ float_bits_1;\n  }\n  if (float_bits_4 < float_bits_1_extended) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return float_bits_1;\n  }\n  float_bits_1_extended = float_bits_1 & 0xffffff | 0x800000;\n  if ((float_bits_1 & 0x80000000) != 0) {\n    float_bits_1_extended = -float_bits_1_extended;\n  }\n  float_bits_3_complement = float_bits_2_complement & 0xffffff | 0x800000;\n  if ((float_bits_2_complement & 0x80000000) != 0) {\n    float_bits_3_complement = -float_bits_3_complement;\n  }\n  if (uVar5 == difference) {\n    float_bits_3_complement = float_bits_3_complement ^ 0x800000;\n    if (uVar5 == 0) {\n      float_bits_1_extended = float_bits_1_extended ^ 0x800000;\n      uVar5 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  float_bits_1_extended = float_bits_1_extended + ((int)float_bits_3_complement >> (difference & 0xff));\n  float_bits_3_complement = float_bits_3_complement << (0x20 - difference & 0xff);\n  float_bits_1 = float_bits_1_extended & 0x80000000;\n  if ((int)float_bits_1_extended < 0) {\n    comparison_result = float_bits_3_complement != 0;\n    float_bits_3_complement = -float_bits_3_complement;\n    float_bits_1_extended = -float_bits_1_extended - (uint)comparison_result;\n  }\n  if (float_bits_1_extended < 0x800000) {\n    float_bits_2_complement = float_bits_3_complement & 0x80000000;\n    float_bits_3_complement = float_bits_3_complement << 1;\n    float_bits_1_extended = float_bits_1_extended * 2 + (uint)(float_bits_2_complement != 0);\n    float_bits_2_complement = uVar5 - 2;\n    if (uVar5 - 1 == 0 || float_bits_1_extended < 0x800000) {\n      MSB_float_bits_1_extended = count_leading_zeroes(float_bits_1_extended);\n      difference = MSB_float_bits_1_extended - 8;\n      float_bits_1_extended = float_bits_1_extended << (difference & 0xff);\n      if ((int)float_bits_2_complement < (int)difference) {\n        float_bits_1_extended = float_bits_1_extended >> (-(float_bits_2_complement - difference) & 0xff);\n      }\n      else {\n        float_bits_1_extended = float_bits_1_extended + (float_bits_2_complement - difference) * 0x800000;\n      }\n      return float_bits_1_extended | float_bits_1;\n    }\n  }\n  else {\n    float_bits_2_complement = uVar5 - 1;\n    if (0xffffff < float_bits_1_extended) {\n      float_bits_2_complement = float_bits_1_extended & 1;\n      float_bits_1_extended = float_bits_1_extended >> 1;\n      float_bits_3_complement = (uint)(float_bits_2_complement != 0) << 0x1f | float_bits_3_complement >> 1;\n      float_bits_2_complement = uVar5;\n      if (0xfd < uVar5) goto LAB_08008e12;\n    }\n  }\n  float_bits_1_extended = float_bits_1_extended + float_bits_2_complement * 0x800000 + (uint)(0x7fffffff < float_bits_3_complement);\n  if (float_bits_3_complement == 0x80000000) {\n    float_bits_1_extended = float_bits_1_extended & 0xfffffffe;\n  }\n  return float_bits_1_extended | float_bits_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008cd8",
            "calling": [
                "FUN_08004940",
                "FUN_080005b4",
                "FUN_08002908",
                "FUN_080028bc",
                "FUN_08003004",
                "FUN_08002978",
                "FUN_08002408",
                "FUN_08001f00"
            ],
            "imported": false,
            "current_name": "calculate_float_08008cd8"
        },
        "FUN_08007930": {
            "renaming": {
                "FUN_08007930": "update_flags_and_values_08007930",
                "puVar1": "data_ptr",
                "uVar2": "new_value",
                "uVar3": "current_sum",
                "uVar4": "previous_sum",
                "iVar5": "current_index"
            },
            "code": "void update_flags_and_values_08007930(void)\n{\n  uint32_t *data_ptr;\n  uint32_t current_sum;\n  uint32_t previous_sum;\n  int current_index;\n  data_ptr = PTR_DAT_080079b8;\n  if (*(int *)PTR_DAT_080079bc != 0) {\n    current_index = *(int *)(data_ptr + 0x14);\n    uint32_t new_value = get_bits_from_indexes_08007884();\n    *(uint32_t *)(data_ptr + current_index * 4) = new_value;\n    if (*(int *)(data_ptr + 0x14) == 3) {\n      current_index = 0;\n    }\n    else {\n      current_index = *(int *)(data_ptr + 0x14) + 1;\n    }\n    *(int *)(data_ptr + 0x14) = current_index;\n    current_sum = calculate_sum_of_four_numbers_080078f4();\n    previous_sum = *(uint32_t *)(data_ptr + 0x10);\n    if (current_sum != previous_sum) {\n      uint32_t changed_bits = (~previous_sum & current_sum);\n      if (changed_bits != 0) {\n        check_and_enable_flags_080074c8(changed_bits);\n      }\n      changed_bits = (~current_sum & previous_sum);\n      if (changed_bits != 0) {\n        set_bit_if_odd_08007520(changed_bits);\n      }\n      *(uint32_t *)(data_ptr + 0x10) = current_sum;\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_08007520",
                "FUN_080074c8",
                "FUN_080078f4",
                "FUN_08007884"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007930",
            "calling": [
                "FUN_08007756"
            ],
            "imported": false,
            "current_name": "update_flags_and_values_08007930"
        },
        "FUN_080082ba": {
            "renaming": {
                "FUN_080082ba": "do_nothing_080082ba"
            },
            "code": "\nvoid do_nothing_080082ba(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080082ba",
            "calling": [
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "do_nothing_080082ba"
        },
        "FUN_08000188": {
            "renaming": {
                "FUN_08000188": "check_if_initialized_08000188",
                "param_1": "ptr_param",
                "*PTR_DAT_080001a0": "*flag_ptr",
                "DAT_080001a4": "data",
                "PTR_FUN_080001a8": "function_ptr"
            },
            "code": "int* check_if_initialized_08000188(int* ptr_param) {\\n    if (*PTR_DAT_080001a0 == \"\\0\") {\\n        if (DAT_080001a4 != 0) {\\n            ptr_param = PTR_FUN_080001a8;\\n        }\\n        *PTR_DAT_080001a0 = 1;\\n    }\\n    return ptr_param;\\n}",
            "called": [
                "FUN_0800b5b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000188",
            "calling": [],
            "imported": false,
            "current_name": "check_if_initialized_08000188"
        },
        "FUN_080082d0": {
            "renaming": {
                "FUN_080082d0": "reverse_and_improve_080082d0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shifted_input4",
                "bVar2": "least_bit",
                "uVar3": "sum1",
                "uVar4": "sum1_abs",
                "uVar5": "sum2",
                "uVar6": "sum2_abs",
                "uVar7": "sum3",
                "iVar8": "shifted_input2",
                "uVar9": "abs_diff1",
                "uVar10": "loop_counter",
                "uVar11": "abs_diff2",
                "uVar12": "temp",
                "bVar13": "input2_abs",
                "bVar14": "input1_equals_input3",
                "bVar15": "input2_sign"
            },
            "code": "\nulonglong reverse_and_improve_080082d0(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shifted_input4;\n  byte least_bit;\n  uint sum1;\n  uint sum1_abs;\n  uint sum2;\n  uint sum2_abs;\n  uint sum3;\n  int shifted_input2;\n  uint abs_diff1;\n  uint loop_counter;\n  uint abs_diff2;\n  uint temp;\n  bool input2_abs;\n  bool input1_equals_input3;\n  bool input2_sign;\n  \n  sum2_abs = input4 ^ 0x80000000;\n  abs_diff1 = input2 << 1;\n  input4 = input4 << 1;\n  input2_abs = ((input2 ^ sum2_abs) & 0x7fffffff) == 0;\n  input1_equals_input3 = input2_abs && input1 == input3;\n  if (!input2_abs || input1 != input3) {\n    input1_equals_input3 = (abs_diff1 | input1) == 0;\n  }\n  if (!input1_equals_input3) {\n    input1_equals_input3 = (input4 | input3) == 0;\n  }\n  shifted_input2 = (int)abs_diff1 >> 0x15;\n  if (!input1_equals_input3) {\n    input1_equals_input3 = shifted_input2 == -1;\n  }\n  shifted_input4 = (int)input4 >> 0x15;\n  if (!input1_equals_input3) {\n    input1_equals_input3 = shifted_input4 == -1;\n  }\n  if (input1_equals_input3) {\n    if (shifted_input2 == -1 || shifted_input4 == -1) {\n      abs_diff1 = sum2_abs;\n      abs_diff2 = input3;\n      if (shifted_input2 == -1) {\n        abs_diff1 = input2;\n        abs_diff2 = input1;\n      }\n      if (shifted_input2 != -1 || shifted_input4 != -1) {\n        input3 = abs_diff2;\n        sum2_abs = abs_diff1;\n      }\n      input1_equals_input3 = (abs_diff2 | abs_diff1 << 0xc) == 0;\n      if (input1_equals_input3) {\n        input1_equals_input3 = (input3 | sum2_abs << 0xc) == 0;\n      }\n      if (input1_equals_input3) {\n        input1_equals_input3 = abs_diff1 == sum2_abs;\n      }\n      if (!input1_equals_input3) {\n        abs_diff1 = abs_diff1 | 0x80000;\n      }\n      return CONCAT44(abs_diff1,abs_diff2);\n    }\n    if (((input2 ^ sum2_abs) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((abs_diff1 | input1) == 0) {\n        input1 = input3;\n        input2 = sum2_abs;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != sum2_abs) {\n      return 0;\n    }\n    if (abs_diff1 >> 0x15 == 0) {\n      input1_equals_input3 = (input1 & 0x80000000) != 0;\n      sum2_abs = input2 * 2 + (uint)input1_equals_input3;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)input1_equals_input3)) {\n        sum2_abs = sum2_abs | 0x80000000;\n      }\n      return CONCAT44(sum2_abs,input1 << 1);\n    }\n    if (abs_diff1 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  abs_diff1 = abs_diff1 >> 0x15;\n  input4 = input4 >> 0x15;\n  abs_diff2 = input4 - abs_diff1;\n  input1_equals_input3 = abs_diff2 != 0;\n  if (input4 < abs_diff1) {\n    abs_diff2 = -abs_diff2;\n  }\n  loop_counter = input1;\n  sum3 = input2;\n  if (input1_equals_input3 && abs_diff1 <= input4) {\n    abs_diff1 = abs_diff1 + abs_diff2;\n    loop_counter = input3;\n    sum3 = sum2_abs;\n    input3 = input1;\n    sum2_abs = input2;\n  }\n  if (0x36 < abs_diff2) {\n    return CONCAT44(sum3,loop_counter);\n  }\n  sum1_abs = sum3 & 0xfffff | 0x100000;\n  if ((sum3 & 0x80000000) != 0) {\n    input1_equals_input3 = loop_counter != 0;\n    loop_counter = -loop_counter;\n    sum1_abs = -sum1_abs - (uint)input1_equals_input3;\n  }\n  sum3 = sum2_abs & 0xfffff | 0x100000;\n  if ((sum2_abs & 0x80000000) != 0) {\n    input1_equals_input3 = input3 != 0;\n    input3 = -input3;\n    sum3 = -sum3 - (uint)input1_equals_input3;\n  }\n  if (abs_diff1 == abs_diff2) {\n    sum3 = sum3 ^ 0x100000;\n    if (abs_diff1 == 0) {\n      sum1_abs = sum1_abs ^ 0x100000;\n      abs_diff1 = 1;\n    }\n    else {\n      abs_diff2 = abs_diff2 - 1;\n    }\n  }\n  sum2_abs = -abs_diff2 + 0x20;\n  if ((int)abs_diff2 < 0x21) {\n    temp = input3 << (sum2_abs & 0xff);\n    input3 = input3 >> (abs_diff2 & 0xff);\n    sum1 = loop_counter + input3;\n    sum2 = sum3 << (sum2_abs & 0xff);\n    sum2_abs = sum1 + sum2;\n    sum1_abs = sum1_abs + CARRY4(loop_counter,input3) + ((int)sum3 >> (abs_diff2 & 0xff)) +\n            (uint)CARRY4(sum1,sum2);\n  }\n  else {\n    temp = sum3 << (-abs_diff2 + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp = temp | 2;\n    }\n    sum3 = (int)sum3 >> (abs_diff2 - 0x20 & 0xff);\n    sum2_abs = loop_counter + sum3;\n    sum1_abs = sum1_abs + ((int)sum3 >> 0x1f) + (uint)CARRY4(loop_counter,sum3);\n  }\n  input2 = sum1_abs & 0x80000000;\n  abs_diff2 = sum1_abs;\n  if ((int)sum1_abs < 0) {\n    input1_equals_input3 = temp == 0;\n    temp = -temp;\n    abs_diff2 = -sum2_abs;\n    sum2_abs = -(uint)!input1_equals_input3 - sum2_abs;\n    abs_diff2 = -(uint)(input1_equals_input3 <= abs_diff2) - sum1_abs;\n  }\n  if (0xfffff < abs_diff2) {\n    loop_counter = abs_diff1 - 1;\n    if (0x1fffff < abs_diff2) {\n      loop_counter = abs_diff2 & 1;\n      abs_diff2 = abs_diff2 >> 1;\n      least_bit = (byte)sum2_abs;\n      sum2_abs = (uint)(loop_counter != 0) << 0x1f | sum2_abs >> 1;\n      temp = (uint)(least_bit & 1) << 0x1f | temp >> 1;\n      loop_counter = abs_diff1;\n      if (0xffbfffff < abs_diff1 * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    input1_equals_input3 = 0x7fffffff < temp;\n    if (temp == 0x80000000) {\n      input1_equals_input3 = (sum2_abs & 1) != 0;\n    }\n    return CONCAT44(abs_diff2 + loop_counter * 0x100000 + (uint)CARRY4(sum2_abs,(uint)input1_equals_input3) | input2,\n                    sum2_abs + input1_equals_input3);\n  }\n  input2_abs = (temp & 0x80000000) != 0;\n  temp = temp << 1;\n  loop_counter = sum2_abs * 2;\n  input1_equals_input3 = CARRY4(sum2_abs,sum2_abs);\n  sum2_abs = sum2_abs * 2 + (uint)input2_abs;\n  abs_diff2 = abs_diff2 * 2 + (uint)(input1_equals_input3 || CARRY4(loop_counter,(uint)input2_abs));\n  loop_counter = abs_diff1 - 2;\n  if (abs_diff1 - 1 != 0 && 0xfffff < abs_diff2) goto LAB_080083e0;\n  sum3 = sum2_abs;\n  abs_diff1 = abs_diff2;\n  if (abs_diff2 == 0) {\n    sum3 = 0;\n    abs_diff1 = sum2_abs;\n  }\n  shifted_input2 = count_leading_zeroes(abs_diff1);\n  if (abs_diff2 == 0) {\n    shifted_input2 = shifted_input2 + 0x20;\n  }\n  abs_diff2 = shifted_input2 - 0xb;\n  input2_sign = SBORROW4(abs_diff2,0x20);\n  sum2_abs = shifted_input2 - 0x2b;\n  input1_equals_input3 = (int)sum2_abs < 0;\n  input2_abs = sum2_abs == 0;\n  if ((int)abs_diff2 < 0x20) {\n    input2_sign = SCARRY4(sum2_abs,0xc);\n    shifted_input2 = shifted_input2 + -0x1f;\n    input1_equals_input3 = shifted_input2 < 0;\n    input2_abs = shifted_input2 == 0;\n    sum2_abs = abs_diff2;\n    if (!input2_abs && input1_equals_input3 == input2_sign) {\n      sum3 = abs_diff1 << (abs_diff2 & 0xff);\n      abs_diff1 = abs_diff1 >> (0xcU - shifted_input2 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (input2_abs || input1_equals_input3 != input2_sign) {\n    temp = 0x20 - sum2_abs;\n  }\n  abs_diff1 = abs_diff1 << (sum2_abs & 0xff);\n  if (input2_abs || input1_equals_input3 != input2_sign) {\n    abs_diff1 = abs_diff1 | sum3 >> (temp & 0xff);\n  }\n  if (input2_abs || input1_equals_input3 != input2_sign) {\n    sum3 = sum3 << (sum2_abs & 0xff);\n  }\nLAB_08008458:\n  if ((int)abs_diff2 <= (int)loop_counter) {\n    return CONCAT44(abs_diff1 + (loop_counter - abs_diff2) * 0x100000 | input2,sum3);\n  }\n  sum2_abs = ~(loop_counter - abs_diff2);\n  if ((int)sum2_abs < 0x1f) {\n    shifted_input2 = sum2_abs - 0x13;\n    if (shifted_input2 != 0 && shifted_input2 < 0 == SCARRY4(sum2_abs - 0x1f,0xc)) {\n      return CONCAT44(sum1_abs,sum3 >> (0x20 - (0xcU - shifted_input2) & 0xff) | abs_diff1 << (0xcU - shifted_input2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    sum2_abs = sum2_abs + 1;\n    return CONCAT44(input2 | abs_diff1 >> (sum2_abs & 0xff),\n                    sum3 >> (sum2_abs & 0xff) | abs_diff1 << (0x20 - sum2_abs & 0xff));\n  }\n  return CONCAT44(sum1_abs,abs_diff1 >> (sum2_abs - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080082d0",
            "calling": [
                "FUN_08009410",
                "FUN_08009990",
                "FUN_080096e8",
                "FUN_0800af78",
                "FUN_08004940",
                "FUN_08009d78",
                "FUN_08003004",
                "FUN_08001f00",
                "FUN_08009b24",
                "FUN_0800a1bc",
                "FUN_0800a348",
                "FUN_0800a5a0",
                "FUN_0800adf0"
            ],
            "imported": false,
            "current_name": "reverse_and_improve_080082d0"
        },
        "FUN_08009318": {
            "renaming": {
                "FUN_08009318": "calculate_position_08009318",
                "param_1": "x",
                "param_2": "y",
                "param_3": "param_3",
                "param_4": "param_4",
                "iVar1": "is_collision_detected",
                "uVar2": "shift_difference",
                "uVar3": "shift_amount",
                "bVar4": "carry",
                "uVar5": "collision_detection_result",
                "lVar6": "result",
                "DAT_08009400": "unknown1",
                "DAT_08009404": "unknown2",
                "DAT_08009408": "shift_mask",
                "DAT_0800940c": "unknown3"
            },
            "code": "longlong calculate_position_08009318(uint x, uint y, undefined4 param_3, undefined4 param_4)\n{\n  int shift_amount = (y << 1) >> 0x15;\n  int shift_difference = shift_amount - 0x3ff;\n  longlong result;\n  if (shift_difference < 0x14) {\n    if (shift_difference < 0) {\n      uint64_t combined = (uint64_t)y << 32 | x;\n      uint64_t collision_detection_result = calculate_double_precision_080082d4(x, y, DAT_08009400, DAT_08009404, param_4);\n      int is_collision_detected = isCollisionDetected_08008b60((int)collision_detection_result, (int)(collision_detection_result >> 0x20), 0, 0);\n      if (is_collision_detected != 0) {\n        if ((int)y < 0) {\n          result = -0x8000000000000000;\n        }\n        else {\n          x |= y;\n          result = (uint64_t)DAT_0800940c << 32;\n        }\n      }\n      else {\n        result = combined;\n      }\n    }\n    else {\n      uint DAT_08009408 = DAT_08009408 >> (shift_difference & 0xff);\n      uint64_t combined = (uint64_t)y << 32 | x;\n      if ((y & DAT_08009408 | x) != 0) {\n        uint64_t collision_detection_result = calculate_double_precision_080082d4(x, y, DAT_08009400, DAT_08009404, param_4);\n        int is_collision_detected = isCollisionDetected_08008b60((int)collision_detection_result, (int)(collision_detection_result >> 0x20), 0, 0);\n        if (is_collision_detected != 0) {\n          if (0 < (int)y) {\n            y = y + (0x100000 >> (shift_difference & 0xff));\n          }\n          result = (uint64_t)(y & ~DAT_08009408) << 32;\n        }\n        else {\n          result = combined;\n        }\n      }\n      else {\n        result = combined;\n      }\n    }\n  }\n  else if (shift_difference < 0x34) {\n    uint DAT_08009408 = 0xffffffff >> ((y << 1) >> 0x15 - 0x413 & 0xff);\n    uint64_t combined = (uint64_t)y << 32 | x;\n    if ((DAT_08009408 & x) != 0) {\n      uint64_t collision_detection_result = calculate_double_precision_080082d4(x, y, DAT_08009400, DAT_08009404, param_4);\n      int is_collision_detected = isCollisionDetected_08008b60((int)collision_detection_result, (int)(collision_detection_result >> 0x20), 0, 0);\n      if (is_collision_detected != 0) {\n        if (0 < (int)y) {\n          if (shift_difference == 0x14) {\n            y = y + 1;\n          }\n          else {\n            uint shift_value = 1 << (0x34 - shift_difference & 0xff);\n            bool carry = CARRY4(shift_value, x);\n            x = shift_value + x;\n            if (carry != false) {\n              y = y + 1;\n            }\n          }\n        }\n        result = (uint64_t)(y & ~DAT_08009408) << 32;\n      }\n      else {\n        result = combined;\n      }\n    }\n    else {\n      result = combined;\n    }\n  }\n  else {\n    uint64_t combined = (uint64_t)y << 32 | x;\n    if (shift_difference == 0x400) {\n      result = calculate_double_precision_080082d4();\n    }\n    else {\n      result = combined;\n    }\n  }\n  return result;\n}\n",
            "called": [
                "FUN_080082d4",
                "FUN_08008b60"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009318",
            "calling": [
                "FUN_08001994",
                "FUN_08003004",
                "FUN_08002c18"
            ],
            "imported": false,
            "current_name": "calculate_position_08009318"
        },
        "FUN_080018cc": {
            "renaming": {
                "FUN_080018cc": "update_value_at_address_080018cc",
                "param_1": "new_value",
                "*(uint *)(DAT_080018f8 + 0x14)": "address",
                "*(uint *)(DAT_080018f8 + 0x14) & 0xfffffaaf": "masked_current_value",
                "param_1 | *(uint *)(DAT_080018f8 + 0x14) & 0xfffffaaf": "masked_new_value",
                "DAT_080018f8": "data_address"
            },
            "code": "update_value_at_address_080018ccvupdate_value_at_address_080018ccoupdate_value_at_address_080018cciupdate_value_at_address_080018ccdupdate_value_at_address_080018cc update_value_at_address_080018ccuupdate_value_at_address_080018ccpupdate_value_at_address_080018ccdupdate_value_at_address_080018ccaupdate_value_at_address_080018cctupdate_value_at_address_080018cceupdate_value_at_address_080018cc_update_value_at_address_080018ccvupdate_value_at_address_080018ccaupdate_value_at_address_080018cclupdate_value_at_address_080018ccuupdate_value_at_address_080018cceupdate_value_at_address_080018cc_update_value_at_address_080018ccaupdate_value_at_address_080018cctupdate_value_at_address_080018cc_update_value_at_address_080018cc*update_value_at_address_080018cc(update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc)update_value_at_address_080018cc(update_value_at_address_080018ccDupdate_value_at_address_080018ccAupdate_value_at_address_080018ccTupdate_value_at_address_080018cc_update_value_at_address_080018cc0update_value_at_address_080018cc8update_value_at_address_080018cc0update_value_at_address_080018cc0update_value_at_address_080018cc1update_value_at_address_080018cc8update_value_at_address_080018ccfupdate_value_at_address_080018cc8update_value_at_address_080018cc update_value_at_address_080018cc+update_value_at_address_080018cc update_value_at_address_080018cc0update_value_at_address_080018ccxupdate_value_at_address_080018cc1update_value_at_address_080018cc4update_value_at_address_080018cc)update_value_at_address_080018cc(update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc update_value_at_address_080018ccnupdate_value_at_address_080018cceupdate_value_at_address_080018ccwupdate_value_at_address_080018cc_update_value_at_address_080018ccvupdate_value_at_address_080018ccaupdate_value_at_address_080018cclupdate_value_at_address_080018ccuupdate_value_at_address_080018cceupdate_value_at_address_080018cc)update_value_at_address_080018cc update_value_at_address_080018cc{update_value_at_address_080018cc\nupdate_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc*update_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc(update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc)update_value_at_address_080018cc(update_value_at_address_080018ccDupdate_value_at_address_080018ccAupdate_value_at_address_080018ccTupdate_value_at_address_080018cc_update_value_at_address_080018cc0update_value_at_address_080018cc8update_value_at_address_080018cc0update_value_at_address_080018cc0update_value_at_address_080018cc1update_value_at_address_080018cc8update_value_at_address_080018ccfupdate_value_at_address_080018cc8update_value_at_address_080018cc update_value_at_address_080018cc+update_value_at_address_080018cc update_value_at_address_080018cc0update_value_at_address_080018ccxupdate_value_at_address_080018cc1update_value_at_address_080018cc4update_value_at_address_080018cc)update_value_at_address_080018cc update_value_at_address_080018cc=update_value_at_address_080018cc update_value_at_address_080018cc(update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc*update_value_at_address_080018cc)update_value_at_address_080018cc(update_value_at_address_080018ccDupdate_value_at_address_080018ccAupdate_value_at_address_080018ccTupdate_value_at_address_080018cc_update_value_at_address_080018cc0update_value_at_address_080018cc8update_value_at_address_080018cc0update_value_at_address_080018cc0update_value_at_address_080018cc1update_value_at_address_080018cc8update_value_at_address_080018ccfupdate_value_at_address_080018cc8update_value_at_address_080018cc update_value_at_address_080018cc+update_value_at_address_080018cc update_value_at_address_080018cc0update_value_at_address_080018ccxupdate_value_at_address_080018cc1update_value_at_address_080018cc4update_value_at_address_080018cc)update_value_at_address_080018cc;update_value_at_address_080018cc\nupdate_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc update_value_at_address_080018cccupdate_value_at_address_080018ccuupdate_value_at_address_080018ccrupdate_value_at_address_080018ccrupdate_value_at_address_080018cceupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc_update_value_at_address_080018ccvupdate_value_at_address_080018ccaupdate_value_at_address_080018cclupdate_value_at_address_080018ccuupdate_value_at_address_080018cceupdate_value_at_address_080018cc update_value_at_address_080018cc=update_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc*update_value_at_address_080018cc(update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc)update_value_at_address_080018cc(update_value_at_address_080018ccDupdate_value_at_address_080018ccAupdate_value_at_address_080018ccTupdate_value_at_address_080018cc_update_value_at_address_080018cc0update_value_at_address_080018cc8update_value_at_address_080018cc0update_value_at_address_080018cc0update_value_at_address_080018cc1update_value_at_address_080018cc8update_value_at_address_080018ccfupdate_value_at_address_080018cc8update_value_at_address_080018cc update_value_at_address_080018cc+update_value_at_address_080018cc update_value_at_address_080018cc0update_value_at_address_080018ccxupdate_value_at_address_080018cc1update_value_at_address_080018cc4update_value_at_address_080018cc)update_value_at_address_080018cc;update_value_at_address_080018cc\nupdate_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc update_value_at_address_080018ccmupdate_value_at_address_080018ccaupdate_value_at_address_080018ccsupdate_value_at_address_080018cckupdate_value_at_address_080018cc update_value_at_address_080018cc=update_value_at_address_080018cc update_value_at_address_080018cc0update_value_at_address_080018ccxupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccaupdate_value_at_address_080018ccaupdate_value_at_address_080018ccfupdate_value_at_address_080018cc;update_value_at_address_080018cc\nupdate_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc(update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc)update_value_at_address_080018cc(update_value_at_address_080018ccDupdate_value_at_address_080018ccAupdate_value_at_address_080018ccTupdate_value_at_address_080018cc_update_value_at_address_080018cc0update_value_at_address_080018cc8update_value_at_address_080018cc0update_value_at_address_080018cc0update_value_at_address_080018cc1update_value_at_address_080018cc8update_value_at_address_080018ccfupdate_value_at_address_080018cc8update_value_at_address_080018cc update_value_at_address_080018cc+update_value_at_address_080018cc update_value_at_address_080018cc0update_value_at_address_080018ccxupdate_value_at_address_080018cc1update_value_at_address_080018cc4update_value_at_address_080018cc)update_value_at_address_080018cc update_value_at_address_080018cc&update_value_at_address_080018cc update_value_at_address_080018cc0update_value_at_address_080018ccxupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccaupdate_value_at_address_080018ccaupdate_value_at_address_080018ccfupdate_value_at_address_080018cc update_value_at_address_080018cc=update_value_at_address_080018cc update_value_at_address_080018cccupdate_value_at_address_080018ccuupdate_value_at_address_080018ccrupdate_value_at_address_080018ccrupdate_value_at_address_080018cceupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc_update_value_at_address_080018ccvupdate_value_at_address_080018ccaupdate_value_at_address_080018cclupdate_value_at_address_080018ccuupdate_value_at_address_080018cceupdate_value_at_address_080018cc update_value_at_address_080018cc&update_value_at_address_080018cc update_value_at_address_080018ccmupdate_value_at_address_080018ccaupdate_value_at_address_080018ccsupdate_value_at_address_080018cckupdate_value_at_address_080018cc;update_value_at_address_080018cc\nupdate_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc update_value_at_address_080018ccpupdate_value_at_address_080018ccaupdate_value_at_address_080018ccrupdate_value_at_address_080018ccaupdate_value_at_address_080018ccmupdate_value_at_address_080018cc_update_value_at_address_080018cc1update_value_at_address_080018cc update_value_at_address_080018cc|update_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc(update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc)update_value_at_address_080018cc(update_value_at_address_080018ccDupdate_value_at_address_080018ccAupdate_value_at_address_080018ccTupdate_value_at_address_080018cc_update_value_at_address_080018cc0update_value_at_address_080018cc8update_value_at_address_080018cc0update_value_at_address_080018cc0update_value_at_address_080018cc1update_value_at_address_080018cc8update_value_at_address_080018ccfupdate_value_at_address_080018cc8update_value_at_address_080018cc update_value_at_address_080018cc+update_value_at_address_080018cc update_value_at_address_080018cc0update_value_at_address_080018ccxupdate_value_at_address_080018cc1update_value_at_address_080018cc4update_value_at_address_080018cc)update_value_at_address_080018cc update_value_at_address_080018cc&update_value_at_address_080018cc update_value_at_address_080018cc0update_value_at_address_080018ccxupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccaupdate_value_at_address_080018ccaupdate_value_at_address_080018ccfupdate_value_at_address_080018cc update_value_at_address_080018cc=update_value_at_address_080018cc update_value_at_address_080018ccnupdate_value_at_address_080018cceupdate_value_at_address_080018ccwupdate_value_at_address_080018cc_update_value_at_address_080018ccvupdate_value_at_address_080018ccaupdate_value_at_address_080018cclupdate_value_at_address_080018ccuupdate_value_at_address_080018cceupdate_value_at_address_080018cc update_value_at_address_080018cc|update_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc(update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc)update_value_at_address_080018cc(update_value_at_address_080018ccDupdate_value_at_address_080018ccAupdate_value_at_address_080018ccTupdate_value_at_address_080018cc_update_value_at_address_080018cc0update_value_at_address_080018cc8update_value_at_address_080018cc0update_value_at_address_080018cc0update_value_at_address_080018cc1update_value_at_address_080018cc8update_value_at_address_080018ccfupdate_value_at_address_080018cc8update_value_at_address_080018cc update_value_at_address_080018cc+update_value_at_address_080018cc update_value_at_address_080018cc0update_value_at_address_080018ccxupdate_value_at_address_080018cc1update_value_at_address_080018cc4update_value_at_address_080018cc)update_value_at_address_080018cc update_value_at_address_080018cc&update_value_at_address_080018cc update_value_at_address_080018cc0update_value_at_address_080018ccxupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccaupdate_value_at_address_080018ccaupdate_value_at_address_080018ccfupdate_value_at_address_080018cc;update_value_at_address_080018cc\nupdate_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc*update_value_at_address_080018cc(update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc)update_value_at_address_080018cc(update_value_at_address_080018ccDupdate_value_at_address_080018ccAupdate_value_at_address_080018ccTupdate_value_at_address_080018cc_update_value_at_address_080018cc0update_value_at_address_080018cc8update_value_at_address_080018cc0update_value_at_address_080018cc0update_value_at_address_080018cc1update_value_at_address_080018cc8update_value_at_address_080018ccfupdate_value_at_address_080018cc8update_value_at_address_080018cc update_value_at_address_080018cc+update_value_at_address_080018cc update_value_at_address_080018cc0update_value_at_address_080018ccxupdate_value_at_address_080018cc1update_value_at_address_080018cc4update_value_at_address_080018cc)update_value_at_address_080018cc update_value_at_address_080018cc=update_value_at_address_080018cc update_value_at_address_080018ccpupdate_value_at_address_080018ccaupdate_value_at_address_080018ccrupdate_value_at_address_080018ccaupdate_value_at_address_080018ccmupdate_value_at_address_080018cc_update_value_at_address_080018cc1update_value_at_address_080018cc update_value_at_address_080018cc|update_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc(update_value_at_address_080018ccuupdate_value_at_address_080018cciupdate_value_at_address_080018ccnupdate_value_at_address_080018cctupdate_value_at_address_080018cc update_value_at_address_080018cc*update_value_at_address_080018cc)update_value_at_address_080018cc(update_value_at_address_080018ccDupdate_value_at_address_080018ccAupdate_value_at_address_080018ccTupdate_value_at_address_080018cc_update_value_at_address_080018cc0update_value_at_address_080018cc8update_value_at_address_080018cc0update_value_at_address_080018cc0update_value_at_address_080018cc1update_value_at_address_080018cc8update_value_at_address_080018ccfupdate_value_at_address_080018cc8update_value_at_address_080018cc update_value_at_address_080018cc+update_value_at_address_080018cc update_value_at_address_080018cc0update_value_at_address_080018ccxupdate_value_at_address_080018cc1update_value_at_address_080018cc4update_value_at_address_080018cc)update_value_at_address_080018cc update_value_at_address_080018cc&update_value_at_address_080018cc update_value_at_address_080018cc0update_value_at_address_080018ccxupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccfupdate_value_at_address_080018ccaupdate_value_at_address_080018ccaupdate_value_at_address_080018ccfupdate_value_at_address_080018cc;update_value_at_address_080018cc\nupdate_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018cc update_value_at_address_080018ccrupdate_value_at_address_080018cceupdate_value_at_address_080018cctupdate_value_at_address_080018ccuupdate_value_at_address_080018ccrupdate_value_at_address_080018ccnupdate_value_at_address_080018cc;update_value_at_address_080018cc\nupdate_value_at_address_080018cc}update_value_at_address_080018cc",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080018cc",
            "calling": [
                "FUN_08001994"
            ],
            "imported": false,
            "current_name": "update_value_at_address_080018cc"
        },
        "FUN_080079e0": {
            "renaming": {
                "FUN_080079e0": "set_bit_in_array_080079e0",
                "param_1": "bit_index",
                "DAT_08007a0c": "array_ptr",
                "uint": "uint32_t",
                "int": "int32_t",
                "byte": "uint8_t",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "void set_bit_in_array_080079e0(uint8_t bit_index) {\n    uint8_t array_index = bit_index >> 5;\n    uint32_t* DAT_08007a0c = (uint32_t*)(DAT_08007a0c + array_index * 4);\n    uint8_t bit_offset = bit_index & 0x1f;\n    uint32_t bit_mask = 1 << bit_offset;\n    *DAT_08007a0c = bit_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080079e0",
            "calling": [
                "FUN_08007a70"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_080079e0"
        },
        "FUN_08006a58": {
            "renaming": {
                "FUN_08006a58": "set_bit_in_array_08006a58",
                "param_1": "bit_position",
                "DAT_08006a88": "array_start_ptr"
            },
            "code": "void set_bit_in_array_08006a58(byte bit_position) {\n    int* array_ptr = (int*)(DAT_08006a88 + (((uint)(int)(char)bit_position >> 5) + 0x40) * 4);\n    int bit_mask = 1 << (bit_position & 0x1f);\n    *array_ptr = bit_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006a58",
            "calling": [
                "FUN_08006dc4"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_08006a58"
        },
        "FUN_08005a84": {
            "renaming": {
                "FUN_08005a84": "get_value_from_pointer_08005a84",
                "undefined4": "int",
                "*PTR_DAT_08005a94": "PTR_DAT_08005a94",
                "return": "return",
                "*(undefined4 *)PTR_DAT_08005a94": "*ptr",
                "int *ptr": "int *ptr"
            },
            "code": "int get_value_from_pointer_08005a84() {\n    int *(undefined4 *)PTR_DAT_08005a94 = (int *)*PTR_DAT_08005a94;\n    return *(undefined4 *)PTR_DAT_08005a94;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a84",
            "calling": [
                "FUN_08005a98",
                "FUN_0800618c",
                "FUN_08005cec",
                "FUN_08000268",
                "FUN_08007756"
            ],
            "imported": false,
            "current_name": "get_value_from_pointer_08005a84"
        },
        "FUN_08008b10": {
            "renaming": {
                "FUN_08008b10": "checkForCollision_08008b10",
                "in_ZR": "collisionResult"
            },
            "code": "bool checkForCollision_08008b10()\\n{\\n  char collisionResult;\\n  \\n  collisionResult = check_collision_and_return_result_08008b00();\\n  return collisionResult != \"\\0\";\\n}",
            "called": [
                "FUN_08008b00"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b10",
            "calling": [
                "FUN_08009d78",
                "FUN_0800a5a0"
            ],
            "imported": false,
            "current_name": "checkForCollision_08008b10"
        },
        "FUN_08004e30": {
            "renaming": {
                "FUN_08004e30": "process_parameters_08004e30",
                "param_1": "parameter_type",
                "param_2": "parameter_value",
                "uVar1": "result",
                "uVar2": "shift_amount",
                "uVar3": "float_result",
                "iVar4": "check_result",
                "uVar5": "reversed_value"
            },
            "code": "\nundefined4 process_parameters_08004e30(int parameter_type,uint parameter_value)\n\n{\n  undefined result;\n  undefined2 shift_amount;\n  undefined4 float_result;\n  int check_result;\n  undefined8 reversed_value;\n  \n  switch(parameter_type) {\n  case 0:\n  case 1:\n  case 2:\n    check_result = check_concatenation_result_0800923c(parameter_value,0);\n    if (check_result != 0) {\n      return 8;\n    }\n    *(uint *)(PTR_DAT_080051a8 + parameter_type * 4) = parameter_value;\n    break;\n  case 3:\n    check_result = is_string_terminated_08009228(parameter_value,DAT_080051ac);\n    if (check_result != 0) {\n      return 9;\n    }\n    reversed_value = reverse_bits_08008590(parameter_value);\n    reversed_value = calculate_double_precision_08009654((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    result = calculate_shift_amount_08008bf0((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    PTR_DAT_080051a8[0xd] = result;\n    break;\n  case 4:\n    *(uint *)(PTR_DAT_080051a8 + 0x10) = parameter_value;\n    break;\n  case 5:\n    *(uint *)(PTR_DAT_080051a8 + 0x14) = parameter_value;\n    break;\n  case 6:\n    reversed_value = reverse_bits_08008590(parameter_value);\n    reversed_value = calculate_08009798((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    shift_amount = calculate_shift_amount_08008bf0((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    *(undefined2 *)(PTR_DAT_080051a8 + 0x18) = shift_amount;\n    break;\n  case 7:\n    reversed_value = reverse_bits_08008590(parameter_value);\n    reversed_value = calculate_double_precision_08009654((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    result = calculate_shift_amount_08008bf0((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    PTR_DAT_080051a8[0x3c] = result;\n    break;\n  case 8:\n    float_result = calculate_float_08008eec(parameter_value,DAT_080051b0);\n    float_result = calculate_float_08008eec(float_result,DAT_080051b0);\n    *(undefined4 *)(PTR_DAT_080051a8 + 0x20) = float_result;\n    break;\n  case 9:\n    *(uint *)(PTR_DAT_080051a8 + 0x24) = parameter_value & 0x7fffffff;\n    break;\n  case 10:\n    *(uint *)(PTR_DAT_080051a8 + 0x1c) = parameter_value;\n    break;\n  case 0xb:\n    reversed_value = reverse_bits_08008590(parameter_value);\n    reversed_value = calculate_double_precision_08009654((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    result = calculate_shift_amount_08008bf0((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    PTR_DAT_080051a8[0x3e] = result;\n    break;\n  case 0xc:\n    reversed_value = reverse_bits_08008590(parameter_value);\n    reversed_value = calculate_double_precision_08009654((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    result = calculate_shift_amount_08008bf0((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    PTR_DAT_080051a8[0x3d] = result;\n    break;\n  case 0xd:\n    check_result = is_string_concatenated_08009214(parameter_value,0);\n    if (check_result == 0) {\n      PTR_DAT_080051a8[0x28] = PTR_DAT_080051a8[0x28] | 1;\n    }\n    else {\n      PTR_DAT_080051a8[0x28] = PTR_DAT_080051a8[0x28] & 0xfe;\n    }\n    break;\n  case 0xe:\n    check_result = is_string_concatenated_08009214(parameter_value,0);\n    if (check_result == 0) {\n      PTR_DAT_080051a8[0x28] = PTR_DAT_080051a8[0x28] | 2;\n    }\n    else {\n      PTR_DAT_080051a8[0x28] = PTR_DAT_080051a8[0x28] & 0xfd;\n    }\n    break;\n  case 0xf:\n    check_result = is_string_concatenated_08009214(parameter_value,0);\n    if (check_result == 0) {\n      PTR_DAT_080051a8[0x28] = PTR_DAT_080051a8[0x28] | 4;\n    }\n    else {\n      PTR_DAT_080051a8[0x28] = PTR_DAT_080051a8[0x28] & 0xfb;\n    }\n    break;\n  case 0x10:\n    check_result = is_string_concatenated_08009214(parameter_value,0);\n    if (check_result == 0) {\n      PTR_DAT_080051a8[0x28] = PTR_DAT_080051a8[0x28] | 8;\n    }\n    else {\n      PTR_DAT_080051a8[0x28] = PTR_DAT_080051a8[0x28] & 0xf7;\n    }\n    check_data_integrity_0800192c();\n    break;\n  case 0x11:\n    check_result = is_string_concatenated_08009214(parameter_value,0);\n    if (check_result == 0) {\n      PTR_DAT_080051a8[0x28] = PTR_DAT_080051a8[0x28] | 0x10;\n    }\n    else {\n      PTR_DAT_080051a8[0x28] = PTR_DAT_080051a8[0x28] & 0xef;\n    }\n    break;\n  case 0x12:\n    reversed_value = reverse_bits_08008590(parameter_value);\n    reversed_value = calculate_08009798((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    shift_amount = calculate_shift_amount_08008bf0((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    *(undefined2 *)(PTR_DAT_080051a8 + 0x2a) = shift_amount;\n    break;\n  case 0x13:\n    *(uint *)(PTR_DAT_080051a8 + 0x2c) = parameter_value;\n    break;\n  case 0x14:\n    *(uint *)(PTR_DAT_080051a8 + 0x30) = parameter_value;\n    break;\n  case 0x15:\n    reversed_value = reverse_bits_08008590(parameter_value);\n    reversed_value = calculate_double_precision_08009654((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    shift_amount = calculate_shift_amount_08008bf0((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    *(undefined2 *)(PTR_DAT_080051a8 + 0x34) = shift_amount;\n    break;\n  case 0x16:\n    *(uint *)(PTR_DAT_080051a8 + 0x38) = parameter_value;\n    break;\n  case 0x17:\n    reversed_value = reverse_bits_08008590(parameter_value);\n    reversed_value = calculate_08009798((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    shift_amount = calculate_shift_amount_08008bf0((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n    *(undefined2 *)(PTR_DAT_080051a8 + 0x1a) = shift_amount;\n    break;\n  default:\n    return 6;\n  }\n  initialize_and_store_checksum_08004c2a();\n  return 0;\n}\n\n",
            "called": [
                "FUN_08008590",
                "FUN_0800192c",
                "FUN_08009214",
                "FUN_08009798",
                "FUN_08008bf0",
                "FUN_08009228",
                "FUN_08004c2a",
                "FUN_0800923c",
                "FUN_08009654",
                "FUN_08008eec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e30",
            "calling": [
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "process_parameters_08004e30"
        },
        "FUN_08008c30": {
            "renaming": {
                "FUN_08008c30": "calculate_float_bits_08008c30",
                "param_1": "float_bits",
                "param_2": "exponent_bits",
                "uVar1": "result",
                "uVar2": "significand_bits_2x",
                "uVar3": "biased_exponent",
                "in_r12": "significand_bits",
                "bVar4": "is_special_case",
                "bVar5": "is_small_exponent",
                "shift_amount": "shift_amount",
                "shifted_float_bits": "shifted_float_bits"
            },
            "code": "uint calculate_float_bits_08008c30(uint float_bits, uint exponent_bits)\n{\n  uint significand_bits_2x = exponent_bits * 2;\n  bool is_small_exponent = significand_bits_2x < 0x70000000;\n  uint biased_exponent = significand_bits_2x + 0x90000000;\n  uint result = biased_exponent;\n  uint significand_bits = 0;\n  if (!is_small_exponent) {\n    significand_bits = significand_bits_2x + 0x8fe00000;\n    result = significand_bits;\n  }\n  bool is_special_case = result == 0;\n  if (!is_small_exponent && biased_exponent >= 0x200000) {\n    is_special_case = significand_bits == 0x1fc00000;\n  }\n  if (((is_small_exponent || biased_exponent < 0x200000) || 0x1fc00000 < significand_bits) || is_special_case) {\n    if ((exponent_bits & 0x40000000) != 0) {\n      if (((int)significand_bits_2x >> 0x15 == -1) && ((float_bits | exponent_bits << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return exponent_bits & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(significand_bits_2x + 0x92e00000) < 0 != SCARRY4(biased_exponent,0x2e00000)) {\n      return exponent_bits & 0x80000000;\n    }\n    uint shift_amount = 0x18 - (significand_bits_2x + 0x92e00000 >> 0x15);\n    uint shifted_float_bits = float_bits >> (shift_amount & 0xff);\n    if (float_bits << (0x20 - shift_amount & 0xff) != 0) {\n      shifted_float_bits = shifted_float_bits | 1;\n    }\n    significand_bits = exponent_bits & 0x1fffff | 0x100000;\n    float_bits = shifted_float_bits | significand_bits << (0x20 - shift_amount & 0xff);\n    significand_bits = (significand_bits >> (shift_amount & 0xff)) << 1;\n  }\n  result = (exponent_bits & 0x80000000 | float_bits >> 0x1d) + significand_bits * 4 + (uint)(0x7fffffff < float_bits * 8);\n  if (float_bits * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008c30",
            "calling": [
                "FUN_08001994",
                "FUN_080046d0",
                "FUN_08004940",
                "FUN_080005b4",
                "FUN_08003004",
                "FUN_0800056c",
                "FUN_08002638",
                "FUN_08002978",
                "FUN_080044e8",
                "FUN_08001f00"
            ],
            "imported": false,
            "current_name": "calculate_float_bits_08008c30"
        },
        "FUN_080082d4": {
            "renaming": {
                "FUN_080082d4": "calculate_double_precision_080082d4",
                "param_1": "left_operand_high",
                "param_2": "left_operand_low",
                "param_3": "right_operand_high",
                "param_4": "right_operand_low",
                "iVar1": "right_operand_low_shifted",
                "bVar2": "right_operand_low_bit",
                "uVar3": "addition_result_low",
                "uVar4": "addition_result_low_shifted",
                "uVar5": "left_operand_low_normalized",
                "iVar6": "left_operand_low_normalized_shift",
                "uVar7": "left_operand_low_normalized_shifted",
                "uVar8": "left_operand_high_normalized",
                "uVar9": "left_operand_high_normalized_shifted",
                "uVar10": "difference",
                "uVar11": "rounding_bit",
                "uVar12": "addition_result_high",
                "bVar13": "left_right_equal",
                "bVar14": "condition_met",
                "bVar15": "overflow"
            },
            "code": "\nulonglong calculate_double_precision_080082d4(uint left_operand_high,uint left_operand_low,uint right_operand_high,uint right_operand_low)\n\n{\n  int right_operand_low_shifted;\n  byte right_operand_low_bit;\n  uint addition_result_low;\n  uint addition_result_low_shifted;\n  uint left_operand_low_normalized;\n  int left_operand_low_normalized_shift;\n  uint left_operand_low_normalized_shifted;\n  uint left_operand_high_normalized;\n  uint left_operand_high_normalized_shifted;\n  uint difference;\n  uint rounding_bit;\n  uint addition_result_high;\n  bool left_right_equal;\n  bool condition_met;\n  bool overflow;\n  \n  left_operand_low_normalized_shifted = left_operand_low << 1;\n  left_operand_high_normalized_shifted = right_operand_low << 1;\n  left_right_equal = ((left_operand_low ^ right_operand_low) & 0x7fffffff) == 0;\n  condition_met = left_right_equal && left_operand_high == right_operand_high;\n  if (!left_right_equal || left_operand_high != right_operand_high) {\n    condition_met = (left_operand_low_normalized_shifted | left_operand_high) == 0;\n  }\n  if (!condition_met) {\n    condition_met = (left_operand_high_normalized_shifted | right_operand_high) == 0;\n  }\n  left_operand_low_normalized_shift = (int)left_operand_low_normalized_shifted >> 0x15;\n  if (!condition_met) {\n    condition_met = left_operand_low_normalized_shift == -1;\n  }\n  right_operand_low_shifted = (int)left_operand_high_normalized_shifted >> 0x15;\n  if (!condition_met) {\n    condition_met = right_operand_low_shifted == -1;\n  }\n  if (condition_met) {\n    if (left_operand_low_normalized_shift == -1 || right_operand_low_shifted == -1) {\n      left_operand_high_normalized_shifted = right_operand_low;\n      left_operand_low_normalized_shifted = right_operand_high;\n      if (left_operand_low_normalized_shift == -1) {\n        left_operand_high_normalized_shifted = left_operand_low;\n        left_operand_low_normalized_shifted = left_operand_high;\n      }\n      if (left_operand_low_normalized_shift != -1 || right_operand_low_shifted != -1) {\n        right_operand_high = left_operand_low_normalized_shifted;\n        right_operand_low = left_operand_high_normalized_shifted;\n      }\n      condition_met = (left_operand_low_normalized_shifted | left_operand_high_normalized_shifted << 0xc) == 0;\n      if (condition_met) {\n        condition_met = (right_operand_high | right_operand_low << 0xc) == 0;\n      }\n      if (condition_met) {\n        condition_met = left_operand_high_normalized_shifted == right_operand_low;\n      }\n      if (!condition_met) {\n        left_operand_high_normalized_shifted = left_operand_high_normalized_shifted | 0x80000;\n      }\n      return CONCAT44(left_operand_high_normalized_shifted,left_operand_low_normalized_shifted);\n    }\n    if (((left_operand_low ^ right_operand_low) & 0x7fffffff) != 0 || left_operand_high != right_operand_high) {\n      if ((left_operand_low_normalized_shifted | left_operand_high) == 0) {\n        left_operand_high = right_operand_high;\n        left_operand_low = right_operand_low;\n      }\n      return CONCAT44(left_operand_low,left_operand_high);\n    }\n    if (left_operand_low != right_operand_low) {\n      return 0;\n    }\n    if (left_operand_low_normalized_shifted >> 0x15 == 0) {\n      condition_met = (left_operand_high & 0x80000000) != 0;\n      left_operand_high_normalized_shifted = left_operand_low * 2 + (uint)condition_met;\n      if (CARRY4(left_operand_low,left_operand_low) || CARRY4(left_operand_low * 2,(uint)condition_met)) {\n        left_operand_high_normalized_shifted = left_operand_high_normalized_shifted | 0x80000000;\n      }\n      return CONCAT44(left_operand_high_normalized_shifted,left_operand_high << 1);\n    }\n    if (left_operand_low_normalized_shifted < 0xffc00000) {\n      return CONCAT44(left_operand_low + 0x100000,left_operand_high);\n    }\n    left_operand_low = left_operand_low & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(left_operand_low | 0x7ff00000) << 0x20;\n  }\n  left_operand_low_normalized_shifted = left_operand_low_normalized_shifted >> 0x15;\n  left_operand_high_normalized_shifted = left_operand_high_normalized_shifted >> 0x15;\n  difference = left_operand_high_normalized_shifted - left_operand_low_normalized_shifted;\n  condition_met = difference != 0;\n  if (left_operand_high_normalized_shifted < left_operand_low_normalized_shifted) {\n    difference = -difference;\n  }\n  left_operand_high_normalized = left_operand_high;\n  left_operand_low_normalized = left_operand_low;\n  if (condition_met && left_operand_low_normalized_shifted <= left_operand_high_normalized_shifted) {\n    left_operand_low_normalized_shifted = left_operand_low_normalized_shifted + difference;\n    left_operand_high_normalized = right_operand_high;\n    left_operand_low_normalized = right_operand_low;\n    right_operand_high = left_operand_high;\n    right_operand_low = left_operand_low;\n  }\n  if (0x36 < difference) {\n    return CONCAT44(left_operand_low_normalized,left_operand_high_normalized);\n  }\n  left_operand_high_normalized_shifted = left_operand_low_normalized & 0xfffff | 0x100000;\n  if ((left_operand_low_normalized & 0x80000000) != 0) {\n    condition_met = left_operand_high_normalized != 0;\n    left_operand_high_normalized = -left_operand_high_normalized;\n    left_operand_high_normalized_shifted = -left_operand_high_normalized_shifted - (uint)condition_met;\n  }\n  left_operand_low_normalized = right_operand_low & 0xfffff | 0x100000;\n  if ((right_operand_low & 0x80000000) != 0) {\n    condition_met = right_operand_high != 0;\n    right_operand_high = -right_operand_high;\n    left_operand_low_normalized = -left_operand_low_normalized - (uint)condition_met;\n  }\n  if (left_operand_low_normalized_shifted == difference) {\n    left_operand_low_normalized = left_operand_low_normalized ^ 0x100000;\n    if (left_operand_low_normalized_shifted == 0) {\n      left_operand_high_normalized_shifted = left_operand_high_normalized_shifted ^ 0x100000;\n      left_operand_low_normalized_shifted = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  addition_result_high = -difference + 0x20;\n  if ((int)difference < 0x21) {\n    rounding_bit = right_operand_high << (addition_result_high & 0xff);\n    right_operand_high = right_operand_high >> (difference & 0xff);\n    addition_result_low = left_operand_high_normalized + right_operand_high;\n    addition_result_low_shifted = left_operand_low_normalized << (addition_result_high & 0xff);\n    addition_result_high = addition_result_low + addition_result_low_shifted;\n    left_operand_high_normalized_shifted = left_operand_high_normalized_shifted + CARRY4(left_operand_high_normalized,right_operand_high) + ((int)left_operand_low_normalized >> (difference & 0xff)) +\n            (uint)CARRY4(addition_result_low,addition_result_low_shifted);\n  }\n  else {\n    rounding_bit = left_operand_low_normalized << (-difference + 0x40 & 0xff);\n    if (right_operand_high != 0) {\n      rounding_bit = rounding_bit | 2;\n    }\n    left_operand_low_normalized = (int)left_operand_low_normalized >> (difference - 0x20 & 0xff);\n    addition_result_high = left_operand_high_normalized + left_operand_low_normalized;\n    left_operand_high_normalized_shifted = left_operand_high_normalized_shifted + ((int)left_operand_low_normalized >> 0x1f) + (uint)CARRY4(left_operand_high_normalized,left_operand_low_normalized);\n  }\n  left_operand_low = left_operand_high_normalized_shifted & 0x80000000;\n  difference = left_operand_high_normalized_shifted;\n  if ((int)left_operand_high_normalized_shifted < 0) {\n    condition_met = rounding_bit == 0;\n    rounding_bit = -rounding_bit;\n    difference = -addition_result_high;\n    addition_result_high = -(uint)!condition_met - addition_result_high;\n    difference = -(uint)(condition_met <= difference) - left_operand_high_normalized_shifted;\n  }\n  if (0xfffff < difference) {\n    left_operand_high_normalized = left_operand_low_normalized_shifted - 1;\n    if (0x1fffff < difference) {\n      left_operand_high_normalized_shifted = difference & 1;\n      difference = difference >> 1;\n      right_operand_low_bit = (byte)addition_result_high;\n      addition_result_high = (uint)(left_operand_high_normalized_shifted != 0) << 0x1f | addition_result_high >> 1;\n      rounding_bit = (uint)(right_operand_low_bit & 1) << 0x1f | rounding_bit >> 1;\n      left_operand_high_normalized = left_operand_low_normalized_shifted;\n      if (0xffbfffff < left_operand_low_normalized_shifted * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    condition_met = 0x7fffffff < rounding_bit;\n    if (rounding_bit == 0x80000000) {\n      condition_met = (addition_result_high & 1) != 0;\n    }\n    return CONCAT44(difference + left_operand_high_normalized * 0x100000 + (uint)CARRY4(addition_result_high,(uint)condition_met) | left_operand_low,\n                    addition_result_high + condition_met);\n  }\n  left_right_equal = (rounding_bit & 0x80000000) != 0;\n  rounding_bit = rounding_bit << 1;\n  left_operand_high_normalized = addition_result_high * 2;\n  condition_met = CARRY4(addition_result_high,addition_result_high);\n  addition_result_high = addition_result_high * 2 + (uint)left_right_equal;\n  difference = difference * 2 + (uint)(condition_met || CARRY4(left_operand_high_normalized,(uint)left_right_equal));\n  left_operand_high_normalized = left_operand_low_normalized_shifted - 2;\n  if (left_operand_low_normalized_shifted - 1 != 0 && 0xfffff < difference) goto LAB_080083e0;\n  left_operand_low_normalized = addition_result_high;\n  left_operand_low_normalized_shifted = difference;\n  if (difference == 0) {\n    left_operand_low_normalized = 0;\n    left_operand_low_normalized_shifted = addition_result_high;\n  }\n  left_operand_low_normalized_shift = count_leading_zeroes(left_operand_low_normalized_shifted);\n  if (difference == 0) {\n    left_operand_low_normalized_shift = left_operand_low_normalized_shift + 0x20;\n  }\n  addition_result_high = left_operand_low_normalized_shift - 0xb;\n  overflow = SBORROW4(addition_result_high,0x20);\n  difference = left_operand_low_normalized_shift - 0x2b;\n  condition_met = (int)difference < 0;\n  left_right_equal = difference == 0;\n  if ((int)addition_result_high < 0x20) {\n    overflow = SCARRY4(difference,0xc);\n    left_operand_low_normalized_shift = left_operand_low_normalized_shift + -0x1f;\n    condition_met = left_operand_low_normalized_shift < 0;\n    left_right_equal = left_operand_low_normalized_shift == 0;\n    difference = addition_result_high;\n    if (!left_right_equal && condition_met == overflow) {\n      left_operand_low_normalized = left_operand_low_normalized_shifted << (addition_result_high & 0xff);\n      left_operand_low_normalized_shifted = left_operand_low_normalized_shifted >> (0xcU - left_operand_low_normalized_shift & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (left_right_equal || condition_met != overflow) {\n    rounding_bit = 0x20 - difference;\n  }\n  left_operand_low_normalized_shifted = left_operand_low_normalized_shifted << (difference & 0xff);\n  if (left_right_equal || condition_met != overflow) {\n    left_operand_low_normalized_shifted = left_operand_low_normalized_shifted | left_operand_low_normalized >> (rounding_bit & 0xff);\n  }\n  if (left_right_equal || condition_met != overflow) {\n    left_operand_low_normalized = left_operand_low_normalized << (difference & 0xff);\n  }\nLAB_08008458:\n  if ((int)addition_result_high <= (int)left_operand_high_normalized) {\n    return CONCAT44(left_operand_low_normalized_shifted + (left_operand_high_normalized - addition_result_high) * 0x100000 | left_operand_low,left_operand_low_normalized);\n  }\n  difference = ~(left_operand_high_normalized - addition_result_high);\n  if ((int)difference < 0x1f) {\n    left_operand_low_normalized_shift = difference - 0x13;\n    if (left_operand_low_normalized_shift != 0 && left_operand_low_normalized_shift < 0 == SCARRY4(difference - 0x1f,0xc)) {\n      return CONCAT44(left_operand_high_normalized_shifted,left_operand_low_normalized >> (0x20 - (0xcU - left_operand_low_normalized_shift) & 0xff) | left_operand_low_normalized_shifted << (0xcU - left_operand_low_normalized_shift & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    difference = difference + 1;\n    return CONCAT44(left_operand_low | left_operand_low_normalized_shifted >> (difference & 0xff),\n                    left_operand_low_normalized >> (difference & 0xff) | left_operand_low_normalized_shifted << (0x20 - difference & 0xff));\n  }\n  return CONCAT44(left_operand_high_normalized_shifted,left_operand_low_normalized_shifted >> (difference - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080082d4",
            "calling": [
                "FUN_08009318",
                "FUN_080094c0",
                "FUN_08009990",
                "FUN_0800af78",
                "FUN_08009d78",
                "FUN_0800b2e8",
                "FUN_08001f00",
                "FUN_08009b24",
                "FUN_0800a1bc",
                "FUN_0800a348",
                "FUN_0800a5a0",
                "FUN_08009798",
                "FUN_0800adf0",
                "FUN_08009654"
            ],
            "imported": false,
            "current_name": "calculate_double_precision_080082d4"
        },
        "FUN_08007bf0": {
            "renaming": {
                "FUN_08007bf0": "update_data_08007bf0",
                "param_1": "new_data",
                "_DAT_4000002c": "PTR_DAT_4000002c",
                "_DAT_40000024": "PTR_DAT_40000024"
            },
            "code": "void update_data_08007bf0(uint32_t new_data) {\n  _DAT_4000002c = new_data;\n  if (new_data <= _DAT_40000024) {\n    _DAT_40000024 = new_data;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007bf0",
            "calling": [
                "FUN_08005324"
            ],
            "imported": false,
            "current_name": "update_data_08007bf0"
        },
        "FUN_08008590": {
            "renaming": {
                "FUN_08008590": "reverse_bits_08008590",
                "param_1": "num",
                "param_2": "mask",
                "param_3": "shift",
                "param_4": "val",
                "uVar1": "sign_bit",
                "uVar2": "low_bit_mask",
                "uVar3": "high_bit_mask",
                "uVar4": "shifted_num",
                "uVar5": "temp_num",
                "uVar7": "num_high_bit",
                "iVar6": "leading_zeros",
                "in_r12": "num_low_bit",
                "bVar8": "high_bit_equals_zero",
                "bVar9": "is_zero",
                "bVar10": "high_bit_overflow"
            },
            "code": "uint64_t reverse_bits_08008590(uint32_t num, uint32_t mask, uint32_t shift, uint32_t val)\n{\n  uint32_t temp_num = num << 1;\n  bool is_zero = temp_num == 0;\n  uint32_t sign_bit = (uint32_t)((num & 0x80000000) != 0) << 0x1f;\n  uint32_t shifted_num = (uint32_t)(((int)temp_num >> 3) >> 1);\n  uint32_t num_high_byte = 0;\n  if (!is_zero) {\n    num_high_byte = temp_num & 0xff000000;\n    is_zero = num_high_byte == 0;\n  }\n  if (!is_zero) {\n    is_zero = num_high_byte == 0xff000000;\n  }\n  if (!is_zero) {\n    return ((uint64_t)sign_bit << 0x20) | ((uint64_t)shifted_num << 0x1d) | val) ^ 0x3800000000000000;\n  }\n  if ((temp_num & 0xffffff) == 0) {\n    return ((uint64_t)sign_bit << 0x20) | ((uint64_t)shifted_num << 0x1d) | val;\n  }\n  if (num_high_byte == 0xff000000) {\n    return ((uint64_t)sign_bit << 0x20) | ((uint64_t)shifted_num << 0x1d) | val | 0x8000000000000;\n  }\n  uint32_t high_bit_mask = shifted_num;\n  uint32_t low_bit_mask = val;\n  if (shifted_num == 0) {\n    high_bit_mask = 0;\n    low_bit_mask = val;\n  }\n  int leading_zeros = count_leading_zeroes(shifted_num);\n  if (shifted_num == 0) {\n    leading_zeros += 0x20;\n  }\n  uint32_t num_high_bit = leading_zeros - 0xb;\n  bool high_bit_overflow = num_high_bit < 0;\n  bool high_bit_equals_zero = num_high_bit == 0;\n  if (num_high_bit < 0x20) {\n    high_bit_overflow = shifted_num - 0xc < num_high_bit;\n    leading_zeros += -0x1f;\n    high_bit_equals_zero = leading_zeros == 0;\n    high_bit_mask = shifted_num << (num_high_bit & 0xff);\n    low_bit_mask = shifted_num >> (0xcU - leading_zeros & 0xff) | val << (num_high_bit & 0xff);\n  }\n  if (!high_bit_equals_zero && high_bit_overflow == high_bit_equals_zero) {\n    high_bit_mask = shifted_num << (num_high_bit & 0xff);\n    low_bit_mask = shifted_num >> (0xcU - leading_zeros & 0xff) | val << (num_high_bit & 0xff);\n  }\n  if (num_high_bit < 0x381) {\n    return ((uint64_t)high_bit_mask + (0x380 - num_high_bit) * 0x100000 | sign_bit) << 0x20 | low_bit_mask;\n  }\n  uint32_t num_low_bit = ~(0x380 - num_high_bit);\n  if (num_low_bit > 0x1e) {\n    return ((uint64_t)high_bit_mask >> (num_low_bit - 0x1f & 0xff) | sign_bit) & 0x80000000ffffffff;\n  }\n  int num_shift = num_low_bit - 0x13;\n  if (num_shift == 0 || (num_shift < 0) != ((num_low_bit - 0x1f) < 0xc)) {\n    num_low_bit++;\n    return ((uint64_t)sign_bit | ((uint64_t)high_bit_mask >> (num_low_bit & 0xff)) | ((uint64_t)low_bit_mask << (0x20 - num_low_bit & 0xff)));\n  }\n  return ((uint64_t)sign_bit << 0x20) | ((uint64_t)high_bit_mask >> (0x20 - (0xcU - num_shift) & 0xff) | ((uint64_t)low_bit_mask << (0xcU - num_shift & 0xff))) & 0x80000000ffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008590",
            "calling": [
                "FUN_080046d0",
                "FUN_08004940",
                "FUN_08003004",
                "FUN_0800056c",
                "FUN_08002638",
                "FUN_08002978",
                "FUN_08004e30",
                "FUN_08001f00",
                "FUN_08003b98",
                "FUN_08002c18",
                "FUN_08001994",
                "FUN_080005b4",
                "FUN_080044e8",
                "FUN_08002408"
            ],
            "imported": false,
            "current_name": "reverse_bits_08008590"
        },
        "FUN_08007ad0": {
            "renaming": {
                "FUN_08007ad0": "initialize_memory_08007ad0",
                "_DAT_40000000": "ptr[0]",
                "_DAT_40000004": "ptr[1]",
                "_DAT_40000008": "ptr[2]",
                "_DAT_4000000c": "ptr[3]",
                "_DAT_40000010": "ptr[4]",
                "_DAT_40000018": "ptr[5]",
                "_DAT_4000001c": "ptr[6]",
                "_DAT_40000020": "ptr[7]",
                "_DAT_40000024": "ptr[8]",
                "_DAT_40000028": "ptr[9]",
                "_DAT_4000002c": "ptr[10]",
                "_DAT_40000034": "ptr[12]",
                "_DAT_40000038": "ptr[13]",
                "_DAT_4000003c": "ptr[14]",
                "_DAT_40000040": "ptr[15]",
                "_DAT_40000048": "ptr[16]",
                "_DAT_4000004c": "ptr[17]",
                "set_flag_08007a10": "set_flag",
                "write_bits_to_memory_08007a70": "write_bits_to_memory",
                "PTR_DAT_08007b68": "ptr_08007b68",
                "DAT_08007b6c": "num_08007b6c"
            },
            "code": "void initialize_memory_08007ad0(void)\n{\n  set_flag(0x40000000);\n  uint32_t* ptr = (uint32_t*)0x40000000;\n  for(int i = 0; i < 11; i++)\n  {\n    ptr[i] = 0;\n  }\n  ptr[11] = (uint)((unsigned long long)DAT_08007b6c * (unsigned long long)*(uint32_t*)PTR_DAT_08007b68 >> 0x38) - 1;\n  for(int i = 12; i < 19; i++)\n  {\n    ptr[i] = 0;\n  }\n  write_bits_to_memory(0x40000000,0,0);\n}\n",
            "called": [
                "FUN_08007a70",
                "FUN_08007a10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ad0",
            "calling": [
                "FUN_08007e08"
            ],
            "imported": false,
            "current_name": "initialize_memory_08007ad0"
        },
        "FUN_080005b4": {
            "renaming": {
                "FUN_080005b4": "process_data_080005b4",
                "param_1": "inputData",
                "puVar1": "pointer1",
                "uVar2": "variable2",
                "iVar3": "variable3",
                "uVar4": "variable4",
                "uVar5": "result",
                "uVar6": "variable6",
                "uVar7": "variable7",
                "local_94": "localArray1",
                "local_84": "localVariable1",
                "local_80": "localVariable2",
                "local_7c": "localVariable3",
                "uStack_78": "stackVariable1",
                "uStack_74": "stackVariable2",
                "auStack_70": "stackArray1",
                "local_58": "localVariable4",
                "local_52": "localVariable5",
                "local_51": "localArray2",
                "local_3d": "localVariable6",
                "local_3c": "localVariable7",
                "local_3b": "localVariable8",
                "local_3a": "localVariable9",
                "local_39": "localVariable10",
                "local_38": "localVariable11",
                "local_34": "localVariable12",
                "local_2f": "localVariable13",
                "local_2e": "localVariable14",
                "local_2d": "localVariable15",
                "local_2c": "localVariable16",
                "local_27": "localVariable17",
                "local_26": "localVariable18",
                "local_24": "localVariable19"
            },
            "code": "\nuint processData_080005b4(undefined4 inputData)\n\n{\n  undefined *pointer1;\n  undefined variable2;\n  int variable3;\n  undefined4 variable4;\n  uint result;\n  undefined4 variable6;\n  undefined8 variable7;\n  undefined4 localArray1 [4];\n  undefined4 localVariable1;\n  undefined4 localVariable2;\n  undefined4 localVariable3;\n  undefined4 stackVariable1;\n  undefined4 stackVariable2;\n  undefined4 stackArray1 [6];\n  undefined4 localVariable4;\n  byte localVariable5;\n  undefined localArray2 [20];\n  byte localVariable6;\n  byte localVariable7;\n  byte localVariable8;\n  byte localVariable9;\n  char localVariable10;\n  undefined4 localVariable11;\n  undefined4 localVariable12;\n  sbyte localVariable13;\n  char localVariable14;\n  char localVariable15;\n  undefined4 localVariable16;\n  byte localVariable17;\n  ushort localVariable18;\n  uint localVariable19;\n  \n  if (PTR_DAT_08000808[1] == '\\x06') {\n    result = 0xc;\n  }\n  else {\n    localArray2[0] = 0;\n    localVariable18 = 0;\n    localVariable17 = 0;\n    localVariable16 = DAT_0800080c;\n    localVariable15 = '\\0';\n    localVariable14 = '\\0';\n    fill_memory_with_value_0800b430(stackArray1 + 3,0,0xc);\n    fill_memory_with_value_0800b430(stackArray1,0,0xc);\n    *PTR_DAT_08000810 = 0;\n    localVariable13 = 0;\n    while (variable3 = check_and_extract_byte_0800184c(&localVariable5,stackArray1 + 6,inputData,localArray2), variable3 != 0) {\n      variable7 = reverse_bits_08008590(localVariable4);\n      variable7 = calculate_08009798((int)variable7,(int)((ulonglong)variable7 >> 0x20));\n      localVariable19 = calculate_08008ba0((int)variable7,(int)((ulonglong)variable7 >> 0x20));\n      if (localVariable5 == 0x47) {\n        switch(localVariable19) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 0x50:\n          localVariable13 = 2;\n          break;\n        case 4:\n        case 10:\n        case 0x1c:\n        case 0x1e:\n        case 0x35:\n        case 0x5c:\n          localVariable13 = 1;\n          break;\n        case 0x11:\n        case 0x12:\n        case 0x13:\n          localVariable13 = 3;\n          break;\n        case 0x14:\n        case 0x15:\n          localVariable13 = 7;\n          break;\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n          localVariable13 = 9;\n          break;\n        case 0x5a:\n        case 0x5b:\n          localVariable13 = 4;\n          break;\n        case 0x5d:\n        case 0x5e:\n          localVariable13 = 6;\n        }\n        switch(localVariable19) {\n        case 0:\n          PTR_DAT_08000ca0[1] = 0;\n          break;\n        case 1:\n          PTR_DAT_08000ca0[1] = 1;\n          break;\n        case 2:\n          PTR_DAT_08000ca0[1] = 2;\n          break;\n        case 3:\n          PTR_DAT_08000ca0[1] = 3;\n          break;\n        case 4:\n          localVariable14 = '\\x01';\n          break;\n        default:\n          *PTR_DAT_08000ca0 = 3;\n          break;\n        case 10:\n          localVariable14 = '\\x02';\n          break;\n        case 0x11:\n          set_parameters_in_array_08000478(0,1,2);\n          break;\n        case 0x12:\n          set_parameters_in_array_08000478(2,0,1);\n          break;\n        case 0x13:\n          set_parameters_in_array_08000478(1,2,0);\n          break;\n        case 0x14:\n          PTR_DAT_08000ca0[3] = 1;\n          break;\n        case 0x15:\n          PTR_DAT_08000ca0[3] = 0;\n          break;\n        case 0x1c:\n        case 0x1e:\n          variable4 = calculate_float_08008eec(localVariable4,DAT_08000ca4);\n          variable7 = reverse_bits_08008590(variable4);\n          variable7 = calculate_08009798((int)variable7,(int)((ulonglong)variable7 >> 0x20));\n          localVariable19 = calculate_08008ba0((int)variable7,(int)((ulonglong)variable7 >> 0x20));\n          switch(localVariable19) {\n          case 0x118:\n            localVariable14 = '\\x03';\n            break;\n          case 0x119:\n            localVariable14 = '\\x04';\n            break;\n          default:\n            *PTR_DAT_08000ca0 = 3;\n            break;\n          case 300:\n            localVariable14 = '\\x05';\n            break;\n          case 0x12d:\n            localVariable14 = '\\x06';\n          }\n          break;\n        case 0x35:\n          localVariable15 = '\\x01';\n          break;\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n          PTR_DAT_08000ca0[0x1c] = (char)localVariable19 + -0x36;\n          break;\n        case 0x50:\n          PTR_DAT_08000ca0[1] = 4;\n          break;\n        case 0x5a:\n          PTR_DAT_08000ca0[4] = 1;\n          break;\n        case 0x5b:\n          PTR_DAT_08000ca0[4] = 0;\n          break;\n        case 0x5c:\n          variable4 = calculate_float_08008eec(localVariable4,DAT_08000ca4);\n          variable7 = reverse_bits_08008590(variable4);\n          variable7 = calculate_08009798((int)variable7,(int)((ulonglong)variable7 >> 0x20));\n          localVariable19 = calculate_08008ba0((int)variable7,(int)((ulonglong)variable7 >> 0x20));\n          if (localVariable19 == 0x398) {\n            localVariable14 = '\\a';\n          }\n          else if (localVariable19 == 0x399) {\n            localVariable14 = '\\b';\n          }\n          else {\n            *PTR_DAT_08000ca0 = 3;\n          }\n          break;\n        case 0x5d:\n          PTR_DAT_08000ca0[2] = 1;\n          break;\n        case 0x5e:\n          PTR_DAT_08000ca0[2] = 0;\n        }\n      }\n      else if (localVariable5 == 0x4d) {\n        if (localVariable19 == 0x1e) {\nLAB_08000b96:\n          localVariable13 = 5;\n        }\n        else if ((int)localVariable19 < 0x1f) {\n          if ((int)localVariable19 < 3) {\n            if (-1 < (int)localVariable19) goto LAB_08000b96;\n          }\n          else if (localVariable19 - 3 < 3) {\n            localVariable13 = 8;\n          }\n        }\n        switch(localVariable19) {\n        case 0:\n          PTR_DAT_08000ca0[5] = 1;\n          break;\n        case 1:\n          break;\n        case 2:\n        case 0x1e:\n          PTR_DAT_08000ca0[5] = 2;\n          break;\n        case 3:\n          PTR_DAT_08000ca0[6] = 1;\n          break;\n        case 4:\n          PTR_DAT_08000ca0[6] = 0xff;\n          break;\n        case 5:\n          PTR_DAT_08000ca0[6] = 0;\n          break;\n        default:\n          *PTR_DAT_08000ca0 = 3;\n          break;\n        case 7:\n          PTR_DAT_08000ca0[7] = 2;\n          break;\n        case 8:\n          PTR_DAT_08000ca0[7] = 1;\n          break;\n        case 9:\n          PTR_DAT_08000ca0[7] = 0;\n        }\n      }\n      if (localVariable13 != 0) {\n        if (((int)(uint)localVariable18 >> localVariable13 & 1U) == 0) {\n          localVariable18 = localVariable18 | (ushort)(1 << localVariable13);\n        }\n        else {\n          *PTR_DAT_08000ca0 = 5;\n        }\n        localVariable13 = 0;\n      }\n    }\n    if (*PTR_DAT_08000ff0 == '\\0') {\n      localVariable12 = 0;\n      localVariable11 = 0;\n      localVariable10 = '\\0';\n      localArray2[0] = 0;\nswitchD_08000d18_caseD_47:\n      variable3 = check_and_extract_byte_0800184c(&localVariable5,stackArray1 + 6,inputData,localArray2);\n      if (variable3 != 0) {\n        switch(localVariable5) {\n        case 0x46:\n          variable3 = check_concatenation_result_0800923c(localVariable4,0);\n          if (variable3 != 0) {\n            *PTR_DAT_08000ff0 = 6;\n          }\n          if (PTR_DAT_08000ff0[2] == '\\0') {\n            variable4 = calculate_reversed_float_bits_0800056c(localVariable4);\n            *(undefined4 *)(PTR_DAT_08000ff0 + 8) = variable4;\n          }\n          else {\n            localVariable16 = calculate_reversed_float_bits_0800056c(localVariable4);\n          }\n          break;\n        case 0x47:\n        case 0x4d:\n        case 0x4e:\n          break;\n        default:\n          *PTR_DAT_08000ff0 = 3;\n          break;\n        case 0x49:\n        case 0x4a:\n        case 0x4b:\n          result = (uint)localVariable5;\n          variable4 = calculate_reversed_float_bits_0800056c(localVariable4);\n          stackArray1[result - 0x49] = variable4;\n          break;\n        case 0x4c:\n          variable7 = reverse_bits_08008590(localVariable4);\n          variable7 = calculate_08009798((int)variable7,(int)((ulonglong)variable7 >> 0x20));\n          localVariable10 = calculate_shift_amount_08008bf0((int)variable7,(int)((ulonglong)variable7 >> 0x20));\n          break;\n        case 0x50:\n          localVariable12 = localVariable4;\n          break;\n        case 0x52:\n          localVariable11 = calculate_reversed_float_bits_0800056c(localVariable4);\n          break;\n        case 0x53:\n          variable3 = is_string_terminated_08009228(localVariable4,0);\n          if (variable3 != 0) {\n            *PTR_DAT_08000ff0 = 6;\n          }\n          break;\n        case 0x54:\n          variable3 = is_string_terminated_08009228(localVariable4,0);\n          if (variable3 != 0) {\n            *PTR_DAT_08000ff0 = 6;\n          }\n          variable7 = reverse_bits_08008590(localVariable4);\n          variable7 = calculate_08009798((int)variable7,(int)((ulonglong)variable7 >> 0x20));\n          variable2 = calculate_shift_amount_08008bf0((int)variable7,(int)((ulonglong)variable7 >> 0x20));\n          PTR_DAT_08000ff0[0x18] = variable2;\n          break;\n        case 0x58:\n          stackArray1[3] = calculate_reversed_float_bits_0800056c(localVariable4);\n          localVariable17 = localVariable17 | 1;\n          break;\n        case 0x59:\n          stackArray1[4] = calculate_reversed_float_bits_0800056c(localVariable4);\n          localVariable17 = localVariable17 | 2;\n          break;\n        case 0x5a:\n          stackArray1[5] = calculate_reversed_float_bits_0800056c(localVariable4);\n          localVariable17 = localVariable17 | 4;\n        }\n        goto switchD_08000d18_caseD_47;\n      }\n      if (*PTR_DAT_08000ff0 == '\\0') {\n        if (PTR_DAT_08000ff4[1] != '\\a') {\n          check_param_0800525c((int)(char)PTR_DAT_08000ff0[6]);\n          process_input_and_update_state_08000220(PTR_DAT_08000ff0[7]);\n        }\n        if ((localVariable18 & 0x200) != 0) {\n          variable3 = is_sum_equal_to_last_value_and_fill_memory_with_value_08004d7c(PTR_DAT_08000ff0[0x1c],&localVariable3);\n          pointer1 = PTR_DAT_08000ff0;\n          if (variable3 == 0) {\n            return 10;\n          }\n          *(undefined4 *)(PTR_DAT_08000ff0 + 0x20) = localVariable3;\n          *(undefined4 *)(pointer1 + 0x24) = stackVariable1;\n          *(undefined4 *)(pointer1 + 0x28) = stackVariable2;\n        }\n        switch(localVariable14) {\n        case '\\x01':\n          variable3 = is_string_terminated_08009228(localVariable12,0);\n          if (variable3 == 0) {\n            if (PTR_DAT_08000ff4[1] != '\\a') {\n              process_data_08002408(localVariable12);\n            }\n          }\n          else {\n            *PTR_DAT_08000ff0 = 6;\n          }\n          break;\n        case '\\x02':\n          variable7 = reverse_bits_08008590(localVariable12);\n          variable7 = calculate_08009798((int)variable7,(int)((ulonglong)variable7 >> 0x20));\n          localVariable19 = calculate_08008ba0((int)variable7,(int)((ulonglong)variable7 >> 0x20));\n          if ((((localVariable10 == '\\x02') || (localVariable10 == '\\x14')) && (-1 < (int)localVariable19)) &&\n             ((int)localVariable19 < 7)) {\n            if ((localVariable17 == 0) && (localVariable10 == '\\x02')) {\n              *PTR_DAT_08000ff0 = 6;\n            }\n            else {\n              if ((int)localVariable19 < 1) {\n                localVariable19 = (uint)(byte)PTR_DAT_08001304[0x1c];\n              }\n              else {\n                localVariable19 = localVariable19 - 1;\n              }\n              variable3 = is_sum_equal_to_last_value_and_fill_memory_with_value_08004d7c(localVariable19 & 0xff,localArray1);\n              if (variable3 == 0) {\n                return 10;\n              }\n              for (localVariable9 = 0; localVariable9 < 3; localVariable9 = localVariable9 + 1) {\n                if (((int)(uint)localVariable17 >> localVariable9 & 1U) != 0) {\n                  if (localVariable10 == '\\x14') {\n                    result = (uint)localVariable9;\n                    variable4 = calculate_float_08008cd8(*(undefined4 *)(PTR_DAT_08001304 + (localVariable9 + 2) * 4 + 4),\n                                         stackArray1[localVariable9 + 3]);\n                    localArray1[result] = variable4;\n                  }\n                  else {\n                    localArray1[localVariable9] = stackArray1[localVariable9 + 3];\n                  }\n                }\n              }\n              calculate_checksum_08004bf4(localVariable19 & 0xff,localArray1);\n              pointer1 = PTR_DAT_08001304;\n              if (localVariable19 == (byte)PTR_DAT_08001304[0x1c]) {\n                *(undefined4 *)(PTR_DAT_08001304 + 0x20) = localArray1[0];\n                *(undefined4 *)(pointer1 + 0x24) = localArray1[1];\n                *(undefined4 *)(pointer1 + 0x28) = localArray1[2];\n              }\n            }\n          }\n          else {\n            *PTR_DAT_08000ff0 = 3;\n          }\n          localVariable17 = 0;\n          break;\n        case '\\x03':\n        case '\\x05':\n          if (localVariable17 != 0) {\n            for (localVariable8 = 0; localVariable8 < 3; localVariable8 = localVariable8 + 1) {\n              if (((int)(uint)localVariable17 >> localVariable8 & 1U) == 0) {\n                stackArray1[localVariable8 + 3] =\n                     *(undefined4 *)(PTR_DAT_08001304 + (localVariable8 + 2) * 4 + 4);\n              }\n              else if (PTR_DAT_08001304[4] == '\\0') {\n                result = (uint)localVariable8;\n                variable4 = calculate_float_08008cdc(stackArray1[localVariable8 + 3],\n                                     *(undefined4 *)(PTR_DAT_08001304 + (localVariable8 + 2) * 4 + 4));\n                stackArray1[result + 3] = variable4;\n              }\n              else {\n                variable6 = stackArray1[localVariable8 + 3];\n                variable4 = calculate_float_08008cdc(*(undefined4 *)(PTR_DAT_08001304 + (localVariable8 + 8) * 4),\n                                     *(undefined4 *)(PTR_DAT_08001304 + (localVariable8 + 10) * 4 + 4));\n                result = (uint)localVariable8;\n                variable4 = calculate_float_08008cdc(variable6,variable4);\n                stackArray1[result + 3] = variable4;\n              }\n            }\n            process_data_and_set_flags_if_second_element_is_two_08001e98(stackArray1[3],stackArray1[4],stackArray1[5],\n                         *(undefined4 *)(PTR_DAT_08001308 + 0x14),0);\n          }\n          if (localVariable14 == '\\x05') {\n            variable3 = is_sum_equal_to_last_value_and_fill_memory_with_value_08004d7c(7,localArray1 + 3);\n            if (variable3 == 0) {\n              return 10;\n            }\n          }\n          else {\n            variable3 = is_sum_equal_to_last_value_and_fill_memory_with_value_08004d7c(6,localArray1 + 3);\n            if (variable3 == 0) {\n              return 10;\n            }\n          }\n          process_data_and_set_flags_if_second_element_is_two_08001e98(localArray1[3],localVariable1,localVariable2,*(undefined4 *)(PTR_DAT_08001308 + 0x14),0);\n          pointer1 = PTR_DAT_08001304;\n          *(undefined4 *)(PTR_DAT_08001304 + 0xc) = localArray1[3];\n          *(undefined4 *)(pointer1 + 0x10) = localVariable1;\n          *(undefined4 *)(pointer1 + 0x14) = localVariable2;\n          localVariable17 = 0;\n          break;\n        case '\\x04':\n        case '\\x06':\n          if (localVariable14 == '\\x06') {\n            calculate_checksum_08004bf4(7,PTR_DAT_0800130c);\n          }\n          else {\n            calculate_checksum_08004bf4(6,PTR_DAT_0800130c);\n          }\n          break;\n        case '\\a':\n          if (localVariable17 == 0) {\n            *PTR_DAT_08001304 = 6;\n          }\n          else {\n            for (localVariable7 = 0; localVariable7 < 3; localVariable7 = localVariable7 + 1) {\n              if (((int)(uint)localVariable17 >> localVariable7 & 1U) != 0) {\n                variable4 = calculate_float_08008cd8(*(undefined4 *)(PTR_DAT_08001304 + (localVariable7 + 2) * 4 + 4),\n                                     *(undefined4 *)(PTR_DAT_08001304 + (localVariable7 + 8) * 4));\n                result = (uint)localVariable7;\n                variable4 = calculate_float_08008cd8(variable4,stackArray1[localVariable7 + 3]);\n                *(undefined4 *)(PTR_DAT_08001304 + (result + 10) * 4 + 4) = variable4;\n              }\n            }\n          }\n          localVariable17 = 0;\n          break;\n        case '\\b':\n          fill_memory_with_value_0800b430(PTR_DAT_08001310,0,0xc);\n        }\n        if (((localVariable18 & 4) != 0) || (localVariable17 != 0)) {\n          if ((PTR_DAT_08001574[2] != '\\0') &&\n             ((variable3 = is_string_terminated_08009228(localVariable16,0), variable3 != 0 && (PTR_DAT_08001574[1] != '\\x04')))) {\n            *PTR_DAT_08001574 = 6;\n          }\n          if (((localVariable15 != '\\0') && (PTR_DAT_08001574[1] != '\\0')) &&\n             (PTR_DAT_08001574[1] != '\\x01')) {\n            *PTR_DAT_08001574 = 6;\n          }\n          if (*PTR_DAT_08001574 != '\\0') {\n            return (uint)(byte)*PTR_DAT_08001574;\n          }\n          for (localVariable6 = 0; pointer1 = PTR_DAT_08001840, localVariable6 < 3; localVariable6 = localVariable6 + 1) {\n            if (((int)(uint)localVariable17 >> localVariable6 & 1U) == 0) {\n              stackArray1[localVariable6 + 3] = *(undefined4 *)(PTR_DAT_08001574 + (localVariable6 + 2) * 4 + 4);\n            }\n            else if (localVariable15 == '\\0') {\n              if (PTR_DAT_08001574[4] == '\\0') {\n                result = (uint)localVariable6;\n                variable4 = calculate_float_08008cdc(stackArray1[localVariable6 + 3],\n                                     *(undefined4 *)(PTR_DAT_08001574 + (localVariable6 + 2) * 4 + 4));\n                stackArray1[result + 3] = variable4;\n              }\n              else {\n                variable6 = stackArray1[localVariable6 + 3];\n                variable4 = calculate_float_08008cdc(*(undefined4 *)(PTR_DAT_08001574 + (localVariable6 + 8) * 4),\n                                     *(undefined4 *)(PTR_DAT_08001574 + (localVariable6 + 10) * 4 + 4));\n                result = (uint)localVariable6;\n                variable4 = calculate_float_08008cdc(variable6,variable4);\n                stackArray1[result + 3] = variable4;\n              }\n            }\n          }\n          if ((byte)PTR_DAT_08001574[1] < 5) {\n                    /* WARNING: Could not recover jumptable at 0x08001474. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n            result = (*(code *)(&switchD_08001474::switchdataD_08001478)[(byte)PTR_DAT_08001574[1]])\n                              ();\n            return result;\n          }\n          if (*PTR_DAT_08001840 != '\\0') {\n            return (uint)(byte)*PTR_DAT_08001840;\n          }\n          *(undefined4 *)(PTR_DAT_08001840 + 0xc) = stackArray1[3];\n          *(undefined4 *)(pointer1 + 0x10) = stackArray1[4];\n          *(undefined4 *)(pointer1 + 0x14) = stackArray1[5];\n        }\n        if (PTR_DAT_08001840[5] != '\\0') {\n          process_until_alarm_or_exit_08002fd4();\n          PTR_DAT_08001848[0x10] = 0;\n          if (PTR_DAT_08001840[5] == '\\x02') {\n            enable_flag_if_not_set_and_check_080025e8();\n          }\n          else {\n            PTR_DAT_08001840[5] = 0;\n          }\n        }\n        result = (uint)(byte)*PTR_DAT_08001840;\n      }\n      else {\n        result = (uint)(byte)*PTR_DAT_08000ff0;\n      }\n    }\n    else {\n      result = (uint)(byte)*PTR_DAT_08000ff0;\n    }\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_08002fd4",
                "FUN_08008590",
                "FUN_08008bf0",
                "FUN_08000220",
                "FUN_08004d7c",
                "FUN_0800b430",
                "FUN_08001f00",
                "FUN_080025e8",
                "FUN_08001e98",
                "FUN_08000478",
                "FUN_08009798",
                "FUN_08009214",
                "FUN_08008cd8",
                "FUN_0800981c",
                "FUN_08008eec",
                "FUN_0800525c",
                "FUN_08004bf4",
                "FUN_080098d0",
                "FUN_08009228",
                "FUN_0800056c",
                "FUN_08008cdc",
                "FUN_08008c30",
                "FUN_08008ba0",
                "FUN_0800184c",
                "FUN_0800923c",
                "FUN_08008894",
                "FUN_08002408"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080005b4",
            "calling": [
                "FUN_080039bc",
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "process_data_080005b4"
        },
        "FUN_080039a0": {
            "renaming": {
                "FUN_080039a0": "initializeProgram_080039a0",
                "PTR_DAT_080039b8": "programStatus",
                "clear_data_08003980": "clearData",
                "printHelpMessage_08004228": "printHelpMessage"
            },
            "code": "void initializeProgram_080039a0(void)\n{\n  clearData();\n  printHelpMessage();\n  *(int *)PTR_DAT_080039b8 = 1;\n  return;\n}",
            "called": [
                "FUN_08003980",
                "FUN_08004228"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080039a0",
            "calling": [
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "initializeProgram_080039a0"
        },
        "FUN_08009204": {
            "renaming": {
                "FUN_08009204": "concatenate_08009204",
                "param_1": "first_half",
                "param_2": "second_half",
                "CONCAT44": "concatenate_64"
            },
            "code": "typedef unsigned long long uint64_t;\n\nuint64_t concatenate_08009204(uint32_t param_1, uint32_t param_2)\n{\n  calculate_result();\n  return ((uint64_t)param_2 << 32) | param_1;\n}",
            "called": [
                "FUN_0800919c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009204",
            "calling": [
                "FUN_08009214",
                "FUN_08009228",
                "FUN_080091fc",
                "FUN_0800923c"
            ],
            "imported": false,
            "current_name": "concatenate_08009204"
        },
        "FUN_080029d8": {
            "renaming": {
                "FUN_080029d8": "string_concatenation_check_080029d8",
                "param_1": "string_info_ptr",
                "param_2": "string_ptr",
                "param_3": "end_of_string_ptr",
                "iVar1": "is_concatenated",
                "uVar2": "hash_value",
                "uVar3": "string_info",
                "PTR_DAT_08002a90": "constant_data_pointer"
            },
            "code": "void string_concatenation_check_080029d8(int string_info_ptr, int string_ptr, int end_of_string_ptr)\\n{\\n    int is_concatenated = is_string_concatenated(string_info_ptr, *(undefined4 *)(string_ptr + 0x18), *(undefined4 *)(string_ptr + 0x1c));\\n    if (string_ptr != 0 && end_of_string_ptr != 0 && is_concatenated == 0) {\\n        if (*(char *)(string_ptr + 0x25) == \"\\0\" && is_end_of_string(end_of_string_ptr, *(undefined4 *)(string_ptr + 0x1c)) != 0) {\\n            undefined4 hash_value = calculate_hash_value(PTR_DAT_08002a90[0x20] ^ 0x80000000, *(undefined4 *)(end_of_string_ptr + 0x18), *(undefined4 *)(string_ptr + 0x20));\\n            if (is_string_terminated(*(undefined4 *)(string_ptr + 0x1c), hash_value) == 0) {\\n                hash_value = calculate_hash_value(PTR_DAT_08002a90[0x20] ^ 0x80000000, *(undefined4 *)(end_of_string_ptr + 0x18), *(undefined4 *)(string_ptr + 0x20));\\n            }\\n            *(undefined4 *)(string_ptr + 0x18) = hash_value;\\n        } else {\\n            *(undefined4 *)(string_ptr + 0x18) = *(undefined4 *)(string_ptr + 0x1c);\\n        }\\n        *(undefined *)(string_ptr + 0x24) = 1;\\n    }\\n    return;\\n}",
            "called": [
                "FUN_08009214",
                "FUN_08009264",
                "FUN_08009228",
                "FUN_08002978"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080029d8",
            "calling": [
                "FUN_08002a94"
            ],
            "imported": false,
            "current_name": "string_concatenation_check_080029d8"
        },
        "FUN_08007c5e": {
            "renaming": {
                "FUN_08007c5e": "set_global_variable_value_08007c5e",
                "param_1": "value",
                "_DAT_40000038": "global_variable"
            },
            "code": "void set_global_variable_value_08007c5e(int value)\n{\n    _DAT_40000038 = value;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007c5e",
            "calling": [
                "FUN_08005790"
            ],
            "imported": false,
            "current_name": "set_global_variable_value_08007c5e"
        },
        "FUN_08005760": {
            "renaming": {
                "FUN_08005760": "set_param_from_pointer_08005760",
                "PTR_DAT_08005774": "PTR_DATA",
                "set_param_with_mask_080052ac": "set_param_with_mask",
                "*(undefined2 *)(PTR_DAT_08005774 + 0x18)": "*(int *)(PTR_DATA + 0x18)"
            },
            "code": "void set_param_from_pointer_08005760(void)\n{\n  int param = *(undefined2 *)(PTR_DAT_08005774 + 0x18);\n  set_param_with_mask(param);\n  return;\n}",
            "called": [
                "FUN_080052ac"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005760",
            "calling": [
                "FUN_08007c7c"
            ],
            "imported": false,
            "current_name": "set_param_from_pointer_08005760"
        },
        "FUN_08008b24": {
            "renaming": {
                "FUN_08008b24": "is_collision_not_detected_08008b24",
                "in_CY": "input_char",
                "check_collision_and_return_result_08008b00": "check_collision_and_return_result"
            },
            "code": "bool is_collision_not_detected_08008b24(void)\n{\n  char input_char;\n  check_collision_and_return_result();\n  return input_char == '\\0';\n}",
            "called": [
                "FUN_08008b00"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b24",
            "calling": [
                "FUN_080098d0",
                "FUN_08003004",
                "FUN_08009b24"
            ],
            "imported": false,
            "current_name": "is_collision_not_detected_08008b24"
        },
        "FUN_08002814": {
            "renaming": {
                "FUN_08002814": "do_nothing_08002814"
            },
            "code": "\nvoid do_nothing_08002814(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002814",
            "calling": [
                "FUN_08001d4c",
                "FUN_08004148",
                "FUN_08002408"
            ],
            "imported": false,
            "current_name": "do_nothing_08002814"
        },
        "FUN_0800587c": {
            "renaming": {
                "FUN_0800587c": "update_data_if_condition_met_0800587c",
                "PTR_DAT_0800589c": "data_pointer"
            },
            "code": "void update_data_if_condition_met_0800587c(void)\n{\n  char second_char = PTR_DAT_0800589c[1];\n  if (second_char == '\\x03') {\n    PTR_DAT_0800589c[1] = 4;\n    PTR_DAT_0800589c[0x10] = 0;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800587c",
            "calling": [
                "FUN_08003a74"
            ],
            "imported": false,
            "current_name": "update_data_if_condition_met_0800587c"
        },
        "FUN_08008a02": {
            "renaming": {
                "FUN_08008a02": "convert_float_to_uint_08008a02",
                "param_1": "sign",
                "param_2": "exponent",
                "param_3": "mantissa",
                "param_4": "round_mode",
                "unaff_r4": "sign_copy",
                "uVar1": "msb",
                "uVar2": "sign_bit_copy",
                "uVar3": "mantissa_copy",
                "in_r12": "ROUNDING_MODE_BIT",
                "bVar4": "zero"
            },
            "code": "ulonglong convert_float_to_uint_08008a02(uint sign, uint exponent, uint mantissa, uint round_mode) {\n  uint sign_bit = sign & 0x80000000;\n  uint exponent_bits = exponent << 1;\n  uint mantissa_bits = mantissa;\n  if (round_mode != 0x80000000 || exponent_bits != 0x80000000) {\n    if (exponent_bits == 0x80000000) {\n      if ((sign | mantissa_bits) == 0) {\n        return (ulonglong)((sign ^ round_mode) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (round_mode == 0x80000000) {\n      if ((exponent | mantissa_bits) == 0) {\n        return (ulonglong)((sign ^ round_mode) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      bool zero = (sign | exponent_bits) == 0 || (exponent | mantissa_bits) == 0;\n      if (!zero) {\n        if (round_mode == 0) {\n          uint sign_bit_copy = sign & 0x80000000;\n          do {\n            uint msb = exponent_bits & 0x80000000;\n            exponent_bits <<= 1;\n            mantissa_bits = mantissa_bits * 2 + (uint)(msb != 0);\n          } while ((mantissa_bits & 0x100000) == 0);\n          mantissa_bits |= sign_bit_copy;\n          if (round_mode != sign_bit) {\n            return ((ulonglong) mantissa_bits << 0x20) | exponent_bits;\n          }\n        }\n        do {\n          uint msb = exponent & 0x80000000;\n          exponent <<= 1;\n          mantissa = mantissa * 2 + (uint)(msb != 0);\n        } while ((mantissa & 0x100000) == 0);\n        return ((ulonglong) mantissa_bits << 0x20) | exponent_bits;\n      }\n      if ((sign | exponent_bits) != 0) {\n        return (ulonglong)((sign ^ round_mode) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n      if ((exponent | mantissa_bits) != 0) {\n        return (ulonglong)((sign ^ round_mode) & 0x80000000) << 0x20;\n      }\n    }\n  }\n  return ((ulonglong) mantissa_bits << 0x20) | exponent_bits | 0x7ff8000000000000;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a02",
            "calling": [
                "FUN_08008894"
            ],
            "imported": false,
            "current_name": "convert_float_to_uint_08008a02"
        },
        "FUN_0800369c": {
            "renaming": {
                "FUN_0800369c": "processString_0800369c",
                "param_1": "str",
                "local_c": "currentChar",
                "waitForFlagAndReturn_08008250": "waitForFlagAndReturn"
            },
            "code": "void processString_0800369c(char *str)\n{\n    char *currentChar = str;\n    while (*currentChar != '\\0') \n    {\n        waitForFlagAndReturn(*currentChar);\n        currentChar++;\n    }\n    return;\n}",
            "called": [
                "FUN_08008250"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800369c",
            "calling": [
                "FUN_080039bc",
                "FUN_08004900"
            ],
            "imported": false,
            "current_name": "processString_0800369c"
        },
        "FUN_08005a98": {
            "renaming": {
                "FUN_08005a98": "check_values_within_range_08005a98",
                "param_1": "range_limit",
                "iVar1": "current_value",
                "uVar2": "next_value",
                "get_value_from_pointer_08005a84": "get_current_value"
            },
            "code": "void check_values_within_range_08005a98(int range_limit){\n  int current_value = get_current_value();\n  do {\n    uint next_value = get_current_value();\n  } while (next_value < (uint)(range_limit + current_value));\n  return;\n}",
            "called": [
                "FUN_08005a84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a98",
            "calling": [
                "FUN_080002a0"
            ],
            "imported": false,
            "current_name": "check_values_within_range_08005a98"
        },
        "FUN_08008cdc": {
            "renaming": {
                "FUN_08008cdc": "calculate_float_08008cdc",
                "param_1": "float1",
                "param_2": "float2",
                "param_3": "undefined",
                "param_4": "rounding_mode",
                "iVar1": "int_var1",
                "uVar2": "uint_var2",
                "uVar3": "uint_var3",
                "uVar4": "uint_var4",
                "uVar5": "uint_var5",
                "iVar6": "int_var6",
                "bVar7": "bool_var1"
            },
            "code": "\nuint calculate_float_08008cdc(uint float1,uint float2,undefined4 undefined,uint rounding_mode)\n\n{\n  int int_var1;\n  uint uint_var2;\n  uint uint_var3;\n  uint uint_var4;\n  uint uint_var5;\n  int int_var6;\n  bool bool_var1;\n  \n  uint_var3 = float1 << 1;\n  bool_var1 = uint_var3 == 0;\n  if (!bool_var1) {\n    rounding_mode = float2 << 1;\n    bool_var1 = rounding_mode == 0;\n  }\n  if (!bool_var1) {\n    bool_var1 = uint_var3 == rounding_mode;\n  }\n  int_var6 = (int)uint_var3 >> 0x18;\n  if (!bool_var1) {\n    bool_var1 = int_var6 == -1;\n  }\n  if (!bool_var1) {\n    bool_var1 = (int)rounding_mode >> 0x18 == -1;\n  }\n  if (bool_var1) {\n    int_var1 = (int)(float2 << 1) >> 0x18;\n    if (int_var6 == -1 || int_var1 == -1) {\n      uint_var3 = float2;\n      if (int_var6 == -1) {\n        uint_var3 = float1;\n      }\n      if (int_var6 != -1 || int_var1 != -1) {\n        float2 = uint_var3;\n      }\n      bool_var1 = (uint_var3 & 0x7fffff) == 0;\n      if (bool_var1) {\n        bool_var1 = (float2 & 0x7fffff) == 0;\n      }\n      if (bool_var1) {\n        bool_var1 = uint_var3 == float2;\n      }\n      if (!bool_var1) {\n        uint_var3 = uint_var3 | 0x400000;\n      }\n      return uint_var3;\n    }\n    if (((float1 ^ float2) & 0x7fffffff) != 0) {\n      if (uint_var3 == 0) {\n        float1 = float2;\n      }\n      return float1;\n    }\n    if (float1 != float2) {\n      return 0;\n    }\n    if ((uint_var3 & 0xff000000) == 0) {\n      uint_var3 = float1 << 1;\n      if ((float1 & 0x80000000) != 0) {\n        uint_var3 = uint_var3 | 0x80000000;\n      }\n      return uint_var3;\n    }\n    if (uint_var3 < 0xfe000000) {\n      return float1 + 0x800000;\n    }\n    float1 = float1 & 0x80000000;\nLAB_08008e12:\n    return float1 | 0x7f800000;\n  }\n  uint_var3 = uint_var3 >> 0x18;\n  rounding_mode = rounding_mode >> 0x18;\n  uint_var5 = rounding_mode - uint_var3;\n  bool_var1 = uint_var5 != 0;\n  uint_var4 = uint_var3;\n  if (bool_var1 && uint_var3 <= rounding_mode) {\n    uint_var4 = uint_var3 + uint_var5;\n  }\n  if (bool_var1 && uint_var3 <= rounding_mode) {\n    float2 = float2 ^ float1;\n  }\n  if (bool_var1 && uint_var3 <= rounding_mode) {\n    float1 = float1 ^ float2;\n  }\n  if (bool_var1 && uint_var3 <= rounding_mode) {\n    float2 = float2 ^ float1;\n  }\n  if (rounding_mode < uint_var3) {\n    uint_var5 = -uint_var5;\n  }\n  if (0x19 < uint_var5) {\n    return float1;\n  }\n  uint_var3 = float1 & 0xffffff | 0x800000;\n  if ((float1 & 0x80000000) != 0) {\n    uint_var3 = -uint_var3;\n  }\n  uint_var2 = float2 & 0xffffff | 0x800000;\n  if ((float2 & 0x80000000) != 0) {\n    uint_var2 = -uint_var2;\n  }\n  if (uint_var4 == uint_var5) {\n    uint_var2 = uint_var2 ^ 0x800000;\n    if (uint_var4 == 0) {\n      uint_var3 = uint_var3 ^ 0x800000;\n      uint_var4 = 1;\n    }\n    else {\n      uint_var5 = uint_var5 - 1;\n    }\n  }\n  uint_var3 = uint_var3 + ((int)uint_var2 >> (uint_var5 & 0xff));\n  uint_var2 = uint_var2 << (0x20 - uint_var5 & 0xff);\n  float1 = uint_var3 & 0x80000000;\n  if ((int)uint_var3 < 0) {\n    bool_var1 = uint_var2 != 0;\n    uint_var2 = -uint_var2;\n    uint_var3 = -uint_var3 - (uint)bool_var1;\n  }\n  if (uint_var3 < 0x800000) {\n    uint_var5 = uint_var2 & 0x80000000;\n    uint_var2 = uint_var2 << 1;\n    uint_var3 = uint_var3 * 2 + (uint)(uint_var5 != 0);\n    uint_var5 = uint_var4 - 2;\n    if (uint_var4 - 1 == 0 || uint_var3 < 0x800000) {\n      int_var6 = count_leading_zeroes(uint_var3);\n      uint_var4 = int_var6 - 8;\n      uint_var3 = uint_var3 << (uint_var4 & 0xff);\n      if ((int)uint_var5 < (int)uint_var4) {\n        uint_var3 = uint_var3 >> (-(uint_var5 - uint_var4) & 0xff);\n      }\n      else {\n        uint_var3 = uint_var3 + (uint_var5 - uint_var4) * 0x800000;\n      }\n      return uint_var3 | float1;\n    }\n  }\n  else {\n    uint_var5 = uint_var4 - 1;\n    if (0xffffff < uint_var3) {\n      uint_var5 = uint_var3 & 1;\n      uint_var3 = uint_var3 >> 1;\n      uint_var2 = (uint)(uint_var5 != 0) << 0x1f | uint_var2 >> 1;\n      uint_var5 = uint_var4;\n      if (0xfd < uint_var4) goto LAB_08008e12;\n    }\n  }\n  uint_var3 = uint_var3 + uint_var5 * 0x800000 + (uint)(0x7fffffff < uint_var2);\n  if (uint_var2 == 0x80000000) {\n    uint_var3 = uint_var3 & 0xfffffffe;\n  }\n  return uint_var3 | float1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008cdc",
            "calling": [
                "FUN_08004940",
                "FUN_080005b4",
                "FUN_08003826",
                "FUN_08002908",
                "FUN_080028bc",
                "FUN_08003004",
                "FUN_08002978",
                "FUN_08001f00"
            ],
            "imported": false,
            "current_name": "calculate_float_08008cdc"
        },
        "FUN_080044e8": {
            "renaming": {
                "FUN_080044e8": "printStackValues_080044e8",
                "auStack_18": "stack_values",
                "local_a": "index",
                "local_9": "stack_index",
                "iVar1": "is_sum_equal",
                "uVar2": "float_bits",
                "uVar3": "reverse_bits_result",
                "PTR_s__G92__080046c8": "error_message",
                "PTR_DAT_080046bc": "data",
                "PTR_DAT_080046cc": "stack_memory",
                "PTR_DAT_08004698": "sum_string",
                "PTR_DAT_0800469c": "sum_string_0",
                "PTR_DAT_080046a0": "sum_string_1",
                "PTR_DAT_080046a4": "sum_string_2",
                "PTR_DAT_080046a8": "sum_string_3",
                "PTR_DAT_080046ac": "sum_string_4",
                "PTR_DAT_080046b0": "sum_string_5",
                "PTR_DAT_080046b4": "sum_string_6",
                "PTR_DAT_080046b8": "sum_string_7",
                "PTR_DAT_080046c0": "comma_string",
                "PTR_DAT_080046c4": "new_line_string",
                "print_decimal_number_08003826": "printDecimalNumber",
                "processString_080036c6": "printString",
                "is_sum_equal_to_last_value_and_fill_memory_with_value_08004d7c": "isSumEqualToLastValueAndFillMemoryWithValues",
                "reverse_bits_08008590": "reverseBits",
                "FUN_08008640": "calculateFloatValue",
                "calculate_float_bits_08008c30": "calculateFloatBits",
                "printErrorMessage_08004030": "printErrorMessage"
            },
            "code": "void printStackValues_080044e8(void)\n{\n  int index;\n  int is_sum_equal;\n  undefined4 float_bits;\n  undefined8 reverse_bits_result;\n  undefined4 stack_values[3];\n  byte stack_index = 0;\n  while(stack_index <= 7) {\n    is_sum_equal = isSumEqualToLastValueAndFillMemoryWithValues(stack_index, stack_values);\n    if (!is_sum_equal) {\n      printErrorMessage(10);\n      return;\n    }\n    printString(\"Sum of previous 2 values and current value at index \");\n    printDecimalNumber(stack_index);\n    printString(\": \");\n    for (index = 0; index < 3; index++) {\n      if ((PTR_DAT_080046bc[0x28] & 1) == 0) {\n        printDecimalNumber(stack_values[index]);\n      }\n      else {\n        reverse_bits_result = reverseBits(stack_values[index]);\n        reverse_bits_result = calculateFloatValue(reverse_bits_result, reverse_bits_result >> 0x20, DAT_08004690, DAT_08004694);\n        float_bits = calculateFloatBits(reverse_bits_result, reverse_bits_result >> 0x20);\n        printDecimalNumber(float_bits);\n      }\n      if (index < 2) {\n        printString(\", \");\n      }\n    }\n    printString(\"\\n\");\n    stack_index++;\n  }\n}",
            "called": [
                "FUN_08008590",
                "FUN_08008c30",
                "FUN_08003826",
                "FUN_08008640",
                "FUN_08004d7c",
                "FUN_08004030",
                "FUN_080036c6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080044e8",
            "calling": [
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "printStackValues_080044e8"
        },
        "FUN_08006c9c": {
            "renaming": {
                "FUN_08006c9c": "validate_param_08006c9c",
                "param_1": "param",
                "bVar1": "is_valid",
                "DAT_08006cdc": "PTR_DAT_08006cdc",
                "write_byte_to_memory_08006b00": "write_byte_to_memory"
            },
            "code": "bool validate_param_08006c9c(unsigned int param) {\n    bool is_valid = param < 0x1000000;\n    if (is_valid) {\n        DAT_08006cdc[1] = param - 1;\n        write_byte_to_memory_08006b00(0xffffffff, 0xf);\n        DAT_08006cdc[2] = 0;\n        *DAT_08006cdc = 7;\n    }\n    return !is_valid;\n}",
            "called": [
                "FUN_08006b00"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c9c",
            "calling": [
                "FUN_08006d72"
            ],
            "imported": false,
            "current_name": "validate_param_08006c9c"
        },
        "FUN_0800a5a0": {
            "renaming": {
                "FUN_0800a5a0": "reverse_and_improve_0800a5a0",
                "param_1": "input_value",
                "param_2": "output_array",
                "param_3": "array_length",
                "param_4": "shift_amount",
                "param_5": "loop_count",
                "param_6": "input_array",
                "puVar1": "pointer1",
                "uVar2": "result",
                "uVar3": "temp_result",
                "iVar4": "loop_index",
                "puVar5": "pointer2",
                "uVar6": "temp_value",
                "ppuVar7": "pointer_array",
                "uVar8": "temp_value_2",
                "iVar9": "temp_index",
                "puVar10": "pointer3",
                "uVar11": "temp_value_3",
                "uVar12": "temp_value_4",
                "puVar13": "pointer4",
                "iVar14": "temp_index_2",
                "iVar15": "temp_value_5",
                "iVar17": "temp_value_6",
                "uStack_208": "temp_stack_1",
                "local_168": "temp_value_7",
                "local_160": "temp_array_1",
                "uStack_c8": "temp_stack_2",
                "uVar20": "temp_value_8",
                "iVar21": "temp_value_9",
                "puVar22": "pointer5",
                "puVar23": "pointer6",
                "bVar24": "boolean_flag",
                "uVar25": "temp_value_13",
                "uVar26": "temp_value_14",
                "uVar27": "temp_value_15",
                "uVar28": "final_result_3",
                "uVar29": "final_result_4",
                "local_284": "temp_stack_3",
                "local_280": "temp_value_16",
                "local_270": "temp_value_17",
                "local_26c": "temp_value_18",
                "local_260": "temp_array_2",
                "local_258": "temp_array_3"
            },
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: stack */\n\nuint reverse_and_improve_0800a5a0(int input_value,undefined8 *output_array,int array_length,int shift_amount,int loop_count,int input_array)\n\n{\n  undefined4 *pointer1;\n  uint result;\n  uint temp_result;\n  int loop_index;\n  uint *pointer2;\n  undefined4 temp_value;\n  uint **pointer_array;\n  undefined4 temp_value_2;\n  int temp_index;\n  undefined4 *pointer3;\n  undefined4 temp_value_3;\n  uint temp_value_4;\n  uint *pointer4;\n  int temp_index_2;\n  int temp_value_5;\n  undefined8 *pointer16;\n  int temp_value_6;\n  undefined4 *pointer18;\n  undefined8 *pointer19;\n  undefined4 temp_value_8;\n  int temp_value_9;\n  undefined8 *pointer5;\n  undefined4 *pointer6;\n  bool boolean_flag;\n  undefined8 temp_value_13;\n  undefined8 temp_value_14;\n  undefined8 temp_value_15;\n  undefined8 final_result_3;\n  ulonglong final_result_4;\n  undefined8 *temp_stack_3;\n  int temp_value_16;\n  int temp_value_17;\n  int temp_value_18;\n  uint *temp_array_2 [2];\n  uint temp_array_3 [20];\n  undefined8 temp_stack_1;\n  undefined8 temp_value_7;\n  int temp_array_1 [38];\n  undefined8 temp_stack_2;\n  \n  final_result_3 = CONCAT44(loop_count,loop_count);\n  temp_value_5 = *(int *)(PTR_DAT_0800a894 + loop_count * 4);\n  temp_index = shift_amount + -1;\n  temp_array_2[1] = (uint *)output_array;\n  if (array_length + 0x14 < 0 == SCARRY4(array_length,0x14)) {\n    temp_value_18 = (int)((longlong)DAT_0800a898 * (longlong)(array_length + -3) >> 0x22) -\n                (array_length + -3 >> 0x1f);\n    temp_value_17 = (temp_value_18 + 1) * -0x18;\n  }\n  else {\n    temp_value_17 = -0x18;\n    temp_value_18 = 0;\n  }\n  temp_value_17 = array_length + temp_value_17;\n  temp_value_6 = temp_value_18 - temp_index;\n  if (-1 < temp_value_5 + temp_index) {\n    temp_value_9 = temp_value_5 + temp_index + 1 + temp_value_6;\n    pointer16 = &temp_stack_1;\n    do {\n      while (temp_value_6 < 0) {\n        temp_value_6 = temp_value_6 + 1;\n        *(undefined4 *)pointer16 = 0;\n        *(undefined4 *)((int)pointer16 + 4) = 0;\n        pointer16 = pointer16 + 1;\n        if (temp_value_6 == temp_value_9) goto LAB_0800a626;\n      }\n      temp_value_14 = calculate_0800856c(*(undefined4 *)(input_array + temp_value_6 * 4));\n      temp_value_6 = temp_value_6 + 1;\n      *pointer16 = temp_value_14;\n      pointer16 = pointer16 + 1;\n    } while (temp_value_6 != temp_value_9);\n  }\nLAB_0800a626:\n  pointer3 = (undefined4 *)(input_value + -8);\n  if (-1 < temp_value_5) {\n    pointer5 = &temp_stack_1 + shift_amount;\n    temp_value_6 = temp_index;\n    pointer16 = &temp_stack_2;\n    do {\n      if (temp_index < 0) {\n        temp_value_14 = 0;\n      }\n      else {\n        temp_value_14 = 0;\n        pointer6 = pointer3;\n        pointer19 = pointer5;\n        do {\n          pointer18 = pointer6 + 2;\n          temp_value_13 = calculate_product_08008640(*pointer18,pointer6[3],*(undefined4 *)(pointer19 + -1),\n                                *(undefined4 *)((int)pointer19 + -4));\n          temp_value_14 = calculate_double_precision_080082d4((int)temp_value_14,(int)((ulonglong)temp_value_14 >> 0x20),(int)temp_value_13,\n                                (int)((ulonglong)temp_value_13 >> 0x20));\n          pointer6 = pointer18;\n          pointer19 = pointer19 + -1;\n        } while (pointer18 != pointer3 + shift_amount * 2);\n      }\n      temp_value_6 = temp_value_6 + 1;\n      *pointer16 = temp_value_14;\n      pointer5 = pointer5 + 1;\n      pointer16 = pointer16 + 1;\n    } while (temp_value_6 != temp_value_5 + shift_amount);\n  }\n  temp_array_2[0] = temp_array_3 + temp_value_5 + -1;\n  temp_value_6 = temp_value_5;\n  do {\n    temp_value_14 = CONCAT44(*(undefined4 *)((int)&temp_stack_2 + temp_value_6 * 8 + 4),\n                      *(undefined4 *)(&temp_stack_2 + temp_value_6));\n    if (0 < temp_value_6) {\n      pointer16 = &temp_stack_2 + temp_value_6;\n      pointer2 = temp_array_3;\n      do {\n        temp_value = (undefined4)((ulonglong)temp_value_14 >> 0x20);\n        calculate_product_08008640((int)temp_value_14,temp_value,0,DAT_0800a89c);\n        calculate_08008ba0();\n        temp_value_13 = calculate_0800856c();\n        temp_value_2 = (undefined4)((ulonglong)temp_value_13 >> 0x20);\n        temp_value_15 = calculate_product_08008640((int)temp_value_13,temp_value_2,0,DAT_0800a8a0);\n        reverse_and_improve_0800a5a0_080082d0((int)temp_value_14,temp_value,(int)temp_value_15,(int)((ulonglong)temp_value_15 >> 0x20));\n        result = calculate_08008ba0();\n        pointer5 = pointer16 + -1;\n        temp_value = *(undefined4 *)pointer5;\n        temp_value_3 = *(undefined4 *)((int)pointer16 + -4);\n        *pointer2 = result;\n        temp_value_14 = calculate_double_precision_080082d4((int)temp_value_13,temp_value_2,temp_value,temp_value_3);\n        pointer16 = pointer5;\n        pointer2 = pointer2 + 1;\n      } while (pointer5 != &temp_stack_2);\n    }\n    temp_value_14 = calculate_hash_0800b2e8((int)temp_value_14,(int)((ulonglong)temp_value_14 >> 0x20),temp_value_17);\n    temp_value_2 = (undefined4)((ulonglong)temp_value_14 >> 0x20);\n    calculate_product_08008640((int)temp_value_14,temp_value_2,0,0x3fc00000);\n    temp_value_13 = calculate_collision_080094c0();\n    temp_value_13 = calculate_product_08008640((int)temp_value_13,(int)((ulonglong)temp_value_13 >> 0x20),0,DAT_0800a8a4);\n    temp_value_14 = reverse_and_improve_0800a5a0_080082d0((int)temp_value_14,temp_value_2,(int)temp_value_13,(int)((ulonglong)temp_value_13 >> 0x20));\n    result = calculate_08008ba0();\n    temp_value_13 = calculate_0800856c();\n    temp_value_14 = reverse_and_improve_0800a5a0_080082d0((int)temp_value_14,(int)((ulonglong)temp_value_14 >> 0x20),(int)temp_value_13,\n                          (int)((ulonglong)temp_value_13 >> 0x20));\n    temp_value = (undefined4)((ulonglong)temp_value_14 >> 0x20);\n    temp_value_2 = (undefined4)temp_value_14;\n    if (temp_value_17 < 1) {\n      if (temp_value_17 == 0) {\n        temp_value_9 = (int)temp_array_3[temp_value_6 + -1] >> 0x17;\n        goto joined_r0x0800a8b8;\n      }\n      temp_value_9 = check_collision_and_return_result_08008b4c(temp_value_2,temp_value,0,DAT_0800ac3c);\n      if (temp_value_9 != 0) {\n        result = result + 1;\n        if (temp_value_6 < 1) {\n          temp_value_14 = reverse_and_improve_0800a5a0_080082d0(0,DAT_0800ac38,temp_value_2,temp_value);\n          temp_value_9 = 2;\n          goto LAB_0800a7a4;\n        }\n        temp_value_9 = 2;\n        goto LAB_0800a8c8;\n      }\n    }\n    else {\n      loop_index = (int)temp_array_3[temp_value_6 + -1] >> (0x18U - temp_value_17 & 0xff);\n      temp_value_4 = temp_array_3[temp_value_6 + -1] - (loop_index << (0x18U - temp_value_17 & 0xff));\n      temp_value_9 = (int)temp_value_4 >> (0x17U - temp_value_17 & 0xff);\n      temp_array_3[temp_value_6 + -1] = temp_value_4;\n      result = result + loop_index;\njoined_r0x0800a8b8:\n      if (0 < temp_value_9) {\n        result = result + 1;\n        if (temp_value_6 < 1) {\n          temp_value_4 = 0;\n        }\n        else {\nLAB_0800a8c8:\n          temp_value_4 = temp_array_3[0];\n          if (temp_array_3[0] == 0) {\n            if (temp_value_6 != 1) {\n              pointer2 = temp_array_3;\n              loop_index = 1;\n              do {\n                pointer2 = pointer2 + 1;\n                temp_value_4 = *pointer2;\n                if (temp_value_4 != 0) {\n                  temp_index_2 = loop_index + 1;\n                  goto LAB_0800a8e2;\n                }\n                loop_index = loop_index + 1;\n              } while (loop_index != temp_value_6);\n            }\n          }\n          else {\n            temp_index_2 = 1;\n            loop_index = 0;\nLAB_0800a8e2:\n            temp_array_3[loop_index] = 0x1000000 - temp_value_4;\n            if (temp_index_2 < temp_value_6) {\n              temp_value_4 = temp_array_3[temp_index_2];\n              pointer2 = temp_array_3 + temp_index_2;\n              while( true ) {\n                pointer4 = pointer2 + 1;\n                *pointer2 = 0xffffff - temp_value_4;\n                if (pointer4 == temp_array_3 + temp_value_6) break;\n                temp_value_4 = *pointer4;\n                pointer2 = pointer4;\n              }\n            }\n            temp_value_4 = 1;\n          }\n        }\n        if (0 < temp_value_17) {\n          if (temp_value_17 == 1) {\n            temp_array_3[temp_value_6 + -1] = temp_array_3[temp_value_6 + -1] & 0x7fffff;\n          }\n          else if (temp_value_17 == 2) {\n            temp_array_3[temp_value_6 + -1] = temp_array_3[temp_value_6 + -1] & 0x3fffff;\n          }\n        }\n        if (temp_value_9 == 2) {\n          temp_value_14 = reverse_and_improve_0800a5a0_080082d0(0,DAT_0800ac38,temp_value_2,temp_value);\n          if (temp_value_4 != 0) {\n            temp_value_13 = calculate_hash_0800b2e8(0,DAT_0800ac38,temp_value_17);\n            temp_value_14 = reverse_and_improve_0800a5a0_080082d0((int)temp_value_14,(int)((ulonglong)temp_value_14 >> 0x20),(int)temp_value_13,\n                                  (int)((ulonglong)temp_value_13 >> 0x20));\n          }\n        }\n      }\n    }\nLAB_0800a7a4:\n    temp_value_2 = (undefined4)((ulonglong)temp_value_14 >> 0x20);\n    loop_index = checkForCollision_08008b10((int)temp_value_14,temp_value_2,0,0);\n    if (loop_index == 0) {\n      temp_value_14 = calculate_hash_0800b2e8((int)temp_value_14,temp_value_2,-temp_value_17);\n      temp_value = (undefined4)((ulonglong)temp_value_14 >> 0x20);\n      temp_value_2 = (undefined4)temp_value_14;\n      temp_index = check_collision_and_return_result_08008b4c(temp_value_2,temp_value,0,DAT_0800ade4);\n      if (temp_index == 0) {\n        temp_value_4 = calculate_08008ba0(temp_value_2,temp_value);\n        temp_array_3[temp_value_6] = temp_value_4;\n        loop_index = temp_value_6;\n      }\n      else {\n        calculate_product_08008640(temp_value_2,temp_value,0,DAT_0800ade8);\n        temp_value_4 = calculate_08008ba0();\n        temp_value_14 = calculate_0800856c();\n        temp_value_14 = calculate_product_08008640((int)temp_value_14,(int)((ulonglong)temp_value_14 >> 0x20),0,DAT_0800ade4);\n        reverse_and_improve_0800a5a0_080082d0(temp_value_2,temp_value,(int)temp_value_14,(int)((ulonglong)temp_value_14 >> 0x20));\n        temp_result = calculate_08008ba0();\n        temp_value_17 = temp_value_17 + 0x18;\n        temp_array_3[temp_value_6] = temp_result;\n        temp_array_3[temp_value_6 + 1] = temp_value_4;\n        loop_index = temp_value_6 + 1;\n      }\n      goto LAB_0800a9f6;\n    }\n    loop_index = temp_value_6 + -1;\n    if (temp_value_5 <= loop_index) {\n      temp_value_4 = 0;\n      pointer2 = temp_array_3 + temp_value_6 + 0x3fffffff;\n      do {\n        pointer4 = pointer2 + -1;\n        temp_value_4 = temp_value_4 | *pointer2;\n        pointer2 = pointer4;\n      } while (pointer4 != temp_array_2[0]);\n      if (temp_value_4 != 0) break;\n    }\n    if (temp_array_3[temp_value_5 + -1] == 0) {\n      temp_value_16 = 1;\n      pointer_array = temp_array_2 + temp_value_5;\n      do {\n        pointer2 = *pointer_array;\n        temp_value_16 = temp_value_16 + 1;\n        pointer_array = pointer_array + -1;\n      } while (pointer2 == (uint *)0x0);\n      temp_value_16 = temp_value_6 + temp_value_16;\n    }\n    else {\n      temp_value_16 = temp_value_6 + 1;\n    }\n    temp_value_9 = temp_value_6 + 1;\n    pointer6 = (undefined4 *)(input_array + (temp_value_9 + temp_value_18 + 0x3fffffff) * 4);\n    pointer16 = &temp_stack_1 + temp_value_6 + shift_amount;\n    temp_stack_3 = &temp_stack_2 + temp_value_9;\n    do {\n      pointer6 = pointer6 + 1;\n      temp_value_14 = calculate_0800856c(*pointer6);\n      *pointer16 = temp_value_14;\n      pointer5 = pointer16 + 1;\n      if (temp_index < 0) {\n        temp_value_13 = 0;\n      }\n      else {\n        temp_value_13 = 0;\n        pointer18 = pointer3;\n        while( true ) {\n          pointer16 = pointer16 + -1;\n          pointer1 = pointer18 + 2;\n          temp_value_14 = calculate_product_08008640((int)temp_value_14,(int)((ulonglong)temp_value_14 >> 0x20),*pointer1,pointer18[3]);\n          temp_value_13 = calculate_double_precision_080082d4((int)temp_value_13,(int)((ulonglong)temp_value_13 >> 0x20),(int)temp_value_14,\n                                (int)((ulonglong)temp_value_14 >> 0x20));\n          if (pointer1 == pointer3 + shift_amount * 2) break;\n          temp_value_14 = *pointer16;\n          pointer18 = pointer1;\n        }\n      }\n      *temp_stack_3 = temp_value_13;\n      temp_value_9 = temp_value_9 + 1;\n      temp_value_6 = temp_value_16;\n      pointer16 = pointer5;\n      temp_stack_3 = temp_stack_3 + 1;\n    } while (temp_value_9 <= temp_value_16);\n  } while( true );\n  temp_value_17 = temp_value_17 + -0x18;\n  if (temp_array_3[loop_index] == 0) {\n    pointer2 = temp_array_3 + temp_value_6 + 0x3ffffffe;\n    do {\n      temp_value_4 = *pointer2;\n      loop_index = loop_index + -1;\n      temp_value_17 = temp_value_17 + -0x18;\n      pointer2 = pointer2 + -1;\n    } while (temp_value_4 == 0);\n  }\nLAB_0800a9f6:\n  temp_value_14 = calculate_hash_0800b2e8(0,DAT_0800ac38,temp_value_17);\n  if (loop_index < 0) {\n    if (2 < loop_count) {\n      if (loop_count == 3) {\n        final_result_3 = 0;\nLAB_0800abe4:\n        if (temp_value_9 == 0) {\n          *temp_array_2[1] = (undefined4)temp_value_7;\n          *(int *)((int)temp_array_2[1] + 4) = temp_value_7._4_4_;\n          *(undefined8 *)((int)temp_array_2[1] + 0x10) = final_result_3;\n          *(int *)((int)temp_array_2[1] + 8) = temp_array_1[0];\n          *(int *)((int)temp_array_2[1] + 0xc) = temp_array_1[1];\n          return result & 7;\n        }\n        *(int *)((int)temp_array_2[1] + 0x10) = (int)final_result_3;\n        *(int *)((int)temp_array_2[1] + 8) = temp_array_1[0];\n        *(int *)((int)temp_array_2[1] + 0x14) = (int)((ulonglong)final_result_3 >> 0x20) + -0x80000000;\n        *(int *)((int)temp_array_2[1] + 4) = temp_value_7._4_4_ + -0x80000000;\n        *(int *)((int)temp_array_2[1] + 0xc) = temp_array_1[1] + -0x80000000;\n        *temp_array_2[1] = (undefined4)temp_value_7;\n        return result & 7;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (loop_count < 1) {\n      if (loop_count != 0) goto LAB_0800ab0e;\nLAB_0800aafc:\n      temp_index = (int)((ulonglong)final_result_3 >> 0x20);\n      if (temp_value_9 != 0) {\n        temp_index = temp_index + -0x80000000;\n      }\n      *temp_array_2[1] = (int)final_result_3;\n      *(int *)((int)temp_array_2[1] + 4) = temp_index;\nLAB_0800ab0e:\n      return result & 7;\n    }\n    final_result_3 = 0;\n  }\n  else {\n    pointer5 = &temp_stack_2 + loop_index;\n    pointer2 = temp_array_3 + loop_index + 1;\n    pointer16 = &temp_stack_2 + loop_index + 1;\n    do {\n      temp_value_2 = (undefined4)((ulonglong)temp_value_14 >> 0x20);\n      pointer2 = pointer2 + -1;\n      temp_value_13 = calculate_0800856c(*pointer2);\n      temp_value_13 = calculate_product_08008640((int)temp_value_13,(int)((ulonglong)temp_value_13 >> 0x20),(int)temp_value_14,temp_value_2);\n      pointer16 = pointer16 + -1;\n      *pointer16 = temp_value_13;\n      temp_value_14 = calculate_product_08008640((int)temp_value_14,temp_value_2,0,DAT_0800ac40);\n    } while (pointer2 != temp_array_3);\n    temp_index = 0;\n    temp_value_2 = DAT_0800ac30;\n    temp_value = DAT_0800ac34;\n    do {\n      DAT_0800ac30 = temp_value_2;\n      DAT_0800ac34 = temp_value;\n      if (temp_value_5 < 0) {\n        temp_value_14 = 0;\n      }\n      else {\n        temp_value_14 = 0;\n        temp_value_6 = 0;\n        pointer16 = pointer5;\n        pointer3 = (undefined4 *)PTR_DAT_0800ac44;\n        while( true ) {\n          temp_value_13 = calculate_product_08008640(*(undefined4 *)pointer16,*(undefined4 *)((int)pointer16 + 4),temp_value_2,temp_value\n                               );\n          temp_value_14 = calculate_double_precision_080082d4((int)temp_value_14,(int)((ulonglong)temp_value_14 >> 0x20),(int)temp_value_13,\n                                (int)((ulonglong)temp_value_13 >> 0x20));\n          temp_value_6 = temp_value_6 + 1;\n          if ((temp_value_5 < temp_value_6) || (temp_index < temp_value_6)) break;\n          temp_value_2 = *pointer3;\n          temp_value = pointer3[1];\n          pointer16 = pointer16 + 1;\n          pointer3 = pointer3 + 2;\n        }\n      }\n      boolean_flag = temp_index != loop_index;\n      *(int *)(&temp_value_7 + temp_index) = (int)temp_value_14;\n      *(int *)((int)&temp_value_7 + (temp_index * 2 + 1) * 4) = (int)((ulonglong)temp_value_14 >> 0x20);\n      pointer5 = pointer5 + -1;\n      temp_index = temp_index + 1;\n      temp_value_2 = DAT_0800ac30;\n      temp_value = DAT_0800ac34;\n    } while (boolean_flag);\n    if (2 < loop_count) {\n      if (loop_count == 3) {\n        if (loop_index != 0) {\n          pointer16 = &temp_value_7 + loop_index;\n          final_result_3 = CONCAT44(*(undefined4 *)((int)&temp_value_7 + (loop_index * 2 + 1) * 4),\n                            *(undefined4 *)pointer16);\n          do {\n            temp_value = (undefined4)((ulonglong)final_result_3 >> 0x20);\n            temp_value_2 = (undefined4)final_result_3;\n            temp_value_3 = *(undefined4 *)(pointer16 + -1);\n            temp_value_8 = *(undefined4 *)((int)pointer16 + -4);\n            final_result_3 = calculate_double_precision_080082d4(temp_value_2,temp_value,temp_value_3,temp_value_8);\n            temp_value_14 = reverse_and_improve_0800a5a0_080082d0(temp_value_3,temp_value_8,(int)final_result_3,(int)((ulonglong)final_result_3 >> 0x20));\n            temp_value_14 = calculate_double_precision_080082d4((int)temp_value_14,(int)((ulonglong)temp_value_14 >> 0x20),temp_value_2,temp_value);\n            *pointer16 = temp_value_14;\n            pointer16 = pointer16 + -1;\n            *pointer16 = final_result_3;\n          } while (&temp_value_7 != pointer16);\n          if (1 < loop_index) {\n            pointer16 = &temp_value_7 + loop_index;\n            final_result_3 = CONCAT44(*(undefined4 *)((int)&temp_value_7 + (loop_index * 2 + 1) * 4),\n                              *(undefined4 *)pointer16);\n            do {\n              temp_value = (undefined4)((ulonglong)final_result_3 >> 0x20);\n              temp_value_2 = (undefined4)final_result_3;\n              temp_value_3 = *(undefined4 *)(pointer16 + -1);\n              temp_value_8 = *(undefined4 *)((int)pointer16 + -4);\n              final_result_3 = calculate_double_precision_080082d4(temp_value_2,temp_value,temp_value_3,temp_value_8);\n              temp_value_14 = reverse_and_improve_0800a5a0_080082d0(temp_value_3,temp_value_8,(int)final_result_3,(int)((ulonglong)final_result_3 >> 0x20));\n              temp_value_14 = calculate_double_precision_080082d4((int)temp_value_14,(int)((ulonglong)temp_value_14 >> 0x20),temp_value_2,temp_value);\n              *pointer16 = temp_value_14;\n              pointer16 = pointer16 + -1;\n              *pointer16 = final_result_3;\n            } while (&temp_value_7 + 1 != pointer16);\n            final_result_3 = 0;\n            pointer16 = &temp_value_7 + loop_index + 1;\n            do {\n              pointer5 = pointer16 + -1;\n              final_result_3 = calculate_double_precision_080082d4((int)final_result_3,(int)((ulonglong)final_result_3 >> 0x20),\n                                    *(undefined4 *)pointer5,*(undefined4 *)((int)pointer16 + -4));\n              pointer16 = pointer5;\n            } while (&temp_value_7 + 2 != pointer5);\n            goto LAB_0800abe4;\n          }\n        }\n        final_result_3 = 0;\n        goto LAB_0800abe4;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (loop_count < 1) {\n      if (loop_count != 0) goto LAB_0800ab0e;\n      pointer16 = &temp_value_7 + loop_index + 1;\n      do {\n        pointer5 = pointer16 + -1;\n        final_result_3 = calculate_double_precision_080082d4((int)final_result_3,(int)((ulonglong)final_result_3 >> 0x20),*(undefined4 *)pointer5,\n                              *(undefined4 *)((int)pointer16 + -4));\n        pointer16 = pointer5;\n      } while (&temp_value_7 != pointer5);\n      goto LAB_0800aafc;\n    }\n    final_result_3 = 0;\n    pointer16 = &temp_value_7 + loop_index + 1;\n    do {\n      pointer5 = pointer16 + -1;\n      final_result_3 = calculate_double_precision_080082d4((int)final_result_3,(int)((ulonglong)final_result_3 >> 0x20),*(undefined4 *)pointer5,\n                            *(undefined4 *)((int)pointer16 + -4));\n      pointer16 = pointer5;\n    } while (&temp_value_7 != pointer5);\n  }\n  temp_index = (int)((ulonglong)final_result_3 >> 0x20);\n  temp_value_2 = (undefined4)final_result_3;\n  if (temp_value_9 == 0) {\n    *(undefined8 *)temp_array_2[1] = final_result_3;\n    final_result_4 = reverse_and_improve_0800a5a0_080082d0((undefined4)temp_value_7,temp_value_7._4_4_,temp_value_2,temp_index);\n    if (loop_index < 1) goto LAB_0800ad26;\nLAB_0800ad04:\n    temp_index = 1;\n    pointer16 = &temp_value_7;\n    do {\n      final_result_4 = calculate_double_precision_080082d4((int)final_result_4,(int)(final_result_4 >> 0x20),*(undefined4 *)(pointer16 + 1),\n                            *(undefined4 *)((int)pointer16 + 0xc));\n      temp_index = temp_index + 1;\n      pointer16 = pointer16 + 1;\n    } while (temp_index <= loop_index);\n    if (temp_value_9 == 0) goto LAB_0800ad26;\n  }\n  else {\n    *temp_array_2[1] = temp_value_2;\n    *(int *)((int)temp_array_2[1] + 4) = temp_index + -0x80000000;\n    final_result_4 = reverse_and_improve_0800a5a0_080082d0((undefined4)temp_value_7,temp_value_7._4_4_,temp_value_2,temp_index);\n    if (0 < loop_index) goto LAB_0800ad04;\n  }\n  final_result_4 = final_result_4 & 0xffffffff | (ulonglong)((int)(final_result_4 >> 0x20) + 0x80000000) << 0x20;\nLAB_0800ad26:\n  *(ulonglong *)((int)temp_array_2[1] + 8) = final_result_4;\n  return result & 7;\n}\n\n",
            "called": [
                "FUN_080082d0",
                "FUN_080082d4",
                "FUN_080094c0",
                "FUN_0800856c",
                "FUN_08008b4c",
                "FUN_08008ba0",
                "FUN_08008640",
                "FUN_0800b2e8",
                "FUN_08008b10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a5a0",
            "calling": [
                "FUN_08009d78"
            ],
            "imported": false,
            "current_name": "reverse_and_improve_0800a5a0"
        },
        "FUN_0800195c": {
            "renaming": {
                "FUN_0800195c": "check_and_enable_flag_if_not_set_0800195c",
                "PTR_DAT_08001990": "data",
                "enable_flag_if_not_set_and_check_080025e8": "enable_flag_if_not_set_and_check"
            },
            "code": "void check_and_enable_flag_if_not_set_0800195c(void)\n{\n  if ((PTR_DAT_08001990[1] != '\\x06') && ((PTR_DAT_08001990[2] & 0x20) == 0)) {\n    enable_flag_if_not_set_and_check();\n    PTR_DAT_08001990[2] |= 0x40;\n  }\n  return;\n}",
            "called": [
                "FUN_080025e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800195c",
            "calling": [
                "FUN_080074c8"
            ],
            "imported": false,
            "current_name": "check_and_enable_flag_if_not_set_0800195c"
        },
        "FUN_08009214": {
            "renaming": {
                "FUN_08009214": "is_string_concatenated_08009214",
                "in_ZR": "input_char",
                "concatenate_08009204": "concatenate_strings"
            },
            "code": "bool is_string_concatenated_08009214() {\\n  char input_char;\\n  concatenate_strings();\\n  return input_char != \"\\0\";\\n}",
            "called": [
                "FUN_08009204"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009214",
            "calling": [
                "FUN_08002afc",
                "FUN_080029d8",
                "FUN_080005b4",
                "FUN_08002638",
                "FUN_08004e30",
                "FUN_08001f00"
            ],
            "imported": false,
            "current_name": "is_string_concatenated_08009214"
        },
        "FUN_08004dd2": {
            "renaming": {
                "FUN_08004dd2": "validate_data_08004dd2",
                "bVar1": "data_value",
                "iVar2": "is_sum_equal",
                "PTR_DAT_08004e2c": "PTR_DAT",
                "initialize_data_08004c48": "initialize_data"
            },
            "code": "int validate_data_08004dd2() {\n  byte data_value = get_data_value(0);\n  if (data_value == 5) {\n    int is_sum_equal = is_sum_equal_to_last_value(PTR_DAT_08004e2c_08004e2c, 1, 0x40);\n    if (is_sum_equal == 0) {\n      return 0;\n    }\n  }\n  else {\n    if (data_value > 4) {\n      return 0;\n    }\n    int is_sum_equal = is_sum_equal_to_last_value(PTR_DAT_08004e2c_08004e2c, 1, 0x28);\n    if (is_sum_equal == 0) {\n      return 0;\n    }\n    initialize_data(0);\n  }\n  return 1;\n}\n",
            "called": [
                "FUN_08000310",
                "FUN_08004c48",
                "FUN_080003ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004dd2",
            "calling": [
                "FUN_080051b4"
            ],
            "imported": false,
            "current_name": "validate_data_08004dd2"
        },
        "FUN_08008244": {
            "renaming": {
                "FUN_08008244": "do_nothing_08008244"
            },
            "code": "\nvoid do_nothing_08008244(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008244",
            "calling": [
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "do_nothing_08008244"
        },
        "FUN_08005778": {
            "renaming": {
                "FUN_08005778": "set_param_using_first_ushort_08005778",
                "PTR_DAT_0800578c": "first_ushort_ptr",
                "set_param_with_mask_080052ac": "set_param_with_mask",
                "*(undefined2 *)PTR_DAT_0800578c": "*first_ushort_ptr"
            },
            "code": "void set_param_using_first_ushort_08005778(void)\n{\n  ushort *(undefined2 *)PTR_DAT_0800578c = *(ushort **)PTR_DAT_0800578c;\n  set_param_with_mask_080052ac(*(undefined2 *)PTR_DAT_0800578c);\n  return;\n}",
            "called": [
                "FUN_080052ac"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005778",
            "calling": [
                "FUN_08007c7c"
            ],
            "imported": false,
            "current_name": "set_param_using_first_ushort_08005778"
        },
        "FUN_080028bc": {
            "renaming": {
                "FUN_080028bc": "calculate_result_080028bc",
                "param_1": "operand1",
                "param_2": "operand2",
                "param_3": "operand3",
                "uVar1": "result1",
                "uVar2": "result2",
                "FUN_08008eec": "square",
                "FUN_08008cd8": "add",
                "FUN_08008cdc": "square",
                "FUN_08009054": "subtract"
            },
            "code": "int calculate_result_080028bc(int operand1, int operand2, int operand3) {\n    int result1 = square(operand2);\n    int result2 = square(operand1);\n    int result3 = add(result1, result2);\n    int result4 = square(operand3);\n    int final_result = subtract(result3, result4);\n    return final_result;\n}",
            "called": [
                "FUN_08008cd8",
                "FUN_08009054",
                "FUN_08008cdc",
                "FUN_08008eec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080028bc",
            "calling": [
                "FUN_08002c18"
            ],
            "imported": false,
            "current_name": "calculate_result_080028bc"
        },
        "FUN_08006628": {
            "renaming": {
                "FUN_08006628": "calculate_and_store_divisor_08006628",
                "uVar1": "divisor",
                "uVar2": "leading_zeroes_count"
            },
            "code": "\nundefined4 calculate_and_store_divisor_08006628(void)\n\n{\n  uint divisor;\n  uint leading_zeroes_count;\n  \n  divisor = calculate_divisor_080064ec();\n  leading_zeroes_count = count_leading_zeroes(0xf000000);\n  *(uint *)PTR_DAT_0800667c =\n       divisor >> PTR_DAT_08006678[(*(uint *)(DAT_08006674 + 8) & 0xf0) >> (leading_zeroes_count & 0xff)];\n  return *(undefined4 *)PTR_DAT_0800667c;\n}\n\n",
            "called": [
                "FUN_080064ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006628",
            "calling": [
                "FUN_0800618c",
                "FUN_08006680",
                "FUN_080066cc"
            ],
            "imported": false,
            "current_name": "calculate_and_store_divisor_08006628"
        },
        "FUN_0800738e": {
            "renaming": {
                "FUN_0800738e": "check_and_update_value_0800738e",
                "param_1": "input_value",
                "DAT_080073bc": "data_ptr",
                "PTR_DAT_080073bc_0014": "mask"
            },
            "code": "void check_and_update_value_0800738e(ushort input_value)\n{\n  uint* DAT_080073bc = (uint*)(DAT_080073bc + 0x14);\n  uint PTR_DAT_080073bc_0014 = *DAT_080073bc;\n  if (((uint)input_value & PTR_DAT_080073bc_0014) != 0) {\n    *DAT_080073bc = (uint)input_value;\n    do_nothing_080073c0(input_value);\n  }\n  return;\n}",
            "called": [
                "FUN_080073c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800738e",
            "calling": [],
            "imported": false,
            "current_name": "check_and_update_value_0800738e"
        },
        "FUN_08002828": {
            "renaming": {
                "FUN_08002828": "do_nothing_08002828"
            },
            "code": "\nvoid do_nothing_08002828(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002828",
            "calling": [
                "FUN_08001994"
            ],
            "imported": false,
            "current_name": "do_nothing_08002828"
        },
        "FUN_080053a0": {
            "renaming": {
                "FUN_080053a0": "calculate_data_080053a0",
                "uVar1": "value",
                "iVar2": "result",
                "set_param_080052dc": "set_param",
                "get_value_if_not_equal_08002f74": "get_value_if_not_equal",
                "check_flags_080057e4": "check_flags",
                "calculate_data_08005324": "calculate_data",
                "check_value_within_range_08005360": "check_value_within_range"
            },
            "code": "\nvoid calculate_data_080053a0(void)\n\n{\n  undefined4 value;\n  int result;\n  \n  set_param_080052dc(*(undefined2 *)PTR_DAT_080055f0);\n  *(undefined2 *)PTR_DAT_080055f8 = *(undefined2 *)PTR_DAT_080055f4;\n  if (*(int *)PTR_DAT_080055fc == 0) {\n    value = get_value_if_not_equal_08002f74();\n    *(undefined4 *)PTR_DAT_080055fc = value;\n    if (*(int *)PTR_DAT_080055fc == 0) {\n      check_flags_080057e4();\n      PTR_DAT_08005600[2] = PTR_DAT_08005600[2] | 4;\n    }\n    else {\n      if (PTR_DAT_08005600[1] == '\\x03') {\n        *(undefined4 *)(PTR_DAT_08005604 + 0x1c) = *(undefined4 *)(*(int *)PTR_DAT_080055fc + 0x28);\n        calculate_data_080053a0(*(undefined4 *)(PTR_DAT_08005604 + 0x1c));\n        *(undefined4 *)(PTR_DAT_08005604 + 0x18) = DAT_08005608;\n      }\n      *(int *)(PTR_DAT_08005604 + 0x20) =\n           (*(int *)(*(int *)PTR_DAT_080055fc + 0x30) >> 1) +\n           *(int *)(*(int *)PTR_DAT_080055fc + 0x30);\n      *(int *)PTR_DAT_08005604 = -(*(int *)(*(int *)PTR_DAT_080055fc + 0x10) >> 1);\n      *(undefined4 *)(PTR_DAT_08005604 + 4) = *(undefined4 *)PTR_DAT_08005604;\n      *(undefined4 *)(PTR_DAT_08005604 + 8) = *(undefined4 *)PTR_DAT_08005604;\n      *(undefined4 *)(PTR_DAT_08005604 + 0xc) = *(undefined4 *)(*(int *)PTR_DAT_080055fc + 0x10);\n      *(undefined4 *)(PTR_DAT_08005604 + 0x10) = 0;\n    }\n  }\n  if (*(int *)PTR_DAT_080055fc != 0) {\n    *(undefined2 *)PTR_DAT_080055f0 = **(undefined2 **)PTR_DAT_080055fc;\n    *(undefined2 *)PTR_DAT_080055f4 = 0;\n    *(int *)PTR_DAT_08005604 = *(int *)(*(int *)PTR_DAT_080055fc + 4) + *(int *)PTR_DAT_08005604;\n    if (0 < *(int *)PTR_DAT_08005604) {\n      *(ushort *)PTR_DAT_080055f4 = *(ushort *)PTR_DAT_080055f4 | 0x10;\n      *(int *)PTR_DAT_08005604 = *(int *)PTR_DAT_08005604 - *(int *)(PTR_DAT_08005604 + 0xc);\n      if ((*(ushort *)PTR_DAT_080055f0 & 0x20) == 0) {\n        *(int *)(PTR_DAT_08005600 + 4) = *(int *)(PTR_DAT_08005600 + 4) + 1;\n      }\n      else {\n        *(int *)(PTR_DAT_08005600 + 4) = *(int *)(PTR_DAT_08005600 + 4) + -1;\n      }\n    }\n    *(int *)(PTR_DAT_08005604 + 4) =\n         *(int *)(*(int *)PTR_DAT_080055fc + 8) + *(int *)(PTR_DAT_08005604 + 4);\n    if (0 < *(int *)(PTR_DAT_08005604 + 4)) {\n      *(ushort *)PTR_DAT_080055f4 = *(ushort *)PTR_DAT_080055f4 | 0x440;\n      *(int *)(PTR_DAT_08005604 + 4) =\n           *(int *)(PTR_DAT_08005604 + 4) - *(int *)(PTR_DAT_08005604 + 0xc);\n      if ((*(ushort *)PTR_DAT_080055f0 & 0x80) == 0) {\n        *(int *)(PTR_DAT_08005600 + 8) = *(int *)(PTR_DAT_08005600 + 8) + 1;\n      }\n      else {\n        *(int *)(PTR_DAT_08005600 + 8) = *(int *)(PTR_DAT_08005600 + 8) + -1;\n      }\n    }\n    *(int *)(PTR_DAT_08005604 + 8) =\n         *(int *)(*(int *)PTR_DAT_080055fc + 0xc) + *(int *)(PTR_DAT_08005604 + 8);\n    if (0 < *(int *)(PTR_DAT_08005604 + 8)) {\n      *(ushort *)PTR_DAT_080055f4 = *(ushort *)PTR_DAT_080055f4 | 0x100;\n      *(int *)(PTR_DAT_08005604 + 8) =\n           *(int *)(PTR_DAT_08005604 + 8) - *(int *)(PTR_DAT_08005604 + 0xc);\n      if ((*(ushort *)PTR_DAT_080055f0 & 0x200) == 0) {\n        *(int *)(PTR_DAT_08005600 + 0xc) = *(int *)(PTR_DAT_08005600 + 0xc) + 1;\n      }\n      else {\n        *(int *)(PTR_DAT_08005600 + 0xc) = *(int *)(PTR_DAT_08005600 + 0xc) + -1;\n      }\n    }\n    *(int *)(PTR_DAT_08005604 + 0x10) = *(int *)(PTR_DAT_08005604 + 0x10) + 1;\n    if (*(uint *)(PTR_DAT_08005604 + 0x10) < *(uint *)(*(int *)PTR_DAT_080055fc + 0x10)) {\n      if (PTR_DAT_08005600[1] == '\\x04') {\n        result = check_value_within_range_08005360();\n        if (result != 0) {\n          if (*(uint *)(*(int *)PTR_DAT_080055fc + 0x30) < *(uint *)(PTR_DAT_08005604 + 0x1c)) {\n            *(int *)(PTR_DAT_08005604 + 0x1c) =\n                 *(int *)(PTR_DAT_08005604 + 0x1c) - *(int *)(*(int *)PTR_DAT_080055fc + 0x30);\n            calculate_data_080053a0(*(undefined4 *)(PTR_DAT_08005604 + 0x1c));\n          }\n          else {\n            check_flags_080057e4();\n            PTR_DAT_08005600[2] = PTR_DAT_08005600[2] | 4;\n          }\n        }\n      }\n      else if (*(uint *)(PTR_DAT_08005748 + 0x10) < *(uint *)(*(int *)PTR_DAT_0800574c + 0x34)) {\n        result = check_value_within_range_08005360();\n        if (result != 0) {\n          *(int *)(PTR_DAT_08005748 + 0x1c) =\n               *(int *)(PTR_DAT_08005748 + 0x1c) + *(int *)(*(int *)PTR_DAT_0800574c + 0x30);\n          if (*(uint *)(*(int *)PTR_DAT_0800574c + 0x3c) <= *(uint *)(PTR_DAT_08005748 + 0x1c)) {\n            *(undefined4 *)(PTR_DAT_08005748 + 0x1c) =\n                 *(undefined4 *)(*(int *)PTR_DAT_0800574c + 0x3c);\n          }\n          calculate_data_080053a0(*(undefined4 *)(PTR_DAT_08005748 + 0x1c));\n        }\n      }\n      else if (*(uint *)(PTR_DAT_08005748 + 0x10) < *(uint *)(*(int *)PTR_DAT_0800574c + 0x38)) {\n        if (*(int *)(PTR_DAT_08005748 + 0x1c) != *(int *)(*(int *)PTR_DAT_0800574c + 0x3c)) {\n          *(undefined4 *)(PTR_DAT_08005748 + 0x1c) =\n               *(undefined4 *)(*(int *)PTR_DAT_0800574c + 0x3c);\n          calculate_data_080053a0(*(undefined4 *)(PTR_DAT_08005748 + 0x1c));\n        }\n      }\n      else if (*(int *)(PTR_DAT_08005748 + 0x10) == *(int *)(*(int *)PTR_DAT_0800574c + 0x38)) {\n        if (*(int *)(PTR_DAT_08005748 + 0x1c) == *(int *)(*(int *)PTR_DAT_0800574c + 0x3c)) {\n          *(undefined4 *)(PTR_DAT_08005748 + 0x18) = DAT_08005750;\n        }\n        else {\n          *(int *)(PTR_DAT_08005748 + 0x18) = 420000 - *(int *)(PTR_DAT_08005748 + 0x18);\n        }\n      }\n      else {\n        result = check_value_within_range_08005360();\n        if (result != 0) {\n          if (*(uint *)(PTR_DAT_08005748 + 0x20) < *(uint *)(PTR_DAT_08005748 + 0x1c)) {\n            *(int *)(PTR_DAT_08005748 + 0x1c) =\n                 *(int *)(PTR_DAT_08005748 + 0x1c) - *(int *)(*(int *)PTR_DAT_0800574c + 0x30);\n          }\n          else {\n            *(uint *)(PTR_DAT_08005748 + 0x1c) = *(uint *)(PTR_DAT_08005748 + 0x1c) >> 1;\n          }\n          if (*(uint *)(PTR_DAT_08005748 + 0x1c) < *(uint *)(*(int *)PTR_DAT_0800574c + 0x2c)) {\n            *(undefined4 *)(PTR_DAT_08005748 + 0x1c) =\n                 *(undefined4 *)(*(int *)PTR_DAT_0800574c + 0x2c);\n          }\n          calculate_data_080053a0(*(undefined4 *)(PTR_DAT_08005748 + 0x1c));\n        }\n      }\n    }\n    else {\n      *(undefined2 *)PTR_DAT_08005754 = 0;\n      *(undefined4 *)PTR_DAT_0800574c = 0;\n      check_and_reset_counter_08002f40();\n    }\n  }\n  *(ushort *)PTR_DAT_08005754 = *(ushort *)PTR_DAT_08005754 ^ *(ushort *)(PTR_DAT_08005758 + 0x18);\n  *(ushort *)PTR_DAT_0800575c = *(ushort *)PTR_DAT_0800575c ^ *(ushort *)(PTR_DAT_08005758 + 0x1a);\n  return;\n}\n\n",
            "called": [
                "FUN_080052dc",
                "FUN_08005324",
                "FUN_08002f40",
                "FUN_080057e4",
                "FUN_08005360",
                "FUN_08002f74"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053a0",
            "calling": [
                "FUN_08007c7c"
            ],
            "imported": false,
            "current_name": "calculate_data_080053a0"
        },
        "FUN_080092c4": {
            "renaming": {
                "FUN_080092c4": "copy_data_and_clear_memory_080092c4",
                "iVar1": "counter",
                "puVar2": "ptr_data_start",
                "UNRECOVERED_JUMPTABLE": "jump_table"
            },
            "code": "void copy_data_and_clear_memory_080092c4(void)\n{\n  int counter;\n  undefined4 *ptr_data_start = (undefined4 *)PTR_DAT_0800930c;\n  undefined4 *ptr_data_end = PTR_DAT_08009308;\n  undefined4 *ptr_data_clear = PTR_DAT_08009310;\n  \n  for (counter = 0; ptr_data_start + counter < ptr_data_end; counter += 4) {\n    *(undefined4 *)(PTR_DAT_08009304 + counter) = *(undefined4 *)(DAT_08009300 + counter);\n  }\n  \n  for (; ptr_data_start < ptr_data_clear; ptr_data_start++) {\n    *ptr_data_start = 0;\n  }\n  \n  set_bit_and_clear_other_bits();\n  execute_functions();\n  \n  code *jump_table = (code *)0x80092fa;\n  run_system();\n  (*jump_table)();\n  return;\n}",
            "called": [
                "FUN_08007540",
                "FUN_0800756c",
                "FUN_0800b3e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080092c4",
            "calling": [],
            "imported": false,
            "current_name": "copy_data_and_clear_memory_080092c4"
        },
        "FUN_08008250": {
            "renaming": {
                "FUN_08008250": "waitForFlagAndReturn_08008250",
                "param_1": "flagPtr",
                "waitForFlagToSet_08007e1c": "waitForFlagToSet"
            },
            "code": "void waitForFlagAndReturn_08008250(void* flagPtr)\n{\n  waitForFlagToSet(flagPtr);\n  return;\n}",
            "called": [
                "FUN_08007e1c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008250",
            "calling": [
                "FUN_0800369c",
                "FUN_08003826",
                "FUN_080036f0",
                "FUN_080037fc",
                "FUN_08003778",
                "FUN_080036c6"
            ],
            "imported": false,
            "current_name": "waitForFlagAndReturn_08008250"
        },
        "FUN_0800184c": {
            "renaming": {
                "FUN_0800184c": "check_and_extract_byte_0800184c",
                "param_1": "output",
                "param_2": "output_size",
                "param_3": "string_start",
                "param_4": "input_string",
                "uVar2": "return_value",
                "iVar1": "extracted_integer",
                "*PTR_DAT_080018c8": "error_code"
            },
            "code": "int check_and_extract_byte_0800184c(char *output, int output_size, int string_start, char *input_string) {\n  int string_index = (int)*input_string;\n  if (*(char *)(string_start + string_index) == '\\0') {\n    return 0;\n  }\n  else {\n    *output = *(char *)(string_start + string_index);\n    if ((*output < 'A') || ('Z' < *output)) {\n      *PTR_DAT_080018c8 = 2;\n      return 0;\n    }\n    else {\n      *input_string = *input_string + 1;\n      int extracted_integer = extract_integer_from_string_08002638(string_start, input_string, output_size);\n      if (extracted_integer == 0) {\n        *PTR_DAT_080018c8 = 1;\n        return 0;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n}",
            "called": [
                "FUN_08002638"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800184c",
            "calling": [
                "FUN_080005b4"
            ],
            "imported": false,
            "current_name": "check_and_extract_byte_0800184c"
        },
        "FUN_08001f00": {
            "renaming": {
                "FUN_08001f00": "process_data_08001f00",
                "param_1": "data_pointer_1",
                "param_2": "data_pointer_2",
                "param_3": "data_pointer_3",
                "param_4": "byte_array_index_1",
                "param_5": "byte_array_index_2",
                "param_6": "byte_array_index_3",
                "param_7": "float_value_1",
                "param_8": "flag_1",
                "param_9": "float_value_2",
                "param_10": "flag_2",
                "uVar1": "float_value_3",
                "uVar2": "float_value_4",
                "iVar3": "integer_value_1",
                "uVar4": "float_value_5",
                "uVar5": "float_value_6",
                "uVar6": "float_value_7",
                "local_6c": "float_array",
                "local_5c": "float_value_8",
                "local_58": "float_value_9",
                "local_54": "float_value_10",
                "local_50": "float_value_11",
                "local_4c": "float_value_12",
                "local_48": "float_value_13",
                "local_42": "ushort_value_1",
                "local_40": "float_value_14",
                "local_3c": "float_value_15",
                "local_38": "float_value_16",
                "local_34": "uint_value_1",
                "local_30": "float_value_17",
                "local_2c": "float_value_18",
                "local_27": "char_value_1",
                "local_26": "ushort_value_2",
                "local_24": "float_value_19",
                "local_20": "uint_value_2",
                "local_1c": "uint_value_3"
            },
            "code": "\nvoid process_data_08001f00(int data_pointer_1,undefined4 *data_pointer_2,int data_pointer_3,byte byte_array_index_1,byte byte_array_index_2,byte byte_array_index_3\n                 ,undefined4 float_value_1,char flag_1,undefined4 float_value_2,char flag_2)\n\n{\n  undefined4 float_value_3;\n  undefined4 float_value_4;\n  int integer_value_1;\n  uint float_value_5;\n  undefined8 float_value_6;\n  undefined8 float_value_7;\n  uint float_array [4];\n  undefined4 float_value_8;\n  undefined4 float_value_9;\n  undefined4 float_value_10;\n  undefined4 float_value_11;\n  undefined4 float_value_12;\n  undefined4 float_value_13;\n  ushort ushort_value_1;\n  undefined4 float_value_14;\n  undefined4 float_value_15;\n  undefined4 float_value_16;\n  uint uint_value_1;\n  undefined4 float_value_17;\n  undefined4 float_value_18;\n  char char_value_1;\n  ushort ushort_value_2;\n  undefined4 float_value_19;\n  uint uint_value_2;\n  uint uint_value_3;\n  \n  float_value_18 = calculate_float_08008cdc(*(undefined4 *)((uint)byte_array_index_1 * 4 + data_pointer_1),\n                          *(undefined4 *)((uint)byte_array_index_1 * 4 + data_pointer_3));\n  float_value_17 = calculate_float_08008cdc(*(undefined4 *)((uint)byte_array_index_2 * 4 + data_pointer_1),\n                          *(undefined4 *)((uint)byte_array_index_2 * 4 + data_pointer_3));\n  uint_value_1 = calculate_float_08008cd8(data_pointer_2[byte_array_index_3],*(undefined4 *)((uint)byte_array_index_3 * 4 + data_pointer_1));\n  uint_value_3 = *(uint *)((uint)byte_array_index_1 * 4 + data_pointer_3) ^ 0x80000000;\n  uint_value_2 = *(uint *)((uint)byte_array_index_2 * 4 + data_pointer_3) ^ 0x80000000;\n  float_value_16 = calculate_float_08008cd8(data_pointer_2[byte_array_index_1],float_value_18);\n  float_value_15 = calculate_float_08008cd8(data_pointer_2[byte_array_index_2],float_value_17);\n  float_value_3 = calculate_float_08008eec(uint_value_3,float_value_15);\n  float_value_4 = calculate_float_08008eec(uint_value_2,float_value_16);\n  float_value_3 = calculate_float_08008cd8(float_value_3,float_value_4);\n  float_value_6 = reverse_bits_08008590(float_value_3);\n  float_value_3 = calculate_float_08008eec(uint_value_3,float_value_16);\n  float_value_4 = calculate_float_08008eec(uint_value_2,float_value_15);\n  float_value_3 = calculate_float_08008cdc(float_value_3,float_value_4);\n  float_value_7 = reverse_bits_08008590(float_value_3);\n  float_value_6 = thunk_calculate_result_08009990((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20),(int)float_value_7,\n                             (int)((ulonglong)float_value_7 >> 0x20));\n  float_value_19 = calculate_float_bits_08008c30((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20));\n  if (flag_2 == '\\0') {\n    integer_value_1 = check_concatenation_result_0800923c(float_value_19,0);\n    if (integer_value_1 != 0) {\n      float_value_6 = reverse_bits_08008590(float_value_19);\n      float_value_6 = calculate_double_precision_080082d4((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20),DAT_08002240,DAT_08002244);\n      float_value_19 = calculate_float_bits_08008c30((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20));\n    }\n  }\n  else {\n    integer_value_1 = check_strings_concatenated_08009250(float_value_19,0);\n    if (integer_value_1 != 0) {\n      float_value_6 = reverse_bits_08008590(float_value_19);\n      float_value_6 = reverse_and_improve_080082d0((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20),DAT_08002240,DAT_08002244);\n      float_value_19 = calculate_float_bits_08008c30((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20));\n    }\n  }\n  float_value_3 = calculate_float_08008eec(float_value_19,float_value_2);\n  float_value_6 = reverse_bits_08008590(float_value_3);\n  float_value_7 = reverse_bits_08008590(uint_value_1 & 0x7fffffff);\n  float_value_6 = calculate_hypotenuse_0800981c((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20),(int)float_value_7,\n                       (int)((ulonglong)float_value_7 >> 0x20));\n  float_value_14 = calculate_float_bits_08008c30((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20));\n  integer_value_1 = is_string_concatenated_08009214(float_value_14,0);\n  if (integer_value_1 == 0) {\n    float_value_3 = float_bits_to_float_08009054(float_value_14,*(undefined4 *)(PTR_DAT_08002248 + 0x1c));\n    float_value_6 = reverse_bits_08008590(float_value_3);\n    float_value_6 = calculate_collision_080094c0((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20));\n    ushort_value_1 = calculate_shift_amount_08008bf0((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20));\n    if (flag_1 != '\\0') {\n      float_value_3 = convert_to_fixed_point_08008e44(ushort_value_1);\n      float_value_1 = calculate_float_08008eec(float_value_1,float_value_3);\n    }\n    float_value_3 = convert_to_fixed_point_08008e44(ushort_value_1);\n    float_value_13 = float_bits_to_float_08009054(float_value_19,float_value_3);\n    float_value_3 = convert_to_fixed_point_08008e44(ushort_value_1);\n    float_value_12 = float_bits_to_float_08009054(uint_value_1,float_value_3);\n    float_value_6 = reverse_bits_08008590(float_value_13);\n    float_value_6 = calculate_product_08008640((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20),0,DAT_0800224c);\n    float_value_7 = reverse_bits_08008590(float_value_13);\n    float_value_6 = calculate_product_08008640((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20),(int)float_value_7,\n                         (int)((ulonglong)float_value_7 >> 0x20));\n    float_value_6 = reverse_and_improve_080082d0(0,DAT_08002250,(int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20));\n    float_value_11 = calculate_float_bits_08008c30((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20));\n    float_value_10 = float_value_13;\n    char_value_1 = '\\0';\n    float_array[byte_array_index_3] = *(uint *)(data_pointer_1 + (uint)byte_array_index_3 * 4);\n    for (ushort_value_2 = 1; ushort_value_2 < ushort_value_1; ushort_value_2 = ushort_value_2 + 1) {\n      if ((int)char_value_1 < (int)(uint)(byte)PTR_DAT_08002248[0x3e]) {\n        float_value_3 = calculate_float_08008eec(uint_value_3,float_value_10);\n        float_value_4 = calculate_float_08008eec(uint_value_2,float_value_11);\n        float_array[3] = calculate_float_08008cdc(float_value_3,float_value_4);\n        float_value_3 = calculate_float_08008eec(uint_value_3,float_value_11);\n        float_value_4 = calculate_float_08008eec(uint_value_2,float_value_10);\n        uint_value_3 = calculate_float_08008cd8(float_value_3,float_value_4);\n        uint_value_2 = float_array[3];\n        char_value_1 = char_value_1 + '\\x01';\n      }\n      else {\n        float_value_3 = convert_to_fixed_point_08008e44(ushort_value_2);\n        float_value_3 = calculate_float_08008eec(float_value_3,float_value_13);\n        float_value_6 = reverse_bits_08008590(float_value_3);\n        float_value_6 = calculate_new_value_08009410((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20));\n        float_value_9 = calculate_float_bits_08008c30((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20));\n        float_value_3 = convert_to_fixed_point_08008e44(ushort_value_2);\n        float_value_3 = calculate_float_08008eec(float_value_3,float_value_13);\n        float_value_6 = reverse_bits_08008590(float_value_3);\n        float_value_6 = calculate_new_value_080096e8((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20));\n        float_value_8 = calculate_float_bits_08008c30((int)float_value_6,(int)((ulonglong)float_value_6 >> 0x20));\n        float_value_3 = calculate_float_08008eec(*(uint *)((uint)byte_array_index_1 * 4 + data_pointer_3) ^ 0x80000000,float_value_9);\n        float_value_4 = calculate_float_08008eec(*(undefined4 *)((uint)byte_array_index_2 * 4 + data_pointer_3),float_value_8);\n        uint_value_3 = calculate_float_08008cdc(float_value_3,float_value_4);\n        float_value_3 = calculate_float_08008eec(*(uint *)((uint)byte_array_index_1 * 4 + data_pointer_3) ^ 0x80000000,float_value_8);\n        float_value_4 = calculate_float_08008eec(*(undefined4 *)((uint)byte_array_index_2 * 4 + data_pointer_3),float_value_9);\n        uint_value_2 = calculate_float_08008cd8(float_value_3,float_value_4);\n        char_value_1 = '\\0';\n      }\n      float_value_5 = calculate_float_08008cdc(float_value_18,uint_value_3);\n      float_array[byte_array_index_1] = float_value_5;\n      float_value_5 = calculate_float_08008cdc(float_value_17,uint_value_2);\n      float_array[byte_array_index_2] = float_value_5;\n      float_value_5 = calculate_float_08008cdc(float_array[byte_array_index_3],float_value_12);\n      float_array[byte_array_index_3] = float_value_5;\n      process_data_08001f00_and_set_flags_if_second_element_is_two_08001e98(float_array[0],float_array[1],float_array[2],float_value_1,flag_1);\n      if (*PTR_DAT_08002404 != '\\0') {\n        return;\n      }\n    }\n    process_data_08001f00_and_set_flags_if_second_element_is_two_08001e98(*data_pointer_2,data_pointer_2[1],data_pointer_2[2],float_value_1,flag_1);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08009250",
                "FUN_08009410",
                "FUN_080094c0",
                "FUN_08008590",
                "FUN_080096e8",
                "FUN_08008640",
                "FUN_08008bf0",
                "thunk_FUN_08009990",
                "FUN_08008cdc",
                "FUN_080082d0",
                "FUN_080082d4",
                "FUN_08008c30",
                "FUN_08008e44",
                "FUN_08001e98",
                "FUN_08009214",
                "FUN_08008cd8",
                "FUN_08009054",
                "FUN_0800923c",
                "FUN_0800981c",
                "FUN_08008eec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001f00",
            "calling": [
                "FUN_080005b4"
            ],
            "imported": false,
            "current_name": "process_data_08001f00"
        },
        "FUN_08006ce0": {
            "renaming": {
                "FUN_08006ce0": "update_register_value_08006ce0",
                "param_1": "value"
            },
            "code": "void update_register_value_08006ce0(undefined4 value)\n{\n  update_register_value_08006ce0_08006950(value);\n  return;\n}",
            "called": [
                "FUN_08006950"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ce0",
            "calling": [
                "FUN_080059b4"
            ],
            "imported": false,
            "current_name": "update_register_value_08006ce0"
        },
        "FUN_08006d4a": {
            "renaming": {
                "FUN_08006d4a": "set_bit_in_array_08006d4a",
                "param_1": "character",
                "set_bit_in_array_080069e4": "set_bit_in_array_helper"
            },
            "code": "void set_bit_in_array_08006d4a(char character) {\n  set_bit_in_array_08006d4a_helper((int)character);\n  return;\n}",
            "called": [
                "FUN_080069e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d4a",
            "calling": [],
            "imported": false,
            "current_name": "set_bit_in_array_08006d4a"
        },
        "FUN_08008894": {
            "renaming": {
                "FUN_08008894": "convert_float_to_uint_08008894",
                "param_1": "float_bits_1",
                "param_2": "float_bits_2",
                "param_3": "float_bits_3",
                "param_4": "float_bits_4",
                "uVar1": "temp_1",
                "uVar2": "temp_2",
                "uVar3": "temp_3",
                "uVar4": "temp_4",
                "uVar5": "temp_5",
                "uVar6": "temp_6",
                "uVar7": "result_bits",
                "iVar8": "exponent_diff",
                "uVar9": "adjusted_exponent",
                "uVar10": "adjusted_exponent_bits",
                "uVar11": "mantissa_bits",
                "uVar12": "temp_7",
                "uVar13": "temp_8",
                "bVar14": "bool_1",
                "bVar15": "bool_2",
                "bVar16": "bool_3"
            },
            "code": "\nulonglong convert_float_to_uint_08008894(undefined4 float_bits_1,uint float_bits_2,uint float_bits_3,uint float_bits_4)\n\n{\n  uint temp_1;\n  uint temp_2;\n  uint temp_3;\n  uint temp_4;\n  uint temp_5;\n  uint temp_6;\n  uint result_bits;\n  int exponent_diff;\n  uint adjusted_exponent;\n  uint unaff_r5;\n  uint adjusted_exponent_bits;\n  uint mantissa_bits;\n  uint temp_7;\n  uint temp_8;\n  bool bool_1;\n  bool bool_2;\n  bool bool_3;\n  ulonglong temp_17;\n  \n  temp_17 = CONCAT44(float_bits_2,float_bits_1);\n  temp_8 = 0x7ff;\n  result_bits = float_bits_2 >> 0x14 & 0x7ff;\n  bool_1 = result_bits == 0;\n  if (!bool_1) {\n    unaff_r5 = float_bits_4 >> 0x14 & 0x7ff;\n    bool_1 = unaff_r5 == 0;\n  }\n  if (!bool_1) {\n    bool_1 = result_bits == 0x7ff;\n  }\n  if (!bool_1) {\n    bool_1 = unaff_r5 == 0x7ff;\n  }\n  if (bool_1) {\n    temp_17 = convert_float_to_uint_08008894_08008a02();\n  }\n  adjusted_exponent = (uint)(temp_17 >> 0x20);\n  mantissa_bits = (uint)temp_17;\n  exponent_diff = result_bits - unaff_r5;\n  if ((float_bits_3 | float_bits_4 << 0xc) == 0) {\n    result_bits = (adjusted_exponent ^ float_bits_4) & 0x80000000 | adjusted_exponent & 0xfffff;\n    bool_3 = SCARRY4(exponent_diff,temp_8 >> 1);\n    adjusted_exponent = exponent_diff + (temp_8 >> 1);\n    bool_1 = (int)adjusted_exponent < 0;\n    bool_2 = adjusted_exponent == 0;\n    if (!bool_2 && bool_1 == bool_3) {\n      bool_3 = SBORROW4(temp_8,adjusted_exponent);\n      bool_1 = (int)(temp_8 - adjusted_exponent) < 0;\n      bool_2 = temp_8 == adjusted_exponent;\n    }\n    if (!bool_2 && bool_1 == bool_3) {\n      result_bits = result_bits | adjusted_exponent * 0x100000;\n    }\n    if (!bool_2 && bool_1 == bool_3) {\n      return temp_17 & 0xffffffff | (ulonglong)result_bits << 0x20;\n    }\n    result_bits = result_bits | 0x100000;\n    temp_8 = 0;\n    bool_2 = SBORROW4(adjusted_exponent,1);\n    adjusted_exponent = adjusted_exponent - 1;\n    bool_1 = adjusted_exponent == 0;\n    temp_3 = adjusted_exponent;\n  }\n  else {\n    temp_3 = (float_bits_4 << 0xc) >> 4 | 0x10000000 | float_bits_3 >> 0x18;\n    temp_8 = float_bits_3 << 8;\n    adjusted_exponent_bits = (adjusted_exponent << 0xc) >> 4 | 0x10000000 | mantissa_bits >> 0x18;\n    mantissa_bits = mantissa_bits * 0x100;\n    result_bits = (adjusted_exponent ^ float_bits_4) & 0x80000000;\n    bool_1 = temp_3 <= adjusted_exponent_bits;\n    if (adjusted_exponent_bits == temp_3) {\n      bool_1 = temp_8 <= mantissa_bits;\n    }\n    exponent_diff = exponent_diff + (uint)bool_1;\n    adjusted_exponent = exponent_diff + 0x3fd;\n    if (bool_1 == false) {\n      temp_3 = temp_3 >> 1;\n      temp_8 = (uint)((float_bits_3 >> 0x18 & 1) != 0) << 0x1f | temp_8 >> 1;\n    }\n    temp_7 = mantissa_bits - temp_8;\n    adjusted_exponent_bits = (adjusted_exponent_bits - temp_3) - (uint)(mantissa_bits < temp_8);\n    temp_4 = temp_3 >> 1;\n    temp_1 = (uint)((temp_3 & 1) != 0) << 0x1f | temp_8 >> 1;\n    mantissa_bits = 0x100000;\n    temp_3 = 0x80000;\n    while( true ) {\n      bool_1 = temp_1 <= temp_7;\n      if (temp_4 < adjusted_exponent_bits || adjusted_exponent_bits - temp_4 < (uint)bool_1) {\n        temp_7 = temp_7 - temp_1;\n        mantissa_bits = mantissa_bits | temp_3;\n        adjusted_exponent_bits = (adjusted_exponent_bits - temp_4) - (uint)!bool_1;\n      }\n      temp_5 = temp_4 >> 1;\n      temp_1 = (uint)((temp_4 & 1) != 0) << 0x1f | temp_1 >> 1;\n      bool_2 = temp_1 <= temp_7;\n      bool_1 = adjusted_exponent_bits - temp_5 < (uint)bool_2;\n      temp_8 = adjusted_exponent_bits;\n      if (temp_5 < adjusted_exponent_bits || bool_1) {\n        temp_7 = temp_7 - temp_1;\n        temp_8 = (adjusted_exponent_bits - temp_5) - (uint)!bool_2;\n      }\n      if (temp_5 < adjusted_exponent_bits || bool_1) {\n        mantissa_bits = mantissa_bits | temp_3 >> 1;\n      }\n      adjusted_exponent_bits = temp_4 >> 2;\n      temp_2 = (uint)((temp_5 & 1) != 0) << 0x1f | temp_1 >> 1;\n      bool_2 = temp_2 <= temp_7;\n      bool_1 = temp_8 - adjusted_exponent_bits < (uint)bool_2;\n      temp_5 = temp_8;\n      if (adjusted_exponent_bits < temp_8 || bool_1) {\n        temp_7 = temp_7 - temp_2;\n        temp_5 = (temp_8 - adjusted_exponent_bits) - (uint)!bool_2;\n      }\n      if (adjusted_exponent_bits < temp_8 || bool_1) {\n        mantissa_bits = mantissa_bits | temp_3 >> 2;\n      }\n      temp_6 = temp_4 >> 3;\n      temp_1 = (uint)((adjusted_exponent_bits & 1) != 0) << 0x1f | temp_2 >> 1;\n      bool_2 = temp_1 <= temp_7;\n      bool_1 = temp_5 - temp_6 < (uint)bool_2;\n      adjusted_exponent_bits = temp_5;\n      if (temp_6 < temp_5 || bool_1) {\n        temp_7 = temp_7 - temp_1;\n        adjusted_exponent_bits = (temp_5 - temp_6) - (uint)!bool_2;\n      }\n      if (temp_6 < temp_5 || bool_1) {\n        mantissa_bits = mantissa_bits | temp_3 >> 3;\n      }\n      temp_8 = adjusted_exponent_bits | temp_7;\n      if (temp_8 == 0) break;\n      adjusted_exponent_bits = adjusted_exponent_bits << 4 | temp_7 >> 0x1c;\n      temp_7 = temp_7 << 4;\n      temp_4 = temp_4 & 0xfffffff8 | temp_1 >> 0x1d;\n      temp_1 = (temp_2 >> 1) << 3;\n      temp_3 = temp_3 >> 4;\n      if (temp_3 == 0) {\n        temp_6 = temp_4;\n        if ((result_bits & 0x100000) != 0) goto LAB_080089b2;\n        result_bits = result_bits | mantissa_bits;\n        mantissa_bits = 0;\n        temp_3 = 0x80000000;\n      }\n    }\n    if ((result_bits & 0x100000) == 0) {\n      result_bits = result_bits | mantissa_bits;\n      mantissa_bits = 0;\n    }\nLAB_080089b2:\n    bool_3 = 0xfc < adjusted_exponent;\n    bool_2 = SBORROW4(adjusted_exponent,0xfd);\n    temp_4 = exponent_diff + 0x300;\n    bool_1 = temp_4 == 0;\n    temp_3 = temp_4;\n    if (bool_3 && !bool_1) {\n      bool_3 = 0x6ff < temp_4;\n      bool_2 = SBORROW4(temp_4,0x700);\n      temp_3 = exponent_diff - 0x400;\n      bool_1 = temp_4 == 0x700;\n    }\n    if (!bool_3 || bool_1) {\n      bool_1 = temp_6 <= adjusted_exponent_bits;\n      if (adjusted_exponent_bits == temp_6) {\n        bool_1 = temp_1 <= temp_7;\n      }\n      if (adjusted_exponent_bits == temp_6 && temp_7 == temp_1) {\n        bool_1 = (mantissa_bits & 1) != 0;\n      }\n      return CONCAT44(result_bits + adjusted_exponent * 0x100000 + (uint)CARRY4(mantissa_bits,(uint)bool_1),mantissa_bits + bool_1);\n    }\n  }\n  if (!bool_1 && (int)temp_3 < 0 == bool_2) {\n    return (ulonglong)(result_bits & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bool_3 = SCARRY4(adjusted_exponent,0x36);\n  bool_1 = (int)(adjusted_exponent + 0x36) < 0;\n  bool_2 = adjusted_exponent == 0xffffffca;\n  if (bool_2 || bool_1 != bool_3) {\n    mantissa_bits = 0;\n  }\n  if (bool_2 || bool_1 != bool_3) {\n    result_bits = result_bits & 0x80000000;\n  }\n  if (bool_2 || bool_1 != bool_3) {\n    return CONCAT44(result_bits,mantissa_bits);\n  }\n  temp_3 = -adjusted_exponent;\n  adjusted_exponent_bits = temp_3 - 0x20;\n  if (0x1f < (int)temp_3) {\n    temp_3 = mantissa_bits >> (adjusted_exponent_bits & 0xff) | result_bits << (0x20 - adjusted_exponent_bits & 0xff);\n    adjusted_exponent = (result_bits >> (adjusted_exponent_bits & 0xff) & ~((result_bits & 0x80000000) >> (adjusted_exponent_bits & 0xff))) -\n            ((int)temp_3 >> 0x1f);\n    if ((temp_8 | mantissa_bits << (0x20 - adjusted_exponent_bits & 0xff) | temp_3 << 1) == 0) {\n      adjusted_exponent = adjusted_exponent & ~(temp_3 >> 0x1f);\n    }\n    return CONCAT44(result_bits,adjusted_exponent) & 0x80000000ffffffff;\n  }\n  exponent_diff = temp_3 - 0x14;\n  if (exponent_diff != 0 && exponent_diff < 0 == SCARRY4(adjusted_exponent_bits,0xc)) {\n    adjusted_exponent = 0xc - exponent_diff;\n    temp_3 = mantissa_bits << (adjusted_exponent & 0xff);\n    mantissa_bits = mantissa_bits >> (0x20 - adjusted_exponent & 0xff) | result_bits << (adjusted_exponent & 0xff);\n    adjusted_exponent = mantissa_bits + -((int)temp_3 >> 0x1f);\n    if ((temp_8 | temp_3 << 1) == 0) {\n      adjusted_exponent = adjusted_exponent & ~(temp_3 >> 0x1f);\n    }\n    return CONCAT44((result_bits & 0x80000000) + (uint)CARRY4(mantissa_bits,-((int)temp_3 >> 0x1f)),adjusted_exponent);\n  }\n  adjusted_exponent_bits = mantissa_bits << (adjusted_exponent + 0x20 & 0xff);\n  mantissa_bits = mantissa_bits >> (temp_3 & 0xff) | result_bits << (adjusted_exponent + 0x20 & 0xff);\n  adjusted_exponent = mantissa_bits + -((int)adjusted_exponent_bits >> 0x1f);\n  if ((temp_8 | adjusted_exponent_bits << 1) == 0) {\n    adjusted_exponent = adjusted_exponent & ~(adjusted_exponent_bits >> 0x1f);\n  }\n  return CONCAT44((result_bits & 0x80000000) +\n                  ((result_bits & 0x7fffffff) >> (temp_3 & 0xff)) +\n                  (uint)CARRY4(mantissa_bits,-((int)adjusted_exponent_bits >> 0x1f)),adjusted_exponent);\n}\n\n",
            "called": [
                "FUN_08008a02"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008894",
            "calling": [
                "FUN_08001994",
                "FUN_0800a1bc",
                "FUN_080098d0",
                "FUN_08009990",
                "FUN_0800af78",
                "FUN_080005b4",
                "FUN_08003004"
            ],
            "imported": false,
            "current_name": "convert_float_to_uint_08008894"
        },
        "FUN_08000374": {
            "renaming": {
                "FUN_08000374": "storeChecksum_08000374",
                "param_1": "starting_address",
                "param_2": "data",
                "param_3": "length",
                "local_1c": "remaining_length",
                "local_18": "current_data",
                "local_14": "current_address",
                "local_9": "checksum"
            },
            "code": "void storeChecksum_08000374(int starting_address, char *data, int length) {\n  int current_address = starting_address;\n  char *current_data = data;\n  int remaining_length = length;\n  char checksum = '\\0';\n  if (*(int *)PTR_DAT_080003e8 == 0) {\n    initializeMemoryAndSetValueTo255_080002f0();\n    current_data = data;\n    current_address = starting_address;\n  }\n  while (remaining_length != 0) {\n    checksum = (checksum != '\\0') + *current_data;\n    initializeMemoryAndSetValueTo255_08000340(current_address,*current_data);\n    current_data++;\n    current_address++;\n    remaining_length--;\n  }\n  initializeMemoryAndSetValueTo255_08000340(current_address,checksum);\n  return;\n}",
            "called": [
                "FUN_080002f0",
                "FUN_08000340"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000374",
            "calling": [
                "FUN_08004bf4",
                "FUN_08004bc0",
                "FUN_08004c2a"
            ],
            "imported": false,
            "current_name": "storeChecksum_08000374"
        },
        "FUN_080037fc": {
            "renaming": {
                "FUN_080037fc": "printAbsoluteValue_080037fc",
                "param_1": "value",
                "local_c": "absoluteValue",
                "print_digits_of_number_08003778": "printDigitsOfNumber",
                "waitForFlagAndReturn_08008250": "waitForFlagAndReturn"
            },
            "code": "void printAbsoluteValue_080037fc(int value) {\n  int absoluteValue = value;\n  if (value < 0) {\n    waitForFlagAndReturn_08008250(0x2d);\n    absoluteValue = -value;\n  }\n  printDigitsOfNumber(absoluteValue);\n  return;\n}",
            "called": [
                "FUN_08008250",
                "FUN_08003778"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080037fc",
            "calling": [
                "FUN_08004250",
                "FUN_080046d0",
                "FUN_08004900"
            ],
            "imported": false,
            "current_name": "printAbsoluteValue_080037fc"
        },
        "FUN_0800a1bc": {
            "renaming": {
                "FUN_0800a1bc": "calculate_0800a1bc",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar1": "quotient",
                "uVar2": "bit",
                "iVar3": "bit_position",
                "uVar4": "temp",
                "uVar5": "temp_dividend",
                "uVar6": "remainder",
                "uVar7": "mask",
                "uVar8": "dividend_copy",
                "uVar9": "difference",
                "uVar10": "temp_bit",
                "uVar11": "i",
                "uVar12": "temp_remainder",
                "uVar13": "shift",
                "uVar14": "result"
            },
            "code": "uint calculate_0800a1bc(uint dividend, uint divisor)\n{\n  uint quotient = 0;\n  uint bit = 1 << 31;\n  uint remainder = dividend;\n  if ((0x0800a340 & ~divisor) == 0) {\n    uint64_t result = multiply(dividend, divisor);\n    quotient = divide(result, divisor);\n    return quotient;\n  }\n  if ((int)divisor < 1) {\n    if ((divisor & 0x7fffffff | dividend) == 0) {\n      return dividend;\n    }\n    if (divisor != 0) {\n      uint64_t result = divide(dividend, divisor);\n      quotient = add(result, result);\n      quotient = add(quotient, quotient);\n      quotient = add(quotient, result >> 63);\n      return quotient;\n    }\n    do {\n      uint temp_dividend = dividend;\n      quotient = quotient >> 1;\n      dividend = temp_dividend << 1;\n    } while (quotient == 0);\n  }\n  else {\n    uint bit_position = 0;\n    while ((divisor & 0x80000000) == 0) {\n      divisor = divisor << 1;\n      bit_position++;\n    }\n    remainder = dividend << bit_position;\n    bit = bit >> bit_position;\n    uint mask = 1 << bit_position;\n    for (int i = 0; i <= bit_position; i++) {\n      uint temp = remainder - divisor;\n      if ((temp & 0x80000000) == 0) {\n        remainder = temp;\n        quotient = quotient | mask;\n      }\n      mask = mask >> 1;\n      divisor = divisor >> 1;\n    }\n  }\n  return quotient;\n}\n\nuint64_t multiply(uint32_t a, uint32_t b) {\n  return (uint64_t)a * b;\n}\n\nuint divide(uint64_t dividend, uint32_t divisor) {\n  uint quotient = 0;\n  uint bit = 1 << 31;\n  uint remainder = dividend >> 32;\n  uint64_t temp_dividend = dividend;\n  for (int i = 0; i < 32; i++) {\n    if ((remainder & bit) != 0) {\n      quotient = quotient | bit;\n    }\n    bit = bit >> 1;\n    remainder = remainder << 1;\n    uint64_t temp = (temp_dividend >> (63 - i)) & 1;\n    remainder = remainder | temp;\n    if (divisor <= remainder) {\n      remainder = remainder - divisor;\n      quotient = quotient | bit;\n    }\n  }\n  return quotient;\n}\n\nuint add(uint64_t a, uint64_t b) {\n  uint64_t sum = a + b;\n  return (uint)(sum >> 32) + (uint)sum;\n}",
            "called": [
                "FUN_080082d0",
                "FUN_080082d4",
                "FUN_08008640",
                "FUN_08008894"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a1bc",
            "calling": [
                "FUN_080098d0",
                "FUN_08009b24"
            ],
            "imported": false,
            "current_name": "calculate_0800a1bc"
        },
        "FUN_0800525c": {
            "renaming": {
                "FUN_0800525c": "check_param_0800525c",
                "param_1": "param",
                "*PTR_DAT_080052a8": "current_ptr_val",
                "process_until_alarm_or_exit_08002fd4": "process_until_alarm_or_exit",
                "'\\0'": "'\\0'",
                "do_nothing_and_return_08005250": "do_nothing_and_return",
                "param_1 == '\\0'": "param == '\\0'",
                "param_1 < '\\x01'": "param < '\\x01'",
                "do_nothing_0800522c": "do_nothing_case_1",
                "do_nothing_08005220": "do_nothing_case_2",
                "do_nothing_08005208": "do_nothing_final"
            },
            "code": "void check_param_0800525c(char param) {\n  int *PTR_DAT_080052a8 = (int)*PTR_DAT_080052a8;\n  int param_val = (int)param;\n  if (*PTR_DAT_080052a8 != param_val) {\n    process_until_alarm_or_exit();\n    if (param == '\\0') {\n      do_nothing_and_return();\n    }\n    else {\n      if (param < '\\x01') {\n        do_nothing_case_1();\n      }\n      else {\n        do_nothing_case_2();\n      }\n      do_nothing_final();\n    }\n    *PTR_DAT_080052a8 = param;\n  }\n  return;\n}",
            "called": [
                "FUN_08005250",
                "FUN_08002fd4",
                "FUN_0800522c",
                "FUN_08005220",
                "FUN_08005208"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800525c",
            "calling": [
                "FUN_080005b4"
            ],
            "imported": false,
            "current_name": "check_param_0800525c"
        },
        "FUN_080073d4": {
            "renaming": {
                "FUN_080073d4": "set_bit_in_short_array_080073d4",
                "param_1": "bit_position",
                "PTR_": "array_ptr",
                "DAT_": "bit_mask, array_index, array_offset"
            },
            "code": "void set_bit_in_short_array_080073d4(uint bit_position)\n{\n    uint array_index = bit_position >> 4;\n    uint array_offset = (array_index * 0x400) + 0x4002001a;\n    short* PTR_ = (short*)array_offset;\n    uint bit_mask = 1 << (bit_position & 0xf);\n    *PTR_ = bit_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073d4",
            "calling": [
                "FUN_08007520"
            ],
            "imported": false,
            "current_name": "set_bit_in_short_array_080073d4"
        },
        "FUN_08006dfe": {
            "renaming": {
                "FUN_08006dfe": "set_bit_in_array_08006dfe",
                "param_1": "character",
                "set_bit_in_array_08006a8c": "set_bit_in_array_helper"
            },
            "code": "void set_bit_in_array_08006dfe(char character){\n\tset_bit_in_array_08006dfe_helper((int)character);\n}",
            "called": [
                "FUN_08006a8c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006dfe",
            "calling": [],
            "imported": false,
            "current_name": "set_bit_in_array_08006dfe"
        },
        "FUN_08006d66": {
            "renaming": {
                "FUN_08006d66": "synchronize_data_and_return_08006d66",
                "synchronize_data_08006c70": "synchronize_data_08006c70"
            },
            "code": "void synchronize_data_and_return_08006d66(void)\n{\n  synchronize_data_08006c70();\n  return;\n}",
            "called": [
                "FUN_08006c70"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d66",
            "calling": [],
            "imported": false,
            "current_name": "synchronize_data_and_return_08006d66"
        },
        "FUN_08006e88": {
            "renaming": {
                "FUN_08006e88": "update_registers_08006e88",
                "param_1": "register_values",
                "param_2": "update_values",
                "uVar1": "bit_mask",
                "uVar2": "bit_value",
                "iVar3": "index",
                "local_c": "mask",
                "value": "value",
                "DAT_0800719c": "PTR_DAT_0800719c",
                "DAT_080071a0": "PTR_DAT_080071a0",
                "DAT_080071a4": "PTR_DAT_080071a4",
                "DAT_080071a8": "PTR_DAT_080071a8",
                "DAT_080071ac": "PTR_DAT_080071ac",
                "DAT_080071b0": "PTR_DAT_080071b0",
                "DAT_080071b4": "PTR_DAT_080071b4",
                "DAT_080071b8": "PTR_DAT_080071b8",
                "DAT_080071bc": "PTR_DAT_080071bc",
                "DAT_080071c0": "PTR_DAT_080071c0",
                "DAT_080071c4": "PTR_DAT_080071c4",
                "DAT_080071cc": "PTR_DAT_080071cc"
            },
            "code": "void update_registers_08006e88(uint *register_values, uint *update_values)\n{\n  uint mask;\n  for (mask = 0; mask < 0x10; mask++) {\n    uint bit_mask = 1 << (mask & 0xff);\n    uint bit_value = *update_values & bit_mask;\n    if (bit_value == bit_mask) {\n      if ((update_values[1] == 2) || (update_values[1] == 0x12)) {\n        uint value = update_values[4];\n        register_values[(mask >> 3) + 8] &= ~(0xf << ((mask & 7) << 2));\n        register_values[(mask >> 3) + 8] |= value << ((mask & 7) << 2);\n      }\n      *register_values &= ~(3 << ((mask & 0x7f) << 1));\n      *register_values |= (update_values[1] & 3) << ((mask & 0x7f) << 1);\n      if ((((update_values[1] == 1) || (update_values[1] == 2)) || (update_values[1] == 0x11)) || (update_values[1] == 0x12)) {\n        register_values[2] &= ~(3 << ((mask & 0x7f) << 1));\n        register_values[2] |= update_values[3] << ((mask & 0x7f) << 1);\n        register_values[1] &= ~(1 << (mask & 0xff));\n        register_values[1] |= (update_values[1] >> 4 & 1) << (mask & 0xff);\n      }\n      register_values[3] &= ~(3 << ((mask & 0x7f) << 1));\n      register_values[3] |= update_values[2] << ((mask & 0x7f) << 1);\n      if ((update_values[1] & 0x10000000) != 0) {\n        *DAT_0800719c |= 0x4000;\n        *(uint *)(DAT_080071a0 + ((mask >> 2) + 2) * 4) = ~(0xf << ((mask & 3) << 2)) & *(uint *)(DAT_080071a0 + ((mask >> 2) + 2) * 4);\n        int index;\n        if (register_values == DAT_080071a4) index = 0;\n        else if (register_values == DAT_080071a8) index = 1;\n        else if (register_values == DAT_080071ac) index = 2;\n        else if (register_values == DAT_080071b0) index = 3;\n        else if (register_values == DAT_080071b4) index = 4;\n        else if (register_values == DAT_080071b8) index = 5;\n        else if (register_values == DAT_080071bc) index = 6;\n        else if (register_values == DAT_080071c0) index = 7;\n        else if (register_values == DAT_080071c4) index = 8;\n        else index = 10;\n        *(uint *)(DAT_080071a0 + ((mask >> 2) + 2) * 4) = index << ((mask & 3) << 2) | *(uint *)(DAT_080071a0 + ((mask >> 2) + 2) * 4);\n        *DAT_080071cc = ~bit_value & *DAT_080071cc;\n        DAT_080071cc[1] = ~bit_value & DAT_080071cc[1];\n        if ((update_values[1] & 0x10000) != 0) {\n          *DAT_080071cc = bit_value | *DAT_080071cc;\n        }\n        if ((update_values[1] & 0x20000) != 0) {\n          DAT_080071cc[1] = bit_value | DAT_080071cc[1];\n        }\n        DAT_080071cc[2] = ~bit_value & DAT_080071cc[2];\n        DAT_080071cc[3] = ~bit_value & DAT_080071cc[3];\n        if ((update_values[1] & 0x100000) != 0) {\n          DAT_080071cc[2] = bit_value | DAT_080071cc[2];\n        }\n        if ((update_values[1] & 0x200000) != 0) {\n          DAT_080071cc[3] = bit_value | DAT_080071cc[3];\n        }\n      }\n    }\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e88",
            "calling": [
                "FUN_0800640c",
                "FUN_0800778c"
            ],
            "imported": false,
            "current_name": "update_registers_08006e88"
        },
        "FUN_080001e0": {
            "renaming": {
                "FUN_080001e0": "do_nothing_080001e0"
            },
            "code": "\nvoid do_nothing_080001e0(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001e0",
            "calling": [
                "FUN_08000220"
            ],
            "imported": false,
            "current_name": "do_nothing_080001e0"
        },
        "FUN_080036f0": {
            "renaming": {
                "FUN_080036f0": "print_bits_of_uint_080036f0",
                "param_1": "num",
                "param_2": "num_bits",
                "uVar1": "bit_value",
                "local_10": "bit_index",
                "local_c": "mask"
            },
            "code": "void print_bits_of_uint_080036f0(uint num, int num_bits) {\n    undefined4 bit_value;\n    int bit_index;\n    uint mask = 1 << (num_bits - 1);\n    for (bit_index = 0; bit_index < num_bits; bit_index++) {\n        if ((mask & num) == 0) {\n            bit_value = 0x30; // ASCII for '0'\n        }\n        else {\n            bit_value = 0x31; // ASCII for '1'\n        }\n        waitForFlagAndReturn_08008250(bit_value);\n        mask = mask >> 1;\n    }\n}",
            "called": [
                "FUN_08008250"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036f0",
            "calling": [
                "FUN_0800375c",
                "FUN_08003740"
            ],
            "imported": false,
            "current_name": "print_bits_of_uint_080036f0"
        },
        "FUN_08002edc": {
            "renaming": {
                "FUN_08002edc": "concatenate_all_strings_and_calculate_collisions_08002edc",
                "concatenate_strings_from_array_08002a94": "concatenate_strings_from_array",
                "concatenate_strings_from_array_08002ba8": "concatenate_strings_from_array",
                "calculate_collision_for_all_objects_08002e08": "calculate_collision_for_all_objects"
            },
            "code": "void concatenate_all_strings_and_calculate_collisions_08002edc(void)\n{\n  concatenate_strings_from_array();\n  concatenate_strings_from_array();\n  calculate_collision_for_all_objects();\n  return;\n}",
            "called": [
                "FUN_08002e08",
                "FUN_08002ba8",
                "FUN_08002a94"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002edc",
            "calling": [
                "FUN_08003004",
                "FUN_08003618"
            ],
            "imported": false,
            "current_name": "concatenate_all_strings_and_calculate_collisions_08002edc"
        },
        "FUN_0800375c": {
            "renaming": {
                "FUN_0800375c": "print_bits_of_uint_0800375c",
                "param_1": "number",
                "print_bits_of_uint_080036f0": "print_bits_of_uint",
                "0x10": "num_bits"
            },
            "code": "void print_bits_of_uint_0800375c(uint16_t number, uint16_t num_bits)\n{\n  print_bits_of_uint_0800375c(number, num_bits);\n  return;\n}",
            "called": [
                "FUN_080036f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800375c",
            "calling": [
                "FUN_08004250"
            ],
            "imported": false,
            "current_name": "print_bits_of_uint_0800375c"
        },
        "FUN_08009990": {
            "renaming": {
                "FUN_08009990": "calculate_result_08009990",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "difference",
                "uVar2": "temp_var_1",
                "uVar3": "result",
                "uVar4": "temp_var_2",
                "uVar5": "temp_var_3",
                "uVar6": "combined_inputs"
            },
            "code": "uint calculate_result_08009990(uint input_1, uint input_2, uint input_3, uint input_4)\n{\n  int difference;\n  undefined4 temp_var_1;\n  uint result;\n  uint temp_var_2;\n  uint temp_var_3;\n  undefined8 combined_inputs;\n  \n  combined_inputs = CONCAT44(DAT_08009b04,DAT_08009b00);\n  input_4 = input_4 & 0x7fffffff;\n  if ((DAT_08009b18 < (input_4 | (-input_3 | input_3) >> 0x1f)) ||\n     (input_2 = input_2 & 0x7fffffff, DAT_08009b18 < (input_2 | (-input_1 | input_1) >> 0x1f))) {\n    result = calculate_double_precision_080082d4(input_3, input_4, input_1, input_2);\n  }\n  else {\n    if ((input_4 + 0xc0100000 | input_3) == 0) {\n      result = calculate_value_0800af78();\n      return result;\n    }\n    temp_var_2 = (int)input_4 >> 0x1e & 2U | input_2 >> 0x1f;\n    if ((input_1 | input_2) == 0) {\n      result = DAT_08009af0;\n      if ((temp_var_2 != 2) && (result = input_1, temp_var_2 == 3)) {\n        result = DAT_08009af8;\n      }\n    }\n    else {\n      if ((input_4 | input_3) != 0) {\n        if (input_4 == DAT_08009b18) {\n          temp_var_2 = temp_var_2 - 1;\n          if (input_2 == input_4) {\n            if (2 < temp_var_2) {\n              return DAT_08009b10;\n            }\n            return *(uint *)(PTR_DAT_08009b20 + temp_var_2 * 8);\n          }\n          if (temp_var_2 < 3) {\n            return *(uint *)(PTR_DAT_08009b1c + temp_var_2 * 8);\n          }\n          return 0;\n        }\n        if (input_2 != DAT_08009b18) {\n          difference = (int)(input_2 - input_4) >> 0x14;\n          if ((int)(input_2 - input_4) < 0x3d00000) {\n            if (((int)input_4 < 0) && (difference + 0x3c < 0 != SCARRY4(difference,0x3c))) {\n              combined_inputs = 0;\n            }\n            else {\n              convert_float_to_uint_08008894(input_1, input_2, input_3, input_4, input_4);\n              do_nothing_0800b2cc();\n              combined_inputs = calculate_value_0800af78();\n            }\n          }\n          temp_var_1 = (undefined4)((ulonglong)combined_inputs >> 0x20);\n          result = (uint)combined_inputs;\n          if (temp_var_2 == 1) {\n            return result;\n          }\n          if (temp_var_2 == 2) {\n            combined_inputs = reverse_and_improve_080082d0(result, temp_var_1, DAT_08009ae8, DAT_08009aec);\n            result = reverse_and_improve_080082d0(DAT_08009af0, DAT_08009af4, (int)combined_inputs, (int)((ulonglong)combined_inputs >> 0x20));\n            return result;\n          }\n          if (temp_var_2 == 0) {\n            return result;\n          }\n          combined_inputs = reverse_and_improve_080082d0(result, temp_var_1, DAT_08009ae8, DAT_08009aec);\n          result = reverse_and_improve_080082d0((int)combined_inputs, (int)((ulonglong)combined_inputs >> 0x20), DAT_08009af0, DAT_08009af4)\n          ;\n          return result;\n        }\n      }\n      result = DAT_08009b08;\n      if (-1 < (int)input_2) {\n        result = DAT_08009b00;\n      }\n    }\n  }\n  return result;\n}",
            "called": [
                "FUN_080082d0",
                "FUN_080082d4",
                "FUN_0800af78",
                "FUN_0800b2cc",
                "FUN_08008894"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009990",
            "calling": [
                "thunk_FUN_08009990"
            ],
            "imported": false,
            "current_name": "calculate_result_08009990"
        },
        "FUN_08007e58": {
            "renaming": {
                "FUN_08007e58": "is_bit_set_08007e58",
                "DAT_08007e80": "data_pointer",
                "0x20": "MASK"
            },
            "code": "bool is_bit_set_08007e58(void)\n{\n  bool is_set = (*DAT_08007e80 & MASK) != 0;\n  return is_set;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e58",
            "calling": [
                "FUN_08008286"
            ],
            "imported": false,
            "current_name": "is_bit_set_08007e58"
        },
        "FUN_080059f8": {
            "renaming": {
                "FUN_080059f8": "initialize_values_080059f8",
                "DAT_08005a4c": "data_ptr"
            },
            "code": "void initialize_values_080059f8()\n{\n    int* DAT_08005a4c = DAT_08005a4c;\n    *(DAT_08005a4c + 8) = -1;\n    *(DAT_08005a4c + 8) = 0;\n    *(DAT_08005a4c + 12) = -1;\n    *(DAT_08005a4c + 12) = 0;\n    *(DAT_08005a4c + 4) = -1;\n    *(DAT_08005a4c + 4) = 0;\n    *(DAT_08005a4c + 6) = -1;\n    *(DAT_08005a4c + 6) = 0;\n    *(DAT_08005a4c + 8) = -1;\n    *(DAT_08005a4c + 8) = 0;\n    do_nothing_08005a5c();\n}",
            "called": [
                "FUN_08005a5c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080059f8",
            "calling": [],
            "imported": false,
            "current_name": "initialize_values_080059f8"
        },
        "FUN_08003f34": {
            "renaming": {
                "FUN_08003f34": "process_user_input_08003f34",
                "bVar1": "current_character",
                "bVar2": "current_char",
                "uVar3": "command_result",
                "PTR_DAT_08004028": "is_inside_parentheses",
                "PTR_DAT_08004020": "buffer_index",
                "PTR_DAT_08004024": "input_buffer"
            },
            "code": "void process_user_input_08003f34(void)\n{\n  char current_char;\n  char PTR_DAT_08004028 = 0;\n  char PTR_DAT_08004024[20];\n  int PTR_DAT_08004020 = 0;\n  while(1) {\n    current_char = process_dat_value_08008286();\n    if (current_char == 0xff) {\n      return;\n    }\n    if ((current_char == 10) || (current_char == 0xd)) {\n      continue;\n    }\n    if (PTR_DAT_08004024[0] == '\\0') {\n      if ((current_char > 0x20) && (current_char != 0x2f)) {\n        if (current_char == 0x28) {\n          PTR_DAT_08004028 = 1;\n        }\n        else if (PTR_DAT_08004020 == -1) {\n          print_error_message(0xd);\n          clear_data_08003980();\n        }\n        else if ((current_char < 0x61) || (0x7a < current_char)) {\n          PTR_DAT_08004024[PTR_DAT_08004020] = current_char;\n          PTR_DAT_08004020++;\n        }\n        else {\n          PTR_DAT_08004024[PTR_DAT_08004020] = current_char - 0x20;\n          PTR_DAT_08004020++;\n        }\n      }\n    }\n    else if (current_char == 0x29) {\n      PTR_DAT_08004028 = 0;\n    }\n    if (PTR_DAT_08004028 == 0) {\n      process_alarm_08003a74();\n      if (*PTR_DAT_0800401c != '\\0') {\n        continue;\n      }\n      if (PTR_DAT_08004020 == 0) {\n        print_error_message(0);\n      }\n      else {\n        PTR_DAT_08004024[PTR_DAT_08004020] = '\\0';\n        int command_result = process_command_08003b98(PTR_DAT_08004024);\n        print_error_message(command_result);\n      }\n      clear_data_08003980();\n    }\n  }\n}",
            "called": [
                "FUN_08008286",
                "FUN_08003980",
                "FUN_08004030",
                "FUN_08003b98",
                "FUN_08003a74"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f34",
            "calling": [
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "process_user_input_08003f34"
        },
        "FUN_080095b8": {
            "renaming": {
                "FUN_080095b8": "calculate_result_080095b8",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar1": "shift_mask",
                "uVar2": "shifted_input_2",
                "uVar3": "normalized_input_2",
                "uVar5": "shift_amount",
                "iVar4": "sign"
            },
            "code": "int calculate_result_080095b8(uint input_1, uint input_2)\n{\n  uint shifted_input_2 = (input_2 << 1) >> 21;\n  int sign = (int)input_2 < 0 ? -1 : 1;\n  uint normalized_input_2 = input_2 & 0xfffff | 0x100000;\n  uint shift_amount = shifted_input_2 - 0x3ff;\n  if ((int)shift_amount < 0x14)\n  {\n    if ((int)shift_amount < 0)\n    {\n      if (shift_amount != 0xffffffff)\n      {\n        sign = 0;\n      }\n      return sign;\n    }\n    normalized_input_2 = normalized_input_2 + (0x80000 >> (shift_amount & 0xff)) >> (0x14 - shift_amount & 0xff);\n  }\n  else\n  {\n    if (0x1e < shift_amount)\n    {\n      sign = calculate_08008ba0();\n      return sign;\n    }\n    if ((int)shift_amount < 0x34)\n    {\n      uint shift_mask = 0x80000000 >> (shifted_input_2 - 0x413 & 0xff);\n      if (CARRY4(shift_mask, input_1) != false)\n      {\n        normalized_input_2 = normalized_input_2 + 1;\n      }\n      normalized_input_2 = normalized_input_2 << (shifted_input_2 - 0x413 & 0xff);\n      if (shift_amount != 0x14)\n      {\n        normalized_input_2 = normalized_input_2 | shift_mask + input_1 >> (0x34 - shift_amount & 0xff);\n      }\n    }\n    else\n    {\n      normalized_input_2 = normalized_input_2 << (shifted_input_2 - 0x413 & 0xff) | input_1 << (shifted_input_2 - 0x433 & 0xff);\n    }\n  }\n  return normalized_input_2 * sign;\n}",
            "called": [
                "FUN_08008ba0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080095b8",
            "calling": [
                "FUN_08001994",
                "FUN_08003004"
            ],
            "imported": false,
            "current_name": "calculate_result_080095b8"
        },
        "FUN_08006cf6": {
            "renaming": {
                "FUN_08006cf6": "write_bits_to_memory_08006cf6",
                "param_1": "memory_location",
                "param_2": "mask",
                "param_3": "shift_amount",
                "uVar1": "bits",
                "get_bits_from_uint_08006998": "get_bits_from_uint",
                "apply_mask_08006ba0": "apply_mask",
                "write_byte_to_memory_08006b00": "write_byte_to_memory"
            },
            "code": "void write_bits_to_memory_08006cf6(char memory_location, uint32_t mask, uint32_t shift_amount) {\n  uint32_t bits = get_bits_from_uint();\n  uint32_t masked_bits = apply_mask(bits, mask, shift_amount);\n  write_byte_to_memory((int)memory_location, masked_bits);\n  return;\n}",
            "called": [
                "FUN_08006998",
                "FUN_08006ba0",
                "FUN_08006b00"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006cf6",
            "calling": [
                "FUN_08007a70"
            ],
            "imported": false,
            "current_name": "write_bits_to_memory_08006cf6"
        },
        "FUN_08002ef0": {
            "renaming": {
                "FUN_08002ef0": "copy_and_reset_data_08002ef0",
                "uVar1": "incremented_value",
                "*PTR_DAT_08002f1c": "*destination",
                "*PTR_DAT_08002f18": "*source",
                "*PTR_DAT_08002f20": "*PTR_DAT_08002f20"
            },
            "code": "void copy_and_reset_data_08002ef0(void)\n{\n  int* source = PTR_DAT_08002f18;\n  int* destination = PTR_DAT_08002f1c;\n  int incremented_value = increment_and_reset_08002870(*PTR_DAT_08002f18);\n  *PTR_DAT_08002f1c = *PTR_DAT_08002f18;\n  *PTR_DAT_08002f20 = incremented_value;\n  return;\n}",
            "called": [
                "FUN_08002870"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ef0",
            "calling": [
                "FUN_08002f24"
            ],
            "imported": false,
            "current_name": "copy_and_reset_data_08002ef0"
        },
        "FUN_08001d4c": {
            "renaming": {
                "FUN_08001d4c": "check_and_execute_08001d4c",
                "local_9": "flag",
                "cVar1": "decrementer",
                "set_flags_based_on_data_08005790": "set_flags_based_on_data",
                "FUN_08001994": "execute_function",
                "do_nothing_08002814": "do_nothing",
                "PTR_DAT_08001dd8": "PTR_DAT_08001dd8",
                "check_flags_080057e4": "check_flags"
            },
            "code": "void check_and_execute_08001d4c(void)\n{\n  char decrementer;\n  char flag = 0x02;\n  set_flags_based_on_data();\n  execute_function(4, 1, 0, *(undefined4 *)(PTR_DAT_08001dd8 + 0x30));\n  execute_function(3, 1, 0, *(undefined4 *)(PTR_DAT_08001dd8 + 0x30));\n  do_nothing(*(undefined2 *)(PTR_DAT_08001dd8 + 0x34));\n  while(flag)\n  {\n    decrementer = flag - 1;\n    execute_function(7, 0, 1, *(undefined4 *)(PTR_DAT_08001dd8 + 0x2c));\n    do_nothing(*(undefined2 *)(PTR_DAT_08001dd8 + 0x34));\n    flag = decrementer;\n    if (decrementer > 0)\n    {\n      execute_function(7, 1, 0, *(undefined4 *)(PTR_DAT_08001dd8 + 0x2c));\n      do_nothing(*(undefined2 *)(PTR_DAT_08001dd8 + 0x34));\n    }\n  }\n  check_flags();\n  return;\n}",
            "called": [
                "FUN_08001994",
                "FUN_08005790",
                "FUN_080057e4",
                "FUN_08002814"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001d4c",
            "calling": [
                "FUN_080024c4"
            ],
            "imported": false,
            "current_name": "check_and_execute_08001d4c"
        },
        "FUN_08000268": {
            "renaming": {
                "FUN_08000268": "calculate_value_from_pointer_08000268",
                "iVar1": "pointer_value",
                "get_value_from_pointer_08005a84": "get_value_from_pointer",
                "DAT_0800029c": "global_data",
                "DAT_08000298": "global_data"
            },
            "code": "int calculate_value_from_pointer_08000268(void)\n{\n  int pointer_value = get_value_from_pointer();\n  int result = (pointer_value + 1) * 1000 - ((unsigned long long)DAT_0800029c * (unsigned long long)(*(unsigned int *)(DAT_0800029c + 8) >> 3) >> 0x21);\n  return result;\n}",
            "called": [
                "FUN_08005a84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000268",
            "calling": [
                "FUN_080002b6"
            ],
            "imported": false,
            "current_name": "calculate_value_from_pointer_08000268"
        },
        "FUN_08003778": {
            "renaming": {
                "FUN_08003778": "print_digits_of_number_08003778",
                "param_1": "number",
                "local_1c": "quotient",
                "acStack_15": "digits",
                "local_9": "digit_count",
                "uVar1": "remainder"
            },
            "code": "void print_digits_of_number_08003778(uint number) {\n  uint remainder;\n  uint quotient = number;\n  char digits[12];\n  byte digit_count = 0;\n  if (number == 0) {\n    waitForFlagAndReturn_08008250(0x30);\n  }\n  else {\n    while (quotient != 0) {\n      remainder = quotient % 10;\n      quotient /= 10;\n      digits[digit_count++] = remainder + '0';\n    }\n    while (digit_count != 0) {\n      waitForFlagAndReturn_08008250(digits[--digit_count]);\n    }\n  }\n}",
            "called": [
                "FUN_08008250"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003778",
            "calling": [
                "FUN_080037fc"
            ],
            "imported": false,
            "current_name": "print_digits_of_number_08003778"
        },
        "FUN_0800b3dc": {
            "renaming": {
                "FUN_0800b3dc": "get_value_from_pointer_to_pointer_0800b3dc",
                "PTR_PTR_DAT_0800b3e4": "value_pointer_to_pointer"
            },
            "code": "int get_value_from_pointer_to_pointer_0800b3dc() {\n  int *value_pointer = *(int **)PTR_PTR_DAT_0800b3e4;\n  int value = *value_pointer;\n  return value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b3dc",
            "calling": [
                "FUN_080098d0",
                "FUN_0800981c"
            ],
            "imported": false,
            "current_name": "get_value_from_pointer_to_pointer_0800b3dc"
        },
        "FUN_080046d0": {
            "renaming": {
                "FUN_080046d0": "printFormattedData_080046d0",
                "bVar1": "dataByte",
                "cVar2": "dataChar",
                "uVar3": "dataUndefined4",
                "uVar4": "dataUndefined8"
            },
            "code": "void printFormattedData_080046d0(void)\\n{\\n    byte dataByte;\\n    char dataChar;\\n    undefined4 dataUndefined4;\\n    undefined8 dataUndefined8;\\n\\n    if (4 < (byte)PTR_DAT_08004890[1]) {\\n        processString_080036c6(PTR_DAT_080048a8);\\n        printAbsoluteValue_080037fc((byte)PTR_DAT_08004890[0x1c] + 0x36);\\n        if (PTR_DAT_08004890[0x19] == \"\\0\") {\\n            if (PTR_DAT_08004890[0x1a] == \"\\x01\") {\\n                processString_080036c6(PTR_DAT_080048ac);\\n            }\\n            else {\\n                processString_080036c6(PTR_DAT_080048b0);\\n            }\\n        }\\n        else {\\n            processString_080036c6(PTR_DAT_080048b4);\\n        }\\n        if (PTR_DAT_08004890[3] == \"\\0\") {\\n            processString_080036c6(PTR_DAT_080048bc);\\n        }\\n        else {\\n            processString_080036c6(PTR_DAT_080048b8);\\n        }\\n        if (PTR_DAT_08004890[4] == \"\\0\") {\\n            processString_080036c6(PTR_DAT_080048c4);\\n        }\\n        else {\\n            processString_080036c6(PTR_DAT_080048c0);\\n        }\\n        if (PTR_DAT_08004890[2] == \"\\0\") {\\n            processString_080036c6(PTR_DAT_080048cc);\\n        }\\n        else {\\n            processString_080036c6(PTR_DAT_080048c8);\\n        }\\n        dataByte = PTR_DAT_08004890[5];\\n        if (dataByte == 2) {\\n            processString_080036c6(PTR_DAT_080048d8);\\n        }\\n        else if (dataByte < 3) {\\n            if (dataByte == 0) {\\n                processString_080036c6(PTR_DAT_080048d0);\\n            }\\n            else if (dataByte == 1) {\\n                processString_080036c6(PTR_DAT_080048d4);\\n            }\\n        }\\n        dataChar = PTR_DAT_08004890[6];\\n        if (dataChar == \"\\x01\") {\\n            processString_080036c6(PTR_DAT_080048dc);\\n        }\\n        else if (dataChar < \"\\x02\") {\\n            if (dataChar == -1) {\\n                processString_080036c6(PTR_DAT_080048e0);\\n            }\\n            else if (dataChar == \"\\0\") {\\n                processString_080036c6(PTR_DAT_080048e4);\\n            }\\n        }\\n        dataByte = PTR_DAT_08004890[7];\\n        if (dataByte == 2) {\\n            processString_080036c6(PTR_DAT_080048f0);\\n        }\\n        else if (dataByte < 3) {\\n            if (dataByte == 0) {\\n                processString_080036c6(PTR_DAT_080048e8);\\n            }\\n            else if (dataByte == 1) {\\n                processString_080036c6(PTR_DAT_080048ec);\\n            }\\n        }\\n        processString_080036c6(PTR_DAT_080048f4);\\n        printAbsoluteValue_080037fc(PTR_DAT_08004890[0x18]);\\n        processString_080036c6(PTR_DAT_080048f8);\\n        if (PTR_DAT_08004890[3] == \"\\0\") {\\n            print_decimal_number_08003826(*(undefined4 *)(PTR_DAT_08004890 + 8));\\n        }\\n        else {\\n            dataUndefined8 = reverse_bits_08008590(*(undefined4 *)(PTR_DAT_08004890 + 8));\\n            dataUndefined8 = calculate_product_08008640((int)dataUndefined8, (int)((ulonglong)dataUndefined8 >> 0x20), DAT_08004888, DAT_0800488c);\\n            dataUndefined4 = calculate_float_bits_08008c30((int)dataUndefined8, (int)((ulonglong)dataUndefined8 >> 0x20));\\n            print_decimal_number_08003826(dataUndefined4);\\n        }\\n        processString_080036c6(PTR_DAT_080048fc);\\n        return;\\n    }\\n    (*(code *)(&switchD_080046de::switchdataD_080046e4)[(byte)PTR_DAT_08004890[1]])();\\n    return;\\n}",
            "called": [
                "FUN_08008590",
                "FUN_08008c30",
                "FUN_080037fc",
                "FUN_08003826",
                "FUN_08008640",
                "FUN_080036c6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080046d0",
            "calling": [
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "printFormattedData_080046d0"
        },
        "FUN_08006d72": {
            "renaming": {
                "FUN_08006d72": "validate_and_return_param_08006d72",
                "param_1": "input_param",
                "uVar1": "validated_param",
                "validate_param_08006c9c": "validate_input_param"
            },
            "code": "int validate_and_return_param_08006d72(undefined4 input_param)\n{\n  int validated_param = validate_input_param(input_param);\n  return validated_param;\n}",
            "called": [
                "FUN_08006c9c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d72",
            "calling": [
                "FUN_080059b4"
            ],
            "imported": false,
            "current_name": "validate_and_return_param_08006d72"
        },
        "FUN_0800756c": {
            "renaming": {
                "FUN_0800756c": "set_bit_and_clear_other_bits_0800756c",
                "DAT_080075bc": "data",
                "DAT_080075c0": "data_1",
                "DAT_080075c4": "more_data"
            },
            "code": "void set_bit_and_clear_other_bits_0800756c(void)\n{\n  unsigned int *DAT_080075bc = PTR_DAT_080075bc;\n  DAT_080075bc[0] |= 0x1;\n  DAT_080075bc[2] = 0;\n  DAT_080075bc[0] &= 0xfef6ffff;\n  DAT_080075bc[1] = DAT_080075c0;\n  DAT_080075bc[0] &= 0xfffbffff;\n  DAT_080075bc[3] = 0;\n  unsigned int *DAT_080075c4 = PTR_DAT_080075c4;\n  *(DAT_080075c4 + 2) = 0x8000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800756c",
            "calling": [
                "FUN_080092c4"
            ],
            "imported": false,
            "current_name": "set_bit_and_clear_other_bits_0800756c"
        },
        "FUN_080001f8": {
            "renaming": {
                "FUN_080001f8": "initialize_pointer_080001f8",
                "*PTR_DAT_0800020c": "*pointer_data",
                "do_nothing_twice_08000210": "do_nothing_twice"
            },
            "code": "void initialize_pointer_080001f8() {\n  *PTR_DAT_0800020c = 0;\n  do_nothing_twice();\n  return;\n}",
            "called": [
                "FUN_08000210"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001f8",
            "calling": [
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "initialize_pointer_080001f8"
        },
        "FUN_08002f74": {
            "renaming": {
                "FUN_08002f74": "get_value_if_not_equal_08002f74",
                "puVar1": "value",
                "*PTR_DAT_08002fa0": "ptr1",
                "*PTR_DAT_08002fa4": "ptr2",
                "PTR_DAT_08002fa8": "data_ptr"
            },
            "code": "undefined* get_value_if_not_equal_08002f74() {\n    undefined* value;\n    if (*PTR_DAT_08002fa0 == *PTR_DAT_08002fa4) {\n        value = (undefined*)0x0;\n    }\n    else {\n        uint8_t index = (uint8_t)*PTR_DAT_08002fa4;\n        value = PTR_DAT_08002fa8 + (uint)index * 0x40;\n    }\n    return value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f74",
            "calling": [
                "FUN_080053a0",
                "FUN_08002fd4"
            ],
            "imported": false,
            "current_name": "get_value_if_not_equal_08002f74"
        },
        "FUN_0800b3e8": {
            "renaming": {
                "FUN_0800b3e8": "execute_functions_0800b3e8",
                "ppcVar2": "function_ptr",
                "iVar1": "i",
                "iVar3": "num_functions",
                "do_nothing_0800b5b0": "do_nothing",
                "PTR_DAT_0800b420": "PTR_functions_end",
                "PTR_DAT_0800b424": "PTR_functions_start",
                "PTR_DAT_0800b428": "PTR_more_functions_end",
                "PTR_DAT_0800b42c": "PTR_more_functions_start"
            },
            "code": "void execute_functions_0800b3e8() {\n    int num_functions = (int)PTR_DAT_0800b420 - (int)PTR_DAT_0800b424 >> 2;\n    if (num_functions != 0) {\n        int i = 0;\n        code **function_ptr = (code **)PTR_DAT_0800b424;\n        while (i != num_functions) {\n            (**function_ptr)();\n            function_ptr++;\n            i++;\n        }\n    }\n    function_ptr = (code **)PTR_DAT_0800b42c;\n    int num_more_functions = (int)PTR_DAT_0800b428 - (int)PTR_DAT_0800b42c >> 2;\n    do_nothing();\n    if (num_more_functions != 0) {\n        int i = 0;\n        while (i != num_more_functions) {\n            (**function_ptr)();\n            function_ptr++;\n            i++;\n        }\n    }\n    return;\n}",
            "called": [
                "FUN_080001ac",
                "FUN_0800b5b0",
                "FUN_0800b4d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b3e8",
            "calling": [
                "FUN_080092c4"
            ],
            "imported": false,
            "current_name": "execute_functions_0800b3e8"
        },
        "FUN_080096e8": {
            "renaming": {
                "FUN_080096e8": "calculate_new_value_080096e8",
                "param_1": "param1",
                "param_2": "param2",
                "DAT_08009790": "max_value",
                "DAT_08009794": "max_value_2",
                "local_28": "local_var1",
                "uStack_24": "local_var2",
                "local_20": "local_var3",
                "uStack_1c": "local_var4",
                "uVar1": "result",
                "uVar2": "uVar2"
            },
            "code": "int calculate_new_value_080096e8(int param1, unsigned int param2, int param3, int param4, int param5) {\n    int result;\n    unsigned int uVar2;\n    int local_var1;\n    int local_var2;\n    int local_var3;\n    int local_var4;\n\n    if (DAT_08009790 < (int)(param2 & 0x7fffffff)) {\n        if (DAT_08009794 < (int)(param2 & 0x7fffffff)) {\n            result = calculate_new_value_080096e8_2(param1, param2, param1, param2);\n        }\n        else {\n            uVar2 = calculate_new_value_080096e8_3(param1, param2, &local_var1);\n            uVar2 = uVar2 & 3;\n            if (uVar2 == 1) {\n                result = calculate_new_value_080096e8_4(local_var1, local_var2, local_var3, local_var4);\n            }\n            else if (uVar2 == 2) {\n                result = calculate_new_value_080096e8_5(local_var1, local_var2, local_var3, local_var4, 1);\n            }\n            else if (uVar2 == 0) {\n                result = calculate_new_value_080096e8_5(local_var1, local_var2, local_var3, local_var4, 1);\n            }\n            else {\n                result = calculate_new_value_080096e8_4(local_var1, local_var2, local_var3, local_var4);\n            }\n        }\n        return result;\n    }\n    result = calculate_new_value_080096e8_5(param1, param2, 0, 0, 0);\n    return result;\n}",
            "called": [
                "FUN_080082d0",
                "FUN_0800a348",
                "FUN_08009d78",
                "FUN_0800adf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080096e8",
            "calling": [
                "FUN_08001f00"
            ],
            "imported": false,
            "current_name": "calculate_new_value_080096e8"
        },
        "FUN_08006a18": {
            "renaming": {
                "FUN_08006a18": "isBitSetInArray_08006a18",
                "param_1": "bitIndex",
                "DAT_08006a54": "bitArray",
                "PTR_08006a54": "bitArray"
            },
            "code": "bool isBitSetInArray_08006a18(uint8_t bitIndex)\n{\n    uint32_t *DAT_08006a54 = (uint32_t *)(DAT_08006a54 + (((uint32_t)bitIndex >> 5) + 0x40) * 4);\n    uint32_t mask = 1 << (bitIndex & 0x1f);\n    return ((*DAT_08006a54 & mask) != 0);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006a18",
            "calling": [
                "FUN_08006de0"
            ],
            "imported": false,
            "current_name": "isBitSetInArray_08006a18"
        },
        "FUN_08002c18": {
            "renaming": {
                "FUN_08002c18": "calculate_collision_08002c18",
                "param_1": "input",
                "param_2": "param_3",
                "param_3": "hash_seed",
                "uVar1": "hash1",
                "iVar2": "shift_amount",
                "uVar3": "hash2",
                "uVar4": "fixed_point",
                "uVar5": "fixed_point_neg",
                "uVar6": "result1",
                "uVar7": "result2",
                "local_1c": "collision",
                "local_20": "offset"
            },
            "code": "void calculate_collision_08002c18(uint32_t param_1, uint32_t param_2, uint32_t param_3)\n{\n    uint32_t hash1 = calculate_hash(param_1);\n    uint32_t hash2 = calculate_hash(param_2);\n    int32_t shift_amount = calculate_shift_amount(reverse_bits(FUN(hash1, param_3)));\n    int32_t shift_amount2 = calculate_shift_amount(reverse_bits(FUN(hash2, param_3)));\n    uint32_t fixed_point = calculate_fixed_point(calculate(param_1));\n    uint32_t fixed_point_neg = calculate_fixed_point(-calculate(param_1));\n    uint32_t result1 = calculate_result(hash1, hash2, fixed_point);\n    uint32_t result2 = calculate_result(hash1, hash2, fixed_point_neg);\n    uint32_t collision = calculate_collision_08002c18_position(result1, result2, shift_amount, shift_amount2);\n    uint32_t possible_length = calculate_possible_length(param_1, collision);\n    uint32_t collision_length = calculate_collision_08002c18_length(param_1, collision, possible_length);\n    uint32_t offset = calculate_offset(param_1, collision_length, possible_length);\n    *(uint32_t *)(param_1 + 0x34) = possible_length;\n    *(uint32_t *)(param_1 + 0x38) = offset + possible_length;\n}",
            "called": [
                "FUN_08009318",
                "FUN_080094c0",
                "FUN_08008590",
                "FUN_08008e44",
                "FUN_08008ba0",
                "FUN_0800856c",
                "FUN_08002908",
                "FUN_080028bc",
                "FUN_08008640",
                "FUN_08008bf0",
                "FUN_08008e3c",
                "FUN_08008eec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c18",
            "calling": [
                "FUN_08002e08"
            ],
            "imported": false,
            "current_name": "calculate_collision_08002c18"
        },
        "FUN_08006ac0": {
            "renaming": {
                "FUN_08006ac0": "isBitSet_08006ac0",
                "param_1": "bit",
                "DAT_08006afc": "data",
                "uint": "uint32_t",
                "byte": "uint8_t",
                "PTR_": "ptr_",
                "DAT_": "data_"
            },
            "code": "bool isBitSet_08006ac0(uint8_t bit, uint32_t* DAT_08006afc) {\n    uint8_t index = bit >> 5;\n    uint8_t offset = bit & 0x1f;\n    uint32_t* ptr = DAT_08006afc + (index + 0x80) * 4;\n    return ((*ptr) & (1 << offset)) != 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ac0",
            "calling": [
                "FUN_08006e1a"
            ],
            "imported": false,
            "current_name": "isBitSet_08006ac0"
        },
        "FUN_080001ec": {
            "renaming": {
                "FUN_080001ec": "do_nothing_080001ec"
            },
            "code": "\nvoid do_nothing_080001ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001ec",
            "calling": [
                "FUN_08000210"
            ],
            "imported": false,
            "current_name": "do_nothing_080001ec"
        },
        "FUN_08005a50": {
            "renaming": {
                "FUN_08005a50": "do_nothing_08005a50"
            },
            "code": "\nvoid do_nothing_08005a50(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a50",
            "calling": [
                "FUN_080059b4"
            ],
            "imported": false,
            "current_name": "do_nothing_08005a50"
        },
        "FUN_08002ba8": {
            "renaming": {
                "FUN_08002ba8": "concatenate_strings_from_array_08002ba8",
                "*PTR_DAT_08002c0c": "current_index",
                "*PTR_DAT_08002c14": "end_index",
                "local_9": "current_char",
                "local_14": "previous_string",
                "local_10": "current_string",
                "puVar1": "array_of_strings",
                "puVar2": "previous_string",
                "puVar3": "concatenated_string",
                "validate_and_concatenate_strings_08002afc": "validate_and_concatenate_strings",
                "increment_and_reset_08002870": "increment_and_reset"
            },
            "code": "void concatenate_strings_from_array_08002ba8(void)\n{\n  uint8_t current_char;\n  uint8_t *current_string = NULL;\n  uint8_t *previous_string = NULL;\n  uint8_t *concatenated_string = NULL;\n\n  current_char = **PTR_DAT_08002c0c;\n  while (current_char != **PTR_DAT_08002c14)\n  {\n    previous_string = current_string;\n    current_string = array_of_strings + (uint)current_char * 0x40;\n    validate_and_concatenate_strings(previous_string, concatenated_string, current_string);\n    current_char = increment_and_reset(current_char);\n    concatenated_string = previous_string;\n  }\n  validate_and_concatenate_strings(current_string, concatenated_string, NULL, previous_string, concatenated_string);\n  return;\n}",
            "called": [
                "FUN_08002afc",
                "FUN_08002870"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ba8",
            "calling": [
                "FUN_08002edc"
            ],
            "imported": false,
            "current_name": "concatenate_strings_from_array_08002ba8"
        },
        "FUN_0800919c": {
            "renaming": {
                "FUN_0800919c": "calculate_result_0800919c",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_negative_1",
                "uVar2": "input_1_times_2",
                "uVar3": "input_2_times_2",
                "uVar4": "input_1_and_input_2_bitwise_and",
                "bVar5": "is_input_1_and_input_2_bitwise_and_zero"
            },
            "code": "uint calculate_result_0800919c(uint input_1, uint input_2)\n{\n  bool is_negative_1 = false;\n  bool is_negative_2 = false;\n  uint input_1_times_2 = input_1 * 2;\n  uint input_2_times_2 = input_2 * 2;\n  if (((int)input_1_times_2 >> 0x18 == -1 || (int)input_2_times_2 >> 0x18 == -1) && ((((int)input_1_times_2 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) || (((int)input_2_times_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0))))))\n  {\n    return 1;\n  }\n  uint input_1_and_input_2_bitwise_and = input_2 & 0x7fffffff | input_1_times_2;\n  bool is_input_1_and_input_2_bitwise_and_zero = input_1_and_input_2_bitwise_and == 0;\n  if (!is_input_1_and_input_2_bitwise_and_zero)\n  {\n    uint input_1_xor_input_2 = input_1 ^ input_2;\n    is_input_1_and_input_2_bitwise_and_zero = input_1_xor_input_2 == 0;\n  }\n  is_negative_1 = -1 < (int)input_1_xor_input_2;\n  if (is_negative_1)\n  {\n    input_1 = input_1_times_2 + input_2 * -2;\n    is_input_1_and_input_2_bitwise_and_zero = input_1 == 0;\n  }\n  if (is_negative_1 && input_2_times_2 <= input_1_times_2 && !is_input_1_and_input_2_bitwise_and_zero)\n  {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative_1 || input_2_times_2 > input_1_times_2)\n  {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_input_1_and_input_2_bitwise_and_zero)\n  {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800919c",
            "calling": [
                "FUN_08009204"
            ],
            "imported": false,
            "current_name": "calculate_result_0800919c"
        },
        "FUN_0800b2cc": {
            "renaming": {
                "FUN_0800b2cc": "do_nothing_0800b2cc"
            },
            "code": "\nvoid do_nothing_0800b2cc(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2cc",
            "calling": [
                "FUN_08009990",
                "FUN_0800af78",
                "FUN_08009d78"
            ],
            "imported": false,
            "current_name": "do_nothing_0800b2cc"
        },
        "FUN_0800854c": {
            "renaming": {
                "FUN_0800854c": "reverse_bits_0800854c",
                "param_1": "input",
                "uVar1": "left_shifted",
                "uVar2": "shift_amount",
                "iVar3": "leading_zeroes",
                "uVar4": "shift_amount_temp",
                "in_r12": "unused",
                "bVar5": "is_negative_shift",
                "bVar6": "is_shift_amount_zero",
                "bVar7": "is_shift_amount_negative"
            },
            "code": "unsigned long long reverse_bits_0800854c(uint input)\n{\n    if (input == 0) {\n        return 0;\n    }\n    uint leading_zeroes = count_leading_zeroes(input);\n    uint shift_amount = leading_zeroes + 0x15;\n    bool is_negative_shift = shift_amount < 0x20;\n    if (is_negative_shift) {\n        shift_amount = leading_zeroes + 1;\n    }\n    uint left_shifted = input << (shift_amount & 0xff);\n    uint right_shifted = input >> ((0xcU - leading_zeroes) & 0xff);\n    if (is_negative_shift) {\n        right_shifted |= 0U >> ((0x20 - shift_amount) & 0xff);\n    }\n    unsigned long long result = (unsigned long long)left_shifted;\n    if (shift_amount < 0x433) {\n        result += (0x432 - shift_amount) * 0x100000;\n    } else {\n        uint inverted_shift_amount = ~(0x432 - shift_amount);\n        if (inverted_shift_amount > 0x1e) {\n            result = (unsigned long long)(right_shifted >> ((inverted_shift_amount - 0x1f) & 0xff));\n        } else {\n            int shift_diff = inverted_shift_amount - 0x13;\n            if (shift_diff == 0 || (shift_diff < 0) != ((inverted_shift_amount - 0x1f) < 0xc)) {\n                uint shifted_right = right_shifted >> (inverted_shift_amount & 0xff);\n                uint shifted_left = left_shifted >> (0x20 - inverted_shift_amount & 0xff);\n                result |= (unsigned long long)shifted_right;\n                result |= (unsigned long long)shifted_left;\n            } else {\n                result = (unsigned long long)(right_shifted >> (0x20 - (0xcU - shift_diff) & 0xff));\n                result |= (unsigned long long)(left_shifted << (0xcU - shift_diff & 0xff));\n            }\n        }\n    }\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800854c",
            "calling": [
                "FUN_08001994"
            ],
            "imported": false,
            "current_name": "reverse_bits_0800854c"
        },
        "FUN_08008e44": {
            "renaming": {
                "FUN_08008e44": "convert_to_fixed_point_08008e44",
                "param_1": "input",
                "uVar2": "fractional_bits",
                "uVar3": "sign_bit",
                "iVar1": "leading_zeros",
                "iVar4": "integer_part",
                "uVar5": "rounding",
                "count_leading_zeroes": "count_leading_zeroes"
            },
            "code": "uint convert_to_fixed_point_08008e44(uint input)\n{\n  int leading_zeros = count_leading_zeroes(input);\n  uint fractional_bits = leading_zeros - 8;\n  uint sign_bit = input & 0x80000000;\n  if ((int)sign_bit < 0) {\n    input = -input;\n  }\n  if (input == 0) {\n    return 0;\n  }\n  uint integer_part;\n  if (leading_zeros > 7) {\n    uint rounding = 0 << (fractional_bits & 0xff);\n    integer_part = ((sign_bit | 0x4b000000) - 0x800000) + (input << (fractional_bits & 0xff)) + (0U >> (0x20 - fractional_bits & 0xff)) + (uint)(0x7fffffff < rounding);\n    if (rounding == 0x80000000) {\n      integer_part = integer_part & 0xfffffffe;\n    }\n  }\n  else {\n    uint integer_bits = input << (leading_zeros + 0x18U & 0xff);\n    integer_part = ((sign_bit | 0x4b000000) - 0x800000) + ((input >> (0x20 - (leading_zeros + 0x18U) & 0xff)) - ((int)integer_bits >> 0x1f));\n    if ((integer_bits & 0x7fffffff) == 0) {\n      integer_part = integer_part & ~(integer_bits >> 0x1f);\n    }\n  }\n  return integer_part;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e44",
            "calling": [
                "FUN_080004fc",
                "FUN_08004940",
                "FUN_08003004",
                "FUN_08003618",
                "FUN_080024c4",
                "FUN_08002408",
                "FUN_08001f00",
                "FUN_08002c18"
            ],
            "imported": false,
            "current_name": "convert_to_fixed_point_08008e44"
        },
        "FUN_0800733e": {
            "renaming": {
                "FUN_0800733e": "set_parameter_value_0800733e",
                "param_1": "parameter_index",
                "param_2": "value",
                "param_3": "is_second_parameter"
            },
            "code": "void set_parameter_value_0800733e(int parameter_index, unsigned short value, char is_second_parameter)\\n{\\n  if (is_second_parameter == \"\\0\") {\\n    *(unsigned short *)(parameter_index + 0x1a) = value;\\n  }\\n  else {\\n    *(unsigned short *)(parameter_index + 0x18) = value;\\n  }\\n  return;\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800733e",
            "calling": [
                "FUN_0800778c"
            ],
            "imported": false,
            "current_name": "set_parameter_value_0800733e"
        },
        "FUN_0800583c": {
            "renaming": {
                "FUN_0800583c": "set_param_and_flags_based_on_data_0800583c",
                "set_param_with_mask_080052ac": "set_param_with_mask",
                "set_flags_based_on_data_08005790": "set_flags_based_on_data",
                "check_flags_080057e4": "check_flags",
                "PTR_DAT_08005858": "PTR_DATA",
                "param": "parameter"
            },
            "code": "void set_param_and_flags_based_on_data_0800583c(void)\n{\n  uint16_t param = *(uint16_t *)(PTR_DAT_08005858 + 0x18);\n  set_param_with_mask(param);\n  set_flags_based_on_data();\n  check_flags();\n  return;\n}",
            "called": [
                "FUN_080052ac",
                "FUN_08005790",
                "FUN_080057e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800583c",
            "calling": [
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "set_param_and_flags_based_on_data_0800583c"
        },
        "FUN_08001e98": {
            "renaming": {
                "FUN_08001e98": "process_data_and_set_flags_if_second_element_is_two_08001e98",
                "param_1": "data1",
                "param_2": "data2",
                "param_3": "data3",
                "param_4": "data4",
                "param_5": "flag",
                "iVar1": "pointer_match_result",
                "PTR_DAT_08001efc": "PTR_DAT",
                "process_alarm_08003a74": "process_alarm",
                "check_pointers_match_08002fac": "check_pointers_match",
                "FUN_08003004": "process_data",
                "set_flags_if_second_element_is_two_0800585c": "set_flags_if_second_element_is_two"
            },
            "code": "void process_data_and_set_flags_if_second_element_is_two_08001e98(int data1, int data2, int data3, int data4, char flag) {\\n  int pointer_match_result;\\n  if (PTR_DAT_08001efc_08001efc[1] != \"\\a\") {\\n    do {\\n      process_alarm();\\n      if (*PTR_DAT_08001efc_08001efc != \"\\0\") {\\n        return;\\n      }\\n      pointer_match_result = check_pointers_match();\\n    } while (pointer_match_result != 0);\\n    calculate_collision_08003004(data1, data2, data3, data4, flag);\\n    if (PTR_DAT_08001efc_08001efc[1] == \"\\0\") {\\n      PTR_DAT_08001efc_08001efc[1] = 2;\\n    }\\n    if (PTR_DAT_08001efc_08001efc[0x10] != \"\\0\") {\\n      set_flags_if_second_element_is_two();\\n    }\\n  }\\n  return;\\n}",
            "called": [
                "FUN_08002fac",
                "FUN_08003004",
                "FUN_0800585c",
                "FUN_08003a74"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001e98",
            "calling": [
                "FUN_080005b4",
                "FUN_080024c4",
                "FUN_08001f00"
            ],
            "imported": false,
            "current_name": "process_data_and_set_flags_if_second_element_is_two_08001e98"
        },
        "FUN_080069e4": {
            "renaming": {
                "FUN_080069e4": "set_bit_in_array_080069e4",
                "param_1": "index",
                "DAT_08006a14": "array_start_ptr"
            },
            "code": "void set_bit_in_array_080069e4(uint8_t index) {\n    uint32_t* array_ptr = (uint32_t*)(DAT_08006a14 + (((uint32_t)index >> 5) + 0x20) * 4);\n    uint32_t bit_mask = 1 << (index & 0x1f);\n    *array_ptr = bit_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080069e4",
            "calling": [
                "FUN_08006d4a"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_080069e4"
        },
        "FUN_0800b2d4": {
            "renaming": {
                "FUN_0800b2d4": "set_sign_bit_and_shift_right_0800b2d4",
                "param_1": "input_value",
                "param_2": "original_value",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "uint set_sign_bit_and_shift_right_0800b2d4(uint input_value)\n{\n    uint signed_value = input_value | 0x80000000;\n    uint shifted_value = signed_value + 0x100000;\n    uint result = shifted_value >> 0x1f;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2d4",
            "calling": [
                "FUN_0800981c"
            ],
            "imported": false,
            "current_name": "set_sign_bit_and_shift_right_0800b2d4"
        },
        "FUN_08008e3c": {
            "renaming": {
                "FUN_08008e3c": "calculate_hash_08008e3c",
                "param_1": "input",
                "iVar1": "leading_zeroes",
                "uVar2": "shift_amount",
                "iVar3": "multiplier",
                "uVar4": "shift_mask",
                "shifted_input": "shifted_input",
                "shifted_mask": "shifted_mask",
                "result": "result"
            },
            "code": "uint calculate_hash_08008e3c(uint input)\n{\n  if (input == 0) {\n    return 0;\n  }\n  int leading_zeroes = count_leading_zeroes(input);\n  uint shift_amount = leading_zeroes - 8;\n  int multiplier = shift_amount * -0x800000 + 0x4a800000;\n  if (leading_zeroes > 7) {\n    uint shift_mask = 0 << (shift_amount & 0xff);\n    uint shifted_input = input << (shift_amount & 0xff);\n    uint shifted_mask = 0U >> (0x20 - shift_amount & 0xff);\n    uint result = multiplier + shifted_input + shifted_mask + (uint)(0x7fffffff < shift_mask);\n    if (shift_mask == 0x80000000) {\n      result = result & 0xfffffffe;\n    }\n    return result;\n  }\n  uint shifted_input = input << (leading_zeroes + 0x18U & 0xff);\n  uint shifted_mask = (input >> (0x20 - (leading_zeroes + 0x18U) & 0xff)) - ((int)shifted_input >> 0x1f);\n  uint result = multiplier + shifted_mask;\n  if ((shifted_input & 0x7fffffff) == 0) {\n    result = result & ~(shifted_input >> 0x1f);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e3c",
            "calling": [
                "FUN_08002638",
                "FUN_08002c18"
            ],
            "imported": false,
            "current_name": "calculate_hash_08008e3c"
        },
        "FUN_08009654": {
            "renaming": {
                "FUN_08009654": "calculate_double_precision_08009654",
                "param_1": "first_parameter",
                "param_2": "second_parameter",
                "uVar1": "shifted_difference",
                "uVar2": "shift_amount",
                "lVar3": "result",
                "DAT_080096e4": "mask",
                "CARRY4": "CARRY4"
            },
            "code": "longlong calculate_double_precision_08009654(uint first_parameter, uint second_parameter)\n{\n  longlong result = CONCAT44(second_parameter, first_parameter);\n  uint shift_amount = (second_parameter << 1) >> 0x15;\n  uint shifted_difference = shift_amount - 0x3ff;\n  if ((int)shifted_difference < 0x14) {\n    if ((int)shifted_difference < 0) {\n      second_parameter = second_parameter & 0x80000000;\n      if (shifted_difference == 0xffffffff) {\n        second_parameter = second_parameter | 0x3ff00000;\n      }\n      result = (ulonglong)second_parameter << 0x20;\n    }\n    else {\n      uint DAT_080096e4 = DAT_080096e4 >> (shifted_difference & 0xff);\n      result = CONCAT44(second_parameter, first_parameter);\n      if ((second_parameter & DAT_080096e4 | first_parameter) != 0) {\n        result = (ulonglong)(second_parameter + (0x80000 >> (shifted_difference & 0xff)) & ~DAT_080096e4) << 0x20;\n      }\n    }\n  }\n  else if ((int)shifted_difference < 0x34) {\n    uint DAT_080096e4 = 0xffffffff >> (shift_amount - 0x413 & 0xff);\n    if ((first_parameter & DAT_080096e4) != 0) {\n      uint carry = 1 << (0x33 - shifted_difference & 0xff);\n      if (CARRY4(first_parameter, carry) != false) {\n        second_parameter = second_parameter + 1;\n      }\n      result = CONCAT44(second_parameter, first_parameter + carry & ~DAT_080096e4);\n    }\n  }\n  else {\n    result = CONCAT44(second_parameter, first_parameter);\n    if (shifted_difference == 0x400) {\n      result = calculate_double_precision_080082d4();\n    }\n  }\n  return result;\n}",
            "called": [
                "FUN_080082d4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009654",
            "calling": [
                "FUN_08004e30"
            ],
            "imported": false,
            "current_name": "calculate_double_precision_08009654"
        },
        "FUN_08007bc2": {
            "renaming": {
                "FUN_08007bc2": "clear_flags_08007bc2",
                "_DAT_40000000": "PTR_DAT_40000000",
                "_DAT_4000000c": "PTR_DAT_4000000c"
            },
            "code": "void clear_flags_08007bc2(void)\n{\n  _DAT_40000000 = _DAT_40000000 & 0xfffffffe;\n  _DAT_4000000c = _DAT_4000000c & 0xfffffff8;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007bc2",
            "calling": [
                "FUN_080057e4"
            ],
            "imported": false,
            "current_name": "clear_flags_08007bc2"
        },
        "FUN_08009410": {
            "renaming": {
                "FUN_08009410": "calculate_new_value_08009410",
                "param_1": "val1",
                "param_2": "val2",
                "local_28": "val3",
                "uStack_24": "val4",
                "local_20": "flag",
                "DAT_080094b4": "PTR_DAT_080094b4",
                "DAT_080094b8": "PTR_DAT_080094b8",
                "uVar1": "result",
                "uVar2": "temp",
                "FUN_080082d0": "original_function",
                "FUN_08009d78": "some_other_function",
                "calculate_new_value_0800adf0": "calculate_new_value"
            },
            "code": "int calculate_new_value_08009410(int val1, int val2, int val3, int val4, int flag)\n{\n    int result;\n    if (DAT_080094b4 < (int)(val2 & 0x7fffffff)) {\n        if (DAT_080094b8 < (int)(val2 & 0x7fffffff)) {\n            result = original_function(val1, val2, val1, val2);\n        }\n        else {\n            int temp_result = some_other_function(val1, val2, &val3);\n            int temp = temp_result & 3;\n            if (temp == 1) {\n                result = calculate_new_value_08009410(val3, val4, val1, val2, 1);\n            }\n            else if (temp == 2 || temp == 0) {\n                result = some_third_function(val3, val4, val1, val2);\n            }\n            else {\n                result = calculate_new_value_08009410(val3, val4, val1, val2, 1);\n            }\n        }\n    }\n    else {\n        result = some_third_function(val1, val2, 0, 0);\n    }\n    return result;\n}",
            "called": [
                "FUN_080082d0",
                "FUN_0800a348",
                "FUN_08009d78",
                "FUN_0800adf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009410",
            "calling": [
                "FUN_08001f00"
            ],
            "imported": false,
            "current_name": "calculate_new_value_08009410"
        },
        "FUN_080035ec": {
            "renaming": {
                "FUN_080035ec": "store_params_in_memory_080035ec",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "PTR_DAT_08003614": "PTR_PARAMS"
            },
            "code": "void store_params_in_memory_080035ec(unsigned int param1, unsigned int param2, unsigned int param3) {\n  *(unsigned int *)PTR_DAT_08003614 = param1;\n  *(unsigned int *)(PTR_DAT_08003614 + sizeof(unsigned int)) = param2;\n  *(unsigned int *)(PTR_DAT_08003614 + 2 * sizeof(unsigned int)) = param3;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035ec",
            "calling": [
                "FUN_0800283a"
            ],
            "imported": false,
            "current_name": "store_params_in_memory_080035ec"
        },
        "FUN_08006c70": {
            "renaming": {
                "FUN_08006c70": "synchronize_data_08006c70",
                "PTR_data": "ptr_data",
                "DAT_08006c94": "data_address",
                "DAT_08006c98": "data_value",
                "uint": "unsigned int"
            },
            "code": "void synchronize_data_08006c70(void)\n{\n    DataSynchronizationBarrier(0xf);\n    uint* PTR_data = (uint*)(DAT_08006c94 + 0xc);\n    uint DAT_08006c98 = *PTR_data & 0x700;\n    *PTR_data = DAT_08006c98 | DAT_08006c98;\n    DataSynchronizationBarrier(0xf);\n    while(true) {\n        // Do nothing, infinite loop\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c70",
            "calling": [
                "FUN_08006d66"
            ],
            "imported": false,
            "current_name": "synchronize_data_08006c70"
        },
        "FUN_08006d98": {
            "renaming": {
                "FUN_08006d98": "extract_bits_from_param_08006d98",
                "param_1": "input_param",
                "param_2": "bit_position",
                "param_3": "num_bits_to_extract",
                "param_4": "destination",
                "uVar1": "extracted_value",
                "get_value_from_param_08006b54": "get_value_from_param",
                "extract_bits_08006c04": "extract_bits"
            },
            "code": "void extract_bits_from_param_08006d98(char input_param, int bit_position, int num_bits_to_extract, int destination) {\n  int extracted_value = get_value_from_param(input_param);\n  extract_bits(extracted_value, bit_position, num_bits_to_extract, destination);\n  return;\n}",
            "called": [
                "FUN_08006b54",
                "FUN_08006c04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d98",
            "calling": [],
            "imported": false,
            "current_name": "extract_bits_from_param_08006d98"
        },
        "FUN_08005a68": {
            "renaming": {
                "FUN_08005a68": "increment_ptr_dat_08005a80_08005a68",
                "PTR_DAT_08005a80": "PTR_DAT_08005a80",
                "int": "int",
                "*": "*",
                "ptr_dat_08005a80": "ptr_dat_08005a80"
            },
            "code": "void increment_ptr_dat_08005a80_08005a68(void)\n{\n  int *ptr_dat_08005a80 = (int *)PTR_DAT_08005a80;\n  *ptr_dat_08005a80 = *ptr_dat_08005a80 + 1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a68",
            "calling": [
                "FUN_08007756"
            ],
            "imported": false,
            "current_name": "increment_ptr_dat_08005a80_08005a68"
        },
        "FUN_080079c0": {
            "renaming": {
                "FUN_080079c0": "initialize_data_080079c0",
                "PTR_DAT_080079d8": "data_array",
                "PTR_DAT_080079dc": "data_flag",
                "fill_memory_with_value_0800b430": "fill_memory_with_value"
            },
            "code": "void initialize_data_080079c0()\n{\n  fill_memory_with_value(PTR_DAT_080079d8, 0, sizeof(PTR_DAT_080079d8));\n  *PTR_DAT_080079dc = 1;\n  return;\n}",
            "called": [
                "FUN_0800b430"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080079c0",
            "calling": [
                "FUN_08007540"
            ],
            "imported": false,
            "current_name": "initialize_data_080079c0"
        },
        "FUN_0800b2e0": {
            "renaming": {
                "FUN_0800b2e0": "returnZero_0800b2e0"
            },
            "code": "int returnZero_0800b2e0(void) {\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2e0",
            "calling": [
                "FUN_080098d0",
                "FUN_0800981c"
            ],
            "imported": false,
            "current_name": "returnZero_0800b2e0"
        },
        "FUN_08002908": {
            "renaming": {
                "FUN_08002908": "calculate_result_08002908",
                "param_1": "x",
                "param_2": "y",
                "param_3": "z",
                "param_4": "w",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "FUN_08008cdc": "calculate_1",
                "FUN_08008eec": "calculate_2",
                "FUN_08008cd8": "calculate_3",
                "FUN_08009054": "calculate_4"
            },
            "code": "float calculate_result_08002908(float x, float y, float z, float w)\n{\n    float result;\n    float temp1, temp2, temp3, temp4;\n    temp1 = calculate_1(z);\n    temp2 = calculate_2(temp1, w);\n    temp3 = calculate_2(x, x);\n    temp4 = calculate_3(temp2, temp3);\n    result = calculate_1(temp4, y);\n    return result;\n}",
            "called": [
                "FUN_08008cd8",
                "FUN_08009054",
                "FUN_08008cdc",
                "FUN_08008eec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002908",
            "calling": [
                "FUN_08002c18"
            ],
            "imported": false,
            "current_name": "calculate_result_08002908"
        },
        "FUN_08007c40": {
            "renaming": {
                "FUN_08007c40": "set_data_at_address_08007c40",
                "param_1": "address",
                "_DAT_40000034": "data"
            },
            "code": "void set_data_at_address_08007c40(void* address, int _DAT_40000034) {\n  *address = _DAT_40000034;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007c40",
            "calling": [
                "FUN_08005790"
            ],
            "imported": false,
            "current_name": "set_data_at_address_08007c40"
        },
        "FUN_080094c0": {
            "renaming": {
                "FUN_080094c0": "calculate_collision_080094c0",
                "param_1": "x",
                "param_2": "y",
                "param_3": "param_3",
                "param_4": "param_4",
                "iVar1": "collision_detected",
                "uVar2": "shift_amount_diff",
                "uVar3": "shifted_y",
                "bVar4": "carry_flag",
                "uVar5": "hash",
                "lVar6": "result",
                "DAT_080095a8": "constant1",
                "DAT_080095ac": "constant2",
                "DAT_080095b0": "mask_constant1",
                "DAT_080095b4": "mask_constant2",
                "isCollisionDetected_08008b60": "is_collision_detected",
                "FUN_080082d4": "hash_func"
            },
            "code": "long long calculate_collision_080094c0(uint x, uint y, undefined4 param_3, undefined4 param_4)\n{\n    int shift_amount = (y << 1) >> 0x15;\n    uint mask;\n    uint temp_x;\n    long long result;\n\n    if (shift_amount < 0x14)\n    {\n        if (shift_amount < 0)\n        {\n            uint64_t hash = hash_func(x, y, DAT_080095a8, DAT_080095ac, param_4);\n            bool collision_detected = is_collision_detected((int)hash, (int)(hash >> 0x20), 0, 0);\n            result = ((int)y < 0 && (x | y & 0x7fffffff) != 0) ? ((long long)DAT_080095b4 << 0x20) : 0;\n            if (!collision_detected)\n            {\n                result |= (uint64_t)x | (uint64_t)y << 0x20;\n            }\n        }\n        else\n        {\n            mask = DAT_080095b0 >> (shift_amount & 0xff);\n            temp_x = x | y & ~mask;\n            bool collision_detected = is_collision_detected((int)hash, (int)(hash >> 0x20), 0, 0);\n            result = ((int)y < 0) ? ((temp_x + (0x100000 >> (shift_amount & 0xff))) & mask) : temp_x;\n            result |= (uint64_t)y << 0x20;\n            if (collision_detected)\n            {\n                result &= ~mask;\n            }\n        }\n    }\n    else if (shift_amount < 0x34)\n    {\n        mask = 0xffffffff >> (shift_amount - 0x413 & 0xff);\n        bool collision_detected = is_collision_detected((int)hash, (int)(hash >> 0x20), 0, 0);\n        result = (collision_detected && (int)y < 0) ? ((shift_amount == 0x14) ? (uint64_t)(y + 1) << 0x20 : ((uint64_t)(1 << (0x34 - shift_amount & 0xff)) + x)) & ~mask : (uint64_t)x | (uint64_t)y << 0x20;\n    }\n    else\n    {\n        result = (shift_amount == 0x400) ? hash_func() : (uint64_t)x | (uint64_t)y << 0x20;\n    }\n    return result;\n}\n",
            "called": [
                "FUN_080082d4",
                "FUN_08008b60"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080094c0",
            "calling": [
                "FUN_0800a5a0",
                "FUN_08002408",
                "FUN_08001f00",
                "FUN_08002c18"
            ],
            "imported": false,
            "current_name": "calculate_collision_080094c0"
        },
        "FUN_08008eec": {
            "renaming": {
                "FUN_08008eec": "calculate_float_08008eec",
                "param_1": "float_a",
                "param_2": "float_b",
                "param_3": "arg_c",
                "param_4": "arg_d",
                "lVar1": "long_result",
                "uVar2": "result",
                "uVar3": "byte_a",
                "uVar6": "product",
                "uVar8": "sign_and_mantissa_a",
                "bVar9": "is_zero_or_one",
                "bVar10": "is_negative",
                "iVar4": "sum_of_bytes",
                "iVar5": "exponent_difference",
                "iVar7": "temp_var",
                "SBORROW4": "integer_subtraction_overflow",
                "SCARRY4": "integer_addition_overflow"
            },
            "code": "\nuint calculate_float_08008eec(uint float_a,uint float_b,undefined4 arg_c,uint arg_d)\n\n{\n  longlong long_result;\n  uint result;\n  uint byte_a;\n  int sum_of_bytes;\n  int exponent_difference;\n  uint product;\n  int temp_var;\n  uint sign_and_mantissa_a;\n  bool is_zero_or_one;\n  bool is_negative;\n  \n  byte_a = float_a >> 0x17 & 0xff;\n  is_zero_or_one = byte_a == 0;\n  if (!is_zero_or_one) {\n    arg_d = float_b >> 0x17 & 0xff;\n    is_zero_or_one = arg_d == 0;\n  }\n  if (!is_zero_or_one) {\n    is_zero_or_one = byte_a == 0xff;\n  }\n  if (!is_zero_or_one) {\n    is_zero_or_one = arg_d == 0xff;\n  }\n  if (is_zero_or_one) {\n    arg_d = float_b >> 0x17 & 0xff;\n    if (byte_a == 0xff || arg_d == 0xff) {\n      is_zero_or_one = float_a == 0 || float_a == 0x80000000;\n      result = float_b;\n      if (float_a != 0 && float_a != 0x80000000) {\n        is_zero_or_one = float_b == 0;\n        result = float_a;\n      }\n      if (!is_zero_or_one) {\n        is_zero_or_one = float_b == 0x80000000;\n      }\n      sign_and_mantissa_a = result;\n      if (((is_zero_or_one) || ((byte_a == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((arg_d == 0xff && (sign_and_mantissa_a = float_b, (float_b & 0x7fffff) != 0)))) {\n        return sign_and_mantissa_a | 0x7fc00000;\n      }\n      result = result ^ float_b;\n      goto LAB_0800903c;\n    }\n    is_zero_or_one = (float_a & 0x7fffffff) == 0;\n    if (!is_zero_or_one) {\n      is_zero_or_one = (float_b & 0x7fffffff) == 0;\n    }\n    if (is_zero_or_one) {\n      return (float_a ^ float_b) & 0x80000000;\n    }\n    is_zero_or_one = byte_a == 0;\n    result = float_a & 0x80000000;\n    while( true ) {\n      if (is_zero_or_one) {\n        float_a = float_a << 1;\n        is_zero_or_one = (float_a & 0x800000) == 0;\n      }\n      if (!is_zero_or_one) break;\n      byte_a = byte_a - 1;\n    }\n    float_a = float_a | result;\n    is_zero_or_one = arg_d == 0;\n    result = float_b & 0x80000000;\n    while( true ) {\n      if (is_zero_or_one) {\n        float_b = float_b << 1;\n        is_zero_or_one = (float_b & 0x800000) == 0;\n      }\n      if (!is_zero_or_one) break;\n      arg_d = arg_d - 1;\n    }\n    float_b = float_b | result;\n  }\n  sum_of_bytes = byte_a + arg_d;\n  sign_and_mantissa_a = float_a ^ float_b;\n  byte_a = float_a << 9;\n  is_zero_or_one = byte_a == 0;\n  if (!is_zero_or_one) {\n    float_b = float_b << 9;\n    is_zero_or_one = float_b == 0;\n  }\n  if (is_zero_or_one) {\n    if (byte_a == 0) {\n      float_b = float_b << 9;\n    }\n    result = sign_and_mantissa_a & 0x80000000 | float_a & 0x7fffff | float_b >> 9;\n    is_negative = integer_subtraction_overflow(sum_of_bytes,0x7f);\n    exponent_difference = sum_of_bytes + -0x7f;\n    is_zero_or_one = exponent_difference == 0;\n    temp_var = exponent_difference;\n    if (!is_zero_or_one && 0x7e < sum_of_bytes) {\n      is_negative = integer_subtraction_overflow(0xff,exponent_difference);\n      temp_var = 0xff - exponent_difference;\n      is_zero_or_one = exponent_difference == 0xff;\n    }\n    if (!is_zero_or_one && temp_var < 0 == is_negative) {\n      result = result | exponent_difference * 0x800000;\n    }\n    if (!is_zero_or_one && temp_var < 0 == is_negative) {\n      return result;\n    }\n    result = result | 0x800000;\n    product = 0;\n    is_negative = integer_subtraction_overflow(exponent_difference,1);\n    sign_and_mantissa_a = sum_of_bytes - 0x80;\n    is_zero_or_one = sign_and_mantissa_a == 0;\n    byte_a = sign_and_mantissa_a;\n  }\n  else {\n    long_result = (ulonglong)(byte_a >> 5 | 0x8000000) * (ulonglong)(float_b >> 5 | 0x8000000);\n    product = (uint)long_result;\n    result = (uint)((ulonglong)long_result >> 0x20);\n    is_zero_or_one = result < 0x800000;\n    if (is_zero_or_one) {\n      result = result << 1;\n    }\n    if (is_zero_or_one) {\n      result = result | product >> 0x1f;\n      product = product << 1;\n    }\n    result = sign_and_mantissa_a & 0x80000000 | result;\n    sign_and_mantissa_a = (sum_of_bytes + -0x7f) - (uint)is_zero_or_one;\n    is_negative = integer_subtraction_overflow(sign_and_mantissa_a,0xfd);\n    is_zero_or_one = sign_and_mantissa_a == 0xfd;\n    byte_a = sign_and_mantissa_a - 0xfd;\n    if (sign_and_mantissa_a < 0xfe) {\n      result = result + sign_and_mantissa_a * 0x800000 + (uint)(0x7fffffff < product);\n      if (product == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (is_zero_or_one || (int)byte_a < 0 != is_negative) {\n    is_zero_or_one = (int)(sign_and_mantissa_a + 0x19) < 0;\n    if (sign_and_mantissa_a == 0xffffffe7 || is_zero_or_one != integer_addition_overflow(sign_and_mantissa_a,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (sign_and_mantissa_a != 0xffffffe7 && is_zero_or_one == integer_addition_overflow(sign_and_mantissa_a,0x19)) {\n      byte_a = (result << 1) >> (-sign_and_mantissa_a & 0xff);\n      sign_and_mantissa_a = result << (sign_and_mantissa_a + 0x20 & 0xff);\n      byte_a = ((uint)((result & 0x80000000) != 0) << 0x1f | byte_a >> 1) + (uint)((byte)byte_a & 1);\n      if ((product | sign_and_mantissa_a << 1) == 0) {\n        byte_a = byte_a & ~(sign_and_mantissa_a >> 0x1f);\n      }\n      return byte_a;\n    }\n    return result;\n  }\nLAB_0800903c:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008eec",
            "calling": [
                "FUN_08003004",
                "FUN_08003618",
                "FUN_08002638",
                "FUN_08002978",
                "FUN_08004e30",
                "FUN_08001f00",
                "FUN_08002c18",
                "FUN_08001994",
                "FUN_08003826",
                "FUN_080005b4",
                "FUN_08002908",
                "FUN_080028bc",
                "FUN_080024c4",
                "FUN_08002408"
            ],
            "imported": false,
            "current_name": "calculate_float_08008eec"
        },
        "FUN_08006b54": {
            "renaming": {
                "FUN_08006b54": "get_value_from_param_08006b54",
                "param_1": "param",
                "bVar1": "value",
                "DAT_08006b98": "data_ptr_1",
                "DAT_08006b9c": "data_ptr_2"
            },
            "code": "byte get_value_from_param_08006b54(byte param) {\n  byte value;\n  if ((char)param < 0) {\n    value = *(byte *)((param & 0xf) + DAT_08006b98 + 0x14);\n  }\n  else {\n    value = *(byte *)((char)param + DAT_08006b9c + 0x300);\n  }\n  return value >> 4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b54",
            "calling": [
                "FUN_08006d98"
            ],
            "imported": false,
            "current_name": "get_value_from_param_08006b54"
        },
        "FUN_08007e84": {
            "renaming": {
                "FUN_08007e84": "get_dat_value_08007e84",
                "DAT_08007ea0": "DAT_OFFSET"
            },
            "code": "uint get_dat_value_08007e84(void)\n{\n    uint* data_pointer = (uint*)(DAT_08007ea0 + 4);\n    uint masked_value = *data_pointer & 0xff;\n    return masked_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e84",
            "calling": [
                "FUN_08008286"
            ],
            "imported": false,
            "current_name": "get_dat_value_08007e84"
        },
        "FUN_080057e4": {
            "renaming": {
                "FUN_080057e4": "check_flags_080057e4",
                "PTR_DAT_0800580c": "flag_array",
                "PTR_DAT_08005810": "flag_array",
                "clear_flags_08007bc2": "clear_flags",
                "do_nothing_0800530c": "do_nothing"
            },
            "code": "void check_flags_080057e4(void)\n{\n  clear_flags();\n  if ((PTR_DAT_0800580c[60] != -1) || ((PTR_DAT_0800580c[64] & 0x20) != 0)) {\n    do_nothing();\n  }\n  return;\n}",
            "called": [
                "FUN_08007bc2",
                "FUN_0800530c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080057e4",
            "calling": [
                "FUN_080025e8",
                "FUN_080053a0",
                "FUN_08001d4c",
                "FUN_0800583c"
            ],
            "imported": false,
            "current_name": "check_flags_080057e4"
        },
        "FUN_08006d8a": {
            "renaming": {
                "FUN_08006d8a": "get_bits_08006d8a",
                "uVar1": "bits",
                "get_bits_from_uint_08006998": "get_bits_from_uint"
            },
            "code": "uint32_t get_bits_08006d8a(void)\n{\n  uint32_t bits = get_bits_08006d8a_from_uint();\n  return bits;\n}",
            "called": [
                "FUN_08006998"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d8a",
            "calling": [],
            "imported": false,
            "current_name": "get_bits_08006d8a"
        },
        "FUN_0800b2e8": {
            "renaming": {
                "FUN_0800b2e8": "calculate_hash_0800b2e8",
                "param_1": "a",
                "param_2": "b",
                "param_3": "c",
                "param_4": "d",
                "uVar1": "hash_value",
                "iVar2": "sum",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "FUN_08008640": "calculate_hash_helper",
                "DAT_0800b3c8": "c1",
                "DAT_0800b3cc": "c2",
                "DAT_0800b3d8": "c3",
                "DAT_0800b3d0": "c4",
                "DAT_0800b3b8": "c5",
                "DAT_0800b3bc": "c6",
                "DAT_0800b3d4": "c7",
                "DAT_0800b3c0": "c8",
                "DAT_0800b3c4": "c9",
                "calculate_hash_helper": "calculate_hash_helper",
                "calculate_hash_special_case": "calculate_hash_special_case"
            },
            "code": "uint calculate_hash_0800b2e8(uint a, uint b, int c, undefined4 d) {\n  uint hash_value;\n  int sum;\n  uint temp1;\n  ulonglong temp2;\n  \n  temp2 = CONCAT44(b, a);\n  hash_value = (b << 1) >> 0x15;\n  if (hash_value == 0) {\n    if ((a | b & 0x7fffffff) == 0) {\n      return a;\n    }\n    temp2 = calculate_hash_0800b2e8_helper(a, b, DAT_0800b3DAT_0800b3c0);\n    if (c < DAT_0800b3cc) goto LAB_0800b34a;\n    sum = ((int)(temp2 >> 0x20) << 1) >> 0x15 - 0x36;\n  }\n  else if (hash_value == 0x7ff) {\n    hash_value = calculate_hash_0800b2e8_special_case(a, b, d);\n    return hash_value;\n  }\n  temp1 = (uint)(temp2 >> 0x20);\n  sum = hash_value + c;\n  if (sum < 0x7ff) {\n    if (0 < sum) {\n      return (uint)temp2;\n    }\n    if (sum + 0x35 < 0 == SCARRY4(sum,0x35)) {\n      hash_value = calculate_hash_0800b2e8_helper((uint)temp2,temp1 & 0x800fffff | (sum + 0x36) * 0x100000, DAT_0800b3d8);\n      return hash_value;\n    }\n    if (c < 0xDAT_0800b3d851) {\n      temp2 = temp2 & 0x8000000000000000 | (ulonglong)DAT_0800b3d0 | 0x1a56e1f00000000;\n      goto LAB_0800b34a;\n    }\n  }\n  hash_value = calculate_hash_0800b2e8_helper(DAT_0800b3d4,temp1 & 0x80000000 | 0x7e37e43c, DAT_0800b3c0);\n  return hash_value;\n}\n\nuint calculate_hash_0800b2e8_helper(uint a, uint b, uint c) {\n  uint hash_value;\n  int sum;\n  \n  sum = 0;\n  do {\n    hash_value = a * 0x5bd1e995 + b + c;\n    a = hash_value;\n    b = b * 0x5bd1e995 + 1;\n    sum = sum + -1;\n  } while (sum != 0);\n  return hash_value;\n}\n\nuint calculate_hash_0800b2e8_special_case(uint a, uint b, undefined4 c) {\n  uint hash_value;\n  \n  hash_value = calculate_hash_0800b2e8_helper(a, b, a, b, c);\n  return hash_value;\n}\n",
            "called": [
                "FUN_080082d4",
                "FUN_08008640"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2e8",
            "calling": [
                "FUN_0800a5a0"
            ],
            "imported": false,
            "current_name": "calculate_hash_0800b2e8"
        },
        "FUN_08005220": {
            "renaming": {
                "FUN_08005220": "do_nothing_08005220"
            },
            "code": "\nvoid do_nothing_08005220(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005220",
            "calling": [
                "FUN_0800525c"
            ],
            "imported": false,
            "current_name": "do_nothing_08005220"
        },
        "FUN_08007520": {
            "renaming": {
                "FUN_08007520": "set_bit_if_odd_08007520",
                "param_1": "input",
                "set_bit_in_short_array_080073d4": "set_bit_in_short_array"
            },
            "code": "void set_bit_if_odd_08007520(uint input) {\n  if ((input & 1) != 0) {\n    set_bit_in_short_array(0x3e);\n  }\n  return;\n}",
            "called": [
                "FUN_080073d4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007520",
            "calling": [
                "FUN_08007930"
            ],
            "imported": false,
            "current_name": "set_bit_if_odd_08007520"
        },
        "FUN_08007884": {
            "renaming": {
                "FUN_08007884": "get_bits_from_indexes_08007884",
                "iVar1": "first_bit",
                "iVar2": "second_bit",
                "iVar3": "third_bit",
                "iVar4": "fourth_bit",
                "iVar5": "fifth_bit",
                "uVar6": "zeroth_bit"
            },
            "code": "uint get_bits_from_indexes_08007884(void)\n{\n  int first_bit = get_bit_at_index_08007854(0x36);\n  int second_bit = get_bit_at_index_08007854(0x37);\n  int third_bit = get_bit_at_index_08007854(0x38);\n  int fourth_bit = get_bit_at_index_08007854(0x39);\n  int fifth_bit = get_bit_at_index_08007854(0xf);\n  uint zeroth_bit = get_bit_at_index_08007854(0);\n  return zeroth_bit | first_bit << 4 | second_bit << 3 | third_bit << 2 | fourth_bit << 1 | fifth_bit << 7;\n}",
            "called": [
                "FUN_08007854"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007884",
            "calling": [
                "FUN_08007930"
            ],
            "imported": false,
            "current_name": "get_bits_from_indexes_08007884"
        },
        "FUN_08004250": {
            "renaming": {
                "FUN_08004250": "printSettings_08004250",
                "PTR_DAT_08004470": "x_step_mm",
                "PTR_DAT_08004474": "settings",
                "PTR_s___x__step_mm___1__08004478": "s_x_step_mm",
                "PTR_s___y__step_mm___2__0800447c": "s_y_step_mm",
                "PTR_s___z__step_mm___3__08004480": "s_z_step_mm",
                "PTR_s___step_pulse__usec___4__08004484": "s_step_pulse_usec",
                "PTR_s___default_feed__mm_min___5__08004488": "s_default_feedrate",
                "PTR_s___default_seek__mm_min___6__0800448c": "s_default_seekrate",
                "PTR_s___step_port_invert_mask__int__08004490": "s_step_port_invert_mask",
                "PTR_s____7__08004494": "s_report_inches",
                "PTR_s___auto_start__bool___15__080044b8": "s_auto_start",
                "PTR_s___invert_step_enable__bool___16__080044bc": "s_invert_step_enable",
                "PTR_s___hard_limits__bool___17__080044c0": "s_hard_limits",
                "PTR_s___homing_cycle__bool___18__080044c4": "s_homing_cycle",
                "PTR_s___homing_dir_invert_mask__int__080044c8": "s_homing_dir_invert_mask",
                "PTR_s___homing_feed__mm_min___20__080044d0": "s_homing_feedrate",
                "PTR_s___homing_seek__mm_min___21__080044d4": "s_homing_seekrate",
                "PTR_s___homing_debounce__msec___22__080044d8": "s_homing_debounce_msec",
                "PTR_s___homing_pull_off__mm___23__080044dc": "s_homing_pull_off_distance",
                "PTR_s___dir_port_invert_mask__int__080044e0": "s_dir_port_invert_mask",
                "PTR_DAT_080044e4": "s_arc_tolerance",
                "print_decimal_number_08003826": "print_decimal_number",
                "print_bits_of_uint_0800375c": "print_bits_of_uint",
                "printAbsoluteValue_080037fc": "printAbsoluteValue",
                "processString_080036c6": "printString"
            },
            "code": "void printSettings_08004250(void)\n{\n  printString(\"X step/mm: \");\n  print_decimal_number(*(float *)PTR_DAT_08004470);\n  printString(\"\\r\\n\");\n  printString(\"Y step/mm: \");\n  print_decimal_number(*(float *)y_step_mm);\n  printString(\"\\r\\n\");\n  printString(\"Z step/mm: \");\n  print_decimal_number(*(float *)z_step_mm);\n  printString(\"\\r\\n\");\n  printString(\"Step pulse usec: \");\n  print_decimal_number(*(int *)step_pulse_usec);\n  printString(\"\\r\\n\");\n  printString(\"Default feedrate: \");\n  print_decimal_number(*(float *)default_feedrate);\n  printString(\"\\r\\n\");\n  printString(\"Default seek rate: \");\n  print_decimal_number(*(float *)default_seekrate);\n  printString(\"\\r\\n\");\n  printString(\"Step port invert mask: \");\n  print_bits_of_uint(*(int *)step_port_invert_mask);\n  printString(\"\\r\\n\");\n  printString(\"Report inches: \");\n  printAbsoluteValue((*(int *)report_inches) != 0);\n  printString(\"\\r\\n\");\n  printString(\"Auto start: \");\n  printAbsoluteValue((*(int *)auto_start) != 0);\n  printString(\"\\r\\n\");\n  printString(\"Invert step enable: \");\n  printAbsoluteValue((*(int *)invert_step_enable) != 0);\n  printString(\"\\r\\n\");\n  printString(\"Hard limits: \");\n  printAbsoluteValue((*(int *)hard_limits) != 0);\n  printString(\"\\r\\n\");\n  printString(\"Homing cycle: \");\n  printAbsoluteValue(*(int *)homing_cycle);\n  printString(\"\\r\\n\");\n  printString(\"Homing dir invert mask: \");\n  print_bits_of_uint(*(int *)homing_dir_invert_mask);\n  printString(\"\\r\\n\");\n  printString(\"Homing feedrate: \");\n  print_decimal_number(*(float *)homing_feedrate);\n  printString(\"\\r\\n\");\n  printString(\"Homing seekrate: \");\n  print_decimal_number(*(float *)homing_seekrate);\n  printString(\"\\r\\n\");\n  printString(\"Homing debounce msec: \");\n  print_decimal_number(*(int *)homing_debounce_msec);\n  printString(\"\\r\\n\");\n  printString(\"Homing pull-off distance: \");\n  printAbsoluteValue(*(float *)homing_pull_off_distance);\n  printString(\"\\r\\n\");\n  printString(\"Dir port invert mask: \");\n  print_bits_of_uint(*(int *)dir_port_invert_mask);\n  printString(\"\\r\\n\");\n  printString(\"Arc tolerance: \");\n  printAbsoluteValue(*(float *)arc_tolerance);\n  printString(\"\\r\\n\");\n  printString(\"N decimal places: \");\n  printAbsoluteValue(*(int *)n_decimal_places);\n  printString(\"\\r\\n\");\n}\n",
            "called": [
                "FUN_0800375c",
                "FUN_08003826",
                "FUN_080037fc",
                "FUN_08009054",
                "FUN_080036c6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004250",
            "calling": [
                "FUN_080051b4",
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "printSettings_08004250"
        },
        "FUN_08006dc4": {
            "renaming": {
                "FUN_08006dc4": "set_bit_in_array_08006dc4",
                "param_1": "character"
            },
            "code": "void set_bit_in_array_08006dc4(char character) {\n    set_bit_in_array_08006dc4_helper((int)character);\n}\n",
            "called": [
                "FUN_08006a58"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006dc4",
            "calling": [],
            "imported": false,
            "current_name": "set_bit_in_array_08006dc4"
        },
        "FUN_08007402": {
            "renaming": {
                "FUN_08007402": "set_bit_at_position_08007402",
                "param_1": "position",
                "short": "short",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void set_bit_at_position_08007402(uint position) {\n    uint shifted_position = position & 0xf;\n    uint array_index = (position >> 4) * 0x400 + 0x40020018;\n    short* array_ptr = (short*) array_index;\n    short bit_mask = (short)(1 << shifted_position);\n    *array_ptr = bit_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007402",
            "calling": [
                "FUN_080074c8"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_08007402"
        },
        "FUN_08002870": {
            "renaming": {
                "FUN_08002870": "increment_and_reset_08002870",
                "param_1": "input_char",
                "local_9": "incremented_char"
            },
            "code": "char increment_and_reset_08002870(char input_char) {\n    char incremented_char = input_char + 1;\n    if (incremented_char == 18) {\n        incremented_char = 0;\n    }\n    return incremented_char;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002870",
            "calling": [
                "FUN_08002ef0",
                "FUN_08002ba8",
                "FUN_08002e08",
                "FUN_08003004",
                "FUN_08002f40"
            ],
            "imported": false,
            "current_name": "increment_and_reset_08002870"
        },
        "FUN_08000210": {
            "renaming": {
                "FUN_08000210": "do_nothing_twice_08000210",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void do_nothing_twice_08000210(void)\n{\n  do_nothing_080001ec();\n  do_nothing_080001d4();\n  return;\n}",
            "called": [
                "FUN_080001d4",
                "FUN_080001ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000210",
            "calling": [
                "FUN_080025e8",
                "FUN_080001f8",
                "FUN_08000220"
            ],
            "imported": false,
            "current_name": "do_nothing_twice_08000210"
        },
        "FUN_08005900": {
            "renaming": {
                "FUN_08005900": "process_byte_08005900",
                "param_1": "input_byte",
                "PTR_DAT_08005978": "flag",
                "enable_flag_if_not_set_and_check_080025e8": "enable_flag"
            },
            "code": "int process_byte_08005900(byte input_byte)\n{\n    int PTR_DAT_08005978 = 0;\n\n    if (input_byte == 0x7e)\n    {\n        PTR_DAT_08005978 |= 2;\n    }\n    else if (input_byte == 0x3f)\n    {\n        PTR_DAT_08005978 |= 1;\n    }\n    else if (input_byte == 0x18)\n    {\n        enable_PTR_DAT_08005978_if_not_set_and_check_080025e8();\n        PTR_DAT_08005978 = 1;\n    }\n    else if (input_byte == 0x21)\n    {\n        PTR_DAT_08005978 |= 8;\n    }\n\n    return PTR_DAT_08005978;\n}",
            "called": [
                "FUN_080025e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005900",
            "calling": [
                "FUN_08008286"
            ],
            "imported": false,
            "current_name": "process_byte_08005900"
        },
        "FUN_08002638": {
            "renaming": {
                "FUN_08002638": "extract_integer_from_string_08002638",
                "param_1": "start",
                "param_2": "string",
                "param_3": "result",
                "bVar1": "current_digit",
                "bVar2": "is_negative",
                "bVar3": "is_decimal",
                "iVar4": "hash_exists",
                "pcVar5": "string_position",
                "pcVar6": "current_position",
                "uVar7": "return_value",
                "uVar8": "temp_value",
                "local_1c": "hash",
                "local_16": "digit_count",
                "local_15": "decimal_places",
                "local_14": "integer_value",
                "local_d": "current_char",
                "local_c": "current_position",
                "DAT_08002800": "magic_number_1",
                "DAT_08002804": "magic_number_2",
                "DAT_08002808": "magic_number_3",
                "DAT_0800280c": "magic_number_4",
                "DAT_08002810": "magic_number_5",
                "calculate_hash_08008e3c": "calculate_hash",
                "is_string_concatenated_08009214": "is_string_concatenated",
                "reverse_bits_08008590": "reverse_bits",
                "FUN_08008640": "calculate_float",
                "calculate_float_bits_08008c30": "calculate_float_bits",
                "FUN_08008eec": "update_hash"
            },
            "code": "uint32_t extract_integer_from_string_08002638(const uint32_t start, const char *string, uint32_t *result)\n{\n    char current_char;\n    bool is_negative = false;\n    bool is_decimal = false;\n    uint32_t integer_value = 0;\n    int8_t decimal_places = 0;\n    uint32_t string_index = start;\n    char *current_position = (char *)(start + (uint32_t)string);\n    current_char = *current_position;\n    if (current_char == '-') {\n        is_negative = true;\n        current_char = *(++current_position);\n        ++string_index;\n    }\n    else if (current_char == '+') {\n        current_char = *(++current_position);\n        ++string_index;\n    }\n    while (true) {\n        if ((current_char >= '0') && (current_char <= '9')) {\n            ++integer_value;\n            if (is_decimal) {\n                --decimal_places;\n            }\n            integer_value = (uint32_t)(current_char - '0') + integer_value * 10;\n            if (decimal_places < -1) {\n                break;\n            }\n        }\n        else {\n            if ((current_char == '.') && (!is_decimal)) {\n                is_decimal = true;\n            }\n            else {\n                break;\n            }\n        }\n        ++current_position;\n        ++string_index;\n        current_char = *current_position;\n    }\n    if (decimal_places == 0) {\n        *result = integer_value;\n    }\n    else {\n        uint32_t hash = calculate_hash_08008e3c(integer_value);\n        if (!is_string_concatenated_08009214(hash, 0)) {\n            while (decimal_places < -1) {\n                hash = calculate_float_bits_08008c30(calculate_product_08008640(reverse_bits_08008590(hash), reverse_bits_08008590(hash) >> 0x20, DAT_08002800, DAT_08002804), 0);\n                decimal_places += 2;\n            }\n            if (decimal_places == -1) {\n                hash = calculate_float_bits_08008c30(calculate_product_08008640(reverse_bits_08008590(hash), reverse_bits_08008590(hash) >> 0x20, DAT_08002808, DAT_0800280c), 0);\n            }\n            else {\n                while (decimal_places > 0) {\n                    hash = calculate_float_08008eec(hash, DAT_08002810);\n                    --decimal_places;\n                }\n            }\n        }\n        *result = is_negative ? (hash ^ 0x80000000) : hash;\n    }\n    return 1;\n}",
            "called": [
                "FUN_08008590",
                "FUN_08008c30",
                "FUN_08008640",
                "FUN_08009214",
                "FUN_08008e3c",
                "FUN_08008eec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002638",
            "calling": [
                "FUN_0800184c",
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "extract_integer_from_string_08002638"
        },
        "FUN_080051b4": {
            "renaming": {
                "FUN_080051b4": "validate_and_print_data_080051b4",
                "iVar1": "validation_result",
                "auStack_18": "data_buffer",
                "local_9": "index",
                "validate_data_08004dd2": "validate_data",
                "printErrorMessage_08004030": "print_error_message",
                "initialize_data_08004c48": "initialize_data",
                "printSettings_08004250": "print_settings",
                "is_sum_equal_to_last_value_and_fill_memory_with_value_08004d7c": "is_sum_equal_to_last_value_and_fill_memory"
            },
            "code": "void validate_and_print_data_080051b4() {\n  int validation_result;\n  undefined data_buffer [15];\n  byte index;\n  \n  validation_result = validate_data();\n  if (validation_result == 0) {\n    print_error_message(10);\n    initialize_data(1);\n    print_settings();\n  }\n  for (index = 0; index < 8; index = index + 1) {\n    validation_result = is_sum_equal_to_last_value_and_fill_memory(index, data_buffer);\n    if (validation_result == 0) {\n      print_error_message(10);\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_08004250",
                "FUN_08004c48",
                "FUN_08004d7c",
                "FUN_08004030",
                "FUN_08004dd2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080051b4",
            "calling": [
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "validate_and_print_data_080051b4"
        },
        "FUN_080098d0": {
            "renaming": {
                "FUN_080098d0": "calculate_collision_080098d0_080098d0",
                "param_1": "x",
                "param_2": "y",
                "cVar1": "input_char",
                "uVar2": "result",
                "local_50": "local_one",
                "local_4c": "local_pointer",
                "local_48": "local_x",
                "uStack_44": "local_y",
                "local_40": "local_x_copy",
                "uStack_3c": "local_y_copy",
                "local_38": "local_result",
                "local_30": "parameter_validity",
                "iVar3": "collision_detected",
                "zero": "zero_result",
                "puVar4": "pointer_to_local_result",
                "piVar5": "pointer_to_parameter_validity"
            },
            "code": "undefined4 calculate_collision_080098d0_080098d0(undefined4 x, undefined4 y)\n{\n  char input_char = *PTR_DAT_08009988;\n  undefined4 result = calculate_0800a1bc();\n  int parameter_validity = is_parameters_valid_08008b74(x, y, x, y);\n  int collision_detected = is_collision_not_detected_08008b24(x, y, 0, 0);\n  if (input_char == -1 || parameter_validity != 0 || collision_detected == 0)\n  {\n    return result;\n  }\n  undefined4 local_50 = 1;\n  undefined *local_4c = PTR_DAT_0800998c;\n  undefined4 local_48 = x;\n  undefined4 uStack_44 = y;\n  undefined4 local_40 = x;\n  undefined4 uStack_3c = y;\n  undefined8 local_38;\n  int zero = 0;\n  if (input_char == '\\0')\n  {\n    local_38 = 0;\n  }\n  else\n  {\n    local_38 = convert_float_to_uint_08008894(0, 0, 0, 0);\n    if (input_char == '\\x02')\n    {\n      goto LAB_0800996c;\n    }\n  }\n  int zero_result = returnZero_0800b2e0(&local_50);\n  if (zero_result != 0)\n  {\n    goto joined_r0x0800997a;\n  }\nLAB_0800996c:\n  undefined4 *puVar4 = (undefined4 *)get_value_from_pointer_to_pointer_0800b3dc();\n  *puVar4 = 0x21;\njoined_r0x0800997a:\n  if (parameter_validity != 0)\n  {\n    int *piVar5 = (int *)get_value_from_pointer_to_pointer_0800b3dc();\n    *piVar5 = parameter_validity;\n  }\n  return (undefined4)local_38;\n}",
            "called": [
                "FUN_08008b74",
                "FUN_0800a1bc",
                "FUN_08008b24",
                "FUN_0800b2e0",
                "FUN_08008894",
                "FUN_0800b3dc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080098d0",
            "calling": [
                "FUN_08001994",
                "FUN_080005b4",
                "FUN_08003004",
                "FUN_08002978"
            ],
            "imported": false,
            "current_name": "calculate_collision_080098d0_080098d0"
        },
        "FUN_08005c30": {
            "renaming": {
                "FUN_08005c30": "is_param_valid_08005c30",
                "param_1": "param",
                "bVar1": "is_valid",
                "DAT_08005c70": "ptr_to_dat"
            },
            "code": "bool is_param_valid_08005c30(int param){\n\tbool is_valid = param < 0x1000000;\n\tif (is_valid) {\n\t\tint* DAT_08005c70 = &DAT_08005c70[1];\n\t\t*DAT_08005c70 = param - 1;\n\t\tset_byte_in_memory_08005bdc(0xffffffff,0xf);\n\t\t*(DAT_08005c70 + 1) = 0;\n\t\t*DAT_08005c70 = 7;\n\t}\n\treturn !is_valid;\n}",
            "called": [
                "FUN_08005bdc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005c30",
            "calling": [
                "FUN_0800618c"
            ],
            "imported": false,
            "current_name": "is_param_valid_08005c30"
        },
        "FUN_0800b51c": {
            "renaming": {
                "FUN_0800b51c": "do_nothing_0800b51c"
            },
            "code": "\nvoid do_nothing_0800b51c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b51c",
            "calling": [
                "FUN_0800b524"
            ],
            "imported": false,
            "current_name": "do_nothing_0800b51c"
        },
        "FUN_0800056c": {
            "renaming": {
                "FUN_0800056c": "calculate_reversed_float_bits_0800056c",
                "param_1": "float_bits",
                "uVar1": "reversed_bits",
                "reverse_bits_08008590": "reverse_bits",
                "FUN_08008640": "apply_transform",
                "DAT_080005a8": "transform_constant_1",
                "DAT_080005ac": "transform_constant_2",
                "calculate_float_bits_08008c30": "calculate_float_bits"
            },
            "code": "float calculate_reversed_float_bits_0800056c(float float_bits) {\\n  if (PTR_DAT_080005b0[3] != \"\\0\") {\\n    float_bits = reverse_bits(float_bits);\\n    float_bits = apply_transform(float_bits, (int)((ulonglong)float_bits >> 0x20), DAT_080005a8, DAT_080005ac);\\n    float_bits = calculate_float_bits(float_bits, (int)((ulonglong)float_bits >> 0x20));\\n  }\\n  return float_bits;\\n}",
            "called": [
                "FUN_08008590",
                "FUN_08008c30",
                "FUN_08008640"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800056c",
            "calling": [
                "FUN_080005b4"
            ],
            "imported": false,
            "current_name": "calculate_reversed_float_bits_0800056c"
        },
        "FUN_08002f24": {
            "renaming": {
                "FUN_08002f24": "copy_and_reset_data_08002f24",
                "fill_memory_with_value_0800b430": "fill_memory_with_value",
                "PTR_DAT_08002f3c": "PTR_DATA"
            },
            "code": "void copy_and_reset_data_08002f24() {\n  copy_and_reset_data_08002f24_08002ef0();\n  fill_memory_with_value(PTR_DAT_08002f3c, 0, 0x1c);\n  return;\n}",
            "called": [
                "FUN_08002ef0",
                "FUN_0800b430"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f24",
            "calling": [
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "copy_and_reset_data_08002f24"
        },
        "FUN_0800981c": {
            "renaming": {
                "FUN_0800981c": "calculate_hypotenuse_0800981c",
                "param_1": "x1",
                "param_2": "x2",
                "param_3": "y1",
                "param_4": "y2",
                "cVar1": "hypotenuse_type",
                "puVar2": "hypotenuse_value_ptr",
                "iVar3": "shift_result",
                "puVar4": "hypotenuse_value_ptr",
                "piVar5": "hypotenuse_sign_bit",
                "uVar6": "result",
                "local_50": "shift_constant",
                "puStack_4c": "hypotenuse_value_ptr",
                "local_48": "x1",
                "uStack_44": "x2",
                "local_40": "y1",
                "uStack_3c": "y2",
                "local_38": "hypotenuse_sign_bit",
                "uStack_34": "hypotenuse_value",
                "local_30": "hypotenuse_sign_bit"
            },
            "code": "uint64_t calculate_hypotenuse_0800981c(uint32_t x1, uint32_t x2, uint32_t y1, uint32_t y2) {\n  char hypotenuse_type;\n  uint32_t *hypotenuse_value_ptr;\n  int shift_result;\n  uint32_t hypotenuse_value;\n  uint32_t shift_constant;\n  uint32_t hypotenuse_sign_bit;\n  uint64_t result;\n\n  hypotenuse_value_ptr = PTR_DAT_080098cc;\n  result = calculate_result_08009b24();\n  if (*hypotenuse_value_ptr == -1) {\n    return result;\n  }\n\n  hypotenuse_sign_bit = set_sign_bit_and_shift_right_0800b2d4();\n  if (hypotenuse_sign_bit != 0) {\n    return result;\n  }\n\n  shift_result = set_sign_bit_and_shift_right_0800b2d4(x1, x2);\n  if (shift_result == 0) {\n    return result;\n  }\n\n  shift_result = set_sign_bit_and_shift_right_0800b2d4(y1, y2);\n  if (shift_result == 0) {\n    return result;\n  }\n\n  hypotenuse_type = *hypotenuse_value_ptr;\n  shift_constant = 3;\n  hypotenuse_value_ptr = PTR_s_hypot_080098c0;\n\n  if (hypotenuse_type == '\\0') {\n    hypotenuse_sign_bit = 0xE0000000;\n    hypotenuse_value = DAT_080098c8;\n  }\n  else {\n    hypotenuse_sign_bit = 0;\n    hypotenuse_value = DAT_080098c4;\n    if (hypotenuse_type != '\\x02') {\n      goto end_calculation;\n    }\n  }\n\n  *(uint32_t *)get_value_from_pointer_to_pointer_0800b3dc() = 0x22;\n\n  end_calculation:\n  result = ((uint64_t)hypotenuse_value << 32) | hypotenuse_sign_bit;\n  if (hypotenuse_sign_bit != 0) {\n    *(int *)get_value_from_pointer_to_pointer_0800b3dc() = hypotenuse_sign_bit;\n    result = ((uint64_t)hypotenuse_value << 32) | hypotenuse_sign_bit;\n  }\n  return result;\n}",
            "called": [
                "FUN_0800b2d4",
                "FUN_0800b2e0",
                "FUN_0800b3dc",
                "FUN_08009b24"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800981c",
            "calling": [
                "FUN_080005b4",
                "FUN_08001f00"
            ],
            "imported": false,
            "current_name": "calculate_hypotenuse_0800981c"
        },
        "FUN_080059b4": {
            "renaming": {
                "FUN_080059b4": "set_flags_and_values_080059b4",
                "*DAT_080059f4": "data_ptr",
                "validate_and_return_param_08006d72": "validate_and_return_param",
                "update_register_value_08006ce0": "update_register_value",
                "do_nothing_08005a50": "do_nothing"
            },
            "code": "int set_flags_and_values_080059b4(void)\n{\n  int* *DAT_080059f4 = DAT_080059f4;\n  **DAT_080059f4 |= 0x200;\n  **DAT_080059f4 |= 0x400;\n  **DAT_080059f4 |= 0x100;\n  validate_and_return_param(16000);\n  update_register_value(3);\n  do_nothing();\n  return 0;\n}",
            "called": [
                "FUN_08005a50",
                "FUN_08006d72",
                "FUN_08006ce0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080059b4",
            "calling": [
                "FUN_08007540"
            ],
            "imported": false,
            "current_name": "set_flags_and_values_080059b4"
        },
        "FUN_08006c04": {
            "renaming": {
                "FUN_08006c04": "extract_bits_08006c04",
                "param_1": "input",
                "param_2": "shift_amount",
                "param_3": "high_bits",
                "param_4": "low_bits",
                "uVar1": "num_bits_remaining",
                "num_bits_to_extract": "num_bits_to_extract"
            },
            "code": "void extract_bits_08006c04(uint input,uint shift_amount,uint *high_bits,uint *low_bits)\n{\n  uint num_bits_to_extract;\n  uint num_bits_remaining;\n  shift_amount = shift_amount & 7;\n  num_bits_remaining = 7 - shift_amount;\n  if (num_bits_remaining > 3) {\n    num_bits_to_extract = 4;\n  }\n  else {\n    num_bits_to_extract = num_bits_remaining;\n  }\n  if (shift_amount + 4 < 7) {\n    shift_amount = 0;\n  }\n  else {\n    shift_amount = shift_amount - 3;\n  }\n  *high_bits = (1 << (num_bits_to_extract & 0xff)) - 1U & input >> (shift_amount & 0xff);\n  *low_bits = (1 << (shift_amount & 0xff)) - 1U & input;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c04",
            "calling": [
                "FUN_08006d98"
            ],
            "imported": false,
            "current_name": "extract_bits_08006c04"
        },
        "FUN_08002e08": {
            "renaming": {
                "FUN_08002e08": "calculate_collision_for_all_objects_08002e08",
                "PTR_DAT_08002ed0": "current_object_index_ptr",
                "PTR_DAT_08002ed8": "last_object_index_ptr",
                "PTR_DAT_08002ed4": "object_data_ptr",
                "increment_and_reset_08002870": "increment_and_reset",
                "calculate_collision_08002c18": "calculate_collision",
                "local_11": "current_object_index",
                "local_18": "previous_object_ptr"
            },
            "code": "void calculate_collision_for_all_objects_08002e08(void)\n{\n  uint8_t current_object_index = *PTR_DAT_08002ed0;\n  uint8_t previous_object_index = 0;\n  uint8_t *current_object_ptr = NULL;\n  uint8_t *previous_object_ptr = NULL;\n  \n  while (current_object_index != *PTR_DAT_08002ed8) {\n    current_object_ptr = PTR_DAT_08002ed4 + (uint)current_object_index * OBJECT_DATA_SIZE;\n    if ((previous_object_ptr != NULL) && ((previous_object_ptr[0x24] != 0 || (current_object_ptr[0x24] != 0)))) {\n      uint32_t current_object_parameter_1 = *(uint32_t *)(previous_object_ptr + 0x18);\n      uint32_t current_object_parameter_2 = *(uint32_t *)(previous_object_ptr + 0x14);\n      uint32_t current_object_parameter_3 = *(uint32_t *)(current_object_ptr + 0x18);\n      uint32_t current_object_parameter_4 = *(uint32_t *)(previous_object_ptr + 0x14);\n      uint32_t current_object_parameter_5 = *(uint32_t *)(current_object_ptr + 0x14);\n      calculate_collision(current_object_parameter_1, current_object_parameter_2, current_object_parameter_3, current_object_parameter_4, current_object_parameter_5);\n      previous_object_ptr[0x24] = 0;\n    }\n    current_object_index = increment_and_reset(current_object_index);\n    previous_object_ptr = current_object_ptr;\n  }\n  uint32_t current_object_parameter_1 = *(uint32_t *)(previous_object_ptr + 0x18);\n  uint32_t current_object_parameter_2 = *(uint32_t *)(previous_object_ptr + 0x14);\n  calculate_collision(current_object_parameter_1, current_object_parameter_2, 0, current_object_parameter_2, 0);\n  previous_object_ptr[0x24] = 0;\n  return;\n}",
            "called": [
                "FUN_08009054",
                "FUN_08002870",
                "FUN_08002c18"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e08",
            "calling": [
                "FUN_08002edc"
            ],
            "imported": false,
            "current_name": "calculate_collision_for_all_objects_08002e08"
        },
        "FUN_08006680": {
            "renaming": {
                "FUN_08006680": "get_shift_amount_08006680",
                "uVar1": "function_result",
                "uVar2": "leading_zero_count",
                "FUN_08006628": "get_function_result",
                "PTR_DAT_080066c8": "ptr_dat_080066c8",
                "DAT_080066c4": "dat_080066c4"
            },
            "code": "uint get_shift_amount_08006680(void)\n{\n  uint function_result;\n  uint leading_zero_count;\n  \n  function_result = get_function_result();\n  leading_zero_count = count_leading_zeroes(0x380000);\n  return function_result >> PTR_DAT_080066c8[(*(uint *)(DAT_080066c4 + 8) & 0x1c00) >> (leading_zero_count & 0xff)];\n}",
            "called": [
                "FUN_08006628"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006680",
            "calling": [
                "FUN_08007f54"
            ],
            "imported": false,
            "current_name": "get_shift_amount_08006680"
        },
        "FUN_08000340": {
            "renaming": {
                "FUN_08000340": "initializeMemoryAndSetValueTo255_08000340",
                "param_1": "index",
                "param_2": "value",
                "PTR_DAT_0800036c": "PTR_DATA_INITIALIZED",
                "initialize_memory_and_set_value_to_255_080002f0": "initializeMemoryAndSetValueTo255",
                "PTR_DAT_08000370": "PTR_DATA_MEMORY"
            },
            "code": "void initializeMemoryAndSetValueTo255_08000340(uint32_t index, uint8_t value) {\n  if (*(int *)PTR_DAT_0800036c == 0) {\n    initializeMemoryAndSetValueTo255_08000340(PTR_DAT_08000370_START);\n  }\n  PTR_DAT_08000370[index & 0x3ff] = value;\n  return;\n}",
            "called": [
                "FUN_080002f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000340",
            "calling": [
                "FUN_08000374",
                "FUN_08004c2a"
            ],
            "imported": false,
            "current_name": "initializeMemoryAndSetValueTo255_08000340"
        },
        "thunk_FUN_08009990": {
            "renaming": {
                "thunk_FUN_08009990": "calculate_thunk_08009990",
                "param_1": "x",
                "param_2": "y",
                "param_3": "z",
                "param_4": "w",
                "iVar1": "temp1",
                "uVar2": "result",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "uVar5": "temp4",
                "uVar6": "temp5"
            },
            "code": "uint calculate_thunk_08009990(uint x, uint y, uint z, uint w) {\n  int temp1;\n  uint result;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  temp6 = CONCAT44(DAT_08009b04,DAT_08009b00);\n  temp4 = w & 0x7fffffff;\n  if ((DAT_08009b18 < (temp4 | (-z | z) >> 0x1f)) || (temp5 = y & 0x7fffffff, DAT_08009b18 < (temp5 | (-x | x) >> 0x1f))) {\n    temp4 = calculate_double_precision_080082d4(z,w,x,y);\n  }\n  else {\n    if ((w + 0xc0100000 | z) == 0) {\n      temp4 = calculate_value_0800af78();\n      return temp4;\n    }\n    temp3 = (int)w >> 0x1e & 2U | y >> 0x1f;\n    if ((temp5 | x) == 0) {\n      temp4 = DAT_08009af0;\n      if ((temp3 != 2) && (temp4 = x, temp3 == 3)) {\n        temp4 = DAT_08009af8;\n      }\n    }\n    else {\n      if ((temp4 | z) != 0) {\n        if (temp4 == DAT_08009b18) {\n          temp3 = temp3 - 1;\n          if (temp5 == temp4) {\n            if (2 < temp3) {\n              return DAT_08009b10;\n            }\n            return *(uint *)(PTR_DAT_08009b20 + temp3 * 8);\n          }\n          if (temp3 < 3) {\n            return *(uint *)(PTR_DAT_08009b1c + temp3 * 8);\n          }\n          return 0;\n        }\n        if (temp5 != DAT_08009b18) {\n          temp1 = (int)(temp5 - temp4) >> 0x14;\n          if ((int)(temp5 - temp4) < 0x3d00000) {\n            if (((int)w < 0) && (temp1 + 0x3c < 0 != SCARRY4(temp1,0x3c))) {\n              temp6 = 0;\n            }\n            else {\n              convert_float_to_uint_08008894(x,y,z,w,w);\n              do_nothing_0800b2cc();\n              temp6 = calculate_value_0800af78();\n            }\n          }\n          temp2 = (uint)temp6;\n          result = (uint)((ulonglong)temp6 >> 0x20);\n          if (temp3 == 1) {\n            return temp2;\n          }\n          if (temp3 == 2) {\n            temp6 = reverse_and_improve_080082d0(temp2,result,DAT_08009ae8,DAT_08009aec);\n            temp2 = reverse_and_improve_080082d0(DAT_08009af0,DAT_08009af4,(int)temp6,(int)((ulonglong)temp6 >> 0x20));\n            return temp2;\n          }\n          if (temp3 == 0) {\n            return temp2;\n          }\n          temp6 = reverse_and_improve_080082d0(temp2,result,DAT_08009ae8,DAT_08009aec);\n          temp2 = reverse_and_improve_080082d0((int)temp6,(int)((ulonglong)temp6 >> 0x20),DAT_08009af0,DAT_08009af4);\n          return temp2;\n        }\n      }\n      temp4 = DAT_08009b08;\n      if (-1 < (int)y) {\n        temp4 = DAT_08009b00;\n      }\n    }\n  }\n  return temp4;\n}",
            "called": [
                "FUN_08009990"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009818",
            "calling": [
                "FUN_08001f00"
            ],
            "imported": false,
            "current_name": "calculate_thunk_08009990"
        },
        "FUN_08004bf4": {
            "renaming": {
                "FUN_08004bf4": "calculate_checksum_08004bf4",
                "param_1": "data",
                "param_2": "checksum",
                "storeChecksum_08000374": "store_checksum",
                "ushort": "uint16_t"
            },
            "code": "void calculate_checksum_08004bf4(byte data, uint32_t checksum) {\n    uint16_t sum = (uint16_t)data * 0xd + 0x200;\n    store_checksum(sum, checksum, 0xc);\n    return;\n}",
            "called": [
                "FUN_08000374"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004bf4",
            "calling": [
                "FUN_080005b4",
                "FUN_08004d7c"
            ],
            "imported": false,
            "current_name": "calculate_checksum_08004bf4"
        },
        "FUN_08004d7c": {
            "renaming": {
                "FUN_08004d7c": "is_sum_equal_to_last_value_and_fill_memory_with_value_08004d7c",
                "param_1": "input_byte",
                "param_2": "memory_address",
                "iVar1": "is_sum_equal"
            },
            "code": "bool is_sum_equal_to_last_value_and_fill_memory_with_value_08004d7c(byte input_byte, undefined4 memory_address){\n    int is_sum_equal = is_sum_equal_to_last_value_080003ec(memory_address, (ushort)input_byte * 0xd + 0x200, 0xc);\n    if (is_sum_equal == 0) {\n        fill_memory_with_value_0800b430(memory_address, 0, 0xc);\n        calculate_checksum_08004bf4(input_byte, memory_address);\n    }\n    return is_sum_equal != 0;\n}",
            "called": [
                "FUN_08004bf4",
                "FUN_0800b430",
                "FUN_080003ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d7c",
            "calling": [
                "FUN_080005b4",
                "FUN_080004ac",
                "FUN_080051b4",
                "FUN_080044e8"
            ],
            "imported": false,
            "current_name": "is_sum_equal_to_last_value_and_fill_memory_with_value_08004d7c"
        },
        "FUN_08009278": {
            "renaming": {
                "FUN_08009278": "calculate_value_08009278",
                "param_1": "inputValue",
                "uVar1": "shiftedValueMSB",
                "uVar2": "difference",
                "uVar3": "shiftedOutputValue",
                "uVar4": "outputValue"
            },
            "code": "uint calculate_value_08009278(uint inputValue)\n{\n  uint shiftedValue = inputValue << 1;\n  uint shiftedValueMSB = shiftedValue >> 0x18;\n  uint difference = 0x9e - shiftedValueMSB;\n  uint outputValue;\n  if (shiftedValue < 0x7f000000)\n  {\n    outputValue = 0;\n  }\n  else if ((shiftedValueMSB < 0x9f) && (difference != 0))\n  {\n    uint shiftedOutputValue = (inputValue << 8 | 0x80000000) >> (difference & 0xff);\n    if ((inputValue & 0x80000000) != 0)\n    {\n      outputValue = -shiftedOutputValue;\n    }\n    else\n    {\n      outputValue = shiftedOutputValue;\n    }\n  }\n  else if ((difference == 0xffffff9f) && ((inputValue & 0x7fffff) != 0))\n  {\n    outputValue = 0;\n  }\n  else\n  {\n    if ((inputValue & 0x80000000) == 0)\n    {\n      outputValue = 0x7fffffff;\n    }\n    else\n    {\n      outputValue = inputValue;\n    }\n  }\n  return outputValue;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009278",
            "calling": [
                "FUN_08003826",
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "calculate_value_08009278"
        },
        "FUN_080004fc": {
            "renaming": {
                "FUN_080004fc": "convert_and_store_fixed_point_values_080004fc",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "uVar1": "fixed_point_value",
                "PTR_DAT_08000564": "data_pointer1",
                "PTR_DAT_08000568": "data_pointer2",
                "convert_to_fixed_point_08008e44": "convert_to_fixed_point",
                "FUN_08009054": "calculate_fixed_point_value"
            },
            "code": "void convert_and_store_fixed_point_values_080004fc(float param1, float param2, float param3) {\n    float fixed_point_value1 = convert_to_fixed_point(param1);\n    float fixed_point_value2 = convert_to_fixed_point(param2);\n    float fixed_point_value3 = convert_to_fixed_point(param3);\n    *(float *)(PTR_DAT_08000568 + 0xc) = float_bits_to_float_08009054(fixed_point_value1, *(float *)PTR_DAT_08000564);\n    *(float *)(PTR_DAT_08000568 + 0x10) = float_bits_to_float_08009054(fixed_point_value2, *(float *)(PTR_DAT_08000564 + 4));\n    *(float *)(PTR_DAT_08000568 + 0x14) = float_bits_to_float_08009054(fixed_point_value3, *(float *)(PTR_DAT_08000564 + 8));\n}",
            "called": [
                "FUN_08008e44",
                "FUN_08009054"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004fc",
            "calling": [
                "FUN_0800283a"
            ],
            "imported": false,
            "current_name": "convert_and_store_fixed_point_values_080004fc"
        },
        "FUN_08000220": {
            "renaming": {
                "FUN_08000220": "process_input_and_update_state_08000220",
                "param_1": "input",
                "*PTR_DAT_08000264": "*current_input_ptr",
                "process_until_alarm_or_exit_08002fd4": "process_until_alarm_or_exit",
                "'\\x01'": "'\\x01' (represents first input)",
                "do_nothing_080001c8": "do_nothing_on_first_input",
                "'\\x02'": "'\\x02' (represents second input)",
                "do_nothing_080001e0": "do_nothing_on_second_input",
                "do_nothing_twice_08000210": "do_nothing_on_other_inputs"
            },
            "code": "void process_input_and_update_state_08000220(char input) {\n  if (input != *PTR_DAT_08000264) {\n    process_until_alarm_or_exit_08002fd4();\n    if (input == '\\x01') {\n      do_nothing_on_first_input_080001c8();\n    }\n    else if (input == '\\x02') {\n      do_nothing_on_second_input_080001e0();\n    }\n    else {\n      do_nothing_on_other_inputs_08000210();\n    }\n    *PTR_DAT_08000264 = input;\n  }\n  return;\n}",
            "called": [
                "FUN_08002fd4",
                "FUN_080001c8",
                "FUN_08000210",
                "FUN_080001e0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000220",
            "calling": [
                "FUN_080005b4"
            ],
            "imported": false,
            "current_name": "process_input_and_update_state_08000220"
        },
        "FUN_08005238": {
            "renaming": {
                "FUN_08005238": "clear_data_08005238",
                "*PTR_DAT_0800524c": "data_pointer",
                "do_nothing_and_return_08005250": "do_nothing"
            },
            "code": "void clear_data_08005238()\n{\n  **PTR_DAT_0800524c = 0;\n  do_nothing();\n  return;\n}",
            "called": [
                "FUN_08005250"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005238",
            "calling": [
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "clear_data_08005238"
        },
        "FUN_08007da8": {
            "renaming": {
                "FUN_08007da8": "set_flag_and_toggle_bit_08007da8",
                "puVar1": "flag_ptr"
            },
            "code": "void set_flag_and_toggle_bit_08007da8(void)\n{\n  uint *flag_ptr;\n  flag_ptr = DAT_08007dd4;\n  DAT_08007dd4[8] |= 0x10;\n  *flag_ptr |= 1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007da8",
            "calling": [
                "FUN_08007e08"
            ],
            "imported": false,
            "current_name": "set_flag_and_toggle_bit_08007da8"
        },
        "FUN_08004148": {
            "renaming": {
                "FUN_08004148": "displayAlarmMessage_08004148",
                "param_1": "alarmType",
                "PTR_s_ALARM__08004190": "ALARM_MESSAGE",
                "PTR_s_Abort_during_cycle_08004198": "ABORT_CYCLE_MESSAGE",
                "PTR_s_Hard_limit_08004194": "HARD_LIMIT_MESSAGE",
                "PTR_s___MPos__0800419c": "MPOS_MESSAGE",
                "do_nothing_08002814": "delayMilliseconds"
            },
            "code": "void displayAlarmMessage_08004148(char alarmType)\n{\n    displayMessage(\"ALARM:\");\n    if (alarmType == -2)\n    {\n        displayMessage(\"Abort during cycle\");\n    }\n    else if (alarmType == -1)\n    {\n        displayMessage(\"Hard limit\");\n    }\n    displayMessage(\"MPos:\");\n    delayMilliseconds(500);\n    return;\n}",
            "called": [
                "FUN_08002814",
                "FUN_080036c6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004148",
            "calling": [
                "FUN_08003a74"
            ],
            "imported": false,
            "current_name": "displayAlarmMessage_08004148"
        },
        "FUN_08004940": {
            "renaming": {
                "FUN_08004940": "process_data_08004940",
                "uVar1": "float_num",
                "uVar2": "index",
                "uVar3": "temp",
                "uVar4": "reversed_bits",
                "uVar5": "temp1",
                "auStack_2c": "stack_arr",
                "local_11": "local_byte",
                "PTR_DAT_08004b88": "data_ptr",
                "PTR_DAT_08004bac": "config_ptr",
                "PTR_DAT_08004bb8": "temp_ptr",
                "PTR_DAT_08004ba8": "string_ptr_1",
                "PTR_DAT_08004bb0": "string_ptr_2",
                "PTR_s_WPos__08004bb4": "string_ptr_3",
                "PTR_DAT_08004bbc": "string_ptr_4",
                "convert_to_fixed_point_08008e44": "convert_to_fixed_point",
                "FUN_08009054": "calculate_fixed_point",
                "calculate_float_bits_08008c30": "calculate_fixed_point_from_float",
                "reverse_bits_08008590": "reverse_bits",
                "FUN_08008640": "calculate_reversed_bits",
                "print_decimal_number_08003826": "print_decimal_number",
                "FUN_08008cdc": "calculate_fixed_point_division",
                "FUN_08008cd8": "calculate_fixed_point_multiplication",
                "FUN_080082d0": "calculate_fixed_point_addition"
            },
            "code": "void process_data_08004940(void)\n{\n  uint index;\n  float fixed_point_num;\n  uint8_t byte_val;\n  float stack_arr[6];\n  uint8_t local_byte;\n  stack_arr[3] = *(float *)(PTR_DAT_08004b88 + 4);\n  stack_arr[4] = *(float *)(PTR_DAT_08004b88 + 8);\n  stack_arr[5] = *(float *)(PTR_DAT_08004b88 + 0xc);\n  if ((uint8_t)PTR_DAT_08004b88[1] < 8) {\n    (*(code *)(&switchD_0800495e::switchdataD_08004964)[(uint8_t)PTR_DAT_08004b88[1]])();\n    return;\n  }\n  process_string(PTR_s__MPos__08004ba8);\n  for (index = 0; index < 3; index++) {\n    fixed_point_num = convert_to_fixed_point(stack_arr[index + 3]);\n    fixed_point_num = calculate_fixed_point(fixed_point_num,*(float *)(PTR_DAT_08004bac + index * 4));\n    stack_arr[index] = fixed_point_num;\n    if ((PTR_DAT_08004bac[0x28] & 1) != 0) {\n      float reversed_bits = reverse_bits(stack_arr[index]);\n      reversed_bits = calculate_reversed_bits((int)reversed_bits,(int)((unsigned long long)reversed_bits >> 0x20),DAT_08004b80,DAT_08004b84);\n      fixed_point_num = calculate_fixed_point_from_float((int)reversed_bits,(int)((unsigned long long)reversed_bits >> 0x20));\n      stack_arr[index] = fixed_point_num;\n    }\n    print_decimal_number(stack_arr[index]);\n    process_string(PTR_DAT_08004bb0);\n  }\n  process_string(PTR_s_WPos__08004bb4);\n  for (index = 0; index < 3; index++) {\n    if ((PTR_DAT_08004bac[0x28] & 1) == 0) {\n      float temp = stack_arr[index];\n      fixed_point_num = calculate_fixed_point(calculate_float_08008cdc(*(float *)(PTR_DAT_08004bb8 + (index + 8) * 4), *(float *)(PTR_DAT_08004bb8 + (index + 10) * 4 + 4)),temp);\n      stack_arr[index] = fixed_point_num;\n    }\n    else {\n      float reversed_bits = reverse_bits(stack_arr[index]);\n      float temp1 = calculate_float_08008cdc(*(float *)(PTR_DAT_08004bb8 + (index + 8) * 4),*(float *)(PTR_DAT_08004bb8 + (index + 10) * 4 + 4));\n      float reversed_temp1 = reverse_bits(temp1);\n      reversed_temp1 = calculate_reversed_bits((int)reversed_temp1,(int)((unsigned long long)reversed_temp1 >> 0x20),DAT_08004b80,DAT_08004b84);\n      float temp2 = calculate_fixed_point((int)reversed_bits,(int)((unsigned long long)reversed_bits >> 0x20));\n      fixed_point_num = calculate_fixed_point(reverse_and_improve_080082d0((int)reversed_bits,(int)((unsigned long long)reversed_bits >> 0x20),(int)reversed_temp1,(int)((unsigned long long)reversed_temp1 >> 0x20)),temp2);\n      stack_arr[index] = fixed_point_num;\n    }\n    print_decimal_number(stack_arr[index]);\n    if (index < 2) {\n      process_string(PTR_DAT_08004bb0);\n    }\n  }\n  process_string(PTR_DAT_08004bbc);\n  return;\n}\n",
            "called": [
                "FUN_080082d0",
                "FUN_08008590",
                "FUN_08008c30",
                "FUN_08008e44",
                "FUN_08003826",
                "FUN_08008640",
                "FUN_08008cd8",
                "FUN_08009054",
                "FUN_08008cdc",
                "FUN_080036c6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004940",
            "calling": [
                "FUN_08003a74"
            ],
            "imported": false,
            "current_name": "process_data_08004940"
        },
        "FUN_08008a74": {
            "renaming": {
                "FUN_08008a74": "check_collision_08008a74",
                "param_1": "x1",
                "param_2": "y1",
                "param_3": "x2",
                "param_4": "y2",
                "uVar1": "x_diff",
                "bVar2": "x_overlap",
                "bVar3": "y_aligned"
            },
            "code": "uint check_collision_08008a74(uint x1, uint y1, uint x2, uint y2) {\n  bool x_overlap = (x1 | x2 << 1) == 0;\n  bool y_overlap = (y1 | y2 << 1) == 0;\n  if (x_overlap && y_overlap) {\n    return 1;\n  }\n  bool same_x = x1 == x2;\n  bool same_y = y1 == y2;\n  if (!same_x && !same_y) {\n    uint x_diff = x1 ^ x2;\n    bool x_aligned = x_diff == 0 || (int)x_diff > 0 && x2 <= x1;\n    uint y_diff = y1 ^ y2;\n    bool y_aligned = y_diff == 0 || (int)y_diff > 0 && y2 <= y1;\n    if (x_aligned && y_aligned) {\n      return 1;\n    }\n    uint y_overlap = (int)y_diff >> 0x1f;\n    if (!y_aligned) {\n      y_overlap = ~y_overlap;\n    }\n    return y_overlap | 1;\n  }\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a74",
            "calling": [
                "FUN_08008b00"
            ],
            "imported": false,
            "current_name": "check_collision_08008a74"
        },
        "FUN_08002fd4": {
            "renaming": {
                "FUN_08002fd4": "process_until_alarm_or_exit_08002fd4",
                "iVar1": "value",
                "get_value_if_not_equal_08002f74": "get_value_if_not_equal",
                "process_alarm_08003a74": "process_alarm",
                "*PTR_DAT_08003000": "PTR_DAT_08003000"
            },
            "code": "void process_until_alarm_or_exit_08002fd4() {\\n  int value;\\n  while ((value = get_value_if_not_equal(), value != 0 || (*PTR_DAT_08003000[1] == \"\\x03\"))) {\\n    process_alarm();\\n    if (**PTR_DAT_08003000 != \"\\0\") {\\n      return;\\n    }\\n  }\\n  return;\\n}",
            "called": [
                "FUN_08002f74",
                "FUN_08003a74"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fd4",
            "calling": [
                "FUN_0800525c",
                "FUN_080005b4",
                "FUN_08000220",
                "FUN_080024c4",
                "FUN_08002408"
            ],
            "imported": false,
            "current_name": "process_until_alarm_or_exit_08002fd4"
        },
        "FUN_08002408": {
            "renaming": {
                "FUN_08002408": "process_data_08002408",
                "param_1": "data",
                "uVar1": "shift_amount",
                "uVar2": "processed_data",
                "uVar3": "fixed_point_value",
                "uVar4": "reversed_data",
                "local_12": "shift_amount",
                "FUN_08008eec": "FUN_get_processed_data",
                "DAT_080024b8": "CONST_processing_constant_1",
                "reverse_bits_08008590": "reverse_bits",
                "calculate_collision_080094c0": "calculate_collision",
                "calculate_shift_amount_08008bf0": "calculate_shift_amount",
                "process_until_alarm_or_exit_08002fd4": "process_until_alarm_or_exit",
                "DAT_080024bc": "CONST_processing_constant_2",
                "convert_to_fixed_point_08008e44": "convert_to_fixed_point",
                "FUN_08008cd8": "FUN_multiply_fixed_point",
                "do_nothing_08002814": "do_nothing",
                "process_alarm_08003a74": "process_alarm",
                "PTR_DAT_080024c0": "CONST_alarm_flag",
                "check_parameter_range_080002a0": "check_parameter_range",
                "0x32": "CONST_parameter_range"
            },
            "code": "void process_data_08002408(unsigned int data)\n{\n    unsigned int processed_data;\n    unsigned long long reversed_data;\n    unsigned short shift_amount;\n    \n    processed_data = FUN_get_processed_data(data, DAT_080024b8);\n    reversed_data = reverse_bits(processed_data);\n    reversed_data = calculate_collision(reversed_data & 0xFFFFFFFF, reversed_data >> 32);\n    shift_amount = calculate_shift_amount(reversed_data & 0xFFFFFFFF, reversed_data >> 32);\n    \n    process_until_alarm_or_exit();\n    \n    processed_data = FUN_get_processed_data(data, DAT_080024bc);\n    shift_amount = (unsigned short)(calculate_shift_amount(reverse_bits(processed_data & 0xFFFFFFFF)));\n    do_nothing(shift_amount);\n    \n    while (shift_amount != 0 && process_alarm()) {\n        check_parameter_range(CONST_parameter_range);\n        shift_amount--;\n    }\n}",
            "called": [
                "FUN_080094c0",
                "FUN_080002a0",
                "FUN_08008590",
                "FUN_08002fd4",
                "FUN_08008e44",
                "FUN_08008bf0",
                "FUN_08008cd8",
                "FUN_08002814",
                "FUN_08008eec",
                "FUN_08003a74"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002408",
            "calling": [
                "FUN_080005b4"
            ],
            "imported": false,
            "current_name": "process_data_08002408"
        },
        "FUN_08002a94": {
            "renaming": {
                "FUN_08002a94": "concatenate_strings_from_array_08002a94",
                "*PTR_DAT_08002af0": "*string_array_start",
                "*PTR_DAT_08002af8": "*string_array_end",
                "local_18": "current_string",
                "local_14": "previous_string",
                "local_9": "current_index",
                "PTR_DAT_08002af4": "string_array_start"
            },
            "code": "void concatenate_strings_from_array_08002a94(void)\n{\n    undefined *current_string = (undefined *)0x0;\n    undefined *previous_string = (undefined *)0x0;\n    byte current_index = *PTR_DAT_08002af0;\n\n    while (current_index != *PTR_DAT_08002af8) {\n        current_index = replace_null_with_0x12(current_index);\n        previous_string = current_string;\n        current_string = PTR_DAT_08002af4 + (uint)current_index * 0x40;\n        concatenate_strings(current_string, previous_string);\n    }\n    return;\n}",
            "called": [
                "FUN_08002896",
                "FUN_080029d8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a94",
            "calling": [
                "FUN_08002edc"
            ],
            "imported": false,
            "current_name": "concatenate_strings_from_array_08002a94"
        },
        "FUN_08003618": {
            "renaming": {
                "FUN_08003618": "calculate_collisions_and_concatenate_strings_08003618",
                "param_1": "input",
                "PTR_DAT_08003698": "data_ptr",
                "PTR_DAT_08003694": "index_ptr",
                "uVar3": "fixed_input",
                "uVar4": "intermediate_result",
                "bVar1": "index",
                "convert_to_fixed_point_08008e44": "convert_to_fixed_point",
                "FUN_08008eec": "multiply_fixed_point",
                "FUN_08009054": "add_fixed_point"
            },
            "code": "void calculate_collisions_and_concatenate_strings_08003618(undefined4 input)\n{\n  byte index = *PTR_DAT_08003694;\n  undefined *PTR_DAT_08003698 = PTR_DAT_08003698;\n  undefined4 fixed_input = convert_to_fixed_point(input);\n  undefined4 intermediate_result = multiply_fixed_point(fixed_input, *(undefined4 *)(PTR_DAT_08003698 + (uint)index * 0x40 + 0x20));\n  undefined4 fixed_data = convert_to_fixed_point(*(undefined4 *)(PTR_DAT_08003698 + (uint)index * 0x40 + 0x10));\n  intermediate_result = add_fixed_point(intermediate_result, fixed_data);\n  *(undefined4 *)(PTR_DAT_08003698 + (uint)index * 0x40 + 0x20) = intermediate_result;\n  *(undefined4 *)(PTR_DAT_08003698 + (uint)index * 0x40 + 0x10) = input;\n  *(undefined4 *)(PTR_DAT_08003698 + (uint)index * 0x40 + 0x18) = 0;\n  *(undefined4 *)(PTR_DAT_08003698 + (uint)index * 0x40 + 0x1c) = 0;\n  PTR_DAT_08003698[(uint)index * 0x40 + 0x25] = 0;\n  PTR_DAT_08003698[(uint)index * 0x40 + 0x24] = 1;\n  concatenate_all_strings_and_calculate_collisions();\n  return;\n}",
            "called": [
                "FUN_08008e44",
                "FUN_08009054",
                "FUN_08002edc",
                "FUN_08008eec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003618",
            "calling": [
                "FUN_080058a0"
            ],
            "imported": false,
            "current_name": "calculate_collisions_and_concatenate_strings_08003618"
        },
        "FUN_0800522c": {
            "renaming": {
                "FUN_0800522c": "do_nothing_0800522c"
            },
            "code": "\nvoid do_nothing_0800522c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800522c",
            "calling": [
                "FUN_0800525c"
            ],
            "imported": false,
            "current_name": "do_nothing_0800522c"
        },
        "FUN_0800af78": {
            "renaming": {
                "FUN_0800af78": "calculate_value_0800af78",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "puVar1": "undefined_pointer",
                "iVar2": "result",
                "uVar3": "calculation_result_1",
                "uVar4": "calculation_result_2",
                "uVar5": "calculation_result_3",
                "uVar6": "calculation_result_4",
                "uVar7": "calculation_result_5",
                "uVar8": "unsigned_input_value_2",
                "uVar9": "calculation_result_6",
                "uVar10": "calculation_result_7",
                "local_2c": "local_variable"
            },
            "code": "\nint calculate_value_0800af78(int input_value_1,uint input_value_2)\n\n{\n  undefined *undefined_pointer;\n  int result;\n  undefined4 calculation_result_1;\n  undefined4 calculation_result_2;\n  undefined4 calculation_result_3;\n  undefined4 calculation_result_4;\n  undefined4 calculation_result_5;\n  uint unsigned_input_value_2;\n  undefined8 calculation_result_6;\n  undefined8 calculation_result_7;\n  undefined4 local_variable;\n  \n  calculation_result_6 = CONCAT44(input_value_2,input_value_1);\n  unsigned_input_value_2 = input_value_2 & 0x7fffffff;\n  if (DAT_0800b298 < (int)unsigned_input_value_2) {\n    if ((unsigned_input_value_2 != DAT_0800b29c && (int)DAT_0800b29c <= (int)unsigned_input_value_2) ||\n       ((result = DAT_0800b2a8, unsigned_input_value_2 == DAT_0800b29c && (input_value_1 != 0)))) {\n      result = calculate_double_precision_080082d4(input_value_1,input_value_2,input_value_1);\n      return result;\n    }\n  }\n  else {\n    if (DAT_0800b2ac < (int)unsigned_input_value_2) {\n      calculation_result_6 = do_nothing_0800b2cc();\n      calculation_result_4 = (undefined4)((ulonglong)calculation_result_6 >> 0x20);\n      calculation_result_1 = (undefined4)calculation_result_6;\n      if (DAT_0800b2bc < (int)unsigned_input_value_2) {\n        if ((int)unsigned_input_value_2 < DAT_0800b2c0) {\n          calculation_result_6 = reverse_and_improve_080082d0(calculation_result_1,calculation_result_4,0,DAT_0800b2c4);\n          calculation_result_7 = calculate_product_08008640(calculation_result_1,calculation_result_4,0,DAT_0800b2c4);\n          calculation_result_7 = calculate_double_precision_080082d4((int)calculation_result_7,(int)((ulonglong)calculation_result_7 >> 0x20),0,DAT_0800b2b8);\n          calculation_result_6 = convert_float_to_uint_08008894((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),(int)calculation_result_7,\n                               (int)((ulonglong)calculation_result_7 >> 0x20));\n          result = 2;\n        }\n        else {\n          calculation_result_6 = convert_float_to_uint_08008894(0,DAT_0800b2c8,calculation_result_1,calculation_result_4);\n          result = 3;\n        }\n      }\n      else if (DAT_0800b2bc + -0xd0000 < (int)unsigned_input_value_2) {\n        calculation_result_6 = reverse_and_improve_080082d0(calculation_result_1,calculation_result_4,0,DAT_0800b2b8);\n        calculation_result_7 = calculate_double_precision_080082d4(calculation_result_1,calculation_result_4,0,DAT_0800b2b8);\n        calculation_result_6 = convert_float_to_uint_08008894((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),(int)calculation_result_7,\n                             (int)((ulonglong)calculation_result_7 >> 0x20));\n        result = 1;\n      }\n      else {\n        calculation_result_6 = calculate_double_precision_080082d4(calculation_result_1,calculation_result_4,calculation_result_1,calculation_result_4);\n        calculation_result_6 = reverse_and_improve_080082d0((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),0,DAT_0800b2b8);\n        calculation_result_7 = calculate_double_precision_080082d4(calculation_result_1,calculation_result_4,0,0x40000000);\n        calculation_result_6 = convert_float_to_uint_08008894((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),(int)calculation_result_7,\n                             (int)((ulonglong)calculation_result_7 >> 0x20));\n        result = 0;\n      }\n    }\n    else {\n      if ((int)unsigned_input_value_2 <= DAT_0800b2ac + -0x1bc0000) {\n        calculation_result_7 = calculate_double_precision_080082d4(input_value_1,input_value_2,DAT_0800b290,DAT_0800b294);\n        result = isCollisionDetected_08008b60((int)calculation_result_7,(int)((ulonglong)calculation_result_7 >> 0x20),0,DAT_0800b2b8);\n        if (result != 0) {\n          return input_value_1;\n        }\n      }\n      result = -1;\n    }\n    local_variable = (undefined4)((ulonglong)calculation_result_6 >> 0x20);\n    calculation_result_5 = (undefined4)calculation_result_6;\n    calculation_result_6 = calculate_product_08008640(calculation_result_5,local_variable,calculation_result_5);\n    calculation_result_2 = (undefined4)((ulonglong)calculation_result_6 >> 0x20);\n    calculation_result_1 = (undefined4)calculation_result_6;\n    calculation_result_6 = calculate_product_08008640(calculation_result_1,calculation_result_2,calculation_result_1,calculation_result_2);\n    calculation_result_3 = (undefined4)((ulonglong)calculation_result_6 >> 0x20);\n    calculation_result_4 = (undefined4)calculation_result_6;\n    calculation_result_6 = calculate_product_08008640(calculation_result_4,calculation_result_3,DAT_0800b238,DAT_0800b23c);\n    calculation_result_6 = calculate_double_precision_080082d4((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),DAT_0800b240,DAT_0800b244);\n    calculation_result_6 = calculate_product_08008640((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),calculation_result_4,calculation_result_3);\n    calculation_result_6 = calculate_double_precision_080082d4((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),DAT_0800b248,DAT_0800b24c);\n    calculation_result_6 = calculate_product_08008640((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),calculation_result_4,calculation_result_3);\n    calculation_result_6 = calculate_double_precision_080082d4((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),DAT_0800b250,DAT_0800b254);\n    calculation_result_6 = calculate_product_08008640((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),calculation_result_4,calculation_result_3);\n    calculation_result_6 = calculate_double_precision_080082d4((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),DAT_0800b258,DAT_0800b25c);\n    calculation_result_6 = calculate_product_08008640((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),calculation_result_4,calculation_result_3);\n    calculation_result_6 = calculate_double_precision_080082d4((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),DAT_0800b260,DAT_0800b264);\n    calculation_result_6 = calculate_product_08008640((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),calculation_result_1,calculation_result_2);\n    calculation_result_1 = (undefined4)((ulonglong)calculation_result_6 >> 0x20);\n    calculation_result_7 = calculate_product_08008640(calculation_result_4,calculation_result_3,DAT_0800b268,DAT_0800b26c);\n    calculation_result_7 = reverse_and_improve_080082d0((int)calculation_result_7,(int)((ulonglong)calculation_result_7 >> 0x20),DAT_0800b270,DAT_0800b274);\n    calculation_result_7 = calculate_product_08008640((int)calculation_result_7,(int)((ulonglong)calculation_result_7 >> 0x20),calculation_result_4,calculation_result_3);\n    calculation_result_7 = reverse_and_improve_080082d0((int)calculation_result_7,(int)((ulonglong)calculation_result_7 >> 0x20),DAT_0800b278,DAT_0800b27c);\n    calculation_result_7 = calculate_product_08008640((int)calculation_result_7,(int)((ulonglong)calculation_result_7 >> 0x20),calculation_result_4,calculation_result_3);\n    calculation_result_7 = reverse_and_improve_080082d0((int)calculation_result_7,(int)((ulonglong)calculation_result_7 >> 0x20),DAT_0800b280,DAT_0800b284);\n    calculation_result_7 = calculate_product_08008640((int)calculation_result_7,(int)((ulonglong)calculation_result_7 >> 0x20),calculation_result_4,calculation_result_3);\n    calculation_result_7 = reverse_and_improve_080082d0((int)calculation_result_7,(int)((ulonglong)calculation_result_7 >> 0x20),DAT_0800b288,DAT_0800b28c);\n    calculation_result_7 = calculate_product_08008640((int)calculation_result_7,(int)((ulonglong)calculation_result_7 >> 0x20),calculation_result_4,calculation_result_3);\n    calculation_result_4 = (undefined4)((ulonglong)calculation_result_7 >> 0x20);\n    if (result == -1) {\n      calculation_result_6 = calculate_double_precision_080082d4((int)calculation_result_6,calculation_result_1,(int)calculation_result_7,calculation_result_4);\n      calculation_result_6 = calculate_product_08008640((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),calculation_result_5,local_variable);\n      result = reverse_and_improve_080082d0(calculation_result_5,local_variable,(int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20));\n      return result;\n    }\n    calculation_result_6 = calculate_double_precision_080082d4((int)calculation_result_6,calculation_result_1,(int)calculation_result_7,calculation_result_4);\n    undefined_pointer = PTR_DAT_0800b2b0;\n    calculation_result_6 = calculate_product_08008640((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),calculation_result_5,local_variable);\n    calculation_result_6 = reverse_and_improve_080082d0((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),\n                         *(undefined4 *)(PTR_DAT_0800b2b4 + result * 8),\n                         *(undefined4 *)((int)(PTR_DAT_0800b2b4 + result * 8) + 4));\n    calculation_result_6 = reverse_and_improve_080082d0((int)calculation_result_6,(int)((ulonglong)calculation_result_6 >> 0x20),calculation_result_5,local_variable);\n    result = reverse_and_improve_080082d0(*(undefined4 *)(undefined_pointer + result * 8),\n                         *(undefined4 *)((int)(undefined_pointer + result * 8) + 4),(int)calculation_result_6,\n                         (int)((ulonglong)calculation_result_6 >> 0x20));\n    if ((int)input_value_2 < 0) {\n      return result;\n    }\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_080082d0",
                "FUN_080082d4",
                "FUN_08008b60",
                "FUN_0800b2cc",
                "FUN_08008640",
                "FUN_08008894"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800af78",
            "calling": [
                "FUN_08009990"
            ],
            "imported": false,
            "current_name": "calculate_value_0800af78"
        },
        "FUN_08007d08": {
            "renaming": {
                "FUN_08007d08": "initialize_flag_08007d08",
                "puVar1": "flag",
                "DAT_08007d9c": "flag",
                "set_flag_08007a10": "set_flag",
                "PTR_DAT_08007da0": "ptr",
                "DAT_08007da4": "dat"
            },
            "code": "void initialize_flag_08007d08(void)\n{\n  // Define pointer to array of undefined 4 byte integers\n  undefined4 *DAT_08007d9c = DAT_08007d9c;\n  // Call function to set DAT_08007d9c\n  set_DAT_08007d9c_08007a10(DAT_08007d9c);\n  // Set DAT_08007d9c values\n  DAT_08007d9c[0] = 0x80;\n  DAT_08007d9c[1] = 0;\n  DAT_08007d9c[2] = 0;\n  DAT_08007d9c[3] = 0;\n  DAT_08007d9c[4] = 0;\n  DAT_08007d9c[5] = 1;\n  DAT_08007d9c[6] = 0x6800;\n  DAT_08007d9c[7] = 0;\n  DAT_08007d9c[8] = 0;\n  DAT_08007d9c[9] = 0;\n  DAT_08007d9c[10] = (uint)((ulonglong)DAT_08007da4 * (ulonglong)*(uint *)PTR_DAT_08007da0 >> 0x35) - 1;\n  DAT_08007d9c[11] = 199;\n  DAT_08007d9c[12] = 0;\n  DAT_08007d9c[13] = 100;\n  DAT_08007d9c[14] = 0;\n  DAT_08007d9c[15] = 0;\n  DAT_08007d9c[16] = 0;\n  DAT_08007d9c[17] = 0;\n}\n",
            "called": [
                "FUN_08007a10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007d08",
            "calling": [
                "FUN_08007e08"
            ],
            "imported": false,
            "current_name": "initialize_flag_08007d08"
        },
        "FUN_080091fc": {
            "renaming": {
                "FUN_080091fc": "concatenate_strings_080091fc",
                "param_1": "dest",
                "param_2": "src",
                "concatenate_08009204": "strcat"
            },
            "code": "void concatenate_strings_080091fc(char* dest, const char* src)\n{\n    strcat(dest, src);\n    return;\n}",
            "called": [
                "FUN_08009204"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091fc",
            "calling": [
                "FUN_08009250",
                "FUN_08009264"
            ],
            "imported": false,
            "current_name": "concatenate_strings_080091fc"
        },
        "FUN_080058a0": {
            "renaming": {
                "FUN_080058a0": "process_data_if_available_080058a0",
                "PTR_DAT_080058f0": "data_ptr_pointer",
                "PTR_DAT_080058f4": "data_length_ptr",
                "PTR_DAT_080058fc": "result_array",
                "DAT_080058f8": "data_type",
                "calculate_collisions_and_concatenate_strings_08003618": "calculate_collisions_and_concatenate_strings",
                "calculate_data_08005324": "calculate_data"
            },
            "code": "void process_data_if_available_080058a0(void)\n{\n  int* data_pointer = *(int**)PTR_DAT_080058f0;\n  if (*data_pointer == 0) {\n    PTR_DAT_080058fc[1] = 0;\n  }\n  else {\n    int data_length = *(data_pointer + 4) - *(int*)(PTR_DAT_080058f4 + 4);\n    calculate_collisions_and_concatenate_strings(data_length);\n    *(int*)(PTR_DAT_080058f4 + 28) = 0;\n    calculate_data(*(int*)(PTR_DAT_080058f4 + 28));\n    *(int*)(PTR_DAT_080058f4 + 24) = DAT_080058f8;\n    *(int*)(PTR_DAT_080058f4 + 16) = 0;\n    PTR_DAT_080058fc[1] = 2;\n  }\n  return;\n}",
            "called": [
                "FUN_08005324",
                "FUN_08003618"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058a0",
            "calling": [
                "FUN_08003a74"
            ],
            "imported": false,
            "current_name": "process_data_if_available_080058a0"
        },
        "FUN_080036c6": {
            "renaming": {
                "FUN_080036c6": "processString_080036c6",
                "param_1": "inputString",
                "local_c": "currentChar",
                "*local_c": "*currentChar",
                "waitForFlagAndReturn_08008250": "waitForFlagAndReturn"
            },
            "code": "void processString_080036c6(char *inputString)\\n{\\n  char *currentChar;\\n  currentChar = inputString;\\n  while (*currentChar != \"\\0\") {\\n    waitForFlagAndReturn(*currentChar);\\n    currentChar++;\\n  }\\n  return;\\n}",
            "called": [
                "FUN_08008250"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036c6",
            "calling": [
                "FUN_08004250",
                "FUN_080046d0",
                "FUN_08004148",
                "FUN_08004940",
                "FUN_0800423c",
                "FUN_08004030",
                "FUN_080041a0",
                "FUN_08004228",
                "FUN_080044e8",
                "FUN_08004900"
            ],
            "imported": false,
            "current_name": "processString_080036c6"
        },
        "FUN_08008190": {
            "renaming": {
                "FUN_08008190": "configure_device_08008190",
                "puVar1": "device_ptr"
            },
            "code": "void configure_device_08008190(void)\n{\n    uint *device_ptr;\n    device_ptr = DAT_08008240;\n    set_flags_08007ea4(device_ptr);\n    device_ptr[3] &= 0xffffdfff;\n    device_ptr[3] &= 0xffff400c;\n    device_ptr[3] |= 0xc;\n    device_ptr[4] &= 0xffff8090;\n    device_ptr[5] &= 0xfffff000;\n    *device_ptr &= 0xfffffc00;\n    calculate_shift_and_set_value_08007f54(device_ptr,0x1c200);\n    device_ptr[6] = device_ptr[6];\n    device_ptr[3] |= 0x2000;\n    return;\n}",
            "called": [
                "FUN_08007f54",
                "FUN_08007ea4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008190",
            "calling": [
                "FUN_08007540"
            ],
            "imported": false,
            "current_name": "configure_device_08008190"
        },
        "FUN_080074c8": {
            "renaming": {
                "FUN_080074c8": "check_and_enable_flags_080074c8",
                "param_1": "flags",
                "set_bit_at_position_08007402": "set_bit_at_position",
                "check_and_enable_flag_if_not_set_0800195c": "check_and_enable_flag_if_not_set",
                "check_flags_08003a18": "check_flags"
            },
            "code": "void check_and_enable_flags_080074c8(uint flags){\n    if ((flags & 0b1) != 0) {\n        set_bit_at_position(0x3e);\n    }\n    if ((*(int *)PTR_DAT_08007518 != 0) && ((flags & 0b11110) != 0)) {\n        check_and_enable_flag_if_not_set();\n    }\n    if ((*(int *)PTR_DAT_0800751c != 0) && ((flags & 0b10000000) != 0)) {\n        check_flags(param_1);\n    }\n    return;\n}",
            "called": [
                "FUN_08007402",
                "FUN_0800195c",
                "FUN_08003a18"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080074c8",
            "calling": [
                "FUN_08007930"
            ],
            "imported": false,
            "current_name": "check_and_enable_flags_080074c8"
        },
        "FUN_0800b430": {
            "renaming": {
                "FUN_0800b430": "fill_memory_with_value_0800b430",
                "param_1": "memory",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "current_address",
                "puVar2": "end_address",
                "uVar3": "size_remaining",
                "uVar4": "value_32_bits",
                "bVar5": "is_address_not_32_bits_aligned"
            },
            "code": "void fill_memory_with_value_0800b430(uint32_t *memory, uint8_t value, uint32_t size) {\n  uint32_t *current_address;\n  uint32_t *end_address;\n  uint32_t value_32_bits;\n  bool is_address_not_32_bits_aligned = ((uint)memory & 3) != 0;\n  if (is_address_not_32_bits_aligned) {\n    size--;\n    current_address = memory;\n    if (size == 0) {\n      return;\n    }\n    while (true) {\n      memory = (uint32_t *)((int)current_address + 1);\n      *(uint8_t *)current_address = value;\n      size--;\n      if (((uint)memory & 3) == 0) break;\n      if (size == 0) {\n        return;\n      }\n      current_address = memory;\n    }\n  }\n  if (size > 3) {\n    value_32_bits = (value << 24) | (value << 16) | (value << 8) | value;\n    if (size > 15) {\n      end_address = (uint32_t *)((int)memory + (size - 16 & 0xfffffff0) + 0x20);\n      current_address = memory + 4;\n      do {\n        current_address[-4] = value_32_bits;\n        current_address[-3] = value_32_bits;\n        current_address[-2] = value_32_bits;\n        current_address[-1] = value_32_bits;\n        current_address = current_address + 4;\n      } while (current_address != end_address);\n      size &= 0xf;\n      memory = end_address - 4;\n    }\n    end_address = (uint32_t *)((size - 4 & 0xfffffffc) + 4 + (int)memory);\n    current_address = memory + 1;\n    while (current_address != end_address) {\n      *memory = value_32_bits;\n      memory = current_address;\n      current_address++;\n    }\n    size &= 3;\n  }\n  if (size != 0) {\n    current_address = memory;\n    end_address = (uint32_t *)(size + (int)memory);\n    while (current_address != end_address) {\n      *(uint8_t *)current_address = value;\n      current_address++;\n    }\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b430",
            "calling": [
                "FUN_080079c0",
                "FUN_08001994",
                "FUN_080005b4",
                "FUN_080002f0",
                "FUN_080004ac",
                "FUN_08004d7c",
                "FUN_08005814",
                "FUN_080024c4",
                "FUN_08002f24",
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "fill_memory_with_value_0800b430"
        },
        "FUN_08004030": {
            "renaming": {
                "FUN_08004030": "printErrorMessage_08004030",
                "param_1": "errorCode",
                "processString_080036c6": "printString"
            },
            "code": "void printErrorMessage_08004030(char errorCode) {\n  if (errorCode == '\\0') {\n    printString(PTR_DAT_08004108);\n  }\n  else {\n    printString(PTR_s_error__0800410c);\n    switch(errorCode) {\n      case '\\x01':\n        printString(PTR_s_Bad_number_format_08004110);\n        break;\n      case '\\x02':\n        printString(PTR_s_Expected_command_letter_08004114);\n        break;\n      case '\\x03':\n        printString(PTR_s_Unsupported_statement_08004118);\n        break;\n      case '\\x04':\n        printString(PTR_s_Invalid_radius_0800411c);\n        break;\n      case '\\x05':\n        printString(PTR_s_Modal_group_violation_08004120);\n        break;\n      case '\\x06':\n        printString(PTR_s_Invalid_statement_08004124);\n        break;\n      case '\\a':\n        printString(PTR_s_Setting_disabled_08004128);\n        break;\n      case '\\b':\n        printString(PTR_s_Value___0_0_0800412c);\n        break;\n      case '\\t':\n        printString(PTR_s_Value___3_usec_08004130);\n        break;\n      case '\\n':\n        printString(PTR_s_EEPROM_read_fail__Using_defaults_08004134);\n        break;\n      case '\\v':\n        printString(PTR_s_Busy_or_queued_08004138);\n        break;\n      case '\\f':\n        printString(PTR_s_Alarm_lock_0800413c);\n        break;\n      case '\\r':\n        printString(PTR_s_Line_overflow_08004140);\n    }\n    printString(PTR_DAT_08004144);\n  }\n  return;\n}",
            "called": [
                "FUN_080036c6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004030",
            "calling": [
                "FUN_08003f34",
                "FUN_080039bc",
                "FUN_080004ac",
                "FUN_080051b4",
                "FUN_080044e8",
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "printErrorMessage_08004030"
        },
        "FUN_08005360": {
            "renaming": {
                "FUN_08005360": "check_value_within_range_08005360",
                "uVar1": "max_value",
                "uVar2": "current_value",
                "sum": "sum_of_values"
            },
            "code": "bool check_value_within_range_08005360(void)\n{\n    int sum = *(int *)(PTR_DAT_08005398 + 0x14) + *(int *)(PTR_DAT_08005398 + 0x18);\n    *(int *)(PTR_DAT_08005398 + 0x18) = sum;\n    uint max_value = DAT_0800539c;\n    uint current_value = *(uint *)(PTR_DAT_08005398 + 0x18);\n    if (max_value < current_value) {\n        *(int *)(PTR_DAT_08005398 + 0x18) = sum - 420000;\n    }\n    return max_value < current_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005360",
            "calling": [
                "FUN_080053a0"
            ],
            "imported": false,
            "current_name": "check_value_within_range_08005360"
        },
        "FUN_08003980": {
            "renaming": {
                "FUN_08003980": "clear_data_08003980",
                "*PTR_DAT_08003998": "data_pointer_1",
                "*PTR_DAT_0800399c": "data_pointer_2"
            },
            "code": "void clear_data_08003980(void)\n{\n  int* *PTR_DAT_08003998 = PTR_DAT_08003998;\n  int* *PTR_DAT_0800399c = PTR_DAT_0800399c;\n  **PTR_DAT_08003998 = 0;\n  **PTR_DAT_0800399c = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003980",
            "calling": [
                "FUN_080039a0",
                "FUN_08003f34"
            ],
            "imported": false,
            "current_name": "clear_data_08003980"
        },
        "FUN_08006de0": {
            "renaming": {
                "FUN_08006de0": "is_bit_set_in_array_08006de0",
                "param_1": "index",
                "uVar1": "result",
                "isBitSetInArray_08006a18": "is_bit_set_in_array_08006a18"
            },
            "code": "int is_bit_set_in_array_08006de0(int index) {\n    int result = isBitSetInArray_08006a18(index);\n    return result;\n}",
            "called": [
                "FUN_08006a18"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006de0",
            "calling": [],
            "imported": false,
            "current_name": "is_bit_set_in_array_08006de0"
        },
        "FUN_08007540": {
            "renaming": {
                "FUN_08007540": "run_system_08007540",
                "set_flags_and_values_080059b4": "set_flags_and_values",
                "initialize_variables_08007436": "initialize_variables",
                "update_registers_and_set_parameter_values_0800778c": "update_registers_and_set_parameter_values",
                "initialize_and_set_flag_08007e08_08007e08": "initialize_and_set_flag",
                "initialize_data_080079c0": "initialize_data",
                "configure_device_08008190": "configure_device",
                "print_system_call_if_not_null_08005984": "print_system_call_if_not_null",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int run_system_08007540(void)\n{\n  set_flags_and_values();\n  initialize_variables();\n  update_registers_and_set_parameter_values();\n  initialize_and_set_flag();\n  initialize_data();\n  configure_device();\n  print_system_call_if_not_null(0);\n  run_program();\n  return 0;\n}",
            "called": [
                "FUN_08008190",
                "FUN_080079c0",
                "FUN_08007436",
                "FUN_080059b4",
                "FUN_08007e08",
                "FUN_08005984",
                "FUN_0800778c",
                "FUN_08001ddc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007540",
            "calling": [
                "FUN_080092c4"
            ],
            "imported": false,
            "current_name": "run_system_08007540"
        },
        "FUN_080052dc": {
            "renaming": {
                "FUN_080052dc": "set_param_080052dc",
                "param_1": "new_param",
                "DAT_08005308": "ptr_base"
            },
            "code": "void set_param_080052dc(uint new_param){\n    uint* ptr = (uint*)(DAT_08005308 + 0x14);\n    uint mask = 0xfffff55f;\n    *ptr = (new_param | (*ptr & mask));\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052dc",
            "calling": [
                "FUN_080053a0"
            ],
            "imported": false,
            "current_name": "set_param_080052dc"
        },
        "FUN_080064ec": {
            "renaming": {
                "FUN_080064ec": "calculate_divisor_080064ec",
                "uVar1": "divisor_type",
                "uVar2": "divisor_value",
                "local_c": "dividend",
                "count_leading_zeroes": "count_leading_zero_bits",
                "DAT_0800661c": "data_pointer_1",
                "DAT_08006620": "default_divisor_1",
                "DAT_08006624": "default_divisor_2"
            },
            "code": "uint calculate_divisor_080064ec(void)\n{\n  uint divisor_type;\n  uint divisor_value;\n  uint leading_zeroes;\n  \n  divisor_type = *(uint *)(DAT_0800661c + 8) & 0xc;\n  if (divisor_type == 8) {\n    divisor_value = *(uint *)(DAT_0800661c + 4) & 0x3f;\n    leading_zeroes = count_leading_zeroes(0x200);\n    if ((*(uint *)(DAT_0800661c + 4) & 0x400000) >> (leading_zeroes & 0xff) == 0) {\n      leading_zeroes = count_leading_zeroes(0x3fe0000);\n      divisor_value = ((*(uint *)(DAT_0800661c + 4) & 0x7fc0) >> (leading_zeroes & 0xff)) * (DAT_08006620 / divisor_value);\n    }\n    else {\n      leading_zeroes = count_leading_zeroes(0x3fe0000);\n      divisor_value = ((*(uint *)(DAT_0800661c + 4) & 0x7fc0) >> (leading_zeroes & 0xff)) * (DAT_08006624 / divisor_value);\n    }\n    leading_zeroes = count_leading_zeroes(0xc000);\n    return divisor_value / ((((*(uint *)(DAT_0800661c + 4) & 0x30000) >> (leading_zeroes & 0xff)) + 1) * 2);\n  }\n  if (divisor_type < 9) {\n    if (divisor_type == 0) {\n      return DAT_08006620;\n    }\n    if (divisor_type == 4) {\n      return DAT_08006624;\n    }\n  }\n  return DAT_08006620;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064ec",
            "calling": [
                "FUN_08006628"
            ],
            "imported": false,
            "current_name": "calculate_divisor_080064ec"
        },
        "FUN_08006ba0": {
            "renaming": {
                "FUN_08006ba0": "apply_mask_08006ba0",
                "param_1": "mask",
                "param_2": "value",
                "param_3": "shift_amount",
                "uVar1": "shift_value"
            },
            "code": "uint apply_mask_08006ba0(uint mask, uint value, uint shift_amount) {\n  uint shift_value = 7 - (mask & 7);\n  if (shift_value > 3) {\n    shift_value = 4;\n  }\n  if ((mask & 7) + 4 < 7) {\n    mask = 0;\n  }\n  else {\n    mask = (mask & 7) - 3;\n  }\n  return value & ((1 << (mask & 0xff)) - 1U) | ((1 << (shift_value & 0xff)) - 1U & mask) << (shift_amount & 0xff);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ba0",
            "calling": [
                "FUN_08006cf6"
            ],
            "imported": false,
            "current_name": "apply_mask_08006ba0"
        },
        "FUN_080003ec": {
            "renaming": {
                "FUN_080003ec": "is_sum_equal_to_last_value_080003ec",
                "param_1": "input_string",
                "param_2": "input_length",
                "param_3": "last_value",
                "cVar1": "current_char",
                "uVar2": "last_value_in_data",
                "local_1c": "current_index",
                "local_18": "input_index",
                "local_14": "current_char_pointer",
                "local_9": "sum_of_chars"
            },
            "code": "bool is_sum_equal_to_last_value_080003ec(char *input_string, int input_length, int last_value) {\n  char current_char;\n  uint sum_of_chars = 0;\n  int current_index = input_length;\n  char *current_char_pointer = input_string;\n  if (*(int *)PTR_DAT_08000470 == 0) {\n    initialize_memory_and_set_value_to_255_080002f0();\n    current_index = input_length;\n    current_char_pointer = input_string;\n  }\n  for (; current_index != 0; current_index--) {\n    current_char = get_value_from_data_08000310(input_length - current_index);\n    sum_of_chars += current_char != 0 ? 1 : 0;\n    *current_char_pointer = current_char;\n    current_char_pointer++;\n  }\n  uint last_value_in_data = get_value_from_data_08000310(input_length);\n  return sum_of_chars == last_value_in_data;\n}",
            "called": [
                "FUN_08000310",
                "FUN_080002f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080003ec",
            "calling": [
                "FUN_08004d2c",
                "FUN_08004d7c",
                "FUN_08004dd2"
            ],
            "imported": false,
            "current_name": "is_sum_equal_to_last_value_080003ec"
        },
        "FUN_08002896": {
            "renaming": {
                "FUN_08002896": "replace_null_with_0x12_08002896",
                "param_1": "input_char",
                "local_9": "output_char"
            },
            "code": "char replace_null_with_0x12_08002896(char input_char) {\n  char output_char;\n  output_char = input_char;\n  if (input_char == '\\0') {\n    output_char = '\\x12';\n  }\n  return output_char - 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002896",
            "calling": [
                "FUN_08002a94"
            ],
            "imported": false,
            "current_name": "replace_null_with_0x12_08002896"
        },
        "FUN_0800a348": {
            "renaming": {
                "FUN_0800a348": "calculate_result_0800a348",
                "param_1": "num_1",
                "param_2": "num_2",
                "param_3": "num_3",
                "param_4": "num_4",
                "iVar1": "calculation_result",
                "uVar2": "product_lower_bits",
                "uVar3": "product_upper_bits",
                "uVar4": "absolute_value_num_2",
                "uVar5": "product_1",
                "uVar6": "product_2",
                "uVar7": "product_3",
                "lVar8": "long_long_product",
                "local_30": "final_result_lower_bits",
                "uStack_2c": "final_result_upper_bits",
                "local_28": "temp_result_lower_bits",
                "uStack_24": "temp_result_upper_bits"
            },
            "code": "\nundefined4 calculate_result_0800a348(undefined4 num_1,uint num_2,undefined4 num_3,undefined4 num_4)\n\n{\n  int calculation_result;\n  undefined4 product_lower_bits;\n  undefined4 product_upper_bits;\n  uint absolute_value_num_2;\n  undefined8 product_1;\n  undefined8 product_2;\n  undefined8 product_3;\n  longlong long_long_product;\n  undefined4 final_result_lower_bits;\n  undefined4 final_result_upper_bits;\n  undefined4 temp_result_lower_bits;\n  undefined4 temp_result_upper_bits;\n  \n  absolute_value_num_2 = num_2 & 0x7fffffff;\n  if (absolute_value_num_2 < 0x3e400000) {\n    calculation_result = calculate_08008ba0();\n    if (calculation_result == 0) {\n      return 0;\n    }\n    product_1 = calculate_product_08008640(num_1,num_2,num_1,num_2);\n    product_upper_bits = (undefined4)((ulonglong)product_1 >> 0x20);\n    product_lower_bits = (undefined4)product_1;\n    product_2 = calculate_product_08008640(product_lower_bits,product_upper_bits,DAT_0800a558,DAT_0800a55c);\n    product_2 = calculate_double_precision_080082d4((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a560,DAT_0800a564);\n    product_2 = calculate_product_08008640((int)product_2,(int)((ulonglong)product_2 >> 0x20),product_lower_bits,product_upper_bits);\n    product_2 = reverse_and_improve_080082d0((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a568,DAT_0800a56c);\n    product_2 = calculate_product_08008640((int)product_2,(int)((ulonglong)product_2 >> 0x20),product_lower_bits,product_upper_bits);\n    product_2 = calculate_double_precision_080082d4((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a570,DAT_0800a574);\n    product_2 = calculate_product_08008640((int)product_2,(int)((ulonglong)product_2 >> 0x20),product_lower_bits,product_upper_bits);\n    product_2 = reverse_and_improve_080082d0((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a578,DAT_0800a57c);\n    product_2 = calculate_product_08008640((int)product_2,(int)((ulonglong)product_2 >> 0x20),product_lower_bits,product_upper_bits);\n    product_2 = calculate_double_precision_080082d4((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a580,DAT_0800a584);\n    product_2 = calculate_product_08008640((int)product_2,(int)((ulonglong)product_2 >> 0x20),product_lower_bits,product_upper_bits);\n  }\n  else {\n    product_1 = calculate_product_08008640(num_1,num_2,num_1,num_2);\n    product_upper_bits = (undefined4)((ulonglong)product_1 >> 0x20);\n    product_lower_bits = (undefined4)product_1;\n    product_2 = calculate_product_08008640(product_lower_bits,product_upper_bits,DAT_0800a558,DAT_0800a55c);\n    product_2 = calculate_double_precision_080082d4((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a560,DAT_0800a564);\n    product_2 = calculate_product_08008640((int)product_2,(int)((ulonglong)product_2 >> 0x20),product_lower_bits,product_upper_bits);\n    product_2 = reverse_and_improve_080082d0((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a568,DAT_0800a56c);\n    product_2 = calculate_product_08008640((int)product_2,(int)((ulonglong)product_2 >> 0x20),product_lower_bits,product_upper_bits);\n    product_2 = calculate_double_precision_080082d4((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a570,DAT_0800a574);\n    product_2 = calculate_product_08008640((int)product_2,(int)((ulonglong)product_2 >> 0x20),product_lower_bits,product_upper_bits);\n    product_2 = reverse_and_improve_080082d0((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a578,DAT_0800a57c);\n    product_2 = calculate_product_08008640((int)product_2,(int)((ulonglong)product_2 >> 0x20),product_lower_bits,product_upper_bits);\n    product_2 = calculate_double_precision_080082d4((int)product_2,(int)((ulonglong)product_2 >> 0x20),DAT_0800a580,DAT_0800a584);\n    product_2 = calculate_product_08008640((int)product_2,(int)((ulonglong)product_2 >> 0x20),product_lower_bits,product_upper_bits);\n    if (DAT_0800a590 < (int)absolute_value_num_2) {\n      if (DAT_0800a594 < (int)absolute_value_num_2) {\n        long_long_product = (ulonglong)DAT_0800a598 << 0x20;\n        calculation_result = DAT_0800a59c;\n      }\n      else {\n        long_long_product = reverse_and_improve_080082d0(0,DAT_0800a58c,0,absolute_value_num_2 - 0x200000);\n        calculation_result = absolute_value_num_2 - 0x200000;\n      }\n      temp_result_upper_bits = (undefined4)((ulonglong)long_long_product >> 0x20);\n      temp_result_lower_bits = (undefined4)long_long_product;\n      product_1 = calculate_product_08008640(product_lower_bits,product_upper_bits,0,DAT_0800a588);\n      product_1 = reverse_and_improve_080082d0((int)product_1,(int)((ulonglong)product_1 >> 0x20),0,calculation_result);\n      product_2 = calculate_product_08008640(product_lower_bits,product_upper_bits,(int)product_2,(int)((ulonglong)product_2 >> 0x20));\n      product_3 = calculate_product_08008640(num_1,num_2,num_3,num_4);\n      product_2 = reverse_and_improve_080082d0((int)product_2,(int)((ulonglong)product_2 >> 0x20),(int)product_3,\n                           (int)((ulonglong)product_3 >> 0x20));\n      product_1 = reverse_and_improve_080082d0((int)product_1,(int)((ulonglong)product_1 >> 0x20),(int)product_2,\n                           (int)((ulonglong)product_2 >> 0x20));\n      product_lower_bits = reverse_and_improve_080082d0(temp_result_lower_bits,temp_result_upper_bits,(int)product_1,(int)((ulonglong)product_1 >> 0x20));\n      return product_lower_bits;\n    }\n  }\n  final_result_upper_bits = (undefined4)((ulonglong)product_2 >> 0x20);\n  final_result_lower_bits = (undefined4)product_2;\n  product_lower_bits = (undefined4)((ulonglong)product_1 >> 0x20);\n  product_2 = calculate_product_08008640((int)product_1,product_lower_bits,0,DAT_0800a588);\n  product_1 = calculate_product_08008640((int)product_1,product_lower_bits,final_result_lower_bits,final_result_upper_bits);\n  product_3 = calculate_product_08008640(num_1,num_2,num_3,num_4);\n  product_1 = reverse_and_improve_080082d0((int)product_1,(int)((ulonglong)product_1 >> 0x20),(int)product_3,\n                       (int)((ulonglong)product_3 >> 0x20));\n  product_1 = reverse_and_improve_080082d0((int)product_2,(int)((ulonglong)product_2 >> 0x20),(int)product_1,\n                       (int)((ulonglong)product_1 >> 0x20));\n  product_lower_bits = reverse_and_improve_080082d0(0,DAT_0800a58c,(int)product_1,(int)((ulonglong)product_1 >> 0x20));\n  return product_lower_bits;\n}\n\n",
            "called": [
                "FUN_080082d0",
                "FUN_080082d4",
                "FUN_08008ba0",
                "FUN_08008640"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a348",
            "calling": [
                "FUN_08009410",
                "FUN_080096e8"
            ],
            "imported": false,
            "current_name": "calculate_result_0800a348"
        },
        "FUN_080001ac": {
            "renaming": {
                "FUN_080001ac": "concatenate_values_080001ac",
                "param_1": "value1",
                "param_2": "value2",
                "DAT_080001bc": "global_variable",
                "PTR_FUN_080001c4": "global_pointer_value",
                "PTR_DAT_080001c0": "global_data_value"
            },
            "code": "uint64_t concatenate_values_080001ac(uint64_t value1, uint64_t value2) {\n  if (DAT_080001bc != 0) {\n    value1 = PTR_FUN_080001c4;\n    value2 = PTR_DAT_080001c0;\n  }\n  return ((uint64_t)value2 << 32) | value1;\n}",
            "called": [
                "FUN_0800b5b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001ac",
            "calling": [
                "FUN_0800b3e8"
            ],
            "imported": false,
            "current_name": "concatenate_values_080001ac"
        },
        "FUN_08003740": {
            "renaming": {
                "FUN_08003740": "print_bits_of_uint_08003740",
                "param_1": "number"
            },
            "code": "void print_bits_of_uint_08003740(uint number, int num_bits) {\n\tprint_bits_of_uint_08003740(number, num_bits);\n\treturn;\n}",
            "called": [
                "FUN_080036f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003740",
            "calling": [],
            "imported": false,
            "current_name": "print_bits_of_uint_08003740"
        },
        "FUN_08000478": {
            "renaming": {
                "FUN_08000478": "set_parameters_in_array_08000478",
                "param_1": "first_param",
                "param_2": "second_param",
                "param_3": "third_param",
                "PTR_DAT_080004a8": "parameters_array"
            },
            "code": "void set_parameters_in_array_08000478(int first_param, int second_param, int third_param)\n{\n  PTR_DAT_080004a8[25] = first_param;\n  PTR_DAT_080004a8[26] = second_param;\n  PTR_DAT_080004a8[27] = third_param;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000478",
            "calling": [
                "FUN_080005b4",
                "FUN_080004ac"
            ],
            "imported": false,
            "current_name": "set_parameters_in_array_08000478"
        },
        "FUN_08006d2e": {
            "renaming": {
                "FUN_08006d2e": "set_bit_in_array_08006d2e",
                "param_1": "character_to_set"
            },
            "code": "void set_bit_in_array_08006d2e(char character_to_set) {\n    set_bit_in_array_08006d2e_080069b4((int)character_to_set);\n}",
            "called": [
                "FUN_080069b4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d2e",
            "calling": [],
            "imported": false,
            "current_name": "set_bit_in_array_08006d2e"
        },
        "FUN_08007e1c": {
            "renaming": {
                "FUN_08007e1c": "waitForFlagToSet_08007e1c",
                "param_1": "flag",
                "DAT_08007e48": "statusFlag"
            },
            "code": "void waitForFlagToSet_08007e1c(byte flag){\n  do {\n  } while ((*DAT_08007e48 & 0x80) == 0);\n  DAT_08007e48[1] = (uint)flag;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e1c",
            "calling": [
                "FUN_08008250",
                "FUN_0800826a"
            ],
            "imported": false,
            "current_name": "waitForFlagToSet_08007e1c"
        },
        "FUN_0800adf0": {
            "renaming": {
                "FUN_0800adf0": "calculate_new_value_0800adf0",
                "param_1": "currentValue",
                "param_2": "valueToCheck",
                "param_3": "param_3",
                "param_4": "param_4",
                "param_5": "param_5",
                "iVar1": "calculationResult",
                "uVar2": "firstResult",
                "uVar3": "secondResult",
                "uVar4": "thirdResult",
                "uVar5": "fourthResult",
                "uVar6": "fifthResult",
                "uVar7": "sixthResult",
                "uVar8": "seventhResult"
            },
            "code": "undefined4 calculate_new_value_0800adf0(undefined4 currentValue,uint valueToCheck,undefined4 param_3,undefined4 param_4,int param_5) {\n  int calculationResult;\n  undefined4 firstResult;\n  undefined4 secondResult;\n  undefined4 thirdResult;\n  undefined4 fourthResult;\n  undefined4 fifthResult;\n  undefined8 sixthResult;\n  undefined8 seventhResult;\n  if (((valueToCheck & 0x7fffffff) < 0x3e400000) && (calculationResult = calculate_08008ba0(), calculationResult == 0)) {\n    return currentValue;\n  }\n  sixthResult = calculate_product_08008640(currentValue,valueToCheck,currentValue);\n  thirdResult = (undefined4)((ulonglong)sixthResult >> 0x20);\n  firstResult = (undefined4)sixthResult;\n  sixthResult = calculate_product_08008640(currentValue,valueToCheck,firstResult,thirdResult);\n  fifthResult = (undefined4)((ulonglong)sixthResult >> 0x20);\n  secondResult = (undefined4)sixthResult;\n  sixthResult = calculate_product_08008640(firstResult,thirdResult,DAT_0800af40,DAT_0800af44);\n  sixthResult = reverse_and_improve_080082d0((int)sixthResult,(int)((ulonglong)sixthResult >> 0x20),DAT_0800af48,DAT_0800af4c);\n  sixthResult = calculate_product_08008640((int)sixthResult,(int)((ulonglong)sixthResult >> 0x20),firstResult,thirdResult);\n  sixthResult = calculate_double_precision_080082d4((int)sixthResult,(int)((ulonglong)sixthResult >> 0x20),DAT_0800af50,DAT_0800af54);\n  sixthResult = calculate_product_08008640((int)sixthResult,(int)((ulonglong)sixthResult >> 0x20),firstResult,thirdResult);\n  sixthResult = reverse_and_improve_080082d0((int)sixthResult,(int)((ulonglong)sixthResult >> 0x20),DAT_0800af58,DAT_0800af5c);\n  sixthResult = calculate_product_08008640((int)sixthResult,(int)((ulonglong)sixthResult >> 0x20),firstResult,thirdResult);\n  sixthResult = calculate_double_precision_080082d4((int)sixthResult,(int)((ulonglong)sixthResult >> 0x20),DAT_0800af60,DAT_0800af64);\n  fourthResult = (undefined4)((ulonglong)sixthResult >> 0x20);\n  if (param_5 != 0) {\n    seventhResult = calculate_product_08008640(param_3,param_4,0,DAT_0800af70);\n    sixthResult = calculate_product_08008640(secondResult,fifthResult,(int)sixthResult,fourthResult);\n    sixthResult = reverse_and_improve_080082d0((int)seventhResult,(int)((ulonglong)seventhResult >> 0x20),(int)sixthResult,\n                         (int)((ulonglong)sixthResult >> 0x20));\n    sixthResult = calculate_product_08008640((int)sixthResult,(int)((ulonglong)sixthResult >> 0x20),firstResult,thirdResult);\n    sixthResult = reverse_and_improve_080082d0((int)sixthResult,(int)((ulonglong)sixthResult >> 0x20),param_3,param_4);\n    seventhResult = calculate_product_08008640(secondResult,fifthResult,DAT_0800af68,DAT_0800af6c);\n    sixthResult = calculate_double_precision_080082d4((int)sixthResult,(int)((ulonglong)sixthResult >> 0x20),(int)seventhResult,\n                         (int)((ulonglong)seventhResult >> 0x20));\n    firstResult = reverse_and_improve_080082d0(currentValue,valueToCheck,(int)sixthResult,(int)((ulonglong)sixthResult >> 0x20));\n    return firstResult;\n  }\n  sixthResult = calculate_product_08008640(firstResult,thirdResult,(int)sixthResult,fourthResult);\n  sixthResult = reverse_and_improve_080082d0((int)sixthResult,(int)((ulonglong)sixthResult >> 0x20),DAT_0800af68,DAT_0800af6c);\n  sixthResult = calculate_product_08008640((int)sixthResult,(int)((ulonglong)sixthResult >> 0x20),secondResult,fifthResult);\n  firstResult = calculate_double_precision_080082d4((int)sixthResult,(int)((ulonglong)sixthResult >> 0x20),currentValue,valueToCheck);\n  return firstResult;\n}",
            "called": [
                "FUN_080082d0",
                "FUN_080082d4",
                "FUN_08008ba0",
                "FUN_08008640"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800adf0",
            "calling": [
                "FUN_08009410",
                "FUN_080096e8"
            ],
            "imported": false,
            "current_name": "calculate_new_value_0800adf0"
        },
        "FUN_08003a74": {
            "renaming": {
                "FUN_08003a74": "process_alarm_08003a74",
                "PTR_DAT_08003b90": "alarm_data",
                "PTR_DAT_08003b94": "data_array",
                "displayAlarmMessage_08004148": "display_alarm_message",
                "displayMessage_080041a0": "display_message",
                "process_data_08004940": "process_data",
                "update_data_if_condition_met_0800587c": "update_data_if_condition_met",
                "process_data_if_available_080058a0": "process_data_if_available",
                "set_flags_if_second_element_is_two_0800585c": "set_flags_if_second_element_is_two"
            },
            "code": "void process_alarm_08003a74() {\n    byte alarm_flags = PTR_DAT_08003b90[2];\n\n    if (alarm_flags != '\\0') {\n        if ((alarm_flags & 0x60) != 0) {\n            PTR_DAT_08003b90[1] = 6;\n\n            if ((alarm_flags & 0x40) == 0) {\n                display_alarm_message(0xfffffffe);\n            }\n            else {\n                display_alarm_message(0xffffffff);\n                display_message(1);\n                PTR_DAT_08003b90[2] &= 0xef;\n                while ((PTR_DAT_08003b90[2] & 0x10) == 0);\n            }\n\n            PTR_DAT_08003b90[2] &= 0x9f;\n        }\n\n        if ((alarm_flags & 0x10) == 0) {\n            if ((alarm_flags & 1) != 0) {\n                process_data();\n                PTR_DAT_08003b90[2] &= 0xfe;\n            }\n\n            if ((alarm_flags & 8) != 0) {\n                update_data_if_condition_met();\n                PTR_DAT_08003b90[2] &= 0xf7;\n            }\n\n            if ((alarm_flags & 4) != 0) {\n                process_data_if_available();\n                PTR_DAT_08003b90[2] &= 0xfb;\n            }\n\n            if ((alarm_flags & 2) != 0) {\n                set_flags_if_second_element_is_two();\n\n                if ((PTR_DAT_08003b94[0x28] & 2) != 0) {\n                    PTR_DAT_08003b90[0x10] = 1;\n                }\n\n                PTR_DAT_08003b90[2] &= 0xfd;\n            }\n        }\n        else {\n            *PTR_DAT_08003b90 = 1;\n        }\n    }\n}",
            "called": [
                "FUN_080058a0",
                "FUN_08004940",
                "FUN_08004148",
                "FUN_0800587c",
                "FUN_0800585c",
                "FUN_080041a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a74",
            "calling": [
                "FUN_08002fd4",
                "FUN_08003f34",
                "FUN_08001e98",
                "FUN_080024c4",
                "FUN_08002408",
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "process_alarm_08003a74"
        },
        "FUN_08005cec": {
            "renaming": {
                "FUN_08005cec": "check_params_08005cec",
                "param_1": "params",
                "iVar1": "value",
                "uVar2": "next_value",
                "uVar3": "leading_zeroes_1",
                "uVar4": "leading_zeroes_2"
            },
            "code": "\nundefined4 check_params_08005cec(uint *params)\n\n{\n  int value;\n  uint next_value;\n  uint leading_zeroes_1;\n  uint leading_zeroes_2;\n  \n  if ((*params & 1) != 0) {\n    if (((DAT_08005fac[2] & 0xc) == 4) ||\n       (((DAT_08005fac[2] & 0xc) == 8 && ((DAT_08005fac[1] & 0x400000) == 0x400000)))) {\n      if (((*DAT_08005fac & 0x20000) != 0) && (params[1] != 1)) {\n        return 1;\n      }\n    }\n    else {\n      *DAT_08005fb0 = 0;\n      value = get_value_from_pointer_08005a84();\n      while ((*DAT_08005fac & 0x20000) != 0) {\n        next_value = get_value_from_pointer_08005a84();\n        if (value + 5000U <= next_value) {\n          return 3;\n        }\n      }\n      *DAT_08005fb0 = (char)params[1];\n      if (params[1] == 1) {\n        value = get_value_from_pointer_08005a84();\n        while ((*DAT_08005fac & 0x20000) == 0) {\n          next_value = get_value_from_pointer_08005a84();\n          if (value + 5000U <= next_value) {\n            return 3;\n          }\n        }\n      }\n      else {\n        value = get_value_from_pointer_08005a84();\n        while ((*DAT_08005fac & 0x20000) != 0) {\n          next_value = get_value_from_pointer_08005a84();\n          if (value + 5000U <= next_value) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*params & 2) != 0) {\n    if (((DAT_08005fac[2] & 0xc) == 0) ||\n       (((DAT_08005fac[2] & 0xc) == 8 && ((DAT_08005fac[1] & 0x400000) == 0)))) {\n      if (((*DAT_08005fac & 2) != 0) && (params[3] != 1)) {\n        return 1;\n      }\n    }\n    else if (params[3] == 0) {\n      *DAT_08005fb4 = 0;\n      value = get_value_from_pointer_08005a84();\n      while ((*DAT_08005fac & 2) != 0) {\n        next_value = get_value_from_pointer_08005a84();\n        if (value + 100U <= next_value) {\n          return 3;\n        }\n      }\n    }\n    else {\n      *DAT_08005fb4 = 1;\n      value = get_value_from_pointer_08005a84();\n      while ((*DAT_08005fac & 2) == 0) {\n        next_value = get_value_from_pointer_08005a84();\n        if (value + 100U <= next_value) {\n          return 3;\n        }\n      }\n      next_value = count_leading_zeroes(0x1f000000);\n      *DAT_08005fac = params[4] << (next_value & 0xff) | *DAT_08005fac & 0xffffff07;\n    }\n  }\n  if ((*params & 8) != 0) {\n    if (params[5] == 0) {\n      *DAT_08005fb8 = 0;\n      value = get_value_from_pointer_08005a84();\n      while ((DAT_08005fac[0x1d] & 2) != 0) {\n        next_value = get_value_from_pointer_08005a84();\n        if (value + 100U <= next_value) {\n          return 3;\n        }\n      }\n    }\n    else {\n      *DAT_08005fb8 = 1;\n      value = get_value_from_pointer_08005a84();\n      while ((DAT_08005fac[0x1d] & 2) == 0) {\n        next_value = get_value_from_pointer_08005a84();\n        if (value + 100U <= next_value) {\n          return 3;\n        }\n      }\n    }\n  }\n  if ((*params & 4) != 0) {\n    DAT_08005fac[0x10] = DAT_08005fac[0x10] | 0x10000000;\n    *DAT_08005fbc = *DAT_08005fbc | 0x100;\n    value = get_value_from_pointer_08005a84();\n    while ((*DAT_08005fbc & 0x100) == 0) {\n      next_value = get_value_from_pointer_08005a84();\n      if (value + 100U <= next_value) {\n        return 3;\n      }\n    }\n    *DAT_08005fc0 = 0;\n    value = get_value_from_pointer_08005a84();\n    while ((DAT_08006180[0x1c] & 2) != 0) {\n      next_value = get_value_from_pointer_08005a84();\n      if (value + 5000U <= next_value) {\n        return 3;\n      }\n    }\n    *DAT_08006184 = (char)params[2];\n    if (params[2] == 1) {\n      value = get_value_from_pointer_08005a84();\n      while ((DAT_08006180[0x1c] & 2) == 0) {\n        next_value = get_value_from_pointer_08005a84();\n        if (value + 5000U <= next_value) {\n          return 3;\n        }\n      }\n    }\n    else {\n      value = get_value_from_pointer_08005a84();\n      while ((DAT_08006180[0x1c] & 2) != 0) {\n        next_value = get_value_from_pointer_08005a84();\n        if (value + 5000U <= next_value) {\n          return 3;\n        }\n      }\n    }\n  }\n  if (params[6] != 0) {\n    if ((DAT_08006180[2] & 0xc) == 8) {\n      return 1;\n    }\n    if (params[6] == 2) {\n      *DAT_08006188 = 0;\n      value = get_value_from_pointer_08005a84();\n      while ((*DAT_08006180 & 0x2000000) != 0) {\n        next_value = get_value_from_pointer_08005a84();\n        if (value + 100U <= next_value) {\n          return 3;\n        }\n      }\n      next_value = count_leading_zeroes(0x3fe0000);\n      leading_zeroes_1 = count_leading_zeroes(0xc000);\n      leading_zeroes_2 = count_leading_zeroes(0xf0);\n      DAT_08006180[1] =\n           params[0xb] << (leading_zeroes_2 & 0xff) |\n           params[8] | params[9] << (next_value & 0xff) | (params[10] >> 1) - 1 << (leading_zeroes_1 & 0xff) |\n           params[7] | 0x20000000;\n      *DAT_08006188 = 1;\n      value = get_value_from_pointer_08005a84();\n      while ((*DAT_08006180 & 0x2000000) == 0) {\n        next_value = get_value_from_pointer_08005a84();\n        if (value + 100U <= next_value) {\n          return 3;\n        }\n      }\n    }\n    else {\n      *DAT_08006188 = 0;\n      value = get_value_from_pointer_08005a84();\n      while ((*DAT_08006180 & 0x2000000) != 0) {\n        next_value = get_value_from_pointer_08005a84();\n        if (value + 100U <= next_value) {\n          return 3;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_08005a84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cec",
            "calling": [
                "FUN_08007436"
            ],
            "imported": false,
            "current_name": "check_params_08005cec"
        },
        "FUN_08006b00": {
            "renaming": {
                "FUN_08006b00": "write_byte_to_memory_08006b00",
                "param_1": "address",
                "param_2": "data",
                "DAT_08006b4c": "memory_start_address",
                "DAT_08006b50": "memory_start_address"
            },
            "code": "void write_byte_to_memory_08006b00(byte address, uint8_t data)\n{\n    if (address < 0)\n    {\n        *(char *)((address & 0xf) + DAT_08006b4c + 0x14) = (char)((data & 0xff) << 4);\n    }\n    else\n    {\n        *(char *)((char)address + DAT_08006b4c + 0x300) = (char)((data & 0xff) << 4);\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b00",
            "calling": [
                "FUN_08006cf6",
                "FUN_08006c9c"
            ],
            "imported": false,
            "current_name": "write_byte_to_memory_08006b00"
        },
        "FUN_0800b4d0": {
            "renaming": {
                "FUN_0800b4d0": "checkDataAvailability_0800b4d0",
                "DAT_0800b4dc": "isDataAvailable",
                "PTR_LAB_0800b4f0_1_0800b4e0": "dataLabel",
                "insert_data_0800b524": "insertData"
            },
            "code": "void checkDataAvailability_0800b4d0(void)\n{\n  if (DAT_0800b4dc != 0) {\n    insertData(0, PTR_LAB_0800b4f0_1_0800b4e0, 0);\n    return;\n  }\n  return;\n}",
            "called": [
                "FUN_0800b524"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b4d0",
            "calling": [
                "FUN_0800b3e8"
            ],
            "imported": false,
            "current_name": "checkDataAvailability_0800b4d0"
        },
        "FUN_08007f54": {
            "renaming": {
                "FUN_08007f54": "calculate_shift_and_set_value_08007f54",
                "param_1": "value",
                "param_2": "shift_amount",
                "lVar1": "shifted_value",
                "iVar2": "shift_amount_1",
                "iVar3": "shift_amount_2",
                "uVar4": "constant",
                "DAT_08008184": "ptr_1",
                "DAT_08008188": "ptr_2",
                "DAT_0800818c": "ptr_3"
            },
            "code": "void calculate_shift_and_set_value_08007f54(int value, int shift_amount) {\n  long long shifted_value;\n  int shift_amount_1;\n  int shift_amount_2;\n  int value_1;\n  int value_2;\n  int constant = 50;\n  if ((*(uint *)(value + 0xc) & 0x8000) == 0) {\n    if ((value != DAT_08008184) && (value != DAT_08008188)) {\n      shift_amount_1 = get_shift_amount();\n      shifted_value = (long long)DAT_0800818c * ((long long)(uint)((int)shift_amount_1 * 0x19) / (long long)(uint)(shift_amount << 2));\n      shift_amount_2 = get_shift_amount(shift_amount_1, (int)((ulonglong)shift_amount_1 >> 0x20), (int)shifted_value);\n      value_1 = get_shift_amount();\n      value_2 = get_shift_amount();\n      *(uint *)(value + 8) = (uint)((ulonglong)shifted_value >> 0x25) << 4 | (uint)((ulonglong)DAT_0800818c * (ulonglong)(((uint)(shift_amount_2 * 0x19) / (uint)(shift_amount << 2) + (uint)((ulonglong)DAT_0800818c * ((ulonglong)(uint)(value_1 * 0x19) / (ulonglong)(uint)(shift_amount << 2)) >> 0x25) * -100) * 0x10 + constant) >> 0x25) & 0xf;\n      return;\n    }\n    shift_amount_1 = calculate_shift_amount();\n    shifted_value = (long long)DAT_0800818c * ((long long)(uint)((int)shift_amount_1 * 0x19) / (long long)(uint)(shift_amount << 2));\n    shift_amount_2 = calculate_shift_amount(shift_amount_1, (int)((ulonglong)shift_amount_1 >> 0x20), (int)shifted_value);\n    value_1 = calculate_shift_amount();\n    value_2 = calculate_shift_amount();\n    *(uint *)(value + 8) = (uint)((ulonglong)shifted_value >> 0x25) << 4 | (uint)((ulonglong)DAT_0800818c * (ulonglong)(((uint)(shift_amount_2 * 0x19) / (uint)(shift_amount << 2) + (uint)((ulonglong)DAT_0800818c * ((ulonglong)(uint)(value_1 * 0x19) / (ulonglong)(uint)(shift_amount << 2)) >> 0x25) * -100) * 0x10 + constant) >> 0x25) & 0xf;\n  }\n  else {\n    if ((value != DAT_08008184) && (value != DAT_08008188)) {\n      shift_amount_1 = get_shift_amount();\n      shifted_value = (long long)DAT_0800818c * ((long long)(uint)((int)shift_amount_1 * 0x19) / (long long)(uint)(shift_amount << 1));\n      shift_amount_2 = get_shift_amount(shift_amount_1, (int)((ulonglong)shift_amount_1 >> 0x20), (int)shifted_value);\n      value_1 = get_shift_amount();\n      value_2 = get_shift_amount();\n      *(uint *)(value + 8) = (uint)((ulonglong)shifted_value >> 0x25) << 4 | (uint)((ulonglong)DAT_0800818c * (ulonglong)(((uint)(shift_amount_2 * 0x19) / (uint)(shift_amount << 1) + (uint)((ulonglong)DAT_0800818c * ((ulonglong)(uint)(value_1 * 0x19) / (ulonglong)(uint)(shift_amount << 1)) >> 0x25) * -100) * 0x10 + constant) >> 0x25) & 0xf;\n      return;\n    }\n    shift_amount_1 = calculate_shift_amount();\n    shifted_value = (long long)DAT_0800818c * ((long long)(uint)((int)shift_amount_1 * 0x19) / (long long)(uint)(shift_amount << 1));\n    shift_amount_2 = calculate_shift_amount(shift_amount_1, (int)((ulonglong)shift_amount_1 >> 0x20), (int)shifted_value);\n    value_1 = calculate_shift_amount();\n    value_2 = calculate_shift_amount();\n    *(uint *)(value + 8) = (uint)((ulonglong)shifted_value >> 0x25) << 4 | (uint)((ulonglong)DAT_0800818c * (ulonglong)(((uint)(shift_amount_2 * 0x19) / (uint)(shift_amount << 1) + (uint)((ulonglong)DAT_0800818c * ((ulonglong)(uint)(value_1 * 0x19) / (ulonglong)(uint)(shift_amount << 1)) >> 0x25) * -100) * 0x10 + constant) >> 0x25) & 0xf;\n  }\n}",
            "called": [
                "FUN_08006680",
                "FUN_080066cc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f54",
            "calling": [
                "FUN_08008190"
            ],
            "imported": false,
            "current_name": "calculate_shift_and_set_value_08007f54"
        },
        "FUN_08003b98": {
            "renaming": {
                "FUN_08003b98": "process_command_08003b98",
                "param_1": "command",
                "bVar1": "first_char",
                "iVar2": "int_value",
                "uVar3": "calculated_value",
                "uVar4": "return_value",
                "uVar5": "reversed_value",
                "local_14": "second_integer",
                "local_10": "first_integer",
                "local_a": "index_1",
                "local_9": "index_2"
            },
            "code": "uint process_command_08003b98(char *command)\n{\n  byte first_char = command[0];\n  int int_value;\n  uint return_value;\n  undefined8 reversed_value;\n  undefined4 local_14;\n  undefined4 local_10;\n  byte index_1 = 1;\n  byte index_2 = 0;\n  if (first_char != '$') {\n    return process_data_080005b4(command);\n  }\n  if (command[1] == 0) {\n    view_Grbl_settings_0800423c();\n    return 0;\n  }\n  if ((0x58 < command[1]) || (command[1] < 0x23)) {\n    goto switchD_08003bdc_caseD_25;\n  }\n  switch(command[1]) {\n    case 0x23:\n      index_1 = 2;\n      if (command[2] != '\\0') {\n        return 3;\n      }\n      printStackValues_080044e8();\n      break;\n    case 0x24:\n      index_1 = 2;\n      if (command[2] != '\\0') {\n        return 3;\n      }\n      printSettings_08004250();\n      break;\n    case 0x43:\n      index_1 = 2;\n      if (command[2] != '\\0') {\n        return 3;\n      }\n      if (PTR_DAT_08003f2c[1] == '\\a') {\n        enable_flag_if_not_set_and_check_080025e8();\n        displayMessage_080041a0(5);\n      }\n      else {\n        if (PTR_DAT_08003f2c[1] != '\\0') {\n          return 0xb;\n        }\n        PTR_DAT_08003f2c[1] = 7;\n        displayMessage_080041a0(4);\n      }\n      break;\n    case 0x47:\n      index_1 = 2;\n      if (command[2] != '\\0') {\n        return 3;\n      }\n      printFormattedData_080046d0();\n      break;\n    case 0x48:\n      if ((PTR_DAT_08003f30[0x28] & 0x10) == 0) {\n        return 7;\n      }\n      if ((PTR_DAT_08003f2c[1] != '\\0') && (PTR_DAT_08003f2c[1] != '\\x06')) {\n        return 0xb;\n      }\n      process_data_080024c4();\n      if (*PTR_DAT_08003f2c == '\\0') {\n        processChecksumsAndUpdate_080039bc();\n      }\n      break;\n    case 0x4e:\n      index_1 = 2;\n      if (command[2] == '\\0') {\n        for (index_2 = 0; index_2 < 2; index_2++) {\n          int_value = check_sum_and_update_checksum_08004d2c(index_2,command);\n          if (int_value == 0) {\n            printErrorMessage_08004030(10);\n          }\n          else {\n            printAbsoluteValueAndProcessStrings_08004900(index_2,command);\n          }\n        }\n        return 0;\n      }\n      index_2 = '\\x01';\n    default:\n  switchD_08003bdc_caseD_25:\n      int_value = extract_integer_from_string_08002638(command,&index_1,&local_10);\n      if (int_value == 0) {\n        return 1;\n      }\n      byte next_char = index_1 + 1;\n      if (command[index_1] != '=') {\n        return 3;\n      }\n      index_1 = next_char;\n      if (index_2 == '\\0') {\n        int_value = extract_integer_from_string_08002638(command,&index_1,&local_14);\n        if (int_value == 0) {\n          return 1;\n        }\n        if (command[index_1] == '\\0') {\n          undefined4 calculated_value = calculate_value_08009278(local_10);\n          return_value = process_parameters_08004e30(calculated_value,local_14);\n          return return_value;\n        }\n        return 3;\n      }\n      do {\n        command[(uint)index_1 - (uint)next_char] = command[index_1];\n        return_value = (uint)index_1;\n        index_1++;\n      } while (command[return_value] != '\\0');\n      index_2 = next_char;\n      return_value = process_data_080005b4(command);\n      if (return_value != 0) {\n        return return_value;\n      }\n      reversed_value = reverse_bits_08008590(local_10);\n      reversed_value = calculate_08009798((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n      index_2 = calculate_shift_amount_08008bf0((int)reversed_value,(int)((ulonglong)reversed_value >> 0x20));\n      calculate_checksum_08004bc0(index_2,command);\n      break;\n    case 0x58:\n      index_1 = 2;\n      if (command[2] != '\\0') {\n        return 3;\n      }\n      if (PTR_DAT_08003f2c[1] == '\\x06') {\n        displayMessage_080041a0(3);\n        PTR_DAT_08003f2c[1] = 0;\n      }\n  }\n  return 0;\n}",
            "called": [
                "FUN_080046d0",
                "FUN_08008590",
                "FUN_08004bc0",
                "FUN_080039bc",
                "FUN_08008bf0",
                "FUN_0800423c",
                "FUN_08004030",
                "FUN_08009278",
                "FUN_08002638",
                "FUN_08004e30",
                "FUN_080025e8",
                "FUN_08004250",
                "FUN_08004d2c",
                "FUN_080005b4",
                "FUN_08009798",
                "FUN_080024c4",
                "FUN_080041a0",
                "FUN_08004900",
                "FUN_080044e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003b98",
            "calling": [
                "FUN_08003f34"
            ],
            "imported": false,
            "current_name": "process_command_08003b98"
        },
        "FUN_080024c4": {
            "renaming": {
                "FUN_080024c4": "process_data_080024c4",
                "PTR_DAT_080025d8": "data_ptr2",
                "PTR_DAT_080025dc": "data_ptr1",
                "PTR_DAT_080025e0": "data_ptr3",
                "PTR_DAT_080025e4": "data_ptr4",
                "check_and_execute_08001d4c": "check_and_execute",
                "process_alarm_08003a74": "process_alarm",
                "fill_memory_with_value_0800b430": "fill_memory_with_value",
                "store_and_convert_fixed_point_values_0800283a": "store_and_convert_fixed_point_values",
                "convert_to_fixed_point_08008e44": "convert_to_fixed_point",
                "FUN_08008eec": "perform_operation",
                "process_data_and_set_flags_if_second_element_is_two_08001e98": "process_data_and_set_flags_if_second_element_is_two",
                "set_flags_if_second_element_is_two_0800585c": "set_flags_if_second_element_is_two",
                "process_until_alarm_or_exit_08002fd4": "process_until_alarm_or_exit"
            },
            "code": "void process_data_080024c4() {\n  int flag1 = 5;\n  *(int *)PTR_DAT_080025dc = 0;\n  check_and_execute();\n  process_alarm();\n  if (*PTR_DAT_080025d8 == '\\0') {\n    fill_memory_with_value(PTR_DAT_080025e0,0,12);\n    store_and_convert_fixed_point_values();\n    PTR_DAT_080025d8[1] = 0;\n    char local_1 = (*(unsigned short *)(PTR_DAT_080025e4 + 0x2a) & 0x20) == 0 ? -1 : '\\x01';\n    char local_2 = (*(unsigned short *)(PTR_DAT_080025e4 + 0x2a) & 0x80) == 0 ? -1 : '\\x01';\n    char local_3 = (*(unsigned short *)(PTR_DAT_080025e4 + 0x2a) & 0x200) == 0 ? -1 : '\\x01';\n    int fixed_point1 = convert_to_fixed_point(local_1);\n    fixed_point1 = perform_operation(fixed_point1, *(int *)(PTR_DAT_080025e4 + 0x38));\n    int fixed_point2 = convert_to_fixed_point(local_2);\n    fixed_point2 = perform_operation(fixed_point2, *(int *)(PTR_DAT_080025e4 + 0x38));\n    int fixed_point3 = convert_to_fixed_point(local_3);\n    fixed_point3 = perform_operation(fixed_point3, *(int *)(PTR_DAT_080025e4 + 0x38));\n    process_data_080024c4_and_set_flags_if_second_element_is_two(fixed_point1, fixed_point2, fixed_point3, *(int *)(PTR_DAT_080025e4 + 0x30), 0);\n    set_flags_if_second_element_is_two();\n    process_until_alarm_or_exit();\n    store_and_convert_fixed_point_values();\n    if ((PTR_DAT_080025e4[0x28] & 8) != 0) {\n      *(int *)PTR_DAT_080025dc = 1;\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_08002fd4",
                "FUN_08001d4c",
                "FUN_0800283a",
                "FUN_08008e44",
                "FUN_08001e98",
                "FUN_0800585c",
                "FUN_0800b430",
                "FUN_08008eec",
                "FUN_08003a74"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080024c4",
            "calling": [
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "process_data_080024c4"
        },
        "FUN_08002f40": {
            "renaming": {
                "FUN_08002f40": "check_and_reset_counter_08002f40",
                "uVar1": "new_value",
                "*PTR_DAT_08002f70": "current_value",
                "*PTR_DAT_08002f6c": "expected_value",
                "increment_and_reset_08002870": "increment_and_reset_counter"
            },
            "code": "void check_and_reset_counter_08002f40(void)\n{\n  int *PTR_DAT_08002f70 = *PTR_DAT_08002f70;\n  int *PTR_DAT_08002f6c = *PTR_DAT_08002f6c;\n\n  if (*PTR_DAT_08002f70 != *PTR_DAT_08002f6c) {\n    int new_value = increment_and_reset_08002870(*PTR_DAT_08002f6c);\n    *PTR_DAT_08002f70 = new_value;\n  }\n  return;\n}",
            "called": [
                "FUN_08002870"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f40",
            "calling": [
                "FUN_080053a0"
            ],
            "imported": false,
            "current_name": "check_and_reset_counter_08002f40"
        },
        "FUN_08009054": {
            "renaming": {
                "FUN_08009054": "float_bits_to_float_08009054",
                "param_1": "float_bits",
                "param_2": "float_bits_2",
                "param_3": "float_bits_3",
                "param_4": "float_bits_4",
                "uVar1": "mantissa_mask",
                "uVar2": "exponent_first_bits",
                "iVar3": "exponent_diff",
                "uVar4": "exponent",
                "iVar5": "biased_exponent",
                "uVar6": "result_bits",
                "bVar7": "condition",
                "bVar8": "condition_2",
                "bVar9": "condition_3"
            },
            "code": "\nuint float_bits_to_float_08009054(uint float_bits,uint float_bits_2,undefined4 float_bits_3,uint float_bits_4)\n\n{\n  uint mantissa_mask;\n  uint exponent_first_bits;\n  int exponent_diff;\n  uint exponent;\n  int biased_exponent;\n  uint result_bits;\n  bool condition;\n  bool condition_2;\n  bool condition_3;\n  \n  exponent_first_bits = float_bits >> 0x17 & 0xff;\n  condition = exponent_first_bits == 0;\n  if (!condition) {\n    float_bits_4 = float_bits_2 >> 0x17 & 0xff;\n    condition = float_bits_4 == 0;\n  }\n  if (!condition) {\n    condition = exponent_first_bits == 0xff;\n  }\n  if (!condition) {\n    condition = float_bits_4 == 0xff;\n  }\n  if (condition) {\n    float_bits_4 = float_bits_2 >> 0x17 & 0xff;\n    result_bits = float_bits;\n    if (exponent_first_bits == 0xff) {\n      if (((float_bits & 0x7fffff) != 0) || (result_bits = float_bits_2, float_bits_4 == 0xff)) {\nLAB_0800904a:\n        return result_bits | 0x7fc00000;\n      }\n    }\n    else {\n      if (float_bits_4 == 0xff) {\n        result_bits = float_bits_2;\n        if ((float_bits_2 & 0x7fffff) == 0) {\nLAB_08009000:\n          return (float_bits ^ float_bits_2) & 0x80000000;\n        }\n        goto LAB_0800904a;\n      }\n      condition = (float_bits & 0x7fffffff) == 0;\n      if (!condition) {\n        condition = (float_bits_2 & 0x7fffffff) == 0;\n      }\n      if (!condition) {\n        condition = exponent_first_bits == 0;\n        result_bits = float_bits & 0x80000000;\n        while( true ) {\n          if (condition) {\n            float_bits = float_bits << 1;\n            condition = (float_bits & 0x800000) == 0;\n          }\n          if (!condition) break;\n          exponent_first_bits = exponent_first_bits - 1;\n        }\n        float_bits = float_bits | result_bits;\n        condition = float_bits_4 == 0;\n        result_bits = float_bits_2 & 0x80000000;\n        while( true ) {\n          if (condition) {\n            float_bits_2 = float_bits_2 << 1;\n            condition = (float_bits_2 & 0x800000) == 0;\n          }\n          if (!condition) break;\n          float_bits_4 = float_bits_4 - 1;\n        }\n        float_bits_2 = float_bits_2 | result_bits;\n        goto LAB_0800906c;\n      }\n      if ((float_bits & 0x7fffffff) == 0) {\n        if ((float_bits_2 & 0x7fffffff) != 0) goto LAB_08009000;\n        goto LAB_0800904a;\n      }\n    }\n    float_bits = float_bits ^ float_bits_2;\n  }\n  else {\nLAB_0800906c:\n    exponent_diff = exponent_first_bits - float_bits_4;\n    if (float_bits_2 << 9 == 0) {\n      float_bits = (float_bits ^ float_bits_2) & 0x80000000 | float_bits & 0x7fffff;\n      condition_3 = SCARRY4(exponent_diff,0x7f);\n      biased_exponent = exponent_diff + 0x7f;\n      condition = biased_exponent < 0;\n      condition_2 = biased_exponent == 0;\n      if (!condition_2 && condition == condition_3) {\n        condition_3 = SBORROW4(0xff,biased_exponent);\n        condition = 0xff - biased_exponent < 0;\n        condition_2 = biased_exponent == 0xff;\n      }\n      if (!condition_2 && condition == condition_3) {\n        float_bits = float_bits | biased_exponent * 0x800000;\n      }\n      if (!condition_2 && condition == condition_3) {\n        return float_bits;\n      }\n      float_bits = float_bits | 0x800000;\n      exponent_first_bits = 0;\n      condition_2 = SBORROW4(biased_exponent,1);\n      exponent = exponent_diff + 0x7e;\n      condition = exponent == 0;\n      result_bits = exponent;\n    }\n    else {\n      mantissa_mask = (float_bits_2 << 9) >> 4 | 0x10000000;\n      exponent_first_bits = (float_bits << 9) >> 4 | 0x10000000;\n      float_bits = (float_bits ^ float_bits_2) & 0x80000000;\n      condition = mantissa_mask <= exponent_first_bits;\n      if (!condition) {\n        exponent_first_bits = exponent_first_bits << 1;\n      }\n      exponent = exponent_diff + 0x7d + (uint)condition;\n      result_bits = 0x800000;\n      do {\n        if (mantissa_mask <= exponent_first_bits) {\n          exponent_first_bits = exponent_first_bits - mantissa_mask;\n          float_bits = float_bits | result_bits;\n        }\n        condition = mantissa_mask >> 1 <= exponent_first_bits;\n        if (condition) {\n          exponent_first_bits = exponent_first_bits - (mantissa_mask >> 1);\n        }\n        if (condition) {\n          float_bits = float_bits | result_bits >> 1;\n        }\n        condition = mantissa_mask >> 2 <= exponent_first_bits;\n        if (condition) {\n          exponent_first_bits = exponent_first_bits - (mantissa_mask >> 2);\n        }\n        if (condition) {\n          float_bits = float_bits | result_bits >> 2;\n        }\n        condition = mantissa_mask >> 3 <= exponent_first_bits;\n        if (condition) {\n          exponent_first_bits = exponent_first_bits - (mantissa_mask >> 3);\n        }\n        if (condition) {\n          float_bits = float_bits | result_bits >> 3;\n        }\n        exponent_first_bits = exponent_first_bits * 0x10;\n        condition = exponent_first_bits == 0;\n        if (!condition) {\n          result_bits = result_bits >> 4;\n          condition = result_bits == 0;\n        }\n      } while (!condition);\n      condition_2 = SBORROW4(exponent,0xfd);\n      condition = exponent == 0xfd;\n      result_bits = exponent - 0xfd;\n      if (exponent < 0xfe) {\n        float_bits = float_bits + exponent * 0x800000 + (uint)(mantissa_mask <= exponent_first_bits);\n        if (exponent_first_bits - mantissa_mask == 0) {\n          float_bits = float_bits & 0xfffffffe;\n        }\n        return float_bits;\n      }\n    }\n    if (condition || (int)result_bits < 0 != condition_2) {\n      condition = (int)(exponent + 0x19) < 0;\n      if (exponent == 0xffffffe7 || condition != SCARRY4(exponent,0x19)) {\n        float_bits = float_bits & 0x80000000;\n      }\n      if (exponent == 0xffffffe7 || condition != SCARRY4(exponent,0x19)) {\n        return float_bits;\n      }\n      result_bits = (float_bits << 1) >> (-exponent & 0xff);\n      exponent = float_bits << (exponent + 0x20 & 0xff);\n      result_bits = ((uint)((float_bits & 0x80000000) != 0) << 0x1f | result_bits >> 1) + (uint)((byte)result_bits & 1);\n      if ((exponent_first_bits | exponent << 1) == 0) {\n        result_bits = result_bits & ~(exponent >> 0x1f);\n      }\n      return result_bits;\n    }\n  }\n  return float_bits & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009054",
            "calling": [
                "FUN_08004250",
                "FUN_08001994",
                "FUN_080004fc",
                "FUN_08004940",
                "FUN_08002908",
                "FUN_08002e08",
                "FUN_080028bc",
                "FUN_08003004",
                "FUN_08003618",
                "FUN_08001f00"
            ],
            "imported": false,
            "current_name": "float_bits_to_float_08009054"
        },
        "FUN_080025e8": {
            "renaming": {
                "FUN_080025e8": "enable_flag_if_not_set_and_check_080025e8",
                "PTR_DAT_08002634": "flag_data",
                "do_nothing_and_return_08005250": "do_nothing_and_return",
                "do_nothing_twice_08000210": "do_nothing_twice",
                "check_flags_080057e4": "check_flags"
            },
            "code": "void enable_flag_if_not_set_and_check_080025e8(byte *PTR_DAT_08002634) {\n  if ((PTR_DAT_08002634[2] & 0x10) == 0) {\n    PTR_DAT_08002634[2] |= 0x10;\n    do_nothing_and_return();\n    do_nothing_twice();\n    if ((byte)PTR_DAT_08002634[1] - 3 < 3) {\n      PTR_DAT_08002634[2] |= 0x20;\n      check_flags();\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_08005250",
                "FUN_080057e4",
                "FUN_08000210"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025e8",
            "calling": [
                "FUN_08005900",
                "FUN_080005b4",
                "FUN_08003b98",
                "FUN_0800195c",
                "FUN_08003a18"
            ],
            "imported": false,
            "current_name": "enable_flag_if_not_set_and_check_080025e8"
        },
        "FUN_080001c8": {
            "renaming": {
                "FUN_080001c8": "do_nothing_080001c8"
            },
            "code": "\nvoid do_nothing_080001c8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001c8",
            "calling": [
                "FUN_08000220"
            ],
            "imported": false,
            "current_name": "do_nothing_080001c8"
        },
        "FUN_08005250": {
            "renaming": {
                "FUN_08005250": "do_nothing_and_return_08005250",
                "do_nothing_08005214": "do_nothing"
            },
            "code": "void do_nothing_and_return_08005250(void)\n{\n  do_nothing();\n  return;\n}",
            "called": [
                "FUN_08005214"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005250",
            "calling": [
                "FUN_080025e8",
                "FUN_0800525c",
                "FUN_08005238"
            ],
            "imported": false,
            "current_name": "do_nothing_and_return_08005250"
        },
        "FUN_08007430": {
            "renaming": {
                "FUN_08007430": "infinite_loop_08007430"
            },
            "code": "void infinite_loop_08007430(void)\n{\n    while(true)\n    {\n        // Do nothing\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007430",
            "calling": [
                "FUN_08007436"
            ],
            "imported": false,
            "current_name": "infinite_loop_08007430"
        },
        "FUN_08008640": {
            "renaming": {
                "FUN_08008640": "calculate_product_08008640",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "result1",
                "param_4": "result2",
                "uVar1": "temp1",
                "lVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "iVar5": "temp5",
                "uVar6": "temp6",
                "unaff_r5": "temp7",
                "uVar7": "temp8",
                "uVar8": "temp9",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3",
                "uVar12": "concatenatedNum"
            },
            "code": "\nulonglong calculateProduct_08008640(undefined4 num1,uint num2,uint result1,uint result2)\n\n{\n  ulonglong temp1;\n  longlong temp2;\n  uint temp3;\n  uint temp4;\n  int temp5;\n  uint temp6;\n  uint temp7;\n  uint temp8;\n  uint temp9;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  ulonglong concatenatedNum;\n  \n  concatenatedNum = CONCAT44(num2,num1);\n  temp8 = 0x7ff;\n  temp4 = num2 >> 0x14 & 0x7ff;\n  flag1 = temp4 == 0;\n  if (!flag1) {\n    temp7 = result2 >> 0x14 & 0x7ff;\n    flag1 = temp7 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp4 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp7 == 0x7ff;\n  }\n  if (flag1) {\n    concatenatedNum = calculateResult_0800881c();\n  }\n  temp3 = (uint)(concatenatedNum >> 0x20);\n  temp5 = temp4 + temp7;\n  temp4 = temp3 ^ result2;\n  temp3 = temp3 & ~(temp8 << 0x15);\n  result2 = result2 & ~(temp8 << 0x15);\n  flag1 = ((uint)concatenatedNum | temp3 << 0xc) == 0;\n  if (!flag1) {\n    flag1 = (result1 | result2 << 0xc) == 0;\n  }\n  temp3 = temp3 | 0x100000;\n  result2 = result2 | 0x100000;\n  if (flag1) {\n    result1 = (uint)concatenatedNum | result1;\n    result2 = (temp4 & 0x80000000 | temp3) ^ result2;\n    temp4 = temp8 >> 1;\n    flag3 = SBORROW4(temp5,temp4);\n    temp6 = temp5 - temp4;\n    flag1 = temp6 == 0;\n    temp3 = temp6;\n    if (!flag1 && (int)temp4 <= temp5) {\n      flag3 = SBORROW4(temp8,temp6);\n      temp3 = temp8 - temp6;\n      flag1 = temp8 == temp6;\n    }\n    if (!flag1 && (int)temp3 < 0 == flag3) {\n      result2 = result2 | temp6 * 0x100000;\n    }\n    if (!flag1 && (int)temp3 < 0 == flag3) {\n      return CONCAT44(result2,result1);\n    }\n    result2 = result2 | 0x100000;\n    temp8 = 0;\n    flag3 = SBORROW4(temp6,1);\n    temp6 = temp6 - 1;\n    flag1 = temp6 == 0;\n    temp4 = temp6;\n  }\n  else {\n    temp1 = (concatenatedNum & 0xffffffff) * (ulonglong)result1;\n    concatenatedNum = (concatenatedNum & 0xffffffff) * (ulonglong)result2 +\n             (ulonglong)temp3 * (ulonglong)result1 + (temp1 >> 0x20);\n    temp9 = (uint)concatenatedNum;\n    temp2 = (ulonglong)temp3 * (ulonglong)result2 + (concatenatedNum >> 0x20);\n    temp8 = (uint)temp2;\n    temp3 = (uint)((ulonglong)temp2 >> 0x20);\n    if ((int)temp1 != 0) {\n      temp9 = temp9 | 1;\n    }\n    temp6 = (temp5 + -0x3ff) - (uint)(temp3 < 0x200);\n    if (temp3 < 0x200) {\n      flag1 = (temp9 & 0x80000000) != 0;\n      temp9 = temp9 << 1;\n      temp2 = CONCAT44(temp3 * 2 + (uint)(CARRY4(temp8,temp8) || CARRY4(temp8 * 2,(uint)flag1)),\n                       temp8 * 2 + (uint)flag1);\n    }\n    result2 = temp4 & 0x80000000 | (int)((ulonglong)temp2 >> 0x20) << 0xb | (uint)temp2 >> 0x15;\n    result1 = (uint)temp2 << 0xb | temp9 >> 0x15;\n    temp8 = temp9 * 0x800;\n    flag2 = 0xfc < temp6;\n    flag3 = SBORROW4(temp6,0xfd);\n    temp3 = temp6 - 0xfd;\n    flag1 = temp3 == 0;\n    temp4 = temp3;\n    if (flag2 && !flag1) {\n      flag2 = 0x6ff < temp3;\n      flag3 = SBORROW4(temp3,0x700);\n      temp4 = temp6 - 0x7fd;\n      flag1 = temp3 == 0x700;\n    }\n    if (!flag2 || flag1) {\n      flag1 = 0x7fffffff < temp8;\n      if (temp8 == 0x80000000) {\n        flag1 = (temp9 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(result2 + temp6 * 0x100000 + (uint)CARRY4(result1,(uint)flag1),result1 + flag1\n                     );\n    }\n  }\n  if (!flag1 && (int)temp4 < 0 == flag3) {\n    return (ulonglong)(result2 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag2 = SCARRY4(temp6,0x36);\n  flag1 = (int)(temp6 + 0x36) < 0;\n  flag3 = temp6 == 0xffffffca;\n  if (flag3 || flag1 != flag2) {\n    result1 = 0;\n  }\n  if (flag3 || flag1 != flag2) {\n    result2 = result2 & 0x80000000;\n  }\n  if (flag3 || flag1 != flag2) {\n    return CONCAT44(result2,result1);\n  }\n  temp4 = -temp6;\n  temp3 = temp4 - 0x20;\n  if (0x1f < (int)temp4) {\n    temp6 = result1 >> (temp3 & 0xff) | result2 << (0x20 - temp3 & 0xff);\n    temp4 = (result2 >> (temp3 & 0xff) & ~((result2 & 0x80000000) >> (temp3 & 0xff))) -\n            ((int)temp6 >> 0x1f);\n    if ((temp8 | result1 << (0x20 - temp3 & 0xff) | temp6 << 1) == 0) {\n      temp4 = temp4 & ~(temp6 >> 0x1f);\n    }\n    return CONCAT44(result2,temp4) & 0x80000000ffffffff;\n  }\n  temp5 = temp4 - 0x14;\n  if (temp5 == 0 || temp5 < 0 != SCARRY4(temp3,0xc)) {\n    temp9 = result1 << (temp6 + 0x20 & 0xff);\n    temp3 = result1 >> (temp4 & 0xff) | result2 << (temp6 + 0x20 & 0xff);\n    temp6 = temp3 + -((int)temp9 >> 0x1f);\n    if ((temp8 | temp9 << 1) == 0) {\n      temp6 = temp6 & ~(temp9 >> 0x1f);\n    }\n    return CONCAT44((result2 & 0x80000000) +\n                    ((result2 & 0x7fffffff) >> (temp4 & 0xff)) +\n                    (uint)CARRY4(temp3,-((int)temp9 >> 0x1f)),temp6);\n  }\n  temp4 = 0xc - temp5;\n  temp6 = result1 << (temp4 & 0xff);\n  temp4 = result1 >> (0x20 - temp4 & 0xff) | result2 << (temp4 & 0xff);\n  temp3 = temp4 + -((int)temp6 >> 0x1f);\n  if ((temp8 | temp6 << 1) == 0) {\n    temp3 = temp3 & ~(temp6 >> 0x1f);\n  }\n  return CONCAT44((result2 & 0x80000000) + (uint)CARRY4(temp4,-((int)temp6 >> 0x1f)),temp3);\n}\n\n",
            "called": [
                "FUN_0800881c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008640",
            "calling": [
                "FUN_080046d0",
                "FUN_0800af78",
                "FUN_08004940",
                "FUN_08009d78",
                "FUN_08003004",
                "FUN_0800056c",
                "FUN_0800b2e8",
                "FUN_08002638",
                "FUN_08001f00",
                "FUN_08009b24",
                "FUN_08002c18",
                "FUN_08001994",
                "FUN_0800a1bc",
                "FUN_0800a348",
                "FUN_0800a5a0",
                "FUN_0800adf0",
                "FUN_080044e8"
            ],
            "imported": false,
            "current_name": "calculate_product_08008640"
        },
        "FUN_08007436": {
            "renaming": {
                "FUN_08007436": "initialize_variables_08007436",
                "local_4c": "var_1",
                "local_48": "var_2",
                "local_34": "var_3",
                "local_30": "var_4",
                "local_2c": "var_5",
                "local_28": "var_6",
                "local_24": "var_7",
                "local_20": "var_8",
                "local_1c": "var_9",
                "local_18": "var_10",
                "local_14": "var_11",
                "local_10": "var_12",
                "local_c": "var_13",
                "DAT_080074c0": "ptr_1",
                "DAT_080074c4": "ptr_2",
                "PTR_08005cec": "FUN_08005cec",
                "PTR_0800618c": "validate_inputs_0800618c"
            },
            "code": "void initialize_variables_08007436(void)\n{\n  int return_value;\n  uint* DAT_080074c0 = (uint*)(DAT_080074c0 + 0x40);\n  uint* DAT_080074c4 = (uint*)DAT_080074c4;\n  uint var_1 = 1;\n  uint var_2 = 1;\n  uint var_3 = 2;\n  uint var_4 = 0x400000;\n  uint var_5 = 8;\n  uint var_6 = 0x150;\n  uint var_7 = 2;\n  uint var_8 = 7;\n  return_value = PTR_08005cec(&var_1);\n  if (return_value != 0) {\n    infinite_loop_08007430();\n  }\n  uint var_9 = 0xf;\n  uint var_10 = 2;\n  uint var_11 = 0;\n  uint var_12 = 0x1400;\n  uint var_13 = 0x1000;\n  return_value = PTR_0800618c(&var_9,5);\n  if (return_value != 0) {\n    infinite_loop_08007430();\n  }\n  return;\n}",
            "called": [
                "FUN_0800618c",
                "FUN_08005cec",
                "FUN_08007430"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007436",
            "calling": [
                "FUN_08007540"
            ],
            "imported": false,
            "current_name": "initialize_variables_08007436"
        },
        "FUN_08005814": {
            "renaming": {
                "FUN_08005814": "initialize_data_08005814",
                "PTR_DAT_08005834": "data_buffer",
                "calculate_data_08005324": "calculate_data",
                "PTR_DAT_08005838": "reset_flag"
            },
            "code": "void initialize_data_08005814(void)\n{\n  fill_memory_with_value(PTR_DAT_08005834, 0, 0x24);\n  calculate_data(800);\n  *PTR_DAT_08005838 = 0;\n  return;\n}",
            "called": [
                "FUN_08005324",
                "FUN_0800b430"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005814",
            "calling": [
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "initialize_data_08005814"
        },
        "FUN_08005bdc": {
            "renaming": {
                "FUN_08005bdc": "set_byte_in_memory_08005bdc",
                "param_1": "index",
                "param_2": "value",
                "DAT_08005c28": "data_ptr_1",
                "DAT_08005c2c": "data_ptr_2"
            },
            "code": "void set_byte_in_memory_08005bdc(byte index, uint value) {\n  if (index < 0) {\n    *(char *)((index & 0xf) + DAT_08005c28 + 0x14) = (char)((value & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)index + DAT_08005c2c + 0x300) = (char)((value & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bdc",
            "calling": [
                "FUN_08005c30"
            ],
            "imported": false,
            "current_name": "set_byte_in_memory_08005bdc"
        },
        "FUN_080002f0": {
            "renaming": {
                "FUN_080002f0": "initialize_memory_and_set_value_to_255_080002f0",
                "PTR_DAT_08000308": "memory_pointer",
                "PTR_DAT_0800030c": "flag_pointer"
            },
            "code": "void initialize_memory_and_set_value_to_255_080002f0(void)\n{\n  fill_memory_with_value_0800b430(PTR_DAT_08000308, 255, 4);\n  *(unsigned int *)PTR_DAT_0800030c = 1;\n  return;\n}",
            "called": [
                "FUN_0800b430"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002f0",
            "calling": [
                "FUN_08000374",
                "FUN_08000310",
                "FUN_08000340",
                "FUN_080003ec"
            ],
            "imported": false,
            "current_name": "initialize_memory_and_set_value_to_255_080002f0"
        },
        "FUN_080073c0": {
            "renaming": {
                "FUN_080073c0": "do_nothing_080073c0"
            },
            "code": "\nvoid do_nothing_080073c0(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073c0",
            "calling": [
                "FUN_0800738e"
            ],
            "imported": false,
            "current_name": "do_nothing_080073c0"
        },
        "FUN_0800778c": {
            "renaming": {
                "FUN_0800778c": "update_registers_and_set_parameter_values_0800778c",
                "local_24": "mask",
                "local_20": "reg2",
                "local_1c": "reg3",
                "local_18": "reg4",
                "local_14": "reg5",
                "local_10": "instruction",
                "local_c": "index"
            },
            "code": "void update_registers_and_set_parameter_values_0800778c(void)\n{\n  int index;\n  uint mask;\n  uint offset;\n  uint reg1;\n  uint reg2;\n  uint reg3;\n  uint reg4;\n  uint reg5;\n  uint *instruction;\n  uint value;\n  for (index = 0; index < 0x11; index = index + 1) {\n    instruction = (uint *)(PTR_DAT_0800784c + index * 0x18);\n    mask = 1 << (*instruction >> 4 & 0xff);\n    *(uint *)(DAT_08007850 + 0x30) |= mask;\n    offset = *instruction & 0xf;\n    reg1 = instruction[1];\n    reg2 = instruction[2];\n    reg3 = instruction[3];\n    reg4 = instruction[4];\n    update_registers_08006e88(((*instruction >> 4) + 0x100080) * 0x400,&mask);\n    if (instruction[5] >= 0) {\n      value = 1 << offset & 0xffff;\n      set_parameter_value_0800733e(((*instruction >> 4) + 0x100080) * 0x400,value,instruction[5] & 0xff);\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_0800733e",
                "FUN_08006e88"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800778c",
            "calling": [
                "FUN_08007540"
            ],
            "imported": false,
            "current_name": "update_registers_and_set_parameter_values_0800778c"
        },
        "FUN_080001d4": {
            "renaming": {
                "FUN_080001d4": "do_nothing_080001d4"
            },
            "code": "\nvoid do_nothing_080001d4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001d4",
            "calling": [
                "FUN_08000210"
            ],
            "imported": false,
            "current_name": "do_nothing_080001d4"
        },
        "FUN_08001ddc": {
            "renaming": {
                "FUN_08001ddc": "run_program_08001ddc",
                "PTR_DAT_08001e90": "memory_ptr",
                "PTR_DAT_08001e94": "data_ptr",
                "do_nothing_08008244": "do_nothing",
                "validate_and_print_data_080051b4": "validate_and_print_data",
                "set_param_and_flags_based_on_data_0800583c": "set_parameters_and_flags_based_on_data",
                "fill_memory_with_value_0800b430": "fill_memory_with_value",
                "do_nothing_080082ba": "do_nothing",
                "copy_and_reset_data_08002f24": "copy_and_reset_data",
                "initialize_data_and_check_sum_080004ac": "initialize_data_and_check_sum",
                "initializeProgram_080039a0": "initialize_program",
                "clear_data_08005238": "clear_data",
                "initialize_pointer_080001f8": "initialize_pointer",
                "check_data_integrity_0800192c": "check_data_integrity",
                "initialize_data_08005814": "initialize_data",
                "store_and_convert_fixed_point_values_0800283a": "store_and_convert_fixed_point_values",
                "processChecksumsAndUpdate_080039bc": "process_checksums_and_update",
                "process_alarm_08003a74": "process_alarm",
                "process_user_input_08003f34": "process_user_input",
                "displayMessage_080041a0": "display_message"
            },
            "code": "void run_program_08001ddc(void)\n{\n  do_nothing();\n  validate_and_print_data();\n  set_parameters_and_flags_based_on_data();\n  fill_memory_with_value(PTR_DAT_08001e90, 0, 0x14);\n  *PTR_DAT_08001e90 = 1;\n  PTR_DAT_08001e90[1] = 1;\n  do {\n    if (*PTR_DAT_08001e90 != '\\0') {\n      do_nothing();\n      copy_and_reset_data();\n      initialize_data_and_check_sum();\n      initialize_program();\n      clear_data();\n      initialize_pointer();\n      check_data_integrity();\n      initialize_data();\n      store_and_convert_fixed_point_values();\n      *PTR_DAT_08001e90 = 0;\n      PTR_DAT_08001e90[2] = 0;\n      if ((PTR_DAT_08001e90[4] & 2) != 0) {\n        PTR_DAT_08001e90[16] = 1;\n      }\n      if ((PTR_DAT_08001e90[1] == '\\x01') && ((PTR_DAT_08001e90[4] & 0x10) != 0)) {\n        PTR_DAT_08001e90[1] = 6;\n      }\n      if (PTR_DAT_08001e90[1] == '\\x06') {\n        display_message(2);\n      }\n      else {\n        PTR_DAT_08001e90[1] = 0;\n        process_checksums_and_update();\n      }\n    }\n    process_alarm();\n    process_user_input();\n  } while( true );\n}\n",
            "called": [
                "FUN_080039a0",
                "FUN_0800283a",
                "FUN_080039bc",
                "FUN_0800583c",
                "FUN_080001f8",
                "FUN_080004ac",
                "FUN_080051b4",
                "FUN_08005814",
                "FUN_0800b430",
                "FUN_08002f24",
                "FUN_080082ba",
                "FUN_08003a74",
                "FUN_08008244",
                "FUN_08003f34",
                "FUN_08005238",
                "FUN_0800192c",
                "FUN_080041a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001ddc",
            "calling": [
                "FUN_08007540"
            ],
            "imported": false,
            "current_name": "run_program_08001ddc"
        },
        "FUN_080069b4": {
            "renaming": {
                "FUN_080069b4": "set_bit_in_array_080069b4",
                "param_1": "bit_position",
                "DAT_080069e0": "array_ptr"
            },
            "code": "void set_bit_in_array_080069b4(uint8_t bit_position){\n    uint32_t* DAT_080069e0 = (uint32_t*)(DAT_080069e0 + (bit_position >> 5) * 4);\n    uint8_t bit_offset = bit_position & 0x1f;\n    uint32_t bit_mask = 1 << bit_offset;\n    *DAT_080069e0 = bit_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080069b4",
            "calling": [
                "FUN_08006d2e"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_080069b4"
        },
        "FUN_08009228": {
            "renaming": {
                "FUN_08009228": "is_string_terminated_08009228",
                "in_CY": "current_char",
                "concatenate_08009204": "concatenate_string"
            },
            "code": "bool is_string_terminated_08009228(void)\n{\n  char current_char;\n  concatenate_string();\n  return current_char == '\\0';\n}",
            "called": [
                "FUN_08009204"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009228",
            "calling": [
                "FUN_08002afc",
                "FUN_080005b4",
                "FUN_08003826",
                "FUN_080029d8",
                "FUN_08003004",
                "FUN_08004e30"
            ],
            "imported": false,
            "current_name": "is_string_terminated_08009228"
        },
        "FUN_08007c7c": {
            "renaming": {
                "FUN_08007c7c": "check_and_update_params_08007c7c",
                "_DAT_40000010": "param_1",
                "_DAT_4000000c": "param_2",
                "set_param_using_first_ushort_08005778": "set_param_using_first_ushort",
                "set_param_from_pointer_08005760": "set_param_from_pointer",
                "FUN_080053a0": "execute_function"
            },
            "code": "void check_and_update_params_08007c7c(void)\n{\n  bool is__DAT_40000010_set = (_DAT_40000010 & 2) != 0;\n  bool is__DAT_4000000c_set = (_DAT_4000000c & 2) != 0;\n  bool is_param_3_set = (_DAT_40000010 & 4) != 0;\n  bool is_param_4_set = (_DAT_4000000c & 4) != 0;\n  bool is_param_5_set = (_DAT_40000010 & 1) != 0;\n  bool is_param_6_set = (_DAT_4000000c & 1) != 0;\n\n  if (is__DAT_40000010_set && is__DAT_4000000c_set) {\n    _DAT_40000010 &= 0xfffffffd;\n    set_param_using_first_ushort();\n  }\n  if (is_param_3_set && is_param_4_set) {\n    _DAT_40000010 &= 0xfffffffb;\n    set_param_from_pointer();\n  }\n  if (is_param_5_set && is_param_6_set) {\n    _DAT_40000010 &= 0xfffffffe;\n    execute_function();\n  }\n  return;\n}",
            "called": [
                "FUN_080053a0",
                "FUN_08005778",
                "FUN_08005760"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007c7c",
            "calling": [],
            "imported": false,
            "current_name": "check_and_update_params_08007c7c"
        },
        "FUN_08007b70": {
            "renaming": {
                "FUN_08007b70": "set_flags_based_on_data_08007b70",
                "local_c": "flags",
                "_DAT_40000034": "data_flag_1",
                "_DAT_40000038": "data_flag_2",
                "_DAT_4000000c": "control_register_2",
                "_DAT_40000000": "control_register_1"
            },
            "code": "void set_flags_based_on_data_08007b70(void)\n{\n  uint8_t flags = 1;\n  if (_DAT_40000034 != 0) {\n    flags |= 0x3;\n  }\n  if (_DAT_40000038 != 0) {\n    flags |= 0x4;\n  }\n  _DAT_4000000c |= flags;\n  _DAT_40000000 |= 0x1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007b70",
            "calling": [
                "FUN_08005790"
            ],
            "imported": false,
            "current_name": "set_flags_based_on_data_08007b70"
        },
        "FUN_08004d2c": {
            "renaming": {
                "FUN_08004d2c": "check_sum_and_update_checksum_08004d2c",
                "param_1": "message_length",
                "param_2": "message_ptr",
                "iVar1": "is_sum_equal_to_last_value"
            },
            "code": "bool check_sum_and_update_checksum_08004d2c(byte message_length, undefined *message_ptr)\n{\n  int is_sum_equal_to_last_value = is_sum_equal_to_last_value_080003ec(message_ptr, (ushort)message_length * 0x101 + 0x300, 0x100);\n  if (is_sum_equal_to_last_value == 0) {\n    *message_ptr = 0;\n    calculate_checksum_08004bc0(message_length, message_ptr);\n  }\n  return is_sum_equal_to_last_value != 0;\n}",
            "called": [
                "FUN_08004bc0",
                "FUN_080003ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d2c",
            "calling": [
                "FUN_080039bc",
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "check_sum_and_update_checksum_08004d2c"
        },
        "FUN_08003004": {
            "renaming": {
                "FUN_08003004": "calculate_collision_08003004",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "puVar1": "ptr1",
                "uVar2": "var2",
                "uVar3": "var3",
                "iVar4": "var4",
                "iVar5": "var5",
                "iVar6": "var6",
                "uVar7": "var7",
                "uVar8": "var8",
                "uVar9": "var9",
                "uVar10": "var10",
                "uVar11": "var11",
                "puVar12": "ptr2",
                "iVar13": "var13",
                "uVar14": "var14",
                "uVar15": "var15",
                "uVar16": "var16",
                "uVar17": "var17",
                "local_20": "localVar1",
                "local_1c": "localVar2"
            },
            "code": "\nvoid calculate_collision_08003004(undefined4 param1,undefined4 param2,undefined4 param3,undefined4 param4,\n                 char param5)\n\n{\n  undefined *ptr1;\n  undefined var2;\n  undefined4 var3;\n  int var4;\n  int var5;\n  int var6;\n  undefined4 var7;\n  undefined4 var8;\n  undefined4 var9;\n  undefined4 var10;\n  uint var11;\n  ushort *ptr2;\n  int var13;\n  uint var14;\n  undefined8 var15;\n  undefined8 var16;\n  undefined8 var17;\n  undefined4 localVar1;\n  undefined4 localVar2;\n  \n  ptr2 = (ushort *)(PTR_DAT_08003234 + (uint)(byte)*PTR_DAT_08003230 * 0x40);\n  var3 = calculate_float_08008eec(*(undefined4 *)PTR_DAT_08003238,param1);\n  var15 = reverse_bits_08008590(var3);\n  var4 = calculate_result_080095b8((int)var15,(int)((ulonglong)var15 >> 0x20));\n  var3 = calculate_float_08008eec(*(undefined4 *)(PTR_DAT_08003238 + 4),param2);\n  var15 = reverse_bits_08008590(var3);\n  var5 = calculate_result_080095b8((int)var15,(int)((ulonglong)var15 >> 0x20));\n  var3 = calculate_float_08008eec(*(undefined4 *)(PTR_DAT_08003238 + 8),param3);\n  var15 = reverse_bits_08008590(var3);\n  var6 = calculate_result_080095b8((int)var15,(int)((ulonglong)var15 >> 0x20));\n  *ptr2 = 0;\n  if (var4 < *(int *)PTR_DAT_0800323c) {\n    *ptr2 = *ptr2 | 0x20;\n  }\n  if (var5 < *(int *)(PTR_DAT_0800323c + 4)) {\n    *ptr2 = *ptr2 | 0x880;\n  }\n  if (var6 < *(int *)(PTR_DAT_0800323c + 8)) {\n    *ptr2 = *ptr2 | 0x200;\n  }\n  var13 = var4 - *(int *)PTR_DAT_0800323c;\n  if (var13 < 0) {\n    var13 = -var13;\n  }\n  *(int *)(ptr2 + 2) = var13;\n  var13 = var5 - *(int *)(PTR_DAT_0800323c + 4);\n  if (var13 < 0) {\n    var13 = -var13;\n  }\n  *(int *)(ptr2 + 4) = var13;\n  var13 = var6 - *(int *)(PTR_DAT_0800323c + 8);\n  if (var13 < 0) {\n    var13 = -var13;\n  }\n  *(int *)(ptr2 + 6) = var13;\n  var11 = *(uint *)(ptr2 + 6);\n  if (*(uint *)(ptr2 + 6) < *(uint *)(ptr2 + 4)) {\n    var11 = *(uint *)(ptr2 + 4);\n  }\n  var14 = *(uint *)(ptr2 + 2);\n  if (*(uint *)(ptr2 + 2) < var11) {\n    var14 = var11;\n  }\n  *(uint *)(ptr2 + 8) = var14;\n  if (*(int *)(ptr2 + 8) != 0) {\n    var3 = convert_to_fixed_point_08008e44(var4 - *(int *)PTR_DAT_0800323c);\n    var3 = float_bits_to_float_08009054(var3,*(undefined4 *)PTR_DAT_08003238);\n    var7 = convert_to_fixed_point_08008e44(var5 - *(int *)(PTR_DAT_0800323c + 4));\n    var7 = float_bits_to_float_08009054(var7,*(undefined4 *)(PTR_DAT_08003238 + 4));\n    var8 = convert_to_fixed_point_08008e44(var6 - *(int *)(PTR_DAT_0800323c + 8));\n    var8 = float_bits_to_float_08009054(var8,*(undefined4 *)(PTR_DAT_08003238 + 8));\n    var9 = calculate_float_08008eec(var3,var3);\n    var10 = calculate_float_08008eec(var7,var7);\n    var9 = calculate_float_08008cdc(var9,var10);\n    var10 = calculate_float_08008eec(var8,var8);\n    var9 = calculate_float_08008cdc(var9,var10);\n    var15 = reverse_bits_08008590(var9);\n    var15 = calculate_collision_08003004_080098d0_080098d0((int)var15,(int)((ulonglong)var15 >> 0x20));\n    var9 = calculate_float_bits_08008c30((int)var15,(int)((ulonglong)var15 >> 0x20));\n    *(undefined4 *)(ptr2 + 0x10) = var9;\n    var9 = float_bits_to_float_08009054(0x3f800000,*(undefined4 *)(ptr2 + 0x10));\n    if (param5 == '\\0') {\n      localVar2 = calculate_float_08008eec(param4,var9);\n    }\n    else {\n      localVar2 = float_bits_to_float_08009054(0x3f800000,param4);\n    }\n    var10 = calculate_float_08008eec(*(undefined4 *)(ptr2 + 0x10),localVar2);\n    *(undefined4 *)(ptr2 + 10) = var10;\n    var10 = convert_to_fixed_point_08008e44(*(undefined4 *)(ptr2 + 8));\n    var10 = calculate_float_08008eec(var10,localVar2);\n    var15 = reverse_bits_08008590(var10);\n    var15 = calculate_position_08009318((int)var15,(int)((ulonglong)var15 >> 0x20));\n    var10 = calculate_shift_amount_08008bf0((int)var15,(int)((ulonglong)var15 >> 0x20));\n    *(undefined4 *)(ptr2 + 0x1e) = var10;\n    var10 = convert_to_fixed_point_08008e44(*(undefined4 *)(ptr2 + 8));\n    var10 = calculate_float_08008eec(var10,var9);\n    var10 = calculate_float_08008eec(var10,*(undefined4 *)(PTR_DAT_08003560 + 0x20));\n    var10 = float_bits_to_float_08009054(var10,DAT_08003564);\n    var15 = reverse_bits_08008590(var10);\n    var15 = calculate_position_08009318((int)var15,(int)((ulonglong)var15 >> 0x20));\n    var10 = calculate_08008ba0((int)var15,(int)((ulonglong)var15 >> 0x20));\n    *(undefined4 *)(ptr2 + 0x18) = var10;\n    var3 = calculate_float_08008eec(var3,var9);\n    var7 = calculate_float_08008eec(var7,var9);\n    var8 = calculate_float_08008eec(var8,var9);\n    localVar1 = 0;\n    if ((*PTR_DAT_08003568 != *PTR_DAT_0800356c) &&\n       (var13 = is_end_of_string_08009264(*(undefined4 *)(PTR_DAT_08003570 + 0x18),0), var13 != 0)) {\n      var9 = calculate_float_08008eec(*(uint *)(PTR_DAT_08003570 + 0xc) ^ 0x80000000,var3);\n      var10 = calculate_float_08008eec(*(undefined4 *)(PTR_DAT_08003570 + 0x10),var7);\n      var9 = calculate_float_08008cd8(var9,var10);\n      var10 = calculate_float_08008eec(*(undefined4 *)(PTR_DAT_08003570 + 0x14),var8);\n      var9 = calculate_float_08008cd8(var9,var10);\n      var15 = reverse_bits_08008590(var9);\n      var13 = is_collision_not_detected_08008b24((int)var15,(int)((ulonglong)var15 >> 0x20),DAT_08003550,DAT_08003554);\n      if (var13 != 0) {\n        var13 = is_string_terminated_08009228(*(undefined4 *)(PTR_DAT_08003570 + 0x18),*(undefined4 *)(ptr2 + 10)\n                             );\n        if (var13 == 0) {\n          localVar1 = *(undefined4 *)(ptr2 + 10);\n        }\n        else {\n          localVar1 = *(undefined4 *)(PTR_DAT_08003570 + 0x18);\n        }\n        var15 = reverse_bits_08008590(var9);\n        var13 = isCollisionDetected_08008b60((int)var15,(int)((ulonglong)var15 >> 0x20),DAT_08003558,DAT_0800355c\n                             );\n        if (var13 != 0) {\n          var15 = reverse_bits_08008590(var9);\n          var15 = reverse_and_improve_080082d0(0,DAT_08003574,(int)var15,(int)((ulonglong)var15 >> 0x20));\n          var15 = calculate_product_08008640((int)var15,(int)((ulonglong)var15 >> 0x20),0,DAT_08003578);\n          var15 = calculate_collision_08003004_080098d0_080098d0((int)var15,(int)((ulonglong)var15 >> 0x20));\n          var9 = calculate_float_bits_08008c30((int)var15,(int)((ulonglong)var15 >> 0x20));\n          var15 = reverse_bits_08008590(localVar1);\n          var10 = calculate_float_08008eec(*(undefined4 *)(PTR_DAT_08003560 + 0x20),\n                                *(undefined4 *)(PTR_DAT_08003560 + 0x24));\n          var10 = calculate_float_08008eec(var10,var9);\n          var16 = reverse_bits_08008590(var10);\n          var17 = reverse_bits_08008590(var9);\n          var17 = reverse_and_improve_080082d0(0,DAT_08003574,(int)var17,(int)((ulonglong)var17 >> 0x20));\n          var16 = convert_float_to_uint_08008894((int)var16,(int)((ulonglong)var16 >> 0x20),(int)var17,\n                                (int)((ulonglong)var17 >> 0x20));\n          var16 = calculate_collision_08003004_080098d0_080098d0((int)var16,(int)((ulonglong)var16 >> 0x20));\n          var13 = is_collision_not_detected_08008b24((int)var15,(int)((ulonglong)var15 >> 0x20),(int)var16,\n                                (int)((ulonglong)var16 >> 0x20));\n          if (var13 == 0) {\n            var10 = calculate_float_08008eec(*(undefined4 *)(PTR_DAT_08003560 + 0x20),\n                                  *(undefined4 *)(PTR_DAT_08003560 + 0x24));\n            var10 = calculate_float_08008eec(var10,var9);\n            var15 = reverse_bits_08008590(var10);\n            var16 = reverse_bits_08008590(var9);\n            var16 = reverse_and_improve_080082d0(0,DAT_08003574,(int)var16,(int)((ulonglong)var16 >> 0x20));\n            var15 = convert_float_to_uint_08008894((int)var15,(int)((ulonglong)var15 >> 0x20),(int)var16,\n                                  (int)((ulonglong)var16 >> 0x20));\n            var15 = calculate_collision_08003004_080098d0_080098d0((int)var15,(int)((ulonglong)var15 >> 0x20));\n            localVar1 = calculate_float_bits_08008c30((int)var15,(int)((ulonglong)var15 >> 0x20));\n          }\n        }\n      }\n    }\n    *(undefined4 *)(ptr2 + 0xe) = localVar1;\n    var10 = calculate_hash_value_08002978(*(uint *)(PTR_DAT_08003560 + 0x20) ^ 0x80000000,0,\n                          *(undefined4 *)(ptr2 + 0x10));\n    var13 = is_string_terminated_08009228(localVar1,var10);\n    var9 = var10;\n    if (var13 != 0) {\n      var9 = localVar1;\n    }\n    *(undefined4 *)(ptr2 + 0xc) = var9;\n    var13 = check_strings_concatenated_08009250(var10,*(undefined4 *)(ptr2 + 10));\n    if (var13 == 0) {\n      *(undefined *)((int)ptr2 + 0x25) = 0;\n    }\n    else {\n      *(undefined *)((int)ptr2 + 0x25) = 1;\n    }\n    *(undefined *)(ptr2 + 0x12) = 1;\n    ptr1 = PTR_DAT_080035e0;\n    *(undefined4 *)(PTR_DAT_080035e0 + 0xc) = var3;\n    *(undefined4 *)(ptr1 + 0x10) = var7;\n    *(undefined4 *)(ptr1 + 0x14) = var8;\n    *(undefined4 *)(PTR_DAT_080035e0 + 0x18) = *(undefined4 *)(ptr2 + 10);\n    *PTR_DAT_080035e8 = *PTR_DAT_080035e4;\n    var2 = increment_and_reset_08002870(*PTR_DAT_080035e8);\n    *PTR_DAT_080035e4 = var2;\n    ptr1 = PTR_DAT_080035e0;\n    *(int *)PTR_DAT_080035e0 = var4;\n    *(int *)(ptr1 + 4) = var5;\n    *(int *)(ptr1 + 8) = var6;\n    concatenate_all_strings_and_calculate_collision_08003004s_08002edc();\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08009318",
                "FUN_08009250",
                "FUN_080098d0",
                "FUN_08008590",
                "FUN_08008b60",
                "FUN_08008640",
                "FUN_08008b24",
                "FUN_08008bf0",
                "FUN_08009264",
                "FUN_08009228",
                "FUN_08002870",
                "FUN_08002978",
                "FUN_08008cdc",
                "FUN_08002edc",
                "FUN_080082d0",
                "FUN_08008c30",
                "FUN_08008e44",
                "FUN_08008ba0",
                "FUN_08008cd8",
                "FUN_08009054",
                "FUN_08008894",
                "FUN_080095b8",
                "FUN_08008eec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003004",
            "calling": [
                "FUN_08001e98"
            ],
            "imported": false,
            "current_name": "calculate_collision_08003004"
        },
        "FUN_080066cc": {
            "renaming": {
                "FUN_080066cc": "calculate_shift_amount_080066cc",
                "uVar1": "function_result",
                "uVar2": "leading_zeroes_count",
                "PTR_DAT_08006714": "shift_amount_pointer",
                "DAT_08006710": "data_pointer"
            },
            "code": "uint calculate_shift_amount_080066cc(void)\n{\n  uint result;\n  uint function_result;\n  uint leading_zeroes_count;\n  \n  function_result = calculate_and_store_divisor_08006628();\n  leading_zeroes_count = count_leading_zeroes(0x70000);\n  result = (*(uint *)(DAT_08006710 + 8) & 0xe000) >> (leading_zeroes_count & 0xff);\n  return function_result >> PTR_DAT_08006714[result];\n}",
            "called": [
                "FUN_08006628"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080066cc",
            "calling": [
                "FUN_08007f54"
            ],
            "imported": false,
            "current_name": "calculate_shift_amount_080066cc"
        },
        "FUN_080018fc": {
            "renaming": {
                "FUN_080018fc": "set_param_in_memory_080018fc",
                "param_1": "new_param_value",
                "*(uint *)(DAT_08001928 + 0x14)": "memory_location",
                "0xfffff55f": "bitwise_mask"
            },
            "code": "void set_param_in_memory_080018fc(uint new_param_value)\n{\n  uint* *(uint *)(DAT_08001928 + 0x14) = (uint*)(DAT_08001928 + 0x14);\n  **(uint *)(DAT_08001928 + 0x14) = new_param_value | (**(uint *)(DAT_08001928 + 0x14) & 0xfffff55f);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080018fc",
            "calling": [
                "FUN_08001994"
            ],
            "imported": false,
            "current_name": "set_param_in_memory_080018fc"
        },
        "FUN_080039bc": {
            "renaming": {
                "FUN_080039bc": "processChecksumsAndUpdate_080039bc",
                "iVar1": "result",
                "uVar2": "errorCode",
                "local_9": "index",
                "check_sum_and_update_checksum_08004d2c": "calculateChecksumAndUpdate",
                "PTR_DAT_08003a14": "PTR_data",
                "printErrorMessage_08004030": "printErrorMessage",
                "processString_0800369c": "processString",
                "FUN_080005b4": "getErrorCode"
            },
            "code": "void processChecksumsAndUpdate_080039bc() {\n  int result;\n  undefined4 errorCode;\n  byte index;\n  for (index = 0; index < 2; index++) {\n    result = calculateChecksumAndUpdate(index, PTR_DAT_08003a14);\n    if (result == 0) {\n      printErrorMessage(10);\n    }\n    else if (*PTR_DAT_08003a14 != '\\0') {\n      processString(PTR_DAT_08003a14);\n      errorCode = getErrorCode(PTR_DAT_08003a14);\n      printErrorMessage(errorCode);\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_08004d2c",
                "FUN_0800369c",
                "FUN_080005b4",
                "FUN_08004030"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080039bc",
            "calling": [
                "FUN_08001ddc",
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "processChecksumsAndUpdate_080039bc"
        },
        "FUN_0800618c": {
            "renaming": {
                "FUN_0800618c": "validate_inputs_0800618c",
                "param_1": "inputs",
                "param_2": "num_inputs",
                "lVar1": "result1",
                "iVar2": "index",
                "uVar3": "curr_val",
                "uVar4": "max_val",
                "uVar5": "curr_time"
            },
            "code": "int validate_inputs_0800618c(uint *inputs, uint num_inputs) {\n    long long result1;\n    int iVar2;\n    uint curr_val;\n    uint max_val;\n    ulonglong curr_time;\n    \n    if ((*PTR_DAT_08006400 & 0xf) < num_inputs) {\n        *(char *)PTR_DAT_08006400 = (char)num_inputs;\n        if (num_inputs != (*PTR_DAT_08006400 & 0xf)) {\n            return 1;\n        }\n        if ((*inputs & 1) != 0) {\n            if (inputs[1] == 1) {\n                if ((*PTR_DAT_08006404 & 0x20000) == 0) {\n                    return 1;\n                }\n            }\n            else if ((inputs[1] != 2) && ((*PTR_DAT_08006404 & 2) == 0)) {\n                return 1;\n            }\n            PTR_DAT_08006404[2] = inputs[1] | PTR_DAT_08006404[2] & 0xfffffffc;\n            iVar2 = get_value_from_pointer_08005a84();\n            max_val = iVar2 + 5000;\n            if (inputs[1] == 1) {\n                while ((PTR_DAT_08006404[2] & 0xc) != 4) {\n                    curr_val = get_value_from_pointer_08005a84();\n                    if (max_val <= curr_val) {\n                        return 3;\n                    }\n                }\n            }\n            else if (inputs[1] == 2) {\n                while ((PTR_DAT_08006404[2] & 0xc) != 8) {\n                    curr_val = get_value_from_pointer_08005a84();\n                    if (max_val <= curr_val) {\n                        return 3;\n                    }\n                }\n            }\n            else {\n                while ((PTR_DAT_08006404[2] & 0xc) != 0) {\n                    curr_val = get_value_from_pointer_08005a84();\n                    if (max_val <= curr_val) {\n                        return 3;\n                    }\n                }\n            }\n        }\n    }\n    else {\n        if ((*inputs & 1) != 0) {\n            if (inputs[1] == 1) {\n                if ((*PTR_DAT_08006404 & 0x20000) == 0) {\n                    return 1;\n                }\n            }\n            else if (inputs[1] == 2) {\n                if ((*PTR_DAT_08006404 & 0x2000000) == 0) {\n                    return 1;\n                }\n            }\n            else if ((*PTR_DAT_08006404 & 2) == 0) {\n                return 1;\n            }\n            PTR_DAT_08006404[2] = inputs[1] | PTR_DAT_08006404[2] & 0xfffffffc;\n            iVar2 = get_value_from_pointer_08005a84();\n            max_val = iVar2 + 5000;\n            if (inputs[1] == 1) {\n                while ((PTR_DAT_08006404[2] & 0xc) != 4) {\n                    curr_val = get_value_from_pointer_08005a84();\n                    if (max_val <= curr_val) {\n                        return 3;\n                    }\n                }\n            }\n            else if (inputs[1] == 2) {\n                while ((PTR_DAT_08006404[2] & 0xc) != 8) {\n                    curr_val = get_value_from_pointer_08005a84();\n                    if (max_val <= curr_val) {\n                        return 3;\n                    }\n                }\n            }\n            else {\n                while ((PTR_DAT_08006404[2] & 0xc) != 0) {\n                    curr_val = get_value_from_pointer_08005a84();\n                    if (max_val <= curr_val) {\n                        return 3;\n                    }\n                }\n            }\n        }\n        *(char *)PTR_DAT_08006400 = (char)num_inputs;\n        if (num_inputs != (*PTR_DAT_08006400 & 0xf)) {\n            return 1;\n        }\n    }\n    if ((*inputs & 2) != 0) {\n        PTR_DAT_08006404[2] = inputs[2] | PTR_DAT_08006404[2] & 0xffffff0f;\n    }\n    if ((*inputs & 4) != 0) {\n        PTR_DAT_08006404[2] = inputs[3] | PTR_DAT_08006404[2] & 0xffffe3ff;\n    }\n    if ((*inputs & 8) != 0) {\n        PTR_DAT_08006404[2] = inputs[4] << 3 | PTR_DAT_08006404[2] & 0xffff1fff;\n    }\n    curr_time = calculate_and_store_divisor_08006628();\n    result1 = (ulonglong)PTR_DAT_08006408 * (curr_time & 0xffffffff);\n    is_param_valid_08005c30((uint)((ulonglong)result1 >> 0x26),(int)(curr_time >> 0x20),(int)result1);\n    return 0;\n}",
            "called": [
                "FUN_08006628",
                "FUN_08005c30",
                "FUN_08005a84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800618c",
            "calling": [
                "FUN_08007436"
            ],
            "imported": false,
            "current_name": "validate_inputs_0800618c"
        },
        "FUN_08006998": {
            "renaming": {
                "FUN_08006998": "get_bits_from_uint_08006998",
                "DAT_080069b0": "PTR_DATA"
            },
            "code": "uint get_bits_from_uint_08006998(void)\n{\n  uint value = *(uint *)(DAT_080069b0 + 0xc);\n  uint shifted_value = value >> 8;\n  uint bits = shifted_value & 7;\n  return bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006998",
            "calling": [
                "FUN_08006cf6",
                "FUN_08006d8a"
            ],
            "imported": false,
            "current_name": "get_bits_from_uint_08006998"
        },
        "FUN_080004ac": {
            "renaming": {
                "FUN_080004ac": "initialize_data_and_check_sum_080004ac",
                "PTR_DAT_080004f0": "data",
                "PTR_DAT_080004f4": "array",
                "PTR_DAT_080004f8": "last_value"
            },
            "code": "void initialize_data_and_check_sum_080004ac(void)\n{\n  int sum;\n  int is_sum_valid;\n  int* PTR_DAT_080004f0 = PTR_DAT_080004f0;\n  int* PTR_DAT_080004f4 = PTR_DAT_080004f4;\n  int* PTR_DAT_080004f8 = PTR_DAT_080004f8;\n  fill_memory_with_value_0800b430(PTR_DAT_080004f0, 0, 0x38);\n  PTR_DAT_080004f0[2] = PTR_DAT_080004f4[4];\n  set_parameters_in_PTR_DAT_080004f4_08000478(PTR_DAT_080004f0[0], PTR_DAT_080004f0[1], PTR_DAT_080004f0[2]);\n  PTR_DAT_080004f0[1] = 1;\n  sum = is_sum_equal_to_PTR_DAT_080004f8_and_fill_memory_with_value_08004d7c(PTR_DAT_080004f0[0x1c], PTR_DAT_080004f8);\n  is_sum_valid = (sum != 0);\n  if (!is_sum_valid) {\n    printErrorMessage_08004030(10);\n  }\n  return;\n}",
            "called": [
                "FUN_08000478",
                "FUN_08004d7c",
                "FUN_0800b430",
                "FUN_08004030"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004ac",
            "calling": [
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "initialize_data_and_check_sum_080004ac"
        },
        "FUN_080078f4": {
            "renaming": {
                "FUN_080078f4": "calculate_sum_of_four_numbers_080078f4",
                "local_10": "index",
                "local_c": "sum"
            },
            "code": "uint calculate_sum_of_four_numbers_080078f4(void)\n{\n  int index;\n  uint sum = 0;\n  for (index = 0; index < 4; index++) {\n    sum = *(uint *)(PTR_DAT_0800792c + index * 4) | sum;\n  }\n  return sum;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078f4",
            "calling": [
                "FUN_08001994",
                "FUN_08007930"
            ],
            "imported": false,
            "current_name": "calculate_sum_of_four_numbers_080078f4"
        },
        "FUN_080041a0": {
            "renaming": {
                "FUN_080041a0": "displayMessage_080041a0",
                "param_1": "messageType",
                "processString_080036c6": "processString",
                "PTR_DAT_0800420c": "PTR_MESSAGE_HEADER",
                "PTR_s_Reset_to_continue_08004210": "PTR_RESET_TO_CONTINUE_MESSAGE",
                "PTR_s___H____X__to_unlock_08004214": "PTR_UNLOCK_MESSAGE",
                "PTR_s_Caution__Unlocked_08004218": "PTR_CAUTION_MESSAGE",
                "PTR_s_Enabled_0800421c": "PTR_ENABLED_MESSAGE",
                "PTR_s_Disabled_08004220": "PTR_DISABLED_MESSAGE",
                "PTR_DAT_08004224": "PTR_MESSAGE_FOOTER"
            },
            "code": "void displayMessage_080041a0(int messageType) {\n    processString(PTR_DAT_0800420c);\n    switch(messageType) {\n        case 1:\n            processString(PTR_s_Reset_to_continue_08004210);\n            break;\n        case 2:\n            processString(PTR_s___H____X__to_unlock_08004214);\n            break;\n        case 3:\n            processString(PTR_s_Caution__Unlocked_08004218);\n            break;\n        case 4:\n            processString(PTR_s_Enabled_0800421c);\n            break;\n        case 5:\n            processString(PTR_s_Disabled_08004220);\n            break;\n    }\n    processString(PTR_DAT_08004224);\n    return;\n}",
            "called": [
                "FUN_080036c6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041a0",
            "calling": [
                "FUN_08001ddc",
                "FUN_08003b98",
                "FUN_08003a74"
            ],
            "imported": false,
            "current_name": "displayMessage_080041a0"
        },
        "FUN_08008bf0": {
            "renaming": {
                "FUN_08008bf0": "calculate_shift_amount_08008bf0",
                "param_1": "dividend",
                "param_2": "divisor",
                "iVar1": "temp_var",
                "uVar2": "quotient"
            },
            "code": "uint calculate_shift_amount_08008bf0(uint dividend, uint divisor)\n{\n  int temp_var;\n  uint quotient;\n  \n  if ((divisor & 0x80000000) != 0)\n  {\n    return 0;\n  }\n  \n  temp_var = divisor * 2 + 0x200000;\n  if (divisor * 2 < 0xffe00000)\n  {\n    if (-1 < temp_var)\n    {\n      return 0;\n    }\n    quotient = -(temp_var >> 0x15) - 0x3e1;\n    if (-1 < (int)quotient)\n    {\n      return (divisor << 0xb | 0x80000000 | dividend >> 0x15) >> (quotient & 0xff);\n    }\n  }\n  else if ((dividend | divisor << 0xc) != 0)\n  {\n    return 0;\n  }\n  return 0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008bf0",
            "calling": [
                "FUN_08001994",
                "FUN_080005b4",
                "FUN_08003004",
                "FUN_08004e30",
                "FUN_08002408",
                "FUN_08001f00",
                "FUN_08003b98",
                "FUN_08002c18"
            ],
            "imported": false,
            "current_name": "calculate_shift_amount_08008bf0"
        },
        "FUN_08003a18": {
            "renaming": {
                "FUN_08003a18": "check_flags_08003a18",
                "param_1": "flag",
                "PTR_DAT_08003a70": "ptr",
                "mask_1": "0x80",
                "mask_2": "0x40",
                "mask_3": "0x20"
            },
            "code": "void check_flags_08003a18(uint8_t flag)\n{\n    uint8_t mask_1 = 0x80;\n    uint8_t mask_2 = 0x40;\n    uint8_t mask_3 = 0x20;\n    uint8_t* PTR_DAT_08003a70 = PTR_DAT_08003a70;\n    \n    if ((flag & mask_1) != mask_1) {\n        if ((flag & mask_2) != mask_2) {\n            if ((flag & mask_3) == mask_3) {\n                PTR_DAT_08003a70[2] |= 2;\n            }\n        }\n        else {\n            PTR_DAT_08003a70[2] |= 8;\n        }\n    }\n    else {\n        enable_flag_if_not_set_and_check_080025e8();\n    }\n    return;\n}",
            "called": [
                "FUN_080025e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a18",
            "calling": [
                "FUN_080074c8"
            ],
            "imported": false,
            "current_name": "check_flags_08003a18"
        },
        "FUN_08005790": {
            "renaming": {
                "FUN_08005790": "set_flags_based_on_data_08005790",
                "PTR_DAT_080057d4": "data",
                "PTR_DAT_080057dc": "data_address_1",
                "PTR_DAT_080057d8": "data_address_2",
                "PTR_DAT_080057e0": "data_address_3",
                "set_data_at_address_08007c40": "set_data",
                "set_global_variable_value_08007c5e": "set_global_variable_value"
            },
            "code": "void set_flags_based_on_data_08005790()\n{\n  do_nothing();\n  if (PTR_DAT_080057d4[1] == '\\x03') {\n    *(undefined2 *)PTR_DAT_080057dc = *(undefined2 *)(PTR_DAT_080057d8 + 0x18);\n    *(undefined2 *)PTR_DAT_080057d8 = *(undefined2 *)(PTR_DAT_080057d8 + 0x1a);\n    set_PTR_DAT_080057d4(0x69);\n    set_global_variable_value((byte)PTR_DAT_080057d4[0xd] + 5) * 0x15);\n    set_flags_based_on_data_08005790();\n  }\n  return;\n}",
            "called": [
                "FUN_08007b70",
                "FUN_08007c5e",
                "FUN_08005318",
                "FUN_08007c40"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005790",
            "calling": [
                "FUN_08001d4c",
                "FUN_0800583c",
                "FUN_0800585c"
            ],
            "imported": false,
            "current_name": "set_flags_based_on_data_08005790"
        },
        "FUN_08001994": {
            "renaming": {
                "FUN_08001994": "calculate_collision_08001994",
                "param_1": "bit_flags",
                "param_2": "should_xor",
                "param_3": "should_xor_sum",
                "param_4": "product",
                "uVar1": "float_result",
                "uVar2": "max_value",
                "uVar3": "uint_result",
                "uVar4": "reverse_product",
                "local_61": "bit_counter",
                "local_5c": "first_value",
                "local_58": "second_value",
                "local_54": "third_value",
                "local_4e": "initial_value",
                "local_4c": "minimum_value",
                "local_48": "shift_amount",
                "local_44": "float_bits",
                "local_40": "max_value_so_far",
                "local_3c": "four_num_sum",
                "local_36": "new_value",
                "local_34": "sum_threshold",
                "local_30": "sum_divisor",
                "local_2c": "sum_difference",
                "local_28": "first_offset",
                "local_24": "third_offset",
                "local_20": "second_offset",
                "local_1a": "param_in_memory",
                "local_18": "min_value",
                "local_11": "counter"
            },
            "code": "\nvoid calculate_collision_08001994(byte bit_flags,char should_xor,char should_xor_sum,undefined4 product)\n\n{\n  undefined4 float_result;\n  uint max_value;\n  undefined8 uint_result;\n  undefined8 reverse_product;\n  byte bit_counter;\n  uint first_value;\n  uint second_value;\n  uint third_value;\n  ushort initial_value;\n  uint minimum_value;\n  int shift_amount;\n  undefined4 float_bits;\n  uint max_value_so_far;\n  uint four_num_sum;\n  ushort new_value;\n  uint sum_threshold;\n  uint sum_divisor;\n  int sum_difference;\n  int first_offset;\n  int third_offset;\n  int second_offset;\n  ushort param_in_memory;\n  uint min_value;\n  char counter;\n  \n  counter = '\\0';\n  fill_memory_with_value_0800b430(&first_value,0,0xc);\n  if ((bit_flags & 1) != 0) {\n    counter = counter + '\\x01';\n    uint_result = reverse_bits_08008590(*(undefined4 *)PTR_DAT_08001c90);\n    first_value = calculate_result_080095b8((int)uint_result,(int)((ulonglong)uint_result >> 0x20));\n  }\n  if ((bit_flags & 2) != 0) {\n    counter = counter + '\\x01';\n    uint_result = reverse_bits_08008590(*(undefined4 *)(PTR_DAT_08001c90 + 4));\n    second_value = calculate_result_080095b8((int)uint_result,(int)((ulonglong)uint_result >> 0x20));\n  }\n  if ((bit_flags & 4) != 0) {\n    counter = counter + '\\x01';\n    uint_result = reverse_bits_08008590(*(undefined4 *)(PTR_DAT_08001c90 + 8));\n    third_value = calculate_result_080095b8((int)uint_result,(int)((ulonglong)uint_result >> 0x20));\n  }\n  max_value = third_value;\n  if (third_value < second_value) {\n    max_value = second_value;\n  }\n  max_value_so_far = first_value;\n  if (first_value < max_value) {\n    max_value_so_far = max_value;\n  }\n  uint_result = reverse_bits_0800854c(max_value_so_far);\n  reverse_product = reverse_bits_0800854c(counter);\n  reverse_product = calculate_collision_08001994_080098d0_080098d0((int)reverse_product,(int)((ulonglong)reverse_product >> 0x20));\n  uint_result = convert_float_to_uint_08008894((int)uint_result,(int)((ulonglong)uint_result >> 0x20),(int)reverse_product,\n                       (int)((ulonglong)reverse_product >> 0x20));\n  float_bits = calculate_float_bits_08008c30((int)uint_result,(int)((ulonglong)uint_result >> 0x20));\n  float_result = calculate_float_08008eec(*(undefined4 *)(PTR_DAT_08001c90 + 0x20),float_bits);\n  float_result = float_bits_to_float_08009054(float_result,DAT_08001c94);\n  uint_result = reverse_bits_08008590(float_result);\n  uint_result = calculate_position_08009318((int)uint_result,(int)((ulonglong)uint_result >> 0x20));\n  shift_amount = calculate_shift_amount_08008bf0((int)uint_result,(int)((ulonglong)uint_result >> 0x20));\n  uint_result = reverse_bits_0800854c(counter);\n  uint_result = calculate_collision_08001994_080098d0_080098d0((int)uint_result,(int)((ulonglong)uint_result >> 0x20));\n  reverse_product = reverse_bits_08008590(product);\n  uint_result = calculate_product_08008640((int)uint_result,(int)((ulonglong)uint_result >> 0x20),(int)reverse_product,\n                       (int)((ulonglong)reverse_product >> 0x20));\n  float_result = calculate_float_bits_08008c30((int)uint_result,(int)((ulonglong)uint_result >> 0x20));\n  float_result = calculate_float_08008eec(float_bits,float_result);\n  float_result = float_bits_to_float_08009054(DAT_08001c98,float_result);\n  uint_result = reverse_bits_08008590(float_result);\n  minimum_value = calculate_result_080095b8((int)uint_result,(int)((ulonglong)uint_result >> 0x20));\n  min_value = DAT_08001c9c;\n  if (minimum_value < DAT_08001c9c) {\n    min_value = minimum_value;\n  }\n  initial_value = *(ushort *)(PTR_DAT_08001c90 + 0x18);\n  param_in_memory = *(ushort *)(PTR_DAT_08001c90 + 0x1a) ^ *(ushort *)(PTR_DAT_08001c90 + 0x2a) & 0xaa0;\n  if (should_xor == '\\0') {\n    param_in_memory = param_in_memory ^ 0xaa0;\n  }\n  set_param_in_memory_080018fc(param_in_memory);\n  update_value_at_address_080018cc(initial_value);\n  first_offset = -(max_value_so_far >> 1);\n  sum_difference = min_value - (byte)PTR_DAT_08001c90[0xd];\n  sum_divisor = 0;\n  sum_threshold = 10000;\n  bit_counter = bit_flags;\n  third_offset = first_offset;\n  second_offset = first_offset;\n  while( true ) {\n    new_value = initial_value;\n    four_num_sum = calculate_sum_of_four_numbers_080078f4();\n    if (should_xor_sum == '\\0') {\n      four_num_sum = four_num_sum ^ 0x1e;\n    }\n    if (((bit_counter & 1) != 0) && (second_offset = second_offset + first_value, 0 < second_offset)) {\n      if ((four_num_sum & 0x10) == 0) {\n        bit_counter = bit_counter & 0xfe;\n      }\n      else {\n        new_value = new_value ^ 0x10;\n      }\n      second_offset = second_offset - max_value_so_far;\n    }\n    if (((bit_counter & 2) != 0) && (third_offset = third_offset + second_value, 0 < third_offset)) {\n      if ((four_num_sum & 8) == 0) {\n        bit_counter = bit_counter & 0xfd;\n      }\n      else {\n        new_value = new_value ^ 0x440;\n      }\n      third_offset = third_offset - max_value_so_far;\n    }\n    if (((bit_counter & 4) != 0) && (first_offset = first_offset + third_value, 0 < first_offset)) {\n      if ((four_num_sum & 4) == 0) {\n        bit_counter = bit_counter & 0xfb;\n      }\n      else {\n        new_value = new_value ^ 0x100;\n      }\n      first_offset = first_offset - max_value_so_far;\n    }\n    if ((bit_counter == 0) || ((PTR_DAT_08001d40[2] & 0x10) != 0)) break;\n    update_value_at_address_080018cc(new_value);\n    do_nothing_08002828(PTR_DAT_08001d44[0xd]);\n    update_value_at_address_080018cc(initial_value);\n    do_nothing_08002828(sum_difference);\n    if ((minimum_value < min_value) && (sum_threshold = min_value + sum_threshold, 20000 < sum_threshold)) {\n      sum_threshold = sum_threshold - 20000;\n      sum_divisor = shift_amount + sum_divisor;\n      min_value = DAT_08001d48 / sum_divisor;\n      if (min_value < minimum_value) {\n        min_value = minimum_value;\n      }\n      sum_difference = min_value - (byte)PTR_DAT_08001d44[0xd];\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_08009318",
                "FUN_08008590",
                "FUN_080098d0",
                "FUN_08008640",
                "FUN_080078f4",
                "FUN_08008bf0",
                "FUN_0800b430",
                "FUN_080018fc",
                "FUN_08008c30",
                "FUN_080018cc",
                "FUN_08002828",
                "FUN_08009054",
                "FUN_08008894",
                "FUN_080095b8",
                "FUN_0800854c",
                "FUN_08008eec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001994",
            "calling": [
                "FUN_08001d4c"
            ],
            "imported": false,
            "current_name": "calculate_collision_08001994"
        },
        "FUN_08007854": {
            "renaming": {
                "FUN_08007854": "get_bit_at_index_08007854",
                "param_1": "index",
                "PTR_": "pointer_",
                "DAT_": "data_"
            },
            "code": "uint get_bit_at_index_08007854(uint index)\n{\n    uint base_address = ((int)index >> 4) * 0x400 + 0x40020010;\n    uint bit_mask = 1 << (index & 0xf);\n    uint result = *(uint *)base_address >> bit_mask & 1;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007854",
            "calling": [
                "FUN_08007884"
            ],
            "imported": false,
            "current_name": "get_bit_at_index_08007854"
        },
        "FUN_08004900": {
            "renaming": {
                "FUN_08004900": "printAbsoluteValueAndProcessStrings_08004900",
                "param_1": "input",
                "param_2": "value",
                "PTR_DAT_08004934": "PTR_DAT_message1",
                "PTR_DAT_08004938": "PTR_DAT_message2",
                "PTR_DAT_0800493c": "PTR_DAT_message3",
                "processString_080036c6": "processString",
                "printAbsoluteValue_080037fc": "printAbsoluteValue",
                "processString_0800369c": "processString"
            },
            "code": "void printAbsoluteValueAndProcessStrings_08004900(undefined input, undefined4 value) {\n  processString(PTR_DAT_08004934);\n  printAbsoluteValue(input);\n  processString(PTR_DAT_08004938);\n  processString(value);\n  processString(PTR_DAT_0800493c);\n  return;\n}",
            "called": [
                "FUN_0800369c",
                "FUN_080037fc",
                "FUN_080036c6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004900",
            "calling": [
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "printAbsoluteValueAndProcessStrings_08004900"
        },
        "FUN_08005318": {
            "renaming": {
                "FUN_08005318": "do_nothing_08005318"
            },
            "code": "\nvoid do_nothing_08005318(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005318",
            "calling": [
                "FUN_08005790"
            ],
            "imported": false,
            "current_name": "do_nothing_08005318"
        },
        "FUN_08004228": {
            "renaming": {
                "FUN_08004228": "printHelpMessage_08004228",
                "PTR_s__Grbl_0_8c______for_help__08004238": "helpMessage",
                "processString_080036c6": "processStringForHelp"
            },
            "code": "void printHelpMessage_08004228(void)\n{\n    processStringForHelp(PTR_s__Grbl_0_8c______for_help__08004238);\n    return;\n}",
            "called": [
                "FUN_080036c6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004228",
            "calling": [
                "FUN_080039a0"
            ],
            "imported": false,
            "current_name": "printHelpMessage_08004228"
        },
        "FUN_08009b24": {
            "renaming": {
                "FUN_08009b24": "calculate_result_08009b24",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "uVar1": "constant",
                "iVar2": "collision_detected",
                "uVar3": "max_num",
                "iVar4": "exponent",
                "uVar5": "num5",
                "iVar6": "exponent2",
                "uVar7": "min_num",
                "uVar8": "num8",
                "uVar9": "num9",
                "uVar10": "result1",
                "uVar11": "result2",
                "uVar12": "result3",
                "uVar13": "result4",
                "local_3c": "shift_amount"
            },
            "code": "\nuint calculate_result_08009b24(uint num1,uint num2,uint num3,uint num4)\n\n{\n  undefined4 constant;\n  int collision_detected;\n  uint max_num;\n  int exponent;\n  undefined4 num5;\n  int exponent2;\n  uint min_num;\n  undefined4 num8;\n  undefined4 num9;\n  undefined8 result1;\n  undefined8 result2;\n  undefined8 result3;\n  undefined8 result4;\n  int shift_amount;\n  \n  constant = DAT_08009d70;\n  num2 = num2 & 0x7fffffff;\n  num4 = num4 & 0x7fffffff;\n  max_num = num1;\n  min_num = num2;\n  if (num2 < num4) {\n    max_num = num3;\n    num3 = num1;\n    min_num = num4;\n    num4 = num2;\n  }\n  if (0x3c00000 < (int)(min_num - num4)) {\n    max_num = calculate_double_precision_080082d4(max_num,min_num,num3,num4);\n    return max_num;\n  }\n  if (DAT_08009d68 < (int)min_num) {\n    if (DAT_08009d74 < (int)min_num) {\n      if ((min_num & 0xfffff | max_num) != 0) {\n        max_num = calculate_double_precision_080082d4(max_num,min_num,num3,num4);\n      }\n      if ((num4 ^ 0x7ff00000 | num3) != 0) {\n        return max_num;\n      }\n      return num3;\n    }\n    min_num = min_num + 0xda800000;\n    num4 = num4 + 0xda800000;\n    shift_amount = 600;\n  }\n  else {\n    shift_amount = 0;\n  }\n  result2 = CONCAT44(min_num,max_num);\n  result1 = CONCAT44(num4,num3);\n  if ((int)num4 <= DAT_08009d6c) {\n    if ((int)num4 < 0x100000) {\n      if ((num4 | num3) == 0) {\n        return max_num;\n      }\n      result1 = calculate_product_08008640(num3,num4,0,DAT_08009d70);\n      result2 = calculate_product_08008640(max_num,min_num,0,constant);\n      shift_amount = shift_amount + -0x3fe;\n    }\n    else {\n      min_num = min_num + 0x25800000;\n      result2 = CONCAT44(min_num,max_num);\n      num4 = num4 + 0x25800000;\n      result1 = CONCAT44(num4,num3);\n      shift_amount = shift_amount + -600;\n    }\n  }\n  num9 = (undefined4)((ulonglong)result2 >> 0x20);\n  num8 = (undefined4)result2;\n  exponent2 = (int)((ulonglong)result1 >> 0x20);\n  num5 = (undefined4)result1;\n  result1 = reverse_and_improve_080082d0(num8,num9,num5,exponent2);\n  exponent = (int)((ulonglong)result1 >> 0x20);\n  constant = (undefined4)result1;\n  collision_detected = is_collision_not_detected_08008b24(num5,exponent2,constant,exponent);\n  if (collision_detected == 0) {\n    result1 = calculate_product_08008640(0,num4,0);\n    result2 = calculate_product_08008640(constant,exponent + -0x80000000,constant,exponent);\n    result3 = calculate_double_precision_080082d4(num8,num9,num8,num9);\n    result3 = reverse_and_improve_080082d0((int)result3,(int)((ulonglong)result3 >> 0x20),0,min_num + 0x100000);\n    result3 = calculate_product_08008640((int)result3,(int)((ulonglong)result3 >> 0x20),num5,exponent2);\n    result4 = reverse_and_improve_080082d0(num5,exponent2,0,num4);\n    result4 = calculate_product_08008640((int)result4,(int)((ulonglong)result4 >> 0x20),0,min_num + 0x100000);\n    result3 = calculate_double_precision_080082d4((int)result3,(int)((ulonglong)result3 >> 0x20),(int)result4,\n                          (int)((ulonglong)result4 >> 0x20));\n    result2 = reverse_and_improve_080082d0((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                          (int)((ulonglong)result3 >> 0x20));\n    reverse_and_improve_080082d0((int)result1,(int)((ulonglong)result1 >> 0x20),(int)result2,\n                 (int)((ulonglong)result2 >> 0x20));\n    result1 = calculate_0800a1bc();\n  }\n  else {\n    result1 = calculate_product_08008640(0,min_num,0,min_num);\n    result2 = calculate_product_08008640(num5,exponent2 + -0x80000000,num5,exponent2);\n    result3 = calculate_double_precision_080082d4(num8,num9,0,min_num);\n    result4 = reverse_and_improve_080082d0(num8,num9,0,min_num);\n    result3 = calculate_product_08008640((int)result3,(int)((ulonglong)result3 >> 0x20),(int)result4,\n                          (int)((ulonglong)result4 >> 0x20));\n    result2 = reverse_and_improve_080082d0((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                          (int)((ulonglong)result3 >> 0x20));\n    reverse_and_improve_080082d0((int)result1,(int)((ulonglong)result1 >> 0x20),(int)result2,\n                 (int)((ulonglong)result2 >> 0x20));\n    result1 = calculate_0800a1bc();\n  }\n  max_num = (uint)result1;\n  if (shift_amount != 0) {\n    max_num = calculate_product_08008640(max_num,(int)((ulonglong)result1 >> 0x20),0,shift_amount * 0x100000 + 0x3ff00000);\n  }\n  return max_num;\n}\n\n",
            "called": [
                "FUN_080082d0",
                "FUN_0800a1bc",
                "FUN_080082d4",
                "FUN_08008640",
                "FUN_08008b24"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009b24",
            "calling": [
                "FUN_0800981c"
            ],
            "imported": false,
            "current_name": "calculate_result_08009b24"
        },
        "FUN_080076c8": {
            "renaming": {
                "FUN_080076c8": "toggle_bit_at_position_080076c8",
                "param_1": "position",
                "PTR_": "ptr",
                "DAT_": "mask"
            },
            "code": "void toggle_bit_at_position_080076c8(uint position){\n    uint* PTR_ = (uint*)(((int)position >> 4) * 0x400 + 0x40020014);\n    uint DAT_ = 1 << (position & 0xf);\n    *PTR_ = *PTR_ ^ DAT_;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080076c8",
            "calling": [
                "FUN_08007756"
            ],
            "imported": false,
            "current_name": "toggle_bit_at_position_080076c8"
        },
        "FUN_0800530c": {
            "renaming": {
                "FUN_0800530c": "do_nothing_0800530c"
            },
            "code": "\nvoid do_nothing_0800530c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800530c",
            "calling": [
                "FUN_080057e4"
            ],
            "imported": false,
            "current_name": "do_nothing_0800530c"
        },
        "FUN_08006a8c": {
            "renaming": {
                "FUN_08006a8c": "set_bit_in_array_08006a8c",
                "param_1": "bit_position",
                "DAT_08006abc": "array_ptr",
                "index": "index",
                "bit_mask": "bit_mask"
            },
            "code": "void set_bit_in_array_08006a8c(byte bit_position){\n    int* DAT_08006abc = DAT_08006abc;\n    uint index = (((uint)(int)(char)bit_position >> 5) + 0x60) * 4;\n    uint bit_mask = 1 << (bit_position & 0x1f);\n    *(DAT_08006abc + index) = bit_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006a8c",
            "calling": [
                "FUN_08006dfe"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_08006a8c"
        },
        "FUN_0800283a": {
            "renaming": {
                "FUN_0800283a": "store_and_convert_fixed_point_values_0800283a",
                "PTR_DAT_08002868": "ptr_data",
                "store_params_in_memory_080035ec": "store_params_in_memory",
                "convert_and_store_fixed_point_values_080004fc": "convert_and_store_fixed_point_values"
            },
            "code": "void store_and_convert_fixed_point_values_0800283a(void)\n{\n  int param1 = *(int *)(PTR_DAT_08002868 + 4);\n  int param2 = *(int *)(PTR_DAT_08002868 + 8);\n  int param3 = *(int *)(PTR_DAT_08002868 + 0xc);\n  store_params_in_memory(param1, param2, param3);\n  convert_and_store_fixed_point_values(param1, param2, param3);\n  return;\n}",
            "called": [
                "FUN_080004fc",
                "FUN_080035ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800283a",
            "calling": [
                "FUN_080024c4",
                "FUN_08001ddc"
            ],
            "imported": false,
            "current_name": "store_and_convert_fixed_point_values_0800283a"
        },
        "FUN_0800881c": {
            "renaming": {
                "FUN_0800881c": "calculateResult_0800881c",
                "param_1": "firstParam",
                "param_2": "secondParam",
                "param_3": "thirdParam",
                "param_4": "fourthParam",
                "uVar1": "tempVar1",
                "unaff_r4": "unaffr4",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "in_r12": "inr12",
                "bVar4": "isZero",
                "tempVar4": "tempVar4",
                "tempVar5": "tempVar5",
                "tempVar6": "tempVar6",
                "isZero": "isZero",
                "isZero2": "isZero2",
                "isUnaffr4NotEqualToInr12": "isUnaffr4NotEqualToInr12",
                "isUVar2NotEqualToInr12": "isUVar2NotEqualToInr12"
            },
            "code": "ulonglong calculateResult_0800881c(uint firstParam, uint secondParam, uint thirdParam, uint fourthParam) {\n  uint tempVar1;\n  uint tempVar2;\n  uint tempVar3;\n  uint tempVar4;\n  uint tempVar5;\n  uint tempVar6;\n  bool isZero;\n  bool isZero2;\n  bool isUnaffr4NotEqualToInr12;\n  bool isUVar2NotEqualToInr12;\n  isUVar2NotEqualToInr12 = (in_r12 & fourthParam >> 0x14) != in_r12;\n  isUnaffr4NotEqualToInr12 = unaff_r4 != in_r12 && isUVar2NotEqualToInr12;\n  isZero = (firstParam | secondParam << 1) == 0;\n  isZero2 = (thirdParam | fourthParam << 1) == 0;\n  if (isUnaffr4NotEqualToInr12) {\n    if (isZero) {\n      tempVar1 = fourthParam;\n      tempVar2 = thirdParam;\n    }\n    else {\n      if (isZero2) {\n        return (ulonglong)((secondParam ^ fourthParam) & 0x80000000) << 0x20;\n      }\n      if (unaff_r4 == 0) {\n        tempVar3 = secondParam & 0x80000000;\n        do {\n          tempVar4 = firstParam & 0x80000000;\n          firstParam = firstParam << 1;\n          secondParam = secondParam * 2 + (uint)(tempVar4 != 0);\n        } while ((secondParam & 0x100000) == 0);\n        secondParam |= tempVar3;\n        if (isUVar2NotEqualToInr12) {\n          return CONCAT44(secondParam, firstParam);\n        }\n      }\n      do {\n        tempVar5 = thirdParam & 0x80000000;\n        thirdParam = thirdParam << 1;\n        fourthParam = fourthParam * 2 + (uint)(tempVar5 != 0);\n      } while ((fourthParam & 0x100000) == 0);\n      return CONCAT44(secondParam, firstParam);\n    }\n  }\n  else {\n    if (isZero) {\n      secondParam = fourthParam;\n      firstParam = thirdParam;\n    }\n    else {\n      if (!isZero) {\n        isZero2 = (thirdParam | fourthParam << 1) == 0;\n      }\n      tempVar6 = secondParam;\n      if (((!isZero2) && ((unaff_r4 != in_r12 || ((firstParam | secondParam << 0xc) == 0)))) && ((isUVar2NotEqualToInr12 || (firstParam = thirdParam, tempVar6 = fourthParam, (thirdParam | fourthParam << 0xc) == 0)))) {\n        return (ulonglong)((secondParam ^ fourthParam) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n      return CONCAT44(tempVar6, firstParam) | 0x7ff8000000000000;\n    }\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800881c",
            "calling": [
                "FUN_08008640"
            ],
            "imported": false,
            "current_name": "calculateResult_0800881c"
        },
        "FUN_08004bc0": {
            "renaming": {
                "FUN_08004bc0": "calculate_checksum_08004bc0",
                "param_1": "data",
                "param_2": "checksum",
                "storeChecksum_08000374": "store_checksum",
                "ushort": "uint16_t",
                "PTR_": "PTR_ (unchanged)",
                "DAT_": "DAT_ (unchanged)"
            },
            "code": "void calculate_checksum_08004bc0(byte data, uint32_t checksum) {\n    uint16_t offset = (uint16_t)data * 0x101 + 0x300;\n    store_checksum(offset, checksum, 0x100);\n    return;\n}",
            "called": [
                "FUN_08000374"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004bc0",
            "calling": [
                "FUN_08004d2c",
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "calculate_checksum_08004bc0"
        },
        "FUN_08008b4c": {
            "renaming": {
                "FUN_08008b4c": "check_collision_and_return_result_08008b4c",
                "in_CY": "is_CY_zero",
                "in_ZR": "is_ZR_nonzero"
            },
            "code": "bool check_collision_and_return_result_08008b4c(void)\n{\n  bool is_CY_zero = false;\n  bool is_ZR_nonzero = false;\n  \n  is_CY_zero = check_collision_and_return_result_08008b4c_08008af0();\n  return !is_CY_zero || is_ZR_nonzero;\n}",
            "called": [
                "FUN_08008af0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b4c",
            "calling": [
                "FUN_0800a5a0"
            ],
            "imported": false,
            "current_name": "check_collision_and_return_result_08008b4c"
        },
        "FUN_08004c2a": {
            "renaming": {
                "FUN_08004c2a": "initialize_and_store_checksum_08004c2a",
                "initializeMemoryAndSetValueTo255_08000340": "initialize_memory_and_set_value_to_255",
                "storeChecksum_08000374": "store_checksum",
                "PTR_DAT_08004c44": "ptr_data"
            },
            "code": "void initialize_and_store_checksum_08004c2a(void)\n{\n  initialize_memory_and_set_value_to_255(0, 5);\n  store_checksum(1, PTR_DAT_08004c44, 0x40);\n  return;\n}",
            "called": [
                "FUN_08000374",
                "FUN_08000340"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c2a",
            "calling": [
                "FUN_08004c48",
                "FUN_08004e30"
            ],
            "imported": false,
            "current_name": "initialize_and_store_checksum_08004c2a"
        },
        "FUN_0800826a": {
            "renaming": {
                "FUN_0800826a": "wait_for_flag_and_return_zero_0800826a",
                "param_1": "flag_address"
            },
            "code": "int wait_for_flag_and_return_zero_0800826a(void *flag_address)\n{\n  waitForFlagToSet_08007e1c(flag_address);\n  return 0;\n}",
            "called": [
                "FUN_08007e1c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800826a",
            "calling": [],
            "imported": false,
            "current_name": "wait_for_flag_and_return_zero_0800826a"
        },
        "FUN_08008b60": {
            "renaming": {
                "FUN_08008b60": "isCollisionDetected_08008b60",
                "in_CY": "inputChar",
                "check_collision_and_return_result_08008af0": "checkCollision"
            },
            "code": "bool isCollisionDetected_08008b60(void)\n{\n  char inputChar;\n  checkCollision();\n  return inputChar == '\\0';\n}",
            "called": [
                "FUN_08008af0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b60",
            "calling": [
                "FUN_08009318",
                "FUN_080094c0",
                "FUN_0800af78",
                "FUN_08003004"
            ],
            "imported": false,
            "current_name": "isCollisionDetected_08008b60"
        },
        "FUN_08005324": {
            "renaming": {
                "FUN_08005324": "calculate_data_08005324",
                "param_1": "user_input",
                "local_14": "max_input",
                "DAT_08005358": "data_value",
                "PTR_DAT_0800535c": "data_pointer",
                "update_data_08007bf0": "update_data"
            },
            "code": "void calculate_data_08005324(uint user_input)\n{\n  uint max_input = user_input;\n  if (user_input < 800) {\n    max_input = 800;\n  }\n  uint calculated_data = DAT_08005358 / max_input;\n  *(uint *)(PTR_DAT_0800535c + 0x14) = calculated_data;\n  update_data_08007bf0(calculated_data);\n  return;\n}",
            "called": [
                "FUN_08007bf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005324",
            "calling": [
                "FUN_080058a0",
                "FUN_080053a0",
                "FUN_08005814"
            ],
            "imported": false,
            "current_name": "calculate_data_08005324"
        },
        "FUN_08000310": {
            "renaming": {
                "FUN_08000310": "get_value_from_data_08000310",
                "param_1": "index",
                "PTR_DAT_08000338": "is_initialized",
                "initialize_memory_and_set_value_to_255_080002f0": "initialize_memory_and_set_value_to_255",
                "PTR_DAT_0800033c": "data_array"
            },
            "code": "uint8_t get_value_from_data_08000310(uint16_t index) {\n  if (*PTR_DAT_08000338 == 0) {\n    initialize_memory_and_set_value_to_255();\n  }\n  return PTR_DAT_0800033c[index & 0x3ff];\n}",
            "called": [
                "FUN_080002f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000310",
            "calling": [
                "FUN_080003ec",
                "FUN_08004dd2"
            ],
            "imported": false,
            "current_name": "get_value_from_data_08000310"
        },
        "FUN_08005208": {
            "renaming": {
                "FUN_08005208": "do_nothing_08005208"
            },
            "code": "\nvoid do_nothing_08005208(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005208",
            "calling": [
                "FUN_0800525c"
            ],
            "imported": false,
            "current_name": "do_nothing_08005208"
        },
        "FUN_08007a70": {
            "renaming": {
                "FUN_08007a70": "write_bits_to_memory_08007a70",
                "param_1": "bit_value",
                "param_2": "memory_address",
                "param_3": "memory_size",
                "local_c": "bit_position",
                "DAT_08007ac8": "ptr_data_08007ac8",
                "DAT_08007acc": "ptr_data_08007acc"
            },
            "code": "void write_bits_to_memory_08007a70(uint8_t bit_value, uint32_t* memory_address, uint32_t memory_size)\n{\n  uint8_t bit_position;\n\n  if (*memory_address == 0x40000000) {\n    bit_position = 0x1c;\n  }\n  else if (*memory_address == DAT_08007ac8) {\n    bit_position = 0x1d;\n  }\n  else {\n    if (*memory_address != DAT_08007acc) {\n      return;\n    }\n    bit_position = 0x1e;\n  }\n  write_bits_to_memory_08007a70_08006cf6(bit_value, memory_address, memory_size);\n  set_bit_in_array_080079e0(bit_position);\n  return;\n}",
            "called": [
                "FUN_080079e0",
                "FUN_08006cf6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007a70",
            "calling": [
                "FUN_08007ad0"
            ],
            "imported": false,
            "current_name": "write_bits_to_memory_08007a70"
        },
        "FUN_0800b5b0": {
            "renaming": {
                "FUN_0800b5b0": "do_nothing_0800b5b0"
            },
            "code": "\nvoid do_nothing_0800b5b0(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b5b0",
            "calling": [
                "FUN_080001ac",
                "FUN_0800b3e8",
                "FUN_08000188"
            ],
            "imported": false,
            "current_name": "do_nothing_0800b5b0"
        },
        "FUN_08002978": {
            "renaming": {
                "FUN_08002978": "calculate_hash_value_08002978",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "result3"
            },
            "code": "float calculate_hash_value_08002978(float input1, float input2, float input3)\n{\n    float result1 = calculate_float_08008eec(input2, input2);\n    float result2 = calculate_float_08008cdc(input1, input1);\n    float result3 = calculate_float_08008eec(result2, input3);\n    float result4 = calculate_float_08008cd8(result1, result3);\n    unsigned long long reversed_bits = reverse_bits_08008590(result4);\n    unsigned int low_bits = (unsigned int)reversed_bits;\n    unsigned int high_bits = (unsigned int)(reversed_bits >> 0x20);\n    unsigned long long collision = calculate_collision_080098d0_080098d0(low_bits, high_bits);\n    unsigned int float_bits_low = (unsigned int)collision;\n    unsigned int float_bits_high = (unsigned int)(collision >> 0x20);\n    float result5 = calculate_float_bits_08008c30(float_bits_low, float_bits_high);\n    return result5;\n}",
            "called": [
                "FUN_080098d0",
                "FUN_08008590",
                "FUN_08008c30",
                "FUN_08008cd8",
                "FUN_08008cdc",
                "FUN_08008eec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002978",
            "calling": [
                "FUN_08002afc",
                "FUN_080029d8",
                "FUN_08003004"
            ],
            "imported": false,
            "current_name": "calculate_hash_value_08002978"
        },
        "FUN_08009d78": {
            "renaming": {
                "FUN_08009d78": "calculate_and_reverse_double_precision_08009d78",
                "param_1": "input_value",
                "param_2": "input_size",
                "param_3": "output_values",
                "uVar1": "result_low",
                "uVar2": "temp_1",
                "uVar3": "temp_2",
                "uVar4": "temp_3",
                "uVar5": "temp_4",
                "uVar6": "temp_5",
                "uVar7": "temp_6",
                "uVar8": "unsigned_input_size",
                "iVar9": "return_value",
                "uVar10": "temp_7",
                "uVar11": "temp_8",
                "uVar12": "temp_9",
                "local_50": "result_high",
                "uStack_4c": "temp_10",
                "local_40": "temp_11",
                "local_38": "temp_12",
                "local_30": "temp_13"
            },
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint calculate_and_reverse_double_precision_08009d78(undefined4 input_value,uint input_size,undefined8 *output_values)\n\n{\n  undefined4 result_low;\n  undefined4 temp_1;\n  undefined4 temp_2;\n  undefined4 temp_3;\n  undefined4 temp_4;\n  undefined4 temp_5;\n  undefined4 temp_6;\n  uint unsigned_input_size;\n  int return_value;\n  undefined8 temp_7;\n  undefined8 temp_8;\n  undefined8 temp_9;\n  undefined4 result_high;\n  undefined4 temp_10;\n  undefined8 temp_11;\n  undefined8 temp_12;\n  undefined8 temp_13;\n  \n  unsigned_input_size = input_size & 0x7fffffff;\n  if ((int)unsigned_input_size <= DAT_08009fb0) {\n    *(undefined4 *)output_values = input_value;\n    *(uint *)((int)output_values + 4) = input_size;\n    *(undefined4 *)(output_values + 1) = 0;\n    *(undefined4 *)((int)output_values + 0xc) = 0;\n    return 0;\n  }\n  if ((int)unsigned_input_size <= DAT_08009fb4) {\n    if ((int)input_size < 1) {\n      temp_7 = calculate_double_precision_080082d4(input_value,input_size,DAT_08009f88,DAT_08009f8c);\n      temp_2 = (undefined4)((ulonglong)temp_7 >> 0x20);\n      result_low = (undefined4)temp_7;\n      if (unsigned_input_size != DAT_0800a1b8) {\n        temp_7 = calculate_double_precision_080082d4(result_low,temp_2,DAT_0800a1b0,DAT_0800a1b4);\n        *output_values = temp_7;\n        temp_7 = reverse_and_improve_080082d0(result_low,temp_2);\n        temp_7 = calculate_double_precision_080082d4((int)temp_7,(int)((ulonglong)temp_7 >> 0x20),DAT_0800a1b0,DAT_0800a1b4\n                             );\n        output_values[1] = temp_7;\n        return -1;\n      }\n      temp_7 = calculate_double_precision_080082d4(result_low,temp_2,DAT_0800a190,DAT_0800a194);\n      result_low = (undefined4)((ulonglong)temp_7 >> 0x20);\n      temp_8 = calculate_double_precision_080082d4((int)temp_7,result_low,DAT_0800a198,DAT_0800a19c);\n      *output_values = temp_8;\n      temp_7 = reverse_and_improve_080082d0((int)temp_7,result_low);\n      temp_7 = calculate_double_precision_080082d4((int)temp_7,(int)((ulonglong)temp_7 >> 0x20),DAT_0800a198,DAT_0800a19c);\n      output_values[1] = temp_7;\n      return -1;\n    }\n    temp_7 = reverse_and_improve_080082d0();\n    temp_2 = (undefined4)((ulonglong)temp_7 >> 0x20);\n    result_low = (undefined4)temp_7;\n    if (unsigned_input_size != DAT_08009fb8) {\n      temp_7 = reverse_and_improve_080082d0(result_low,temp_2,DAT_08009f90,DAT_08009f94);\n      *output_values = temp_7;\n      temp_7 = reverse_and_improve_080082d0(result_low,temp_2);\n      temp_7 = reverse_and_improve_080082d0((int)temp_7,(int)((ulonglong)temp_7 >> 0x20),DAT_08009f90,DAT_08009f94);\n      output_values[1] = temp_7;\n      return 1;\n    }\n    temp_7 = reverse_and_improve_080082d0(result_low,temp_2,DAT_08009f98,DAT_08009f9c);\n    result_low = (undefined4)((ulonglong)temp_7 >> 0x20);\n    temp_8 = reverse_and_improve_080082d0((int)temp_7,result_low,DAT_08009fa0,DAT_08009fa4);\n    *output_values = temp_8;\n    temp_7 = reverse_and_improve_080082d0((int)temp_7,result_low);\n    temp_7 = reverse_and_improve_080082d0((int)temp_7,(int)((ulonglong)temp_7 >> 0x20),DAT_08009fa0,DAT_08009fa4);\n    output_values[1] = temp_7;\n    return 1;\n  }\n  if (DAT_08009fbc < (int)unsigned_input_size) {\n    if (DAT_08009fc0 < (int)unsigned_input_size) {\n      temp_7 = reverse_and_improve_080082d0(input_value,input_size,input_value,input_size);\n      output_values[1] = temp_7;\n      *output_values = temp_7;\n      return 0;\n    }\n    return_value = ((int)unsigned_input_size >> 0x14) + -0x416;\n    calculate_08008ba0();\n    temp_11 = calculate_0800856c();\n    temp_7 = reverse_and_improve_080082d0(input_value,unsigned_input_size + return_value * -0x100000,(int)temp_11,\n                          (int)((ulonglong)temp_11 >> 0x20));\n    temp_7 = calculate_product_08008640((int)temp_7,(int)((ulonglong)temp_7 >> 0x20),0,DAT_08009fc4);\n    calculate_08008ba0();\n    temp_12 = calculate_0800856c();\n    temp_7 = reverse_and_improve_080082d0((int)temp_7,(int)((ulonglong)temp_7 >> 0x20));\n    temp_13 = calculate_product_08008640((int)temp_7,(int)((ulonglong)temp_7 >> 0x20),0,DAT_08009fc4);\n    checkForCollision_08008b10((int)temp_13,(int)((ulonglong)temp_13 >> 0x20),0,0);\n    return_value = reverse_and_improve_0800a5a0(&temp_11,output_values,return_value);\n    if (-1 < (int)input_size) {\n      return return_value;\n    }\n    *(int *)((int)output_values + 4) = *(int *)((int)output_values + 4) + -0x80000000;\n    *(int *)((int)output_values + 0xc) = *(int *)((int)output_values + 0xc) + -0x80000000;\n    return -return_value;\n  }\n  temp_7 = do_nothing_0800b2cc();\n  temp_2 = (undefined4)((ulonglong)temp_7 >> 0x20);\n  temp_8 = calculate_product_08008640((int)temp_7,temp_2,DAT_08009fa8,DAT_08009fac);\n  calculate_double_precision_080082d4((int)temp_8,(int)((ulonglong)temp_8 >> 0x20),0,DAT_08009fcc);\n  return_value = calculate_08008ba0();\n  temp_8 = calculate_0800856c();\n  temp_3 = (undefined4)((ulonglong)temp_8 >> 0x20);\n  result_low = (undefined4)temp_8;\n  temp_8 = calculate_product_08008640(result_low,temp_3,DAT_08009f88,DAT_08009f8c);\n  temp_7 = reverse_and_improve_080082d0((int)temp_7,temp_2,(int)temp_8,(int)((ulonglong)temp_8 >> 0x20));\n  temp_4 = (undefined4)((ulonglong)temp_7 >> 0x20);\n  temp_2 = (undefined4)temp_7;\n  temp_8 = calculate_product_08008640(result_low,temp_3,DAT_08009f90,DAT_08009f94);\n  if ((0x1f < return_value) || (*(uint *)(PTR_DAT_08009fd0 + (return_value + -1) * 4) == unsigned_input_size)) {\n    temp_9 = reverse_and_improve_080082d0(temp_2,temp_4,(int)temp_8,(int)((ulonglong)temp_8 >> 0x20));\n    if ((int)((unsigned_input_size >> 0x14) - ((uint)((int)((ulonglong)temp_9 >> 0x20) << 1) >> 0x15)) < 0x11)\n    goto LAB_0800a0ce;\n    temp_8 = calculate_product_08008640(result_low,temp_3,DAT_0800a190,DAT_0800a194);\n    temp_5 = (undefined4)((ulonglong)temp_8 >> 0x20);\n    temp_7 = reverse_and_improve_080082d0(temp_2,temp_4,(int)temp_8,temp_5);\n    temp_6 = (undefined4)((ulonglong)temp_7 >> 0x20);\n    temp_1 = (undefined4)temp_7;\n    temp_9 = reverse_and_improve_080082d0(temp_2,temp_4,temp_1,temp_6);\n    temp_8 = reverse_and_improve_080082d0((int)temp_9,(int)((ulonglong)temp_9 >> 0x20),(int)temp_8,temp_5);\n    temp_9 = calculate_product_08008640(result_low,temp_3,DAT_0800a198,DAT_0800a19c);\n    temp_8 = reverse_and_improve_080082d0((int)temp_9,(int)((ulonglong)temp_9 >> 0x20),(int)temp_8,\n                          (int)((ulonglong)temp_8 >> 0x20));\n    temp_9 = reverse_and_improve_080082d0(temp_1,temp_6,(int)temp_8,(int)((ulonglong)temp_8 >> 0x20));\n    if ((int)(((int)unsigned_input_size >> 0x14) - ((uint)((int)((ulonglong)temp_9 >> 0x20) << 1) >> 0x15)) < 0x32\n       ) goto LAB_0800a0ce;\n    temp_8 = calculate_product_08008640(result_low,temp_3,DAT_0800a1a0,DAT_0800a1a4);\n    temp_2 = (undefined4)((ulonglong)temp_8 >> 0x20);\n    temp_7 = reverse_and_improve_080082d0(temp_1,temp_6,(int)temp_8,temp_2);\n    temp_9 = reverse_and_improve_080082d0(temp_1,temp_6);\n    temp_8 = reverse_and_improve_080082d0((int)temp_9,(int)((ulonglong)temp_9 >> 0x20),(int)temp_8,temp_2);\n    temp_9 = calculate_product_08008640(result_low,temp_3,DAT_0800a1a8,DAT_0800a1ac);\n    temp_8 = reverse_and_improve_080082d0((int)temp_9,(int)((ulonglong)temp_9 >> 0x20),(int)temp_8,\n                          (int)((ulonglong)temp_8 >> 0x20));\n  }\n  temp_9 = reverse_and_improve_080082d0((int)temp_7,(int)((ulonglong)temp_7 >> 0x20),(int)temp_8,\n                        (int)((ulonglong)temp_8 >> 0x20));\nLAB_0800a0ce:\n  temp_10 = (undefined4)((ulonglong)temp_7 >> 0x20);\n  result_high = (undefined4)temp_7;\n  *output_values = temp_9;\n  temp_7 = reverse_and_improve_080082d0(result_high,temp_10);\n  temp_7 = reverse_and_improve_080082d0((int)temp_7,(int)((ulonglong)temp_7 >> 0x20),(int)temp_8,\n                        (int)((ulonglong)temp_8 >> 0x20));\n  output_values[1] = temp_7;\n  if ((int)input_size < 0) {\n    *(int *)output_values = (int)temp_9;\n    *(int *)((int)output_values + 4) = (int)((ulonglong)temp_9 >> 0x20) + -0x80000000;\n    *(int *)(output_values + 1) = (int)temp_7;\n    *(int *)((int)output_values + 0xc) = (int)((ulonglong)temp_7 >> 0x20) + -0x80000000;\n    return_value = -return_value;\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_080082d0",
                "FUN_080082d4",
                "FUN_0800b2cc",
                "FUN_0800856c",
                "FUN_08008ba0",
                "FUN_0800a5a0",
                "FUN_08008640",
                "FUN_08008b10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009d78",
            "calling": [
                "FUN_08009410",
                "FUN_080096e8"
            ],
            "imported": false,
            "current_name": "calculate_and_reverse_double_precision_08009d78"
        },
        "FUN_08003826": {
            "renaming": {
                "FUN_08003826": "print_decimal_number_08003826",
                "param_1": "number",
                "iVar1": "is_string_terminated",
                "uVar2": "shifted_number",
                "bVar3": "decimal_index",
                "uVar4": "index",
                "local_24": "number_copy",
                "acStack_1d": "decimal_number",
                "local_10": "digit_count",
                "local_a": "decimal_index",
                "local_9": "digit_index"
            },
            "code": "void print_decimal_number_08003826(uint number)\n{\n  int is_string_terminated = is_string_terminated_08009228(number, 0);\n  uint number_copy = number;\n  if (is_string_terminated != 0) {\n    waitForFlagAndReturn_08008250(0x2d);\n    number_copy = number ^ 0x80000000;\n  }\n  for (uint i = 0; i < (byte)PTR_DAT_08003970[0x3d]; i += 2) {\n    number_copy = calculate_float_08008eec(number_copy, DAT_08003974);\n  }\n  if ((byte)PTR_DAT_08003970[0x3d] % 2 != 0) {\n    number_copy = calculate_float_08008eec(number_copy, DAT_08003978);\n  }\n  uint shifted_number = calculate_float_08008cdc(number_copy, 0x3f000000);\n  uint digit_count = calculate_value_08009278(shifted_number);\n  char decimal_number[13];\n  decimal_number[(byte)PTR_DAT_08003970[0x3d] + 1] = '.';\n  for (; digit_count != 0; digit_count = (uint)((ulonglong)DAT_0800397c * (ulonglong)digit_count >> 0x23)) {\n    if (decimal_number[0] == PTR_DAT_08003970[0x3d]) {\n      decimal_number[0] = decimal_number[0] + 1;\n    }\n    uint index = (uint)decimal_number[0];\n    decimal_number[0] = decimal_number[0] + 1;\n    decimal_number[index] = (char)digit_count + (char)(uint)((ulonglong)DAT_0800397c * (ulonglong)digit_count >> 0x23) * -10 + '0';\n  }\n  while (decimal_number[0] < (byte)PTR_DAT_08003970[0x3d]) {\n    uint index = (uint)decimal_number[0];\n    decimal_number[0] = decimal_number[0] + 1;\n    decimal_number[index] = '0';\n  }\n  if (decimal_number[0] == PTR_DAT_08003970[0x3d]) {\n    uint index = decimal_number[0] + 1;\n    decimal_number[0] = decimal_number[0] + 2;\n    decimal_number[index] = '0';\n  }\n  for (; decimal_number[0] != 0; decimal_number[0] = decimal_number[0] - 1) {\n    waitForFlagAndReturn_08008250(decimal_number[decimal_number[0]]);\n  }\n}",
            "called": [
                "FUN_08008250",
                "FUN_08009228",
                "FUN_08009278",
                "FUN_08008cdc",
                "FUN_08008eec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003826",
            "calling": [
                "FUN_08004250",
                "FUN_080046d0",
                "FUN_08004940",
                "FUN_080044e8"
            ],
            "imported": false,
            "current_name": "print_decimal_number_08003826"
        },
        "FUN_0800923c": {
            "renaming": {
                "FUN_0800923c": "check_concatenation_result_0800923c",
                "in_CY": "CY",
                "in_ZR": "ZR"
            },
            "code": "bool check_concatenation_result_0800923c(void)\n{\n  bool is_CY_zero = (bool)CY;\n  bool is_ZR_zero = (bool)ZR;\n  return is_CY_zero || is_ZR_zero;\n}",
            "called": [
                "FUN_08009204"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800923c",
            "calling": [
                "FUN_080005b4",
                "FUN_08004e30",
                "FUN_08001f00"
            ],
            "imported": false,
            "current_name": "check_concatenation_result_0800923c"
        },
        "FUN_08002afc": {
            "renaming": {
                "FUN_08002afc": "validate_and_concatenate_strings_08002afc",
                "param_1": "input_string_address",
                "param_2": "output_string_address",
                "iVar1": "is_valid_string",
                "uVar2": "hash_value",
                "uVar3": "output_string_address_copy"
            },
            "code": "void validate_and_concatenate_strings_08002afc(int input_string_address, int output_string_address) {\n  int is_input_string_valid = (input_string_address != 0) && (*(char *)(input_string_address + 0x25) == '\\0');\n  if (is_input_string_valid) {\n    int is_input_string_terminated = is_string_terminated(*(unsigned int *)(input_string_address + 0x18), *(unsigned int *)(output_string_address + 0x18));\n    if (is_input_string_terminated) {\n      unsigned int hash_value = calculate_hash_value(*(unsigned int *)(input_string_address + 0x18), *(unsigned int *)(input_string_address + 0x20));\n      int is_hashed_string_terminated = is_string_terminated(*(unsigned int *)(output_string_address + 0x18), hash_value);\n      if (!is_hashed_string_terminated) {\n        is_hashed_string_terminated = 1;\n        *(unsigned int *)(output_string_address + 0x18) = hash_value;\n      }\n      if (!is_string_concatenated(*(unsigned int *)(output_string_address + 0x18), *(unsigned int *)(output_string_address + 0x18))) {\n        *(unsigned char *)(output_string_address + 0x24) = 1;\n      }\n    }\n  }\n}\n",
            "called": [
                "FUN_08009214",
                "FUN_08009228",
                "FUN_08002978"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002afc",
            "calling": [
                "FUN_08002ba8"
            ],
            "imported": false,
            "current_name": "validate_and_concatenate_strings_08002afc"
        },
        "FUN_08004c48": {
            "renaming": {
                "FUN_08004c48": "initialize_data_08004c48",
                "param_1": "input",
                "PTR_DAT_08004d0c": "PTR_DAT_08004d0c",
                "DAT_08004d10": "default_value",
                "PTR_DAT_08004d0c + 4": "PTR_DAT_08004d0c_array[1]",
                "PTR_DAT_08004d0c + 8": "PTR_DAT_08004d0c_array[2]",
                "PTR_DAT_08004d0c + 0xd": "PTR_DAT_08004d0c_array[3]",
                "DAT_08004d14": "default_value_2",
                "DAT_08004d18": "default_value_3",
                "PTR_DAT_08004d0c + 0x20": "PTR_DAT_08004d0c_array[9]",
                "PTR_DAT_08004d0c + 0x1c": "PTR_DAT_08004d0c_array[10]",
                "PTR_DAT_08004d0c + 0x18": "PTR_DAT_08004d0c_array[8]",
                "PTR_DAT_08004d0c + 0x1a": "PTR_DAT_08004d0c_array[7]",
                "DAT_08004d24": "default_value_4",
                "PTR_DAT_08004d0c + 0x28": "PTR_DAT_08004d0c_array[16]",
                "DAT_08004d28": "default_value_5",
                "PTR_DAT_08004d0c + 0x2c": "PTR_DAT_08004d0c_array[17]",
                "PTR_DAT_08004d0c + 0x30": "PTR_DAT_08004d0c_array[18]",
                "PTR_DAT_08004d0c + 0x34": "PTR_DAT_08004d0c_array[19]",
                "PTR_DAT_08004d0c + 0x38": "PTR_DAT_08004d0c_array[20]",
                "PTR_DAT_08004d0c + 0x3c": "PTR_DAT_08004d0c_array[21]",
                "PTR_DAT_08004d0c + 0x3d": "PTR_DAT_08004d0c_array[22]",
                "PTR_DAT_08004d0c + 0x3e": "PTR_DAT_08004d0c_array[23]"
            },
            "code": "void initialize_data_08004c48(char input) {\n    if (input != '\\0') {\n        int DAT_08004d10 = 10;\n        int DAT_08004d14 = 100;\n        int DAT_08004d18 = 0x3f800000;\n        int DAT_08004d24 = 0x19;\n        int DAT_08004d28 = 3;\n        int PTR_DAT_08004d0c_array[] = {\n            DAT_08004d10, DAT_08004d10, DAT_08004d10, 10,\n            DAT_08004d14, DAT_08004d18, 0, 0xa80, DAT_08004d20,\n            DAT_08004d1c, DAT_08004d24, 0, 0, DAT_08004d28,\n            DAT_08004d14, 100, 0x3f800000, 0x19, 3, 0x19\n        };\n        memcpy(PTR_DAT_08004d0c, PTR_DAT_08004d0c_array, sizeof(PTR_DAT_08004d0c_array));\n    }\n    PTR_DAT_08004d0c[0x28] |= 2;\n    PTR_DAT_08004d0c[0x28] |= 0x10;\n    PTR_DAT_08004d0c[0x34] = 100;\n    PTR_DAT_08004d0c[0x38] = 0x3f800000;\n    initialize_and_store_checksum_08004c2a();\n    return;\n}",
            "called": [
                "FUN_08004c2a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c48",
            "calling": [
                "FUN_080051b4",
                "FUN_08004dd2"
            ],
            "imported": false,
            "current_name": "initialize_data_08004c48"
        },
        "FUN_080002a0": {
            "renaming": {
                "FUN_080002a0": "check_parameter_range_080002a0",
                "param_1": "parameter",
                "check_values_within_range_08005a98": "check_values_within_range"
            },
            "code": "void check_parameter_range_080002a0(int parameter) {\n  check_values_within_range(param);\n  return;\n}",
            "called": [
                "FUN_08005a98"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002a0",
            "calling": [
                "FUN_08002408"
            ],
            "imported": false,
            "current_name": "check_parameter_range_080002a0"
        },
        "FUN_08009250": {
            "renaming": {
                "FUN_08009250": "check_strings_concatenated_08009250",
                "in_ZR": "in_zero",
                "in_CY": "in_carry",
                "concatenate_strings_080091fc": "concatenate_strings"
            },
            "code": "bool check_strings_concatenated_08009250(void)\n{\n  undefined in_zero = 0;\n  undefined in_carry = 0;\n  concatenate_strings();\n  return !(bool)in_carry || (bool)in_zero;\n}",
            "called": [
                "FUN_080091fc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009250",
            "calling": [
                "FUN_08003004",
                "FUN_08001f00"
            ],
            "imported": false,
            "current_name": "check_strings_concatenated_08009250"
        },
        "FUN_0800640c": {
            "renaming": {
                "FUN_0800640c": "update_registers_0800640c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "local_1c": "local_1",
                "local_18": "local_2",
                "local_14": "local_4",
                "local_10": "local_3",
                "local_c": "local_5",
                "PTR_DAT_080064b0": "ptr_1",
                "PTR_DAT_080064b4": "ptr_2",
                "PTR_DAT_080064b8": "ptr_3"
            },
            "code": "void update_registers_0800640c(uint32_t param1, uint32_t param2, uint32_t param3)\n{\n  uint32_t bitmask = 0;\n  uint32_t local_1 = 0x100;\n  uint32_t local_2 = 2;\n  uint32_t local_3 = 3;\n  uint32_t local_4 = 0;\n  uint32_t local_5 = 0;\n  uint32_t* PTR_DAT_080064b0 = (uint32_t *)(DAT_080064b0 + 0x30);\n  uint32_t* PTR_DAT_080064b4 = (uint32_t *)(DAT_080064b0 + 8);\n\n  if (param1 == 0) {\n    *PTR_DAT_080064b0 = *PTR_DAT_080064b0 | 1;\n    local_1 = 0x100;\n    local_2 = 2;\n    local_3 = 3;\n    local_4 = 0;\n    local_5 = 0;\n    update_registers_0800640c_08006e88(DAT_080064b4,&local_1);\n    bitmask = param3 | param2 | (*PTR_DAT_080064b4 & 0xf89fffff);\n  }\n  else {\n    *PTR_DAT_080064b0 = *PTR_DAT_080064b0 | 4;\n    local_1 = 0x200;\n    local_2 = 2;\n    local_3 = 3;\n    local_4 = 0;\n    local_5 = 0;\n    update_registers_0800640c_08006e88(DAT_080064b8,&local_1);\n    bitmask = param2 | (param3 << 3) | (*PTR_DAT_080064b4 & 0x7ffffff);\n  }\n  *PTR_DAT_080064b4 = bitmask;\n}\n",
            "called": [
                "FUN_08006e88"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800640c",
            "calling": [],
            "imported": false,
            "current_name": "update_registers_0800640c"
        },
        "FUN_08008af0": {
            "renaming": {
                "FUN_08008af0": "check_collision_and_return_result_08008af0",
                "param_1": "object1",
                "param_2": "object2",
                "param_3": "position1",
                "param_4": "position2"
            },
            "code": "void check_collision_and_return_result_08008af0(void* object1, void* object2, void* position1, void* position2)\n{\n  check_collision(object1, object2, position1, position2);\n  return;\n}",
            "called": [
                "FUN_08008b00"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008af0",
            "calling": [
                "FUN_08008b60",
                "FUN_08008b4c"
            ],
            "imported": false,
            "current_name": "check_collision_and_return_result_08008af0"
        },
        "FUN_08006e1a": {
            "renaming": {
                "FUN_08006e1a": "is_bit_set_08006e1a",
                "param_1": "bit_position",
                "uVar1": "is_set"
            },
            "code": "bool is_bit_set_08006e1a(int bit_position) {\n  bool is_set = false;\n  if ((bit_position >= 0) && (bit_position <= 31)) {\n    uint32_t mask = 1 << bit_position;\n    is_set = (mask & 0xffffffff) != 0;\n  }\n  return is_set;\n}",
            "called": [
                "FUN_08006ac0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e1a",
            "calling": [],
            "imported": false,
            "current_name": "is_bit_set_08006e1a"
        },
        "FUN_080052ac": {
            "renaming": {
                "FUN_080052ac": "set_param_with_mask_080052ac",
                "param_1": "new_param",
                "PTR_DAT_080052d8": "param_ptr",
                "DAT_080052d8": "param_offset",
                "mask": "mask"
            },
            "code": "void set_param_with_mask_080052ac(uint new_param) {\n    uint* PTR_DAT_080052d8 = (uint*)(DAT_080052d8 + 0x14);\n    uint mask = 0xfffffaaf;\n    *PTR_DAT_080052d8 = (new_param | (*PTR_DAT_080052d8 & mask));\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052ac",
            "calling": [
                "FUN_0800583c",
                "FUN_08005778",
                "FUN_08005760"
            ],
            "imported": false,
            "current_name": "set_param_with_mask_080052ac"
        },
        "FUN_08008286": {
            "renaming": {
                "FUN_08008286": "process_dat_value_08008286",
                "uVar1": "dat_value",
                "iVar2": "is_bit_set",
                "is_bit_set_08007e58": "check_bit_status",
                "get_dat_value_08007e84": "get_dat_value",
                "process_byte_08005900": "process_dat_byte"
            },
            "code": "undefined process_dat_value_08008286(void)\n{\n  undefined dat_value;\n  int is_bit_set;\n  \n  is_bit_set = check_bit_status();\n  if (is_bit_set != 0) {\n    dat_value = get_dat_value();\n    int process_result = process_dat_byte(dat_value);\n    if (process_result == 0) {\n      return dat_value;\n    }\n  }\n  return 0xff;\n}",
            "called": [
                "FUN_08005900",
                "FUN_08007e84",
                "FUN_08007e58"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008286",
            "calling": [
                "FUN_08003f34"
            ],
            "imported": false,
            "current_name": "process_dat_value_08008286"
        },
        "FUN_0800b5bc": {
            "renaming": {
                "FUN_0800b5bc": "do_nothing_0800b5bc"
            },
            "code": "\nvoid do_nothing_0800b5bc(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b5bc",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800b5bc"
        },
        "FUN_08008b74": {
            "renaming": {
                "FUN_08008b74": "is_parameters_valid_08008b74",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4"
            },
            "code": "int is_parameters_valid_08008b74(uint32_t value1, int32_t value2, uint32_t value3, int32_t value4) {\n    bool is_value2_valid = (value2 << 1) >> 0x15 != -1 || (value1 | value2 << 0xc) == 0;\n    bool is_value4_valid = (value4 << 1) >> 0x15 != -1 || (value3 | value4 << 0xc) == 0;\n    if (is_value2_valid && is_value4_valid) {\n        return 1;\n    }\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b74",
            "calling": [
                "FUN_080098d0"
            ],
            "imported": false,
            "current_name": "is_parameters_valid_08008b74"
        },
        "FUN_0800b524": {
            "renaming": {
                "FUN_0800b524": "insert_data_0800b524",
                "param_1": "data_type",
                "param_2": "data",
                "param_3": "data_size",
                "param_4": "data_flag",
                "puVar1": "DATA_PTR_PTR",
                "uVar2": "data_block_index",
                "uVar3": "data_block_flag",
                "iVar4": "data_struct_ptr",
                "iVar5": "data_block_ptr",
                "uVar6": "data_block_index"
            },
            "code": "int insert_data_0800b524(int data_type, int data, int data_size, int data_flag) {\n  undefined *data_ptr;\n  int data_struct_ptr;\n  int data_block_ptr;\n  uint data_block_index;\n  uint data_block_flag;\n  \n  data_ptr = DATA_PTR_PTR;\n  do_nothing(DATA_PTR);\n  data_struct_ptr = *(int *)DATA_STRUCT_PTR_PTR;\n  data_block_ptr = *(int *)(data_struct_ptr + DATA_BLOCK_OFFSET);\n  if (data_block_ptr == 0) {\n    data_block_ptr = data_struct_ptr + DATA_BLOCK_PTR_OFFSET;\n    *(int *)(data_struct_ptr + DATA_BLOCK_OFFSET) = data_block_ptr;\n  }\n  data_block_index = *(uint *)(data_block_ptr + DATA_BLOCK_INDEX_OFFSET);\n  if ((int)data_block_index < DATA_BLOCK_LIMIT) {\n    if (data_type != 0) {\n      data_block_ptr = data_block_ptr + data_block_index * 4;\n      *(int *)(data_block_ptr + DATA_BLOCK_DATA_OFFSET) = data_size;\n      data_block_flag = 1 << (data_block_index & 0xff);\n      *(uint *)(data_block_ptr + DATA_BLOCK_FLAG_OFFSET) = *(uint *)(data_block_ptr + DATA_BLOCK_FLAG_OFFSET) | data_block_flag;\n      *(int *)(data_block_ptr + DATA_BLOCK_DATA_FLAG_OFFSET) = data_flag;\n      if (data_type == 2) {\n        *(uint *)(data_block_ptr + DATA_BLOCK_DATA_FLAG_OFFSET + 4) = data_block_flag | *(uint *)(data_block_ptr + DATA_BLOCK_DATA_FLAG_OFFSET + 4);\n      }\n    }\n    data_ptr = *(undefined **)data_ptr;\n    *(uint *)(data_block_ptr + DATA_BLOCK_INDEX_OFFSET) = data_block_index + 1;\n    *(undefined **)(data_block_ptr + (data_block_index + 2) * 4) = data;\n    do_nothing(data_ptr);\n    data_block_index = 0;\n  }\n  else {\n    do_nothing(data_ptr);\n    data_block_index = 0xffffffff;\n  }\n  return data_block_index;\n}",
            "called": [
                "FUN_0800b51c",
                "FUN_0800b520"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b524",
            "calling": [
                "FUN_0800b4d0"
            ],
            "imported": false,
            "current_name": "insert_data_0800b524"
        },
        "FUN_08005214": {
            "renaming": {
                "FUN_08005214": "do_nothing_08005214"
            },
            "code": "\nvoid do_nothing_08005214(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005214",
            "calling": [
                "FUN_08005250"
            ],
            "imported": false,
            "current_name": "do_nothing_08005214"
        },
        "FUN_08007ea4": {
            "renaming": {
                "FUN_08007ea4": "set_flags_08007ea4",
                "param_1": "flag_value",
                "DAT_08007f38": "flag1",
                "DAT_08007f40": "flag2",
                "DAT_08007f44": "flag3",
                "DAT_08007f48": "flag4",
                "DAT_08007f4c": "flag5",
                "DAT_08007f50": "flag6",
                "*(uint *)(DAT_08007f3c + 0x44)": "*(uint *)(flag_ptr + 0x44)",
                "*(uint *)(DAT_08007f3c + 0x40)": "*(uint *)(flag_ptr + 0x40)",
                "DAT_08007f3c": "flag_ptr"
            },
            "code": "void set_flags_08007ea4(int flag_value)\n{\n  if (flag_value == DAT_08007f38) {\n    *(uint *)(DAT_08007f3c + 0x44) |= 0x10;\n  }\n  else if (flag_value == DAT_08007f40) {\n    *(uint *)(DAT_08007f3c + 0x40) |= 0x20000;\n  }\n  else if (flag_value == DAT_08007f44) {\n    *(uint *)(DAT_08007f3c + 0x40) |= 0x40000;\n  }\n  else if (flag_value == DAT_08007f48) {\n    *(uint *)(DAT_08007f3c + 0x40) |= 0x80000;\n  }\n  else if (flag_value == DAT_08007f4c) {\n    *(uint *)(DAT_08007f3c + 0x40) |= 0x100000;\n  }\n  else if (flag_value == DAT_08007f50) {\n    *(uint *)(DAT_08007f3c + 0x44) |= 0x20;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ea4",
            "calling": [
                "FUN_08008190"
            ],
            "imported": false,
            "current_name": "set_flags_08007ea4"
        },
        "FUN_08007756": {
            "renaming": {
                "FUN_08007756": "checkAndUpdateData_08007756",
                "get_value_from_pointer_08005a84": "getValueFromPointer",
                "toggle_bit_at_position_080076c8": "toggleBitAtPosition",
                "update_flags_and_values_08007930": "updateFlagsAndValues",
                "increment_ptr_dat_08005a80_08005a68": "incrementPointer"
            },
            "code": "void checkAndUpdateData_08007756(void)\n{\n  uint32_t data;\n  data = getValueFromPointer();\n  if ((data & 0x1ff) == 0)\n  {\n    toggleBitAtPosition(60);\n  }\n  if ((data & 0xf) == 0)\n  {\n    updateFlagsAndValues();\n  }\n  incrementPointer();\n  return;\n}",
            "called": [
                "FUN_08007930",
                "FUN_080076c8",
                "FUN_08005a68",
                "FUN_08005a84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007756",
            "calling": [],
            "imported": false,
            "current_name": "checkAndUpdateData_08007756"
        },
        "FUN_0800b520": {
            "renaming": {
                "FUN_0800b520": "do_nothing_0800b520"
            },
            "code": "\nvoid do_nothing_0800b520(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b520",
            "calling": [
                "FUN_0800b524"
            ],
            "imported": false,
            "current_name": "do_nothing_0800b520"
        },
        "FUN_0800423c": {
            "renaming": {
                "FUN_0800423c": "view_Grbl_settings_0800423c",
                "PTR_s_____view_Grbl_settings______view_0800424": "PTR_view_Grbl_settings",
                "processString_080036c6": "processString"
            },
            "code": "void view_Grbl_settings_0800423c(void)\n{\n  processString(PTR_s_____view_Grbl_settings_0800423c______view_0800424);\n  return;\n}",
            "called": [
                "FUN_080036c6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800423c",
            "calling": [
                "FUN_08003b98"
            ],
            "imported": false,
            "current_name": "view_Grbl_settings_0800423c"
        },
        "FUN_08009264": {
            "renaming": {
                "FUN_08009264": "is_end_of_string_08009264",
                "in_CY": "current_char",
                "concatenate_strings_080091fc": "concatenate_strings"
            },
            "code": "bool is_end_of_string_08009264(void)\n{\n  char current_char;\n  concatenate_strings();\n  return current_char == '\\0';\n}",
            "called": [
                "FUN_080091fc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009264",
            "calling": [
                "FUN_080029d8",
                "FUN_08003004"
            ],
            "imported": false,
            "current_name": "is_end_of_string_08009264"
        },
        "FUN_08007e08": {
            "renaming": {
                "FUN_08007e08": "initialize_and_set_flag_08007e08_08007e08",
                "PTR_08007ad0": "memory_pointer_08007ad0",
                "PTR_08007d08": "flag_pointer_08007d08",
                "DAT_08007da8": "flag_data_08007da8"
            },
            "code": "void initialize_and_set_flag_08007e08_08007e08(void)\n{\n  initialize_memory_08007ad0();\n  initialize_flag_08007d08();\n  set_flag_and_toggle_bit_08007da8();\n  return;\n}",
            "called": [
                "FUN_08007ad0",
                "FUN_08007d08",
                "FUN_08007da8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e08",
            "calling": [
                "FUN_08007540"
            ],
            "imported": false,
            "current_name": "initialize_and_set_flag_08007e08_08007e08"
        },
        "FUN_08002fac": {
            "renaming": {
                "FUN_08002fac": "check_pointers_match_08002fac",
                "*PTR_DAT_08002fcc": "*pointer1",
                "*PTR_DAT_08002fd0": "*pointer2"
            },
            "code": "bool check_pointers_match_08002fac(void)\n{\n  bool pointers_match = (*PTR_DAT_08002fcc == *PTR_DAT_08002fd0);\n  return pointers_match;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fac",
            "calling": [
                "FUN_08001e98"
            ],
            "imported": false,
            "current_name": "check_pointers_match_08002fac"
        },
        "FUN_080002b6": {
            "renaming": {
                "FUN_080002b6": "check_value_080002b6",
                "param_1": "param",
                "uVar1": "value_lower_bits",
                "uVar2": "base_value_upper_bits",
                "bVar3": "is_greater_or_equal",
                "lVar4": "base_value"
            },
            "code": "void check_value_080002b6(uint64_t param)\n{\n  uint64_t value;\n  uint32_t upper_bits;\n  bool is_greater_or_equal;\n  uint64_t base_value;\n  \n  base_value = calculate_value_from_pointer_08000268();\n  upper_bits = (uint32_t)(base_value + param >> 0x20);\n  \n  do {\n    value = calculate_value_from_pointer_08000268();\n    uint32_t value_upper_bits = (uint32_t)(value >> 0x20);\n    is_greater_or_equal = upper_bits <= value_upper_bits;\n    if (value_upper_bits == upper_bits) {\n      is_greater_or_equal = (uint32_t)(base_value + param) <= (uint32_t)value;\n    }\n  } while (!is_greater_or_equal);\n  return;\n}",
            "called": [
                "FUN_08000268"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002b6",
            "calling": [],
            "imported": false,
            "current_name": "check_value_080002b6"
        }
    },
    "used_tokens": 265634,
    "layers": [
        [
            "FUN_0800192c",
            "FUN_08006950",
            "FUN_08008ba0",
            "FUN_08007a10",
            "FUN_0800856c",
            "FUN_0800597c",
            "FUN_08009798",
            "FUN_08000188",
            "FUN_080018cc",
            "FUN_080079e0",
            "FUN_08006a58",
            "FUN_08005a84",
            "FUN_08008c30",
            "FUN_08007bf0",
            "FUN_08008590",
            "FUN_08007c5e",
            "FUN_0800587c",
            "FUN_08008a02",
            "FUN_080028bc",
            "FUN_0800738e",
            "FUN_0800a1bc",
            "FUN_080073d4",
            "FUN_08006e88",
            "FUN_08009990",
            "FUN_08007e58",
            "FUN_080059f8",
            "FUN_0800b3dc",
            "FUN_0800756c",
            "FUN_08002f74",
            "FUN_0800b3e8",
            "FUN_08006a18",
            "FUN_08006ac0",
            "FUN_0800919c",
            "FUN_0800854c",
            "FUN_08008e44",
            "FUN_0800733e",
            "FUN_080069e4",
            "FUN_0800b2d4",
            "FUN_08008e3c",
            "FUN_08009654",
            "FUN_08007bc2",
            "FUN_080035ec",
            "FUN_08006c70",
            "FUN_08005a68",
            "FUN_0800b2e0",
            "FUN_08002908",
            "FUN_08007c40",
            "FUN_08006b54",
            "FUN_08007e84",
            "FUN_0800b2e8",
            "FUN_08007402",
            "FUN_08002870",
            "FUN_08000210",
            "FUN_08006c04",
            "thunk_FUN_08009990",
            "FUN_08009278",
            "FUN_08007da8",
            "FUN_08008a74",
            "FUN_0800b430",
            "FUN_08005360",
            "FUN_08003980",
            "FUN_080052dc",
            "FUN_080064ec",
            "FUN_08006ba0",
            "FUN_08002896",
            "FUN_080001ac",
            "FUN_08000478",
            "FUN_08007e1c",
            "FUN_08006b00",
            "FUN_08005250",
            "FUN_08007430",
            "FUN_08005bdc",
            "FUN_080069b4",
            "FUN_08007b70",
            "FUN_080018fc",
            "FUN_08006998",
            "FUN_080078f4",
            "FUN_08008bf0",
            "FUN_08007854",
            "FUN_080076c8",
            "FUN_08006a8c",
            "FUN_0800881c",
            "FUN_080052ac",
            "FUN_08008b74",
            "FUN_0800b524",
            "FUN_08007ea4",
            "FUN_08002fac"
        ],
        [
            "FUN_08005984",
            "FUN_08008b00",
            "FUN_08009204",
            "FUN_08005760",
            "FUN_08005a98",
            "FUN_08006c9c",
            "FUN_08005778",
            "FUN_08006628",
            "FUN_08008250",
            "FUN_08006ce0",
            "FUN_08006d4a",
            "FUN_08006dfe",
            "FUN_08006d66",
            "FUN_080095b8",
            "FUN_08006cf6",
            "FUN_08002ef0",
            "FUN_08000268",
            "FUN_080001f8",
            "FUN_08006d98",
            "FUN_080079c0",
            "FUN_080057e4",
            "FUN_08006d8a",
            "FUN_08007520",
            "FUN_08007884",
            "FUN_08006dc4",
            "FUN_08005c30",
            "FUN_0800056c",
            "FUN_0800981c",
            "FUN_080004fc",
            "FUN_08005238",
            "FUN_08007d08",
            "FUN_08006de0",
            "FUN_08006d2e",
            "FUN_0800adf0",
            "FUN_0800b4d0",
            "FUN_08002f40",
            "FUN_080002f0",
            "FUN_0800778c",
            "FUN_08005790",
            "FUN_0800826a",
            "FUN_08005324",
            "FUN_0800640c",
            "FUN_08006e1a"
        ],
        [
            "FUN_0800585c",
            "FUN_08008b10",
            "FUN_08008b24",
            "FUN_0800369c",
            "FUN_08009214",
            "FUN_080036f0",
            "FUN_08001d4c",
            "FUN_08003778",
            "FUN_08006d72",
            "FUN_080096e8",
            "FUN_0800583c",
            "FUN_08009410",
            "FUN_08002f24",
            "FUN_08006680",
            "FUN_08000340",
            "FUN_080091fc",
            "FUN_080036c6",
            "FUN_080025e8",
            "FUN_08005814",
            "FUN_08009228",
            "FUN_08007c7c",
            "FUN_080066cc",
            "FUN_0800618c",
            "FUN_0800283a",
            "FUN_08000310",
            "FUN_08007a70",
            "FUN_0800923c",
            "FUN_080002a0",
            "FUN_08008af0",
            "FUN_080002b6"
        ],
        [
            "FUN_08007ad0",
            "FUN_0800195c",
            "FUN_08000374",
            "FUN_080037fc",
            "FUN_0800375c",
            "FUN_08005900",
            "FUN_08002638",
            "FUN_080098d0",
            "FUN_080059b4",
            "FUN_08004148",
            "FUN_08004030",
            "FUN_080003ec",
            "FUN_08003740",
            "FUN_08007f54",
            "FUN_08007436",
            "FUN_080041a0",
            "FUN_08003a18",
            "FUN_08004228",
            "FUN_08008b4c",
            "FUN_08008b60",
            "FUN_08003826",
            "FUN_08009250",
            "FUN_0800423c",
            "FUN_08009264"
        ],
        [
            "FUN_08009318",
            "FUN_080039a0",
            "FUN_0800184c",
            "FUN_080046d0",
            "FUN_080094c0",
            "FUN_08004250",
            "FUN_08004bf4",
            "FUN_08004940",
            "FUN_08008190",
            "FUN_080074c8",
            "FUN_08004900",
            "FUN_08004bc0",
            "FUN_08004c2a",
            "FUN_08002978",
            "FUN_08008286",
            "FUN_08007e08"
        ],
        [
            "FUN_08007930",
            "FUN_080029d8",
            "FUN_08002c18",
            "FUN_08004d7c",
            "FUN_08004d2c",
            "FUN_08002afc",
            "FUN_08004c48"
        ],
        [
            "FUN_080044e8",
            "FUN_08004dd2",
            "FUN_08002ba8",
            "FUN_08002e08",
            "FUN_08002a94",
            "FUN_080039bc",
            "FUN_080004ac",
            "FUN_08007756"
        ],
        [
            "FUN_08002edc",
            "FUN_080051b4"
        ],
        [
            "FUN_08003618"
        ],
        [
            "FUN_080058a0"
        ],
        [
            "FUN_08003a74"
        ],
        [
            "FUN_08001e98",
            "FUN_08002fd4"
        ],
        [
            "FUN_0800525c",
            "FUN_08000220",
            "FUN_08002408",
            "FUN_080024c4"
        ],
        [
            "FUN_08003b98"
        ],
        [
            "FUN_08003f34"
        ],
        [
            "FUN_08001ddc"
        ],
        [
            "FUN_08007540"
        ],
        [
            "FUN_080092c4"
        ],
        [
            "FUN_08008cd8",
            "FUN_080082d0",
            "FUN_080082d4",
            "FUN_08008cdc",
            "FUN_08006628",
            "FUN_080053a0",
            "FUN_08008894",
            "FUN_08008eec",
            "FUN_08005cec",
            "FUN_08009054",
            "FUN_08008640"
        ],
        [
            "FUN_08004e30",
            "FUN_080005b4",
            "FUN_0800a5a0",
            "FUN_08001f00",
            "FUN_0800af78",
            "FUN_0800a348",
            "FUN_08003004",
            "FUN_08001994",
            "FUN_08009b24"
        ],
        [
            "FUN_08009d78"
        ]
    ],
    "locked_functions": []
}