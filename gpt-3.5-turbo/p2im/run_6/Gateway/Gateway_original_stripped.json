{
    "functions": {
        "FUN_08007246": {
            "renaming": {
                "FUN_08007246": "handle_sys_tick_08007246",
                "HAL_IncTick": "increment_tick",
                "HAL_SYSTICK_IRQHandler": "handle_systick_interrupt",
                "noOsSystickHandler": "handle_no_os_systick"
            },
            "code": "\nvoid handle_sys_tick_08007246(void)\n\n{\n  increment_tick();\n  handle_systick_interrupt();\n  handle_no_os_systick();\n  return;\n}\n\n",
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007246",
            "calling": [],
            "imported": false,
            "current_name": "handle_sys_tick_08007246"
        },
        "FUN_0800a042": {
            "renaming": {
                "FUN_0800a042": "write_or_seek_file_0800a042",
                "param_1": "file_descriptor",
                "param_2": "buffer_pointer",
                "param_3": "buffer_size",
                "param_4": "number_of_bytes_written",
                "ushort": "unsigned_short",
                "_lseek_r": "file_seek",
                "_write_r": "file_write"
            },
            "code": "\nvoid write_or_seek_file_0800a042(undefined4 file_descriptor,int buffer_pointer,undefined4 buffer_size,undefined4 number_of_bytes_written)\n\n{\n  if ((int)((uint)*(unsigned_short *)(buffer_pointer + 0xc) << 0x17) < 0) {\n    file_seek(file_descriptor,(int)*(short *)(buffer_pointer + 0xe),0,2);\n  }\n  *(unsigned_short *)(buffer_pointer + 0xc) = *(unsigned_short *)(buffer_pointer + 0xc) & 0xefff;\n  file_write(file_descriptor,(int)*(short *)(buffer_pointer + 0xe),buffer_size,number_of_bytes_written);\n  return;\n}\n\n",
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a042",
            "calling": [],
            "imported": false,
            "current_name": "write_or_seek_file_0800a042"
        },
        "FUN_08008e4e": {
            "renaming": {
                "this": "self",
                "buffer": "data",
                "size": "data_size",
                "pPVar1": "print_obj",
                "sVar2": "bytes_printed",
                "FUN_08008e4e": "print_buffer_08008e4e"
            },
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08008e62 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\ndata_size_t __selfcall Print::print_buffer_08008e4e(Print *self,uint8_t *data,data_size_t data_size)\n\n{\n  Print *print_obj;\n  data_size_t bytes_printed;\n  \n  bytes_printed = 0;\n  print_obj = self;\n  while( true ) {\n    if (data_size == 0) {\n      return bytes_printed;\n    }\n    print_obj = (Print *)(**self->_vptr_Print)(print_obj,(uint)*data);\n    if (print_obj == (Print *)0x0) break;\n    bytes_printed = bytes_printed + 1;\n    data = data + 1;\n    data_size = data_size - 1;\n  }\n  return bytes_printed;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e4e",
            "calling": [],
            "imported": false,
            "current_name": "print_buffer_08008e4e"
        },
        "FUN_08008694": {
            "renaming": {
                "FUN_08008694": "setup_serial_transmission_08008694",
                "obj": "serial_object",
                "callback": "callback_function",
                "bVar1": "serial_index",
                "HAL_NVIC_SetPriority": "set_interrupt_priority",
                "HAL_NVIC_EnableIRQ": "enable_interrupt",
                "HAL_UART_Transmit_IT": "transmit_data_interrupt",
                "UART_HandleTypeDef": "uart_handle",
                "irq": "interrupt_request",
                "tx_buff": "transmit_buffer",
                "tx_tail": "transmit_tail"
            },
            "code": "\nvoid setup_serial_transmission_08008694(serial_t *serial_object,_func_int_serial_t_ptr *callback_function)\n\n{\n  byte serial_index;\n  \n  if (serial_object != (serial_t *)0x0) {\n    serial_index = serial_object->index;\n    *(_func_int_serial_t_ptr **)(PTR_tx_callback_function_080086dc + (uint)serial_index * 4) = callback_function;\n    *(serial_t **)(PTR_tx_callback_function_serial_object_080086e0 + (uint)serial_index * 4) = serial_object;\n    set_interrupt_priority(serial_object->interrupt_request,0,2);\n    enable_interrupt(serial_object->interrupt_request);\n    transmit_data_interrupt\n              (*(uart_handle **)(PTR_uart_handlers_080086e4 + (uint)serial_object->index * 4),\n               serial_object->transmit_buffer + serial_object->transmit_tail,1);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_SetPriority",
                "HAL_NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008694",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "setup_serial_transmission_08008694"
        },
        "FUN_08002ce0": {
            "renaming": {
                "this": "self",
                "this_00": "parser_instance",
                "FirmataMarshaller::FirmataMarshaller": "initialize_marshaller",
                "FirmataParser::FirmataParser": "initialize_parser",
                "FirmataParser::attach": "attach_parser",
                "'q'": "ANALOG_MESSAGE",
                "'y'": "REPORT_VERSION",
                "FUN_08002ce0": "initialize_08002ce0"
            },
            "code": "\ninitialize_08002ce0 * __selfcall firmata::initialize_08002ce0::initialize_08002ce0(initialize_08002ce0 *self)\n\n{\n  FirmataParser *parser_instance;\n  \n  initialize_08002ce0_marshaller(&self->marshaller);\n  parser_instance = &self->parser;\n  initialize_08002ce0_parser(parser_instance,self->parserBuffer,0x40);\n  self->firmwareVersionCount = '\\0';\n  self->firmwareVersionVector = (byte *)0x0;\n  self->blinkVersionDisabled = false;\n  attach_parser(parser_instance,0xe0,DAT_08002d90,(void *)0x0);\n  attach_parser(parser_instance,0x90,DAT_08002d94,(void *)0x0);\n  attach_parser(parser_instance,0xc0,DAT_08002d98,(void *)0x0);\n  attach_parser(parser_instance,0xd0,DAT_08002d9c,(void *)0x0);\n  attach_parser(parser_instance,0xf4,DAT_08002da0,(void *)0x0);\n  attach_parser(parser_instance,0xf5,DAT_08002da4,(void *)0x0);\n  attach_parser(parser_instance,ANALOG_MESSAGE,DAT_08002da8,(void *)0x0);\n  attach_parser(parser_instance,0xf0,DAT_08002dac,(void *)0x0);\n  attach_parser(parser_instance,REPORT_VERSION,DAT_08002db0,self);\n  attach_parser(parser_instance,0xf9,DAT_08002db4,self);\n  attach_parser(parser_instance,0xff,DAT_08002db8,(void *)0x0);\n  return self;\n}\n\n",
            "called": [
                "attach",
                "attach",
                "FirmataMarshaller",
                "attach",
                "FirmataParser",
                "attach",
                "attach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ce0",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_08002ce0"
        },
        "FUN_08005188": {
            "renaming": {
                "FUN_08005188": "handle_i2c_communication_08005188",
                "hi2c": "i2c_handle",
                "pIVar1": "i2c_instance",
                "uVar2": "i2c_status_reg_1",
                "uVar3": "i2c_control_reg_2",
                "uVar4": "i2c_status_reg_2",
                "I2C_Master_ADDR": "i2c_master_address",
                "I2C_Master_ADD10": "i2c_master_add10",
                "I2C_Master_SB": "i2c_master_start_bit",
                "I2C_MasterReceive_RXNE": "i2c_master_receive_rxne",
                "I2C_MasterReceive_BTF": "i2c_master_receive_btf",
                "I2C_MasterTransmit_TXE": "i2c_master_transmit_txe",
                "I2C_MasterTransmit_BTF": "i2c_master_transmit_btf",
                "I2C_Slave_ADDR": "i2c_slave_address",
                "I2C_Slave_STOPF": "i2c_slave_stopf",
                "I2C_SlaveReceive_RXNE": "i2c_slave_receive_rxne",
                "I2C_SlaveReceive_BTF": "i2c_slave_receive_btf",
                "I2C_SlaveTransmit_TXE": "i2c_slave_transmit_txe",
                "I2C_SlaveTransmit_BTF": "i2c_slave_transmit_btf"
            },
            "code": "\nvoid handle_i2c_communication_08005188(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  I2C_TypeDef_conflict *i2c_instance;\n  uint i2c_status_reg_1;\n  uint i2c_control_reg_2;\n  uint i2c_status_reg_2;\n  \n  i2c_instance = i2c_handle->Instance;\n  i2c_status_reg_2 = i2c_instance->SR2;\n  i2c_status_reg_1 = i2c_instance->SR1;\n  i2c_control_reg_2 = i2c_instance->CR2;\n  if ((i2c_handle->Mode == HAL_I2C_MODE_MASTER) || (i2c_handle->Mode == HAL_I2C_MODE_MEM)) {\n    if (((i2c_status_reg_1 & 0x10001) == 0) || ((i2c_control_reg_2 & 0x200) == 0)) {\n      if (((DAT_080052e8 & i2c_status_reg_1) == 0) || ((i2c_control_reg_2 & 0x200) == 0)) {\n        if (((DAT_080052d4 & i2c_status_reg_1) != 0) && ((i2c_control_reg_2 & 0x200) != 0)) {\n          i2c_master_address(i2c_handle);\n        }\n      }\n      else {\n        i2c_master_add10(i2c_handle);\n      }\n    }\n    else {\n      i2c_master_start_bit(i2c_handle);\n    }\n    if ((DAT_080052dc & i2c_status_reg_2) == 0) {\n      if ((((DAT_080052ec & i2c_status_reg_1) != 0) && ((i2c_control_reg_2 & 0x400) != 0)) && ((DAT_080052e4 & i2c_status_reg_1) == 0)\n         ) {\n        i2c_master_receive_rxne(i2c_handle);\n        return;\n      }\n      if (((DAT_080052e4 & i2c_status_reg_1) != 0) && ((i2c_control_reg_2 & 0x200) != 0)) {\n        i2c_master_receive_btf(i2c_handle);\n        return;\n      }\n    }\n    else {\n      if ((((DAT_080052e0 & i2c_status_reg_1) != 0) && ((i2c_control_reg_2 & 0x400) != 0)) && ((DAT_080052e4 & i2c_status_reg_1) == 0)\n         ) {\n        i2c_master_transmit_txe(i2c_handle);\n        return;\n      }\n      if (((DAT_080052e4 & i2c_status_reg_1) != 0) && ((i2c_control_reg_2 & 0x200) != 0)) {\n        i2c_master_transmit_btf(i2c_handle);\n        return;\n      }\n    }\n  }\n  else {\n    if (((DAT_080052d4 & i2c_status_reg_1) != 0) && ((i2c_control_reg_2 & 0x200) != 0)) {\n      i2c_slave_address(i2c_handle);\n      return;\n    }\n    if (((DAT_080052d8 & i2c_status_reg_1) != 0) && ((i2c_control_reg_2 & 0x200) != 0)) {\n      i2c_slave_stopf(i2c_handle);\n      return;\n    }\n    if ((DAT_080052dc & i2c_status_reg_2) == 0) {\n      if ((((DAT_080052ec & i2c_status_reg_1) != 0) && ((i2c_control_reg_2 & 0x400) != 0)) && ((DAT_080052e4 & i2c_status_reg_1) == 0)\n         ) {\n        i2c_slave_receive_rxne(i2c_handle);\n        return;\n      }\n      if (((DAT_080052e4 & i2c_status_reg_1) != 0) && ((i2c_control_reg_2 & 0x200) != 0)) {\n        i2c_slave_receive_btf(i2c_handle);\n      }\n    }\n    else {\n      if ((((DAT_080052e0 & i2c_status_reg_1) != 0) && ((i2c_control_reg_2 & 0x400) != 0)) && ((DAT_080052e4 & i2c_status_reg_1) == 0)\n         ) {\n        i2c_slave_transmit_txe(i2c_handle);\n        return;\n      }\n      if (((DAT_080052e4 & i2c_status_reg_1) != 0) && ((i2c_control_reg_2 & 0x200) != 0)) {\n        i2c_slave_transmit_btf(i2c_handle);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "I2C_MasterTransmit_BTF",
                "I2C_Master_ADD10",
                "I2C_Master_ADDR",
                "I2C_MasterTransmit_TXE",
                "I2C_SlaveReceive_RXNE",
                "I2C_Master_SB",
                "I2C_SlaveReceive_BTF",
                "I2C_MasterReceive_BTF",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_TXE",
                "I2C_SlaveTransmit_BTF",
                "I2C_Slave_STOPF",
                "I2C_MasterReceive_RXNE"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005188",
            "calling": [
                "I2C1_EV_IRQHandler",
                "I2C2_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_communication_08005188"
        },
        "FUN_08007244": {
            "renaming": {
                "FUN_08007244": "do_nothing_08007244"
            },
            "code": "\nvoid do_nothing_08007244(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007244",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "do_nothing_08007244"
        },
        "FUN_08001bf8": {
            "renaming": {
                "FUN_08001bf8": "send_data_via_wire_08001bf8",
                "data": "byte_data",
                "TwoWire::write": "write_to_wire"
            },
            "code": "\nvoid send_data_via_wire_08001bf8(byte byte_data)\n\n{\n  write_to_wire((TwoWire *)PTR_Wire_08001c04,byte_data);\n  return;\n}\n\n",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001bf8",
            "calling": [
                "sysexCallback",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "send_data_via_wire_08001bf8"
        },
        "FUN_080069ec": {
            "renaming": {
                "FUN_080069ec": "uart_handler_080069ec",
                "huart": "uart_handle",
                "HVar1": "hal_status",
                "uVar2": "control_reg",
                "pUVar3": "usart_instance",
                "uVar4": "cr3_bit",
                "uVar5": "sr_reg"
            },
            "code": "\nvoid uart_handler_080069ec(UART_HandleTypeDef *uart_handle)\n\n{\n  HAL_StatusTypeDef_conflict hal_status;\n  uint control_reg;\n  USART_TypeDef *usart_instance;\n  uint cr3_bit;\n  uint sr_reg;\n  \n  usart_instance = uart_handle->Instance;\n  sr_reg = usart_instance->SR;\n  control_reg = usart_instance->CR1;\n  if ((((sr_reg & 0xf) == 0) && ((sr_reg & 0x20) != 0)) && ((control_reg & 0x20) != 0)) {\n    UART_Receive_IT(uart_handle);\n    return;\n  }\n  if (((sr_reg & 0xf) == 0) || ((cr3_bit = usart_instance->CR3 & 1, cr3_bit == 0 && ((control_reg & 0x120) == 0)))) {\n    if (((sr_reg & 0x80) != 0) && ((control_reg & 0x80) != 0)) {\n      UART_Transmit_IT(uart_handle);\n      return;\n    }\n    if (((sr_reg & 0x40) != 0) && ((control_reg & 0x40) != 0)) {\n      UART_EndTransmit_IT(uart_handle);\n    }\n  }\n  else {\n    if (((sr_reg & 1) != 0) && ((control_reg & 0x100) != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 1;\n    }\n    if (((sr_reg & 4) != 0) && (cr3_bit != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 2;\n    }\n    if (((sr_reg & 2) != 0) && (cr3_bit != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 4;\n    }\n    if (((sr_reg & 8) != 0) && (cr3_bit != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 8;\n    }\n    if (uart_handle->ErrorCode != 0) {\n      if (((sr_reg & 0x20) != 0) && ((control_reg & 0x20) != 0)) {\n        UART_Receive_IT(uart_handle);\n      }\n      if (((uart_handle->ErrorCode & 8) == 0) && ((uart_handle->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(uart_handle);\n        uart_handle->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(uart_handle);\n      usart_instance = uart_handle->Instance;\n      if ((usart_instance->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(uart_handle);\n        return;\n      }\n      usart_instance->CR3 = usart_instance->CR3 & 0xffffffbf;\n      if (uart_handle->hdmarx == (DMA_HandleTypeDef_conflict *)0x0) {\n        HAL_UART_ErrorCallback(uart_handle);\n        return;\n      }\n      uart_handle->hdmarx->XferAbortCallback = DAT_08006b08;\n      hal_status = HAL_DMA_Abort_IT(uart_handle->hdmarx);\n      if (hal_status != HAL_OK) {\n        (*uart_handle->hdmarx->XferAbortCallback)(uart_handle->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "UART_EndTransmit_IT",
                "HAL_DMA_Abort_IT",
                "UART_EndRxTransfer",
                "UART_Receive_IT",
                "UART_Transmit_IT",
                "HAL_UART_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080069ec",
            "calling": [
                "USART2_IRQHandler",
                "USART1_IRQHandler",
                "USART3_IRQHandler"
            ],
            "imported": false,
            "current_name": "uart_handler_080069ec"
        },
        "FUN_0800a168": {
            "renaming": {
                "FUN_0800a168": "read_from_file_0800a168",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "puVar1": "errno_ptr",
                "iVar2": "bytes_read"
            },
            "code": "\nvoid read_from_file_0800a168(int *error_code,int file_descriptor,char *buffer,int buffer_size)\n\n{\n  undefined *errno_ptr;\n  int bytes_read;\n  \n  errno_ptr = PTR_errno_0800a188;\n  *(undefined4 *)PTR_errno_0800a188 = 0;\n  bytes_read = _read(file_descriptor,buffer,buffer_size);\n  if ((bytes_read == -1) && (*(int *)errno_ptr != 0)) {\n    *error_code = *(int *)errno_ptr;\n  }\n  return;\n}\n\n",
            "called": [
                "_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a168",
            "calling": [
                "__sread"
            ],
            "imported": false,
            "current_name": "read_from_file_0800a168"
        },
        "FUN_080067ac": {
            "renaming": {
                "FUN_080067ac": "send_data_via_uart_080067ac",
                "huart": "uart_handle",
                "pData": "data_buffer",
                "Size": "data_size",
                "Timeout": "timeout_ms",
                "HVar1": "status",
                "Tickstart": "start_tick",
                "HAL_UART_STATE_READY": "ready_state",
                "HAL_ERROR": "error_status",
                "HAL_LOCKED": "locked_status",
                "HAL_BUSY": "busy_status",
                "HAL_UART_STATE_BUSY_TX": "busy_tx_state",
                "HAL_GetTick()": "get_current_tick()",
                "UART_WaitOnFlagUntilTimeout": "wait_on_flag_until_timeout",
                "RESET": "reset_value",
                "HAL_TIMEOUT": "timeout_status"
            },
            "code": "\nHAL_StatusTypeDef_conflict\nsend_data_via_uart_080067ac(UART_HandleTypeDef *uart_handle,uint8_t *data_buffer,uint16_t data_size,uint32_t timeout_ms)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t start_tick;\n  \n  if (uart_handle->gState == ready_state) {\n    if (data_buffer == (uint8_t *)0x0) {\n      status = error_status;\n    }\n    else if (data_size == 0) {\n      status = error_status;\n    }\n    else if (uart_handle->Lock == locked_status) {\n      status = busy_status;\n    }\n    else {\n      uart_handle->Lock = locked_status;\n      uart_handle->ErrorCode = 0;\n      uart_handle->gState = busy_tx_state;\n      start_tick = get_current_tick();\n      uart_handle->TxXferdata_size = data_size;\n      uart_handle->TxXferCount = data_size;\n      while (uart_handle->TxXferCount != 0) {\n        uart_handle->TxXferCount = uart_handle->TxXferCount - 1;\n        if ((uart_handle->Init).WordLength == 0x1000) {\n          status = wait_on_flag_until_timeout(uart_handle,0x80,reset_value,start_tick,timeout_ms);\n          if (status != HAL_OK) {\n            return timeout_status;\n          }\n          uart_handle->Instance->DR = *(ushort *)data_buffer & 0x1ff;\n          if ((uart_handle->Init).Parity == 0) {\n            data_buffer = (uint8_t *)((int)data_buffer + 2);\n          }\n          else {\n            data_buffer = (uint8_t *)((int)data_buffer + 1);\n          }\n        }\n        else {\n          status = wait_on_flag_until_timeout(uart_handle,0x80,reset_value,start_tick,timeout_ms);\n          if (status != HAL_OK) {\n            return timeout_status;\n          }\n          uart_handle->Instance->DR = (uint)*data_buffer;\n          data_buffer = (uint8_t *)((int)data_buffer + 1);\n        }\n      }\n      status = wait_on_flag_until_timeout(uart_handle,0x40,reset_value,start_tick,timeout_ms);\n      if (status == HAL_OK) {\n        uart_handle->gState = ready_state;\n        uart_handle->Lock = HAL_UNLOCKED;\n      }\n      else {\n        status = timeout_status;\n      }\n    }\n  }\n  else {\n    status = busy_status;\n  }\n  return status;\n}\n\n",
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080067ac",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "send_data_via_uart_080067ac"
        },
        "FUN_0800735a": {
            "renaming": {
                "FUN_0800735a": "find_pin_function_0800735a",
                "PinName_conflict": "requested_pin",
                "PinMap_conflict": "pin_map",
                "map": "current_pin",
                "NC": "not_connected",
                "function": "pin_function"
            },
            "code": "\nuint32_t find_pin_function_0800735a(requested_pin pin,pin_map *current_pin)\n\n{\n  while( true ) {\n    if (current_pin->pin == not_connected) {\n      return 0xffffffff;\n    }\n    if (current_pin->pin == pin) break;\n    current_pin = current_pin + 1;\n  }\n  return current_pin->pin_function;\n}\n\n",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800735a",
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "imported": false,
            "current_name": "find_pin_function_0800735a"
        },
        "FUN_08008c20": {
            "renaming": {
                "this": "serialInstance",
                "ctx": "keyContext",
                "FUN_08008c20": "initialize_serial_buffers_08008c20"
            },
            "code": "\nint __serialInstancecall HardwareSerial::initializeSerialBuffers_08008c20(HardwareSerial *serialInstance,EVP_PKEY_CTX *keyContext)\n\n{\n  (serialInstance->_serial).rx_buff = serialInstance->_rx_buffer;\n  (serialInstance->_serial).rx_head = 0;\n  (serialInstance->_serial).rx_tail = 0;\n  (serialInstance->_serial).tx_buff = serialInstance->_tx_buffer;\n  (serialInstance->_serial).tx_head = 0;\n  (serialInstance->_serial).tx_tail = 0;\n  return (int)serialInstance;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008c20",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "initialize_serial_buffers_08008c20"
        },
        "FUN_0800723c": {
            "renaming": {
                "FUN_0800723c": "get_current_time_0800723c",
                "uVar1": "current_time",
                "HAL_GetTick": "get_tick_count"
            },
            "code": "\nuint32_t get_current_time_0800723c(void)\n\n{\n  uint32_t current_time;\n  \n  current_time = get_tick_count();\n  return current_time;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800723c",
            "calling": [
                "millis"
            ],
            "imported": false,
            "current_name": "get_current_time_0800723c"
        },
        "FUN_080043a2": {
            "renaming": {
                "FUN_080043a2": "handle_i2c_state_080043a2",
                "hi2c": "i2c_handle",
                "uVar1": "transfer_options",
                "pIVar2": "i2c_instance",
                "tmpreg": "tmp_reg_1",
                "tmpreg_1": "tmp_reg_2",
                "tmpreg_2": "tmp_reg_3",
                "tmpreg_3": "tmp_reg_4",
                "tmpreg_4": "tmp_reg_5",
                "tmpreg_5": "tmp_reg_6",
                "tmpreg_6": "tmp_reg_7",
                "tmpreg_7": "tmp_reg_8",
                "tmpreg_8": "tmp_reg_9",
                "tmpreg_9": "tmp_reg_10"
            },
            "code": "\nHAL_StatusTypeDef_conflict handle_i2c_state_080043a2(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  uint32_t transfer_options;\n  I2C_TypeDef_conflict *i2c_instance;\n  uint32_t tmp_reg_1;\n  uint32_t tmp_reg_2;\n  uint32_t tmp_reg_3;\n  uint32_t tmp_reg_4;\n  uint32_t tmp_reg_5;\n  uint32_t tmp_reg_6;\n  uint32_t tmp_reg_7;\n  uint32_t tmp_reg_8;\n  uint32_t tmp_reg_9;\n  uint32_t tmp_reg_10;\n  uint32_t tmp_reg_20;\n  \n  transfer_options = i2c_handle->XferOptions;\n  if ((i2c_handle->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((i2c_handle->EventCount != 0 || (i2c_handle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((i2c_handle->EventCount == 0) && ((i2c_handle->Init).AddressingMode == 0xc000)) {\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x100;\n      i2c_handle->EventCount = i2c_handle->EventCount + 1;\n    }\n    else {\n      if (i2c_handle->XferCount == 0) {\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n      }\n      else if (i2c_handle->XferCount == 1) {\n        if (transfer_options == 0xffff0000) {\n          i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffbff;\n          i2c_instance = i2c_handle->Instance;\n          if ((i2c_instance->CR2 & 0x800) == 0) {\n            i2c_instance->CR1 = i2c_instance->CR1 | 0x200;\n          }\n          else {\n            i2c_instance->CR1 = i2c_instance->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((transfer_options == 4) || (transfer_options == 8)) || (i2c_handle->PreviousState == 0x12)) {\n          i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffbff;\n          i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n        }\n        else if (i2c_handle->XferOptions == 2) {\n          i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (i2c_handle->XferCount == 2) {\n        if (i2c_handle->XferOptions == 2) {\n          i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x800;\n          i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffbff;\n        }\n        i2c_instance = i2c_handle->Instance;\n        if ((i2c_instance->CR2 & 0x800) != 0) {\n          i2c_instance->CR2 = i2c_instance->CR2 | 0x1000;\n        }\n      }\n      else {\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x400;\n        i2c_instance = i2c_handle->Instance;\n        if ((i2c_instance->CR2 & 0x800) != 0) {\n          i2c_instance->CR2 = i2c_instance->CR2 | 0x1000;\n        }\n      }\n      i2c_handle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080043a2",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_state_080043a2"
        },
        "FUN_08006280": {
            "renaming": {
                "FUN_08006280": "configure_tim_channel_08006280",
                "htim": "tim_handle",
                "Channel": "channel_num",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "pTVar1": "tim_instance",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "\nHAL_StatusTypeDef configure_TIM_channel_08006280(TIM_HandleTypeDef_conflict *tim_handle,uint32_t channel_num)\n\n{\n  TIM_TypeDef *tim_instance;\n  \n  switch(channel_num) {\n  case 0:\n    tim_handle->Instance->DIER = tim_handle->Instance->DIER | 2;\n    break;\n  case 4:\n    tim_handle->Instance->DIER = tim_handle->Instance->DIER | 4;\n    break;\n  case 8:\n    tim_handle->Instance->DIER = tim_handle->Instance->DIER | 8;\n    break;\n  case 0xc:\n    tim_handle->Instance->DIER = tim_handle->Instance->DIER | 0x10;\n  }\n  TIM_CCxchannel_numCmd(tim_handle->Instance,channel_num,1);\n  tim_instance = tim_handle->Instance;\n  if (tim_instance == DAT_080062f0) {\n    tim_instance->BDTR = tim_instance->BDTR | 0x8000;\n  }\n  tim_handle->Instance->CR1 = tim_handle->Instance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006280",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "configure_tim_channel_08006280"
        },
        "FUN_08007258": {
            "renaming": {
                "FUN_08007258": "initialize_gpio_pin_08007258",
                "pin": "pin_name",
                "mode": "pin_mode",
                "pull": "pin_pull",
                "uVar1": "pin_number",
                "GPIOx": "GPIO_port",
                "tmpreg": "temporary_register",
                "GPIO_InitStructure": "GPIO_initialization_structure"
            },
            "code": "\nvoid initialize_GPIO_pin_08007258(PinName_conflict pin_name,uint32_t pin_mode,uint32_t pin_pull)\n\n{\n  uint pin_number;\n  GPIO_TypeDef *GPIO_port;\n  uint32_t temporary_register;\n  GPIO_InitTypeDef GPIO_initialization_structure;\n  \n  pin_number = (uint)pin_name;\n  GPIO_port = set_GPIO_Port_Clock((pin_number << 0x18) >> 0x1c);\n  GPIO_initialization_structure.Pin = 1 << (pin_number & 0xf) & 0xffff;\n  GPIO_initialization_structure.Speed = 3;\n  *(uint *)(DAT_080072d0 + 0x18) = *(uint *)(DAT_080072d0 + 0x18) | 1;\n  if ((pin_number - 0xd & 0xff) < 2) {\n    *(uint *)(DAT_080072d4 + 4) = *(uint *)(DAT_080072d4 + 4) & 0xf8ffffff | 0x4000000;\n  }\n  if (((pin_number == 0xf) || (pin_number == 0x13)) || (pin_number == 0x14)) {\n    *(uint *)(DAT_080072d4 + 4) = *(uint *)(DAT_080072d4 + 4) & 0xf8ffffff | 0x2000000;\n  }\n  GPIO_initialization_structure.Mode = pin_mode;\n  GPIO_initialization_structure.Pull = pin_pull;\n  HAL_GPIO_Init(GPIO_port,&GPIO_initialization_structure);\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007258",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "initialize_gpio_pin_08007258"
        },
        "FUN_08009f4c": {
            "renaming": {
                "FUN_08009f4c": "realloc_or_malloc_08009f4c",
                "param_1": "size",
                "param_2": "old_ptr",
                "param_3": "new_size",
                "param_4": "alignment",
                "pvVar1": "result_ptr",
                "pvVar2": "usable_size"
            },
            "code": "\nvoid * realloc_or_malloc_08009f4c(undefined4 size,void *old_ptr,void *new_size,undefined4 alignment)\n\n{\n  void *result_ptr;\n  void *usable_size;\n  \n  if (old_ptr != (void *)0x0) {\n    if (new_size == (void *)0x0) {\n      _free_r();\n      result_ptr = new_size;\n    }\n    else {\n      usable_size = (void *)_malloc_usable_size_r();\n      result_ptr = old_ptr;\n      if ((usable_size < new_size) && (result_ptr = (void *)_malloc_r(size,new_size), result_ptr != (void *)0x0)\n         ) {\n        memcpy(result_ptr,old_ptr,(size_t)new_size);\n        _free_r(size,old_ptr);\n      }\n    }\n    return result_ptr;\n  }\n  result_ptr = (void *)_malloc_r(size,new_size,new_size,alignment);\n  return result_ptr;\n}\n\n",
            "called": [
                "_free_r",
                "memcpy",
                "_malloc_usable_size_r",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f4c",
            "calling": [
                "realloc"
            ],
            "imported": false,
            "current_name": "realloc_or_malloc_08009f4c"
        },
        "FUN_08009f4a": {
            "renaming": {
                "FUN_08009f4a": "do_nothing_08009f4a"
            },
            "code": "\nvoid do_nothing_08009f4a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f4a",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_08009f4a"
        },
        "FUN_08006c7c": {
            "renaming": {
                "FUN_08006c7c": "get_pwm_frequency_08006c7c",
                "pin": "pin_name",
                "uVar1": "pwm_function",
                "uVar2": "shifted_value"
            },
            "code": "\nuint32_t get_pwm_frequency_08006c7c(PinName_conflict pin_name)\n\n{\n  uint32_t pwm_function;\n  uint shifted_value;\n  \n  pwm_function = pin_namemap_function(pin_name,(PinMap_conflict *)PTR_PinMap_PWM_08006ca4);\n  shifted_value = (pwm_function << 0xc) >> 0x1b;\n  if (shifted_value == 3) {\n    return 8;\n  }\n  if (shifted_value != 4) {\n    if (shifted_value != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c7c",
            "calling": [
                "pwm_stop",
                "pwm_start"
            ],
            "imported": false,
            "current_name": "get_pwm_frequency_08006c7c"
        },
        "FUN_08006b5c": {
            "renaming": {
                "FUN_08006b5c": "update_pin_map_08006b5c",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "pin_index"
            },
            "code": "\nvoid update_pin_map_08006b5c(PinName_conflict pin_name,uint32_t *pin_map)\n\n{\n  uint pin_index;\n  \n  pin_index = (uint)((int)pin_name << 0x18) >> 0x1c;\n  pin_map[pin_index] = pin_map[pin_index] & ~(1 << ((int)pin_name & 0xfU));\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b5c",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "update_pin_map_08006b5c"
        },
        "FUN_08007376": {
            "renaming": {
                "FUN_08007376": "find_pin_function_08007376",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "function_index"
            },
            "code": "\nuint32_t find_pin_function_08007376(PinName_conflict pin_name,PinMap_conflict *pin_map)\n\n{\n  uint32_t function_index;\n  \n  if (pin_name == NC) {\n    return 0xffffffff;\n  }\n  function_index = pin_namepin_map_find_function(pin_name,pin_map);\n  return function_index;\n}\n\n",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007376",
            "calling": [
                "pwm_stop",
                "get_adc_channel",
                "get_pwm_channel",
                "HAL_TIM_PWM_MspInit",
                "pwm_start",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "find_pin_function_08007376"
        },
        "FUN_080033cc": {
            "renaming": {
                "dataBuffer": "buffer",
                "sysexBytesRead": "bytes_read",
                "currentStringCallback": "string_callback",
                "currentStringCallbackContext": "string_callback_context",
                "currentReportFirmwareCallback": "firmware_report_callback",
                "currentReportFirmwareCallbackContext": "firmware_report_callback_context",
                "currentSysexCallback": "sysex_callback",
                "currentSysexCallbackContext": "sysex_callback_context",
                "decodeByteStream": "decode_stream",
                "bufferDataAtPosition": "buffer_data",
                "FUN_080033cc": "firmata_parser_080033cc",
                "puVar3": "buffer_ptr",
                "sVar2": "decoded_stream_size",
                "uVar1": "first_byte"
            },
            "code": "\nvoid __thiscall firmata::FirmataParser::firmata_parser_080033cc(FirmataParser *this)\n\n{\n  uint8_t first_byte;\n  size_t decoded_stream_size;\n  uint8_t *buffer_ptr;\n  \n  buffer_ptr = this->buffer;\n  first_byte = *buffer_ptr;\n  if (first_byte == 'q') {\n    if (this->string_callback != (stringCallbackFunction)0x0) {\n      decoded_stream_size = decode_stream(this,this->bytes_read - 1,buffer_ptr + 1);\n      buffer_data(this,'\\0',decoded_stream_size + 1);\n      (*this->string_callback)\n                (this->string_callback_context,(char *)(this->buffer + 1));\n      return;\n    }\n  }\n  else if (first_byte == 'y') {\n    if (this->firmware_report_callback != (versionCallbackFunction)0x0) {\n      if (this->bytes_read < 3) {\n        (*this->firmware_report_callback)\n                  (this->firmware_report_callback_context,0,0,(char *)0x0);\n        return;\n      }\n      decoded_stream_size = decode_stream(this,this->bytes_read - 3,buffer_ptr + 3);\n      buffer_data(this,'\\0',decoded_stream_size + 3);\n      buffer_ptr = this->buffer;\n      (*this->firmware_report_callback)\n                (this->firmware_report_callback_context,(uint)buffer_ptr[1],(uint)buffer_ptr[2],\n                 (char *)(buffer_ptr + 3));\n      return;\n    }\n  }\n  else if (this->sysex_callback != (sysexCallbackFunction)0x0) {\n    (*this->sysex_callback)\n              (this->sysex_callback_context,first_byte,this->bytes_read - 1,buffer_ptr + 1);\n  }\n  return;\n}\n\n",
            "called": [
                "bufferDataAtPosition",
                "decodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033cc",
            "calling": [
                "parse"
            ],
            "imported": false,
            "current_name": "firmata_parser_080033cc"
        },
        "FUN_08003de4": {
            "renaming": {
                "FUN_08003de4": "stop_adc_conversion_08003de4",
                "hadc": "adc_handle",
                "HVar1": "status",
                "HAL_LOCKED": "locked",
                "HAL_UNLOCKED": "unlocked",
                "ADC_ConversionStop_Disable": "disable_adc_conversion_stop",
                "HAL_BUSY": "busy",
                "State": "state"
            },
            "code": "\nHAL_StatusTypeDef_conflict stop_adc_conversion_08003de4(ADC_HandleTypeDef *adc_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  \n  if (adc_handle->Lock == locked) {\n    return busy;\n  }\n  adc_handle->Lock = locked;\n  status = disable_adc_conversion_stop(adc_handle);\n  if (status == HAL_OK) {\n    adc_handle->state = adc_handle->state & 0xffffeefe | 1;\n  }\n  adc_handle->Lock = unlocked;\n  return status;\n}\n\n",
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003de4",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "stop_adc_conversion_08003de4"
        },
        "FUN_08000500": {
            "renaming": {
                "FUN_08000500": "attach_servo_08000500",
                "pin": "servo_pin",
                "minPulse": "min_pulse_width",
                "maxPulse": "max_pulse_width",
                "bVar1": "servo_count",
                "bVar2": "detached_servo_count",
                "pin_00": "servo_pin_uint"
            },
            "code": "\nvoid attach_servo_08000500(byte servo_pin,int min_pulse_width,int max_pulse_width)\n\n{\n  byte servo_count;\n  byte detached_servo_count;\n  uint servo_pin_uint;\n  \n  servo_pin_uint = (uint)servo_pin;\n  servo_count = *PTR_servoCount_0800056c;\n  if (0xb < servo_count) {\n    firmata::FirmataClass::sendString\n              ((FirmataClass *)PTR_Firmata_08000584,PTR_s_Max_servos_attached_08000580);\n    return;\n  }\n  detached_servo_count = *PTR_detachedServoCount_08000570;\n  if (detached_servo_count == 0) {\n    PTR_servoPinMap_08000578[servo_pin_uint] = servo_count;\n    *PTR_servoCount_0800056c = servo_count + 1;\n  }\n  else {\n    PTR_servoPinMap_08000578[servo_pin_uint] = PTR_detachedServos_08000574[detached_servo_count - 1];\n    *PTR_detachedServoCount_08000570 = detached_servo_count - 1;\n  }\n  if ((0 < min_pulse_width) && (0 < max_pulse_width)) {\n    Servo::attach((Servo *)(PTR_servos_0800057c + (uint)(byte)PTR_servoPinMap_08000578[servo_pin_uint] * 3),\n                  servo_pin_uint,min_pulse_width,max_pulse_width);\n    return;\n  }\n  Servo::attach((Servo *)(PTR_servos_0800057c + (uint)(byte)PTR_servoPinMap_08000578[servo_pin_uint] * 3),\n                servo_pin_uint);\n  return;\n}\n\n",
            "called": [
                "attach",
                "attach",
                "sendString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000500",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "attach_servo_08000500"
        },
        "FUN_08009d24": {
            "renaming": {
                "FUN_08009d24": "allocate_array_08009d24",
                "param_1": "size",
                "param_2": "num_elements",
                "puVar1": "array_ptr",
                "iVar2": "total_size",
                "_malloc_r": "allocate_memory",
                "puVar1[1]": "array_ptr[1]",
                "puVar1[2]": "array_ptr[2]",
                "memset": "set_array_values"
            },
            "code": "\nundefined4 * allocate_array_08009d24(undefined4 size,int num_elements)\n\n{\n  undefined4 *array_ptr;\n  int total_size;\n  \n  total_size = (num_elements + -1) * 0x68;\n  array_ptr = (undefined4 *)allocate_memory(size,total_size + 0x74);\n  if (array_ptr != (undefined4 *)0x0) {\n    *array_ptr = 0;\n    array_ptr[1] = num_elements;\n    array_ptr[2] = array_ptr + 3;\n    set_array_values(array_ptr + 3,0,total_size + 0x68);\n  }\n  return array_ptr;\n}\n\n",
            "called": [
                "memset",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009d24",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "allocate_array_08009d24"
        },
        "FUN_08008e72": {
            "renaming": {
                "sVar1": "result",
                "FUN_08008e72": "print_char_08008e72"
            },
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08008e78 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nsize_t __thiscall Print::print_char_08008e72(Print *this,char c)\n\n{\n  size_t result;\n  \n  result = (**this->_vptr_Print)(this,(int)c);\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e72",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "print_char_08008e72"
        },
        "FUN_080022f8": {
            "renaming": {
                "FUN_080022f8": "process_pins_data_080022f8",
                "bVar1": "is_digital_pin",
                "PVar2": "pin_name",
                "bVar3": "pin_mode",
                "iVar4": "firmata_available",
                "uVar5": "current_millis",
                "uVar6": "pin_index",
                "ulPin": "digital_pin_number"
            },
            "code": "\nvoid process_pins_data_080022f8(void)\n\n{\n  bool is_digital_pin;\n  PinName_conflict pin_name;\n  byte pin_mode;\n  int firmata_available;\n  uint32_t current_millis;\n  uint pin_index;\n  uint digital_pin_number;\n  \n  checkDigitalInputs();\n  while (firmata_available = firmata::FirmataClass::available((FirmataClass *)PTR_Firmata_080023e0), firmata_available != 0)\n  {\n    firmata::FirmataClass::processInput((FirmataClass *)PTR_Firmata_080023e0);\n  }\n  current_millis = millis();\n  *(uint32_t *)PTR_currentMillis_080023e4 = current_millis;\n  if (*(uint *)PTR_samplingInterval_080023ec < current_millis - *(int *)PTR_previousMillis_080023e8) {\n    *(uint *)PTR_previousMillis_080023e8 =\n         *(int *)PTR_previousMillis_080023e8 + *(uint *)PTR_samplingInterval_080023ec;\n    for (pin_index = 0; pin_index < 0x3c; pin_index = pin_index + 1 & 0xff) {\n      digital_pin_number = pin_index - 0x2e & 0xff;\n      if (digital_pin_number < 0xe) {\n        if (pin_index < 0x3c) {\n          pin_name = PTR_digitalPin_080023f4[pin_index];\n        }\n        else {\n          pin_name = NC;\n        }\n        current_millis = pinNametoDigitalPin(pin_name);\n        if (current_millis == 0) {\n          is_digital_pin = false;\n        }\n        else {\n          if (pin_index < 0x3c) {\n            pin_name = PTR_digitalPin_080023f4[pin_index];\n          }\n          else {\n            pin_name = NC;\n          }\n          current_millis = pinNametoDigitalPin(pin_name);\n          if (current_millis == 1) {\n            is_digital_pin = false;\n          }\n          else {\n            pin_mode = firmata::FirmataClass::getPinMode\n                              ((FirmataClass *)PTR_Firmata_080023e0,(byte)pin_index);\n            if (pin_mode == '\\x02') {\n              is_digital_pin = true;\n            }\n            else {\n              is_digital_pin = false;\n            }\n          }\n        }\n      }\n      else {\n        is_digital_pin = false;\n      }\n      if ((is_digital_pin) && ((*(int *)PTR_analogInputsToReport_080023f0 >> digital_pin_number & 1U) != 0)) {\n        current_millis = analogRead(digital_pin_number);\n        firmata::FirmataClass::sendAnalog((FirmataClass *)PTR_Firmata_080023e0,(byte)digital_pin_number,current_millis);\n      }\n    }\n    if (-1 < (char)*PTR_queryIndex_080023f8) {\n      for (pin_index = 0; (int)pin_index < (char)*PTR_queryIndex_080023f8 + 1; pin_index = pin_index + 1 & 0xff) {\n        firmata_available = pin_index * 0xc;\n        readAndReportData(PTR_query_080023fc[firmata_available],*(int *)(PTR_query_080023fc + firmata_available + 4),\n                          PTR_query_080023fc[firmata_available + 8],PTR_query_080023fc[firmata_available + 9]);\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "processInput",
                "checkDigitalInputs",
                "millis",
                "pinNametoDigitalPin",
                "sendAnalog",
                "analogRead",
                "readAndReportData",
                "getPinMode",
                "available"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080022f8",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "process_pins_data_080022f8"
        },
        "FUN_08005084": {
            "renaming": {
                "FUN_08005084": "i2c_transfer_08005084",
                "hi2c": "i2c_handle",
                "HVar1": "i2c_state",
                "pIVar2": "i2c_instance",
                "puVar3": "data_ptr",
                "tmpreg": "temporary_register"
            },
            "code": "\nHAL_StatusTypeDef_conflict i2c_transfer_08005084(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  HAL_I2C_StateTypeDef_conflict i2c_state;\n  I2C_TypeDef_conflict *i2c_instance;\n  uint8_t *data_ptr;\n  uint32_t temporary_register;\n  \n  i2c_state = i2c_handle->State;\n  i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n  i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 1;\n  i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffbff;\n  i2c_instance = i2c_handle->Instance;\n  if ((i2c_instance->CR2 & 0x800) != 0) {\n    if ((i2c_handle->State == HAL_I2C_STATE_BUSY_RX) || (i2c_handle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2c_handle->XferCount = (uint16_t)i2c_handle->hdmarx->Instance->CNDTR;\n    }\n    else {\n      i2c_handle->XferCount = (uint16_t)i2c_handle->hdmatx->Instance->CNDTR;\n    }\n  }\n  if (i2c_handle->XferCount != 0) {\n    if ((i2c_instance->SR1 & 4) != 0) {\n      data_ptr = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = data_ptr + 1;\n      *data_ptr = (uint8_t)i2c_instance->DR;\n      i2c_handle->XferCount = i2c_handle->XferCount - 1;\n    }\n    if ((i2c_handle->Instance->SR1 & 0x40) != 0) {\n      data_ptr = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = data_ptr + 1;\n      *data_ptr = (uint8_t)i2c_handle->Instance->DR;\n      i2c_handle->XferCount = i2c_handle->XferCount - 1;\n    }\n    i2c_handle->ErrorCode = i2c_handle->ErrorCode | 4;\n  }\n  if (i2c_handle->ErrorCode == 0) {\n    if (((i2c_state == HAL_I2C_STATE_LISTEN) || (i2c_state == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (i2c_state == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2c_handle->XferOptions = DAT_08005184;\n      i2c_handle->PreviousState = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2c_handle);\n    }\n    else if ((i2c_handle->PreviousState == 0x22) || (i2c_state == HAL_I2C_STATE_BUSY_RX)) {\n      i2c_handle->PreviousState = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2c_handle);\n    }\n  }\n  else {\n    I2C_ITError(i2c_handle);\n  }\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005084",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08005084"
        },
        "FUN_08008b0e": {
            "renaming": {
                "FUN_08008b0e": "read_next_byte_from_serial_08008b0e",
                "this": "serial_instance",
                "_serial": "serial_data",
                "rx_tail": "tail_index",
                "rx_head": "head_index",
                "rx_buff": "receive_buffer"
            },
            "code": "\nint __serial_instancecall HardwareSerial::read_next_byte_from_serial_08008b0e(HardwareSerial *serial_instance)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)(serial_instance->serial_data).tail_index;\n  if ((serial_instance->serial_data).head_index != uVar1) {\n    return (uint)(serial_instance->serial_data).receive_buffer[uVar1];\n  }\n  return -1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b0e",
            "calling": [],
            "imported": false,
            "current_name": "read_next_byte_from_serial_08008b0e"
        },
        "FUN_0800291c": {
            "renaming": {
                "this": "i2c_connection",
                "FUN_0800291c": "initialize_i2c_connection_0800291c"
            },
            "code": "\ninitialize_i2c_connection_0800291c * __i2c_connectioncall initialize_i2c_connection_0800291c::initialize_i2c_connection_0800291c(initialize_i2c_connection_0800291c *i2c_connection)\n\n{\n  undefined *puVar1;\n  \n  (i2c_connection->super_Stream).super_Print.write_error = 0;\n  (i2c_connection->super_Stream)._timeout = 1000;\n  (i2c_connection->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)PTR_PTR_write_1_08002940;\n  puVar1 = PTR_digitalPin_08002944;\n  (i2c_connection->_i2c).sda = PTR_digitalPin_08002944[0xe];\n  (i2c_connection->_i2c).scl = puVar1[0xf];\n  return i2c_connection;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800291c",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_i2c_connection_0800291c"
        },
        "FUN_08002ac0": {
            "renaming": {
                "this": "wireInstance",
                "uVar1": "returnValue",
                "FUN_08002ac0": "initialize_wire_connection_08002ac0"
            },
            "code": "\nuint8_t __wireInstancecall TwoWire::initializeWireConnection_08002ac0(TwoWire *wireInstance)\n\n{\n  uint8_t returnValue;\n  \n  returnValue = initializeWireConnection_08002ac0(wireInstance,'\\x01');\n  return returnValue;\n}\n\n",
            "called": [
                "endTransmission"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ac0",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "initialize_wire_connection_08002ac0"
        },
        "FUN_080032bc": {
            "renaming": {
                "this": "self",
                "dataBuffer": "buffer",
                "dataBufferSize": "buffer_size",
                "executeMultiByteCommand": "multi_byte_command",
                "multiByteChannel": "multi_byte_channel",
                "waitForData": "wait_for_data",
                "parsingSysex": "is_parsing_sysex",
                "sysexBytesRead": "sysex_bytes_read",
                "currentAnalogCallbackContext": "analog_callback_context",
                "currentDigitalCallbackContext": "digital_callback_context",
                "currentReportAnalogCallbackContext": "report_analog_callback_context",
                "currentReportDigitalCallbackContext": "report_digital_callback_context",
                "currentPinModeCallbackContext": "pin_mode_callback_context",
                "currentPinValueCallbackContext": "pin_value_callback_context",
                "currentReportFirmwareCallbackContext": "report_firmware_callback_context",
                "currentReportVersionCallbackContext": "report_version_callback_context",
                "currentDataBufferOverflowCallbackContext": "data_buffer_overflow_callback_context",
                "currentStringCallbackContext": "string_callback_context",
                "currentSysexCallbackContext": "sysex_callback_context",
                "currentSystemResetCallbackContext": "system_reset_callback_context",
                "currentAnalogCallback": "analog_callback",
                "currentDigitalCallback": "digital_callback",
                "currentReportAnalogCallback": "report_analog_callback",
                "currentReportDigitalCallback": "report_digital_callback",
                "currentPinModeCallback": "pin_mode_callback",
                "currentPinValueCallback": "pin_value_callback",
                "currentDataBufferOverflowCallback": "data_buffer_overflow_callback",
                "currentStringCallback": "string_callback",
                "currentSysexCallback": "sysex_callback",
                "currentReportFirmwareCallback": "report_firmware_callback",
                "currentReportVersionCallback": "report_version_callback",
                "currentSystemResetCallback": "system_reset_callback",
                "count_leading_zeroes": "count_leading_zeros",
                "allowBufferUpdate": "is_buffer_update_allowed",
                "FUN_080032bc": "initialize_firmata_080032bc"
            },
            "code": "\ninitialize_firmata_080032bc * __selfcall\nfirmata::initialize_firmata_080032bc::initialize_firmata_080032bc(initialize_firmata_080032bc *self,uint8_t *buffer,size_t buffer_size)\n\n{\n  uint uVar1;\n  \n  self->buffer = buffer;\n  self->buffer_size = buffer_size;\n  self->multi_byte_command = '\\0';\n  self->multi_byte_channel = '\\0';\n  self->wait_for_data = 0;\n  self->is_parsing_sysex = false;\n  self->sysex_bytes_read = 0;\n  self->analog_callback_context = (void *)0x0;\n  self->digital_callback_context = (void *)0x0;\n  self->report_analog_callback_context = (void *)0x0;\n  self->report_digital_callback_context = (void *)0x0;\n  self->pin_mode_callback_context = (void *)0x0;\n  self->pin_value_callback_context = (void *)0x0;\n  self->report_firmware_callback_context = (void *)0x0;\n  self->report_version_callback_context = (void *)0x0;\n  self->data_buffer_overflow_callback_context = (void *)0x0;\n  self->string_callback_context = (void *)0x0;\n  self->sysex_callback_context = (void *)0x0;\n  self->system_reset_callback_context = (void *)0x0;\n  self->analog_callback = (callbackFunction)0x0;\n  self->digital_callback = (callbackFunction)0x0;\n  self->report_analog_callback = (callbackFunction)0x0;\n  self->report_digital_callback = (callbackFunction)0x0;\n  self->pin_mode_callback = (callbackFunction)0x0;\n  self->pin_value_callback = (callbackFunction)0x0;\n  self->data_buffer_overflow_callback = (bufferOverflowCallbackFunction)0x0;\n  self->string_callback = (stringCallbackFunction)0x0;\n  self->sysex_callback = (sysexCallbackFunction)0x0;\n  self->report_firmware_callback = (versionCallbackFunction)0x0;\n  self->report_version_callback = (systemCallbackFunction)0x0;\n  self->system_reset_callback = (systemCallbackFunction)0x0;\n  uVar1 = count_leading_zeros(buffer);\n  self->is_buffer_update_allowed = SUB41(uVar1 >> 5,0);\n  return self;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080032bc",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "initialize_firmata_080032bc"
        },
        "FUN_080077b0": {
            "renaming": {
                "FUN_080077b0": "initialize_i2_c_080077b0",
                "obj": "i2cConfig",
                "timing": "timingMode",
                "addressingMode": "addressMode",
                "ownAddress": "ownAddr",
                "master": "isMaster",
                "puVar1": "ptrVar1",
                "pIVar2": "ptrVar2",
                "pIVar3": "mergedPeripheral",
                "pGVar4": "gpioPort",
                "uVar5": "var5",
                "uVar6": "var6",
                "hi2c": "i2cHandle",
                "tmpreg": "tempReg",
                "tmpreg_1": "tempReg1",
                "tmpreg_3": "tempReg3",
                "tmpreg_2": "tempReg2",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "code": "\nvoid initializeI2C_080077b0(i2c_t_conflict *i2cConfig,i2c_timingMode_e_conflict timingMode,uint32_t addressMode,\n                    uint32_t ownAddr,uint8_t isMaster)\n\n{\n  undefined *ptrVar1;\n  I2C_TypeDef_conflict *ptrVar2;\n  void *a;\n  void *b;\n  I2C_TypeDef_conflict *mergedPeripheral;\n  GPIO_TypeDef *gpioPort;\n  uint32_t var5;\n  uint32_t var6;\n  I2C_HandleTypeDef_conflict *i2cHandle;\n  uint32_t tempReg;\n  uint32_t tempReg1;\n  uint32_t tempReg3;\n  uint32_t tempReg2;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  if (i2cConfig != (i2c_t_conflict *)0x0) {\n    i2cHandle = &i2cConfig->handle;\n    a = pinmap_peripheral(i2cConfig->sda,(PinMap_conflict *)PTR_PinMap_I2C_SDA_08007a74);\n    b = pinmap_peripheral(i2cConfig->scl,(PinMap_conflict *)PTR_PinMap_I2C_SCL_08007a78);\n    if ((a == (void *)0x0) || (b == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_I2C_pin_has_n_08007a88);\n    }\n    else {\n      mergedPeripheral = (I2C_TypeDef_conflict *)pinmap_merge_peripheral(a,b);\n      i2cConfig->i2c = mergedPeripheral;\n      ptrVar2 = DAT_08007a7c;\n      if (mergedPeripheral == (I2C_TypeDef_conflict *)0x0) {\n        iprintf(PTR_s_ERROR__I2C_pins_mismatch_08007a8c);\n      }\n      else {\n        if (mergedPeripheral == DAT_08007a7c) {\n          DAT_08007a7c[0xc56].CR2 = DAT_08007a7c[0xc56].CR2 | 0x200000;\n          ptrVar2[0xc55].CCR = ptrVar2[0xc55].CCR | 0x200000;\n          ptrVar2[0xc55].CCR = ptrVar2[0xc55].CCR & 0xffdfffff;\n          i2cConfig->irq = I2C1_EV_IRQn;\n          i2cConfig->irqER = I2C1_ER_IRQn;\n          *(I2C_HandleTypeDef_conflict **)PTR_i2c_handles_08007a90 = i2cHandle;\n        }\n        ptrVar2 = DAT_08007a80;\n        if (i2cConfig->i2c == DAT_08007a80) {\n          DAT_08007a80[0xc39].SR2 = DAT_08007a80[0xc39].SR2 | 0x400000;\n          ptrVar2[0xc39].OAR2 = ptrVar2[0xc39].OAR2 | 0x400000;\n          ptrVar2[0xc39].OAR2 = ptrVar2[0xc39].OAR2 & 0xffbfffff;\n          i2cConfig->irq = I2C2_EV_IRQn;\n          i2cConfig->irqER = I2C2_ER_IRQn;\n          *(I2C_HandleTypeDef_conflict **)(PTR_i2c_handles_08007a90 + 4) = i2cHandle;\n        }\n        gpioPort = set_GPIO_Port_Clock((uint)((int)i2cConfig->scl << 0x18) >> 0x1c);\n        ptrVar1 = PTR_PinMap_I2C_SCL_08007a78;\n        gpioInitStruct.Pin = 1 << ((int)i2cConfig->scl & 0xfU) & 0xffff;\n        var5 = pinmap_function(i2cConfig->scl,(PinMap_conflict *)PTR_PinMap_I2C_SCL_08007a78);\n        var6 = pinmap_function(i2cConfig->scl,(PinMap_conflict *)ptrVar1);\n        gpioInitStruct.Mode = (var5 >> 3 & 1) << 4 | var6 & 7;\n        gpioInitStruct.Speed = 3;\n        var5 = pinmap_function(i2cConfig->scl,(PinMap_conflict *)ptrVar1);\n        gpioInitStruct.Pull = (var5 << 0x1a) >> 0x1e;\n        var5 = pinmap_function(i2cConfig->scl,(PinMap_conflict *)ptrVar1);\n        *(uint *)(DAT_08007a84 + 0x18) = *(uint *)(DAT_08007a84 + 0x18) | 1;\n        switch((var5 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x4000000;\n        }\n        HAL_GPIO_Init(gpioPort,&gpioInitStruct);\n        gpioPort = set_GPIO_Port_Clock((uint)((int)i2cConfig->sda << 0x18) >> 0x1c);\n        ptrVar1 = PTR_PinMap_I2C_SDA_08007a74;\n        gpioInitStruct.Pin = 1 << ((int)i2cConfig->sda & 0xfU) & 0xffff;\n        var5 = pinmap_function(i2cConfig->sda,(PinMap_conflict *)PTR_PinMap_I2C_SDA_08007a74);\n        var6 = pinmap_function(i2cConfig->sda,(PinMap_conflict *)ptrVar1);\n        gpioInitStruct.Mode = (var5 >> 3 & 1) << 4 | var6 & 7;\n        gpioInitStruct.Speed = 3;\n        var5 = pinmap_function(i2cConfig->sda,(PinMap_conflict *)ptrVar1);\n        gpioInitStruct.Pull = (var5 << 0x1a) >> 0x1e;\n        var5 = pinmap_function(i2cConfig->sda,(PinMap_conflict *)ptrVar1);\n        *(uint *)(DAT_08007a84 + 0x18) = *(uint *)(DAT_08007a84 + 0x18) | 1;\n        switch((var5 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x4000000;\n        }\n        HAL_GPIO_Init(gpioPort,&gpioInitStruct);\n        (i2cConfig->handle).Instance = i2cConfig->i2c;\n        (i2cConfig->handle).Init.ClockSpeed = timingMode;\n        (i2cConfig->handle).Init.DutyCycle = 0;\n        (i2cConfig->handle).Init.OwnAddress1 = ownAddr;\n        (i2cConfig->handle).Init.OwnAddress2 = 0xff;\n        (i2cConfig->handle).Init.AddressingMode = addressMode;\n        (i2cConfig->handle).Init.DualAddressMode = 0;\n        (i2cConfig->handle).Init.GeneralCallMode = 0;\n        (i2cConfig->handle).Init.NoStretchMode = 0;\n        (i2cConfig->handle).State = HAL_I2C_STATE_RESET;\n        HAL_NVIC_SetPriority(i2cConfig->irq,0,1);\n        HAL_NVIC_EnableIRQ(i2cConfig->irq);\n        HAL_NVIC_SetPriority(i2cConfig->irqER,0,1);\n        HAL_NVIC_EnableIRQ(i2cConfig->irqER);\n        HAL_I2C_Init(i2cHandle);\n        i2cConfig->isMaster = isMaster;\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "pinmap_function",
                "HAL_GPIO_Init",
                "pinmap_merge_peripheral",
                "pinmap_peripheral",
                "set_GPIO_Port_Clock",
                "HAL_NVIC_SetPriority",
                "HAL_I2C_Init",
                "HAL_NVIC_EnableIRQ",
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080077b0",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initialize_i2_c_080077b0"
        },
        "FUN_08008c44": {
            "renaming": {
                "this": "serialObject",
                "baud": "baudRate",
                "config": "serialConfig",
                "bVar1": "configMask",
                "iVar2": "dataBits",
                "uart_init": "initializeUART",
                "uart_attach_rx_callback": "attachRXCallback",
                "__assert_func": "assertFunction",
                "FUN_08008c44": "initialize_serial_08008c44"
            },
            "code": "\nvoid __serialObjectcall HardwareSerial::initializeSerial_08008c44(HardwareSerial *serialObject,ulong baudRate,byte serialConfig)\n\n{\n  byte configMask;\n  int dataBits;\n  \n  (serialObject->_serial).baudRaterate = baudRate;\n  serialObject->_serialConfig = serialConfig;\n  configMask = serialConfig & 7;\n  if (configMask == 4) {\n    dataBits = 7;\n  }\n  else if (configMask == 6) {\n    dataBits = 8;\n  }\n  else if (configMask == 2) {\n    dataBits = 6;\n  }\n  else {\n    dataBits = 0;\n  }\n  if ((serialConfig & 0x30) == 0x30) {\n    (serialObject->_serial).parity = 0x600;\n    dataBits = dataBits + 1;\n  }\n  else if ((serialConfig & 0x20) == 0) {\n    (serialObject->_serial).parity = 0;\n  }\n  else {\n    (serialObject->_serial).parity = 0x400;\n    dataBits = dataBits + 1;\n  }\n  if ((serialConfig & 8) == 0) {\n    (serialObject->_serial).stopbits = 0;\n  }\n  else {\n    (serialObject->_serial).stopbits = 0x2000;\n  }\n  if (dataBits == 8) {\n    (serialObject->_serial).databits = 0;\n  }\n  else if (dataBits == 9) {\n    (serialObject->_serial).databits = 0x1000;\n  }\n  else {\n    dataBits = 0;\n  }\n  if (dataBits != 0) {\n    initializeUART((serial_t *)&serialObject->_serial);\n    attachRXCallback((serial_t *)&serialObject->_serial,DAT_08008cf0);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  assertFunction(PTR_s__home_bo__arduino15_packages_STM_08008cfc,299,PTR___PRETTY_FUNCTION___08008cf8\n                ,PTR_s_databits__0_08008cf4);\n}\n\n",
            "called": [
                "uart_attach_rx_callback",
                "__assert_func",
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008c44",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initialize_serial_08008c44"
        },
        "FUN_08006060": {
            "renaming": {
                "FUN_08006060": "initialize_timer_08006060",
                "htim": "timer_handle",
                "State": "timer_state",
                "HAL_TIM_STATE_RESET": "timer_reset_state",
                "HAL_UNLOCKED": "timer_unlocked",
                "HAL_TIM_OC_MspInit": "timer_OC_MspInit",
                "HAL_TIM_STATE_BUSY": "timer_busy_state",
                "TIM_Base_SetConfig": "timer_set_config",
                "HAL_TIM_STATE_READY": "timer_ready_state",
                "HAL_OK": "timer_ok",
                "HAL_ERROR": "timer_error"
            },
            "code": "\nHAL_StatusTypeDef_conflict initialize_timer_08006060(TIM_HandleTypeDef_conflict *timer_handle)\n\n{\n  if (timer_handle != (TIM_HandleTypeDef_conflict *)0x0) {\n    if (timer_handle->timer_state == timer_reset_state) {\n      timer_handle->Lock = timer_unlocked;\n      timer_OC_MspInit(timer_handle);\n    }\n    timer_handle->timer_state = timer_busy_state;\n    timer_set_config(timer_handle->Instance,&timer_handle->Init);\n    timer_handle->timer_state = timer_ready_state;\n    return timer_ok;\n  }\n  return timer_error;\n}\n\n",
            "called": [
                "TIM_Base_SetConfig",
                "HAL_TIM_OC_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006060",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "initialize_timer_08006060"
        },
        "FUN_08009698": {
            "renaming": {
                "FUN_08009698": "print_formatted_output_08009698",
                "param_1": "stream",
                "param_2": "format",
                "param_3": "width",
                "param_4": "print_func",
                "param_5": "args",
                "bVar1": "byte_val",
                "iVar2": "ret_val",
                "puVar3": "arg_ptr",
                "pvVar4": "null_ptr",
                "iVar5": "loop_var",
                "puVar6": "hex_arr",
                "uVar7": "flag_val",
                "uVar9": "int_val",
                "uVar10": "div_val",
                "puVar11": "str_ptr",
                "__s": "format_str",
                "local_24": "int_arr"
            },
            "code": "\nuint print_formatted_output_08009698(undefined4 stream,uint *format,undefined4 width,code *print_func,uint **args)\n\n{\n  byte byte_val;\n  int ret_val;\n  uint *arg_ptr;\n  void *null_ptr;\n  int loop_var;\n  undefined *hex_arr;\n  uint flag_val;\n  uint **ppuVar8;\n  uint int_val;\n  uint div_val;\n  undefined *str_ptr;\n  undefined *format_str;\n  uint int_arr [2];\n  \n  byte_val = *(byte *)(format + 6);\n  format_str = (undefined *)((int)format + 0x43);\n  if (byte_val != 0x6e) {\n    if (byte_val < 0x6f) {\n      if (byte_val != 99) {\n        if (byte_val < 100) {\n          if (byte_val == 0) goto LAB_08009852;\n          if (byte_val != 0x58) goto LAB_080096c8;\n          *(undefined *)((int)format + 0x45) = 0x58;\n          hex_arr = PTR_s_0123456789ABCDEF_080098d4;\nLAB_080097e2:\n          flag_val = *format;\n          arg_ptr = *args;\n          *args = arg_ptr + 1;\n          if (((flag_val & 0x80) == 0) && ((int)(flag_val << 0x19) < 0)) {\n            int_val = (uint)*(ushort *)arg_ptr;\n          }\n          else {\n            int_val = *arg_ptr;\n          }\n          if ((int)(flag_val << 0x1f) < 0) {\n            *format = flag_val | 0x20;\n          }\n          if (int_val == 0) {\n            *format = *format & 0xffffffdf;\n          }\n          flag_val = 0x10;\nLAB_08009778:\n          *(undefined *)((int)format + 0x43) = 0;\n        }\n        else {\n          if ((byte_val != 100) && (byte_val != 0x69)) goto LAB_080096c8;\n          int_val = *format;\n          arg_ptr = *args;\n          if ((int_val & 0x80) == 0) {\n            *args = arg_ptr + 1;\n            if ((int_val & 0x40) == 0) goto LAB_080096e8;\n            int_val = (uint)(short)*(ushort *)arg_ptr;\n          }\n          else {\n            *args = arg_ptr + 1;\nLAB_080096e8:\n            int_val = *arg_ptr;\n          }\n          if ((int)int_val < 0) {\n            int_val = -int_val;\n            *(undefined *)((int)format + 0x43) = 0x2d;\n          }\n          flag_val = 10;\n          hex_arr = PTR_s_0123456789ABCDEF_080098d4;\n        }\n        div_val = format[1];\n        format[2] = div_val;\n        str_ptr = format_str;\n        if ((int)div_val < 0) {\n          if (int_val != 0) goto LAB_08009816;\nLAB_080098c4:\n          *(undefined *)((int)format + 0x42) = *hex_arr;\n          str_ptr = (undefined *)((int)format + 0x42);\n        }\n        else {\n          *format = *format & 0xfffffffb;\n          if (int_val == 0) {\n            if (div_val != 0) goto LAB_080098c4;\n          }\n          else {\nLAB_08009816:\n            do {\n              div_val = int_val / flag_val;\n              str_ptr = str_ptr + -1;\n              *str_ptr = hex_arr[int_val - flag_val * div_val];\n              int_val = div_val;\n            } while (div_val != 0);\n          }\n        }\n        if (((flag_val == 8) && ((int)(*format << 0x1f) < 0)) && ((int)format[1] <= (int)format[4]))\n        {\n          str_ptr[-1] = 0x30;\n          str_ptr = str_ptr + -1;\n        }\n        format[4] = (int)format_str - (int)str_ptr;\n        format_str = str_ptr;\n        goto LAB_080097be;\n      }\n      arg_ptr = *args;\n      *args = arg_ptr + 1;\n      *(char *)((int)format + 0x42) = (char)*arg_ptr;\nLAB_08009728:\n      format_str = (undefined *)((int)format + 0x42);\n      int_val = 1;\n    }\n    else {\n      if (byte_val != 0x73) {\n        if (byte_val < 0x74) {\n          if (byte_val == 0x6f) {\nLAB_0800974e:\n            int_val = *format;\n            arg_ptr = *args;\n            if ((int_val & 0x80) == 0) {\n              *args = arg_ptr + 1;\n              if ((int_val & 0x40) == 0) goto LAB_0800975c;\n              int_val = (uint)*(ushort *)arg_ptr;\n            }\n            else {\n              *args = arg_ptr + 1;\nLAB_0800975c:\n              int_val = *arg_ptr;\n            }\n            hex_arr = PTR_s_0123456789ABCDEF_080098d4;\n            if (byte_val == 0x6f) {\n              flag_val = 8;\n            }\n            else {\n              flag_val = 10;\n            }\n            goto LAB_08009778;\n          }\n          if (byte_val == 0x70) {\n            *format = *format | 0x20;\nLAB_0800970e:\n            hex_arr = PTR_s_0123456789abcdef_080098d0;\n            *(undefined *)((int)format + 0x45) = 0x78;\n            goto LAB_080097e2;\n          }\n        }\n        else {\n          if (byte_val == 0x75) goto LAB_0800974e;\n          if (byte_val == 0x78) goto LAB_0800970e;\n        }\nLAB_080096c8:\n        *(byte *)((int)format + 0x42) = byte_val;\n        goto LAB_08009728;\n      }\n      arg_ptr = *args;\n      *args = arg_ptr + 1;\n      format_str = (undefined *)*arg_ptr;\n      null_ptr = memchr(format_str,0,format[1]);\n      if (null_ptr != (void *)0x0) {\n        format[1] = (int)null_ptr - (int)format_str;\n      }\n      int_val = format[1];\n    }\n    format[4] = int_val;\n    *(undefined *)((int)format + 0x43) = 0;\n    goto LAB_080097be;\n  }\n  int_val = *format;\n  ppuVar8 = (uint **)*args;\n  flag_val = format[5];\n  if ((int_val & 0x80) == 0) {\n    *args = (uint *)(ppuVar8 + 1);\n    arg_ptr = *ppuVar8;\n    if ((int_val & 0x40) == 0) goto LAB_0800983e;\n    *(short *)arg_ptr = (short)flag_val;\n  }\n  else {\n    *args = (uint *)(ppuVar8 + 1);\n    arg_ptr = *ppuVar8;\nLAB_0800983e:\n    *arg_ptr = flag_val;\n  }\nLAB_08009852:\n  format[4] = 0;\nLAB_080097be:\n  ret_val = _printf_common(stream,format,int_arr,width,print_func);\n  if ((ret_val == -1) || (ret_val = (*print_func)(stream,width,format_str,format[4]), ret_val == -1)) {\nLAB_080097d2:\n    int_val = 0xffffffff;\n  }\n  else {\n    if ((int)(*format << 0x1e) < 0) {\n      for (ret_val = 0; ret_val < (int)(format[3] - int_arr[0]); ret_val = ret_val + 1) {\n        loop_var = (*print_func)(stream,width,(int)format + 0x19,1);\n        if (loop_var == -1) goto LAB_080097d2;\n      }\n    }\n    int_val = format[3];\n    if ((int)format[3] < (int)int_arr[0]) {\n      int_val = int_arr[0];\n    }\n  }\n  return int_val;\n}\n\n",
            "called": [
                "_printf_common",
                "memchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009698",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "print_formatted_output_08009698"
        },
        "FUN_08006186": {
            "renaming": {
                "FUN_08006186": "configure_tim_output_compare_08006186",
                "htim": "TIM_handle",
                "sConfig": "TIM_OC_config",
                "Channel": "channel_num",
                "HAL_StatusTypeDef_conflict": "TIM_config_status",
                "HAL_LOCKED": "TIM_LOCKED",
                "HAL_TIM_STATE_BUSY": "TIM_STATE_BUSY",
                "HAL_TIM_STATE_READY": "TIM_STATE_READY",
                "HAL_UNLOCKED": "TIM_UNLOCKED",
                "TIM_OC1_SetConfig": "configure_TIM_OC1",
                "TIM_OC2_SetConfig": "configure_TIM_OC2",
                "TIM_OC3_SetConfig": "configure_TIM_OC3",
                "TIM_OC4_SetConfig": "configure_TIM_OC4"
            },
            "code": "\nTIM_config_status\nconfigure_TIM_output_compare_08006186(TIM_HandleTypeDef_conflict *TIM_handle,TIM_OC_InitTypeDef *TIM_OC_config,uint32_t channel_num)\n\n{\n  if (TIM_handle->Lock != TIM_LOCKED) {\n    TIM_handle->Lock = TIM_LOCKED;\n    TIM_handle->State = TIM_STATE_BUSY;\n    switch(channel_num) {\n    case 0:\n      configure_TIM_OC1(TIM_handle->Instance,TIM_OC_config);\n      TIM_handle->Instance->CCMR1 = TIM_handle->Instance->CCMR1 | 8;\n      TIM_handle->Instance->CCMR1 = TIM_handle->Instance->CCMR1 & 0xfffffffb;\n      TIM_handle->Instance->CCMR1 = TIM_handle->Instance->CCMR1 | TIM_OC_config->OCFastMode;\n      break;\n    case 4:\n      configure_TIM_OC2(TIM_handle->Instance,TIM_OC_config);\n      TIM_handle->Instance->CCMR1 = TIM_handle->Instance->CCMR1 | 0x800;\n      TIM_handle->Instance->CCMR1 = TIM_handle->Instance->CCMR1 & 0xfffffbff;\n      TIM_handle->Instance->CCMR1 = TIM_handle->Instance->CCMR1 | TIM_OC_config->OCFastMode << 8;\n      break;\n    case 8:\n      configure_TIM_OC3(TIM_handle->Instance,TIM_OC_config);\n      TIM_handle->Instance->CCMR2 = TIM_handle->Instance->CCMR2 | 8;\n      TIM_handle->Instance->CCMR2 = TIM_handle->Instance->CCMR2 & 0xfffffffb;\n      TIM_handle->Instance->CCMR2 = TIM_handle->Instance->CCMR2 | TIM_OC_config->OCFastMode;\n      break;\n    case 0xc:\n      configure_TIM_OC4(TIM_handle->Instance,TIM_OC_config);\n      TIM_handle->Instance->CCMR2 = TIM_handle->Instance->CCMR2 | 0x800;\n      TIM_handle->Instance->CCMR2 = TIM_handle->Instance->CCMR2 & 0xfffffbff;\n      TIM_handle->Instance->CCMR2 = TIM_handle->Instance->CCMR2 | TIM_OC_config->OCFastMode << 8;\n    }\n    TIM_handle->State = TIM_STATE_READY;\n    TIM_handle->Lock = TIM_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006186",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configure_tim_output_compare_08006186"
        },
        "FUN_08006b7c": {
            "renaming": {
                "FUN_08006b7c": "get_gpio_by_port_idx_08006b7c",
                "port_idx": "port_index"
            },
            "code": "\nGPIO_TypeDef * get_GPIO_by_port_idx_08006b7c(uint32_t port_index)\n\n{\n  switch(port_index) {\n  case 0:\n    return DAT_08006ba4;\n  case 1:\n    return DAT_08006bb4;\n  case 2:\n    return DAT_08006ba8;\n  case 3:\n    return DAT_08006bac;\n  case 4:\n    return DAT_08006bb0;\n  default:\n    return (GPIO_TypeDef *)0x0;\n  }\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b7c",
            "calling": [
                "digitalRead",
                "digitalWrite"
            ],
            "imported": false,
            "current_name": "get_gpio_by_port_idx_08006b7c"
        },
        "FUN_08008e7c": {
            "renaming": {
                "FUN_08008e7c": "print_number_in_base_08008e7c",
                "this": "print_obj",
                "n": "number",
                "base": "num_base",
                "cVar1": "char_val",
                "sVar2": "str_len",
                "sVar3": "ret_val",
                "uVar4": "mod_val",
                "uVar5": "base_val",
                "uVar6": "div_val",
                "__s": "str_ptr",
                "buf": "buffer"
            },
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x08008ecc */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n\nsize_t __print_objcall Prinumbert::print_number_in_base_08008e7c(Prinumbert *print_obj,ulonumberg number,uinumbert8_t num_base)\n\n{\n  char char_val;\n  size_t str_len;\n  size_t ret_val;\n  uinumbert mod_val;\n  uinumbert base_val;\n  uinumbert div_val;\n  char *str_ptr;\n  char buffer [33];\n  \n  base_val = (uinumbert)num_base;\n  buffer[32] = '\\0';\n  if (base_val < 2) {\n    base_val = 10;\n  }\n  str_ptr = buffer + 0x20;\n  do {\n    div_val = number / base_val;\n    mod_val = (number & 0xff) - (div_val * base_val & 0xff) & 0xff;\n    str_ptr = str_ptr + -1;\n    char_val = (char)mod_val;\n    if (mod_val < 10) {\n      char_val = char_val + '0';\n    }\n    else {\n      char_val = char_val + '7';\n    }\n    *str_ptr = char_val;\n    number = div_val;\n  } while (div_val != 0);\n  if (str_ptr == (char *)0x0) {\n    ret_val = 0;\n  }\n  else {\n    str_len = strlenumber(str_ptr);\n    ret_val = (*print_obj->_vptr_Prinumbert[1])(str_len,str_ptr,str_len);\n  }\n  returnumber ret_val;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e7c",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "print_number_in_base_08008e7c"
        },
        "FUN_0800a194": {
            "renaming": {
                "ctype_byname": "update_ids",
                "FUN_0800a194": "update_ids_0800a194"
            },
            "code": "\n/* std::update_ids_0800a194<char>::update_ids_0800a194(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::update_ids_0800a194<char>::update_ids_0800a194(void)\n\n{\n  if (-1 < *(int *)PTR_id_0800a228 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a228 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a22c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a22c = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a230 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a230 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a234 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a234 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a238 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a238 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a23c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a23c = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a240 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a240 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a244 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a244 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a248 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a248 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a24c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a24c = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a250 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a250 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a254 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a254 = 1;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a194",
            "calling": [],
            "imported": false,
            "current_name": "update_ids_0800a194"
        },
        "FUN_08003aa0": {
            "renaming": {
                "FUN_08003aa0": "configure_adc_08003aa0",
                "hadc": "ADC_handle",
                "HVar1": "status",
                "pAVar2": "ADC_instance",
                "Lock": "is_locked",
                "State": "ADC_state",
                "ErrorCode": "ADC_error_code",
                "JOFR1": "ADC_JOFR1"
            },
            "code": "\nHAL_StatusTypeDef_conflict configure_ADC_08003aa0(ADC_HandleTypeDef *ADC_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  ADC_TypeDef *ADC_instance;\n  \n  if (ADC_handle->is_locked != HAL_LOCKED) {\n    ADC_handle->is_locked = HAL_LOCKED;\n    status = ADC_Enable(ADC_handle);\n    if (status == HAL_OK) {\n      ADC_handle->ADC_state = ADC_handle->ADC_state & 0xfffffcfe | 0x100;\n      ADC_instance = ADC_handle->Instance;\n      if ((ADC_instance == DAT_08003b84) && ((DAT_08003b84[-0xd].ADC_JOFR1 & 0xf0000) != 0)) {\n        ADC_handle->ADC_state = ADC_handle->ADC_state | 0x100000;\n        if ((*(uint *)(DAT_08003b88 + 4) & 0x400) != 0) {\n          ADC_handle->ADC_state = ADC_handle->ADC_state & 0xffffcfff | 0x1000;\n        }\n      }\n      else {\n        ADC_handle->ADC_state = ADC_handle->ADC_state & 0xffefffff;\n        if ((ADC_instance->CR1 & 0x400) != 0) {\n          ADC_handle->ADC_state = ADC_handle->ADC_state & 0xffffcfff | 0x1000;\n        }\n      }\n      if ((ADC_handle->ADC_state & 0x1000) == 0) {\n        ADC_handle->ADC_error_code = 0;\n      }\n      else {\n        ADC_handle->ADC_error_code = ADC_handle->ADC_error_code & 0xfffffff9;\n      }\n      ADC_handle->is_locked = HAL_UNLOCKED;\n      ADC_instance->SR = 0xfffffffd;\n      ADC_instance = ADC_handle->Instance;\n      if (((ADC_instance->CR2 & 0xe0000) == 0xe0000) &&\n         ((ADC_instance != DAT_08003b84 || ((DAT_08003b84[-0xd].ADC_JOFR1 & 0xf0000) == 0)))) {\n        ADC_instance->CR2 = ADC_instance->CR2 | 0x500000;\n      }\n      else {\n        ADC_instance->CR2 = ADC_instance->CR2 | 0x100000;\n      }\n    }\n    else {\n      ADC_handle->is_locked = HAL_UNLOCKED;\n    }\n    return status;\n  }\n  return HAL_BUSY;\n}\n\n",
            "called": [
                "ADC_Enable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003aa0",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "configure_adc_08003aa0"
        },
        "FUN_08005fe8": {
            "renaming": {
                "FUN_08005fe8": "configure_tim_08005fe8",
                "TIMx": "tim_handle",
                "Structure": "tim_config",
                "uVar1": "cr1_reg",
                "CounterMode": "counter_mode",
                "ClockDivision": "clock_division",
                "AutoReloadPreload": "auto_reload_preload",
                "Period": "period",
                "Prescaler": "prescaler",
                "RepetitionCounter": "repetition_counter"
            },
            "code": "\nvoid configure_TIM_08005fe8(TIM_TypeDef_conflict *tim_handle,TIM_Base_InitTypeDef_conflict *tim_config)\n\n{\n  uint cr1_reg;\n  \n  cr1_reg = tim_handle->CR1;\n  if ((((tim_handle == DAT_0800605c) || (tim_handle == (TIM_TypeDef_conflict *)0x40000000)) ||\n      (tim_handle == (TIM_TypeDef_conflict *)&DAT_0800605c[-0x387].DMAR)) ||\n     (tim_handle == (TIM_TypeDef_conflict *)&DAT_0800605c[-0x37a].SMCR)) {\n    cr1_reg = cr1_reg & 0xffffff8f | tim_config->counter_mode;\n  }\n  if (((tim_handle == DAT_0800605c) || (tim_handle == (TIM_TypeDef_conflict *)0x40000000)) ||\n     ((tim_handle == (TIM_TypeDef_conflict *)&DAT_0800605c[-0x387].DMAR ||\n      (tim_handle == (TIM_TypeDef_conflict *)&DAT_0800605c[-0x37a].SMCR)))) {\n    cr1_reg = cr1_reg & 0xfffffcff | tim_config->clock_division;\n  }\n  tim_handle->CR1 = cr1_reg & 0xffffff7f | tim_config->auto_reload_preload;\n  tim_handle->ARR = tim_config->period;\n  tim_handle->PSC = tim_config->prescaler;\n  if (tim_handle == DAT_0800605c) {\n    tim_handle->RCR = tim_config->repetition_counter;\n  }\n  tim_handle->EGR = 1;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005fe8",
            "calling": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_OC_Init"
            ],
            "imported": false,
            "current_name": "configure_tim_08005fe8"
        },
        "FUN_08003ce8": {
            "renaming": {
                "FUN_08003ce8": "stop_adc_conversion_08003ce8",
                "hadc": "adc_handle",
                "HVar1": "status",
                "HAL_ERROR": "error",
                "ADC_ConversionStop_Disable": "disable_adc_conversion_stop",
                "Instance": "instance",
                "SR": "status_register",
                "CR1": "control_register_1",
                "CR2": "control_register_2",
                "SMPR1": "sample_time_register_1",
                "SMPR2": "sample_time_register_2",
                "JOFR1": "offset_register_1",
                "JOFR2": "offset_register_2",
                "JOFR3": "offset_register_3",
                "JOFR4": "offset_register_4",
                "HTR": "high_threshold_register",
                "LTR": "low_threshold_register",
                "SQR1": "sequence_register_1",
                "SQR2": "sequence_register_2",
                "SQR3": "sequence_register_3",
                "JSQR": "injected_sequence_register",
                "HAL_ADC_MspDeInit": "deinitialize_adc_gpio_pins",
                "ErrorCode": "error_code",
                "State": "state",
                "Lock": "lock"
            },
            "code": "\nHAL_StatusTypeDef_conflict stop_adc_conversion_08003ce8(ADC_HandleTypeDef *adc_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  \n  if (adc_handle == (ADC_HandleTypeDef *)0x0) {\n    status = error;\n  }\n  else {\n    adc_handle->state = adc_handle->state | 2;\n    status = disable_adc_conversion_stop(adc_handle);\n    if (status == HAL_OK) {\n      adc_handle->instance->status_register = 0xffffffe0;\n      adc_handle->instance->control_register_1 = DAT_08003ddc & adc_handle->instance->control_register_1;\n      adc_handle->instance->control_register_2 = DAT_08003de0 & adc_handle->instance->control_register_2;\n      adc_handle->instance->sample_time_register_1 = adc_handle->instance->sample_time_register_1 & 0xff000000;\n      adc_handle->instance->sample_time_register_2 = adc_handle->instance->sample_time_register_2 & 0xc0000000;\n      adc_handle->instance->offset_register_1 = adc_handle->instance->offset_register_1 & 0xfffff000;\n      adc_handle->instance->offset_register_2 = adc_handle->instance->offset_register_2 & 0xfffff000;\n      adc_handle->instance->offset_register_3 = adc_handle->instance->offset_register_3 & 0xfffff000;\n      adc_handle->instance->FHYUAXZstatus_registerG = adc_handle->instance->FHYUAXZstatus_registerG & 0xfffff000;\n      adc_handle->instance->high_threshold_register = adc_handle->instance->high_threshold_register & 0xfffff000;\n      adc_handle->instance->low_threshold_register = adc_handle->instance->low_threshold_register & 0xfffff000;\n      adc_handle->instance->sequence_register_1 = adc_handle->instance->sequence_register_1 & 0xff000000;\n      adc_handle->instance->sequence_register_1 = adc_handle->instance->sequence_register_1 & 0xff000000;\n      adc_handle->instance->sequence_register_2 = adc_handle->instance->sequence_register_2 & 0xc0000000;\n      adc_handle->instance->sequence_register_3 = adc_handle->instance->sequence_register_3 & 0xc0000000;\n      adc_handle->instance->injected_sequence_register = adc_handle->instance->injected_sequence_register & 0xffc00000;\n      adc_handle->instance->injected_sequence_register = adc_handle->instance->injected_sequence_register & 0xffc00000;\n      deinitialize_adc_gpio_pins(adc_handle);\n      adc_handle->error_code = 0;\n      adc_handle->state = 0;\n    }\n    adc_handle->lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ce8",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "stop_adc_conversion_08003ce8"
        },
        "FUN_0800738a": {
            "renaming": {
                "FUN_0800738a": "pin_map_valid_0800738a",
                "pin": "pin_name",
                "map": "pin_map",
                "NC": "no_connection"
            },
            "code": "\n_Bool pin_map_valid_0800738a(PinName_conflict pin_name,PinMap_conflict *pin_map)\n\n{\n  if (pin_name == no_connection) {\n    return false;\n  }\n  while( true ) {\n    if (pin_map->pin_name == no_connection) {\n      return false;\n    }\n    if (pin_name == pin_map->pin_name) break;\n    pin_map = pin_map + 1;\n  }\n  return true;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800738a",
            "calling": [
                "enableI2CPins",
                "analogWrite",
                "pinMode",
                "sysexCallback",
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "pin_map_valid_0800738a"
        },
        "FUN_08002948": {
            "renaming": {
                "FUN_08002948": "initialize_wire_08002948",
                "__initialize_p": "is_initialized",
                "__priority": "wire_priority",
                "TwoWire": "Wire"
            },
            "code": "\nvoid initialize_wire_08002948(int is_initialized,int wire_priority)\n\n{\n  if (is_initialized != 1) {\n    return;\n  }\n  if (wire_priority == 0xffff) {\n    Wire::Wire((Wire *)PTR_Wire_08002964);\n  }\n  return;\n}\n\n",
            "called": [
                "TwoWire"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002948",
            "calling": [
                "_GLOBAL__sub_I__ZN7TwoWire8rxBufferE"
            ],
            "imported": false,
            "current_name": "initialize_wire_08002948"
        },
        "FUN_08009e64": {
            "renaming": {
                "FUN_08009e64": "check_file_permissions_08009e64",
                "param_1": "file_descriptor",
                "param_2": "file_info",
                "param_3": "permission_flags",
                "param_4": "is_executable",
                "iVar1": "status",
                "uVar2": "permission",
                "auStack_4c": "stat_buffer",
                "local_48": "file_mode"
            },
            "code": "\nundefined4 check_file_permissions_08009e64(undefined4 file_descriptor,int file_info,undefined4 *permission_flags,uint *is_executable)\n\n{\n  int status;\n  undefined4 permission;\n  undefined stat_buffer [4];\n  uint file_mode;\n  \n  if ((*(short *)(file_info + 0xe) < 0) ||\n     (status = _fstat_r(file_descriptor,(int)*(short *)(file_info + 0xe),stat_buffer), status < 0)) {\n    *is_executable = 0;\n    if ((int)((uint)*(ushort *)(file_info + 0xc) << 0x18) < 0) {\n      permission = 0x40;\n      goto LAB_08009ea4;\n    }\n  }\n  else {\n    *is_executable = (uint)((file_mode & 0xf000) == 0x2000);\n  }\n  permission = 0x400;\nLAB_08009ea4:\n  *permission_flags = permission;\n  return 0;\n}\n\n",
            "called": [
                "_fstat_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009e64",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_file_permissions_08009e64"
        },
        "FUN_08002acc": {
            "renaming": {
                "length": "new_length",
                "puVar1": "rx_buffer_ptr",
                "pvVar2": "new_rx_buffer_ptr",
                "uVar3": "new_rx_buffer_size",
                "FUN_08002acc": "resize_rx_buffer_08002acc"
            },
            "code": "\nvoid TwoWire::resize_rx_buffer_08002acc(size_t new_length)\n\n{\n  undefined *rx_buffer_ptr;\n  void *new_rx_buffer_ptr;\n  undefined new_rx_buffer_size;\n  \n  rx_buffer_ptr = PTR_rxBuffer_08002afc;\n  if ((byte)*PTR_rxBufferAllocated_08002af8 < new_length) {\n    if (new_length < 0x20) {\n      new_length = 0x20;\n    }\n    new_rx_buffer_ptr = realloc(*(void **)PTR_rxBuffer_08002afc,new_length);\n    *(void **)rx_buffer_ptr = new_rx_buffer_ptr;\n    if (new_rx_buffer_ptr == (void *)0x0) {\n      new_rx_buffer_size = 0;\n    }\n    else {\n      new_rx_buffer_size = (undefined)new_length;\n    }\n    *PTR_rxBufferAllocated_08002af8 = new_rx_buffer_size;\n  }\n  return;\n}\n\n",
            "called": [
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002acc",
            "calling": [
                "requestFrom",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "resize_rx_buffer_08002acc"
        },
        "FUN_0800932c": {
            "renaming": {
                "FUN_0800932c": "write_to_output_0800932c",
                "param_1": "file_descriptor",
                "param_2": "character",
                "param_3": "output_buffer",
                "pbVar2": "last_char_ptr",
                "uVar1": "write_result"
            },
            "code": "\nuint write_to_output_0800932c(undefined4 file_descriptor,byte character,byte **output_buffer)\n\n{\n  uint write_result;\n  byte *last_char_ptr;\n  \n  last_char_ptr = output_buffer[2] + -1;\n  output_buffer[2] = last_char_ptr;\n  if (((int)last_char_ptr < 0) && (((int)last_char_ptr < (int)output_buffer[6] || (character == 10)))) {\n    write_result = __swbuf_r();\n    return write_result;\n  }\n  last_char_ptr = *output_buffer;\n  *output_buffer = last_char_ptr + 1;\n  *last_char_ptr = character;\n  return (uint)character;\n}\n\n",
            "called": [
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800932c",
            "calling": [
                "__sfputs_r"
            ],
            "imported": false,
            "current_name": "write_to_output_0800932c"
        },
        "FUN_080099a4": {
            "renaming": {
                "FUN_080099a4": "find_substring_080099a4",
                "__haystack": "haystack",
                "__needle": "needle",
                "pcVar1": "current_haystack",
                "pcVar2": "current_needle",
                "pcVar3": "temp_needle"
            },
            "code": "\nchar * find_substring_080099a4(char *haystack,char *needle)\n\n{\n  char *current_haystack;\n  char *current_needle;\n  char *temp_needle;\n  \n  if (*haystack == '\\0') {\n    if (*needle != '\\0') {\n      haystack = (char *)0x0;\n    }\n    return haystack;\n  }\n  do {\n    current_haystack = haystack;\n    if (*current_haystack == '\\0') {\n      return (char *)0x0;\n    }\n    temp_needle = needle + -1;\n    current_needle = current_haystack + -1;\n    do {\n      temp_needle = temp_needle + 1;\n      if (*temp_needle == '\\0') {\n        return current_haystack;\n      }\n      current_needle = current_needle + 1;\n      haystack = current_haystack + 1;\n    } while (*current_needle == *temp_needle);\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080099a4",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "find_substring_080099a4"
        },
        "FUN_08005a1c": {
            "renaming": {
                "FUN_08005a1c": "get_system_core_clock_08005a1c"
            },
            "code": "\nuint32_t get_SystemCoreClock_08005a1c(void)\n\n{\n  return *(uint32_t *)PTR_SystemCoreClock_08005a24;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a1c",
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "SystemClock_Config",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "imported": false,
            "current_name": "get_system_core_clock_08005a1c"
        },
        "FUN_08006b0c": {
            "renaming": {
                "FUN_08006b0c": "reset_uart_transfer_counts_08006b0c",
                "hdma": "dma_handle",
                "huart": "uart_handle",
                "RxXferCount": "rx_transfer_count",
                "TxXferCount": "tx_transfer_count"
            },
            "code": "\nvoid reset_uart_transfer_counts_08006b0c(DMA_HandleTypeDef_conflict *dma_handle)\n\n{\n  UART_HandleTypeDef *uart_handle;\n  \n  uart_handle = (UART_HandleTypeDef *)dma_handle->Parent;\n  uart_handle->rx_transfer_count = 0;\n  uart_handle->tx_transfer_count = 0;\n  HAL_UART_ErrorCallback(uart_handle);\n  return;\n}\n\n",
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b0c",
            "calling": [],
            "imported": false,
            "current_name": "reset_uart_transfer_counts_08006b0c"
        },
        "FUN_08001cd0": {
            "renaming": {
                "FUN_08001cd0": "process_command_08001cd0",
                "command": "cmd",
                "argc": "argCount",
                "argv": "argValues",
                "bVar1": "byteVar1",
                "address": "pinAddress",
                "bVar2": "byteVar2",
                "bVar3": "byteVar3",
                "bVar4": "byteVar4",
                "bVar5": "byteVar5",
                "cVar6": "charVar6",
                "puVar7": "ptrVar7",
                "this": "firmataObject",
                "PVar8": "pinName",
                "_Var9": "boolVar9",
                "bVar10": "byteVar10",
                "uVar11": "uintVar11",
                "uVar12": "uintVar12",
                "iVar13": "intVar13",
                "iVar14": "intVar14",
                "cVar15": "charVar15",
                "uVar16": "uintVar16",
                "iVar17": "intVar17",
                "bVar18": "boolVar18"
            },
            "code": "\nvoid processCommand_08001cd0(byte cmd,byte argCount,byte *argValues)\n\n{\n  byte byteVar1;\n  uint8_t pinAddress;\n  byte byteVar2;\n  byte byteVar3;\n  byte byteVar4;\n  byte byteVar5;\n  char charVar6;\n  undefined *ptrVar7;\n  undefined *firmataObject;\n  PinName_conflict pinName;\n  _Bool boolVar9;\n  byte byteVar10;\n  uint32_t uintVar11;\n  uint uintVar12;\n  int intVar13;\n  int intVar14;\n  char charVar15;\n  uint uintVar16;\n  int intVar17;\n  bool boolVar18;\n  \n  firmataObject = PTR_Firmata_080022e8;\n  ptrVar7 = PTR_Firmata_08002044;\n  uintVar16 = (uint)argCount;\n  switch(cmd) {\n  case 'i':\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf0);\n    firmata::FirmataClass::write((FirmataClass *)firmataObject,'j');\n    for (uintVar16 = 0; uintVar16 < 0x3c; uintVar16 = uintVar16 + 1 & 0xff) {\n      uintVar12 = uintVar16 - 0x2e & 0xff;\n      byteVar10 = (byte)uintVar12;\n      if (uintVar12 < 0xe) {\n        if (uintVar16 < 0x3c) {\n          pinName = PTR_digitalPin_080022e4[uintVar16];\n        }\n        else {\n          pinName = NC;\n        }\n        uintVar11 = pinNametoDigitalPin(pinName);\n        if (uintVar11 == 0) {\n          byteVar10 = '\\x7f';\n        }\n        else {\n          if (uintVar16 < 0x3c) {\n            pinName = PTR_digitalPin_080022e4[uintVar16];\n          }\n          else {\n            pinName = NC;\n          }\n          uintVar11 = pinNametoDigitalPin(pinName);\n          if (uintVar11 == 1) {\n            byteVar10 = '\\x7f';\n          }\n        }\n      }\n      else {\n        byteVar10 = '\\x7f';\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,byteVar10);\n    }\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n    break;\n  case 'k':\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_08002044,0xf0);\n    firmata::FirmataClass::write((FirmataClass *)ptrVar7,'l');\n    for (uintVar16 = 0; uintVar16 < 0x3c; uintVar16 = uintVar16 + 1 & 0xff) {\n      if (uintVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uintVar16] == NC) {\n          boolVar18 = false;\n        }\n        else {\n          uintVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uintVar16]);\n          if (uintVar11 == 0) {\n            boolVar18 = false;\n          }\n          else {\n            uintVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uintVar16]);\n            if (uintVar11 == 1) {\n              boolVar18 = false;\n            }\n            else {\n              boolVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        boolVar18 = false;\n      }\n      ptrVar7 = PTR_Firmata_08002044;\n      if (boolVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_08002044,'\\0');\n        firmata::FirmataClass::write((FirmataClass *)ptrVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)ptrVar7,'\\v');\n        firmata::FirmataClass::write((FirmataClass *)ptrVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)ptrVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)ptrVar7,'\\x01');\n      }\n      if ((uintVar16 - 0x2e & 0xff) < 0xe) {\n        if (uintVar16 < 0x3c) {\n          pinName = PTR_digitalPin_08002060[uintVar16];\n        }\n        else {\n          pinName = NC;\n        }\n        uintVar11 = pinNametoDigitalPin(pinName);\n        if (uintVar11 == 0) {\n          boolVar18 = false;\n        }\n        else {\n          if (uintVar16 < 0x3c) {\n            pinName = PTR_digitalPin_08002060[uintVar16];\n          }\n          else {\n            pinName = NC;\n          }\n          uintVar11 = pinNametoDigitalPin(pinName);\n          if (uintVar11 == 1) {\n            boolVar18 = false;\n          }\n          else {\n            boolVar18 = true;\n          }\n        }\n      }\n      else {\n        boolVar18 = false;\n      }\n      ptrVar7 = PTR_Firmata_080022e8;\n      if (boolVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x02');\n        firmata::FirmataClass::write((FirmataClass *)ptrVar7,'\\n');\n      }\n      if (uintVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uintVar16] == NC) {\n          boolVar9 = false;\n        }\n        else {\n          uintVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uintVar16]);\n          if (uintVar11 == 0) {\n            boolVar9 = false;\n          }\n          else {\n            uintVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uintVar16]);\n            if (uintVar11 == 1) {\n              boolVar9 = false;\n            }\n            else {\n              boolVar9 = pin_in_pinmap(PTR_digitalPin_080022e4[uintVar16],\n                                    (PinMap_conflict *)PTR_PinMap_PWM_080022ec);\n            }\n          }\n        }\n      }\n      else {\n        boolVar9 = false;\n      }\n      ptrVar7 = PTR_Firmata_080022e8;\n      if (boolVar9 != false) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x03');\n        firmata::FirmataClass::write((FirmataClass *)ptrVar7,'\\b');\n      }\n      if (uintVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uintVar16] == NC) {\n          boolVar18 = false;\n        }\n        else {\n          uintVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uintVar16]);\n          if (uintVar11 == 0) {\n            boolVar18 = false;\n          }\n          else {\n            uintVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uintVar16]);\n            if (uintVar11 == 1) {\n              boolVar18 = false;\n            }\n            else {\n              boolVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        boolVar18 = false;\n      }\n      ptrVar7 = PTR_Firmata_080022e8;\n      if (boolVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x04');\n        firmata::FirmataClass::write((FirmataClass *)ptrVar7,'\\x0e');\n      }\n      if (uintVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uintVar16] == NC) {\n          boolVar9 = false;\n        }\n        else {\n          uintVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uintVar16]);\n          if (uintVar11 == 0) {\n            boolVar9 = false;\n          }\n          else {\n            uintVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uintVar16]);\n            if (uintVar11 == 1) {\n              boolVar9 = false;\n            }\n            else {\n              boolVar9 = pin_in_pinmap(PTR_digitalPin_080022e4[uintVar16],\n                                    (PinMap_conflict *)PTR_PinMap_I2C_SDA_080022f0);\n              if (!boolVar9) {\n                boolVar9 = pin_in_pinmap(PTR_digitalPin_080022e4[uintVar16],\n                                      (PinMap_conflict *)PTR_PinMap_I2C_SCL_080022f4);\n              }\n            }\n          }\n        }\n      }\n      else {\n        boolVar9 = false;\n      }\n      ptrVar7 = PTR_Firmata_080022e8;\n      if (boolVar9 != false) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x06');\n        firmata::FirmataClass::write((FirmataClass *)ptrVar7,'\\x01');\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x7f');\n    }\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n    return;\n  case 'm':\n    if (uintVar16 != 0) {\n      byteVar1 = *argValues;\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf0);\n      firmata::FirmataClass::write((FirmataClass *)firmataObject,'n');\n      firmata::FirmataClass::write((FirmataClass *)firmataObject,byteVar1);\n      if (byteVar1 < 0x3c) {\n        byteVar10 = firmata::FirmataClass::getPinMode((FirmataClass *)firmataObject,byteVar1);\n        firmata::FirmataClass::write((FirmataClass *)firmataObject,byteVar10);\n        intVar13 = firmata::FirmataClass::getPinState((FirmataClass *)firmataObject,byteVar1);\n        firmata::FirmataClass::write((FirmataClass *)firmataObject,(byte)intVar13 & 0x7f);\n        uintVar16 = firmata::FirmataClass::getPinState((FirmataClass *)firmataObject,byteVar1);\n        if ((uintVar16 & 0xff80) != 0) {\n          intVar13 = firmata::FirmataClass::getPinState((FirmataClass *)firmataObject,byteVar1);\n          firmata::FirmataClass::write((FirmataClass *)firmataObject,(byte)((uint)(intVar13 << 0x12) >> 0x19));\n        }\n        uintVar16 = firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_080022e8,byteVar1);\n        ptrVar7 = PTR_Firmata_080022e8;\n        if ((uintVar16 & 0xc000) != 0) {\n          intVar13 = firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_080022e8,byteVar1);\n          firmata::FirmataClass::write((FirmataClass *)ptrVar7,(byte)((uint)(intVar13 << 0xb) >> 0x19))\n          ;\n        }\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n      return;\n    }\n    break;\n  case 'o':\n    if (1 < uintVar16) {\n      uintVar12 = (uint)argValues[1];\n      if (2 < uintVar16) {\n        uintVar12 = uintVar12 | (uint)argValues[2] << 7;\n      }\n      if (3 < uintVar16) {\n        uintVar12 = uintVar12 | (uint)argValues[3] << 0xe;\n      }\n      analogWriteCallback(*argValues,uintVar12);\n      return;\n    }\n    break;\n  case 'p':\n    if (4 < uintVar16) {\n      byteVar1 = *argValues;\n      uintVar16 = (uint)byteVar1;\n      byteVar2 = argValues[1];\n      byteVar3 = argValues[2];\n      byteVar4 = argValues[3];\n      byteVar5 = argValues[4];\n      if (uintVar16 < 0x3c) {\n        if (PTR_digitalPin_08002060[uintVar16] == NC) {\n          boolVar18 = false;\n        }\n        else {\n          uintVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uintVar16]);\n          if (uintVar11 == 0) {\n            boolVar18 = false;\n          }\n          else {\n            uintVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uintVar16]);\n            if (uintVar11 == 1) {\n              boolVar18 = false;\n            }\n            else {\n              boolVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        boolVar18 = false;\n      }\n      if (boolVar18) {\n        if ((byte)PTR_servoPinMap_08002064[uintVar16] < 0xc) {\n          boolVar18 = Servo::attached((Servo *)(PTR_servos_08002068 +\n                                            (uint)(byte)PTR_servoPinMap_08002064[uintVar16] * 3));\n        }\n        else {\n          boolVar18 = false;\n        }\n        if (boolVar18 != false) {\n          detachServo(byteVar1);\n        }\n        attachServo(byteVar1,(uint)byteVar2 + (uint)byteVar3 * 0x80,(uint)byteVar4 + (uint)byteVar5 * 0x80);\n        setPinModeCallback(byteVar1,4);\n        return;\n      }\n    }\n    break;\n  case 'v':\n    byteVar1 = argValues[1];\n    if ((byteVar1 & 0x20) != 0) {\n      firmata::FirmataClass::sendString\n                ((FirmataClass *)PTR_Firmata_08002044,PTR_s_10_bit_pinAddressing_not_supported_08002040\n                );\n      return;\n    }\n    pinAddress = *argValues;\n    boolVar18 = (byteVar1 & 0x40) == 0;\n    if ((byteVar1 & 0x18) < 0x19) {\n      switch(byteVar1 & 0x18) {\n      case 0:\n        TwoWire::beginTransmission((TwoWire *)PTR_Wire_08002048,pinAddress);\n        for (uintVar12 = 2; uintVar12 < uintVar16; uintVar12 = uintVar12 + 2 & 0xff) {\n          wireWrite(argValues[uintVar12 + 1] * -0x80 + argValues[uintVar12]);\n        }\n        TwoWire::endTransmission((TwoWire *)PTR_Wire_08002048);\n        return;\n      case 8:\n        if (uintVar16 == 6) {\n          intVar13 = (uint)argValues[2] + (uint)argValues[3] * 0x80;\n          byteVar10 = argValues[4] + argValues[5] * -0x80;\n        }\n        else {\n          byteVar10 = argValues[2] + argValues[3] * -0x80;\n          intVar13 = -1;\n        }\n        readAndReportData(pinAddress,intVar13,byteVar10,boolVar18);\n        return;\n      case 0x10:\n        if ((char)*PTR_queryIndex_0800204c + 1 < 8) {\n          if (uintVar16 == 6) {\n            intVar13 = (uint)argValues[2] + (uint)argValues[3] * 0x80;\n            charVar15 = argValues[4] + argValues[5] * -0x80;\n          }\n          else {\n            charVar15 = argValues[2] + argValues[3] * -0x80;\n            intVar13 = -1;\n          }\n          charVar6 = *PTR_queryIndex_0800204c + '\\x01';\n          *PTR_queryIndex_0800204c = charVar6;\n          ptrVar7 = PTR_query_08002050;\n          intVar14 = charVar6 * 0xc;\n          PTR_query_08002050[intVar14] = pinAddress;\n          *(int *)(ptrVar7 + intVar14 + 4) = intVar13;\n          ptrVar7[intVar14 + 8] = charVar15;\n          ptrVar7[intVar14 + 9] = boolVar18;\n          return;\n        }\n        firmata::FirmataClass::sendString\n                  ((FirmataClass *)PTR_Firmata_08002044,PTR_s_too_many_queries_08002054);\n        return;\n      case 0x18:\n        charVar15 = *PTR_queryIndex_0800204c;\n        if (charVar15 < 1) {\n          *PTR_queryIndex_0800204c = 0xff;\n          return;\n        }\n      }\n      for (uintVar16 = 0; intVar13 = charVar15 + 1, (int)uintVar16 < intVar13; uintVar16 = uintVar16 + 1 & 0xff) {\n        if (pinAddress == PTR_query_08002050[uintVar16 * 0xc]) goto LAB_08001e66;\n      }\n      uintVar16 = 0;\nLAB_08001e66:\n      for (; ptrVar7 = PTR_query_08002050, (int)uintVar16 < intVar13; uintVar16 = uintVar16 + 1 & 0xff) {\n        if (uintVar16 < 8) {\n          intVar14 = (uintVar16 + 1) * 0xc;\n          intVar17 = uintVar16 * 0xc;\n          PTR_query_08002050[intVar17] = PTR_query_08002050[intVar14];\n          *(undefined4 *)(ptrVar7 + intVar17 + 4) = *(undefined4 *)(ptrVar7 + intVar14 + 4);\n          ptrVar7[intVar17 + 8] = ptrVar7[intVar14 + 8];\n          ptrVar7[intVar17 + 9] = ptrVar7[intVar14 + 9];\n        }\n      }\n      *PTR_queryIndex_0800204c = charVar15 + -1;\n      return;\n    }\n    break;\n  case 'x':\n    intVar13 = (uint)*argValues + (uint)argValues[1] * 0x80;\n    if ((1 < uintVar16) && (intVar13 != 0)) {\n      *(int *)PTR_i2cReadDelayTime_08002058 = intVar13;\n    }\n    if (*PTR_isI2CEnabled_0800205c == '\\0') {\n      enableI2CPins();\n      return;\n    }\n    break;\n  case 'z':\n    if ((1 < uintVar16) &&\n       (intVar13 = (uint)*argValues + (uint)argValues[1] * 0x80, *(int *)PTR_samplingInterval_0800206c = intVar13,\n       intVar13 == 0)) {\n      *(undefined4 *)PTR_samplingInterval_0800206c = 1;\n      return;\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "enableI2CPins",
                "attached",
                "pin_in_pinmap",
                "beginTransmission",
                "pinNametoDigitalPin",
                "wireWrite",
                "sendString",
                "write",
                "endTransmission",
                "attachServo",
                "getPinState",
                "detachServo",
                "getPinMode",
                "readAndReportData",
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001cd0",
            "calling": [],
            "imported": false,
            "current_name": "process_command_08001cd0"
        },
        "FUN_08007320": {
            "renaming": {
                "FUN_08007320": "find_peripheral_pin_08007320",
                "pin": "pin_name",
                "map": "pin_map",
                "pvVar1": "peripheral_address"
            },
            "code": "\nvoid * find_peripheral_pin_08007320(PinName_conflict pin_name,PinMap_conflict *pin_map)\n\n{\n  void *peripheral_address;\n  \n  if (pin_name != NC) {\n    peripheral_address = pin_namepin_map_find_peripheral(pin_name,pin_map);\n    return peripheral_address;\n  }\n  return (void *)0x0;\n}\n\n",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007320",
            "calling": [
                "pwm_stop",
                "uart_debug_init",
                "pwm_start",
                "uart_init",
                "adc_read_value",
                "i2c_custom_init",
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "find_peripheral_pin_08007320"
        },
        "FUN_080002ec": {
            "renaming": {
                "FUN_080002ec": "digital_write_multiple_pins_080002ec",
                "port": "portNum",
                "value": "pinsValue",
                "bVar1": "isPinValid",
                "bVar2": "pinMode",
                "uVar3": "portNumUint",
                "uVar4": "digitalPinNum",
                "uVar6": "pinMask",
                "uVar7": "endPinNum",
                "uVar8": "validPinMask",
                "iVar5": "pinState",
                "pin": "pinNum",
                "ulPin": "pinIndex",
                "ulPin_00": "startPinIndex",
                "NC": "NOT_CONNECTED"
            },
            "code": "\nvoid digitalWriteMultiplePins_080002ec(byte portNum,int pinsValue)\n\n{\n  bool isPinValid;\n  byte pinMode;\n  uint portNumUint;\n  uint32_t digitalPinNum;\n  int pinState;\n  byte pinNum;\n  uint32_t pinIndex;\n  uint pinMask;\n  uint endPinNum;\n  uint32_t startPinIndex;\n  uint validPinMask;\n  \n  portNumUint = (uint)portNum;\n  if (portNumUint < 5) {\n    endPinNum = (portNumUint + 1 & 0x1f) * 8;\n    if (0x3c < endPinNum) {\n      endPinNum = 0x3c;\n    }\n    validPinMask = 0;\n    pinMask = 1;\n    startPinIndex = (portNumUint & 0x1f) * 8;\n    for (pinIndex = startPinIndex; pinIndex < endPinNum; pinIndex = pinIndex + 1 & 0xff) {\n      if (pinIndex < 0x3c) {\n        if (PTR_digitalPin_08000480[pinIndex] == NOT_CONNECTED) {\n          isPinValid = false;\n        }\n        else {\n          digitalPinNum = pinNumNametoDigitalPin(PTR_digitalPin_08000480[pinIndex]);\n          if (digitalPinNum == 0) {\n            isPinValid = false;\n          }\n          else {\n            digitalPinNum = pinNumNametoDigitalPin(PTR_digitalPin_08000480[pinIndex]);\n            if (digitalPinNum == 1) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        pinNum = (byte)pinIndex;\n        pinMode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000484,pinNum);\n        if ((pinMode != '\\x01') &&\n           (pinMode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000484,pinNum),\n           pinMode != '\\0')) {\n          isPinValid = false;\n        }\n        if (isPinValid) {\n          portNumUint = (uint)((pinMask & pinsValue) != 0);\n          pinMode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000484,pinNum);\n          if (pinMode == '\\x01') {\n            validPinMask = pinMask | validPinMask;\n          }\n          else {\n            pinMode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000484,pinNum);\n            if (pinMode == '\\0') {\n              if (portNumUint == 0) {\n                isPinValid = false;\n              }\n              else {\n                pinState = firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_08000484,pinNum)\n                ;\n                if (pinState == 1) {\n                  isPinValid = false;\n                }\n              }\n            }\n            else {\n              isPinValid = false;\n            }\n            if (isPinValid) {\n              pinNumMode(pinIndex,2);\n            }\n          }\n          firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000484,pinNum,portNumUint);\n        }\n      }\n      pinMask = (pinMask & 0x7f) << 1;\n    }\n    if ((validPinMask & 1) != 0) {\n      digitalWrite(startPinIndex,pinsValue & 1);\n    }\n    if ((validPinMask & 2) != 0) {\n      digitalWrite(startPinIndex + 1,pinsValue & 2);\n    }\n    if ((validPinMask & 4) != 0) {\n      digitalWrite(startPinIndex + 2,pinsValue & 4);\n    }\n    if ((validPinMask & 8) != 0) {\n      digitalWrite(startPinIndex + 3,pinsValue & 8);\n    }\n    if ((validPinMask & 0x10) != 0) {\n      digitalWrite(startPinIndex + 4,pinsValue & 0x10);\n    }\n    if ((validPinMask & 0x20) != 0) {\n      digitalWrite(startPinIndex + 5,pinsValue & 0x20);\n    }\n    if ((validPinMask & 0x40) != 0) {\n      digitalWrite(startPinIndex + 6,pinsValue & 0x40);\n    }\n    if ((validPinMask & 0x80) != 0) {\n      digitalWrite(startPinIndex + 7,pinsValue & 0x80);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "digitalWrite",
                "pinNametoDigitalPin",
                "setPinState",
                "pinMode",
                "getPinState",
                "getPinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002ec",
            "calling": [],
            "imported": false,
            "current_name": "digital_write_multiple_pins_080002ec"
        },
        "FUN_08000be8": {
            "renaming": {
                "FUN_08000be8": "send_digital_port_if_changed_08000be8",
                "portNumber": "port_number",
                "portValue": "port_value",
                "forceSend": "force_send"
            },
            "code": "\nvoid send_digital_port_if_changed_08000be8(byte port_number,byte port_value,byte force_send)\n\n{\n  byte bVar1;\n  \n  bVar1 = PTR_portConfigInputs_08000c0c[port_number] & port_value;\n  if ((force_send != '\\0') || ((uint)bVar1 != (uint)(byte)PTR_previousPINs_08000c10[port_number])) {\n    firmata::FirmataClass::sendDigitalPort\n              ((FirmataClass *)PTR_Firmata_08000c14,port_number,(uint)bVar1);\n    PTR_previousPINs_08000c10[port_number] = bVar1;\n  }\n  return;\n}\n\n",
            "called": [
                "sendDigitalPort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000be8",
            "calling": [
                "checkDigitalInputs",
                "reportDigitalCallback"
            ],
            "imported": false,
            "current_name": "send_digital_port_if_changed_08000be8"
        },
        "FUN_08003fd8": {
            "renaming": {
                "FUN_08003fd8": "check_ticks_number_08003fd8",
                "TicksNumb": "ticks_number",
                "puVar1": "pointer"
            },
            "code": "\nuint32_t check_ticks_number_08003fd8(uint32_t ticks_number)\n\n{\n  undefined4 *pointer;\n  \n  pointer = DAT_08003ffc;\n  if (ticks_number - 1 < 0x1000000) {\n    DAT_08003ffc[1] = ticks_number - 1;\n    *(undefined *)(DAT_08004000 + 0x23) = 0xf0;\n    pointer[2] = 0;\n    *pointer = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fd8",
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "check_ticks_number_08003fd8"
        },
        "FUN_0800307a": {
            "renaming": {
                "this": "marshaller",
                "bytec": "num_bytes",
                "bytev": "byte_array",
                "max_bytes": "max_num_bytes",
                "uVar1": "current_byte",
                "uVar2": "num_bits",
                "uVar3": "num_encoded_bytes",
                "uVar4": "byte_index",
                "FUN_0800307a": "encode_varints_0800307a"
            },
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003102 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::encode_varints_0800307a(FirmataMarshaller *marshaller,size_t num_bytes,uint8_t *byte_array,size_t max_num_bytes)\n\n{\n  uint current_byte;\n  uint num_bits;\n  uint num_encoded_bytes;\n  uint byte_index;\n  \n  current_byte = (uint)*byte_array;\n  if (max_num_bytes == 0) {\n    max_num_bytes = 0xffffffff;\n  }\n  byte_index = 0;\n  num_bits = 0;\n  num_encoded_bytes = 0;\n  while ((byte_index < num_bytes && (num_encoded_bytes < max_num_bytes))) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)\n              (marshaller->FirmataStream,((uint)byte_array[byte_index] << (num_bits & 0xff) | current_byte) & 0x7f);\n    current_byte = (int)(uint)byte_array[byte_index] >> (7 - num_bits & 0xff) & 0xff;\n    num_bits = num_bits + 1;\n    while ((num_encoded_bytes = num_encoded_bytes + 1, 6 < num_bits && (num_encoded_bytes < max_num_bytes))) {\n      (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,current_byte & 0x7f);\n      current_byte = current_byte >> 7;\n      num_bits = num_bits - 7;\n    }\n    byte_index = byte_index + 1;\n  }\n  if ((num_bits != 0) && (num_encoded_bytes < max_num_bytes)) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)\n              (marshaller->FirmataStream,(1 << (num_bits & 0xff)) - 1U & current_byte);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800307a",
            "calling": [
                "sendExtendedAnalog",
                "sendSysex",
                "sendFirmwareVersion",
                "sendDigitalPort",
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "encode_varints_0800307a"
        },
        "FUN_08004b80": {
            "renaming": {
                "FUN_08004b80": "do_nothing_08004b80"
            },
            "code": "\nvoid do_nothing_08004b80(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b80",
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004b80"
        },
        "FUN_08002ca4": {
            "renaming": {
                "param_1": "param",
                "c_str": "string",
                "code": "callback",
                "FUN_08002ca4": "handle_string_callback_08002ca4"
            },
            "code": "\nvoid firmata::FirmataClass::handleStringCallback_08002ca4(void *param,char *string)\n\n{\n  if (*(callback **)PTR_currentStringCallback_08002cb4 != (callback *)0x0) {\n    (**(callback **)PTR_currentStringCallback_08002cb4)(string);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ca4",
            "calling": [],
            "imported": false,
            "current_name": "handle_string_callback_08002ca4"
        },
        "FUN_0800319e": {
            "renaming": {
                "this": "marshaller",
                "portNumber": "port",
                "portData": "data",
                "local_a": "encodedData",
                "super_Print": "printInterface",
                "_vptr_Print": "virtualPrintInterface",
                "encodeByteStream": "encodeData",
                "FUN_0800319e": "send_port_data_0800319e"
            },
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080031ba */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendPortData_0800319e(FirmataMarshaller *marshaller,uint8_t port,uint16_t data)\n\n{\n  uint16_t encodedData;\n  \n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    encodedData = data;\n    (**(marshaller->FirmataStream->printInterface).virtualPrintInterface)(marshaller,port & 0xf | 0x90);\n    encodeData(marshaller,2,(uint8_t *)&encodedData,2);\n  }\n  return;\n}\n\n",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800319e",
            "calling": [
                "sendDigitalPort"
            ],
            "imported": false,
            "current_name": "send_port_data_0800319e"
        },
        "FUN_08008d00": {
            "renaming": {
                "_rx": "pin_index",
                "PVar1": "pin_name",
                "NC": "no_connection",
                "FUN_08008d00": "set_rx_pin_08008d00"
            },
            "code": "\nvoid __thiscall HardwareSerial::set_rx_pin_08008d00(HardwareSerial *this,uint32_t pin_index)\n\n{\n  PinName pin_name;\n  \n  if (pin_index < 0x3c) {\n    pin_name = PTR_digitalPin_08008d14[pin_index];\n  }\n  else {\n    pin_name = no_connection;\n  }\n  (this->_serial).pinpin_index = pin_name;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d00",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "set_rx_pin_08008d00"
        },
        "FUN_08004b82": {
            "renaming": {
                "FUN_08004b82": "i2c_transfer_complete_handler_08004b82",
                "hi2c": "i2c_handle",
                "HVar1": "i2c_state",
                "pbVar2": "data_ptr",
                "uVar3": "xfer_options",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "HAL_I2C_StateTypeDef_conflict": "HAL_I2C_StateTypeDef",
                "byte": "uint8_t",
                "HAL_I2C_MasterTxCpltCallback": "i2c_master_tx_complete_callback",
                "HAL_I2C_MemTxCpltCallback": "i2c_mem_tx_complete_callback",
                "Instance": "i2c_instance",
                "CR2": "i2c_cr2_reg",
                "CR1": "i2c_cr1_reg",
                "PreviousState": "prev_i2c_state",
                "Mode": "i2c_mode",
                "XferSize": "xfer_size",
                "XferOptions": "xfer_options",
                "XferCount": "xfer_count",
                "EventCount": "event_count",
                "MemaddSize": "mem_addr_size",
                "Memaddress": "mem_addr",
                "State": "i2c_state",
                "pBuffPtr": "data_buffer_ptr"
            },
            "code": "\nHAL_StatusTypeDef i2c_transfer_complete_handler_08004b82(I2C_HandleTypeDef *i2c_handle)\n\n{\n  HAL_I2C_StateTypeDef i2c_state;\n  uint8_t *data_ptr;\n  uint32_t xfer_options;\n  \n  i2c_state = i2c_handle->i2c_state;\n  xfer_options = i2c_handle->xfer_options;\n  if ((i2c_handle->xfer_size == 0) && (i2c_state == HAL_I2C_STATE_BUSY_TX)) {\n    if ((xfer_options == 4) || ((xfer_options == 8 || (xfer_options == 0xffff0000)))) {\n      i2c_handle->i2c_instance->i2c_cr2_reg = i2c_handle->i2c_instance->i2c_cr2_reg & 0xfffff8ff;\n      i2c_handle->i2c_instance->i2c_cr1_reg = i2c_handle->i2c_instance->i2c_cr1_reg | 0x200;\n      i2c_handle->prev_i2c_state = 0;\n      i2c_handle->i2c_state = HAL_I2C_STATE_READY;\n      if (i2c_handle->i2c_mode == HAL_I2C_MODE_MEM) {\n        i2c_handle->i2c_mode = HAL_I2C_MODE_NONE;\n        i2c_mem_tx_complete_callback(i2c_handle);\n      }\n      else {\n        i2c_handle->i2c_mode = HAL_I2C_MODE_NONE;\n        i2c_master_tx_complete_callback(i2c_handle);\n      }\n    }\n    else {\n      i2c_handle->i2c_instance->i2c_cr2_reg = i2c_handle->i2c_instance->i2c_cr2_reg & 0xfffff8ff;\n      i2c_handle->prev_i2c_state = 0x11;\n      i2c_handle->i2c_mode = HAL_I2C_MODE_NONE;\n      i2c_handle->i2c_state = HAL_I2C_STATE_READY;\n      i2c_master_tx_complete_callback(i2c_handle);\n    }\n  }\n  else if ((i2c_state == HAL_I2C_STATE_BUSY_TX) ||\n          ((i2c_handle->i2c_mode == HAL_I2C_MODE_MEM && (i2c_state == HAL_I2C_STATE_BUSY_RX)))) {\n    if (i2c_handle->xfer_count == 0) {\n      i2c_handle->i2c_instance->i2c_cr2_reg = i2c_handle->i2c_instance->i2c_cr2_reg & 0xfffffbff;\n    }\n    else if (i2c_handle->i2c_mode == HAL_I2C_MODE_MEM) {\n      if (i2c_handle->event_count == 0) {\n        if (i2c_handle->mem_addr_size == 1) {\n          i2c_handle->i2c_instance->DR = i2c_handle->mem_addr & 0xff;\n          i2c_handle->event_count = i2c_handle->event_count + 2;\n        }\n        else {\n          i2c_handle->i2c_instance->DR = (i2c_handle->mem_addr << 0x10) >> 0x18;\n          i2c_handle->event_count = i2c_handle->event_count + 1;\n        }\n      }\n      else if (i2c_handle->event_count == 1) {\n        i2c_handle->i2c_instance->DR = i2c_handle->mem_addr & 0xff;\n        i2c_handle->event_count = i2c_handle->event_count + 1;\n      }\n      else if (i2c_handle->event_count == 2) {\n        if (i2c_handle->i2c_state == HAL_I2C_STATE_BUSY_RX) {\n          i2c_handle->i2c_instance->i2c_cr1_reg = i2c_handle->i2c_instance->i2c_cr1_reg | 0x100;\n        }\n        else if (i2c_handle->i2c_state == HAL_I2C_STATE_BUSY_TX) {\n          data_ptr = i2c_handle->data_buffer_ptr;\n          i2c_handle->data_buffer_ptr = data_ptr + 1;\n          i2c_handle->i2c_instance->DR = (uint)*data_ptr;\n          i2c_handle->xfer_count = i2c_handle->xfer_count - 1;\n        }\n      }\n    }\n    else {\n      data_ptr = i2c_handle->data_buffer_ptr;\n      i2c_handle->data_buffer_ptr = data_ptr + 1;\n      i2c_handle->i2c_instance->DR = (uint)*data_ptr;\n      i2c_handle->xfer_count = i2c_handle->xfer_count - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b82",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_complete_handler_08004b82"
        },
        "FUN_0800997e": {
            "renaming": {
                "FUN_0800997e": "find_last_occurrence_0800997e",
                "__s": "str",
                "__c": "target_char",
                "pcVar1": "occurrence",
                "pcVar2": "last_occurrence"
            },
            "code": "\nchar * find_last_occurrence_0800997e(char *str,int target_char)\n\n{\n  char *occurrence;\n  char *last_occurrence;\n  \n  if (target_char != 0) {\n    last_occurrence = (char *)0x0;\n    while (occurrence = strchr(str,target_char), occurrence != (char *)0x0) {\n      str = occurrence + 1;\n      last_occurrence = occurrence;\n    }\n    return last_occurrence;\n  }\n  last_occurrence = strchr(str,0);\n  return last_occurrence;\n}\n\n",
            "called": [
                "strchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800997e",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "find_last_occurrence_0800997e"
        },
        "FUN_0800779c": {
            "renaming": {
                "FUN_0800779c": "handle_timer_interrupt_0800779c",
                "TIM_HandleTypeDef_conflict": "Timer_HandleTypeDef",
                "HAL_TIM_IRQHandler": "handle_timer_irq"
            },
            "code": "\nvoid handle_timer_interrupt_0800779c(void)\n\n{\n  if (*(Timer_HandleTypeDef **)(PTR_timer_handles_080077ac + 0xc) !=\n      (Timer_HandleTypeDef *)0x0) {\n    handle_timer_irq(*(Timer_HandleTypeDef **)(PTR_timer_handles_080077ac + 0xc));\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800779c",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_0800779c"
        },
        "FUN_08002dbc": {
            "renaming": {
                "FUN_08002dbc": "initialize_firmata_08002dbc",
                "__initialize_p": "is_initialized",
                "__priority": "priority_level",
                "firmata::FirmataClass::FirmataClass": "initialize_firmata_class"
            },
            "code": "\nvoid initialize_firmata_08002dbc(int is_initialized,int priority_level)\n\n{\n  if (is_initialized != 1) {\n    return;\n  }\n  if (priority_level == 0xffff) {\n    initialize_firmata_08002dbc_class((FirmataClass *)PTR_Firmata_08002dd8);\n  }\n  return;\n}\n\n",
            "called": [
                "FirmataClass"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002dbc",
            "calling": [
                "_GLOBAL__sub_I_Firmata"
            ],
            "imported": false,
            "current_name": "initialize_firmata_08002dbc"
        },
        "FUN_08007f78": {
            "renaming": {
                "FUN_08007f78": "get_i2c_event_count_ptr_08007f78",
                "hi2c": "i2c_handle_ptr",
                "i2c_t_conflict": "i2c_event_count_struct",
                "EventCount": "event_count"
            },
            "code": "\ni2c_event_count_struct * get_i2c_event_count_ptr_08007f78(I2C_HandleTypeDef_conflict *i2c_handle_ptr)\n\n{\n  return (i2c_event_count_struct *)&i2c_handle_ptr[-1].event_count;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f78",
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "imported": false,
            "current_name": "get_i2c_event_count_ptr_08007f78"
        },
        "FUN_08006b28": {
            "renaming": {
                "FUN_08006b28": "check_pin_state_08006b28",
                "PinName_conflict": "pin_name",
                "map": "pin_state_map",
                "byte": "state_byte",
                "uint": "unsigned_int"
            },
            "code": "\n_Bool check_pin_state_08006b28(pin_name pin,unsigned_int32_t *pin_state_map)\n\n{\n  return (_Bool)((state_byte)(pin_state_map[(unsigned_int)((int)pin << 0x18) >> 0x1c] >> ((int)pin & 0xfU)) & 1);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b28",
            "calling": [
                "digitalRead",
                "digitalWrite",
                "analogWrite",
                "pinMode"
            ],
            "imported": false,
            "current_name": "check_pin_state_08006b28"
        },
        "FUN_08006b1c": {
            "renaming": {
                "FUN_08006b1c": "get_uart_state_08006b1c",
                "huart": "uart_handle",
                "RxState": "rx_state",
                "gState": "global_state"
            },
            "code": "\nHAL_UART_StateTypeDef get_uart_state_08006b1c(UART_HandleTypeDef *uart_handle)\n\n{\n  return uart_handle->rx_state | uart_handle->global_state;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b1c",
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "imported": false,
            "current_name": "get_uart_state_08006b1c"
        },
        "FUN_0800a130": {
            "renaming": {
                "FUN_0800a130": "set_file_pointer_0800a130",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "origin",
                "puVar1": "error_pointer",
                "iVar2": "result"
            },
            "code": "\nvoid set_file_pointer_0800a130(int *error_code,int file_descriptor,int offset,int origin)\n\n{\n  undefined *error_pointer;\n  int result;\n  \n  error_pointer = PTR_errno_0800a150;\n  *(undefined4 *)PTR_errno_0800a150 = 0;\n  result = _lseek(file_descriptor,offset,origin);\n  if ((result == -1) && (*(int *)error_pointer != 0)) {\n    *error_code = *(int *)error_pointer;\n  }\n  return;\n}\n\n",
            "called": [
                "_lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a130",
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "imported": false,
            "current_name": "set_file_pointer_0800a130"
        },
        "FUN_08008f3c": {
            "renaming": {
                "FUN_08008f3c": "pin_bit_position_08008f3c",
                "pin": "pin_number",
                "uVar1": "pin_copy",
                "uVar2": "bit_position"
            },
            "code": "\nuint8_t pin_bit_position_08008f3c(uint16_t pin_number)\n\n{\n  uint pin_copy;\n  uint8_t bit_position;\n  \n  bit_position = '\\0';\n  for (pin_copy = (uint)pin_number; pin_copy != 1; pin_copy = pin_copy >> 1) {\n    bit_position = bit_position + '\\x01';\n  }\n  return bit_position;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f3c",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "pin_bit_position_08008f3c"
        },
        "FUN_08002ef2": {
            "renaming": {
                "pin": "pinNumber",
                "value": "pinValue",
                "FUN_08002ef2": "update_pin_value_08002ef2"
            },
            "code": "\nvoid __thiscall firmata::FirmataClass::updatePinValue_08002ef2(FirmataClass *this,byte pinNumber,int pinValue)\n\n{\n  FirmataMarshaller::updatePinValue_08002ef2(&this->marshaller,pinNumber,(uint16_t)pinValue);\n  return;\n}\n\n",
            "called": [
                "sendAnalog"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ef2",
            "calling": [
                "reportAnalogCallback",
                "loop"
            ],
            "imported": false,
            "current_name": "update_pin_value_08002ef2"
        },
        "FUN_08007332": {
            "renaming": {
                "FUN_08007332": "find_pin_name_08007332",
                "peripheral": "peripheral_ptr",
                "map": "pin_map_ptr",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap",
                "NC": "NoConnection",
                "while": "while_loop",
                "true": "condition_true",
                "return": "return_value",
                "void": "void_type",
                "if": "if_statement",
                "==": "is_equal_to",
                "break": "break_loop",
                "pin": "pin_name"
            },
            "code": "\nPinName find_pin_name_08007332(void_type *peripheral_ptr,PinMap *pin_map_ptr)\n\n{\n  while_loop( condition_true ) {\n    if_statement (pin_map_ptr->peripheral_ptr is_equal_to (void_type *)0x0) {\n      return_value NoConnection;\n    }\n    if_statement (pin_map_ptr->peripheral_ptr is_equal_to peripheral_ptr) break_loop;\n    pin_map_ptr = pin_map_ptr + 1;\n  }\n  return_value pin_map_ptr->pin_name;\n}\n\n",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007332",
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "imported": false,
            "current_name": "find_pin_name_08007332"
        },
        "FUN_08006128": {
            "renaming": {
                "FUN_08006128": "configure_tim_output_compare_channel_08006128",
                "htim": "TIM_handle",
                "sConfig": "TIM_OC_config",
                "Channel": "TIM_channel",
                "TIM_OC1_SetConfig": "configure_TIM_output_compare_channel_1",
                "TIM_OC2_SetConfig": "configure_TIM_output_compare_channel_2",
                "TIM_OC3_SetConfig": "configure_TIM_output_compare_channel_3",
                "TIM_OC4_SetConfig": "configure_TIM_output_compare_channel_4",
                "HAL_LOCKED": "TIM_handle_locked",
                "HAL_TIM_STATE_BUSY": "TIM_state_busy",
                "HAL_TIM_STATE_READY": "TIM_state_ready",
                "HAL_UNLOCKED": "TIM_handle_unlocked",
                "HAL_StatusTypeDef_conflict": "TIM_configure_status"
            },
            "code": "\nTIM_configure_status\nconfigure_TIM_output_compare_channel_08006128(TIM_HandleTypeDef_conflict *TIM_handle,TIM_OC_InitTypeDef *TIM_OC_config,uint32_t TIM_channel)\n\n{\n  if (TIM_handle->Lock != TIM_handle_locked) {\n    TIM_handle->Lock = TIM_handle_locked;\n    TIM_handle->State = TIM_state_busy;\n    switch(TIM_channel) {\n    case 0:\n      configure_TIM_output_compare_channel_08006128_1(TIM_handle->Instance,TIM_OC_config);\n      break;\n    case 4:\n      configure_TIM_output_compare_channel_08006128_2(TIM_handle->Instance,TIM_OC_config);\n      break;\n    case 8:\n      configure_TIM_output_compare_channel_08006128_3(TIM_handle->Instance,TIM_OC_config);\n      break;\n    case 0xc:\n      configure_TIM_output_compare_channel_08006128_4(TIM_handle->Instance,TIM_OC_config);\n    }\n    TIM_handle->State = TIM_state_ready;\n    TIM_handle->Lock = TIM_handle_unlocked;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006128",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "configure_tim_output_compare_channel_08006128"
        },
        "FUN_0800a258": {
            "renaming": {
                "ctype_byname": "set_pointers_to_one_if_negative",
                "FUN_0800a258": "set_pointers_to_one_if_negative_0800a258"
            },
            "code": "\n/* std::set_pointers_to_one_if_negative_0800a258<wchar_t>::set_pointers_to_one_if_negative_0800a258(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::set_pointers_to_one_if_negative_0800a258<wchar_t>::set_pointers_to_one_if_negative_0800a258(void)\n\n{\n  if (-1 < *(int *)PTR_id_0800a2ec << 0x1f) {\n    *(undefined4 *)PTR_id_0800a2ec = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a2f0 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a2f0 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a2f4 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a2f4 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a2f8 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a2f8 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a2fc << 0x1f) {\n    *(undefined4 *)PTR_id_0800a2fc = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a300 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a300 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a304 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a304 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a308 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a308 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a30c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a30c = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a310 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a310 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a314 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a314 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a318 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a318 = 1;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a258",
            "calling": [],
            "imported": false,
            "current_name": "set_pointers_to_one_if_negative_0800a258"
        },
        "FUN_08002cb8": {
            "renaming": {
                "FUN_08002cb8": "handle_sysex_message_08002cb8",
                "param_1": "data",
                "command": "commandByte",
                "argc": "argumentCount",
                "argv": "arguments",
                "code": "functionPointer"
            },
            "code": "\nvoid firmata::FirmataClass::handleSysexMessage_08002cb8(void *data,uint8_t commandByte,size_t argumentCount,uint8_t *arguments)\n\n{\n  if (*(functionPointer **)PTR_currentSysexCallback_08002ccc != (functionPointer *)0x0) {\n    (**(functionPointer **)PTR_currentSysexCallback_08002ccc)(commandByte,argumentCount & 0xff,arguments,arguments,arguments);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002cb8",
            "calling": [],
            "imported": false,
            "current_name": "handle_sysex_message_08002cb8"
        },
        "FUN_08004a74": {
            "renaming": {
                "FUN_08004a74": "do_nothing_08004a74"
            },
            "code": "\nvoid do_nothing_08004a74(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a74",
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a74"
        },
        "FUN_08008f50": {
            "renaming": {
                "FUN_08008f50": "free_gpio_irq_conf_08008f50",
                "param_1": "void_param",
                "puVar1": "malloc_free_list",
                "puVar2": "current_ptr"
            },
            "code": "\nvoid free_gpio_irq_conf_08008f50(void *void_param)\n\n{\n  undefined *malloc_free_list;\n  undefined *current_ptr;\n  \n  malloc_free_list = PTR___malloc_free_list_08008f70;\n  while (current_ptr = malloc_free_list, current_ptr != PTR_gpio_irq_conf_08008f74) {\n    malloc_free_list = current_ptr + -0x14;\n    if (*(code **)(current_ptr + -8) != (code *)0x0) {\n      (**(code **)(current_ptr + -8))(current_ptr + -0x10,current_ptr + -0x10,3);\n    }\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f50",
            "calling": [],
            "imported": false,
            "current_name": "free_gpio_irq_conf_08008f50"
        },
        "FUN_08004a76": {
            "renaming": {
                "FUN_08004a76": "i2c_transfer_08004a76",
                "hi2c": "i2c_handle",
                "HVar1": "i2c_state",
                "puVar2": "data_ptr",
                "XferCount": "transfer_count",
                "pBuffPtr": "buffer_ptr",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "PreviousState": "previous_state",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_I2C_StateTypeDef_conflict": "HAL_I2C_StateTypeDef",
                "HAL_I2C_SlaveRxCpltCallback": "i2c_slave_receive_complete_callback"
            },
            "code": "\nHAL_StatusTypeDef i2c_transfer_08004a76(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  HAL_I2C_StateTypeDef GOCdata_registerZZNAZ;\n  uint8_t *data_ptr;\n  \n  GOCdata_registerZZNAZ = i2c_handle->State;\n  if (i2c_handle->transfer_count != 0) {\n    data_ptr = i2c_handle->buffer_ptr;\n    i2c_handle->buffer_ptr = data_ptr + 1;\n    *data_ptr = (uint8_t)i2c_handle->i2c_instance->data_register;\n    i2c_handle->transfer_count = i2c_handle->transfer_count - 1;\n    if ((i2c_handle->transfer_count == 0) && (GOCdata_registerZZNAZ == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2c_handle->i2c_instance->CR2 = i2c_handle->i2c_instance->CR2 & 0xfffffbff;\n      i2c_handle->previous_state = 0x22;\n      i2c_handle->State = HAL_I2C_STATE_LISTEN;\n      i2c_slave_receive_complete_callback(i2c_handle);\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a76",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08004a76"
        },
        "FUN_0800877c": {
            "renaming": {
                "FUN_0800877c": "initialize_uart_0800877c",
                "huart": "uart_handler",
                "tmpval": "temporary_value"
            },
            "code": "\nvoid initialize_uart_0800877c(UART_HandleTypeDef *uart_handler)\n\n{\n  uint32_t temporary_value;\n  \n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800877c",
            "calling": [
                "HAL_UART_IRQHandler",
                "UART_DMAAbortOnError"
            ],
            "imported": false,
            "current_name": "initialize_uart_0800877c"
        },
        "FUN_080047f4": {
            "renaming": {
                "FUN_080047f4": "read_i2c_data_080047f4",
                "hi2c": "i2c_handle",
                "DevAddress": "device_address",
                "pData": "data_buffer",
                "Size": "data_size",
                "HVar1": "status",
                "pIVar2": "i2c_instance",
                "count": "timeout_count"
            },
            "code": "\nHAL_StatusTypeDef_conflict\nread_i2c_data_080047f4(I2C_HandleTypeDef_conflict *i2c_handle,uint16_t device_address,uint8_t *data_buffer,uint16_t data_size)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2c_instance;\n  uint32_t timeout_count;\n  \n  if (i2c_handle->State == HAL_I2C_STATE_READY) {\n    timeout_count = (uint)((ulonglong)DAT_080048c0 * (ulonglong)(*(uint *)PTR_SystemCoreClock_080048bc >> 3)\n                  >> 0x28) * 0x19;\n    do {\n      if (timeout_count == 0) {\n        i2c_handle->PreviousState = 0;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        i2c_handle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      i2c_instance = i2c_handle->Instance;\n      timeout_count = timeout_count - 1;\n    } while ((i2c_instance->SR2 & 2) != 0);\n    if (i2c_handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2c_handle->Lock = HAL_LOCKED;\n      if ((i2c_instance->CR1 & 1) == 0) {\n        i2c_instance->CR1 = i2c_instance->CR1 | 1;\n      }\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffff7ff;\n      i2c_handle->State = HAL_I2C_STATE_BUSY_RX;\n      i2c_handle->Mode = HAL_I2C_MODE_MASTER;\n      status = HAL_OK;\n      i2c_handle->ErrorCode = 0;\n      i2c_handle->pBuffPtr = data_buffer;\n      i2c_handle->XferCount = data_size;\n      i2c_handle->XferOptions = DAT_080048c4;\n      i2c_handle->Xferdata_size = i2c_handle->XferCount;\n      i2c_handle->Devaddress = (uint)device_address;\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x400;\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x100;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047f4",
            "calling": [
                "i2c_master_read"
            ],
            "imported": false,
            "current_name": "read_i2c_data_080047f4"
        },
        "FUN_08005a48": {
            "renaming": {
                "FUN_08005a48": "get_hclk_frequency_08005a48",
                "uVar1": "HCLK_freq"
            },
            "code": "\nuint32_t get_HCLK_frequency_08005a48(void)\n\n{\n  uint32_t HCLK_freq;\n  \n  HCLK_freq = HAL_RCC_GetHCLKFreq();\n  return HCLK_freq >> PTR_APBPrescTable_08005a64[(uint)(*(int *)(DAT_08005a60 + 4) << 0x12) >> 0x1d];\n}\n\n",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a48",
            "calling": [
                "HAL_RCCEx_GetPeriphCLKFreq",
                "getTimerClkFreq",
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "get_hclk_frequency_08005a48"
        },
        "FUN_080033a8": {
            "renaming": {
                "this": "self",
                "bytec": "byteCount",
                "bytev": "byteArray",
                "bVar1": "currentByte",
                "sVar2": "parsedByteCount",
                "uVar3": "byteIndex",
                "FUN_080033a8": "parse_firmata_080033a8"
            },
            "code": "\nsize_t __selfcall\nfirmata::FirmataParser::parseFirmata_080033a8(FirmataParser *self,size_t byteCount,uint8_t *byteArray)\n\n{\n  byte currentByte;\n  size_t parsedByteCount;\n  uint byteIndex;\n  \n  parsedByteCount = 0;\n  for (byteIndex = 0; byteIndex < byteCount; byteIndex = byteIndex + 2) {\n    currentByte = byteArray[byteIndex];\n    byteArray[parsedByteCount] = currentByte;\n    byteArray[parsedByteCount] = byteArray[byteIndex + 1] << 7 | currentByte;\n    parsedByteCount = parsedByteCount + 1;\n  }\n  return parsedByteCount;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033a8",
            "calling": [
                "processSysexMessage"
            ],
            "imported": false,
            "current_name": "parse_firmata_080033a8"
        },
        "FUN_08008d18": {
            "renaming": {
                "this": "serial_object",
                "_tx": "pin_number",
                "PVar1": "pin_name",
                "NC": "no_connection",
                "FUN_08008d18": "set_serial_pin_tx_08008d18"
            },
            "code": "\nvoid __serial_objectcall HardwareSerial::set_serial_pin_tx_08008d18(HardwareSerial *serial_object,uint32_t pin_number)\n\n{\n  PinName pin_name;\n  \n  if (pin_number < 0x3c) {\n    pin_name = PTR_digitalPin_08008d2c[pin_number];\n  }\n  else {\n    pin_name = no_connection;\n  }\n  (serial_object->_serial).pinpin_number = pin_name;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d18",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "set_serial_pin_tx_08008d18"
        },
        "FUN_0800a020": {
            "renaming": {
                "FUN_0800a020": "read_and_update_0800a020",
                "param_1": "file_descriptor",
                "param_2": "file_info",
                "iVar1": "bytes_read",
                "uVar2": "new_file_position",
                "bVar3": "is_read_successful"
            },
            "code": "\nvoid read_and_update_0800a020(undefined4 file_descriptor,int file_info)\n\n{\n  int bytes_read;\n  uint new_file_position;\n  bool is_read_successful;\n  \n  bytes_read = _read_r(file_descriptor,(int)*(short *)(file_info + 0xe));\n  is_read_successful = -1 < bytes_read;\n  if (is_read_successful) {\n    new_file_position = *(int *)(file_info + 0x54) + bytes_read;\n  }\n  else {\n    new_file_position = *(ushort *)(file_info + 0xc) & 0xffffefff;\n  }\n  if (is_read_successful) {\n    *(uint *)(file_info + 0x54) = new_file_position;\n  }\n  if (!is_read_successful) {\n    *(short *)(file_info + 0xc) = (short)new_file_position;\n  }\n  return;\n}\n\n",
            "called": [
                "_read_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a020",
            "calling": [],
            "imported": false,
            "current_name": "read_and_update_0800a020"
        },
        "FUN_08007f7c": {
            "renaming": {
                "FUN_08007f7c": "set_i2c_slave_receive_callback_08007f7c",
                "obj": "i2c_obj",
                "function": "callback_function",
                "i2c_onSlaveReceive": "slave_receive_callback",
                "HAL_I2C_EnableListen_IT": "enable_i2c_listen_interrupt",
                "handle": "i2c_handle"
            },
            "code": "\nvoid set_i2c_slave_receive_callback_08007f7c(i2c_t_conflict *i2c_obj,_func_void_uint8_t_ptr_int *callback_function)\n\n{\n  if (i2c_obj != (i2c_t_conflict *)0x0) {\n    if (callback_function != (_func_void_uint8_t_ptr_int *)0x0) {\n      i2c_obj->slave_receive_callback = callback_function;\n      enable_i2c_listen_interrupt(&i2c_obj->i2c_handle);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f7c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "set_i2c_slave_receive_callback_08007f7c"
        },
        "FUN_08006d80": {
            "renaming": {
                "FUN_08006d80": "read_adc_value_08006d80",
                "pin": "pin_name",
                "HVar1": "hal_status",
                "uVar2": "adc_value",
                "uhADCxConvertedValue": "converted_value",
                "AdcChannelConf": "adc_channel_config",
                "AdcHandle": "adc_handle",
                "get_adc_channel": "get_channel_num"
            },
            "code": "\nuint16_t read_ADC_value_08006d80(PinName_conflict pin_name)\n\n{\n  HAL_StatusTypeDef_conflict hal_status;\n  uint32_t adc_value;\n  uint16_t converted_value;\n  ADC_ChannelConfTypeDef adc_channel_config;\n  ADC_HandleTypeDef adc_handle;\n  \n  memset(&adc_handle,0,0x30);\n  adc_channel_config.Channel = 0;\n  adc_channel_config.Rank = 0;\n  adc_channel_config.SamplingTime = 0;\n  converted_value = 0;\n  adc_handle.Instance =\n       (ADC_TypeDef *)pin_namemap_peripheral(pin_name,(PinMap_conflict *)PTR_PinMap_ADC_08006e60);\n  if (adc_handle.Instance == (ADC_TypeDef *)0x0) {\n    converted_value = 0;\n  }\n  else {\n    adc_handle.Init.DataAlign = 0;\n    adc_handle.Init.ScanConvMode = 0;\n    adc_handle.Init.ContinuousConvMode = 0;\n    adc_handle.Init.DiscontinuousConvMode = 0;\n    adc_handle.Init.ExternalTrigConv = 0xe0000;\n    adc_handle.State = 0;\n    adc_handle.Init.NbrOfConversion = 1;\n    adc_handle.Init.NbrOfDiscConversion = 0;\n    *PTR_g_current_pin_name_08006e64 = pin_name;\n    hal_status = HAL_ADC_Init(&adc_handle);\n    if (hal_status == HAL_OK) {\n      adc_channel_config.Channel = get_channel_num(pin_name);\n      if (adc_channel_config.Channel < 0x12) {\n        adc_channel_config.Rank = 1;\n        adc_channel_config.SamplingTime = 2;\n        hal_status = HAL_ADC_ConfigChannel(&adc_handle,&adc_channel_config);\n        if (hal_status == HAL_OK) {\n          hal_status = HAL_ADCEx_Calibration_Start(&adc_handle);\n          if (hal_status == HAL_OK) {\n            hal_status = HAL_ADC_Start(&adc_handle);\n            if (hal_status == HAL_OK) {\n              hal_status = HAL_ADC_PollForConversion(&adc_handle,10);\n              if (hal_status == HAL_OK) {\n                adc_value = HAL_ADC_GetState(&adc_handle);\n                if ((adc_value & 0x200) != 0) {\n                  adc_value = HAL_ADC_GetValue(&adc_handle);\n                  converted_value = (uint16_t)adc_value;\n                }\n                hal_status = HAL_ADC_Stop(&adc_handle);\n                if (hal_status == HAL_OK) {\n                  hal_status = HAL_ADC_DeInit(&adc_handle);\n                  if (hal_status != HAL_OK) {\n                    converted_value = 0;\n                  }\n                }\n                else {\n                  converted_value = 0;\n                }\n              }\n              else {\n                converted_value = 0;\n              }\n            }\n            else {\n              converted_value = 0;\n            }\n          }\n          else {\n            converted_value = 0;\n          }\n        }\n        else {\n          converted_value = 0;\n        }\n      }\n      else {\n        converted_value = 0;\n      }\n    }\n    else {\n      converted_value = 0;\n    }\n  }\n  return converted_value;\n}\n\n",
            "called": [
                "get_adc_channel",
                "memset",
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_PollForConversion",
                "HAL_ADC_Stop",
                "HAL_ADC_GetState",
                "pinmap_peripheral",
                "HAL_ADC_DeInit",
                "HAL_ADC_ConfigChannel",
                "HAL_ADC_GetValue",
                "HAL_ADC_Start"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d80",
            "calling": [
                "analogRead"
            ],
            "imported": false,
            "current_name": "read_adc_value_08006d80"
        },
        "FUN_08006c60": {
            "renaming": {
                "FUN_08006c60": "get_adc_pin_function_08006c60",
                "pin": "pin_name",
                "uVar1": "adc_function"
            },
            "code": "\nuint32_t get_ADC_pin_function_08006c60(PinName_conflict pin_name)\n\n{\n  uint32_t adc_function;\n  \n  adc_function = pin_namemap_function(pin_name,(PinMap_conflict *)PTR_PinMap_ADC_08006c78);\n  adc_function = (adc_function << 0xc) >> 0x1b;\n  if (0x10 < adc_function - 1) {\n    adc_function = 0;\n  }\n  return adc_function;\n}\n\n",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c60",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_adc_pin_function_08006c60"
        },
        "FUN_08008e40": {
            "renaming": {
                "FUN_08008e40": "initialize_static_variables_08008e40",
                "__static_initialization_and_destruction_0": "initialize_and_destroy"
            },
            "code": "\nvoid initialize_static_variables_08008e40(void)\n\n{\n  initialize_and_destroy(1,0xffff);\n  return;\n}\n\n",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e40",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_08008e40"
        },
        "FUN_080045c0": {
            "renaming": {
                "FUN_080045c0": "configure_i2_c_080045c0",
                "hi2c": "I2C_handle",
                "bVar1": "is_valid_clock_speed",
                "uVar2": "PCLK1_freq",
                "uVar3": "CCR_value",
                "uVar4": "leading_zeroes_count",
                "uVar5": "duty_cycle",
                "HAL_StatusTypeDef_conflict": "HAL_status",
                "I2C_HandleTypeDef_conflict": "I2C_handleTypeDef",
                "HAL_UNLOCKED": "HAL_UNLOCK",
                "HAL_I2C_MspInit": "I2C_MspInit",
                "HAL_I2C_STATE_RESET": "I2C_STATE_RESET",
                "HAL_I2C_STATE_BUSY": "I2C_STATE_BUSY",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE"
            },
            "code": "\nHAL_status configure_I2C_080045c0(I2C_handleTypeDef *I2C_handle)\n\n{\n  bool is_valid_clock_speed;\n  uint32_t PCLK1_freq;\n  uint CCR_value;\n  uint leading_zeroes_count;\n  uint32_t duty_cycle;\n  \n  if (I2C_handle == (I2C_handleTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (I2C_handle->State == I2C_STATE_RESET) {\n    I2C_handle->Lock = HAL_UNLOCK;\n    I2C_MspInit(I2C_handle);\n  }\n  I2C_handle->State = I2C_STATE_BUSY;\n  I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 & 0xfffffffe;\n  PCLK1_freq = HAL_RCC_GetPCLK1Freq();\n  if (DAT_08004714 < (I2C_handle->Init).ClockSpeed) {\n    is_valid_clock_speed = PCLK1_freq <= DAT_08004720;\n  }\n  else if (DAT_08004718 < PCLK1_freq) {\n    is_valid_clock_speed = false;\n  }\n  else {\n    is_valid_clock_speed = true;\n  }\n  if (is_valid_clock_speed) {\n    return HAL_ERROR;\n  }\n  CCR_value = (uint)((ulonglong)DAT_0800471c * (ulonglong)PCLK1_freq >> 0x32);\n  I2C_handle->Instance->CR2 = CCR_value;\n  if (DAT_08004714 < (I2C_handle->Init).ClockSpeed) {\n    CCR_value = (uint)((ulonglong)DAT_08004724 * (ulonglong)(CCR_value * 300) >> 0x26);\n  }\n  I2C_handle->Instance->TRISE = CCR_value + 1;\n  CCR_value = (I2C_handle->Init).ClockSpeed;\n  if (DAT_08004714 < CCR_value) {\n    duty_cycle = (I2C_handle->Init).DutyCycle;\n    if (duty_cycle == 0) {\n      leading_zeroes_count = count_leading_zeroes((PCLK1_freq - 1) / (CCR_value * 3) + 1 & 0xfff);\n    }\n    else {\n      leading_zeroes_count = count_leading_zeroes((PCLK1_freq - 1) / (CCR_value * 0x19) + 1 & 0xfff);\n    }\n    if (leading_zeroes_count >> 5 == 0) {\n      if (duty_cycle == 0) {\n        PCLK1_freq = (PCLK1_freq - 1) / (CCR_value * 3) + 1 & 0xfff | 0x8000;\n      }\n      else {\n        PCLK1_freq = (PCLK1_freq - 1) / (CCR_value * 0x19) + 1 & 0xfff | 0xc000;\n      }\n    }\n    else {\n      PCLK1_freq = 1;\n    }\n  }\n  else {\n    PCLK1_freq = (PCLK1_freq - 1) / (CCR_value << 1) + 1 & 0xfff;\n    if (PCLK1_freq < 4) {\n      PCLK1_freq = 4;\n    }\n  }\n  I2C_handle->Instance->CCR = PCLK1_freq;\n  I2C_handle->Instance->CR1 = (I2C_handle->Init).GeneralCallMode | (I2C_handle->Init).NoStretchMode;\n  I2C_handle->Instance->OAR1 = (I2C_handle->Init).AddressingMode | (I2C_handle->Init).OwnAddress1;\n  I2C_handle->Instance->OAR2 = (I2C_handle->Init).DualAddressMode | (I2C_handle->Init).OwnAddress2;\n  I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 | 1;\n  I2C_handle->ErrorCode = 0;\n  I2C_handle->State = I2C_STATE_READY;\n  I2C_handle->PreviousState = 0;\n  I2C_handle->Mode = I2C_MODE_NONE;\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_I2C_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045c0",
            "calling": [
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "configure_i2_c_080045c0"
        },
        "FUN_08007e74": {
            "renaming": {
                "FUN_08007e74": "transmit_i2c_data_08007e74",
                "obj": "i2c_object",
                "dev_address": "device_address",
                "data": "data_buffer",
                "size": "data_size",
                "HVar1": "i2c_state",
                "HVar2": "hal_status",
                "uVar3": "start_tick",
                "uVar4": "current_tick",
                "uVar5": "elapsed_time",
                "iVar6": "transmission_status",
                "hi2c": "i2c_handle"
            },
            "code": "\ni2c_status_e_conflict\ntransmit_i2c_data_08007e74(i2c_t_conflict *i2c_object,uint8_t device_address,uint8_t *data_buffer,uint16_t data_size)\n\n{\n  HAL_I2C_StateTypeDef_conflict i2c_state;\n  HAL_StatusTypeDef_conflict hal_status;\n  uint32_t start_tick;\n  uint32_t current_tick;\n  uint elapsed_time;\n  i2c_status_e_conflict transmission_status;\n  I2C_HandleTypeDef_conflict *i2c_handle;\n  \n  start_tick = HAL_GetTick();\n  elapsed_time = 0;\n  transmission_status = I2C_ERROR;\n  do {\n    i2c_handle = &i2c_object->handle;\n    hal_status = HAL_I2C_Master_Transmit_IT(i2c_handle,(ushort)device_address,data_buffer,data_size);\n    if (hal_status == HAL_OK) {\n      transmission_status = I2C_OK;\n      while ((i2c_state = HAL_I2C_GetState(i2c_handle), i2c_state != HAL_I2C_STATE_READY && (transmission_status == I2C_OK))) {\n        current_tick = HAL_GetTick();\n        elapsed_time = current_tick - start_tick;\n        if (elapsed_time < 0x65) {\n          current_tick = HAL_I2C_GetError(i2c_handle);\n          if (current_tick != 0) {\n            transmission_status = I2C_ERROR;\n          }\n        }\n        else {\n          transmission_status = I2C_TIMEOUT;\n        }\n      }\n    }\n    current_tick = HAL_I2C_GetError(i2c_handle);\n  } while ((current_tick == 4) && (elapsed_time < 100));\n  return transmission_status;\n}\n\n",
            "called": [
                "HAL_GetTick",
                "HAL_I2C_Master_Transmit_IT",
                "HAL_I2C_GetState",
                "HAL_I2C_GetError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e74",
            "calling": [
                "endTransmission"
            ],
            "imported": false,
            "current_name": "transmit_i2c_data_08007e74"
        },
        "FUN_08002efe": {
            "renaming": {
                "FUN_08002efe": "send_port_data_08002efe",
                "this": "firmataInstance"
            },
            "code": "\nvoid __firmataInstancecall\nfirmata::FirmataClass::sendPortData_08002efe(FirmataClass *firmataInstance,byte portNumber,int portData)\n\n{\n  FirmataMarshaller::sendPortData_08002efe(&firmataInstance->marshaller,portNumber,(uint16_t)portData);\n  return;\n}\n\n",
            "called": [
                "sendDigitalPort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002efe",
            "calling": [
                "outputPort"
            ],
            "imported": false,
            "current_name": "send_port_data_08002efe"
        },
        "FUN_08002ddc": {
            "renaming": {
                "this": "firmata_instance",
                "FUN_08002ddc": "send_firmware_version_08002ddc"
            },
            "code": "\nvoid __firmata_instancecall firmata::FirmataClass::send_firmware_version_08002ddc(FirmataClass *firmata_instance)\n\n{\n  FirmataMarshaller::sendVersion(&firmata_instance->marshaller,'\\x02','\\x05');\n  return;\n}\n\n",
            "called": [
                "sendVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ddc",
            "calling": [
                "staticReportVersionCallback",
                "begin"
            ],
            "imported": false,
            "current_name": "send_firmware_version_08002ddc"
        },
        "FUN_08009f2c": {
            "renaming": {
                "FUN_08009f2c": "find_byte_in_memory_08009f2c",
                "__s": "memory_address",
                "__c": "byte_to_find",
                "__n": "memory_size",
                "pbVar1": "current_byte_address",
                "pbVar2": "previous_byte_address"
            },
            "code": "\nvoid * find_byte_in_memory_08009f2c(void *memory_address,int byte_to_find,size_t memory_size)\n\n{\n  byte *current_byte_address;\n  byte *previous_byte_address;\n  \n  current_byte_address = (byte *)memory_address;\n  do {\n    previous_byte_address = current_byte_address;\n    if (previous_byte_address == (byte *)(memory_size + (int)memory_address)) {\n      return (void *)0x0;\n    }\n    current_byte_address = previous_byte_address + 1;\n  } while ((uint)*previous_byte_address != (byte_to_find & 0xffU));\n  return previous_byte_address;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f2c",
            "calling": [
                "_vfiprintf_r",
                "_printf_i"
            ],
            "imported": false,
            "current_name": "find_byte_in_memory_08009f2c"
        },
        "FUN_0800a154": {
            "renaming": {
                "FUN_0800a154": "calculate_offset_0800a154",
                "param_1": "undefined",
                "param_2": "base_address",
                "iVar1": "offset"
            },
            "code": "\nint calculate_offset_0800a154(undefined4 undefined,int base_address)\n\n{\n  int offset;\n  \n  offset = *(int *)(base_address + -4) + -4;\n  if (*(int *)(base_address + -4) < 0) {\n    offset = offset + *(int *)(base_address + offset);\n  }\n  return offset;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a154",
            "calling": [
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "calculate_offset_0800a154"
        },
        "FUN_08007f8e": {
            "renaming": {
                "FUN_08007f8e": "set_i2c_slave_transmit_callback_08007f8e",
                "obj": "i2c_conflict_obj",
                "function": "callback_function",
                "i2c_onSlaveTransmit": "slave_transmit_callback",
                "HAL_I2C_EnableListen_IT": "enable_i2c_listen_interrupt",
                "handle": "i2c_handle"
            },
            "code": "\nvoid set_i2c_slave_transmit_callback_08007f8e(i2c_t_conflict *i2c_conflict_obj,_func_void *callback_function)\n\n{\n  if (i2c_conflict_obj != (i2c_t_conflict *)0x0) {\n    if (callback_function != (_func_void *)0x0) {\n      i2c_conflict_obj->slave_transmit_callback = callback_function;\n      enable_i2c_listen_interrupt(&i2c_conflict_obj->i2c_handle);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f8e",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "set_i2c_slave_transmit_callback_08007f8e"
        },
        "FUN_08006b3e": {
            "renaming": {
                "FUN_08006b3e": "map_pin_to_bit_08006b3e",
                "pin": "pin_name",
                "map": "bit_map",
                "uVar1": "bit_map_index"
            },
            "code": "\nvoid map_pin_to_bit_08006b3e(PinName_conflict pin_name,uint32_t *bit_map)\n\n{\n  uint bit_map_index;\n  \n  bit_map_index = (uint)((int)pin_name << 0x18) >> 0x1c;\n  bit_map[bit_map_index] = bit_map[bit_map_index] | 1 << ((int)pin_name & 0xfU);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b3e",
            "calling": [
                "analogWrite",
                "pinMode"
            ],
            "imported": false,
            "current_name": "map_pin_to_bit_08006b3e"
        },
        "FUN_08006262": {
            "renaming": {
                "FUN_08006262": "update_ti_mx_channel_state_08006262",
                "TIMx": "tim_instance",
                "Channel": "channel_num",
                "ChannelState": "channel_state",
                "CCER": "ccer_reg"
            },
            "code": "\nvoid update_TIMx_ChannelState_08006262(TIM_TypeDef_conflict *tim_instance,uint32_t channel_num,uint32_t channel_state)\n\n{\n  tim_instance->ccer_reg = tim_instance->ccer_reg & ~(1 << (channel_num & 0xff));\n  tim_instance->ccer_reg = tim_instance->ccer_reg | channel_state << (channel_num & 0xff);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006262",
            "calling": [
                "HAL_TIM_PWM_Stop",
                "HAL_TIM_OC_Stop_IT",
                "HAL_TIM_OC_Start_IT",
                "HAL_TIM_PWM_Start"
            ],
            "imported": false,
            "current_name": "update_ti_mx_channel_state_08006262"
        },
        "FUN_08007110": {
            "renaming": {
                "FUN_08007110": "FUNC_08007110"
            },
            "code": "\nvoid FUNC_08007110(TIM_HandleTypeDef_conflict *htim)\n\n{\n  timer_disable_clock(htim);\n  return;\n}\n\n",
            "called": [
                "timer_disable_clock"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08007110",
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "imported": false,
            "current_name": "FUNC_08007110"
        },
        "FUN_08007594": {
            "renaming": {
                "FUN_08007594": "get_timer_instance_type_08007594",
                "tim": "timer_instance"
            },
            "code": "\nuint8_t get_timer_instance_type_08007594(TIM_TypeDef_conflict *timer_instance)\n\n{\n  if (timer_instance == (TIM_TypeDef_conflict *)0xffffffff) {\n    return '\\0';\n  }\n  if (timer_instance == DAT_080075d0) {\n    return '\\x01';\n  }\n  if (DAT_080075d0 < timer_instance) {\n    if (timer_instance == DAT_080075d4) {\n      return '\\x01';\n    }\n    if (timer_instance == (TIM_TypeDef_conflict *)&DAT_080075d4[0x379].DMAR) {\n      return '\\x02';\n    }\n  }\n  else if (timer_instance == (TIM_TypeDef_conflict *)0x40000000) {\n    return '\\x01';\n  }\n  iprintf(PTR_s_TIM__Unknown_timer_instanceer_instance_080075d8);\n  return '\\0';\n}\n\n",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007594",
            "calling": [
                "getTimerClkFreq"
            ],
            "imported": false,
            "current_name": "get_timer_instance_type_08007594"
        },
        "FUN_08002cd0": {
            "renaming": {
                "FUN_08002cd0": "handle_system_reset_callback_08002cd0",
                "param_1": "callback_param",
                "code": "function_ptr"
            },
            "code": "\nvoid firmata::FirmataClass::handle_system_reset_callback_08002cd0(void *callback_param)\n\n{\n  if (*(function_ptr **)PTR_currentSystemResetCallback_08002cdc != (function_ptr *)0x0) {\n    (**(function_ptr **)PTR_currentSystemResetCallback_08002cdc)();\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002cd0",
            "calling": [],
            "imported": false,
            "current_name": "handle_system_reset_callback_08002cd0"
        },
        "FUN_08002df6": {
            "renaming": {
                "this": "firmataInstance",
                "puVar1": "firmwareVersionVectorPtr",
                "FirmataMarshaller::sendFirmwareVersion": "sendFirmwareVersion",
                "puVar1[1]": "firmwareVersionMinor",
                "FUN_08002df6": "send_firmware_version_if_available_08002df6"
            },
            "code": "\nvoid __firmataInstancecall firmata::FirmataClass::sendFirmwareVersionIfAvailable_08002df6(FirmataClass *firmataInstance)\n\n{\n  uint8_t *firmwareVersionVectorPtr;\n  \n  if (firmataInstance->firmwareVersionCount == 0) {\n    return;\n  }\n  firmwareVersionVectorPtr = firmataInstance->firmwareVersionVector;\n  sendFirmwareVersion\n            (&firmataInstance->marshaller,*firmwareVersionVectorPtr,firmwareVersionMinor,firmataInstance->firmwareVersionCount - 2,firmwareVersionVectorPtr + 2);\n  return;\n}\n\n",
            "called": [
                "sendFirmwareVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002df6",
            "calling": [
                "begin",
                "staticReportFirmwareCallback"
            ],
            "imported": false,
            "current_name": "send_firmware_version_if_available_08002df6"
        },
        "FUN_080045bc": {
            "renaming": {
                "FUN_080045bc": "do_nothing_080045bc"
            },
            "code": "\nvoid do_nothing_080045bc(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045bc",
            "calling": [
                "HAL_I2C_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_080045bc"
        },
        "FUN_08007118": {
            "renaming": {
                "FUN_08007118": "configure_pwm_pin_08007118",
                "pin": "pin_name",
                "clock_freq": "clock_frequency",
                "period": "pwm_period",
                "value": "pwm_value",
                "do_init": "initialize_pwm",
                "HVar1": "hal_status",
                "uVar2": "timer_clk_freq",
                "uVar3": "pwm_function",
                "timConfig": "timer_output_compare_config",
                "timHandle": "timer_handle"
            },
            "code": "\nvoid configure_pwm_pin_08007118(PinName_conflict pin_name,uint32_t clock_frequency,uint32_t pwm_period,uint32_t pwm_value,\n              uint8_t initialize_pwm)\n\n{\n  HAL_StatusTypeDef_conflict hal_status;\n  uint32_t timer_clk_freq;\n  uint32_t pwm_function;\n  TIM_OC_InitTypeDef timer_output_compare_config;\n  TIM_HandleTypeDef_conflict timer_handle;\n  \n  memset(&timer_handle,0,0x40);\n  timer_output_compare_config.OCMode = 0;\n  timer_output_compare_config.Pulse = 0;\n  timer_output_compare_config.OCPolarity = 0;\n  timer_output_compare_config.OCNPolarity = 0;\n  timer_output_compare_config.OCFastMode = 0;\n  timer_output_compare_config.OCIdleState = 0;\n  timer_output_compare_config.OCNIdleState = 0;\n  timer_handle.Instance =\n       (TIM_TypeDef_conflict *)pin_namemap_peripheral(pin_name,(PinMap_conflict *)PTR_PinMap_PWM_080071dc);\n  if (timer_handle.Instance != (TIM_TypeDef_conflict *)0x0) {\n    timer_clk_freq = getTimerClkFreq(timer_handle.Instance);\n    timer_handle.Init.Prescaler = timer_clk_freq / clock_frequency - 1;\n    timer_handle.Init.Period = pwm_period - 1;\n    timer_handle.Init.ClockDivision = 0;\n    timer_handle.Init.CounterMode = 0;\n    timer_handle.Init.RepetitionCounter = 0;\n    timer_handle.State = HAL_TIM_STATE_RESET;\n    if (initialize_pwm == '\\x01') {\n      *PTR_g_current_pin_name_080071e0 = pin_name;\n      hal_status = HAL_TIM_PWM_Init(&timer_handle);\n      if (hal_status != HAL_OK) {\n        return;\n      }\n    }\n    timer_clk_freq = get_pwm_channel(pin_name);\n    if ((((timer_clk_freq == 0) || (timer_clk_freq == 4)) || (timer_clk_freq == 8)) || ((timer_clk_freq == 0xc || (timer_clk_freq == 0x18)))) {\n      timer_output_compare_config.OCMode = 0x60;\n      timer_output_compare_config.OCPolarity = 0;\n      timer_output_compare_config.OCFastMode = 0;\n      timer_output_compare_config.OCNPolarity = 0;\n      timer_output_compare_config.OCNIdleState = 0;\n      timer_output_compare_config.OCIdleState = 0;\n      timer_output_compare_config.Pulse = pwm_value;\n      hal_status = HAL_TIM_PWM_ConfigChannel(&timer_handle,&timer_output_compare_config,timer_clk_freq);\n      if (hal_status == HAL_OK) {\n        pwm_function = pin_namemap_function(pin_name,(PinMap_conflict *)PTR_PinMap_PWM_080071dc);\n        if ((pwm_function & 0x100000) == 0) {\n          HAL_TIM_PWM_Start(&timer_handle,timer_clk_freq);\n        }\n        else {\n          HAL_TIMEx_PWMN_Start(&timer_handle,timer_clk_freq);\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "pinmap_function",
                "memset",
                "get_pwm_channel",
                "HAL_TIM_PWM_Init",
                "getTimerClkFreq",
                "HAL_TIMEx_PWMN_Start",
                "pinmap_peripheral",
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_PWM_Start"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007118",
            "calling": [
                "analogWrite"
            ],
            "imported": false,
            "current_name": "configure_pwm_pin_08007118"
        },
        "FUN_08001be8": {
            "renaming": {
                "FUN_08001be8": "initialize_static_variables_08001be8"
            },
            "code": "\nvoid initialize_static_variables_08001be8(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001be8",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_08001be8"
        },
        "FUN_08005a68": {
            "renaming": {
                "FUN_08005a68": "configure_rcc_clocks_08005a68",
                "RCC_ClkInitTypeDef_conflict": "RCC_Clock_Init",
                "pFLatency": "flash_latency",
                "ClockType": "clock_type",
                "SYSCLKSource": "system_clock_source",
                "AHBCLKDivider": "AHB_clock_divider",
                "APB1CLKDivider": "APB1_clock_divider",
                "APB2CLKDivider": "APB2_clock_divider"
            },
            "code": "\nvoid configure_RCC_clocks_08005a68(RCC_Clock_Init *RCC_ClkInitStruct,uint32_t *flash_latency)\n\n{\n  int iVar1;\n  \n  RCC_ClkInitStruct->clock_type = 0xf;\n  iVar1 = DAT_08005a9c;\n  RCC_ClkInitStruct->system_clock_source = *(uint *)(DAT_08005a9c + 4) & 3;\n  RCC_ClkInitStruct->AHB_clock_divider = *(uint *)(iVar1 + 4) & 0xf0;\n  RCC_ClkInitStruct->APB1_clock_divider = *(uint *)(iVar1 + 4) & 0x700;\n  RCC_ClkInitStruct->APB2_clock_divider = *(uint *)(iVar1 + 4) >> 3 & 0x700;\n  *flash_latency = *DAT_08005aa0 & 7;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a68",
            "calling": [
                "getTimerClkFreq"
            ],
            "imported": false,
            "current_name": "configure_rcc_clocks_08005a68"
        },
        "FUN_08008f78": {
            "renaming": {
                "FUN_08008f78": "initialize_gpio_irq_08008f78",
                "__initialize_p": "is_initialized",
                "__priority": "priority",
                "puVar1": "gpio_irq_conf_ptr"
            },
            "code": "\nvoid initialize_gpio_irq_08008f78(int is_initialized,int priority)\n\n{\n  undefined *gpio_irq_conf_ptr;\n  \n  gpio_irq_conf_ptr = PTR_gpio_irq_conf_08009018;\n  if (is_initialized != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    *PTR_gpio_irq_conf_08009018 = 6;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0xc) = 0;\n    gpio_irq_conf_ptr[0x14] = 7;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x20) = 0;\n    gpio_irq_conf_ptr[0x28] = 8;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x34) = 0;\n    gpio_irq_conf_ptr[0x3c] = 9;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x48) = 0;\n    gpio_irq_conf_ptr[0x50] = 10;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x5c) = 0;\n    gpio_irq_conf_ptr[100] = 0x17;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x70) = 0;\n    gpio_irq_conf_ptr[0x78] = 0x17;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x84) = 0;\n    gpio_irq_conf_ptr[0x8c] = 0x17;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x98) = 0;\n    gpio_irq_conf_ptr[0xa0] = 0x17;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0xac) = 0;\n    gpio_irq_conf_ptr[0xb4] = 0x17;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0xc0) = 0;\n    gpio_irq_conf_ptr[200] = 0x28;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0xd4) = 0;\n    gpio_irq_conf_ptr[0xdc] = 0x28;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0xe8) = 0;\n    gpio_irq_conf_ptr[0xf0] = 0x28;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0xfc) = 0;\n    gpio_irq_conf_ptr[0x104] = 0x28;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x110) = 0;\n    gpio_irq_conf_ptr[0x118] = 0x28;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x124) = 0;\n    gpio_irq_conf_ptr[300] = 0x28;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x138) = 0;\n    __aeabi_atexit(0,DAT_08009020,PTR___dso_handle_0800901c);\n  }\n  return;\n}\n\n",
            "called": [
                "__aeabi_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f78",
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "imported": false,
            "current_name": "initialize_gpio_irq_08008f78"
        },
        "FUN_08002dea": {
            "renaming": {
                "FUN_08002dea": "print_firmata_version_08002dea",
                "printVersion": "print_firmata_version_info"
            },
            "code": "\nvoid firmata::FirmataClass::print_firmata_version_08002dea(void *context)\n\n{\n  if (context != (void *)0x0) {\n    print_firmata_version_08002dea_info((FirmataClass *)context);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002dea",
            "calling": [],
            "imported": false,
            "current_name": "print_firmata_version_08002dea"
        },
        "FUN_08008d30": {
            "renaming": {
                "this": "serialConnection",
                "peripheral": "peripheralDevice",
                "PVar1": "pinName",
                "extraout_r1": "context1",
                "ctx": "context2",
                "extraout_r1_00": "context3",
                "FUN_08008d30": "initialize_serial_connection_08008d30"
            },
            "code": "\ninitializeSerialConnection_08008d30 * __serialConnectioncall initializeSerialConnection_08008d30::initializeSerialConnection_08008d30(initializeSerialConnection_08008d30 *serialConnection,void *peripheralDevice)\n\n{\n  PinName_conflict pinName;\n  EVP_PKEY_CTX *context1;\n  EVP_PKEY_CTX *context2;\n  EVP_PKEY_CTX *context3;\n  \n  (serialConnection->super_Stream).super_Print.write_error = 0;\n  (serialConnection->super_Stream)._timeout = 1000;\n  (serialConnection->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)PTR_PTR_write_1_08008d7c;\n  if (serialConnection == (initializeSerialConnection_08008d30 *)PTR_Serial2_08008d80) {\n    setRx(serialConnection,0);\n    setTx(serialConnection,1);\n    context2 = context3;\n  }\n  else {\n    pinName = pinmap_pin(peripheralDevice,(PinMap_conflict *)PTR_PinMap_UART_RX_08008d84);\n    (serialConnection->_serial).pin_rx = pinName;\n    pinName = pinmap_pin(peripheralDevice,(PinMap_conflict *)PTR_PinMap_UART_TX_08008d88);\n    (serialConnection->_serial).pin_tx = pinName;\n    context2 = context1;\n  }\n  init(serialConnection,context2);\n  return serialConnection;\n}\n\n",
            "called": [
                "init",
                "pinmap_pin",
                "setTx",
                "setRx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d30",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_serial_connection_08008d30"
        },
        "FUN_0800734a": {
            "renaming": {
                "FUN_0800734a": "find_peripheral_pin_0800734a",
                "peripheral": "peripheral_ptr",
                "map": "pin_map",
                "PVar1": "pin_name",
                "NC": "no_connection"
            },
            "code": "\nPinName_conflict find_peripheral_pin_0800734a(void *peripheral_ptr,PinMap_conflict *pin_map)\n\n{\n  PinName_conflict pin_name;\n  \n  if (peripheral_ptr != (void *)0x0) {\n    pin_name = pinpin_map_find_pin(peripheral_ptr,pin_map);\n    return pin_name;\n  }\n  return no_connection;\n}\n\n",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800734a",
            "calling": [
                "uart_debug_init",
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "find_peripheral_pin_0800734a"
        },
        "FUN_08000aec": {
            "renaming": {
                "FUN_08000aec": "initialize_pins_08000aec",
                "bVar1": "is_valid_pin",
                "PVar2": "pin_name",
                "uVar3": "digital_pin_number",
                "uVar4": "pin_index",
                "disableI2CPins": "disable_i2c_pins",
                "NC": "not_connected",
                "pinNametoDigitalPin": "get_digital_pin_from_name",
                "setPinModeCallback": "set_pin_mode_callback",
                "(byte)uVar4": "pin_mode"
            },
            "code": "\nvoid initialize_pins_08000aec(void)\n\n{\n  bool is_valid_pin;\n  PinName_conflict pin_name;\n  uint32_t digital_pin_number;\n  uint pin_index;\n  \n  *PTR_isResetting_08000bc0 = 1;\n  if (*PTR_isI2CEnabled_08000bc4 != '\\0') {\n    disable_i2c_pins();\n  }\n  for (pin_index = 0; pin_index < 5; pin_index = pin_index + 1 & 0xff) {\n    PTR_reportPINs_08000bc8[pin_index] = 0;\n    PTR_portConfigInputs_08000bcc[pin_index] = 0;\n    PTR_previousPINs_08000bd0[pin_index] = 0;\n  }\n  for (pin_index = 0; pin_index < 0x3c; pin_index = pin_index + 1 & 0xff) {\n    if ((pin_index - 0x2e & 0xff) < 0xe) {\n      if (pin_index < 0x3c) {\n        pin_name = PTR_digitalPin_08000bd4[pin_index];\n      }\n      else {\n        pin_name = not_connected;\n      }\n      digital_pin_number = get_digital_pin_from_name(pin_name);\n      if (digital_pin_number == 0) {\n        is_valid_pin = false;\n      }\n      else {\n        if (pin_index < 0x3c) {\n          pin_name = PTR_digitalPin_08000bd4[pin_index];\n        }\n        else {\n          pin_name = not_connected;\n        }\n        digital_pin_number = get_digital_pin_from_name(pin_name);\n        if (digital_pin_number == 1) {\n          is_valid_pin = false;\n        }\n        else {\n          is_valid_pin = true;\n        }\n      }\n    }\n    else {\n      is_valid_pin = false;\n    }\n    if (is_valid_pin) {\n      set_pin_mode_callback(pin_mode,2);\n    }\n    else {\n      if ((((pin_index < 0x3c) && (PTR_digitalPin_08000bd4[pin_index] != not_connected)) &&\n          (digital_pin_number = get_digital_pin_from_name(PTR_digitalPin_08000bd4[pin_index]), digital_pin_number != 0)) &&\n         (digital_pin_number = get_digital_pin_from_name(PTR_digitalPin_08000bd4[pin_index]), digital_pin_number != 1)) {\n        is_valid_pin = true;\n      }\n      if (is_valid_pin) {\n        set_pin_mode_callback(pin_mode,1);\n      }\n    }\n    PTR_servoPinMap_08000bd8[pin_index] = 0xff;\n  }\n  *(undefined4 *)PTR_analogInputsToReport_08000bdc = 0;\n  *PTR_detachedServoCount_08000be0 = 0;\n  *PTR_servoCount_08000be4 = 0;\n  *PTR_isResetting_08000bc0 = 0;\n  return;\n}\n\n",
            "called": [
                "disableI2CPins",
                "pinNametoDigitalPin",
                "setPinModeCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000aec",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "initialize_pins_08000aec"
        },
        "FUN_080068d6": {
            "renaming": {
                "FUN_080068d6": "initialize_uart_receive_080068d6",
                "huart": "uart_handle",
                "pData": "rx_buffer",
                "Size": "rx_buffer_size",
                "HAL_StatusTypeDef_conflict": "uart_receive_status",
                "HAL_UART_STATE_READY": "uart_ready_state",
                "HAL_BUSY": "uart_busy_status",
                "HAL_ERROR": "uart_error_status",
                "HAL_LOCKED": "uart_locked_status",
                "pRxBuffPtr": "rx_buffer_pointer",
                "RxXferSize": "rx_transfer_size",
                "RxXferCount": "rx_transfer_count",
                "ErrorCode": "uart_error_code",
                "HAL_UART_STATE_BUSY_RX": "uart_busy_receive_state",
                "HAL_UNLOCKED": "uart_unlocked_status",
                "Instance": "uart_instance",
                "CR1": "uart_control_register_1",
                "CR3": "uart_control_register_3"
            },
            "code": "\nuart_receive_status\ninitialize_uart_receive_080068d6(UART_HandleTypeDef *uart_handle,uint8_t *rx_buffer,uint16_t rx_buffer_size)\n\n{\n  if (uart_handle->RxState != uart_ready_state) {\n    return uart_busy_status;\n  }\n  if (rx_buffer == (uint8_t *)0x0) {\n    return uart_error_status;\n  }\n  if (rx_buffer_size == 0) {\n    return uart_error_status;\n  }\n  if (uart_handle->Lock != uart_locked_status) {\n    uart_handle->rx_buffer_pointer = rx_buffer;\n    uart_handle->rx_transfer_size = rx_buffer_size;\n    uart_handle->rx_transfer_count = rx_buffer_size;\n    uart_handle->uart_error_code = 0;\n    uart_handle->RxState = uart_busy_receive_state;\n    uart_handle->Lock = uart_unlocked_status;\n    uart_handle->uart_instance->uart_control_register_1 = uart_handle->uart_instance->uart_control_register_1 | 0x100;\n    uart_handle->uart_instance->uart_control_register_3 = uart_handle->uart_instance->uart_control_register_3 | 1;\n    uart_handle->uart_instance->uart_control_register_1 = uart_handle->uart_instance->uart_control_register_1 | 0x20;\n    return HAL_OK;\n  }\n  return uart_busy_status;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080068d6",
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "imported": false,
            "current_name": "initialize_uart_receive_080068d6"
        },
        "FUN_080032a2": {
            "renaming": {
                "this": "marshaller",
                "string": "message",
                "bytec": "message_length",
                "FUN_080032a2": "send_sysex_with_string_080032a2"
            },
            "code": "\nvoid __marshallercall firmata::FirmataMarshaller::send_sysex_with_string_080032a2(FirmataMarshaller *marshaller,char *message)\n\n{\n  size_t message_length;\n  \n  message_length = strlen(message);\n  sendSysex(marshaller,'q',message_length,(uint8_t *)message);\n  return;\n}\n\n",
            "called": [
                "sendSysex",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080032a2",
            "calling": [
                "sendString"
            ],
            "imported": false,
            "current_name": "send_sysex_with_string_080032a2"
        },
        "FUN_08009e28": {
            "renaming": {
                "FUN_08009e28": "process_data_08009e28",
                "param_1": "data_ptr",
                "param_2": "callback_func",
                "param_3": "arg1",
                "param_4": "arg2",
                "piVar3": "list_ptr",
                "iVar4": "item_ptr",
                "iVar6": "count",
                "uVar1": "result",
                "uVar5": "aggregate_result"
            },
            "code": "\nuint process_data_08009e28(int data_ptr,code *callback_func,undefined4 arg1,undefined4 arg2)\n\n{\n  uint result;\n  int iVar2;\n  int *list_ptr;\n  int item_ptr;\n  uint aggregate_result;\n  int count;\n  \n  aggregate_result = 0;\n  for (list_ptr = (int *)(data_ptr + 0x48); list_ptr != (int *)0x0; list_ptr = (int *)*list_ptr) {\n    item_ptr = list_ptr[2];\n    count = list_ptr[1];\n    while (count = count + -1, -1 < count) {\n      if ((1 < *(ushort *)(item_ptr + 0xc)) && (iVar2 = *(short *)(item_ptr + 0xe) + 1, iVar2 != 0)) {\n        result = (*callback_func)(data_ptr,item_ptr,arg1,iVar2,arg2);\n        aggregate_result = aggregate_result | result;\n      }\n      item_ptr = item_ptr + 0x68;\n    }\n  }\n  return aggregate_result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009e28",
            "calling": [
                "_cleanup_r"
            ],
            "imported": false,
            "current_name": "process_data_08009e28"
        },
        "FUN_0800a01c": {
            "renaming": {
                "FUN_0800a01c": "get_process_id_0800a01c",
                "__pid_t": "pid_t"
            },
            "code": "\npid_t get_process_id_0800a01c(void)\n\n{\n  return 1;\n}\n\n",
            "called": [
                "_getpid"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a01c",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "get_process_id_0800a01c"
        },
        "FUN_08006390": {
            "renaming": {
                "FUN_08006390": "enable_tim_channel_08006390",
                "htim": "tim_handle",
                "Channel": "channel_num",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "pTVar1": "tim_instance",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "\nHAL_StatusTypeDef enable_tim_channel_08006390(TIM_HandleTypeDef_conflict *tim_handle,uint32_t channel_num)\n\n{\n  TIM_TypeDef *tim_instance;\n  \n  TIM_CCxchannel_numCmd(tim_handle->Instance,channel_num,1);\n  tim_instance = tim_handle->Instance;\n  if (tim_instance == DAT_080063bc) {\n    tim_instance->BDTR = tim_instance->BDTR | 0x8000;\n  }\n  tim_handle->Instance->CR1 = tim_handle->Instance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006390",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "enable_tim_channel_08006390"
        },
        "FUN_08009f48": {
            "renaming": {
                "FUN_08009f48": "do_nothing_08009f48"
            },
            "code": "\nvoid do_nothing_08009f48(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f48",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_08009f48"
        },
        "FUN_08004d6a": {
            "renaming": {
                "FUN_08004d6a": "do_nothing_08004d6a"
            },
            "code": "\nvoid do_nothing_08004d6a(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d6a",
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004d6a"
        },
        "FUN_08008730": {
            "renaming": {
                "FUN_08008730": "transmit_data_08008730",
                "huart": "uart_handle",
                "bVar1": "uart_index",
                "uVar2": "uart_index_uint",
                "iVar3": "callback_return_value",
                "iVar4": "callback_obj",
                "HAL_UART_Transmit_IT": "transmit_data_it"
            },
            "code": "\nvoid transmit_data_08008730(UART_HandleTypeDef *uart_handle)\n\n{\n  byte uart_index;\n  int callback_return_value;\n  int callback_obj;\n  uint uart_index_uint;\n  \n  uart_index = uart_index(uart_handle);\n  uart_index_uint = (uint)uart_index;\n  callback_obj = *(int *)(PTR_tx_callback_obj_08008770 + uart_index_uint * 4);\n  if ((uart_index_uint < 5) &&\n     (callback_return_value = (**(code **)(PTR_tx_callback_08008774 + uart_index_uint * 4))(callback_obj), callback_return_value != -1)) {\n    transmit_data_08008730_it\n              (*(UART_HandleTypeDef **)\n                (PTR_uart_handlers_08008778 + (uint)*(byte *)(callback_obj + 0x44) * 4),\n               (uint8_t *)(*(int *)(callback_obj + 100) + (uint)*(ushort *)(callback_obj + 0x6a)),1);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008730",
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "imported": false,
            "current_name": "transmit_data_08008730"
        },
        "FUN_08005460": {
            "renaming": {
                "FUN_08005460": "configure_rcc_oscillator_08005460",
                "RCC_OscInitStruct": "RCC_Oscillator_Init",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "HVar3": "status",
                "uVar4": "tick_start",
                "uVar5": "oscillator_state",
                "bVar6": "flag",
                "tmpreg": "temporary_register"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nHAL_StatusTypeDef_conflict configure_RCC_Oscillator_08005460(RCC_OscInitTypeDef_conflict *RCC_Oscillator_Init)\n\n{\n  uint *ptr1;\n  uint *ptr2;\n  HAL_StatusTypeDef_conflict status;\n  uint32_t tick_start;\n  uint32_t oscillator_state;\n  bool flag;\n  uint32_t temporary_register;\n  \n  ptr1 = DAT_08005720;\n  if ((RCC_Oscillator_Init->OscillatorType & 1) != 0) {\n    if (((DAT_08005720[1] & 0xc) == 4) ||\n       (((DAT_08005720[1] & 0xc) == 8 && ((DAT_08005720[1] & 0x10000) != 0)))) {\n      if (((*DAT_08005720 & 0x20000) != 0) && (RCC_Oscillator_Init->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      oscillator_state = RCC_Oscillator_Init->HSEState;\n      if (oscillator_state == 0x10000) {\n        *DAT_08005720 = *DAT_08005720 | 0x10000;\n      }\n      else if (oscillator_state == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (oscillator_state == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        *DAT_08005720 = *DAT_08005720 & 0xfffeffff;\n        *ptr1 = *ptr1 & 0xfffbffff;\n      }\n      if (RCC_Oscillator_Init->HSEState == 0) {\n        oscillator_state = HAL_GetTick();\n        while ((*DAT_08005720 & 0x20000) != 0) {\n          tick_start = HAL_GetTick();\n          if (100 < tick_start - oscillator_state) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        oscillator_state = HAL_GetTick();\n        while ((*DAT_08005720 & 0x20000) == 0) {\n          tick_start = HAL_GetTick();\n          if (100 < tick_start - oscillator_state) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_Oscillator_Init->OscillatorType & 2) != 0) {\n    if (((DAT_08005720[1] & 0xc) == 0) ||\n       (((DAT_08005720[1] & 0xc) == 8 && ((DAT_08005720[1] & 0x10000) == 0)))) {\n      if (((*DAT_08005720 & 2) != 0) && (RCC_Oscillator_Init->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      *DAT_08005720 = *DAT_08005720 & 0xffffff07 | RCC_Oscillator_Init->HSICalibrationValue << 3;\n    }\n    else if (RCC_Oscillator_Init->HSIState == 0) {\n      *DAT_08005724 = 0;\n      oscillator_state = HAL_GetTick();\n      while ((*DAT_08005720 & 2) != 0) {\n        tick_start = HAL_GetTick();\n        if (2 < tick_start - oscillator_state) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005724 = 1;\n      oscillator_state = HAL_GetTick();\n      while ((*DAT_08005720 & 2) == 0) {\n        tick_start = HAL_GetTick();\n        if (2 < tick_start - oscillator_state) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_08005720 = *DAT_08005720 & 0xffffff07 | RCC_Oscillator_Init->HSICalibrationValue << 3;\n    }\n  }\n  if ((RCC_Oscillator_Init->OscillatorType & 8) != 0) {\n    if (RCC_Oscillator_Init->LSIState == 0) {\n      *DAT_08005728 = 0;\n      oscillator_state = HAL_GetTick();\n      while ((DAT_08005720[9] & 2) != 0) {\n        tick_start = HAL_GetTick();\n        if (2 < tick_start - oscillator_state) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005728 = 1;\n      oscillator_state = HAL_GetTick();\n      while ((DAT_08005720[9] & 2) == 0) {\n        tick_start = HAL_GetTick();\n        if (2 < tick_start - oscillator_state) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((RCC_Oscillator_Init->OscillatorType & 4) != 0) {\n    flag = (DAT_08005720[7] & 0x10000000) == 0;\n    if (flag) {\n      DAT_08005720[7] = DAT_08005720[7] | 0x10000000;\n    }\n    if ((*DAT_0800572c & 0x100) == 0) {\n      *DAT_0800572c = *DAT_0800572c | 0x100;\n      oscillator_state = HAL_GetTick();\n      while ((*DAT_0800572c & 0x100) == 0) {\n        tick_start = HAL_GetTick();\n        if (100 < tick_start - oscillator_state) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    ptr2 = DAT_08005838;\n    ptr1 = DAT_08005720;\n    oscillator_state = RCC_Oscillator_Init->LSEState;\n    if (oscillator_state == 1) {\n      DAT_08005720[8] = DAT_08005720[8] | 1;\n    }\n    else if (oscillator_state == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (oscillator_state == 5) {\n      DAT_08005838[8] = DAT_08005838[8] | 4;\n      ptr2[8] = ptr2[8] | 1;\n    }\n    else {\n      DAT_08005720[8] = DAT_08005720[8] & 0xfffffffe;\n      ptr1[8] = ptr1[8] & 0xfffffffb;\n    }\n    if (RCC_Oscillator_Init->LSEState == 0) {\n      oscillator_state = HAL_GetTick();\n      while ((DAT_08005838[8] & 2) != 0) {\n        tick_start = HAL_GetTick();\n        if (5000 < tick_start - oscillator_state) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      oscillator_state = HAL_GetTick();\n      while ((DAT_08005720[8] & 2) == 0) {\n        tick_start = HAL_GetTick();\n        if (5000 < tick_start - oscillator_state) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (flag) {\n      DAT_08005838[7] = DAT_08005838[7] & 0xefffffff;\n    }\n  }\n  oscillator_state = (RCC_Oscillator_Init->PLL).PLLState;\n  if (oscillator_state == 0) {\n    status = HAL_OK;\n  }\n  else if ((DAT_08005838[1] & 0xc) == 8) {\n    status = HAL_ERROR;\n  }\n  else if (oscillator_state == 2) {\n    *DAT_0800583c = 0;\n    oscillator_state = HAL_GetTick();\n    do {\n      if ((*DAT_08005838 & 0x2000000) == 0) {\n        if ((RCC_Oscillator_Init->PLL).PLLSource == 0x10000) {\n          DAT_08005838[1] = DAT_08005838[1] & 0xfffdffff | RCC_Oscillator_Init->HSEPredivValue;\n        }\n        DAT_08005838[1] =\n             DAT_08005838[1] & 0xffc2ffff |\n             (RCC_Oscillator_Init->PLL).PLLSource | (RCC_Oscillator_Init->PLL).PLLMUL;\n        *DAT_0800583c = 1;\n        oscillator_state = HAL_GetTick();\n        do {\n          if ((*DAT_08005838 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          tick_start = HAL_GetTick();\n        } while (tick_start - oscillator_state < 3);\n        return HAL_TIMEOUT;\n      }\n      tick_start = HAL_GetTick();\n    } while (tick_start - oscillator_state < 3);\n    status = HAL_TIMEOUT;\n  }\n  else {\n    *DAT_0800583c = 0;\n    oscillator_state = HAL_GetTick();\n    do {\n      if ((*DAT_08005838 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      tick_start = HAL_GetTick();\n    } while (tick_start - oscillator_state < 3);\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005460",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configure_rcc_oscillator_08005460"
        },
        "FUN_08008854": {
            "renaming": {
                "FUN_08008854": "read_file_contents_08008854",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "pointer_to_data",
                "dir_UNUSED": "directory_path"
            },
            "code": "\nint read_file_contents_08008854(int file_descriptor,int pointer_to_data,int directory_path)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008854",
            "calling": [
                "_lseek_r"
            ],
            "imported": false,
            "current_name": "read_file_contents_08008854"
        },
        "FUN_08004d6c": {
            "renaming": {
                "FUN_08004d6c": "i2c_read_data_08004d6c",
                "hi2c": "i2c_handle",
                "puVar1": "data_ptr",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "XferCount": "data_count",
                "XferOptions": "transfer_options",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "State": "i2c_state",
                "PreviousState": "previous_i2c_state",
                "Mode": "i2c_mode",
                "pBuffPtr": "buffer_ptr"
            },
            "code": "\nHAL_StatusTypeDef i2c_read_data_08004d6c(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  uint8_t *data_ptr;\n  \n  if (i2c_handle->i2c_state == HAL_I2C_STATE_BUSY_RX) {\n    if (i2c_handle->data_count < 4) {\n      if (i2c_handle->data_count - 2 < 2) {\n        if (i2c_handle->transfer_options == 2) {\n          i2c_handle->i2c_instance->CR1 = i2c_handle->i2c_instance->CR1 | 0x400;\n        }\n        else {\n          i2c_handle->i2c_instance->CR1 = i2c_handle->i2c_instance->CR1 & 0xfffffbff;\n          i2c_handle->i2c_instance->CR1 = i2c_handle->i2c_instance->CR1 | 0x800;\n        }\n        i2c_handle->i2c_instance->CR2 = i2c_handle->i2c_instance->CR2 & 0xfffffbff;\n      }\n      else {\n        if (i2c_handle->transfer_options == 2) {\n          i2c_handle->i2c_instance->CR1 = i2c_handle->i2c_instance->CR1 | 0x400;\n        }\n        else {\n          i2c_handle->i2c_instance->CR1 = i2c_handle->i2c_instance->CR1 & 0xfffffbff;\n        }\n        i2c_handle->i2c_instance->CR2 = i2c_handle->i2c_instance->CR2 & 0xfffff8ff;\n        data_ptr = i2c_handle->buffer_ptr;\n        i2c_handle->buffer_ptr = data_ptr + 1;\n        *data_ptr = (uint8_t)i2c_handle->i2c_instance->data_register;\n        i2c_handle->data_count = i2c_handle->data_count - 1;\n        i2c_handle->i2c_state = HAL_I2C_STATE_READY;\n        i2c_handle->previous_i2c_state = 0;\n        if (i2c_handle->i2c_mode == HAL_I2C_MODE_MEM) {\n          i2c_handle->i2c_mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(i2c_handle);\n        }\n        else {\n          i2c_handle->i2c_mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(i2c_handle);\n        }\n      }\n    }\n    else {\n      data_ptr = i2c_handle->buffer_ptr;\n      i2c_handle->buffer_ptr = data_ptr + 1;\n      *data_ptr = (uint8_t)i2c_handle->i2c_instance->data_register;\n      i2c_handle->data_count = i2c_handle->data_count - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d6c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_read_data_08004d6c"
        },
        "FUN_08007760": {
            "renaming": {
                "FUN_08007760": "handle_timer_interrupt_08007760",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "HAL_TIM_IRQHandler": "handle_tim_interrupt"
            },
            "code": "\nvoid handle_timer_interrupt_08007760(void)\n\n{\n  if (*(TIM_HandleTypeDef **)PTR_timer_handles_08007770 !=\n      (TIM_HandleTypeDef *)0x0) {\n    handle_tim_interrupt(*(TIM_HandleTypeDef **)PTR_timer_handles_08007770);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007760",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007760"
        },
        "FUN_08008850": {
            "renaming": {
                "FUN_08008850": "check_file_existence_08008850",
                "file_UNUSED": "file_path"
            },
            "code": "\nint check_file_existence_08008850(int file_path)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008850",
            "calling": [
                "_isatty_r"
            ],
            "imported": false,
            "current_name": "check_file_existence_08008850"
        },
        "FUN_08002fc2": {
            "renaming": {
                "this": "self",
                "FUN_08002fc2": "update_pin_state_08002fc2"
            },
            "code": "\nvoid __selfcall firmata::FirmataClass::updatePinState_08002fc2(FirmataClass *self,byte pin,int state)\n\n{\n  self->pinState[pin] = state;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fc2",
            "calling": [
                "digitalWriteCallback",
                "analogWriteCallback",
                "setPinValueCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "update_pin_state_08002fc2"
        },
        "FUN_08008afa": {
            "renaming": {
                "_this": "serial",
                "FUN_08008afa": "calculate_rx_buffer_size_08008afa",
                "_serial": "serial_data",
                "rx_head": "head_index",
                "rx_tail": "tail_index"
            },
            "code": "\nint _serialcall HardwareSerial::calculate_rx_buffer_size_08008afa(HardwareSerial *this)\n\n{\n  return ((this->serial_data).head_index + 0x40) - (uint)(this->serial_data).tail_index & 0x3f;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008afa",
            "calling": [
                "serialEventRun"
            ],
            "imported": false,
            "current_name": "calculate_rx_buffer_size_08008afa"
        },
        "FUN_08003048": {
            "renaming": {
                "this": "firmataInstance",
                "speed": "baudRate",
                "s": "serialPtr",
                "blinkVersion": "blinkFirmwareVersion",
                "return": "void",
                "FUN_08003048": "initialize_firmata_08003048"
            },
            "code": "\nvoid __firmataInstancecall firmata::FirmataClaserialPtrserialPtr::initializeFirmata_08003048(FirmataClaserialPtrserialPtr *firmataInstance,long baudRate)\n\n{\n  undefined *serialPtr;\n  \n  serialPtr = PTR_Serial2_08003068;\n  HardwareSerial::initializeFirmata_08003048((HardwareSerial *)PTR_Serial2_08003068,baudRate,'\\x06');\n  blinkFirmwareVersion(firmataInstance);\n  initializeFirmata_08003048(firmataInstance,(Stream *)serialPtr);\n  void;\n}\n\n",
            "called": [
                "begin",
                "blinkVersion",
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003048",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "initialize_firmata_08003048"
        },
        "FUN_080038dc": {
            "renaming": {
                "FUN_080038dc": "get_adc_data_080038dc",
                "hadc": "adc_handle",
                "Instance": "adc_instance",
                "DR": "adc_data"
            },
            "code": "\nuint32_t get_adc_data_080038dc(ADC_HandleTypeDef *adc_handle)\n\n{\n  return adc_handle->adc_instance->adc_data;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080038dc",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_adc_data_080038dc"
        },
        "FUN_080025ac": {
            "renaming": {
                "this": "servo",
                "pin": "servo_pin",
                "min": "min_pulse_width",
                "max": "max_pulse_width",
                "timer16_Sequence_t": "timer_sequence",
                "isTimerActive": "check_timer_status",
                "initISR": "initialize_ISR",
                "stimer_t": "timer_structure",
                "FUN_080025ac": "configure_servo_080025ac"
            },
            "code": "\nuint8_t __servocall Servo::configure_servo_080025ac(Servo *servo,int servo_pin,int min_pulse_width,int max_pulse_width)\n\n{\n  undefined *obj;\n  boolean bVar1;\n  int iVar2;\n  timer_sequence timer;\n  \n  if (servo->servoIndex < 0xc) {\n    servo_pinMode(servo_pin,1);\n    PTR_servos_08002628[(uint)servo->servoIndex * 8] =\n         PTR_servos_08002628[(uint)servo->servoIndex * 8] & 0xc0 | (byte)servo_pin & 0x3f;\n    iVar2 = -min_pulse_width + 0x220;\n    if (iVar2 < 0) {\n      iVar2 = -min_pulse_width + 0x223;\n    }\n    servo->min_pulse_width = (int8_t)((uint)(iVar2 << 0x16) >> 0x18);\n    iVar2 = -max_pulse_width + 0x960;\n    if (iVar2 < 0) {\n      iVar2 = -max_pulse_width + 0x963;\n    }\n    servo->max_pulse_width = (int8_t)((uint)(iVar2 << 0x16) >> 0x18);\n    timer = (timer_sequence)\n            (uint)((ulonglong)DAT_0800262c * (ulonglong)servo->servoIndex >> 0x23);\n    bVar1 = check_timer_status(timer);\n    obj = PTR__timer_08002630;\n    if (!bVar1) {\n      PTR__timer_08002630[0x44] = timer;\n      initialize_ISR((timer_structure *)obj);\n    }\n    PTR_servos_08002628[(uint)servo->servoIndex * 8] =\n         PTR_servos_08002628[(uint)servo->servoIndex * 8] | 0x40;\n  }\n  return servo->servoIndex;\n}\n\n",
            "called": [
                "initISR",
                "isTimerActive",
                "pinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025ac",
            "calling": [
                "attachServo",
                "attach"
            ],
            "imported": false,
            "current_name": "configure_servo_080025ac"
        },
        "FUN_08007648": {
            "renaming": {
                "FUN_08007648": "initialize_timer_08007648",
                "obj": "timer_config",
                "period": "timer_period",
                "pulseWidth": "timer_pulse_width",
                "irqHandle": "timer_irq_handle",
                "HVar1": "hal_status",
                "uVar2": "timer_clk_freq",
                "htim": "timer_handle",
                "sConfig": "timer_oc_config"
            },
            "code": "\nvoid initialize_timer_08007648(stimer_t_conflict *timer_config,uint16_t timer_period,uint16_t timer_pulse_width,\n                   _func_void_stimer_t_ptr_uint32_t_conflict *timer_irq_handle)\n\n{\n  HAL_StatusTypeDef_conflict hal_status;\n  uint32_t timer_clk_freq;\n  TIM_HandleTypeDef_conflict *timer_handle;\n  TIM_OC_InitTypeDef timer_oc_config;\n  \n  timer_oc_config.OCMode = 0;\n  timer_oc_config.Pulse = 0;\n  timer_oc_config.OCPolarity = 0;\n  timer_oc_config.OCNPolarity = 0;\n  timer_oc_config.OCFastMode = 0;\n  timer_oc_config.OCIdleState = 0;\n  timer_oc_config.OCNIdleState = 0;\n  timer_handle = &timer_config->handle;\n  timer_config->timer = (TIM_TypeDef_conflict *)0x40000000;\n  (timer_config->handle).Instance = (TIM_TypeDef_conflict *)0x40000000;\n  (timer_config->handle).Init.Period = (uint)timer_period;\n  timer_clk_freq = getTimerClkFreq((TIM_TypeDef_conflict *)0x40000000);\n  (timer_config->handle).Init.Prescaler = (uint)((ulonglong)DAT_080076dc * (ulonglong)timer_clk_freq >> 0x32) - 1;\n  (timer_config->handle).Init.ClockDivision = 0;\n  (timer_config->handle).Init.CounterMode = 0;\n  (timer_config->handle).Init.RepetitionCounter = 0;\n  timer_config->timer_irq_handleOC = timer_irq_handle;\n  timer_oc_config.OCMode = 0;\n  timer_oc_config.OCPolarity = 0;\n  timer_oc_config.OCFastMode = 0;\n  timer_oc_config.OCNPolarity = 0;\n  timer_oc_config.OCIdleState = 0;\n  timer_oc_config.OCNIdleState = 0;\n  timer_oc_config.Pulse = (uint)timer_pulse_width;\n  timer_clk_freq = getTimerIrq(timer_config->timer);\n  HAL_NVIC_SetPriority((IRQn_Type_conflict)timer_clk_freq,0xe,0);\n  timer_clk_freq = getTimerIrq(timer_config->timer);\n  HAL_NVIC_EnableIRQ((IRQn_Type_conflict)timer_clk_freq);\n  hal_status = HAL_TIM_OC_Init(timer_handle);\n  if ((hal_status == HAL_OK) && (hal_status = HAL_TIM_OC_ConfigChannel(timer_handle,&timer_oc_config,0), hal_status == HAL_OK)) {\n    HAL_TIM_OC_Start_IT(timer_handle,0);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_TIM_OC_Init",
                "getTimerClkFreq",
                "getTimerIrq",
                "HAL_NVIC_SetPriority",
                "HAL_TIM_OC_ConfigChannel",
                "HAL_TIM_OC_Start_IT",
                "HAL_NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007648",
            "calling": [
                "initISR"
            ],
            "imported": false,
            "current_name": "initialize_timer_08007648"
        },
        "FUN_08008858": {
            "renaming": {
                "FUN_08008858": "improved_file_processing_08008858",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "file_buffer",
                "len_UNUSED": "buffer_length"
            },
            "code": "\nint improved_file_processing_08008858(int file_descriptor,char *file_buffer,int buffer_length)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008858",
            "calling": [
                "_read_r"
            ],
            "imported": false,
            "current_name": "improved_file_processing_08008858"
        },
        "FUN_08004a20": {
            "renaming": {
                "FUN_08004a20": "do_nothing_08004a20"
            },
            "code": "\nvoid do_nothing_08004a20(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a20",
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a20"
        },
        "FUN_08004a24": {
            "renaming": {
                "FUN_08004a24": "send_i2c_data_08004a24",
                "hi2c": "i2c_handle",
                "HVar1": "i2c_state",
                "pbVar2": "data_ptr",
                "XferCount": "transfer_count",
                "pBuffPtr": "buffer_ptr",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "CR2": "control_register_2",
                "PreviousState": "previous_state",
                "HAL_I2C_StateTypeDef_conflict": "i2c_state_type_def",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "busy_tx_listen",
                "HAL_I2C_STATE_LISTEN": "i2c_listen",
                "HAL_I2C_SlaveTxCpltCallback": "slave_tx_complete_callback",
                "HAL_OK": "hal_ok"
            },
            "code": "\nHAL_StatusTypeDef_conflict send_i2c_data_08004a24(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  i2c_state_type_def i2c_state;\n  byte *data_ptr;\n  \n  i2c_state = i2c_handle->State;\n  if (i2c_handle->transfer_count != 0) {\n    data_ptr = i2c_handle->buffer_ptr;\n    i2c_handle->buffer_ptr = data_ptr + 1;\n    i2c_handle->i2c_instance->data_register = (uint)*data_ptr;\n    i2c_handle->transfer_count = i2c_handle->transfer_count - 1;\n    if ((i2c_handle->transfer_count == 0) && (i2c_state == busy_tx_listen)) {\n      i2c_handle->i2c_instance->control_register_2 = i2c_handle->i2c_instance->control_register_2 & 0xfffffbff;\n      i2c_handle->previous_state = 0x21;\n      i2c_handle->State = i2c_listen;\n      slave_tx_complete_callback(i2c_handle);\n    }\n    return hal_ok;\n  }\n  return hal_ok;\n}\n\n",
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a24",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "send_i2c_data_08004a24"
        },
        "FUN_08004a22": {
            "renaming": {
                "FUN_08004a22": "do_nothing_08004a22"
            },
            "code": "\nvoid do_nothing_08004a22(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a22",
            "calling": [
                "I2C_Slave_AF",
                "I2C_SlaveTransmit_TXE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a22"
        },
        "FUN_08002fba": {
            "renaming": {
                "FUN_08002fba": "get_pin_state_08002fba",
                "this": "firmataObject",
                "pinState": "pinStates"
            },
            "code": "\nint __firmataObjectcall firmata::FirmataClass::getPinState_08002fba(FirmataClass *firmataObject,byte pin)\n\n{\n  return firmataObject->pinStates[pin];\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fba",
            "calling": [
                "digitalWriteCallback",
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "get_pin_state_08002fba"
        },
        "FUN_080090cc": {
            "renaming": {
                "FUN_080090cc": "print_assertion_failed_and_abort_080090cc",
                "param_1": "assertion",
                "param_2": "file",
                "param_3": "message",
                "param_4": "line_number",
                "puVar1": "default_message",
                "puVar2": "function_name"
            },
            "code": "\nvoid print_assertion_failed_and_abort_080090cc(undefined4 assertion,undefined4 file,undefined *message,undefined4 line_number)\n\n{\n  undefined *default_message;\n  undefined *function_name;\n  \n  default_message = PTR_s__08009104;\n  function_name = PTR_s__08009104;\n  if (message != (undefined *)0x0) {\n    default_message = message;\n    function_name = PTR_s___function__080090fc;\n  }\n  fiprintf(*(FILE **)(*(int *)PTR__impure_ptr_080090f8 + 0xc),\n           PTR_s_assertion___s__failed__file___s__08009100,line_number,assertion,file,function_name,default_message,\n           line_number);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "called": [
                "fiprintf",
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090cc",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "print_assertion_failed_and_abort_080090cc"
        },
        "FUN_080049e0": {
            "renaming": {
                "FUN_080049e0": "initialize_i2c_communication_080049e0",
                "hi2c": "i2c_handle",
                "pIVar1": "i2c_instance",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "I2C_TypeDef_conflict": "I2C_TypeDef",
                "HAL_I2C_STATE_READY": "HAL_I2C_READY",
                "HAL_BUSY": "HAL_I2C_BUSY",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_LISTEN",
                "CR1": "control_register_1",
                "CR2": "control_register_2"
            },
            "code": "\nHAL_StatusTypeDef initialize_i2c_communication_080049e0(I2C_HandleTypeDef *i2c_handle)\n\n{\n  I2C_TypeDef *i2c_instance;\n  \n  if (i2c_handle->State != HAL_I2C_READY) {\n    return HAL_I2C_BUSY;\n  }\n  i2c_handle->State = HAL_I2C_LISTEN;\n  i2c_instance = i2c_handle->Instance;\n  if ((i2c_instance->control_register_1 & 1) == 0) {\n    i2c_instance->control_register_1 = i2c_instance->control_register_1 | 1;\n  }\n  i2c_handle->Instance->control_register_1 = i2c_handle->Instance->control_register_1 | 0x400;\n  i2c_handle->Instance->control_register_2 = i2c_handle->Instance->control_register_2 | 0x300;\n  return HAL_OK;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080049e0",
            "calling": [
                "i2c_attachSlaveRxEvent",
                "i2c_attachSlaveTxEvent",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "imported": false,
            "current_name": "initialize_i2c_communication_080049e0"
        },
        "FUN_08006d24": {
            "renaming": {
                "FUN_08006d24": "update_adc_instance_08006d24",
                "hadc": "adc_handle",
                "iVar1": "data_ptr"
            },
            "code": "\nvoid update_adc_instance_08006d24(ADC_HandleTypeDef *adc_handle)\n\n{\n  int data_ptr;\n  \n  data_ptr = DAT_08006d7c;\n  if (adc_handle->Instance != DAT_08006d74) {\n    if (adc_handle->Instance == DAT_08006d78) {\n      *(uint *)(DAT_08006d7c + 0xc) = *(uint *)(DAT_08006d7c + 0xc) | 0x400;\n      *(uint *)(data_ptr + 0xc) = *(uint *)(data_ptr + 0xc) & 0xfffffbff;\n      *(uint *)(data_ptr + 0x18) = *(uint *)(data_ptr + 0x18) & 0xfffffbff;\n      *(uint *)(data_ptr + 0x18) = *(uint *)(data_ptr + 0x18) & 0xfffffbff;\n    }\n    return;\n  }\n  *(uint *)(DAT_08006d7c + 0xc) = *(uint *)(DAT_08006d7c + 0xc) | 0x200;\n  *(uint *)(data_ptr + 0xc) = *(uint *)(data_ptr + 0xc) & 0xfffffdff;\n  *(uint *)(data_ptr + 0x18) = *(uint *)(data_ptr + 0x18) & 0xfffffdff;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d24",
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "imported": false,
            "current_name": "update_adc_instance_08006d24"
        },
        "FUN_08008500": {
            "renaming": {
                "FUN_08008500": "transmit_data_over_uart_08008500",
                "data": "data_buffer",
                "size": "data_size",
                "PinName_conflict": "PinName",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "uVar2": "current_tick",
                "pvVar3": "peripheral_address",
                "uVar4": "elapsed_time",
                "uVar5": "handler_index",
                "HVar1": "transmit_status"
            },
            "code": "\ndata_size_t transmit_data_over_uart_08008500(uint8_t *data_buffer,uint32_t data_size)\n\n{\n  PinName pin;\n  HAL_StatusTypeDef transmit_status;\n  uint32_t current_tick;\n  void *peripheral_address;\n  uint32_t elapsed_time;\n  uint handler_index;\n  \n  current_tick = HAL_GetTick();\n  pin = PTR_digitalPin_080085a8[1];\n  peripheral_address = pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_UART_TX_080085ac);\n  if (peripheral_address == (void *)0x0) {\n    return 0;\n  }\n  handler_index = 0;\n  while ((handler_index < 5 &&\n         ((*(int *)(PTR_uart_handlers_080085b0 + handler_index * 4) == 0 ||\n          (peripheral_address = pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_UART_TX_080085ac),\n          **(void ***)(PTR_uart_handlers_080085b0 + handler_index * 4) != peripheral_address))))) {\n    handler_index = handler_index + 1 & 0xff;\n  }\n  if (4 < handler_index) {\n    if ((4 < (byte)PTR_serial_debug_080085b4[0x44]) &&\n       (uart_debug_init(), 4 < (byte)PTR_serial_debug_080085b4[0x44])) {\n      return 0;\n    }\n    handler_index = (uint)(byte)PTR_serial_debug_080085b4[0x44];\n  }\n  do {\n    transmit_status = HAL_UART_Transmit(*(UART_HandleTypeDef **)(PTR_uart_handlers_080085b0 + handler_index * 4),data_buffer,\n                              (uint16_t)data_size,1000);\n    if (transmit_status == HAL_OK) {\n      return data_size;\n    }\n    elapsed_time = HAL_GetTick();\n  } while (elapsed_time - current_tick < 1000);\n  return 0;\n}\n\n",
            "called": [
                "HAL_GetTick",
                "uart_debug_init",
                "pinmap_peripheral",
                "HAL_UART_Transmit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008500",
            "calling": [
                "_write"
            ],
            "imported": false,
            "current_name": "transmit_data_over_uart_08008500"
        },
        "FUN_08007774": {
            "renaming": {
                "FUN_08007774": "handle_timer_interrupt_08007774",
                "TIM_HandleTypeDef_conflict": "TimerHandle"
            },
            "code": "\nvoid handle_timer_interrupt_08007774(void)\n\n{\n  if (*(TimerHandle **)(PTR_timer_handles_08007784 + 4) !=\n      (TimerHandle *)0x0) {\n    HAL_TIM_IRQHandler(*(TimerHandle **)(PTR_timer_handles_08007784 + 4));\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007774",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007774"
        },
        "FUN_08005e6c": {
            "renaming": {
                "FUN_08005e6c": "do_nothing_08005e6c"
            },
            "code": "\nvoid do_nothing_08005e6c(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6c",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e6c"
        },
        "FUN_080001a8": {
            "renaming": {
                "FUN_080001a8": "set_pin_state_080001a8",
                "pin": "pin_number",
                "value": "pin_value",
                "bVar1": "is_pin_valid",
                "bVar2": "pin_mode",
                "ulPin": "unsigned_pin_number",
                "uVar3": "digital_pin_number"
            },
            "code": "\nvoid set_pin_state_080001a8(byte pin_number,int pin_value)\n\n{\n  bool is_pin_valid;\n  byte pin_mode;\n  uint unsigned_pin_number;\n  uint32_t digital_pin_number;\n  \n  unsigned_pin_number = (uint)pin_number;\n  if (unsigned_pin_number < 0x3c) {\n    if (unsigned_pin_number < 0x3c) {\n      if (PTR_digitalPin_0800020c[unsigned_pin_number] == NC) {\n        is_pin_valid = false;\n      }\n      else {\n        digital_pin_number = pin_numberNametoDigitalPin(PTR_digitalPin_0800020c[unsigned_pin_number]);\n        if (digital_pin_number == 0) {\n          is_pin_valid = false;\n        }\n        else {\n          digital_pin_number = pin_numberNametoDigitalPin(PTR_digitalPin_0800020c[unsigned_pin_number]);\n          if (digital_pin_number == 1) {\n            is_pin_valid = false;\n          }\n          else {\n            is_pin_valid = true;\n          }\n        }\n      }\n    }\n    else {\n      is_pin_valid = false;\n    }\n  }\n  else {\n    is_pin_valid = false;\n  }\n  if ((is_pin_valid) &&\n     (pin_mode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000210,pin_number),\n     pin_mode == '\\x01')) {\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000210,pin_number,pin_value);\n    digitalWrite(unsigned_pin_number,pin_value);\n  }\n  return;\n}\n\n",
            "called": [
                "digitalWrite",
                "pinNametoDigitalPin",
                "setPinState",
                "getPinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001a8",
            "calling": [],
            "imported": false,
            "current_name": "set_pin_state_080001a8"
        },
        "FUN_080048c8": {
            "renaming": {
                "FUN_080048c8": "i2c_slave_listen_080048c8",
                "hi2c": "i2c_handle",
                "pData": "data_buffer",
                "Size": "data_size",
                "XferOptions": "transfer_options",
                "HVar1": "status",
                "pIVar2": "i2c_instance",
                "tmpreg": "temporary_register"
            },
            "code": "\nHAL_StatusTypeDef_conflict\ni2c_slave_listen_080048c8(I2C_HandleTypeDef_conflict *i2c_handle,uint8_t *data_buffer,uint16_t data_size,uint32_t transfer_options)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2c_instance;\n  uint32_t temporary_register;\n  \n  if (i2c_handle->State == HAL_I2C_STATE_LISTEN) {\n    if (data_buffer == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (data_size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2c_handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2c_handle->Lock = HAL_LOCKED;\n      i2c_instance = i2c_handle->Instance;\n      if ((i2c_instance->CR1 & 1) == 0) {\n        i2c_instance->CR1 = i2c_instance->CR1 | 1;\n      }\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffff7ff;\n      i2c_handle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      i2c_handle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2c_handle->ErrorCode = 0;\n      i2c_handle->pBuffPtr = data_buffer;\n      i2c_handle->XferCount = data_size;\n      i2c_handle->transfer_options = transfer_options;\n      i2c_handle->Xferdata_size = i2c_handle->XferCount;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080048c8",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "i2c_slave_listen_080048c8"
        },
        "FUN_08009954": {
            "renaming": {
                "FUN_08009954": "copy_string_08009954",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_chars",
                "cVar1": "current_char",
                "sVar2": "remaining_chars",
                "pcVar3": "dest_ptr",
                "pcVar4": "dest_start"
            },
            "code": "\nchar * copy_string_08009954(char *destination,char *source,size_t num_chars)\n\n{\n  char current_char;\n  size_t remaining_chars;\n  char *dest_ptr;\n  char *dest_start;\n  \n  dest_ptr = destination;\n  do {\n    dest_start = dest_ptr;\n    remaining_chars = num_chars;\n    if (remaining_chars == 0) {\n      return destination;\n    }\n    current_char = *source;\n    dest_ptr = dest_start + 1;\n    *dest_start = current_char;\n    source = source + 1;\n    num_chars = remaining_chars - 1;\n  } while (current_char != '\\0');\n  for (; dest_ptr != dest_start + remaining_chars; dest_ptr = dest_ptr + 1) {\n    *dest_ptr = '\\0';\n  }\n  return destination;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009954",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "copy_string_08009954"
        },
        "FUN_08005e6e": {
            "renaming": {
                "FUN_08005e6e": "handle_tim_interrupts_08005e6e",
                "htim": "TIM_handler",
                "pTVar1": "TIM_instance",
                "SR": "status_register",
                "DIER": "interrupt_enable_register",
                "Channel": "active_TIM_channel",
                "HAL_TIM_ACTIVE_CHANNEL_1": "TIM_channel_1",
                "HAL_TIM_ACTIVE_CHANNEL_2": "TIM_channel_2",
                "HAL_TIM_ACTIVE_CHANNEL_3": "TIM_channel_3",
                "HAL_TIM_ACTIVE_CHANNEL_4": "TIM_channel_4",
                "HAL_TIM_ACTIVE_CHANNEL_CLEARED": "no_active_TIM_channel",
                "CCMR1": "capture_compare_mode_register_1",
                "CCMR2": "capture_compare_mode_register_2",
                "HAL_TIM_OC_DelayElapsedCallback": "handle_TIM_OC_delay_elapsed",
                "HAL_TIM_PWM_PulseFinishedCallback": "handle_TIM_PWM_pulse_finished",
                "HAL_TIM_IC_CaptureCallback": "handle_TIM_IC_capture",
                "HAL_TIM_PeriodElapsedCallback": "handle_TIM_period_elapsed",
                "HAL_TIMEx_BreakCallback": "handle_TIM_break",
                "HAL_TIM_TriggerCallback": "handle_TIM_trigger",
                "HAL_TIMEx_CommutationCallback": "handle_TIM_commutation"
            },
            "code": "\nvoid handle_TIM_interrupts_08005e6e(TIM_HandleTypeDef_conflict *TIM_handler)\n\n{\n  TIM_TypeDef_conflict *TIM_instance;\n  \n  TIM_instance = TIM_handler->Instance;\n  if (((TIM_instance->status_register & 2) != 0) && ((TIM_instance->interrupt_enable_register & 2) != 0)) {\n    TIM_instance->status_register = 0xfffffffd;\n    TIM_handler->active_TIM_channel = TIM_channel_1;\n    if ((TIM_handler->Instance->capture_compare_mode_register_1 & 3) == 0) {\n      handle_TIM_OC_delay_elapsed(TIM_handler);\n      handle_TIM_PWM_pulse_finished(TIM_handler);\n    }\n    else {\n      handle_TIM_IC_capture(TIM_handler);\n    }\n    TIM_handler->active_TIM_channel = no_active_TIM_channel;\n  }\n  TIM_instance = TIM_handler->Instance;\n  if (((TIM_instance->status_register & 4) != 0) && ((TIM_instance->interrupt_enable_register & 4) != 0)) {\n    TIM_instance->status_register = 0xfffffffb;\n    TIM_handler->active_TIM_channel = TIM_channel_2;\n    if ((TIM_handler->Instance->capture_compare_mode_register_1 & 0x300) == 0) {\n      handle_TIM_OC_delay_elapsed(TIM_handler);\n      handle_TIM_PWM_pulse_finished(TIM_handler);\n    }\n    else {\n      handle_TIM_IC_capture(TIM_handler);\n    }\n    TIM_handler->active_TIM_channel = no_active_TIM_channel;\n  }\n  TIM_instance = TIM_handler->Instance;\n  if (((TIM_instance->status_register & 8) != 0) && ((TIM_instance->interrupt_enable_register & 8) != 0)) {\n    TIM_instance->status_register = 0xfffffff7;\n    TIM_handler->active_TIM_channel = TIM_channel_3;\n    if ((TIM_handler->Instance->capture_compare_mode_register_2 & 3) == 0) {\n      handle_TIM_OC_delay_elapsed(TIM_handler);\n      handle_TIM_PWM_pulse_finished(TIM_handler);\n    }\n    else {\n      handle_TIM_IC_capture(TIM_handler);\n    }\n    TIM_handler->active_TIM_channel = no_active_TIM_channel;\n  }\n  TIM_instance = TIM_handler->Instance;\n  if (((TIM_instance->status_register & 0x10) != 0) && ((TIM_instance->interrupt_enable_register & 0x10) != 0)) {\n    TIM_instance->status_register = 0xffffffef;\n    TIM_handler->active_TIM_channel = TIM_channel_4;\n    if ((TIM_handler->Instance->capture_compare_mode_register_2 & 0x300) == 0) {\n      handle_TIM_OC_delay_elapsed(TIM_handler);\n      handle_TIM_PWM_pulse_finished(TIM_handler);\n    }\n    else {\n      handle_TIM_IC_capture(TIM_handler);\n    }\n    TIM_handler->active_TIM_channel = no_active_TIM_channel;\n  }\n  TIM_instance = TIM_handler->Instance;\n  if (((TIM_instance->status_register & 1) != 0) && ((TIM_instance->interrupt_enable_register & 1) != 0)) {\n    TIM_instance->status_register = 0xfffffffe;\n    handle_TIM_period_elapsed(TIM_handler);\n  }\n  TIM_instance = TIM_handler->Instance;\n  if (((TIM_instance->status_register & 0x80) != 0) && ((TIM_instance->interrupt_enable_register & 0x80) != 0)) {\n    TIM_instance->status_register = 0xffffff7f;\n    handle_TIM_break(TIM_handler);\n  }\n  TIM_instance = TIM_handler->Instance;\n  if (((TIM_instance->status_register & 0x40) != 0) && ((TIM_instance->interrupt_enable_register & 0x40) != 0)) {\n    TIM_instance->status_register = 0xffffffbf;\n    handle_TIM_trigger(TIM_handler);\n  }\n  TIM_instance = TIM_handler->Instance;\n  if (((TIM_instance->status_register & 0x20) != 0) && ((TIM_instance->interrupt_enable_register & 0x20) != 0)) {\n    TIM_instance->status_register = 0xffffffdf;\n    handle_TIM_commutation(TIM_handler);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIMEx_BreakCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6e",
            "calling": [
                "TIM2_IRQHandler",
                "TIM4_IRQHandler",
                "TIM1_UP_IRQHandler",
                "TIM3_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_tim_interrupts_08005e6e"
        },
        "FUN_08004024": {
            "renaming": {
                "FUN_08004024": "set_clock_source_08004024",
                "CLKSource": "clock_source"
            },
            "code": "\nvoid set_clock_source_08004024(uint32_t clock_source)\n\n{\n  if (clock_source != 4) {\n    *DAT_08004040 = *DAT_08004040 & 0xfffffffb;\n    return;\n  }\n  *DAT_08004040 = *DAT_08004040 | 4;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004024",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_clock_source_08004024"
        },
        "FUN_08005e6a": {
            "renaming": {
                "FUN_08005e6a": "do_nothing_08005e6a"
            },
            "code": "\nvoid do_nothing_08005e6a(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6a",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e6a"
        },
        "FUN_08004a1e": {
            "renaming": {
                "FUN_08004a1e": "do_nothing_08004a1e"
            },
            "code": "\nvoid do_nothing_08004a1e(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a1e",
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a1e"
        },
        "FUN_08008868": {
            "renaming": {
                "FUN_08008868": "infinite_loop_08008868",
                "status_UNUSED": "unused_status",
                "true": "true_value"
            },
            "code": "\nvoid infinite_loop_08008868(int unused_status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true_value );\n}\n\n",
            "called": [
                "_exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008868",
            "calling": [
                "abort",
                "_exit"
            ],
            "imported": false,
            "current_name": "infinite_loop_08008868"
        },
        "FUN_080036ac": {
            "renaming": {
                "FUN_080036ac": "pin_conflict_to_uint32_080036ac",
                "p": "pin_conflict",
                "uVar1": "result"
            },
            "code": "\nuint32_t pin_conflict_to_uint32_080036ac(PinName_conflict pin_conflict)\n\n{\n  uint32_t result;\n  \n  if ((uint)((int)pin_conflict << 0x18) >> 0x1c < 5) {\n    for (result = 0; (result < 0x3c && ((int)pin_conflict != (int)(char)PTR_digitalPin_080036d0[result]));\n        result = result + 1) {\n    }\n  }\n  else {\n    result = 0xffffffff;\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036ac",
            "calling": [
                "enableI2CPins",
                "checkDigitalInputs",
                "loop",
                "digitalWriteCallback",
                "sysexCallback",
                "systemResetCallback",
                "analogWriteCallback",
                "setPinValueCallback",
                "setPinModeCallback",
                "reportDigitalCallback"
            ],
            "imported": false,
            "current_name": "pin_conflict_to_uint32_080036ac"
        },
        "FUN_0800885c": {
            "renaming": {
                "FUN_0800885c": "send_uart_data_0800885c",
                "file_UNUSED": "file_descriptor",
                "ptr": "data_pointer",
                "len": "data_length",
                "sVar1": "bytes_sent"
            },
            "code": "\nint send_uart_data_0800885c(int file_descriptor,char *data_pointer,int data_length)\n\n{\n  size_t bytes_sent;\n  \n  bytes_sent = uart_debugsend_uart_data_0800885c((uint8_t *)data_pointer,data_length);\n  return bytes_sent;\n}\n\n",
            "called": [
                "uart_debug_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800885c",
            "calling": [
                "_write_r"
            ],
            "imported": false,
            "current_name": "send_uart_data_0800885c"
        },
        "FUN_0800643c": {
            "renaming": {
                "FUN_0800643c": "initialize_timer_channel_0800643c",
                "htim": "timerHandle",
                "Channel": "channelNumber",
                "Instance": "timerInstance",
                "BDTR": "breakAndDeadTimeRegister",
                "CR1": "controlRegister1"
            },
            "code": "\nHAL_StatusTypeDef_conflict initializeTimerChannel_0800643c(TIM_HandleTypeDef_conflict *timerHandle,uint32_t channelNumber)\n\n{\n  TIM_CCxNchannelNumberCmd(timerHandle->timerInstance,channelNumber,4);\n  timerHandle->timerInstance->breakAndDeadTimeRegister = timerHandle->timerInstance->breakAndDeadTimeRegister | 0x8000;\n  timerHandle->timerInstance->controlRegister1 = timerHandle->timerInstance->controlRegister1 | 1;\n  return HAL_OK;\n}\n\n",
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800643c",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "initialize_timer_channel_0800643c"
        },
        "FUN_08002fca": {
            "renaming": {
                "FUN_08002fca": "blink_led_08002fca",
                "this": "self",
                "pin": "pinNumber",
                "count": "blinkCount",
                "onInterval": "onDuration",
                "offInterval": "offDuration",
                "uVar1": "loopCounter"
            },
            "code": "\nvoid __selfcall\nfirmata::FirmataClass::blinkLED_08002fca(FirmataClass *self,byte pinNumber,int blinkCount,int onDuration,int offDuration)\n\n{\n  uint loopCounter;\n  \n  for (loopCounter = 0; (int)loopCounter < blinkCount; loopCounter = loopCounter + 1 & 0xff) {\n    delay(offDuration);\n    digitalWrite((uint)pinNumber,1);\n    delay(onDuration);\n    digitalWrite((uint)pinNumber,0);\n  }\n  return;\n}\n\n",
            "called": [
                "delay",
                "digitalWrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fca",
            "calling": [
                "blinkVersion"
            ],
            "imported": false,
            "current_name": "blink_led_08002fca"
        },
        "FUN_0800a31c": {
            "renaming": {
                "ctype_byname": "set_flags",
                "FUN_0800a31c": "set_flags_0800a31c"
            },
            "code": "\n/* std::set_flags_0800a31c<wchar_t>::set_flags_0800a31c(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::set_flags_0800a31c<wchar_t>::set_flags_0800a31c(void)\n\n{\n  if (-1 < *(int *)PTR_id_0800a380 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a380 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a384 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a384 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a388 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a388 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a38c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a38c = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a390 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a390 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a394 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a394 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a398 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a398 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a39c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a39c = 1;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a31c",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_0800a31c"
        },
        "FUN_080026f8": {
            "renaming": {
                "this": "servo",
                "servoIndex": "index",
                "FUN_080026f8": "check_servo_index_080026f8"
            },
            "code": "\nbool __servocall Servo::checkServoIndex_080026f8(Servo *servo)\n\n{\n  return SUB41(((uint)(byte)PTR_servos_08002708[(uint)servo->index * 8] << 0x19) >> 0x1f,0);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026f8",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "check_servo_index_080026f8"
        },
        "FUN_08007544": {
            "renaming": {
                "FUN_08007544": "get_timer_interrupt_08007544",
                "tim": "timer",
                "iprintf": "print_error_message"
            },
            "code": "\nuint32_t get_timer_interrupt_08007544(TIM_TypeDef_conflict *timer)\n\n{\n  if (timer == (TIM_TypeDef_conflict *)0xffffffff) {\n    return 0;\n  }\n  if (timer == DAT_08007588) {\n    return 0x1d;\n  }\n  if (DAT_08007588 < timer) {\n    if (timer == DAT_0800758c) {\n      return 0x1e;\n    }\n    if (timer == (TIM_TypeDef_conflict *)&DAT_0800758c[0x379].DMAR) {\n      return 0x19;\n    }\n  }\n  else if (timer == (TIM_TypeDef_conflict *)0x40000000) {\n    return 0x1c;\n  }\n  print_error_message(PTR_s_TIM__Unknown_timerer_IRQn_08007590);\n  return 0;\n}\n\n",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007544",
            "calling": [
                "TimerPulseDeinit",
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "get_timer_interrupt_08007544"
        },
        "FUN_08008990": {
            "renaming": {
                "FUN_08008990": "configure_pin_08008990",
                "ulPin": "pin_number",
                "ulMode": "mode",
                "_Var1": "is_pin_configured",
                "pin": "pin_name",
                "NC": "not_connected",
                "is_pin_configured": "check_pin_configured",
                "pin_in_pinmap": "check_pin_in_pinmap",
                "PinMap_conflict": "pin_map_conflict",
                "pwm_stop": "stop_pwm",
                "reset_pin_configured": "unconfigure_pin",
                "digital_io_init": "initialize_digital_io"
            },
            "code": "\nvoid configure_pin_08008990(uint32_t pin_number,uint32_t mode)\n\n{\n  _Bool is_pin_configured;\n  PinName_conflict pin_name;\n  \n  if (pin_number < 0x3c) {\n    pin_name = PTR_digitalPin_08008a14[pin_number];\n  }\n  else {\n    pin_name = not_connected;\n  }\n  if (pin_name != not_connected) {\n    is_pin_configured = check_pin_configured(pin_name,(uint32_t *)PTR_g_anOutputPinConfigured_08008a18);\n    if (is_pin_configured) {\n      is_pin_configured = check_pin_in_pinmap(pin_name,(pin_map_conflict *)PTR_PinMap_PWM_08008a1c);\n      if (is_pin_configured) {\n        stop_pwm(pin_name);\n      }\n      unconfigure_pin_08008990(pin_name,(uint32_t *)PTR_g_anOutputPinConfigured_08008a18);\n    }\n    switch(mode) {\n    case 0:\n      initialize_digital_io(pin_name,0,0);\n      break;\n    case 1:\n      initialize_digital_io(pin_name,1,0);\n      break;\n    case 2:\n      initialize_digital_io(pin_name,0,1);\n      break;\n    case 3:\n      initialize_digital_io(pin_name,0,2);\n    }\n    set_pin_name_configured(pin_name,(uint32_t *)PTR_g_digPinConfigured_08008a20);\n  }\n  return;\n}\n\n",
            "called": [
                "pwm_stop",
                "pin_in_pinmap",
                "digital_io_init",
                "set_pin_configured",
                "reset_pin_configured",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008990",
            "calling": [
                "attach",
                "analogWrite",
                "digitalWriteCallback",
                "blinkVersion",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "configure_pin_08008990"
        },
        "FUN_08004396": {
            "renaming": {
                "FUN_08004396": "send_i2c_data_08004396",
                "hi2c": "i2c_handle",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "Devaddress": "device_address"
            },
            "code": "\nHAL_StatusTypeDef_conflict send_i2c_data_08004396(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  i2c_handle->i2c_instance->data_register = i2c_handle->device_address & 0xff;\n  return HAL_OK;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004396",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "send_i2c_data_08004396"
        },
        "FUN_08003fb0": {
            "renaming": {
                "FUN_08003fb0": "set_irq_enable_08003fb0",
                "IRQn": "irq_num",
                "uVar1": "irq_val"
            },
            "code": "\nvoid set_irq_enable_08003fb0(irq_num_Type_conflict irq_num)\n\n{\n  uint irq_val;\n  \n  irq_val = (uint)irq_num;\n  if (-1 < (int)irq_val) {\n    *(int *)(DAT_08003fd4 + ((irq_val >> 5) + 0x20) * 4) = 1 << (irq_val & 0x1f);\n    DataSynchronizationBarrier(0xf);\n    InstructionSynchronizationBarrier(0xf);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fb0",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "set_irq_enable_08003fb0"
        },
        "FUN_08007788": {
            "renaming": {
                "FUN_08007788": "timer_handler_interrupt_08007788",
                "TIM_HandleTypeDef_conflict": "timer_handle",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt"
            },
            "code": "\nvoid timer_handler_interrupt_08007788(void)\n\n{\n  if (*(timer_handle **)(PTR_timer_handles_08007798 + 8) !=\n      (timer_handle *)0x0) {\n    handle_timer_interrupt(*(timer_handle **)(PTR_timer_handles_08007798 + 8));\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007788",
            "calling": [],
            "imported": false,
            "current_name": "timer_handler_interrupt_08007788"
        },
        "FUN_08008f0c": {
            "renaming": {
                "FUN_08008f0c": "do_nothing_08008f0c"
            },
            "code": "\nvoid do_nothing_08008f0c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f0c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "do_nothing_08008f0c"
        },
        "FUN_08002ec4": {
            "renaming": {
                "this": "self",
                "iVar1": "print_result",
                "FUN_08002ec4": "print_firmata_stream_08002ec4"
            },
            "code": "\nint __selfcall firmata::FirmataClass::print_firmata_stream_08002ec4(FirmataClass *self)\n\n{\n  int print_result;\n  \n  print_result = (*(self->FirmataStream->super_Print)._vptr_Print[2])();\n  return print_result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ec4",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "print_firmata_stream_08002ec4"
        },
        "FUN_08007306": {
            "renaming": {
                "FUN_08007306": "find_peripheral_by_pin_08007306",
                "pin": "target_pin",
                "map": "pin_map",
                "NC": "NotConnected",
                "peripheral": "matched_peripheral"
            },
            "code": "\nvoid * find_peripheral_by_pin_08007306(PinName_conflict target_pin,PinMap_conflict *pin_map)\n\n{\n  while( true ) {\n    if (pin_map->target_pin == NotConnected) {\n      return (void *)0x0;\n    }\n    if (pin_map->target_pin == target_pin) break;\n    pin_map = pin_map + 1;\n  }\n  return pin_map->matched_peripheral;\n}\n\n",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007306",
            "calling": [
                "pinmap_peripheral",
                "pinmap_find_peripheral"
            ],
            "imported": false,
            "current_name": "find_peripheral_by_pin_08007306"
        },
        "FUN_08008f0e": {
            "renaming": {
                "FUN_08008f0e": "initialize_crypto_context_08008f0e",
                "ctx": "crypto_context",
                "HAL_NVIC_SetPriorityGrouping": "configure_interrupt_priority",
                "init": "initialize_crypto_library"
            },
            "code": "\nvoid initialize_crypto_context_08008f0e(void)\n\n{\n  EVP_PKEY_CTX *crypto_context;\n  \n  crypto_context = (EVP_PKEY_CTX *)0x3;\n  configure_interrupt_priority(3);\n  initialize_crypto_library(crypto_context);\n  return;\n}\n\n",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f0e",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "initialize_crypto_context_08008f0e"
        },
        "FUN_0800886c": {
            "renaming": {
                "FUN_0800886c": "set_errno_0800886c",
                "pid_UNUSED": "unused_pid",
                "sig_UNUSED": "unused_sig"
            },
            "code": "\nint set_errno_0800886c(int unused_pid,int unused_sig)\n\n{\n  *(undefined4 *)PTR_errno_08008878 = 0x16;\n  return -1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800886c",
            "calling": [
                "_kill_r"
            ],
            "imported": false,
            "current_name": "set_errno_0800886c"
        },
        "FUN_080036d4": {
            "renaming": {
                "FUN_080036d4": "do_nothing_080036d4"
            },
            "code": "\nvoid do_nothing_080036d4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036d4",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_080036d4"
        },
        "FUN_08006e68": {
            "renaming": {
                "FUN_08006e68": "configure_pwm_pin_08006e68",
                "htim": "timer_handle",
                "puVar1": "current_pin_ptr",
                "uVar2": "pin_function",
                "GPIOx": "gpio_port",
                "tmpreg": "temporary_register",
                "GPIO_InitStruct": "gpio_init_structure"
            },
            "code": "\nvoid configure_PWM_pin_08006e68(TIM_HandleTypeDef_conflict *timer_handle)\n\n{\n  undefined *current_pin_ptr;\n  uint32_t pin_function;\n  GPIO_TypeDef *gpio_port;\n  uint32_t temporary_register;\n  GPIO_InitTypeDef gpio_init_structure;\n  \n  current_pin_ptr = PTR_g_current_pin_08007100;\n  pin_function = pinmap_function(*PTR_g_current_pin_08007100,(PinMap_conflict *)PTR_PinMap_PWM_08007104);\n  timer_enable_clock(timer_handle);\n  gpio_port = set_GPIO_Port_Clock((uint)((int)(char)*current_pin_ptr << 0x18) >> 0x1c);\n  gpio_init_structure.Mode = 2;\n  gpio_init_structure.Pull = 0;\n  gpio_init_structure.Speed = 3;\n  *(uint *)(DAT_08007108 + 0x18) = *(uint *)(DAT_08007108 + 0x18) | 1;\n  switch((pin_function << 0x11) >> 0x19) {\n  case 1:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000001;\n    break;\n  case 2:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffe | 0x7000000;\n    break;\n  case 3:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000002;\n    break;\n  case 4:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffd | 0x7000000;\n    break;\n  case 5:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000004;\n    break;\n  case 6:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffb | 0x7000000;\n    break;\n  case 7:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000008;\n    break;\n  case 8:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffff7 | 0x7000000;\n    break;\n  case 9:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000030;\n    break;\n  case 10:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffffcf | 0x7000010;\n    break;\n  case 0xb:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffffcf | 0x7000000;\n    break;\n  case 0xc:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x70000c0;\n    break;\n  case 0xd:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffff3f | 0x7000040;\n    break;\n  case 0xe:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffff3f | 0x7000000;\n    break;\n  case 0xf:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000300;\n    break;\n  case 0x10:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000200;\n    break;\n  case 0x11:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000100;\n    break;\n  case 0x12:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000000;\n    break;\n  case 0x13:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000c00;\n    break;\n  case 0x14:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffff3ff | 0x7000800;\n    break;\n  case 0x15:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffff3ff | 0x7000000;\n    break;\n  case 0x16:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7001000;\n    break;\n  case 0x17:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffefff | 0x7000000;\n    break;\n  case 0x1b:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7008000;\n    break;\n  case 0x1c:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffff7fff | 0x7000000;\n    break;\n  case 0x21:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff;\n    break;\n  case 0x22:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x1000000;\n    break;\n  case 0x23:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x2000000;\n    break;\n  case 0x24:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x4000000;\n  }\n  gpio_init_structure.Pin = 1 << (*PTR_g_current_pin_08007100 & 0xf) & 0xffff;\n  HAL_GPIO_Init(gpio_port,&gpio_init_structure);\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init",
                "pinmap_function",
                "timer_enable_clock",
                "set_GPIO_Port_Clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e68",
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "imported": false,
            "current_name": "configure_pwm_pin_08006e68"
        },
        "FUN_080036d8": {
            "renaming": {
                "FUN_080036d8": "initialize_sys_tick_080036d8",
                "TickPriority": "tickPriority",
                "uVar1": "systickConfigStatus",
                "HAL_SYSTICK_Config": "configureSysTick",
                "HAL_NVIC_SetPriority": "setSysTickPriority",
                "HAL_OK": "HAL_SUCCESS",
                "HAL_ERROR": "HAL_FAILURE",
                "SysTick_IRQn": "SYSTICK_IRQ"
            },
            "code": "\nHAL_StatusTypeDef_conflict initializeSysTick_080036d8(uint32_t tickPriority)\n\n{\n  uint32_t systickConfigStatus;\n  \n  systickConfigStatus = configureSysTick((uint32_t)\n                             ((ulonglong)*(uint *)PTR_SystemCoreClock_0800371c /\n                             (1000 / (ulonglong)(byte)*PTR_uwTickFreq_08003718)));\n  if (systickConfigStatus != 0) {\n    return HAL_FAILURE;\n  }\n  if (0xf < tickPriority) {\n    return HAL_FAILURE;\n  }\n  setSysTickPriority(SYSTICK_IRQ,tickPriority,0);\n  *(uint32_t *)PTR_uwTickPrio_08003720 = tickPriority;\n  return HAL_SUCCESS;\n}\n\n",
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036d8",
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "initialize_sys_tick_080036d8"
        },
        "FUN_0800a110": {
            "renaming": {
                "FUN_0800a110": "check_isatty_0800a110",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "puVar1": "errno_pointer",
                "iVar2": "isatty_result"
            },
            "code": "\nvoid check_isatty_0800a110(int *error_code,int file_descriptor)\n\n{\n  undefined *errno_pointer;\n  int isatty_result;\n  \n  errno_pointer = PTR_errno_0800a12c;\n  *(undefined4 *)PTR_errno_0800a12c = 0;\n  isatty_result = _isatty(file_descriptor);\n  if ((isatty_result == -1) && (*(int *)errno_pointer != 0)) {\n    *error_code = *(int *)errno_pointer;\n  }\n  return;\n}\n\n",
            "called": [
                "_isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a110",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_isatty_0800a110"
        },
        "FUN_08003b8c": {
            "renaming": {
                "FUN_08003b8c": "check_adc_conversion_complete_08003b8c",
                "hadc": "adc_handle",
                "uVar1": "start_time",
                "uVar2": "current_time",
                "pAVar3": "adc_instance",
                "HAL_GetTick": "get_current_time",
                "HAL_OK": "adc_conversion_complete",
                "HAL_ERROR": "adc_conversion_error"
            },
            "code": "\nHAL_StatusTypeDef_conflict check_adc_conversion_complete_08003b8c(ADC_HandleTypeDef *adc_handle)\n\n{\n  uint32_t start_time;\n  uint32_t current_time;\n  ADC_TypeDef *adc_instance;\n  \n  adc_instance = adc_handle->Instance;\n  if ((adc_instance->CR2 & 1) == 0) {\n    return adc_conversion_complete;\n  }\n  adc_instance->CR2 = adc_instance->CR2 & 0xfffffffe;\n  start_time = get_current_time();\n  do {\n    if ((adc_handle->Instance->CR2 & 1) == 0) {\n      return adc_conversion_complete;\n    }\n    current_time = get_current_time();\n  } while (current_time - start_time < 3);\n  adc_handle->State = adc_handle->State | 0x10;\n  adc_handle->ErrorCode = adc_handle->ErrorCode | 1;\n  return adc_conversion_error;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003b8c",
            "calling": [
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_DeInit",
                "HAL_ADC_Stop"
            ],
            "imported": false,
            "current_name": "check_adc_conversion_complete_08003b8c"
        },
        "FUN_080035b8": {
            "renaming": {
                "FUN_080035b8": "initialize_system_clock_080035b8",
                "HVar1": "status",
                "uVar2": "hclk_freq",
                "PeriphClkInit": "peripheral_clk_init",
                "RCC_ClkInitStruct": "rcc_clk_init_struct",
                "RCC_OscInitStruct": "rcc_osc_init_struct",
                "OscillatorType": "osc_type",
                "HSIState": "hsi_state",
                "HSICalibrationValue": "hsi_calib_value",
                "PLLState": "pll_state",
                "PLLSource": "pll_source",
                "PLLMUL": "pll_mul",
                "ClockType": "clock_type",
                "SYSCLKSource": "sysclk_source",
                "AHBCLKDivider": "ahb_clk_divider",
                "APB1CLKDivider": "apb1_clk_divider",
                "APB2CLKDivider": "apb2_clk_divider"
            },
            "code": "\nvoid initialize_system_clock_080035b8(void)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t hclk_freq;\n  RCC_PeriphCLKInitTypeDef peripheral_clk_init;\n  RCC_ClkInitTypeDef rcc_clk_init_struct;\n  RCC_OscInitTypeDef rcc_osc_init_struct;\n  \n  rcc_osc_init_struct.osc_type = 2;\n  rcc_osc_init_struct.hsi_state = 1;\n  rcc_osc_init_struct.hsi_calib_value = 0x10;\n  rcc_osc_init_struct.PLL.pll_state = 2;\n  rcc_osc_init_struct.PLL.pll_source = 0;\n  rcc_osc_init_struct.PLL.pll_mul = 0x380000;\n  status = HAL_RCC_OscConfig((RCC_OscInitTypeDef_conflict *)&rcc_osc_init_struct);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x88);\n  }\n  rcc_clk_init_struct.clock_type = 0xf;\n  rcc_clk_init_struct.sysclk_source = 2;\n  rcc_clk_init_struct.ahb_clk_divider = 0;\n  rcc_clk_init_struct.apb1_clk_divider = 0x400;\n  rcc_clk_init_struct.apb2_clk_divider = 0;\n  status = HAL_RCC_ClockConfig((RCC_ClkInitTypeDef_conflict *)&rcc_clk_init_struct,2);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x95);\n  }\n  peripheral_clk_init.PeriphClockSelection = 2;\n  peripheral_clk_init.AdcClockSelection = 0x8000;\n  status = HAL_RCCEx_PeriphCLKConfig((RCC_PeriphCLKInitTypeDef_conflict *)&peripheral_clk_init);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x9c);\n  }\n  hclk_freq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config((uint)((ulonglong)DAT_08003650 * (ulonglong)hclk_freq >> 0x26));\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "called": [
                "_Error_Handler",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_OscConfig",
                "HAL_SYSTICK_Config",
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035b8",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "initialize_system_clock_080035b8"
        },
        "FUN_08006460": {
            "renaming": {
                "FUN_08006460": "disable_timer_channel_08006460",
                "htim": "timerHandle",
                "Channel": "channelNumber",
                "pTVar1": "timerInstance",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "\nHAL_StatusTypeDef disableTimerChannel_08006460(TIM_HandleTypeDef_conflict *timerHandle,uint32_t channelNumber)\n\n{\n  TIM_TypeDef_conflict *timerInstance;\n  \n  TIM_CCxNchannelNumberCmd(timerHandle->Instance,channelNumber,0);\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006460",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "disable_timer_channel_08006460"
        },
        "FUN_08004046": {
            "renaming": {
                "FUN_08004046": "initialize_systick_08004046"
            },
            "code": "\nvoid initialize_systick_08004046(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n",
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004046",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "initialize_systick_08004046"
        },
        "FUN_08008880": {
            "renaming": {
                "FUN_08008880": "read_analog_pin_08008880",
                "ulPin": "pin_number",
                "bVar1": "is_valid_pin",
                "pin": "pin_name",
                "uVar2": "adc_value",
                "uVar3": "analog_value",
                "uVar4": "read_resolution",
                "NC": "not_connected"
            },
            "code": "\nuint32_t read_analog_pin_08008880(uint32_t pin_number)\n\n{\n  bool is_valid_pin;\n  PinName_conflict pin_name;\n  uint16_t adc_value;\n  uint32_t analog_value;\n  uint read_resolution;\n  \n  if (pin_number < 0xe) {\n    if (pin_number + 0x2e < 0x3c) {\n      is_valid_pin = true;\n    }\n    else {\n      is_valid_pin = false;\n    }\n  }\n  else {\n    is_valid_pin = pin_number < 0x3c;\n  }\n  if (is_valid_pin) {\n    if (pin_number < 0xe) {\n      pin_number = pin_number + 0x2e;\n    }\n    pin_name = PTR_digitalPin_080088d8[pin_number];\n  }\n  else {\n    pin_name = not_connected;\n  }\n  if (pin_name == not_connected) {\n    analog_value = 0;\n  }\n  else {\n    adc_value = adc_read_value(pin_name);\n    analog_value = (uint32_t)adc_value;\n    read_resolution = *(uint *)PTR__readResolution_080088dc;\n    if (read_resolution != 0xc) {\n      if (read_resolution < 0xc) {\n        return (uint)(adc_value >> (0xc - read_resolution & 0xff));\n      }\n      return analog_value << (read_resolution - 0xc & 0xff);\n    }\n  }\n  return analog_value;\n}\n\n",
            "called": [
                "adc_read_value"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008880",
            "calling": [
                "reportAnalogCallback",
                "loop"
            ],
            "imported": false,
            "current_name": "read_analog_pin_08008880"
        },
        "FUN_08004044": {
            "renaming": {
                "FUN_08004044": "do_nothing_08004044"
            },
            "code": "\nvoid do_nothing_08004044(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004044",
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08004044"
        },
        "FUN_08002ed2": {
            "renaming": {
                "FUN_08002ed2": "parse_firmata_stream_08002ed2",
                "this": "firmata_instance",
                "iVar1": "stream_data",
                "FirmataStream": "firmata_stream",
                "super_Print": "super_print",
                "_vptr_Print": "virtual_print_table",
                "FirmataParser": "firmata_parser",
                "parser": "firmata_parser_instance"
            },
            "code": "\nvoid __firmata_instancecall firmata::FirmataClass::parse_firmata_stream_08002ed2(FirmataClass *firmata_instance)\n\n{\n  int stream_data;\n  \n  stream_data = (*(firmata_instance->firmata_stream->super_print).virtual_print_table[3])();\n  if (stream_data != -1) {\n    firmata_parser::parse(&firmata_instance->firmata_parser_instance,(uint8_t)stream_data);\n  }\n  return;\n}\n\n",
            "called": [
                "parse"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ed2",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "parse_firmata_stream_08002ed2"
        },
        "FUN_08008f1c": {
            "renaming": {
                "FUN_08008f1c": "run_program_08008f1c",
                "initVariant": "initializeVariant",
                "setup": "setupProgram",
                "loop": "runLoop",
                "serialEventRun": "runSerialEvent"
            },
            "code": "\nint runProgram_08008f1c(void)\n\n{\n  initializeVariant();\n  setupProgram();\n  do {\n    do {\n      runLoop();\n    } while (DAT_08008f38 == 0);\n    runSerialEvent();\n  } while( true );\n}\n\n",
            "called": [
                "loop",
                "initVariant",
                "serialEventRun",
                "setup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f1c",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "run_program_08008f1c"
        },
        "FUN_080058ac": {
            "renaming": {
                "FUN_080058ac": "configure_clocks_080058ac",
                "RCC_ClkInitTypeDef_conflict": "RCC_ClockConfigTypeDef",
                "RCC_ClkInitStruct": "clock_init_struct",
                "FLatency": "flash_latency",
                "puVar1": "ptr_to_dat_08005a0c",
                "uVar2": "tick_start",
                "uVar3": "tick_current",
                "uVar4": "sysclk_source",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "\nHAL_StatusTypeDef\nconfigure_clocks_080058ac(RCC_ClockConfigTypeDef *clock_init_struct,uint32_t flash_latency)\n\n{\n  uint *ptr_to_dat_08005a0c;\n  uint32_t tick_start;\n  uint32_t tick_current;\n  uint sysclk_source;\n  \n  ptr_to_dat_08005a0c = DAT_08005a0c;\n  if (((*DAT_08005a0c & 7) < flash_latency) &&\n     (*DAT_08005a0c = *DAT_08005a0c & 0xfffffff8 | flash_latency, flash_latency != (*ptr_to_dat_08005a0c & 7))) {\n    return HAL_ERROR;\n  }\n  if ((clock_init_struct->ClockType & 2) != 0) {\n    DAT_08005a10[1] = DAT_08005a10[1] & 0xffffff0f | clock_init_struct->AHBCLKDivider;\n  }\n  if ((clock_init_struct->ClockType & 1) != 0) {\n    sysclk_source = clock_init_struct->SYSCLKSource;\n    if (sysclk_source == 1) {\n      if ((*DAT_08005a10 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((sysclk_source != 2) && ((*DAT_08005a10 & 2) == 0)) {\n      return HAL_ERROR;\n    }\n    DAT_08005a10[1] = sysclk_source | DAT_08005a10[1] & 0xfffffffc;\n    tick_start = HAL_GetTick();\n    if (clock_init_struct->SYSCLKSource == 1) {\n      while ((DAT_08005a10[1] & 0xc) != 4) {\n        tick_current = HAL_GetTick();\n        if (5000 < tick_current - tick_start) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else if (clock_init_struct->SYSCLKSource == 2) {\n      while ((DAT_08005a10[1] & 0xc) != 8) {\n        tick_current = HAL_GetTick();\n        if (5000 < tick_current - tick_start) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      while ((DAT_08005a10[1] & 0xc) != 0) {\n        tick_current = HAL_GetTick();\n        if (5000 < tick_current - tick_start) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  ptr_to_dat_08005a0c = DAT_08005a0c;\n  if ((flash_latency < (*DAT_08005a0c & 7)) &&\n     (*DAT_08005a0c = *DAT_08005a0c & 0xfffffff8 | flash_latency, flash_latency != (*ptr_to_dat_08005a0c & 7))) {\n    return HAL_ERROR;\n  }\n  if ((clock_init_struct->ClockType & 4) != 0) {\n    DAT_08005a10[1] = DAT_08005a10[1] & 0xfffff8ff | clock_init_struct->APB1CLKDivider;\n  }\n  if ((clock_init_struct->ClockType & 8) != 0) {\n    DAT_08005a10[1] = DAT_08005a10[1] & 0xffffc7ff | clock_init_struct->APB2CLKDivider << 3;\n  }\n  sysclk_source = HAL_RCC_GetSysClockFreq();\n  *(uint *)PTR_SystemCoreClock_08005a18 =\n       sysclk_source >> PTR_AHBPrescTable_08005a14[(DAT_08005a10[1] << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_GetTick",
                "HAL_InitTick",
                "HAL_RCC_GetSysClockFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058ac",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configure_clocks_080058ac"
        },
        "FUN_08007438": {
            "renaming": {
                "FUN_08007438": "configure_timer_08007438",
                "htim": "timer_handle",
                "tmpreg": "temporary_register_1",
                "tmpreg_1": "temporary_register_2",
                "tmpreg_2": "temporary_register_3",
                "tmpreg_3": "temporary_register_4",
                "Instance": "timer_instance",
                "TIM_TypeDef_conflict": "timer_type_conflict",
                "DIER": "interrupt_enable_register",
                "CCMR1": "capture_compare_mode_register_1",
                "SMCR": "slave_mode_control_register"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid configure_timer_08007438(TIM_HandleTypeDef_conflict *timer_handle)\n\n{\n  uint32_t temporary_register_1;\n  uint32_t temporary_register_2;\n  uint32_t temporary_register_3;\n  uint32_t temporary_register_4;\n  \n  if (timer_handle->timer_instance == DAT_080074d0) {\n    DAT_080074d0[0x2b7].interrupt_enable_register = DAT_080074d0[0x2b7].interrupt_enable_register | 0x800;\n    *(TIM_HandleTypeDef_conflict **)PTR_timer_handles_080074dc = timer_handle;\n  }\n  if (timer_handle->timer_instance == (timer_type_conflict *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c | 1;\n    *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_080074dc + 4) = timer_handle;\n  }\n  if (timer_handle->timer_instance == DAT_080074d4) {\n    DAT_080074d4[0x63d].capture_compare_mode_register_1 = DAT_080074d4[0x63d].capture_compare_mode_register_1 | 2;\n    *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_080074dc + 8) = timer_handle;\n  }\n  if (timer_handle->timer_instance == DAT_080074d8) {\n    DAT_080074d8[0x631].slave_mode_control_register = DAT_080074d8[0x631].slave_mode_control_register | 4;\n    *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_080074dc + 0xc) = timer_handle;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007438",
            "calling": [
                "HAL_TIM_PWM_MspInit",
                "HAL_TIM_OC_MspInit"
            ],
            "imported": false,
            "current_name": "configure_timer_08007438"
        },
        "FUN_0800306c": {
            "renaming": {
                "FUN_0800306c": "initialize_static_variables_0800306c"
            },
            "code": "\nvoid initialize_static_variables_0800306c(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800306c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_0800306c"
        },
        "FUN_0800887c": {
            "renaming": {
                "FUN_0800887c": "get_process_id_0800887c"
            },
            "code": "\n__pid_t get_process_id_0800887c(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800887c",
            "calling": [
                "_getpid_r"
            ],
            "imported": false,
            "current_name": "get_process_id_0800887c"
        },
        "FUN_0800863c": {
            "renaming": {
                "FUN_0800863c": "initialize_serial_rx_0800863c",
                "obj": "serial_obj",
                "callback": "rx_callback",
                "bVar1": "index_byte",
                "uVar2": "rx_active_byte",
                "HAL_NVIC_SetPriority": "set_irq_priority",
                "HAL_NVIC_EnableIRQ": "enable_irq",
                "HAL_UART_Receive_IT": "uart_receive_interrupt"
            },
            "code": "\nvoid initialize_serial_rx_0800863c(serial_t *serial_obj,_func_void_serial_t_ptr *rx_callback)\n\n{\n  byte index_byte;\n  uint8_t rx_active_byte;\n  \n  if (serial_obj != (serial_t *)0x0) {\n    rx_active_byte = serial_rx_active(serial_obj);\n    if (rx_active_byte == '\\0') {\n      index_byte = serial_obj->index;\n      *(_func_void_serial_t_ptr **)(PTR_rx_rx_callback_08008688 + (uint)index_byte * 4) = rx_callback;\n      *(serial_t **)(PTR_rx_rx_callback_serial_obj_0800868c + (uint)index_byte * 4) = serial_obj;\n      set_irq_priority(serial_obj->irq,0,1);\n      enable_irq(serial_obj->irq);\n      uart_receive_interrupt(*(UART_HandleTypeDef **)\n                           (PTR_uart_handlers_08008690 + (uint)serial_obj->index * 4),&serial_obj->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "HAL_NVIC_EnableIRQ",
                "serial_rx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800863c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initialize_serial_rx_0800863c"
        },
        "FUN_08004050": {
            "renaming": {
                "FUN_08004050": "reset_dma_channel_08004050",
                "hdma": "dma_handle",
                "uVar1": "reset_value",
                "pDVar2": "dma_channel",
                "HAL_DMA_STATE_BUSY": "DMA_BUSY",
                "HAL_DMA_STATE_READY": "DMA_READY",
                "HAL_UNLOCKED": "DMA_UNLOCKED",
                "HAL_OK": "DMA_OK",
                "HAL_ERROR": "DMA_ERROR",
                "XferAbortCallback": "DMA_abort_callback",
                "ErrorCode": "DMA_error_code",
                "Instance": "DMA_instance",
                "CNDTR": "DMA_transfer_counter",
                "CPAR": "DMA_peripheral_address",
                "CMAR": "DMA_memory_address",
                "CCR": "DMA_control_register",
                "State": "DMA_state",
                "Lock": "DMA_lock"
            },
            "code": "\nHAL_StatusTypeDef_conflict reset_DMA_channel_08004050(DMA_HandleTypeDef_conflict *dma_handle)\n\n{\n  undefined4 reset_value;\n  DMA_Channel_TypeDef_conflict *dma_channel;\n  \n  if (dma_handle->DMA_state != DMA_BUSY) {\n    dma_handle->DMA_error_code = 4;\n    return DMA_ERROR;\n  }\n  dma_handle->DMA_instance->DMA_control_register = dma_handle->DMA_instance->DMA_control_register & 0xfffffff1;\n  dma_handle->DMA_instance->DMA_control_register = dma_handle->DMA_instance->DMA_control_register & 0xfffffffe;\n  dma_channel = dma_handle->DMA_instance;\n  if (dma_channel == DAT_080040e0) {\n    reset_value = 1;\n  }\n  else if (dma_channel == (DMA_Channel_TypeDef_conflict *)&DAT_080040e0[1].DMA_transfer_counter) {\n    reset_value = 0x10;\n  }\n  else if (dma_channel == (DMA_Channel_TypeDef_conflict *)&DAT_080040e0[2].DMA_peripheral_address) {\n    reset_value = 0x100;\n  }\n  else if (dma_channel == (DMA_Channel_TypeDef_conflict *)&DAT_080040e0[3].DMA_memory_address) {\n    reset_value = 0x1000;\n  }\n  else if (dma_channel == DAT_080040e0 + 5) {\n    reset_value = 0x10000;\n  }\n  else if (dma_channel == (DMA_Channel_TypeDef_conflict *)&DAT_080040e0[6].DMA_transfer_counter) {\n    reset_value = 0x100000;\n  }\n  else {\n    reset_value = 0x1000000;\n  }\n  *(undefined4 *)(DAT_080040e4 + 4) = reset_value;\n  dma_handle->DMA_state = DMA_READY;\n  dma_handle->DMA_lock = DMA_UNLOCKED;\n  if (dma_handle->DMA_abort_callback != (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0) {\n    (*dma_handle->DMA_abort_callback)(dma_handle);\n    return DMA_OK;\n  }\n  return DMA_OK;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004050",
            "calling": [
                "HAL_UART_IRQHandler",
                "I2C_ITError"
            ],
            "imported": false,
            "current_name": "reset_dma_channel_08004050"
        },
        "FUN_08008e14": {
            "renaming": {
                "FUN_08008e14": "initialize_ip_address_08008e14",
                "__initialize_p": "isInitializationRequired",
                "__priority": "priorityValue",
                "IPAddress": "IPAddressConstructor"
            },
            "code": "\nvoid initializeIPAddress_08008e14(int isInitializationRequired,int priorityValue)\n\n{\n  if ((isInitializationRequired == 1) && (priorityValue == 0xffff)) {\n    IPAddressConstructor::IPAddressConstructor((IPAddressConstructor *)PTR_INADDR_NONE_08008e3c,'\\0','\\0','\\0','\\0');\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "IPAddress"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e14",
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "imported": false,
            "current_name": "initialize_ip_address_08008e14"
        },
        "FUN_08005a28": {
            "renaming": {
                "FUN_08005a28": "get_apb_prescaler_value_08005a28",
                "uVar1": "HCLK_frequency"
            },
            "code": "\nuint32_t get_APB_prescaler_value_08005a28(void)\n\n{\n  uint32_t HCLK_frequency;\n  \n  HCLK_frequency = HAL_RCC_GetHCLKFreq();\n  return HCLK_frequency >> PTR_APBPrescTable_08005a44[(uint)(*(int *)(DAT_08005a40 + 4) << 0x15) >> 0x1d];\n}\n\n",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a28",
            "calling": [
                "getTimerClkFreq",
                "HAL_I2C_Init",
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "get_apb_prescaler_value_08005a28"
        },
        "FUN_08008ac6": {
            "renaming": {
                "FUN_08008ac6": "update_tx_tail_08008ac6",
                "obj": "serial_object",
                "uVar1": "next_tx_tail",
                "uVar2": "masked_tx_tail",
                "iVar3": "current_tx_tail"
            },
            "code": "\nint HardwareSerial::update_tx_tail_08008ac6(serial_t_conflict *serial_object)\n\n{\n  ushort next_tx_tail;\n  uint16_t masked_tx_tail;\n  int current_tx_tail;\n  \n  current_tx_tail = serial_object->tx_tail + 1;\n  next_tx_tail = (ushort)current_tx_tail;\n  masked_tx_tail = next_tx_tail & 0x7f;\n  if (current_tx_tail == 0) {\n    masked_tx_tail = -(-next_tx_tail & 0x7f);\n  }\n  serial_object->tx_tail = masked_tx_tail;\n  if (serial_object->tx_head != serial_object->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ac6",
            "calling": [],
            "imported": false,
            "current_name": "update_tx_tail_08008ac6"
        },
        "FUN_08003002": {
            "renaming": {
                "this": "firmataInstance",
                "pinMode": "setPinMode",
                "strobeBlinkPin": "blinkPin",
                "delay": "wait",
                "FUN_08003002": "initialize_blink_sequence_08003002"
            },
            "code": "\nvoid __firmataInstancecall firmata::FirmataClass::initializeBlinkSequence_08003002(FirmataClass *firmataInstance)\n\n{\n  if (firmataInstance->initializeBlinkSequence_08003002Disabled != false) {\n    return;\n  }\n  setPinMode(0xd,1);\n  blinkPin(firmataInstance,'\\r',2,0x28,0xd2);\n  wait(0xfa);\n  blinkPin(firmataInstance,'\\r',5,0x28,0xd2);\n  wait(0x7d);\n  return;\n}\n\n",
            "called": [
                "delay",
                "strobeBlinkPin",
                "pinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003002",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initialize_blink_sequence_08003002"
        },
        "FUN_08008ac4": {
            "renaming": {
                "FUN_08008ac4": "do_nothing_08008ac4"
            },
            "code": "\nvoid do_nothing_08008ac4(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ac4",
            "calling": [
                "strobeBlinkPin",
                "blinkVersion"
            ],
            "imported": false,
            "current_name": "do_nothing_08008ac4"
        },
        "FUN_08003366": {
            "renaming": {
                "FUN_08003366": "set_string_callback_08003366",
                "this": "parser",
                "command": "cmd",
                "newFunction": "callback",
                "context": "ctx",
                "currentStringCallback": "currentCallback",
                "currentStringCallbackContext": "currentCallbackCtx"
            },
            "code": "\nvoid __parsercall\nfirmata::FirmataParser::setStringCallback_08003366(FirmataParser *parser,uint8_t cmd,stringCallbackFunction callback,void *ctx)\n\n{\n  if (cmd == 'q') {\n    parser->currentCallback = callback;\n    parser->currentCallbackCtx = ctx;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003366",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "set_string_callback_08003366"
        },
        "FUN_080091b0": {
            "renaming": {
                "FUN_080091b0": "copy_memory_080091b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_bytes",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "code": "\nvoid * copy_memory_080091b0(void *destination,void *source,size_t num_bytes)\n\n{\n  undefined *dest_ptr;\n  undefined *src_ptr;\n  \n  src_ptr = (undefined *)((int)destination + -1);\n  dest_ptr = (undefined *)(num_bytes + (int)source);\n  for (; (undefined *)source != dest_ptr; source = (void *)((int)source + 1)) {\n    src_ptr = src_ptr + 1;\n    *src_ptr = *source;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return destination;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091b0",
            "calling": [
                "write",
                "_realloc_r",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "copy_memory_080091b0"
        },
        "FUN_08009908": {
            "renaming": {
                "FUN_08009908": "allocate_memory_block_08009908",
                "__ptr": "memory_block_pointer",
                "__size": "block_size",
                "pvVar1": "allocated_block_pointer"
            },
            "code": "\nvoid * allocate_memory_block_08009908(void *memory_block_pointer,size_t block_size)\n\n{\n  void *allocated_block_pointer;\n  \n  allocated_block_pointer = (void *)_allocate_memory_block_08009908_r(*(undefined4 *)PTR__impure_ptr_08009914,memory_block_pointer,block_size);\n  return allocated_block_pointer;\n}\n\n",
            "called": [
                "_realloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009908",
            "calling": [
                "write",
                "write",
                "allocateRxBuffer"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_08009908"
        },
        "FUN_08008abc": {
            "renaming": {
                "FUN_08008abc": "get_current_milliseconds_08008abc",
                "uVar1": "current_milliseconds"
            },
            "code": "\nuint32_t get_current_milliseconds_08008abc(void)\n\n{\n  uint32_t current_milliseconds;\n  \n  current_milliseconds = GetCurrentMilli();\n  return current_milliseconds;\n}\n\n",
            "called": [
                "GetCurrentMilli"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008abc",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "get_current_milliseconds_08008abc"
        },
        "FUN_08002b68": {
            "renaming": {
                "this": "wire",
                "address": "deviceAddress",
                "quantity": "dataSize",
                "iaddress": "internalAddress",
                "isize": "internalAddressSize",
                "sendStop": "stopBit",
                "i2c_status_e_conflict": "I2CStatus",
                "uVar2": "internalAddressByteSize",
                "master": "isMaster",
                "allocateRxBuffer": "allocateReceiveBuffer",
                "beginTransmission": "startTransmission",
                "endTransmission": "stopTransmission",
                "i2c_master_read": "readI2CMaster",
                "i2c_t_conflict": "I2CType",
                "_i2c": "i2c",
                "I2C_OK": "I2CStatusOK",
                "FUN_08002b68": "read_i2_c_data_08002b68"
            },
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08002bb2 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nuint8_t __wirecall\nTwoWire::readI2CData_08002b68(TwoWire *wire,uint8_t deviceAddress,uint8_t dataSize,uint32_t internalAddress,uint8_t internalAddressSize,\n          uint8_t stopBit)\n\n{\n  I2CStatus iVar1;\n  uint internalAddressByteSize;\n  \n  internalAddressByteSize = (uint)internalAddressSize;\n  if (wire->isMaster == false) {\n    return '\\0';\n  }\n  allocateReceiveBuffer((uint)dataSize);\n  if (*(int *)PTR_rxBuffer_08002bf4 != 0) {\n    if (internalAddressByteSize != 0) {\n      startTransmission(wire,deviceAddress);\n      if (3 < internalAddressByteSize) {\n        internalAddressByteSize = 3;\n      }\n      while( true ) {\n        if (internalAddressByteSize == 0) break;\n        (**(wire->super_Stream).super_Print._vptr_Print)\n                  (wire,internalAddress >> ((internalAddressByteSize - 1 & 0x1f) << 3) & 0xff);\n        internalAddressByteSize = internalAddressByteSize - 1 & 0xff;\n      }\n      stopTransmission(wire,'\\0');\n    }\n    iVar1 = readI2CMaster((I2CType *)&wire->i2c,deviceAddress << 1,\n                            *(uint8_t **)PTR_rxBuffer_08002bf4,(ushort)dataSize);\n    if (iVar1 != I2CStatusOK) {\n      dataSize = '\\0';\n    }\n    *PTR_rxBufferIndex_08002bf8 = 0;\n    *PTR_rxBufferLength_08002bfc = dataSize;\n    return dataSize;\n  }\n  (wire->super_Stream).super_Print.write_error = 1;\n  return '\\0';\n}\n\n",
            "called": [
                "beginTransmission",
                "endTransmission",
                "i2c_master_read",
                "allocateRxBuffer"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002b68",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "read_i2_c_data_08002b68"
        },
        "FUN_080005e0": {
            "renaming": {
                "FUN_080005e0": "disable_i2_c_080005e0"
            },
            "code": "\nvoid disableI2C_080005e0(void)\n\n{\n  *PTR_isI2CEnabled_080005f0 = 0;\n  *PTR_queryIndex_080005f4 = 0xff;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080005e0",
            "calling": [
                "systemResetCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "disable_i2_c_080005e0"
        },
        "FUN_0800674c": {
            "renaming": {
                "FUN_0800674c": "do_nothing_0800674c"
            },
            "code": "\nvoid do_nothing_0800674c(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800674c",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_0800674c"
        },
        "FUN_0800674e": {
            "renaming": {
                "FUN_0800674e": "initialize_uart_0800674e",
                "huart": "uart_handle",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_UART_MspInit": "initialize_uart_pins",
                "UART_SetConfig": "set_uart_config",
                "Instance": "uart_instance",
                "CR1": "uart_cr1",
                "CR2": "uart_cr2",
                "CR3": "uart_cr3",
                "ErrorCode": "uart_error_code",
                "Lock": "uart_lock"
            },
            "code": "\nHAL_StatusTypeDef initialize_uart_0800674e(UART_HandleTypeDef *uart_handle)\n\n{\n  if (uart_handle != (UART_HandleTypeDef *)0x0) {\n    if (uart_handle->gState == HAL_UART_STATE_RESET) {\n      uart_handle->uart_lock = HAL_UNLOCKED;\n      initialize_uart_0800674e_pins(uart_handle);\n    }\n    uart_handle->gState = HAL_UART_STATE_BUSY;\n    uart_handle->uart_instance->uart_cr1 = uart_handle->uart_instance->uart_cr1 & 0xffffdfff;\n    set_uart_config(uart_handle);\n    uart_handle->uart_instance->uart_cr2 = uart_handle->uart_instance->uart_cr2 & 0xffffb7ff;\n    uart_handle->uart_instance->uart_cr3 = uart_handle->uart_instance->uart_cr3 & 0xffffffd5;\n    uart_handle->uart_instance->uart_cr1 = uart_handle->uart_instance->uart_cr1 | 0x2000;\n    uart_handle->uart_error_code = 0;\n    uart_handle->gState = HAL_UART_STATE_READY;\n    uart_handle->RxState = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800674e",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_0800674e"
        },
        "FUN_0800771c": {
            "renaming": {
                "FUN_0800771c": "handle_timer_interrupt_0800771c",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "get_timer_obj": "retrieve_timer_object",
                "irqHandleOC": "timer_interrupt_handler",
                "_func_void_stimer_t_ptr_uint32_t_conflict": "timer_interrupt_handler_function_pointer"
            },
            "code": "\nvoid handle_timer_interrupt_0800771c(TIM_HandleTypeDef_conflict *timer_handle)\n\n{\n  stimer_t_conflict *timer_obj;\n  \n  timer_obj = retrieve_timer_object(timer_handle);\n  if ((timer_obj->timer_interrupt_handler != (timer_interrupt_handler_function_pointer *)0x0) &&\n     (timer_handle->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timer_obj->timer_interrupt_handler)(timer_obj,0);\n  }\n  return;\n}\n\n",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800771c",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_0800771c"
        },
        "FUN_08003370": {
            "renaming": {
                "FUN_08003370": "set_sysex_callback_function_08003370",
                "this": "parser",
                "command": "cmd",
                "newFunction": "callback",
                "context": "callbackContext",
                "currentSysexCallback": "sysexCallback",
                "currentSysexCallbackContext": "sysexCallbackContext"
            },
            "code": "\nvoid __parsercall\nfirmata::FirmataParser::setSysexCallbackFunction_08003370(FirmataParser *parser,uint8_t cmd,sysexCallbackFunction callback,void *callbackContext)\n\n{\n  parser->sysexCallback = callback;\n  parser->sysexCallbackContext = callbackContext;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003370",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "set_sysex_callback_function_08003370"
        },
        "FUN_08003376": {
            "renaming": {
                "FUN_08003376": "handle_firmata_data_08003376",
                "this": "firmataParser",
                "data": "firmataData",
                "pos": "dataPosition",
                "bVar1": "isBufferOverflow",
                "dataBufferOverflowCallbackFunction": "bufferOverflowCallbackFunction",
                "allowBufferUpdate": "canUpdateBuffer",
                "currentDataBufferOverflowCallback": "bufferOverflowCallback",
                "currentDataBufferOverflowCallbackContext": "bufferOverflowCallbackContext",
                "dataBufferSize": "bufferSize",
                "dataBuffer": "firmataDataBuffer"
            },
            "code": "\nbool __firmataParsercall\nfirmata::FirmataParser::handleFirmataData_08003376(FirmataParser *firmataParser,uint8_t firmataData,size_t dataPosition)\n\n{\n  bool isBufferOverflow;\n  \n  if (dataPosition < firmataParser->bufferSize) {\n    isBufferOverflow = false;\n  }\n  else {\n    isBufferOverflow = true;\n    if (firmataParser->bufferOverflowCallback != (bufferOverflowCallbackFunction)0x0) {\n      firmataParser->canUpdateBuffer = true;\n      (*firmataParser->bufferOverflowCallback)(firmataParser->bufferOverflowCallbackContext);\n      if (dataPosition < firmataParser->bufferSize) {\n        isBufferOverflow = false;\n      }\n      else {\n        isBufferOverflow = true;\n      }\n    }\n  }\n  if (!isBufferOverflow) {\n    firmataParser->firmataDataBuffer[dataPosition] = firmataData;\n  }\n  return isBufferOverflow;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003376",
            "calling": [
                "parse",
                "processSysexMessage"
            ],
            "imported": false,
            "current_name": "handle_firmata_data_08003376"
        },
        "FUN_08008bf4": {
            "renaming": {
                "FUN_08008bf4": "check_serial_availability_08008bf4"
            },
            "code": "\nvoid check_serial_availability_08008bf4(void)\n\n{\n  if (DAT_08008c18 != 0) {\n    HardwareSerial::available((HardwareSerial *)PTR_Serial2_08008c1c);\n  }\n  return;\n}\n\n",
            "called": [
                "available"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008bf4",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "check_serial_availability_08008bf4"
        },
        "FUN_08002c7c": {
            "renaming": {
                "FUN_08002c7c": "process_analog_command_08002c7c",
                "param_1": "data_ptr",
                "command": "command_num",
                "value": "command_val"
            },
            "code": "\nvoid firmata::FirmataClass::process_analog_command_08002c7c(void *data_ptr,uint8_t command_num,uint16_t command_val)\n\n{\n  if (*(code **)PTR_currentReportAnalogCallback_08002c8c != (code *)0x0) {\n    (**(code **)PTR_currentReportAnalogCallback_08002c8c)(command_num,command_val);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c7c",
            "calling": [],
            "imported": false,
            "current_name": "process_analog_command_08002c7c"
        },
        "FUN_08005430": {
            "renaming": {
                "FUN_08005430": "get_i2_c_error_code_08005430",
                "hi2c": "i2cHandler",
                "ErrorCode": "errorCode"
            },
            "code": "\nuint32_t getI2CErrorCode_08005430(I2C_HandleTypeDef_conflict *i2cHandler)\n\n{\n  return i2cHandler->errorCode;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005430",
            "calling": [
                "i2c_master_read",
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "get_i2_c_error_code_08005430"
        },
        "FUN_08009918": {
            "renaming": {
                "FUN_08009918": "allocate_memory_08009918",
                "param_1": "memory_address",
                "param_2": "memory_size",
                "puVar1": "errno_ptr",
                "pcVar2": "allocated_memory_ptr"
            },
            "code": "\nvoid allocate_memory_08009918(int *memory_address,int memory_size)\n\n{\n  undefined *errno_ptr;\n  caddr_t allocated_memory_ptr;\n  \n  errno_ptr = PTR_errno_08009934;\n  *(undefined4 *)PTR_errno_08009934 = 0;\n  allocated_memory_ptr = _sbrk(memory_size);\n  if ((allocated_memory_ptr == (caddr_t)0xffffffff) && (*(int *)errno_ptr != 0)) {\n    *memory_address = *(int *)errno_ptr;\n  }\n  return;\n}\n\n",
            "called": [
                "_sbrk"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009918",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009918"
        },
        "FUN_08005434": {
            "renaming": {
                "FUN_08005434": "delay_for_milliseconds_08005434",
                "mdelay": "milliseconds",
                "Delay": "delay_cycles",
                "bVar1": "delay_not_zero"
            },
            "code": "\nvoid delay_for_milliseconds_08005434(uint32_t milliseconds)\n\n{\n  bool delay_not_zero;\n  uint32_t delay_cycles;\n  \n  delay_cycles = milliseconds * (uint)((ulonglong)DAT_0800545c * (ulonglong)*(uint *)PTR_SystemCoreClock_08005458\n                         >> 0x29);\n  do {\n    delay_not_zero = delay_cycles != 0;\n    delay_cycles = delay_cycles - 1;\n  } while (delay_not_zero);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005434",
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "imported": false,
            "current_name": "delay_for_milliseconds_08005434"
        },
        "FUN_08005e2e": {
            "renaming": {
                "FUN_08005e2e": "reset_tim_08005e2e",
                "htim": "TIM_handle",
                "HAL_TIM_STATE_BUSY": "TIM_busy",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "pTVar1": "TIM_instance",
                "CCER": "Capture_Compare_Enable_Register",
                "CR1": "Control_Register_1",
                "HAL_TIM_PWM_MspDeInit": "deinitialize_TIM_PWM",
                "HAL_TIM_STATE_RESET": "TIM_reset",
                "HAL_UNLOCKED": "unlocked",
                "HAL_OK": "TIM_OK"
            },
            "code": "\nHAL_StatusTypeDef_conflict reset_TIM_08005e2e(TIM_HandleTypeDef_conflict *TIM_handle)\n\n{\n  TIM_TypeDef *TIM_instance;\n  \n  TIM_handle->State = TIM_busy;\n  TIM_instance = TIM_handle->Instance;\n  if (((TIM_instance->Capture_Compare_Enable_Register & 0x1111) == 0) && ((TIM_instance->Capture_Compare_Enable_Register & 0x444) == 0)) {\n    TIM_instance->Control_Register_1 = TIM_instance->Control_Register_1 & 0xfffffffe;\n  }\n  deinitialize_TIM_PWM(TIM_handle);\n  TIM_handle->State = TIM_reset;\n  TIM_handle->Lock = unlocked;\n  return TIM_OK;\n}\n\n",
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e2e",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "reset_tim_08005e2e"
        },
        "FUN_08007736": {
            "renaming": {
                "FUN_08007736": "handle_timer_interrupt_08007736",
                "htim": "timer_handler",
                "psVar1": "timer_obj",
                "get_timer_obj": "retrieve_timer_object",
                "irqHandle": "interrupt_handler"
            },
            "code": "\nvoid handle_timer_interrupt_08007736(TIM_HandleTypeDef_conflict *timer_handler)\n\n{\n  stimer_t_conflict *timer_obj;\n  \n  timer_obj = retrieve_timer_object(timer_handler);\n  if (timer_obj->interrupt_handler != (_func_void_stimer_t_ptr_conflict *)0x0) {\n    (*timer_obj->interrupt_handler)(timer_obj);\n  }\n  return;\n}\n\n",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007736",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007736"
        },
        "FUN_08002c90": {
            "renaming": {
                "FUN_08002c90": "report_digital_callback_08002c90",
                "param_1": "data",
                "code": "function_pointer"
            },
            "code": "\nvoid firmata::FirmataClass::reportDigitalCallback_08002c90(void *data,uint8_t command,uint16_t value)\n\n{\n  if (*(function_pointer **)PTR_currentReportDigitalCallback_08002ca0 != (function_pointer *)0x0) {\n    (**(function_pointer **)PTR_currentReportDigitalCallback_08002ca0)(command,value);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c90",
            "calling": [],
            "imported": false,
            "current_name": "report_digital_callback_08002c90"
        },
        "FUN_0800542a": {
            "renaming": {
                "FUN_0800542a": "get_i2_c_state_0800542a",
                "hi2c": "I2C_handle",
                "HAL_I2C_StateTypeDef_conflict": "I2C_state"
            },
            "code": "\nI2C_state get_I2C_state_0800542a(I2C_HandleTypeDef_conflict *I2C_handle)\n\n{\n  return I2C_handle->State;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800542a",
            "calling": [
                "i2c_master_read",
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "get_i2_c_state_0800542a"
        },
        "FUN_0800457c": {
            "renaming": {
                "FUN_0800457c": "send_byte_via_i2c_0800457c",
                "hi2c": "i2c_handle",
                "XferCount": "transfer_count",
                "pBuffPtr": "buffer_pointer",
                "Instance": "i2c_instance",
                "DR": "data_register"
            },
            "code": "\nHAL_StatusTypeDef_conflict send_byte_via_i2c_0800457c(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  byte *pbVar1;\n  \n  if (i2c_handle->transfer_count != 0) {\n    pbVar1 = i2c_handle->buffer_pointer;\n    i2c_handle->buffer_pointer = pbVar1 + 1;\n    i2c_handle->i2c_instance->data_register = (uint)*pbVar1;\n    i2c_handle->transfer_count = i2c_handle->transfer_count - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800457c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "send_byte_via_i2c_0800457c"
        },
        "FUN_080091c6": {
            "renaming": {
                "FUN_080091c6": "memset_bytes_080091c6",
                "__s": "dest",
                "__c": "byte",
                "__n": "count",
                "puVar1": "dest_ptr"
            },
            "code": "\nvoid * memset_bytes_080091c6(void *dest,int byte,size_t count)\n\n{\n  undefined *dest_ptr;\n  \n  for (dest_ptr = (undefined *)dest; dest_ptr != (undefined *)(count + (int)dest); dest_ptr = dest_ptr + 1) {\n    *dest_ptr = (char)byte;\n  }\n  return dest;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091c6",
            "calling": [
                "begin",
                "std.isra.0",
                "endTransmission",
                "pwm_start",
                "__sfp",
                "adc_read_value",
                "flush",
                "__sfmoreglue"
            ],
            "imported": false,
            "current_name": "memset_bytes_080091c6"
        },
        "FUN_08003a20": {
            "renaming": {
                "FUN_08003a20": "initialize_adc_08003a20",
                "hadc": "ADC_handle",
                "HVar1": "status",
                "uVar2": "start_tick",
                "uVar3": "current_tick",
                "pAVar4": "ADC_instance",
                "wait_loop_index": "loop_index"
            },
            "code": "\nHAL_StatusTypeDef_conflict initialize_ADC_08003a20(ADC_HandleTypeDef *ADC_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t start_tick;\n  uint32_t current_tick;\n  ADC_TypeDef *ADC_instance;\n  uint32_t loop_index;\n  \n  ADC_instance = ADC_handle->Instance;\n  if ((ADC_instance->CR2 & 1) == 0) {\n    ADC_instance->CR2 = ADC_instance->CR2 | 1;\n    for (loop_index =\n              (uint32_t)\n              ((ulonglong)DAT_08003a9c * (ulonglong)*(uint *)PTR_SystemCoreClock_08003a98 >> 0x32);\n        loop_index != 0; loop_index = loop_index - 1) {\n    }\n    start_tick = HAL_GetTick();\n    do {\n      if ((ADC_handle->Instance->CR2 & 1) != 0) {\n        return HAL_OK;\n      }\n      current_tick = HAL_GetTick();\n    } while (current_tick - start_tick < 3);\n    ADC_handle->State = ADC_handle->State | 0x10;\n    ADC_handle->ErrorCode = ADC_handle->ErrorCode | 1;\n    ADC_handle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  else {\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a20",
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start"
            ],
            "imported": false,
            "current_name": "initialize_adc_08003a20"
        },
        "FUN_08009cdc": {
            "renaming": {
                "std_isra_0": "initialize_data_struct",
                "param_1": "data_struct_ptr",
                "param_2": "initial_value_1",
                "param_3": "initial_value_2",
                "uVar1": "default_value",
                "param_1[1]": "data_struct_ptr[1]",
                "param_1[2]": "data_struct_ptr[2]",
                "param_1[0x19]": "data_struct_ptr[25]",
                "param_1[4]": "data_struct_ptr[4]",
                "param_1[5]": "data_struct_ptr[5]",
                "param_1[6]": "data_struct_ptr[6]",
                "param_1[8]": "data_struct_ptr[8]",
                "param_1[9]": "data_struct_ptr[9]",
                "param_1[10]": "data_struct_ptr[10]",
                "param_1[0xb]": "data_struct_ptr[11]",
                "param_1[0xc]": "data_struct_ptr[12]",
                "FUN_08009cdc": "initialize_data_struct_08009cdc"
            },
            "code": "\nvoid initialize_data_struct_08009cdc(undefined4 *data_struct_ptr,undefined2 initial_value_1,undefined2 initial_value_2)\n\n{\n  undefined4 default_value;\n  \n  *data_struct_ptr = 0;\n  data_struct_ptr[1] = 0;\n  data_struct_ptr[2] = 0;\n  *(undefined2 *)(data_struct_ptr + 3) = initial_value_1;\n  data_struct_ptr[25] = 0;\n  *(undefined2 *)((int)data_struct_ptr + 0xe) = initial_value_2;\n  data_struct_ptr[4] = 0;\n  data_struct_ptr[5] = 0;\n  data_struct_ptr[6] = 0;\n  memset(data_struct_ptr + 0x17,0,8);\n  default_value = DAT_08009d14;\n  data_struct_ptr[8] = data_struct_ptr;\n  data_struct_ptr[9] = default_value;\n  data_struct_ptr[10] = DAT_08009d18;\n  data_struct_ptr[11] = DAT_08009d1c;\n  data_struct_ptr[12] = DAT_08009d20;\n  return;\n}\n\n",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009cdc",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_data_struct_08009cdc"
        },
        "FUN_080026b0": {
            "renaming": {
                "this": "servo",
                "value": "servo_value",
                "map": "map_value",
                "FUN_080026b0": "map_servo_value_to_microseconds_080026b0"
            },
            "code": "\nvoid __servocall Servo::map_servo_value_to_microseconds_080026b0(Servo *servo,int servo_value)\n\n{\n  if (servo_value < 0x220) {\n    if (servo_value < 0) {\n      servo_value = 0;\n    }\n    else if (0xb4 < servo_value) {\n      servo_value = 0xb4;\n    }\n    servo_value = map_value(servo_value,0,0xb4,(0x88 - servo->min) * 4,(600 - servo->max) * 4);\n  }\n  map_servo_value_to_microseconds_080026b0Microseconds(servo,servo_value);\n  return;\n}\n\n",
            "called": [
                "map",
                "writeMicroseconds"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026b0",
            "calling": [
                "analogWriteCallback"
            ],
            "imported": false,
            "current_name": "map_servo_value_to_microseconds_080026b0"
        },
        "FUN_08002a58": {
            "renaming": {
                "this": "wire_obj",
                "sendStop": "send_stop",
                "i2c_status_e_conflict": "i2c_status",
                "uVar2": "return_val",
                "master": "is_master",
                "i2c_t_conflict": "i2c_t",
                "_i2c": "i2c_obj",
                "iVar1": "i2c_status_val",
                "I2C_OK": "I2C_SUCCESS",
                "I2C_TIMEOUT": "I2C_TIMED_OUT",
                "memset": "clear_memory",
                "FUN_08002a58": "transmit_i2c_data_08002a58"
            },
            "code": "\nuint8_t __wire_objcall TwoWire::transmit_i2c_data_08002a58(TwoWire *wire_obj,uint8_t send_stop)\n\n{\n  i2c_status i2c_status_val;\n  uint8_t return_val;\n  \n  if (wire_obj->is_master == false) {\n    return_val = '\\x04';\n  }\n  else {\n    i2c_status_val = i2c_is_master_write((i2c_t *)&wire_obj->i2c_obj,*PTR_txAddress_08002ab0,\n                             *(uint8_t **)PTR_txBuffer_08002aac,\n                             (ushort)(byte)*PTR_txBufferLength_08002aa8);\n    if (i2c_status_val == I2C_SUCCESS) {\n      return_val = '\\0';\n    }\n    else if (i2c_status_val == I2C_TIMED_OUT) {\n      return_val = '\\x01';\n    }\n    else {\n      return_val = '\\x04';\n    }\n    if (*(void **)PTR_txBuffer_08002aac != (void *)0x0) {\n      clear_memory(*(void **)PTR_txBuffer_08002aac,0,(uint)(byte)*PTR_txBufferAllocated_08002ab4);\n    }\n    *PTR_txBufferIndex_08002ab8 = 0;\n    *PTR_txBufferLength_08002aa8 = 0;\n    *PTR_transmitting_08002abc = 0;\n  }\n  return return_val;\n}\n\n",
            "called": [
                "memset",
                "i2c_master_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a58",
            "calling": [
                "requestFrom",
                "endTransmission",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "transmit_i2c_data_08002a58"
        },
        "FUN_080004d4": {
            "renaming": {
                "FUN_080004d4": "initialize_servos_080004d4",
                "__initialize_p": "is_initialized",
                "__priority": "priority_level",
                "this": "servo_instance",
                "iVar1": "loop_counter"
            },
            "code": "\nvoid initialize_servos_080004d4(int is_initialized,int priority_level)\n\n{\n  int loop_counter;\n  Servo *servo_instance;\n  \n  if (is_initialized != 1) {\n    return;\n  }\n  if (priority_level == 0xffff) {\n    servo_instance = (Servo *)PTR_servos_080004fc;\n    for (loop_counter = 0xb; -1 < loop_counter; loop_counter = loop_counter + -1) {\n      Servo::Servo(servo_instance);\n      servo_instance = servo_instance + 1;\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "Servo"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004d4",
            "calling": [
                "_GLOBAL__sub_I_analogInputsToReport"
            ],
            "imported": false,
            "current_name": "initialize_servos_080004d4"
        },
        "FUN_080005f8": {
            "renaming": {
                "FUN_080005f8": "configure_pin_080005f8",
                "this": "self",
                "bVar1": "pinModeResult",
                "PVar2": "pinName",
                "bVar3": "isPinValid",
                "bVar4": "isServoAttached",
                "_Var5": "isPinInPinMap",
                "ulPin": "pinNumber",
                "uVar6": "digitalPin",
                "uVar8": "analogPin",
                "cVar7": "isI2CEnabled",
                "pinNametoDigitalPin": "convertPinNametoDigitalPin",
                "Servo::attached": "isServoAttached",
                "pinMode": "setPinMode",
                "digitalWrite": "setDigitalPinState",
                "analogWrite": "setAnalogPinState",
                "firmata::FirmataClass::sendString": "sendString"
            },
            "code": "\nvoid configurePin_080005f8(byte pin,int mode)\n\n{\n  undefined *self;\n  byte pinModeResult;\n  PinName_conflict pinName;\n  bool isPinValid;\n  bool isServoAttached;\n  _Bool isPinInPinMap;\n  uint pinNumber;\n  uint32_t digitalPin;\n  char isI2CEnabled;\n  uint analogPin;\n  \n  pinNumber = (uint)pin;\n  pinModeResult = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000874,pin);\n  if (pinModeResult != '\\x7f') {\n    pinModeResult = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000874,pin);\n    if (pinModeResult == '\\x06') {\n      isI2CEnabled = *PTR_isI2CEnabled_0800087c;\n      if (isI2CEnabled == '\\0') {\n        isI2CEnabled = '\\0';\n      }\n      else if (mode == 6) {\n        isI2CEnabled = '\\0';\n      }\n    }\n    else {\n      isI2CEnabled = '\\0';\n    }\n    if (isI2CEnabled != '\\0') {\n      disableI2CPins();\n    }\n    if (pinNumber < 0x3c) {\n      if (PTR_digitalPin_08000878[pinNumber] == NC) {\n        isPinValid = false;\n      }\n      else {\n        digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000878[pinNumber]);\n        if (digitalPin == 0) {\n          isPinValid = false;\n        }\n        else {\n          digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000878[pinNumber]);\n          if (digitalPin == 1) {\n            isPinValid = false;\n          }\n          else if (mode == 4) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = true;\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      if ((byte)PTR_servoPinMap_08000880[pinNumber] < 0xc) {\n        isPinValid = isServoAttached((Servo *)(PTR_servos_08000884 +\n                                         (uint)(byte)PTR_servoPinMap_08000880[pinNumber] * 3));\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid != false) {\n        detachServo(pin);\n      }\n    }\n    analogPin = pinNumber - 0x2e & 0xff;\n    if (analogPin < 0xe) {\n      if (pinNumber < 0x3c) {\n        pinName = PTR_digitalPin_08000878[pinNumber];\n      }\n      else {\n        pinName = NC;\n      }\n      digitalPin = convertPinNametoDigitalPin(pinName);\n      if (digitalPin == 0) {\n        isPinValid = false;\n      }\n      else {\n        if (pinNumber < 0x3c) {\n          pinName = PTR_digitalPin_08000878[pinNumber];\n        }\n        else {\n          pinName = NC;\n        }\n        digitalPin = convertPinNametoDigitalPin(pinName);\n        if (digitalPin == 1) {\n          isPinValid = false;\n        }\n        else {\n          isPinValid = true;\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      reportAnalogCallback((byte)analogPin,(uint)(mode == 2));\n    }\n    if (pinNumber < 0x3c) {\n      if (PTR_digitalPin_08000878[pinNumber] == NC) {\n        isPinValid = false;\n      }\n      else {\n        digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000878[pinNumber]);\n        if (digitalPin == 0) {\n          isPinValid = false;\n        }\n        else {\n          digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000878[pinNumber]);\n          if (digitalPin == 1) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = true;\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      if ((mode == 0) || (mode == 0xb)) {\n        PTR_portConfigInputs_08000888[pin >> 3] =\n             PTR_portConfigInputs_08000888[pin >> 3] | (byte)(1 << (pinNumber & 7));\n      }\n      else {\n        PTR_portConfigInputs_08000888[pin >> 3] =\n             PTR_portConfigInputs_08000888[pin >> 3] & ~(byte)(1 << (pinNumber & 7));\n      }\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000874,pin,0);\n    switch(mode) {\n    case 0:\n      if (pinNumber < 0x3c) {\n        if (PTR_digitalPin_08000878[pinNumber] == NC) {\n          isPinValid = false;\n        }\n        else {\n          digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000878[pinNumber]);\n          if (digitalPin == 0) {\n            isPinValid = false;\n          }\n          else {\n            digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000878[pinNumber]);\n            if (digitalPin == 1) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        setPinMode(pinNumber,0);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000874,pin,'\\0');\n        return;\n      }\n      break;\n    case 1:\n      if (pinNumber < 0x3c) {\n        if (PTR_digitalPin_08000a48[pinNumber] == NC) {\n          isPinValid = false;\n        }\n        else {\n          digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000a48[pinNumber]);\n          if (digitalPin == 0) {\n            isPinValid = false;\n          }\n          else {\n            digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000a48[pinNumber]);\n            if (digitalPin == 1) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        pinModeResult = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000a44,pin);\n        if (pinModeResult == '\\x03') {\n          setDigitalPinState(pinNumber,0);\n        }\n        setPinMode(pinNumber,1);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x01');\n        return;\n      }\n      break;\n    case 2:\n      if (analogPin < 0xe) {\n        if (pinNumber < 0x3c) {\n          pinName = PTR_digitalPin_08000878[pinNumber];\n        }\n        else {\n          pinName = NC;\n        }\n        digitalPin = convertPinNametoDigitalPin(pinName);\n        if (digitalPin == 0) {\n          isPinValid = false;\n        }\n        else {\n          if (pinNumber < 0x3c) {\n            pinName = PTR_digitalPin_08000878[pinNumber];\n          }\n          else {\n            pinName = NC;\n          }\n          digitalPin = convertPinNametoDigitalPin(pinName);\n          if (digitalPin == 1) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = true;\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        if (pinNumber < 0x3c) {\n          if (PTR_digitalPin_08000878[pinNumber] == NC) {\n            isPinValid = false;\n          }\n          else {\n            digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000878[pinNumber]);\n            if (digitalPin == 0) {\n              isPinValid = false;\n            }\n            else {\n              digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000878[pinNumber]);\n              if (digitalPin == 1) {\n                isPinValid = false;\n              }\n            }\n          }\n        }\n        else {\n          isPinValid = false;\n        }\n        if (isPinValid) {\n          setPinMode(pinNumber,0);\n        }\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000874,pin,'\\x02');\n        return;\n      }\n      break;\n    case 3:\n      if (pinNumber < 0x3c) {\n        if (PTR_digitalPin_08000a48[pinNumber] == NC) {\n          isPinInPinMap = false;\n        }\n        else {\n          digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000a48[pinNumber]);\n          if (digitalPin == 0) {\n            isPinInPinMap = false;\n          }\n          else {\n            digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000a48[pinNumber]);\n            if (digitalPin == 1) {\n              isPinInPinMap = false;\n            }\n            else {\n              isPinInPinMap = pin_in_pinmap(PTR_digitalPin_08000a48[pinNumber],\n                                    (PinMap_conflict *)PTR_PinMap_PWM_08000a4c);\n            }\n          }\n        }\n      }\n      else {\n        isPinInPinMap = false;\n      }\n      if (isPinInPinMap != false) {\n        setPinMode(pinNumber,1);\n        setAnalogPinState(pinNumber,0);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x03');\n        return;\n      }\n      break;\n    case 4:\n      if (pinNumber < 0x3c) {\n        if (PTR_digitalPin_08000a48[pinNumber] == NC) {\n          isPinValid = false;\n        }\n        else {\n          digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000a48[pinNumber]);\n          if (digitalPin == 0) {\n            isPinValid = false;\n          }\n          else {\n            digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000a48[pinNumber]);\n            if (digitalPin == 1) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x04');\n        if (((byte)PTR_servoPinMap_08000a50[pinNumber] != 0xff) &&\n           (isServoAttached = isServoAttached((Servo *)(PTR_servos_08000a54 +\n                                             (uint)(byte)PTR_servoPinMap_08000a50[pinNumber] * 3)),\n           isServoAttached)) {\n          isPinValid = false;\n        }\n        if (isPinValid) {\n          attachServo(pin,-1,-1);\n          return;\n        }\n      }\n      break;\n    default:\n      sendString\n                ((FirmataClass *)PTR_Firmata_08000a44,PTR_s_Unknown_pin_mode_08000a60);\n      break;\n    case 6:\n      if (pinNumber < 0x3c) {\n        if (PTR_digitalPin_08000a48[pinNumber] == NC) {\n          isPinInPinMap = false;\n        }\n        else {\n          digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000a48[pinNumber]);\n          if (digitalPin == 0) {\n            isPinInPinMap = false;\n          }\n          else {\n            digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000a48[pinNumber]);\n            if (digitalPin == 1) {\n              isPinInPinMap = false;\n            }\n            else {\n              isPinInPinMap = pin_in_pinmap(PTR_digitalPin_08000a48[pinNumber],\n                                    (PinMap_conflict *)PTR_PinMap_I2C_SDA_08000a58);\n              if (!isPinInPinMap) {\n                isPinInPinMap = pin_in_pinmap(PTR_digitalPin_08000a48[pinNumber],\n                                      (PinMap_conflict *)PTR_PinMap_I2C_SCL_08000a5c);\n              }\n            }\n          }\n        }\n      }\n      else {\n        isPinInPinMap = false;\n      }\n      if (isPinInPinMap != false) {\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x06');\n        return;\n      }\n      break;\n    case 10:\n      break;\n    case 0xb:\n      if (pinNumber < 0x3c) {\n        if (PTR_digitalPin_08000878[pinNumber] == NC) {\n          isPinValid = false;\n        }\n        else {\n          digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000878[pinNumber]);\n          if (digitalPin == 0) {\n            isPinValid = false;\n          }\n          else {\n            digitalPin = convertPinNametoDigitalPin(PTR_digitalPin_08000878[pinNumber]);\n            if (digitalPin == 1) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        setPinMode(pinNumber,2);\n        self = PTR_Firmata_08000a44;\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\v');\n        firmata::FirmataClass::setPinState((FirmataClass *)self,pin,1);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "attached",
                "pin_in_pinmap",
                "disableI2CPins",
                "digitalWrite",
                "pinNametoDigitalPin",
                "analogWrite",
                "pinMode",
                "sendString",
                "reportAnalogCallback",
                "setPinState",
                "attachServo",
                "detachServo",
                "getPinMode",
                "setPinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080005f8",
            "calling": [
                "enableI2CPins",
                "sysexCallback",
                "systemResetCallback"
            ],
            "imported": false,
            "current_name": "configure_pin_080005f8"
        },
        "FUN_08002fa0": {
            "renaming": {
                "FUN_08002fa0": "get_pin_configuration_08002fa0",
                "this": "self",
                "pin": "pinNumber",
                "pinConfig": "pinConfiguration"
            },
            "code": "\nbyte __selfcall firmata::FirmataClass::getPinConfiguration_08002fa0(FirmataClass *self,byte pinNumber)\n\n{\n  return self->pinConfiguration[pinNumber];\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fa0",
            "calling": [
                "loop",
                "digitalWriteCallback",
                "sysexCallback",
                "analogWriteCallback",
                "setPinValueCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "get_pin_configuration_08002fa0"
        },
        "FUN_0800a424": {
            "renaming": {
                "FUN_0800a424": "do_nothing_0800a424"
            },
            "code": "\nvoid do_nothing_0800a424(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a424",
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "do_nothing_0800a424"
        },
        "FUN_08003a1c": {
            "renaming": {
                "FUN_08003a1c": "get_adc_state_08003a1c",
                "hadc": "ADC_handle",
                "State": "ADC_state"
            },
            "code": "\nuint32_t get_ADC_state_08003a1c(ADC_HandleTypeDef *ADC_handle)\n\n{\n  return ADC_handle->ADC_state;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a1c",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_adc_state_08003a1c"
        },
        "FUN_08007744": {
            "renaming": {
                "FUN_08007744": "get_timer_counter_08007744",
                "obj": "timer_object",
                "handle": "timer_handle",
                "Instance": "timer_instance",
                "CNT": "timer_counter"
            },
            "code": "\nuint32_t get_timer_counter_08007744(stimer_t_conflict *timer_object)\n\n{\n  return ((timer_object->timer_handle).timer_instance)->timer_counter;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007744",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "get_timer_counter_08007744"
        },
        "FUN_08006538": {
            "renaming": {
                "FUN_08006538": "configure_uart_08006538",
                "huart": "UART_handle",
                "pUVar12": "USART_instance",
                "uVar1": "baud_rate_divider",
                "uVar2": "APBCLK_divider",
                "uVar3": "PCLK_frequency",
                "uVar4": "PCLK_frequency",
                "uVar5": "PCLK_frequency",
                "uVar6": "PCLK_frequency",
                "uVar7": "PCLK_frequency",
                "uVar8": "baud_rate",
                "uVar9": "baud_rate",
                "uVar10": "baud_rate",
                "uVar11": "baud_rate",
                "CR1": "control_register_1",
                "CR2": "control_register_2",
                "CR3": "control_register_3",
                "Instance": "USART_instance",
                "StopBits": "stop_bits",
                "WordLength": "word_length",
                "Parity": "parity",
                "Mode": "mode",
                "HwFlowCtl": "hardware_flow_control"
            },
            "code": "\nvoid configure_UART_08006538(UART_HandleTypeDef *UART_handle)\n\n{\n  ulonglong baud_rate_divider;\n  uint APBCLK_divider;\n  uint32_t PCLK_frequency;\n  uint32_t PCLK_frequency;\n  uint32_t PCLK_frequency;\n  uint32_t PCLK_frequency;\n  uint32_t PCLK_frequency;\n  uint32_t baud_rate;\n  uint32_t baud_rate;\n  uint32_t baud_rate;\n  uint32_t baud_rate;\n  USART_TypeDef *USART_instance;\n  \n  UART_handle->USART_instance->control_register_2 = UART_handle->USART_instance->control_register_2 & 0xffffcfff | (UART_handle->Init).stop_bits;\n  UART_handle->USART_instance->control_register_1 =\n       (UART_handle->Init).word_length | (UART_handle->Init).parity | (UART_handle->Init).mode |\n       UART_handle->USART_instance->control_register_1 & 0xffffe9f3;\n  UART_handle->USART_instance->control_register_3 = UART_handle->USART_instance->control_register_3 & 0xfffffcff | (UART_handle->Init).hardware_flow_control;\n  USART_instance = UART_handle->USART_instance;\n  if (USART_instance != DAT_080066e0) {\n    PCLK_frequency = HAL_RCC_GetPCLK1Freq();\n    APBCLK_divider = DAT_080066e4;\n    baud_rate = (UART_handle->Init).BaudRate;\n    baud_rate_divider = (ulonglong)DAT_080066e4;\n    PCLK_frequency = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (UART_handle->Init).BaudRate;\n    PCLK_frequency = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (UART_handle->Init).BaudRate;\n    PCLK_frequency = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (UART_handle->Init).BaudRate;\n    PCLK_frequency = HAL_RCC_GetPCLK1Freq();\n    USART_instance->BRR = ((uint)((int)((ulonglong)APBCLK_divider *\n                                 (ulonglong)\n                                 (((PCLK_frequency * 0x19) / (baud_rate << 2) +\n                                  (uint)((ulonglong)APBCLK_divider *\n                                         ((ulonglong)(PCLK_frequency * 0x19) /\n                                         (ulonglong)((UART_handle->Init).BaudRate << 2)) >> 0x25) * -100)\n                                  * 0x10 + 0x32) >> 0x20) << 0x17) >> 0x1c) +\n                   ((uint)((ulonglong)APBCLK_divider *\n                           (ulonglong)\n                           (((PCLK_frequency * 0x19) / (baud_rate << 2) +\n                            (uint)((ulonglong)APBCLK_divider *\n                                   ((ulonglong)(PCLK_frequency * 0x19) / (ulonglong)(baud_rate << 2)) >> 0x25) *\n                            -100) * 0x10 + 0x32) >> 0x25) & 0xf0) +\n                   (uint)(baud_rate_divider * ((ulonglong)(PCLK_frequency * 0x19) / (ulonglong)(baud_rate << 2)) >> 0x25) *\n                   0x10;\n    return;\n  }\n  PCLK_frequency = HAL_RCC_GetPCLK2Freq();\n  APBCLK_divider = DAT_080066e4;\n  baud_rate = (UART_handle->Init).BaudRate;\n  baud_rate_divider = (ulonglong)DAT_080066e4;\n  PCLK_frequency = HAL_RCC_GetPCLK2Freq();\n  baud_rate = (UART_handle->Init).BaudRate;\n  PCLK_frequency = HAL_RCC_GetPCLK2Freq();\n  baud_rate = (UART_handle->Init).BaudRate;\n  PCLK_frequency = HAL_RCC_GetPCLK2Freq();\n  baud_rate = (UART_handle->Init).BaudRate;\n  PCLK_frequency = HAL_RCC_GetPCLK2Freq();\n  USART_instance->BRR = ((uint)((int)((ulonglong)APBCLK_divider *\n                               (ulonglong)\n                               (((PCLK_frequency * 0x19) / (baud_rate << 2) +\n                                (uint)((ulonglong)APBCLK_divider *\n                                       ((ulonglong)(PCLK_frequency * 0x19) /\n                                       (ulonglong)((UART_handle->Init).BaudRate << 2)) >> 0x25) * -100) *\n                                0x10 + 0x32) >> 0x20) << 0x17) >> 0x1c) +\n                 ((uint)((ulonglong)APBCLK_divider *\n                         (ulonglong)\n                         (((PCLK_frequency * 0x19) / (baud_rate << 2) +\n                          (uint)((ulonglong)APBCLK_divider *\n                                 ((ulonglong)(PCLK_frequency * 0x19) / (ulonglong)(baud_rate << 2)) >> 0x25) *\n                          -100) * 0x10 + 0x32) >> 0x25) & 0xf0) +\n                 (uint)(baud_rate_divider * ((ulonglong)(PCLK_frequency * 0x19) / (ulonglong)(baud_rate << 2)) >> 0x25) *\n                 0x10;\n  return;\n}\n\n",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006538",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "configure_uart_08006538"
        },
        "FUN_08002fa8": {
            "renaming": {
                "FUN_08002fa8": "update_pin_config_08002fa8",
                "this": "firmataObj",
                "pin": "pinNumber",
                "config": "pinConfigValue",
                "pinConfig": "firmataPinConfig"
            },
            "code": "\nvoid __firmataObjcall firmata::FirmataClass::updatePinConfig_08002fa8(FirmataClass *firmataObj,byte pinNumber,byte pinConfigValue)\n\n{\n  if (firmataObj->firmataPinConfig[pinNumber] != '\\x7f') {\n    firmataObj->firmataPinConfig[pinNumber] = pinConfigValue;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fa8",
            "calling": [
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "update_pin_config_08002fa8"
        },
        "FUN_0800325a": {
            "renaming": {
                "this": "marshaller",
                "command": "commandByte",
                "bytec": "byteCount",
                "bytev": "byteValues",
                "uVar1": "byteIndex",
                "FUN_0800325a": "send_firmata_command_0800325a"
            },
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003272 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendFirmataCommand_0800325a(FirmataMarshaller *marshaller,uint8_t commandByte,size_t byteCount,uint8_t *byteValues)\n\n{\n  uint byteIndex;\n  \n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller,0xf0);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,(uint)commandByte);\n    for (byteIndex = 0; byteIndex < byteCount; byteIndex = byteIndex + 1) {\n      encodeByteStream(marshaller,1,byteValues + byteIndex,0);\n    }\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,0xf7);\n  }\n  return;\n}\n\n",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800325a",
            "calling": [
                "sendString",
                "sendSysex"
            ],
            "imported": false,
            "current_name": "send_firmata_command_0800325a"
        },
        "FUN_080091d8": {
            "renaming": {
                "FUN_080091d8": "allocate_memory_block_080091d8",
                "param_1": "status_code",
                "param_2": "block_size",
                "param_3": "unused_param_1",
                "param_4": "unused_param_2",
                "puVar1": "free_list",
                "extraout_r1": "unused_return_value",
                "ppiVar2": "previous_block",
                "ppiVar3": "current_block",
                "piVar4": "current_block_size",
                "ppiVar5": "free_block",
                "ppiVar6": "previous_free_block",
                "ppiVar7": "new_block"
            },
            "code": "\nvoid allocate_memory_block_080091d8(undefined4 *status_code,int block_size,undefined4 unused_param_1,undefined4 unused_param_2)\n\n{\n  undefined *free_list;\n  int **unused_return_value;\n  int **previous_block;\n  int **current_block;\n  int *current_block_size;\n  int **free_block;\n  int **previous_free_block;\n  int **new_block;\n  \n  if (block_size == 0) {\n    return;\n  }\n  new_block = (int **)(block_size + -4);\n  if (*(int *)(block_size + -4) < 0) {\n    new_block = (int **)((int)new_block + *(int *)(block_size + -4));\n  }\n  __malloc_lock();\n  free_list = PTR___malloc_free_list_0800926c;\n  free_block = *(int ***)PTR___malloc_free_list_0800926c;\n  if (free_block == (int **)0x0) {\n    new_block[1] = (int *)0x0;\n    *(int ***)free_list = new_block;\n    previous_block = unused_return_value;\n    current_block = (int **)free_list;\n  }\n  else if (new_block < free_block) {\n    previous_block = (int **)*new_block;\n    current_block = (int **)((int)new_block + (int)previous_block);\n    if (free_block == current_block) {\n      current_block_size = *free_block;\n      free_block = (int **)free_block[1];\n      current_block = (int **)((int)current_block_size + (int)previous_block);\n      *new_block = (int *)current_block;\n    }\n    new_block[1] = (int *)free_block;\n    *(int ***)free_list = new_block;\n  }\n  else {\n    do {\n      previous_free_block = free_block;\n      current_block = (int **)previous_free_block[1];\n      if (current_block == (int **)0x0) break;\n      free_block = current_block;\n    } while (current_block <= new_block);\n    previous_block = (int **)*previous_free_block;\n    if ((int **)((int)previous_free_block + (int)previous_block) == new_block) {\n      previous_block = (int **)((int)previous_block + (int)*new_block);\n      *previous_free_block = (int *)previous_block;\n      if (current_block == (int **)((int)previous_free_block + (int)previous_block)) {\n        current_block_size = *current_block;\n        current_block = (int **)current_block[1];\n        previous_block = (int **)((int)previous_block + (int)current_block_size);\n        *previous_free_block = (int *)previous_block;\n        previous_free_block[1] = (int *)current_block;\n      }\n    }\n    else if (new_block < (int **)((int)previous_free_block + (int)previous_block)) {\n      *status_code = 0xc;\n    }\n    else {\n      previous_block = (int **)((int)new_block + (int)*new_block);\n      if (current_block == previous_block) {\n        current_block_size = *current_block;\n        current_block = (int **)current_block[1];\n        previous_block = (int **)((int)current_block_size + (int)*new_block);\n        *new_block = (int *)previous_block;\n      }\n      new_block[1] = (int *)current_block;\n      previous_free_block[1] = (int *)new_block;\n    }\n  }\n  __malloc_unlock(status_code,previous_block,current_block,unused_param_2);\n  return;\n}\n\n",
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091d8",
            "calling": [
                "free",
                "__swsetup_r",
                "_realloc_r",
                "__sflush_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_080091d8"
        },
        "FUN_0800688e": {
            "renaming": {
                "FUN_0800688e": "transmit_data_0800688e",
                "huart": "uart_handler",
                "pData": "data_buffer",
                "Size": "data_size",
                "HAL_UART_STATE_READY": "ready_state",
                "HAL_BUSY": "busy_status",
                "HAL_ERROR": "error_status",
                "HAL_LOCKED": "locked_status",
                "HAL_UART_STATE_BUSY_TX": "busy_transmitting_state",
                "HAL_UNLOCKED": "unlocked_status"
            },
            "code": "\nHAL_StatusTypeDef_conflict\ntransmit_data_0800688e(UART_HandleTypeDef *uart_handler,uint8_t *data_buffer,uint16_t data_size)\n\n{\n  if (uart_handler->gState != ready_state) {\n    return busy_status;\n  }\n  if (data_buffer == (uint8_t *)0x0) {\n    return error_status;\n  }\n  if (data_size == 0) {\n    return error_status;\n  }\n  if (uart_handler->Lock != locked_status) {\n    uart_handler->pTxBuffPtr = data_buffer;\n    uart_handler->TxXferdata_size = data_size;\n    uart_handler->TxXferCount = data_size;\n    uart_handler->ErrorCode = 0;\n    uart_handler->gState = busy_transmitting_state;\n    uart_handler->Lock = unlocked_status;\n    uart_handler->Instance->CR1 = uart_handler->Instance->CR1 | 0x80;\n    return HAL_OK;\n  }\n  return busy_status;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800688e",
            "calling": [
                "uart_attach_tx_callback",
                "HAL_UART_TxCpltCallback"
            ],
            "imported": false,
            "current_name": "transmit_data_0800688e"
        },
        "FUN_080090b4": {
            "renaming": {
                "FUN_080090b4": "initialize_static_variables_080090b4",
                "__static_initialization_and_destruction_0": "initialize_and_destroy"
            },
            "code": "\nvoid initialize_static_variables_080090b4(void)\n\n{\n  initialize_and_destroy(1,0xffff);\n  return;\n}\n\n",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090b4",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_080090b4"
        },
        "FUN_0800870c": {
            "renaming": {
                "FUN_0800870c": "handle_uart_rx_0800870c",
                "huart": "uart_handle",
                "bVar1": "index",
                "uVar2": "index_as_uint"
            },
            "code": "\nvoid handle_uart_rx_0800870c(UART_HandleTypeDef *uart_handle)\n\n{\n  byte index;\n  uint index_as_uint;\n  \n  index = uart_index(uart_handle);\n  index_as_uint = (uint)index;\n  if (index_as_uint < 5) {\n    (**(code **)(PTR_rx_callback_08008728 + index_as_uint * 4))\n              (*(undefined4 *)(PTR_rx_callback_obj_0800872c + index_as_uint * 4));\n  }\n  return;\n}\n\n",
            "called": [
                "uart_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800870c",
            "calling": [
                "UART_Receive_IT"
            ],
            "imported": false,
            "current_name": "handle_uart_rx_0800870c"
        },
        "FUN_08008840": {
            "renaming": {
                "FUN_08008840": "get_file_error_code_08008840",
                "file_UNUSED": "file_descriptor",
                "return": "error_code"
            },
            "code": "\nint get_file_error_code_08008840(int file_descriptor)\n\n{\n  error_code -1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008840",
            "calling": [
                "_close_r"
            ],
            "imported": false,
            "current_name": "get_file_error_code_08008840"
        },
        "FUN_08008600": {
            "renaming": {
                "FUN_08008600": "receive_serial_data_08008600",
                "obj": "serial_object",
                "uVar1": "rx_active_flag"
            },
            "code": "\nint receive_serial_data_08008600(serial_t *serial_object,uchar *c)\n\n{\n  uint8_t rx_active_flag;\n  \n  if (serial_object == (serial_t *)0x0) {\n    return -1;\n  }\n  rx_active_flag = serial_rx_active(serial_object);\n  if (rx_active_flag == '\\0') {\n    *c = serial_object->recv;\n    HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08008638 + (uint)serial_object->index * 4),\n                        &serial_object->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008600",
            "calling": [
                "_rx_complete_irq"
            ],
            "imported": false,
            "current_name": "receive_serial_data_08008600"
        },
        "FUN_08003154": {
            "renaming": {
                "this": "marshaller",
                "Stream": "stream",
                "s": "stream",
                "FUN_08003154": "set_firmata_stream_08003154"
            },
            "code": "\nvoid __marshallercall firmata::FirmataMarstreamhaller::setFirmataStream_08003154(FirmataMarstreamhaller *marshaller,stream *stream)\n\n{\n  marshaller->Firmatastream = stream;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003154",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "set_firmata_stream_08003154"
        },
        "FUN_08006420": {
            "renaming": {
                "FUN_08006420": "set_channel_state_08006420",
                "TIM_TypeDef_conflict": "timer_struct",
                "TIMx": "timer",
                "Channel": "channel_number",
                "ChannelNState": "channel_state"
            },
            "code": "\nvoid set_channel_state_08006420(timer_struct *timer,uint32_t channel_number,uint32_t channel_state)\n\n{\n  timer->CCER = timer->CCER & ~(4 << (channel_number & 0xff));\n  timer->CCER = timer->CCER | channel_state << (channel_number & 0xff);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006420",
            "calling": [
                "HAL_TIMEx_PWMN_Start",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "imported": false,
            "current_name": "set_channel_state_08006420"
        },
        "FUN_08007750": {
            "renaming": {
                "FUN_08007750": "set_timer_channel_value_08007750",
                "obj": "timer_object",
                "channel": "channel_number",
                "value": "new_value",
                "handle": "timer_handle"
            },
            "code": "\nvoid set_timer_channel_value_08007750(stimer_t_conflict *timer_object,uint32_t channel_number,uint32_t new_value)\n\n{\n  (&((timer_object->timer_handle).Instance)->CCR1)[channel_number] = new_value;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007750",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "set_timer_channel_value_08007750"
        },
        "FUN_08009938": {
            "renaming": {
                "FUN_08009938": "find_char_08009938",
                "__s": "string",
                "__c": "target_char",
                "pbVar1": "byte_pointer"
            },
            "code": "\nchar * find_char_08009938(char *string,int target_char)\n\n{\n  byte *byte_pointer;\n  \n  do {\n    byte_pointer = (byte *)string;\n    if (*byte_pointer == 0) {\n      if ((target_char & 0xffU) != 0) {\n        byte_pointer = (byte *)0x0;\n      }\n      return (char *)byte_pointer;\n    }\n    string = (char *)(byte_pointer + 1);\n  } while ((target_char & 0xffU) != (uint)*byte_pointer);\n  return (char *)byte_pointer;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009938",
            "calling": [
                "strrchr"
            ],
            "imported": false,
            "current_name": "find_char_08009938"
        },
        "FUN_08007f0e": {
            "renaming": {
                "FUN_08007f0e": "receive_i2c_data_08007f0e",
                "obj": "i2c_object",
                "dev_address": "device_address",
                "data": "data_buffer",
                "size": "data_size",
                "HVar1": "hal_i2c_state",
                "HVar2": "hal_status",
                "uVar3": "start_time",
                "uVar4": "current_time",
                "uVar5": "elapsed_time",
                "iVar6": "i2c_status",
                "hi2c": "i2c_handle"
            },
            "code": "\ni2c_status_e_conflict\nreceive_i2c_data_08007f0e(i2c_t_conflict *i2c_object,uint8_t device_address,uint8_t *data_buffer,uint16_t data_size)\n\n{\n  HAL_I2C_StateTypeDef_conflict hal_i2c_state;\n  HAL_StatusTypeDef_conflict hal_status;\n  uint32_t start_time;\n  uint32_t current_time;\n  uint elapsed_time;\n  i2c_status_e_conflict i2c_status;\n  I2C_HandleTypeDef_conflict *i2c_handle;\n  \n  start_time = HAL_GetTick();\n  elapsed_time = 0;\n  i2c_status = I2C_ERROR;\n  do {\n    i2c_handle = &i2c_object->handle;\n    hal_status = HAL_I2C_Master_Receive_IT(i2c_handle,(ushort)device_address,data_buffer,data_size);\n    if (hal_status == HAL_OK) {\n      i2c_status = I2C_OK;\n      while ((hal_i2c_state = HAL_I2C_GetState(i2c_handle), hal_i2c_state != HAL_I2C_STATE_READY && (i2c_status == I2C_OK))) {\n        current_time = HAL_GetTick();\n        elapsed_time = current_time - start_time;\n        if (elapsed_time < 0x65) {\n          current_time = HAL_I2C_GetError(i2c_handle);\n          if (current_time != 0) {\n            i2c_status = I2C_ERROR;\n          }\n        }\n        else {\n          i2c_status = I2C_TIMEOUT;\n        }\n      }\n    }\n    current_time = HAL_I2C_GetError(i2c_handle);\n  } while ((current_time == 4) && (elapsed_time < 100));\n  return i2c_status;\n}\n\n",
            "called": [
                "HAL_GetTick",
                "HAL_I2C_Master_Receive_IT",
                "HAL_I2C_GetState",
                "HAL_I2C_GetError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f0e",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "receive_i2c_data_08007f0e"
        },
        "FUN_08004004": {
            "renaming": {
                "FUN_08004004": "set_interrupt_handler_08004004",
                "IRQn": "interrupt_number",
                "uVar1": "interrupt_as_uint"
            },
            "code": "\nvoid set_interrupt_handler_08004004(interrupt_number_Type_conflict interrupt_number)\n\n{\n  uint interrupt_as_uint;\n  \n  interrupt_as_uint = (uint)interrupt_number;\n  if (-1 < (int)interrupt_as_uint) {\n    *(int *)(DAT_08004020 + ((interrupt_as_uint >> 5) + 0x60) * 4) = 1 << (interrupt_as_uint & 0x1f);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004004",
            "calling": [
                "USART2_IRQHandler",
                "USART1_IRQHandler",
                "USART3_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_interrupt_handler_08004004"
        },
        "FUN_08003158": {
            "renaming": {
                "this": "marshaller",
                "pin": "pin_number",
                "value": "pin_value",
                "local_a": "encoded_value",
                "FUN_08003158": "send_pin_value_08003158"
            },
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x0800318c */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::send_pin_value_08003158(FirmataMarshaller *marshaller,uint8_t pin_number,uint16_t pin_value)\n\n{\n  uint16_t encoded_value;\n  \n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    encoded_value = pin_value;\n    if ((pin_number < 0x10) && (pin_value < 0x4000)) {\n      (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller,pin_number | 0xe0);\n      encodeByteStream(marshaller,2,(uint8_t *)&encoded_value,2);\n    }\n    else {\n      sendExtendedAnalog(marshaller,pin_number,2,(uint8_t *)&encoded_value);\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "encodeByteStream",
                "sendExtendedAnalog"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003158",
            "calling": [
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "send_pin_value_08003158"
        },
        "FUN_080090c2": {
            "renaming": {
                "FUN_080090c2": "register_exit_function_080090c2",
                "param_1": "exit_function",
                "param_2": "exit_handler",
                "__cxa_atexit": "register_at_exit"
            },
            "code": "\nvoid register_exit_function_080090c2(undefined4 exit_function,undefined4 exit_handler)\n\n{\n  register_at_exit(exit_handler,exit_function);\n  return;\n}\n\n",
            "called": [
                "__cxa_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090c2",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "register_exit_function_080090c2"
        },
        "FUN_08000ef8": {
            "renaming": {
                "FUN_08000ef8": "FUNC_08000ef8"
            },
            "code": "\nvoid FUNC_08000ef8(void)\n\n{\n  byte bVar1;\n  bool bVar2;\n  uint32_t uVar3;\n  int iVar4;\n  byte bVar5;\n  \n  if (*PTR_reportPINs_08001188 != '\\0') {\n    bVar1 = *PTR_portConfigInputs_0800118c;\n    if (*PTR_digitalPin_08001190 == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(*PTR_digitalPin_08001190);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(*PTR_digitalPin_08001190);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001190[1] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[1]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[1]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(1);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001190[2] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[2]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[2]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(2);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001190[3] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[3]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[3]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(3);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001190[4] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[4]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[4]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(4);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001190[5] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[5]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[5]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(5);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001190[6] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[6]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[6]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(6);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001190[7] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[7]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[7]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(7);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\0',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001188[1] != '\\0') {\n    bVar1 = PTR_portConfigInputs_0800118c[1];\n    if (PTR_digitalPin_08001190[8] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[8]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[8]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(8);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001424[9] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[9]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[9]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(9);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001424[10] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[10]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[10]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(10);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001424[0xb] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xb]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xb]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xb);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001424[0xc] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xc]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xc]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xc);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001424[0xd] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xd]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xd]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xd);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001424[0xe] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xe]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xe]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xe);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001424[0xf] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xf]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xf]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xf);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x01',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001428[2] != '\\0') {\n    bVar1 = PTR_portConfigInputs_0800142c[2];\n    if (PTR_digitalPin_08001424[0x10] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0x10]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0x10]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x10);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_080016c4[0x11] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x11]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x11]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x11);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_080016c4[0x12] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x12]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x12]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x12);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_080016c4[0x13] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x13]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x13]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x13);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_080016c4[0x14] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x14]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x14]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x14);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_080016c4[0x15] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x15]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x15]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x15);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_080016c4[0x16] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x16]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x16]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x16);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_080016c4[0x17] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x17]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x17]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x17);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x02',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_080016c8[3] != '\\0') {\n    bVar1 = PTR_portConfigInputs_080016cc[3];\n    if (PTR_digitalPin_080016c4[0x18] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x18]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x18]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x18);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_080016c4[0x19] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x19]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x19]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x19);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001960[0x1a] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1a]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1a]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1a);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001960[0x1b] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1b]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1b]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1b);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001960[0x1c] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1c]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1c]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1c);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001960[0x1d] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1d]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1d]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1d);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001960[0x1e] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1e]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1e]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1e);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001960[0x1f] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1f]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1f]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1f);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x03',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001964[4] != '\\0') {\n    bVar1 = PTR_portConfigInputs_08001968[4];\n    if (PTR_digitalPin_08001960[0x20] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x20]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x20]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x20);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001960[0x21] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x21]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x21]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x21);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001b44[0x22] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x22]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x22]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x22);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001b44[0x23] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x23]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x23]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x23);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001b44[0x24] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x24]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x24]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x24);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001b44[0x25] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x25]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x25]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x25);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001b44[0x26] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x26]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x26]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x26);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001b44[0x27] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x27]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x27]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x27);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x04',bVar5,'\\0');\n  }\n  return;\n}\n\n",
            "called": [
                "digitalRead",
                "pinNametoDigitalPin",
                "outputPort"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000ef8",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "FUNC_08000ef8"
        },
        "FUN_08008846": {
            "renaming": {
                "FUN_08008846": "set_file_mode_08008846",
                "file_UNUSED": "unused_file",
                "st": "file_stats"
            },
            "code": "\nint set_file_mode_08008846(int unused_file,file_statsat *file_stats)\n\n{\n  file_stats->file_stats_mode = 0x2000;\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008846",
            "calling": [
                "_fstat_r"
            ],
            "imported": false,
            "current_name": "set_file_mode_08008846"
        },
        "FUN_0800a430": {
            "renaming": {
                "FUN_0800a430": "do_nothing_0800a430"
            },
            "code": "\nvoid do_nothing_0800a430(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a430",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800a430"
        },
        "FUN_0800459c": {
            "renaming": {
                "FUN_0800459c": "read_i2c_byte_0800459c",
                "hi2c": "i2c_handle",
                "XferCount": "transfer_count",
                "pBuffPtr": "buffer_pointer",
                "Instance": "i2c_instance",
                "DR": "data_register"
            },
            "code": "\nHAL_StatusTypeDef_conflict read_i2c_byte_0800459c(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  uint8_t *puVar1;\n  \n  if (i2c_handle->transfer_count != 0) {\n    puVar1 = i2c_handle->buffer_pointer;\n    i2c_handle->buffer_pointer = puVar1 + 1;\n    *puVar1 = (uint8_t)i2c_handle->i2c_instance->data_register;\n    i2c_handle->transfer_count = i2c_handle->transfer_count - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800459c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "read_i2c_byte_0800459c"
        },
        "FUN_0800774a": {
            "renaming": {
                "FUN_0800774a": "set_timer_value_0800774a",
                "obj": "timer_object",
                "value": "new_timer_value",
                "CNT": "timer_count"
            },
            "code": "\nvoid set_timer_value_0800774a(stimer_t_conflict *timer_object,uint32_t new_timer_value)\n\n{\n  ((timer_object->handle).Instance)->timer_count = new_timer_value;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800774a",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "set_timer_value_0800774a"
        },
        "FUN_080027f0": {
            "renaming": {
                "this": "wire",
                "i2c_status_e_conflict": "i2c_status",
                "iVar3": "status",
                "FUN_080027f0": "transmit_data_080027f0"
            },
            "code": "\nsize_t __wirecall TwoWire::transmit_data_080027f0(TwoWire *wire,uint8_t *data,size_t quantity)\n\n{\n  char cVar1;\n  undefined *puVar2;\n  i2c_status status;\n  void *pvVar4;\n  undefined uVar5;\n  size_t __size;\n  \n  puVar2 = PTR_txBuffer_08002884;\n  if (*PTR_transmitting_08002878 == '\\0') {\n    status = i2c_slave_transmit_data_080027f0_IT((i2c_t_conflict *)&wire->_i2c,data,(uint16_t)quantity);\n    if (status != I2C_OK) {\n      return 0;\n    }\n    return quantity;\n  }\n  __size = (byte)*PTR_txBufferLength_0800287c + quantity;\n  if ((byte)*PTR_txBufferAllocated_08002880 < __size) {\n    if (__size < 0x20) {\n      __size = 0x20;\n    }\n    pvVar4 = realloc(*(void **)PTR_txBuffer_08002884,__size);\n    *(void **)puVar2 = pvVar4;\n    if (pvVar4 == (void *)0x0) {\n      uVar5 = 0;\n    }\n    else {\n      uVar5 = (undefined)__size;\n    }\n    *PTR_txBufferAllocated_08002880 = uVar5;\n  }\n  puVar2 = PTR_txBufferIndex_08002888;\n  if (*(int *)PTR_txBuffer_08002884 != 0) {\n    memcpy((void *)((uint)(byte)*PTR_txBufferIndex_08002888 + *(int *)PTR_txBuffer_08002884),data,\n           quantity);\n    cVar1 = *puVar2 + (char)quantity;\n    *puVar2 = cVar1;\n    *PTR_txBufferLength_0800287c = cVar1;\n    return quantity;\n  }\n  (wire->super_Stream).super_Print.transmit_data_080027f0_error = 1;\n  return 0;\n}\n\n",
            "called": [
                "memcpy",
                "i2c_slave_write_IT",
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080027f0",
            "calling": [],
            "imported": false,
            "current_name": "transmit_data_080027f0"
        },
        "FUN_0800314e": {
            "renaming": {
                "this": "self",
                "FirmataStream": "stream",
                "FUN_0800314e": "initialize_firmata_0800314e"
            },
            "code": "\ninitializeFirmata_0800314e * __selfcall\nfirmata::initializeFirmata_0800314e::initializeFirmata_0800314e(initializeFirmata_0800314e *self)\n\n{\n  self->stream = (Stream *)0x0;\n  return self;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800314e",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "initialize_firmata_0800314e"
        },
        "FUN_080036a0": {
            "renaming": {
                "FUN_080036a0": "infinite_loop_080036a0"
            },
            "code": "\nvoid infinite_loop_080036a0(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036a0",
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "imported": false,
            "current_name": "infinite_loop_080036a0"
        },
        "FUN_080036a2": {
            "renaming": {
                "FUN_080036a2": "configure_hardware_080036a2"
            },
            "code": "\nint configure_hardware_080036a2(EVP_PKEY_CTX *ctx)\n\n{\n  hw_config_configure_hardware_080036a2();\n  return (int)ctx;\n}\n\n",
            "called": [
                "hw_config_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036a2",
            "calling": [
                "premain"
            ],
            "imported": false,
            "current_name": "configure_hardware_080036a2"
        },
        "FUN_080038e4": {
            "renaming": {
                "FUN_080038e4": "configure_adc_channel_080038e4",
                "hadc": "adc_handle",
                "sConfig": "channel_config",
                "HVar1": "status",
                "uVar2": "index",
                "pAVar3": "adc_instance",
                "wait_loop_index": "loop_index"
            },
            "code": "\nHAL_StatusTypeDef_conflict\nconfigure_adc_channel_080038e4(ADC_HandleTypeDef *adc_handle,ADC_ChannelConfTypeDef *channel_config)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint index;\n  ADC_TypeDef *adc_instance;\n  uint32_t loop_index;\n  \n  if (adc_handle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    adc_handle->Lock = HAL_LOCKED;\n    index = channel_config->Rank;\n    if (index < 7) {\n      index = index * 5 - 5;\n      adc_handle->Instance->SQR3 =\n           channel_config->Channel << (index & 0xff) | adc_handle->Instance->SQR3 & ~(0x1f << (index & 0xff));\n    }\n    else if (index < 0xd) {\n      index = index * 5 - 0x23;\n      adc_handle->Instance->SQR2 =\n           channel_config->Channel << (index & 0xff) | adc_handle->Instance->SQR2 & ~(0x1f << (index & 0xff));\n    }\n    else {\n      index = index * 5 - 0x41;\n      adc_handle->Instance->SQR1 =\n           channel_config->Channel << (index & 0xff) | adc_handle->Instance->SQR1 & ~(0x1f << (index & 0xff));\n    }\n    index = channel_config->Channel;\n    if (index < 10) {\n      adc_handle->Instance->SMPR2 =\n           channel_config->SamplingTime << (index * 3 & 0xff) |\n           adc_handle->Instance->SMPR2 & ~(7 << (index * 3 & 0xff));\n    }\n    else {\n      index = index * 3 - 0x1e;\n      adc_handle->Instance->SMPR1 =\n           channel_config->SamplingTime << (index & 0xff) | adc_handle->Instance->SMPR1 & ~(7 << (index & 0xff));\n    }\n    if (channel_config->Channel - 0x10 < 2) {\n      adc_instance = adc_handle->Instance;\n      if (adc_instance == DAT_08003a10) {\n        if ((adc_instance->CR2 & 0x800000) == 0) {\n          adc_instance->CR2 = adc_instance->CR2 | 0x800000;\n          if (channel_config->Channel == 0x10) {\n            for (loop_index =\n                      (uint)((ulonglong)DAT_08003a18 *\n                             (ulonglong)*(uint *)PTR_SystemCoreClock_08003a14 >> 0x32) * 10;\n                loop_index != 0; loop_index = loop_index - 1) {\n            }\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        adc_handle->State = adc_handle->State | 0x20;\n        status = HAL_ERROR;\n      }\n    }\n    else {\n      status = HAL_OK;\n    }\n    adc_handle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080038e4",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "configure_adc_channel_080038e4"
        },
        "FUN_08005e68": {
            "renaming": {
                "FUN_08005e68": "do_nothing_08005e68"
            },
            "code": "\nvoid do_nothing_08005e68(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e68",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e68"
        },
        "FUN_08005d48": {
            "renaming": {
                "FUN_08005d48": "configure_timer_output_compare_08005d48",
                "TIM_TypeDef_conflict": "timer_instance",
                "TIM_OC_InitTypeDef": "timer_output_compare_config",
                "uVar1": "ccer_value",
                "uVar2": "cr2_value",
                "uVar3": "oc_mode"
            },
            "code": "\nvoid configure_timer_output_compare_08005d48(timer_instance *TIMx,timer_output_compare_config *OC_Config)\n\n{\n  uint32_t ccer_value;\n  uint32_t cr2_value;\n  uint oc_mode;\n  \n  TIMx->CCER = TIMx->CCER & 0xfffffeff;\n  cr2_value = TIMx->CR2;\n  oc_mode = OC_Config->OCMode;\n  ccer_value = TIMx->CCER & 0xfffffdff | OC_Config->OCPolarity << 8;\n  if (TIMx == DAT_08005da8) {\n    ccer_value = (ccer_value & 0xfffff7ff | OC_Config->OCNPolarity << 8) & 0xfffffbff;\n    cr2_value = cr2_value & 0xffffcfff | OC_Config->OCIdleState << 4 | OC_Config->OCNIdleState << 4;\n  }\n  TIMx->CR2 = cr2_value;\n  TIMx->CCMR2 = TIMx->CCMR2 & 0xffffff8c | oc_mode;\n  TIMx->CCR3 = OC_Config->Pulse;\n  TIMx->CCER = ccer_value;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d48",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_output_compare_08005d48"
        },
        "FUN_08008ba4": {
            "renaming": {
                "_written": "is_written",
                "_serial": "serial",
                "tx_head": "head",
                "tx_tail": "tail",
                "tx_buff": "buffer",
                "serial_tx_active": "is_serial_tx_active",
                "uart_attach_tx_callback": "attach_uart_tx_callback",
                "FUN_08008ba4": "write_byte_08008ba4",
                "this": "self"
            },
            "code": "\nsize_t __selfcall HardwareSerial::write_byte_08008ba4(HardwareSerial *self,uint8_t c)\n\n{\n  byte bVar1;\n  uint8_t uVar2;\n  byte bVar3;\n  int iVar4;\n  uint uVar5;\n  \n  self->is_written = true;\n  uVar5 = (uint)(self->serial).head;\n  iVar4 = uVar5 + 1;\n  bVar1 = (byte)iVar4;\n  bVar3 = bVar1 & 0x7f;\n  if (iVar4 == 0) {\n    bVar3 = -(-bVar1 & 0x7f);\n  }\n  do {\n  } while ((self->serial).tail == (ushort)bVar3);\n  (self->serial).buffer[uVar5] = c;\n  (self->serial).head = (ushort)bVar3;\n  uVar2 = is_serial_tx_active((serial_t *)&self->serial);\n  if (uVar2 == '\\0') {\n    attach_uart_tx_callback((serial_t *)&self->serial,DAT_08008bf0);\n  }\n  return 1;\n}\n\n",
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ba4",
            "calling": [],
            "imported": false,
            "current_name": "write_byte_08008ba4"
        },
        "FUN_08009ff8": {
            "renaming": {
                "FUN_08009ff8": "kill_process_08009ff8",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal_number",
                "puVar1": "errno_pointer",
                "iVar2": "kill_result"
            },
            "code": "\nvoid kill_process_08009ff8(int *error_code,int process_id,int signal_number)\n\n{\n  undefined *errno_pointer;\n  int kill_result;\n  \n  errno_pointer = PTR_errno_0800a018;\n  *(undefined4 *)PTR_errno_0800a018 = 0;\n  kill_result = _kill(process_id,signal_number);\n  if ((kill_result == -1) && (*(int *)errno_pointer != 0)) {\n    *error_code = *(int *)errno_pointer;\n  }\n  return;\n}\n\n",
            "called": [
                "_kill"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009ff8",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "kill_process_08009ff8"
        },
        "FUN_08009db0": {
            "renaming": {
                "FUN_08009db0": "find_unused_buffer_08009db0",
                "param_1": "error_code",
                "piVar1": "current_buffer",
                "piVar2": "buffer_ptr",
                "iVar3": "global_impure_ptr",
                "ppiVar4": "buffer_list"
            },
            "code": "\nint * find_unused_buffer_08009db0(undefined4 *error_code)\n\n{\n  int *current_buffer;\n  int *buffer_ptr;\n  int global_impure_ptr;\n  int **buffer_list;\n  \n  global_impure_ptr = *(int *)PTR__global_impure_ptr_08009e24;\n  if (*(int *)(global_impure_ptr + 0x18) == 0) {\n    __sinit(global_impure_ptr);\n  }\n  buffer_list = (int **)(global_impure_ptr + 0x48);\n  do {\n    buffer_ptr = buffer_list[2];\n    current_buffer = buffer_list[1];\n    while (current_buffer = (int *)((int)current_buffer + -1), -1 < (int)current_buffer) {\n      if (*(short *)(buffer_ptr + 3) == 0) {\n        *(undefined2 *)((int)buffer_ptr + 0xe) = 0xffff;\n        buffer_ptr[0x19] = 0;\n        *(undefined2 *)(buffer_ptr + 3) = 1;\n        *buffer_ptr = 0;\n        buffer_ptr[2] = 0;\n        buffer_ptr[1] = 0;\n        buffer_ptr[4] = 0;\n        buffer_ptr[5] = 0;\n        buffer_ptr[6] = 0;\n        memset(buffer_ptr + 0x17,0,8);\n        buffer_ptr[0xd] = 0;\n        buffer_ptr[0xe] = 0;\n        buffer_ptr[0x12] = 0;\n        buffer_ptr[0x13] = 0;\n        return buffer_ptr;\n      }\n      buffer_ptr = buffer_ptr + 0x1a;\n    }\n    if (*buffer_list == (int *)0x0) {\n      current_buffer = (int *)__sfmoreglue(error_code,4);\n      *buffer_list = current_buffer;\n      if (current_buffer == (int *)0x0) {\n        *error_code = 0xc;\n        return (int *)0x0;\n      }\n    }\n    buffer_list = (int **)*buffer_list;\n  } while( true );\n}\n\n",
            "called": [
                "memset",
                "__sinit",
                "__sfmoreglue"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009db0",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "find_unused_buffer_08009db0"
        },
        "FUN_08002c2c": {
            "renaming": {
                "FUN_08002c2c": "handle_analog_command_08002c2c",
                "param_1": "data",
                "command": "cmd",
                "value": "val",
                "code": "callback_func"
            },
            "code": "\nvoid firmata::FirmataClass::handle_analog_command_08002c2c(void *data,uint8_t cmd,uint16_t val)\n\n{\n  if (*(callback_func **)PTR_currentAnalogCallback_08002c3c != (callback_func *)0x0) {\n    (**(callback_func **)PTR_currentAnalogCallback_08002c3c)(cmd,val);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c2c",
            "calling": [],
            "imported": false,
            "current_name": "handle_analog_command_08002c2c"
        },
        "FUN_080072f0": {
            "renaming": {
                "FUN_080072f0": "read_gpio_pin_state_080072f0",
                "port": "gpio_port",
                "pin": "gpio_pin",
                "GVar1": "gpio_pin_state"
            },
            "code": "\nuint32_t read_gpio_pin_state_080072f0(GPIO_TypeDef *gpio_port,uint32_t gpio_pin)\n\n{\n  GPIO_PinState gpio_pin_state;\n  \n  gpio_pin_state = HAL_GPIO_ReadPin(gpio_port,(uint16_t)gpio_pin);\n  return (uint)gpio_pin_state;\n}\n\n",
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072f0",
            "calling": [
                "digitalRead"
            ],
            "imported": false,
            "current_name": "read_gpio_pin_state_080072f0"
        },
        "FUN_08000178": {
            "renaming": {
                "FUN_08000178": "find_string_length_08000178",
                "__s": "string",
                "pcVar2": "next_char_pointer",
                "cVar1": "current_char",
                "pcVar3": "current_char_pointer"
            },
            "code": "\nsize_t find_string_length_08000178(char *string)\n\n{\n  char current_char;\n  char *next_char_pointer;\n  char *current_char_pointer;\n  \n  current_char_pointer = string;\n  do {\n    next_char_pointer = current_char_pointer + 1;\n    current_char = *current_char_pointer;\n    current_char_pointer = next_char_pointer;\n  } while (current_char != '\\0');\n  return (size_t)(next_char_pointer + (-1 - (int)string));\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000178",
            "calling": [
                "sendString",
                "setFirmwareNameAndVersion",
                "printNumber"
            ],
            "imported": false,
            "current_name": "find_string_length_08000178"
        },
        "FUN_08000a64": {
            "renaming": {
                "FUN_08000a64": "initialize_i2_c_08000a64",
                "uVar2": "digitalPin",
                "uVar3": "pinIndex",
                "_Var1": "isPinValid",
                "NC": "NOT_CONNECTED",
                "setPinModeCallback": "configurePinMode",
                "byte": "pinNumber",
                "TwoWire::begin": "beginI2C"
            },
            "code": "\nvoid initializeI2C_08000a64(void)\n\n{\n  _Bool isPinValid;\n  uint32_t digitalPin;\n  uint pinIndex;\n  \n  for (pinIndex = 0; pinIndex < 0x3c; pinIndex = pinIndex + 1 & 0xff) {\n    if (pinIndex < 0x3c) {\n      if (PTR_digitalPin_08000ad8[pinIndex] == NOT_CONNECTED) {\n        isPinValid = false;\n      }\n      else {\n        digitalPin = pinNametoDigitalPin(PTR_digitalPin_08000ad8[pinIndex]);\n        if (digitalPin == 0) {\n          isPinValid = false;\n        }\n        else {\n          digitalPin = pinNametoDigitalPin(PTR_digitalPin_08000ad8[pinIndex]);\n          if (digitalPin == 1) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = pin_in_pinmap(PTR_digitalPin_08000ad8[pinIndex],\n                                  (PinMap_conflict *)PTR_PinMap_I2C_SDA_08000adc);\n            if (!isPinValid) {\n              isPinValid = pin_in_pinmap(PTR_digitalPin_08000ad8[pinIndex],\n                                    (PinMap_conflict *)PTR_PinMap_I2C_SCL_08000ae0);\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid != false) {\n      configurePinMode((pinNumber)pinIndex,6);\n    }\n  }\n  *PTR_isI2CEnabled_08000ae4 = 1;\n  beginI2C((TwoWire *)PTR_Wire_08000ae8);\n  return;\n}\n\n",
            "called": [
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "begin",
                "setPinModeCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a64",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "initialize_i2_c_08000a64"
        },
        "FUN_08002c40": {
            "renaming": {
                "FUN_08002c40": "digital_callback_handler_08002c40",
                "param_1": "data",
                "command": "pin_mode",
                "value": "pin_state"
            },
            "code": "\nvoid firmata::FirmataClass::digital_callback_handler_08002c40(void *data,uint8_t pin_mode,uint16_t pin_state)\n\n{\n  if (*(code **)PTR_currentDigitalCallback_08002c50 != (code *)0x0) {\n    (**(code **)PTR_currentDigitalCallback_08002c50)(pin_mode,pin_state);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c40",
            "calling": [],
            "imported": false,
            "current_name": "digital_callback_handler_08002c40"
        },
        "FUN_0800694c": {
            "renaming": {
                "FUN_0800694c": "receive_data_0800694c",
                "huart": "uart_handle",
                "RxState": "receive_state",
                "HAL_UART_STATE_BUSY_RX": "busy_receive_state",
                "HAL_BUSY": "busy_status",
                "Init": "uart_init",
                "WordLength": "word_length",
                "Parity": "parity",
                "pRxBuffPtr": "receive_buffer_pointer",
                "Instance": "uart_instance",
                "DR": "data_register",
                "RxXferCount": "receive_transfer_count",
                "HAL_OK": "ok_status",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "HAL_UART_STATE_READY": "ready_receive_state",
                "HAL_UART_RxCpltCallback": "receive_complete_callback"
            },
            "code": "\nHAL_StatusTypeDef_conflict receive_data_0800694c(UART_HandleTypeDef *uart_handle)\n\n{\n  byte *pbVar1;\n  uint16_t uVar2;\n  uint8_t *puVar3;\n  \n  if (uart_handle->receive_state != busy_receive_state) {\n    return busy_status;\n  }\n  if ((uart_handle->uart_init).word_length == 0x1000) {\n    if ((uart_handle->uart_init).parity == 0) {\n      *(ushort *)uart_handle->receive_buffer_pointer = (ushort)((uart_handle->uart_instance->data_register << 0x17) >> 0x17);\n      uart_handle->receive_buffer_pointer = uart_handle->receive_buffer_pointer + 2;\n    }\n    else {\n      *(ushort *)uart_handle->receive_buffer_pointer = (ushort)uart_handle->uart_instance->data_register & 0xff;\n      uart_handle->receive_buffer_pointer = uart_handle->receive_buffer_pointer + 1;\n    }\n  }\n  else if ((uart_handle->uart_init).parity == 0) {\n    puVar3 = uart_handle->receive_buffer_pointer;\n    uart_handle->receive_buffer_pointer = puVar3 + 1;\n    *puVar3 = (uint8_t)uart_handle->uart_instance->data_register;\n  }\n  else {\n    pbVar1 = uart_handle->receive_buffer_pointer;\n    uart_handle->receive_buffer_pointer = pbVar1 + 1;\n    *pbVar1 = (byte)uart_handle->uart_instance->data_register & 0x7f;\n  }\n  uVar2 = uart_handle->receive_transfer_count - 1;\n  uart_handle->receive_transfer_count = uVar2;\n  if (uVar2 != 0) {\n    return ok_status;\n  }\n  uart_handle->uart_instance->control_register_1 = uart_handle->uart_instance->control_register_1 & 0xffffffdf;\n  uart_handle->uart_instance->control_register_1 = uart_handle->uart_instance->control_register_1 & 0xfffffeff;\n  uart_handle->uart_instance->control_register_3 = uart_handle->uart_instance->control_register_3 & 0xfffffffe;\n  uart_handle->receive_state = ready_receive_state;\n  receive_complete_callback(uart_handle);\n  return ok_status;\n}\n\n",
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800694c",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_data_0800694c"
        },
        "FUN_0800a0ec": {
            "renaming": {
                "FUN_0800a0ec": "get_file_status_0800a0ec",
                "param_1": "status",
                "param_2": "file_descriptor",
                "param_3": "file_status",
                "puVar1": "errno_ptr",
                "iVar2": "status_code"
            },
            "code": "\nvoid get_file_status_0800a0ec(int *status,int file_descriptor,stat *file_status)\n\n{\n  undefined *errno_ptr;\n  int status_code;\n  \n  errno_ptr = PTR_errno_0800a10c;\n  *(undefined4 *)PTR_errno_0800a10c = 0;\n  status_code = _fstat(file_descriptor,file_status);\n  if ((status_code == -1) && (*(int *)errno_ptr != 0)) {\n    *status = *(int *)errno_ptr;\n  }\n  return;\n}\n\n",
            "called": [
                "_fstat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0ec",
            "calling": [
                "__swhatbuf_r"
            ],
            "imported": false,
            "current_name": "get_file_status_0800a0ec"
        },
        "FUN_08008df8": {
            "renaming": {
                "this": "self",
                "first_octet": "octet1",
                "second_octet": "octet2",
                "third_octet": "octet3",
                "fourth_octet": "octet4",
                "FUN_08008df8": "ip_address_08008df8"
            },
            "code": "\nIPAddress_08008df8::IPAddress_08008df8::IPAddress_08008df8::IPAddress_08008df8 * __selfcall\nIPAddress_08008df8::IPAddress_08008df8::IPAddress_08008df8::IPAddress_08008df8::IPAddress_08008df8::IPAddress_08008df8::IPAddress_08008df8::IPAddress_08008df8(IPAddress_08008df8::IPAddress_08008df8::IPAddress_08008df8::IPAddress_08008df8 *self,uint8_t octet1,uint8_t octet2,uint8_t octet3,\n          uint8_t octet4)\n\n{\n  (self->super_Printable)._vptr_Printable = (_func_int_varargs **)PTR_DAT_08008e10;\n  (self->_address).bytes[0] = octet1;\n  (self->_address).bytes[1] = octet2;\n  (self->_address).bytes[2] = octet3;\n  (self->_address).bytes[3] = octet4;\n  return self;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008df8",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "ip_address_08008df8"
        },
        "FUN_08000188": {
            "renaming": {
                "FUN_08000188": "software_interrupt_and_return_08000188"
            },
            "code": "\nuint32_t software_interrupt_and_return_08000188(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000188",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "software_interrupt_and_return_08000188"
        },
        "FUN_08004f3c": {
            "renaming": {
                "FUN_08004f3c": "handle_i2c_state_08004f3c",
                "hi2c": "i2c_handle",
                "HVar1": "status",
                "puVar2": "buffer_ptr",
                "pIVar3": "i2c_instance",
                "State": "current_state",
                "PreviousState": "previous_state",
                "Instance": "i2c_reg",
                "ErrorCode": "error_code",
                "pBuffPtr": "data_ptr",
                "hdmatx": "tx_dma_handle",
                "hdmarx": "rx_dma_handle",
                "XferAbortCallback": "transfer_abort_callback",
                "XferOptions": "transfer_options",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "I2C_TypeDef_conflict": "I2C_TypeDef",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTENING",
                "HAL_I2C_STATE_ABORT": "HAL_I2C_STATE_ABORTED",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY_FOR_TRANSFER",
                "HAL_I2C_MODE_NONE": "HAL_I2C_NO_MODE",
                "HAL_DMA_STATE_READY": "HAL_DMA_READY"
            },
            "code": "\nvoid handle_i2c_state_08004f3c(I2C_HandleTypeDef *i2c_handle)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t *buffer_ptr;\n  I2C_TypeDef *i2c_instance;\n  \n  if ((byte)i2c_handle->current_state - 0x29 < 2) {\n    i2c_handle->previous_state = 0;\n    i2c_handle->current_state = HAL_I2C_STATE_LISTENING;\n  }\n  else {\n    if ((i2c_handle->current_state != HAL_I2C_STATE_ABORTED) && ((i2c_handle->i2c_reg->CR2 & 0x800) == 0)) {\n      i2c_handle->current_state = HAL_I2C_STATE_READY_FOR_TRANSFER;\n    }\n    i2c_handle->previous_state = 0;\n    i2c_handle->Mode = HAL_I2C_NO_MODE;\n  }\n  i2c_handle->i2c_reg->CR1 = i2c_handle->i2c_reg->CR1 & 0xfffff7ff;\n  i2c_instance = i2c_handle->i2c_reg;\n  if ((i2c_instance->CR2 & 0x800) == 0) {\n    if (i2c_handle->current_state == HAL_I2C_STATE_ABORTED) {\n      i2c_handle->current_state = HAL_I2C_STATE_READY_FOR_TRANSFER;\n      i2c_handle->error_code = 0;\n      if ((i2c_instance->SR1 & 0x40) != 0) {\n        buffer_ptr = i2c_handle->data_ptr;\n        i2c_handle->data_ptr = buffer_ptr + 1;\n        *buffer_ptr = (uint8_t)i2c_instance->DR;\n      }\n      i2c_handle->i2c_reg->CR1 = i2c_handle->i2c_reg->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(i2c_handle);\n    }\n    else {\n      if ((i2c_instance->SR1 & 0x40) != 0) {\n        buffer_ptr = i2c_handle->data_ptr;\n        i2c_handle->data_ptr = buffer_ptr + 1;\n        *buffer_ptr = (uint8_t)i2c_instance->DR;\n      }\n      HAL_I2C_ErrorCallback(i2c_handle);\n    }\n  }\n  else {\n    i2c_instance->CR2 = i2c_instance->CR2 & 0xfffff7ff;\n    if (i2c_handle->tx_dma_handle->current_state == HAL_DMA_READY) {\n      i2c_handle->rx_dma_handle->transfer_abort_callback = DAT_0800507c;\n      status = HAL_DMA_Abort_IT(i2c_handle->rx_dma_handle);\n      if (status != HAL_OK) {\n        if ((i2c_handle->i2c_reg->SR1 & 0x40) != 0) {\n          buffer_ptr = i2c_handle->data_ptr;\n          i2c_handle->data_ptr = buffer_ptr + 1;\n          *buffer_ptr = (uint8_t)i2c_handle->i2c_reg->DR;\n        }\n        i2c_handle->i2c_reg->CR1 = i2c_handle->i2c_reg->CR1 & 0xfffffffe;\n        i2c_handle->current_state = HAL_I2C_STATE_READY_FOR_TRANSFER;\n        (*i2c_handle->rx_dma_handle->transfer_abort_callback)(i2c_handle->rx_dma_handle);\n      }\n    }\n    else {\n      i2c_handle->tx_dma_handle->transfer_abort_callback = DAT_0800507c;\n      status = HAL_DMA_Abort_IT(i2c_handle->tx_dma_handle);\n      if (status != HAL_OK) {\n        i2c_handle->i2c_reg->CR1 = i2c_handle->i2c_reg->CR1 & 0xfffffffe;\n        i2c_handle->current_state = HAL_I2C_STATE_READY_FOR_TRANSFER;\n        (*i2c_handle->tx_dma_handle->transfer_abort_callback)(i2c_handle->tx_dma_handle);\n      }\n    }\n  }\n  if ((i2c_handle->current_state == HAL_I2C_STATE_LISTENING) && ((i2c_handle->error_code & 4) != 0)) {\n    i2c_handle->transfer_options = DAT_08005080;\n    i2c_handle->previous_state = 0;\n    i2c_handle->current_state = HAL_I2C_STATE_READY_FOR_TRANSFER;\n    i2c_handle->Mode = HAL_I2C_NO_MODE;\n    HAL_I2C_ListenCpltCallback(i2c_handle);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f3c",
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "handle_i2c_state_08004f3c"
        },
        "FUN_08004f3a": {
            "renaming": {
                "FUN_08004f3a": "do_nothing_08004f3a"
            },
            "code": "\nvoid do_nothing_08004f3a(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f3a",
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "imported": false,
            "current_name": "do_nothing_08004f3a"
        },
        "FUN_0800344a": {
            "renaming": {
                "this": "parserInstance",
                "waitForData": "isWaitingForData",
                "executeMultiByteCommand": "isExecutingMultiByteCommand",
                "multiByteChannel": "multiByteCommandChannel",
                "dataBufferSize": "sizeOfDataBuffer",
                "parsingSysex": "isParsingSysex",
                "sysexBytesRead": "numberOfSysexBytesRead",
                "currentSystemResetCallback": "currentSystemResetCallbackFunction",
                "systemCallbackFunction": "systemResetCallbackFunction",
                "FUN_0800344a": "reset_firmata_parser_0800344a"
            },
            "code": "\nvoid __parserInstancecall firmata::FirmataParser::resetFirmataParser_0800344a(FirmataParser *parserInstance)\n\n{\n  uint uVar1;\n  \n  parserInstance->isWaitingForData = 0;\n  parserInstance->isExecutingMultiByteCommand = '\\0';\n  parserInstance->multiByteCommandChannel = '\\0';\n  for (uVar1 = 0; uVar1 < parserInstance->sizeOfDataBuffer; uVar1 = uVar1 + 1) {\n    parserInstance->dataBuffer[uVar1] = '\\0';\n  }\n  parserInstance->isParsingSysex = false;\n  parserInstance->numberOfSysexBytesRead = 0;\n  if (parserInstance->currentSystemResetCallbackFunction != (systemResetCallbackFunction)0x0) {\n    (*parserInstance->currentSystemResetCallbackFunction)(parserInstance->currentSystemResetCallbackFunctionContext);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800344a",
            "calling": [
                "parse"
            ],
            "imported": false,
            "current_name": "reset_firmata_parser_0800344a"
        },
        "FUN_080071e4": {
            "renaming": {
                "FUN_080071e4": "stop_pwm_signal_080071e4",
                "pin": "pin_name",
                "Channel": "pwm_channel",
                "uVar1": "pwm_function",
                "timHandle": "timer_handle"
            },
            "code": "\nvoid stop_PWM_signal_080071e4(PinName_conflict pin_name)\n\n{\n  uint32_t pwm_channel;\n  uint32_t pwm_function;\n  TIM_HandleTypeDef_conflict timer_handle;\n  \n  timer_handle.Instance =\n       (TIM_TypeDef_conflict *)pin_namemap_peripheral(pin_name,(PinMap_conflict *)PTR_PinMap_PWM_08007238);\n  if ((timer_handle.Instance != (TIM_TypeDef_conflict *)0x0) &&\n     ((((pwm_channel = get_pwm_channel(pin_name), pwm_channel == 0 || (pwm_channel == 4)) || (pwm_channel == 8)) ||\n      ((pwm_channel == 0xc || (pwm_channel == 0x18)))))) {\n    pwm_function = pin_namemap_function(pin_name,(PinMap_conflict *)PTR_PinMap_PWM_08007238);\n    if ((pwm_function & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timer_handle,pwm_channel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timer_handle,pwm_channel);\n    }\n    HAL_TIM_PWM_DeInit(&timer_handle);\n  }\n  return;\n}\n\n",
            "called": [
                "pinmap_function",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "pinmap_peripheral",
                "HAL_TIM_PWM_DeInit",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080071e4",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "stop_pwm_signal_080071e4"
        },
        "FUN_08002c54": {
            "renaming": {
                "FUN_08002c54": "execute_current_pin_mode_callback_08002c54",
                "param_1": "callbackParameter",
                "command": "pinCommand",
                "value": "pinValue"
            },
            "code": "\nvoid firmata::FirmataClass::executeCurrentPinModeCallback_08002c54(void *callbackParameter,uint8_t pinCommand,uint16_t pinValue)\n\n{\n  if (*(code **)PTR_currentPinModeCallback_08002c64 != (code *)0x0) {\n    (**(code **)PTR_currentPinModeCallback_08002c64)(pinCommand,pinValue);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c54",
            "calling": [],
            "imported": false,
            "current_name": "execute_current_pin_mode_callback_08002c54"
        },
        "FUN_080072fa": {
            "renaming": {
                "FUN_080072fa": "initialize_system_080072fa",
                "HAL_Init": "initialize_HAL",
                "SystemClock_Config": "configure_system_clock"
            },
            "code": "\nvoid initialize_system_080072fa(void)\n\n{\n  initialize_HAL();\n  configure_system_clock();\n  return;\n}\n\n",
            "called": [
                "HAL_Init",
                "SystemClock_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072fa",
            "calling": [
                "init"
            ],
            "imported": false,
            "current_name": "initialize_system_080072fa"
        },
        "FUN_08003346": {
            "renaming": {
                "this": "parser",
                "command": "cmd",
                "newFunction": "callback",
                "context": "ctx",
                "currentReportFirmwareCallback": "reportFirmwareCallback",
                "currentReportFirmwareCallbackContext": "reportFirmwareCallbackContext",
                "FUN_08003346": "set_report_firmware_callback_08003346"
            },
            "code": "\nvoid __parsercall\nfirmata::FirmataParser::setReportFirmwareCallback_08003346(FirmataParser *parser,uint8_t cmd,versionCallbackFunction callback,void *ctx)\n\n{\n  if (cmd == 'y') {\n    parser->reportFirmwareCallback = callback;\n    parser->reportFirmwareCallbackContext = ctx;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003346",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "set_report_firmware_callback_08003346"
        },
        "FUN_08003106": {
            "renaming": {
                "FUN_08003106": "send_pin_data_08003106",
                "pin": "pinNumber",
                "bytec": "byteCount",
                "bytev": "byteValues",
                "FirmataStream": "firmataSerial",
                "super_Print": "superPrint",
                "_vptr_Print": "virtualPrint",
                "encodeByteStream": "encodeBytes"
            },
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x0800311e */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::sendPinData_08003106(FirmataMarshaller *this,uint8_t pinNumber,size_t byteCount,uint8_t *byteValues)\n\n{\n  if (this->firmataSerial != (Stream *)0x0) {\n    (**(this->firmataSerial->superPrint).virtualPrint)(this,0xf0);\n    (**(this->firmataSerial->superPrint).virtualPrint)(this->firmataSerial,0x6f);\n    (**(this->firmataSerial->superPrint).virtualPrint)(this->firmataSerial,(uint)pinNumber);\n    encodeBytes(this,byteCount,byteValues,byteCount);\n    (**(this->firmataSerial->superPrint).virtualPrint)(this->firmataSerial,0xf7);\n  }\n  return;\n}\n\n",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003106",
            "calling": [
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "send_pin_data_08003106"
        },
        "FUN_08007708": {
            "renaming": {
                "FUN_08007708": "initialize_timer_08007708",
                "htim": "timer_handle",
                "timer_enable_clock": "enable_timer_clock"
            },
            "code": "\nvoid initialize_timer_08007708(TIM_HandleTypeDef_conflict *timer_handle)\n\n{\n  enable_timer_clock(timer_handle);\n  return;\n}\n\n",
            "called": [
                "timer_enable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007708",
            "calling": [
                "HAL_TIM_OC_Init"
            ],
            "imported": false,
            "current_name": "initialize_timer_08007708"
        },
        "FUN_0800018c": {
            "renaming": {
                "FUN_0800018c": "afl_call_with_ticks_0800018c",
                "ticks": "num_ticks",
                "uVar1": "afl_result"
            },
            "code": "\nint afl_call_with_ticks_0800018c(int num_ticks)\n\n{\n  uint32_t afl_result;\n  \n  if (*(int *)PTR_noHyperCall_080001a4 != 0) {\n    return 0;\n  }\n  afl_result = aflCall(1,num_ticks,0);\n  return afl_result;\n}\n\n",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800018c",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "afl_call_with_ticks_0800018c"
        },
        "FUN_08003f94": {
            "renaming": {
                "FUN_08003f94": "set_irq_trigger_08003f94",
                "IRQn": "irq_number",
                "uVar1": "irq_uint"
            },
            "code": "\nvoid set_irq_trigger_08003f94(irq_number_Type_conflict irq_number)\n\n{\n  uint irq_uint;\n  \n  irq_uint = (uint)irq_number;\n  if (-1 < (int)irq_uint) {\n    *(int *)(DAT_08003fac + (irq_uint >> 5) * 4) = 1 << (irq_uint & 0x1f);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f94",
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "TimerPulseInit",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "set_irq_trigger_08003f94"
        },
        "FUN_08002c68": {
            "renaming": {
                "FUN_08002c68": "process_pin_value_callback_08002c68",
                "param_1": "callbackData",
                "command": "pinCommand",
                "value": "pinValue"
            },
            "code": "\nvoid firmata::FirmataClass::processPinValueCallback_08002c68(void *callbackData,uint8_t pinCommand,uint16_t pinValue)\n\n{\n  if (*(code **)PTR_currentPinValueCallback_08002c78 != (code *)0x0) {\n    (**(code **)PTR_currentPinValueCallback_08002c78)(pinCommand,pinValue);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c68",
            "calling": [],
            "imported": false,
            "current_name": "process_pin_value_callback_08002c68"
        },
        "FUN_08002a26": {
            "renaming": {
                "this": "wireInstance",
                "FUN_08002a26": "initialize_wire_08002a26"
            },
            "code": "\nvoid __wireInstancecall TwoWire::initializeWire_08002a26(TwoWire *wireInstance)\n\n{\n  initializeWire_08002a26(wireInstance,0x33);\n  return;\n}\n\n",
            "called": [
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a26",
            "calling": [
                "enableI2CPins"
            ],
            "imported": false,
            "current_name": "initialize_wire_08002a26"
        },
        "FUN_0800430c": {
            "renaming": {
                "FUN_0800430c": "configure_i2c_mode_0800430c",
                "hi2c": "i2c_handle",
                "Mode": "mode",
                "EventCount": "event_count",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "Devaddress": "device_address",
                "AddressingMode": "addressing_mode",
                "State": "i2c_state",
                "HAL_I2C_MODE_MEM": "memory_mode",
                "HAL_I2C_STATE_BUSY_TX": "busy_tx_state",
                "HAL_OK": "hal_status_ok"
            },
            "code": "\nHAL_StatusTypeDef_conflict configure_i2c_mode_0800430c(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  if (i2c_handle->mode == memory_mode) {\n    if (i2c_handle->event_count == 0) {\n      i2c_handle->i2c_instance->data_register = i2c_handle->device_address & 0xfe;\n    }\n    else {\n      i2c_handle->i2c_instance->data_register = i2c_handle->device_address & 0xff | 1;\n    }\n  }\n  else if ((i2c_handle->Init).addressing_mode == 0x4000) {\n    if (i2c_handle->i2c_state == busy_tx_state) {\n      i2c_handle->i2c_instance->data_register = i2c_handle->device_address & 0xfe;\n    }\n    else {\n      i2c_handle->i2c_instance->data_register = i2c_handle->device_address & 0xff | 1;\n    }\n  }\n  else if (i2c_handle->event_count == 0) {\n    i2c_handle->i2c_instance->data_register = (i2c_handle->device_address << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (i2c_handle->event_count == 1) {\n    i2c_handle->i2c_instance->data_register = (i2c_handle->device_address << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return hal_status_ok;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800430c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "configure_i2c_mode_0800430c"
        },
        "FUN_08003350": {
            "renaming": {
                "this": "self",
                "command": "cmd",
                "newFunction": "callback",
                "context": "ctx",
                "currentReportVersionCallback": "report_ver_cb",
                "currentReportVersionCallbackContext": "report_ver_cb_ctx",
                "currentSystemResetCallback": "sys_reset_cb",
                "currentSystemResetCallbackContext": "sys_reset_cb_ctx",
                "FUN_08003350": "set_callback_08003350"
            },
            "code": "\nvoid __selfcall\nfirmata::FirmataParser::set_callback_08003350(FirmataParser *self,uint8_t cmd,systemCallbackFunction callback,void *ctx)\n\n{\n  if (cmd == 0xf9) {\n    self->report_ver_cb = callback;\n    self->report_ver_cb_ctx = ctx;\n    return;\n  }\n  if (cmd != 0xff) {\n    return;\n  }\n  self->sys_reset_cb = callback;\n  self->sys_reset_cb_ctx = ctx;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003350",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "set_callback_08003350"
        },
        "FUN_08007710": {
            "renaming": {
                "FUN_08007710": "disable_timer_clock_08007710",
                "htim": "timer_handle"
            },
            "code": "\nvoid disable_timer_clock_08007710(TIM_HandleTypeDef_conflict *timer_handle)\n\n{\n  timer_disable_clock(timer_handle);\n  return;\n}\n\n",
            "called": [
                "timer_disable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007710",
            "calling": [
                "HAL_TIM_OC_DeInit"
            ],
            "imported": false,
            "current_name": "disable_timer_clock_08007710"
        },
        "FUN_08003474": {
            "renaming": {
                "this": "parser",
                "inputData": "data",
                "bVar1": "byteVar",
                "uVar2": "uintData",
                "pos": "position",
                "parsingSysex": "isParsingSysex",
                "sysexBytesRead": "sysexDataRead",
                "bufferDataAtPosition": "storeDataAtPosition",
                "processSysexMessage": "handleSysexMessage",
                "waitForData": "dataToWait",
                "multiByteChannel": "channelData",
                "executeMultiByteCommand": "commandToExecute",
                "systemReset": "resetSystem",
                "currentReportVersionCallback": "versionCallback",
                "currentReportVersionCallbackContext": "versionCallbackContext",
                "callbackFunction": "callbackFunc",
                "currentReportDigitalCallback": "digitalReportCallback",
                "currentReportDigitalCallbackContext": "digitalReportCallbackContext",
                "currentDigitalCallback": "digitalCallback",
                "currentDigitalCallbackContext": "digitalCallbackContext",
                "currentReportAnalogCallback": "analogReportCallback",
                "currentReportAnalogCallbackContext": "analogReportCallbackContext",
                "currentPinModeCallback": "pinModeCallback",
                "currentPinModeCallbackContext": "pinModeCallbackContext",
                "currentPinValueCallback": "pinValueCallback",
                "currentPinValueCallbackContext": "pinValueCallbackContext",
                "currentAnalogCallback": "analogCallback",
                "currentAnalogCallbackContext": "analogCallbackContext",
                "FUN_08003474": "parse_firmata_message_08003474"
            },
            "code": "\nvoid __parsercall firmata::FirmataParser::parseFirmataMessage_08003474(FirmataParser *parser,uint8_t data)\n\n{\n  byte byteVar;\n  uint uintData;\n  size_t position;\n  \n  uintData = (uint)data;\n  if (parser->isParsingSysex != false) {\n    if (uintData != 0xf7) {\n      storeDataAtPosition(parser,data,parser->sysexDataRead);\n      parser->sysexDataRead = parser->sysexDataRead + 1;\n      return;\n    }\n    parser->isParsingSysex = false;\n    handleSysexMessage(parser);\n    return;\n  }\n  if ((parser->dataToWait == 0) || (0x7f < uintData)) {\n    if (uintData < 0xf0) {\n      parser->channelData = data & 0xf;\n      uintData = uintData & 0xf0;\n    }\n    if (uintData == 0xf0) {\n      parser->isParsingSysex = true;\n      parser->sysexDataRead = 0;\n      return;\n    }\n    if (uintData < 0xf1) {\n      if (uintData != 0xc0) {\n        if (uintData < 0xc1) {\n          if (uintData != 0x90) {\n            return;\n          }\n        }\n        else {\n          if (uintData == 0xd0) goto LAB_0800359c;\n          if (uintData != 0xe0) {\n            return;\n          }\n        }\nLAB_08003586:\n        parser->dataToWait = 2;\n        parser->commandToExecute = (uint8_t)uintData;\n        return;\n      }\nLAB_0800359c:\n      parser->dataToWait = 1;\n      parser->commandToExecute = (uint8_t)uintData;\n      return;\n    }\n    if (uintData != 0xf9) {\n      if (0xf9 < uintData) {\n        if (uintData == 0xff) {\n          resetSystem(parser);\n          return;\n        }\n        return;\n      }\n      if (1 < uintData - 0xf4) {\n        return;\n      }\n      goto LAB_08003586;\n    }\n    if (parser->versionCallback != (systemCallbackFunction)0x0) {\n      (*parser->versionCallback)(parser->versionCallbackContext);\n    }\n  }\n  else {\n    position = parser->dataToWait - 1;\n    parser->dataToWait = position;\n    storeDataAtPosition(parser,data,position);\n    if ((parser->dataToWait == 0) && (byteVar = parser->commandToExecute, byteVar != 0)) {\n      if (byteVar == 0xd0) {\n        if (parser->digitalReportCallback != (callbackFunc)0x0) {\n          (*parser->digitalReportCallback)\n                    (parser->digitalReportCallbackContext,parser->channelData,\n                     (uint16_t)*parser->dataBuffer);\n        }\n      }\n      else if (byteVar < 0xd1) {\n        if (byteVar == 0x90) {\n          if (parser->digitalCallback != (callbackFunc)0x0) {\n            (*parser->digitalCallback)\n                      (parser->digitalCallbackContext,parser->channelData,\n                       (ushort)parser->dataBuffer[1] + (ushort)*parser->dataBuffer * 0x80);\n          }\n        }\n        else if ((byteVar == 0xc0) && (parser->analogReportCallback != (callbackFunc)0x0)) {\n          (*parser->analogReportCallback)\n                    (parser->analogReportCallbackContext,parser->channelData,\n                     (uint16_t)*parser->dataBuffer);\n        }\n      }\n      else if (byteVar == 0xf4) {\n        if (parser->pinModeCallback != (callbackFunc)0x0) {\n          (*parser->pinModeCallback)\n                    (parser->pinModeCallbackContext,parser->dataBuffer[1],\n                     (uint16_t)*parser->dataBuffer);\n        }\n      }\n      else if (byteVar == 0xf5) {\n        if (parser->pinValueCallback != (callbackFunc)0x0) {\n          (*parser->pinValueCallback)\n                    (parser->pinValueCallbackContext,parser->dataBuffer[1],\n                     (uint16_t)*parser->dataBuffer);\n        }\n      }\n      else if ((byteVar == 0xe0) && (parser->analogCallback != (callbackFunc)0x0)) {\n        (*parser->analogCallback)\n                  (parser->analogCallbackContext,parser->channelData,\n                   (ushort)parser->dataBuffer[1] + (ushort)*parser->dataBuffer * 0x80);\n      }\n      parser->commandToExecute = '\\0';\n      return;\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "systemReset",
                "bufferDataAtPosition",
                "processSysexMessage"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003474",
            "calling": [
                "processInput"
            ],
            "imported": false,
            "current_name": "parse_firmata_message_08003474"
        },
        "FUN_08008804": {
            "renaming": {
                "FUN_08008804": "allocate_memory_08008804",
                "incr": "increment",
                "caddr_t": "memory_address",
                "pcVar1": "current_ptr",
                "pcVar2": "new_ptr",
                "&stack0x00000000": "stack_limit",
                "undefined4": "error_code"
            },
            "code": "\nmemory_address allocate_memory_08008804(int increment)\n\n{\n  memory_address current_ptr;\n  memory_address new_ptr;\n  \n  if (*(int *)PTR_heap_end_08008834 == 0) {\n    *(undefined **)PTR_heap_end_08008834 = PTR__ebss_08008838;\n  }\n  current_ptr = *(memory_address *)PTR_heap_end_08008834;\n  new_ptr = current_ptr + increment;\n  if (new_ptr <= stack_limit) {\n    *(memory_address *)PTR_heap_end_08008834 = new_ptr;\n    return current_ptr;\n  }\n  *(error_code *)PTR_errno_0800883c = 0xc;\n  return (memory_address)0xffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008804",
            "calling": [
                "_sbrk_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08008804"
        },
        "FUN_08004e3c": {
            "renaming": {
                "FUN_08004e3c": "i2c_transfer_08004e3c",
                "hi2c": "i2c_handle",
                "uVar1": "transfer_options",
                "puVar2": "buffer_pointer",
                "XferOptions": "transfer_options",
                "XferCount": "transfer_count",
                "Instance": "i2c_instance",
                "CR1": "control_register_1",
                "CR2": "control_register_2",
                "pBuffPtr": "buffer_pointer",
                "State": "i2c_state",
                "PreviousState": "previous_i2c_state",
                "Mode": "i2c_mode",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "\nHAL_StatusTypeDef i2c_transfer_08004e3c(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  uint32_t transfer_options;\n  uint8_t *buffer_pointer;\n  \n  transfer_options = i2c_handle->transfer_options;\n  if (i2c_handle->transfer_count == 3) {\n    if (((transfer_options == 4) || (transfer_options == 8)) || (transfer_options == 0xffff0000)) {\n      i2c_handle->i2c_instance->control_register_1 = i2c_handle->i2c_instance->control_register_1 & 0xfffffbff;\n    }\n    buffer_pointer = i2c_handle->buffer_pointer;\n    i2c_handle->buffer_pointer = buffer_pointer + 1;\n    *buffer_pointer = (uint8_t)i2c_handle->i2c_instance->DR;\n    i2c_handle->transfer_count = i2c_handle->transfer_count - 1;\n  }\n  else if (i2c_handle->transfer_count == 2) {\n    if (((transfer_options == 4) || (transfer_options == 8)) || (transfer_options == 0xffff0000)) {\n      i2c_handle->i2c_instance->control_register_2 = i2c_handle->i2c_instance->control_register_2 & 0xfffffcff;\n      i2c_handle->i2c_instance->control_register_1 = i2c_handle->i2c_instance->control_register_1 | 0x200;\n    }\n    else {\n      if (transfer_options == 2) {\n        i2c_handle->i2c_instance->control_register_1 = i2c_handle->i2c_instance->control_register_1 | 0x400;\n      }\n      else {\n        i2c_handle->i2c_instance->control_register_1 = i2c_handle->i2c_instance->control_register_1 & 0xfffffbff;\n      }\n      i2c_handle->i2c_instance->control_register_2 = i2c_handle->i2c_instance->control_register_2 & 0xfffffcff;\n    }\n    buffer_pointer = i2c_handle->buffer_pointer;\n    i2c_handle->buffer_pointer = buffer_pointer + 1;\n    *buffer_pointer = (uint8_t)i2c_handle->i2c_instance->DR;\n    i2c_handle->transfer_count = i2c_handle->transfer_count - 1;\n    buffer_pointer = i2c_handle->buffer_pointer;\n    i2c_handle->buffer_pointer = buffer_pointer + 1;\n    *buffer_pointer = (uint8_t)i2c_handle->i2c_instance->DR;\n    i2c_handle->transfer_count = i2c_handle->transfer_count - 1;\n    i2c_handle->i2c_state = HAL_I2C_STATE_READY;\n    i2c_handle->previous_i2c_state = 0;\n    if (i2c_handle->i2c_mode == HAL_I2C_MODE_MEM) {\n      i2c_handle->i2c_mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(i2c_handle);\n    }\n    else {\n      i2c_handle->i2c_mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(i2c_handle);\n    }\n  }\n  else {\n    buffer_pointer = i2c_handle->buffer_pointer;\n    i2c_handle->buffer_pointer = buffer_pointer + 1;\n    *buffer_pointer = (uint8_t)i2c_handle->i2c_instance->DR;\n    i2c_handle->transfer_count = i2c_handle->transfer_count - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e3c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08004e3c"
        },
        "FUN_080091a0": {
            "renaming": {
                "FUN_080091a0": "reverse_and_return_pointer_080091a0",
                "__ptr": "input_pointer"
            },
            "code": "\nvoid reverse_and_return_pointer_080091a0(void *input_pointer)\n\n{\n  _reverse_and_return_pointer_080091a0_r(*(undefined4 *)PTR__impure_ptr_080091ac,input_pointer);\n  return;\n}\n\n",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091a0",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "reverse_and_return_pointer_080091a0"
        },
        "FUN_08002a1c": {
            "renaming": {
                "this": "self",
                "address": "new_address",
                "uint8_t": "byte",
                "FUN_08002a1c": "set_address_08002a1c"
            },
            "code": "\nvoid __selfcall TwoWire::set_address_08002a1c(TwoWire *self,int new_address)\n\n{\n  set_address_08002a1c(self,(byte)new_address);\n  return;\n}\n\n",
            "called": [
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a1c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "set_address_08002a1c"
        },
        "FUN_08007718": {
            "renaming": {
                "FUN_08007718": "get_stimer_08007718",
                "htim": "timer_handle",
                "stimer_t_conflict": "conflict_stimer_t",
                "Lock": "conflict_lock",
                "&htim[-1].Lock": "address_of_conflict_lock"
            },
            "code": "\nconflict_stimer_t * get_stimer_08007718(TIM_HandleTypeDef_conflict *timer_handle)\n\n{\n  return (conflict_stimer_t *)address_of_conflict_lock;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007718",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "imported": false,
            "current_name": "get_stimer_08007718"
        },
        "FUN_08002a30": {
            "renaming": {
                "FUN_08002a30": "initialize_transmission_08002a30",
                "this": "wire",
                "address": "deviceAddress"
            },
            "code": "\nvoid __wirecall TwoWire::initializeTransmission_08002a30(TwoWire *wire,uint8_t deviceAddress)\n\n{\n  *PTR_transmitting_08002a48 = 1;\n  *PTR_txAddress_08002a4c = deviceAddress << 1;\n  *PTR_txBufferIndex_08002a50 = 0;\n  *PTR_txBufferLength_08002a54 = 0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a30",
            "calling": [
                "requestFrom",
                "sysexCallback",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "initialize_transmission_08002a30"
        },
        "FUN_08009cd0": {
            "renaming": {
                "FUN_08009cd0": "register_memory_walk_08009cd0",
                "param_1": "reentrancy_structure",
                "_fwalk_reent": "walk_registered_memory_blocks"
            },
            "code": "\nvoid register_memory_walk_08009cd0(undefined4 reentrancy_structure)\n\n{\n  walk_registered_memory_blocks(reentrancy_structure,DAT_08009cd8);\n  return;\n}\n\n",
            "called": [
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009cd0",
            "calling": [],
            "imported": false,
            "current_name": "register_memory_walk_08009cd0"
        },
        "FUN_0800322c": {
            "renaming": {
                "this": "marshaller",
                "major": "major_version",
                "minor": "minor_version",
                "FirmataStream": "stream",
                "FUN_0800322c": "send_firmware_version_0800322c"
            },
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003240 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::send_firmware_version_0800322c(FirmataMarshaller *marshaller,uint8_t major_version,uint8_t minor_version)\n\n{\n  if (marshaller->stream != (Stream *)0x0) {\n    (**(marshaller->stream->super_Print)._vptr_Print)(marshaller,0xf9);\n    (**(marshaller->stream->super_Print)._vptr_Print)(marshaller->stream,(uint)major_version);\n    (**(marshaller->stream->super_Print)._vptr_Print)(marshaller->stream,(uint)minor_version);\n    return;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800322c",
            "calling": [
                "printVersion"
            ],
            "imported": false,
            "current_name": "send_firmware_version_0800322c"
        },
        "FUN_08003760": {
            "renaming": {
                "FUN_08003760": "get_uw_tick_value_08003760"
            },
            "code": "\nuint32_t get_uwTick_value_08003760(void)\n\n{\n  return *(uint32_t *)PTR_uwTick_08003768;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003760",
            "calling": [
                "ADC_ConversionStop_Disable",
                "ADC_Enable",
                "HAL_ADCEx_Calibration_Start",
                "UART_WaitOnFlagUntilTimeout",
                "HAL_RCC_OscConfig",
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_ADC_PollForConversion",
                "i2c_master_write",
                "uart_debug_write",
                "HAL_RCC_ClockConfig",
                "GetCurrentMilli",
                "i2c_master_read",
                "HAL_UART_Transmit"
            ],
            "imported": false,
            "current_name": "get_uw_tick_value_08003760"
        },
        "FUN_08000130": {
            "renaming": {
                "FUN_08000130": "execute_completed_code_08000130"
            },
            "code": "\nvoid execute_completed_code_08000130(void)\n\n{\n  if (DAT_08000164 == 0) {\n    if ((*(int *)PTR_completed_8667_08000170 != 0) && (DAT_08000174 != (code *)0x0)) {\n                    /* WARNING: Could not recover jumptable at 0x08000160. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*DAT_08000174)();\n      return;\n    }\n    return;\n  }\n  if ((*(int *)PTR_completed_8667_08000170 != 0) && (DAT_08000174 != (code *)0x0)) {\n                    /* WARNING: Could not recover jumptable at 0x08000158. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*DAT_08000174)(PTR_completed_8667_08000170,PTR_object_8672_0800016c);\n    return;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000130",
            "calling": [],
            "imported": false,
            "current_name": "execute_completed_code_08000130"
        },
        "FUN_08002798": {
            "renaming": {
                "this": "wireInstance",
                "FUN_08002798": "reset_wire_buffers_08002798"
            },
            "code": "\nvoid __wireInstancecall TwoWire::resetWireBuffers_08002798(TwoWire *wireInstance)\n\n{\n  *PTR_rxBufferIndex_080027d0 = 0;\n  *PTR_rxBufferLength_080027d4 = 0;\n  if (*(void **)PTR_rxBuffer_080027d8 != (void *)0x0) {\n    memset(*(void **)PTR_rxBuffer_080027d8,0,(uint)(byte)*PTR_rxBufferAllocated_080027dc);\n  }\n  *PTR_txBufferIndex_080027e0 = 0;\n  *PTR_txBufferLength_080027e4 = 0;\n  if (*(void **)PTR_txBuffer_080027e8 != (void *)0x0) {\n    memset(*(void **)PTR_txBuffer_080027e8,0,(uint)(byte)*PTR_txBufferAllocated_080027ec);\n  }\n  return;\n}\n\n",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002798",
            "calling": [],
            "imported": false,
            "current_name": "reset_wire_buffers_08002798"
        },
        "FUN_08009190": {
            "renaming": {
                "FUN_08009190": "allocate_memory_08009190",
                "__size": "memory_size",
                "pvVar1": "allocated_memory"
            },
            "code": "\nvoid * allocate_memory_08009190(size_t memory_size)\n\n{\n  void *allocated_memory;\n  \n  allocated_memory = (void *)_allocate_memory_08009190_r(*(undefined4 *)PTR__impure_ptr_0800919c,memory_size);\n  return allocated_memory;\n}\n\n",
            "called": [
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009190",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009190"
        },
        "FUN_0800242c": {
            "renaming": {
                "FUN_0800242c": "initialize_timer_pulse_0800242c",
                "obj": "timer_object",
                "TimerPulseInit": "initialize_pulse_timer",
                "stimer_t_conflict": "timer_configuration"
            },
            "code": "\nvoid initialize_timer_pulse_0800242c(stimer_t *timer_object)\n\n{\n  initialize_pulse_timer((timer_configuration *)timer_object,60000,0x5dc,DAT_08002440);\n  return;\n}\n\n",
            "called": [
                "TimerPulseInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800242c",
            "calling": [
                "attach"
            ],
            "imported": false,
            "current_name": "initialize_timer_pulse_0800242c"
        },
        "FUN_08002e44": {
            "renaming": {
                "FUN_08002e44": "update_firmware_version_08002e44",
                "this": "firmataObject",
                "name": "firmwareName",
                "major": "majorVersion",
                "minor": "minorVersion",
                "bVar1": "versionCount",
                "pcVar2": "cppString",
                "pcVar3": "lastSlashOrBackslash",
                "pbVar4": "versionVector",
                "sVar5": "nameLength"
            },
            "code": "\nvoid __firmataObjectcall\nfirmata::FirmataClass::updateFirmwareVersion_08002e44(FirmataClass *firmataObject,char *firmwareName,byte majorVersion,byte minorVersion)\n\n{\n  byte versionCount;\n  char *cppString;\n  char *lastSlashOrBackslash;\n  byte *versionVector;\n  size_t nameLength;\n  \n  cppString = strstr(firmwareName,PTR_s__cpp_08002ec0);\n  lastSlashOrBackslash = strrchr(firmwareName,0x2f);\n  if (lastSlashOrBackslash == (char *)0x0) {\n    lastSlashOrBackslash = strrchr(firmwareName,0x5c);\n  }\n  if (lastSlashOrBackslash != (char *)0x0) {\n    firmwareName = lastSlashOrBackslash + 1;\n  }\n  if (cppString == (char *)0x0) {\n    nameLength = strlen(firmwareName);\n    firmataObject->firmwareVersionCount = (char)nameLength + '\\x02';\n  }\n  else {\n    firmataObject->firmwareVersionCount = ((char)cppString - (char)firmwareName) + '\\x02';\n  }\n  free(firmataObject->firmwareVersionVector);\n  versionCount = firmataObject->firmwareVersionCount;\n  versionVector = (byte *)malloc(versionCount + 1);\n  firmataObject->firmwareVersionVector = versionVector;\n  versionVector[versionCount] = '\\0';\n  *versionVector = majorVersion;\n  versionVector[1] = minorVersion;\n  strncpy((char *)(versionVector + 2),firmwareName,firmataObject->firmwareVersionCount - 2);\n  return;\n}\n\n",
            "called": [
                "free",
                "strncpy",
                "strstr",
                "strrchr",
                "malloc",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e44",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "update_firmware_version_08002e44"
        },
        "FUN_0800a0a8": {
            "renaming": {
                "FUN_0800a0a8": "write_and_check_error_0800a0a8",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "puVar1": "errno_ptr",
                "iVar2": "write_result"
            },
            "code": "\nvoid write_and_check_error_0800a0a8(int *error_code,int file_descriptor,char *buffer,int buffer_size)\n\n{\n  undefined *errno_ptr;\n  int write_result;\n  \n  errno_ptr = PTR_errno_0800a0c8;\n  *(undefined4 *)PTR_errno_0800a0c8 = 0;\n  write_result = _write(file_descriptor,buffer,buffer_size);\n  if ((write_result == -1) && (*(int *)errno_ptr != 0)) {\n    *error_code = *(int *)errno_ptr;\n  }\n  return;\n}\n\n",
            "called": [
                "_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0a8",
            "calling": [
                "__swrite"
            ],
            "imported": false,
            "current_name": "write_and_check_error_0800a0a8"
        },
        "FUN_08002c00": {
            "renaming": {
                "FUN_08002c00": "read_write_data_08002c00",
                "this": "wire",
                "address": "device_address",
                "quantity": "data_quantity",
                "sendStop": "send_stop",
                "uVar1": "result"
            },
            "code": "\nuint8_t __wirecall\nTwoWire::read_write_data_08002c00(TwoWire *wire,uint8_t device_address,uint8_t data_quantity,uint8_t send_stop)\n\n{\n  uint8_t result;\n  \n  result = read_write_data_08002c00(wire,device_address,data_quantity,0,'\\0',send_stop);\n  return result;\n}\n\n",
            "called": [
                "requestFrom"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c00",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "read_write_data_08002c00"
        },
        "FUN_08003f30": {
            "renaming": {
                "FUN_08003f30": "set_interrupt_priority_08003f30",
                "IRQn": "interrupt_number",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "uVar1": "interrupt_num",
                "uVar2": "bit_shift",
                "uVar3": "priority_level"
            },
            "code": "\nvoid set_interrupt_priority_08003f30(interrupt_number_Type_conflict interrupt_number,uint32_t preempt_priority,uint32_t sub_priority)\n\n{\n  uint interrupt_num;\n  uint bit_shift;\n  uint priority_level;\n  \n  interrupt_num = (uint)interrupt_number;\n  bit_shift = (uint)(*(int *)(DAT_08003f8c + 0xc) << 0x15) >> 0x1d;\n  priority_level = 7 - bit_shift;\n  if (3 < priority_level) {\n    priority_level = 4;\n  }\n  if (bit_shift + 4 < 7) {\n    bit_shift = 0;\n  }\n  else {\n    bit_shift = bit_shift - 3;\n  }\n  bit_shift = (preempt_priority & (1 << (priority_level & 0xff)) - 1U) << (bit_shift & 0xff) |\n          (1 << (bit_shift & 0xff)) - 1U & sub_priority;\n  if ((int)interrupt_num < 0) {\n    *(char *)(DAT_08003f90 + (interrupt_num & 0xf)) = (char)(bit_shift << 4);\n  }\n  else {\n    *(char *)(interrupt_num + 0xe000e400) = (char)(bit_shift << 4);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f30",
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "HAL_InitTick",
                "TimerPulseInit",
                "SystemClock_Config",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_08003f30"
        },
        "FUN_080073d8": {
            "renaming": {
                "FUN_080073d8": "set_alarm_handler_080073d8"
            },
            "code": "\nvoid set_alarm_handler_080073d8(void)\n\n{\n  HAL_RTC_AlarmIRQHandler((RTC_HandleTypeDef *)PTR_RtcHandle_080073e4);\n  return;\n}\n\n",
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073d8",
            "calling": [],
            "imported": false,
            "current_name": "set_alarm_handler_080073d8"
        },
        "FUN_080085dc": {
            "renaming": {
                "FUN_080085dc": "is_uart_transmit_complete_080085dc",
                "obj": "serial_object",
                "HVar1": "uart_state"
            },
            "code": "\nuint8_t is_uart_transmit_complete_080085dc(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(*(UART_HandleTypeDef **)\n                             (PTR_uart_handlers_080085fc + (uint)serial_object->index * 4));\n  return (uart_state & 0x21U) == 0x21;\n}\n\n",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085dc",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "is_uart_transmit_complete_080085dc"
        },
        "FUN_08008ed6": {
            "renaming": {
                "this": "print_object",
                "n": "number",
                "base": "target_base",
                "sVar1": "result",
                "uint8_t": "unsigned_byte",
                "_vptr_Print": "virtual_function_table",
                "FUN_08008ed6": "print_number_in_base_08008ed6"
            },
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x08008ee8 */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n\nsize_t __print_objectcall Prinumbert::print_number_in_base_08008ed6(Prinumbert *print_object,ulonumberg number,inumbert target_base)\n\n{\n  size_t result;\n  \n  if (target_base != 0) {\n    result = print_number_in_base_08008ed6Number(print_object,number,(unsigned_byte)target_base);\n    returnumber result;\n  }\n  result = (**print_object->virtual_function_table)(print_object,number & 0xff);\n  returnumber result;\n}\n\n",
            "called": [
                "printNumber"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ed6",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "print_number_in_base_08008ed6"
        },
        "FUN_08008db0": {
            "renaming": {
                "FUN_08008db0": "initialize_statics_08008db0",
                "__static_initialization_and_destruction_0": "initialize_destructors"
            },
            "code": "\nvoid initialize_statics_08008db0(void)\n\n{\n  initialize_destructors(1,0xffff);\n  return;\n}\n\n",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008db0",
            "calling": [],
            "imported": false,
            "current_name": "initialize_statics_08008db0"
        },
        "FUN_08002444": {
            "renaming": {
                "FUN_08002444": "set_servo_position_08002444",
                "obj": "servo",
                "uVar5": "servo_idx",
                "bVar1": "servo_found",
                "puVar2": "timer_channel_ptr",
                "iVar4": "servo_offset",
                "uVar3": "timer_counter"
            },
            "code": "\nvoid set_servo_position_08002444(stimer_t *servo,uint32_t channel)\n\n{\n  bool servo_found;\n  undefined *timer_channel_ptr;\n  uint32_t timer_counter;\n  int servo_offset;\n  uint servo_idx;\n  \n  servo_idx = (uint)servo->idx;\n  if ((PTR_timerChannel_0800256c[servo_idx] & 0x80) == 0) {\n    servo_offset = servo_idx * 0xc;\n    if ((char)PTR_timerChannel_0800256c[servo_idx] + servo_offset < (int)(uint)(byte)*PTR_ServoCount_08002570)\n    {\n      if ((PTR_servos_08002574[((char)PTR_timerChannel_0800256c[servo_idx] + servo_offset) * 8] & 0x40) == 0) {\n        servo_found = false;\n      }\n      else {\n        servo_found = true;\n      }\n    }\n    else {\n      servo_found = false;\n    }\n    if (servo_found) {\n      digitalWrite((byte)PTR_servos_08002574[(servo_offset + (char)PTR_timerChannel_0800256c[servo_idx]) * 8] &\n                   0x3f,0);\n    }\n  }\n  else {\n    setTimerCounter((stimer_t_conflict *)servo,0);\n  }\n  timer_channel_ptr = PTR_timerChannel_0800256c;\n  PTR_timerChannel_0800256c[servo_idx] = PTR_timerChannel_0800256c[servo_idx] + '\\x01';\n  servo_offset = servo_idx * 0xc;\n  if ((char)timer_channel_ptr[servo_idx] + servo_offset < (int)(uint)(byte)*PTR_ServoCount_08002570) {\n    if ((char)PTR_timerChannel_0800256c[servo_idx] < '\\f') {\n      servo_found = true;\n    }\n    else {\n      servo_found = false;\n    }\n  }\n  else {\n    servo_found = false;\n  }\n  if (servo_found) {\n    if ((PTR_servos_08002574[((char)PTR_timerChannel_0800256c[servo_idx] + servo_offset) * 8] & 0x40) != 0) {\n      digitalWrite((byte)PTR_servos_08002574[((char)PTR_timerChannel_0800256c[servo_idx] + servo_offset) * 8] &\n                   0x3f,1);\n    }\n    timer_counter = getTimerCounter((stimer_t_conflict *)servo);\n    setCCRRegister((stimer_t_conflict *)servo,channel,\n                   *(int *)(PTR_servos_08002574 +\n                           (servo_offset + (char)PTR_timerChannel_0800256c[servo_idx]) * 8 + 4) + timer_counter);\n    return;\n  }\n  timer_counter = getTimerCounter((stimer_t_conflict *)servo);\n  if (timer_counter + 4 < 20000) {\n    setCCRRegister((stimer_t_conflict *)servo,channel,20000);\n  }\n  else {\n    timer_counter = getTimerCounter((stimer_t_conflict *)servo);\n    setCCRRegister((stimer_t_conflict *)servo,channel,timer_counter + 4);\n  }\n  PTR_timerChannel_0800256c[servo_idx] = 0xff;\n  return;\n}\n\n",
            "called": [
                "digitalWrite",
                "getTimerCounter",
                "setCCRRegister",
                "setTimerCounter"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002444",
            "calling": [],
            "imported": false,
            "current_name": "set_servo_position_08002444"
        },
        "FUN_0800906c": {
            "renaming": {
                "FUN_0800906c": "handle_gpio_exti_irq_0800906c",
                "uVar1": "gpio_pin",
                "HAL_GPIO_EXTI_IRQHandler": "handle_gpio_exti_irq_request"
            },
            "code": "\nvoid handle_gpio_exti_irq_0800906c(void)\n\n{\n  uint gpio_pin;\n  \n  for (gpio_pin = 0x400; gpio_pin < 0x8001; gpio_pin = gpio_pin << 1) {\n    handle_gpio_exti_irq_0800906c_request((uint16_t)gpio_pin);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800906c",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_irq_0800906c"
        },
        "FUN_08003658": {
            "renaming": {
                "FUN_08003658": "initialize_system_08003658",
                "iVar1": "index",
                "puVar2": "ptr_completed",
                "UNRECOVERED_JUMPTABLE": "start_address"
            },
            "code": "\nvoid initialize_system_08003658(void)\n\n{\n  int index;\n  undefined4 *ptr_completed;\n  code *start_address;\n  \n  for (index = 0; ptr_completed = (undefined4 *)PTR_completed_8667_08003698,\n      PTR___dso_handle_08003690 + index < PTR_completed_8667_08003694; index = index + 4) {\n    *(undefined4 *)(PTR___dso_handle_08003690 + index) =\n         *(undefined4 *)(PTR__sidata_0800368c + index);\n  }\n  for (; ptr_completed < PTR__ebss_0800369c; ptr_completed = ptr_completed + 1) {\n    *ptr_completed = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  start_address = (code *)0x800368a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x0800368a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*start_address)();\n  return;\n}\n\n",
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003658",
            "calling": [],
            "imported": false,
            "current_name": "initialize_system_08003658"
        },
        "FUN_08009a80": {
            "renaming": {
                "FUN_08009a80": "process_input_08009a80",
                "param_1": "output_buffer",
                "param_2": "input_buffer",
                "uVar1": "result",
                "uVar2": "flag",
                "iVar3": "impure_ptr",
                "__sinit": "initialize_stream",
                "_free_r": "free_memory",
                "__smakebuf_r": "create_buffer"
            },
            "code": "\nuint process_input_08009a80(undefined4 *output_buffer,undefined4 *input_buffer)\n\n{\n  uint result;\n  ushort flag;\n  int impure_ptr;\n  \n  impure_ptr = *(int *)PTR__impure_ptr_08009b4c;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    initialize_stream(impure_ptr);\n  }\n  if (input_buffer == (undefined4 *)PTR___sf_fake_stdin_08009b50) {\n    input_buffer = *(undefined4 **)(impure_ptr + 4);\n  }\n  else if (input_buffer == (undefined4 *)PTR___sf_fake_stdout_08009b54) {\n    input_buffer = *(undefined4 **)(impure_ptr + 8);\n  }\n  else if (input_buffer == (undefined4 *)PTR___sf_fake_stderr_08009b58) {\n    input_buffer = *(undefined4 **)(impure_ptr + 0xc);\n  }\n  flag = *(ushort *)(input_buffer + 3);\n  result = (uint)flag;\n  if (-1 < (int)(result << 0x1c)) {\n    if (-1 < (int)(result << 0x1b)) {\n      *output_buffer = 9;\n      goto LAB_08009ab0;\n    }\n    if ((int)(result << 0x1d) < 0) {\n      if ((undefined4 *)input_buffer[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)input_buffer[0xd] != input_buffer + 0x11) {\n          free_memory(output_buffer);\n        }\n        input_buffer[0xd] = 0;\n      }\n      *(ushort *)(input_buffer + 3) = *(ushort *)(input_buffer + 3) & 0xffdb;\n      input_buffer[1] = 0;\n      *input_buffer = input_buffer[4];\n    }\n    *(ushort *)(input_buffer + 3) = *(ushort *)(input_buffer + 3) | 8;\n  }\n  if ((input_buffer[4] == 0) && ((*(ushort *)(input_buffer + 3) & 0x280) != 0x200)) {\n    create_buffer(output_buffer,input_buffer);\n  }\n  flag = *(ushort *)(input_buffer + 3);\n  result = flag & 1;\n  if ((flag & 1) == 0) {\n    if (-1 < (int)((uint)flag << 0x1e)) {\n      result = input_buffer[5];\n    }\n    input_buffer[2] = result;\n  }\n  else {\n    input_buffer[2] = 0;\n    input_buffer[6] = -input_buffer[5];\n  }\n  if (input_buffer[4] == 0) {\n    flag = *(ushort *)(input_buffer + 3);\n    result = (int)(short)flag & 0x80;\n    if (result != 0) {\nLAB_08009ab0:\n      *(ushort *)(input_buffer + 3) = flag | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "_free_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009a80",
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "process_input_08009a80"
        },
        "FUN_080062f4": {
            "renaming": {
                "FUN_080062f4": "disable_timer_channel_interrupt_080062f4",
                "htim": "timerHandler",
                "Channel": "channelNumber",
                "pTVar1": "timerInstance",
                "Instance": "instance",
                "DIER": "DMA_interrupt_enable_register",
                "CCER": "capture_compare_enable_register",
                "BDTR": "break_and_dead_time_register",
                "CR1": "control_register_1",
                "TIM_CCxChannelCmd": "disableTimerChannel"
            },
            "code": "\nHAL_StatusTypeDef_conflict disableTimerChannelInterrupt_080062f4(TIM_HandleTypeDef_conflict *timerHandler,uint32_t channelNumber)\n\n{\n  TIM_TypeDef_conflict *timerInstance;\n  \n  switch(channelNumber) {\n  case 0:\n    timerHandler->instance->DMA_interrupt_enable_register = timerHandler->instance->DMA_interrupt_enable_register & 0xfffffffd;\n    break;\n  case 4:\n    timerHandler->instance->DMA_interrupt_enable_register = timerHandler->instance->DMA_interrupt_enable_register & 0xfffffffb;\n    break;\n  case 8:\n    timerHandler->instance->DMA_interrupt_enable_register = timerHandler->instance->DMA_interrupt_enable_register & 0xfffffff7;\n    break;\n  case 0xc:\n    timerHandler->instance->DMA_interrupt_enable_register = timerHandler->instance->DMA_interrupt_enable_register & 0xffffffef;\n  }\n  disableTimerChannel(timerHandler->instance,channelNumber,0);\n  timerInstance = timerHandler->instance;\n  if (((timerInstance == DAT_0800638c) && ((timerInstance->capture_compare_enable_register & 0x1111) == 0)) && ((timerInstance->capture_compare_enable_register & 0x444) == 0))\n  {\n    timerInstance->break_and_dead_time_register = timerInstance->break_and_dead_time_register & 0xffff7fff;\n  }\n  timerInstance = timerHandler->instance;\n  if (((timerInstance->capture_compare_enable_register & 0x1111) == 0) && ((timerInstance->capture_compare_enable_register & 0x444) == 0)) {\n    timerInstance->control_register_1 = timerInstance->control_register_1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080062f4",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "disable_timer_channel_interrupt_080062f4"
        },
        "FUN_080073e8": {
            "renaming": {
                "FUN_080073e8": "wait_for_input_080073e8",
                "msg": "input_message",
                "val": "input_value"
            },
            "code": "\nvoid wait_for_input_080073e8(char *input_message,int input_value)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "_Error_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073e8",
            "calling": [
                "_Error_Handler",
                "SystemClock_Config",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "wait_for_input_080073e8"
        },
        "FUN_0800267c": {
            "renaming": {
                "this": "servo",
                "value": "new_value",
                "iVar1": "min_diff",
                "iVar2": "max_diff",
                "servoIndex": "index",
                "min": "min_value",
                "max": "max_value",
                "FUN_0800267c": "set_servo_value_0800267c"
            },
            "code": "\nvoid __servocall Servo::set_servo_value_0800267c(Servo *servo,int new_value)\n\n{\n  int min_diff;\n  int max_diff;\n  \n  if (servo->index < 0xc) {\n    min_diff = (0x88 - servo->min_value) * 4;\n    if ((min_diff - new_value == 0 || min_diff < new_value) &&\n       (max_diff = 600 - servo->max_value, min_diff = max_diff * 4,\n       new_value == min_diff || new_value + max_diff * -4 < 0 != SBORROW4(new_value,min_diff))) {\n      min_diff = new_value;\n    }\n    *(int *)(PTR_servos_080026ac + (uint)servo->index * 8 + 4) = min_diff;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800267c",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "set_servo_value_0800267c"
        },
        "FUN_0800376c": {
            "renaming": {
                "FUN_0800376c": "perform_adc_conversion_0800376c",
                "hadc": "ADC_handle",
                "Timeout": "timeout_ms",
                "HVar1": "status",
                "uVar2": "start_time_ms",
                "pAVar5": "ADC_instance",
                "uVar3": "current_time_ms",
                "iVar4": "sampling_time_cycles",
                "uVar6": "cpu_frequency_hz",
                "Conversion_Timeout_CPU_cycles": "conversion_timeout_cycles"
            },
            "code": "\nHAL_StatusTypeDef_conflict perform_ADC_conversion_0800376c(ADC_HandleTypeDef *ADC_handle,uint32_t timeout_ms)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t start_time_ms;\n  uint32_t current_time_ms;\n  int sampling_time_cycles;\n  ADC_TypeDef *ADC_instance;\n  uint cpu_frequency_hz;\n  uint32_t conversion_timeout_cycles;\n  \n  conversion_timeout_cycles = 0;\n  start_time_ms = HAL_GetTick();\n  ADC_instance = ADC_handle->Instance;\n  if ((ADC_instance->CR2 & 0x100) == 0) {\n    if (((ADC_instance->CR1 & 0x100) == 0) && ((ADC_instance->SQR1 & 0xf00000) == 0)) {\n      do {\n        if ((ADC_handle->Instance->SR & 2) != 0) goto LAB_0800387e;\n      } while ((timeout_ms == 0xffffffff) ||\n              ((timeout_ms != 0 && (current_time_ms = HAL_GetTick(), current_time_ms - start_time_ms <= timeout_ms))));\n      ADC_handle->State = ADC_handle->State | 4;\n      ADC_handle->Lock = HAL_UNLOCKED;\n      status = HAL_TIMEOUT;\n    }\n    else {\n      cpu_frequency_hz = *(uint *)PTR_SystemCoreClock_080038c8;\n      current_time_ms = HAL_RCCEx_GetPeriphCLKFreq(2);\n      ADC_instance = ADC_handle->Instance;\n      if (((ADC_instance->SMPR2 & DAT_080038cc) == 0) &&\n         ((ADC_instance->SMPR1 & DAT_080038cc + 0xdc000000) == 0)) {\n        if ((ADC_instance->SMPR2 & DAT_080038d0) == 0) {\n          if ((ADC_instance->SMPR1 & DAT_080038d4) == 0) {\n            sampling_time_cycles = 0x14;\n          }\n          else {\n            sampling_time_cycles = 0x29;\n          }\n        }\n        else {\n          sampling_time_cycles = 0x29;\n        }\n      }\n      else if (((ADC_instance->SMPR2 & DAT_080038d0) == 0) &&\n              ((ADC_instance->SMPR1 & DAT_080038d0 + 0xee000000) == 0)) {\n        sampling_time_cycles = 0x54;\n      }\n      else if ((DAT_080038d8 & ADC_instance->SMPR2) == 0) {\n        if ((DAT_080038d8 & ADC_instance->SMPR1) == 0) {\n          sampling_time_cycles = 0x54;\n        }\n        else {\n          sampling_time_cycles = 0xfc;\n        }\n      }\n      else {\n        sampling_time_cycles = 0xfc;\n      }\n      cpu_frequency_hz = (cpu_frequency_hz / current_time_ms) * sampling_time_cycles;\n      for (; conversion_timeout_cycles <= cpu_frequency_hz && cpu_frequency_hz - conversion_timeout_cycles != 0;\n          conversion_timeout_cycles = conversion_timeout_cycles + 1) {\n        if ((timeout_ms != 0xffffffff) &&\n           ((timeout_ms == 0 || (current_time_ms = HAL_GetTick(), timeout_ms < current_time_ms - start_time_ms)))) {\n          ADC_handle->State = ADC_handle->State | 4;\n          ADC_handle->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nLAB_0800387e:\n      ADC_handle->Instance->SR = 0xffffffed;\n      ADC_handle->State = ADC_handle->State | 0x200;\n      if ((ADC_handle->Instance->CR2 & 0xe0000) == 0xe0000) {\n        if ((ADC_handle->Init).ContinuousConvMode == 0) {\n          ADC_handle->State = ADC_handle->State & 0xfffffeff;\n          if ((ADC_handle->State & 0x1000) == 0) {\n            ADC_handle->State = ADC_handle->State | 1;\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        status = HAL_OK;\n      }\n    }\n  }\n  else {\n    ADC_handle->State = ADC_handle->State | 0x20;\n    ADC_handle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  return status;\n}\n\n",
            "called": [
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800376c",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "perform_adc_conversion_0800376c"
        },
        "FUN_08003e20": {
            "renaming": {
                "FUN_08003e20": "adc_conversion_sequence_08003e20",
                "hadc": "adc_handle",
                "HVar1": "status",
                "uVar2": "peripheral_clk_freq",
                "uVar3": "current_tick",
                "pAVar4": "adc_instance",
                "uVar5": "system_core_clk",
                "wait_loop_index": "loop_index"
            },
            "code": "\nHAL_StatusTypeDef_conflict adc_conversion_sequence_08003e20(ADC_HandleTypeDef *adc_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t peripheral_clk_freq;\n  uint32_t current_tick;\n  ADC_TypeDef *adc_instance;\n  uint system_core_clk;\n  uint32_t loop_index;\n  \n  if (adc_handle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  adc_handle->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(adc_handle);\n  if (status == HAL_OK) {\n    adc_handle->State = adc_handle->State & 0xffffeefd | 2;\n    system_core_clk = *(uint *)PTR_SystemCoreClock_08003f08;\n    peripheral_clk_freq = HAL_RCCEx_GetPeriphCLKFreq(2);\n    for (loop_index = system_core_clk / peripheral_clk_freq << 1; loop_index != 0;\n        loop_index = loop_index - 1) {\n    }\n    ADC_Enable(adc_handle);\n    adc_handle->Instance->CR2 = adc_handle->Instance->CR2 | 8;\n    peripheral_clk_freq = HAL_GetTick();\n    while (adc_instance = adc_handle->Instance, (adc_instance->CR2 & 8) != 0) {\n      current_tick = HAL_GetTick();\n      if (10 < current_tick - peripheral_clk_freq) {\n        adc_handle->State = adc_handle->State & 0xffffffed | 0x10;\n        adc_handle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adc_instance->CR2 = adc_instance->CR2 | 4;\n    peripheral_clk_freq = HAL_GetTick();\n    while ((adc_handle->Instance->CR2 & 4) != 0) {\n      current_tick = HAL_GetTick();\n      if (10 < current_tick - peripheral_clk_freq) {\n        adc_handle->State = adc_handle->State & 0xffffffed | 0x10;\n        adc_handle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adc_handle->State = adc_handle->State & 0xfffffffc | 1;\n  }\n  adc_handle->Lock = HAL_UNLOCKED;\n  return status;\n}\n\n",
            "called": [
                "HAL_GetTick",
                "ADC_ConversionStop_Disable",
                "ADC_Enable",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003e20",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "adc_conversion_sequence_08003e20"
        },
        "FUN_08002c14": {
            "renaming": {
                "this": "self",
                "address": "device_address",
                "quantity": "data_quantity",
                "uVar1": "result",
                "FUN_08002c14": "read_quantity_at_address_08002c14"
            },
            "code": "\nuint8_t __selfcall TwoWire::read_quantity_at_address_08002c14(TwoWire *self,uint8_t device_address,uint8_t data_quantity)\n\n{\n  uint8_t result;\n  \n  result = read_quantity_at_address_08002c14(self,device_address,data_quantity,'\\x01');\n  return result;\n}\n\n",
            "called": [
                "requestFrom"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c14",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "read_quantity_at_address_08002c14"
        },
        "FUN_08009084": {
            "renaming": {
                "this": "self",
                "super__Function_base": "base",
                "_M_manager": "manager",
                "_Manager_type": "manager_type",
                "_M_invoker": "invoker",
                "_Any_data": "data",
                "__throw_bad_function_call": "throw_bad_function_call",
                "void": "execute",
                "FUN_08009084": "execute_08009084"
            },
            "code": "\nexecute_08009084 __selfcall std::function<execute_08009084()>::operator__(function_execute_08009084___ *self)\n\n{\n  if ((self->base).manager != (manager_type)0x0) {\n    (*self->invoker)((data *)self);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  throw_bad_function_call();\n}\n\n",
            "called": [
                "__throw_bad_function_call"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009084",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "execute_08009084"
        },
        "FUN_08005840": {
            "renaming": {
                "FUN_08005840": "calculate_result_08005840",
                "abStack_18": "byte_array",
                "local_1c": "short_value",
                "uStack_14": "first_value",
                "uStack_10": "second_value",
                "uStack_c": "third_value",
                "uVar1": "result",
                "uVar2": "input_value"
            },
            "code": "\nuint calculate_result_08005840(void)\n\n{\n  uint result;\n  uint input_value;\n  undefined2 short_value;\n  byte byte_array [4];\n  undefined4 first_value;\n  undefined4 second_value;\n  undefined4 third_value;\n  \n  third_value = *(undefined4 *)(PTR__etext_0800589c + 8);\n  second_value = *(undefined4 *)(PTR__etext_0800589c + 4);\n  first_value = *(undefined4 *)PTR__etext_0800589c;\n  short_value = *(undefined2 *)(PTR__etext_0800589c + 0x10);\n  input_value = *(uint *)(DAT_080058a0 + 4);\n  result = DAT_080058a8;\n  if ((input_value & 0xc) == 8) {\n    if ((input_value & 0x10000) == 0) {\n      result = DAT_080058a4 * (uint)byte_array[(input_value << 10) >> 0x1c];\n    }\n    else {\n      result = (DAT_080058a8 * byte_array[(input_value << 10) >> 0x1c]) /\n              (uint)*(byte *)((int)&short_value - ((*(int *)(DAT_080058a0 + 4) << 0xe) >> 0x1f));\n    }\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005840",
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "calculate_result_08005840"
        },
        "FUN_08003306": {
            "renaming": {
                "this": "self",
                "command": "cmd",
                "newFunction": "callback",
                "context": "ctx",
                "currentReportDigitalCallback": "report_digital_cb",
                "currentReportDigitalCallbackContext": "report_digital_cb_ctx",
                "currentPinModeCallback": "pin_mode_cb",
                "currentPinModeCallbackContext": "pin_mode_cb_ctx",
                "currentPinValueCallback": "pin_value_cb",
                "currentPinValueCallbackContext": "pin_value_cb_ctx",
                "currentAnalogCallback": "analog_cb",
                "currentAnalogCallbackContext": "analog_cb_ctx",
                "currentDigitalCallback": "digital_cb",
                "currentDigitalCallbackContext": "digital_cb_ctx",
                "currentReportAnalogCallback": "report_analog_cb",
                "currentReportAnalogCallbackContext": "report_analog_cb_ctx",
                "FUN_08003306": "set_callback_08003306"
            },
            "code": "\nvoid __selfcall\nfirmata::FirmataParser::set_callback_08003306(FirmataParser *self,uint8_t cmd,callbackFunction callback,void *ctx)\n\n{\n  if (cmd == 0xd0) {\n    self->report_digital_cb = callback;\n    self->report_digital_cb_ctx = ctx;\n    return;\n  }\n  if (0xd0 < cmd) {\n    if (cmd == 0xf4) {\n      self->pin_mode_cb = callback;\n      self->pin_mode_cb_ctx = ctx;\n      return;\n    }\n    if (cmd == 0xf5) {\n      self->pin_value_cb = callback;\n      self->pin_value_cb_ctx = ctx;\n    }\n    else if (cmd == 0xe0) {\n      self->analog_cb = callback;\n      self->analog_cb_ctx = ctx;\n      return;\n    }\n    return;\n  }\n  if (cmd == 0x90) {\n    self->digital_cb = callback;\n    self->digital_cb_ctx = ctx;\n    return;\n  }\n  if (cmd == 0xc0) {\n    self->report_analog_cb = callback;\n    self->report_analog_cb_ctx = ctx;\n    return;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003306",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "set_callback_08003306"
        },
        "FUN_08002578": {
            "renaming": {
                "FUN_08002578": "deinitialize_timer_pulse_08002578",
                "obj": "timer_object"
            },
            "code": "\nvoid deinitialize_timer_pulse_08002578(stimer_t *timer_object)\n\n{\n  TimerPulseDeinit((stimer_t_conflict *)timer_object);\n  return;\n}\n\n",
            "called": [
                "TimerPulseDeinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002578",
            "calling": [
                "detach"
            ],
            "imported": false,
            "current_name": "deinitialize_timer_pulse_08002578"
        },
        "FUN_08006932": {
            "renaming": {
                "FUN_08006932": "reset_uart_08006932",
                "huart": "UART_handle",
                "Instance": "UART_instance",
                "CR1": "UART_control_register_1",
                "gState": "UART_global_state",
                "HAL_UART_TxCpltCallback": "UART_transmit_complete_callback",
                "HAL_StatusTypeDef_conflict": "UART_reset_status",
                "HAL_OK": "UART_HAL_OK"
            },
            "code": "\nUART_reset_status reset_UART_08006932(UART_HandleTypeDef *UART_handle)\n\n{\n  UART_handle->UART_instance->UART_control_register_1 = UART_handle->UART_instance->UART_control_register_1 & 0xffffffbf;\n  UART_handle->UART_global_state = HAL_UART_STATE_READY;\n  UART_transmit_complete_callback(UART_handle);\n  return UART_HAL_OK;\n}\n\n",
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006932",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "reset_uart_08006932"
        },
        "FUN_080060c4": {
            "renaming": {
                "FUN_080060c4": "configure_tim_oc_080060c4",
                "TIMx": "tim",
                "OC_Config": "oc_config",
                "uVar1": "ccer_mask",
                "uVar2": "cr2_mask",
                "uVar3": "oc_mode",
                "Pulse": "pulse_width",
                "CCER": "ccer_reg",
                "CR2": "cr2_reg",
                "CCMR1": "ccmr1_reg",
                "OCPolarity": "oc_polarity",
                "OCNPolarity": "ocn_polarity",
                "OCIdleState": "oc_idle_state",
                "OCNIdleState": "ocn_idle_state"
            },
            "code": "\nvoid configure_tim_oc_080060c4(TIM_TypeDef_conflict *tim,TIM_OC_InitTypeDef *oc_config)\n\n{\n  uint32_t ccer_mask;\n  uint32_t cr2_mask;\n  uint32_t oc_mode;\n  \n  tim->ccer_reg = tim->ccer_reg & 0xffffffef;\n  cr2_mask = tim->cr2_reg;\n  oc_mode = oc_config->OCMode;\n  ccer_mask = tim->ccer_reg & 0xffffffdf | oc_config->oc_polarity << 4;\n  if (tim == DAT_08006124) {\n    ccer_mask = (ccer_mask & 0xffffff7f | oc_config->ocn_polarity << 4) & 0xffffffbf;\n    cr2_mask = cr2_mask & 0xfffff3ff | oc_config->oc_idle_state << 2 | oc_config->ocn_idle_state << 2;\n  }\n  tim->cr2_reg = cr2_mask;\n  tim->ccmr1_reg = tim->ccmr1_reg & 0xffff8cff | oc_mode << 8;\n  tim->Ccr2_reg = oc_config->pulse_width;\n  tim->ccer_reg = ccer_mask;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080060c4",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_tim_oc_080060c4"
        },
        "FUN_08009eac": {
            "renaming": {
                "FUN_08009eac": "initialize_file_descriptor_08009eac",
                "param_1": "file_descriptor",
                "param_2": "file_descriptor_data",
                "uVar1": "status",
                "iVar2": "allocated_memory",
                "local_18": "buffer_size",
                "local_14": "buffer",
                "param_2[4]": "file_descriptor_memory_location",
                "param_2[5]": "file_descriptor_memory_size"
            },
            "code": "\nvoid initialize_file_descriptor_08009eac(int file_descriptor,int *file_descriptor_data)\n\n{\n  ushort status;\n  int allocated_memory;\n  int buffer_size;\n  int *buffer;\n  \n  if (-1 < (int)((uint)*(ushort *)(file_descriptor_data + 3) << 0x1e)) {\n    buffer_size = file_descriptor;\n    buffer = file_descriptor_data;\n    status = __swhatbuf_r(file_descriptor,file_descriptor_data,&buffer_size,&buffer);\n    allocated_memory = _malloc_r(file_descriptor,buffer_size);\n    if (allocated_memory != 0) {\n      *(undefined4 *)(file_descriptor + 0x28) = DAT_08009f28;\n      *file_descriptor_data = allocated_memory;\n      *(ushort *)(file_descriptor_data + 3) = *(ushort *)(file_descriptor_data + 3) | 0x80;\n      file_descriptor_memory_location = allocated_memory;\n      file_descriptor_memory_size = buffer_size;\n      if ((buffer != (int *)0x0) &&\n         (allocated_memory = _isatty_r(file_descriptor,(int)*(short *)((int)file_descriptor_data + 0xe)), allocated_memory != 0)) {\n        *(ushort *)(file_descriptor_data + 3) = *(ushort *)(file_descriptor_data + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(file_descriptor_data + 3) = status | *(ushort *)(file_descriptor_data + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(file_descriptor_data + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(file_descriptor_data + 3) = *(ushort *)(file_descriptor_data + 3) & 0xfffc | 2;\n  }\n  *file_descriptor_data = (int)file_descriptor_data + 0x47;\n  file_descriptor_memory_location = (int)file_descriptor_data + 0x47;\n  file_descriptor_memory_size = 1;\n  return;\n}\n\n",
            "called": [
                "_isatty_r",
                "__swhatbuf_r",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009eac",
            "calling": [
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "initialize_file_descriptor_08009eac"
        },
        "FUN_08008dbe": {
            "renaming": {
                "this": "ipAddressObj",
                "iVar4": "totalPrintedChars",
                "iVar3": "byteIndex",
                "sVar1": "charsPrinted",
                "sVar2": "dotPrinted",
                "FUN_08008dbe": "print_ip_address_08008dbe"
            },
            "code": "\nsize_t __ipAddressObjcall IPAddress::printIPAddress_08008dbe(IPAddress *ipAddressObj,Print *p)\n\n{\n  size_t charsPrinted;\n  size_t dotPrinted;\n  int byteIndex;\n  int totalPrintedChars;\n  \n  totalPrintedChars = 0;\n  for (byteIndex = 0; byteIndex < 3; byteIndex = byteIndex + 1) {\n    charsPrinted = Print::print(p,(ipAddressObj->_address).bytes[byteIndex],10);\n    dotPrinted = Print::print(p,'.');\n    totalPrintedChars = totalPrintedChars + charsPrinted + dotPrinted;\n  }\n  charsPrinted = Print::print(p,(ipAddressObj->_address).bytes[3],10);\n  return charsPrinted + totalPrintedChars;\n}\n\n",
            "called": [
                "print",
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008dbe",
            "calling": [],
            "imported": false,
            "current_name": "print_ip_address_08008dbe"
        },
        "FUN_080072d8": {
            "renaming": {
                "FUN_080072d8": "set_gpio_pin_state_080072d8",
                "port": "gpio_port",
                "pin": "gpio_pin",
                "val": "gpio_pin_state",
                "GPIO_PIN_RESET": "GPIO_PIN_LOW",
                "GPIO_PIN_SET": "GPIO_PIN_HIGH"
            },
            "code": "\nvoid set_gpio_pin_state_080072d8(GPIO_TypeDef *gpio_port,uint32_t gpio_pin,uint32_t gpio_pin_state)\n\n{\n  if (gpio_pin_state == 0) {\n    HAL_GPIO_WritePin(gpio_port,(uint16_t)gpio_pin,GPIO_PIN_LOW);\n    return;\n  }\n  HAL_GPIO_WritePin(gpio_port,(uint16_t)gpio_pin,GPIO_PIN_HIGH);\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072d8",
            "calling": [
                "digitalWrite"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_080072d8"
        },
        "FUN_08002b00": {
            "renaming": {
                "FUN_08002b00": "receive_data_08002b00",
                "inBytes": "input_data",
                "numBytes": "input_length",
                "allocateRxBuffer": "allocate_receive_buffer",
                "_Error_Handler": "handle_error",
                "memcpy": "copy_memory"
            },
            "code": "\nvoid TwoWire::receive_data_08002b00(uint8_t *input_data,int input_length)\n\n{\n  if ((*(int *)PTR_user_onReceive_08002b54 != 0) &&\n     ((byte)*PTR_rxBufferLength_08002b5c <= (byte)*PTR_rxBufferIndex_08002b58)) {\n    allocate_receive_buffer(input_length);\n    if (*(int *)PTR_rxBuffer_08002b60 == 0) {\n      handle_error(PTR_s__home_bo__arduino15_packages_STM_08002b64,0x183);\n    }\n    copy_memory(*(void **)PTR_rxBuffer_08002b60,input_data,input_length);\n    *PTR_rxBufferIndex_08002b58 = 0;\n    *PTR_rxBufferLength_08002b5c = (char)input_length;\n    (**(code **)PTR_user_onReceive_08002b54)(input_length);\n  }\n  return;\n}\n\n",
            "called": [
                "_Error_Handler",
                "memcpy",
                "allocateRxBuffer"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002b00",
            "calling": [],
            "imported": false,
            "current_name": "receive_data_08002b00"
        },
        "FUN_08002f84": {
            "renaming": {
                "FUN_08002f84": "set_system_callback_08002f84",
                "this": "firmata_instance",
                "command": "callback_command",
                "newFunction": "callback_function"
            },
            "code": "\nvoid __firmata_instancecall\nfirmata::FirmataClass::set_system_callback_08002f84(FirmataClass *firmata_instance,uint8_t callback_command,systemCallbackFunction callback_function)\n\n{\n  if (callback_command == 0xff) {\n    *(systemCallbackFunction *)PTR_currentSystemResetCallback_08002f90 = callback_function;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f84",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "set_system_callback_08002f84"
        },
        "FUN_08009094": {
            "renaming": {
                "FUN_08009094": "process_gpio_irq_08009094",
                "GPIO_Pin": "pin_number",
                "bVar1": "pin_id",
                "function_void___": "function_pointer"
            },
            "code": "\nvoid process_gpio_irq_08009094(uint16_t pin_number)\n\n{\n  byte pin_id;\n  \n  pin_id = get_pin_id(pin_number);\n  if (*(int *)(PTR_gpio_irq_conf_080090b0 + (uint)pin_id * 0x14 + 0xc) != 0) {\n    std::function<void()>::operator__\n              ((function_pointer *)(PTR_gpio_irq_conf_080090b0 + (uint)pin_id * 0x14 + 4));\n  }\n  return;\n}\n\n",
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009094",
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "imported": false,
            "current_name": "process_gpio_irq_08009094"
        },
        "FUN_0800a0cc": {
            "renaming": {
                "FUN_0800a0cc": "close_file_descriptor_0800a0cc",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "puVar1": "errno_ptr",
                "iVar2": "close_result"
            },
            "code": "\nvoid close_file_descriptor_0800a0cc(int *error_code,int file_descriptor)\n\n{\n  undefined *errno_ptr;\n  int close_result;\n  \n  errno_ptr = PTR_errno_0800a0e8;\n  *(undefined4 *)PTR_errno_0800a0e8 = 0;\n  close_result = _close(file_descriptor);\n  if ((close_result == -1) && (*(int *)errno_ptr != 0)) {\n    *error_code = *(int *)errno_ptr;\n  }\n  return;\n}\n\n",
            "called": [
                "_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0cc",
            "calling": [
                "__sclose"
            ],
            "imported": false,
            "current_name": "close_file_descriptor_0800a0cc"
        },
        "FUN_08002580": {
            "renaming": {
                "this": "servo",
                "bVar1": "servoCount",
                "FUN_08002580": "initialize_servo_08002580"
            },
            "code": "\ninitializeServo_08002580 * __servocall initializeServo_08002580::initializeServo_08002580(initializeServo_08002580 *servo)\n\n{\n  byte servoCount;\n  \n  servoCount = *PTR_initializeServo_08002580Count_080025a4;\n  if (0xb < servoCount) {\n    servo->servoIndex = 0xff;\n    return servo;\n  }\n  *PTR_initializeServo_08002580Count_080025a4 = servoCount + 1;\n  servo->servoIndex = servoCount;\n  *(undefined4 *)(PTR_servos_080025a8 + (uint)servoCount * 8 + 4) = 0x5dc;\n  return servo;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002580",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_servo_08002580"
        },
        "FUN_080073ec": {
            "renaming": {
                "FUN_080073ec": "set_flags_and_values_080073ec",
                "puVar1": "pointer_to_data",
                "puVar1[1]": "data_3",
                "puVar1[2]": "data_5"
            },
            "code": "\nvoid set_flags_and_values_080073ec(void)\n\n{\n  uint *pointer_to_data;\n  \n  pointer_to_data = DAT_0800742c;\n  *DAT_0800742c = *DAT_0800742c | 1;\n  data_3 = DAT_08007430 & data_3;\n  *pointer_to_data = *pointer_to_data & 0xfef6ffff;\n  *pointer_to_data = *pointer_to_data & 0xfffbffff;\n  data_3 = data_3 & 0xff80ffff;\n  data_5 = 0x9f0000;\n  *(undefined4 *)(DAT_08007434 + 8) = 0x8000000;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073ec",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "set_flags_and_values_080073ec"
        },
        "FUN_08008ef4": {
            "renaming": {
                "FUN_08008ef4": "map_range_08008ef4",
                "x": "value",
                "in_min": "in_lower_bound",
                "in_max": "in_upper_bound",
                "out_min": "out_lower_bound",
                "out_max": "out_upper_bound"
            },
            "code": "\nlong map_range_08008ef4(long value,long in_lower_bound,long in_upper_bound,long out_lower_bound,long out_upper_bound)\n\n{\n  return (uint)((out_upper_bound - out_lower_bound) * (value - in_lower_bound)) / (uint)(in_upper_bound - in_lower_bound) + out_lower_bound;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ef4",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "map_range_08008ef4"
        },
        "FUN_08009fe8": {
            "renaming": {
                "FUN_08009fe8": "signal_handler_08009fe8",
                "__sig": "signal_number",
                "iVar1": "handler_return_value"
            },
            "code": "\nint signal_handler_08009fe8(int signal_number)\n\n{\n  int handler_return_value;\n  \n  handler_return_value = _signal_handler_08009fe8_r(*(undefined4 *)PTR__impure_ptr_08009ff4,signal_number);\n  return handler_return_value;\n}\n\n",
            "called": [
                "_raise_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009fe8",
            "calling": [
                "abort"
            ],
            "imported": false,
            "current_name": "signal_handler_08009fe8"
        },
        "FUN_08002c1e": {
            "renaming": {
                "FUN_08002c1e": "initialize_static_vars_08002c1e",
                "__static_initialization_and_destruction_0": "init_and_destroy_static_vars"
            },
            "code": "\nvoid initialize_static_vars_08002c1e(void)\n\n{\n  init_and_destroy_static_vars(1,0xffff);\n  return;\n}\n\n",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c1e",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_vars_08002c1e"
        },
        "FUN_08002f94": {
            "renaming": {
                "FUN_08002f94": "set_sysex_callback_08002f94",
                "this": "firmata_instance",
                "command": "sysex_command",
                "newFunction": "callback_function"
            },
            "code": "\nvoid __firmata_instancecall\nfirmata::FirmataClass::set_sysex_callback_08002f94(FirmataClass *firmata_instance,uint8_t sysex_command,sysexCallbackFunction callback_function)\n\n{\n  *(sysexCallbackFunction *)PTR_currentSysexCallback_08002f9c = callback_function;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f94",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "set_sysex_callback_08002f94"
        },
        "FUN_08008eec": {
            "renaming": {
                "this": "self",
                "base": "conversion_base",
                "sVar1": "size_of_string",
                "FUN_08008eec": "print_with_base_conversion_08008eec"
            },
            "code": "\nsize_t __selfcall Print::print_with_base_conversion_08008eec(Print *self,uchar b,int conversion_base)\n\n{\n  size_t size_of_string;\n  \n  size_of_string = print_with_base_conversion_08008eec(self,(uint)b,conversion_base);\n  return size_of_string;\n}\n\n",
            "called": [
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008eec",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "print_with_base_conversion_08008eec"
        },
        "FUN_08001b48": {
            "renaming": {
                "FUN_08001b48": "initialize_firmata_08001b48",
                "this": "firmataInstance",
                "firmata::FirmataClass::setFirmwareNameAndVersion": "setFirmwareNameAndVersion",
                "FirmataClass": "Firmata",
                "firmata::FirmataClass::attach": "attach",
                "firmata::FirmataClass::begin": "begin",
                "systemResetCallback": "resetFirmata",
                "startForkserver": "startForkServer"
            },
            "code": "\nvoid initializeFirmata_08001b48(void)\n\n{\n  undefined *firmataInstance;\n  \n  firmataInstance = PTR_Firmata_08001bc0;\n  setFirmwareNameAndVersion\n            ((Firmata *)PTR_Firmata_08001bc0,PTR_s__home_bo_p2im_p2im_real_firmware_08001bc4,\n             '\\x02','\\x05');\n  attach((Firmata *)firmataInstance,0xe0,DAT_08001bc8);\n  attach((Firmata *)firmataInstance,0x90,DAT_08001bcc);\n  attach((Firmata *)firmataInstance,0xc0,DAT_08001bd0);\n  attach((Firmata *)firmataInstance,0xd0,DAT_08001bd4);\n  attach((Firmata *)firmataInstance,0xf4,DAT_08001bd8);\n  attach((Firmata *)firmataInstance,0xf5,DAT_08001bdc);\n  attach((Firmata *)firmataInstance,0xf0,DAT_08001be0);\n  attach((Firmata *)firmataInstance,0xff,DAT_08001be4);\n  begin((Firmata *)firmataInstance,0xe100);\n  resetFirmata();\n  startForkServer(0);\n  return;\n}\n\n",
            "called": [
                "begin",
                "startForkserver",
                "attach",
                "attach",
                "setFirmwareNameAndVersion",
                "attach",
                "systemResetCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001b48",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_firmata_08001b48"
        },
        "FUN_08005df4": {
            "renaming": {
                "FUN_08005df4": "deinit_timer_08005df4",
                "htim": "timer_handle",
                "HAL_TIM_STATE_BUSY": "TIM_BUSY",
                "TIM_TypeDef_conflict": "Timer_TypeDef",
                "pTVar1": "timer_instance",
                "CCER": "capture_compare_enable_register",
                "CR1": "control_register_1",
                "HAL_TIM_STATE_RESET": "TIM_RESET",
                "HAL_UNLOCKED": "TIM_UNLOCKED",
                "HAL_StatusTypeDef_conflict": "Timer_StatusTypeDef"
            },
            "code": "\nTimer_StatusTypeDef deinit_timer_08005df4(TIM_HandleTypeDef_conflict *timer_handle)\n\n{\n  Timer_TypeDef *timer_instance;\n  \n  timer_handle->State = TIM_BUSY;\n  timer_instance = timer_handle->Instance;\n  if (((timer_instance->capture_compare_enable_register & 0x1111) == 0) && ((timer_instance->capture_compare_enable_register & 0x444) == 0)) {\n    timer_instance->control_register_1 = timer_instance->control_register_1 & 0xfffffffe;\n  }\n  HAL_TIM_OC_MspDeInit(timer_handle);\n  timer_handle->State = TIM_RESET;\n  timer_handle->Lock = TIM_UNLOCKED;\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_TIM_OC_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005df4",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "deinit_timer_08005df4"
        },
        "FUN_08009148": {
            "renaming": {
                "FUN_08009148": "execute_preinit_and_global_dtors_08009148",
                "puVar1": "preinit_array_end_pointer",
                "iVar2": "preinit_array_size",
                "iVar3": "i",
                "_init": "execute_init"
            },
            "code": "\nvoid execute_preinit_and_global_dtors_08009148(void)\n\n{\n  undefined *preinit_array_end_pointer;\n  int preinit_array_size;\n  int i;\n  \n  preinit_array_end_pointer = PTR___preinit_array_end_08009180;\n  preinit_array_size = (int)PTR___preinit_array_end_08009184 - (int)PTR___preinit_array_end_08009180;\n  for (i = 0; i != preinit_array_size >> 2; i = i + 1) {\n    (**(code **)(preinit_array_end_pointer + i * 4))();\n  }\n  execute_init();\n  preinit_array_end_pointer = PTR___preinit_array_end_08009188;\n  preinit_array_size = (int)PTR___do_global_dtors_aux_fini_array_entry_0800918c -\n          (int)PTR___preinit_array_end_08009188;\n  for (i = 0; i != preinit_array_size >> 2; i = i + 1) {\n    (**(code **)(preinit_array_end_pointer + i * 4))();\n  }\n  return;\n}\n\n",
            "called": [
                "premain",
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009148",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "execute_preinit_and_global_dtors_08009148"
        },
        "FUN_080099dc": {
            "renaming": {
                "FUN_080099dc": "write_to_stream_080099dc",
                "param_1": "stream",
                "param_2": "char_to_write",
                "param_3": "stream_buffer",
                "param_4": "stream_mutex",
                "iVar1": "status",
                "uVar2": "ushort_value",
                "puVar3": "byte_pointer"
            },
            "code": "\nuint write_to_stream_080099dc(int stream,uint char_to_write,int *stream_buffer,undefined4 stream_mutex)\n\n{\n  int status;\n  uint ushort_value;\n  undefined *byte_pointer;\n  \n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_buffer == (int *)PTR___sf_fake_stdin_08009a74) {\n    stream_buffer = *(int **)(stream + 4);\n  }\n  else if (stream_buffer == (int *)PTR___sf_fake_stdout_08009a78) {\n    stream_buffer = *(int **)(stream + 8);\n  }\n  else if (stream_buffer == (int *)PTR___sf_fake_stderr_08009a7c) {\n    stream_buffer = *(int **)(stream + 0xc);\n  }\n  stream_buffer[2] = stream_buffer[6];\n  ushort_value = (uint)*(ushort *)(stream_buffer + 3);\n  status = ushort_value << 0x1c;\n  if (((status < 0) && (ushort_value = stream_buffer[4], ushort_value != 0)) ||\n     (status = __swsetup_r(stream,stream_buffer,status,ushort_value,stream_mutex), status == 0)) {\n    char_to_write = char_to_write & 0xff;\n    status = *stream_buffer - stream_buffer[4];\n    if ((status < stream_buffer[5]) || (status = _fflush_r(stream,stream_buffer), status == 0)) {\n      stream_buffer[2] = stream_buffer[2] + -1;\n      byte_pointer = (undefined *)*stream_buffer;\n      *stream_buffer = (int)(byte_pointer + 1);\n      *byte_pointer = (char)char_to_write;\n      if (status + 1 != stream_buffer[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream_buffer + 3) << 0x1f)) {\n          return char_to_write;\n        }\n        if (char_to_write != 10) {\n          return char_to_write;\n        }\n      }\n      status = _fflush_r(stream,stream_buffer);\n      if (status == 0) {\n        return char_to_write;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080099dc",
            "calling": [
                "__sfputc_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_080099dc"
        },
        "FUN_08000c18": {
            "renaming": {
                "FUN_08000c18": "report_pin_values_08000c18",
                "port": "port_number",
                "value": "pin_value",
                "bVar1": "port_config_input",
                "bVar2": "is_valid_pin",
                "uVar3": "digital_pin_number",
                "iVar4": "digital_pin_value",
                "uVar5": "pin_index",
                "uVar6": "port_index",
                "portValue": "port_value"
            },
            "code": "\nvoid report_pin_values_08000c18(byte port_number,int pin_value)\n\n{\n  byte port_config_input;\n  bool is_valid_pin;\n  uint32_t digital_pin_number;\n  int digital_pin_value;\n  uint pin_index;\n  uint port_index;\n  byte port_value;\n  \n  port_index = (uint)port_number;\n  if ((port_index < 5) && (PTR_report_numberPINs_08000ebc[port_index] = (char)pin_value, pin_value != 0)) {\n    port_config_input = PTR_port_numberConfigInputs_08000ec0[port_index];\n    port_index = (port_index & 0x1f) * 8;\n    if (port_index < 0x3c) {\n      if (PTR_digitalPin_08000ec4[port_index] == NC) {\n        port_value = 0;\n      }\n      else {\n        digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[port_index]);\n        if (digital_pin_number == 0) {\n          port_value = 0;\n        }\n        else {\n          digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[port_index]);\n          if (digital_pin_number == 1) {\n            port_value = 0;\n          }\n          else if ((port_config_input & 1) == 0) {\n            port_value = 0;\n          }\n          else {\n            digital_pin_value = digitalRead(port_index);\n            if (digital_pin_value == 0) {\n              port_value = 0;\n            }\n            else {\n              port_value = 1;\n            }\n          }\n        }\n      }\n    }\n    else {\n      port_value = 0;\n    }\n    pin_index = port_index + 1;\n    if (pin_index < 0x3c) {\n      if (PTR_digitalPin_08000ec4[pin_index] == NC) {\n        is_valid_pin = false;\n      }\n      else {\n        digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[pin_index]);\n        if (digital_pin_number == 0) {\n          is_valid_pin = false;\n        }\n        else {\n          digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[pin_index]);\n          if (digital_pin_number == 1) {\n            is_valid_pin = false;\n          }\n          else if ((port_config_input & 2) == 0) {\n            is_valid_pin = false;\n          }\n          else {\n            digital_pin_value = digitalRead(pin_index);\n            if (digital_pin_value == 0) {\n              is_valid_pin = false;\n            }\n            else {\n              is_valid_pin = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      is_valid_pin = false;\n    }\n    if (is_valid_pin) {\n      port_value = port_value | 2;\n    }\n    pin_index = port_index + 2;\n    if (pin_index < 0x3c) {\n      if (PTR_digitalPin_08000ec4[pin_index] == NC) {\n        is_valid_pin = false;\n      }\n      else {\n        digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[pin_index]);\n        if (digital_pin_number == 0) {\n          is_valid_pin = false;\n        }\n        else {\n          digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[pin_index]);\n          if (digital_pin_number == 1) {\n            is_valid_pin = false;\n          }\n          else if ((port_config_input & 4) == 0) {\n            is_valid_pin = false;\n          }\n          else {\n            digital_pin_value = digitalRead(pin_index);\n            if (digital_pin_value == 0) {\n              is_valid_pin = false;\n            }\n            else {\n              is_valid_pin = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      is_valid_pin = false;\n    }\n    if (is_valid_pin) {\n      port_value = port_value | 4;\n    }\n    pin_index = port_index + 3;\n    if (pin_index < 0x3c) {\n      if (PTR_digitalPin_08000ec4[pin_index] == NC) {\n        is_valid_pin = false;\n      }\n      else {\n        digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[pin_index]);\n        if (digital_pin_number == 0) {\n          is_valid_pin = false;\n        }\n        else {\n          digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[pin_index]);\n          if (digital_pin_number == 1) {\n            is_valid_pin = false;\n          }\n          else if ((port_config_input & 8) == 0) {\n            is_valid_pin = false;\n          }\n          else {\n            digital_pin_value = digitalRead(pin_index);\n            if (digital_pin_value == 0) {\n              is_valid_pin = false;\n            }\n            else {\n              is_valid_pin = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      is_valid_pin = false;\n    }\n    if (is_valid_pin) {\n      port_value = port_value | 8;\n    }\n    pin_index = port_index + 4;\n    if (pin_index < 0x3c) {\n      if (PTR_digitalPin_08000ec4[pin_index] == NC) {\n        is_valid_pin = false;\n      }\n      else {\n        digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[pin_index]);\n        if (digital_pin_number == 0) {\n          is_valid_pin = false;\n        }\n        else {\n          digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[pin_index]);\n          if (digital_pin_number == 1) {\n            is_valid_pin = false;\n          }\n          else if ((port_config_input & 0x10) == 0) {\n            is_valid_pin = false;\n          }\n          else {\n            digital_pin_value = digitalRead(pin_index);\n            if (digital_pin_value == 0) {\n              is_valid_pin = false;\n            }\n            else {\n              is_valid_pin = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      is_valid_pin = false;\n    }\n    if (is_valid_pin) {\n      port_value = port_value | 0x10;\n    }\n    pin_index = port_index + 5;\n    if (pin_index < 0x3c) {\n      if (PTR_digitalPin_08000ec4[pin_index] == NC) {\n        is_valid_pin = false;\n      }\n      else {\n        digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[pin_index]);\n        if (digital_pin_number == 0) {\n          is_valid_pin = false;\n        }\n        else {\n          digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[pin_index]);\n          if (digital_pin_number == 1) {\n            is_valid_pin = false;\n          }\n          else if ((port_config_input & 0x20) == 0) {\n            is_valid_pin = false;\n          }\n          else {\n            digital_pin_value = digitalRead(pin_index);\n            if (digital_pin_value == 0) {\n              is_valid_pin = false;\n            }\n            else {\n              is_valid_pin = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      is_valid_pin = false;\n    }\n    if (is_valid_pin) {\n      port_value = port_value | 0x20;\n    }\n    pin_index = port_index + 6;\n    if (pin_index < 0x3c) {\n      if (PTR_digitalPin_08000ec4[pin_index] == NC) {\n        is_valid_pin = false;\n      }\n      else {\n        digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[pin_index]);\n        if (digital_pin_number == 0) {\n          is_valid_pin = false;\n        }\n        else {\n          digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[pin_index]);\n          if (digital_pin_number == 1) {\n            is_valid_pin = false;\n          }\n          else if ((port_config_input & 0x40) == 0) {\n            is_valid_pin = false;\n          }\n          else {\n            digital_pin_value = digitalRead(pin_index);\n            if (digital_pin_value == 0) {\n              is_valid_pin = false;\n            }\n            else {\n              is_valid_pin = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      is_valid_pin = false;\n    }\n    if (is_valid_pin) {\n      port_value = port_value | 0x40;\n    }\n    port_index = port_index + 7;\n    if (port_index < 0x3c) {\n      if (PTR_digitalPin_08000ec4[port_index] == NC) {\n        is_valid_pin = false;\n      }\n      else {\n        digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[port_index]);\n        if (digital_pin_number == 0) {\n          is_valid_pin = false;\n        }\n        else {\n          digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_08000ec4[port_index]);\n          if (digital_pin_number == 1) {\n            is_valid_pin = false;\n          }\n          else if ((port_config_input & 0x80) == 0) {\n            is_valid_pin = false;\n          }\n          else {\n            digital_pin_value = digitalRead(port_index);\n            if (digital_pin_value == 0) {\n              is_valid_pin = false;\n            }\n            else {\n              is_valid_pin = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      is_valid_pin = false;\n    }\n    if (is_valid_pin) {\n      port_value = port_value | 0x80;\n    }\n    outputPort(port_number,port_value,'\\x01');\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "digitalRead",
                "pinNametoDigitalPin",
                "outputPort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c18",
            "calling": [],
            "imported": false,
            "current_name": "report_pin_values_08000c18"
        },
        "FUN_08009024": {
            "renaming": {
                "FUN_08009024": "handle_gpio_exti_interrupt_08009024"
            },
            "code": "\nvoid handle_gpio_exti_interrupt_08009024(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009024",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_interrupt_08009024"
        },
        "FUN_080064cc": {
            "renaming": {
                "FUN_080064cc": "send_uart_data_080064cc",
                "huart": "uart_handle",
                "HAL_UART_STATE_BUSY_TX": "UART_BUSY_TX",
                "HAL_BUSY": "UART_BUSY",
                "pbVar2": "byte_to_send",
                "uVar1": "updated_tx_count",
                "HAL_OK": "UART_OK"
            },
            "code": "\nHAL_StatusTypeDef_conflict send_uart_data_080064cc(UART_HandleTypeDef *uart_handle)\n\n{\n  uint16_t updated_tx_count;\n  byte *byte_to_send;\n  \n  if (uart_handle->gState != UART_BUSY_TX) {\n    return UART_BUSY;\n  }\n  if ((uart_handle->Init).WordLength == 0x1000) {\n    uart_handle->Instance->DR = *(ushort *)uart_handle->pTxBuffPtr & 0x1ff;\n    if ((uart_handle->Init).Parity == 0) {\n      uart_handle->pTxBuffPtr = uart_handle->pTxBuffPtr + 2;\n    }\n    else {\n      uart_handle->pTxBuffPtr = uart_handle->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    byte_to_send = uart_handle->pTxBuffPtr;\n    uart_handle->pTxBuffPtr = byte_to_send + 1;\n    uart_handle->Instance->DR = (uint)*byte_to_send;\n  }\n  updated_tx_count = uart_handle->TxXferCount - 1;\n  uart_handle->TxXferCount = updated_tx_count;\n  if (updated_tx_count == 0) {\n    uart_handle->Instance->CR1 = uart_handle->Instance->CR1 & 0xffffff7f;\n    uart_handle->Instance->CR1 = uart_handle->Instance->CR1 | 0x40;\n    return UART_OK;\n  }\n  return UART_OK;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064cc",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "send_uart_data_080064cc"
        },
        "FUN_08008058": {
            "renaming": {
                "FUN_08008058": "handle_i2c_event_08008058"
            },
            "code": "\nvoid handle_i2c_event_08008058(void)\n\n{\n  HAL_I2C_EV_IRQHandler(*(I2C_HandleTypeDef_conflict **)(PTR_i2c_handles_08008064 + 4));\n  return;\n}\n\n",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008058",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_event_08008058"
        },
        "FUN_08004ac2": {
            "renaming": {
                "FUN_08004ac2": "i2c_address_match_callback_08004ac2",
                "hi2c": "i2c_handle",
                "AddrMatchCode": "address_match_code",
                "Instance": "instance",
                "SR2": "sr2",
                "Init": "init",
                "OwnAddress1": "own_address_1",
                "OwnAddress2": "own_address_2",
                "HAL_StatusTypeDef_conflict": "hal_status_type_def"
            },
            "code": "\nhal_status_type_def i2c_address_match_callback_08004ac2(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  uint16_t address_match_code;\n  \n  if ((i2c_handle->instance->sr2 & 0x80) == 0) {\n    address_match_code = *(uint16_t *)&(i2c_handle->init).own_address_1;\n  }\n  else {\n    address_match_code = *(uint16_t *)&(i2c_handle->init).own_address_2;\n  }\n  HAL_I2C_AddrCallback(i2c_handle,(i2c_handle->instance->sr2 & 4) == 0,address_match_code);\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ac2",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_address_match_callback_08004ac2"
        },
        "FUN_08006ca8": {
            "renaming": {
                "FUN_08006ca8": "initialize_adc_gpio_pin_08006ca8",
                "hadc": "ADC_Handle",
                "puVar1": "current_pin",
                "GPIOx": "GPIO_Port",
                "tmpreg": "temporary_register",
                "tmpreg_1": "temporary_register_1",
                "GPIO_InitStruct": "GPIO_Init_Configuration"
            },
            "code": "\nvoid initialize_ADC_GPIO_Pin_08006ca8(ADC_HandleTypeDef *ADC_Handle)\n\n{\n  undefined *current_pin;\n  GPIO_TypeDef *GPIO_Port;\n  uint32_t temporary_register;\n  uint32_t temporary_register_1;\n  GPIO_InitTypeDef GPIO_Init_Configuration;\n  \n  if (ADC_Handle->Instance == DAT_08006d14) {\n    *(uint *)(DAT_08006d20 + 0x18) = *(uint *)(DAT_08006d20 + 0x18) | 0x200;\n  }\n  else if (ADC_Handle->Instance == DAT_08006d18) {\n    *(uint *)(DAT_08006d20 + 0x18) = *(uint *)(DAT_08006d20 + 0x18) | 0x400;\n  }\n  current_pin = PTR_g_current_pin_08006d1c;\n  GPIO_Port = set_GPIO_Port_Clock((uint)((int)(char)*PTR_g_current_pin_08006d1c << 0x18) >> 0x1c);\n  GPIO_Init_Configuration.Pin = 1 << (*current_pin & 0xf) & 0xffff;\n  GPIO_Init_Configuration.Mode = 3;\n  GPIO_Init_Configuration.Pull = 0;\n  HAL_GPIO_Init(GPIO_Port,&GPIO_Init_Configuration);\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ca8",
            "calling": [
                "HAL_ADC_Init"
            ],
            "imported": false,
            "current_name": "initialize_adc_gpio_pin_08006ca8"
        },
        "FUN_0800937c": {
            "renaming": {
                "FUN_0800937c": "print_formatted_output_0800937c",
                "param_1": "file_descriptor",
                "param_2": "stream",
                "param_3": "format",
                "param_4": "args",
                "bVar1": "is_digit",
                "puVar2": "char_set",
                "iVar3": "chars_written",
                "pvVar4": "char_ptr",
                "piVar5": "int_ptr",
                "pbVar6": "format_ptr",
                "pbVar7": "current_char_ptr",
                "unaff_r9": "temp_int",
                "iVar8": "temp_int_2",
                "local_8c": "args_ptr",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "width",
                "local_7c": "num_arg",
                "local_74": "total_chars_written",
                "local_70": "conversion_specifier",
                "local_6f": "space_char",
                "local_6e": "plus_char",
                "local_45": "sign_char",
                "local_30": "zero_char"
            },
            "code": "\nint print_formatted_output_0800937c(int file_descriptor,undefined *stream,byte *format,int *args)\n\n{\n  bool is_digit;\n  undefined *char_set;\n  int chars_written;\n  void *char_ptr;\n  int *int_ptr;\n  byte *format_ptr;\n  byte *current_char_ptr;\n  int temp_int;\n  int temp_int_2;\n  int *args_ptr;\n  uint flags;\n  int precision;\n  undefined4 width;\n  int num_arg;\n  int total_chars_written;\n  byte conversion_specifier;\n  undefined space_char;\n  undefined plus_char;\n  undefined sign_char;\n  undefined4 zero_char;\n  \n  args_ptr = args;\n  if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == PTR___sf_fake_stdin_08009588) {\n    stream = *(undefined **)(file_descriptor + 4);\n  }\n  else if (stream == PTR___sf_fake_stdout_08009590) {\n    stream = *(undefined **)(file_descriptor + 8);\n  }\n  else if (stream == PTR___sf_fake_stderr_08009594) {\n    stream = *(undefined **)(file_descriptor + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(stream + 0xc) << 0x1c)) || (*(int *)(stream + 0x10) == 0)) &&\n     (temp_int_2 = __swsetup_r(file_descriptor,stream), temp_int_2 != 0)) {\n    return -1;\n  }\n  total_chars_written = 0;\n  space_char = 0x20;\n  plus_char = 0x30;\n  format_ptr = format;\nLAB_080093be:\n  current_char_ptr = format_ptr;\n  if (*current_char_ptr != 0) goto LAB_08009474;\n  goto LAB_080093c8;\nLAB_08009474:\n  format_ptr = current_char_ptr + 1;\n  if (*current_char_ptr != 0x25) goto LAB_080093be;\nLAB_080093c8:\n  temp_int_2 = (int)current_char_ptr - (int)format;\n  if (temp_int_2 != 0) {\n    chars_written = __sfputs_r(file_descriptor,stream,format,temp_int_2);\n    if (chars_written == -1) {\nLAB_08009568:\n      if ((int)((uint)*(ushort *)(stream + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return total_chars_written;\n    }\n    total_chars_written = total_chars_written + temp_int_2;\n  }\n  if (*current_char_ptr == 0) goto LAB_08009568;\n  flags = 0;\n  num_arg = 0;\n  precision = -1;\n  width = 0;\n  sign_char = 0;\n  zero_char = 0;\n  format_ptr = current_char_ptr + 1;\n  while( true ) {\n    char_ptr = memchr(PTR_s___0__0800958c,(uint)*format_ptr,5);\n    char_set = PTR_DAT_08009598;\n    format = format_ptr + 1;\n    if (char_ptr == (void *)0x0) break;\n    flags = 1 << ((int)char_ptr - (int)PTR_s___0__0800958c & 0xffU) | flags;\n    format_ptr = format;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    sign_char = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    sign_char = 0x2b;\n  }\n  if (*format_ptr == 0x2a) {\n    int_ptr = args_ptr + 1;\n    temp_int_2 = *args_ptr;\n    args_ptr = int_ptr;\n    if (-1 < temp_int_2) goto LAB_08009498;\n    num_arg = -temp_int_2;\n    flags = flags | 2;\n  }\n  else {\n    is_digit = false;\n    temp_int_2 = num_arg;\n    format = format_ptr;\n    while( true ) {\n      if (9 < *format - 0x30) break;\n      temp_int_2 = temp_int_2 * 10 + (*format - 0x30);\n      is_digit = true;\n      format = format + 1;\n    }\n    if (is_digit) {\nLAB_08009498:\n      num_arg = temp_int_2;\n    }\n  }\n  if (*format == 0x2e) {\n    if (format[1] == 0x2a) {\n      format = format + 2;\n      int_ptr = args_ptr + 1;\n      precision = *args_ptr;\n      args_ptr = int_ptr;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      is_digit = false;\n      temp_int_2 = 0;\n      precision = 0;\n      while( true ) {\n        format = format + 1;\n        if (9 < *format - 0x30) break;\n        temp_int_2 = temp_int_2 * 10 + (*format - 0x30);\n        is_digit = true;\n      }\n      if (is_digit) {\n        precision = temp_int_2;\n      }\n    }\n  }\n  char_ptr = memchr(PTR_DAT_08009598,(uint)*format,3);\n  if (char_ptr != (void *)0x0) {\n    format = format + 1;\n    flags = flags | 0x40 << ((int)char_ptr - (int)char_set & 0xffU);\n  }\n  conversion_specifier = *format;\n  format = format + 1;\n  char_ptr = memchr(PTR_s_efgEFG_0800959c,(uint)conversion_specifier,6);\n  if (char_ptr == (void *)0x0) {\n    temp_int_2 = _printf_i(file_descriptor,&flags,stream,DAT_080095a4,&args_ptr);\n  }\n  else {\n    temp_int_2 = file_descriptor;\n    if (DAT_080095a0 == 0) {\n      args_ptr = (int *)(((int)args_ptr + 7U & 0xfffffff8) + 8);\n      temp_int_2 = temp_int;\n      goto LAB_0800951a;\n    }\n  }\n  if (temp_int_2 == -1) goto LAB_08009568;\nLAB_0800951a:\n  total_chars_written = total_chars_written + temp_int_2;\n  format_ptr = format;\n  temp_int = temp_int_2;\n  goto LAB_080093be;\n}\n\n",
            "called": [
                "memchr",
                "__sfputs_r",
                "__swsetup_r",
                "_printf_i",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800937c",
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "imported": false,
            "current_name": "print_formatted_output_0800937c"
        },
        "FUN_08000214": {
            "renaming": {
                "FUN_08000214": "analog_or_servo_write_08000214",
                "pin": "pin_number",
                "value": "output_value",
                "bVar1": "is_servo_pin",
                "bVar2": "pin_mode",
                "_Var3": "is_pwm_pin",
                "ulPin": "unsigned_pin_number",
                "uVar4": "digital_pin_number"
            },
            "code": "\nvoid analog_or_servo_write_08000214(byte pin_number,int output_value)\n\n{\n  bool is_servo_pin;\n  byte pin_mode;\n  _Bool is_pwm_pin;\n  uint unsigned_pin_number;\n  uint32_t digital_pin_number;\n  \n  unsigned_pin_number = (uint)pin_number;\n  if (0x3b < unsigned_pin_number) {\n    return;\n  }\n  pin_mode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_080002d8,pin_number);\n  if (pin_mode == '\\x03') {\n    if (unsigned_pin_number < 0x3c) {\n      if (PTR_digitalPin_080002dc[unsigned_pin_number] == NC) {\n        is_pwm_pin = false;\n      }\n      else {\n        digital_pin_number = pin_numberNametoDigitalPin(PTR_digitalPin_080002dc[unsigned_pin_number]);\n        if (digital_pin_number == 0) {\n          is_pwm_pin = false;\n        }\n        else {\n          digital_pin_number = pin_numberNametoDigitalPin(PTR_digitalPin_080002dc[unsigned_pin_number]);\n          if (digital_pin_number == 1) {\n            is_pwm_pin = false;\n          }\n          else {\n            is_pwm_pin = pin_number_in_pin_numbermap(PTR_digitalPin_080002dc[unsigned_pin_number],\n                                  (PinMap_conflict *)PTR_PinMap_PWM_080002e8);\n          }\n        }\n      }\n    }\n    else {\n      is_pwm_pin = false;\n    }\n    if (is_pwm_pin != false) {\n      analogWrite(unsigned_pin_number,output_value);\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_080002d8,pin_number,output_value);\n  }\n  else if (pin_mode == '\\x04') {\n    if (unsigned_pin_number < 0x3c) {\n      if (PTR_digitalPin_080002dc[unsigned_pin_number] == NC) {\n        is_servo_pin = false;\n      }\n      else {\n        digital_pin_number = pin_numberNametoDigitalPin(PTR_digitalPin_080002dc[unsigned_pin_number]);\n        if (digital_pin_number == 0) {\n          is_servo_pin = false;\n        }\n        else {\n          digital_pin_number = pin_numberNametoDigitalPin(PTR_digitalPin_080002dc[unsigned_pin_number]);\n          if (digital_pin_number == 1) {\n            is_servo_pin = false;\n          }\n          else {\n            is_servo_pin = true;\n          }\n        }\n      }\n    }\n    else {\n      is_servo_pin = false;\n    }\n    if (is_servo_pin) {\n      Servo::write((Servo *)(PTR_servos_080002e4 + (uint)(byte)PTR_servoPinMap_080002e0[unsigned_pin_number] * 3),\n                   output_value);\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_080002d8,pin_number,output_value);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "setPinState",
                "analogWrite",
                "getPinMode",
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000214",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "analog_or_servo_write_08000214"
        },
        "FUN_08003724": {
            "renaming": {
                "FUN_08003724": "initialize_system_08003724",
                "HAL_StatusTypeDef_conflict": "system_initialization_status",
                "HAL_NVIC_SetPriorityGrouping": "set_interrupt_priority_grouping",
                "HAL_MspInit": "initialize_system_peripheral",
                "HAL_OK": "system_initialization_successful"
            },
            "code": "\nsystem_initialization_status initialize_system_08003724(void)\n\n{\n  *DAT_08003744 = *DAT_08003744 | 0x10;\n  set_interrupt_priority_grouping(3);\n  initialize_system_08003724Tick(0xf);\n  initialize_system_08003724_peripheral();\n  return system_initialization_successful;\n}\n\n",
            "called": [
                "HAL_InitTick",
                "HAL_MspInit",
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003724",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "initialize_system_08003724"
        },
        "FUN_08005bb8": {
            "renaming": {
                "FUN_08005bb8": "calculate_clock_frequency_08005bb8",
                "PeriphClk": "peripheral_clock",
                "uVar1": "clock_frequency",
                "uVar2": "temp_variable",
                "aPredivFactorTable": "pre_divider_factor_table",
                "aPLLMULFactorTable": "pll_multiplier_factor_table"
            },
            "code": "\nuint32_t calculate_clock_frequency_08005bb8(uint32_t peripheral_clock)\n\n{\n  uint32_t clock_frequency;\n  uint temp_variable;\n  uint8_t pre_divider_factor_table [2];\n  uint8_t pll_multiplier_factor_table [16];\n  \n  pll_multiplier_factor_table._12_4_ = *(undefined4 *)(PTR_DAT_08005ca0 + 8);\n  pll_multiplier_factor_table._8_4_ = *(undefined4 *)(PTR_DAT_08005ca0 + 4);\n  pll_multiplier_factor_table._4_4_ = *(undefined4 *)PTR_DAT_08005ca0;\n  pre_divider_factor_table = *(uint8_t (*) [2])(PTR_DAT_08005ca0 + 0x10);\n  if (peripheral_clock == 2) {\n    clock_frequency = HAL_RCC_GetPCLK2Freq();\n    clock_frequency = clock_frequency / ((((DAT_08005ca4[1] << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (peripheral_clock == 0x10) {\n    if ((*DAT_08005ca4 & 0x1000000) == 0) {\n      clock_frequency = 0;\n    }\n    else {\n      temp_variable = DAT_08005cb0;\n      if ((DAT_08005ca4[1] & 0x10000) != 0) {\n        temp_variable = DAT_08005ca8 / pre_divider_factor_table[-((int)(DAT_08005ca4[1] << 0xe) >> 0x1f)];\n      }\n      clock_frequency = temp_variable * pll_multiplier_factor_table[(DAT_08005ca4[1] << 10) >> 0x1c];\n      if ((DAT_08005ca4[1] & 0x400000) == 0) {\n        clock_frequency = (uint32_t)((ulonglong)DAT_08005cac * (ulonglong)(clock_frequency * 2) >> 0x21);\n      }\n    }\n  }\n  else if (peripheral_clock == 1) {\n    if ((DAT_08005ca4[8] & 0x302) == 0x102) {\n      clock_frequency = 0x8000;\n    }\n    else {\n      temp_variable = DAT_08005ca4[8] & 0x300;\n      if ((temp_variable == 0x200) && ((DAT_08005ca4[9] & 2) != 0)) {\n        clock_frequency = 32000;\n      }\n      else if (temp_variable == 0x300) {\n        if ((*DAT_08005ca4 & 0x20000) == 0) {\n          clock_frequency = 0;\n        }\n        else {\n          clock_frequency = 0xf424;\n        }\n      }\n      else {\n        clock_frequency = 0;\n      }\n    }\n  }\n  else {\n    clock_frequency = 0;\n  }\n  return clock_frequency;\n}\n\n",
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bb8",
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_PollForConversion"
            ],
            "imported": false,
            "current_name": "calculate_clock_frequency_08005bb8"
        },
        "FUN_08002f0a": {
            "renaming": {
                "command": "messageType",
                "bytec": "messageLength",
                "FUN_08002f0a": "send_firmata_message_08002f0a"
            },
            "code": "\nvoid __thiscall\nfirmata::FirmataClass::sendFirmataMessage_08002f0a(FirmataClass *this,byte messageType,byte messageLength,byte *bytev)\n\n{\n  FirmataMarshaller::sendFirmataMessage_08002f0a(&this->marshaller,messageType,(uint)messageLength,bytev);\n  return;\n}\n\n",
            "called": [
                "sendSysex"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f0a",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "send_firmata_message_08002f0a"
        },
        "FUN_08002634": {
            "renaming": {
                "this": "servo_instance",
                "pin": "servo_pin",
                "uVar1": "servo_position",
                "FUN_08002634": "set_servo_position_08002634"
            },
            "code": "\nuint8_t __servo_instancecall Servo::set_servo_position_08002634(Servo *servo_instance,int servo_pin)\n\n{\n  uint8_t servo_position;\n  \n  servo_position = set_servo_position_08002634(servo_instance,servo_pin,0x220,0x960);\n  return servo_position;\n}\n\n",
            "called": [
                "attach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002634",
            "calling": [
                "attachServo"
            ],
            "imported": false,
            "current_name": "set_servo_position_08002634"
        },
        "FUN_080063c0": {
            "renaming": {
                "FUN_080063c0": "disable_timer_channel_080063c0",
                "htim": "timerHandle",
                "Channel": "channelNumber",
                "pTVar1": "timerInstance",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "HAL_TIM_STATE_READY": "TIM_READY"
            },
            "code": "\nHAL_StatusTypeDef disableTimerChannel_080063c0(TIM_HandleTypeDef *timerHandle,uint32_t channelNumber)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxchannelNumberCmd(timerHandle->Instance,channelNumber,0);\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance == DAT_0800641c) && ((timerInstance->CCER & 0x1111) == 0)) && ((timerInstance->CCER & 0x444) == 0))\n  {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  timerHandle->State = TIM_READY;\n  return HAL_OK;\n}\n\n",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080063c0",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "disable_timer_channel_080063c0"
        },
        "FUN_0800274c": {
            "renaming": {
                "this": "wire",
                "FUN_0800274c": "read_next_byte_from_buffer_0800274c"
            },
            "code": "\nint __wirecall TwoWire::readNextByteFromBuffer_0800274c(TwoWire *wire)\n\n{\n  if ((uint)(byte)*PTR_rxBufferIndex_08002768 < (uint)(byte)*PTR_rxBufferLength_0800276c) {\n    return (uint)*(byte *)(*(int *)PTR_rxBuffer_08002770 + (uint)(byte)*PTR_rxBufferIndex_08002768);\n  }\n  return -1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800274c",
            "calling": [],
            "imported": false,
            "current_name": "read_next_byte_from_buffer_0800274c"
        },
        "FUN_080098d8": {
            "renaming": {
                "FUN_080098d8": "format_and_print_080098d8",
                "__format": "format_string",
                "iVar1": "impure_ptr_value",
                "pcVar2": "format_string_ptr",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3"
            },
            "code": "\nint format_and_print_080098d8(char *format_string,...)\n\n{\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  int impure_ptr_value;\n  char *format_string_ptr;\n  undefined4 arg1;\n  undefined4 arg2;\n  undefined4 arg3;\n  \n  impure_ptr_value = *(int *)PTR__impure_ptr_08009904;\n  format_string_ptr = format_string;\n  arg1 = in_r1;\n  arg2 = in_r2;\n  arg3 = in_r3;\n  if ((impure_ptr_value != 0) && (*(int *)(impure_ptr_value + 0x18) == 0)) {\n    __sinit(impure_ptr_value);\n  }\n  impure_ptr_value = _vfformat_and_print_080098d8_r(impure_ptr_value,*(undefined4 *)(impure_ptr_value + 8),format_string,&arg1,format_string_ptr,&arg1);\n  return impure_ptr_value;\n}\n\n",
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080098d8",
            "calling": [
                "getTimerClkFreq",
                "getTimerIrq",
                "getTimerClkSrc",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "format_and_print_080098d8"
        },
        "FUN_08009270": {
            "renaming": {
                "FUN_08009270": "allocate_memory_08009270",
                "param_1": "error_code",
                "param_2": "size",
                "puVar1": "break_start",
                "uVar2": "result",
                "puVar3": "free_list",
                "iVar4": "difference",
                "puVar5": "current_block",
                "uVar6": "block_size",
                "puVar7": "previous_block",
                "uVar8": "requested_size"
            },
            "code": "\nuint allocate_memory_08009270(undefined4 *error_code,uint size)\n\n{\n  undefined *break_start;\n  undefined4 result;\n  uint *free_list;\n  int difference;\n  uint *current_block;\n  uint block_size;\n  uint *previous_block;\n  uint requested_size;\n  \n  requested_size = (size + 3 & 0xfffffffc) + 8;\n  if (requested_size < 0xc) {\n    requested_size = 0xc;\n  }\n  if (((int)requested_size < 0) || (requested_size < size)) {\n    *error_code = 0xc;\n  }\n  else {\n    __malloc_lock();\n    break_start = PTR___malloc_sbrk_start_08009328;\n    free_list = *(uint **)PTR___malloc_free_list_08009324;\n    previous_block = *(uint **)PTR___malloc_free_list_08009324;\n    while (current_block = free_list, current_block != (uint *)0x0) {\n      block_size = *current_block - requested_size;\n      if (-1 < (int)block_size) {\n        if (block_size < 0xc) {\n          if (previous_block == current_block) {\n            requested_size = previous_block[1];\n            *(uint *)PTR___malloc_free_list_08009324 = requested_size;\n          }\n          else {\n            requested_size = current_block[1];\n          }\n          if (previous_block != current_block) {\n            previous_block[1] = requested_size;\n            previous_block = current_block;\n          }\n        }\n        else {\n          *current_block = block_size;\n          *(uint *)((int)current_block + block_size) = requested_size;\n          previous_block = (uint *)((int)current_block + block_size);\n        }\n        goto LAB_080092d4;\n      }\n      previous_block = current_block;\n      free_list = (uint *)current_block[1];\n    }\n    if (*(int *)PTR___malloc_sbrk_start_08009328 == 0) {\n      result = _sbrk_r(error_code);\n      *(undefined4 *)break_start = result;\n    }\n    free_list = (uint *)_sbrk_r(error_code,requested_size);\n    if ((free_list != (uint *)0xffffffff) &&\n       ((previous_block = (uint *)((int)free_list + 3U & 0xfffffffc), free_list == previous_block ||\n        (difference = _sbrk_r(error_code,(int)previous_block - (int)free_list), difference != -1)))) {\n      *previous_block = requested_size;\nLAB_080092d4:\n      __malloc_unlock(error_code);\n      requested_size = (int)previous_block + 0xbU & 0xfffffff8;\n      difference = requested_size - (int)(previous_block + 1);\n      if (difference != 0) {\n        *(int *)((int)previous_block + difference) = -difference;\n        return requested_size;\n      }\n      return requested_size;\n    }\n    *error_code = 0xc;\n    __malloc_unlock(error_code);\n  }\n  return 0;\n}\n\n",
            "called": [
                "__malloc_lock",
                "_sbrk_r",
                "__malloc_unlock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009270",
            "calling": [
                "__smakebuf_r",
                "malloc",
                "_realloc_r",
                "__sfmoreglue"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009270"
        },
        "FUN_08009038": {
            "renaming": {
                "FUN_08009038": "handle_gpio_exti_interrupt_08009038"
            },
            "code": "\nvoid handle_GPIO_EXTI_Interrupt_08009038(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(4);\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009038",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_interrupt_08009038"
        },
        "FUN_08005aa4": {
            "renaming": {
                "FUN_08005aa4": "configure_rcc_clocks_08005aa4",
                "PeriphClkInit": "peripheral_clock_init",
                "iVar1": "temp_var_1",
                "puVar2": "temp_var_2",
                "uVar3": "tick_start",
                "uVar4": "tick_end",
                "uVar5": "rtc_clock_selection",
                "bVar6": "flag",
                "tmpreg": "temporary_register",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_TIMEOUT": "HAL_ERROR_TIMEOUT",
                "PeriphClockSelection": "peripheral_clock_selection",
                "RTCClockSelection": "rtc_clock_selection",
                "AdcClockSelection": "adc_clock_selection",
                "UsbClockSelection": "usb_clock_selection"
            },
            "code": "\nHAL_StatusTypeDef\nconfigure_RCC_clocks_08005aa4(RCC_PeriphCLKInitTypeDef_conflict *peripheral_clock_init)\n\n{\n  int temp_var_1;\n  undefined4 *temp_var_2;\n  uint32_t tick_start;\n  uint32_t tick_end;\n  uint rtc_clock_selection;\n  bool flag;\n  uint32_t temporary_register;\n  \n  if ((peripheral_clock_init->peripheral_clock_selection & 1) != 0) {\n    flag = (*(uint *)(DAT_08005bac + 0x1c) & 0x10000000) == 0;\n    if (flag) {\n      *(uint *)(DAT_08005bac + 0x1c) = *(uint *)(DAT_08005bac + 0x1c) | 0x10000000;\n    }\n    if ((*DAT_08005bb0 & 0x100) == 0) {\n      *DAT_08005bb0 = *DAT_08005bb0 | 0x100;\n      tick_start = HAL_GetTick();\n      while ((*DAT_08005bb0 & 0x100) == 0) {\n        tick_end = HAL_GetTick();\n        if (100 < tick_end - tick_start) {\n          return HAL_ERROR_TIMEOUT;\n        }\n      }\n    }\n    temp_var_2 = DAT_08005bb4;\n    temp_var_1 = DAT_08005bac;\n    rtc_clock_selection = *(uint *)(DAT_08005bac + 0x20) & 0x300;\n    if ((rtc_clock_selection != 0) && (rtc_clock_selection != (peripheral_clock_init->rtc_clock_selection & 0x300))) {\n      rtc_clock_selection = *(uint *)(DAT_08005bac + 0x20);\n      *DAT_08005bb4 = 1;\n      *temp_var_2 = 0;\n      *(uint *)(temp_var_1 + 0x20) = rtc_clock_selection & 0xfffffcff;\n      if ((rtc_clock_selection & 1) != 0) {\n        tick_start = HAL_GetTick();\n        while ((*(uint *)(DAT_08005bac + 0x20) & 2) == 0) {\n          tick_end = HAL_GetTick();\n          if (5000 < tick_end - tick_start) {\n            return HAL_ERROR_TIMEOUT;\n          }\n        }\n      }\n    }\n    temp_var_1 = DAT_08005bac;\n    *(uint *)(DAT_08005bac + 0x20) =\n         *(uint *)(DAT_08005bac + 0x20) & 0xfffffcff | peripheral_clock_init->rtc_clock_selection;\n    if (flag) {\n      *(uint *)(temp_var_1 + 0x1c) = *(uint *)(temp_var_1 + 0x1c) & 0xefffffff;\n    }\n  }\n  if ((peripheral_clock_init->peripheral_clock_selection & 2) != 0) {\n    *(uint *)(DAT_08005bac + 4) =\n         *(uint *)(DAT_08005bac + 4) & 0xffff3fff | peripheral_clock_init->adc_clock_selection;\n  }\n  if ((peripheral_clock_init->peripheral_clock_selection & 0x10) != 0) {\n    *(uint *)(DAT_08005bac + 4) =\n         *(uint *)(DAT_08005bac + 4) & 0xffbfffff | peripheral_clock_init->usb_clock_selection;\n  }\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005aa4",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configure_rcc_clocks_08005aa4"
        },
        "FUN_08008068": {
            "renaming": {
                "FUN_08008068": "handle_i2c_error_interrupt_08008068",
                "HAL_I2C_ER_IRQHandler": "handle_i2c_error",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef"
            },
            "code": "\nvoid handle_i2c_error_interrupt_08008068(void)\n\n{\n  handle_i2c_error(*(I2C_HandleTypeDef **)(PTR_i2c_handles_08008074 + 4));\n  return;\n}\n\n",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008068",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_error_interrupt_08008068"
        },
        "FUN_08002400": {
            "renaming": {
                "FUN_08002400": "has_servo_reached_target_08002400",
                "timer": "servo_timer",
                "uVar1": "counter"
            },
            "code": "\nboolean has_servo_reached_target_08002400(servo_timer16_Sequence_t servo_timer)\n\n{\n  uint counter;\n  \n  counter = 0;\n  while( true ) {\n    if (0xb < counter) {\n      return false;\n    }\n    if ((PTR_servos_08002428[((uint)servo_timer * 0xc + counter) * 8] & 0x40) != 0) break;\n    counter = counter + 1 & 0xff;\n  }\n  return true;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002400",
            "calling": [
                "attach",
                "detach"
            ],
            "imported": false,
            "current_name": "has_servo_reached_target_08002400"
        },
        "FUN_08000588": {
            "renaming": {
                "FUN_08000588": "detach_servo_08000588",
                "pin": "servo_pin",
                "cVar1": "count1",
                "cVar2": "count2",
                "puVar3": "servo_pin_map",
                "Servo::detach": "detach"
            },
            "code": "\nvoid detach_servo_08000588(byte servo_pin)\n\n{\n  char count1;\n  char count2;\n  undefined *servo_pin_map;\n  \n  servo_pin_map = PTR_servoPinMap_080005cc;\n  detach((Servo *)(PTR_servos_080005d0 + (uint)(byte)PTR_servoPinMap_080005cc[servo_pin] * 3));\n  count2 = servo_pin_map[servo_pin];\n  count1 = *PTR_servoCount_080005d4;\n  if ((count2 == count1) && (count1 != '\\0')) {\n    *PTR_servoCount_080005d4 = count1 + -1;\n  }\n  else if (count1 != '\\0') {\n    count1 = *PTR_detachedServoCount_080005d8;\n    *PTR_detachedServoCount_080005d8 = count1 + 1U;\n    PTR_detachedServos_080005dc[(byte)(count1 + 1U) - 1] = count2;\n  }\n  PTR_servoPinMap_080005cc[servo_pin] = 0xff;\n  return;\n}\n\n",
            "called": [
                "detach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000588",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "detach_servo_08000588"
        },
        "FUN_08002644": {
            "renaming": {
                "this": "servo",
                "uVar2": "servoIndex",
                "bVar1": "isTimerActive",
                "timer16_Sequence_t": "timerSequence",
                "finISR": "stopTimer",
                "FUN_08002644": "update_servo_08002644"
            },
            "code": "\nvoid __servocall Servo::updateServo_08002644(Servo *servo)\n\n{\n  boolean isTimerActive;\n  uint servoIndex;\n  \n  servoIndex = (uint)servo->servoIndex;\n  PTR_servos_08002670[servoIndex * 8] = PTR_servos_08002670[servoIndex * 8] & 0xbf;\n  isTimerActive = isTimerActive((timerSequence)\n                        (uint)((ulonglong)DAT_08002674 * (ulonglong)servoIndex >> 0x23));\n  if (!isTimerActive) {\n    stopTimer((stimer_t *)PTR__timer_08002678);\n  }\n  return;\n}\n\n",
            "called": [
                "isTimerActive",
                "finISR"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002644",
            "calling": [
                "detachServo"
            ],
            "imported": false,
            "current_name": "update_servo_08002644"
        },
        "FUN_08002f1e": {
            "renaming": {
                "FUN_08002f1e": "print_byte_08002f1e",
                "this": "firmata_object",
                "FirmataStream": "firmata_stream",
                "_vptr_Print": "print_function"
            },
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08002f28 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __firmata_objectcall firmata::FirmataClass::print_byte_08002f1e(FirmataClass *firmata_object,byte c)\n\n{\n  (**(firmata_object->firmata_stream->super_Print).print_function)(firmata_object->firmata_stream,(uint)c);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f1e",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "print_byte_08002f1e"
        },
        "FUN_0800902e": {
            "renaming": {
                "FUN_0800902e": "handle_gpio_exti_irq_2_0800902e"
            },
            "code": "\nvoid handle_GPIO_EXTI_IRQ_2_0800902e(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(2);\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800902e",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_irq_2_0800902e"
        },
        "FUN_08009042": {
            "renaming": {
                "FUN_08009042": "handle_ext_interrupt_08009042",
                "HAL_GPIO_EXTI_IRQHandler": "trigger_gpio_interrupt"
            },
            "code": "\nvoid handle_ext_interrupt_08009042(void)\n\n{\n  trigger_gpio_interrupt(8);\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009042",
            "calling": [],
            "imported": false,
            "current_name": "handle_ext_interrupt_08009042"
        },
        "FUN_08009c7c": {
            "renaming": {
                "FUN_08009c7c": "check_flush_08009c7c",
                "param_1": "stream",
                "param_2": "file",
                "uVar1": "result"
            },
            "code": "\nundefined4 check_flush_08009c7c(int stream,undefined *file,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 result;\n  \n  if (*(int *)(file + 0x10) != 0) {\n    if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n      __sinit();\n    }\n    if (file == PTR___sf_fake_stdin_08009cc4) {\n      file = *(undefined **)(stream + 4);\n    }\n    else if (file == PTR___sf_fake_stdout_08009cc8) {\n      file = *(undefined **)(stream + 8);\n    }\n    else if (file == PTR___sf_fake_stderr_08009ccc) {\n      file = *(undefined **)(stream + 0xc);\n    }\n    if (*(short *)(file + 0xc) != 0) {\n      result = __sflush_r(stream,file,param_3,param_4);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "__sinit",
                "__sflush_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009c7c",
            "calling": [
                "__swbuf_r"
            ],
            "imported": false,
            "current_name": "check_flush_08009c7c"
        },
        "FUN_08009b5c": {
            "renaming": {
                "FUN_08009b5c": "raise_signal_and_exit_08009b5c"
            },
            "code": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid raise_signal_and_exit_08009b5c(void)\n\n{\n  raise(6);\n                    /* WARNING: Subroutine does not return */\n  _exit(1);\n}\n\n",
            "called": [
                "_exit",
                "raise"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009b5c",
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "imported": false,
            "current_name": "raise_signal_and_exit_08009b5c"
        },
        "FUN_08008a6c": {
            "renaming": {
                "FUN_08008a6c": "read_digital_pin_08008a6c",
                "ulPin": "pin_number",
                "_Var1": "is_pin_configured",
                "port": "gpio_port",
                "uVar2": "io_read_result",
                "uVar3": "pin_index",
                "PinName_conflict": "pin_name",
                "get_GPIO_Port": "get_gpio_port",
                "digital_io_read": "read_digital_io"
            },
            "code": "\nint read_digital_pin_08008a6c(uint32_t pin_number)\n\n{\n  _Bool is_pin_configured;\n  GPIO_TypeDef *gpio_port;\n  uint32_t io_read_result;\n  uint pin_index;\n  \n  if (pin_number < 0x3c) {\n    pin_index = (uint)(char)PTR_digitalPin_08008ab4[pin_number];\n  }\n  else {\n    pin_index = 0xffffffff;\n  }\n  if (pin_index == 0xffffffff) {\n    pin_index = 0;\n  }\n  else {\n    is_pin_configured = is_pin_configured((pin_name)pin_index,(uint32_t *)PTR_g_digPinConfigured_08008ab8);\n    if (is_pin_configured) {\n      gpio_port = get_gpio_port((pin_index << 0x18) >> 0x1c);\n      io_read_result = read_digital_io(gpio_port,1 << (pin_index & 0xf) & 0xffff);\n      pin_index = io_read_result & 0xff;\n    }\n    else {\n      pin_index = 0;\n    }\n  }\n  if (pin_index != 0) {\n    pin_index = 1;\n  }\n  return pin_index;\n}\n\n",
            "called": [
                "digital_io_read",
                "get_GPIO_Port",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a6c",
            "calling": [
                "checkDigitalInputs",
                "reportDigitalCallback"
            ],
            "imported": false,
            "current_name": "read_digital_pin_08008a6c"
        },
        "FUN_080085b8": {
            "renaming": {
                "FUN_080085b8": "is_uart_transmitting_080085b8",
                "obj": "serial_obj",
                "HVar1": "uart_state"
            },
            "code": "\nuint8_t is_uart_transmitting_080085b8(serial_t *serial_obj)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(*(UART_HandleTypeDef **)\n                             (PTR_uart_handlers_080085d8 + (uint)serial_obj->index * 4));\n  return (uart_state & 0x22U) == 0x22;\n}\n\n",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085b8",
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "imported": false,
            "current_name": "is_uart_transmitting_080085b8"
        },
        "FUN_08001c08": {
            "renaming": {
                "FUN_08001c08": "read_from_wire_08001c08",
                "in_r1": "address",
                "in_r2": "buffer",
                "in_r3": "length",
                "sVar1": "result"
            },
            "code": "\nbyte read_from_wire_08001c08(void)\n\n{\n  ssize_t result;\n  int address;\n  void *buffer;\n  size_t length;\n  \n  result = TwoWire::read((TwoWire *)PTR_Wire_08001c14,address,buffer,length);\n  return (byte)result;\n}\n\n",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c08",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "read_from_wire_08001c08"
        },
        "FUN_080075dc": {
            "renaming": {
                "FUN_080075dc": "get_timer_frequency_080075dc",
                "tim": "timer",
                "uVar1": "APB2_clk_div",
                "uVar2": "timer_clk_src",
                "uVar3": "timer_freq",
                "uVar4": "APB1_clk_div",
                "pFLatency": "latency",
                "clkconfig": "clock_config"
            },
            "code": "\nuint32_t get_timer_frequency_080075dc(TIM_TypeDef_conflict *timer)\n\n{\n  uint32_t APB2_clk_div;\n  uint8_t timer_clk_src;\n  uint32_t timer_freq;\n  uint32_t APB1_clk_div;\n  uint32_t latency;\n  RCC_ClkInitTypeDef_conflict clock_config;\n  \n  clock_config.ClockType = 0;\n  clock_config.SYSCLKSource = 0;\n  clock_config.AHBCLKDivider = 0;\n  clock_config.APB1CLKDivider = 0;\n  clock_config.APB2CLKDivider = 0;\n  latency = 0;\n  HAL_RCC_GetClockConfig(&clock_config,&latency);\n  timer_clk_src = getTimerClkSrc(timer);\n  APB2_clk_div = clock_config.APB2CLKDivider;\n  APB1_clk_div = clock_config.APB1CLKDivider;\n  if (timer_clk_src == '\\x01') {\n    timer_freq = HAL_RCC_GetPCLK1Freq();\n  }\n  else if (timer_clk_src == '\\x02') {\n    timer_freq = HAL_RCC_GetPCLK2Freq();\n    APB1_clk_div = APB2_clk_div;\n  }\n  else {\n    iprintf(PTR_s_TIM__Unknown_clock_source_08007644);\n    timer_freq = 0;\n    APB1_clk_div = 0;\n  }\n  if (APB1_clk_div != 0x500) {\n    if (APB1_clk_div < 0x501) {\n      if (APB1_clk_div != 0x400) {\n        return timer_freq;\n      }\n    }\n    else if ((APB1_clk_div != 0x600) && (APB1_clk_div != 0x700)) {\n      return timer_freq;\n    }\n  }\n  return timer_freq << 1;\n}\n\n",
            "called": [
                "HAL_RCC_GetClockConfig",
                "HAL_RCC_GetPCLK1Freq",
                "getTimerClkSrc",
                "iprintf",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080075dc",
            "calling": [
                "pwm_start",
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "get_timer_frequency_080075dc"
        },
        "FUN_080087ec": {
            "renaming": {
                "FUN_080087ec": "handle_usart3_interrupt_080087ec",
                "USART3_IRQn": "USART3_interrupt",
                "UART_HandleTypeDef": "UART_handler",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt"
            },
            "code": "\nvoid handle_USART3_interrupt_080087ec(void)\n\n{\n  clear_pending_interrupt(USART3_interrupt);\n  if (*(UART_handler **)(PTR_uart_handlers_08008800 + 8) != (UART_handler *)0x0) {\n    handle_UART_interrupt(*(UART_handler **)(PTR_uart_handlers_08008800 + 8));\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087ec",
            "calling": [],
            "imported": false,
            "current_name": "handle_usart3_interrupt_080087ec"
        },
        "FUN_08007ff0": {
            "renaming": {
                "FUN_08007ff0": "enable_i2c_slave_mode_08007ff0",
                "hi2c": "i2c_handle",
                "piVar1": "i2c_obj",
                "uVar2": "remaining_buffer_size",
                "i2c_onSlaveReceive": "on_slave_receive_callback",
                "slaveMode": "is_slave_mode_enabled",
                "handle": "i2c_handle_struct",
                "XferSize": "transfer_size",
                "i2cTxRxBuffer": "i2c_buffer",
                "HAL_I2C_EnableListen_IT": "enable_i2c_listen_interrupt"
            },
            "code": "\nvoid enable_i2c_slave_mode_08007ff0(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  i2c_t_conflict *i2c_obj;\n  uint remaining_buffer_size;\n  \n  i2c_obj = get_i2c_obj(i2c_handle);\n  if (((i2c_obj->on_slave_receive_callback != (_func_void_uint8_t_ptr_int *)0x0) &&\n      (i2c_obj->is_slave_mode_enabled == '\\x01')) &&\n     (remaining_buffer_size = 0x20 - *(byte *)&(i2c_obj->i2c_handle_struct).transfer_size & 0xff, remaining_buffer_size != 0)) {\n    (*i2c_obj->on_slave_receive_callback)(i2c_obj->i2c_buffer,remaining_buffer_size);\n  }\n  enable_i2c_listen_interrupt(i2c_handle);\n  return;\n}\n\n",
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ff0",
            "calling": [
                "I2C_Slave_AF",
                "I2C_ITError",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "enable_i2c_slave_mode_08007ff0"
        },
        "FUN_08008078": {
            "renaming": {
                "FUN_08008078": "initialize_serial_port_08008078",
                "obj": "serial_object",
                "pUVar1": "usart_1",
                "pUVar2": "usart_2",
                "pUVar3": "usart_3",
                "pUVar4": "usart_peripheral",
                "pGVar5": "gpio_peripheral",
                "uVar6": "pin_function",
                "tmpreg": "temp_reg_1",
                "tmpreg_1": "temp_reg_2",
                "tmpreg_2": "temp_reg_3",
                "tmpreg_3": "temp_reg_4",
                "GPIO_InitStruct": "gpio_init_structure"
            },
            "code": "\nvoid initialize_serial_port_08008078(serial_t *serial_object)\n\n{\n  USART_TypeDef *usart_1;\n  USART_TypeDef *usart_2;\n  USART_TypeDef *usart_3;\n  void *a;\n  void *b;\n  USART_TypeDef *usart_peripheral;\n  GPIO_TypeDef *gpio_peripheral;\n  uint32_t pin_function;\n  uint32_t temp_reg_1;\n  uint32_t temp_reg_2;\n  uint32_t temp_reg_3;\n  uint32_t temp_reg_4;\n  GPIO_InitTypeDef gpio_init_structure;\n  \n  if (serial_object != (serial_t *)0x0) {\n    a = pinmap_peripheral(serial_object->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08008330);\n    b = pinmap_peripheral(serial_object->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08008334);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_UART_pin_has_08008348);\n    }\n    else {\n      usart_peripheral = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      serial_object->uart = usart_peripheral;\n      usart_3 = DAT_08008340;\n      usart_2 = DAT_0800833c;\n      usart_1 = DAT_08008338;\n      if (usart_peripheral == (USART_TypeDef *)0x0) {\n        iprintf(PTR_s_ERROR__U_S_ART_pins_mismatch_0800834c);\n      }\n      else {\n        if (usart_peripheral == DAT_08008338) {\n          DAT_08008338[0x7b7].BRR = DAT_08008338[0x7b7].BRR | 0x4000;\n          usart_1[0x7b7].BRR = usart_1[0x7b7].BRR & 0xffffbfff;\n          usart_1[0x7b7].CR3 = usart_1[0x7b7].CR3 | 0x4000;\n          serial_object->index = '\\0';\n          serial_object->irq = USART1_IRQn;\n        }\n        else if (usart_peripheral == DAT_0800833c) {\n          DAT_0800833c[0x106e].BRR = DAT_0800833c[0x106e].BRR | 0x20000;\n          usart_2[0x106e].BRR = usart_2[0x106e].BRR & 0xfffdffff;\n          usart_2[0x106e].CR3 = usart_2[0x106e].CR3 | 0x20000;\n          serial_object->index = '\\x01';\n          serial_object->irq = USART2_IRQn;\n        }\n        else if (usart_peripheral == DAT_08008340) {\n          DAT_08008340[0x1049].CR3 = DAT_08008340[0x1049].CR3 | 0x40000;\n          usart_3[0x1049].CR3 = usart_3[0x1049].CR3 & 0xfffbffff;\n          usart_3[0x104a].DR = usart_3[0x104a].DR | 0x40000;\n          serial_object->index = '\\x02';\n          serial_object->irq = USART3_IRQn;\n        }\n        gpio_peripheral = set_GPIO_Port_Clock((uint)((int)serial_object->pin_rx << 0x18) >> 0x1c);\n        pin_function = pinmap_function(serial_object->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08008334);\n        gpio_init_structure.Pin = 1 << (serial_object->pin_rx & 0xfU) & 0xffff;\n        gpio_init_structure.Mode = (pin_function >> 3 & 1) << 4 | pin_function & 7;\n        gpio_init_structure.Pull = (pin_function << 0x1a) >> 0x1e;\n        *(uint *)(DAT_08008344 + 0x18) = *(uint *)(DAT_08008344 + 0x18) | 1;\n        switch((pin_function << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x4000000;\n        }\n        gpio_init_structure.Speed = 3;\n        HAL_GPIO_Init(gpio_peripheral,&gpio_init_structure);\n        gpio_peripheral = set_GPIO_Port_Clock((uint)((int)serial_object->pin_tx << 0x18) >> 0x1c);\n        pin_function = pinmap_function(serial_object->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08008330);\n        gpio_init_structure.Pin = 1 << (serial_object->pin_tx & 0xfU) & 0xffff;\n        gpio_init_structure.Mode = (pin_function >> 3 & 1) << 4 | pin_function & 7;\n        gpio_init_structure.Pull = (pin_function << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(gpio_peripheral,&gpio_init_structure);\n        *(UART_HandleTypeDef **)(PTR_uart_handlers_08008354 + (uint)serial_object->index * 4) = &serial_object->handle;\n        (serial_object->handle).Instance = serial_object->uart;\n        (serial_object->handle).Init.BaudRate = serial_object->baudrate;\n        (serial_object->handle).Init.WordLength = serial_object->databits;\n        (serial_object->handle).Init.StopBits = serial_object->stopbits;\n        (serial_object->handle).Init.Parity = serial_object->parity;\n        (serial_object->handle).Init.Mode = 0xc;\n        (serial_object->handle).Init.HwFlowCtl = 0;\n        (serial_object->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&serial_object->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init",
                "pinmap_function",
                "pinmap_merge_peripheral",
                "pinmap_peripheral",
                "HAL_UART_Init",
                "set_GPIO_Port_Clock",
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008078",
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "imported": false,
            "current_name": "initialize_serial_port_08008078"
        },
        "FUN_08002774": {
            "renaming": {
                "FUN_08002774": "execute_user_on_request_function_08002774",
                "pcVar1": "user_onRequest_function_pointer"
            },
            "code": "\nvoid TwoWire::execute_user_onRequest_function_08002774(void)\n\n{\n  code *user_onRequest_function_pointer;\n  \n  user_onRequest_function_pointer = *(code **)PTR_user_onRequest_0800278c;\n  if (user_onRequest_function_pointer != (code *)0x0) {\n    *PTR_txBufferIndex_08002790 = 0;\n    *PTR_txBufferLength_08002794 = 0;\n    (*user_onRequest_function_pointer)();\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002774",
            "calling": [],
            "imported": false,
            "current_name": "execute_user_on_request_function_08002774"
        },
        "FUN_080052f0": {
            "renaming": {
                "FUN_080052f0": "handle_i2c_errors_080052f0",
                "hi2c": "i2c_handle",
                "HVar1": "i2c_state",
                "pIVar2": "i2c_instance",
                "uVar3": "sr1_reg",
                "uVar4": "cr2_reg"
            },
            "code": "\nvoid handle_i2c_errors_080052f0(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  HAL_I2C_StateTypeDef_conflict i2c_state;\n  I2C_TypeDef_conflict *i2c_instance;\n  uint sr1_reg;\n  uint cr2_reg;\n  \n  i2c_instance = i2c_handle->Instance;\n  sr1_reg = i2c_instance->SR1;\n  cr2_reg = i2c_instance->CR2;\n  if (((sr1_reg & DAT_080053c8) != 0) && ((cr2_reg & 0x100) != 0)) {\n    i2c_handle->ErrorCode = i2c_handle->ErrorCode | 1;\n    i2c_instance->SR1 = 0xfffffeff;\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x8000;\n  }\n  if (((sr1_reg & 0x10200) != 0) && ((cr2_reg & 0x100) != 0)) {\n    i2c_handle->ErrorCode = i2c_handle->ErrorCode | 2;\n    i2c_handle->Instance->SR1 = 0xfffffdff;\n  }\n  if (((sr1_reg & 0x10400) != 0) && ((cr2_reg & 0x100) != 0)) {\n    i2c_state = i2c_handle->State;\n    if (((i2c_handle->Mode == HAL_I2C_MODE_SLAVE) && (i2c_handle->XferCount == 0)) &&\n       (((i2c_state == HAL_I2C_STATE_BUSY_TX || (i2c_state == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((i2c_state == HAL_I2C_STATE_LISTEN && (i2c_handle->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(i2c_handle);\n    }\n    else {\n      i2c_handle->ErrorCode = i2c_handle->ErrorCode | 4;\n      if (i2c_handle->Mode == HAL_I2C_MODE_MASTER) {\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n      }\n      i2c_handle->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((sr1_reg & 0x10800) != 0) && ((cr2_reg & 0x100) != 0)) {\n    i2c_handle->ErrorCode = i2c_handle->ErrorCode | 8;\n    i2c_handle->Instance->SR1 = 0xfffff7ff;\n  }\n  if (i2c_handle->ErrorCode != 0) {\n    I2C_ITError(i2c_handle);\n  }\n  return;\n}\n\n",
            "called": [
                "I2C_Slave_AF",
                "I2C_ITError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052f0",
            "calling": [
                "I2C1_ER_IRQHandler",
                "I2C2_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_errors_080052f0"
        },
        "FUN_08002f2c": {
            "renaming": {
                "FUN_08002f2c": "set_callback_function_08002f2c",
                "this": "firmata_instance",
                "command": "callback_type",
                "newFunction": "callback_function"
            },
            "code": "\nvoid __firmata_instancecall\nfirmata::FirmataClass::set_callback_function_08002f2c(FirmataClass *firmata_instance,uint8_t callback_type,callbackFunction callback_function)\n\n{\n  if (callback_type == 0xd0) {\n    *(callbackFunction *)PTR_currentReportDigitalCallback_08002f78 = callback_function;\n    return;\n  }\n  if (0xd0 < callback_type) {\n    if (callback_type == 0xf4) {\n      *(callbackFunction *)PTR_currentPinModeCallback_08002f7c = callback_function;\n      return;\n    }\n    if (callback_type == 0xf5) {\n      *(callbackFunction *)PTR_currentPinValueCallback_08002f80 = callback_function;\n    }\n    else if (callback_type == 0xe0) {\n      *(callbackFunction *)PTR_currentAnalogCallback_08002f6c = callback_function;\n      return;\n    }\n    return;\n  }\n  if (callback_type == 0x90) {\n    *(callbackFunction *)PTR_currentDigitalCallback_08002f74 = callback_function;\n    return;\n  }\n  if (callback_type == 0xc0) {\n    *(callbackFunction *)PTR_currentReportAnalogCallback_08002f70 = callback_function;\n    return;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f2c",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "set_callback_function_08002f2c"
        },
        "FUN_08004954": {
            "renaming": {
                "FUN_08004954": "i2c_listen_mode_08004954",
                "hi2c": "i2c_handle",
                "pData": "data_ptr",
                "Size": "data_size",
                "XferOptions": "transfer_options",
                "HVar1": "status",
                "pIVar2": "i2c_instance",
                "tmpreg": "temporary_register"
            },
            "code": "\nHAL_StatusTypeDef_conflict\ni2c_listen_mode_08004954(I2C_HandleTypeDef_conflict *i2c_handle,uint8_t *data_ptr,uint16_t data_size,uint32_t transfer_options)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2c_instance;\n  uint32_t temporary_register;\n  \n  if (i2c_handle->State == HAL_I2C_STATE_LISTEN) {\n    if (data_ptr == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (data_size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2c_handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2c_handle->Lock = HAL_LOCKED;\n      i2c_instance = i2c_handle->Instance;\n      if ((i2c_instance->CR1 & 1) == 0) {\n        i2c_instance->CR1 = i2c_instance->CR1 | 1;\n      }\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffff7ff;\n      i2c_handle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2c_handle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2c_handle->ErrorCode = 0;\n      i2c_handle->pBuffPtr = data_ptr;\n      i2c_handle->XferCount = data_size;\n      i2c_handle->transfer_options = transfer_options;\n      i2c_handle->Xferdata_size = i2c_handle->XferCount;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004954",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "i2c_listen_mode_08004954"
        },
        "FUN_08005cec": {
            "renaming": {
                "FUN_08005cec": "configure_timer_output_compare_08005cec",
                "TIM_TypeDef_conflict": "timer_instance",
                "TIM_OC_InitTypeDef": "timer_output_compare_config",
                "uVar1": "ccer_value",
                "uVar2": "cr2_value",
                "uVar3": "oc_mode_value",
                "TIMx": "timer_instance",
                "OC_Config": "timer_output_compare_config",
                "Pulse": "pulse_value"
            },
            "code": "\nvoid configure_timer_output_compare_08005cec(timer_instance *timer_instance,timer_output_compare_config *timer_output_compare_config)\n\n{\n  uint32_t ccer_value;\n  uint32_t cr2_value;\n  uint oc_mode_value;\n  \n  timer_instance->CCER = timer_instance->CCER & 0xfffffffe;\n  cr2_value = timer_instance->CR2;\n  oc_mode_value = timer_output_compare_config->OCMode;\n  ccer_value = timer_instance->CCER & 0xfffffffd | timer_output_compare_config->OCPolarity;\n  if (timer_instance == DAT_08005d44) {\n    ccer_value = (ccer_value & 0xfffffff7 | timer_output_compare_config->OCNPolarity) & 0xfffffffb;\n    cr2_value = cr2_value & 0xfffffcff | timer_output_compare_config->OCIdleState | timer_output_compare_config->OCNIdleState;\n  }\n  timer_instance->CR2 = cr2_value;\n  timer_instance->CCMR1 = timer_instance->CCMR1 & 0xffffff8c | oc_mode_value;\n  timer_instance->CCR1 = timer_output_compare_config->pulse_value;\n  timer_instance->CCER = ccer_value;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cec",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_output_compare_08005cec"
        },
        "FUN_08003748": {
            "renaming": {
                "FUN_08003748": "update_uw_tick_08003748"
            },
            "code": "\nvoid update_uwTick_08003748(void)\n\n{\n  *(uint *)PTR_uwTick_08003758 = (uint)(byte)*PTR_uwTickFreq_0800375c + *(int *)PTR_uwTick_08003758;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003748",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "update_uw_tick_08003748"
        },
        "FUN_080040e8": {
            "renaming": {
                "FUN_080040e8": "configure_gpio_pins_080040e8",
                "GPIOx": "GPIO_port",
                "GPIO_Init": "GPIO_pin_config",
                "pGVar1": "current_GPIO_port",
                "uVar2": "temp_var_2",
                "uVar3": "temp_var_3",
                "uVar4": "temp_var_4",
                "uVar5": "current_pin_num",
                "uVar6": "pin_mode",
                "uVar7": "pin_speed",
                "uVar9": "temp_var_9",
                "tmpreg": "temp_register",
                "iVar8": "temp_var_8",
                "iVar10": "temp_var_10"
            },
            "code": "\nvoid configure_GPIO_pins_080040e8(GPIO_TypeDef *GPIO_port,GPIO_pin_configTypeDef *GPIO_pin_config)\n\n{\n  GPIO_TypeDef *current_GPIO_port;\n  uint temp_var_2;\n  uint temp_var_3;\n  uint temp_var_4;\n  uint current_pin_num;\n  uint pin_mode;\n  uint32_t pin_speed;\n  int temp_var_8;\n  uint temp_var_9;\n  int temp_var_10;\n  uint32_t temp_register;\n  \n  pin_speed = 0;\n  current_pin_num = 0;\n  do {\n    if (0xf < current_pin_num) {\n      return;\n    }\n    temp_var_3 = 1 << (current_pin_num & 0xff);\n    temp_var_4 = GPIO_pin_config->Pin & temp_var_3;\n    if (temp_var_3 == temp_var_4) {\n      pin_mode = GPIO_pin_config->Mode;\n      if (pin_mode == 0x12) {\n        pin_speed = GPIO_pin_config->Speed + 0xc;\n      }\n      else if (pin_mode < 0x13) {\n        if (pin_mode == 2) {\n          pin_speed = GPIO_pin_config->Speed + 8;\n        }\n        else if (pin_mode < 3) {\n          if (pin_mode == 0) goto LAB_0800423a;\n          if (pin_mode == 1) {\n            pin_speed = GPIO_pin_config->Speed;\n          }\n        }\n        else if (pin_mode == 3) {\n          pin_speed = 0;\n        }\n        else if (pin_mode == 0x11) {\n          pin_speed = GPIO_pin_config->Speed + 4;\n        }\n      }\n      else {\n        if (pin_mode != DAT_080042c8) {\n          if (DAT_080042c8 < pin_mode) {\n            if (pin_mode == DAT_080042cc) goto LAB_0800423a;\n            temp_var_9 = DAT_080042cc + 0x10000;\n            temp_var_2 = DAT_080042cc;\n          }\n          else {\n            temp_var_9 = DAT_080042c8 - 0x100000;\n            temp_var_2 = DAT_080042c8;\n          }\n          if ((pin_mode != temp_var_9) && (pin_mode != temp_var_2 - 0xf0000)) goto LAB_080040fe;\n        }\nLAB_0800423a:\n        if (GPIO_pin_config->Pull == 0) {\n          pin_speed = 4;\n        }\n        else if (GPIO_pin_config->Pull == 1) {\n          GPIO_port->BSRR = temp_var_3;\n          pin_speed = 8;\n        }\n        else {\n          GPIO_port->BRR = temp_var_3;\n          pin_speed = 8;\n        }\n      }\nLAB_080040fe:\n      temp_var_3 = current_pin_num;\n      current_GPIO_port = GPIO_port;\n      if (0xff < temp_var_4) {\n        temp_var_3 = current_pin_num - 8;\n        current_GPIO_port = (GPIO_TypeDef *)&GPIO_port->CRH;\n      }\n      current_GPIO_port->CRL = current_GPIO_port->CRL & ~(0xf << (temp_var_3 << 2 & 0xff)) | pin_speed << (temp_var_3 << 2 & 0xff);\n      if ((GPIO_pin_config->Mode & 0x10000000) != 0) {\n        *(uint *)(DAT_080042bc + 0x18) = *(uint *)(DAT_080042bc + 0x18) | 1;\n        temp_var_8 = (current_pin_num & 3) << 2;\n        if (GPIO_port == DAT_080042d0) {\n          temp_var_10 = 0;\n        }\n        else if (GPIO_port == (GPIO_TypeDef *)&DAT_080042d0[0x24].BSRR) {\n          temp_var_10 = 1;\n        }\n        else if (GPIO_port == (GPIO_TypeDef *)&DAT_080042d0[0x49].CRH) {\n          temp_var_10 = 2;\n        }\n        else if (GPIO_port == (GPIO_TypeDef *)&DAT_080042d0[0x6d].BRR) {\n          temp_var_10 = 3;\n        }\n        else {\n          temp_var_10 = 4;\n        }\n        *(uint *)(DAT_080042c0 + ((current_pin_num >> 2) + 2) * 4) =\n             *(uint *)(DAT_080042c0 + ((current_pin_num >> 2) + 2) * 4) & ~(0xf << temp_var_8) | temp_var_10 << temp_var_8;\n        if ((GPIO_pin_config->Mode & 0x10000) == 0) {\n          *DAT_080042c4 = *DAT_080042c4 & ~temp_var_4;\n        }\n        else {\n          *DAT_080042c4 = *DAT_080042c4 | temp_var_4;\n        }\n        if ((GPIO_pin_config->Mode & 0x20000) == 0) {\n          DAT_080042c4[1] = DAT_080042c4[1] & ~temp_var_4;\n        }\n        else {\n          DAT_080042c4[1] = DAT_080042c4[1] | temp_var_4;\n        }\n        if ((GPIO_pin_config->Mode & 0x100000) == 0) {\n          DAT_080042c4[2] = DAT_080042c4[2] & ~temp_var_4;\n        }\n        else {\n          DAT_080042c4[2] = DAT_080042c4[2] | temp_var_4;\n        }\n        if ((GPIO_pin_config->Mode & 0x200000) == 0) {\n          DAT_080042c4[3] = DAT_080042c4[3] & ~temp_var_4;\n        }\n        else {\n          DAT_080042c4[3] = temp_var_4 | DAT_080042c4[3];\n        }\n      }\n    }\n    current_pin_num = current_pin_num + 1;\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040e8",
            "calling": [
                "HAL_ADC_MspInit",
                "digital_io_init",
                "HAL_TIM_PWM_MspInit",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "configure_gpio_pins_080040e8"
        },
        "FUN_08009b6c": {
            "renaming": {
                "FUN_08009b6c": "process_data_08009b6c",
                "param_1": "data_buffer",
                "param_2": "data_info",
                "iVar1": "data_offset",
                "piVar2": "free_ptr",
                "uVar3": "data_size",
                "uVar4": "data_flags",
                "iVar5": "block_size",
                "pcVar6": "process_block",
                "iVar7": "remaining_size",
                "uVar8": "original_data",
                "bVar9": "is_zero"
            },
            "code": "\nundefined4 process_data_08009b6c(uint *data_buffer,int *data_info)\n\n{\n  int data_offset;\n  int *free_ptr;\n  uint data_size;\n  ushort data_flags;\n  int block_size;\n  code *process_block;\n  int remaining_size;\n  uint original_data;\n  bool is_zero;\n  \n  data_flags = *(ushort *)(data_info + 3);\n  data_size = (uint)data_flags;\n  if ((int)(data_size << 0x1c) < 0) {\n    data_offset = data_info[4];\n    if (data_offset != 0) {\n      block_size = data_size << 0x1e;\n      is_zero = block_size != 0;\n      if (is_zero) {\n        block_size = 0;\n      }\n      remaining_size = *data_info;\n      if (!is_zero) {\n        block_size = data_info[5];\n      }\n      *data_info = data_offset;\n      data_info[2] = block_size;\n      for (remaining_size = remaining_size - data_offset; 0 < remaining_size; remaining_size = remaining_size - block_size) {\n        block_size = (*(code *)data_info[10])(data_buffer,data_info[8],data_offset,remaining_size);\n        if (block_size < 1) {\n          data_flags = *(ushort *)(data_info + 3);\n          goto LAB_08009c62;\n        }\n        data_offset = data_offset + block_size;\n      }\n    }\n  }\n  else if (((0 < data_info[1]) || (0 < data_info[0x10])) &&\n          (process_block = (code *)data_info[0xb], process_block != (code *)0x0)) {\n    original_data = *data_buffer;\n    *data_buffer = 0;\n    if ((data_flags & 0x1000) == 0) {\n      data_offset = (*process_block)(data_buffer,data_info[8],data_size & 0x1000,1);\n      if ((data_offset == -1) && (data_size = *data_buffer, data_size != 0)) {\n        if ((data_size != 0x1d) && (data_size != 0x16)) {\n          *(ushort *)(data_info + 3) = *(ushort *)(data_info + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *data_buffer = original_data;\n        return 0;\n      }\n    }\n    else {\n      data_offset = data_info[0x15];\n    }\n    if (((int)((uint)*(ushort *)(data_info + 3) << 0x1d) < 0) &&\n       (data_offset = data_offset - data_info[1], data_info[0xd] != 0)) {\n      data_offset = data_offset - data_info[0x10];\n    }\n    data_offset = (*(code *)data_info[0xb])(data_buffer,data_info[8],data_offset,0);\n    data_flags = *(ushort *)(data_info + 3);\n    if ((data_offset == -1) &&\n       ((0x1d < *data_buffer || (-1 < (int)((DAT_08009c78 >> (*data_buffer & 0xff)) << 0x1f))))) {\nLAB_08009c62:\n      *(ushort *)(data_info + 3) = data_flags | 0x40;\n      return 0xffffffff;\n    }\n    data_info[1] = 0;\n    *data_info = data_info[4];\n    if (((int)((uint)data_flags << 0x13) < 0) && ((data_offset != -1 || (*data_buffer == 0)))) {\n      data_info[0x15] = data_offset;\n    }\n    free_ptr = (int *)data_info[0xd];\n    *data_buffer = original_data;\n    if (free_ptr != (int *)0x0) {\n      if (free_ptr != data_info + 0x11) {\n        _free_r(data_buffer);\n      }\n      data_info[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009b6c",
            "calling": [
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "process_data_08009b6c"
        },
        "FUN_0800288c": {
            "renaming": {
                "this": "wire",
                "data": "byte",
                "puVar1": "tx_buffer_ptr",
                "iVar2": "i2c_status",
                "pvVar3": "realloc_ptr",
                "sVar4": "transmit_success",
                "cVar5": "tx_buffer_index",
                "uVar6": "realloc_size",
                "__size": "tx_buffer_size",
                "local_11": "transmit_byte",
                "FUN_0800288c": "transmit_data_0800288c"
            },
            "code": "\nsize_t __wirecall TwoWire::transmit_data_0800288c(TwoWire *wire,uint8_t byte)\n\n{\n  undefined *tx_buffer_ptr;\n  i2c_status_e_conflict i2c_status;\n  void *realloc_ptr;\n  size_t transmit_success;\n  char tx_buffer_index;\n  undefined realloc_size;\n  size_t tx_buffer_size;\n  uint8_t transmit_byte;\n  \n  tx_buffer_ptr = PTR_txBuffer_08002914;\n  transmit_byte = byte;\n  if (*PTR_transmitting_08002908 == '\\0') {\n    i2c_status = i2c_slave_transmit_data_0800288c_IT((i2c_t_conflict *)&wire->_i2c,&transmit_byte,1);\n    if (i2c_status == I2C_OK) {\n      transmit_success = 1;\n    }\n    else {\n      transmit_success = 0;\n    }\n  }\n  else {\n    tx_buffer_size = (byte)*PTR_txBufferLength_0800290c + 1;\n    if ((byte)*PTR_txBufferAllocated_08002910 < tx_buffer_size) {\n      if (tx_buffer_size < 0x20) {\n        tx_buffer_size = 0x20;\n      }\n      realloc_ptr = realloc(*(void **)PTR_txBuffer_08002914,tx_buffer_size);\n      *(void **)tx_buffer_ptr = realloc_ptr;\n      if (realloc_ptr == (void *)0x0) {\n        realloc_size = 0;\n      }\n      else {\n        realloc_size = (undefined)tx_buffer_size;\n      }\n      *PTR_txBufferAllocated_08002910 = realloc_size;\n    }\n    tx_buffer_ptr = PTR_txBufferIndex_08002918;\n    if (*(int *)PTR_txBuffer_08002914 == 0) {\n      (wire->super_Stream).super_Print.transmit_data_0800288c_error = 1;\n      transmit_success = 0;\n    }\n    else {\n      *(uint8_t *)(*(int *)PTR_txBuffer_08002914 + (uint)(byte)*PTR_txBufferIndex_08002918) =\n           transmit_byte;\n      tx_buffer_index = *tx_buffer_ptr + '\\x01';\n      *tx_buffer_ptr = tx_buffer_index;\n      *PTR_txBufferLength_0800290c = tx_buffer_index;\n      transmit_success = 1;\n    }\n  }\n  return transmit_success;\n}\n\n",
            "called": [
                "i2c_slave_write_IT",
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800288c",
            "calling": [
                "wireWrite"
            ],
            "imported": false,
            "current_name": "transmit_data_0800288c"
        },
        "FUN_08002e26": {
            "renaming": {
                "printVersion": "printBoardVersion",
                "printFirmwareVersion": "printFirmwareInformation",
                "FUN_08002e26": "initialize_firmata_08002e26"
            },
            "code": "\nvoid __thiscall firmata::FirmataClass::initializeFirmata_08002e26(FirmataClass *this,Stream *s)\n\n{\n  this->FirmataStream = s;\n  FirmataMarshaller::initializeFirmata_08002e26(&this->marshaller,s);\n  printBoardVersion(this);\n  printFirmwareInformation(this);\n  return;\n}\n\n",
            "called": [
                "printVersion",
                "begin",
                "printFirmwareVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e26",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initialize_firmata_08002e26"
        },
        "FUN_0800010c": {
            "renaming": {
                "FUN_0800010c": "check_completion_and_initialize_0800010c",
                "param_1": "input_pointer"
            },
            "code": "\nundefined * check_completion_and_initialize_0800010c(undefined *input_pointer)\n\n{\n  if (*PTR_completed_8667_08000124 == '\\0') {\n    if (DAT_08000128 != 0) {\n      input_pointer = PTR__init_0800012c;\n    }\n    *PTR_completed_8667_08000124 = 1;\n  }\n  return input_pointer;\n}\n\n",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800010c",
            "calling": [],
            "imported": false,
            "current_name": "check_completion_and_initialize_0800010c"
        },
        "FUN_080086e8": {
            "renaming": {
                "FUN_080086e8": "find_uart_handler_index_080086e8",
                "huart": "uart_handle",
                "uVar1": "index"
            },
            "code": "\nuint8_t find_uart_handler_index_080086e8(UART_HandleTypeDef *uart_handle)\n\n{\n  uint index;\n  \n  if (uart_handle == (UART_HandleTypeDef *)0x0) {\n    index = 5;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (4 < index) {\n        return (uint8_t)index;\n      }\n      if (uart_handle == *(UART_HandleTypeDef **)(PTR_uart_handlers_08008708 + index * 4)) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return (uint8_t)index;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080086e8",
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "imported": false,
            "current_name": "find_uart_handler_index_080086e8"
        },
        "FUN_08001c18": {
            "renaming": {
                "FUN_08001c18": "read_write_i2_c_08001c18",
                "address": "deviceAddress",
                "theRegister": "registerAddress",
                "numBytes": "byteCount",
                "stopTX": "stopTransmission",
                "TwoWire": "Wire",
                "wireWrite": "writeToWire",
                "wireRead": "readFromWire"
            },
            "code": "\nvoid readWriteI2C_08001c18(byte deviceAddress,int registerAddress,byte byteCount,byte stopTransmission)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  byte bVar3;\n  int iVar4;\n  int iVar5;\n  uint uVar6;\n  \n  puVar2 = PTR_Wire_08001cbc;\n  uVar6 = (uint)byteCount;\n  if (registerAddress == -1) {\n    registerAddress = 0;\n  }\n  else {\n    Wire::beginTransmission((Wire *)PTR_Wire_08001cbc,deviceAddress);\n    writeToWire((byte)registerAddress);\n    Wire::endTransmission((Wire *)puVar2,stopTransmission);\n  }\n  puVar2 = PTR_Wire_08001cbc;\n  Wire::requestFrom((Wire *)PTR_Wire_08001cbc,deviceAddress,byteCount);\n  iVar4 = Wire::available((Wire *)puVar2);\n  if ((int)uVar6 < iVar4) {\n    firmata::FirmataClass::sendString\n              ((FirmataClass *)PTR_Firmata_08001cc4,PTR_s_I2C__Too_many_bytes_received_08001cc0);\n  }\n  else {\n    iVar4 = Wire::available((Wire *)PTR_Wire_08001cbc);\n    if (iVar4 < (int)uVar6) {\n      firmata::FirmataClass::sendString\n                ((FirmataClass *)PTR_Firmata_08001cc4,PTR_s_I2C__Too_few_bytes_received_08001ccc);\n    }\n  }\n  puVar2 = PTR_i2cRxData_08001cc8;\n  *PTR_i2cRxData_08001cc8 = deviceAddress;\n  puVar2[1] = (char)registerAddress;\n  iVar4 = 0;\n  while( true ) {\n    if (iVar4 < (int)uVar6) {\n      iVar5 = Wire::available((Wire *)PTR_Wire_08001cbc);\n      if (iVar5 == 0) {\n        bVar1 = false;\n      }\n      else {\n        bVar1 = true;\n      }\n    }\n    else {\n      bVar1 = false;\n    }\n    if (!bVar1) break;\n    bVar3 = readFromWire();\n    PTR_i2cRxData_08001cc8[iVar4 + 2] = bVar3;\n    iVar4 = iVar4 + 1;\n  }\n  firmata::FirmataClass::sendSysex\n            ((FirmataClass *)PTR_Firmata_08001cc4,'w',byteCount + '\\x02',PTR_i2cRxData_08001cc8);\n  return;\n}\n\n",
            "called": [
                "beginTransmission",
                "endTransmission",
                "available",
                "wireWrite",
                "wireRead",
                "sendString",
                "sendSysex",
                "requestFrom"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c18",
            "calling": [
                "loop",
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "read_write_i2_c_08001c18"
        },
        "FUN_08009056": {
            "renaming": {
                "FUN_08009056": "handle_gpio_exti_interrupts_08009056",
                "uVar1": "multiplier",
                "HAL_GPIO_EXTI_IRQHandler": "process_GPIO_EXTI_interrupt"
            },
            "code": "\nvoid handle_GPIO_EXTI_interrupts_08009056(void)\n\n{\n  uint multiplier;\n  \n  for (multiplier = 0x20; multiplier < 0x201; multiplier = multiplier << 1) {\n    process_GPIO_EXTI_interrupt((uint16_t)multiplier);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009056",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_interrupts_08009056"
        },
        "FUN_08002e1a": {
            "renaming": {
                "FUN_08002e1a": "print_firmware_version_if_context_not_null_08002e1a",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4"
            },
            "code": "\nvoid firmata::FirmataClass::printFirmwareVersionIfContextNotNull_08002e1a(void *context,size_t param2,size_t param3,char *param4)\n\n{\n  if (context != (void *)0x0) {\n    printFirmwareVersion((FirmataClass *)context);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printFirmwareVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e1a",
            "calling": [],
            "imported": false,
            "current_name": "print_firmware_version_if_context_not_null_08002e1a"
        },
        "FUN_0800904c": {
            "renaming": {
                "FUN_0800904c": "handle_ext_interrupt_0800904c",
                "HAL_GPIO_EXTI_IRQHandler": "handle_gpio_exti_interrupt"
            },
            "code": "\nvoid handle_ext_interrupt_0800904c(void)\n\n{\n  handle_gpio_exti_interrupt(0x10);\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800904c",
            "calling": [],
            "imported": false,
            "current_name": "handle_ext_interrupt_0800904c"
        },
        "FUN_080073ae": {
            "renaming": {
                "FUN_080073ae": "find_non_null_pointer_080073ae"
            },
            "code": "\nvoid * find_non_null_pointer_080073ae(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073ae",
            "calling": [
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "find_non_null_pointer_080073ae"
        },
        "FUN_08003f0c": {
            "renaming": {
                "FUN_08003f0c": "set_priority_group_08003f0c",
                "PriorityGroup": "priority_group"
            },
            "code": "\nvoid set_priority_group_08003f0c(uint32_t priority_group)\n\n{\n  *(uint32_t *)(DAT_08003f2c + 0xc) =\n       (priority_group & 7) << 8 | *(uint *)(DAT_08003f2c + 0xc) & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f0c",
            "calling": [
                "HAL_Init",
                "premain"
            ],
            "imported": false,
            "current_name": "set_priority_group_08003f0c"
        },
        "FUN_08000488": {
            "renaming": {
                "FUN_08000488": "analog_pin_handler_08000488",
                "analogPin": "analog_pin",
                "value": "analog_value",
                "ulPin": "converted_pin",
                "value_00": "read_analog_value"
            },
            "code": "\nvoid analog_pin_handler_08000488(byte analog_pin,int analog_value)\n\n{\n  uint converted_pin;\n  uint32_t read_analog_value;\n  \n  converted_pin = (uint)analog_pin;\n  if (converted_pin < 0xe) {\n    if (analog_value == 0) {\n      *(uint *)PTR_analogInputsToReport_080004c8 =\n           *(uint *)PTR_analogInputsToReport_080004c8 & ~(1 << converted_pin);\n      return;\n    }\n    *(uint *)PTR_analogInputsToReport_080004c8 =\n         1 << converted_pin | *(uint *)PTR_analogInputsToReport_080004c8;\n    if (*PTR_isResetting_080004cc == '\\0') {\n      read_analog_value = analogRead(converted_pin);\n      firmata::FirmataClass::sendAnalog((FirmataClass *)PTR_Firmata_080004d0,analog_pin,read_analog_value);\n      return;\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "sendAnalog",
                "analogRead"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000488",
            "calling": [
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "analog_pin_handler_08000488"
        },
        "FUN_08006bb8": {
            "renaming": {
                "FUN_08006bb8": "get_gpio_port_08006bb8",
                "port_idx": "port_index",
                "tmpreg": "temporary_register",
                "tmpreg_1": "temporary_register_1",
                "tmpreg_2": "temporary_register_2",
                "tmpreg_3": "temporary_register_3",
                "tmpreg_4": "temporary_register_4",
                "pGVar1": "GPIO_port_pointer"
            },
            "code": "\nGPIO_TypeDef * get_GPIO_port_08006bb8(uint32_t port_index)\n\n{\n  GPIO_TypeDef *GPIO_port_pointer;\n  uint32_t temporary_register;\n  uint32_t temporary_register_1;\n  uint32_t temporary_register_2;\n  uint32_t temporary_register_3;\n  uint32_t temporary_register_4;\n  \n  switch(port_index) {\n  case 0:\n    *(uint *)(DAT_08006c48 + 0x18) = *(uint *)(DAT_08006c48 + 0x18) | 4;\n    GPIO_port_pointer = DAT_08006c4c;\n    break;\n  case 1:\n    *(uint *)(DAT_08006c48 + 0x18) = *(uint *)(DAT_08006c48 + 0x18) | 8;\n    GPIO_port_pointer = DAT_08006c50;\n    break;\n  case 2:\n    *(uint *)(DAT_08006c48 + 0x18) = *(uint *)(DAT_08006c48 + 0x18) | 0x10;\n    GPIO_port_pointer = DAT_08006c54;\n    break;\n  case 3:\n    *(uint *)(DAT_08006c48 + 0x18) = *(uint *)(DAT_08006c48 + 0x18) | 0x20;\n    GPIO_port_pointer = DAT_08006c58;\n    break;\n  case 4:\n    *(uint *)(DAT_08006c48 + 0x18) = *(uint *)(DAT_08006c48 + 0x18) | 0x40;\n    GPIO_port_pointer = DAT_08006c5c;\n    break;\n  default:\n    GPIO_port_pointer = (GPIO_TypeDef *)0x0;\n  }\n  return GPIO_port_pointer;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006bb8",
            "calling": [
                "HAL_ADC_MspInit",
                "digital_io_init",
                "HAL_TIM_PWM_MspInit",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "get_gpio_port_08006bb8"
        },
        "FUN_08004aec": {
            "renaming": {
                "FUN_08004aec": "handle_i2c_state_transitions_08004aec",
                "hi2c": "i2c_handle",
                "XferOptions": "transfer_options",
                "State": "i2c_state",
                "Instance": "i2c_instance",
                "CR2": "control_register_2",
                "SR1": "status_register_1",
                "CR1": "control_register_1",
                "PreviousState": "previous_i2c_state",
                "HAL_I2C_STATE_LISTEN": "I2C_STATE_LISTEN",
                "HAL_I2C_STATE_BUSY_TX": "I2C_STATE_BUSY_TX",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_I2C_ListenCpltCallback": "i2c_listen_complete_callback",
                "HAL_I2C_SlaveTxCpltCallback": "i2c_slave_tx_complete_callback"
            },
            "code": "\nHAL_StatusTypeDef_conflict handle_i2c_state_transitions_08004aec(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  if (((i2c_handle->transfer_options == 4) || (i2c_handle->transfer_options == 8)) &&\n     (i2c_handle->i2c_state == I2C_STATE_LISTEN)) {\n    i2c_handle->transfer_options = DAT_08004b7c;\n    i2c_handle->i2c_instance->control_register_2 = i2c_handle->i2c_instance->control_register_2 & 0xfffff8ff;\n    i2c_handle->i2c_instance->status_register_1 = 0xfffffbff;\n    i2c_handle->i2c_instance->control_register_1 = i2c_handle->i2c_instance->control_register_1 & 0xfffffbff;\n    i2c_handle->previous_i2c_state = 0;\n    i2c_handle->i2c_state = I2C_STATE_READY;\n    i2c_handle->Mode = I2C_MODE_NONE;\n    i2c_listen_complete_callback(i2c_handle);\n  }\n  else if (i2c_handle->i2c_state == I2C_STATE_BUSY_TX) {\n    i2c_handle->transfer_options = DAT_08004b7c;\n    i2c_handle->previous_i2c_state = 0x21;\n    i2c_handle->i2c_state = I2C_STATE_READY;\n    i2c_handle->Mode = I2C_MODE_NONE;\n    i2c_handle->i2c_instance->control_register_2 = i2c_handle->i2c_instance->control_register_2 & 0xfffff8ff;\n    i2c_handle->i2c_instance->status_register_1 = 0xfffffbff;\n    i2c_handle->i2c_instance->control_register_1 = i2c_handle->i2c_instance->control_register_1 & 0xfffffbff;\n    i2c_slave_tx_complete_callback(i2c_handle);\n  }\n  else {\n    i2c_handle->i2c_instance->status_register_1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004aec",
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_state_transitions_08004aec"
        },
        "FUN_08007ede": {
            "renaming": {
                "FUN_08007ede": "copy_data_to_i2c_buffer_08007ede",
                "obj": "i2c_conflict_object",
                "data": "data_to_copy",
                "size": "size_of_data",
                "uVar1": "index",
                "i2cTxRxBuffer": "i2c_buffer",
                "i2cTxRxBufferSize": "i2c_buffer_size"
            },
            "code": "\ni2c_status_e_conflict copy_data_to_i2c_buffer_08007ede(i2c_t_conflict *i2c_conflict_object,uint8_t *data_to_copy,uint16_t size_of_data)\n\n{\n  uint index;\n  \n  if (0x20 < size_of_data) {\n    return I2C_ERROR;\n  }\n  for (index = 0; index < size_of_data; index = index + 1 & 0xff) {\n    i2c_conflict_object->i2c_buffer[index] = data_to_copy[index];\n    i2c_conflict_object->i2c_buffer_size = i2c_conflict_object->i2c_buffer_size + '\\x01';\n  }\n  return I2C_OK;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ede",
            "calling": [
                "write",
                "write"
            ],
            "imported": false,
            "current_name": "copy_data_to_i2c_buffer_08007ede"
        },
        "FUN_08004728": {
            "renaming": {
                "FUN_08004728": "send_i2c_data_08004728",
                "hi2c": "i2c_handle",
                "DevAddress": "device_address",
                "pData": "data",
                "Size": "data_size",
                "HVar1": "status",
                "pIVar2": "i2c_instance",
                "count": "timeout_count"
            },
            "code": "\nHAL_StatusTypeDef_conflict\nsend_i2c_data_08004728(I2C_HandleTypeDef_conflict *i2c_handle,uint16_t device_address,uint8_t *data,uint16_t data_size)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2c_instance;\n  uint32_t timeout_count;\n  \n  if (i2c_handle->State == HAL_I2C_STATE_READY) {\n    timeout_count = (uint)((ulonglong)DAT_080047ec * (ulonglong)(*(uint *)PTR_SystemCoreClock_080047e8 >> 3)\n                  >> 0x28) * 0x19;\n    do {\n      if (timeout_count == 0) {\n        i2c_handle->PreviousState = 0;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        i2c_handle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      i2c_instance = i2c_handle->Instance;\n      timeout_count = timeout_count - 1;\n    } while ((i2c_instance->SR2 & 2) != 0);\n    if (i2c_handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2c_handle->Lock = HAL_LOCKED;\n      if ((i2c_instance->CR1 & 1) == 0) {\n        i2c_instance->CR1 = i2c_instance->CR1 | 1;\n      }\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffff7ff;\n      i2c_handle->State = HAL_I2C_STATE_BUSY_TX;\n      i2c_handle->Mode = HAL_I2C_MODE_MASTER;\n      status = HAL_OK;\n      i2c_handle->ErrorCode = 0;\n      i2c_handle->pBuffPtr = data;\n      i2c_handle->XferCount = data_size;\n      i2c_handle->XferOptions = DAT_080047f0;\n      i2c_handle->Xferdata_size = i2c_handle->XferCount;\n      i2c_handle->Devaddress = (uint)device_address;\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x100;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004728",
            "calling": [
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "send_i2c_data_08004728"
        },
        "FUN_080074e0": {
            "renaming": {
                "FUN_080074e0": "set_timer_instance_080074e0",
                "htim": "timer_handle",
                "Instance": "timer_instance",
                "uint": "unsigned_int",
                "TIM_TypeDef_conflict": "TIM_TypeDef"
            },
            "code": "\nvoid set_timer_instance_080074e0(TIM_HandleTypeDef_conflict *timer_handle)\n\n{\n  if (timer_handle->timer_instance == DAT_08007534) {\n    *(unsigned_int *)(DAT_08007540 + 0x18) = *(unsigned_int *)(DAT_08007540 + 0x18) & 0xfffff7ff;\n  }\n  if (timer_handle->timer_instance == (TIM_TypeDef *)0x40000000) {\n    *(unsigned_int *)(DAT_08007540 + 0x1c) = *(unsigned_int *)(DAT_08007540 + 0x1c) & 0xfffffffe;\n  }\n  if (timer_handle->timer_instance == DAT_08007538) {\n    *(unsigned_int *)(DAT_08007540 + 0x1c) = *(unsigned_int *)(DAT_08007540 + 0x1c) & 0xfffffffd;\n  }\n  if (timer_handle->timer_instance == DAT_0800753c) {\n    *(unsigned_int *)(DAT_08007540 + 0x1c) = *(unsigned_int *)(DAT_08007540 + 0x1c) & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080074e0",
            "calling": [
                "HAL_TIM_PWM_MspDeInit",
                "HAL_TIM_OC_MspDeInit"
            ],
            "imported": false,
            "current_name": "set_timer_instance_080074e0"
        },
        "FUN_080073c0": {
            "renaming": {
                "FUN_080073c0": "execute_rtc_user_callback_080073c0",
                "hrtc": "RTC_HandleTypeDef"
            },
            "code": "\nvoid execute_RTC_user_callback_080073c0(RTC_HandleTypeDef *RTC_HandleTypeDef)\n\n{\n  if (*(code **)PTR_RTCUserCallback_080073d0 != (code *)0x0) {\n    (**(code **)PTR_RTCUserCallback_080073d0)(*(undefined4 *)PTR_callbackUserData_080073d4);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073c0",
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "imported": false,
            "current_name": "execute_rtc_user_callback_080073c0"
        },
        "FUN_080084b0": {
            "renaming": {
                "FUN_080084b0": "initialize_uart_080084b0",
                "pin": "digital_pin",
                "obj": "serial_debug_ptr",
                "PVar1": "uart_rx_pin",
                "pvVar2": "uart_tx_pin_ptr"
            },
            "code": "\nvoid initialize_uart_080084b0(void)\n\n{\n  PinName_conflict digital_pin;\n  undefined *serial_debug_ptr;\n  PinName_conflict uart_rx_pin;\n  void *uart_tx_pin_ptr;\n  \n  digital_pin = PTR_digitalPin_080084f0[1];\n  uart_tx_pin_ptr = digital_pinmap_peripheral(digital_pin,(PinMap_conflict *)PTR_PinMap_UART_TX_080084f4);\n  if (uart_tx_pin_ptr != (void *)0x0) {\n    uart_tx_pin_ptr = digital_pinmap_peripheral(digital_pin,(PinMap_conflict *)PTR_PinMap_UART_TX_080084f4);\n    uart_rx_pin = digital_pinmap_digital_pin(uart_tx_pin_ptr,(PinMap_conflict *)PTR_PinMap_UART_RX_080084f8);\n    serial_debug_ptr = PTR_serial_debug_080084fc;\n    PTR_serial_debug_080084fc[0x59] = uart_rx_pin;\n    serial_debug_ptr[0x58] = digital_pin;\n    *(undefined4 *)(serial_debug_ptr + 0x48) = 0x2580;\n    *(undefined4 *)(serial_debug_ptr + 0x54) = 0;\n    *(undefined4 *)(serial_debug_ptr + 0x4c) = 0;\n    *(undefined4 *)(serial_debug_ptr + 0x50) = 0;\n    uart_init((serial_t *)serial_debug_ptr);\n  }\n  return;\n}\n\n",
            "called": [
                "pinmap_pin",
                "pinmap_peripheral",
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080084b0",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "initialize_uart_080084b0"
        },
        "FUN_080095a8": {
            "renaming": {
                "FUN_080095a8": "print_formatted_string_080095a8",
                "param_1": "output_stream",
                "param_2": "format_specifier",
                "param_3": "formatted_string_size",
                "param_4": "arg_list",
                "param_5": "write_to_output_stream",
                "iVar1": "write_result",
                "uVar2": "specifier_flags",
                "uVar3": "num_chars_written",
                "bVar4": "is_specifier_d_or_i"
            },
            "code": "\nundefined4\nprint_formatted_string_080095a8(undefined4 output_stream,uint *format_specifier,uint *formatted_string_size,undefined4 arg_list,code *write_to_output_stream)\n\n{\n  int write_result;\n  uint specifier_flags;\n  uint num_chars_written;\n  bool is_specifier_d_or_i;\n  \n  specifier_flags = format_specifier[4];\n  if ((int)format_specifier[4] < (int)format_specifier[2]) {\n    specifier_flags = format_specifier[2];\n  }\n  *formatted_string_size = specifier_flags;\n  if (*(char *)((int)format_specifier + 0x43) != '\\0') {\n    *formatted_string_size = specifier_flags + 1;\n  }\n  if ((int)(*format_specifier << 0x1a) < 0) {\n    *formatted_string_size = *formatted_string_size + 2;\n  }\n  specifier_flags = *format_specifier & 6;\n  if (specifier_flags == 0) {\n    for (; (int)specifier_flags < (int)(format_specifier[3] - *formatted_string_size); specifier_flags = specifier_flags + 1) {\n      write_result = (*write_to_output_stream)(output_stream,arg_list,(int)format_specifier + 0x19,1);\n      if (write_result == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  specifier_flags = (uint)*(byte *)((int)format_specifier + 0x43);\n  if (specifier_flags != 0) {\n    specifier_flags = 1;\n  }\n  num_chars_written = specifier_flags;\n  if ((int)(*format_specifier << 0x1a) < 0) {\n    *(undefined *)((int)format_specifier + specifier_flags + 0x43) = 0x30;\n    num_chars_written = specifier_flags + 2;\n    *(undefined *)((int)format_specifier + specifier_flags + 0x44) = *(undefined *)((int)format_specifier + 0x45);\n  }\n  write_result = (*write_to_output_stream)(output_stream,arg_list,(int)format_specifier + 0x43,num_chars_written);\n  if (write_result != -1) {\n    specifier_flags = format_specifier[3];\n    is_specifier_d_or_i = (*format_specifier & 6) != 4;\n    if (is_specifier_d_or_i) {\n      specifier_flags = 0;\n    }\n    num_chars_written = 0;\n    if (!is_specifier_d_or_i) {\n      specifier_flags = specifier_flags - *formatted_string_size;\n    }\n    if (!is_specifier_d_or_i) {\n      specifier_flags = specifier_flags & ~((int)specifier_flags >> 0x1f);\n    }\n    if ((int)format_specifier[4] < (int)format_specifier[2]) {\n      specifier_flags = specifier_flags + (format_specifier[2] - format_specifier[4]);\n    }\n    while( true ) {\n      if (specifier_flags == num_chars_written) {\n        return 0;\n      }\n      write_result = (*write_to_output_stream)(output_stream,arg_list,(int)format_specifier + 0x1a,1);\n      if (write_result == -1) break;\n      num_chars_written = num_chars_written + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080095a8",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "print_formatted_string_080095a8"
        },
        "FUN_08008b2a": {
            "renaming": {
                "FUN_08008b2a": "FUNC_08008b2a"
            },
            "code": "\nssize_t __thiscall HardwareSerial::FUNC_08008b2a(HardwareSerial *this,int __fd,void *__buf,size_t __nbytes)\n\n{\n  byte bVar1;\n  ushort uVar2;\n  \n  uVar2 = (this->_serial).rx_tail;\n  if ((uint)(this->_serial).rx_head != (uint)uVar2) {\n    bVar1 = (this->_serial).rx_buff[uVar2];\n    (this->_serial).rx_tail = uVar2 + 1 & 0x3f;\n    return (uint)bVar1;\n  }\n  return -1;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008b2a",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_08008b2a"
        },
        "FUN_08003bd8": {
            "renaming": {
                "FUN_08003bd8": "initialize_adc_08003bd8",
                "hadc": "ADC_handle",
                "HVar1": "status",
                "uVar2": "var2",
                "uVar3": "var3",
                "uVar4": "var4",
                "uVar5": "var5"
            },
            "code": "\nHAL_StatusTypeDef_conflict initialize_ADC_08003bd8(ADC_HandleTypeDef *ADC_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t var2;\n  uint var3;\n  uint var4;\n  uint32_t var5;\n  \n  if (ADC_handle == (ADC_HandleTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (ADC_handle->State == 0) {\n    ADC_handle->ErrorCode = 0;\n    ADC_handle->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(ADC_handle);\n  }\n  status = ADC_ConversionStop_Disable(ADC_handle);\n  var4 = ADC_handle->State & 0x10;\n  if ((var4 == 0) && (status == HAL_OK)) {\n    ADC_handle->State = ADC_handle->State & 0xffffeefd | 2;\n    var5 = (ADC_handle->Init).ContinuousConvMode;\n    var3 = (ADC_handle->Init).DataAlign | (ADC_handle->Init).ExternalTrigConv | var5 << 1;\n    var2 = (ADC_handle->Init).ScanConvMode;\n    if (var2 == 0x100) {\n      var4 = 0x100;\n    }\n    else if (var2 == 1) {\n      var4 = 0x100;\n    }\n    if ((ADC_handle->Init).DiscontinuousConvMode == 1) {\n      if (var5 == 0) {\n        var4 = var4 | ((ADC_handle->Init).NbrOfDiscConversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        ADC_handle->State = ADC_handle->State | 0x20;\n        ADC_handle->ErrorCode = ADC_handle->ErrorCode | 1;\n      }\n    }\n    ADC_handle->Instance->CR1 = var4 | ADC_handle->Instance->CR1 & 0xffff16ff;\n    ADC_handle->Instance->CR2 = DAT_08003ce0 & ADC_handle->Instance->CR2 | var3;\n    var2 = (ADC_handle->Init).ScanConvMode;\n    if ((var2 == 0x100) || (var2 == 1)) {\n      var4 = ((ADC_handle->Init).NbrOfConversion - 1) * 0x100000;\n    }\n    else {\n      var4 = 0;\n    }\n    ADC_handle->Instance->SQR1 = var4 | ADC_handle->Instance->SQR1 & 0xff0fffff;\n    if (var3 != (DAT_08003ce4 & ADC_handle->Instance->CR2)) {\n      ADC_handle->State = ADC_handle->State & 0xffffffed | 0x10;\n      ADC_handle->ErrorCode = ADC_handle->ErrorCode | 1;\n      return HAL_ERROR;\n    }\n    ADC_handle->ErrorCode = 0;\n    ADC_handle->State = ADC_handle->State & 0xfffffffc | 1;\n    return HAL_OK;\n  }\n  ADC_handle->State = ADC_handle->State | 0x10;\n  return HAL_ERROR;\n}\n\n",
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003bd8",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "initialize_adc_08003bd8"
        },
        "FUN_08009d50": {
            "renaming": {
                "FUN_08009d50": "initialize_object_08009d50",
                "param_1": "object_address",
                "uVar1": "return_value",
                "iVar2": "global_impure_ptr",
                "bVar3": "is_current_object"
            },
            "code": "\nvoid initialize_object_08009d50(int object_address)\n\n{\n  undefined4 return_value;\n  int global_impure_ptr;\n  bool is_current_object;\n  \n  if (*(int *)(object_address + 0x18) == 0) {\n    *(undefined4 *)(object_address + 0x48) = 0;\n    *(undefined4 *)(object_address + 0x4c) = 0;\n    *(undefined4 *)(object_address + 0x50) = 0;\n    global_impure_ptr = *(int *)PTR__global_impure_ptr_08009da8;\n    *(undefined4 *)(object_address + 0x28) = DAT_08009dac;\n    is_current_object = object_address == global_impure_ptr;\n    if (is_current_object) {\n      global_impure_ptr = 1;\n    }\n    if (is_current_object) {\n      *(int *)(object_address + 0x18) = global_impure_ptr;\n    }\n    return_value = __sfp();\n    *(undefined4 *)(object_address + 4) = return_value;\n    return_value = __sfp(object_address);\n    *(undefined4 *)(object_address + 8) = return_value;\n    return_value = __sfp(object_address);\n    *(undefined4 *)(object_address + 0xc) = return_value;\n    std_isra_0(*(undefined4 *)(object_address + 4),4,0);\n    std_isra_0(*(undefined4 *)(object_address + 8),9,1);\n    std_isra_0(*(undefined4 *)(object_address + 0xc),0x12,2);\n    *(undefined4 *)(object_address + 0x18) = 1;\n  }\n  return;\n}\n\n",
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009d50",
            "calling": [
                "_fflush_r",
                "__swbuf_r",
                "_vfiprintf_r",
                "__swsetup_r",
                "__sfp",
                "iprintf"
            ],
            "imported": false,
            "current_name": "initialize_object_08009d50"
        },
        "FUN_08009108": {
            "renaming": {
                "FUN_08009108": "convert_to_longlong_08009108",
                "param_1": "input_value",
                "param_2": "shift_value",
                "CONCAT44": "combine_values"
            },
            "code": "\nlonglong convert_to_longlong_08009108(undefined4 input_value,uint shift_value)\n\n{\n  if (DAT_08009120 != 0) {\n    return combine_values(input_value,2);\n  }\n  return (ulonglong)shift_value << 0x20;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009108",
            "calling": [
                "__aeabi_atexit"
            ],
            "imported": false,
            "current_name": "convert_to_longlong_08009108"
        },
        "FUN_08009f98": {
            "renaming": {
                "FUN_08009f98": "execute_command_08009f98",
                "param_1": "output",
                "param_2": "command",
                "_Var1": "process_id",
                "uVar2": "kill_result",
                "iVar3": "command_list",
                "pcVar4": "command_function"
            },
            "code": "\nundefined4 execute_command_08009f98(undefined4 *output,uint command,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t process_id;\n  undefined4 kill_result;\n  int command_list;\n  code *command_function;\n  \n  if (0x1f < command) {\n    *output = 0x16;\n    return 0xffffffff;\n  }\n  command_list = output[0x11];\n  if ((command_list != 0) && (command_function = *(code **)(command_list + command * 4), command_function != (code *)0x0)) {\n    if (command_function != (code *)0x1) {\n      if (command_function == (code *)0xffffffff) {\n        *output = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(command_list + command * 4) = 0;\n      (*command_function)(command);\n    }\n    return 0;\n  }\n  process_id = _getpid_r();\n  kill_result = _kill_r(output,process_id,command,param_4);\n  return kill_result;\n}\n\n",
            "called": [
                "_getpid_r",
                "_kill_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f98",
            "calling": [
                "raise"
            ],
            "imported": false,
            "current_name": "execute_command_08009f98"
        },
        "FUN_0800a18c": {
            "renaming": {
                "FUN_0800a18c": "abort_program_0800a18c"
            },
            "code": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n/* std::abort_program_0800a18c() */\n\nvoid std::abort_program_0800a18c(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
            "called": [
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a18c",
            "calling": [
                "operator()"
            ],
            "imported": false,
            "current_name": "abort_program_0800a18c"
        },
        "FUN_08008a24": {
            "renaming": {
                "FUN_08008a24": "digital_io_output_08008a24",
                "ulPin": "pin_number",
                "ulVal": "pin_value",
                "_Var1": "is_pin_configured",
                "port": "gpio_port",
                "uVar2": "digital_pin",
                "is_pin_configured": "check_pin_configuration",
                "PinName_conflict": "conflicting_pin_name",
                "get_GPIO_Port": "retrieve_gpio_port",
                "digital_io_write": "write_digital_pin"
            },
            "code": "\nvoid digital_io_output_08008a24(uint32_t pin_number,uint32_t pin_value)\n\n{\n  _Bool is_pin_configured;\n  GPIO_TypeDef *gpio_port;\n  uint digital_pin;\n  \n  if (pin_number < 0x3c) {\n    digital_pin = (uint)(char)PTR_digitalPin_08008a64[pin_number];\n  }\n  else {\n    digital_pin = 0xffffffff;\n  }\n  if ((digital_pin != 0xffffffff) &&\n     (is_pin_configured = check_pin_configuration((conflicting_pin_name)digital_pin,(uint32_t *)PTR_g_digPinConfigured_08008a68)\n     , is_pin_configured)) {\n    gpio_port = retrieve_gpio_port((digital_pin << 0x18) >> 0x1c);\n    write_digital_pin(gpio_port,1 << (digital_pin & 0xf) & 0xffff,pin_value);\n  }\n  return;\n}\n\n",
            "called": [
                "digital_io_write",
                "get_GPIO_Port",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a24",
            "calling": [
                "strobeBlinkPin",
                "analogWrite",
                "digitalWriteCallback",
                "ServoIrqHandle",
                "setPinValueCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "digital_io_output_08008a24"
        },
        "FUN_08008020": {
            "renaming": {
                "FUN_08008020": "enable_i2c_listen_08008020",
                "hi2c": "i2c_handle",
                "piVar1": "i2c_obj",
                "isMaster": "is_master",
                "HAL_I2C_EnableListen_IT": "enable_i2c_listen_interrupt"
            },
            "code": "\nvoid enable_i2c_listen_08008020(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  i2c_t_conflict *i2c_obj;\n  \n  i2c_obj = get_i2c_obj(i2c_handle);\n  if (i2c_obj->is_master == '\\0') {\n    enable_i2c_listen_08008020_interrupt(i2c_handle);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008020",
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "imported": false,
            "current_name": "enable_i2c_listen_08008020"
        },
        "FUN_08005dac": {
            "renaming": {
                "FUN_08005dac": "configure_timer_output_compare_08005dac",
                "TIM_TypeDef_conflict": "timer_structure",
                "TIM_OC_InitTypeDef": "timer_output_compare_configuration",
                "TIMx": "timer",
                "OC_Config": "output_compare_config",
                "uVar1": "control_register_2",
                "uVar2": "output_compare_mode",
                "uVar3": "output_compare_polarity"
            },
            "code": "\nvoid configure_timer_output_compare_08005dac(timer_structure *timer,timer_output_compare_configuration *output_compare_config)\n\n{\n  uint32_t control_register_2;\n  uint32_t output_compare_mode;\n  uint32_t output_compare_polarity;\n  \n  timer->CCER = timer->CCER & 0xffffefff;\n  control_register_2 = timer->CR2;\n  output_compare_mode = output_compare_config->OCMode;\n  output_compare_polarity = output_compare_config->OCPolarity;\n  if (timer == DAT_08005df0) {\n    control_register_2 = control_register_2 & 0xffffbfff | output_compare_config->OCIdleState << 6;\n  }\n  timer->CR2 = control_register_2;\n  timer->CCMR2 = timer->CCMR2 & 0xffff8cff | output_compare_mode << 8;\n  timer->CCR4 = output_compare_config->Pulse;\n  timer->CCER = timer->CCER & 0xffffdfff | output_compare_polarity << 0xc;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005dac",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_output_compare_08005dac"
        },
        "FUN_080066e8": {
            "renaming": {
                "FUN_080066e8": "check_uart_flag_080066e8",
                "huart": "UART_handle",
                "Flag": "flag_to_check",
                "Status": "desired_status",
                "Tickstart": "start_time",
                "Timeout": "timeout_duration",
                "uVar1": "tick_count"
            },
            "code": "\nHAL_desired_statusTypeDef_conflict\ncheck_uart_flag_080066e8(UART_HandleTypeDef *UART_handle,uint32_t flag_to_check,flag_to_checkdesired_status desired_status,uint32_t start_time,\n          uint32_t timeout_duration)\n\n{\n  uint32_t tick_count;\n  \n  do {\n    if (((flag_to_check & ~UART_handle->Instance->SR) == 0) != (bool)desired_status) {\n      return HAL_OK;\n    }\n  } while ((timeout_duration == 0xffffffff) ||\n          ((timeout_duration != 0 && (tick_count = HAL_GetTick(), tick_count - start_time <= timeout_duration))));\n  UART_handle->Instance->CR1 = UART_handle->Instance->CR1 & 0xfffffe5f;\n  UART_handle->Instance->CR3 = UART_handle->Instance->CR3 & 0xfffffffe;\n  UART_handle->gState = HAL_UART_STATE_READY;\n  UART_handle->RxState = HAL_UART_STATE_READY;\n  UART_handle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080066e8",
            "calling": [
                "HAL_UART_Transmit"
            ],
            "imported": false,
            "current_name": "check_uart_flag_080066e8"
        },
        "FUN_08009358": {
            "renaming": {
                "FUN_08009358": "write_to_stream_08009358",
                "param_1": "stream",
                "param_2": "buffer",
                "param_3": "data",
                "param_4": "size",
                "puVar2": "end_of_data",
                "iVar3": "remaining_size",
                "iVar1": "bytes_written"
            },
            "code": "\nint write_to_stream_08009358(undefined4 stream,undefined4 buffer,undefined *data,int size)\n\n{\n  int bytes_written;\n  undefined *end_of_data;\n  int remaining_size;\n  \n  end_of_data = data + size;\n  remaining_size = size;\n  do {\n    if (data == end_of_data) {\n      return 0;\n    }\n    bytes_written = __sfputc_r(stream,*data,buffer,size,remaining_size);\n    size = bytes_written + 1;\n    data = data + 1;\n  } while (size != 0);\n  return bytes_written;\n}\n\n",
            "called": [
                "__sfputc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009358",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_08009358"
        },
        "FUN_0800270c": {
            "renaming": {
                "FUN_0800270c": "calculate_buffer_space_0800270c",
                "this": "wire"
            },
            "code": "\nint __wirecall TwoWire::calculate_buffer_space_0800270c(TwoWire *wire)\n\n{\n  return (uint)(byte)*PTR_rxBufferLength_08002718 - (uint)(byte)*PTR_rxBufferIndex_0800271c;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800270c",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "calculate_buffer_space_0800270c"
        },
        "FUN_08007fa0": {
            "renaming": {
                "FUN_08007fa0": "i2c_data_transfer_08007fa0",
                "hi2c": "i2c_handle",
                "TransferDirection": "transfer_direction",
                "AddrMatchCode": "addr_match_code",
                "piVar1": "i2c_object",
                "get_i2c_obj": "get_i2c_object",
                "i2cTxRxBufferSize": "tx_rx_buffer_size",
                "slaveMode": "slave_mode",
                "i2c_onSlaveTransmit": "on_slave_transmit_callback",
                "HAL_I2C_Slave_Sequential_Transmit_IT": "transmit_data_sequentially",
                "i2cTxRxBuffer": "tx_rx_buffer",
                "HAL_I2C_Slave_Sequential_Receive_IT": "receive_data_sequentially"
            },
            "code": "\nvoid i2c_data_transfer_08007fa0(I2C_HandleTypeDef_conflict *i2c_handle,uint8_t transfer_direction,uint16_t addr_match_code)\n\n{\n  i2c_t_conflict *i2c_object;\n  \n  i2c_object = get_i2c_object(i2c_handle);\n  if ((uint)addr_match_code == (i2c_handle->Init).OwnAddress1) {\n    if (transfer_direction == '\\0') {\n      i2c_object->tx_rx_buffer_size = '\\0';\n      i2c_object->slave_mode = '\\0';\n      if (i2c_object->on_slave_transmit_callback != (_func_void *)0x0) {\n        (*i2c_object->on_slave_transmit_callback)();\n      }\n      transmit_data_sequentially\n                (i2c_handle,i2c_object->tx_rx_buffer,(ushort)i2c_object->tx_rx_buffer_size,8);\n      return;\n    }\n    i2c_object->slave_mode = '\\x01';\n    receive_data_sequentially(i2c_handle,i2c_object->tx_rx_buffer,0x20,8);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007fa0",
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "imported": false,
            "current_name": "i2c_data_transfer_08007fa0"
        },
        "FUN_08002720": {
            "renaming": {
                "this": "wire",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numberOfBytes",
                "bVar1": "currentIndex",
                "bVar2": "currentByte",
                "(uint)bVar2": "currentByteAsUnsigned",
                "FUN_08002720": "read_byte_08002720"
            },
            "code": "\nssize_t __wirecall TwoWire::readByte_08002720(TwoWire *wire,int fileDescriptor,void *buffer,size_t numberOfBytes)\n\n{\n  byte currentIndex;\n  byte currentByte;\n  \n  currentIndex = *PTR_rxBufferIndex_08002740;\n  if ((uint)currentIndex < (uint)(byte)*PTR_rxBufferLength_08002744) {\n    currentByte = *(byte *)(*(int *)PTR_rxBuffer_08002748 + (uint)currentIndex);\n    *PTR_rxBufferIndex_08002740 = currentIndex + 1;\n    return currentByteAsUnsigned;\n  }\n  return -1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002720",
            "calling": [
                "wireRead"
            ],
            "imported": false,
            "current_name": "read_byte_08002720"
        },
        "FUN_080031ce": {
            "renaming": {
                "this": "marshaller",
                "major": "majorVersion",
                "minor": "minorVersion",
                "bytec": "byteCount",
                "bytev": "byteValues",
                "_func_int_varargs": "functionPointer",
                "p_Var1": "printFunctionPointer",
                "uVar2": "iterator",
                "FirmataStream": "firmataStream",
                "Stream": "DataStream",
                "FUN_080031ce": "send_firmata_message_080031ce"
            },
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080031e8 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendFirmataMessage_080031ce(FirmataMarshaller *marshaller,uint8_t majorVersion,uint8_t minorVersion,size_t byteCount,uint8_t *byteValues)\n\n{\n  functionPointer *printFunctionPointer;\n  uint iterator;\n  \n  if (marshaller->firmataStream != (DataStream *)0x0) {\n    printFunctionPointer = *(marshaller->firmataStream->super_Print)._vptr_Print;\n    (*printFunctionPointer)(marshaller,0xf0,(uint)minorVersion,printFunctionPointer,byteCount);\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream,0x79);\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream,(uint)majorVersion);\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream,(uint)minorVersion);\n    for (iterator = 0; iterator < byteCount; iterator = iterator + 1) {\n      encodeByteDataStream(marshaller,1,byteValues + iterator,0);\n    }\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream,0xf7);\n  }\n  return;\n}\n\n",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080031ce",
            "calling": [
                "printFirmwareVersion"
            ],
            "imported": false,
            "current_name": "send_firmata_message_080031ce"
        },
        "FUN_08008b52": {
            "renaming": {
                "this": "serial_object",
                "FUN_08008b52": "check_serial_transmission_complete_08008b52"
            },
            "code": "\nvoid __serial_objectcall HardwareSerial::check_serial_transmission_complete_08008b52(HardwareSerial *serial_object)\n\n{\n  if (serial_object->_written != false) {\n    do {\n    } while ((serial_object->_serial).tx_head != (serial_object->_serial).tx_tail);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b52",
            "calling": [],
            "imported": false,
            "current_name": "check_serial_transmission_complete_08008b52"
        },
        "FUN_08002968": {
            "renaming": {
                "this": "wire",
                "address": "deviceAddress",
                "i2c_t": "i2cObject",
                "memset": "clearBuffer",
                "uint32_t": "uint32",
                "uint8_t": "uint8",
                "true": "MASTER_MODE",
                "false": "SLAVE_MODE",
                "_i2c": "i2c",
                "i2c_t_conflict": "i2cConfig",
                "i2c_custom_init": "initializeI2CConfig",
                "i2c_attachSlaveTxEvent": "attachSlaveTxEvent",
                "i2c_attachSlaveRxEvent": "attachSlaveRxEvent",
                "FUN_08002968": "initialize_i2_c_08002968"
            },
            "code": "\nvoid __wirecall TwoWire::initializeI2C_08002968(TwoWire *wire,uint8 deviceAddress)\n\n{\n  uint32 ownAddress;\n  i2cObject *obj;\n  \n  *PTR_rxBufferIndex_080029ec = 0;\n  *PTR_rxBufferLength_080029f0 = 0;\n  if (*(void **)PTR_rxBuffer_080029f4 != (void *)0x0) {\n    clearBuffer(*(void **)PTR_rxBuffer_080029f4,0,(uint)(byte)*PTR_rxBufferAllocated_080029f8);\n  }\n  *PTR_txBufferIndex_080029fc = 0;\n  *PTR_txBufferLength_08002a00 = 0;\n  if (*(void **)PTR_txBuffer_08002a04 != (void *)0x0) {\n    clearBuffer(*(void **)PTR_txBuffer_08002a04,0,(uint)(byte)*PTR_txBufferAllocated_08002a08);\n  }\n  *PTR_transmitting_08002a0c = 0;\n  ownAddress = (deviceAddress & 0x7f) << 1;\n  wire->ownAddress = (uint8)ownAddress;\n  if (deviceAddress == 0x33) {\n    wire->master = MASTER_MODE;\n  }\n  else {\n    wire->master = SLAVE_MODE;\n  }\n  obj = &wire->i2c;\n  initializeI2C_08002968Config((i2cConfig *)obj,DAT_08002a10,0x4000,ownAddress,wire->master);\n  if (wire->master == SLAVE_MODE) {\n    attachSlaveTxEvent((i2cConfig *)obj,DAT_08002a14);\n    attachSlaveRxEvent((i2cConfig *)obj,DAT_08002a18);\n  }\n  return;\n}\n\n",
            "called": [
                "i2c_attachSlaveRxEvent",
                "i2c_attachSlaveTxEvent",
                "memset",
                "i2c_custom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002968",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initialize_i2_c_08002968"
        },
        "FUN_08004ccc": {
            "renaming": {
                "FUN_08004ccc": "handle_i2_c_transfer_08004ccc",
                "hi2c": "I2C_handle",
                "uVar1": "transfer_options",
                "pbVar2": "buffer_pointer",
                "HAL_StatusTypeDef_conflict": "I2C_status",
                "I2C_HandleTypeDef_conflict": "I2C_handle",
                "XferOptions": "transfer_options",
                "State": "transfer_state",
                "HAL_I2C_STATE_BUSY_TX": "busy_transmitting",
                "XferCount": "transfer_count",
                "Instance": "peripheral_instance",
                "CR2": "control_register_2",
                "CR1": "control_register_1",
                "PreviousState": "previous_transfer_state",
                "HAL_I2C_MODE_MEM": "memory_mode",
                "HAL_I2C_MODE_NONE": "no_mode",
                "Mode": "transfer_mode",
                "HAL_I2C_MasterTxCpltCallback": "master_transmit_complete_callback",
                "HAL_I2C_MemTxCpltCallback": "memory_transmit_complete_callback",
                "DR": "data_register",
                "HAL_OK": "successful_operation"
            },
            "code": "\nI2C_status handle_I2C_transfer_08004ccc(I2C_handle *I2C_handle)\n\n{\n  uint32_t transfer_options;\n  byte *buffer_pointer;\n  \n  transfer_options = I2C_handle->transfer_options;\n  if (I2C_handle->transfer_state == busy_transmitting) {\n    if (I2C_handle->transfer_count == 0) {\n      if (((transfer_options == 4) || (transfer_options == 8)) || (transfer_options == 0xffff0000)) {\n        I2C_handle->peripheral_instance->control_register_2 = I2C_handle->peripheral_instance->control_register_2 & 0xfffff8ff;\n        I2C_handle->peripheral_instance->control_register_1 = I2C_handle->peripheral_instance->control_register_1 | 0x200;\n        I2C_handle->previous_transfer_state = 0;\n        I2C_handle->transfer_state = HAL_I2C_STATE_READY;\n        if (I2C_handle->transfer_mode == memory_mode) {\n          I2C_handle->transfer_mode = no_mode;\n          memory_transmit_complete_callback(I2C_handle);\n        }\n        else {\n          I2C_handle->transfer_mode = no_mode;\n          master_transmit_complete_callback(I2C_handle);\n        }\n      }\n      else {\n        I2C_handle->peripheral_instance->control_register_2 = I2C_handle->peripheral_instance->control_register_2 & 0xfffff8ff;\n        I2C_handle->previous_transfer_state = 0x11;\n        I2C_handle->transfer_mode = no_mode;\n        I2C_handle->transfer_state = HAL_I2C_STATE_READY;\n        master_transmit_complete_callback(I2C_handle);\n      }\n    }\n    else {\n      buffer_pointer = I2C_handle->pBuffPtr;\n      I2C_handle->pBuffPtr = buffer_pointer + 1;\n      I2C_handle->peripheral_instance->data_register = (uint)*buffer_pointer;\n      I2C_handle->transfer_count = I2C_handle->transfer_count - 1;\n    }\n  }\n  return successful_operation;\n}\n\n",
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ccc",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2_c_transfer_08004ccc"
        },
        "FUN_080042d4": {
            "renaming": {
                "FUN_080042d4": "check_gpio_pin_state_080042d4",
                "GPIOx": "GPIO_port",
                "GPIO_Pin": "GPIO_Pin_num",
                "IDR": "input_data_register",
                "GPIO_PIN_RESET": "LOW",
                "GPIO_PIN_SET": "HIGH"
            },
            "code": "\nGPIO_Pin_numState check_GPIO_PinState_080042d4(GPIO_TypeDef *GPIO_port,uint16_t GPIO_Pin_num)\n\n{\n  if (((uint)GPIO_Pin_num & GPIO_port->input_data_register) == 0) {\n    return LOW;\n  }\n  return HIGH;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042d4",
            "calling": [
                "digital_io_read"
            ],
            "imported": false,
            "current_name": "check_gpio_pin_state_080042d4"
        },
        "FUN_0800a07a": {
            "renaming": {
                "FUN_0800a07a": "file_seek_0800a07a",
                "param_1": "file_descriptor",
                "param_2": "seek_info",
                "iVar1": "file_position",
                "uVar2": "seek_flags",
                "bVar3": "seek_failed"
            },
            "code": "\nvoid file_seek_0800a07a(undefined4 file_descriptor,int seek_info)\n\n{\n  int file_position;\n  ushort seek_flags;\n  bool seek_failed;\n  \n  file_position = _lseek_r(file_descriptor,(int)*(short *)(seek_info + 0xe));\n  seek_failed = file_position == -1;\n  if (seek_failed) {\n    seek_flags = *(ushort *)(seek_info + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(seek_info + 0x54) = file_position;\n    seek_flags = *(ushort *)(seek_info + 0xc) | 0x1000;\n  }\n  if (seek_failed) {\n    *(ushort *)(seek_info + 0xc) = seek_flags;\n  }\n  if (!seek_failed) {\n    *(ushort *)(seek_info + 0xc) = seek_flags;\n  }\n  return;\n}\n\n",
            "called": [
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a07a",
            "calling": [],
            "imported": false,
            "current_name": "file_seek_0800a07a"
        },
        "FUN_080064b0": {
            "renaming": {
                "FUN_080064b0": "reset_uart_080064b0",
                "huart": "uart_handler",
                "Instance": "uart_instance",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "RxState": "receive_state"
            },
            "code": "\nvoid reset_uart_080064b0(UART_HandleTypeDef *uart_handler)\n\n{\n  uart_handler->uart_instance->control_register_1 = uart_handler->uart_instance->control_register_1 & 0xfffffedf;\n  uart_handler->uart_instance->control_register_3 = uart_handler->uart_instance->control_register_3 & 0xfffffffe;\n  uart_handler->receive_state = HAL_UART_STATE_READY;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064b0",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "reset_uart_080064b0"
        },
        "FUN_08006092": {
            "renaming": {
                "FUN_08006092": "configure_timer_08006092",
                "htim": "timer_handle",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_TIM_STATE_RESET": "TIM_RESET",
                "HAL_UNLOCKED": "TIM_UNLOCKED",
                "HAL_TIM_STATE_BUSY": "TIM_BUSY",
                "HAL_TIM_STATE_READY": "TIM_READY",
                "HAL_TIM_PWM_MspInit": "initialize_pwm",
                "TIM_Base_SetConfig": "set_timer_config",
                "Instance": "timer_instance",
                "Init": "timer_init"
            },
            "code": "\nHAL_StatusTypeDef configure_timer_08006092(TIM_HandleTypeDef *timer_handle)\n\n{\n  if (timer_handle != (TIM_HandleTypeDef *)0x0) {\n    if (timer_handle->State == TIM_RESET) {\n      timer_handle->Lock = TIM_UNLOCKED;\n      initialize_pwm(timer_handle);\n    }\n    timer_handle->State = TIM_BUSY;\n    set_timer_config(timer_handle->timer_instance,&timer_handle->timer_init);\n    timer_handle->State = TIM_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006092",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configure_timer_08006092"
        },
        "FUN_08008d8c": {
            "renaming": {
                "FUN_08008d8c": "initialize_serial_port_08008d8c",
                "__initialize_p": "is_initialized",
                "__priority": "priority_level"
            },
            "code": "\nvoid initialize_serial_port_08008d8c(int is_initialized,int priority_level)\n\n{\n  if (is_initialized != 1) {\n    return;\n  }\n  if (priority_level == 0xffff) {\n    HardwareSerial::HardwareSerial((HardwareSerial *)PTR_Serial2_08008dac,DAT_08008da8);\n  }\n  return;\n}\n\n",
            "called": [
                "HardwareSerial"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d8c",
            "calling": [
                "_GLOBAL__sub_I_Serial2"
            ],
            "imported": false,
            "current_name": "initialize_serial_port_08008d8c"
        },
        "FUN_08008038": {
            "renaming": {
                "FUN_08008038": "handle_i2c_event_interrupt_08008038"
            },
            "code": "\nvoid handle_i2c_event_interrupt_08008038(void)\n\n{\n  HAL_I2C_EV_IRQHandler(*(I2C_HandleTypeDef_conflict **)PTR_i2c_handles_08008044);\n  return;\n}\n\n",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008038",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_event_interrupt_08008038"
        },
        "FUN_08009124": {
            "renaming": {
                "FUN_08009124": "print_formatted_output_08009124",
                "__stream": "output_file",
                "__format": "format_string",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "uStack_8": "arg4",
                "uStack_4": "arg5"
            },
            "code": "\nint print_formatted_output_08009124(FILE *output_file,char *format_string,...)\n\n{\n  int iVar1;\n  undefined4 arg2;\n  undefined4 arg3;\n  undefined4 arg4;\n  undefined4 arg5;\n  \n  arg4 = arg2;\n  arg5 = arg3;\n  iVar1 = _vprint_formatted_output_08009124_r(*(undefined4 *)PTR__impure_ptr_08009144,output_file,format_string,&arg4,output_file,\n                       &arg4);\n  return iVar1;\n}\n\n",
            "called": [
                "_vfiprintf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009124",
            "calling": [
                "__assert_func"
            ],
            "imported": false,
            "current_name": "print_formatted_output_08009124"
        },
        "FUN_080064ae": {
            "renaming": {
                "FUN_080064ae": "do_nothing_080064ae"
            },
            "code": "\nvoid do_nothing_080064ae(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064ae",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080064ae"
        },
        "FUN_080064ac": {
            "renaming": {
                "FUN_080064ac": "do_nothing_080064ac"
            },
            "code": "\nvoid do_nothing_080064ac(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064ac",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080064ac"
        },
        "FUN_08005cb4": {
            "renaming": {
                "hrtc": "rtc_handle",
                "HAL_RTC_AlarmAEventCallback": "handle_alarm_event",
                "CRH": "control_high_register",
                "CRL": "control_low_register",
                "State": "rtc_state",
                "FUN_08005cb4": "handle_rtc_interrupt_08005cb4"
            },
            "code": "\nvoid handle_rtc_interrupt_08005cb4(RTC_HandleTypeDef *rtc_handle)\n\n{\n  if (((rtc_handle->Instance->control_high_register & 2) != 0) && ((rtc_handle->Instance->control_low_register & 2) != 0)) {\n    handle_alarm_event(rtc_handle);\n    rtc_handle->Instance->control_low_register = 0xfffffffd;\n  }\n  *(undefined4 *)(DAT_08005ce8 + 0x14) = 0x20000;\n  rtc_handle->rtc_state = HAL_RTC_STATE_READY;\n  return;\n}\n\n",
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cb4",
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_rtc_interrupt_08005cb4"
        },
        "FUN_080042e2": {
            "renaming": {
                "FUN_080042e2": "set_gpio_pin_state_080042e2",
                "GPIOx": "gpio_port",
                "GPIO_Pin": "gpio_pin",
                "PinState": "pin_state",
                "BSRR": "bit_set_reset_register"
            },
            "code": "\nvoid set_gpio_pin_state_080042e2(GPIO_TypeDef *gpio_port,uint16_t gpio_pin,gpio_pinState pin_state)\n\n{\n  if (pin_state == GPIO_PIN_RESET) {\n    gpio_port->bit_set_reset_register = (uint)gpio_pin << 0x10;\n    return;\n  }\n  gpio_port->bit_set_reset_register = (uint)gpio_pin;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042e2",
            "calling": [
                "digital_io_write"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_080042e2"
        },
        "FUN_080088e0": {
            "renaming": {
                "FUN_080088e0": "set_pwm_output_080088e0",
                "ulPin": "pin_number",
                "ulValue": "duty_cycle",
                "_Var1": "pin_mapped",
                "uVar2": "write_resolution",
                "pin": "mapped_pin",
                "NC": "not_connected",
                "pin_in_pinmap": "is_pin_mapped",
                "PinMap_conflict": "mapped_pin_name",
                "is_pin_configured": "is_pin_configured_for_pwm",
                "set_pin_configured": "set_pin_configured_for_pwm",
                "pwm_start": "start_pwm_output",
                "pinMode": "set_pin_mode",
                "digitalWrite": "write_digital_pin"
            },
            "code": "\nvoid set_pwm_output_080088e0(uint32_t pin_number,uint32_t duty_cycle)\n\n{\n  _Bool pin_mapped;\n  uint write_resolution;\n  PinName_conflict mapped_pin;\n  \n  if (pin_number < 0x3c) {\n    mapped_pin = PTR_digitalPin_0800897c[pin_number];\n  }\n  else {\n    mapped_pin = not_connected;\n  }\n  if (mapped_pin != not_connected) {\n    pin_mapped = is_pin_mapped(mapped_pin,(mapped_pin_name *)PTR_PinMap_PWM_08008980);\n    if (pin_mapped) {\n      pin_mapped = is_pin_configured_for_pwm(mapped_pin,(uint32_t *)PTR_g_anOutputPinConfigured_08008984);\n      if (!pin_mapped) {\n        set_pin_configured_for_pwm(mapped_pin,(uint32_t *)PTR_g_anOutputPinConfigured_08008984);\n      }\n      write_resolution = *(uint *)PTR__writeResolution_08008988;\n      if (write_resolution != 8) {\n        if (write_resolution < 9) {\n          duty_cycle = duty_cycle << (8 - write_resolution & 0xff);\n        }\n        else {\n          duty_cycle = duty_cycle >> (write_resolution - 8 & 0xff);\n        }\n      }\n      start_pwm_output(mapped_pin,DAT_0800898c,0xff,duty_cycle,!pin_mapped);\n    }\n    else {\n      set_pin_mode(pin_number,1);\n      write_resolution = *(uint *)PTR__writeResolution_08008988;\n      if (write_resolution != 8) {\n        if (write_resolution < 9) {\n          duty_cycle = duty_cycle << (8 - write_resolution & 0xff);\n        }\n        else {\n          duty_cycle = duty_cycle >> (write_resolution - 8 & 0xff);\n        }\n      }\n      if (duty_cycle < 0x80) {\n        write_digital_pin(pin_number,0);\n      }\n      else {\n        write_digital_pin(pin_number,1);\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "pin_in_pinmap",
                "set_pin_configured",
                "digitalWrite",
                "pinMode",
                "pwm_start",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080088e0",
            "calling": [
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "set_pwm_output_080088e0"
        },
        "FUN_08008b66": {
            "renaming": {
                "obj": "serial_object",
                "iVar1": "read_status",
                "uVar2": "next_rx_index",
                "FUN_08008b66": "read_serial_data_08008b66"
            },
            "code": "\nvoid HardwareSerial::read_serial_data_08008b66(serial_t_conflict *serial_object)\n\n{\n  int read_status;\n  ushort next_rx_index;\n  uchar c;\n  \n  read_status = uart_getc((serial_t *)serial_object,&c);\n  if ((read_status == 0) && (next_rx_index = serial_object->rx_head + 1 & 0x3f, next_rx_index != serial_object->rx_tail)) {\n    serial_object->rx_buff[serial_object->rx_head] = c;\n    serial_object->rx_head = next_rx_index;\n  }\n  return;\n}\n\n",
            "called": [
                "uart_getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b66",
            "calling": [],
            "imported": false,
            "current_name": "read_serial_data_08008b66"
        },
        "FUN_0800a3a0": {
            "renaming": {
                "ctype_byname": "set_pointers_to_one",
                "FUN_0800a3a0": "set_pointers_to_one_0800a3a0"
            },
            "code": "\n/* std::set_pointers_to_one_0800a3a0<char>::set_pointers_to_one_0800a3a0(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::set_pointers_to_one_0800a3a0<char>::set_pointers_to_one_0800a3a0(void)\n\n{\n  if (-1 < *(int *)PTR_id_0800a404 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a404 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a408 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a408 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a40c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a40c = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a410 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a410 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a414 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a414 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a418 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a418 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a41c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a41c = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a420 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a420 = 1;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a3a0",
            "calling": [],
            "imported": false,
            "current_name": "set_pointers_to_one_0800a3a0"
        },
        "FUN_08008048": {
            "renaming": {
                "FUN_08008048": "handle_i2c_error_interrupt_08008048"
            },
            "code": "\nvoid handle_i2c_error_interrupt_08008048(void)\n\n{\n  HAL_I2C_ER_IRQHandler(*(I2C_HandleTypeDef_conflict **)PTR_i2c_handles_08008054);\n  return;\n}\n\n",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008048",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_error_interrupt_08008048"
        },
        "FUN_080053cc": {
            "renaming": {
                "FUN_080053cc": "reset_i2_c_dma_transfer_080053cc",
                "hdma": "dma_handle",
                "hi2c": "i2c_handle",
                "Instance": "i2c_instance",
                "XferCount": "transfer_count",
                "hdmatx": "dma_tx_handle",
                "hdmarx": "dma_rx_handle",
                "State": "i2c_state",
                "Mode": "i2c_mode",
                "ErrorCode": "i2c_error_code",
                "HAL_I2C_STATE_ABORT": "HAL_I2C_STATE_ABORTED",
                "CR1": "i2c_control_register",
                "HAL_I2C_ErrorCallback": "i2c_error_callback",
                "HAL_I2C_AbortCpltCallback": "i2c_abort_complete_callback"
            },
            "code": "\nvoid reset_I2C_DMA_transfer_080053cc(DMA_HandleTypeDef_conflict *dma_handle)\n\n{\n  I2C_HandleTypeDef_conflict *i2c_handle;\n  \n  i2c_handle = (I2C_HandleTypeDef_conflict *)dma_handle->Parent;\n  i2c_handle->i2c_instance->i2c_control_register = i2c_handle->i2c_instance->i2c_control_register & 0xfffffbff;\n  i2c_handle->transfer_count = 0;\n  i2c_handle->dma_tx_handle->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0;\n  i2c_handle->dma_rx_handle->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0;\n  if (i2c_handle->i2c_state != HAL_I2C_STATE_ABORTED) {\n    i2c_handle->i2c_state = HAL_I2C_STATE_READY;\n    i2c_handle->i2c_mode = HAL_I2C_MODE_NONE;\n    i2c_handle->i2c_instance->i2c_control_register = i2c_handle->i2c_instance->i2c_control_register & 0xfffffffe;\n    i2c_error_callback(i2c_handle);\n    return;\n  }\n  i2c_handle->i2c_state = HAL_I2C_STATE_READY;\n  i2c_handle->i2c_mode = HAL_I2C_MODE_NONE;\n  i2c_handle->i2c_error_code = 0;\n  i2c_handle->i2c_instance->i2c_control_register = i2c_handle->i2c_instance->i2c_control_register & 0xfffffffe;\n  i2c_abort_complete_callback(i2c_handle);\n  return;\n}\n\n",
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053cc",
            "calling": [],
            "imported": false,
            "current_name": "reset_i2_c_dma_transfer_080053cc"
        },
        "FUN_080087bc": {
            "renaming": {
                "FUN_080087bc": "handle_uart_interrupt_080087bc",
                "USART1_IRQn": "uart1_interrupt"
            },
            "code": "\nvoid handle_uart_interrupt_080087bc(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(uart1_interrupt);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)PTR_uart_handlers_080087d0);\n  return;\n}\n\n",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087bc",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_080087bc"
        },
        "FUN_080042f0": {
            "renaming": {
                "FUN_080042f0": "update_gpio_pin_state_080042f0",
                "GPIO_Pin": "pin_number",
                "HAL_GPIO_EXTI_Callback": "handle_gpio_interrupt"
            },
            "code": "\nvoid update_gpio_pin_state_080042f0(uint16_t pin_number)\n\n{\n  if ((*(uint *)(DAT_08004308 + 0x14) & (uint)pin_number) != 0) {\n    *(uint *)(DAT_08004308 + 0x14) = (uint)pin_number;\n    handle_gpio_interrupt(pin_number);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042f0",
            "calling": [
                "EXTI2_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI1_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI15_10_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI4_IRQHandler"
            ],
            "imported": false,
            "current_name": "update_gpio_pin_state_080042f0"
        },
        "FUN_080087d4": {
            "renaming": {
                "FUN_080087d4": "handle_uart_interrupt_080087d4",
                "USART2_IRQn": "UART_IRQn",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "HAL_UART_IRQHandler": "handle_UART_IRQ"
            },
            "code": "\nvoid handle_UART_interrupt_080087d4(void)\n\n{\n  clear_pending_IRQ(UART_IRQn);\n  handle_UART_IRQ(*(UART_HandleTypeDef **)(PTR_uart_handlers_080087e8 + 4));\n  return;\n}\n\n",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087d4",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_080087d4"
        },
        "FUN_0800a09e": {
            "renaming": {
                "FUN_0800a09e": "close_file_descriptor_0800a09e",
                "param_1": "file_descriptor",
                "param_2": "buffer_address",
                "_close_r": "close"
            },
            "code": "\nvoid close_file_descriptor_0800a09e(undefined4 file_descriptor,int buffer_address)\n\n{\n  close(file_descriptor,(int)*(short *)(buffer_address + 0xe));\n  return;\n}\n\n",
            "called": [
                "_close_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a09e",
            "calling": [],
            "imported": false,
            "current_name": "close_file_descriptor_0800a09e"
        },
        "FUN_080076e0": {
            "renaming": {
                "FUN_080076e0": "disable_timer_interrupts_080076e0",
                "obj": "timer_object",
                "HAL_StatusTypeDef_conflict": "HAL_status",
                "HVar1": "hal_status",
                "uVar2": "irq_number",
                "_func_void_stimer_t_ptr_uint32_t_conflict": "irq_handler",
                "getTimerIrq": "get_timer_irq_number",
                "HAL_NVIC_DisableIRQ": "disable_irq",
                "IRQn_Type_conflict": "irq_type",
                "HAL_TIM_OC_DeInit": "deinitialize_timer_oc",
                "HAL_OK": "HAL_success",
                "HAL_TIM_OC_Stop_IT": "stop_timer_oc_interrupt"
            },
            "code": "\nvoid disable_timer_interrupts_080076e0(stimer_t_conflict *timer_object)\n\n{\n  HAL_status hal_status;\n  uint32_t irq_number;\n  \n  timer_object->irqHandleOC = (irq_handler *)0x0;\n  irq_number = get_timer_irq_number(timer_object->timer);\n  disable_irq((irq_type)irq_number);\n  hal_status = deinitialize_timer_oc(&timer_object->handle);\n  if (hal_status == HAL_success) {\n    stop_timer_oc_interrupt(&timer_object->handle,0);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_TIM_OC_DeInit",
                "getTimerIrq",
                "HAL_TIM_OC_Stop_IT",
                "HAL_NVIC_DisableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080076e0",
            "calling": [
                "finISR"
            ],
            "imported": false,
            "current_name": "disable_timer_interrupts_080076e0"
        },
        "FUN_08002f14": {
            "renaming": {
                "this": "firmataInstance",
                "string": "message",
                "FUN_08002f14": "send_string_to_marshaller_08002f14"
            },
            "code": "\nvoid __firmataInstancecall firmata::FirmataClass::sendStringToMarshaller_08002f14(FirmataClass *firmataInstance,char *message)\n\n{\n  FirmataMarshaller::sendStringToMarshaller_08002f14(&firmataInstance->marshaller,message);\n  return;\n}\n\n",
            "called": [
                "sendString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f14",
            "calling": [
                "attachServo",
                "sysexCallback",
                "readAndReportData",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "send_string_to_marshaller_08002f14"
        }
    },
    "used_tokens": 240585,
    "layers": [
        [
            "FUN_08007246",
            "FUN_0800a042",
            "FUN_08008e4e",
            "FUN_08008694",
            "FUN_08005188",
            "FUN_08001bf8",
            "FUN_080069ec",
            "FUN_0800a168",
            "FUN_080067ac",
            "FUN_0800735a",
            "FUN_08008c20",
            "FUN_0800723c",
            "FUN_080043a2",
            "FUN_08006280",
            "FUN_08007258",
            "FUN_08009f4c",
            "FUN_08006c7c",
            "FUN_08006b5c",
            "FUN_08007376",
            "FUN_080033cc",
            "FUN_08003de4",
            "FUN_08000500",
            "FUN_08009d24",
            "FUN_08008e72",
            "FUN_080022f8",
            "FUN_08005084",
            "FUN_08008b0e",
            "FUN_0800291c",
            "FUN_080032bc",
            "FUN_080077b0",
            "FUN_08008c44",
            "FUN_08006060",
            "FUN_08009698",
            "FUN_08006186",
            "FUN_08006b7c",
            "FUN_08008e7c",
            "FUN_0800a194",
            "FUN_08003aa0",
            "FUN_08005fe8",
            "FUN_08003ce8",
            "FUN_0800738a",
            "FUN_08002948",
            "FUN_08009e64",
            "FUN_08002acc",
            "FUN_0800932c",
            "FUN_080099a4",
            "FUN_08005a1c",
            "FUN_08006b0c",
            "FUN_08001cd0",
            "FUN_08007320",
            "FUN_080002ec",
            "FUN_08000be8",
            "FUN_08003fd8",
            "FUN_0800307a",
            "FUN_08002ca4",
            "FUN_0800319e",
            "FUN_08008d00",
            "FUN_08004b82",
            "FUN_0800997e",
            "FUN_0800779c",
            "FUN_08002dbc",
            "FUN_08007f78",
            "FUN_08006b28",
            "FUN_08006b1c",
            "FUN_0800a130",
            "FUN_08008f3c",
            "FUN_08007332",
            "FUN_08006128",
            "FUN_0800a258",
            "FUN_08002cb8",
            "FUN_08008f50",
            "FUN_08004a76",
            "FUN_0800877c",
            "FUN_080047f4",
            "FUN_08005a48",
            "FUN_080033a8",
            "FUN_08008d18",
            "FUN_0800a020",
            "FUN_08007f7c",
            "FUN_08006d80",
            "FUN_08006c60",
            "FUN_08008e40",
            "FUN_080045c0",
            "FUN_08007e74",
            "FUN_08002ddc",
            "FUN_08009f2c",
            "FUN_0800a154",
            "FUN_08007f8e",
            "FUN_08006b3e",
            "FUN_08006262",
            "FUN_08007110",
            "FUN_08007594",
            "FUN_08002cd0",
            "FUN_08002df6",
            "FUN_08007118",
            "FUN_08001be8",
            "FUN_08005a68",
            "FUN_08008f78",
            "FUN_08002dea",
            "FUN_0800734a",
            "FUN_08000aec",
            "FUN_080068d6",
            "FUN_080032a2",
            "FUN_08009e28",
            "FUN_0800a01c",
            "FUN_08006390",
            "FUN_08008730",
            "FUN_08005460",
            "FUN_08008854",
            "FUN_08004d6c",
            "FUN_08007760",
            "FUN_08008850",
            "FUN_08002fc2",
            "FUN_08008afa",
            "FUN_080038dc",
            "FUN_080025ac",
            "FUN_08007648",
            "FUN_08008858",
            "FUN_08004a24",
            "FUN_08002fba",
            "FUN_080090cc",
            "FUN_080049e0",
            "FUN_08006d24",
            "FUN_08008500",
            "FUN_08007774",
            "FUN_080001a8",
            "FUN_080048c8",
            "FUN_08009954",
            "FUN_08005e6e",
            "FUN_08004024",
            "FUN_08008868",
            "FUN_080036ac",
            "FUN_0800643c",
            "FUN_08002fca",
            "FUN_0800a31c",
            "FUN_080026f8",
            "FUN_08007544",
            "FUN_08008990",
            "FUN_08004396",
            "FUN_08003fb0",
            "FUN_08007788",
            "FUN_08002ec4",
            "FUN_08007306",
            "FUN_08008f0e",
            "FUN_0800886c",
            "FUN_08006e68",
            "FUN_080036d8",
            "FUN_0800a110",
            "FUN_08003b8c",
            "FUN_080035b8",
            "FUN_08006460",
            "FUN_08004046",
            "FUN_08008880",
            "FUN_08002ed2",
            "FUN_08008f1c",
            "FUN_080058ac",
            "FUN_08007438",
            "FUN_0800306c",
            "FUN_0800887c",
            "FUN_0800863c",
            "FUN_08004050",
            "FUN_08008e14",
            "FUN_08005a28",
            "FUN_08008ac6",
            "FUN_08003366",
            "FUN_080091b0",
            "FUN_08008abc",
            "FUN_08002b68",
            "FUN_080005e0",
            "FUN_0800674e",
            "FUN_0800771c",
            "FUN_08003370",
            "FUN_08003376",
            "FUN_08008bf4",
            "FUN_08002c7c",
            "FUN_08005430",
            "FUN_08009918",
            "FUN_08005434",
            "FUN_08005e2e",
            "FUN_08007736",
            "FUN_08002c90",
            "FUN_0800542a",
            "FUN_0800457c",
            "FUN_080091c6",
            "FUN_08003a20",
            "FUN_08002a58",
            "FUN_080004d4",
            "FUN_080005f8",
            "FUN_08002fa0",
            "FUN_08003a1c",
            "FUN_08007744",
            "FUN_08006538",
            "FUN_08002fa8",
            "FUN_0800325a",
            "FUN_080091d8",
            "FUN_0800688e",
            "FUN_080090b4",
            "FUN_0800870c",
            "FUN_08008840",
            "FUN_08008600",
            "FUN_08003154",
            "FUN_08006420",
            "FUN_08007750",
            "FUN_08009938",
            "FUN_08007f0e",
            "FUN_08004004",
            "FUN_08003158",
            "FUN_080090c2",
            "FUN_08000ef8",
            "FUN_08008846",
            "FUN_0800459c",
            "FUN_0800774a",
            "FUN_0800314e",
            "FUN_080036a0",
            "FUN_080038e4",
            "FUN_08005d48",
            "FUN_08008ba4",
            "FUN_08009ff8",
            "FUN_08009db0",
            "FUN_08002c2c",
            "FUN_080072f0",
            "FUN_08000178",
            "FUN_08000a64",
            "FUN_08002c40",
            "FUN_0800694c",
            "FUN_0800a0ec",
            "FUN_08008df8",
            "FUN_08000188",
            "FUN_08004f3c",
            "FUN_0800344a",
            "FUN_080071e4",
            "FUN_08002c54",
            "FUN_080072fa",
            "FUN_08003346",
            "FUN_08003106",
            "FUN_08007708",
            "FUN_0800018c",
            "FUN_08003f94",
            "FUN_08002c68",
            "FUN_0800430c",
            "FUN_08003350",
            "FUN_08007710",
            "FUN_08003474",
            "FUN_08008804",
            "FUN_08004e3c",
            "FUN_08007718",
            "FUN_08002a30",
            "FUN_08009cd0",
            "FUN_0800322c",
            "FUN_08003760",
            "FUN_08000130",
            "FUN_08002798",
            "FUN_0800242c",
            "FUN_08002e44",
            "FUN_0800a0a8",
            "FUN_08003f30",
            "FUN_080073d8",
            "FUN_080085dc",
            "FUN_08008db0",
            "FUN_08002444",
            "FUN_0800906c",
            "FUN_08003658",
            "FUN_08009a80",
            "FUN_080062f4",
            "FUN_080073e8",
            "FUN_0800267c",
            "FUN_0800376c",
            "FUN_08003e20",
            "FUN_08005840",
            "FUN_08003306",
            "FUN_08002578",
            "FUN_08006932",
            "FUN_080060c4",
            "FUN_08009eac",
            "FUN_08008dbe",
            "FUN_080072d8",
            "FUN_08002b00",
            "FUN_08002f84",
            "FUN_08009094",
            "FUN_0800a0cc",
            "FUN_08002580",
            "FUN_080073ec",
            "FUN_08008ef4",
            "FUN_08002c1e",
            "FUN_08002f94",
            "FUN_08001b48",
            "FUN_08005df4",
            "FUN_08009148",
            "FUN_080099dc",
            "FUN_08000c18",
            "FUN_08009024",
            "FUN_080064cc",
            "FUN_08008058",
            "FUN_08004ac2",
            "FUN_08006ca8",
            "FUN_0800937c",
            "FUN_08000214",
            "FUN_08005bb8",
            "FUN_080063c0",
            "FUN_0800274c",
            "FUN_08009270",
            "FUN_08009038",
            "FUN_08005aa4",
            "FUN_08008068",
            "FUN_08002400",
            "FUN_08000588",
            "FUN_08002644",
            "FUN_08002f1e",
            "FUN_0800902e",
            "FUN_08009042",
            "FUN_08009c7c",
            "FUN_08009b5c",
            "FUN_08008a6c",
            "FUN_080085b8",
            "FUN_08001c08",
            "FUN_080075dc",
            "FUN_080087ec",
            "FUN_08007ff0",
            "FUN_08008078",
            "FUN_08002774",
            "FUN_080052f0",
            "FUN_08002f2c",
            "FUN_08004954",
            "FUN_08005cec",
            "FUN_08003748",
            "FUN_080040e8",
            "FUN_08009b6c",
            "FUN_0800010c",
            "FUN_080086e8",
            "FUN_08001c18",
            "FUN_08009056",
            "FUN_08002e1a",
            "FUN_0800904c",
            "FUN_080073ae",
            "FUN_08003f0c",
            "FUN_08000488",
            "FUN_08006bb8",
            "FUN_08004aec",
            "FUN_08007ede",
            "FUN_08004728",
            "FUN_080074e0",
            "FUN_080073c0",
            "FUN_080084b0",
            "FUN_080095a8",
            "FUN_08008b2a",
            "FUN_08003bd8",
            "FUN_08009d50",
            "FUN_08009108",
            "FUN_08009f98",
            "FUN_08008a24",
            "FUN_08008020",
            "FUN_08005dac",
            "FUN_080066e8",
            "FUN_08009358",
            "FUN_0800270c",
            "FUN_08007fa0",
            "FUN_08002720",
            "FUN_080031ce",
            "FUN_08008b52",
            "FUN_08002968",
            "FUN_08004ccc",
            "FUN_080042d4",
            "FUN_0800a07a",
            "FUN_080064b0",
            "FUN_08006092",
            "FUN_08008d8c",
            "FUN_08008038",
            "FUN_08005cb4",
            "FUN_080042e2",
            "FUN_080088e0",
            "FUN_08008b66",
            "FUN_0800a3a0",
            "FUN_08008048",
            "FUN_080053cc",
            "FUN_080087bc",
            "FUN_080042f0",
            "FUN_080087d4",
            "FUN_0800a09e",
            "FUN_080076e0"
        ],
        [
            "FUN_08002ce0",
            "FUN_08002ac0",
            "FUN_08002ef2",
            "FUN_08002efe",
            "FUN_08008d30",
            "FUN_08003048",
            "FUN_0800885c",
            "FUN_08003002",
            "FUN_08009908",
            "FUN_08009cdc",
            "FUN_080026b0",
            "FUN_080027f0",
            "FUN_080036a2",
            "FUN_08002a26",
            "FUN_080091a0",
            "FUN_08002a1c",
            "FUN_08009190",
            "FUN_08002c00",
            "FUN_08008ed6",
            "FUN_08002c14",
            "FUN_08009084",
            "FUN_08009fe8",
            "FUN_08008eec",
            "FUN_08003724",
            "FUN_08002f0a",
            "FUN_08002634",
            "FUN_080098d8",
            "FUN_0800288c",
            "FUN_08002e26",
            "FUN_0800a18c",
            "FUN_08009124",
            "FUN_08002f14"
        ]
    ],
    "locked_functions": []
}