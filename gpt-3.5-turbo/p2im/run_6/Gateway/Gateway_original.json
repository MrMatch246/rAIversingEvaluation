{
    "functions": {
        "setTx": {
            "renaming": {}, 
            "code": "\nvoid __thiscall HardwareSerial::setTx(HardwareSerial *this,uint32_t _tx)\n\n{\n  PinName PVar1;\n  \n  if (_tx < 0x3c) {\n    PVar1 = PTR_digitalPin_08008d2c[_tx];\n  }\n  else {\n    PVar1 = NC;\n  }\n  (this->_serial).pin_tx = PVar1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008d18", 
            "calling": [
                "HardwareSerial"
            ], 
            "imported": false, 
            "current_name": "setTx"
        }, 
        "HAL_RCC_GetSysClockFreq": {
            "renaming": {}, 
            "code": "\nuint HAL_RCC_GetSysClockFreq(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  undefined2 local_1c;\n  byte abStack_18 [4];\n  undefined4 uStack_14;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = *(undefined4 *)(PTR__etext_0800589c + 8);\n  uStack_10 = *(undefined4 *)(PTR__etext_0800589c + 4);\n  uStack_14 = *(undefined4 *)PTR__etext_0800589c;\n  local_1c = *(undefined2 *)(PTR__etext_0800589c + 0x10);\n  uVar2 = *(uint *)(DAT_080058a0 + 4);\n  uVar1 = DAT_080058a8;\n  if ((uVar2 & 0xc) == 8) {\n    if ((uVar2 & 0x10000) == 0) {\n      uVar1 = DAT_080058a4 * (uint)abStack_18[(uVar2 << 10) >> 0x1c];\n    }\n    else {\n      uVar1 = (DAT_080058a8 * abStack_18[(uVar2 << 10) >> 0x1c]) /\n              (uint)*(byte *)((int)&local_1c - ((*(int *)(DAT_080058a0 + 4) << 0xe) >> 0x1f));\n    }\n  }\n  return uVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005840", 
            "calling": [
                "HAL_RCC_ClockConfig"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetSysClockFreq"
        }, 
        "HAL_NVIC_SetPriorityGrouping": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)\n\n{\n  *(uint32_t *)(DAT_08003f2c + 0xc) =\n       (PriorityGroup & 7) << 8 | *(uint *)(DAT_08003f2c + 0xc) & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003f0c", 
            "calling": [
                "HAL_Init", 
                "premain"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_SetPriorityGrouping"
        }, 
        "set_pin_configured": {
            "renaming": {}, 
            "code": "\nvoid set_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)((int)pin << 0x18) >> 0x1c;\n  map[uVar1] = map[uVar1] | 1 << ((int)pin & 0xfU);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006b3e", 
            "calling": [
                "pinMode", 
                "analogWrite"
            ], 
            "imported": false, 
            "current_name": "set_pin_configured"
        }, 
        "get_pin_id": {
            "renaming": {}, 
            "code": "\nuint8_t get_pin_id(uint16_t pin)\n\n{\n  uint uVar1;\n  uint8_t uVar2;\n  \n  uVar2 = '\\0';\n  for (uVar1 = (uint)pin; uVar1 != 1; uVar1 = uVar1 >> 1) {\n    uVar2 = uVar2 + '\\x01';\n  }\n  return uVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008f3c", 
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ], 
            "imported": false, 
            "current_name": "get_pin_id"
        }, 
        "HAL_ADC_DeInit": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_ADC_DeInit(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  \n  if (hadc == (ADC_HandleTypeDef *)0x0) {\n    HVar1 = HAL_ERROR;\n  }\n  else {\n    hadc->State = hadc->State | 2;\n    HVar1 = ADC_ConversionStop_Disable(hadc);\n    if (HVar1 == HAL_OK) {\n      hadc->Instance->SR = 0xffffffe0;\n      hadc->Instance->CR1 = DAT_08003ddc & hadc->Instance->CR1;\n      hadc->Instance->CR2 = DAT_08003de0 & hadc->Instance->CR2;\n      hadc->Instance->SMPR1 = hadc->Instance->SMPR1 & 0xff000000;\n      hadc->Instance->SMPR2 = hadc->Instance->SMPR2 & 0xc0000000;\n      hadc->Instance->JOFR1 = hadc->Instance->JOFR1 & 0xfffff000;\n      hadc->Instance->JOFR2 = hadc->Instance->JOFR2 & 0xfffff000;\n      hadc->Instance->JOFR3 = hadc->Instance->JOFR3 & 0xfffff000;\n      hadc->Instance->JOFR4 = hadc->Instance->JOFR4 & 0xfffff000;\n      hadc->Instance->HTR = hadc->Instance->HTR & 0xfffff000;\n      hadc->Instance->LTR = hadc->Instance->LTR & 0xfffff000;\n      hadc->Instance->SQR1 = hadc->Instance->SQR1 & 0xff000000;\n      hadc->Instance->SQR1 = hadc->Instance->SQR1 & 0xff000000;\n      hadc->Instance->SQR2 = hadc->Instance->SQR2 & 0xc0000000;\n      hadc->Instance->SQR3 = hadc->Instance->SQR3 & 0xc0000000;\n      hadc->Instance->JSQR = hadc->Instance->JSQR & 0xffc00000;\n      hadc->Instance->JSQR = hadc->Instance->JSQR & 0xffc00000;\n      HAL_ADC_MspDeInit(hadc);\n      hadc->ErrorCode = 0;\n      hadc->State = 0;\n    }\n    hadc->Lock = HAL_UNLOCKED;\n  }\n  return HVar1;\n}\n\n", 
            "called": [
                "ADC_ConversionStop_Disable", 
                "HAL_ADC_MspDeInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003ce8", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_DeInit"
        }, 
        "TIM_CCxNChannelCmd": {
            "renaming": {}, 
            "code": "\nvoid TIM_CCxNChannelCmd(TIM_TypeDef_conflict *TIMx,uint32_t Channel,uint32_t ChannelNState)\n\n{\n  TIMx->CCER = TIMx->CCER & ~(4 << (Channel & 0xff));\n  TIMx->CCER = TIMx->CCER | ChannelNState << (Channel & 0xff);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006420", 
            "calling": [
                "HAL_TIMEx_PWMN_Start", 
                "HAL_TIMEx_PWMN_Stop"
            ], 
            "imported": false, 
            "current_name": "TIM_CCxNChannelCmd"
        }, 
        "pinmap_function": {
            "renaming": {}, 
            "code": "\nuint32_t pinmap_function(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  uint32_t uVar1;\n  \n  if (pin == NC) {\n    return 0xffffffff;\n  }\n  uVar1 = pinmap_find_function(pin,map);\n  return uVar1;\n}\n\n", 
            "called": [
                "pinmap_find_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007376", 
            "calling": [
                "HAL_TIM_PWM_MspInit", 
                "get_pwm_channel", 
                "uart_init", 
                "pwm_start", 
                "get_adc_channel", 
                "i2c_custom_init", 
                "pwm_stop"
            ], 
            "imported": false, 
            "current_name": "pinmap_function"
        }, 
        "EXTI0_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI0_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009024", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI0_IRQHandler"
        }, 
        "HAL_TIMEx_BreakCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIMEx_BreakCallback(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080064ae", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIMEx_BreakCallback"
        }, 
        "HAL_SYSTICK_Callback": {
            "renaming": {}, 
            "code": "\nvoid HAL_SYSTICK_Callback(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004044", 
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_Callback"
        }, 
        "frame_dummy": {
            "renaming": {}, 
            "code": "\nvoid frame_dummy(void)\n\n{\n  if (DAT_08000164 == 0) {\n    if ((*(int *)PTR_completed_8667_08000170 != 0) && (DAT_08000174 != (code *)0x0)) {\n                    /* WARNING: Could not recover jumptable at 0x08000160. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*DAT_08000174)();\n      return;\n    }\n    return;\n  }\n  if ((*(int *)PTR_completed_8667_08000170 != 0) && (DAT_08000174 != (code *)0x0)) {\n                    /* WARNING: Could not recover jumptable at 0x08000158. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*DAT_08000174)(PTR_completed_8667_08000170,PTR_object_8672_0800016c);\n    return;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000130", 
            "calling": [], 
            "imported": false, 
            "current_name": "frame_dummy"
        }, 
        "HAL_UART_GetState": {
            "renaming": {}, 
            "code": "\nHAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)\n\n{\n  return huart->RxState | huart->gState;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006b1c", 
            "calling": [
                "serial_tx_active", 
                "serial_rx_active"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_GetState"
        }, 
        "setPinModeCallback": {
            "renaming": {}, 
            "code": "\nvoid setPinModeCallback(byte pin,int mode)\n\n{\n  undefined *this;\n  byte bVar1;\n  PinName_conflict PVar2;\n  bool bVar3;\n  bool bVar4;\n  _Bool _Var5;\n  uint ulPin;\n  uint32_t uVar6;\n  char cVar7;\n  uint uVar8;\n  \n  ulPin = (uint)pin;\n  bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000874,pin);\n  if (bVar1 != '\\x7f') {\n    bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000874,pin);\n    if (bVar1 == '\\x06') {\n      cVar7 = *PTR_isI2CEnabled_0800087c;\n      if (cVar7 == '\\0') {\n        cVar7 = '\\0';\n      }\n      else if (mode == 6) {\n        cVar7 = '\\0';\n      }\n    }\n    else {\n      cVar7 = '\\0';\n    }\n    if (cVar7 != '\\0') {\n      disableI2CPins();\n    }\n    if (ulPin < 0x3c) {\n      if (PTR_digitalPin_08000878[ulPin] == NC) {\n        bVar3 = false;\n      }\n      else {\n        uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else if (mode == 4) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      if ((byte)PTR_servoPinMap_08000880[ulPin] < 0xc) {\n        bVar3 = Servo::attached((Servo *)(PTR_servos_08000884 +\n                                         (uint)(byte)PTR_servoPinMap_08000880[ulPin] * 3));\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3 != false) {\n        detachServo(pin);\n      }\n    }\n    uVar8 = ulPin - 0x2e & 0xff;\n    if (uVar8 < 0xe) {\n      if (ulPin < 0x3c) {\n        PVar2 = PTR_digitalPin_08000878[ulPin];\n      }\n      else {\n        PVar2 = NC;\n      }\n      uVar6 = pinNametoDigitalPin(PVar2);\n      if (uVar6 == 0) {\n        bVar3 = false;\n      }\n      else {\n        if (ulPin < 0x3c) {\n          PVar2 = PTR_digitalPin_08000878[ulPin];\n        }\n        else {\n          PVar2 = NC;\n        }\n        uVar6 = pinNametoDigitalPin(PVar2);\n        if (uVar6 == 1) {\n          bVar3 = false;\n        }\n        else {\n          bVar3 = true;\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      reportAnalogCallback((byte)uVar8,(uint)(mode == 2));\n    }\n    if (ulPin < 0x3c) {\n      if (PTR_digitalPin_08000878[ulPin] == NC) {\n        bVar3 = false;\n      }\n      else {\n        uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      if ((mode == 0) || (mode == 0xb)) {\n        PTR_portConfigInputs_08000888[pin >> 3] =\n             PTR_portConfigInputs_08000888[pin >> 3] | (byte)(1 << (ulPin & 7));\n      }\n      else {\n        PTR_portConfigInputs_08000888[pin >> 3] =\n             PTR_portConfigInputs_08000888[pin >> 3] & ~(byte)(1 << (ulPin & 7));\n      }\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000874,pin,0);\n    switch(mode) {\n    case 0:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000878[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        pinMode(ulPin,0);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000874,pin,'\\0');\n        return;\n      }\n      break;\n    case 1:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000a44,pin);\n        if (bVar1 == '\\x03') {\n          digitalWrite(ulPin,0);\n        }\n        pinMode(ulPin,1);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x01');\n        return;\n      }\n      break;\n    case 2:\n      if (uVar8 < 0xe) {\n        if (ulPin < 0x3c) {\n          PVar2 = PTR_digitalPin_08000878[ulPin];\n        }\n        else {\n          PVar2 = NC;\n        }\n        uVar6 = pinNametoDigitalPin(PVar2);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          if (ulPin < 0x3c) {\n            PVar2 = PTR_digitalPin_08000878[ulPin];\n          }\n          else {\n            PVar2 = NC;\n          }\n          uVar6 = pinNametoDigitalPin(PVar2);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        if (ulPin < 0x3c) {\n          if (PTR_digitalPin_08000878[ulPin] == NC) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 0) {\n              bVar3 = false;\n            }\n            else {\n              uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n              if (uVar6 == 1) {\n                bVar3 = false;\n              }\n            }\n          }\n        }\n        else {\n          bVar3 = false;\n        }\n        if (bVar3) {\n          pinMode(ulPin,0);\n        }\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000874,pin,'\\x02');\n        return;\n      }\n      break;\n    case 3:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          _Var5 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            _Var5 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              _Var5 = false;\n            }\n            else {\n              _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                    (PinMap_conflict *)PTR_PinMap_PWM_08000a4c);\n            }\n          }\n        }\n      }\n      else {\n        _Var5 = false;\n      }\n      if (_Var5 != false) {\n        pinMode(ulPin,1);\n        analogWrite(ulPin,0);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x03');\n        return;\n      }\n      break;\n    case 4:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x04');\n        if (((byte)PTR_servoPinMap_08000a50[ulPin] != 0xff) &&\n           (bVar4 = Servo::attached((Servo *)(PTR_servos_08000a54 +\n                                             (uint)(byte)PTR_servoPinMap_08000a50[ulPin] * 3)),\n           bVar4)) {\n          bVar3 = false;\n        }\n        if (bVar3) {\n          attachServo(pin,-1,-1);\n          return;\n        }\n      }\n      break;\n    default:\n      firmata::FirmataClass::sendString\n                ((FirmataClass *)PTR_Firmata_08000a44,PTR_s_Unknown_pin_mode_08000a60);\n      break;\n    case 6:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          _Var5 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            _Var5 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              _Var5 = false;\n            }\n            else {\n              _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                    (PinMap_conflict *)PTR_PinMap_I2C_SDA_08000a58);\n              if (!_Var5) {\n                _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                      (PinMap_conflict *)PTR_PinMap_I2C_SCL_08000a5c);\n              }\n            }\n          }\n        }\n      }\n      else {\n        _Var5 = false;\n      }\n      if (_Var5 != false) {\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x06');\n        return;\n      }\n      break;\n    case 10:\n      break;\n    case 0xb:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000878[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        pinMode(ulPin,2);\n        this = PTR_Firmata_08000a44;\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\v');\n        firmata::FirmataClass::setPinState((FirmataClass *)this,pin,1);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "pinMode", 
                "setPinMode", 
                "pinNametoDigitalPin", 
                "attached", 
                "sendString", 
                "getPinMode", 
                "pin_in_pinmap", 
                "disableI2CPins", 
                "setPinState", 
                "reportAnalogCallback", 
                "digitalWrite", 
                "analogWrite", 
                "attachServo", 
                "detachServo"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080005f8", 
            "calling": [
                "enableI2CPins", 
                "systemResetCallback", 
                "sysexCallback"
            ], 
            "imported": false, 
            "current_name": "setPinModeCallback"
        }, 
        "sendExtendedAnalog": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x0800311e */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::sendExtendedAnalog\n          (FirmataMarshaller *this,uint8_t pin,size_t bytec,uint8_t *bytev)\n\n{\n  if (this->FirmataStream != (Stream *)0x0) {\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this,0xf0);\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,0x6f);\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,(uint)pin);\n    encodeByteStream(this,bytec,bytev,bytec);\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,0xf7);\n  }\n  return;\n}\n\n", 
            "called": [
                "encodeByteStream"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003106", 
            "calling": [
                "sendAnalog"
            ], 
            "imported": false, 
            "current_name": "sendExtendedAnalog"
        }, 
        "HAL_RCC_GetPCLK2Freq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCC_GetPCLK2Freq(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = HAL_RCC_GetHCLKFreq();\n  return uVar1 >> PTR_APBPrescTable_08005a64[(uint)(*(int *)(DAT_08005a60 + 4) << 0x12) >> 0x1d];\n}\n\n", 
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005a48", 
            "calling": [
                "HAL_RCCEx_GetPeriphCLKFreq", 
                "getTimerClkFreq", 
                "UART_SetConfig"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetPCLK2Freq"
        }, 
        "pinmap_pin": {
            "renaming": {}, 
            "code": "\nPinName_conflict pinmap_pin(void *peripheral,PinMap_conflict *map)\n\n{\n  PinName_conflict PVar1;\n  \n  if (peripheral != (void *)0x0) {\n    PVar1 = pinmap_find_pin(peripheral,map);\n    return PVar1;\n  }\n  return NC;\n}\n\n", 
            "called": [
                "pinmap_find_pin"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800734a", 
            "calling": [
                "HardwareSerial", 
                "uart_debug_init"
            ], 
            "imported": false, 
            "current_name": "pinmap_pin"
        }, 
        "printVersion": {
            "renaming": {}, 
            "code": "\nvoid __thiscall firmata::FirmataClass::printVersion(FirmataClass *this)\n\n{\n  FirmataMarshaller::sendVersion(&this->marshaller,'\\x02','\\x05');\n  return;\n}\n\n", 
            "called": [
                "sendVersion"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002ddc", 
            "calling": [
                "staticReportVersionCallback", 
                "begin"
            ], 
            "imported": false, 
            "current_name": "printVersion"
        }, 
        "HAL_InitTick": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_InitTick(uint32_t TickPriority)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = HAL_SYSTICK_Config((uint32_t)\n                             ((ulonglong)*(uint *)PTR_SystemCoreClock_0800371c /\n                             (1000 / (ulonglong)(byte)*PTR_uwTickFreq_08003718)));\n  if (uVar1 != 0) {\n    return HAL_ERROR;\n  }\n  if (0xf < TickPriority) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,TickPriority,0);\n  *(uint32_t *)PTR_uwTickPrio_08003720 = TickPriority;\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_NVIC_SetPriority", 
                "HAL_SYSTICK_Config"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080036d8", 
            "calling": [
                "HAL_Init", 
                "HAL_RCC_ClockConfig"
            ], 
            "imported": false, 
            "current_name": "HAL_InitTick"
        }, 
        "reportAnalogCallback": {
            "renaming": {}, 
            "code": "\nvoid reportAnalogCallback(byte analogPin,int value)\n\n{\n  uint ulPin;\n  uint32_t value_00;\n  \n  ulPin = (uint)analogPin;\n  if (ulPin < 0xe) {\n    if (value == 0) {\n      *(uint *)PTR_analogInputsToReport_080004c8 =\n           *(uint *)PTR_analogInputsToReport_080004c8 & ~(1 << ulPin);\n      return;\n    }\n    *(uint *)PTR_analogInputsToReport_080004c8 =\n         1 << ulPin | *(uint *)PTR_analogInputsToReport_080004c8;\n    if (*PTR_isResetting_080004cc == '\\0') {\n      value_00 = analogRead(ulPin);\n      firmata::FirmataClass::sendAnalog((FirmataClass *)PTR_Firmata_080004d0,analogPin,value_00);\n      return;\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "sendAnalog", 
                "analogRead"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000488", 
            "calling": [
                "setPinModeCallback"
            ], 
            "imported": false, 
            "current_name": "reportAnalogCallback"
        }, 
        "HAL_I2C_SlaveRxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004a74", 
            "calling": [
                "I2C_SlaveReceive_RXNE", 
                "I2C_Slave_STOPF"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_SlaveRxCpltCallback"
        }, 
        "TwoWire": {
            "renaming": {}, 
            "code": "\nTwoWire * __thiscall TwoWire::TwoWire(TwoWire *this)\n\n{\n  undefined *puVar1;\n  \n  (this->super_Stream).super_Print.write_error = 0;\n  (this->super_Stream)._timeout = 1000;\n  (this->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)PTR_PTR_write_1_08002940;\n  puVar1 = PTR_digitalPin_08002944;\n  (this->_i2c).sda = PTR_digitalPin_08002944[0xe];\n  (this->_i2c).scl = puVar1[0xf];\n  return this;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800291c", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "TwoWire"
        }, 
        "startForkserver": {
            "renaming": {}, 
            "code": "\nint startForkserver(int ticks)\n\n{\n  uint32_t uVar1;\n  \n  if (*(int *)PTR_noHyperCall_080001a4 != 0) {\n    return 0;\n  }\n  uVar1 = aflCall(1,ticks,0);\n  return uVar1;\n}\n\n", 
            "called": [
                "aflCall"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800018c", 
            "calling": [
                "setup"
            ], 
            "imported": false, 
            "current_name": "startForkserver"
        }, 
        "delay": {
            "renaming": {}, 
            "code": "\nvoid delay(uint32_t ms)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008ac4", 
            "calling": [
                "blinkVersion", 
                "strobeBlinkPin"
            ], 
            "imported": false, 
            "current_name": "delay"
        }, 
        "staticStringCallback": {
            "renaming": {}, 
            "code": "\nvoid firmata::FirmataClass::staticStringCallback(void *param_1,char *c_str)\n\n{\n  if (*(code **)PTR_currentStringCallback_08002cb4 != (code *)0x0) {\n    (**(code **)PTR_currentStringCallback_08002cb4)(c_str);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002ca4", 
            "calling": [], 
            "imported": false, 
            "current_name": "staticStringCallback"
        }, 
        "GetCurrentMilli": {
            "renaming": {}, 
            "code": "\nuint32_t GetCurrentMilli(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = HAL_GetTick();\n  return uVar1;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800723c", 
            "calling": [
                "millis"
            ], 
            "imported": false, 
            "current_name": "GetCurrentMilli"
        }, 
        "getPinState": {
            "renaming": {}, 
            "code": "\nint __thiscall firmata::FirmataClass::getPinState(FirmataClass *this,byte pin)\n\n{\n  return this->pinState[pin];\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002fba", 
            "calling": [
                "digitalWriteCallback", 
                "sysexCallback"
            ], 
            "imported": false, 
            "current_name": "getPinState"
        }, 
        "enableI2CPins": {
            "renaming": {}, 
            "code": "\nvoid enableI2CPins(void)\n\n{\n  _Bool _Var1;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  for (uVar3 = 0; uVar3 < 0x3c; uVar3 = uVar3 + 1 & 0xff) {\n    if (uVar3 < 0x3c) {\n      if (PTR_digitalPin_08000ad8[uVar3] == NC) {\n        _Var1 = false;\n      }\n      else {\n        uVar2 = pinNametoDigitalPin(PTR_digitalPin_08000ad8[uVar3]);\n        if (uVar2 == 0) {\n          _Var1 = false;\n        }\n        else {\n          uVar2 = pinNametoDigitalPin(PTR_digitalPin_08000ad8[uVar3]);\n          if (uVar2 == 1) {\n            _Var1 = false;\n          }\n          else {\n            _Var1 = pin_in_pinmap(PTR_digitalPin_08000ad8[uVar3],\n                                  (PinMap_conflict *)PTR_PinMap_I2C_SDA_08000adc);\n            if (!_Var1) {\n              _Var1 = pin_in_pinmap(PTR_digitalPin_08000ad8[uVar3],\n                                    (PinMap_conflict *)PTR_PinMap_I2C_SCL_08000ae0);\n            }\n          }\n        }\n      }\n    }\n    else {\n      _Var1 = false;\n    }\n    if (_Var1 != false) {\n      setPinModeCallback((byte)uVar3,6);\n    }\n  }\n  *PTR_isI2CEnabled_08000ae4 = 1;\n  TwoWire::begin((TwoWire *)PTR_Wire_08000ae8);\n  return;\n}\n\n", 
            "called": [
                "begin", 
                "setPinModeCallback", 
                "pinNametoDigitalPin", 
                "pin_in_pinmap"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000a64", 
            "calling": [
                "sysexCallback"
            ], 
            "imported": false, 
            "current_name": "enableI2CPins"
        }, 
        "processSysexMessage": {
            "renaming": {}, 
            "code": "\nvoid __thiscall firmata::FirmataParser::processSysexMessage(FirmataParser *this)\n\n{\n  uint8_t uVar1;\n  size_t sVar2;\n  uint8_t *puVar3;\n  \n  puVar3 = this->dataBuffer;\n  uVar1 = *puVar3;\n  if (uVar1 == 'q') {\n    if (this->currentStringCallback != (stringCallbackFunction)0x0) {\n      sVar2 = decodeByteStream(this,this->sysexBytesRead - 1,puVar3 + 1);\n      bufferDataAtPosition(this,'\\0',sVar2 + 1);\n      (*this->currentStringCallback)\n                (this->currentStringCallbackContext,(char *)(this->dataBuffer + 1));\n      return;\n    }\n  }\n  else if (uVar1 == 'y') {\n    if (this->currentReportFirmwareCallback != (versionCallbackFunction)0x0) {\n      if (this->sysexBytesRead < 3) {\n        (*this->currentReportFirmwareCallback)\n                  (this->currentReportFirmwareCallbackContext,0,0,(char *)0x0);\n        return;\n      }\n      sVar2 = decodeByteStream(this,this->sysexBytesRead - 3,puVar3 + 3);\n      bufferDataAtPosition(this,'\\0',sVar2 + 3);\n      puVar3 = this->dataBuffer;\n      (*this->currentReportFirmwareCallback)\n                (this->currentReportFirmwareCallbackContext,(uint)puVar3[1],(uint)puVar3[2],\n                 (char *)(puVar3 + 3));\n      return;\n    }\n  }\n  else if (this->currentSysexCallback != (sysexCallbackFunction)0x0) {\n    (*this->currentSysexCallback)\n              (this->currentSysexCallbackContext,uVar1,this->sysexBytesRead - 1,puVar3 + 1);\n  }\n  return;\n}\n\n", 
            "called": [
                "decodeByteStream", 
                "bufferDataAtPosition"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080033cc", 
            "calling": [
                "parse"
            ], 
            "imported": false, 
            "current_name": "processSysexMessage"
        }, 
        "hw_config_init": {
            "renaming": {}, 
            "code": "\nvoid hw_config_init(void)\n\n{\n  HAL_Init();\n  SystemClock_Config();\n  return;\n}\n\n", 
            "called": [
                "HAL_Init", 
                "SystemClock_Config"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080072fa", 
            "calling": [
                "init"
            ], 
            "imported": false, 
            "current_name": "hw_config_init"
        }, 
        "I2C_Master_ADD10": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_Master_ADD10(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  hi2c->Instance->DR = hi2c->Devaddress & 0xff;\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004396", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Master_ADD10"
        }, 
        "HAL_TIM_TriggerCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_TriggerCallback(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005e6c", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_TriggerCallback"
        }, 
        "getTimerIrq": {
            "renaming": {}, 
            "code": "\nuint32_t getTimerIrq(TIM_TypeDef_conflict *tim)\n\n{\n  if (tim == (TIM_TypeDef_conflict *)0xffffffff) {\n    return 0;\n  }\n  if (tim == DAT_08007588) {\n    return 0x1d;\n  }\n  if (DAT_08007588 < tim) {\n    if (tim == DAT_0800758c) {\n      return 0x1e;\n    }\n    if (tim == (TIM_TypeDef_conflict *)&DAT_0800758c[0x379].DMAR) {\n      return 0x19;\n    }\n  }\n  else if (tim == (TIM_TypeDef_conflict *)0x40000000) {\n    return 0x1c;\n  }\n  iprintf(PTR_s_TIM__Unknown_timer_IRQn_08007590);\n  return 0;\n}\n\n", 
            "called": [
                "iprintf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007544", 
            "calling": [
                "TimerPulseDeinit", 
                "TimerPulseInit"
            ], 
            "imported": false, 
            "current_name": "getTimerIrq"
        }, 
        "UART_EndTransmit_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict UART_EndTransmit_IT(UART_HandleTypeDef *huart)\n\n{\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xffffffbf;\n  huart->gState = HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(huart);\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_UART_TxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006932", 
            "calling": [
                "HAL_UART_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "UART_EndTransmit_IT"
        }, 
        "TIM2_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM2_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_08007784 + 4) !=\n      (TIM_HandleTypeDef_conflict *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_08007784 + 4));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007774", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM2_IRQHandler"
        }, 
        "I2C_SlaveReceive_RXNE": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_SlaveReceive_RXNE(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  HAL_I2C_StateTypeDef_conflict HVar1;\n  uint8_t *puVar2;\n  \n  HVar1 = hi2c->State;\n  if (hi2c->XferCount != 0) {\n    puVar2 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar2 + 1;\n    *puVar2 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n    if ((hi2c->XferCount == 0) && (HVar1 == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n      hi2c->PreviousState = 0x22;\n      hi2c->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(hi2c);\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004a76", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_SlaveReceive_RXNE"
        }, 
        "HAL_TIM_PeriodElapsedCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef_conflict *htim)\n\n{\n  stimer_t_conflict *psVar1;\n  \n  psVar1 = get_timer_obj(htim);\n  if (psVar1->irqHandle != (_func_void_stimer_t_ptr_conflict *)0x0) {\n    (*psVar1->irqHandle)(psVar1);\n  }\n  return;\n}\n\n", 
            "called": [
                "get_timer_obj"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007736", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PeriodElapsedCallback"
        }, 
        "getTimerClkSrc": {
            "renaming": {}, 
            "code": "\nuint8_t getTimerClkSrc(TIM_TypeDef_conflict *tim)\n\n{\n  if (tim == (TIM_TypeDef_conflict *)0xffffffff) {\n    return '\\0';\n  }\n  if (tim == DAT_080075d0) {\n    return '\\x01';\n  }\n  if (DAT_080075d0 < tim) {\n    if (tim == DAT_080075d4) {\n      return '\\x01';\n    }\n    if (tim == (TIM_TypeDef_conflict *)&DAT_080075d4[0x379].DMAR) {\n      return '\\x02';\n    }\n  }\n  else if (tim == (TIM_TypeDef_conflict *)0x40000000) {\n    return '\\x01';\n  }\n  iprintf(PTR_s_TIM__Unknown_timer_instance_080075d8);\n  return '\\0';\n}\n\n", 
            "called": [
                "iprintf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007594", 
            "calling": [
                "getTimerClkFreq"
            ], 
            "imported": false, 
            "current_name": "getTimerClkSrc"
        }, 
        "_isatty": {
            "renaming": {}, 
            "code": "\nint _isatty(int file_UNUSED)\n\n{\n  return 1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008850", 
            "calling": [
                "_isatty_r"
            ], 
            "imported": false, 
            "current_name": "_isatty"
        }, 
        "I2C_MasterReceive_RXNE": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_MasterReceive_RXNE(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  uint8_t *puVar1;\n  \n  if (hi2c->State == HAL_I2C_STATE_BUSY_RX) {\n    if (hi2c->XferCount < 4) {\n      if (hi2c->XferCount - 2 < 2) {\n        if (hi2c->XferOptions == 2) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        }\n        else {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x800;\n        }\n        hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n      }\n      else {\n        if (hi2c->XferOptions == 2) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        }\n        else {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n        }\n        hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n        puVar1 = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = puVar1 + 1;\n        *puVar1 = (uint8_t)hi2c->Instance->DR;\n        hi2c->XferCount = hi2c->XferCount - 1;\n        hi2c->State = HAL_I2C_STATE_READY;\n        hi2c->PreviousState = 0;\n        if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n          hi2c->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(hi2c);\n        }\n        else {\n          hi2c->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(hi2c);\n        }\n      }\n    }\n    else {\n      puVar1 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = puVar1 + 1;\n      *puVar1 = (uint8_t)hi2c->Instance->DR;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_MemRxCpltCallback", 
                "HAL_I2C_MasterRxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004d6c", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_MasterReceive_RXNE"
        }, 
        "TimerPulseDeinit": {
            "renaming": {}, 
            "code": "\nvoid TimerPulseDeinit(stimer_t_conflict *obj)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  \n  obj->irqHandleOC = (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0;\n  uVar2 = getTimerIrq(obj->timer);\n  HAL_NVIC_DisableIRQ((IRQn_Type_conflict)uVar2);\n  HVar1 = HAL_TIM_OC_DeInit(&obj->handle);\n  if (HVar1 == HAL_OK) {\n    HAL_TIM_OC_Stop_IT(&obj->handle,0);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_OC_DeInit", 
                "getTimerIrq", 
                "HAL_TIM_OC_Stop_IT", 
                "HAL_NVIC_DisableIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080076e0", 
            "calling": [
                "finISR"
            ], 
            "imported": false, 
            "current_name": "TimerPulseDeinit"
        }, 
        "HAL_I2C_GetError": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_I2C_GetError(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return hi2c->ErrorCode;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005430", 
            "calling": [
                "i2c_master_write", 
                "i2c_master_read"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_GetError"
        }, 
        "pwm_start": {
            "renaming": {}, 
            "code": "\nvoid pwm_start(PinName_conflict pin,uint32_t clock_freq,uint32_t period,uint32_t value,\n              uint8_t do_init)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  TIM_OC_InitTypeDef timConfig;\n  TIM_HandleTypeDef_conflict timHandle;\n  \n  memset(&timHandle,0,0x40);\n  timConfig.OCMode = 0;\n  timConfig.Pulse = 0;\n  timConfig.OCPolarity = 0;\n  timConfig.OCNPolarity = 0;\n  timConfig.OCFastMode = 0;\n  timConfig.OCIdleState = 0;\n  timConfig.OCNIdleState = 0;\n  timHandle.Instance =\n       (TIM_TypeDef_conflict *)pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_PWM_080071dc);\n  if (timHandle.Instance != (TIM_TypeDef_conflict *)0x0) {\n    uVar2 = getTimerClkFreq(timHandle.Instance);\n    timHandle.Init.Prescaler = uVar2 / clock_freq - 1;\n    timHandle.Init.Period = period - 1;\n    timHandle.Init.ClockDivision = 0;\n    timHandle.Init.CounterMode = 0;\n    timHandle.Init.RepetitionCounter = 0;\n    timHandle.State = HAL_TIM_STATE_RESET;\n    if (do_init == '\\x01') {\n      *PTR_g_current_pin_080071e0 = pin;\n      HVar1 = HAL_TIM_PWM_Init(&timHandle);\n      if (HVar1 != HAL_OK) {\n        return;\n      }\n    }\n    uVar2 = get_pwm_channel(pin);\n    if ((((uVar2 == 0) || (uVar2 == 4)) || (uVar2 == 8)) || ((uVar2 == 0xc || (uVar2 == 0x18)))) {\n      timConfig.OCMode = 0x60;\n      timConfig.OCPolarity = 0;\n      timConfig.OCFastMode = 0;\n      timConfig.OCNPolarity = 0;\n      timConfig.OCNIdleState = 0;\n      timConfig.OCIdleState = 0;\n      timConfig.Pulse = value;\n      HVar1 = HAL_TIM_PWM_ConfigChannel(&timHandle,&timConfig,uVar2);\n      if (HVar1 == HAL_OK) {\n        uVar3 = pinmap_function(pin,(PinMap_conflict *)PTR_PinMap_PWM_080071dc);\n        if ((uVar3 & 0x100000) == 0) {\n          HAL_TIM_PWM_Start(&timHandle,uVar2);\n        }\n        else {\n          HAL_TIMEx_PWMN_Start(&timHandle,uVar2);\n        }\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_PWM_ConfigChannel", 
                "get_pwm_channel", 
                "HAL_TIMEx_PWMN_Start", 
                "pinmap_peripheral", 
                "getTimerClkFreq", 
                "HAL_TIM_PWM_Init", 
                "HAL_TIM_PWM_Start", 
                "memset", 
                "pinmap_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007118", 
            "calling": [
                "analogWrite"
            ], 
            "imported": false, 
            "current_name": "pwm_start"
        }, 
        "staticSysexCallback": {
            "renaming": {}, 
            "code": "\nvoid firmata::FirmataClass::staticSysexCallback\n               (void *param_1,uint8_t command,size_t argc,uint8_t *argv)\n\n{\n  if (*(code **)PTR_currentSysexCallback_08002ccc != (code *)0x0) {\n    (**(code **)PTR_currentSysexCallback_08002ccc)(command,argc & 0xff,argv,argv,argv);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002cb8", 
            "calling": [], 
            "imported": false, 
            "current_name": "staticSysexCallback"
        }, 
        "disableI2CPins": {
            "renaming": {}, 
            "code": "\nvoid disableI2CPins(void)\n\n{\n  *PTR_isI2CEnabled_080005f0 = 0;\n  *PTR_queryIndex_080005f4 = 0xff;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080005e0", 
            "calling": [
                "setPinModeCallback", 
                "systemResetCallback"
            ], 
            "imported": false, 
            "current_name": "disableI2CPins"
        }, 
        "_GLOBAL__sub_I_analogInputsToReport": {
            "renaming": {}, 
            "code": "\nvoid _GLOBAL__sub_I_analogInputsToReport(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n", 
            "called": [
                "__static_initialization_and_destruction_0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001be8", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I_analogInputsToReport"
        }, 
        "ADC_Enable": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict ADC_Enable(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  ADC_TypeDef *pAVar4;\n  uint32_t wait_loop_index;\n  \n  pAVar4 = hadc->Instance;\n  if ((pAVar4->CR2 & 1) == 0) {\n    pAVar4->CR2 = pAVar4->CR2 | 1;\n    for (wait_loop_index =\n              (uint32_t)\n              ((ulonglong)DAT_08003a9c * (ulonglong)*(uint *)PTR_SystemCoreClock_08003a98 >> 0x32);\n        wait_loop_index != 0; wait_loop_index = wait_loop_index - 1) {\n    }\n    uVar2 = HAL_GetTick();\n    do {\n      if ((hadc->Instance->CR2 & 1) != 0) {\n        return HAL_OK;\n      }\n      uVar3 = HAL_GetTick();\n    } while (uVar3 - uVar2 < 3);\n    hadc->State = hadc->State | 0x10;\n    hadc->ErrorCode = hadc->ErrorCode | 1;\n    hadc->Lock = HAL_UNLOCKED;\n    HVar1 = HAL_ERROR;\n  }\n  else {\n    HVar1 = HAL_OK;\n  }\n  return HVar1;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003a20", 
            "calling": [
                "HAL_ADC_Start", 
                "HAL_ADCEx_Calibration_Start"
            ], 
            "imported": false, 
            "current_name": "ADC_Enable"
        }, 
        "HAL_ADC_MspDeInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_ADC_MspDeInit(ADC_HandleTypeDef *hadc)\n\n{\n  int iVar1;\n  \n  iVar1 = DAT_08006d7c;\n  if (hadc->Instance != DAT_08006d74) {\n    if (hadc->Instance == DAT_08006d78) {\n      *(uint *)(DAT_08006d7c + 0xc) = *(uint *)(DAT_08006d7c + 0xc) | 0x400;\n      *(uint *)(iVar1 + 0xc) = *(uint *)(iVar1 + 0xc) & 0xfffffbff;\n      *(uint *)(iVar1 + 0x18) = *(uint *)(iVar1 + 0x18) & 0xfffffbff;\n      *(uint *)(iVar1 + 0x18) = *(uint *)(iVar1 + 0x18) & 0xfffffbff;\n    }\n    return;\n  }\n  *(uint *)(DAT_08006d7c + 0xc) = *(uint *)(DAT_08006d7c + 0xc) | 0x200;\n  *(uint *)(iVar1 + 0xc) = *(uint *)(iVar1 + 0xc) & 0xfffffdff;\n  *(uint *)(iVar1 + 0x18) = *(uint *)(iVar1 + 0x18) & 0xfffffdff;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006d24", 
            "calling": [
                "HAL_ADC_DeInit"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_MspDeInit"
        }, 
        "finISR": {
            "renaming": {}, 
            "code": "\nvoid finISR(stimer_t *obj)\n\n{\n  TimerPulseDeinit((stimer_t_conflict *)obj);\n  return;\n}\n\n", 
            "called": [
                "TimerPulseDeinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002578", 
            "calling": [
                "detach"
            ], 
            "imported": false, 
            "current_name": "finISR"
        }, 
        "HAL_TIM_OC_DelayElapsedCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef_conflict *htim)\n\n{\n  stimer_t_conflict *psVar1;\n  \n  psVar1 = get_timer_obj(htim);\n  if ((psVar1->irqHandleOC != (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0) &&\n     (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*psVar1->irqHandleOC)(psVar1,0);\n  }\n  return;\n}\n\n", 
            "called": [
                "get_timer_obj"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800771c", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_OC_DelayElapsedCallback"
        }, 
        "memcpy": {
            "renaming": {}, 
            "code": "\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  \n  puVar2 = (undefined *)((int)__dest + -1);\n  puVar1 = (undefined *)(__n + (int)__src);\n  for (; (undefined *)__src != puVar1; __src = (void *)((int)__src + 1)) {\n    puVar2 = puVar2 + 1;\n    *puVar2 = *__src;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return __dest;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080091b0", 
            "calling": [
                "onReceiveService", 
                "write", 
                "_realloc_r"
            ], 
            "imported": false, 
            "current_name": "memcpy"
        }, 
        "getTimerClkFreq": {
            "renaming": {}, 
            "code": "\nuint32_t getTimerClkFreq(TIM_TypeDef_conflict *tim)\n\n{\n  uint32_t uVar1;\n  uint8_t uVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint32_t pFLatency;\n  RCC_ClkInitTypeDef_conflict clkconfig;\n  \n  clkconfig.ClockType = 0;\n  clkconfig.SYSCLKSource = 0;\n  clkconfig.AHBCLKDivider = 0;\n  clkconfig.APB1CLKDivider = 0;\n  clkconfig.APB2CLKDivider = 0;\n  pFLatency = 0;\n  HAL_RCC_GetClockConfig(&clkconfig,&pFLatency);\n  uVar2 = getTimerClkSrc(tim);\n  uVar1 = clkconfig.APB2CLKDivider;\n  uVar4 = clkconfig.APB1CLKDivider;\n  if (uVar2 == '\\x01') {\n    uVar3 = HAL_RCC_GetPCLK1Freq();\n  }\n  else if (uVar2 == '\\x02') {\n    uVar3 = HAL_RCC_GetPCLK2Freq();\n    uVar4 = uVar1;\n  }\n  else {\n    iprintf(PTR_s_TIM__Unknown_clock_source_08007644);\n    uVar3 = 0;\n    uVar4 = 0;\n  }\n  if (uVar4 != 0x500) {\n    if (uVar4 < 0x501) {\n      if (uVar4 != 0x400) {\n        return uVar3;\n      }\n    }\n    else if ((uVar4 != 0x600) && (uVar4 != 0x700)) {\n      return uVar3;\n    }\n  }\n  return uVar3 << 1;\n}\n\n", 
            "called": [
                "HAL_RCC_GetClockConfig", 
                "HAL_RCC_GetPCLK1Freq", 
                "HAL_RCC_GetPCLK2Freq", 
                "iprintf", 
                "getTimerClkSrc"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080075dc", 
            "calling": [
                "pwm_start", 
                "TimerPulseInit"
            ], 
            "imported": false, 
            "current_name": "getTimerClkFreq"
        }, 
        "IPAddress": {
            "renaming": {}, 
            "code": "\nIPAddress * __thiscall\nIPAddress::IPAddress\n          (IPAddress *this,uint8_t first_octet,uint8_t second_octet,uint8_t third_octet,\n          uint8_t fourth_octet)\n\n{\n  (this->super_Printable)._vptr_Printable = (_func_int_varargs **)PTR_DAT_08008e10;\n  (this->_address).bytes[0] = first_octet;\n  (this->_address).bytes[1] = second_octet;\n  (this->_address).bytes[2] = third_octet;\n  (this->_address).bytes[3] = fourth_octet;\n  return this;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008df8", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "IPAddress"
        }, 
        "_rx_complete_irq": {
            "renaming": {}, 
            "code": "\nvoid HardwareSerial::_rx_complete_irq(serial_t_conflict *obj)\n\n{\n  int iVar1;\n  ushort uVar2;\n  uchar c;\n  \n  iVar1 = uart_getc((serial_t *)obj,&c);\n  if ((iVar1 == 0) && (uVar2 = obj->rx_head + 1 & 0x3f, uVar2 != obj->rx_tail)) {\n    obj->rx_buff[obj->rx_head] = c;\n    obj->rx_head = uVar2;\n  }\n  return;\n}\n\n", 
            "called": [
                "uart_getc"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008b66", 
            "calling": [], 
            "imported": false, 
            "current_name": "_rx_complete_irq"
        }, 
        "HAL_TIMEx_PWMN_Stop": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef_conflict *htim,uint32_t Channel)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  TIM_CCxNChannelCmd(htim->Instance,Channel,0);\n  pTVar1 = htim->Instance;\n  if (((pTVar1->CCER & 0x1111) == 0) && ((pTVar1->CCER & 0x444) == 0)) {\n    pTVar1->BDTR = pTVar1->BDTR & 0xffff7fff;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->CCER & 0x1111) == 0) && ((pTVar1->CCER & 0x444) == 0)) {\n    pTVar1->CR1 = pTVar1->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "TIM_CCxNChannelCmd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006460", 
            "calling": [
                "pwm_stop"
            ], 
            "imported": false, 
            "current_name": "HAL_TIMEx_PWMN_Stop"
        }, 
        "_init": {
            "renaming": {}, 
            "code": "\nvoid _init(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a424", 
            "calling": [
                "__do_global_dtors_aux", 
                "__libc_init_array"
            ], 
            "imported": false, 
            "current_name": "_init"
        }, 
        "get_adc_channel": {
            "renaming": {}, 
            "code": "\nuint32_t get_adc_channel(PinName_conflict pin)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = pinmap_function(pin,(PinMap_conflict *)PTR_PinMap_ADC_08006c78);\n  uVar1 = (uVar1 << 0xc) >> 0x1b;\n  if (0x10 < uVar1 - 1) {\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n", 
            "called": [
                "pinmap_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006c60", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "get_adc_channel"
        }, 
        "HAL_ADC_Start": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_ADC_Start(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  ADC_TypeDef *pAVar2;\n  \n  if (hadc->Lock != HAL_LOCKED) {\n    hadc->Lock = HAL_LOCKED;\n    HVar1 = ADC_Enable(hadc);\n    if (HVar1 == HAL_OK) {\n      hadc->State = hadc->State & 0xfffffcfe | 0x100;\n      pAVar2 = hadc->Instance;\n      if ((pAVar2 == DAT_08003b84) && ((DAT_08003b84[-0xd].JOFR1 & 0xf0000) != 0)) {\n        hadc->State = hadc->State | 0x100000;\n        if ((*(uint *)(DAT_08003b88 + 4) & 0x400) != 0) {\n          hadc->State = hadc->State & 0xffffcfff | 0x1000;\n        }\n      }\n      else {\n        hadc->State = hadc->State & 0xffefffff;\n        if ((pAVar2->CR1 & 0x400) != 0) {\n          hadc->State = hadc->State & 0xffffcfff | 0x1000;\n        }\n      }\n      if ((hadc->State & 0x1000) == 0) {\n        hadc->ErrorCode = 0;\n      }\n      else {\n        hadc->ErrorCode = hadc->ErrorCode & 0xfffffff9;\n      }\n      hadc->Lock = HAL_UNLOCKED;\n      pAVar2->SR = 0xfffffffd;\n      pAVar2 = hadc->Instance;\n      if (((pAVar2->CR2 & 0xe0000) == 0xe0000) &&\n         ((pAVar2 != DAT_08003b84 || ((DAT_08003b84[-0xd].JOFR1 & 0xf0000) == 0)))) {\n        pAVar2->CR2 = pAVar2->CR2 | 0x500000;\n      }\n      else {\n        pAVar2->CR2 = pAVar2->CR2 | 0x100000;\n      }\n    }\n    else {\n      hadc->Lock = HAL_UNLOCKED;\n    }\n    return HVar1;\n  }\n  return HAL_BUSY;\n}\n\n", 
            "called": [
                "ADC_Enable"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003aa0", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_Start"
        }, 
        "HAL_ADC_Stop": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_ADC_Stop(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  \n  if (hadc->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  hadc->Lock = HAL_LOCKED;\n  HVar1 = ADC_ConversionStop_Disable(hadc);\n  if (HVar1 == HAL_OK) {\n    hadc->State = hadc->State & 0xffffeefe | 1;\n  }\n  hadc->Lock = HAL_UNLOCKED;\n  return HVar1;\n}\n\n", 
            "called": [
                "ADC_ConversionStop_Disable"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003de4", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_Stop"
        }, 
        "bufferDataAtPosition": {
            "renaming": {}, 
            "code": "\nbool __thiscall\nfirmata::FirmataParser::bufferDataAtPosition(FirmataParser *this,uint8_t data,size_t pos)\n\n{\n  bool bVar1;\n  \n  if (pos < this->dataBufferSize) {\n    bVar1 = false;\n  }\n  else {\n    bVar1 = true;\n    if (this->currentDataBufferOverflowCallback != (dataBufferOverflowCallbackFunction)0x0) {\n      this->allowBufferUpdate = true;\n      (*this->currentDataBufferOverflowCallback)(this->currentDataBufferOverflowCallbackContext);\n      if (pos < this->dataBufferSize) {\n        bVar1 = false;\n      }\n      else {\n        bVar1 = true;\n      }\n    }\n  }\n  if (!bVar1) {\n    this->dataBuffer[pos] = data;\n  }\n  return bVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003376", 
            "calling": [
                "processSysexMessage", 
                "parse"
            ], 
            "imported": false, 
            "current_name": "bufferDataAtPosition"
        }, 
        "realloc": {
            "renaming": {}, 
            "code": "\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)_realloc_r(*(undefined4 *)PTR__impure_ptr_08009914,__ptr,__size);\n  return pvVar1;\n}\n\n", 
            "called": [
                "_realloc_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009908", 
            "calling": [
                "write", 
                "allocateRxBuffer", 
                "write"
            ], 
            "imported": false, 
            "current_name": "realloc"
        }, 
        "__malloc_lock": {
            "renaming": {}, 
            "code": "\nvoid __malloc_lock(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009f48", 
            "calling": [
                "_malloc_r", 
                "_free_r"
            ], 
            "imported": false, 
            "current_name": "__malloc_lock"
        }, 
        "strlen": {
            "renaming": {}, 
            "code": "\nsize_t strlen(char *__s)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar3 = __s;\n  do {\n    pcVar2 = pcVar3 + 1;\n    cVar1 = *pcVar3;\n    pcVar3 = pcVar2;\n  } while (cVar1 != '\\0');\n  return (size_t)(pcVar2 + (-1 - (int)__s));\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000178", 
            "calling": [
                "setFirmwareNameAndVersion", 
                "printNumber", 
                "sendString"
            ], 
            "imported": false, 
            "current_name": "strlen"
        }, 
        "staticPinModeCallback": {
            "renaming": {}, 
            "code": "\nvoid firmata::FirmataClass::staticPinModeCallback(void *param_1,uint8_t command,uint16_t value)\n\n{\n  if (*(code **)PTR_currentPinModeCallback_08002c64 != (code *)0x0) {\n    (**(code **)PTR_currentPinModeCallback_08002c64)(command,value);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002c54", 
            "calling": [], 
            "imported": false, 
            "current_name": "staticPinModeCallback"
        }, 
        "HAL_TIM_PWM_DeInit": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_TIM_PWM_DeInit(TIM_HandleTypeDef_conflict *htim)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  htim->State = HAL_TIM_STATE_BUSY;\n  pTVar1 = htim->Instance;\n  if (((pTVar1->CCER & 0x1111) == 0) && ((pTVar1->CCER & 0x444) == 0)) {\n    pTVar1->CR1 = pTVar1->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(htim);\n  htim->State = HAL_TIM_STATE_RESET;\n  htim->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005e2e", 
            "calling": [
                "pwm_stop"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_DeInit"
        }, 
        "blinkVersion": {
            "renaming": {}, 
            "code": "\nvoid __thiscall firmata::FirmataClass::blinkVersion(FirmataClass *this)\n\n{\n  if (this->blinkVersionDisabled != false) {\n    return;\n  }\n  pinMode(0xd,1);\n  strobeBlinkPin(this,'\\r',2,0x28,0xd2);\n  delay(0xfa);\n  strobeBlinkPin(this,'\\r',5,0x28,0xd2);\n  delay(0x7d);\n  return;\n}\n\n", 
            "called": [
                "pinMode", 
                "strobeBlinkPin", 
                "delay"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003002", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "blinkVersion"
        }, 
        "_exit": {
            "renaming": {}, 
            "code": "\nvoid _exit(int status_UNUSED)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [
                "_exit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008868", 
            "calling": [
                "_exit", 
                "abort"
            ], 
            "imported": false, 
            "current_name": "_exit"
        }, 
        "_sbrk_r": {
            "renaming": {}, 
            "code": "\nvoid _sbrk_r(int *param_1,int param_2)\n\n{\n  undefined *puVar1;\n  caddr_t pcVar2;\n  \n  puVar1 = PTR_errno_08009934;\n  *(undefined4 *)PTR_errno_08009934 = 0;\n  pcVar2 = _sbrk(param_2);\n  if ((pcVar2 == (caddr_t)0xffffffff) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_sbrk"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009918", 
            "calling": [
                "_malloc_r"
            ], 
            "imported": false, 
            "current_name": "_sbrk_r"
        }, 
        "_read_r": {
            "renaming": {}, 
            "code": "\nvoid _read_r(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_0800a188;\n  *(undefined4 *)PTR_errno_0800a188 = 0;\n  iVar2 = _read(param_2,param_3,param_4);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_read"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a168", 
            "calling": [
                "__sread"
            ], 
            "imported": false, 
            "current_name": "_read_r"
        }, 
        "HAL_TIM_OC_Init": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_TIM_OC_Init(TIM_HandleTypeDef_conflict *htim)\n\n{\n  if (htim != (TIM_HandleTypeDef_conflict *)0x0) {\n    if (htim->State == HAL_TIM_STATE_RESET) {\n      htim->Lock = HAL_UNLOCKED;\n      HAL_TIM_OC_MspInit(htim);\n    }\n    htim->State = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(htim->Instance,&htim->Init);\n    htim->State = HAL_TIM_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n", 
            "called": [
                "HAL_TIM_OC_MspInit", 
                "TIM_Base_SetConfig"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006060", 
            "calling": [
                "TimerPulseInit"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_OC_Init"
        }, 
        "HAL_I2C_SlaveTxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004a22", 
            "calling": [
                "I2C_SlaveTransmit_TXE", 
                "I2C_Slave_AF"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_SlaveTxCpltCallback"
        }, 
        "HAL_RCC_GetPCLK1Freq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCC_GetPCLK1Freq(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = HAL_RCC_GetHCLKFreq();\n  return uVar1 >> PTR_APBPrescTable_08005a44[(uint)(*(int *)(DAT_08005a40 + 4) << 0x15) >> 0x1d];\n}\n\n", 
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005a28", 
            "calling": [
                "getTimerClkFreq", 
                "HAL_I2C_Init", 
                "UART_SetConfig"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetPCLK1Freq"
        }, 
        "UART_Receive_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict UART_Receive_IT(UART_HandleTypeDef *huart)\n\n{\n  byte *pbVar1;\n  uint16_t uVar2;\n  uint8_t *puVar3;\n  \n  if (huart->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((huart->Init).WordLength == 0x1000) {\n    if ((huart->Init).Parity == 0) {\n      *(ushort *)huart->pRxBuffPtr = (ushort)((huart->Instance->DR << 0x17) >> 0x17);\n      huart->pRxBuffPtr = huart->pRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)huart->pRxBuffPtr = (ushort)huart->Instance->DR & 0xff;\n      huart->pRxBuffPtr = huart->pRxBuffPtr + 1;\n    }\n  }\n  else if ((huart->Init).Parity == 0) {\n    puVar3 = huart->pRxBuffPtr;\n    huart->pRxBuffPtr = puVar3 + 1;\n    *puVar3 = (uint8_t)huart->Instance->DR;\n  }\n  else {\n    pbVar1 = huart->pRxBuffPtr;\n    huart->pRxBuffPtr = pbVar1 + 1;\n    *pbVar1 = (byte)huart->Instance->DR & 0x7f;\n  }\n  uVar2 = huart->RxXferCount - 1;\n  huart->RxXferCount = uVar2;\n  if (uVar2 != 0) {\n    return HAL_OK;\n  }\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xffffffdf;\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xfffffeff;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffffe;\n  huart->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(huart);\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_UART_RxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800694c", 
            "calling": [
                "HAL_UART_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "UART_Receive_IT"
        }, 
        "I2C_Master_SB": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_Master_SB(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n    if (hi2c->EventCount == 0) {\n      hi2c->Instance->DR = hi2c->Devaddress & 0xfe;\n    }\n    else {\n      hi2c->Instance->DR = hi2c->Devaddress & 0xff | 1;\n    }\n  }\n  else if ((hi2c->Init).AddressingMode == 0x4000) {\n    if (hi2c->State == HAL_I2C_STATE_BUSY_TX) {\n      hi2c->Instance->DR = hi2c->Devaddress & 0xfe;\n    }\n    else {\n      hi2c->Instance->DR = hi2c->Devaddress & 0xff | 1;\n    }\n  }\n  else if (hi2c->EventCount == 0) {\n    hi2c->Instance->DR = (hi2c->Devaddress << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (hi2c->EventCount == 1) {\n    hi2c->Instance->DR = (hi2c->Devaddress << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800430c", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Master_SB"
        }, 
        "strstr": {
            "renaming": {}, 
            "code": "\nchar * strstr(char *__haystack,char *__needle)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  if (*__haystack == '\\0') {\n    if (*__needle != '\\0') {\n      __haystack = (char *)0x0;\n    }\n    return __haystack;\n  }\n  do {\n    pcVar1 = __haystack;\n    if (*pcVar1 == '\\0') {\n      return (char *)0x0;\n    }\n    pcVar3 = __needle + -1;\n    pcVar2 = pcVar1 + -1;\n    do {\n      pcVar3 = pcVar3 + 1;\n      if (*pcVar3 == '\\0') {\n        return pcVar1;\n      }\n      pcVar2 = pcVar2 + 1;\n      __haystack = pcVar1 + 1;\n    } while (*pcVar2 == *pcVar3);\n  } while( true );\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080099a4", 
            "calling": [
                "setFirmwareNameAndVersion"
            ], 
            "imported": false, 
            "current_name": "strstr"
        }, 
        "get_GPIO_Port": {
            "renaming": {}, 
            "code": "\nGPIO_TypeDef * get_GPIO_Port(uint32_t port_idx)\n\n{\n  switch(port_idx) {\n  case 0:\n    return DAT_08006ba4;\n  case 1:\n    return DAT_08006bb4;\n  case 2:\n    return DAT_08006ba8;\n  case 3:\n    return DAT_08006bac;\n  case 4:\n    return DAT_08006bb0;\n  default:\n    return (GPIO_TypeDef *)0x0;\n  }\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006b7c", 
            "calling": [
                "digitalRead", 
                "digitalWrite"
            ], 
            "imported": false, 
            "current_name": "get_GPIO_Port"
        }, 
        "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm": {
            "renaming": {}, 
            "code": "\nvoid _GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n", 
            "called": [
                "__static_initialization_and_destruction_0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080090b4", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
        }, 
        "aflCall": {
            "renaming": {}, 
            "code": "\nuint32_t aflCall(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000188", 
            "calling": [
                "startForkserver"
            ], 
            "imported": false, 
            "current_name": "aflCall"
        }, 
        "FirmataMarshaller": {
            "renaming": {}, 
            "code": "\nFirmataMarshaller * __thiscall\nfirmata::FirmataMarshaller::FirmataMarshaller(FirmataMarshaller *this)\n\n{\n  this->FirmataStream = (Stream *)0x0;\n  return this;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800314e", 
            "calling": [
                "FirmataClass"
            ], 
            "imported": false, 
            "current_name": "FirmataMarshaller"
        }, 
        "TIM_OC4_SetConfig": {
            "renaming": {}, 
            "code": "\nvoid TIM_OC4_SetConfig(TIM_TypeDef_conflict *TIMx,TIM_OC_InitTypeDef *OC_Config)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  \n  TIMx->CCER = TIMx->CCER & 0xffffefff;\n  uVar1 = TIMx->CR2;\n  uVar2 = OC_Config->OCMode;\n  uVar3 = OC_Config->OCPolarity;\n  if (TIMx == DAT_08005df0) {\n    uVar1 = uVar1 & 0xffffbfff | OC_Config->OCIdleState << 6;\n  }\n  TIMx->CR2 = uVar1;\n  TIMx->CCMR2 = TIMx->CCMR2 & 0xffff8cff | uVar2 << 8;\n  TIMx->CCR4 = OC_Config->Pulse;\n  TIMx->CCER = TIMx->CCER & 0xffffdfff | uVar3 << 0xc;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005dac", 
            "calling": [
                "HAL_TIM_PWM_ConfigChannel", 
                "HAL_TIM_OC_ConfigChannel"
            ], 
            "imported": false, 
            "current_name": "TIM_OC4_SetConfig"
        }, 
        "HAL_GPIO_EXTI_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)\n\n{\n  if ((*(uint *)(DAT_08004308 + 0x14) & (uint)GPIO_Pin) != 0) {\n    *(uint *)(DAT_08004308 + 0x14) = (uint)GPIO_Pin;\n    HAL_GPIO_EXTI_Callback(GPIO_Pin);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080042f0", 
            "calling": [
                "EXTI3_IRQHandler", 
                "EXTI9_5_IRQHandler", 
                "EXTI4_IRQHandler", 
                "EXTI1_IRQHandler", 
                "EXTI2_IRQHandler", 
                "EXTI15_10_IRQHandler", 
                "EXTI0_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_EXTI_IRQHandler"
        }, 
        "uart_debug_write": {
            "renaming": {}, 
            "code": "\nsize_t uart_debug_write(uint8_t *data,uint32_t size)\n\n{\n  PinName_conflict pin;\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  void *pvVar3;\n  uint32_t uVar4;\n  uint uVar5;\n  \n  uVar2 = HAL_GetTick();\n  pin = PTR_digitalPin_080085a8[1];\n  pvVar3 = pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_UART_TX_080085ac);\n  if (pvVar3 == (void *)0x0) {\n    return 0;\n  }\n  uVar5 = 0;\n  while ((uVar5 < 5 &&\n         ((*(int *)(PTR_uart_handlers_080085b0 + uVar5 * 4) == 0 ||\n          (pvVar3 = pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_UART_TX_080085ac),\n          **(void ***)(PTR_uart_handlers_080085b0 + uVar5 * 4) != pvVar3))))) {\n    uVar5 = uVar5 + 1 & 0xff;\n  }\n  if (4 < uVar5) {\n    if ((4 < (byte)PTR_serial_debug_080085b4[0x44]) &&\n       (uart_debug_init(), 4 < (byte)PTR_serial_debug_080085b4[0x44])) {\n      return 0;\n    }\n    uVar5 = (uint)(byte)PTR_serial_debug_080085b4[0x44];\n  }\n  do {\n    HVar1 = HAL_UART_Transmit(*(UART_HandleTypeDef **)(PTR_uart_handlers_080085b0 + uVar5 * 4),data,\n                              (uint16_t)size,1000);\n    if (HVar1 == HAL_OK) {\n      return size;\n    }\n    uVar4 = HAL_GetTick();\n  } while (uVar4 - uVar2 < 1000);\n  return 0;\n}\n\n", 
            "called": [
                "pinmap_peripheral", 
                "uart_debug_init", 
                "HAL_UART_Transmit", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008500", 
            "calling": [
                "_write"
            ], 
            "imported": false, 
            "current_name": "uart_debug_write"
        }, 
        "setRx": {
            "renaming": {}, 
            "code": "\nvoid __thiscall HardwareSerial::setRx(HardwareSerial *this,uint32_t _rx)\n\n{\n  PinName PVar1;\n  \n  if (_rx < 0x3c) {\n    PVar1 = PTR_digitalPin_08008d14[_rx];\n  }\n  else {\n    PVar1 = NC;\n  }\n  (this->_serial).pin_rx = PVar1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008d00", 
            "calling": [
                "HardwareSerial"
            ], 
            "imported": false, 
            "current_name": "setRx"
        }, 
        "HAL_TIM_OC_ConfigChannel": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_TIM_OC_ConfigChannel\n          (TIM_HandleTypeDef_conflict *htim,TIM_OC_InitTypeDef *sConfig,uint32_t Channel)\n\n{\n  if (htim->Lock != HAL_LOCKED) {\n    htim->Lock = HAL_LOCKED;\n    htim->State = HAL_TIM_STATE_BUSY;\n    switch(Channel) {\n    case 0:\n      TIM_OC1_SetConfig(htim->Instance,sConfig);\n      break;\n    case 4:\n      TIM_OC2_SetConfig(htim->Instance,sConfig);\n      break;\n    case 8:\n      TIM_OC3_SetConfig(htim->Instance,sConfig);\n      break;\n    case 0xc:\n      TIM_OC4_SetConfig(htim->Instance,sConfig);\n    }\n    htim->State = HAL_TIM_STATE_READY;\n    htim->Lock = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n", 
            "called": [
                "TIM_OC4_SetConfig", 
                "TIM_OC3_SetConfig", 
                "TIM_OC2_SetConfig", 
                "TIM_OC1_SetConfig"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006128", 
            "calling": [
                "TimerPulseInit"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_OC_ConfigChannel"
        }, 
        "_sbrk": {
            "renaming": {}, 
            "code": "\ncaddr_t _sbrk(int incr)\n\n{\n  caddr_t pcVar1;\n  caddr_t pcVar2;\n  \n  if (*(int *)PTR_heap_end_08008834 == 0) {\n    *(undefined **)PTR_heap_end_08008834 = PTR__ebss_08008838;\n  }\n  pcVar1 = *(caddr_t *)PTR_heap_end_08008834;\n  pcVar2 = pcVar1 + incr;\n  if (pcVar2 <= &stack0x00000000) {\n    *(caddr_t *)PTR_heap_end_08008834 = pcVar2;\n    return pcVar1;\n  }\n  *(undefined4 *)PTR_errno_0800883c = 0xc;\n  return (caddr_t)0xffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008804", 
            "calling": [
                "_sbrk_r"
            ], 
            "imported": false, 
            "current_name": "_sbrk"
        }, 
        "UART_EndRxTransfer": {
            "renaming": {}, 
            "code": "\nvoid UART_EndRxTransfer(UART_HandleTypeDef *huart)\n\n{\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xfffffedf;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffffe;\n  huart->RxState = HAL_UART_STATE_READY;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080064b0", 
            "calling": [
                "HAL_UART_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "UART_EndRxTransfer"
        }, 
        "HAL_UART_MspInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_MspInit(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800674c", 
            "calling": [
                "HAL_UART_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_MspInit"
        }, 
        "HAL_DMA_Abort_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_DMA_Abort_IT(DMA_HandleTypeDef_conflict *hdma)\n\n{\n  undefined4 uVar1;\n  DMA_Channel_TypeDef_conflict *pDVar2;\n  \n  if (hdma->State != HAL_DMA_STATE_BUSY) {\n    hdma->ErrorCode = 4;\n    return HAL_ERROR;\n  }\n  hdma->Instance->CCR = hdma->Instance->CCR & 0xfffffff1;\n  hdma->Instance->CCR = hdma->Instance->CCR & 0xfffffffe;\n  pDVar2 = hdma->Instance;\n  if (pDVar2 == DAT_080040e0) {\n    uVar1 = 1;\n  }\n  else if (pDVar2 == (DMA_Channel_TypeDef_conflict *)&DAT_080040e0[1].CNDTR) {\n    uVar1 = 0x10;\n  }\n  else if (pDVar2 == (DMA_Channel_TypeDef_conflict *)&DAT_080040e0[2].CPAR) {\n    uVar1 = 0x100;\n  }\n  else if (pDVar2 == (DMA_Channel_TypeDef_conflict *)&DAT_080040e0[3].CMAR) {\n    uVar1 = 0x1000;\n  }\n  else if (pDVar2 == DAT_080040e0 + 5) {\n    uVar1 = 0x10000;\n  }\n  else if (pDVar2 == (DMA_Channel_TypeDef_conflict *)&DAT_080040e0[6].CNDTR) {\n    uVar1 = 0x100000;\n  }\n  else {\n    uVar1 = 0x1000000;\n  }\n  *(undefined4 *)(DAT_080040e4 + 4) = uVar1;\n  hdma->State = HAL_DMA_STATE_READY;\n  hdma->Lock = HAL_UNLOCKED;\n  if (hdma->XferAbortCallback != (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0) {\n    (*hdma->XferAbortCallback)(hdma);\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004050", 
            "calling": [
                "HAL_UART_IRQHandler", 
                "I2C_ITError"
            ], 
            "imported": false, 
            "current_name": "HAL_DMA_Abort_IT"
        }, 
        "pinmap_peripheral": {
            "renaming": {}, 
            "code": "\nvoid * pinmap_peripheral(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  void *pvVar1;\n  \n  if (pin != NC) {\n    pvVar1 = pinmap_find_peripheral(pin,map);\n    return pvVar1;\n  }\n  return (void *)0x0;\n}\n\n", 
            "called": [
                "pinmap_find_peripheral"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007320", 
            "calling": [
                "uart_init", 
                "pwm_start", 
                "adc_read_value", 
                "uart_debug_init", 
                "i2c_custom_init", 
                "pwm_stop", 
                "uart_debug_write"
            ], 
            "imported": false, 
            "current_name": "pinmap_peripheral"
        }, 
        "operator()": {
            "renaming": {}, 
            "code": "\nvoid __thiscall std::function<void()>::operator__(function_void___ *this)\n\n{\n  if ((this->super__Function_base)._M_manager != (_Manager_type)0x0) {\n    (*this->_M_invoker)((_Any_data *)this);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __throw_bad_function_call();\n}\n\n", 
            "called": [
                "__throw_bad_function_call"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009084", 
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ], 
            "imported": false, 
            "current_name": "operator()"
        }, 
        "pinmap_merge_peripheral": {
            "renaming": {}, 
            "code": "\nvoid * pinmap_merge_peripheral(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080073ae", 
            "calling": [
                "uart_init", 
                "i2c_custom_init"
            ], 
            "imported": false, 
            "current_name": "pinmap_merge_peripheral"
        }, 
        "parse": {
            "renaming": {}, 
            "code": "\nvoid __thiscall firmata::FirmataParser::parse(FirmataParser *this,uint8_t inputData)\n\n{\n  byte bVar1;\n  uint uVar2;\n  size_t pos;\n  \n  uVar2 = (uint)inputData;\n  if (this->parsingSysex != false) {\n    if (uVar2 != 0xf7) {\n      bufferDataAtPosition(this,inputData,this->sysexBytesRead);\n      this->sysexBytesRead = this->sysexBytesRead + 1;\n      return;\n    }\n    this->parsingSysex = false;\n    processSysexMessage(this);\n    return;\n  }\n  if ((this->waitForData == 0) || (0x7f < uVar2)) {\n    if (uVar2 < 0xf0) {\n      this->multiByteChannel = inputData & 0xf;\n      uVar2 = uVar2 & 0xf0;\n    }\n    if (uVar2 == 0xf0) {\n      this->parsingSysex = true;\n      this->sysexBytesRead = 0;\n      return;\n    }\n    if (uVar2 < 0xf1) {\n      if (uVar2 != 0xc0) {\n        if (uVar2 < 0xc1) {\n          if (uVar2 != 0x90) {\n            return;\n          }\n        }\n        else {\n          if (uVar2 == 0xd0) goto LAB_0800359c;\n          if (uVar2 != 0xe0) {\n            return;\n          }\n        }\nLAB_08003586:\n        this->waitForData = 2;\n        this->executeMultiByteCommand = (uint8_t)uVar2;\n        return;\n      }\nLAB_0800359c:\n      this->waitForData = 1;\n      this->executeMultiByteCommand = (uint8_t)uVar2;\n      return;\n    }\n    if (uVar2 != 0xf9) {\n      if (0xf9 < uVar2) {\n        if (uVar2 == 0xff) {\n          systemReset(this);\n          return;\n        }\n        return;\n      }\n      if (1 < uVar2 - 0xf4) {\n        return;\n      }\n      goto LAB_08003586;\n    }\n    if (this->currentReportVersionCallback != (systemCallbackFunction)0x0) {\n      (*this->currentReportVersionCallback)(this->currentReportVersionCallbackContext);\n    }\n  }\n  else {\n    pos = this->waitForData - 1;\n    this->waitForData = pos;\n    bufferDataAtPosition(this,inputData,pos);\n    if ((this->waitForData == 0) && (bVar1 = this->executeMultiByteCommand, bVar1 != 0)) {\n      if (bVar1 == 0xd0) {\n        if (this->currentReportDigitalCallback != (callbackFunction)0x0) {\n          (*this->currentReportDigitalCallback)\n                    (this->currentReportDigitalCallbackContext,this->multiByteChannel,\n                     (uint16_t)*this->dataBuffer);\n        }\n      }\n      else if (bVar1 < 0xd1) {\n        if (bVar1 == 0x90) {\n          if (this->currentDigitalCallback != (callbackFunction)0x0) {\n            (*this->currentDigitalCallback)\n                      (this->currentDigitalCallbackContext,this->multiByteChannel,\n                       (ushort)this->dataBuffer[1] + (ushort)*this->dataBuffer * 0x80);\n          }\n        }\n        else if ((bVar1 == 0xc0) && (this->currentReportAnalogCallback != (callbackFunction)0x0)) {\n          (*this->currentReportAnalogCallback)\n                    (this->currentReportAnalogCallbackContext,this->multiByteChannel,\n                     (uint16_t)*this->dataBuffer);\n        }\n      }\n      else if (bVar1 == 0xf4) {\n        if (this->currentPinModeCallback != (callbackFunction)0x0) {\n          (*this->currentPinModeCallback)\n                    (this->currentPinModeCallbackContext,this->dataBuffer[1],\n                     (uint16_t)*this->dataBuffer);\n        }\n      }\n      else if (bVar1 == 0xf5) {\n        if (this->currentPinValueCallback != (callbackFunction)0x0) {\n          (*this->currentPinValueCallback)\n                    (this->currentPinValueCallbackContext,this->dataBuffer[1],\n                     (uint16_t)*this->dataBuffer);\n        }\n      }\n      else if ((bVar1 == 0xe0) && (this->currentAnalogCallback != (callbackFunction)0x0)) {\n        (*this->currentAnalogCallback)\n                  (this->currentAnalogCallbackContext,this->multiByteChannel,\n                   (ushort)this->dataBuffer[1] + (ushort)*this->dataBuffer * 0x80);\n      }\n      this->executeMultiByteCommand = '\\0';\n      return;\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "processSysexMessage", 
                "systemReset", 
                "bufferDataAtPosition"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003474", 
            "calling": [
                "processInput"
            ], 
            "imported": false, 
            "current_name": "parse"
        }, 
        "i2c_attachSlaveTxEvent": {
            "renaming": {}, 
            "code": "\nvoid i2c_attachSlaveTxEvent(i2c_t_conflict *obj,_func_void *function)\n\n{\n  if (obj != (i2c_t_conflict *)0x0) {\n    if (function != (_func_void *)0x0) {\n      obj->i2c_onSlaveTransmit = function;\n      HAL_I2C_EnableListen_IT(&obj->handle);\n    }\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_EnableListen_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007f8e", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "i2c_attachSlaveTxEvent"
        }, 
        "HAL_RCC_ClockConfig": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_RCC_ClockConfig(RCC_ClkInitTypeDef_conflict *RCC_ClkInitStruct,uint32_t FLatency)\n\n{\n  uint *puVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  uint uVar4;\n  \n  puVar1 = DAT_08005a0c;\n  if (((*DAT_08005a0c & 7) < FLatency) &&\n     (*DAT_08005a0c = *DAT_08005a0c & 0xfffffff8 | FLatency, FLatency != (*puVar1 & 7))) {\n    return HAL_ERROR;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 2) != 0) {\n    DAT_08005a10[1] = DAT_08005a10[1] & 0xffffff0f | RCC_ClkInitStruct->AHBCLKDivider;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 1) != 0) {\n    uVar4 = RCC_ClkInitStruct->SYSCLKSource;\n    if (uVar4 == 1) {\n      if ((*DAT_08005a10 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((uVar4 != 2) && ((*DAT_08005a10 & 2) == 0)) {\n      return HAL_ERROR;\n    }\n    DAT_08005a10[1] = uVar4 | DAT_08005a10[1] & 0xfffffffc;\n    uVar2 = HAL_GetTick();\n    if (RCC_ClkInitStruct->SYSCLKSource == 1) {\n      while ((DAT_08005a10[1] & 0xc) != 4) {\n        uVar3 = HAL_GetTick();\n        if (5000 < uVar3 - uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else if (RCC_ClkInitStruct->SYSCLKSource == 2) {\n      while ((DAT_08005a10[1] & 0xc) != 8) {\n        uVar3 = HAL_GetTick();\n        if (5000 < uVar3 - uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      while ((DAT_08005a10[1] & 0xc) != 0) {\n        uVar3 = HAL_GetTick();\n        if (5000 < uVar3 - uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  puVar1 = DAT_08005a0c;\n  if ((FLatency < (*DAT_08005a0c & 7)) &&\n     (*DAT_08005a0c = *DAT_08005a0c & 0xfffffff8 | FLatency, FLatency != (*puVar1 & 7))) {\n    return HAL_ERROR;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 4) != 0) {\n    DAT_08005a10[1] = DAT_08005a10[1] & 0xfffff8ff | RCC_ClkInitStruct->APB1CLKDivider;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 8) != 0) {\n    DAT_08005a10[1] = DAT_08005a10[1] & 0xffffc7ff | RCC_ClkInitStruct->APB2CLKDivider << 3;\n  }\n  uVar4 = HAL_RCC_GetSysClockFreq();\n  *(uint *)PTR_SystemCoreClock_08005a18 =\n       uVar4 >> PTR_AHBPrescTable_08005a14[(DAT_08005a10[1] << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_InitTick", 
                "HAL_RCC_GetSysClockFreq", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080058ac", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_ClockConfig"
        }, 
        "print": {
            "renaming": {}, 
            "code": "\nsize_t __thiscall Print::print(Print *this,uchar b,int base)\n\n{\n  size_t sVar1;\n  \n  sVar1 = print(this,(uint)b,base);\n  return sVar1;\n}\n\n", 
            "called": [
                "print"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008eec", 
            "calling": [
                "printTo"
            ], 
            "imported": false, 
            "current_name": "print"
        }, 
        "__swhatbuf_r": {
            "renaming": {}, 
            "code": "\nundefined4 __swhatbuf_r(undefined4 param_1,int param_2,undefined4 *param_3,uint *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_4c [4];\n  uint local_48;\n  \n  if ((*(short *)(param_2 + 0xe) < 0) ||\n     (iVar1 = _fstat_r(param_1,(int)*(short *)(param_2 + 0xe),auStack_4c), iVar1 < 0)) {\n    *param_4 = 0;\n    if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x18) < 0) {\n      uVar2 = 0x40;\n      goto LAB_08009ea4;\n    }\n  }\n  else {\n    *param_4 = (uint)((local_48 & 0xf000) == 0x2000);\n  }\n  uVar2 = 0x400;\nLAB_08009ea4:\n  *param_3 = uVar2;\n  return 0;\n}\n\n", 
            "called": [
                "_fstat_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009e64", 
            "calling": [
                "__smakebuf_r"
            ], 
            "imported": false, 
            "current_name": "__swhatbuf_r"
        }, 
        "HAL_I2C_ErrorCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_ErrorCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  i2c_t_conflict *piVar1;\n  \n  piVar1 = get_i2c_obj(hi2c);\n  if (piVar1->isMaster == '\\0') {\n    HAL_I2C_EnableListen_IT(hi2c);\n  }\n  return;\n}\n\n", 
            "called": [
                "get_i2c_obj", 
                "HAL_I2C_EnableListen_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008020", 
            "calling": [
                "I2C_DMAAbort", 
                "I2C_ITError"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_ErrorCallback"
        }, 
        "I2C_SlaveReceive_BTF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_SlaveReceive_BTF(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  uint8_t *puVar1;\n  \n  if (hi2c->XferCount != 0) {\n    puVar1 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar1 + 1;\n    *puVar1 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800459c", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_SlaveReceive_BTF"
        }, 
        "_fstat_r": {
            "renaming": {}, 
            "code": "\nvoid _fstat_r(int *param_1,int param_2,stat *param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_0800a10c;\n  *(undefined4 *)PTR_errno_0800a10c = 0;\n  iVar2 = _fstat(param_2,param_3);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_fstat"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a0ec", 
            "calling": [
                "__swhatbuf_r"
            ], 
            "imported": false, 
            "current_name": "_fstat_r"
        }, 
        "setup": {
            "renaming": {}, 
            "code": "\nvoid setup(void)\n\n{\n  undefined *this;\n  \n  this = PTR_Firmata_08001bc0;\n  firmata::FirmataClass::setFirmwareNameAndVersion\n            ((FirmataClass *)PTR_Firmata_08001bc0,PTR_s__home_bo_p2im_p2im_real_firmware_08001bc4,\n             '\\x02','\\x05');\n  firmata::FirmataClass::attach((FirmataClass *)this,0xe0,DAT_08001bc8);\n  firmata::FirmataClass::attach((FirmataClass *)this,0x90,DAT_08001bcc);\n  firmata::FirmataClass::attach((FirmataClass *)this,0xc0,DAT_08001bd0);\n  firmata::FirmataClass::attach((FirmataClass *)this,0xd0,DAT_08001bd4);\n  firmata::FirmataClass::attach((FirmataClass *)this,0xf4,DAT_08001bd8);\n  firmata::FirmataClass::attach((FirmataClass *)this,0xf5,DAT_08001bdc);\n  firmata::FirmataClass::attach((FirmataClass *)this,0xf0,DAT_08001be0);\n  firmata::FirmataClass::attach((FirmataClass *)this,0xff,DAT_08001be4);\n  firmata::FirmataClass::begin((FirmataClass *)this,0xe100);\n  systemResetCallback();\n  startForkserver(0);\n  return;\n}\n\n", 
            "called": [
                "attach", 
                "attach", 
                "startForkserver", 
                "begin", 
                "setFirmwareNameAndVersion", 
                "systemResetCallback", 
                "attach"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001b48", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "setup"
        }, 
        "RTC_Alarm_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid RTC_Alarm_IRQHandler(void)\n\n{\n  HAL_RTC_AlarmIRQHandler((RTC_HandleTypeDef *)PTR_RtcHandle_080073e4);\n  return;\n}\n\n", 
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080073d8", 
            "calling": [], 
            "imported": false, 
            "current_name": "RTC_Alarm_IRQHandler"
        }, 
        "USART1_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid USART1_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART1_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)PTR_uart_handlers_080087d0);\n  return;\n}\n\n", 
            "called": [
                "HAL_NVIC_ClearPendingIRQ", 
                "HAL_UART_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080087bc", 
            "calling": [], 
            "imported": false, 
            "current_name": "USART1_IRQHandler"
        }, 
        "UART_Transmit_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict UART_Transmit_IT(UART_HandleTypeDef *huart)\n\n{\n  uint16_t uVar1;\n  byte *pbVar2;\n  \n  if (huart->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((huart->Init).WordLength == 0x1000) {\n    huart->Instance->DR = *(ushort *)huart->pTxBuffPtr & 0x1ff;\n    if ((huart->Init).Parity == 0) {\n      huart->pTxBuffPtr = huart->pTxBuffPtr + 2;\n    }\n    else {\n      huart->pTxBuffPtr = huart->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    pbVar2 = huart->pTxBuffPtr;\n    huart->pTxBuffPtr = pbVar2 + 1;\n    huart->Instance->DR = (uint)*pbVar2;\n  }\n  uVar1 = huart->TxXferCount - 1;\n  huart->TxXferCount = uVar1;\n  if (uVar1 == 0) {\n    huart->Instance->CR1 = huart->Instance->CR1 & 0xffffff7f;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080064cc", 
            "calling": [
                "HAL_UART_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "UART_Transmit_IT"
        }, 
        "writeMicroseconds": {
            "renaming": {}, 
            "code": "\nvoid __thiscall Servo::writeMicroseconds(Servo *this,int value)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  if (this->servoIndex < 0xc) {\n    iVar1 = (0x88 - this->min) * 4;\n    if ((iVar1 - value == 0 || iVar1 < value) &&\n       (iVar2 = 600 - this->max, iVar1 = iVar2 * 4,\n       value == iVar1 || value + iVar2 * -4 < 0 != SBORROW4(value,iVar1))) {\n      iVar1 = value;\n    }\n    *(int *)(PTR_servos_080026ac + (uint)this->servoIndex * 8 + 4) = iVar1;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800267c", 
            "calling": [
                "write"
            ], 
            "imported": false, 
            "current_name": "writeMicroseconds"
        }, 
        "HAL_GPIO_EXTI_Callback": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n\n{\n  byte bVar1;\n  \n  bVar1 = get_pin_id(GPIO_Pin);\n  if (*(int *)(PTR_gpio_irq_conf_080090b0 + (uint)bVar1 * 0x14 + 0xc) != 0) {\n    std::function<void()>::operator__\n              ((function_void___ *)(PTR_gpio_irq_conf_080090b0 + (uint)bVar1 * 0x14 + 4));\n  }\n  return;\n}\n\n", 
            "called": [
                "operator()", 
                "get_pin_id"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009094", 
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_EXTI_Callback"
        }, 
        "HAL_TIM_PWM_PulseFinishedCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005e6a", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_PulseFinishedCallback"
        }, 
        "iprintf": {
            "renaming": {}, 
            "code": "\nint iprintf(char *__format,...)\n\n{\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  int iVar1;\n  char *pcVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  iVar1 = *(int *)PTR__impure_ptr_08009904;\n  pcVar2 = __format;\n  uStack_c = in_r1;\n  uStack_8 = in_r2;\n  uStack_4 = in_r3;\n  if ((iVar1 != 0) && (*(int *)(iVar1 + 0x18) == 0)) {\n    __sinit(iVar1);\n  }\n  iVar1 = _vfiprintf_r(iVar1,*(undefined4 *)(iVar1 + 8),__format,&uStack_c,pcVar2,&uStack_c);\n  return iVar1;\n}\n\n", 
            "called": [
                "__sinit", 
                "_vfiprintf_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080098d8", 
            "calling": [
                "uart_init", 
                "i2c_custom_init", 
                "getTimerClkFreq", 
                "getTimerIrq", 
                "getTimerClkSrc"
            ], 
            "imported": false, 
            "current_name": "iprintf"
        }, 
        "I2C_Slave_STOPF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_Slave_STOPF(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  HAL_I2C_StateTypeDef_conflict HVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  uint8_t *puVar3;\n  uint32_t tmpreg;\n  \n  HVar1 = hi2c->State;\n  hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 | 1;\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n  pIVar2 = hi2c->Instance;\n  if ((pIVar2->CR2 & 0x800) != 0) {\n    if ((hi2c->State == HAL_I2C_STATE_BUSY_RX) || (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      hi2c->XferCount = (uint16_t)hi2c->hdmarx->Instance->CNDTR;\n    }\n    else {\n      hi2c->XferCount = (uint16_t)hi2c->hdmatx->Instance->CNDTR;\n    }\n  }\n  if (hi2c->XferCount != 0) {\n    if ((pIVar2->SR1 & 4) != 0) {\n      puVar3 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = puVar3 + 1;\n      *puVar3 = (uint8_t)pIVar2->DR;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n    if ((hi2c->Instance->SR1 & 0x40) != 0) {\n      puVar3 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = puVar3 + 1;\n      *puVar3 = (uint8_t)hi2c->Instance->DR;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n    hi2c->ErrorCode = hi2c->ErrorCode | 4;\n  }\n  if (hi2c->ErrorCode == 0) {\n    if (((HVar1 == HAL_I2C_STATE_LISTEN) || (HVar1 == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (HVar1 == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c->XferOptions = DAT_08005184;\n      hi2c->PreviousState = 0;\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(hi2c);\n    }\n    else if ((hi2c->PreviousState == 0x22) || (HVar1 == HAL_I2C_STATE_BUSY_RX)) {\n      hi2c->PreviousState = 0;\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(hi2c);\n    }\n  }\n  else {\n    I2C_ITError(hi2c);\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_SlaveRxCpltCallback", 
                "HAL_I2C_ListenCpltCallback", 
                "I2C_ITError"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005084", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Slave_STOPF"
        }, 
        "uart_index": {
            "renaming": {}, 
            "code": "\nuint8_t uart_index(UART_HandleTypeDef *huart)\n\n{\n  uint uVar1;\n  \n  if (huart == (UART_HandleTypeDef *)0x0) {\n    uVar1 = 5;\n  }\n  else {\n    uVar1 = 0;\n    while( true ) {\n      if (4 < uVar1) {\n        return (uint8_t)uVar1;\n      }\n      if (huart == *(UART_HandleTypeDef **)(PTR_uart_handlers_08008708 + uVar1 * 4)) break;\n      uVar1 = uVar1 + 1 & 0xff;\n    }\n  }\n  return (uint8_t)uVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080086e8", 
            "calling": [
                "HAL_UART_TxCpltCallback", 
                "HAL_UART_RxCpltCallback"
            ], 
            "imported": false, 
            "current_name": "uart_index"
        }, 
        "endTransmission": {
            "renaming": {}, 
            "code": "\nuint8_t __thiscall TwoWire::endTransmission(TwoWire *this)\n\n{\n  uint8_t uVar1;\n  \n  uVar1 = endTransmission(this,'\\x01');\n  return uVar1;\n}\n\n", 
            "called": [
                "endTransmission"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002ac0", 
            "calling": [
                "sysexCallback"
            ], 
            "imported": false, 
            "current_name": "endTransmission"
        }, 
        "i2c_attachSlaveRxEvent": {
            "renaming": {}, 
            "code": "\nvoid i2c_attachSlaveRxEvent(i2c_t_conflict *obj,_func_void_uint8_t_ptr_int *function)\n\n{\n  if (obj != (i2c_t_conflict *)0x0) {\n    if (function != (_func_void_uint8_t_ptr_int *)0x0) {\n      obj->i2c_onSlaveReceive = function;\n      HAL_I2C_EnableListen_IT(&obj->handle);\n    }\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_EnableListen_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007f7c", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "i2c_attachSlaveRxEvent"
        }, 
        "EXTI3_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI3_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(8);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009042", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI3_IRQHandler"
        }, 
        "i2c_custom_init": {
            "renaming": {}, 
            "code": "\nvoid i2c_custom_init(i2c_t_conflict *obj,i2c_timing_e_conflict timing,uint32_t addressingMode,\n                    uint32_t ownAddress,uint8_t master)\n\n{\n  undefined *puVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  void *a;\n  void *b;\n  I2C_TypeDef_conflict *pIVar3;\n  GPIO_TypeDef *pGVar4;\n  uint32_t uVar5;\n  uint32_t uVar6;\n  I2C_HandleTypeDef_conflict *hi2c;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_2;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj != (i2c_t_conflict *)0x0) {\n    hi2c = &obj->handle;\n    a = pinmap_peripheral(obj->sda,(PinMap_conflict *)PTR_PinMap_I2C_SDA_08007a74);\n    b = pinmap_peripheral(obj->scl,(PinMap_conflict *)PTR_PinMap_I2C_SCL_08007a78);\n    if ((a == (void *)0x0) || (b == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_I2C_pin_has_n_08007a88);\n    }\n    else {\n      pIVar3 = (I2C_TypeDef_conflict *)pinmap_merge_peripheral(a,b);\n      obj->i2c = pIVar3;\n      pIVar2 = DAT_08007a7c;\n      if (pIVar3 == (I2C_TypeDef_conflict *)0x0) {\n        iprintf(PTR_s_ERROR__I2C_pins_mismatch_08007a8c);\n      }\n      else {\n        if (pIVar3 == DAT_08007a7c) {\n          DAT_08007a7c[0xc56].CR2 = DAT_08007a7c[0xc56].CR2 | 0x200000;\n          pIVar2[0xc55].CCR = pIVar2[0xc55].CCR | 0x200000;\n          pIVar2[0xc55].CCR = pIVar2[0xc55].CCR & 0xffdfffff;\n          obj->irq = I2C1_EV_IRQn;\n          obj->irqER = I2C1_ER_IRQn;\n          *(I2C_HandleTypeDef_conflict **)PTR_i2c_handles_08007a90 = hi2c;\n        }\n        pIVar2 = DAT_08007a80;\n        if (obj->i2c == DAT_08007a80) {\n          DAT_08007a80[0xc39].SR2 = DAT_08007a80[0xc39].SR2 | 0x400000;\n          pIVar2[0xc39].OAR2 = pIVar2[0xc39].OAR2 | 0x400000;\n          pIVar2[0xc39].OAR2 = pIVar2[0xc39].OAR2 & 0xffbfffff;\n          obj->irq = I2C2_EV_IRQn;\n          obj->irqER = I2C2_ER_IRQn;\n          *(I2C_HandleTypeDef_conflict **)(PTR_i2c_handles_08007a90 + 4) = hi2c;\n        }\n        pGVar4 = set_GPIO_Port_Clock((uint)((int)obj->scl << 0x18) >> 0x1c);\n        puVar1 = PTR_PinMap_I2C_SCL_08007a78;\n        GPIO_InitStruct.Pin = 1 << ((int)obj->scl & 0xfU) & 0xffff;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)PTR_PinMap_I2C_SCL_08007a78);\n        uVar6 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Mode = (uVar5 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Speed = 3;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Pull = (uVar5 << 0x1a) >> 0x1e;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        *(uint *)(DAT_08007a84 + 0x18) = *(uint *)(DAT_08007a84 + 0x18) | 1;\n        switch((uVar5 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x4000000;\n        }\n        HAL_GPIO_Init(pGVar4,&GPIO_InitStruct);\n        pGVar4 = set_GPIO_Port_Clock((uint)((int)obj->sda << 0x18) >> 0x1c);\n        puVar1 = PTR_PinMap_I2C_SDA_08007a74;\n        GPIO_InitStruct.Pin = 1 << ((int)obj->sda & 0xfU) & 0xffff;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)PTR_PinMap_I2C_SDA_08007a74);\n        uVar6 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Mode = (uVar5 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Speed = 3;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Pull = (uVar5 << 0x1a) >> 0x1e;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        *(uint *)(DAT_08007a84 + 0x18) = *(uint *)(DAT_08007a84 + 0x18) | 1;\n        switch((uVar5 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x4000000;\n        }\n        HAL_GPIO_Init(pGVar4,&GPIO_InitStruct);\n        (obj->handle).Instance = obj->i2c;\n        (obj->handle).Init.ClockSpeed = timing;\n        (obj->handle).Init.DutyCycle = 0;\n        (obj->handle).Init.OwnAddress1 = ownAddress;\n        (obj->handle).Init.OwnAddress2 = 0xff;\n        (obj->handle).Init.AddressingMode = addressingMode;\n        (obj->handle).Init.DualAddressMode = 0;\n        (obj->handle).Init.GeneralCallMode = 0;\n        (obj->handle).Init.NoStretchMode = 0;\n        (obj->handle).State = HAL_I2C_STATE_RESET;\n        HAL_NVIC_SetPriority(obj->irq,0,1);\n        HAL_NVIC_EnableIRQ(obj->irq);\n        HAL_NVIC_SetPriority(obj->irqER,0,1);\n        HAL_NVIC_EnableIRQ(obj->irqER);\n        HAL_I2C_Init(hi2c);\n        obj->isMaster = master;\n      }\n    }\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "pinmap_peripheral", 
                "pinmap_merge_peripheral", 
                "set_GPIO_Port_Clock", 
                "HAL_NVIC_SetPriority", 
                "HAL_NVIC_EnableIRQ", 
                "iprintf", 
                "HAL_GPIO_Init", 
                "HAL_I2C_Init", 
                "pinmap_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080077b0", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "i2c_custom_init"
        }, 
        "write": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08008e62 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nsize_t __thiscall Print::write(Print *this,uint8_t *buffer,size_t size)\n\n{\n  Print *pPVar1;\n  size_t sVar2;\n  \n  sVar2 = 0;\n  pPVar1 = this;\n  while( true ) {\n    if (size == 0) {\n      return sVar2;\n    }\n    pPVar1 = (Print *)(**this->_vptr_Print)(pPVar1,(uint)*buffer);\n    if (pPVar1 == (Print *)0x0) break;\n    sVar2 = sVar2 + 1;\n    buffer = buffer + 1;\n    size = size - 1;\n  }\n  return sVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008e4e", 
            "calling": [], 
            "imported": false, 
            "current_name": "write"
        }, 
        "HAL_SYSTICK_Config": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 = DAT_08003ffc;\n  if (TicksNumb - 1 < 0x1000000) {\n    DAT_08003ffc[1] = TicksNumb - 1;\n    *(undefined *)(DAT_08004000 + 0x23) = 0xf0;\n    puVar1[2] = 0;\n    *puVar1 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003fd8", 
            "calling": [
                "HAL_InitTick", 
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_Config"
        }, 
        "init": {
            "renaming": {}, 
            "code": "\nint __thiscall HardwareSerial::init(HardwareSerial *this,EVP_PKEY_CTX *ctx)\n\n{\n  (this->_serial).rx_buff = this->_rx_buffer;\n  (this->_serial).rx_head = 0;\n  (this->_serial).rx_tail = 0;\n  (this->_serial).tx_buff = this->_tx_buffer;\n  (this->_serial).tx_head = 0;\n  (this->_serial).tx_tail = 0;\n  return (int)this;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008c20", 
            "calling": [
                "HardwareSerial"
            ], 
            "imported": false, 
            "current_name": "init"
        }, 
        "HAL_UART_RxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n\n{\n  byte bVar1;\n  uint uVar2;\n  \n  bVar1 = uart_index(huart);\n  uVar2 = (uint)bVar1;\n  if (uVar2 < 5) {\n    (**(code **)(PTR_rx_callback_08008728 + uVar2 * 4))\n              (*(undefined4 *)(PTR_rx_callback_obj_0800872c + uVar2 * 4));\n  }\n  return;\n}\n\n", 
            "called": [
                "uart_index"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800870c", 
            "calling": [
                "UART_Receive_IT"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_RxCpltCallback"
        }, 
        "_Error_Handler": {
            "renaming": {}, 
            "code": "\nvoid _Error_Handler(char *msg,int val)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [
                "_Error_Handler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080073e8", 
            "calling": [
                "onReceiveService", 
                "_Error_Handler", 
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "_Error_Handler"
        }, 
        "setPinValueCallback": {
            "renaming": {}, 
            "code": "\nvoid setPinValueCallback(byte pin,int value)\n\n{\n  bool bVar1;\n  byte bVar2;\n  uint ulPin;\n  uint32_t uVar3;\n  \n  ulPin = (uint)pin;\n  if (ulPin < 0x3c) {\n    if (ulPin < 0x3c) {\n      if (PTR_digitalPin_0800020c[ulPin] == NC) {\n        bVar1 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_0800020c[ulPin]);\n        if (uVar3 == 0) {\n          bVar1 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_0800020c[ulPin]);\n          if (uVar3 == 1) {\n            bVar1 = false;\n          }\n          else {\n            bVar1 = true;\n          }\n        }\n      }\n    }\n    else {\n      bVar1 = false;\n    }\n  }\n  else {\n    bVar1 = false;\n  }\n  if ((bVar1) &&\n     (bVar2 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000210,pin),\n     bVar2 == '\\x01')) {\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000210,pin,value);\n    digitalWrite(ulPin,value);\n  }\n  return;\n}\n\n", 
            "called": [
                "getPinMode", 
                "pinNametoDigitalPin", 
                "setPinState", 
                "digitalWrite"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080001a8", 
            "calling": [], 
            "imported": false, 
            "current_name": "setPinValueCallback"
        }, 
        "setFirmwareNameAndVersion": {
            "renaming": {}, 
            "code": "\nvoid __thiscall\nfirmata::FirmataClass::setFirmwareNameAndVersion\n          (FirmataClass *this,char *name,byte major,byte minor)\n\n{\n  byte bVar1;\n  char *pcVar2;\n  char *pcVar3;\n  byte *pbVar4;\n  size_t sVar5;\n  \n  pcVar2 = strstr(name,PTR_s__cpp_08002ec0);\n  pcVar3 = strrchr(name,0x2f);\n  if (pcVar3 == (char *)0x0) {\n    pcVar3 = strrchr(name,0x5c);\n  }\n  if (pcVar3 != (char *)0x0) {\n    name = pcVar3 + 1;\n  }\n  if (pcVar2 == (char *)0x0) {\n    sVar5 = strlen(name);\n    this->firmwareVersionCount = (char)sVar5 + '\\x02';\n  }\n  else {\n    this->firmwareVersionCount = ((char)pcVar2 - (char)name) + '\\x02';\n  }\n  free(this->firmwareVersionVector);\n  bVar1 = this->firmwareVersionCount;\n  pbVar4 = (byte *)malloc(bVar1 + 1);\n  this->firmwareVersionVector = pbVar4;\n  pbVar4[bVar1] = '\\0';\n  *pbVar4 = major;\n  pbVar4[1] = minor;\n  strncpy((char *)(pbVar4 + 2),name,this->firmwareVersionCount - 2);\n  return;\n}\n\n", 
            "called": [
                "strncpy", 
                "malloc", 
                "strstr", 
                "strrchr", 
                "free", 
                "strlen"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002e44", 
            "calling": [
                "setup"
            ], 
            "imported": false, 
            "current_name": "setFirmwareNameAndVersion"
        }, 
        "__smakebuf_r": {
            "renaming": {}, 
            "code": "\nvoid __smakebuf_r(int param_1,int *param_2)\n\n{\n  ushort uVar1;\n  int iVar2;\n  int local_18;\n  int *local_14;\n  \n  if (-1 < (int)((uint)*(ushort *)(param_2 + 3) << 0x1e)) {\n    local_18 = param_1;\n    local_14 = param_2;\n    uVar1 = __swhatbuf_r(param_1,param_2,&local_18,&local_14);\n    iVar2 = _malloc_r(param_1,local_18);\n    if (iVar2 != 0) {\n      *(undefined4 *)(param_1 + 0x28) = DAT_08009f28;\n      *param_2 = iVar2;\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 0x80;\n      param_2[4] = iVar2;\n      param_2[5] = local_18;\n      if ((local_14 != (int *)0x0) &&\n         (iVar2 = _isatty_r(param_1,(int)*(short *)((int)param_2 + 0xe)), iVar2 != 0)) {\n        *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(param_2 + 3) = uVar1 | *(ushort *)(param_2 + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(param_2 + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xfffc | 2;\n  }\n  *param_2 = (int)param_2 + 0x47;\n  param_2[4] = (int)param_2 + 0x47;\n  param_2[5] = 1;\n  return;\n}\n\n", 
            "called": [
                "_malloc_r", 
                "__swhatbuf_r", 
                "_isatty_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009eac", 
            "calling": [
                "__swsetup_r"
            ], 
            "imported": false, 
            "current_name": "__smakebuf_r"
        }, 
        "pinNametoDigitalPin": {
            "renaming": {}, 
            "code": "\nuint32_t pinNametoDigitalPin(PinName_conflict p)\n\n{\n  uint32_t uVar1;\n  \n  if ((uint)((int)p << 0x18) >> 0x1c < 5) {\n    for (uVar1 = 0; (uVar1 < 0x3c && ((int)p != (int)(char)PTR_digitalPin_080036d0[uVar1]));\n        uVar1 = uVar1 + 1) {\n    }\n  }\n  else {\n    uVar1 = 0xffffffff;\n  }\n  return uVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080036ac", 
            "calling": [
                "loop", 
                "analogWriteCallback", 
                "setPinModeCallback", 
                "digitalWriteCallback", 
                "checkDigitalInputs", 
                "enableI2CPins", 
                "systemResetCallback", 
                "setPinValueCallback", 
                "reportDigitalCallback", 
                "sysexCallback"
            ], 
            "imported": false, 
            "current_name": "pinNametoDigitalPin"
        }, 
        "HAL_TIM_IC_CaptureCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005e68", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_IC_CaptureCallback"
        }, 
        "HAL_TIM_OC_Stop_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef_conflict *htim,uint32_t Channel)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  switch(Channel) {\n  case 0:\n    htim->Instance->DIER = htim->Instance->DIER & 0xfffffffd;\n    break;\n  case 4:\n    htim->Instance->DIER = htim->Instance->DIER & 0xfffffffb;\n    break;\n  case 8:\n    htim->Instance->DIER = htim->Instance->DIER & 0xfffffff7;\n    break;\n  case 0xc:\n    htim->Instance->DIER = htim->Instance->DIER & 0xffffffef;\n  }\n  TIM_CCxChannelCmd(htim->Instance,Channel,0);\n  pTVar1 = htim->Instance;\n  if (((pTVar1 == DAT_0800638c) && ((pTVar1->CCER & 0x1111) == 0)) && ((pTVar1->CCER & 0x444) == 0))\n  {\n    pTVar1->BDTR = pTVar1->BDTR & 0xffff7fff;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->CCER & 0x1111) == 0) && ((pTVar1->CCER & 0x444) == 0)) {\n    pTVar1->CR1 = pTVar1->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "TIM_CCxChannelCmd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080062f4", 
            "calling": [
                "TimerPulseDeinit"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_OC_Stop_IT"
        }, 
        "outputPort": {
            "renaming": {}, 
            "code": "\nvoid outputPort(byte portNumber,byte portValue,byte forceSend)\n\n{\n  byte bVar1;\n  \n  bVar1 = PTR_portConfigInputs_08000c0c[portNumber] & portValue;\n  if ((forceSend != '\\0') || ((uint)bVar1 != (uint)(byte)PTR_previousPINs_08000c10[portNumber])) {\n    firmata::FirmataClass::sendDigitalPort\n              ((FirmataClass *)PTR_Firmata_08000c14,portNumber,(uint)bVar1);\n    PTR_previousPINs_08000c10[portNumber] = bVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "sendDigitalPort"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000be8", 
            "calling": [
                "checkDigitalInputs", 
                "reportDigitalCallback"
            ], 
            "imported": false, 
            "current_name": "outputPort"
        }, 
        "_lseek_r": {
            "renaming": {}, 
            "code": "\nvoid _lseek_r(int *param_1,int param_2,int param_3,int param_4)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_0800a150;\n  *(undefined4 *)PTR_errno_0800a150 = 0;\n  iVar2 = _lseek(param_2,param_3,param_4);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_lseek"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a130", 
            "calling": [
                "__sseek", 
                "__swrite"
            ], 
            "imported": false, 
            "current_name": "_lseek_r"
        }, 
        "__sfmoreglue": {
            "renaming": {}, 
            "code": "\nundefined4 * __sfmoreglue(undefined4 param_1,int param_2)\n\n{\n  undefined4 *puVar1;\n  int iVar2;\n  \n  iVar2 = (param_2 + -1) * 0x68;\n  puVar1 = (undefined4 *)_malloc_r(param_1,iVar2 + 0x74);\n  if (puVar1 != (undefined4 *)0x0) {\n    *puVar1 = 0;\n    puVar1[1] = param_2;\n    puVar1[2] = puVar1 + 3;\n    memset(puVar1 + 3,0,iVar2 + 0x68);\n  }\n  return puVar1;\n}\n\n", 
            "called": [
                "_malloc_r", 
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009d24", 
            "calling": [
                "__sfp"
            ], 
            "imported": false, 
            "current_name": "__sfmoreglue"
        }, 
        "pinmap_find_pin": {
            "renaming": {}, 
            "code": "\nPinName_conflict pinmap_find_pin(void *peripheral,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map->peripheral == (void *)0x0) {\n      return NC;\n    }\n    if (map->peripheral == peripheral) break;\n    map = map + 1;\n  }\n  return map->pin;\n}\n\n", 
            "called": [
                "pinmap_find_pin"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007332", 
            "calling": [
                "pinmap_pin", 
                "pinmap_find_pin"
            ], 
            "imported": false, 
            "current_name": "pinmap_find_pin"
        }, 
        "_raise_r": {
            "renaming": {}, 
            "code": "\nundefined4 _raise_r(undefined4 *param_1,uint param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t _Var1;\n  undefined4 uVar2;\n  int iVar3;\n  code *pcVar4;\n  \n  if (0x1f < param_2) {\n    *param_1 = 0x16;\n    return 0xffffffff;\n  }\n  iVar3 = param_1[0x11];\n  if ((iVar3 != 0) && (pcVar4 = *(code **)(iVar3 + param_2 * 4), pcVar4 != (code *)0x0)) {\n    if (pcVar4 != (code *)0x1) {\n      if (pcVar4 == (code *)0xffffffff) {\n        *param_1 = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(iVar3 + param_2 * 4) = 0;\n      (*pcVar4)(param_2);\n    }\n    return 0;\n  }\n  _Var1 = _getpid_r();\n  uVar2 = _kill_r(param_1,_Var1,param_2,param_4);\n  return uVar2;\n}\n\n", 
            "called": [
                "_getpid_r", 
                "_kill_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009f98", 
            "calling": [
                "raise"
            ], 
            "imported": false, 
            "current_name": "_raise_r"
        }, 
        "_GLOBAL__sub_I_ctype_byname": {
            "renaming": {}, 
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::_GLOBAL__sub_I_ctype_byname(void)\n\n{\n  if (-1 < *(int *)PTR_id_0800a404 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a404 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a408 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a408 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a40c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a40c = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a410 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a410 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a414 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a414 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a418 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a418 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a41c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a41c = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a420 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a420 = 1;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a3a0", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I_ctype_byname"
        }, 
        "begin": {
            "renaming": {}, 
            "code": "\nvoid __thiscall HardwareSerial::begin(HardwareSerial *this,ulong baud,byte config)\n\n{\n  byte bVar1;\n  int iVar2;\n  \n  (this->_serial).baudrate = baud;\n  this->_config = config;\n  bVar1 = config & 7;\n  if (bVar1 == 4) {\n    iVar2 = 7;\n  }\n  else if (bVar1 == 6) {\n    iVar2 = 8;\n  }\n  else if (bVar1 == 2) {\n    iVar2 = 6;\n  }\n  else {\n    iVar2 = 0;\n  }\n  if ((config & 0x30) == 0x30) {\n    (this->_serial).parity = 0x600;\n    iVar2 = iVar2 + 1;\n  }\n  else if ((config & 0x20) == 0) {\n    (this->_serial).parity = 0;\n  }\n  else {\n    (this->_serial).parity = 0x400;\n    iVar2 = iVar2 + 1;\n  }\n  if ((config & 8) == 0) {\n    (this->_serial).stopbits = 0;\n  }\n  else {\n    (this->_serial).stopbits = 0x2000;\n  }\n  if (iVar2 == 8) {\n    (this->_serial).databits = 0;\n  }\n  else if (iVar2 == 9) {\n    (this->_serial).databits = 0x1000;\n  }\n  else {\n    iVar2 = 0;\n  }\n  if (iVar2 != 0) {\n    uart_init((serial_t *)&this->_serial);\n    uart_attach_rx_callback((serial_t *)&this->_serial,DAT_08008cf0);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __assert_func(PTR_s__home_bo__arduino15_packages_STM_08008cfc,299,PTR___PRETTY_FUNTION___08008cf8\n                ,PTR_s_databits__0_08008cf4);\n}\n\n",
            "called": [
                "uart_init", 
                "__assert_func", 
                "uart_attach_rx_callback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008c44", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "begin"
        }, 
        "_GLOBAL__sub_I__ZN7TwoWire8rxBufferE": {
            "renaming": {}, 
            "code": "\nvoid _GLOBAL__sub_I__ZN7TwoWire8rxBufferE(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n", 
            "called": [
                "__static_initialization_and_destruction_0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002c1e", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I__ZN7TwoWire8rxBufferE"
        }, 
        "_tx_complete_irq": {
            "renaming": {}, 
            "code": "\nint HardwareSerial::_tx_complete_irq(serial_t_conflict *obj)\n\n{\n  ushort uVar1;\n  uint16_t uVar2;\n  int iVar3;\n  \n  iVar3 = obj->tx_tail + 1;\n  uVar1 = (ushort)iVar3;\n  uVar2 = uVar1 & 0x7f;\n  if (iVar3 == 0) {\n    uVar2 = -(-uVar1 & 0x7f);\n  }\n  obj->tx_tail = uVar2;\n  if (obj->tx_head != obj->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008ac6", 
            "calling": [], 
            "imported": false, 
            "current_name": "_tx_complete_irq"
        }, 
        "HAL_UART_Transmit_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_UART_Transmit_IT(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size)\n\n{\n  if (huart->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (pData == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (Size == 0) {\n    return HAL_ERROR;\n  }\n  if (huart->Lock != HAL_LOCKED) {\n    huart->pTxBuffPtr = pData;\n    huart->TxXferSize = Size;\n    huart->TxXferCount = Size;\n    huart->ErrorCode = 0;\n    huart->gState = HAL_UART_STATE_BUSY_TX;\n    huart->Lock = HAL_UNLOCKED;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800688e", 
            "calling": [
                "HAL_UART_TxCpltCallback", 
                "uart_attach_tx_callback"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_Transmit_IT"
        }, 
        "TIM_Base_SetConfig": {
            "renaming": {}, 
            "code": "\nvoid TIM_Base_SetConfig(TIM_TypeDef_conflict *TIMx,TIM_Base_InitTypeDef_conflict *Structure)\n\n{\n  uint uVar1;\n  \n  uVar1 = TIMx->CR1;\n  if ((((TIMx == DAT_0800605c) || (TIMx == (TIM_TypeDef_conflict *)0x40000000)) ||\n      (TIMx == (TIM_TypeDef_conflict *)&DAT_0800605c[-0x387].DMAR)) ||\n     (TIMx == (TIM_TypeDef_conflict *)&DAT_0800605c[-0x37a].SMCR)) {\n    uVar1 = uVar1 & 0xffffff8f | Structure->CounterMode;\n  }\n  if (((TIMx == DAT_0800605c) || (TIMx == (TIM_TypeDef_conflict *)0x40000000)) ||\n     ((TIMx == (TIM_TypeDef_conflict *)&DAT_0800605c[-0x387].DMAR ||\n      (TIMx == (TIM_TypeDef_conflict *)&DAT_0800605c[-0x37a].SMCR)))) {\n    uVar1 = uVar1 & 0xfffffcff | Structure->ClockDivision;\n  }\n  TIMx->CR1 = uVar1 & 0xffffff7f | Structure->AutoReloadPreload;\n  TIMx->ARR = Structure->Period;\n  TIMx->PSC = Structure->Prescaler;\n  if (TIMx == DAT_0800605c) {\n    TIMx->RCR = Structure->RepetitionCounter;\n  }\n  TIMx->EGR = 1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005fe8", 
            "calling": [
                "HAL_TIM_OC_Init", 
                "HAL_TIM_PWM_Init"
            ], 
            "imported": false, 
            "current_name": "TIM_Base_SetConfig"
        }, 
        "setPinMode": {
            "renaming": {}, 
            "code": "\nvoid __thiscall firmata::FirmataClass::setPinMode(FirmataClass *this,byte pin,byte config)\n\n{\n  if (this->pinConfig[pin] != '\\x7f') {\n    this->pinConfig[pin] = config;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002fa8", 
            "calling": [
                "setPinModeCallback"
            ], 
            "imported": false, 
            "current_name": "setPinMode"
        }, 
        "wireWrite": {
            "renaming": {}, 
            "code": "\nvoid wireWrite(byte data)\n\n{\n  TwoWire::write((TwoWire *)PTR_Wire_08001c04,data);\n  return;\n}\n\n", 
            "called": [
                "write"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001bf8", 
            "calling": [
                "readAndReportData", 
                "sysexCallback"
            ], 
            "imported": false, 
            "current_name": "wireWrite"
        }, 
        "sendString": {
            "renaming": {}, 
            "code": "\nvoid __thiscall firmata::FirmataMarshaller::sendString(FirmataMarshaller *this,char *string)\n\n{\n  size_t bytec;\n  \n  bytec = strlen(string);\n  sendSysex(this,'q',bytec,(uint8_t *)string);\n  return;\n}\n\n", 
            "called": [
                "strlen", 
                "sendSysex"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080032a2", 
            "calling": [
                "sendString"
            ], 
            "imported": false, 
            "current_name": "sendString"
        }, 
        "attachServo": {
            "renaming": {}, 
            "code": "\nvoid attachServo(byte pin,int minPulse,int maxPulse)\n\n{\n  byte bVar1;\n  byte bVar2;\n  uint pin_00;\n  \n  pin_00 = (uint)pin;\n  bVar1 = *PTR_servoCount_0800056c;\n  if (0xb < bVar1) {\n    firmata::FirmataClass::sendString\n              ((FirmataClass *)PTR_Firmata_08000584,PTR_s_Max_servos_attached_08000580);\n    return;\n  }\n  bVar2 = *PTR_detachedServoCount_08000570;\n  if (bVar2 == 0) {\n    PTR_servoPinMap_08000578[pin_00] = bVar1;\n    *PTR_servoCount_0800056c = bVar1 + 1;\n  }\n  else {\n    PTR_servoPinMap_08000578[pin_00] = PTR_detachedServos_08000574[bVar2 - 1];\n    *PTR_detachedServoCount_08000570 = bVar2 - 1;\n  }\n  if ((0 < minPulse) && (0 < maxPulse)) {\n    Servo::attach((Servo *)(PTR_servos_0800057c + (uint)(byte)PTR_servoPinMap_08000578[pin_00] * 3),\n                  pin_00,minPulse,maxPulse);\n    return;\n  }\n  Servo::attach((Servo *)(PTR_servos_0800057c + (uint)(byte)PTR_servoPinMap_08000578[pin_00] * 3),\n                pin_00);\n  return;\n}\n\n", 
            "called": [
                "attach", 
                "sendString", 
                "attach"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000500", 
            "calling": [
                "setPinModeCallback", 
                "sysexCallback"
            ], 
            "imported": false, 
            "current_name": "attachServo"
        }, 
        "_kill": {
            "renaming": {}, 
            "code": "\nint _kill(int pid_UNUSED,int sig_UNUSED)\n\n{\n  *(undefined4 *)PTR_errno_08008878 = 0x16;\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800886c", 
            "calling": [
                "_kill_r"
            ], 
            "imported": false, 
            "current_name": "_kill"
        }, 
        "_fstat": {
            "renaming": {}, 
            "code": "\nint _fstat(int file_UNUSED,stat *st)\n\n{\n  st->st_mode = 0x2000;\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008846", 
            "calling": [
                "_fstat_r"
            ], 
            "imported": false, 
            "current_name": "_fstat"
        }, 
        "HAL_UART_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_IRQHandler(UART_HandleTypeDef *huart)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint uVar2;\n  USART_TypeDef *pUVar3;\n  uint uVar4;\n  uint uVar5;\n  \n  pUVar3 = huart->Instance;\n  uVar5 = pUVar3->SR;\n  uVar2 = pUVar3->CR1;\n  if ((((uVar5 & 0xf) == 0) && ((uVar5 & 0x20) != 0)) && ((uVar2 & 0x20) != 0)) {\n    UART_Receive_IT(huart);\n    return;\n  }\n  if (((uVar5 & 0xf) == 0) || ((uVar4 = pUVar3->CR3 & 1, uVar4 == 0 && ((uVar2 & 0x120) == 0)))) {\n    if (((uVar5 & 0x80) != 0) && ((uVar2 & 0x80) != 0)) {\n      UART_Transmit_IT(huart);\n      return;\n    }\n    if (((uVar5 & 0x40) != 0) && ((uVar2 & 0x40) != 0)) {\n      UART_EndTransmit_IT(huart);\n    }\n  }\n  else {\n    if (((uVar5 & 1) != 0) && ((uVar2 & 0x100) != 0)) {\n      huart->ErrorCode = huart->ErrorCode | 1;\n    }\n    if (((uVar5 & 4) != 0) && (uVar4 != 0)) {\n      huart->ErrorCode = huart->ErrorCode | 2;\n    }\n    if (((uVar5 & 2) != 0) && (uVar4 != 0)) {\n      huart->ErrorCode = huart->ErrorCode | 4;\n    }\n    if (((uVar5 & 8) != 0) && (uVar4 != 0)) {\n      huart->ErrorCode = huart->ErrorCode | 8;\n    }\n    if (huart->ErrorCode != 0) {\n      if (((uVar5 & 0x20) != 0) && ((uVar2 & 0x20) != 0)) {\n        UART_Receive_IT(huart);\n      }\n      if (((huart->ErrorCode & 8) == 0) && ((huart->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(huart);\n        huart->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(huart);\n      pUVar3 = huart->Instance;\n      if ((pUVar3->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      pUVar3->CR3 = pUVar3->CR3 & 0xffffffbf;\n      if (huart->hdmarx == (DMA_HandleTypeDef_conflict *)0x0) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      huart->hdmarx->XferAbortCallback = DAT_08006b08;\n      HVar1 = HAL_DMA_Abort_IT(huart->hdmarx);\n      if (HVar1 != HAL_OK) {\n        (*huart->hdmarx->XferAbortCallback)(huart->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "UART_EndRxTransfer", 
                "UART_Transmit_IT", 
                "UART_EndTransmit_IT", 
                "HAL_UART_ErrorCallback", 
                "HAL_DMA_Abort_IT", 
                "UART_Receive_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080069ec", 
            "calling": [
                "USART2_IRQHandler", 
                "USART1_IRQHandler", 
                "USART3_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_IRQHandler"
        }, 
        "HAL_TIM_PWM_Stop": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_TIM_PWM_Stop(TIM_HandleTypeDef_conflict *htim,uint32_t Channel)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  TIM_CCxChannelCmd(htim->Instance,Channel,0);\n  pTVar1 = htim->Instance;\n  if (((pTVar1 == DAT_0800641c) && ((pTVar1->CCER & 0x1111) == 0)) && ((pTVar1->CCER & 0x444) == 0))\n  {\n    pTVar1->BDTR = pTVar1->BDTR & 0xffff7fff;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->CCER & 0x1111) == 0) && ((pTVar1->CCER & 0x444) == 0)) {\n    pTVar1->CR1 = pTVar1->CR1 & 0xfffffffe;\n  }\n  htim->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n", 
            "called": [
                "TIM_CCxChannelCmd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080063c0", 
            "calling": [
                "pwm_stop"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_Stop"
        }, 
        "HAL_I2C_Init": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_I2C_Init(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  bool bVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint32_t uVar5;\n  \n  if (hi2c == (I2C_HandleTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if (hi2c->State == HAL_I2C_STATE_RESET) {\n    hi2c->Lock = HAL_UNLOCKED;\n    HAL_I2C_MspInit(hi2c);\n  }\n  hi2c->State = HAL_I2C_STATE_BUSY;\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n  uVar2 = HAL_RCC_GetPCLK1Freq();\n  if (DAT_08004714 < (hi2c->Init).ClockSpeed) {\n    bVar1 = uVar2 <= DAT_08004720;\n  }\n  else if (DAT_08004718 < uVar2) {\n    bVar1 = false;\n  }\n  else {\n    bVar1 = true;\n  }\n  if (bVar1) {\n    return HAL_ERROR;\n  }\n  uVar3 = (uint)((ulonglong)DAT_0800471c * (ulonglong)uVar2 >> 0x32);\n  hi2c->Instance->CR2 = uVar3;\n  if (DAT_08004714 < (hi2c->Init).ClockSpeed) {\n    uVar3 = (uint)((ulonglong)DAT_08004724 * (ulonglong)(uVar3 * 300) >> 0x26);\n  }\n  hi2c->Instance->TRISE = uVar3 + 1;\n  uVar3 = (hi2c->Init).ClockSpeed;\n  if (DAT_08004714 < uVar3) {\n    uVar5 = (hi2c->Init).DutyCycle;\n    if (uVar5 == 0) {\n      uVar4 = count_leading_zeroes((uVar2 - 1) / (uVar3 * 3) + 1 & 0xfff);\n    }\n    else {\n      uVar4 = count_leading_zeroes((uVar2 - 1) / (uVar3 * 0x19) + 1 & 0xfff);\n    }\n    if (uVar4 >> 5 == 0) {\n      if (uVar5 == 0) {\n        uVar2 = (uVar2 - 1) / (uVar3 * 3) + 1 & 0xfff | 0x8000;\n      }\n      else {\n        uVar2 = (uVar2 - 1) / (uVar3 * 0x19) + 1 & 0xfff | 0xc000;\n      }\n    }\n    else {\n      uVar2 = 1;\n    }\n  }\n  else {\n    uVar2 = (uVar2 - 1) / (uVar3 << 1) + 1 & 0xfff;\n    if (uVar2 < 4) {\n      uVar2 = 4;\n    }\n  }\n  hi2c->Instance->CCR = uVar2;\n  hi2c->Instance->CR1 = (hi2c->Init).GeneralCallMode | (hi2c->Init).NoStretchMode;\n  hi2c->Instance->OAR1 = (hi2c->Init).AddressingMode | (hi2c->Init).OwnAddress1;\n  hi2c->Instance->OAR2 = (hi2c->Init).DualAddressMode | (hi2c->Init).OwnAddress2;\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 | 1;\n  hi2c->ErrorCode = 0;\n  hi2c->State = HAL_I2C_STATE_READY;\n  hi2c->PreviousState = 0;\n  hi2c->Mode = HAL_I2C_MODE_NONE;\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_RCC_GetPCLK1Freq", 
                "HAL_I2C_MspInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080045c0", 
            "calling": [
                "i2c_custom_init"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_Init"
        }, 
        "map": {
            "renaming": {}, 
            "code": "\nlong map(long x,long in_min,long in_max,long out_min,long out_max)\n\n{\n  return (uint)((out_max - out_min) * (x - in_min)) / (uint)(in_max - in_min) + out_min;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008ef4", 
            "calling": [
                "write"
            ], 
            "imported": false, 
            "current_name": "map"
        }, 
        "malloc": {
            "renaming": {}, 
            "code": "\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)_malloc_r(*(undefined4 *)PTR__impure_ptr_0800919c,__size);\n  return pvVar1;\n}\n\n", 
            "called": [
                "_malloc_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009190", 
            "calling": [
                "setFirmwareNameAndVersion"
            ], 
            "imported": false, 
            "current_name": "malloc"
        }, 
        "staticSystemResetCallback": {
            "renaming": {}, 
            "code": "\nvoid firmata::FirmataClass::staticSystemResetCallback(void *param_1)\n\n{\n  if (*(code **)PTR_currentSystemResetCallback_08002cdc != (code *)0x0) {\n    (**(code **)PTR_currentSystemResetCallback_08002cdc)();\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002cd0", 
            "calling": [], 
            "imported": false, 
            "current_name": "staticSystemResetCallback"
        }, 
        "HAL_RTC_AlarmIRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)\n\n{\n  if (((hrtc->Instance->CRH & 2) != 0) && ((hrtc->Instance->CRL & 2) != 0)) {\n    HAL_RTC_AlarmAEventCallback(hrtc);\n    hrtc->Instance->CRL = 0xfffffffd;\n  }\n  *(undefined4 *)(DAT_08005ce8 + 0x14) = 0x20000;\n  hrtc->State = HAL_RTC_STATE_READY;\n  return;\n}\n\n", 
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005cb4", 
            "calling": [
                "RTC_Alarm_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_RTC_AlarmIRQHandler"
        }, 
        "EXTI2_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI2_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(4);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009038", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI2_IRQHandler"
        }, 
        "HAL_I2C_Slave_Sequential_Receive_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_I2C_Slave_Sequential_Receive_IT\n          (I2C_HandleTypeDef_conflict *hi2c,uint8_t *pData,uint16_t Size,uint32_t XferOptions)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  uint32_t tmpreg;\n  \n  if (hi2c->State == HAL_I2C_STATE_LISTEN) {\n    if (pData == (uint8_t *)0x0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (Size == 0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (hi2c->Lock == HAL_LOCKED) {\n      HVar1 = HAL_BUSY;\n    }\n    else {\n      hi2c->Lock = HAL_LOCKED;\n      pIVar2 = hi2c->Instance;\n      if ((pIVar2->CR1 & 1) == 0) {\n        pIVar2->CR1 = pIVar2->CR1 | 1;\n      }\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffff7ff;\n      hi2c->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      hi2c->Mode = HAL_I2C_MODE_SLAVE;\n      HVar1 = HAL_OK;\n      hi2c->ErrorCode = 0;\n      hi2c->pBuffPtr = pData;\n      hi2c->XferCount = Size;\n      hi2c->XferOptions = XferOptions;\n      hi2c->XferSize = hi2c->XferCount;\n      hi2c->Lock = HAL_UNLOCKED;\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 = HAL_BUSY;\n  }\n  return HVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004954", 
            "calling": [
                "HAL_I2C_AddrCallback"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_Slave_Sequential_Receive_IT"
        }, 
        "sendSysex": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003272 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::sendSysex\n          (FirmataMarshaller *this,uint8_t command,size_t bytec,uint8_t *bytev)\n\n{\n  uint uVar1;\n  \n  if (this->FirmataStream != (Stream *)0x0) {\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this,0xf0);\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,(uint)command);\n    for (uVar1 = 0; uVar1 < bytec; uVar1 = uVar1 + 1) {\n      encodeByteStream(this,1,bytev + uVar1,0);\n    }\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,0xf7);\n  }\n  return;\n}\n\n", 
            "called": [
                "encodeByteStream"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800325a", 
            "calling": [
                "sendSysex", 
                "sendString"
            ], 
            "imported": false, 
            "current_name": "sendSysex"
        }, 
        "_getpid": {
            "renaming": {}, 
            "code": "\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800887c", 
            "calling": [
                "_getpid_r"
            ], 
            "imported": false, 
            "current_name": "_getpid"
        }, 
        "TIM3_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM3_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_08007798 + 8) !=\n      (TIM_HandleTypeDef_conflict *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_08007798 + 8));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007788", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM3_IRQHandler"
        }, 
        "peek": {
            "renaming": {}, 
            "code": "\nint __thiscall HardwareSerial::peek(HardwareSerial *this)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)(this->_serial).rx_tail;\n  if ((this->_serial).rx_head != uVar1) {\n    return (uint)(this->_serial).rx_buff[uVar1];\n  }\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008b0e", 
            "calling": [], 
            "imported": false, 
            "current_name": "peek"
        }, 
        "sendVersion": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003240 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::sendVersion(FirmataMarshaller *this,uint8_t major,uint8_t minor)\n\n{\n  if (this->FirmataStream != (Stream *)0x0) {\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this,0xf9);\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,(uint)major);\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,(uint)minor);\n    return;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800322c", 
            "calling": [
                "printVersion"
            ], 
            "imported": false, 
            "current_name": "sendVersion"
        }, 
        "getTimerCounter": {
            "renaming": {}, 
            "code": "\nuint32_t getTimerCounter(stimer_t_conflict *obj)\n\n{\n  return ((obj->handle).Instance)->CNT;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007744", 
            "calling": [
                "ServoIrqHandle"
            ], 
            "imported": false, 
            "current_name": "getTimerCounter"
        }, 
        "HAL_UART_Receive_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_UART_Receive_IT(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size)\n\n{\n  if (huart->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (pData == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (Size == 0) {\n    return HAL_ERROR;\n  }\n  if (huart->Lock != HAL_LOCKED) {\n    huart->pRxBuffPtr = pData;\n    huart->RxXferSize = Size;\n    huart->RxXferCount = Size;\n    huart->ErrorCode = 0;\n    huart->RxState = HAL_UART_STATE_BUSY_RX;\n    huart->Lock = HAL_UNLOCKED;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x100;\n    huart->Instance->CR3 = huart->Instance->CR3 | 1;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x20;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080068d6", 
            "calling": [
                "uart_getc", 
                "uart_attach_rx_callback"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_Receive_IT"
        }, 
        "initISR": {
            "renaming": {}, 
            "code": "\nvoid initISR(stimer_t *obj)\n\n{\n  TimerPulseInit((stimer_t_conflict *)obj,60000,0x5dc,DAT_08002440);\n  return;\n}\n\n", 
            "called": [
                "TimerPulseInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800242c", 
            "calling": [
                "attach"
            ], 
            "imported": false, 
            "current_name": "initISR"
        }, 
        "I2C_Slave_ADDR": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_Slave_ADDR(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  uint16_t AddrMatchCode;\n  \n  if ((hi2c->Instance->SR2 & 0x80) == 0) {\n    AddrMatchCode = *(uint16_t *)&(hi2c->Init).OwnAddress1;\n  }\n  else {\n    AddrMatchCode = *(uint16_t *)&(hi2c->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(hi2c,(hi2c->Instance->SR2 & 4) == 0,AddrMatchCode);\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_AddrCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004ac2", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Slave_ADDR"
        }, 
        "memchr": {
            "renaming": {}, 
            "code": "\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n  byte *pbVar1;\n  byte *pbVar2;\n  \n  pbVar1 = (byte *)__s;\n  do {\n    pbVar2 = pbVar1;\n    if (pbVar2 == (byte *)(__n + (int)__s)) {\n      return (void *)0x0;\n    }\n    pbVar1 = pbVar2 + 1;\n  } while ((uint)*pbVar2 != (__c & 0xffU));\n  return pbVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009f2c", 
            "calling": [
                "_vfiprintf_r", 
                "_printf_i"
            ], 
            "imported": false, 
            "current_name": "memchr"
        }, 
        "i2c_master_read": {
            "renaming": {}, 
            "code": "\ni2c_status_e_conflict\ni2c_master_read(i2c_t_conflict *obj,uint8_t dev_address,uint8_t *data,uint16_t size)\n\n{\n  HAL_I2C_StateTypeDef_conflict HVar1;\n  HAL_StatusTypeDef_conflict HVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint uVar5;\n  i2c_status_e_conflict iVar6;\n  I2C_HandleTypeDef_conflict *hi2c;\n  \n  uVar3 = HAL_GetTick();\n  uVar5 = 0;\n  iVar6 = I2C_ERROR;\n  do {\n    hi2c = &obj->handle;\n    HVar2 = HAL_I2C_Master_Receive_IT(hi2c,(ushort)dev_address,data,size);\n    if (HVar2 == HAL_OK) {\n      iVar6 = I2C_OK;\n      while ((HVar1 = HAL_I2C_GetState(hi2c), HVar1 != HAL_I2C_STATE_READY && (iVar6 == I2C_OK))) {\n        uVar4 = HAL_GetTick();\n        uVar5 = uVar4 - uVar3;\n        if (uVar5 < 0x65) {\n          uVar4 = HAL_I2C_GetError(hi2c);\n          if (uVar4 != 0) {\n            iVar6 = I2C_ERROR;\n          }\n        }\n        else {\n          iVar6 = I2C_TIMEOUT;\n        }\n      }\n    }\n    uVar4 = HAL_I2C_GetError(hi2c);\n  } while ((uVar4 == 4) && (uVar5 < 100));\n  return iVar6;\n}\n\n", 
            "called": [
                "HAL_I2C_GetError", 
                "HAL_I2C_GetState", 
                "HAL_I2C_Master_Receive_IT", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007f0e", 
            "calling": [
                "requestFrom"
            ], 
            "imported": false, 
            "current_name": "i2c_master_read"
        }, 
        "noOsSystickHandler": {
            "renaming": {}, 
            "code": "\nvoid noOsSystickHandler(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007244", 
            "calling": [
                "SysTick_Handler"
            ], 
            "imported": false, 
            "current_name": "noOsSystickHandler"
        }, 
        "_printf_i": {
            "renaming": {}, 
            "code": "\nuint _printf_i(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint *puVar3;\n  void *pvVar4;\n  int iVar5;\n  undefined *puVar6;\n  uint uVar7;\n  uint **ppuVar8;\n  uint uVar9;\n  uint uVar10;\n  undefined *puVar11;\n  undefined *__s;\n  uint local_24 [2];\n  \n  bVar1 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  if (bVar1 != 0x6e) {\n    if (bVar1 < 0x6f) {\n      if (bVar1 != 99) {\n        if (bVar1 < 100) {\n          if (bVar1 == 0) goto LAB_08009852;\n          if (bVar1 != 0x58) goto LAB_080096c8;\n          *(undefined *)((int)param_2 + 0x45) = 0x58;\n          puVar6 = PTR_s_0123456789ABCDEF_080098d4;\nLAB_080097e2:\n          uVar7 = *param_2;\n          puVar3 = *param_5;\n          *param_5 = puVar3 + 1;\n          if (((uVar7 & 0x80) == 0) && ((int)(uVar7 << 0x19) < 0)) {\n            uVar9 = (uint)*(ushort *)puVar3;\n          }\n          else {\n            uVar9 = *puVar3;\n          }\n          if ((int)(uVar7 << 0x1f) < 0) {\n            *param_2 = uVar7 | 0x20;\n          }\n          if (uVar9 == 0) {\n            *param_2 = *param_2 & 0xffffffdf;\n          }\n          uVar7 = 0x10;\nLAB_08009778:\n          *(undefined *)((int)param_2 + 0x43) = 0;\n        }\n        else {\n          if ((bVar1 != 100) && (bVar1 != 0x69)) goto LAB_080096c8;\n          uVar9 = *param_2;\n          puVar3 = *param_5;\n          if ((uVar9 & 0x80) == 0) {\n            *param_5 = puVar3 + 1;\n            if ((uVar9 & 0x40) == 0) goto LAB_080096e8;\n            uVar9 = (uint)(short)*(ushort *)puVar3;\n          }\n          else {\n            *param_5 = puVar3 + 1;\nLAB_080096e8:\n            uVar9 = *puVar3;\n          }\n          if ((int)uVar9 < 0) {\n            uVar9 = -uVar9;\n            *(undefined *)((int)param_2 + 0x43) = 0x2d;\n          }\n          uVar7 = 10;\n          puVar6 = PTR_s_0123456789ABCDEF_080098d4;\n        }\n        uVar10 = param_2[1];\n        param_2[2] = uVar10;\n        puVar11 = __s;\n        if ((int)uVar10 < 0) {\n          if (uVar9 != 0) goto LAB_08009816;\nLAB_080098c4:\n          *(undefined *)((int)param_2 + 0x42) = *puVar6;\n          puVar11 = (undefined *)((int)param_2 + 0x42);\n        }\n        else {\n          *param_2 = *param_2 & 0xfffffffb;\n          if (uVar9 == 0) {\n            if (uVar10 != 0) goto LAB_080098c4;\n          }\n          else {\nLAB_08009816:\n            do {\n              uVar10 = uVar9 / uVar7;\n              puVar11 = puVar11 + -1;\n              *puVar11 = puVar6[uVar9 - uVar7 * uVar10];\n              uVar9 = uVar10;\n            } while (uVar10 != 0);\n          }\n        }\n        if (((uVar7 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4]))\n        {\n          puVar11[-1] = 0x30;\n          puVar11 = puVar11 + -1;\n        }\n        param_2[4] = (int)__s - (int)puVar11;\n        __s = puVar11;\n        goto LAB_080097be;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      *(char *)((int)param_2 + 0x42) = (char)*puVar3;\nLAB_08009728:\n      __s = (undefined *)((int)param_2 + 0x42);\n      uVar9 = 1;\n    }\n    else {\n      if (bVar1 != 0x73) {\n        if (bVar1 < 0x74) {\n          if (bVar1 == 0x6f) {\nLAB_0800974e:\n            uVar9 = *param_2;\n            puVar3 = *param_5;\n            if ((uVar9 & 0x80) == 0) {\n              *param_5 = puVar3 + 1;\n              if ((uVar9 & 0x40) == 0) goto LAB_0800975c;\n              uVar9 = (uint)*(ushort *)puVar3;\n            }\n            else {\n              *param_5 = puVar3 + 1;\nLAB_0800975c:\n              uVar9 = *puVar3;\n            }\n            puVar6 = PTR_s_0123456789ABCDEF_080098d4;\n            if (bVar1 == 0x6f) {\n              uVar7 = 8;\n            }\n            else {\n              uVar7 = 10;\n            }\n            goto LAB_08009778;\n          }\n          if (bVar1 == 0x70) {\n            *param_2 = *param_2 | 0x20;\nLAB_0800970e:\n            puVar6 = PTR_s_0123456789abcdef_080098d0;\n            *(undefined *)((int)param_2 + 0x45) = 0x78;\n            goto LAB_080097e2;\n          }\n        }\n        else {\n          if (bVar1 == 0x75) goto LAB_0800974e;\n          if (bVar1 == 0x78) goto LAB_0800970e;\n        }\nLAB_080096c8:\n        *(byte *)((int)param_2 + 0x42) = bVar1;\n        goto LAB_08009728;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      __s = (undefined *)*puVar3;\n      pvVar4 = memchr(__s,0,param_2[1]);\n      if (pvVar4 != (void *)0x0) {\n        param_2[1] = (int)pvVar4 - (int)__s;\n      }\n      uVar9 = param_2[1];\n    }\n    param_2[4] = uVar9;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_080097be;\n  }\n  uVar9 = *param_2;\n  ppuVar8 = (uint **)*param_5;\n  uVar7 = param_2[5];\n  if ((uVar9 & 0x80) == 0) {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\n    if ((uVar9 & 0x40) == 0) goto LAB_0800983e;\n    *(short *)puVar3 = (short)uVar7;\n  }\n  else {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\nLAB_0800983e:\n    *puVar3 = uVar7;\n  }\nLAB_08009852:\n  param_2[4] = 0;\nLAB_080097be:\n  iVar2 = _printf_common(param_1,param_2,local_24,param_3,param_4);\n  if ((iVar2 == -1) || (iVar2 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar2 == -1)) {\nLAB_080097d2:\n    uVar9 = 0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar2 = 0; iVar2 < (int)(param_2[3] - local_24[0]); iVar2 = iVar2 + 1) {\n        iVar5 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar5 == -1) goto LAB_080097d2;\n      }\n    }\n    uVar9 = param_2[3];\n    if ((int)param_2[3] < (int)local_24[0]) {\n      uVar9 = local_24[0];\n    }\n  }\n  return uVar9;\n}\n\n", 
            "called": [
                "_printf_common", 
                "memchr"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009698", 
            "calling": [
                "_vfiprintf_r"
            ], 
            "imported": false, 
            "current_name": "_printf_i"
        }, 
        "systemResetCallback": {
            "renaming": {}, 
            "code": "\nvoid systemResetCallback(void)\n\n{\n  bool bVar1;\n  PinName_conflict PVar2;\n  uint32_t uVar3;\n  uint uVar4;\n  \n  *PTR_isResetting_08000bc0 = 1;\n  if (*PTR_isI2CEnabled_08000bc4 != '\\0') {\n    disableI2CPins();\n  }\n  for (uVar4 = 0; uVar4 < 5; uVar4 = uVar4 + 1 & 0xff) {\n    PTR_reportPINs_08000bc8[uVar4] = 0;\n    PTR_portConfigInputs_08000bcc[uVar4] = 0;\n    PTR_previousPINs_08000bd0[uVar4] = 0;\n  }\n  for (uVar4 = 0; uVar4 < 0x3c; uVar4 = uVar4 + 1 & 0xff) {\n    if ((uVar4 - 0x2e & 0xff) < 0xe) {\n      if (uVar4 < 0x3c) {\n        PVar2 = PTR_digitalPin_08000bd4[uVar4];\n      }\n      else {\n        PVar2 = NC;\n      }\n      uVar3 = pinNametoDigitalPin(PVar2);\n      if (uVar3 == 0) {\n        bVar1 = false;\n      }\n      else {\n        if (uVar4 < 0x3c) {\n          PVar2 = PTR_digitalPin_08000bd4[uVar4];\n        }\n        else {\n          PVar2 = NC;\n        }\n        uVar3 = pinNametoDigitalPin(PVar2);\n        if (uVar3 == 1) {\n          bVar1 = false;\n        }\n        else {\n          bVar1 = true;\n        }\n      }\n    }\n    else {\n      bVar1 = false;\n    }\n    if (bVar1) {\n      setPinModeCallback((byte)uVar4,2);\n    }\n    else {\n      if ((((uVar4 < 0x3c) && (PTR_digitalPin_08000bd4[uVar4] != NC)) &&\n          (uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000bd4[uVar4]), uVar3 != 0)) &&\n         (uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000bd4[uVar4]), uVar3 != 1)) {\n        bVar1 = true;\n      }\n      if (bVar1) {\n        setPinModeCallback((byte)uVar4,1);\n      }\n    }\n    PTR_servoPinMap_08000bd8[uVar4] = 0xff;\n  }\n  *(undefined4 *)PTR_analogInputsToReport_08000bdc = 0;\n  *PTR_detachedServoCount_08000be0 = 0;\n  *PTR_servoCount_08000be4 = 0;\n  *PTR_isResetting_08000bc0 = 0;\n  return;\n}\n\n", 
            "called": [
                "setPinModeCallback", 
                "pinNametoDigitalPin", 
                "disableI2CPins"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000aec", 
            "calling": [
                "setup"
            ], 
            "imported": false, 
            "current_name": "systemResetCallback"
        }, 
        "digitalRead": {
            "renaming": {}, 
            "code": "\nint digitalRead(uint32_t ulPin)\n\n{\n  _Bool _Var1;\n  GPIO_TypeDef *port;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  if (ulPin < 0x3c) {\n    uVar3 = (uint)(char)PTR_digitalPin_08008ab4[ulPin];\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  if (uVar3 == 0xffffffff) {\n    uVar3 = 0;\n  }\n  else {\n    _Var1 = is_pin_configured((PinName_conflict)uVar3,(uint32_t *)PTR_g_digPinConfigured_08008ab8);\n    if (_Var1) {\n      port = get_GPIO_Port((uVar3 << 0x18) >> 0x1c);\n      uVar2 = digital_io_read(port,1 << (uVar3 & 0xf) & 0xffff);\n      uVar3 = uVar2 & 0xff;\n    }\n    else {\n      uVar3 = 0;\n    }\n  }\n  if (uVar3 != 0) {\n    uVar3 = 1;\n  }\n  return uVar3;\n}\n\n", 
            "called": [
                "is_pin_configured", 
                "get_GPIO_Port", 
                "digital_io_read"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008a6c", 
            "calling": [
                "checkDigitalInputs", 
                "reportDigitalCallback"
            ], 
            "imported": false, 
            "current_name": "digitalRead"
        }, 
        "HAL_UART_Transmit": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_UART_Transmit(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size,uint32_t Timeout)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t Tickstart;\n  \n  if (huart->gState == HAL_UART_STATE_READY) {\n    if (pData == (uint8_t *)0x0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (Size == 0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (huart->Lock == HAL_LOCKED) {\n      HVar1 = HAL_BUSY;\n    }\n    else {\n      huart->Lock = HAL_LOCKED;\n      huart->ErrorCode = 0;\n      huart->gState = HAL_UART_STATE_BUSY_TX;\n      Tickstart = HAL_GetTick();\n      huart->TxXferSize = Size;\n      huart->TxXferCount = Size;\n      while (huart->TxXferCount != 0) {\n        huart->TxXferCount = huart->TxXferCount - 1;\n        if ((huart->Init).WordLength == 0x1000) {\n          HVar1 = UART_WaitOnFlagUntilTimeout(huart,0x80,RESET,Tickstart,Timeout);\n          if (HVar1 != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          huart->Instance->DR = *(ushort *)pData & 0x1ff;\n          if ((huart->Init).Parity == 0) {\n            pData = (uint8_t *)((int)pData + 2);\n          }\n          else {\n            pData = (uint8_t *)((int)pData + 1);\n          }\n        }\n        else {\n          HVar1 = UART_WaitOnFlagUntilTimeout(huart,0x80,RESET,Tickstart,Timeout);\n          if (HVar1 != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          huart->Instance->DR = (uint)*pData;\n          pData = (uint8_t *)((int)pData + 1);\n        }\n      }\n      HVar1 = UART_WaitOnFlagUntilTimeout(huart,0x40,RESET,Tickstart,Timeout);\n      if (HVar1 == HAL_OK) {\n        huart->gState = HAL_UART_STATE_READY;\n        huart->Lock = HAL_UNLOCKED;\n      }\n      else {\n        HVar1 = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    HVar1 = HAL_BUSY;\n  }\n  return HVar1;\n}\n\n", 
            "called": [
                "UART_WaitOnFlagUntilTimeout", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080067ac", 
            "calling": [
                "uart_debug_write"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_Transmit"
        }, 
        "main": {
            "renaming": {}, 
            "code": "\nint main(void)\n\n{\n  initVariant();\n  setup();\n  do {\n    do {\n      loop();\n    } while (DAT_08008f38 == 0);\n    serialEventRun();\n  } while( true );\n}\n\n", 
            "called": [
                "loop", 
                "setup", 
                "initVariant", 
                "serialEventRun"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008f1c", 
            "calling": [
                "Reset_Handler"
            ], 
            "imported": false, 
            "current_name": "main"
        }, 
        "_free_r": {
            "renaming": {}, 
            "code": "\nvoid _free_r(undefined4 *param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined *puVar1;\n  int **extraout_r1;\n  int **ppiVar2;\n  int **ppiVar3;\n  int *piVar4;\n  int **ppiVar5;\n  int **ppiVar6;\n  int **ppiVar7;\n  \n  if (param_2 == 0) {\n    return;\n  }\n  ppiVar7 = (int **)(param_2 + -4);\n  if (*(int *)(param_2 + -4) < 0) {\n    ppiVar7 = (int **)((int)ppiVar7 + *(int *)(param_2 + -4));\n  }\n  __malloc_lock();\n  puVar1 = PTR___malloc_free_list_0800926c;\n  ppiVar5 = *(int ***)PTR___malloc_free_list_0800926c;\n  if (ppiVar5 == (int **)0x0) {\n    ppiVar7[1] = (int *)0x0;\n    *(int ***)puVar1 = ppiVar7;\n    ppiVar2 = extraout_r1;\n    ppiVar3 = (int **)puVar1;\n  }\n  else if (ppiVar7 < ppiVar5) {\n    ppiVar2 = (int **)*ppiVar7;\n    ppiVar3 = (int **)((int)ppiVar7 + (int)ppiVar2);\n    if (ppiVar5 == ppiVar3) {\n      piVar4 = *ppiVar5;\n      ppiVar5 = (int **)ppiVar5[1];\n      ppiVar3 = (int **)((int)piVar4 + (int)ppiVar2);\n      *ppiVar7 = (int *)ppiVar3;\n    }\n    ppiVar7[1] = (int *)ppiVar5;\n    *(int ***)puVar1 = ppiVar7;\n  }\n  else {\n    do {\n      ppiVar6 = ppiVar5;\n      ppiVar3 = (int **)ppiVar6[1];\n      if (ppiVar3 == (int **)0x0) break;\n      ppiVar5 = ppiVar3;\n    } while (ppiVar3 <= ppiVar7);\n    ppiVar2 = (int **)*ppiVar6;\n    if ((int **)((int)ppiVar6 + (int)ppiVar2) == ppiVar7) {\n      ppiVar2 = (int **)((int)ppiVar2 + (int)*ppiVar7);\n      *ppiVar6 = (int *)ppiVar2;\n      if (ppiVar3 == (int **)((int)ppiVar6 + (int)ppiVar2)) {\n        piVar4 = *ppiVar3;\n        ppiVar3 = (int **)ppiVar3[1];\n        ppiVar2 = (int **)((int)ppiVar2 + (int)piVar4);\n        *ppiVar6 = (int *)ppiVar2;\n        ppiVar6[1] = (int *)ppiVar3;\n      }\n    }\n    else if (ppiVar7 < (int **)((int)ppiVar6 + (int)ppiVar2)) {\n      *param_1 = 0xc;\n    }\n    else {\n      ppiVar2 = (int **)((int)ppiVar7 + (int)*ppiVar7);\n      if (ppiVar3 == ppiVar2) {\n        piVar4 = *ppiVar3;\n        ppiVar3 = (int **)ppiVar3[1];\n        ppiVar2 = (int **)((int)piVar4 + (int)*ppiVar7);\n        *ppiVar7 = (int *)ppiVar2;\n      }\n      ppiVar7[1] = (int *)ppiVar3;\n      ppiVar6[1] = (int *)ppiVar7;\n    }\n  }\n  __malloc_unlock(param_1,ppiVar2,ppiVar3,param_4);\n  return;\n}\n\n", 
            "called": [
                "__malloc_lock", 
                "__malloc_unlock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080091d8", 
            "calling": [
                "__swsetup_r", 
                "__sflush_r", 
                "free", 
                "_realloc_r"
            ], 
            "imported": false, 
            "current_name": "_free_r"
        }, 
        "std.isra.0": {
            "renaming": {}, 
            "code": "\nvoid std_isra_0(undefined4 *param_1,undefined2 param_2,undefined2 param_3)\n\n{\n  undefined4 uVar1;\n  \n  *param_1 = 0;\n  param_1[1] = 0;\n  param_1[2] = 0;\n  *(undefined2 *)(param_1 + 3) = param_2;\n  param_1[0x19] = 0;\n  *(undefined2 *)((int)param_1 + 0xe) = param_3;\n  param_1[4] = 0;\n  param_1[5] = 0;\n  param_1[6] = 0;\n  memset(param_1 + 0x17,0,8);\n  uVar1 = DAT_08009d14;\n  param_1[8] = param_1;\n  param_1[9] = uVar1;\n  param_1[10] = DAT_08009d18;\n  param_1[0xb] = DAT_08009d1c;\n  param_1[0xc] = DAT_08009d20;\n  return;\n}\n\n", 
            "called": [
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009cdc", 
            "calling": [
                "__sinit"
            ], 
            "imported": false, 
            "current_name": "std.isra.0"
        }, 
        "__assert_func": {
            "renaming": {}, 
            "code": "\nvoid __assert_func(undefined4 param_1,undefined4 param_2,undefined *param_3,undefined4 param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  \n  puVar1 = PTR_s__08009104;\n  puVar2 = PTR_s__08009104;\n  if (param_3 != (undefined *)0x0) {\n    puVar1 = param_3;\n    puVar2 = PTR_s___function__080090fc;\n  }\n  fiprintf(*(FILE **)(*(int *)PTR__impure_ptr_080090f8 + 0xc),\n           PTR_s_assertion___s__failed__file___s__08009100,param_4,param_1,param_2,puVar2,puVar1,\n           param_4);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
            "called": [
                "fiprintf", 
                "abort"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080090cc", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "__assert_func"
        }, 
        "sysexCallback": {
            "renaming": {}, 
            "code": "\nvoid sysexCallback(byte command,byte argc,byte *argv)\n\n{\n  byte bVar1;\n  uint8_t address;\n  byte bVar2;\n  byte bVar3;\n  byte bVar4;\n  byte bVar5;\n  char cVar6;\n  undefined *puVar7;\n  undefined *this;\n  PinName_conflict PVar8;\n  _Bool _Var9;\n  byte bVar10;\n  uint32_t uVar11;\n  uint uVar12;\n  int iVar13;\n  int iVar14;\n  char cVar15;\n  uint uVar16;\n  int iVar17;\n  bool bVar18;\n  \n  this = PTR_Firmata_080022e8;\n  puVar7 = PTR_Firmata_08002044;\n  uVar16 = (uint)argc;\n  switch(command) {\n  case 'i':\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf0);\n    firmata::FirmataClass::write((FirmataClass *)this,'j');\n    for (uVar16 = 0; uVar16 < 0x3c; uVar16 = uVar16 + 1 & 0xff) {\n      uVar12 = uVar16 - 0x2e & 0xff;\n      bVar10 = (byte)uVar12;\n      if (uVar12 < 0xe) {\n        if (uVar16 < 0x3c) {\n          PVar8 = PTR_digitalPin_080022e4[uVar16];\n        }\n        else {\n          PVar8 = NC;\n        }\n        uVar11 = pinNametoDigitalPin(PVar8);\n        if (uVar11 == 0) {\n          bVar10 = '\\x7f';\n        }\n        else {\n          if (uVar16 < 0x3c) {\n            PVar8 = PTR_digitalPin_080022e4[uVar16];\n          }\n          else {\n            PVar8 = NC;\n          }\n          uVar11 = pinNametoDigitalPin(PVar8);\n          if (uVar11 == 1) {\n            bVar10 = '\\x7f';\n          }\n        }\n      }\n      else {\n        bVar10 = '\\x7f';\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,bVar10);\n    }\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n    break;\n  case 'k':\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_08002044,0xf0);\n    firmata::FirmataClass::write((FirmataClass *)puVar7,'l');\n    for (uVar16 = 0; uVar16 < 0x3c; uVar16 = uVar16 + 1 & 0xff) {\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_08002044;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_08002044,'\\0');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\v');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n      }\n      if ((uVar16 - 0x2e & 0xff) < 0xe) {\n        if (uVar16 < 0x3c) {\n          PVar8 = PTR_digitalPin_08002060[uVar16];\n        }\n        else {\n          PVar8 = NC;\n        }\n        uVar11 = pinNametoDigitalPin(PVar8);\n        if (uVar11 == 0) {\n          bVar18 = false;\n        }\n        else {\n          if (uVar16 < 0x3c) {\n            PVar8 = PTR_digitalPin_08002060[uVar16];\n          }\n          else {\n            PVar8 = NC;\n          }\n          uVar11 = pinNametoDigitalPin(PVar8);\n          if (uVar11 == 1) {\n            bVar18 = false;\n          }\n          else {\n            bVar18 = true;\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x02');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\n');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          _Var9 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            _Var9 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              _Var9 = false;\n            }\n            else {\n              _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                    (PinMap_conflict *)PTR_PinMap_PWM_080022ec);\n            }\n          }\n        }\n      }\n      else {\n        _Var9 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (_Var9 != false) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x03');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\b');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x04');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x0e');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          _Var9 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            _Var9 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              _Var9 = false;\n            }\n            else {\n              _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                    (PinMap_conflict *)PTR_PinMap_I2C_SDA_080022f0);\n              if (!_Var9) {\n                _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                      (PinMap_conflict *)PTR_PinMap_I2C_SCL_080022f4);\n              }\n            }\n          }\n        }\n      }\n      else {\n        _Var9 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (_Var9 != false) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x06');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x7f');\n    }\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n    return;\n  case 'm':\n    if (uVar16 != 0) {\n      bVar1 = *argv;\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf0);\n      firmata::FirmataClass::write((FirmataClass *)this,'n');\n      firmata::FirmataClass::write((FirmataClass *)this,bVar1);\n      if (bVar1 < 0x3c) {\n        bVar10 = firmata::FirmataClass::getPinMode((FirmataClass *)this,bVar1);\n        firmata::FirmataClass::write((FirmataClass *)this,bVar10);\n        iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n        firmata::FirmataClass::write((FirmataClass *)this,(byte)iVar13 & 0x7f);\n        uVar16 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n        if ((uVar16 & 0xff80) != 0) {\n          iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n          firmata::FirmataClass::write((FirmataClass *)this,(byte)((uint)(iVar13 << 0x12) >> 0x19));\n        }\n        uVar16 = firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_080022e8,bVar1);\n        puVar7 = PTR_Firmata_080022e8;\n        if ((uVar16 & 0xc000) != 0) {\n          iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_080022e8,bVar1);\n          firmata::FirmataClass::write((FirmataClass *)puVar7,(byte)((uint)(iVar13 << 0xb) >> 0x19))\n          ;\n        }\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n      return;\n    }\n    break;\n  case 'o':\n    if (1 < uVar16) {\n      uVar12 = (uint)argv[1];\n      if (2 < uVar16) {\n        uVar12 = uVar12 | (uint)argv[2] << 7;\n      }\n      if (3 < uVar16) {\n        uVar12 = uVar12 | (uint)argv[3] << 0xe;\n      }\n      analogWriteCallback(*argv,uVar12);\n      return;\n    }\n    break;\n  case 'p':\n    if (4 < uVar16) {\n      bVar1 = *argv;\n      uVar16 = (uint)bVar1;\n      bVar2 = argv[1];\n      bVar3 = argv[2];\n      bVar4 = argv[3];\n      bVar5 = argv[4];\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_08002060[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      if (bVar18) {\n        if ((byte)PTR_servoPinMap_08002064[uVar16] < 0xc) {\n          bVar18 = Servo::attached((Servo *)(PTR_servos_08002068 +\n                                            (uint)(byte)PTR_servoPinMap_08002064[uVar16] * 3));\n        }\n        else {\n          bVar18 = false;\n        }\n        if (bVar18 != false) {\n          detachServo(bVar1);\n        }\n        attachServo(bVar1,(uint)bVar2 + (uint)bVar3 * 0x80,(uint)bVar4 + (uint)bVar5 * 0x80);\n        setPinModeCallback(bVar1,4);\n        return;\n      }\n    }\n    break;\n  case 'v':\n    bVar1 = argv[1];\n    if ((bVar1 & 0x20) != 0) {\n      firmata::FirmataClass::sendString\n                ((FirmataClass *)PTR_Firmata_08002044,PTR_s_10_bit_addressing_not_supported_08002040\n                );\n      return;\n    }\n    address = *argv;\n    bVar18 = (bVar1 & 0x40) == 0;\n    if ((bVar1 & 0x18) < 0x19) {\n      switch(bVar1 & 0x18) {\n      case 0:\n        TwoWire::beginTransmission((TwoWire *)PTR_Wire_08002048,address);\n        for (uVar12 = 2; uVar12 < uVar16; uVar12 = uVar12 + 2 & 0xff) {\n          wireWrite(argv[uVar12 + 1] * -0x80 + argv[uVar12]);\n        }\n        TwoWire::endTransmission((TwoWire *)PTR_Wire_08002048);\n        return;\n      case 8:\n        if (uVar16 == 6) {\n          iVar13 = (uint)argv[2] + (uint)argv[3] * 0x80;\n          bVar10 = argv[4] + argv[5] * -0x80;\n        }\n        else {\n          bVar10 = argv[2] + argv[3] * -0x80;\n          iVar13 = -1;\n        }\n        readAndReportData(address,iVar13,bVar10,bVar18);\n        return;\n      case 0x10:\n        if ((char)*PTR_queryIndex_0800204c + 1 < 8) {\n          if (uVar16 == 6) {\n            iVar13 = (uint)argv[2] + (uint)argv[3] * 0x80;\n            cVar15 = argv[4] + argv[5] * -0x80;\n          }\n          else {\n            cVar15 = argv[2] + argv[3] * -0x80;\n            iVar13 = -1;\n          }\n          cVar6 = *PTR_queryIndex_0800204c + '\\x01';\n          *PTR_queryIndex_0800204c = cVar6;\n          puVar7 = PTR_query_08002050;\n          iVar14 = cVar6 * 0xc;\n          PTR_query_08002050[iVar14] = address;\n          *(int *)(puVar7 + iVar14 + 4) = iVar13;\n          puVar7[iVar14 + 8] = cVar15;\n          puVar7[iVar14 + 9] = bVar18;\n          return;\n        }\n        firmata::FirmataClass::sendString\n                  ((FirmataClass *)PTR_Firmata_08002044,PTR_s_too_many_queries_08002054);\n        return;\n      case 0x18:\n        cVar15 = *PTR_queryIndex_0800204c;\n        if (cVar15 < 1) {\n          *PTR_queryIndex_0800204c = 0xff;\n          return;\n        }\n      }\n      for (uVar16 = 0; iVar13 = cVar15 + 1, (int)uVar16 < iVar13; uVar16 = uVar16 + 1 & 0xff) {\n        if (address == PTR_query_08002050[uVar16 * 0xc]) goto LAB_08001e66;\n      }\n      uVar16 = 0;\nLAB_08001e66:\n      for (; puVar7 = PTR_query_08002050, (int)uVar16 < iVar13; uVar16 = uVar16 + 1 & 0xff) {\n        if (uVar16 < 8) {\n          iVar14 = (uVar16 + 1) * 0xc;\n          iVar17 = uVar16 * 0xc;\n          PTR_query_08002050[iVar17] = PTR_query_08002050[iVar14];\n          *(undefined4 *)(puVar7 + iVar17 + 4) = *(undefined4 *)(puVar7 + iVar14 + 4);\n          puVar7[iVar17 + 8] = puVar7[iVar14 + 8];\n          puVar7[iVar17 + 9] = puVar7[iVar14 + 9];\n        }\n      }\n      *PTR_queryIndex_0800204c = cVar15 + -1;\n      return;\n    }\n    break;\n  case 'x':\n    iVar13 = (uint)*argv + (uint)argv[1] * 0x80;\n    if ((1 < uVar16) && (iVar13 != 0)) {\n      *(int *)PTR_i2cReadDelayTime_08002058 = iVar13;\n    }\n    if (*PTR_isI2CEnabled_0800205c == '\\0') {\n      enableI2CPins();\n      return;\n    }\n    break;\n  case 'z':\n    if ((1 < uVar16) &&\n       (iVar13 = (uint)*argv + (uint)argv[1] * 0x80, *(int *)PTR_samplingInterval_0800206c = iVar13,\n       iVar13 == 0)) {\n      *(undefined4 *)PTR_samplingInterval_0800206c = 1;\n      return;\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "analogWriteCallback", 
                "readAndReportData", 
                "getPinState", 
                "setPinModeCallback", 
                "endTransmission", 
                "pinNametoDigitalPin", 
                "enableI2CPins", 
                "attached", 
                "sendString", 
                "getPinMode", 
                "wireWrite", 
                "beginTransmission", 
                "pin_in_pinmap", 
                "write", 
                "attachServo", 
                "detachServo"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001cd0", 
            "calling": [], 
            "imported": false, 
            "current_name": "sysexCallback"
        }, 
        "raise": {
            "renaming": {}, 
            "code": "\nint raise(int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 = _raise_r(*(undefined4 *)PTR__impure_ptr_08009ff4,__sig);\n  return iVar1;\n}\n\n", 
            "called": [
                "_raise_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009fe8", 
            "calling": [
                "abort"
            ], 
            "imported": false, 
            "current_name": "raise"
        }, 
        "HAL_ADC_Init": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_ADC_Init(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint32_t uVar5;\n  \n  if (hadc == (ADC_HandleTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (hadc->State == 0) {\n    hadc->ErrorCode = 0;\n    hadc->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(hadc);\n  }\n  HVar1 = ADC_ConversionStop_Disable(hadc);\n  uVar4 = hadc->State & 0x10;\n  if ((uVar4 == 0) && (HVar1 == HAL_OK)) {\n    hadc->State = hadc->State & 0xffffeefd | 2;\n    uVar5 = (hadc->Init).ContinuousConvMode;\n    uVar3 = (hadc->Init).DataAlign | (hadc->Init).ExternalTrigConv | uVar5 << 1;\n    uVar2 = (hadc->Init).ScanConvMode;\n    if (uVar2 == 0x100) {\n      uVar4 = 0x100;\n    }\n    else if (uVar2 == 1) {\n      uVar4 = 0x100;\n    }\n    if ((hadc->Init).DiscontinuousConvMode == 1) {\n      if (uVar5 == 0) {\n        uVar4 = uVar4 | ((hadc->Init).NbrOfDiscConversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        hadc->State = hadc->State | 0x20;\n        hadc->ErrorCode = hadc->ErrorCode | 1;\n      }\n    }\n    hadc->Instance->CR1 = uVar4 | hadc->Instance->CR1 & 0xffff16ff;\n    hadc->Instance->CR2 = DAT_08003ce0 & hadc->Instance->CR2 | uVar3;\n    uVar2 = (hadc->Init).ScanConvMode;\n    if ((uVar2 == 0x100) || (uVar2 == 1)) {\n      uVar4 = ((hadc->Init).NbrOfConversion - 1) * 0x100000;\n    }\n    else {\n      uVar4 = 0;\n    }\n    hadc->Instance->SQR1 = uVar4 | hadc->Instance->SQR1 & 0xff0fffff;\n    if (uVar3 != (DAT_08003ce4 & hadc->Instance->CR2)) {\n      hadc->State = hadc->State & 0xffffffed | 0x10;\n      hadc->ErrorCode = hadc->ErrorCode | 1;\n      return HAL_ERROR;\n    }\n    hadc->ErrorCode = 0;\n    hadc->State = hadc->State & 0xfffffffc | 1;\n    return HAL_OK;\n  }\n  hadc->State = hadc->State | 0x10;\n  return HAL_ERROR;\n}\n\n", 
            "called": [
                "ADC_ConversionStop_Disable", 
                "HAL_ADC_MspInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003bd8", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_Init"
        }, 
        "uart_init": {
            "renaming": {}, 
            "code": "\nvoid uart_init(serial_t *obj)\n\n{\n  USART_TypeDef *pUVar1;\n  USART_TypeDef *pUVar2;\n  USART_TypeDef *pUVar3;\n  void *a;\n  void *b;\n  USART_TypeDef *pUVar4;\n  GPIO_TypeDef *pGVar5;\n  uint32_t uVar6;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj != (serial_t *)0x0) {\n    a = pinmap_peripheral(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08008330);\n    b = pinmap_peripheral(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08008334);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_UART_pin_has_08008348);\n    }\n    else {\n      pUVar4 = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      obj->uart = pUVar4;\n      pUVar3 = DAT_08008340;\n      pUVar2 = DAT_0800833c;\n      pUVar1 = DAT_08008338;\n      if (pUVar4 == (USART_TypeDef *)0x0) {\n        iprintf(PTR_s_ERROR__U_S_ART_pins_mismatch_0800834c);\n      }\n      else {\n        if (pUVar4 == DAT_08008338) {\n          DAT_08008338[0x7b7].BRR = DAT_08008338[0x7b7].BRR | 0x4000;\n          pUVar1[0x7b7].BRR = pUVar1[0x7b7].BRR & 0xffffbfff;\n          pUVar1[0x7b7].CR3 = pUVar1[0x7b7].CR3 | 0x4000;\n          obj->index = '\\0';\n          obj->irq = USART1_IRQn;\n        }\n        else if (pUVar4 == DAT_0800833c) {\n          DAT_0800833c[0x106e].BRR = DAT_0800833c[0x106e].BRR | 0x20000;\n          pUVar2[0x106e].BRR = pUVar2[0x106e].BRR & 0xfffdffff;\n          pUVar2[0x106e].CR3 = pUVar2[0x106e].CR3 | 0x20000;\n          obj->index = '\\x01';\n          obj->irq = USART2_IRQn;\n        }\n        else if (pUVar4 == DAT_08008340) {\n          DAT_08008340[0x1049].CR3 = DAT_08008340[0x1049].CR3 | 0x40000;\n          pUVar3[0x1049].CR3 = pUVar3[0x1049].CR3 & 0xfffbffff;\n          pUVar3[0x104a].DR = pUVar3[0x104a].DR | 0x40000;\n          obj->index = '\\x02';\n          obj->irq = USART3_IRQn;\n        }\n        pGVar5 = set_GPIO_Port_Clock((uint)((int)obj->pin_rx << 0x18) >> 0x1c);\n        uVar6 = pinmap_function(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08008334);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_rx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar6 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Pull = (uVar6 << 0x1a) >> 0x1e;\n        *(uint *)(DAT_08008344 + 0x18) = *(uint *)(DAT_08008344 + 0x18) | 1;\n        switch((uVar6 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x4000000;\n        }\n        GPIO_InitStruct.Speed = 3;\n        HAL_GPIO_Init(pGVar5,&GPIO_InitStruct);\n        pGVar5 = set_GPIO_Port_Clock((uint)((int)obj->pin_tx << 0x18) >> 0x1c);\n        uVar6 = pinmap_function(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08008330);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_tx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar6 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Pull = (uVar6 << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(pGVar5,&GPIO_InitStruct);\n        *(UART_HandleTypeDef **)(PTR_uart_handlers_08008354 + (uint)obj->index * 4) = &obj->handle;\n        (obj->handle).Instance = obj->uart;\n        (obj->handle).Init.BaudRate = obj->baudrate;\n        (obj->handle).Init.WordLength = obj->databits;\n        (obj->handle).Init.StopBits = obj->stopbits;\n        (obj->handle).Init.Parity = obj->parity;\n        (obj->handle).Init.Mode = 0xc;\n        (obj->handle).Init.HwFlowCtl = 0;\n        (obj->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&obj->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "pinmap_peripheral", 
                "HAL_UART_Init", 
                "pinmap_merge_peripheral", 
                "set_GPIO_Port_Clock", 
                "iprintf", 
                "HAL_GPIO_Init", 
                "pinmap_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008078", 
            "calling": [
                "uart_debug_init", 
                "begin"
            ], 
            "imported": false, 
            "current_name": "uart_init"
        }, 
        "initVariant": {
            "renaming": {}, 
            "code": "\nvoid initVariant(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008f0c", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "initVariant"
        }, 
        "pwm_stop": {
            "renaming": {}, 
            "code": "\nvoid pwm_stop(PinName_conflict pin)\n\n{\n  uint32_t Channel;\n  uint32_t uVar1;\n  TIM_HandleTypeDef_conflict timHandle;\n  \n  timHandle.Instance =\n       (TIM_TypeDef_conflict *)pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_PWM_08007238);\n  if ((timHandle.Instance != (TIM_TypeDef_conflict *)0x0) &&\n     ((((Channel = get_pwm_channel(pin), Channel == 0 || (Channel == 4)) || (Channel == 8)) ||\n      ((Channel == 0xc || (Channel == 0x18)))))) {\n    uVar1 = pinmap_function(pin,(PinMap_conflict *)PTR_PinMap_PWM_08007238);\n    if ((uVar1 & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timHandle,Channel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timHandle,Channel);\n    }\n    HAL_TIM_PWM_DeInit(&timHandle);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_PWM_DeInit", 
                "get_pwm_channel", 
                "pinmap_peripheral", 
                "HAL_TIM_PWM_Stop", 
                "HAL_TIMEx_PWMN_Stop", 
                "pinmap_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080071e4", 
            "calling": [
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "pwm_stop"
        }, 
        "read": {
            "renaming": {}, 
            "code": "\nssize_t __thiscall HardwareSerial::read(HardwareSerial *this,int __fd,void *__buf,size_t __nbytes)\n\n{\n  byte bVar1;\n  ushort uVar2;\n  \n  uVar2 = (this->_serial).rx_tail;\n  if ((uint)(this->_serial).rx_head != (uint)uVar2) {\n    bVar1 = (this->_serial).rx_buff[uVar2];\n    (this->_serial).rx_tail = uVar2 + 1 & 0x3f;\n    return (uint)bVar1;\n  }\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008b2a", 
            "calling": [], 
            "imported": false, 
            "current_name": "read"
        }, 
        "HAL_I2C_Master_Transmit_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_I2C_Master_Transmit_IT\n          (I2C_HandleTypeDef_conflict *hi2c,uint16_t DevAddress,uint8_t *pData,uint16_t Size)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  uint32_t count;\n  \n  if (hi2c->State == HAL_I2C_STATE_READY) {\n    count = (uint)((ulonglong)DAT_080047ec * (ulonglong)(*(uint *)PTR_SystemCoreClock_080047e8 >> 3)\n                  >> 0x28) * 0x19;\n    do {\n      if (count == 0) {\n        hi2c->PreviousState = 0;\n        hi2c->State = HAL_I2C_STATE_READY;\n        hi2c->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      pIVar2 = hi2c->Instance;\n      count = count - 1;\n    } while ((pIVar2->SR2 & 2) != 0);\n    if (hi2c->Lock == HAL_LOCKED) {\n      HVar1 = HAL_BUSY;\n    }\n    else {\n      hi2c->Lock = HAL_LOCKED;\n      if ((pIVar2->CR1 & 1) == 0) {\n        pIVar2->CR1 = pIVar2->CR1 | 1;\n      }\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffff7ff;\n      hi2c->State = HAL_I2C_STATE_BUSY_TX;\n      hi2c->Mode = HAL_I2C_MODE_MASTER;\n      HVar1 = HAL_OK;\n      hi2c->ErrorCode = 0;\n      hi2c->pBuffPtr = pData;\n      hi2c->XferCount = Size;\n      hi2c->XferOptions = DAT_080047f0;\n      hi2c->XferSize = hi2c->XferCount;\n      hi2c->Devaddress = (uint)DevAddress;\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x100;\n      hi2c->Lock = HAL_UNLOCKED;\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 = HAL_BUSY;\n  }\n  return HVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004728", 
            "calling": [
                "i2c_master_write"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_Master_Transmit_IT"
        }, 
        "HAL_TIM_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_IRQHandler(TIM_HandleTypeDef_conflict *htim)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 2) != 0) && ((pTVar1->DIER & 2) != 0)) {\n    pTVar1->SR = 0xfffffffd;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((htim->Instance->CCMR1 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 4) != 0) && ((pTVar1->DIER & 4) != 0)) {\n    pTVar1->SR = 0xfffffffb;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((htim->Instance->CCMR1 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 8) != 0) && ((pTVar1->DIER & 8) != 0)) {\n    pTVar1->SR = 0xfffffff7;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((htim->Instance->CCMR2 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 0x10) != 0) && ((pTVar1->DIER & 0x10) != 0)) {\n    pTVar1->SR = 0xffffffef;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((htim->Instance->CCMR2 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 1) != 0) && ((pTVar1->DIER & 1) != 0)) {\n    pTVar1->SR = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(htim);\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 0x80) != 0) && ((pTVar1->DIER & 0x80) != 0)) {\n    pTVar1->SR = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(htim);\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 0x40) != 0) && ((pTVar1->DIER & 0x40) != 0)) {\n    pTVar1->SR = 0xffffffbf;\n    HAL_TIM_TriggerCallback(htim);\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 0x20) != 0) && ((pTVar1->DIER & 0x20) != 0)) {\n    pTVar1->SR = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(htim);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IC_CaptureCallback", 
                "HAL_TIM_PeriodElapsedCallback", 
                "HAL_TIMEx_CommutationCallback", 
                "HAL_TIM_PWM_PulseFinishedCallback", 
                "HAL_TIM_OC_DelayElapsedCallback", 
                "HAL_TIMEx_BreakCallback", 
                "HAL_TIM_TriggerCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005e6e", 
            "calling": [
                "TIM2_IRQHandler", 
                "TIM4_IRQHandler", 
                "TIM1_UP_IRQHandler", 
                "TIM3_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_IRQHandler"
        }, 
        "HAL_I2C_GetState": {
            "renaming": {}, 
            "code": "\nHAL_I2C_StateTypeDef_conflict HAL_I2C_GetState(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return hi2c->State;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800542a", 
            "calling": [
                "i2c_master_write", 
                "i2c_master_read"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_GetState"
        }, 
        "memset": {
            "renaming": {}, 
            "code": "\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  undefined *puVar1;\n  \n  for (puVar1 = (undefined *)__s; puVar1 != (undefined *)(__n + (int)__s); puVar1 = puVar1 + 1) {\n    *puVar1 = (char)__c;\n  }\n  return __s;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080091c6", 
            "calling": [
                "pwm_start", 
                "begin", 
                "adc_read_value", 
                "flush", 
                "__sfp", 
                "endTransmission", 
                "__sfmoreglue", 
                "std.isra.0"
            ], 
            "imported": false, 
            "current_name": "memset"
        }, 
        "attached": {
            "renaming": {}, 
            "code": "\nbool __thiscall Servo::attached(Servo *this)\n\n{\n  return SUB41(((uint)(byte)PTR_servos_08002708[(uint)this->servoIndex * 8] << 0x19) >> 0x1f,0);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080026f8", 
            "calling": [
                "setPinModeCallback", 
                "sysexCallback"
            ], 
            "imported": false, 
            "current_name": "attached"
        }, 
        "millis": {
            "renaming": {}, 
            "code": "\nuint32_t millis(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = GetCurrentMilli();\n  return uVar1;\n}\n\n", 
            "called": [
                "GetCurrentMilli"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008abc", 
            "calling": [
                "loop"
            ], 
            "imported": false, 
            "current_name": "millis"
        }, 
        "FirmataParser": {
            "renaming": {}, 
            "code": "\nFirmataParser * __thiscall\nfirmata::FirmataParser::FirmataParser(FirmataParser *this,uint8_t *dataBuffer,size_t dataBufferSize)\n\n{\n  uint uVar1;\n  \n  this->dataBuffer = dataBuffer;\n  this->dataBufferSize = dataBufferSize;\n  this->executeMultiByteCommand = '\\0';\n  this->multiByteChannel = '\\0';\n  this->waitForData = 0;\n  this->parsingSysex = false;\n  this->sysexBytesRead = 0;\n  this->currentAnalogCallbackContext = (void *)0x0;\n  this->currentDigitalCallbackContext = (void *)0x0;\n  this->currentReportAnalogCallbackContext = (void *)0x0;\n  this->currentReportDigitalCallbackContext = (void *)0x0;\n  this->currentPinModeCallbackContext = (void *)0x0;\n  this->currentPinValueCallbackContext = (void *)0x0;\n  this->currentReportFirmwareCallbackContext = (void *)0x0;\n  this->currentReportVersionCallbackContext = (void *)0x0;\n  this->currentDataBufferOverflowCallbackContext = (void *)0x0;\n  this->currentStringCallbackContext = (void *)0x0;\n  this->currentSysexCallbackContext = (void *)0x0;\n  this->currentSystemResetCallbackContext = (void *)0x0;\n  this->currentAnalogCallback = (callbackFunction)0x0;\n  this->currentDigitalCallback = (callbackFunction)0x0;\n  this->currentReportAnalogCallback = (callbackFunction)0x0;\n  this->currentReportDigitalCallback = (callbackFunction)0x0;\n  this->currentPinModeCallback = (callbackFunction)0x0;\n  this->currentPinValueCallback = (callbackFunction)0x0;\n  this->currentDataBufferOverflowCallback = (dataBufferOverflowCallbackFunction)0x0;\n  this->currentStringCallback = (stringCallbackFunction)0x0;\n  this->currentSysexCallback = (sysexCallbackFunction)0x0;\n  this->currentReportFirmwareCallback = (versionCallbackFunction)0x0;\n  this->currentReportVersionCallback = (systemCallbackFunction)0x0;\n  this->currentSystemResetCallback = (systemCallbackFunction)0x0;\n  uVar1 = count_leading_zeroes(dataBuffer);\n  this->allowBufferUpdate = SUB41(uVar1 >> 5,0);\n  return this;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080032bc", 
            "calling": [
                "FirmataClass"
            ], 
            "imported": false, 
            "current_name": "FirmataParser"
        }, 
        "HAL_I2C_Slave_Sequential_Transmit_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_I2C_Slave_Sequential_Transmit_IT\n          (I2C_HandleTypeDef_conflict *hi2c,uint8_t *pData,uint16_t Size,uint32_t XferOptions)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  uint32_t tmpreg;\n  \n  if (hi2c->State == HAL_I2C_STATE_LISTEN) {\n    if (pData == (uint8_t *)0x0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (Size == 0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (hi2c->Lock == HAL_LOCKED) {\n      HVar1 = HAL_BUSY;\n    }\n    else {\n      hi2c->Lock = HAL_LOCKED;\n      pIVar2 = hi2c->Instance;\n      if ((pIVar2->CR1 & 1) == 0) {\n        pIVar2->CR1 = pIVar2->CR1 | 1;\n      }\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffff7ff;\n      hi2c->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      hi2c->Mode = HAL_I2C_MODE_SLAVE;\n      HVar1 = HAL_OK;\n      hi2c->ErrorCode = 0;\n      hi2c->pBuffPtr = pData;\n      hi2c->XferCount = Size;\n      hi2c->XferOptions = XferOptions;\n      hi2c->XferSize = hi2c->XferCount;\n      hi2c->Lock = HAL_UNLOCKED;\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 = HAL_BUSY;\n  }\n  return HVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080048c8", 
            "calling": [
                "HAL_I2C_AddrCallback"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_Slave_Sequential_Transmit_IT"
        }, 
        "timer_enable_clock": {
            "renaming": {}, 
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid timer_enable_clock(TIM_HandleTypeDef_conflict *htim)\n\n{\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  \n  if (htim->Instance == DAT_080074d0) {\n    DAT_080074d0[0x2b7].DIER = DAT_080074d0[0x2b7].DIER | 0x800;\n    *(TIM_HandleTypeDef_conflict **)PTR_timer_handles_080074dc = htim;\n  }\n  if (htim->Instance == (TIM_TypeDef_conflict *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c | 1;\n    *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_080074dc + 4) = htim;\n  }\n  if (htim->Instance == DAT_080074d4) {\n    DAT_080074d4[0x63d].CCMR1 = DAT_080074d4[0x63d].CCMR1 | 2;\n    *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_080074dc + 8) = htim;\n  }\n  if (htim->Instance == DAT_080074d8) {\n    DAT_080074d8[0x631].SMCR = DAT_080074d8[0x631].SMCR | 4;\n    *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_080074dc + 0xc) = htim;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007438", 
            "calling": [
                "HAL_TIM_PWM_MspInit", 
                "HAL_TIM_OC_MspInit"
            ], 
            "imported": false, 
            "current_name": "timer_enable_clock"
        }, 
        "pin_in_pinmap": {
            "renaming": {}, 
            "code": "\n_Bool pin_in_pinmap(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  if (pin == NC) {\n    return false;\n  }\n  while( true ) {\n    if (map->pin == NC) {\n      return false;\n    }\n    if (pin == map->pin) break;\n    map = map + 1;\n  }\n  return true;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800738a", 
            "calling": [
                "analogWriteCallback", 
                "pinMode", 
                "setPinModeCallback", 
                "enableI2CPins", 
                "analogWrite", 
                "sysexCallback"
            ], 
            "imported": false, 
            "current_name": "pin_in_pinmap"
        }, 
        "HAL_I2C_EV_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  I2C_TypeDef_conflict *pIVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  pIVar1 = hi2c->Instance;\n  uVar4 = pIVar1->SR2;\n  uVar2 = pIVar1->SR1;\n  uVar3 = pIVar1->CR2;\n  if ((hi2c->Mode == HAL_I2C_MODE_MASTER) || (hi2c->Mode == HAL_I2C_MODE_MEM)) {\n    if (((uVar2 & 0x10001) == 0) || ((uVar3 & 0x200) == 0)) {\n      if (((DAT_080052e8 & uVar2) == 0) || ((uVar3 & 0x200) == 0)) {\n        if (((DAT_080052d4 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n          I2C_Master_ADDR(hi2c);\n        }\n      }\n      else {\n        I2C_Master_ADD10(hi2c);\n      }\n    }\n    else {\n      I2C_Master_SB(hi2c);\n    }\n    if ((DAT_080052dc & uVar4) == 0) {\n      if ((((DAT_080052ec & uVar2) != 0) && ((uVar3 & 0x400) != 0)) && ((DAT_080052e4 & uVar2) == 0)\n         ) {\n        I2C_MasterReceive_RXNE(hi2c);\n        return;\n      }\n      if (((DAT_080052e4 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(hi2c);\n        return;\n      }\n    }\n    else {\n      if ((((DAT_080052e0 & uVar2) != 0) && ((uVar3 & 0x400) != 0)) && ((DAT_080052e4 & uVar2) == 0)\n         ) {\n        I2C_MasterTransmit_TXE(hi2c);\n        return;\n      }\n      if (((DAT_080052e4 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(hi2c);\n        return;\n      }\n    }\n  }\n  else {\n    if (((DAT_080052d4 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n      I2C_Slave_ADDR(hi2c);\n      return;\n    }\n    if (((DAT_080052d8 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n      I2C_Slave_STOPF(hi2c);\n      return;\n    }\n    if ((DAT_080052dc & uVar4) == 0) {\n      if ((((DAT_080052ec & uVar2) != 0) && ((uVar3 & 0x400) != 0)) && ((DAT_080052e4 & uVar2) == 0)\n         ) {\n        I2C_SlaveReceive_RXNE(hi2c);\n        return;\n      }\n      if (((DAT_080052e4 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(hi2c);\n      }\n    }\n    else {\n      if ((((DAT_080052e0 & uVar2) != 0) && ((uVar3 & 0x400) != 0)) && ((DAT_080052e4 & uVar2) == 0)\n         ) {\n        I2C_SlaveTransmit_TXE(hi2c);\n        return;\n      }\n      if (((DAT_080052e4 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(hi2c);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "I2C_MasterReceive_BTF", 
                "I2C_Slave_ADDR", 
                "I2C_Slave_STOPF", 
                "I2C_MasterReceive_RXNE", 
                "I2C_SlaveReceive_BTF", 
                "I2C_Master_ADD10", 
                "I2C_MasterTransmit_BTF", 
                "I2C_MasterTransmit_TXE", 
                "I2C_SlaveReceive_RXNE", 
                "I2C_Master_ADDR", 
                "I2C_SlaveTransmit_TXE", 
                "I2C_SlaveTransmit_BTF", 
                "I2C_Master_SB"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005188", 
            "calling": [
                "I2C1_EV_IRQHandler", 
                "I2C2_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_EV_IRQHandler"
        }, 
        "I2C_DMAAbort": {
            "renaming": {}, 
            "code": "\nvoid I2C_DMAAbort(DMA_HandleTypeDef_conflict *hdma)\n\n{\n  I2C_HandleTypeDef_conflict *hi2c;\n  \n  hi2c = (I2C_HandleTypeDef_conflict *)hdma->Parent;\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n  hi2c->XferCount = 0;\n  hi2c->hdmatx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0;\n  hi2c->hdmarx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0;\n  if (hi2c->State != HAL_I2C_STATE_ABORT) {\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n    hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n    HAL_I2C_ErrorCallback(hi2c);\n    return;\n  }\n  hi2c->State = HAL_I2C_STATE_READY;\n  hi2c->Mode = HAL_I2C_MODE_NONE;\n  hi2c->ErrorCode = 0;\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n  HAL_I2C_AbortCpltCallback(hi2c);\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_AbortCpltCallback", 
                "HAL_I2C_ErrorCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080053cc", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C_DMAAbort"
        }, 
        "USART2_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid USART2_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART2_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_080087e8 + 4));\n  return;\n}\n\n", 
            "called": [
                "HAL_NVIC_ClearPendingIRQ", 
                "HAL_UART_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080087d4", 
            "calling": [], 
            "imported": false, 
            "current_name": "USART2_IRQHandler"
        }, 
        "HAL_NVIC_DisableIRQ": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_DisableIRQ(IRQn_Type_conflict IRQn)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)IRQn;\n  if (-1 < (int)uVar1) {\n    *(int *)(DAT_08003fd4 + ((uVar1 >> 5) + 0x20) * 4) = 1 << (uVar1 & 0x1f);\n    DataSynchronizationBarrier(0xf);\n    InstructionSynchronizationBarrier(0xf);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003fb0", 
            "calling": [
                "TimerPulseDeinit"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_DisableIRQ"
        }, 
        "HAL_TIM_PWM_ConfigChannel": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_TIM_PWM_ConfigChannel\n          (TIM_HandleTypeDef_conflict *htim,TIM_OC_InitTypeDef *sConfig,uint32_t Channel)\n\n{\n  if (htim->Lock != HAL_LOCKED) {\n    htim->Lock = HAL_LOCKED;\n    htim->State = HAL_TIM_STATE_BUSY;\n    switch(Channel) {\n    case 0:\n      TIM_OC1_SetConfig(htim->Instance,sConfig);\n      htim->Instance->CCMR1 = htim->Instance->CCMR1 | 8;\n      htim->Instance->CCMR1 = htim->Instance->CCMR1 & 0xfffffffb;\n      htim->Instance->CCMR1 = htim->Instance->CCMR1 | sConfig->OCFastMode;\n      break;\n    case 4:\n      TIM_OC2_SetConfig(htim->Instance,sConfig);\n      htim->Instance->CCMR1 = htim->Instance->CCMR1 | 0x800;\n      htim->Instance->CCMR1 = htim->Instance->CCMR1 & 0xfffffbff;\n      htim->Instance->CCMR1 = htim->Instance->CCMR1 | sConfig->OCFastMode << 8;\n      break;\n    case 8:\n      TIM_OC3_SetConfig(htim->Instance,sConfig);\n      htim->Instance->CCMR2 = htim->Instance->CCMR2 | 8;\n      htim->Instance->CCMR2 = htim->Instance->CCMR2 & 0xfffffffb;\n      htim->Instance->CCMR2 = htim->Instance->CCMR2 | sConfig->OCFastMode;\n      break;\n    case 0xc:\n      TIM_OC4_SetConfig(htim->Instance,sConfig);\n      htim->Instance->CCMR2 = htim->Instance->CCMR2 | 0x800;\n      htim->Instance->CCMR2 = htim->Instance->CCMR2 & 0xfffffbff;\n      htim->Instance->CCMR2 = htim->Instance->CCMR2 | sConfig->OCFastMode << 8;\n    }\n    htim->State = HAL_TIM_STATE_READY;\n    htim->Lock = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n", 
            "called": [
                "TIM_OC4_SetConfig", 
                "TIM_OC3_SetConfig", 
                "TIM_OC2_SetConfig", 
                "TIM_OC1_SetConfig"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006186", 
            "calling": [
                "pwm_start"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_ConfigChannel"
        }, 
        "serial_rx_active": {
            "renaming": {}, 
            "code": "\nuint8_t serial_rx_active(serial_t *obj)\n\n{\n  HAL_UART_StateTypeDef HVar1;\n  \n  HVar1 = HAL_UART_GetState(*(UART_HandleTypeDef **)\n                             (PTR_uart_handlers_080085d8 + (uint)obj->index * 4));\n  return (HVar1 & 0x22U) == 0x22;\n}\n\n", 
            "called": [
                "HAL_UART_GetState"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080085b8", 
            "calling": [
                "uart_getc", 
                "uart_attach_rx_callback"
            ], 
            "imported": false, 
            "current_name": "serial_rx_active"
        }, 
        "analogWriteCallback": {
            "renaming": {}, 
            "code": "\nvoid analogWriteCallback(byte pin,int value)\n\n{\n  bool bVar1;\n  byte bVar2;\n  _Bool _Var3;\n  uint ulPin;\n  uint32_t uVar4;\n  \n  ulPin = (uint)pin;\n  if (0x3b < ulPin) {\n    return;\n  }\n  bVar2 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_080002d8,pin);\n  if (bVar2 == '\\x03') {\n    if (ulPin < 0x3c) {\n      if (PTR_digitalPin_080002dc[ulPin] == NC) {\n        _Var3 = false;\n      }\n      else {\n        uVar4 = pinNametoDigitalPin(PTR_digitalPin_080002dc[ulPin]);\n        if (uVar4 == 0) {\n          _Var3 = false;\n        }\n        else {\n          uVar4 = pinNametoDigitalPin(PTR_digitalPin_080002dc[ulPin]);\n          if (uVar4 == 1) {\n            _Var3 = false;\n          }\n          else {\n            _Var3 = pin_in_pinmap(PTR_digitalPin_080002dc[ulPin],\n                                  (PinMap_conflict *)PTR_PinMap_PWM_080002e8);\n          }\n        }\n      }\n    }\n    else {\n      _Var3 = false;\n    }\n    if (_Var3 != false) {\n      analogWrite(ulPin,value);\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_080002d8,pin,value);\n  }\n  else if (bVar2 == '\\x04') {\n    if (ulPin < 0x3c) {\n      if (PTR_digitalPin_080002dc[ulPin] == NC) {\n        bVar1 = false;\n      }\n      else {\n        uVar4 = pinNametoDigitalPin(PTR_digitalPin_080002dc[ulPin]);\n        if (uVar4 == 0) {\n          bVar1 = false;\n        }\n        else {\n          uVar4 = pinNametoDigitalPin(PTR_digitalPin_080002dc[ulPin]);\n          if (uVar4 == 1) {\n            bVar1 = false;\n          }\n          else {\n            bVar1 = true;\n          }\n        }\n      }\n    }\n    else {\n      bVar1 = false;\n    }\n    if (bVar1) {\n      Servo::write((Servo *)(PTR_servos_080002e4 + (uint)(byte)PTR_servoPinMap_080002e0[ulPin] * 3),\n                   value);\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_080002d8,pin,value);\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "getPinMode", 
                "pinNametoDigitalPin", 
                "setPinState", 
                "pin_in_pinmap", 
                "write", 
                "analogWrite"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000214", 
            "calling": [
                "sysexCallback"
            ], 
            "imported": false, 
            "current_name": "analogWriteCallback"
        }, 
        "_realloc_r": {
            "renaming": {}, 
            "code": "\nvoid * _realloc_r(undefined4 param_1,void *param_2,void *param_3,undefined4 param_4)\n\n{\n  void *pvVar1;\n  void *pvVar2;\n  \n  if (param_2 != (void *)0x0) {\n    if (param_3 == (void *)0x0) {\n      _free_r();\n      pvVar1 = param_3;\n    }\n    else {\n      pvVar2 = (void *)_malloc_usable_size_r();\n      pvVar1 = param_2;\n      if ((pvVar2 < param_3) && (pvVar1 = (void *)_malloc_r(param_1,param_3), pvVar1 != (void *)0x0)\n         ) {\n        memcpy(pvVar1,param_2,(size_t)param_3);\n        _free_r(param_1,param_2);\n      }\n    }\n    return pvVar1;\n  }\n  pvVar1 = (void *)_malloc_r(param_1,param_3,param_3,param_4);\n  return pvVar1;\n}\n\n", 
            "called": [
                "_malloc_r", 
                "_malloc_usable_size_r", 
                "_free_r", 
                "memcpy"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009f4c", 
            "calling": [
                "realloc"
            ], 
            "imported": false, 
            "current_name": "_realloc_r"
        }, 
        "HAL_TIM_PWM_Start": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_TIM_PWM_Start(TIM_HandleTypeDef_conflict *htim,uint32_t Channel)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  TIM_CCxChannelCmd(htim->Instance,Channel,1);\n  pTVar1 = htim->Instance;\n  if (pTVar1 == DAT_080063bc) {\n    pTVar1->BDTR = pTVar1->BDTR | 0x8000;\n  }\n  htim->Instance->CR1 = htim->Instance->CR1 | 1;\n  return HAL_OK;\n}\n\n", 
            "called": [
                "TIM_CCxChannelCmd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006390", 
            "calling": [
                "pwm_start"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_Start"
        }, 
        "SystemClock_Config": {
            "renaming": {}, 
            "code": "\nvoid SystemClock_Config(void)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  RCC_PeriphCLKInitTypeDef PeriphClkInit;\n  RCC_ClkInitTypeDef RCC_ClkInitStruct;\n  RCC_OscInitTypeDef RCC_OscInitStruct;\n  \n  RCC_OscInitStruct.OscillatorType = 2;\n  RCC_OscInitStruct.HSIState = 1;\n  RCC_OscInitStruct.HSICalibrationValue = 0x10;\n  RCC_OscInitStruct.PLL.PLLState = 2;\n  RCC_OscInitStruct.PLL.PLLSource = 0;\n  RCC_OscInitStruct.PLL.PLLMUL = 0x380000;\n  HVar1 = HAL_RCC_OscConfig((RCC_OscInitTypeDef_conflict *)&RCC_OscInitStruct);\n  if (HVar1 != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x88);\n  }\n  RCC_ClkInitStruct.ClockType = 0xf;\n  RCC_ClkInitStruct.SYSCLKSource = 2;\n  RCC_ClkInitStruct.AHBCLKDivider = 0;\n  RCC_ClkInitStruct.APB1CLKDivider = 0x400;\n  RCC_ClkInitStruct.APB2CLKDivider = 0;\n  HVar1 = HAL_RCC_ClockConfig((RCC_ClkInitTypeDef_conflict *)&RCC_ClkInitStruct,2);\n  if (HVar1 != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x95);\n  }\n  PeriphClkInit.PeriphClockSelection = 2;\n  PeriphClkInit.AdcClockSelection = 0x8000;\n  HVar1 = HAL_RCCEx_PeriphCLKConfig((RCC_PeriphCLKInitTypeDef_conflict *)&PeriphClkInit);\n  if (HVar1 != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x9c);\n  }\n  uVar2 = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config((uint)((ulonglong)DAT_08003650 * (ulonglong)uVar2 >> 0x26));\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n", 
            "called": [
                "HAL_RCC_GetHCLKFreq", 
                "_Error_Handler", 
                "HAL_SYSTICK_CLKSourceConfig", 
                "HAL_RCC_OscConfig", 
                "HAL_SYSTICK_Config", 
                "HAL_NVIC_SetPriority", 
                "HAL_RCCEx_PeriphCLKConfig", 
                "HAL_RCC_ClockConfig"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080035b8", 
            "calling": [
                "hw_config_init"
            ], 
            "imported": false, 
            "current_name": "SystemClock_Config"
        }, 
        "HAL_I2C_EnableListen_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_I2C_EnableListen_IT(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  I2C_TypeDef_conflict *pIVar1;\n  \n  if (hi2c->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  hi2c->State = HAL_I2C_STATE_LISTEN;\n  pIVar1 = hi2c->Instance;\n  if ((pIVar1->CR1 & 1) == 0) {\n    pIVar1->CR1 = pIVar1->CR1 | 1;\n  }\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n  hi2c->Instance->CR2 = hi2c->Instance->CR2 | 0x300;\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080049e0", 
            "calling": [
                "i2c_attachSlaveRxEvent", 
                "HAL_I2C_ListenCpltCallback", 
                "i2c_attachSlaveTxEvent", 
                "HAL_I2C_ErrorCallback"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_EnableListen_IT"
        }, 
        "__aeabi_atexit": {
            "renaming": {}, 
            "code": "\nvoid __aeabi_atexit(undefined4 param_1,undefined4 param_2)\n\n{\n  __cxa_atexit(param_2,param_1);\n  return;\n}\n\n", 
            "called": [
                "__cxa_atexit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080090c2", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "__aeabi_atexit"
        }, 
        "HAL_I2C_ER_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  HAL_I2C_StateTypeDef_conflict HVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  pIVar2 = hi2c->Instance;\n  uVar3 = pIVar2->SR1;\n  uVar4 = pIVar2->CR2;\n  if (((uVar3 & DAT_080053c8) != 0) && ((uVar4 & 0x100) != 0)) {\n    hi2c->ErrorCode = hi2c->ErrorCode | 1;\n    pIVar2->SR1 = 0xfffffeff;\n    hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x8000;\n  }\n  if (((uVar3 & 0x10200) != 0) && ((uVar4 & 0x100) != 0)) {\n    hi2c->ErrorCode = hi2c->ErrorCode | 2;\n    hi2c->Instance->SR1 = 0xfffffdff;\n  }\n  if (((uVar3 & 0x10400) != 0) && ((uVar4 & 0x100) != 0)) {\n    HVar1 = hi2c->State;\n    if (((hi2c->Mode == HAL_I2C_MODE_SLAVE) && (hi2c->XferCount == 0)) &&\n       (((HVar1 == HAL_I2C_STATE_BUSY_TX || (HVar1 == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((HVar1 == HAL_I2C_STATE_LISTEN && (hi2c->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(hi2c);\n    }\n    else {\n      hi2c->ErrorCode = hi2c->ErrorCode | 4;\n      if (hi2c->Mode == HAL_I2C_MODE_MASTER) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n      }\n      hi2c->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((uVar3 & 0x10800) != 0) && ((uVar4 & 0x100) != 0)) {\n    hi2c->ErrorCode = hi2c->ErrorCode | 8;\n    hi2c->Instance->SR1 = 0xfffff7ff;\n  }\n  if (hi2c->ErrorCode != 0) {\n    I2C_ITError(hi2c);\n  }\n  return;\n}\n\n", 
            "called": [
                "I2C_Slave_AF", 
                "I2C_ITError"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080052f0", 
            "calling": [
                "I2C2_ER_IRQHandler", 
                "I2C1_ER_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_ER_IRQHandler"
        }, 
        "staticReportFirmwareCallback": {
            "renaming": {}, 
            "code": "\nvoid firmata::FirmataClass::staticReportFirmwareCallback\n               (void *context,size_t param_2,size_t param_3,char *param_4)\n\n{\n  if (context != (void *)0x0) {\n    printFirmwareVersion((FirmataClass *)context);\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "printFirmwareVersion"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002e1a", 
            "calling": [], 
            "imported": false, 
            "current_name": "staticReportFirmwareCallback"
        }, 
        "pinmap_find_function": {
            "renaming": {}, 
            "code": "\nuint32_t pinmap_find_function(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map->pin == NC) {\n      return 0xffffffff;\n    }\n    if (map->pin == pin) break;\n    map = map + 1;\n  }\n  return map->function;\n}\n\n", 
            "called": [
                "pinmap_find_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800735a", 
            "calling": [
                "pinmap_find_function", 
                "pinmap_function"
            ], 
            "imported": false, 
            "current_name": "pinmap_find_function"
        }, 
        "__sfp": {
            "renaming": {}, 
            "code": "\nint * __sfp(undefined4 *param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int iVar3;\n  int **ppiVar4;\n  \n  iVar3 = *(int *)PTR__global_impure_ptr_08009e24;\n  if (*(int *)(iVar3 + 0x18) == 0) {\n    __sinit(iVar3);\n  }\n  ppiVar4 = (int **)(iVar3 + 0x48);\n  do {\n    piVar2 = ppiVar4[2];\n    piVar1 = ppiVar4[1];\n    while (piVar1 = (int *)((int)piVar1 + -1), -1 < (int)piVar1) {\n      if (*(short *)(piVar2 + 3) == 0) {\n        *(undefined2 *)((int)piVar2 + 0xe) = 0xffff;\n        piVar2[0x19] = 0;\n        *(undefined2 *)(piVar2 + 3) = 1;\n        *piVar2 = 0;\n        piVar2[2] = 0;\n        piVar2[1] = 0;\n        piVar2[4] = 0;\n        piVar2[5] = 0;\n        piVar2[6] = 0;\n        memset(piVar2 + 0x17,0,8);\n        piVar2[0xd] = 0;\n        piVar2[0xe] = 0;\n        piVar2[0x12] = 0;\n        piVar2[0x13] = 0;\n        return piVar2;\n      }\n      piVar2 = piVar2 + 0x1a;\n    }\n    if (*ppiVar4 == (int *)0x0) {\n      piVar1 = (int *)__sfmoreglue(param_1,4);\n      *ppiVar4 = piVar1;\n      if (piVar1 == (int *)0x0) {\n        *param_1 = 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar4 = (int **)*ppiVar4;\n  } while( true );\n}\n\n", 
            "called": [
                "__sinit", 
                "__sfmoreglue", 
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009db0", 
            "calling": [
                "__sinit"
            ], 
            "imported": false, 
            "current_name": "__sfp"
        }, 
        "strchr": {
            "renaming": {}, 
            "code": "\nchar * strchr(char *__s,int __c)\n\n{\n  byte *pbVar1;\n  \n  do {\n    pbVar1 = (byte *)__s;\n    if (*pbVar1 == 0) {\n      if ((__c & 0xffU) != 0) {\n        pbVar1 = (byte *)0x0;\n      }\n      return (char *)pbVar1;\n    }\n    __s = (char *)(pbVar1 + 1);\n  } while ((__c & 0xffU) != (uint)*pbVar1);\n  return (char *)pbVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009938", 
            "calling": [
                "strrchr"
            ], 
            "imported": false, 
            "current_name": "strchr"
        }, 
        "I2C_SlaveTransmit_TXE": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_SlaveTransmit_TXE(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  HAL_I2C_StateTypeDef_conflict HVar1;\n  byte *pbVar2;\n  \n  HVar1 = hi2c->State;\n  if (hi2c->XferCount != 0) {\n    pbVar2 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = pbVar2 + 1;\n    hi2c->Instance->DR = (uint)*pbVar2;\n    hi2c->XferCount = hi2c->XferCount - 1;\n    if ((hi2c->XferCount == 0) && (HVar1 == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n      hi2c->PreviousState = 0x21;\n      hi2c->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(hi2c);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004a24", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_SlaveTransmit_TXE"
        }, 
        "_malloc_usable_size_r": {
            "renaming": {}, 
            "code": "\nint _malloc_usable_size_r(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = *(int *)(param_2 + -4) + -4;\n  if (*(int *)(param_2 + -4) < 0) {\n    iVar1 = iVar1 + *(int *)(param_2 + iVar1);\n  }\n  return iVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a154", 
            "calling": [
                "_realloc_r"
            ], 
            "imported": false, 
            "current_name": "_malloc_usable_size_r"
        }, 
        "get_i2c_obj": {
            "renaming": {}, 
            "code": "\ni2c_t_conflict * get_i2c_obj(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return (i2c_t_conflict *)&hi2c[-1].EventCount;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007f78", 
            "calling": [
                "HAL_I2C_ListenCpltCallback", 
                "HAL_I2C_AddrCallback", 
                "HAL_I2C_ErrorCallback"
            ], 
            "imported": false, 
            "current_name": "get_i2c_obj"
        }, 
        "HAL_TIM_PWM_MspInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_PWM_MspInit(TIM_HandleTypeDef_conflict *htim)\n\n{\n  undefined *puVar1;\n  uint32_t uVar2;\n  GPIO_TypeDef *GPIOx;\n  uint32_t tmpreg;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  puVar1 = PTR_g_current_pin_08007100;\n  uVar2 = pinmap_function(*PTR_g_current_pin_08007100,(PinMap_conflict *)PTR_PinMap_PWM_08007104);\n  timer_enable_clock(htim);\n  GPIOx = set_GPIO_Port_Clock((uint)((int)(char)*puVar1 << 0x18) >> 0x1c);\n  GPIO_InitStruct.Mode = 2;\n  GPIO_InitStruct.Pull = 0;\n  GPIO_InitStruct.Speed = 3;\n  *(uint *)(DAT_08007108 + 0x18) = *(uint *)(DAT_08007108 + 0x18) | 1;\n  switch((uVar2 << 0x11) >> 0x19) {\n  case 1:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000001;\n    break;\n  case 2:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffe | 0x7000000;\n    break;\n  case 3:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000002;\n    break;\n  case 4:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffd | 0x7000000;\n    break;\n  case 5:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000004;\n    break;\n  case 6:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffb | 0x7000000;\n    break;\n  case 7:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000008;\n    break;\n  case 8:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffff7 | 0x7000000;\n    break;\n  case 9:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000030;\n    break;\n  case 10:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffffcf | 0x7000010;\n    break;\n  case 0xb:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffffcf | 0x7000000;\n    break;\n  case 0xc:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x70000c0;\n    break;\n  case 0xd:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffff3f | 0x7000040;\n    break;\n  case 0xe:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffff3f | 0x7000000;\n    break;\n  case 0xf:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000300;\n    break;\n  case 0x10:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000200;\n    break;\n  case 0x11:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000100;\n    break;\n  case 0x12:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000000;\n    break;\n  case 0x13:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000c00;\n    break;\n  case 0x14:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffff3ff | 0x7000800;\n    break;\n  case 0x15:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffff3ff | 0x7000000;\n    break;\n  case 0x16:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7001000;\n    break;\n  case 0x17:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffefff | 0x7000000;\n    break;\n  case 0x1b:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7008000;\n    break;\n  case 0x1c:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffff7fff | 0x7000000;\n    break;\n  case 0x21:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff;\n    break;\n  case 0x22:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x1000000;\n    break;\n  case 0x23:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x2000000;\n    break;\n  case 0x24:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x4000000;\n  }\n  GPIO_InitStruct.Pin = 1 << (*PTR_g_current_pin_08007100 & 0xf) & 0xffff;\n  HAL_GPIO_Init(GPIOx,&GPIO_InitStruct);\n  return;\n}\n\n", 
            "called": [
                "timer_enable_clock", 
                "set_GPIO_Port_Clock", 
                "HAL_GPIO_Init", 
                "pinmap_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006e68", 
            "calling": [
                "HAL_TIM_PWM_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_MspInit"
        }, 
        "setTimerCounter": {
            "renaming": {}, 
            "code": "\nvoid setTimerCounter(stimer_t_conflict *obj,uint32_t value)\n\n{\n  ((obj->handle).Instance)->CNT = value;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800774a", 
            "calling": [
                "ServoIrqHandle"
            ], 
            "imported": false, 
            "current_name": "setTimerCounter"
        }, 
        "_vfiprintf_r": {
            "renaming": {}, 
            "code": "\nint _vfiprintf_r(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  int iVar3;\n  void *pvVar4;\n  int *piVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  int unaff_r9;\n  int iVar8;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 local_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  local_8c = param_4;\n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == PTR___sf_fake_stdin_08009588) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR___sf_fake_stdout_08009590) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR___sf_fake_stderr_08009594) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar8 = __swsetup_r(param_1,param_2), iVar8 != 0)) {\n    return -1;\n  }\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar6 = param_3;\nLAB_080093be:\n  pbVar7 = pbVar6;\n  if (*pbVar7 != 0) goto LAB_08009474;\n  goto LAB_080093c8;\nLAB_08009474:\n  pbVar6 = pbVar7 + 1;\n  if (*pbVar7 != 0x25) goto LAB_080093be;\nLAB_080093c8:\n  iVar8 = (int)pbVar7 - (int)param_3;\n  if (iVar8 != 0) {\n    iVar3 = __sfputs_r(param_1,param_2,param_3,iVar8);\n    if (iVar3 == -1) {\nLAB_08009568:\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar8;\n  }\n  if (*pbVar7 == 0) goto LAB_08009568;\n  local_88 = 0;\n  local_7c = 0;\n  local_84 = -1;\n  local_80 = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar6 = pbVar7 + 1;\n  while( true ) {\n    pvVar4 = memchr(PTR_s___0__0800958c,(uint)*pbVar6,5);\n    puVar2 = PTR_DAT_08009598;\n    param_3 = pbVar6 + 1;\n    if (pvVar4 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar4 - (int)PTR_s___0__0800958c & 0xffU) | local_88;\n    pbVar6 = param_3;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar6 == 0x2a) {\n    piVar5 = local_8c + 1;\n    iVar8 = *local_8c;\n    local_8c = piVar5;\n    if (-1 < iVar8) goto LAB_08009498;\n    local_7c = -iVar8;\n    local_88 = local_88 | 2;\n  }\n  else {\n    bVar1 = false;\n    iVar8 = local_7c;\n    param_3 = pbVar6;\n    while( true ) {\n      if (9 < *param_3 - 0x30) break;\n      iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n      bVar1 = true;\n      param_3 = param_3 + 1;\n    }\n    if (bVar1) {\nLAB_08009498:\n      local_7c = iVar8;\n    }\n  }\n  if (*param_3 == 0x2e) {\n    if (param_3[1] == 0x2a) {\n      param_3 = param_3 + 2;\n      piVar5 = local_8c + 1;\n      local_84 = *local_8c;\n      local_8c = piVar5;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n    }\n    else {\n      bVar1 = false;\n      iVar8 = 0;\n      local_84 = 0;\n      while( true ) {\n        param_3 = param_3 + 1;\n        if (9 < *param_3 - 0x30) break;\n        iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar8;\n      }\n    }\n  }\n  pvVar4 = memchr(PTR_DAT_08009598,(uint)*param_3,3);\n  if (pvVar4 != (void *)0x0) {\n    param_3 = param_3 + 1;\n    local_88 = local_88 | 0x40 << ((int)pvVar4 - (int)puVar2 & 0xffU);\n  }\n  local_70 = *param_3;\n  param_3 = param_3 + 1;\n  pvVar4 = memchr(PTR_s_efgEFG_0800959c,(uint)local_70,6);\n  if (pvVar4 == (void *)0x0) {\n    iVar8 = _printf_i(param_1,&local_88,param_2,DAT_080095a4,&local_8c);\n  }\n  else {\n    iVar8 = param_1;\n    if (DAT_080095a0 == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar8 = unaff_r9;\n      goto LAB_0800951a;\n    }\n  }\n  if (iVar8 == -1) goto LAB_08009568;\nLAB_0800951a:\n  local_74 = local_74 + iVar8;\n  pbVar6 = param_3;\n  unaff_r9 = iVar8;\n  goto LAB_080093be;\n}\n\n", 
            "called": [
                "__swsetup_r", 
                "__sinit", 
                "_printf_i", 
                "memchr", 
                "__sfputs_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800937c", 
            "calling": [
                "fiprintf", 
                "iprintf"
            ], 
            "imported": false, 
            "current_name": "_vfiprintf_r"
        }, 
        "I2C_MasterTransmit_BTF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_MasterTransmit_BTF(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  uint32_t uVar1;\n  byte *pbVar2;\n  \n  uVar1 = hi2c->XferOptions;\n  if (hi2c->State == HAL_I2C_STATE_BUSY_TX) {\n    if (hi2c->XferCount == 0) {\n      if (((uVar1 == 4) || (uVar1 == 8)) || (uVar1 == 0xffff0000)) {\n        hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n        hi2c->PreviousState = 0;\n        hi2c->State = HAL_I2C_STATE_READY;\n        if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n          hi2c->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(hi2c);\n        }\n        else {\n          hi2c->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(hi2c);\n        }\n      }\n      else {\n        hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n        hi2c->PreviousState = 0x11;\n        hi2c->Mode = HAL_I2C_MODE_NONE;\n        hi2c->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(hi2c);\n      }\n    }\n    else {\n      pbVar2 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = pbVar2 + 1;\n      hi2c->Instance->DR = (uint)*pbVar2;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_MasterTxCpltCallback", 
                "HAL_I2C_MemTxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004ccc", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_MasterTransmit_BTF"
        }, 
        "timer_disable_clock": {
            "renaming": {}, 
            "code": "\nvoid timer_disable_clock(TIM_HandleTypeDef_conflict *htim)\n\n{\n  if (htim->Instance == DAT_08007534) {\n    *(uint *)(DAT_08007540 + 0x18) = *(uint *)(DAT_08007540 + 0x18) & 0xfffff7ff;\n  }\n  if (htim->Instance == (TIM_TypeDef_conflict *)0x40000000) {\n    *(uint *)(DAT_08007540 + 0x1c) = *(uint *)(DAT_08007540 + 0x1c) & 0xfffffffe;\n  }\n  if (htim->Instance == DAT_08007538) {\n    *(uint *)(DAT_08007540 + 0x1c) = *(uint *)(DAT_08007540 + 0x1c) & 0xfffffffd;\n  }\n  if (htim->Instance == DAT_0800753c) {\n    *(uint *)(DAT_08007540 + 0x1c) = *(uint *)(DAT_08007540 + 0x1c) & 0xfffffffb;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080074e0", 
            "calling": [
                "HAL_TIM_OC_MspDeInit", 
                "HAL_TIM_PWM_MspDeInit"
            ], 
            "imported": false, 
            "current_name": "timer_disable_clock"
        }, 
        "HAL_RCC_GetHCLKFreq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCC_GetHCLKFreq(void)\n\n{\n  return *(uint32_t *)PTR_SystemCoreClock_08005a24;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005a1c", 
            "calling": [
                "HAL_RCC_GetPCLK1Freq", 
                "HAL_RCC_GetPCLK2Freq", 
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetHCLKFreq"
        }, 
        "I2C_MasterTransmit_TXE": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_MasterTransmit_TXE(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  HAL_I2C_StateTypeDef_conflict HVar1;\n  byte *pbVar2;\n  uint32_t uVar3;\n  \n  HVar1 = hi2c->State;\n  uVar3 = hi2c->XferOptions;\n  if ((hi2c->XferSize == 0) && (HVar1 == HAL_I2C_STATE_BUSY_TX)) {\n    if ((uVar3 == 4) || ((uVar3 == 8 || (uVar3 == 0xffff0000)))) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n      hi2c->PreviousState = 0;\n      hi2c->State = HAL_I2C_STATE_READY;\n      if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n        hi2c->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(hi2c);\n      }\n      else {\n        hi2c->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(hi2c);\n      }\n    }\n    else {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n      hi2c->PreviousState = 0x11;\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      hi2c->State = HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(hi2c);\n    }\n  }\n  else if ((HVar1 == HAL_I2C_STATE_BUSY_TX) ||\n          ((hi2c->Mode == HAL_I2C_MODE_MEM && (HVar1 == HAL_I2C_STATE_BUSY_RX)))) {\n    if (hi2c->XferCount == 0) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n    }\n    else if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n      if (hi2c->EventCount == 0) {\n        if (hi2c->MemaddSize == 1) {\n          hi2c->Instance->DR = hi2c->Memaddress & 0xff;\n          hi2c->EventCount = hi2c->EventCount + 2;\n        }\n        else {\n          hi2c->Instance->DR = (hi2c->Memaddress << 0x10) >> 0x18;\n          hi2c->EventCount = hi2c->EventCount + 1;\n        }\n      }\n      else if (hi2c->EventCount == 1) {\n        hi2c->Instance->DR = hi2c->Memaddress & 0xff;\n        hi2c->EventCount = hi2c->EventCount + 1;\n      }\n      else if (hi2c->EventCount == 2) {\n        if (hi2c->State == HAL_I2C_STATE_BUSY_RX) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x100;\n        }\n        else if (hi2c->State == HAL_I2C_STATE_BUSY_TX) {\n          pbVar2 = hi2c->pBuffPtr;\n          hi2c->pBuffPtr = pbVar2 + 1;\n          hi2c->Instance->DR = (uint)*pbVar2;\n          hi2c->XferCount = hi2c->XferCount - 1;\n        }\n      }\n    }\n    else {\n      pbVar2 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = pbVar2 + 1;\n      hi2c->Instance->DR = (uint)*pbVar2;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_MasterTxCpltCallback", 
                "HAL_I2C_MemTxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004b82", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_MasterTransmit_TXE"
        }, 
        "__sinit": {
            "renaming": {}, 
            "code": "\nvoid __sinit(int param_1)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  bool bVar3;\n  \n  if (*(int *)(param_1 + 0x18) == 0) {\n    *(undefined4 *)(param_1 + 0x48) = 0;\n    *(undefined4 *)(param_1 + 0x4c) = 0;\n    *(undefined4 *)(param_1 + 0x50) = 0;\n    iVar2 = *(int *)PTR__global_impure_ptr_08009da8;\n    *(undefined4 *)(param_1 + 0x28) = DAT_08009dac;\n    bVar3 = param_1 == iVar2;\n    if (bVar3) {\n      iVar2 = 1;\n    }\n    if (bVar3) {\n      *(int *)(param_1 + 0x18) = iVar2;\n    }\n    uVar1 = __sfp();\n    *(undefined4 *)(param_1 + 4) = uVar1;\n    uVar1 = __sfp(param_1);\n    *(undefined4 *)(param_1 + 8) = uVar1;\n    uVar1 = __sfp(param_1);\n    *(undefined4 *)(param_1 + 0xc) = uVar1;\n    std_isra_0(*(undefined4 *)(param_1 + 4),4,0);\n    std_isra_0(*(undefined4 *)(param_1 + 8),9,1);\n    std_isra_0(*(undefined4 *)(param_1 + 0xc),0x12,2);\n    *(undefined4 *)(param_1 + 0x18) = 1;\n  }\n  return;\n}\n\n", 
            "called": [
                "__sfp", 
                "std.isra.0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009d50", 
            "calling": [
                "__swsetup_r", 
                "_fflush_r", 
                "iprintf", 
                "__swbuf_r", 
                "__sfp", 
                "_vfiprintf_r"
            ], 
            "imported": false, 
            "current_name": "__sinit"
        }, 
        "HAL_NVIC_SetPriority": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_SetPriority(IRQn_Type_conflict IRQn,uint32_t PreemptPriority,uint32_t SubPriority)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  uVar1 = (uint)IRQn;\n  uVar2 = (uint)(*(int *)(DAT_08003f8c + 0xc) << 0x15) >> 0x1d;\n  uVar3 = 7 - uVar2;\n  if (3 < uVar3) {\n    uVar3 = 4;\n  }\n  if (uVar2 + 4 < 7) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = uVar2 - 3;\n  }\n  uVar2 = (PreemptPriority & (1 << (uVar3 & 0xff)) - 1U) << (uVar2 & 0xff) |\n          (1 << (uVar2 & 0xff)) - 1U & SubPriority;\n  if ((int)uVar1 < 0) {\n    *(char *)(DAT_08003f90 + (uVar1 & 0xf)) = (char)(uVar2 << 4);\n  }\n  else {\n    *(char *)(uVar1 + 0xe000e400) = (char)(uVar2 << 4);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003f30", 
            "calling": [
                "uart_attach_tx_callback", 
                "HAL_InitTick", 
                "i2c_custom_init", 
                "uart_attach_rx_callback", 
                "TimerPulseInit", 
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_SetPriority"
        }, 
        "Servo": {
            "renaming": {}, 
            "code": "\nServo * __thiscall Servo::Servo(Servo *this)\n\n{\n  byte bVar1;\n  \n  bVar1 = *PTR_ServoCount_080025a4;\n  if (0xb < bVar1) {\n    this->servoIndex = 0xff;\n    return this;\n  }\n  *PTR_ServoCount_080025a4 = bVar1 + 1;\n  this->servoIndex = bVar1;\n  *(undefined4 *)(PTR_servos_080025a8 + (uint)bVar1 * 8 + 4) = 0x5dc;\n  return this;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002580", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "Servo"
        }, 
        "UART_DMAAbortOnError": {
            "renaming": {}, 
            "code": "\nvoid UART_DMAAbortOnError(DMA_HandleTypeDef_conflict *hdma)\n\n{\n  UART_HandleTypeDef *huart;\n  \n  huart = (UART_HandleTypeDef *)hdma->Parent;\n  huart->RxXferCount = 0;\n  huart->TxXferCount = 0;\n  HAL_UART_ErrorCallback(huart);\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_ErrorCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006b0c", 
            "calling": [], 
            "imported": false, 
            "current_name": "UART_DMAAbortOnError"
        }, 
        "_write": {
            "renaming": {}, 
            "code": "\nint _write(int file_UNUSED,char *ptr,int len)\n\n{\n  size_t sVar1;\n  \n  sVar1 = uart_debug_write((uint8_t *)ptr,len);\n  return sVar1;\n}\n\n", 
            "called": [
                "uart_debug_write"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800885c", 
            "calling": [
                "_write_r"
            ], 
            "imported": false, 
            "current_name": "_write"
        }, 
        "I2C_SlaveTransmit_BTF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_SlaveTransmit_BTF(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  byte *pbVar1;\n  \n  if (hi2c->XferCount != 0) {\n    pbVar1 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = pbVar1 + 1;\n    hi2c->Instance->DR = (uint)*pbVar1;\n    hi2c->XferCount = hi2c->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800457c", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_SlaveTransmit_BTF"
        }, 
        "onReceiveService": {
            "renaming": {}, 
            "code": "\nvoid TwoWire::onReceiveService(uint8_t *inBytes,int numBytes)\n\n{\n  if ((*(int *)PTR_user_onReceive_08002b54 != 0) &&\n     ((byte)*PTR_rxBufferLength_08002b5c <= (byte)*PTR_rxBufferIndex_08002b58)) {\n    allocateRxBuffer(numBytes);\n    if (*(int *)PTR_rxBuffer_08002b60 == 0) {\n      _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08002b64,0x183);\n    }\n    memcpy(*(void **)PTR_rxBuffer_08002b60,inBytes,numBytes);\n    *PTR_rxBufferIndex_08002b58 = 0;\n    *PTR_rxBufferLength_08002b5c = (char)numBytes;\n    (**(code **)PTR_user_onReceive_08002b54)(numBytes);\n  }\n  return;\n}\n\n", 
            "called": [
                "_Error_Handler", 
                "allocateRxBuffer", 
                "memcpy"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002b00", 
            "calling": [], 
            "imported": false, 
            "current_name": "onReceiveService"
        }, 
        "HAL_I2C_MspInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_MspInit(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080045bc", 
            "calling": [
                "HAL_I2C_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_MspInit"
        }, 
        "digital_io_write": {
            "renaming": {}, 
            "code": "\nvoid digital_io_write(GPIO_TypeDef *port,uint32_t pin,uint32_t val)\n\n{\n  if (val == 0) {\n    HAL_GPIO_WritePin(port,(uint16_t)pin,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(port,(uint16_t)pin,GPIO_PIN_SET);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_WritePin"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080072d8", 
            "calling": [
                "digitalWrite"
            ], 
            "imported": false, 
            "current_name": "digital_io_write"
        }, 
        "HAL_I2C_ListenCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  i2c_t_conflict *piVar1;\n  uint uVar2;\n  \n  piVar1 = get_i2c_obj(hi2c);\n  if (((piVar1->i2c_onSlaveReceive != (_func_void_uint8_t_ptr_int *)0x0) &&\n      (piVar1->slaveMode == '\\x01')) &&\n     (uVar2 = 0x20 - *(byte *)&(piVar1->handle).XferSize & 0xff, uVar2 != 0)) {\n    (*piVar1->i2c_onSlaveReceive)(piVar1->i2cTxRxBuffer,uVar2);\n  }\n  HAL_I2C_EnableListen_IT(hi2c);\n  return;\n}\n\n", 
            "called": [
                "get_i2c_obj", 
                "HAL_I2C_EnableListen_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007ff0", 
            "calling": [
                "I2C_Slave_AF", 
                "I2C_Slave_STOPF", 
                "I2C_ITError"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_ListenCpltCallback"
        }, 
        "EXTI1_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI1_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(2);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800902e", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI1_IRQHandler"
        }, 
        "ADC_ConversionStop_Disable": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict ADC_ConversionStop_Disable(ADC_HandleTypeDef *hadc)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  ADC_TypeDef *pAVar3;\n  \n  pAVar3 = hadc->Instance;\n  if ((pAVar3->CR2 & 1) == 0) {\n    return HAL_OK;\n  }\n  pAVar3->CR2 = pAVar3->CR2 & 0xfffffffe;\n  uVar1 = HAL_GetTick();\n  do {\n    if ((hadc->Instance->CR2 & 1) == 0) {\n      return HAL_OK;\n    }\n    uVar2 = HAL_GetTick();\n  } while (uVar2 - uVar1 < 3);\n  hadc->State = hadc->State | 0x10;\n  hadc->ErrorCode = hadc->ErrorCode | 1;\n  return HAL_ERROR;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003b8c", 
            "calling": [
                "HAL_ADC_DeInit", 
                "HAL_ADC_Stop", 
                "HAL_ADC_Init", 
                "HAL_ADCEx_Calibration_Start"
            ], 
            "imported": false, 
            "current_name": "ADC_ConversionStop_Disable"
        }, 
        "_GLOBAL__sub_I_Serial2": {
            "renaming": {}, 
            "code": "\nvoid _GLOBAL__sub_I_Serial2(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n", 
            "called": [
                "__static_initialization_and_destruction_0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008db0", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I_Serial2"
        }, 
        "HAL_TIM_PWM_Init": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_TIM_PWM_Init(TIM_HandleTypeDef_conflict *htim)\n\n{\n  if (htim != (TIM_HandleTypeDef_conflict *)0x0) {\n    if (htim->State == HAL_TIM_STATE_RESET) {\n      htim->Lock = HAL_UNLOCKED;\n      HAL_TIM_PWM_MspInit(htim);\n    }\n    htim->State = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(htim->Instance,&htim->Init);\n    htim->State = HAL_TIM_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n", 
            "called": [
                "HAL_TIM_PWM_MspInit", 
                "TIM_Base_SetConfig"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006092", 
            "calling": [
                "pwm_start"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_Init"
        }, 
        "__sfputc_r": {
            "renaming": {}, 
            "code": "\nuint __sfputc_r(undefined4 param_1,byte param_2,byte **param_3)\n\n{\n  uint uVar1;\n  byte *pbVar2;\n  \n  pbVar2 = param_3[2] + -1;\n  param_3[2] = pbVar2;\n  if (((int)pbVar2 < 0) && (((int)pbVar2 < (int)param_3[6] || (param_2 == 10)))) {\n    uVar1 = __swbuf_r();\n    return uVar1;\n  }\n  pbVar2 = *param_3;\n  *param_3 = pbVar2 + 1;\n  *pbVar2 = param_2;\n  return (uint)param_2;\n}\n\n", 
            "called": [
                "__swbuf_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800932c", 
            "calling": [
                "__sfputs_r"
            ], 
            "imported": false, 
            "current_name": "__sfputc_r"
        }, 
        "staticAnalogCallback": {
            "renaming": {}, 
            "code": "\nvoid firmata::FirmataClass::staticAnalogCallback(void *param_1,uint8_t command,uint16_t value)\n\n{\n  if (*(code **)PTR_currentAnalogCallback_08002c3c != (code *)0x0) {\n    (**(code **)PTR_currentAnalogCallback_08002c3c)(command,value);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002c2c", 
            "calling": [], 
            "imported": false, 
            "current_name": "staticAnalogCallback"
        }, 
        "USB_HP_CAN1_TX_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid USB_HP_CAN1_TX_IRQHandler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080036a0", 
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "USB_HP_CAN1_TX_IRQHandler"
        }, 
        "HAL_TIMEx_PWMN_Start": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef_conflict *htim,uint32_t Channel)\n\n{\n  TIM_CCxNChannelCmd(htim->Instance,Channel,4);\n  htim->Instance->BDTR = htim->Instance->BDTR | 0x8000;\n  htim->Instance->CR1 = htim->Instance->CR1 | 1;\n  return HAL_OK;\n}\n\n", 
            "called": [
                "TIM_CCxNChannelCmd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800643c", 
            "calling": [
                "pwm_start"
            ], 
            "imported": false, 
            "current_name": "HAL_TIMEx_PWMN_Start"
        }, 
        "attach": {
            "renaming": {}, 
            "code": "\nvoid __thiscall\nfirmata::FirmataParser::attach\n          (FirmataParser *this,uint8_t command,sysexCallbackFunction newFunction,void *context)\n\n{\n  this->currentSysexCallback = newFunction;\n  this->currentSysexCallbackContext = context;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003370", 
            "calling": [
                "FirmataClass"
            ], 
            "imported": false, 
            "current_name": "attach"
        }, 
        "free": {
            "renaming": {}, 
            "code": "\nvoid free(void *__ptr)\n\n{\n  _free_r(*(undefined4 *)PTR__impure_ptr_080091ac,__ptr);\n  return;\n}\n\n", 
            "called": [
                "_free_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080091a0", 
            "calling": [
                "setFirmwareNameAndVersion"
            ], 
            "imported": false, 
            "current_name": "free"
        }, 
        "requestFrom": {
            "renaming": {}, 
            "code": "\nuint8_t __thiscall TwoWire::requestFrom(TwoWire *this,uint8_t address,uint8_t quantity)\n\n{\n  uint8_t uVar1;\n  \n  uVar1 = requestFrom(this,address,quantity,'\\x01');\n  return uVar1;\n}\n\n", 
            "called": [
                "requestFrom"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002c14", 
            "calling": [
                "readAndReportData"
            ], 
            "imported": false, 
            "current_name": "requestFrom"
        }, 
        "HAL_IncTick": {
            "renaming": {}, 
            "code": "\nvoid HAL_IncTick(void)\n\n{\n  *(uint *)PTR_uwTick_08003758 = (uint)(byte)*PTR_uwTickFreq_0800375c + *(int *)PTR_uwTick_08003758;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003748", 
            "calling": [
                "SysTick_Handler"
            ], 
            "imported": false, 
            "current_name": "HAL_IncTick"
        }, 
        "fiprintf": {
            "renaming": {}, 
            "code": "\nint fiprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  uStack_8 = in_r2;\n  uStack_4 = in_r3;\n  iVar1 = _vfiprintf_r(*(undefined4 *)PTR__impure_ptr_08009144,__stream,__format,&uStack_8,__stream,\n                       &uStack_8);\n  return iVar1;\n}\n\n", 
            "called": [
                "_vfiprintf_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009124", 
            "calling": [
                "__assert_func"
            ], 
            "imported": false, 
            "current_name": "fiprintf"
        }, 
        "__sfputs_r": {
            "renaming": {}, 
            "code": "\nint __sfputs_r(undefined4 param_1,undefined4 param_2,undefined *param_3,int param_4)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  int iVar3;\n  \n  puVar2 = param_3 + param_4;\n  iVar3 = param_4;\n  do {\n    if (param_3 == puVar2) {\n      return 0;\n    }\n    iVar1 = __sfputc_r(param_1,*param_3,param_2,param_4,iVar3);\n    param_4 = iVar1 + 1;\n    param_3 = param_3 + 1;\n  } while (param_4 != 0);\n  return iVar1;\n}\n\n", 
            "called": [
                "__sfputc_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009358", 
            "calling": [
                "_vfiprintf_r"
            ], 
            "imported": false, 
            "current_name": "__sfputs_r"
        }, 
        "checkDigitalInputs": {
            "renaming": {}, 
            "code": "\nvoid checkDigitalInputs(void)\n\n{\n  byte bVar1;\n  bool bVar2;\n  uint32_t uVar3;\n  int iVar4;\n  byte bVar5;\n  \n  if (*PTR_reportPINs_08001188 != '\\0') {\n    bVar1 = *PTR_portConfigInputs_0800118c;\n    if (*PTR_digitalPin_08001190 == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(*PTR_digitalPin_08001190);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(*PTR_digitalPin_08001190);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001190[1] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[1]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[1]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(1);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001190[2] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[2]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[2]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(2);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001190[3] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[3]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[3]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(3);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001190[4] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[4]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[4]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(4);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001190[5] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[5]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[5]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(5);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001190[6] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[6]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[6]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(6);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001190[7] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[7]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[7]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(7);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\0',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001188[1] != '\\0') {\n    bVar1 = PTR_portConfigInputs_0800118c[1];\n    if (PTR_digitalPin_08001190[8] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[8]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[8]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(8);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001424[9] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[9]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[9]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(9);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001424[10] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[10]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[10]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(10);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001424[0xb] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xb]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xb]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xb);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001424[0xc] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xc]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xc]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xc);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001424[0xd] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xd]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xd]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xd);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001424[0xe] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xe]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xe]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xe);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001424[0xf] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xf]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xf]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xf);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x01',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001428[2] != '\\0') {\n    bVar1 = PTR_portConfigInputs_0800142c[2];\n    if (PTR_digitalPin_08001424[0x10] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0x10]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0x10]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x10);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_080016c4[0x11] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x11]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x11]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x11);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_080016c4[0x12] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x12]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x12]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x12);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_080016c4[0x13] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x13]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x13]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x13);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_080016c4[0x14] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x14]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x14]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x14);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_080016c4[0x15] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x15]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x15]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x15);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_080016c4[0x16] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x16]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x16]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x16);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_080016c4[0x17] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x17]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x17]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x17);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x02',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_080016c8[3] != '\\0') {\n    bVar1 = PTR_portConfigInputs_080016cc[3];\n    if (PTR_digitalPin_080016c4[0x18] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x18]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x18]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x18);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_080016c4[0x19] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x19]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x19]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x19);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001960[0x1a] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1a]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1a]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1a);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001960[0x1b] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1b]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1b]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1b);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001960[0x1c] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1c]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1c]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1c);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001960[0x1d] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1d]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1d]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1d);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001960[0x1e] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1e]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1e]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1e);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001960[0x1f] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1f]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1f]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1f);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x03',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001964[4] != '\\0') {\n    bVar1 = PTR_portConfigInputs_08001968[4];\n    if (PTR_digitalPin_08001960[0x20] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x20]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x20]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x20);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001960[0x21] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x21]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x21]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x21);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001b44[0x22] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x22]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x22]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x22);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001b44[0x23] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x23]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x23]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x23);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001b44[0x24] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x24]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x24]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x24);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001b44[0x25] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x25]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x25]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x25);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001b44[0x26] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x26]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x26]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x26);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001b44[0x27] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x27]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x27]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x27);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x04',bVar5,'\\0');\n  }\n  return;\n}\n\n", 
            "called": [
                "outputPort", 
                "pinNametoDigitalPin", 
                "digitalRead"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000ef8", 
            "calling": [
                "loop"
            ], 
            "imported": false, 
            "current_name": "checkDigitalInputs"
        }, 
        "HAL_MspInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_MspInit(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080036d4", 
            "calling": [
                "HAL_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_MspInit"
        }, 
        "HAL_I2C_AbortCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004f3a", 
            "calling": [
                "I2C_DMAAbort", 
                "I2C_ITError"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_AbortCpltCallback"
        }, 
        "HAL_ADCEx_Calibration_Start": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  ADC_TypeDef *pAVar4;\n  uint uVar5;\n  uint32_t wait_loop_index;\n  \n  if (hadc->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  hadc->Lock = HAL_LOCKED;\n  HVar1 = ADC_ConversionStop_Disable(hadc);\n  if (HVar1 == HAL_OK) {\n    hadc->State = hadc->State & 0xffffeefd | 2;\n    uVar5 = *(uint *)PTR_SystemCoreClock_08003f08;\n    uVar2 = HAL_RCCEx_GetPeriphCLKFreq(2);\n    for (wait_loop_index = uVar5 / uVar2 << 1; wait_loop_index != 0;\n        wait_loop_index = wait_loop_index - 1) {\n    }\n    ADC_Enable(hadc);\n    hadc->Instance->CR2 = hadc->Instance->CR2 | 8;\n    uVar2 = HAL_GetTick();\n    while (pAVar4 = hadc->Instance, (pAVar4->CR2 & 8) != 0) {\n      uVar3 = HAL_GetTick();\n      if (10 < uVar3 - uVar2) {\n        hadc->State = hadc->State & 0xffffffed | 0x10;\n        hadc->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    pAVar4->CR2 = pAVar4->CR2 | 4;\n    uVar2 = HAL_GetTick();\n    while ((hadc->Instance->CR2 & 4) != 0) {\n      uVar3 = HAL_GetTick();\n      if (10 < uVar3 - uVar2) {\n        hadc->State = hadc->State & 0xffffffed | 0x10;\n        hadc->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    hadc->State = hadc->State & 0xfffffffc | 1;\n  }\n  hadc->Lock = HAL_UNLOCKED;\n  return HVar1;\n}\n\n", 
            "called": [
                "HAL_RCCEx_GetPeriphCLKFreq", 
                "ADC_ConversionStop_Disable", 
                "ADC_Enable", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003e20", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADCEx_Calibration_Start"
        }, 
        "setPinState": {
            "renaming": {}, 
            "code": "\nvoid __thiscall firmata::FirmataClass::setPinState(FirmataClass *this,byte pin,int state)\n\n{\n  this->pinState[pin] = state;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002fc2", 
            "calling": [
                "analogWriteCallback", 
                "setPinModeCallback", 
                "digitalWriteCallback", 
                "setPinValueCallback"
            ], 
            "imported": false, 
            "current_name": "setPinState"
        }, 
        "USART3_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid USART3_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART3_IRQn);\n  if (*(UART_HandleTypeDef **)(PTR_uart_handlers_08008800 + 8) != (UART_HandleTypeDef *)0x0) {\n    HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08008800 + 8));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_NVIC_ClearPendingIRQ", 
                "HAL_UART_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080087ec", 
            "calling": [], 
            "imported": false, 
            "current_name": "USART3_IRQHandler"
        }, 
        "__swsetup_r": {
            "renaming": {}, 
            "code": "\nuint __swsetup_r(undefined4 *param_1,undefined4 *param_2)\n\n{\n  uint uVar1;\n  ushort uVar2;\n  int iVar3;\n  \n  iVar3 = *(int *)PTR__impure_ptr_08009b4c;\n  if ((iVar3 != 0) && (*(int *)(iVar3 + 0x18) == 0)) {\n    __sinit(iVar3);\n  }\n  if (param_2 == (undefined4 *)PTR___sf_fake_stdin_08009b50) {\n    param_2 = *(undefined4 **)(iVar3 + 4);\n  }\n  else if (param_2 == (undefined4 *)PTR___sf_fake_stdout_08009b54) {\n    param_2 = *(undefined4 **)(iVar3 + 8);\n  }\n  else if (param_2 == (undefined4 *)PTR___sf_fake_stderr_08009b58) {\n    param_2 = *(undefined4 **)(iVar3 + 0xc);\n  }\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar1 = (uint)uVar2;\n  if (-1 < (int)(uVar1 << 0x1c)) {\n    if (-1 < (int)(uVar1 << 0x1b)) {\n      *param_1 = 9;\n      goto LAB_08009ab0;\n    }\n    if ((int)(uVar1 << 0x1d) < 0) {\n      if ((undefined4 *)param_2[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] != param_2 + 0x11) {\n          _free_r(param_1);\n        }\n        param_2[0xd] = 0;\n      }\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xffdb;\n      param_2[1] = 0;\n      *param_2 = param_2[4];\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] == 0) && ((*(ushort *)(param_2 + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(param_1,param_2);\n  }\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar1 = uVar2 & 1;\n  if ((uVar2 & 1) == 0) {\n    if (-1 < (int)((uint)uVar2 << 0x1e)) {\n      uVar1 = param_2[5];\n    }\n    param_2[2] = uVar1;\n  }\n  else {\n    param_2[2] = 0;\n    param_2[6] = -param_2[5];\n  }\n  if (param_2[4] == 0) {\n    uVar2 = *(ushort *)(param_2 + 3);\n    uVar1 = (int)(short)uVar2 & 0x80;\n    if (uVar1 != 0) {\nLAB_08009ab0:\n      *(ushort *)(param_2 + 3) = uVar2 | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n", 
            "called": [
                "__smakebuf_r", 
                "__sinit", 
                "_free_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009a80", 
            "calling": [
                "__swbuf_r", 
                "_vfiprintf_r"
            ], 
            "imported": false, 
            "current_name": "__swsetup_r"
        }, 
        "HAL_RCCEx_PeriphCLKConfig": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef_conflict *PeriphClkInit)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint uVar5;\n  bool bVar6;\n  uint32_t tmpreg;\n  \n  if ((PeriphClkInit->PeriphClockSelection & 1) != 0) {\n    bVar6 = (*(uint *)(DAT_08005bac + 0x1c) & 0x10000000) == 0;\n    if (bVar6) {\n      *(uint *)(DAT_08005bac + 0x1c) = *(uint *)(DAT_08005bac + 0x1c) | 0x10000000;\n    }\n    if ((*DAT_08005bb0 & 0x100) == 0) {\n      *DAT_08005bb0 = *DAT_08005bb0 | 0x100;\n      uVar3 = HAL_GetTick();\n      while ((*DAT_08005bb0 & 0x100) == 0) {\n        uVar4 = HAL_GetTick();\n        if (100 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    puVar2 = DAT_08005bb4;\n    iVar1 = DAT_08005bac;\n    uVar5 = *(uint *)(DAT_08005bac + 0x20) & 0x300;\n    if ((uVar5 != 0) && (uVar5 != (PeriphClkInit->RTCClockSelection & 0x300))) {\n      uVar5 = *(uint *)(DAT_08005bac + 0x20);\n      *DAT_08005bb4 = 1;\n      *puVar2 = 0;\n      *(uint *)(iVar1 + 0x20) = uVar5 & 0xfffffcff;\n      if ((uVar5 & 1) != 0) {\n        uVar3 = HAL_GetTick();\n        while ((*(uint *)(DAT_08005bac + 0x20) & 2) == 0) {\n          uVar4 = HAL_GetTick();\n          if (5000 < uVar4 - uVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    iVar1 = DAT_08005bac;\n    *(uint *)(DAT_08005bac + 0x20) =\n         *(uint *)(DAT_08005bac + 0x20) & 0xfffffcff | PeriphClkInit->RTCClockSelection;\n    if (bVar6) {\n      *(uint *)(iVar1 + 0x1c) = *(uint *)(iVar1 + 0x1c) & 0xefffffff;\n    }\n  }\n  if ((PeriphClkInit->PeriphClockSelection & 2) != 0) {\n    *(uint *)(DAT_08005bac + 4) =\n         *(uint *)(DAT_08005bac + 4) & 0xffff3fff | PeriphClkInit->AdcClockSelection;\n  }\n  if ((PeriphClkInit->PeriphClockSelection & 0x10) != 0) {\n    *(uint *)(DAT_08005bac + 4) =\n         *(uint *)(DAT_08005bac + 4) & 0xffbfffff | PeriphClkInit->UsbClockSelection;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005aa4", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_RCCEx_PeriphCLKConfig"
        }, 
        "HAL_ADC_GetState": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_ADC_GetState(ADC_HandleTypeDef *hadc)\n\n{\n  return hadc->State;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003a1c", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_GetState"
        }, 
        "available": {
            "renaming": {}, 
            "code": "\nint __thiscall HardwareSerial::available(HardwareSerial *this)\n\n{\n  return ((this->_serial).rx_head + 0x40) - (uint)(this->_serial).rx_tail & 0x3f;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008afa", 
            "calling": [
                "serialEventRun"
            ], 
            "imported": false, 
            "current_name": "available"
        }, 
        "staticPinValueCallback": {
            "renaming": {}, 
            "code": "\nvoid firmata::FirmataClass::staticPinValueCallback(void *param_1,uint8_t command,uint16_t value)\n\n{\n  if (*(code **)PTR_currentPinValueCallback_08002c78 != (code *)0x0) {\n    (**(code **)PTR_currentPinValueCallback_08002c78)(command,value);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002c68", 
            "calling": [], 
            "imported": false, 
            "current_name": "staticPinValueCallback"
        }, 
        "EXTI15_10_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI15_10_IRQHandler(void)\n\n{\n  uint uVar1;\n  \n  for (uVar1 = 0x400; uVar1 < 0x8001; uVar1 = uVar1 << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)uVar1);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800906c", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI15_10_IRQHandler"
        }, 
        "onRequestService": {
            "renaming": {}, 
            "code": "\nvoid TwoWire::onRequestService(void)\n\n{\n  code *pcVar1;\n  \n  pcVar1 = *(code **)PTR_user_onRequest_0800278c;\n  if (pcVar1 != (code *)0x0) {\n    *PTR_txBufferIndex_08002790 = 0;\n    *PTR_txBufferLength_08002794 = 0;\n    (*pcVar1)();\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002774", 
            "calling": [], 
            "imported": false, 
            "current_name": "onRequestService"
        }, 
        "HAL_UART_ErrorCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)\n\n{\n  uint32_t tmpval;\n  \n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800877c", 
            "calling": [
                "UART_DMAAbortOnError", 
                "HAL_UART_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_ErrorCallback"
        }, 
        "loop": {
            "renaming": {}, 
            "code": "\nvoid loop(void)\n\n{\n  bool bVar1;\n  PinName_conflict PVar2;\n  byte bVar3;\n  int iVar4;\n  uint32_t uVar5;\n  uint uVar6;\n  uint ulPin;\n  \n  checkDigitalInputs();\n  while (iVar4 = firmata::FirmataClass::available((FirmataClass *)PTR_Firmata_080023e0), iVar4 != 0)\n  {\n    firmata::FirmataClass::processInput((FirmataClass *)PTR_Firmata_080023e0);\n  }\n  uVar5 = millis();\n  *(uint32_t *)PTR_currentMillis_080023e4 = uVar5;\n  if (*(uint *)PTR_samplingInterval_080023ec < uVar5 - *(int *)PTR_previousMillis_080023e8) {\n    *(uint *)PTR_previousMillis_080023e8 =\n         *(int *)PTR_previousMillis_080023e8 + *(uint *)PTR_samplingInterval_080023ec;\n    for (uVar6 = 0; uVar6 < 0x3c; uVar6 = uVar6 + 1 & 0xff) {\n      ulPin = uVar6 - 0x2e & 0xff;\n      if (ulPin < 0xe) {\n        if (uVar6 < 0x3c) {\n          PVar2 = PTR_digitalPin_080023f4[uVar6];\n        }\n        else {\n          PVar2 = NC;\n        }\n        uVar5 = pinNametoDigitalPin(PVar2);\n        if (uVar5 == 0) {\n          bVar1 = false;\n        }\n        else {\n          if (uVar6 < 0x3c) {\n            PVar2 = PTR_digitalPin_080023f4[uVar6];\n          }\n          else {\n            PVar2 = NC;\n          }\n          uVar5 = pinNametoDigitalPin(PVar2);\n          if (uVar5 == 1) {\n            bVar1 = false;\n          }\n          else {\n            bVar3 = firmata::FirmataClass::getPinMode\n                              ((FirmataClass *)PTR_Firmata_080023e0,(byte)uVar6);\n            if (bVar3 == '\\x02') {\n              bVar1 = true;\n            }\n            else {\n              bVar1 = false;\n            }\n          }\n        }\n      }\n      else {\n        bVar1 = false;\n      }\n      if ((bVar1) && ((*(int *)PTR_analogInputsToReport_080023f0 >> ulPin & 1U) != 0)) {\n        uVar5 = analogRead(ulPin);\n        firmata::FirmataClass::sendAnalog((FirmataClass *)PTR_Firmata_080023e0,(byte)ulPin,uVar5);\n      }\n    }\n    if (-1 < (char)*PTR_queryIndex_080023f8) {\n      for (uVar6 = 0; (int)uVar6 < (char)*PTR_queryIndex_080023f8 + 1; uVar6 = uVar6 + 1 & 0xff) {\n        iVar4 = uVar6 * 0xc;\n        readAndReportData(PTR_query_080023fc[iVar4],*(int *)(PTR_query_080023fc + iVar4 + 4),\n                          PTR_query_080023fc[iVar4 + 8],PTR_query_080023fc[iVar4 + 9]);\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "millis", 
                "readAndReportData", 
                "sendAnalog", 
                "getPinMode", 
                "processInput", 
                "available", 
                "checkDigitalInputs", 
                "pinNametoDigitalPin", 
                "analogRead"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080022f8", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "loop"
        }, 
        "_close_r": {
            "renaming": {}, 
            "code": "\nvoid _close_r(int *param_1,int param_2)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_0800a0e8;\n  *(undefined4 *)PTR_errno_0800a0e8 = 0;\n  iVar2 = _close(param_2);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_close"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a0cc", 
            "calling": [
                "__sclose"
            ], 
            "imported": false, 
            "current_name": "_close_r"
        }, 
        "_GLOBAL__sub_I_Firmata": {
            "renaming": {}, 
            "code": "\nvoid _GLOBAL__sub_I_Firmata(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n", 
            "called": [
                "__static_initialization_and_destruction_0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800306c", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I_Firmata"
        }, 
        "__libc_init_array": {
            "renaming": {}, 
            "code": "\nvoid __libc_init_array(void)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  int iVar3;\n  \n  puVar1 = PTR___preinit_array_end_08009180;\n  iVar2 = (int)PTR___preinit_array_end_08009184 - (int)PTR___preinit_array_end_08009180;\n  for (iVar3 = 0; iVar3 != iVar2 >> 2; iVar3 = iVar3 + 1) {\n    (**(code **)(puVar1 + iVar3 * 4))();\n  }\n  _init();\n  puVar1 = PTR___preinit_array_end_08009188;\n  iVar2 = (int)PTR___do_global_dtors_aux_fini_array_entry_0800918c -\n          (int)PTR___preinit_array_end_08009188;\n  for (iVar3 = 0; iVar3 != iVar2 >> 2; iVar3 = iVar3 + 1) {\n    (**(code **)(puVar1 + iVar3 * 4))();\n  }\n  return;\n}\n\n", 
            "called": [
                "premain", 
                "_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009148", 
            "calling": [
                "Reset_Handler"
            ], 
            "imported": false, 
            "current_name": "__libc_init_array"
        }, 
        "HAL_UART_TxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)\n\n{\n  byte bVar1;\n  int iVar3;\n  int iVar4;\n  uint uVar2;\n  \n  bVar1 = uart_index(huart);\n  uVar2 = (uint)bVar1;\n  iVar4 = *(int *)(PTR_tx_callback_obj_08008770 + uVar2 * 4);\n  if ((uVar2 < 5) &&\n     (iVar3 = (**(code **)(PTR_tx_callback_08008774 + uVar2 * 4))(iVar4), iVar3 != -1)) {\n    HAL_UART_Transmit_IT\n              (*(UART_HandleTypeDef **)\n                (PTR_uart_handlers_08008778 + (uint)*(byte *)(iVar4 + 0x44) * 4),\n               (uint8_t *)(*(int *)(iVar4 + 100) + (uint)*(ushort *)(iVar4 + 0x6a)),1);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_Transmit_IT", 
                "uart_index"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008730", 
            "calling": [
                "UART_EndTransmit_IT"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_TxCpltCallback"
        }, 
        "_getpid_r": {
            "renaming": {}, 
            "code": "\n__pid_t _getpid_r(void)\n\n{\n  return 1;\n}\n\n", 
            "called": [
                "_getpid"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a01c", 
            "calling": [
                "_raise_r"
            ], 
            "imported": false, 
            "current_name": "_getpid_r"
        }, 
        "__sclose": {
            "renaming": {}, 
            "code": "\nvoid __sclose(undefined4 param_1,int param_2)\n\n{\n  _close_r(param_1,(int)*(short *)(param_2 + 0xe));\n  return;\n}\n\n", 
            "called": [
                "_close_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a09e", 
            "calling": [], 
            "imported": false, 
            "current_name": "__sclose"
        }, 
        "__static_initialization_and_destruction_0": {
            "renaming": {}, 
            "code": "\nvoid __static_initialization_and_destruction_0(int __initialize_p,int __priority)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = PTR_gpio_irq_conf_08009018;\n  if (__initialize_p != 1) {\n    return;\n  }\n  if (__priority == 0xffff) {\n    *PTR_gpio_irq_conf_08009018 = 6;\n    *(undefined4 *)(puVar1 + 0xc) = 0;\n    puVar1[0x14] = 7;\n    *(undefined4 *)(puVar1 + 0x20) = 0;\n    puVar1[0x28] = 8;\n    *(undefined4 *)(puVar1 + 0x34) = 0;\n    puVar1[0x3c] = 9;\n    *(undefined4 *)(puVar1 + 0x48) = 0;\n    puVar1[0x50] = 10;\n    *(undefined4 *)(puVar1 + 0x5c) = 0;\n    puVar1[100] = 0x17;\n    *(undefined4 *)(puVar1 + 0x70) = 0;\n    puVar1[0x78] = 0x17;\n    *(undefined4 *)(puVar1 + 0x84) = 0;\n    puVar1[0x8c] = 0x17;\n    *(undefined4 *)(puVar1 + 0x98) = 0;\n    puVar1[0xa0] = 0x17;\n    *(undefined4 *)(puVar1 + 0xac) = 0;\n    puVar1[0xb4] = 0x17;\n    *(undefined4 *)(puVar1 + 0xc0) = 0;\n    puVar1[200] = 0x28;\n    *(undefined4 *)(puVar1 + 0xd4) = 0;\n    puVar1[0xdc] = 0x28;\n    *(undefined4 *)(puVar1 + 0xe8) = 0;\n    puVar1[0xf0] = 0x28;\n    *(undefined4 *)(puVar1 + 0xfc) = 0;\n    puVar1[0x104] = 0x28;\n    *(undefined4 *)(puVar1 + 0x110) = 0;\n    puVar1[0x118] = 0x28;\n    *(undefined4 *)(puVar1 + 0x124) = 0;\n    puVar1[300] = 0x28;\n    *(undefined4 *)(puVar1 + 0x138) = 0;\n    __aeabi_atexit(0,DAT_08009020,PTR___dso_handle_0800901c);\n  }\n  return;\n}\n\n", 
            "called": [
                "__aeabi_atexit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008f78", 
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ], 
            "imported": false, 
            "current_name": "__static_initialization_and_destruction_0"
        }, 
        "HAL_GetTick": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_GetTick(void)\n\n{\n  return *(uint32_t *)PTR_uwTick_08003768;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003760", 
            "calling": [
                "ADC_ConversionStop_Disable", 
                "HAL_RCC_OscConfig", 
                "ADC_Enable", 
                "HAL_RCCEx_PeriphCLKConfig", 
                "HAL_RCC_ClockConfig", 
                "HAL_ADCEx_Calibration_Start", 
                "i2c_master_write", 
                "UART_WaitOnFlagUntilTimeout", 
                "HAL_UART_Transmit", 
                "i2c_master_read", 
                "GetCurrentMilli", 
                "uart_debug_write", 
                "HAL_ADC_PollForConversion"
            ], 
            "imported": false, 
            "current_name": "HAL_GetTick"
        }, 
        "EXTI9_5_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI9_5_IRQHandler(void)\n\n{\n  uint uVar1;\n  \n  for (uVar1 = 0x20; uVar1 < 0x201; uVar1 = uVar1 << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)uVar1);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009056", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI9_5_IRQHandler"
        }, 
        "TIM_CCxChannelCmd": {
            "renaming": {}, 
            "code": "\nvoid TIM_CCxChannelCmd(TIM_TypeDef_conflict *TIMx,uint32_t Channel,uint32_t ChannelState)\n\n{\n  TIMx->CCER = TIMx->CCER & ~(1 << (Channel & 0xff));\n  TIMx->CCER = TIMx->CCER | ChannelState << (Channel & 0xff);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006262", 
            "calling": [
                "HAL_TIM_OC_Start_IT", 
                "HAL_TIM_PWM_Stop", 
                "HAL_TIM_PWM_Start", 
                "HAL_TIM_OC_Stop_IT"
            ], 
            "imported": false, 
            "current_name": "TIM_CCxChannelCmd"
        }, 
        "I2C1_EV_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid I2C1_EV_IRQHandler(void)\n\n{\n  HAL_I2C_EV_IRQHandler(*(I2C_HandleTypeDef_conflict **)PTR_i2c_handles_08008044);\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008038", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C1_EV_IRQHandler"
        }, 
        "get_timer_obj": {
            "renaming": {}, 
            "code": "\nstimer_t_conflict * get_timer_obj(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return (stimer_t_conflict *)&htim[-1].Lock;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007718", 
            "calling": [
                "HAL_TIM_PeriodElapsedCallback", 
                "HAL_TIM_OC_DelayElapsedCallback"
            ], 
            "imported": false, 
            "current_name": "get_timer_obj"
        }, 
        "abort": {
            "renaming": {}, 
            "code": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n  raise(6);\n                    /* WARNING: Subroutine does not return */\n  _exit(1);\n}\n\n", 
            "called": [
                "raise", 
                "_exit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009b5c", 
            "calling": [
                "__assert_func", 
                "__throw_bad_function_call"
            ], 
            "imported": false, 
            "current_name": "abort"
        }, 
        "_isatty_r": {
            "renaming": {}, 
            "code": "\nvoid _isatty_r(int *param_1,int param_2)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_0800a12c;\n  *(undefined4 *)PTR_errno_0800a12c = 0;\n  iVar2 = _isatty(param_2);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_isatty"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a110", 
            "calling": [
                "__smakebuf_r"
            ], 
            "imported": false, 
            "current_name": "_isatty_r"
        }, 
        "__sread": {
            "renaming": {}, 
            "code": "\nvoid __sread(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  bool bVar3;\n  \n  iVar1 = _read_r(param_1,(int)*(short *)(param_2 + 0xe));\n  bVar3 = -1 < iVar1;\n  if (bVar3) {\n    uVar2 = *(int *)(param_2 + 0x54) + iVar1;\n  }\n  else {\n    uVar2 = *(ushort *)(param_2 + 0xc) & 0xffffefff;\n  }\n  if (bVar3) {\n    *(uint *)(param_2 + 0x54) = uVar2;\n  }\n  if (!bVar3) {\n    *(short *)(param_2 + 0xc) = (short)uVar2;\n  }\n  return;\n}\n\n", 
            "called": [
                "_read_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a020", 
            "calling": [], 
            "imported": false, 
            "current_name": "__sread"
        }, 
        "Reset_Handler": {
            "renaming": {}, 
            "code": "\nvoid Reset_Handler(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (iVar1 = 0; puVar2 = (undefined4 *)PTR_completed_8667_08003698,\n      PTR___dso_handle_08003690 + iVar1 < PTR_completed_8667_08003694; iVar1 = iVar1 + 4) {\n    *(undefined4 *)(PTR___dso_handle_08003690 + iVar1) =\n         *(undefined4 *)(PTR__sidata_0800368c + iVar1);\n  }\n  for (; puVar2 < PTR__ebss_0800369c; puVar2 = puVar2 + 1) {\n    *puVar2 = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  UNRECOVERED_JUMPTABLE = (code *)0x800368a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x0800368a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n", 
            "called": [
                "main", 
                "__libc_init_array", 
                "SystemInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003658", 
            "calling": [], 
            "imported": false, 
            "current_name": "Reset_Handler"
        }, 
        "HAL_ADC_ConfigChannel": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc,ADC_ChannelConfTypeDef *sConfig)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint uVar2;\n  ADC_TypeDef *pAVar3;\n  uint32_t wait_loop_index;\n  \n  if (hadc->Lock == HAL_LOCKED) {\n    HVar1 = HAL_BUSY;\n  }\n  else {\n    hadc->Lock = HAL_LOCKED;\n    uVar2 = sConfig->Rank;\n    if (uVar2 < 7) {\n      uVar2 = uVar2 * 5 - 5;\n      hadc->Instance->SQR3 =\n           sConfig->Channel << (uVar2 & 0xff) | hadc->Instance->SQR3 & ~(0x1f << (uVar2 & 0xff));\n    }\n    else if (uVar2 < 0xd) {\n      uVar2 = uVar2 * 5 - 0x23;\n      hadc->Instance->SQR2 =\n           sConfig->Channel << (uVar2 & 0xff) | hadc->Instance->SQR2 & ~(0x1f << (uVar2 & 0xff));\n    }\n    else {\n      uVar2 = uVar2 * 5 - 0x41;\n      hadc->Instance->SQR1 =\n           sConfig->Channel << (uVar2 & 0xff) | hadc->Instance->SQR1 & ~(0x1f << (uVar2 & 0xff));\n    }\n    uVar2 = sConfig->Channel;\n    if (uVar2 < 10) {\n      hadc->Instance->SMPR2 =\n           sConfig->SamplingTime << (uVar2 * 3 & 0xff) |\n           hadc->Instance->SMPR2 & ~(7 << (uVar2 * 3 & 0xff));\n    }\n    else {\n      uVar2 = uVar2 * 3 - 0x1e;\n      hadc->Instance->SMPR1 =\n           sConfig->SamplingTime << (uVar2 & 0xff) | hadc->Instance->SMPR1 & ~(7 << (uVar2 & 0xff));\n    }\n    if (sConfig->Channel - 0x10 < 2) {\n      pAVar3 = hadc->Instance;\n      if (pAVar3 == DAT_08003a10) {\n        if ((pAVar3->CR2 & 0x800000) == 0) {\n          pAVar3->CR2 = pAVar3->CR2 | 0x800000;\n          if (sConfig->Channel == 0x10) {\n            for (wait_loop_index =\n                      (uint)((ulonglong)DAT_08003a18 *\n                             (ulonglong)*(uint *)PTR_SystemCoreClock_08003a14 >> 0x32) * 10;\n                wait_loop_index != 0; wait_loop_index = wait_loop_index - 1) {\n            }\n            HVar1 = HAL_OK;\n          }\n          else {\n            HVar1 = HAL_OK;\n          }\n        }\n        else {\n          HVar1 = HAL_OK;\n        }\n      }\n      else {\n        hadc->State = hadc->State | 0x20;\n        HVar1 = HAL_ERROR;\n      }\n    }\n    else {\n      HVar1 = HAL_OK;\n    }\n    hadc->Lock = HAL_UNLOCKED;\n  }\n  return HVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080038e4", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_ConfigChannel"
        }, 
        "pinMode": {
            "renaming": {}, 
            "code": "\nvoid pinMode(uint32_t ulPin,uint32_t ulMode)\n\n{\n  _Bool _Var1;\n  PinName_conflict pin;\n  \n  if (ulPin < 0x3c) {\n    pin = PTR_digitalPin_08008a14[ulPin];\n  }\n  else {\n    pin = NC;\n  }\n  if (pin != NC) {\n    _Var1 = is_pin_configured(pin,(uint32_t *)PTR_g_anOutputPinConfigured_08008a18);\n    if (_Var1) {\n      _Var1 = pin_in_pinmap(pin,(PinMap_conflict *)PTR_PinMap_PWM_08008a1c);\n      if (_Var1) {\n        pwm_stop(pin);\n      }\n      reset_pin_configured(pin,(uint32_t *)PTR_g_anOutputPinConfigured_08008a18);\n    }\n    switch(ulMode) {\n    case 0:\n      digital_io_init(pin,0,0);\n      break;\n    case 1:\n      digital_io_init(pin,1,0);\n      break;\n    case 2:\n      digital_io_init(pin,0,1);\n      break;\n    case 3:\n      digital_io_init(pin,0,2);\n    }\n    set_pin_configured(pin,(uint32_t *)PTR_g_digPinConfigured_08008a20);\n  }\n  return;\n}\n\n", 
            "called": [
                "set_pin_configured", 
                "is_pin_configured", 
                "pin_in_pinmap", 
                "digital_io_init", 
                "pwm_stop", 
                "reset_pin_configured"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008990", 
            "calling": [
                "setPinModeCallback", 
                "blinkVersion", 
                "digitalWriteCallback", 
                "attach", 
                "analogWrite"
            ], 
            "imported": false, 
            "current_name": "pinMode"
        }, 
        "set_GPIO_Port_Clock": {
            "renaming": {}, 
            "code": "\nGPIO_TypeDef * set_GPIO_Port_Clock(uint32_t port_idx)\n\n{\n  GPIO_TypeDef *pGVar1;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  \n  switch(port_idx) {\n  case 0:\n    *(uint *)(DAT_08006c48 + 0x18) = *(uint *)(DAT_08006c48 + 0x18) | 4;\n    pGVar1 = DAT_08006c4c;\n    break;\n  case 1:\n    *(uint *)(DAT_08006c48 + 0x18) = *(uint *)(DAT_08006c48 + 0x18) | 8;\n    pGVar1 = DAT_08006c50;\n    break;\n  case 2:\n    *(uint *)(DAT_08006c48 + 0x18) = *(uint *)(DAT_08006c48 + 0x18) | 0x10;\n    pGVar1 = DAT_08006c54;\n    break;\n  case 3:\n    *(uint *)(DAT_08006c48 + 0x18) = *(uint *)(DAT_08006c48 + 0x18) | 0x20;\n    pGVar1 = DAT_08006c58;\n    break;\n  case 4:\n    *(uint *)(DAT_08006c48 + 0x18) = *(uint *)(DAT_08006c48 + 0x18) | 0x40;\n    pGVar1 = DAT_08006c5c;\n    break;\n  default:\n    pGVar1 = (GPIO_TypeDef *)0x0;\n  }\n  return pGVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006bb8", 
            "calling": [
                "HAL_TIM_PWM_MspInit", 
                "uart_init", 
                "HAL_ADC_MspInit", 
                "i2c_custom_init", 
                "digital_io_init"
            ], 
            "imported": false, 
            "current_name": "set_GPIO_Port_Clock"
        }, 
        "_write_r": {
            "renaming": {}, 
            "code": "\nvoid _write_r(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_0800a0c8;\n  *(undefined4 *)PTR_errno_0800a0c8 = 0;\n  iVar2 = _write(param_2,param_3,param_4);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_write"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a0a8", 
            "calling": [
                "__swrite"
            ], 
            "imported": false, 
            "current_name": "_write_r"
        }, 
        "HAL_I2C_MemTxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004b80", 
            "calling": [
                "I2C_MasterTransmit_TXE", 
                "I2C_MasterTransmit_BTF"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_MemTxCpltCallback"
        }, 
        "HAL_SYSTICK_CLKSourceConfig": {
            "renaming": {}, 
            "code": "\nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)\n\n{\n  if (CLKSource != 4) {\n    *DAT_08004040 = *DAT_08004040 & 0xfffffffb;\n    return;\n  }\n  *DAT_08004040 = *DAT_08004040 | 4;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004024", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_CLKSourceConfig"
        }, 
        "I2C2_EV_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid I2C2_EV_IRQHandler(void)\n\n{\n  HAL_I2C_EV_IRQHandler(*(I2C_HandleTypeDef_conflict **)(PTR_i2c_handles_08008064 + 4));\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008058", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C2_EV_IRQHandler"
        }, 
        "flush": {
            "renaming": {}, 
            "code": "\nvoid __thiscall HardwareSerial::flush(HardwareSerial *this)\n\n{\n  if (this->_written != false) {\n    do {\n    } while ((this->_serial).tx_head != (this->_serial).tx_tail);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008b52", 
            "calling": [], 
            "imported": false, 
            "current_name": "flush"
        }, 
        "TimerPulseInit": {
            "renaming": {}, 
            "code": "\nvoid TimerPulseInit(stimer_t_conflict *obj,uint16_t period,uint16_t pulseWidth,\n                   _func_void_stimer_t_ptr_uint32_t_conflict *irqHandle)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  TIM_HandleTypeDef_conflict *htim;\n  TIM_OC_InitTypeDef sConfig;\n  \n  sConfig.OCMode = 0;\n  sConfig.Pulse = 0;\n  sConfig.OCPolarity = 0;\n  sConfig.OCNPolarity = 0;\n  sConfig.OCFastMode = 0;\n  sConfig.OCIdleState = 0;\n  sConfig.OCNIdleState = 0;\n  htim = &obj->handle;\n  obj->timer = (TIM_TypeDef_conflict *)0x40000000;\n  (obj->handle).Instance = (TIM_TypeDef_conflict *)0x40000000;\n  (obj->handle).Init.Period = (uint)period;\n  uVar2 = getTimerClkFreq((TIM_TypeDef_conflict *)0x40000000);\n  (obj->handle).Init.Prescaler = (uint)((ulonglong)DAT_080076dc * (ulonglong)uVar2 >> 0x32) - 1;\n  (obj->handle).Init.ClockDivision = 0;\n  (obj->handle).Init.CounterMode = 0;\n  (obj->handle).Init.RepetitionCounter = 0;\n  obj->irqHandleOC = irqHandle;\n  sConfig.OCMode = 0;\n  sConfig.OCPolarity = 0;\n  sConfig.OCFastMode = 0;\n  sConfig.OCNPolarity = 0;\n  sConfig.OCIdleState = 0;\n  sConfig.OCNIdleState = 0;\n  sConfig.Pulse = (uint)pulseWidth;\n  uVar2 = getTimerIrq(obj->timer);\n  HAL_NVIC_SetPriority((IRQn_Type_conflict)uVar2,0xe,0);\n  uVar2 = getTimerIrq(obj->timer);\n  HAL_NVIC_EnableIRQ((IRQn_Type_conflict)uVar2);\n  HVar1 = HAL_TIM_OC_Init(htim);\n  if ((HVar1 == HAL_OK) && (HVar1 = HAL_TIM_OC_ConfigChannel(htim,&sConfig,0), HVar1 == HAL_OK)) {\n    HAL_TIM_OC_Start_IT(htim,0);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_OC_Start_IT", 
                "HAL_TIM_OC_Init", 
                "HAL_NVIC_EnableIRQ", 
                "HAL_NVIC_SetPriority", 
                "getTimerIrq", 
                "getTimerClkFreq", 
                "HAL_TIM_OC_ConfigChannel"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007648", 
            "calling": [
                "initISR"
            ], 
            "imported": false, 
            "current_name": "TimerPulseInit"
        }, 
        "HAL_RTC_AlarmAEventCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)\n\n{\n  if (*(code **)PTR_RTCUserCallback_080073d0 != (code *)0x0) {\n    (**(code **)PTR_RTCUserCallback_080073d0)(*(undefined4 *)PTR_callbackUserData_080073d4);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080073c0", 
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_RTC_AlarmAEventCallback"
        }, 
        "__cxa_atexit": {
            "renaming": {}, 
            "code": "\nlonglong __cxa_atexit(undefined4 param_1,uint param_2)\n\n{\n  if (DAT_08009120 != 0) {\n    return CONCAT44(param_1,2);\n  }\n  return (ulonglong)param_2 << 0x20;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009108", 
            "calling": [
                "__aeabi_atexit"
            ], 
            "imported": false, 
            "current_name": "__cxa_atexit"
        }, 
        "i2c_master_write": {
            "renaming": {}, 
            "code": "\ni2c_status_e_conflict\ni2c_master_write(i2c_t_conflict *obj,uint8_t dev_address,uint8_t *data,uint16_t size)\n\n{\n  HAL_I2C_StateTypeDef_conflict HVar1;\n  HAL_StatusTypeDef_conflict HVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint uVar5;\n  i2c_status_e_conflict iVar6;\n  I2C_HandleTypeDef_conflict *hi2c;\n  \n  uVar3 = HAL_GetTick();\n  uVar5 = 0;\n  iVar6 = I2C_ERROR;\n  do {\n    hi2c = &obj->handle;\n    HVar2 = HAL_I2C_Master_Transmit_IT(hi2c,(ushort)dev_address,data,size);\n    if (HVar2 == HAL_OK) {\n      iVar6 = I2C_OK;\n      while ((HVar1 = HAL_I2C_GetState(hi2c), HVar1 != HAL_I2C_STATE_READY && (iVar6 == I2C_OK))) {\n        uVar4 = HAL_GetTick();\n        uVar5 = uVar4 - uVar3;\n        if (uVar5 < 0x65) {\n          uVar4 = HAL_I2C_GetError(hi2c);\n          if (uVar4 != 0) {\n            iVar6 = I2C_ERROR;\n          }\n        }\n        else {\n          iVar6 = I2C_TIMEOUT;\n        }\n      }\n    }\n    uVar4 = HAL_I2C_GetError(hi2c);\n  } while ((uVar4 == 4) && (uVar5 < 100));\n  return iVar6;\n}\n\n", 
            "called": [
                "HAL_I2C_Master_Transmit_IT", 
                "HAL_I2C_GetError", 
                "HAL_I2C_GetState", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007e74", 
            "calling": [
                "endTransmission"
            ], 
            "imported": false, 
            "current_name": "i2c_master_write"
        }, 
        "uart_debug_init": {
            "renaming": {}, 
            "code": "\nvoid uart_debug_init(void)\n\n{\n  PinName_conflict pin;\n  undefined *obj;\n  PinName_conflict PVar1;\n  void *pvVar2;\n  \n  pin = PTR_digitalPin_080084f0[1];\n  pvVar2 = pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_UART_TX_080084f4);\n  if (pvVar2 != (void *)0x0) {\n    pvVar2 = pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_UART_TX_080084f4);\n    PVar1 = pinmap_pin(pvVar2,(PinMap_conflict *)PTR_PinMap_UART_RX_080084f8);\n    obj = PTR_serial_debug_080084fc;\n    PTR_serial_debug_080084fc[0x59] = PVar1;\n    obj[0x58] = pin;\n    *(undefined4 *)(obj + 0x48) = 0x2580;\n    *(undefined4 *)(obj + 0x54) = 0;\n    *(undefined4 *)(obj + 0x4c) = 0;\n    *(undefined4 *)(obj + 0x50) = 0;\n    uart_init((serial_t *)obj);\n  }\n  return;\n}\n\n", 
            "called": [
                "uart_init", 
                "pinmap_peripheral", 
                "pinmap_pin"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080084b0", 
            "calling": [
                "uart_debug_write"
            ], 
            "imported": false, 
            "current_name": "uart_debug_init"
        }, 
        "_fwalk_reent": {
            "renaming": {}, 
            "code": "\nuint _fwalk_reent(int param_1,code *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  uint uVar1;\n  int iVar2;\n  int *piVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  \n  uVar5 = 0;\n  for (piVar3 = (int *)(param_1 + 0x48); piVar3 != (int *)0x0; piVar3 = (int *)*piVar3) {\n    iVar4 = piVar3[2];\n    iVar6 = piVar3[1];\n    while (iVar6 = iVar6 + -1, -1 < iVar6) {\n      if ((1 < *(ushort *)(iVar4 + 0xc)) && (iVar2 = *(short *)(iVar4 + 0xe) + 1, iVar2 != 0)) {\n        uVar1 = (*param_2)(param_1,iVar4,param_3,iVar2,param_4);\n        uVar5 = uVar5 | uVar1;\n      }\n      iVar4 = iVar4 + 0x68;\n    }\n  }\n  return uVar5;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009e28", 
            "calling": [
                "_cleanup_r"
            ], 
            "imported": false, 
            "current_name": "_fwalk_reent"
        }, 
        "SystemInit": {
            "renaming": {}, 
            "code": "\nvoid SystemInit(void)\n\n{\n  uint *puVar1;\n  \n  puVar1 = DAT_0800742c;\n  *DAT_0800742c = *DAT_0800742c | 1;\n  puVar1[1] = DAT_08007430 & puVar1[1];\n  *puVar1 = *puVar1 & 0xfef6ffff;\n  *puVar1 = *puVar1 & 0xfffbffff;\n  puVar1[1] = puVar1[1] & 0xff80ffff;\n  puVar1[2] = 0x9f0000;\n  *(undefined4 *)(DAT_08007434 + 8) = 0x8000000;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080073ec", 
            "calling": [
                "Reset_Handler"
            ], 
            "imported": false, 
            "current_name": "SystemInit"
        }, 
        "uart_getc": {
            "renaming": {}, 
            "code": "\nint uart_getc(serial_t *obj,uchar *c)\n\n{\n  uint8_t uVar1;\n  \n  if (obj == (serial_t *)0x0) {\n    return -1;\n  }\n  uVar1 = serial_rx_active(obj);\n  if (uVar1 == '\\0') {\n    *c = obj->recv;\n    HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08008638 + (uint)obj->index * 4),\n                        &obj->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n", 
            "called": [
                "serial_rx_active", 
                "HAL_UART_Receive_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008600", 
            "calling": [
                "_rx_complete_irq"
            ], 
            "imported": false, 
            "current_name": "uart_getc"
        }, 
        "uart_attach_rx_callback": {
            "renaming": {}, 
            "code": "\nvoid uart_attach_rx_callback(serial_t *obj,_func_void_serial_t_ptr *callback)\n\n{\n  byte bVar1;\n  uint8_t uVar2;\n  \n  if (obj != (serial_t *)0x0) {\n    uVar2 = serial_rx_active(obj);\n    if (uVar2 == '\\0') {\n      bVar1 = obj->index;\n      *(_func_void_serial_t_ptr **)(PTR_rx_callback_08008688 + (uint)bVar1 * 4) = callback;\n      *(serial_t **)(PTR_rx_callback_obj_0800868c + (uint)bVar1 * 4) = obj;\n      HAL_NVIC_SetPriority(obj->irq,0,1);\n      HAL_NVIC_EnableIRQ(obj->irq);\n      HAL_UART_Receive_IT(*(UART_HandleTypeDef **)\n                           (PTR_uart_handlers_08008690 + (uint)obj->index * 4),&obj->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_NVIC_EnableIRQ", 
                "HAL_NVIC_SetPriority", 
                "serial_rx_active", 
                "HAL_UART_Receive_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800863c", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "uart_attach_rx_callback"
        }, 
        "isTimerActive": {
            "renaming": {}, 
            "code": "\nboolean isTimerActive(timer16_Sequence_t timer)\n\n{\n  uint uVar1;\n  \n  uVar1 = 0;\n  while( true ) {\n    if (0xb < uVar1) {\n      return false;\n    }\n    if ((PTR_servos_08002428[((uint)timer * 0xc + uVar1) * 8] & 0x40) != 0) break;\n    uVar1 = uVar1 + 1 & 0xff;\n  }\n  return true;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002400", 
            "calling": [
                "attach", 
                "detach"
            ], 
            "imported": false, 
            "current_name": "isTimerActive"
        }, 
        "HAL_I2C_AddrCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_AddrCallback\n               (I2C_HandleTypeDef_conflict *hi2c,uint8_t TransferDirection,uint16_t AddrMatchCode)\n\n{\n  i2c_t_conflict *piVar1;\n  \n  piVar1 = get_i2c_obj(hi2c);\n  if ((uint)AddrMatchCode == (hi2c->Init).OwnAddress1) {\n    if (TransferDirection == '\\0') {\n      piVar1->i2cTxRxBufferSize = '\\0';\n      piVar1->slaveMode = '\\0';\n      if (piVar1->i2c_onSlaveTransmit != (_func_void *)0x0) {\n        (*piVar1->i2c_onSlaveTransmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT\n                (hi2c,piVar1->i2cTxRxBuffer,(ushort)piVar1->i2cTxRxBufferSize,8);\n      return;\n    }\n    piVar1->slaveMode = '\\x01';\n    HAL_I2C_Slave_Sequential_Receive_IT(hi2c,piVar1->i2cTxRxBuffer,0x20,8);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_Slave_Sequential_Transmit_IT", 
                "get_i2c_obj", 
                "HAL_I2C_Slave_Sequential_Receive_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007fa0", 
            "calling": [
                "I2C_Slave_ADDR"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_AddrCallback"
        }, 
        "UART_SetConfig": {
            "renaming": {}, 
            "code": "\nvoid UART_SetConfig(UART_HandleTypeDef *huart)\n\n{\n  ulonglong uVar1;\n  uint uVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint32_t uVar5;\n  uint32_t uVar6;\n  uint32_t uVar7;\n  uint32_t uVar8;\n  uint32_t uVar9;\n  uint32_t uVar10;\n  uint32_t uVar11;\n  USART_TypeDef *pUVar12;\n  \n  huart->Instance->CR2 = huart->Instance->CR2 & 0xffffcfff | (huart->Init).StopBits;\n  huart->Instance->CR1 =\n       (huart->Init).WordLength | (huart->Init).Parity | (huart->Init).Mode |\n       huart->Instance->CR1 & 0xffffe9f3;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffcff | (huart->Init).HwFlowCtl;\n  pUVar12 = huart->Instance;\n  if (pUVar12 != DAT_080066e0) {\n    uVar3 = HAL_RCC_GetPCLK1Freq();\n    uVar2 = DAT_080066e4;\n    uVar8 = (huart->Init).BaudRate;\n    uVar1 = (ulonglong)DAT_080066e4;\n    uVar4 = HAL_RCC_GetPCLK1Freq();\n    uVar9 = (huart->Init).BaudRate;\n    uVar5 = HAL_RCC_GetPCLK1Freq();\n    uVar10 = (huart->Init).BaudRate;\n    uVar6 = HAL_RCC_GetPCLK1Freq();\n    uVar11 = (huart->Init).BaudRate;\n    uVar7 = HAL_RCC_GetPCLK1Freq();\n    pUVar12->BRR = ((uint)((int)((ulonglong)uVar2 *\n                                 (ulonglong)\n                                 (((uVar6 * 0x19) / (uVar11 << 2) +\n                                  (uint)((ulonglong)uVar2 *\n                                         ((ulonglong)(uVar7 * 0x19) /\n                                         (ulonglong)((huart->Init).BaudRate << 2)) >> 0x25) * -100)\n                                  * 0x10 + 0x32) >> 0x20) << 0x17) >> 0x1c) +\n                   ((uint)((ulonglong)uVar2 *\n                           (ulonglong)\n                           (((uVar4 * 0x19) / (uVar9 << 2) +\n                            (uint)((ulonglong)uVar2 *\n                                   ((ulonglong)(uVar5 * 0x19) / (ulonglong)(uVar10 << 2)) >> 0x25) *\n                            -100) * 0x10 + 0x32) >> 0x25) & 0xf0) +\n                   (uint)(uVar1 * ((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 << 2)) >> 0x25) *\n                   0x10;\n    return;\n  }\n  uVar3 = HAL_RCC_GetPCLK2Freq();\n  uVar2 = DAT_080066e4;\n  uVar8 = (huart->Init).BaudRate;\n  uVar1 = (ulonglong)DAT_080066e4;\n  uVar4 = HAL_RCC_GetPCLK2Freq();\n  uVar9 = (huart->Init).BaudRate;\n  uVar5 = HAL_RCC_GetPCLK2Freq();\n  uVar10 = (huart->Init).BaudRate;\n  uVar6 = HAL_RCC_GetPCLK2Freq();\n  uVar11 = (huart->Init).BaudRate;\n  uVar7 = HAL_RCC_GetPCLK2Freq();\n  pUVar12->BRR = ((uint)((int)((ulonglong)uVar2 *\n                               (ulonglong)\n                               (((uVar6 * 0x19) / (uVar11 << 2) +\n                                (uint)((ulonglong)uVar2 *\n                                       ((ulonglong)(uVar7 * 0x19) /\n                                       (ulonglong)((huart->Init).BaudRate << 2)) >> 0x25) * -100) *\n                                0x10 + 0x32) >> 0x20) << 0x17) >> 0x1c) +\n                 ((uint)((ulonglong)uVar2 *\n                         (ulonglong)\n                         (((uVar4 * 0x19) / (uVar9 << 2) +\n                          (uint)((ulonglong)uVar2 *\n                                 ((ulonglong)(uVar5 * 0x19) / (ulonglong)(uVar10 << 2)) >> 0x25) *\n                          -100) * 0x10 + 0x32) >> 0x25) & 0xf0) +\n                 (uint)(uVar1 * ((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 << 2)) >> 0x25) *\n                 0x10;\n  return;\n}\n\n", 
            "called": [
                "HAL_RCC_GetPCLK1Freq", 
                "HAL_RCC_GetPCLK2Freq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006538", 
            "calling": [
                "HAL_UART_Init"
            ], 
            "imported": false, 
            "current_name": "UART_SetConfig"
        }, 
        "is_pin_configured": {
            "renaming": {}, 
            "code": "\n_Bool is_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  return (_Bool)((byte)(map[(uint)((int)pin << 0x18) >> 0x1c] >> ((int)pin & 0xfU)) & 1);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006b28", 
            "calling": [
                "pinMode", 
                "digitalRead", 
                "digitalWrite", 
                "analogWrite"
            ], 
            "imported": false, 
            "current_name": "is_pin_configured"
        }, 
        "reset_pin_configured": {
            "renaming": {}, 
            "code": "\nvoid reset_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)((int)pin << 0x18) >> 0x1c;\n  map[uVar1] = map[uVar1] & ~(1 << ((int)pin & 0xfU));\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006b5c", 
            "calling": [
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "reset_pin_configured"
        }, 
        "_kill_r": {
            "renaming": {}, 
            "code": "\nvoid _kill_r(int *param_1,int param_2,int param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_0800a018;\n  *(undefined4 *)PTR_errno_0800a018 = 0;\n  iVar2 = _kill(param_2,param_3);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_kill"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009ff8", 
            "calling": [
                "_raise_r"
            ], 
            "imported": false, 
            "current_name": "_kill_r"
        }, 
        "pinmap_find_peripheral": {
            "renaming": {}, 
            "code": "\nvoid * pinmap_find_peripheral(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map->pin == NC) {\n      return (void *)0x0;\n    }\n    if (map->pin == pin) break;\n    map = map + 1;\n  }\n  return map->peripheral;\n}\n\n", 
            "called": [
                "pinmap_find_peripheral"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007306", 
            "calling": [
                "pinmap_peripheral", 
                "pinmap_find_peripheral"
            ], 
            "imported": false, 
            "current_name": "pinmap_find_peripheral"
        }, 
        "HAL_I2C_MasterTxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004a1e", 
            "calling": [
                "I2C_MasterTransmit_TXE", 
                "I2C_MasterTransmit_BTF"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_MasterTxCpltCallback"
        }, 
        "__malloc_unlock": {
            "renaming": {}, 
            "code": "\nvoid __malloc_unlock(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009f4a", 
            "calling": [
                "_malloc_r", 
                "_free_r"
            ], 
            "imported": false, 
            "current_name": "__malloc_unlock"
        }, 
        "adc_read_value": {
            "renaming": {}, 
            "code": "\nuint16_t adc_read_value(PinName_conflict pin)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint16_t uhADCxConvertedValue;\n  ADC_ChannelConfTypeDef AdcChannelConf;\n  ADC_HandleTypeDef AdcHandle;\n  \n  memset(&AdcHandle,0,0x30);\n  AdcChannelConf.Channel = 0;\n  AdcChannelConf.Rank = 0;\n  AdcChannelConf.SamplingTime = 0;\n  uhADCxConvertedValue = 0;\n  AdcHandle.Instance =\n       (ADC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_ADC_08006e60);\n  if (AdcHandle.Instance == (ADC_TypeDef *)0x0) {\n    uhADCxConvertedValue = 0;\n  }\n  else {\n    AdcHandle.Init.DataAlign = 0;\n    AdcHandle.Init.ScanConvMode = 0;\n    AdcHandle.Init.ContinuousConvMode = 0;\n    AdcHandle.Init.DiscontinuousConvMode = 0;\n    AdcHandle.Init.ExternalTrigConv = 0xe0000;\n    AdcHandle.State = 0;\n    AdcHandle.Init.NbrOfConversion = 1;\n    AdcHandle.Init.NbrOfDiscConversion = 0;\n    *PTR_g_current_pin_08006e64 = pin;\n    HVar1 = HAL_ADC_Init(&AdcHandle);\n    if (HVar1 == HAL_OK) {\n      AdcChannelConf.Channel = get_adc_channel(pin);\n      if (AdcChannelConf.Channel < 0x12) {\n        AdcChannelConf.Rank = 1;\n        AdcChannelConf.SamplingTime = 2;\n        HVar1 = HAL_ADC_ConfigChannel(&AdcHandle,&AdcChannelConf);\n        if (HVar1 == HAL_OK) {\n          HVar1 = HAL_ADCEx_Calibration_Start(&AdcHandle);\n          if (HVar1 == HAL_OK) {\n            HVar1 = HAL_ADC_Start(&AdcHandle);\n            if (HVar1 == HAL_OK) {\n              HVar1 = HAL_ADC_PollForConversion(&AdcHandle,10);\n              if (HVar1 == HAL_OK) {\n                uVar2 = HAL_ADC_GetState(&AdcHandle);\n                if ((uVar2 & 0x200) != 0) {\n                  uVar2 = HAL_ADC_GetValue(&AdcHandle);\n                  uhADCxConvertedValue = (uint16_t)uVar2;\n                }\n                HVar1 = HAL_ADC_Stop(&AdcHandle);\n                if (HVar1 == HAL_OK) {\n                  HVar1 = HAL_ADC_DeInit(&AdcHandle);\n                  if (HVar1 != HAL_OK) {\n                    uhADCxConvertedValue = 0;\n                  }\n                }\n                else {\n                  uhADCxConvertedValue = 0;\n                }\n              }\n              else {\n                uhADCxConvertedValue = 0;\n              }\n            }\n            else {\n              uhADCxConvertedValue = 0;\n            }\n          }\n          else {\n            uhADCxConvertedValue = 0;\n          }\n        }\n        else {\n          uhADCxConvertedValue = 0;\n        }\n      }\n      else {\n        uhADCxConvertedValue = 0;\n      }\n    }\n    else {\n      uhADCxConvertedValue = 0;\n    }\n  }\n  return uhADCxConvertedValue;\n}\n\n", 
            "called": [
                "HAL_ADC_GetValue", 
                "pinmap_peripheral", 
                "get_adc_channel", 
                "HAL_ADC_DeInit", 
                "HAL_ADC_Stop", 
                "memset", 
                "HAL_ADC_ConfigChannel", 
                "HAL_ADC_Init", 
                "HAL_ADC_PollForConversion", 
                "HAL_ADC_Start", 
                "HAL_ADC_GetState", 
                "HAL_ADCEx_Calibration_Start"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006d80", 
            "calling": [
                "analogRead"
            ], 
            "imported": false, 
            "current_name": "adc_read_value"
        }, 
        "_GLOBAL__sub_I__ZN9IPAddressC2Ev": {
            "renaming": {}, 
            "code": "\nvoid _GLOBAL__sub_I__ZN9IPAddressC2Ev(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n", 
            "called": [
                "__static_initialization_and_destruction_0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008e40", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
        }, 
        "TIM_OC2_SetConfig": {
            "renaming": {}, 
            "code": "\nvoid TIM_OC2_SetConfig(TIM_TypeDef_conflict *TIMx,TIM_OC_InitTypeDef *OC_Config)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  \n  TIMx->CCER = TIMx->CCER & 0xffffffef;\n  uVar2 = TIMx->CR2;\n  uVar3 = OC_Config->OCMode;\n  uVar1 = TIMx->CCER & 0xffffffdf | OC_Config->OCPolarity << 4;\n  if (TIMx == DAT_08006124) {\n    uVar1 = (uVar1 & 0xffffff7f | OC_Config->OCNPolarity << 4) & 0xffffffbf;\n    uVar2 = uVar2 & 0xfffff3ff | OC_Config->OCIdleState << 2 | OC_Config->OCNIdleState << 2;\n  }\n  TIMx->CR2 = uVar2;\n  TIMx->CCMR1 = TIMx->CCMR1 & 0xffff8cff | uVar3 << 8;\n  TIMx->CCR2 = OC_Config->Pulse;\n  TIMx->CCER = uVar1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080060c4", 
            "calling": [
                "HAL_TIM_PWM_ConfigChannel", 
                "HAL_TIM_OC_ConfigChannel"
            ], 
            "imported": false, 
            "current_name": "TIM_OC2_SetConfig"
        }, 
        "_read": {
            "renaming": {}, 
            "code": "\nint _read(int file_UNUSED,char *ptr_UNUSED,int len_UNUSED)\n\n{\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008858", 
            "calling": [
                "_read_r"
            ], 
            "imported": false, 
            "current_name": "_read"
        }, 
        "HAL_TIM_PWM_MspDeInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef_conflict *htim)\n\n{\n  timer_disable_clock(htim);\n  return;\n}\n\n", 
            "called": [
                "timer_disable_clock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007110", 
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_MspDeInit"
        }, 
        "digital_io_init": {
            "renaming": {}, 
            "code": "\nvoid digital_io_init(PinName_conflict pin,uint32_t mode,uint32_t pull)\n\n{\n  uint uVar1;\n  GPIO_TypeDef *GPIOx;\n  uint32_t tmpreg;\n  GPIO_InitTypeDef GPIO_InitStructure;\n  \n  uVar1 = (uint)pin;\n  GPIOx = set_GPIO_Port_Clock((uVar1 << 0x18) >> 0x1c);\n  GPIO_InitStructure.Pin = 1 << (uVar1 & 0xf) & 0xffff;\n  GPIO_InitStructure.Speed = 3;\n  *(uint *)(DAT_080072d0 + 0x18) = *(uint *)(DAT_080072d0 + 0x18) | 1;\n  if ((uVar1 - 0xd & 0xff) < 2) {\n    *(uint *)(DAT_080072d4 + 4) = *(uint *)(DAT_080072d4 + 4) & 0xf8ffffff | 0x4000000;\n  }\n  if (((uVar1 == 0xf) || (uVar1 == 0x13)) || (uVar1 == 0x14)) {\n    *(uint *)(DAT_080072d4 + 4) = *(uint *)(DAT_080072d4 + 4) & 0xf8ffffff | 0x2000000;\n  }\n  GPIO_InitStructure.Mode = mode;\n  GPIO_InitStructure.Pull = pull;\n  HAL_GPIO_Init(GPIOx,&GPIO_InitStructure);\n  return;\n}\n\n", 
            "called": [
                "set_GPIO_Port_Clock", 
                "HAL_GPIO_Init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007258", 
            "calling": [
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "digital_io_init"
        }, 
        "processInput": {
            "renaming": {}, 
            "code": "\nvoid __thiscall firmata::FirmataClass::processInput(FirmataClass *this)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(this->FirmataStream->super_Print)._vptr_Print[3])();\n  if (iVar1 != -1) {\n    FirmataParser::parse(&this->parser,(uint8_t)iVar1);\n  }\n  return;\n}\n\n", 
            "called": [
                "parse"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002ed2", 
            "calling": [
                "loop"
            ], 
            "imported": false, 
            "current_name": "processInput"
        }, 
        "_printf_common": {
            "renaming": {}, 
            "code": "\nundefined4\n_printf_common(undefined4 param_1,uint *param_2,uint *param_3,undefined4 param_4,code *param_5)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  bool bVar4;\n  \n  uVar2 = param_2[4];\n  if ((int)param_2[4] < (int)param_2[2]) {\n    uVar2 = param_2[2];\n  }\n  *param_3 = uVar2;\n  if (*(char *)((int)param_2 + 0x43) != '\\0') {\n    *param_3 = uVar2 + 1;\n  }\n  if ((int)(*param_2 << 0x1a) < 0) {\n    *param_3 = *param_3 + 2;\n  }\n  uVar2 = *param_2 & 6;\n  if (uVar2 == 0) {\n    for (; (int)uVar2 < (int)(param_2[3] - *param_3); uVar2 = uVar2 + 1) {\n      iVar1 = (*param_5)(param_1,param_4,(int)param_2 + 0x19,1);\n      if (iVar1 == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  uVar2 = (uint)*(byte *)((int)param_2 + 0x43);\n  if (uVar2 != 0) {\n    uVar2 = 1;\n  }\n  uVar3 = uVar2;\n  if ((int)(*param_2 << 0x1a) < 0) {\n    *(undefined *)((int)param_2 + uVar2 + 0x43) = 0x30;\n    uVar3 = uVar2 + 2;\n    *(undefined *)((int)param_2 + uVar2 + 0x44) = *(undefined *)((int)param_2 + 0x45);\n  }\n  iVar1 = (*param_5)(param_1,param_4,(int)param_2 + 0x43,uVar3);\n  if (iVar1 != -1) {\n    uVar2 = param_2[3];\n    bVar4 = (*param_2 & 6) != 4;\n    if (bVar4) {\n      uVar2 = 0;\n    }\n    uVar3 = 0;\n    if (!bVar4) {\n      uVar2 = uVar2 - *param_3;\n    }\n    if (!bVar4) {\n      uVar2 = uVar2 & ~((int)uVar2 >> 0x1f);\n    }\n    if ((int)param_2[4] < (int)param_2[2]) {\n      uVar2 = uVar2 + (param_2[2] - param_2[4]);\n    }\n    while( true ) {\n      if (uVar2 == uVar3) {\n        return 0;\n      }\n      iVar1 = (*param_5)(param_1,param_4,(int)param_2 + 0x1a,1);\n      if (iVar1 == -1) break;\n      uVar3 = uVar3 + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080095a8", 
            "calling": [
                "_printf_i"
            ], 
            "imported": false, 
            "current_name": "_printf_common"
        }, 
        "HardwareSerial": {
            "renaming": {}, 
            "code": "\nHardwareSerial * __thiscall HardwareSerial::HardwareSerial(HardwareSerial *this,void *peripheral)\n\n{\n  PinName_conflict PVar1;\n  EVP_PKEY_CTX *extraout_r1;\n  EVP_PKEY_CTX *ctx;\n  EVP_PKEY_CTX *extraout_r1_00;\n  \n  (this->super_Stream).super_Print.write_error = 0;\n  (this->super_Stream)._timeout = 1000;\n  (this->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)PTR_PTR_write_1_08008d7c;\n  if (this == (HardwareSerial *)PTR_Serial2_08008d80) {\n    setRx(this,0);\n    setTx(this,1);\n    ctx = extraout_r1_00;\n  }\n  else {\n    PVar1 = pinmap_pin(peripheral,(PinMap_conflict *)PTR_PinMap_UART_RX_08008d84);\n    (this->_serial).pin_rx = PVar1;\n    PVar1 = pinmap_pin(peripheral,(PinMap_conflict *)PTR_PinMap_UART_TX_08008d88);\n    (this->_serial).pin_tx = PVar1;\n    ctx = extraout_r1;\n  }\n  init(this,ctx);\n  return this;\n}\n\n", 
            "called": [
                "pinmap_pin", 
                "setRx", 
                "setTx", 
                "init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008d30", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "HardwareSerial"
        }, 
        "printFirmwareVersion": {
            "renaming": {}, 
            "code": "\nvoid __thiscall firmata::FirmataClass::printFirmwareVersion(FirmataClass *this)\n\n{\n  uint8_t *puVar1;\n  \n  if (this->firmwareVersionCount == 0) {\n    return;\n  }\n  puVar1 = this->firmwareVersionVector;\n  FirmataMarshaller::sendFirmwareVersion\n            (&this->marshaller,*puVar1,puVar1[1],this->firmwareVersionCount - 2,puVar1 + 2);\n  return;\n}\n\n", 
            "called": [
                "sendFirmwareVersion"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002df6", 
            "calling": [
                "begin", 
                "staticReportFirmwareCallback"
            ], 
            "imported": false, 
            "current_name": "printFirmwareVersion"
        }, 
        "I2C_Master_ADDR": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_Master_ADDR(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  uint32_t uVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  \n  uVar1 = hi2c->XferOptions;\n  if ((hi2c->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((hi2c->EventCount != 0 || (hi2c->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((hi2c->EventCount == 0) && ((hi2c->Init).AddressingMode == 0xc000)) {\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x100;\n      hi2c->EventCount = hi2c->EventCount + 1;\n    }\n    else {\n      if (hi2c->XferCount == 0) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n      }\n      else if (hi2c->XferCount == 1) {\n        if (uVar1 == 0xffff0000) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n          pIVar2 = hi2c->Instance;\n          if ((pIVar2->CR2 & 0x800) == 0) {\n            pIVar2->CR1 = pIVar2->CR1 | 0x200;\n          }\n          else {\n            pIVar2->CR1 = pIVar2->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((uVar1 == 4) || (uVar1 == 8)) || (hi2c->PreviousState == 0x12)) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n        }\n        else if (hi2c->XferOptions == 2) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        }\n        else {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (hi2c->XferCount == 2) {\n        if (hi2c->XferOptions == 2) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        }\n        else {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x800;\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n        }\n        pIVar2 = hi2c->Instance;\n        if ((pIVar2->CR2 & 0x800) != 0) {\n          pIVar2->CR2 = pIVar2->CR2 | 0x1000;\n        }\n      }\n      else {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        pIVar2 = hi2c->Instance;\n        if ((pIVar2->CR2 & 0x800) != 0) {\n          pIVar2->CR2 = pIVar2->CR2 | 0x1000;\n        }\n      }\n      hi2c->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080043a2", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Master_ADDR"
        }, 
        "I2C2_ER_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid I2C2_ER_IRQHandler(void)\n\n{\n  HAL_I2C_ER_IRQHandler(*(I2C_HandleTypeDef_conflict **)(PTR_i2c_handles_08008074 + 4));\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008068", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C2_ER_IRQHandler"
        }, 
        "strobeBlinkPin": {
            "renaming": {}, 
            "code": "\nvoid __thiscall\nfirmata::FirmataClass::strobeBlinkPin\n          (FirmataClass *this,byte pin,int count,int onInterval,int offInterval)\n\n{\n  uint uVar1;\n  \n  for (uVar1 = 0; (int)uVar1 < count; uVar1 = uVar1 + 1 & 0xff) {\n    delay(offInterval);\n    digitalWrite((uint)pin,1);\n    delay(onInterval);\n    digitalWrite((uint)pin,0);\n  }\n  return;\n}\n\n", 
            "called": [
                "digitalWrite", 
                "delay"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002fca", 
            "calling": [
                "blinkVersion"
            ], 
            "imported": false, 
            "current_name": "strobeBlinkPin"
        }, 
        "decodeByteStream": {
            "renaming": {}, 
            "code": "\nsize_t __thiscall\nfirmata::FirmataParser::decodeByteStream(FirmataParser *this,size_t bytec,uint8_t *bytev)\n\n{\n  byte bVar1;\n  size_t sVar2;\n  uint uVar3;\n  \n  sVar2 = 0;\n  for (uVar3 = 0; uVar3 < bytec; uVar3 = uVar3 + 2) {\n    bVar1 = bytev[uVar3];\n    bytev[sVar2] = bVar1;\n    bytev[sVar2] = bytev[uVar3 + 1] << 7 | bVar1;\n    sVar2 = sVar2 + 1;\n  }\n  return sVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080033a8", 
            "calling": [
                "processSysexMessage"
            ], 
            "imported": false, 
            "current_name": "decodeByteStream"
        }, 
        "SysTick_Handler": {
            "renaming": {}, 
            "code": "\nvoid SysTick_Handler(void)\n\n{\n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  noOsSystickHandler();\n  return;\n}\n\n", 
            "called": [
                "HAL_IncTick", 
                "HAL_SYSTICK_IRQHandler", 
                "noOsSystickHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007246", 
            "calling": [], 
            "imported": false, 
            "current_name": "SysTick_Handler"
        }, 
        "uart_attach_tx_callback": {
            "renaming": {}, 
            "code": "\nvoid uart_attach_tx_callback(serial_t *obj,_func_int_serial_t_ptr *callback)\n\n{\n  byte bVar1;\n  \n  if (obj != (serial_t *)0x0) {\n    bVar1 = obj->index;\n    *(_func_int_serial_t_ptr **)(PTR_tx_callback_080086dc + (uint)bVar1 * 4) = callback;\n    *(serial_t **)(PTR_tx_callback_obj_080086e0 + (uint)bVar1 * 4) = obj;\n    HAL_NVIC_SetPriority(obj->irq,0,2);\n    HAL_NVIC_EnableIRQ(obj->irq);\n    HAL_UART_Transmit_IT\n              (*(UART_HandleTypeDef **)(PTR_uart_handlers_080086e4 + (uint)obj->index * 4),\n               obj->tx_buff + obj->tx_tail,1);\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_Transmit_IT", 
                "HAL_NVIC_EnableIRQ", 
                "HAL_NVIC_SetPriority"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008694", 
            "calling": [
                "write"
            ], 
            "imported": false, 
            "current_name": "uart_attach_tx_callback"
        }, 
        "TIM_OC1_SetConfig": {
            "renaming": {}, 
            "code": "\nvoid TIM_OC1_SetConfig(TIM_TypeDef_conflict *TIMx,TIM_OC_InitTypeDef *OC_Config)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  TIMx->CCER = TIMx->CCER & 0xfffffffe;\n  uVar2 = TIMx->CR2;\n  uVar3 = OC_Config->OCMode;\n  uVar1 = TIMx->CCER & 0xfffffffd | OC_Config->OCPolarity;\n  if (TIMx == DAT_08005d44) {\n    uVar1 = (uVar1 & 0xfffffff7 | OC_Config->OCNPolarity) & 0xfffffffb;\n    uVar2 = uVar2 & 0xfffffcff | OC_Config->OCIdleState | OC_Config->OCNIdleState;\n  }\n  TIMx->CR2 = uVar2;\n  TIMx->CCMR1 = TIMx->CCMR1 & 0xffffff8c | uVar3;\n  TIMx->CCR1 = OC_Config->Pulse;\n  TIMx->CCER = uVar1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005cec", 
            "calling": [
                "HAL_TIM_PWM_ConfigChannel", 
                "HAL_TIM_OC_ConfigChannel"
            ], 
            "imported": false, 
            "current_name": "TIM_OC1_SetConfig"
        }, 
        "__throw_bad_function_call": {
            "renaming": {}, 
            "code": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n/* std::__throw_bad_function_call() */\n\nvoid std::__throw_bad_function_call(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
            "called": [
                "abort"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a18c", 
            "calling": [
                "operator()"
            ], 
            "imported": false, 
            "current_name": "__throw_bad_function_call"
        }, 
        "RCC_Delay": {
            "renaming": {}, 
            "code": "\nvoid RCC_Delay(uint32_t mdelay)\n\n{\n  bool bVar1;\n  uint32_t Delay;\n  \n  Delay = mdelay * (uint)((ulonglong)DAT_0800545c * (ulonglong)*(uint *)PTR_SystemCoreClock_08005458\n                         >> 0x29);\n  do {\n    bVar1 = Delay != 0;\n    Delay = Delay - 1;\n  } while (bVar1);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005434", 
            "calling": [
                "HAL_RCC_OscConfig"
            ], 
            "imported": false, 
            "current_name": "RCC_Delay"
        }, 
        "printTo": {
            "renaming": {}, 
            "code": "\nsize_t __thiscall IPAddress::printTo(IPAddress *this,Print *p)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  int iVar3;\n  int iVar4;\n  \n  iVar4 = 0;\n  for (iVar3 = 0; iVar3 < 3; iVar3 = iVar3 + 1) {\n    sVar1 = Print::print(p,(this->_address).bytes[iVar3],10);\n    sVar2 = Print::print(p,'.');\n    iVar4 = iVar4 + sVar1 + sVar2;\n  }\n  sVar1 = Print::print(p,(this->_address).bytes[3],10);\n  return sVar1 + iVar4;\n}\n\n", 
            "called": [
                "print", 
                "print"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008dbe", 
            "calling": [], 
            "imported": false, 
            "current_name": "printTo"
        }, 
        "encodeByteStream": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003102 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::encodeByteStream\n          (FirmataMarshaller *this,size_t bytec,uint8_t *bytev,size_t max_bytes)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  uVar1 = (uint)*bytev;\n  if (max_bytes == 0) {\n    max_bytes = 0xffffffff;\n  }\n  uVar4 = 0;\n  uVar2 = 0;\n  uVar3 = 0;\n  while ((uVar4 < bytec && (uVar3 < max_bytes))) {\n    (**(this->FirmataStream->super_Print)._vptr_Print)\n              (this->FirmataStream,((uint)bytev[uVar4] << (uVar2 & 0xff) | uVar1) & 0x7f);\n    uVar1 = (int)(uint)bytev[uVar4] >> (7 - uVar2 & 0xff) & 0xff;\n    uVar2 = uVar2 + 1;\n    while ((uVar3 = uVar3 + 1, 6 < uVar2 && (uVar3 < max_bytes))) {\n      (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,uVar1 & 0x7f);\n      uVar1 = uVar1 >> 7;\n      uVar2 = uVar2 - 7;\n    }\n    uVar4 = uVar4 + 1;\n  }\n  if ((uVar2 != 0) && (uVar3 < max_bytes)) {\n    (**(this->FirmataStream->super_Print)._vptr_Print)\n              (this->FirmataStream,(1 << (uVar2 & 0xff)) - 1U & uVar1);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800307a", 
            "calling": [
                "sendExtendedAnalog", 
                "sendAnalog", 
                "sendDigitalPort", 
                "sendFirmwareVersion", 
                "sendSysex"
            ], 
            "imported": false, 
            "current_name": "encodeByteStream"
        }, 
        "_close": {
            "renaming": {}, 
            "code": "\nint _close(int file_UNUSED)\n\n{\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008840", 
            "calling": [
                "_close_r"
            ], 
            "imported": false, 
            "current_name": "_close"
        }, 
        "HAL_I2C_Master_Receive_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_I2C_Master_Receive_IT\n          (I2C_HandleTypeDef_conflict *hi2c,uint16_t DevAddress,uint8_t *pData,uint16_t Size)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  uint32_t count;\n  \n  if (hi2c->State == HAL_I2C_STATE_READY) {\n    count = (uint)((ulonglong)DAT_080048c0 * (ulonglong)(*(uint *)PTR_SystemCoreClock_080048bc >> 3)\n                  >> 0x28) * 0x19;\n    do {\n      if (count == 0) {\n        hi2c->PreviousState = 0;\n        hi2c->State = HAL_I2C_STATE_READY;\n        hi2c->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      pIVar2 = hi2c->Instance;\n      count = count - 1;\n    } while ((pIVar2->SR2 & 2) != 0);\n    if (hi2c->Lock == HAL_LOCKED) {\n      HVar1 = HAL_BUSY;\n    }\n    else {\n      hi2c->Lock = HAL_LOCKED;\n      if ((pIVar2->CR1 & 1) == 0) {\n        pIVar2->CR1 = pIVar2->CR1 | 1;\n      }\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffff7ff;\n      hi2c->State = HAL_I2C_STATE_BUSY_RX;\n      hi2c->Mode = HAL_I2C_MODE_MASTER;\n      HVar1 = HAL_OK;\n      hi2c->ErrorCode = 0;\n      hi2c->pBuffPtr = pData;\n      hi2c->XferCount = Size;\n      hi2c->XferOptions = DAT_080048c4;\n      hi2c->XferSize = hi2c->XferCount;\n      hi2c->Devaddress = (uint)DevAddress;\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x100;\n      hi2c->Lock = HAL_UNLOCKED;\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 = HAL_BUSY;\n  }\n  return HVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080047f4", 
            "calling": [
                "i2c_master_read"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_Master_Receive_IT"
        }, 
        "HAL_TIM_OC_MspDeInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef_conflict *htim)\n\n{\n  timer_disable_clock(htim);\n  return;\n}\n\n", 
            "called": [
                "timer_disable_clock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007710", 
            "calling": [
                "HAL_TIM_OC_DeInit"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_OC_MspDeInit"
        }, 
        "EXTI4_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI4_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(0x10);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800904c", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI4_IRQHandler"
        }, 
        "getPinMode": {
            "renaming": {}, 
            "code": "\nbyte __thiscall firmata::FirmataClass::getPinMode(FirmataClass *this,byte pin)\n\n{\n  return this->pinConfig[pin];\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002fa0", 
            "calling": [
                "loop", 
                "analogWriteCallback", 
                "setPinModeCallback", 
                "digitalWriteCallback", 
                "setPinValueCallback", 
                "sysexCallback"
            ], 
            "imported": false, 
            "current_name": "getPinMode"
        }, 
        "serial_tx_active": {
            "renaming": {}, 
            "code": "\nuint8_t serial_tx_active(serial_t *obj)\n\n{\n  HAL_UART_StateTypeDef HVar1;\n  \n  HVar1 = HAL_UART_GetState(*(UART_HandleTypeDef **)\n                             (PTR_uart_handlers_080085fc + (uint)obj->index * 4));\n  return (HVar1 & 0x21U) == 0x21;\n}\n\n", 
            "called": [
                "HAL_UART_GetState"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080085dc", 
            "calling": [
                "write"
            ], 
            "imported": false, 
            "current_name": "serial_tx_active"
        }, 
        "HAL_UART_Init": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_UART_Init(UART_HandleTypeDef *huart)\n\n{\n  if (huart != (UART_HandleTypeDef *)0x0) {\n    if (huart->gState == HAL_UART_STATE_RESET) {\n      huart->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(huart);\n    }\n    huart->gState = HAL_UART_STATE_BUSY;\n    huart->Instance->CR1 = huart->Instance->CR1 & 0xffffdfff;\n    UART_SetConfig(huart);\n    huart->Instance->CR2 = huart->Instance->CR2 & 0xffffb7ff;\n    huart->Instance->CR3 = huart->Instance->CR3 & 0xffffffd5;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x2000;\n    huart->ErrorCode = 0;\n    huart->gState = HAL_UART_STATE_READY;\n    huart->RxState = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n", 
            "called": [
                "HAL_UART_MspInit", 
                "UART_SetConfig"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800674e", 
            "calling": [
                "uart_init"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_Init"
        }, 
        "sendAnalog": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x0800318c */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::sendAnalog(FirmataMarshaller *this,uint8_t pin,uint16_t value)\n\n{\n  uint16_t local_a;\n  \n  if (this->FirmataStream != (Stream *)0x0) {\n    local_a = value;\n    if ((pin < 0x10) && (value < 0x4000)) {\n      (**(this->FirmataStream->super_Print)._vptr_Print)(this,pin | 0xe0);\n      encodeByteStream(this,2,(uint8_t *)&local_a,2);\n    }\n    else {\n      sendExtendedAnalog(this,pin,2,(uint8_t *)&local_a);\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "sendExtendedAnalog", 
                "encodeByteStream"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003158", 
            "calling": [
                "sendAnalog"
            ], 
            "imported": false, 
            "current_name": "sendAnalog"
        }, 
        "analogRead": {
            "renaming": {}, 
            "code": "\nuint32_t analogRead(uint32_t ulPin)\n\n{\n  bool bVar1;\n  PinName_conflict pin;\n  uint16_t uVar2;\n  uint32_t uVar3;\n  uint uVar4;\n  \n  if (ulPin < 0xe) {\n    if (ulPin + 0x2e < 0x3c) {\n      bVar1 = true;\n    }\n    else {\n      bVar1 = false;\n    }\n  }\n  else {\n    bVar1 = ulPin < 0x3c;\n  }\n  if (bVar1) {\n    if (ulPin < 0xe) {\n      ulPin = ulPin + 0x2e;\n    }\n    pin = PTR_digitalPin_080088d8[ulPin];\n  }\n  else {\n    pin = NC;\n  }\n  if (pin == NC) {\n    uVar3 = 0;\n  }\n  else {\n    uVar2 = adc_read_value(pin);\n    uVar3 = (uint32_t)uVar2;\n    uVar4 = *(uint *)PTR__readResolution_080088dc;\n    if (uVar4 != 0xc) {\n      if (uVar4 < 0xc) {\n        return (uint)(uVar2 >> (0xc - uVar4 & 0xff));\n      }\n      return uVar3 << (uVar4 - 0xc & 0xff);\n    }\n  }\n  return uVar3;\n}\n\n", 
            "called": [
                "adc_read_value"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008880", 
            "calling": [
                "loop", 
                "reportAnalogCallback"
            ], 
            "imported": false, 
            "current_name": "analogRead"
        }, 
        "beginTransmission": {
            "renaming": {}, 
            "code": "\nvoid __thiscall TwoWire::beginTransmission(TwoWire *this,uint8_t address)\n\n{\n  *PTR_transmitting_08002a48 = 1;\n  *PTR_txAddress_08002a4c = address << 1;\n  *PTR_txBufferIndex_08002a50 = 0;\n  *PTR_txBufferLength_08002a54 = 0;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002a30", 
            "calling": [
                "readAndReportData", 
                "requestFrom", 
                "sysexCallback"
            ], 
            "imported": false, 
            "current_name": "beginTransmission"
        }, 
        "_cleanup_r": {
            "renaming": {}, 
            "code": "\nvoid _cleanup_r(undefined4 param_1)\n\n{\n  _fwalk_reent(param_1,DAT_08009cd8);\n  return;\n}\n\n", 
            "called": [
                "_fwalk_reent"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009cd0", 
            "calling": [], 
            "imported": false, 
            "current_name": "_cleanup_r"
        }, 
        "sendFirmwareVersion": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080031e8 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::sendFirmwareVersion\n          (FirmataMarshaller *this,uint8_t major,uint8_t minor,size_t bytec,uint8_t *bytev)\n\n{\n  _func_int_varargs *p_Var1;\n  uint uVar2;\n  \n  if (this->FirmataStream != (Stream *)0x0) {\n    p_Var1 = *(this->FirmataStream->super_Print)._vptr_Print;\n    (*p_Var1)(this,0xf0,(uint)minor,p_Var1,bytec);\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,0x79);\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,(uint)major);\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,(uint)minor);\n    for (uVar2 = 0; uVar2 < bytec; uVar2 = uVar2 + 1) {\n      encodeByteStream(this,1,bytev + uVar2,0);\n    }\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,0xf7);\n  }\n  return;\n}\n\n", 
            "called": [
                "encodeByteStream"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080031ce", 
            "calling": [
                "printFirmwareVersion"
            ], 
            "imported": false, 
            "current_name": "sendFirmwareVersion"
        }, 
        "HAL_NVIC_ClearPendingIRQ": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type_conflict IRQn)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)IRQn;\n  if (-1 < (int)uVar1) {\n    *(int *)(DAT_08004020 + ((uVar1 >> 5) + 0x60) * 4) = 1 << (uVar1 & 0x1f);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004004", 
            "calling": [
                "USART2_IRQHandler", 
                "USART1_IRQHandler", 
                "USART3_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_ClearPendingIRQ"
        }, 
        "TIM_OC3_SetConfig": {
            "renaming": {}, 
            "code": "\nvoid TIM_OC3_SetConfig(TIM_TypeDef_conflict *TIMx,TIM_OC_InitTypeDef *OC_Config)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  TIMx->CCER = TIMx->CCER & 0xfffffeff;\n  uVar2 = TIMx->CR2;\n  uVar3 = OC_Config->OCMode;\n  uVar1 = TIMx->CCER & 0xfffffdff | OC_Config->OCPolarity << 8;\n  if (TIMx == DAT_08005da8) {\n    uVar1 = (uVar1 & 0xfffff7ff | OC_Config->OCNPolarity << 8) & 0xfffffbff;\n    uVar2 = uVar2 & 0xffffcfff | OC_Config->OCIdleState << 4 | OC_Config->OCNIdleState << 4;\n  }\n  TIMx->CR2 = uVar2;\n  TIMx->CCMR2 = TIMx->CCMR2 & 0xffffff8c | uVar3;\n  TIMx->CCR3 = OC_Config->Pulse;\n  TIMx->CCER = uVar1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005d48", 
            "calling": [
                "HAL_TIM_PWM_ConfigChannel", 
                "HAL_TIM_OC_ConfigChannel"
            ], 
            "imported": false, 
            "current_name": "TIM_OC3_SetConfig"
        }, 
        "HAL_TIM_OC_DeInit": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_TIM_OC_DeInit(TIM_HandleTypeDef_conflict *htim)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  htim->State = HAL_TIM_STATE_BUSY;\n  pTVar1 = htim->Instance;\n  if (((pTVar1->CCER & 0x1111) == 0) && ((pTVar1->CCER & 0x444) == 0)) {\n    pTVar1->CR1 = pTVar1->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_OC_MspDeInit(htim);\n  htim->State = HAL_TIM_STATE_RESET;\n  htim->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_TIM_OC_MspDeInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005df4", 
            "calling": [
                "TimerPulseDeinit"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_OC_DeInit"
        }, 
        "sendDigitalPort": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080031ba */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::sendDigitalPort\n          (FirmataMarshaller *this,uint8_t portNumber,uint16_t portData)\n\n{\n  uint16_t local_a;\n  \n  if (this->FirmataStream != (Stream *)0x0) {\n    local_a = portData;\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this,portNumber & 0xf | 0x90);\n    encodeByteStream(this,2,(uint8_t *)&local_a,2);\n  }\n  return;\n}\n\n", 
            "called": [
                "encodeByteStream"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800319e", 
            "calling": [
                "sendDigitalPort"
            ], 
            "imported": false, 
            "current_name": "sendDigitalPort"
        }, 
        "I2C_MasterReceive_BTF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_MasterReceive_BTF(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  uint32_t uVar1;\n  uint8_t *puVar2;\n  \n  uVar1 = hi2c->XferOptions;\n  if (hi2c->XferCount == 3) {\n    if (((uVar1 == 4) || (uVar1 == 8)) || (uVar1 == 0xffff0000)) {\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n    }\n    puVar2 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar2 + 1;\n    *puVar2 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n  }\n  else if (hi2c->XferCount == 2) {\n    if (((uVar1 == 4) || (uVar1 == 8)) || (uVar1 == 0xffff0000)) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffcff;\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n    }\n    else {\n      if (uVar1 == 2) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n      }\n      else {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n      }\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffcff;\n    }\n    puVar2 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar2 + 1;\n    *puVar2 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n    puVar2 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar2 + 1;\n    *puVar2 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->PreviousState = 0;\n    if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(hi2c);\n    }\n    else {\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(hi2c);\n    }\n  }\n  else {\n    puVar2 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar2 + 1;\n    *puVar2 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_MemRxCpltCallback", 
                "HAL_I2C_MasterRxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004e3c", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_MasterReceive_BTF"
        }, 
        "analogWrite": {
            "renaming": {}, 
            "code": "\nvoid analogWrite(uint32_t ulPin,uint32_t ulValue)\n\n{\n  _Bool _Var1;\n  uint uVar2;\n  PinName_conflict pin;\n  \n  if (ulPin < 0x3c) {\n    pin = PTR_digitalPin_0800897c[ulPin];\n  }\n  else {\n    pin = NC;\n  }\n  if (pin != NC) {\n    _Var1 = pin_in_pinmap(pin,(PinMap_conflict *)PTR_PinMap_PWM_08008980);\n    if (_Var1) {\n      _Var1 = is_pin_configured(pin,(uint32_t *)PTR_g_anOutputPinConfigured_08008984);\n      if (!_Var1) {\n        set_pin_configured(pin,(uint32_t *)PTR_g_anOutputPinConfigured_08008984);\n      }\n      uVar2 = *(uint *)PTR__writeResolution_08008988;\n      if (uVar2 != 8) {\n        if (uVar2 < 9) {\n          ulValue = ulValue << (8 - uVar2 & 0xff);\n        }\n        else {\n          ulValue = ulValue >> (uVar2 - 8 & 0xff);\n        }\n      }\n      pwm_start(pin,DAT_0800898c,0xff,ulValue,!_Var1);\n    }\n    else {\n      pinMode(ulPin,1);\n      uVar2 = *(uint *)PTR__writeResolution_08008988;\n      if (uVar2 != 8) {\n        if (uVar2 < 9) {\n          ulValue = ulValue << (8 - uVar2 & 0xff);\n        }\n        else {\n          ulValue = ulValue >> (uVar2 - 8 & 0xff);\n        }\n      }\n      if (ulValue < 0x80) {\n        digitalWrite(ulPin,0);\n      }\n      else {\n        digitalWrite(ulPin,1);\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "pinMode", 
                "set_pin_configured", 
                "pwm_start", 
                "is_pin_configured", 
                "pin_in_pinmap", 
                "digitalWrite"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080088e0", 
            "calling": [
                "analogWriteCallback", 
                "setPinModeCallback"
            ], 
            "imported": false, 
            "current_name": "analogWrite"
        }, 
        "strrchr": {
            "renaming": {}, 
            "code": "\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  \n  if (__c != 0) {\n    pcVar2 = (char *)0x0;\n    while (pcVar1 = strchr(__s,__c), pcVar1 != (char *)0x0) {\n      __s = pcVar1 + 1;\n      pcVar2 = pcVar1;\n    }\n    return pcVar2;\n  }\n  pcVar2 = strchr(__s,0);\n  return pcVar2;\n}\n\n", 
            "called": [
                "strchr"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800997e", 
            "calling": [
                "setFirmwareNameAndVersion"
            ], 
            "imported": false, 
            "current_name": "strrchr"
        }, 
        "HAL_RCC_GetClockConfig": {
            "renaming": {}, 
            "code": "\nvoid HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef_conflict *RCC_ClkInitStruct,uint32_t *pFLatency)\n\n{\n  int iVar1;\n  \n  RCC_ClkInitStruct->ClockType = 0xf;\n  iVar1 = DAT_08005a9c;\n  RCC_ClkInitStruct->SYSCLKSource = *(uint *)(DAT_08005a9c + 4) & 3;\n  RCC_ClkInitStruct->AHBCLKDivider = *(uint *)(iVar1 + 4) & 0xf0;\n  RCC_ClkInitStruct->APB1CLKDivider = *(uint *)(iVar1 + 4) & 0x700;\n  RCC_ClkInitStruct->APB2CLKDivider = *(uint *)(iVar1 + 4) >> 3 & 0x700;\n  *pFLatency = *DAT_08005aa0 & 7;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005a68", 
            "calling": [
                "getTimerClkFreq"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetClockConfig"
        }, 
        "I2C1_ER_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid I2C1_ER_IRQHandler(void)\n\n{\n  HAL_I2C_ER_IRQHandler(*(I2C_HandleTypeDef_conflict **)PTR_i2c_handles_08008054);\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008048", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C1_ER_IRQHandler"
        }, 
        "ServoIrqHandle": {
            "renaming": {}, 
            "code": "\nvoid ServoIrqHandle(stimer_t *obj,uint32_t channel)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  uint32_t uVar3;\n  int iVar4;\n  uint uVar5;\n  \n  uVar5 = (uint)obj->idx;\n  if ((PTR_timerChannel_0800256c[uVar5] & 0x80) == 0) {\n    iVar4 = uVar5 * 0xc;\n    if ((char)PTR_timerChannel_0800256c[uVar5] + iVar4 < (int)(uint)(byte)*PTR_ServoCount_08002570)\n    {\n      if ((PTR_servos_08002574[((char)PTR_timerChannel_0800256c[uVar5] + iVar4) * 8] & 0x40) == 0) {\n        bVar1 = false;\n      }\n      else {\n        bVar1 = true;\n      }\n    }\n    else {\n      bVar1 = false;\n    }\n    if (bVar1) {\n      digitalWrite((byte)PTR_servos_08002574[(iVar4 + (char)PTR_timerChannel_0800256c[uVar5]) * 8] &\n                   0x3f,0);\n    }\n  }\n  else {\n    setTimerCounter((stimer_t_conflict *)obj,0);\n  }\n  puVar2 = PTR_timerChannel_0800256c;\n  PTR_timerChannel_0800256c[uVar5] = PTR_timerChannel_0800256c[uVar5] + '\\x01';\n  iVar4 = uVar5 * 0xc;\n  if ((char)puVar2[uVar5] + iVar4 < (int)(uint)(byte)*PTR_ServoCount_08002570) {\n    if ((char)PTR_timerChannel_0800256c[uVar5] < '\\f') {\n      bVar1 = true;\n    }\n    else {\n      bVar1 = false;\n    }\n  }\n  else {\n    bVar1 = false;\n  }\n  if (bVar1) {\n    if ((PTR_servos_08002574[((char)PTR_timerChannel_0800256c[uVar5] + iVar4) * 8] & 0x40) != 0) {\n      digitalWrite((byte)PTR_servos_08002574[((char)PTR_timerChannel_0800256c[uVar5] + iVar4) * 8] &\n                   0x3f,1);\n    }\n    uVar3 = getTimerCounter((stimer_t_conflict *)obj);\n    setCCRRegister((stimer_t_conflict *)obj,channel,\n                   *(int *)(PTR_servos_08002574 +\n                           (iVar4 + (char)PTR_timerChannel_0800256c[uVar5]) * 8 + 4) + uVar3);\n    return;\n  }\n  uVar3 = getTimerCounter((stimer_t_conflict *)obj);\n  if (uVar3 + 4 < 20000) {\n    setCCRRegister((stimer_t_conflict *)obj,channel,20000);\n  }\n  else {\n    uVar3 = getTimerCounter((stimer_t_conflict *)obj);\n    setCCRRegister((stimer_t_conflict *)obj,channel,uVar3 + 4);\n  }\n  PTR_timerChannel_0800256c[uVar5] = 0xff;\n  return;\n}\n\n", 
            "called": [
                "getTimerCounter", 
                "setTimerCounter", 
                "digitalWrite", 
                "setCCRRegister"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002444", 
            "calling": [], 
            "imported": false, 
            "current_name": "ServoIrqHandle"
        }, 
        "__sflush_r": {
            "renaming": {}, 
            "code": "\nundefined4 __sflush_r(uint *param_1,int *param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  uint uVar3;\n  ushort uVar4;\n  int iVar5;\n  code *pcVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  \n  uVar4 = *(ushort *)(param_2 + 3);\n  uVar3 = (uint)uVar4;\n  if ((int)(uVar3 << 0x1c) < 0) {\n    iVar1 = param_2[4];\n    if (iVar1 != 0) {\n      iVar5 = uVar3 << 0x1e;\n      bVar9 = iVar5 != 0;\n      if (bVar9) {\n        iVar5 = 0;\n      }\n      iVar7 = *param_2;\n      if (!bVar9) {\n        iVar5 = param_2[5];\n      }\n      *param_2 = iVar1;\n      param_2[2] = iVar5;\n      for (iVar7 = iVar7 - iVar1; 0 < iVar7; iVar7 = iVar7 - iVar5) {\n        iVar5 = (*(code *)param_2[10])(param_1,param_2[8],iVar1,iVar7);\n        if (iVar5 < 1) {\n          uVar4 = *(ushort *)(param_2 + 3);\n          goto LAB_08009c62;\n        }\n        iVar1 = iVar1 + iVar5;\n      }\n    }\n  }\n  else if (((0 < param_2[1]) || (0 < param_2[0x10])) &&\n          (pcVar6 = (code *)param_2[0xb], pcVar6 != (code *)0x0)) {\n    uVar8 = *param_1;\n    *param_1 = 0;\n    if ((uVar4 & 0x1000) == 0) {\n      iVar1 = (*pcVar6)(param_1,param_2[8],uVar3 & 0x1000,1);\n      if ((iVar1 == -1) && (uVar3 = *param_1, uVar3 != 0)) {\n        if ((uVar3 != 0x1d) && (uVar3 != 0x16)) {\n          *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *param_1 = uVar8;\n        return 0;\n      }\n    }\n    else {\n      iVar1 = param_2[0x15];\n    }\n    if (((int)((uint)*(ushort *)(param_2 + 3) << 0x1d) < 0) &&\n       (iVar1 = iVar1 - param_2[1], param_2[0xd] != 0)) {\n      iVar1 = iVar1 - param_2[0x10];\n    }\n    iVar1 = (*(code *)param_2[0xb])(param_1,param_2[8],iVar1,0);\n    uVar4 = *(ushort *)(param_2 + 3);\n    if ((iVar1 == -1) &&\n       ((0x1d < *param_1 || (-1 < (int)((DAT_08009c78 >> (*param_1 & 0xff)) << 0x1f))))) {\nLAB_08009c62:\n      *(ushort *)(param_2 + 3) = uVar4 | 0x40;\n      return 0xffffffff;\n    }\n    param_2[1] = 0;\n    *param_2 = param_2[4];\n    if (((int)((uint)uVar4 << 0x13) < 0) && ((iVar1 != -1 || (*param_1 == 0)))) {\n      param_2[0x15] = iVar1;\n    }\n    piVar2 = (int *)param_2[0xd];\n    *param_1 = uVar8;\n    if (piVar2 != (int *)0x0) {\n      if (piVar2 != param_2 + 0x11) {\n        _free_r(param_1);\n      }\n      param_2[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n", 
            "called": [
                "_free_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009b6c", 
            "calling": [
                "_fflush_r"
            ], 
            "imported": false, 
            "current_name": "__sflush_r"
        }, 
        "TIM4_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM4_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_080077ac + 0xc) !=\n      (TIM_HandleTypeDef_conflict *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_080077ac + 0xc));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800779c", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM4_IRQHandler"
        }, 
        "digital_io_read": {
            "renaming": {}, 
            "code": "\nuint32_t digital_io_read(GPIO_TypeDef *port,uint32_t pin)\n\n{\n  GPIO_PinState GVar1;\n  \n  GVar1 = HAL_GPIO_ReadPin(port,(uint16_t)pin);\n  return (uint)GVar1;\n}\n\n", 
            "called": [
                "HAL_GPIO_ReadPin"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080072f0", 
            "calling": [
                "digitalRead"
            ], 
            "imported": false, 
            "current_name": "digital_io_read"
        }, 
        "HAL_GPIO_Init": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_Init(GPIO_TypeDef *GPIOx,GPIO_InitTypeDef *GPIO_Init)\n\n{\n  GPIO_TypeDef *pGVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint32_t uVar7;\n  int iVar8;\n  uint uVar9;\n  int iVar10;\n  uint32_t tmpreg;\n  \n  uVar7 = 0;\n  uVar5 = 0;\n  do {\n    if (0xf < uVar5) {\n      return;\n    }\n    uVar3 = 1 << (uVar5 & 0xff);\n    uVar4 = GPIO_Init->Pin & uVar3;\n    if (uVar3 == uVar4) {\n      uVar6 = GPIO_Init->Mode;\n      if (uVar6 == 0x12) {\n        uVar7 = GPIO_Init->Speed + 0xc;\n      }\n      else if (uVar6 < 0x13) {\n        if (uVar6 == 2) {\n          uVar7 = GPIO_Init->Speed + 8;\n        }\n        else if (uVar6 < 3) {\n          if (uVar6 == 0) goto LAB_0800423a;\n          if (uVar6 == 1) {\n            uVar7 = GPIO_Init->Speed;\n          }\n        }\n        else if (uVar6 == 3) {\n          uVar7 = 0;\n        }\n        else if (uVar6 == 0x11) {\n          uVar7 = GPIO_Init->Speed + 4;\n        }\n      }\n      else {\n        if (uVar6 != DAT_080042c8) {\n          if (DAT_080042c8 < uVar6) {\n            if (uVar6 == DAT_080042cc) goto LAB_0800423a;\n            uVar9 = DAT_080042cc + 0x10000;\n            uVar2 = DAT_080042cc;\n          }\n          else {\n            uVar9 = DAT_080042c8 - 0x100000;\n            uVar2 = DAT_080042c8;\n          }\n          if ((uVar6 != uVar9) && (uVar6 != uVar2 - 0xf0000)) goto LAB_080040fe;\n        }\nLAB_0800423a:\n        if (GPIO_Init->Pull == 0) {\n          uVar7 = 4;\n        }\n        else if (GPIO_Init->Pull == 1) {\n          GPIOx->BSRR = uVar3;\n          uVar7 = 8;\n        }\n        else {\n          GPIOx->BRR = uVar3;\n          uVar7 = 8;\n        }\n      }\nLAB_080040fe:\n      uVar3 = uVar5;\n      pGVar1 = GPIOx;\n      if (0xff < uVar4) {\n        uVar3 = uVar5 - 8;\n        pGVar1 = (GPIO_TypeDef *)&GPIOx->CRH;\n      }\n      pGVar1->CRL = pGVar1->CRL & ~(0xf << (uVar3 << 2 & 0xff)) | uVar7 << (uVar3 << 2 & 0xff);\n      if ((GPIO_Init->Mode & 0x10000000) != 0) {\n        *(uint *)(DAT_080042bc + 0x18) = *(uint *)(DAT_080042bc + 0x18) | 1;\n        iVar8 = (uVar5 & 3) << 2;\n        if (GPIOx == DAT_080042d0) {\n          iVar10 = 0;\n        }\n        else if (GPIOx == (GPIO_TypeDef *)&DAT_080042d0[0x24].BSRR) {\n          iVar10 = 1;\n        }\n        else if (GPIOx == (GPIO_TypeDef *)&DAT_080042d0[0x49].CRH) {\n          iVar10 = 2;\n        }\n        else if (GPIOx == (GPIO_TypeDef *)&DAT_080042d0[0x6d].BRR) {\n          iVar10 = 3;\n        }\n        else {\n          iVar10 = 4;\n        }\n        *(uint *)(DAT_080042c0 + ((uVar5 >> 2) + 2) * 4) =\n             *(uint *)(DAT_080042c0 + ((uVar5 >> 2) + 2) * 4) & ~(0xf << iVar8) | iVar10 << iVar8;\n        if ((GPIO_Init->Mode & 0x10000) == 0) {\n          *DAT_080042c4 = *DAT_080042c4 & ~uVar4;\n        }\n        else {\n          *DAT_080042c4 = *DAT_080042c4 | uVar4;\n        }\n        if ((GPIO_Init->Mode & 0x20000) == 0) {\n          DAT_080042c4[1] = DAT_080042c4[1] & ~uVar4;\n        }\n        else {\n          DAT_080042c4[1] = DAT_080042c4[1] | uVar4;\n        }\n        if ((GPIO_Init->Mode & 0x100000) == 0) {\n          DAT_080042c4[2] = DAT_080042c4[2] & ~uVar4;\n        }\n        else {\n          DAT_080042c4[2] = DAT_080042c4[2] | uVar4;\n        }\n        if ((GPIO_Init->Mode & 0x200000) == 0) {\n          DAT_080042c4[3] = DAT_080042c4[3] & ~uVar4;\n        }\n        else {\n          DAT_080042c4[3] = uVar4 | DAT_080042c4[3];\n        }\n      }\n    }\n    uVar5 = uVar5 + 1;\n  } while( true );\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080040e8", 
            "calling": [
                "HAL_TIM_PWM_MspInit", 
                "uart_init", 
                "HAL_ADC_MspInit", 
                "i2c_custom_init", 
                "digital_io_init"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_Init"
        }, 
        "HAL_RCCEx_GetPeriphCLKFreq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)\n\n{\n  uint32_t uVar1;\n  uint uVar2;\n  uint8_t aPredivFactorTable [2];\n  uint8_t aPLLMULFactorTable [16];\n  \n  aPLLMULFactorTable._12_4_ = *(undefined4 *)(PTR_DAT_08005ca0 + 8);\n  aPLLMULFactorTable._8_4_ = *(undefined4 *)(PTR_DAT_08005ca0 + 4);\n  aPLLMULFactorTable._4_4_ = *(undefined4 *)PTR_DAT_08005ca0;\n  aPredivFactorTable = *(uint8_t (*) [2])(PTR_DAT_08005ca0 + 0x10);\n  if (PeriphClk == 2) {\n    uVar1 = HAL_RCC_GetPCLK2Freq();\n    uVar1 = uVar1 / ((((DAT_08005ca4[1] << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (PeriphClk == 0x10) {\n    if ((*DAT_08005ca4 & 0x1000000) == 0) {\n      uVar1 = 0;\n    }\n    else {\n      uVar2 = DAT_08005cb0;\n      if ((DAT_08005ca4[1] & 0x10000) != 0) {\n        uVar2 = DAT_08005ca8 / aPredivFactorTable[-((int)(DAT_08005ca4[1] << 0xe) >> 0x1f)];\n      }\n      uVar1 = uVar2 * aPLLMULFactorTable[(DAT_08005ca4[1] << 10) >> 0x1c];\n      if ((DAT_08005ca4[1] & 0x400000) == 0) {\n        uVar1 = (uint32_t)((ulonglong)DAT_08005cac * (ulonglong)(uVar1 * 2) >> 0x21);\n      }\n    }\n  }\n  else if (PeriphClk == 1) {\n    if ((DAT_08005ca4[8] & 0x302) == 0x102) {\n      uVar1 = 0x8000;\n    }\n    else {\n      uVar2 = DAT_08005ca4[8] & 0x300;\n      if ((uVar2 == 0x200) && ((DAT_08005ca4[9] & 2) != 0)) {\n        uVar1 = 32000;\n      }\n      else if (uVar2 == 0x300) {\n        if ((*DAT_08005ca4 & 0x20000) == 0) {\n          uVar1 = 0;\n        }\n        else {\n          uVar1 = 0xf424;\n        }\n      }\n      else {\n        uVar1 = 0;\n      }\n    }\n  }\n  else {\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n", 
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005bb8", 
            "calling": [
                "HAL_ADC_PollForConversion", 
                "HAL_ADCEx_Calibration_Start"
            ], 
            "imported": false, 
            "current_name": "HAL_RCCEx_GetPeriphCLKFreq"
        }, 
        "setCCRRegister": {
            "renaming": {}, 
            "code": "\nvoid setCCRRegister(stimer_t_conflict *obj,uint32_t channel,uint32_t value)\n\n{\n  (&((obj->handle).Instance)->CCR1)[channel] = value;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007750", 
            "calling": [
                "ServoIrqHandle"
            ], 
            "imported": false, 
            "current_name": "setCCRRegister"
        }, 
        "reportDigitalCallback": {
            "renaming": {}, 
            "code": "\nvoid reportDigitalCallback(byte port,int value)\n\n{\n  byte bVar1;\n  bool bVar2;\n  uint32_t uVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte portValue;\n  \n  uVar6 = (uint)port;\n  if ((uVar6 < 5) && (PTR_reportPINs_08000ebc[uVar6] = (char)value, value != 0)) {\n    bVar1 = PTR_portConfigInputs_08000ec0[uVar6];\n    uVar6 = (uVar6 & 0x1f) * 8;\n    if (uVar6 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar6] == NC) {\n        portValue = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n        if (uVar3 == 0) {\n          portValue = 0;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n          if (uVar3 == 1) {\n            portValue = 0;\n          }\n          else if ((bVar1 & 1) == 0) {\n            portValue = 0;\n          }\n          else {\n            iVar4 = digitalRead(uVar6);\n            if (iVar4 == 0) {\n              portValue = 0;\n            }\n            else {\n              portValue = 1;\n            }\n          }\n        }\n      }\n    }\n    else {\n      portValue = 0;\n    }\n    uVar5 = uVar6 + 1;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 2) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 2;\n    }\n    uVar5 = uVar6 + 2;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 4) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 4;\n    }\n    uVar5 = uVar6 + 3;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 8) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 8;\n    }\n    uVar5 = uVar6 + 4;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x10) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x10;\n    }\n    uVar5 = uVar6 + 5;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x20) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x20;\n    }\n    uVar5 = uVar6 + 6;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x40) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x40;\n    }\n    uVar6 = uVar6 + 7;\n    if (uVar6 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar6] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x80) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar6);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x80;\n    }\n    outputPort(port,portValue,'\\x01');\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "outputPort", 
                "pinNametoDigitalPin", 
                "digitalRead"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000c18", 
            "calling": [], 
            "imported": false, 
            "current_name": "reportDigitalCallback"
        }, 
        "UART_WaitOnFlagUntilTimeout": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nUART_WaitOnFlagUntilTimeout\n          (UART_HandleTypeDef *huart,uint32_t Flag,FlagStatus Status,uint32_t Tickstart,\n          uint32_t Timeout)\n\n{\n  uint32_t uVar1;\n  \n  do {\n    if (((Flag & ~huart->Instance->SR) == 0) != (bool)Status) {\n      return HAL_OK;\n    }\n  } while ((Timeout == 0xffffffff) ||\n          ((Timeout != 0 && (uVar1 = HAL_GetTick(), uVar1 - Tickstart <= Timeout))));\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xfffffe5f;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffffe;\n  huart->gState = HAL_UART_STATE_READY;\n  huart->RxState = HAL_UART_STATE_READY;\n  huart->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080066e8", 
            "calling": [
                "HAL_UART_Transmit"
            ], 
            "imported": false, 
            "current_name": "UART_WaitOnFlagUntilTimeout"
        }, 
        "__sseek": {
            "renaming": {}, 
            "code": "\nvoid __sseek(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  ushort uVar2;\n  bool bVar3;\n  \n  iVar1 = _lseek_r(param_1,(int)*(short *)(param_2 + 0xe));\n  bVar3 = iVar1 == -1;\n  if (bVar3) {\n    uVar2 = *(ushort *)(param_2 + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(param_2 + 0x54) = iVar1;\n    uVar2 = *(ushort *)(param_2 + 0xc) | 0x1000;\n  }\n  if (bVar3) {\n    *(ushort *)(param_2 + 0xc) = uVar2;\n  }\n  if (!bVar3) {\n    *(ushort *)(param_2 + 0xc) = uVar2;\n  }\n  return;\n}\n\n", 
            "called": [
                "_lseek_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a07a", 
            "calling": [], 
            "imported": false, 
            "current_name": "__sseek"
        }, 
        "digitalWriteCallback": {
            "renaming": {}, 
            "code": "\nvoid digitalWriteCallback(byte port,int value)\n\n{\n  bool bVar1;\n  byte bVar2;\n  uint uVar3;\n  uint32_t uVar4;\n  int iVar5;\n  byte pin;\n  uint32_t ulPin;\n  uint uVar6;\n  uint uVar7;\n  uint32_t ulPin_00;\n  uint uVar8;\n  \n  uVar3 = (uint)port;\n  if (uVar3 < 5) {\n    uVar7 = (uVar3 + 1 & 0x1f) * 8;\n    if (0x3c < uVar7) {\n      uVar7 = 0x3c;\n    }\n    uVar8 = 0;\n    uVar6 = 1;\n    ulPin_00 = (uVar3 & 0x1f) * 8;\n    for (ulPin = ulPin_00; ulPin < uVar7; ulPin = ulPin + 1 & 0xff) {\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000480[ulPin] == NC) {\n          bVar1 = false;\n        }\n        else {\n          uVar4 = pinNametoDigitalPin(PTR_digitalPin_08000480[ulPin]);\n          if (uVar4 == 0) {\n            bVar1 = false;\n          }\n          else {\n            uVar4 = pinNametoDigitalPin(PTR_digitalPin_08000480[ulPin]);\n            if (uVar4 == 1) {\n              bVar1 = false;\n            }\n            else {\n              bVar1 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar1 = false;\n      }\n      if (bVar1) {\n        pin = (byte)ulPin;\n        bVar2 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000484,pin);\n        if ((bVar2 != '\\x01') &&\n           (bVar2 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000484,pin),\n           bVar2 != '\\0')) {\n          bVar1 = false;\n        }\n        if (bVar1) {\n          uVar3 = (uint)((uVar6 & value) != 0);\n          bVar2 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000484,pin);\n          if (bVar2 == '\\x01') {\n            uVar8 = uVar6 | uVar8;\n          }\n          else {\n            bVar2 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000484,pin);\n            if (bVar2 == '\\0') {\n              if (uVar3 == 0) {\n                bVar1 = false;\n              }\n              else {\n                iVar5 = firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_08000484,pin)\n                ;\n                if (iVar5 == 1) {\n                  bVar1 = false;\n                }\n              }\n            }\n            else {\n              bVar1 = false;\n            }\n            if (bVar1) {\n              pinMode(ulPin,2);\n            }\n          }\n          firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000484,pin,uVar3);\n        }\n      }\n      uVar6 = (uVar6 & 0x7f) << 1;\n    }\n    if ((uVar8 & 1) != 0) {\n      digitalWrite(ulPin_00,value & 1);\n    }\n    if ((uVar8 & 2) != 0) {\n      digitalWrite(ulPin_00 + 1,value & 2);\n    }\n    if ((uVar8 & 4) != 0) {\n      digitalWrite(ulPin_00 + 2,value & 4);\n    }\n    if ((uVar8 & 8) != 0) {\n      digitalWrite(ulPin_00 + 3,value & 8);\n    }\n    if ((uVar8 & 0x10) != 0) {\n      digitalWrite(ulPin_00 + 4,value & 0x10);\n    }\n    if ((uVar8 & 0x20) != 0) {\n      digitalWrite(ulPin_00 + 5,value & 0x20);\n    }\n    if ((uVar8 & 0x40) != 0) {\n      digitalWrite(ulPin_00 + 6,value & 0x40);\n    }\n    if ((uVar8 & 0x80) != 0) {\n      digitalWrite(ulPin_00 + 7,value & 0x80);\n    }\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "pinMode", 
                "getPinMode", 
                "getPinState", 
                "pinNametoDigitalPin", 
                "setPinState", 
                "digitalWrite"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080002ec", 
            "calling": [], 
            "imported": false, 
            "current_name": "digitalWriteCallback"
        }, 
        "HAL_ADC_MspInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_ADC_MspInit(ADC_HandleTypeDef *hadc)\n\n{\n  undefined *puVar1;\n  GPIO_TypeDef *GPIOx;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (hadc->Instance == DAT_08006d14) {\n    *(uint *)(DAT_08006d20 + 0x18) = *(uint *)(DAT_08006d20 + 0x18) | 0x200;\n  }\n  else if (hadc->Instance == DAT_08006d18) {\n    *(uint *)(DAT_08006d20 + 0x18) = *(uint *)(DAT_08006d20 + 0x18) | 0x400;\n  }\n  puVar1 = PTR_g_current_pin_08006d1c;\n  GPIOx = set_GPIO_Port_Clock((uint)((int)(char)*PTR_g_current_pin_08006d1c << 0x18) >> 0x1c);\n  GPIO_InitStruct.Pin = 1 << (*puVar1 & 0xf) & 0xffff;\n  GPIO_InitStruct.Mode = 3;\n  GPIO_InitStruct.Pull = 0;\n  HAL_GPIO_Init(GPIOx,&GPIO_InitStruct);\n  return;\n}\n\n", 
            "called": [
                "set_GPIO_Port_Clock", 
                "HAL_GPIO_Init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006ca8", 
            "calling": [
                "HAL_ADC_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_MspInit"
        }, 
        "systemReset": {
            "renaming": {}, 
            "code": "\nvoid __thiscall firmata::FirmataParser::systemReset(FirmataParser *this)\n\n{\n  uint uVar1;\n  \n  this->waitForData = 0;\n  this->executeMultiByteCommand = '\\0';\n  this->multiByteChannel = '\\0';\n  for (uVar1 = 0; uVar1 < this->dataBufferSize; uVar1 = uVar1 + 1) {\n    this->dataBuffer[uVar1] = '\\0';\n  }\n  this->parsingSysex = false;\n  this->sysexBytesRead = 0;\n  if (this->currentSystemResetCallback != (systemCallbackFunction)0x0) {\n    (*this->currentSystemResetCallback)(this->currentSystemResetCallbackContext);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800344a", 
            "calling": [
                "parse"
            ], 
            "imported": false, 
            "current_name": "systemReset"
        }, 
        "_lseek": {
            "renaming": {}, 
            "code": "\nint _lseek(int file_UNUSED,int ptr_UNUSED,int dir_UNUSED)\n\n{\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008854", 
            "calling": [
                "_lseek_r"
            ], 
            "imported": false, 
            "current_name": "_lseek"
        }, 
        "get_pwm_channel": {
            "renaming": {}, 
            "code": "\nuint32_t get_pwm_channel(PinName_conflict pin)\n\n{\n  uint32_t uVar1;\n  uint uVar2;\n  \n  uVar1 = pinmap_function(pin,(PinMap_conflict *)PTR_PinMap_PWM_08006ca4);\n  uVar2 = (uVar1 << 0xc) >> 0x1b;\n  if (uVar2 == 3) {\n    return 8;\n  }\n  if (uVar2 != 4) {\n    if (uVar2 != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n", 
            "called": [
                "pinmap_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006c7c", 
            "calling": [
                "pwm_start", 
                "pwm_stop"
            ], 
            "imported": false, 
            "current_name": "get_pwm_channel"
        }, 
        "detachServo": {
            "renaming": {}, 
            "code": "\nvoid detachServo(byte pin)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined *puVar3;\n  \n  puVar3 = PTR_servoPinMap_080005cc;\n  Servo::detach((Servo *)(PTR_servos_080005d0 + (uint)(byte)PTR_servoPinMap_080005cc[pin] * 3));\n  cVar2 = puVar3[pin];\n  cVar1 = *PTR_servoCount_080005d4;\n  if ((cVar2 == cVar1) && (cVar1 != '\\0')) {\n    *PTR_servoCount_080005d4 = cVar1 + -1;\n  }\n  else if (cVar1 != '\\0') {\n    cVar1 = *PTR_detachedServoCount_080005d8;\n    *PTR_detachedServoCount_080005d8 = cVar1 + 1U;\n    PTR_detachedServos_080005dc[(byte)(cVar1 + 1U) - 1] = cVar2;\n  }\n  PTR_servoPinMap_080005cc[pin] = 0xff;\n  return;\n}\n\n", 
            "called": [
                "detach"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000588", 
            "calling": [
                "setPinModeCallback", 
                "sysexCallback"
            ], 
            "imported": false, 
            "current_name": "detachServo"
        }, 
        "allocateRxBuffer": {
            "renaming": {}, 
            "code": "\nvoid TwoWire::allocateRxBuffer(size_t length)\n\n{\n  undefined *puVar1;\n  void *pvVar2;\n  undefined uVar3;\n  \n  puVar1 = PTR_rxBuffer_08002afc;\n  if ((byte)*PTR_rxBufferAllocated_08002af8 < length) {\n    if (length < 0x20) {\n      length = 0x20;\n    }\n    pvVar2 = realloc(*(void **)PTR_rxBuffer_08002afc,length);\n    *(void **)puVar1 = pvVar2;\n    if (pvVar2 == (void *)0x0) {\n      uVar3 = 0;\n    }\n    else {\n      uVar3 = (undefined)length;\n    }\n    *PTR_rxBufferAllocated_08002af8 = uVar3;\n  }\n  return;\n}\n\n", 
            "called": [
                "realloc"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002acc", 
            "calling": [
                "onReceiveService", 
                "requestFrom"
            ], 
            "imported": false, 
            "current_name": "allocateRxBuffer"
        }, 
        "staticDigitalCallback": {
            "renaming": {}, 
            "code": "\nvoid firmata::FirmataClass::staticDigitalCallback(void *param_1,uint8_t command,uint16_t value)\n\n{\n  if (*(code **)PTR_currentDigitalCallback_08002c50 != (code *)0x0) {\n    (**(code **)PTR_currentDigitalCallback_08002c50)(command,value);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002c40", 
            "calling": [], 
            "imported": false, 
            "current_name": "staticDigitalCallback"
        }, 
        "HAL_Init": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_Init(void)\n\n{\n  *DAT_08003744 = *DAT_08003744 | 0x10;\n  HAL_NVIC_SetPriorityGrouping(3);\n  HAL_InitTick(0xf);\n  HAL_MspInit();\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_NVIC_SetPriorityGrouping", 
                "HAL_MspInit", 
                "HAL_InitTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003724", 
            "calling": [
                "hw_config_init"
            ], 
            "imported": false, 
            "current_name": "HAL_Init"
        }, 
        "HAL_SYSTICK_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_SYSTICK_IRQHandler(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n", 
            "called": [
                "HAL_SYSTICK_Callback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004046", 
            "calling": [
                "SysTick_Handler"
            ], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_IRQHandler"
        }, 
        "FirmataClass": {
            "renaming": {}, 
            "code": "\nFirmataClass * __thiscall firmata::FirmataClass::FirmataClass(FirmataClass *this)\n\n{\n  FirmataParser *this_00;\n  \n  FirmataMarshaller::FirmataMarshaller(&this->marshaller);\n  this_00 = &this->parser;\n  FirmataParser::FirmataParser(this_00,this->parserBuffer,0x40);\n  this->firmwareVersionCount = '\\0';\n  this->firmwareVersionVector = (byte *)0x0;\n  this->blinkVersionDisabled = false;\n  FirmataParser::attach(this_00,0xe0,DAT_08002d90,(void *)0x0);\n  FirmataParser::attach(this_00,0x90,DAT_08002d94,(void *)0x0);\n  FirmataParser::attach(this_00,0xc0,DAT_08002d98,(void *)0x0);\n  FirmataParser::attach(this_00,0xd0,DAT_08002d9c,(void *)0x0);\n  FirmataParser::attach(this_00,0xf4,DAT_08002da0,(void *)0x0);\n  FirmataParser::attach(this_00,0xf5,DAT_08002da4,(void *)0x0);\n  FirmataParser::attach(this_00,'q',DAT_08002da8,(void *)0x0);\n  FirmataParser::attach(this_00,0xf0,DAT_08002dac,(void *)0x0);\n  FirmataParser::attach(this_00,'y',DAT_08002db0,this);\n  FirmataParser::attach(this_00,0xf9,DAT_08002db4,this);\n  FirmataParser::attach(this_00,0xff,DAT_08002db8,(void *)0x0);\n  return this;\n}\n\n", 
            "called": [
                "FirmataParser", 
                "attach", 
                "attach", 
                "attach", 
                "FirmataMarshaller", 
                "attach", 
                "attach"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002ce0", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "FirmataClass"
        }, 
        "HAL_RCC_OscConfig": {
            "renaming": {}, 
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nHAL_StatusTypeDef_conflict HAL_RCC_OscConfig(RCC_OscInitTypeDef_conflict *RCC_OscInitStruct)\n\n{\n  uint *puVar1;\n  uint *puVar2;\n  HAL_StatusTypeDef_conflict HVar3;\n  uint32_t uVar4;\n  uint32_t uVar5;\n  bool bVar6;\n  uint32_t tmpreg;\n  \n  puVar1 = DAT_08005720;\n  if ((RCC_OscInitStruct->OscillatorType & 1) != 0) {\n    if (((DAT_08005720[1] & 0xc) == 4) ||\n       (((DAT_08005720[1] & 0xc) == 8 && ((DAT_08005720[1] & 0x10000) != 0)))) {\n      if (((*DAT_08005720 & 0x20000) != 0) && (RCC_OscInitStruct->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      uVar5 = RCC_OscInitStruct->HSEState;\n      if (uVar5 == 0x10000) {\n        *DAT_08005720 = *DAT_08005720 | 0x10000;\n      }\n      else if (uVar5 == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (uVar5 == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        *DAT_08005720 = *DAT_08005720 & 0xfffeffff;\n        *puVar1 = *puVar1 & 0xfffbffff;\n      }\n      if (RCC_OscInitStruct->HSEState == 0) {\n        uVar5 = HAL_GetTick();\n        while ((*DAT_08005720 & 0x20000) != 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar5) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        uVar5 = HAL_GetTick();\n        while ((*DAT_08005720 & 0x20000) == 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar5) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 2) != 0) {\n    if (((DAT_08005720[1] & 0xc) == 0) ||\n       (((DAT_08005720[1] & 0xc) == 8 && ((DAT_08005720[1] & 0x10000) == 0)))) {\n      if (((*DAT_08005720 & 2) != 0) && (RCC_OscInitStruct->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      *DAT_08005720 = *DAT_08005720 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n    else if (RCC_OscInitStruct->HSIState == 0) {\n      *DAT_08005724 = 0;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_08005720 & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005724 = 1;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_08005720 & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_08005720 = *DAT_08005720 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 8) != 0) {\n    if (RCC_OscInitStruct->LSIState == 0) {\n      *DAT_08005728 = 0;\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[9] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005728 = 1;\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[9] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 4) != 0) {\n    bVar6 = (DAT_08005720[7] & 0x10000000) == 0;\n    if (bVar6) {\n      DAT_08005720[7] = DAT_08005720[7] | 0x10000000;\n    }\n    if ((*DAT_0800572c & 0x100) == 0) {\n      *DAT_0800572c = *DAT_0800572c | 0x100;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_0800572c & 0x100) == 0) {\n        uVar4 = HAL_GetTick();\n        if (100 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    puVar2 = DAT_08005838;\n    puVar1 = DAT_08005720;\n    uVar5 = RCC_OscInitStruct->LSEState;\n    if (uVar5 == 1) {\n      DAT_08005720[8] = DAT_08005720[8] | 1;\n    }\n    else if (uVar5 == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (uVar5 == 5) {\n      DAT_08005838[8] = DAT_08005838[8] | 4;\n      puVar2[8] = puVar2[8] | 1;\n    }\n    else {\n      DAT_08005720[8] = DAT_08005720[8] & 0xfffffffe;\n      puVar1[8] = puVar1[8] & 0xfffffffb;\n    }\n    if (RCC_OscInitStruct->LSEState == 0) {\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005838[8] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[8] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (bVar6) {\n      DAT_08005838[7] = DAT_08005838[7] & 0xefffffff;\n    }\n  }\n  uVar5 = (RCC_OscInitStruct->PLL).PLLState;\n  if (uVar5 == 0) {\n    HVar3 = HAL_OK;\n  }\n  else if ((DAT_08005838[1] & 0xc) == 8) {\n    HVar3 = HAL_ERROR;\n  }\n  else if (uVar5 == 2) {\n    *DAT_0800583c = 0;\n    uVar5 = HAL_GetTick();\n    do {\n      if ((*DAT_08005838 & 0x2000000) == 0) {\n        if ((RCC_OscInitStruct->PLL).PLLSource == 0x10000) {\n          DAT_08005838[1] = DAT_08005838[1] & 0xfffdffff | RCC_OscInitStruct->HSEPredivValue;\n        }\n        DAT_08005838[1] =\n             DAT_08005838[1] & 0xffc2ffff |\n             (RCC_OscInitStruct->PLL).PLLSource | (RCC_OscInitStruct->PLL).PLLMUL;\n        *DAT_0800583c = 1;\n        uVar5 = HAL_GetTick();\n        do {\n          if ((*DAT_08005838 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          uVar4 = HAL_GetTick();\n        } while (uVar4 - uVar5 < 3);\n        return HAL_TIMEOUT;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar5 < 3);\n    HVar3 = HAL_TIMEOUT;\n  }\n  else {\n    *DAT_0800583c = 0;\n    uVar5 = HAL_GetTick();\n    do {\n      if ((*DAT_08005838 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar5 < 3);\n    HVar3 = HAL_TIMEOUT;\n  }\n  return HVar3;\n}\n\n", 
            "called": [
                "RCC_Delay", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005460", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_OscConfig"
        }, 
        "HAL_TIMEx_CommutationCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080064ac", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIMEx_CommutationCallback"
        }, 
        "I2C_Slave_AF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_Slave_AF(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  if (((hi2c->XferOptions == 4) || (hi2c->XferOptions == 8)) &&\n     (hi2c->State == HAL_I2C_STATE_LISTEN)) {\n    hi2c->XferOptions = DAT_08004b7c;\n    hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n    hi2c->Instance->SR1 = 0xfffffbff;\n    hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n    hi2c->PreviousState = 0;\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(hi2c);\n  }\n  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX) {\n    hi2c->XferOptions = DAT_08004b7c;\n    hi2c->PreviousState = 0x21;\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n    hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n    hi2c->Instance->SR1 = 0xfffffbff;\n    hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(hi2c);\n  }\n  else {\n    hi2c->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_ListenCpltCallback", 
                "HAL_I2C_SlaveTxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004aec", 
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Slave_AF"
        }, 
        "I2C_ITError": {
            "renaming": {}, 
            "code": "\nvoid I2C_ITError(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint8_t *puVar2;\n  I2C_TypeDef_conflict *pIVar3;\n  \n  if ((byte)hi2c->State - 0x29 < 2) {\n    hi2c->PreviousState = 0;\n    hi2c->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((hi2c->State != HAL_I2C_STATE_ABORT) && ((hi2c->Instance->CR2 & 0x800) == 0)) {\n      hi2c->State = HAL_I2C_STATE_READY;\n    }\n    hi2c->PreviousState = 0;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n  }\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffff7ff;\n  pIVar3 = hi2c->Instance;\n  if ((pIVar3->CR2 & 0x800) == 0) {\n    if (hi2c->State == HAL_I2C_STATE_ABORT) {\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->ErrorCode = 0;\n      if ((pIVar3->SR1 & 0x40) != 0) {\n        puVar2 = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = puVar2 + 1;\n        *puVar2 = (uint8_t)pIVar3->DR;\n      }\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(hi2c);\n    }\n    else {\n      if ((pIVar3->SR1 & 0x40) != 0) {\n        puVar2 = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = puVar2 + 1;\n        *puVar2 = (uint8_t)pIVar3->DR;\n      }\n      HAL_I2C_ErrorCallback(hi2c);\n    }\n  }\n  else {\n    pIVar3->CR2 = pIVar3->CR2 & 0xfffff7ff;\n    if (hi2c->hdmatx->State == HAL_DMA_STATE_READY) {\n      hi2c->hdmarx->XferAbortCallback = DAT_0800507c;\n      HVar1 = HAL_DMA_Abort_IT(hi2c->hdmarx);\n      if (HVar1 != HAL_OK) {\n        if ((hi2c->Instance->SR1 & 0x40) != 0) {\n          puVar2 = hi2c->pBuffPtr;\n          hi2c->pBuffPtr = puVar2 + 1;\n          *puVar2 = (uint8_t)hi2c->Instance->DR;\n        }\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n        hi2c->State = HAL_I2C_STATE_READY;\n        (*hi2c->hdmarx->XferAbortCallback)(hi2c->hdmarx);\n      }\n    }\n    else {\n      hi2c->hdmatx->XferAbortCallback = DAT_0800507c;\n      HVar1 = HAL_DMA_Abort_IT(hi2c->hdmatx);\n      if (HVar1 != HAL_OK) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n        hi2c->State = HAL_I2C_STATE_READY;\n        (*hi2c->hdmatx->XferAbortCallback)(hi2c->hdmatx);\n      }\n    }\n  }\n  if ((hi2c->State == HAL_I2C_STATE_LISTEN) && ((hi2c->ErrorCode & 4) != 0)) {\n    hi2c->XferOptions = DAT_08005080;\n    hi2c->PreviousState = 0;\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(hi2c);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_AbortCpltCallback", 
                "HAL_I2C_ListenCpltCallback", 
                "HAL_DMA_Abort_IT", 
                "HAL_I2C_ErrorCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004f3c", 
            "calling": [
                "I2C_Slave_STOPF", 
                "HAL_I2C_ER_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_ITError"
        }, 
        "_malloc_r": {
            "renaming": {}, 
            "code": "\nuint _malloc_r(undefined4 *param_1,uint param_2)\n\n{\n  undefined *puVar1;\n  undefined4 uVar2;\n  uint *puVar3;\n  int iVar4;\n  uint *puVar5;\n  uint uVar6;\n  uint *puVar7;\n  uint uVar8;\n  \n  uVar8 = (param_2 + 3 & 0xfffffffc) + 8;\n  if (uVar8 < 0xc) {\n    uVar8 = 0xc;\n  }\n  if (((int)uVar8 < 0) || (uVar8 < param_2)) {\n    *param_1 = 0xc;\n  }\n  else {\n    __malloc_lock();\n    puVar1 = PTR___malloc_sbrk_start_08009328;\n    puVar3 = *(uint **)PTR___malloc_free_list_08009324;\n    puVar7 = *(uint **)PTR___malloc_free_list_08009324;\n    while (puVar5 = puVar3, puVar5 != (uint *)0x0) {\n      uVar6 = *puVar5 - uVar8;\n      if (-1 < (int)uVar6) {\n        if (uVar6 < 0xc) {\n          if (puVar7 == puVar5) {\n            uVar8 = puVar7[1];\n            *(uint *)PTR___malloc_free_list_08009324 = uVar8;\n          }\n          else {\n            uVar8 = puVar5[1];\n          }\n          if (puVar7 != puVar5) {\n            puVar7[1] = uVar8;\n            puVar7 = puVar5;\n          }\n        }\n        else {\n          *puVar5 = uVar6;\n          *(uint *)((int)puVar5 + uVar6) = uVar8;\n          puVar7 = (uint *)((int)puVar5 + uVar6);\n        }\n        goto LAB_080092d4;\n      }\n      puVar7 = puVar5;\n      puVar3 = (uint *)puVar5[1];\n    }\n    if (*(int *)PTR___malloc_sbrk_start_08009328 == 0) {\n      uVar2 = _sbrk_r(param_1);\n      *(undefined4 *)puVar1 = uVar2;\n    }\n    puVar3 = (uint *)_sbrk_r(param_1,uVar8);\n    if ((puVar3 != (uint *)0xffffffff) &&\n       ((puVar7 = (uint *)((int)puVar3 + 3U & 0xfffffffc), puVar3 == puVar7 ||\n        (iVar4 = _sbrk_r(param_1,(int)puVar7 - (int)puVar3), iVar4 != -1)))) {\n      *puVar7 = uVar8;\nLAB_080092d4:\n      __malloc_unlock(param_1);\n      uVar8 = (int)puVar7 + 0xbU & 0xfffffff8;\n      iVar4 = uVar8 - (int)(puVar7 + 1);\n      if (iVar4 != 0) {\n        *(int *)((int)puVar7 + iVar4) = -iVar4;\n        return uVar8;\n      }\n      return uVar8;\n    }\n    *param_1 = 0xc;\n    __malloc_unlock(param_1);\n  }\n  return 0;\n}\n\n", 
            "called": [
                "__malloc_lock", 
                "__malloc_unlock", 
                "_sbrk_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009270", 
            "calling": [
                "malloc", 
                "__smakebuf_r", 
                "__sfmoreglue", 
                "_realloc_r"
            ], 
            "imported": false, 
            "current_name": "_malloc_r"
        }, 
        "staticReportVersionCallback": {
            "renaming": {}, 
            "code": "\nvoid firmata::FirmataClass::staticReportVersionCallback(void *context)\n\n{\n  if (context != (void *)0x0) {\n    printVersion((FirmataClass *)context);\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "printVersion"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002dea", 
            "calling": [], 
            "imported": false, 
            "current_name": "staticReportVersionCallback"
        }, 
        "staticReportDigitalCallback": {
            "renaming": {}, 
            "code": "\nvoid firmata::FirmataClass::staticReportDigitalCallback\n               (void *param_1,uint8_t command,uint16_t value)\n\n{\n  if (*(code **)PTR_currentReportDigitalCallback_08002ca0 != (code *)0x0) {\n    (**(code **)PTR_currentReportDigitalCallback_08002ca0)(command,value);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002c90", 
            "calling": [], 
            "imported": false, 
            "current_name": "staticReportDigitalCallback"
        }, 
        "__swrite": {
            "renaming": {}, 
            "code": "\nvoid __swrite(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x17) < 0) {\n    _lseek_r(param_1,(int)*(short *)(param_2 + 0xe),0,2);\n  }\n  *(ushort *)(param_2 + 0xc) = *(ushort *)(param_2 + 0xc) & 0xefff;\n  _write_r(param_1,(int)*(short *)(param_2 + 0xe),param_3,param_4);\n  return;\n}\n\n", 
            "called": [
                "_write_r", 
                "_lseek_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a042", 
            "calling": [], 
            "imported": false, 
            "current_name": "__swrite"
        }, 
        "HAL_I2C_MemRxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004d6a", 
            "calling": [
                "I2C_MasterReceive_BTF", 
                "I2C_MasterReceive_RXNE"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_MemRxCpltCallback"
        }, 
        "HAL_GPIO_WritePin": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin,GPIO_PinState PinState)\n\n{\n  if (PinState == GPIO_PIN_RESET) {\n    GPIOx->BSRR = (uint)GPIO_Pin << 0x10;\n    return;\n  }\n  GPIOx->BSRR = (uint)GPIO_Pin;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080042e2", 
            "calling": [
                "digital_io_write"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_WritePin"
        }, 
        "HAL_ADC_GetValue": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_ADC_GetValue(ADC_HandleTypeDef *hadc)\n\n{\n  return hadc->Instance->DR;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080038dc", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_GetValue"
        }, 
        "premain": {
            "renaming": {}, 
            "code": "\nvoid premain(void)\n\n{\n  EVP_PKEY_CTX *ctx;\n  \n  ctx = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(ctx);\n  return;\n}\n\n", 
            "called": [
                "HAL_NVIC_SetPriorityGrouping", 
                "init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008f0e", 
            "calling": [
                "__libc_init_array"
            ], 
            "imported": false, 
            "current_name": "premain"
        }, 
        "HAL_TIM_OC_Start_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_TIM_OC_Start_IT(TIM_HandleTypeDef_conflict *htim,uint32_t Channel)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  switch(Channel) {\n  case 0:\n    htim->Instance->DIER = htim->Instance->DIER | 2;\n    break;\n  case 4:\n    htim->Instance->DIER = htim->Instance->DIER | 4;\n    break;\n  case 8:\n    htim->Instance->DIER = htim->Instance->DIER | 8;\n    break;\n  case 0xc:\n    htim->Instance->DIER = htim->Instance->DIER | 0x10;\n  }\n  TIM_CCxChannelCmd(htim->Instance,Channel,1);\n  pTVar1 = htim->Instance;\n  if (pTVar1 == DAT_080062f0) {\n    pTVar1->BDTR = pTVar1->BDTR | 0x8000;\n  }\n  htim->Instance->CR1 = htim->Instance->CR1 | 1;\n  return HAL_OK;\n}\n\n", 
            "called": [
                "TIM_CCxChannelCmd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006280", 
            "calling": [
                "TimerPulseInit"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_OC_Start_IT"
        }, 
        "HAL_TIM_OC_MspInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_OC_MspInit(TIM_HandleTypeDef_conflict *htim)\n\n{\n  timer_enable_clock(htim);\n  return;\n}\n\n", 
            "called": [
                "timer_enable_clock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007708", 
            "calling": [
                "HAL_TIM_OC_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_OC_MspInit"
        }, 
        "wireRead": {
            "renaming": {}, 
            "code": "\nbyte wireRead(void)\n\n{\n  ssize_t sVar1;\n  int in_r1;\n  void *in_r2;\n  size_t in_r3;\n  \n  sVar1 = TwoWire::read((TwoWire *)PTR_Wire_08001c14,in_r1,in_r2,in_r3);\n  return (byte)sVar1;\n}\n\n", 
            "called": [
                "read"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001c08", 
            "calling": [
                "readAndReportData"
            ], 
            "imported": false, 
            "current_name": "wireRead"
        }, 
        "staticReportAnalogCallback": {
            "renaming": {}, 
            "code": "\nvoid firmata::FirmataClass::staticReportAnalogCallback(void *param_1,uint8_t command,uint16_t value)\n\n{\n  if (*(code **)PTR_currentReportAnalogCallback_08002c8c != (code *)0x0) {\n    (**(code **)PTR_currentReportAnalogCallback_08002c8c)(command,value);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002c7c", 
            "calling": [], 
            "imported": false, 
            "current_name": "staticReportAnalogCallback"
        }, 
        "__swbuf_r": {
            "renaming": {}, 
            "code": "\nuint __swbuf_r(int param_1,uint param_2,int *param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined *puVar3;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_3 == (int *)PTR___sf_fake_stdin_08009a74) {\n    param_3 = *(int **)(param_1 + 4);\n  }\n  else if (param_3 == (int *)PTR___sf_fake_stdout_08009a78) {\n    param_3 = *(int **)(param_1 + 8);\n  }\n  else if (param_3 == (int *)PTR___sf_fake_stderr_08009a7c) {\n    param_3 = *(int **)(param_1 + 0xc);\n  }\n  param_3[2] = param_3[6];\n  uVar2 = (uint)*(ushort *)(param_3 + 3);\n  iVar1 = uVar2 << 0x1c;\n  if (((iVar1 < 0) && (uVar2 = param_3[4], uVar2 != 0)) ||\n     (iVar1 = __swsetup_r(param_1,param_3,iVar1,uVar2,param_4), iVar1 == 0)) {\n    param_2 = param_2 & 0xff;\n    iVar1 = *param_3 - param_3[4];\n    if ((iVar1 < param_3[5]) || (iVar1 = _fflush_r(param_1,param_3), iVar1 == 0)) {\n      param_3[2] = param_3[2] + -1;\n      puVar3 = (undefined *)*param_3;\n      *param_3 = (int)(puVar3 + 1);\n      *puVar3 = (char)param_2;\n      if (iVar1 + 1 != param_3[5]) {\n        if (-1 < (int)((uint)*(ushort *)(param_3 + 3) << 0x1f)) {\n          return param_2;\n        }\n        if (param_2 != 10) {\n          return param_2;\n        }\n      }\n      iVar1 = _fflush_r(param_1,param_3);\n      if (iVar1 == 0) {\n        return param_2;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n", 
            "called": [
                "__swsetup_r", 
                "__sinit", 
                "_fflush_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080099dc", 
            "calling": [
                "__sfputc_r"
            ], 
            "imported": false, 
            "current_name": "__swbuf_r"
        }, 
        "readAndReportData": {
            "renaming": {}, 
            "code": "\nvoid readAndReportData(byte address,int theRegister,byte numBytes,byte stopTX)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  byte bVar3;\n  int iVar4;\n  int iVar5;\n  uint uVar6;\n  \n  puVar2 = PTR_Wire_08001cbc;\n  uVar6 = (uint)numBytes;\n  if (theRegister == -1) {\n    theRegister = 0;\n  }\n  else {\n    TwoWire::beginTransmission((TwoWire *)PTR_Wire_08001cbc,address);\n    wireWrite((byte)theRegister);\n    TwoWire::endTransmission((TwoWire *)puVar2,stopTX);\n  }\n  puVar2 = PTR_Wire_08001cbc;\n  TwoWire::requestFrom((TwoWire *)PTR_Wire_08001cbc,address,numBytes);\n  iVar4 = TwoWire::available((TwoWire *)puVar2);\n  if ((int)uVar6 < iVar4) {\n    firmata::FirmataClass::sendString\n              ((FirmataClass *)PTR_Firmata_08001cc4,PTR_s_I2C__Too_many_bytes_received_08001cc0);\n  }\n  else {\n    iVar4 = TwoWire::available((TwoWire *)PTR_Wire_08001cbc);\n    if (iVar4 < (int)uVar6) {\n      firmata::FirmataClass::sendString\n                ((FirmataClass *)PTR_Firmata_08001cc4,PTR_s_I2C__Too_few_bytes_received_08001ccc);\n    }\n  }\n  puVar2 = PTR_i2cRxData_08001cc8;\n  *PTR_i2cRxData_08001cc8 = address;\n  puVar2[1] = (char)theRegister;\n  iVar4 = 0;\n  while( true ) {\n    if (iVar4 < (int)uVar6) {\n      iVar5 = TwoWire::available((TwoWire *)PTR_Wire_08001cbc);\n      if (iVar5 == 0) {\n        bVar1 = false;\n      }\n      else {\n        bVar1 = true;\n      }\n    }\n    else {\n      bVar1 = false;\n    }\n    if (!bVar1) break;\n    bVar3 = wireRead();\n    PTR_i2cRxData_08001cc8[iVar4 + 2] = bVar3;\n    iVar4 = iVar4 + 1;\n  }\n  firmata::FirmataClass::sendSysex\n            ((FirmataClass *)PTR_Firmata_08001cc4,'w',numBytes + '\\x02',PTR_i2cRxData_08001cc8);\n  return;\n}\n\n", 
            "called": [
                "wireRead", 
                "sendString", 
                "requestFrom", 
                "available", 
                "wireWrite", 
                "beginTransmission", 
                "endTransmission", 
                "sendSysex"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001c18", 
            "calling": [
                "loop", 
                "sysexCallback"
            ], 
            "imported": false, 
            "current_name": "readAndReportData"
        }, 
        "printNumber": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08008ecc */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nsize_t __thiscall Print::printNumber(Print *this,ulong n,uint8_t base)\n\n{\n  char cVar1;\n  size_t sVar2;\n  size_t sVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  char *__s;\n  char buf [33];\n  \n  uVar5 = (uint)base;\n  buf[32] = '\\0';\n  if (uVar5 < 2) {\n    uVar5 = 10;\n  }\n  __s = buf + 0x20;\n  do {\n    uVar6 = n / uVar5;\n    uVar4 = (n & 0xff) - (uVar6 * uVar5 & 0xff) & 0xff;\n    __s = __s + -1;\n    cVar1 = (char)uVar4;\n    if (uVar4 < 10) {\n      cVar1 = cVar1 + '0';\n    }\n    else {\n      cVar1 = cVar1 + '7';\n    }\n    *__s = cVar1;\n    n = uVar6;\n  } while (uVar6 != 0);\n  if (__s == (char *)0x0) {\n    sVar3 = 0;\n  }\n  else {\n    sVar2 = strlen(__s);\n    sVar3 = (*this->_vptr_Print[1])(sVar2,__s,sVar2);\n  }\n  return sVar3;\n}\n\n", 
            "called": [
                "strlen"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008e7c", 
            "calling": [
                "print"
            ], 
            "imported": false, 
            "current_name": "printNumber"
        }, 
        "i2c_slave_write_IT": {
            "renaming": {}, 
            "code": "\ni2c_status_e_conflict i2c_slave_write_IT(i2c_t_conflict *obj,uint8_t *data,uint16_t size)\n\n{\n  uint uVar1;\n  \n  if (0x20 < size) {\n    return I2C_ERROR;\n  }\n  for (uVar1 = 0; uVar1 < size; uVar1 = uVar1 + 1 & 0xff) {\n    obj->i2cTxRxBuffer[uVar1] = data[uVar1];\n    obj->i2cTxRxBufferSize = obj->i2cTxRxBufferSize + '\\x01';\n  }\n  return I2C_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007ede", 
            "calling": [
                "write", 
                "write"
            ], 
            "imported": false, 
            "current_name": "i2c_slave_write_IT"
        }, 
        "HAL_ADC_PollForConversion": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_ADC_PollForConversion(ADC_HandleTypeDef *hadc,uint32_t Timeout)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  int iVar4;\n  ADC_TypeDef *pAVar5;\n  uint uVar6;\n  uint32_t Conversion_Timeout_CPU_cycles;\n  \n  Conversion_Timeout_CPU_cycles = 0;\n  uVar2 = HAL_GetTick();\n  pAVar5 = hadc->Instance;\n  if ((pAVar5->CR2 & 0x100) == 0) {\n    if (((pAVar5->CR1 & 0x100) == 0) && ((pAVar5->SQR1 & 0xf00000) == 0)) {\n      do {\n        if ((hadc->Instance->SR & 2) != 0) goto LAB_0800387e;\n      } while ((Timeout == 0xffffffff) ||\n              ((Timeout != 0 && (uVar3 = HAL_GetTick(), uVar3 - uVar2 <= Timeout))));\n      hadc->State = hadc->State | 4;\n      hadc->Lock = HAL_UNLOCKED;\n      HVar1 = HAL_TIMEOUT;\n    }\n    else {\n      uVar6 = *(uint *)PTR_SystemCoreClock_080038c8;\n      uVar3 = HAL_RCCEx_GetPeriphCLKFreq(2);\n      pAVar5 = hadc->Instance;\n      if (((pAVar5->SMPR2 & DAT_080038cc) == 0) &&\n         ((pAVar5->SMPR1 & DAT_080038cc + 0xdc000000) == 0)) {\n        if ((pAVar5->SMPR2 & DAT_080038d0) == 0) {\n          if ((pAVar5->SMPR1 & DAT_080038d4) == 0) {\n            iVar4 = 0x14;\n          }\n          else {\n            iVar4 = 0x29;\n          }\n        }\n        else {\n          iVar4 = 0x29;\n        }\n      }\n      else if (((pAVar5->SMPR2 & DAT_080038d0) == 0) &&\n              ((pAVar5->SMPR1 & DAT_080038d0 + 0xee000000) == 0)) {\n        iVar4 = 0x54;\n      }\n      else if ((DAT_080038d8 & pAVar5->SMPR2) == 0) {\n        if ((DAT_080038d8 & pAVar5->SMPR1) == 0) {\n          iVar4 = 0x54;\n        }\n        else {\n          iVar4 = 0xfc;\n        }\n      }\n      else {\n        iVar4 = 0xfc;\n      }\n      uVar6 = (uVar6 / uVar3) * iVar4;\n      for (; Conversion_Timeout_CPU_cycles <= uVar6 && uVar6 - Conversion_Timeout_CPU_cycles != 0;\n          Conversion_Timeout_CPU_cycles = Conversion_Timeout_CPU_cycles + 1) {\n        if ((Timeout != 0xffffffff) &&\n           ((Timeout == 0 || (uVar3 = HAL_GetTick(), Timeout < uVar3 - uVar2)))) {\n          hadc->State = hadc->State | 4;\n          hadc->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nLAB_0800387e:\n      hadc->Instance->SR = 0xffffffed;\n      hadc->State = hadc->State | 0x200;\n      if ((hadc->Instance->CR2 & 0xe0000) == 0xe0000) {\n        if ((hadc->Init).ContinuousConvMode == 0) {\n          hadc->State = hadc->State & 0xfffffeff;\n          if ((hadc->State & 0x1000) == 0) {\n            hadc->State = hadc->State | 1;\n            HVar1 = HAL_OK;\n          }\n          else {\n            HVar1 = HAL_OK;\n          }\n        }\n        else {\n          HVar1 = HAL_OK;\n        }\n      }\n      else {\n        HVar1 = HAL_OK;\n      }\n    }\n  }\n  else {\n    hadc->State = hadc->State | 0x20;\n    hadc->Lock = HAL_UNLOCKED;\n    HVar1 = HAL_ERROR;\n  }\n  return HVar1;\n}\n\n", 
            "called": [
                "HAL_RCCEx_GetPeriphCLKFreq", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800376c", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_PollForConversion"
        }, 
        "__tcf_0": {
            "renaming": {}, 
            "code": "\nvoid __tcf_0(void *param_1)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  \n  puVar1 = PTR___malloc_free_list_08008f70;\n  while (puVar2 = puVar1, puVar2 != PTR_gpio_irq_conf_08008f74) {\n    puVar1 = puVar2 + -0x14;\n    if (*(code **)(puVar2 + -8) != (code *)0x0) {\n      (**(code **)(puVar2 + -8))(puVar2 + -0x10,puVar2 + -0x10,3);\n    }\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008f50", 
            "calling": [], 
            "imported": false, 
            "current_name": "__tcf_0"
        }, 
        "__do_global_dtors_aux": {
            "renaming": {}, 
            "code": "\nundefined * __do_global_dtors_aux(undefined *param_1)\n\n{\n  if (*PTR_completed_8667_08000124 == '\\0') {\n    if (DAT_08000128 != 0) {\n      param_1 = PTR__init_0800012c;\n    }\n    *PTR_completed_8667_08000124 = 1;\n  }\n  return param_1;\n}\n\n", 
            "called": [
                "_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800010c", 
            "calling": [], 
            "imported": false, 
            "current_name": "__do_global_dtors_aux"
        }, 
        "HAL_GPIO_ReadPin": {
            "renaming": {}, 
            "code": "\nGPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin)\n\n{\n  if (((uint)GPIO_Pin & GPIOx->IDR) == 0) {\n    return GPIO_PIN_RESET;\n  }\n  return GPIO_PIN_SET;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080042d4", 
            "calling": [
                "digital_io_read"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_ReadPin"
        }, 
        "strncpy": {
            "renaming": {}, 
            "code": "\nchar * strncpy(char *__dest,char *__src,size_t __n)\n\n{\n  char cVar1;\n  size_t sVar2;\n  char *pcVar3;\n  char *pcVar4;\n  \n  pcVar3 = __dest;\n  do {\n    pcVar4 = pcVar3;\n    sVar2 = __n;\n    if (sVar2 == 0) {\n      return __dest;\n    }\n    cVar1 = *__src;\n    pcVar3 = pcVar4 + 1;\n    *pcVar4 = cVar1;\n    __src = __src + 1;\n    __n = sVar2 - 1;\n  } while (cVar1 != '\\0');\n  for (; pcVar3 != pcVar4 + sVar2; pcVar3 = pcVar3 + 1) {\n    *pcVar3 = '\\0';\n  }\n  return __dest;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009954", 
            "calling": [
                "setFirmwareNameAndVersion"
            ], 
            "imported": false, 
            "current_name": "strncpy"
        }, 
        "_fini": {
            "renaming": {}, 
            "code": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a430", 
            "calling": [], 
            "imported": false, 
            "current_name": "_fini"
        }, 
        "HAL_I2C_MasterRxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004a20", 
            "calling": [
                "I2C_MasterReceive_BTF", 
                "I2C_MasterReceive_RXNE"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_MasterRxCpltCallback"
        }, 
        "digitalWrite": {
            "renaming": {}, 
            "code": "\nvoid digitalWrite(uint32_t ulPin,uint32_t ulVal)\n\n{\n  _Bool _Var1;\n  GPIO_TypeDef *port;\n  uint uVar2;\n  \n  if (ulPin < 0x3c) {\n    uVar2 = (uint)(char)PTR_digitalPin_08008a64[ulPin];\n  }\n  else {\n    uVar2 = 0xffffffff;\n  }\n  if ((uVar2 != 0xffffffff) &&\n     (_Var1 = is_pin_configured((PinName_conflict)uVar2,(uint32_t *)PTR_g_digPinConfigured_08008a68)\n     , _Var1)) {\n    port = get_GPIO_Port((uVar2 << 0x18) >> 0x1c);\n    digital_io_write(port,1 << (uVar2 & 0xf) & 0xffff,ulVal);\n  }\n  return;\n}\n\n", 
            "called": [
                "is_pin_configured", 
                "get_GPIO_Port", 
                "digital_io_write"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008a24", 
            "calling": [
                "setPinModeCallback", 
                "digitalWriteCallback", 
                "strobeBlinkPin", 
                "setPinValueCallback", 
                "analogWrite", 
                "ServoIrqHandle"
            ], 
            "imported": false, 
            "current_name": "digitalWrite"
        }, 
        "detach": {
            "renaming": {}, 
            "code": "\nvoid __thiscall Servo::detach(Servo *this)\n\n{\n  boolean bVar1;\n  uint uVar2;\n  \n  uVar2 = (uint)this->servoIndex;\n  PTR_servos_08002670[uVar2 * 8] = PTR_servos_08002670[uVar2 * 8] & 0xbf;\n  bVar1 = isTimerActive((timer16_Sequence_t)\n                        (uint)((ulonglong)DAT_08002674 * (ulonglong)uVar2 >> 0x23));\n  if (!bVar1) {\n    finISR((stimer_t *)PTR__timer_08002678);\n  }\n  return;\n}\n\n", 
            "called": [
                "finISR", 
                "isTimerActive"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002644", 
            "calling": [
                "detachServo"
            ], 
            "imported": false, 
            "current_name": "detach"
        }, 
        "serialEventRun": {
            "renaming": {}, 
            "code": "\nvoid serialEventRun(void)\n\n{\n  if (DAT_08008c18 != 0) {\n    HardwareSerial::available((HardwareSerial *)PTR_Serial2_08008c1c);\n  }\n  return;\n}\n\n", 
            "called": [
                "available"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008bf4", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "serialEventRun"
        }, 
        "_fflush_r": {
            "renaming": {}, 
            "code": "\nundefined4 _fflush_r(int param_1,undefined *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uVar1;\n  \n  if (*(int *)(param_2 + 0x10) != 0) {\n    if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n      __sinit();\n    }\n    if (param_2 == PTR___sf_fake_stdin_08009cc4) {\n      param_2 = *(undefined **)(param_1 + 4);\n    }\n    else if (param_2 == PTR___sf_fake_stdout_08009cc8) {\n      param_2 = *(undefined **)(param_1 + 8);\n    }\n    else if (param_2 == PTR___sf_fake_stderr_08009ccc) {\n      param_2 = *(undefined **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 0xc) != 0) {\n      uVar1 = __sflush_r(param_1,param_2,param_3,param_4);\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n", 
            "called": [
                "__sinit", 
                "__sflush_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009c7c", 
            "calling": [
                "__swbuf_r"
            ], 
            "imported": false, 
            "current_name": "_fflush_r"
        }, 
        "HAL_NVIC_EnableIRQ": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_EnableIRQ(IRQn_Type_conflict IRQn)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)IRQn;\n  if (-1 < (int)uVar1) {\n    *(int *)(DAT_08003fac + (uVar1 >> 5) * 4) = 1 << (uVar1 & 0x1f);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003f94", 
            "calling": [
                "uart_attach_tx_callback", 
                "i2c_custom_init", 
                "uart_attach_rx_callback", 
                "TimerPulseInit"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_EnableIRQ"
        }, 
        "TIM1_UP_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM1_UP_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef_conflict **)PTR_timer_handles_08007770 !=\n      (TIM_HandleTypeDef_conflict *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef_conflict **)PTR_timer_handles_08007770);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007760", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM1_UP_IRQHandler"
        }
    }, 
    "locked_functions": [], 
    "used_tokens": 0, 
    "layers": []
}