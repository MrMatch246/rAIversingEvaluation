{
    "functions": {
        "FUN_000816a6": {
            "renaming": {
                "FUN_000816a6": "do_nothing_000816a6"
            },
            "code": "\nvoid do_nothing_000816a6(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000816a6",
            "calling": [
                "FUN_000816a8"
            ],
            "imported": false,
            "current_name": "do_nothing_000816a6"
        },
        "FUN_000816a8": {
            "renaming": {
                "FUN_000816a8": "initialize_and_execute_process_000816a8",
                "set_default_value_of_pointer_000816d4": "set_default_value_of_pointer",
                "initialize_and_execute_00080ae4": "initialize_and_execute",
                "do_nothing_000816a6": "do_nothing",
                "do_nothing_0008120c": "do_nothing_with_parameter",
                "process_data_and_set_values_000804a8": "process_data_and_set_values",
                "FUN_000805d0": "execute_function",
                "DAT_000816d0": "data_check",
                "check_differences_00080ce0": "check_for_differences"
            },
            "code": "void initialize_and_execute_process_000816a8() {\n  set_default_value_of_pointer();\n  initialize_and_execute();\n  do_nothing();\n  do_nothing_with_parameter(1);\n  process_data_and_set_values();\n  do {\n    do {\n      execute_function();\n    } while (DAT_000816d0 == 0);\n    check_for_differences();\n  } while(true);\n}",
            "called": [
                "FUN_00080ae4",
                "FUN_000804a8",
                "FUN_0008120c",
                "FUN_000816d4",
                "FUN_000816a6",
                "FUN_00080ce0",
                "FUN_000805d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000816a8",
            "calling": [
                "FUN_00080f24"
            ],
            "imported": false,
            "current_name": "initialize_and_execute_process_000816a8"
        },
        "FUN_00081042": {
            "renaming": {
                "FUN_00081042": "set_bits_in_register_00081042",
                "param_1": "register_address",
                "param_2": "mask",
                "param_3": "value",
                "param_4": "shift_amount",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "void set_bits_in_register_00081042(int register_address, uint32_t mask, uint32_t value, uint32_t shift_amount)\n{\n    uint32_t* register_ptr = (uint32_t*)(register_address + 4);\n    *register_ptr |= value | ((mask & 0xF) << 0x18) | ((shift_amount & 3) << 0x1C);\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081042",
            "calling": [
                "FUN_00080ae4"
            ],
            "imported": false,
            "current_name": "set_bits_in_register_00081042"
        },
        "FUN_00082ac0": {
            "renaming": {
                "FUN_00082ac0": "process_input_00082ac0",
                "param_1": "input",
                "param_2": "size",
                "param_3": "input_list",
                "piVar1": "current_input",
                "iVar2": "result",
                "piVar3": "remaining_inputs",
                "uVar4": "i",
                "puVar5": "input_start",
                "uVar6": "input_size",
                "uVar7": "input_size",
                "FUN_00083f34": "process_input_00083f34",
                "process_input_00083c40": "process_input_00083c40"
            },
            "code": "int process_input_00082ac0(int input, int size, int **input_list) {\n  int *current_input = *input_list;\n  int *remaining_inputs = input_list[2];\n  while (remaining_inputs != NULL) {\n    uint input_size = current_input[1] >> 2;\n    if (input_size != 0) {\n      undefined4 *input_start = (undefined4 *)(*current_input - 4);\n      uint i = 0;\n      while (i != input_size) {\n        input_start++;\n        int result = process_input_00082ac0_00083c40(input, *input_start, size);\n        i++;\n        if (result == -1) {\n          input_list[2] = NULL;\n          input_list[1] = NULL;\n          return -1;\n        }\n      }\n    }\n    remaining_inputs = (int *)((int)remaining_inputs - (current_input[1] & 0xfffffffc));\n    input_list[2] = remaining_inputs;\n    current_input += 2;\n  }\n  input_list[2] = NULL;\n  input_list[1] = NULL;\n  return 0;\n}",
            "called": [
                "FUN_00083c40",
                "FUN_00083f34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00082ac0",
            "calling": [
                "FUN_00082b38"
            ],
            "imported": false,
            "current_name": "process_input_00082ac0"
        },
        "FUN_00080ce0": {
            "renaming": {
                "FUN_00080ce0": "check_differences_00080ce0",
                "calculate_difference_000813e4": "calculate_difference",
                "PTR_DAT_00080d14": "PTR_DATA_1",
                "PTR_DAT_00080d18": "PTR_DATA_2",
                "PTR_DAT_00080d1c": "PTR_DATA_3",
                "PTR_DAT_00080d20": "PTR_DATA_4",
                "do_nothing_00080aa8": "do_nothing_1",
                "do_nothing_00080ab8": "do_nothing_2",
                "do_nothing_00080aba": "do_nothing_3",
                "do_nothing_00080abc": "do_nothing_4"
            },
            "code": "void check_differences_00080ce0()\n{\n  int difference;\n  difference = calculate_difference(PTR_DAT_00080d14);\n  if (difference != 0) {\n    do_nothing_1();\n  }\n  difference = calculate_difference(PTR_DAT_00080d18);\n  if (difference != 0) {\n    do_nothing_2();\n  }\n  difference = calculate_difference(PTR_DAT_00080d1c);\n  if (difference != 0) {\n    do_nothing_3();\n  }\n  difference = calculate_difference(PTR_DAT_00080d20);\n  if (difference != 0) {\n    do_nothing_4();\n  }\n  return;\n}",
            "called": [
                "FUN_000813e4",
                "FUN_00080abc",
                "FUN_00080ab8",
                "FUN_00080aba",
                "FUN_00080aa8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080ce0",
            "calling": [
                "FUN_000816a8"
            ],
            "imported": false,
            "current_name": "check_differences_00080ce0"
        },
        "FUN_00081682": {
            "renaming": {
                "FUN_00081682": "initialize_array_with_zeroes_00081682",
                "param_1": "array",
                "param_2": "size",
                "uVar1": "count_of_nonzero_bytes"
            },
            "code": "undefined4 *initialize_array_with_zeroes_00081682(undefined4 *array, int size)\n{\n    undefined4 count_of_nonzero_bytes;\n    array[0] = 0;\n    array[1] = 0;\n    array[2] = 0;\n    if (size != 0)\n    {\n        count_of_nonzero_bytes = count_bytes_with_nonzero_00082a50(size);\n        execute_and_check_reset_memory_0008165c_0008165c(array, size, count_of_nonzero_bytes);\n    }\n    return array;\n}",
            "called": [
                "FUN_0008165c",
                "FUN_00082a50"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081682",
            "calling": [
                "FUN_00080a68"
            ],
            "imported": false,
            "current_name": "initialize_array_with_zeroes_00081682"
        },
        "FUN_000815fe": {
            "renaming": {
                "FUN_000815fe": "allocateMemoryBlockAndReturnPointer_000815fe",
                "*param_1": "*memoryBlockSize",
                "allocate_memory_block_00081e04": "allocateMemoryBlock"
            },
            "code": "void allocateMemoryBlockAndReturnPointer_000815fe(int *memoryBlockSize) {\n    allocateMemoryBlock(*memoryBlockSize);\n}\n",
            "called": [
                "FUN_00081e04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000815fe",
            "calling": [],
            "imported": false,
            "current_name": "allocateMemoryBlockAndReturnPointer_000815fe"
        },
        "FUN_00081d1c": {
            "renaming": {
                "FUN_00081d1c": "validate_input_00081d1c",
                "param_1": "input",
                "uVar1": "shift_distance",
                "is_negative": "is_negative",
                "is_valid": "is_valid",
                "shift_amount": "shift_amount",
                "result": "result"
            },
            "code": "uint validate_input_00081d1c(uint input) {\n  uint result;\n  bool is_negative = (input & 0x80000000) != 0;\n  bool is_valid = (input << 1) < 0x7f000000;\n  if (is_negative || !is_valid) {\n    return 0;\n  }\n  uint shift_amount = (input << 1) >> 0x18;\n  uint shift_distance = 0x9e - shift_amount;\n  if (shift_distance >= 0) {\n    result = (input << 8 | 0x80000000) >> (shift_distance & 0xff);\n  } else if (shift_distance == 0xffffff9f && (input & 0x7fffff) != 0) {\n    result = 0;\n  } else {\n    result = 0xffffffff;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081d1c",
            "calling": [
                "FUN_000805d0"
            ],
            "imported": false,
            "current_name": "validate_input_00081d1c"
        },
        "FUN_000847ac": {
            "renaming": {
                "FUN_000847ac": "calculate_difference_000847ac",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "var_1",
                "param_4": "var_2",
                "param_5": "output_array",
                "uVar1": "multiplication_result",
                "lVar2": "func_result"
            },
            "code": "void calculate_difference_000847ac(uint input_1, int input_2, undefined4 var_1, undefined4 var_2, int *output_array)\n{\n  uint multiplication_result;\n  longlong func_result = FUNC_00084a80();\n  multiplication_result = (uint)(func_result * (longlong)var_1 * (longlong)var_2);\n  output_array[0] = input_1 - multiplication_result;\n  output_array[1] = input_2 - (int)(func_result >> 32) - (input_1 < multiplication_result);\n  return;\n}",
            "called": [
                "FUN_00084a80"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000847ac",
            "calling": [
                "FUN_00084750"
            ],
            "imported": false,
            "current_name": "calculate_difference_000847ac"
        },
        "FUN_00080118": {
            "renaming": {
                "FUN_00080118": "execute_function_if_available_00080118",
                "param_1": "param1",
                "param_2": "data",
                "param_3": "param2",
                "param_4": "param3",
                "DAT_00080134": "function_pointer",
                "PTR_DAT_0008013c": "data_pointer",
                "DAT_00080140": "function_pointer",
                "DAT_00080144": "code_address"
            },
            "code": "void execute_function_if_available_00080118(int param1, char* data, int param2, int param3)\n{\n  if (DAT_00080134 != 0)\n  {\n    data = PTR_DAT_0008013c;\n  }\n  if ((*DAT_00080134 != 0) && (DAT_00080144 != (code *)0x0))\n  {\n    (*DAT_00080144)(DAT_00080134, data, param2, DAT_00080144, param3);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080118",
            "calling": [
                "FUN_00081d7c"
            ],
            "imported": false,
            "current_name": "execute_function_if_available_00080118"
        },
        "FUN_00080aa8": {
            "renaming": {
                "FUN_00080aa8": "do_nothing_00080aa8"
            },
            "code": "\nvoid do_nothing_00080aa8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080aa8",
            "calling": [
                "FUN_00080ce0"
            ],
            "imported": false,
            "current_name": "do_nothing_00080aa8"
        },
        "FUN_00081c94": {
            "renaming": {
                "FUN_00081c94": "check_concatenated_params_00081c94",
                "in_CY": "is_CY_false",
                "in_ZR": "is_ZR_true",
                "concatenate_params_00081c5c": "concatenate_params"
            },
            "code": "bool check_concatenated_params_00081c94(void)\n{\n  bool is_CY_false = false;\n  bool is_ZR_true = true;\n  concatenate_params();\n  return !is_CY_false || is_ZR_true;\n}",
            "called": [
                "FUN_00081c5c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081c94",
            "calling": [
                "FUN_000805d0"
            ],
            "imported": false,
            "current_name": "check_concatenated_params_00081c94"
        },
        "FUN_00083b14": {
            "renaming": {
                "FUN_00083b14": "initialize_00083b14",
                "param_1": "config_ptr",
                "puVar1": "undefined_ptr_1",
                "uVar2": "undefined_val",
                "puVar3": "undefined_ptr_2",
                "puVar4": "undefined_ptr_3",
                "puVar5": "config",
                "puVar6": "ptr"
            },
            "code": "void initialize_00083b14(int param_1)\n{\n  if (*(int *)(param_1 + 0x38) == 0) {\n    undefined4 *config = *(undefined4 **)(param_1 + 4);\n    undefined4 *ptr1 = *(undefined4 **)(param_1 + 8);\n    undefined4 *ptr2 = *(undefined4 **)(param_1 + 0xc);\n    config[0] = 0;\n    config[1] = 0;\n    config[2] = 0;\n    config[3] = config;\n    config[4] = 0;\n    config[5] = 0;\n    config[6] = 0;\n    config[7] = config;\n    config[8] = PTR_LAB_00084440_1_00083bf8;\n    config[9] = DAT_00083bfc;\n    config[10] = PTR_set_default_value_0008449c_1_00083c00;\n    config[11] = PTR_LAB_000844bc_1_00083c04;\n    *(undefined2 *)((int)config + 0xe) = 4;\n    *(undefined2 *)(config + 3) = 4;\n    *(undefined4 *)(param_1 + 0x2e0) = 0;\n    *(undefined4 *)(param_1 + 0x2e4) = 3;\n    *(int *)(param_1 + 0x2e8) = param_1 + 0x2ec;\n    fill_memory_with_value_00082504(config + 0x17,0,8);\n    ptr1[0] = 0;\n    ptr1[1] = 0;\n    ptr1[2] = 0;\n    ptr1[3] = ptr1;\n    ptr1[4] = 0;\n    ptr1[5] = 0;\n    ptr1[6] = 0;\n    ptr1[7] = ptr1;\n    ptr1[8] = PTR_LAB_00084440_1_00083bf8;\n    ptr1[9] = DAT_00083bfc;\n    ptr1[10] = PTR_set_default_value_0008449c_1_00083c00;\n    ptr1[11] = PTR_LAB_000844bc_1_00083c04;\n    *(undefined2 *)((int)ptr1 + 0xe) = 1;\n    *(undefined2 *)(ptr1 + 3) = 9;\n    ptr2[0] = 0;\n    ptr2[1] = 0;\n    ptr2[2] = 0;\n    ptr2[3] = ptr2;\n    ptr2[4] = 0;\n    ptr2[5] = 0;\n    ptr2[6] = 0;\n    ptr2[7] = ptr2;\n    ptr2[8] = PTR_LAB_00084440_1_00083bf8;\n    ptr2[9] = DAT_00083bfc;\n    ptr2[10] = PTR_set_default_value_0008449c_1_00083c00;\n    ptr2[11] = PTR_LAB_000844bc_1_00083c04;\n    *(undefined2 *)((int)ptr2 + 0xe) = 2;\n    *(undefined2 *)(ptr2 + 3) = 0x12;\n    *(undefined4 *)(param_1 + 0x38) = 1;\n  }\n  return;\n}",
            "called": [
                "FUN_00082504"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00083b14",
            "calling": [
                "FUN_00083adc",
                "FUN_000844c4",
                "FUN_00083808",
                "FUN_00082b38",
                "FUN_000846a4"
            ],
            "imported": false,
            "current_name": "initialize_00083b14"
        },
        "FUN_000842a4": {
            "renaming": {
                "FUN_000842a4": "checkMemory_000842a4",
                "param_1": "address",
                "param_2": "data",
                "uVar1": "flag",
                "iVar2": "result",
                "iVar3": "memoryResult",
                "uVar4": "flagVal",
                "bVar5": "isFlagged",
                "auStack_54": "localFlag",
                "local_50": "flagValue",
                "PTR_FUN_0008449c_1_00084380": "originalFunction",
                "PTR_LAB_00083b08_1_0008437c": "newFunction"
            },
            "code": "void checkMemory_000842a4(int address, int *data)\n{\n    ushort flag = *(ushort *)(data + 3);\n    uint flagVal = (uint)flag;\n    if ((int)(flagVal << 0x1e) < 0) {\n        *data = (int)data + 0x43;\n        data[4] = (int)data + 0x43;\n        data[5] = 1;\n        return;\n    }\n    if (-1 < *(short *)((int)data + 0xe)) {\n        int result = setMemoryFlag(address, (int)*(short *)((int)data + 0xe), flagVal);\n        if (-1 < result) {\n            bool isFlagged = (localFlag & 0xf000) == 0x2000;\n            if (((localFlag & 0xf000) == 0x8000) && ((undefined *)data[10] == PTR_FUN_0008449c_1_00084380)) {\n                result = 0x400;\n                *(ushort *)(data + 3) = *(ushort *)(data + 3) | 0x400;\n                data[0x13] = 0x400;\n            }\n            else {\n                result = 0x400;\n                *(ushort *)(data + 3) = *(ushort *)(data + 3) | 0x800;\n            }\n            goto LAB_00084300;\n        }\n        flag = *(ushort *)(data + 3);\n        flagVal = (uint)flag;\n    }\n    *(ushort *)(data + 3) = flag | 0x800;\n    int flagValue = (flagVal & 0x80) == 0 ? 0x400 : 0x40;\n    bool isFlagged = false;\n    LAB_00084300:\n    int result = memoryCheck(address, flagValue);\n    flag = *(ushort *)(data + 3);\n    if (result == 0) {\n        if (-1 < (int)((uint)flag << 0x16)) {\n            *(ushort *)(data + 3) = flag | 2;\n            *data = (int)data + 0x43;\n            data[4] = (int)data + 0x43;\n            data[5] = 1;\n        }\n    }\n    else {\n        *(undefined **)(address + 0x3c) = PTR_LAB_00083b08_1_0008437c;\n        *(ushort *)(data + 3) = flag | 0x80;\n        *data = result;\n        data[4] = result;\n        data[5] = flagValue;\n        if ((isFlagged) && (result = getIntegerOrDefault(address, (int)*(short *)((int)data + 0xe)), result != 0)) {\n            *(ushort *)(data + 3) = *(ushort *)(data + 3) | 1;\n        }\n    }\n    return;\n}",
            "called": [
                "FUN_000846b4",
                "FUN_000846dc",
                "FUN_00081e14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000842a4",
            "calling": [
                "FUN_00083808"
            ],
            "imported": false,
            "current_name": "checkMemory_000842a4"
        },
        "FUN_000846a4": {
            "renaming": {
                "FUN_000846a4": "process_data_000846a4",
                "param_1": "data",
                "DAT_000846b0": "PTR_DATA",
                "iVar3": "ptr",
                "initialize_00083b14": "initialize_data",
                "process_data_00083adc": "process_data_subroutine",
                "code": "function_pointer",
                "iVar2": "return_value",
                "allocate_memory_block_00083d9c": "allocate_memory_block",
                "do_nothing_00083c08": "do_nothing1",
                "do_nothing_00083c0c": "do_nothing2"
            },
            "code": "undefined4 process_data_000846a4(int data)\n{\n  undefined4 result;\n  int ptr = *DAT_000846b0;\n  if (data != 0) {\n    if ((ptr != 0) && (*(int *)(ptr + 0x38) == 0)) {\n      initialize_data();\n    }\n    if (*(short *)(data + 0xc) != 0) {\n      result = process_data_000846a4_00083adc(ptr, data);\n      if ((*(code **)(data + 0x2c) != (code *)0x0) && (iVar = (**(code **)(data + 0x2c))(ptr, *(undefined4 *)(data + 0x1c)), iVar < 0)) {\n        result = 0xffffffff;\n      }\n      if ((int)((uint)*(ushort *)(data + 0xc) << 0x18) < 0) {\n        allocate_memory_block(ptr, *(undefined4 *)(data + 0x10));\n      }\n      if (*(int *)(data + 0x30) != 0) {\n        if (*(int *)(data + 0x30) != data + 0x40) {\n          allocate_memory_block(ptr);\n        }\n        *(undefined4 *)(data + 0x30) = 0;\n      }\n      if (*(int *)(data + 0x44) != 0) {\n        allocate_memory_block(ptr);\n        *(undefined4 *)(data + 0x44) = 0;\n      }\n      do_nothing_00083c08();\n      *(undefined2 *)(data + 0xc) = 0;\n      do_nothing_00083c0c();\n      return result;\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_00083adc",
                "FUN_00083b14",
                "FUN_00083d9c",
                "FUN_00083c0c",
                "FUN_00083c08"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000846a4",
            "calling": [],
            "imported": false,
            "current_name": "process_data_000846a4"
        },
        "FUN_00080f24": {
            "renaming": {
                "FUN_00080f24": "initialize_memory_00080f24",
                "puVar1": "rel_array_start",
                "puVar2": "data_start",
                "iVar3": "i",
                "puVar4": "data_end",
                "PTR_Elf32_Rel_ARRAY_00080f80": "rel_array_start",
                "DAT_00080f7c": "data_start",
                "PTR_DAT_00080f84": "data_end",
                "PTR_DAT_00080f88": "rel_array_end",
                "DAT_00080f94": "memory_size",
                "PTR_DAT_00080f90": "data_end_aligned",
                "DAT_00080f98": "function_pointer"
            },
            "code": "void initialize_memory_00080f24(void)\n{\n  undefined *PTR_Elf32_Rel_ARRAY_00080f80 = PTR_Elf32_Rel_ARRAY_00080f80;\n  undefined *DAT_00080f7c = DAT_00080f7c;\n  int rel_array_size = PTR_DAT_00080f88 - PTR_Elf32_Rel_ARRAY_00080f80;\n  undefined4 *PTR_DAT_00080f84 = (undefined4 *)PTR_DAT_00080f84 + rel_array_size / 4;\n  if (DAT_00080f7c != PTR_Elf32_Rel_ARRAY_00080f80) {\n    for (int i = 0; i < rel_array_size; i += 4) {\n      *(undefined4 *)(PTR_Elf32_Rel_ARRAY_00080f80 + i) = *(undefined4 *)(DAT_00080f7c + i);\n    }\n  }\n  for (; PTR_DAT_00080f84 < (undefined4 *)DAT_00080f8c; PTR_DAT_00080f84++) {\n    *PTR_DAT_00080f84 = 0;\n  }\n  undefined *PTR_DAT_00080f90 = PTR_DAT_00080f90 + (-0x20000000);\n  uint *DAT_00080f94 = (uint *)DAT_00080f94;\n  *DAT_00080f94 = (uint)PTR_DAT_00080f90 & 0x1fffff80;\n  if (PTR_DAT_00080f90 < (undefined *)0x100000) {\n    *DAT_00080f94 |= 0x20000000;\n  }\n  (*DAT_00080f98)();\n  while(true) {\n    // do nothing\n  }\n}\n",
            "called": [
                "FUN_000816a8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080f24",
            "calling": [],
            "imported": false,
            "current_name": "initialize_memory_00080f24"
        },
        "FUN_00080e04": {
            "renaming": {
                "FUN_00080e04": "checkParameter_00080e04",
                "param_1": "ptr_param1",
                "param_2": "param2",
                "uVar1": "result"
            },
            "code": "uint checkParameter_00080e04(int ptr_param1, uint param2)\n{\n  uint result = *(uint *)(ptr_param1 + 8) & param2;\n  if (result != 0) {\n    if ((param2 & *(uint *)(ptr_param1 + 0x18)) == 0) {\n      result = 0;\n    }\n    else {\n      result = 1;\n    }\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080e04",
            "calling": [
                "FUN_00081318"
            ],
            "imported": false,
            "current_name": "checkParameter_00080e04"
        },
        "FUN_000804a8": {
            "renaming": {
                "FUN_000804a8": "process_data_and_set_values_000804a8",
                "puVar1": "data_ptr_1",
                "puVar2": "data_ptr_2",
                "puVar3": "data_ptr_3",
                "puVar4": "data_ptr_4",
                "uVar5": "value",
                "iVar6": "value_1"
            },
            "code": "undefined8 process_data_and_set_values_000804a8(void)\n{\n  int first_arg = 1;\n  int second_arg = 0;\n  process_data(first_arg, second_arg);\n  first_arg = 6;\n  second_arg = 1;\n  process_data(first_arg, second_arg);\n  first_arg = 0;\n  second_arg = 1;\n  process_data(first_arg, second_arg);\n  first_arg = 1;\n  second_arg = 1;\n  process_data(first_arg, second_arg);\n  set_data(0, 0);\n  set_data(1, 0);\n  undefined *data_ptr_1 = PTR_DAT_000805a8;\n  undefined *data_ptr_2 = PTR_DAT_000805ac;\n  *(undefined2 *)(data_ptr_1 + 0xe) = 0x13;\n  *(undefined2 *)(data_ptr_1 + 0x10) = 10;\n  *(undefined **)(data_ptr_1 + 0x14) = data_ptr_2 + 0x26;\n  data_ptr_1[1] = 3;\n  data_ptr_1[0x19] = 3;\n  *(undefined2 *)(data_ptr_1 + 0x1a) = 0x14;\n  *(undefined2 *)(data_ptr_1 + 0x28) = 3;\n  *(undefined2 *)(data_ptr_1 + 4) = 0x10;\n  *(undefined **)(data_ptr_1 + 8) = data_ptr_2;\n  data_ptr_1[0xd] = 0x10;\n  *(undefined2 *)(data_ptr_1 + 0x1c) = 0xc;\n  data_ptr_1[0x25] = 0x10;\n  *(undefined2 *)(data_ptr_1 + 0x34) = 8;\n  undefined *data_ptr_3 = PTR_DAT_000805b0;\n  *(undefined2 *)(data_ptr_1 + 0x26) = 0x1c;\n  *(undefined **)(data_ptr_1 + 0x2c) = data_ptr_2 + 0x38;\n  undefined *data_ptr_4 = PTR_DAT_000805b4;\n  data_ptr_1[0x30] = 2;\n  data_ptr_1[0x31] = 2;\n  *(undefined **)(data_ptr_1 + 0x38) = data_ptr_3;\n  data_ptr_1[0x3c] = 2;\n  *data_ptr_1 = 1;\n  data_ptr_1[0xc] = 1;\n  data_ptr_1[0x18] = 1;\n  data_ptr_1[0x24] = 1;\n  *(undefined2 *)(data_ptr_1 + 0x3e) = 1;\n  *(undefined2 *)(data_ptr_1 + 0x40) = 1;\n  *(undefined2 *)(data_ptr_1 + 2) = 0;\n  *(undefined **)(data_ptr_1 + 0x20) = data_ptr_2 + 0x28;\n  *(undefined2 *)(data_ptr_1 + 0x32) = 0;\n  data_ptr_1[0x3d] = 5;\n  *(undefined **)(data_ptr_1 + 0x44) = data_ptr_3 + 2;\n  process_data(data_ptr_4, 0x4b00);\n  *(undefined2 *)(data_ptr_4 + 0x56) = 2000;\n  undefined4 value = get_value_from_pointer_thunk_00081714();\n  *(undefined4 *)PTR_DAT_000805b8 = value;\n  int value_1 = get_value_from_pointer_thunk_00081714();\n  *(int *)PTR_DAT_000805bc = value_1 + 1000;\n  int value_2 = get_value_from_pointer_thunk_00081714();\n  *(int *)PTR_DAT_000805c0 = value_2 + 1000;\n  int value_3 = get_value_from_pointer_thunk_00081714();\n  *(int *)PTR_DAT_000805c4 = value_3 + 1000;\n  int value_4 = get_value_from_pointer_thunk_00081714();\n  *(int *)PTR_DAT_000805c8 = value_4 + 1000;\n  *PTR_DAT_000805cc = 0;\n  if (*(int *)PTR_DAT_00080160 == 0) {\n    software_interrupt(0x3f);\n    return 1;\n  }\n  return 0;\n}",
            "called": [
                "FUN_00081210",
                "FUN_00080164",
                "thunk_FUN_00081714",
                "FUN_00081318"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000804a8",
            "calling": [
                "FUN_000816a8"
            ],
            "imported": false,
            "current_name": "process_data_and_set_values_000804a8"
        },
        "FUN_000802da": {
            "renaming": {
                "FUN_000802da": "process_data_000802da",
                "param_1": "data",
                "param_2": "size",
                "param_3": "buffer",
                "cVar1": "error_code",
                "bVar2": "byte_value",
                "uVar3": "undefined_value",
                "uVar4": "short_value",
                "uVar5": "uint_value",
                "puVar6": "buffer_pointer",
                "local_1c": "local_char",
                "local_1b": "local_undefined",
                "local_1a": "local_short"
            },
            "code": "int process_data_000802da(int data, unsigned short size, unsigned short *buffer)\n{\n    char error_code;\n    byte byte_value;\n    undefined undefined_value;\n    unsigned short short_value;\n    uint uint_value;\n    unsigned short *buffer_pointer;\n    char local_char;\n    undefined local_undefined;\n    unsigned short local_short;\n  \n    uint_value = (uint)size;\n    if (*(char *)(data + 4) != \"\\0\") {\n        error_code = -2;\n        goto ERROR;\n    }\n    if (*(char *)(data + 7) != \"\\0\") {\n        error_code = -1;\n        goto ERROR;\n    }\n    if (0xf6 < (byte)(local_char - 1U)) {\n        error_code = -3;\n        goto ERROR;\n    }\n    *(char *)(data + 9) = local_char;\n    *(undefined *)(data + 10) = local_undefined;\n    *(unsigned short **)(data + 0x4c) = buffer;\n    *(char *)(data + 0xb) = (char)((uint)local_short >> 8);\n    *(char *)(data + 0xc) = (char)local_short;\n    error_code = (char)size;\n    undefined_value = (undefined)(uint_value >> 8);\n    switch(local_undefined) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n            *(undefined *)(data + 0xd) = undefined_value;\n            break;\n        case 5:\n            short_value = *buffer;\n            if (short_value != 0) {\n                short_value = 1;\n            }\n            *(char *)(data + 0xd) = -(char)short_value;\n            uint_value = 0;\n            break;\n        case 6:\n            *(char *)(data + 0xd) = (char)((uint)*buffer >> 8);\n            uint_value = (uint)*buffer;\n            break;\n        default:\n            goto SWITCH_DEFAULT;\n        case 0xf:\n            byte_value = (byte)(size >> 3) & 0xfe;\n            if ((size & 0xf) != 0) {\n                byte_value = byte_value + 1;\n            }\n            *(char *)(data + 0xe) = error_code;\n            *(undefined *)(data + 0xd) = undefined_value;\n            *(byte *)(data + 0xf) = byte_value;\n            undefined_value = 7;\n            goto LAB_0008034a;\n        case 0x10:\n            *(undefined *)(data + 0xd) = undefined_value;\n            *(char *)(data + 0xe) = error_code;\n            buffer = buffer + -1;\n            *(char *)(data + 0xf) = error_code * \"\\x02\";\n            *(undefined *)(data + 0x49) = 7;\n            buffer_pointer = buffer + uint_value;\n            while (buffer != buffer_pointer) {\n                byte_value = *(byte *)(data + 0x49);\n                *(char *)(data + (uint)byte_value + 9) = (char)((uint)buffer[1] >> 8);\n                uint_value = byte_value + 1 & 0xff;\n                *(char *)(data + (uint)byte_value + 9) = (char)*buffer;\n                *(byte *)(data + 0x49) = byte_value + 2;\n                buffer = buffer + 1;\n            }\n            goto SWITCH_DEFAULT;\n    }\n    *(char *)(data + 0xe) = (char)uint_value;\n    undefined_value = 6;\nLAB_0008034a:\n    *(undefined *)(data + 0x49) = undefined_value;\nSWITCH_DEFAULT:\n    calculate_checksum_and_process_data_000802da_00080258(data);\n    *(undefined *)(data + 7) = 1;\n    error_code = \"\\0\";\nERROR:\n    return (int)error_code;\n}",
            "called": [
                "FUN_00080258"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000802da",
            "calling": [
                "FUN_000805d0"
            ],
            "imported": false,
            "current_name": "process_data_000802da"
        },
        "FUN_00080f9c": {
            "renaming": {
                "FUN_00080f9c": "find_value_at_index_00080f9c",
                "param_1": "output_array",
                "param_2": "input_value",
                "param_3": "divisor",
                "param_4": "max_value",
                "local_58": "local_array",
                "uVar1": "quotient",
                "uVar2": "index"
            },
            "code": "uint32_t find_value_at_index_00080f9c(uint32_t *output_array, uint32_t input_value, int divisor, int max_value)\n{\n    uint32_t local_array[16] = {0};\n    local_array[0] = *(uint32_t *)PTR_DAT_0008102c;\n    local_array[1] = *(uint32_t *)(PTR_DAT_0008102c + 4);\n    local_array[2] = *(uint32_t *)(PTR_DAT_0008102c + 8);\n    local_array[3] = *(uint32_t *)(PTR_DAT_0008102c + 0xc);\n    local_array[4] = *(uint32_t *)(PTR_DAT_0008102c + 0x10);\n    local_array[5] = *(uint32_t *)(PTR_DAT_0008102c + 0x14);\n    local_array[6] = *(uint32_t *)(PTR_DAT_0008102c + 0x18);\n    local_array[7] = *(uint32_t *)(PTR_DAT_0008102c + 0x1c);\n    local_array[8] = *(uint32_t *)(PTR_DAT_0008102c + 0x20);\n    local_array[9] = *(uint32_t *)(PTR_DAT_0008102c + 0x24);\n    local_array[10] = *(uint32_t *)(PTR_DAT_0008102c + 0x28);\n    local_array[11] = *(uint32_t *)(PTR_DAT_0008102c + 0x2c);\n    local_array[12] = *(uint32_t *)(PTR_DAT_0008102c + 0x30);\n    local_array[13] = *(uint32_t *)(PTR_DAT_0008102c + 0x34);\n    local_array[14] = *(uint32_t *)(PTR_DAT_0008102c + 0x38);\n    local_array[15] = *(uint32_t *)(PTR_DAT_0008102c + 0x3c);\n    output_array[0] = 1;\n    output_array[1] = 0;\n    output_array[0x48] = 0x202;\n    output_array[0x41] = 0;\n    output_array[0x45] = 0;\n    uint32_t quotient = input_value / (uint32_t)(divisor * 2);\n    if (input_value == divisor * 2 * quotient) {\n        quotient = quotient - 1;\n    }\n    uint32_t index = 0;\n    while (index != 0x10) {\n        if ((uint32_t)(max_value * (int)(((uint64_t)input_value / (uint64_t)((quotient + 1) * 2)) / (uint64_t)DAT_00081030)) <= local_array[index]) {\n            output_array[1] = (index & 0xf) << 0x10 | (quotient & 0xff) << 8 | output_array[1];\n            return 0;\n        }\n        index++;\n    }\n    return 0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080f9c",
            "calling": [
                "FUN_00080ae4"
            ],
            "imported": false,
            "current_name": "find_value_at_index_00080f9c"
        },
        "FUN_00081210": {
            "renaming": {
                "FUN_00081210": "process_data_00081210",
                "param_1": "data_index",
                "param_2": "data_type",
                "puVar1": "data_ptr1",
                "puVar2": "data_ptr2",
                "iVar3": "result",
                "uVar4": "bit_mask",
                "uVar5": "data_type_2",
                "uVar6": "data_type_3",
                "bVar7": "data_byte1",
                "bVar8": "data_byte2",
                "iVar9": "data_index_2",
                "iVar10": "data_index_3"
            },
            "code": "int process_data_00081210(int data_index, int data_type, int data_param1, int data_param2) {\n  undefined *data_ptr1;\n  undefined *data_ptr2;\n  int result;\n  uint bit_mask;\n  byte data_byte1;\n  byte data_byte2;\n  int data_index_2;\n  int data_index_3;\n  data_ptr2 = PTR_DAT_00081310;\n  data_ptr1 = PTR_DAT_0008130c;\n  result = data_index;\n  if (PTR_DAT_0008130c[data_index * 0x1c + 0xc] != '\\0') {\n    if ((PTR_DAT_00081310[data_index] & 0xf) == 4) {\n      result = set_bit_at_position(DAT_00081314,PTR_DAT_0008130c[data_index * 0x1c + 0x19]);\n    }\n    data_byte2 = data_ptr2[data_index];\n    data_byte1 = data_byte2 & 0xf;\n    if ((data_byte1 < 3) && (data_byte2 != 0)) {\n      if (data_byte1 == 2) {\n        if (data_type == 0) {\n          return result;\n        }\n      }\n      else if (data_byte1 == 1) {\n        if (data_type == 2) {\n          return result;\n        }\n      }\n      else if (data_byte1 == 3) {\n        if (data_type == 1) {\n          return result;\n        }\n        goto LAB_0008126c;\n      }\n    }\n    if (data_type != 1) {\nLAB_0008126c:\n      if (data_type == 0) {\n        data_index_2 = data_index * 0x1c;\n        check_and_set_bit(*(undefined4 *)(data_ptr1 + data_index_2 + 8));\n        result = process_data_00081210(*(undefined4 *)(data_ptr1 + data_index_2),3,*(undefined4 *)(data_ptr1 + data_index_2 + 4),0);\n        data_byte2 = data_ptr2[data_index] & 0xf0 | 2;\n      }\n      else {\n        if (data_type != 2) {\n          return result;\n        }\n        data_index_2 = data_index * 0x1c;\n        check_and_set_bit(*(undefined4 *)(data_ptr1 + data_index_2 + 8));\n        result = process_data_00081210(*(undefined4 *)(data_ptr1 + data_index_2),3,*(undefined4 *)(data_ptr1 + data_index_2 + 4),1);\n        data_byte2 = data_ptr2[data_index] & 0xf0 | 1;\n      }\n      data_ptr2[data_index] = data_byte2;\n      return result;\n    }\n    data_index_3 = data_index * 0x1c;\n    data_index_2 = *(int *)(data_ptr1 + data_index_3);\n    if (data_byte2 >> 4 == 0) {\n      data_type = 4;\n    }\n    else {\n      data_type = 5;\n    }\n    result = process_data_00081210(data_index_2,data_type,*(undefined4 *)(data_ptr1 + data_index_3 + 4),*(undefined4 *)(data_ptr1 + data_index_3 + 0x10));\n    data_ptr2[data_index] = data_ptr2[data_index] & 0xf0 | 3;\n    if (*(int *)(data_index_2 + 0x18) == -1) {\n      bit_mask = *(uint *)(data_ptr1 + data_index_3 + 8);\n      if (0x2c < bit_mask) {\n        return 1;\n      }\n      if (bit_mask < 0x20) {\n        bit_mask = 1 << (bit_mask & 0xff);\n        data_type = *(uint *)(DAT_00080e98 + 0x18) & bit_mask;\n        if (data_type == bit_mask) {\n          *(uint *)(DAT_00080e98 + 0x14) = data_type;\n        }\n      }\n      else {\n        bit_mask = 1 << (bit_mask - 0x20 & 0xff);\n        data_type = *(uint *)(DAT_00080e98 + 0x108) & bit_mask;\n        if (data_type == bit_mask) {\n          *(uint *)(DAT_00080e98 + 0x104) = data_type;\n        }\n      }\n      return 0;\n    }\n  }\n  return result;\n}",
            "called": [
                "FUN_00080da0",
                "FUN_00080e18",
                "FUN_0008105c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081210",
            "calling": [
                "FUN_000804a8",
                "FUN_00080164",
                "FUN_00081318"
            ],
            "imported": false,
            "current_name": "process_data_00081210"
        },
        "FUN_00081454": {
            "renaming": {
                "FUN_00081454": "update_data_00081454",
                "param_1": "data_ptr",
                "param_2": "new_data",
                "iVar1": "data_struct_ptr",
                "uVar2": "data_mask",
                "count_ptr": "count_ptr",
                "count": "count",
                "max_count": "max_count",
                "current_count": "current_count",
                "current_index": "current_index",
                "*(int *)(count_ptr + 0x1c)": "*(int *)(count_ptr + 0x1c)",
                "*(char *)(data_struct_ptr + current_index)": "*(char *)(data_struct_ptr + current_index)",
                "*(int *)(data_struct_ptr + 0x80)": "*(int *)(data_struct_ptr + 0x80)"
            },
            "code": "int update_data_00081454(int data_ptr, int new_data) {\n  int data_struct_ptr = *(int *)(data_ptr + 0x14);\n  int count_ptr = *(int *)(data_ptr + 0x18);\n  int count = *(int *)(count_ptr + 0x14);\n  int max_count = count << 0x1e;\n  int current_count = *(int *)(data_struct_ptr + 0x84);\n  int current_index = *(int *)(data_struct_ptr + 0x80);\n\n  if (max_count < 0 && current_count == current_index) {\n    *(int *)(count_ptr + 0x1c) = new_data;\n  }\n  else {\n    uint32_t data_mask = DAT_000814a4;\n    int new_index = current_index + 1;\n    if (new_index < 0) {\n      new_index = (new_index - 1 | 0xffffff80) + 1;\n    }\n    while (current_count == data_mask & current_index + 1) {\n    }\n    *(char *)(data_struct_ptr + current_index) = (char)new_data;\n    *(int *)(data_struct_ptr + 0x80) = new_index;\n    *(int *)(count_ptr + 8) = 2;\n  }\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081454",
            "calling": [],
            "imported": false,
            "current_name": "update_data_00081454"
        },
        "FUN_00081730": {
            "renaming": {
                "FUN_00081730": "calculate_float_00081730",
                "param_1": "float_bits_1",
                "param_2": "float_bits_2",
                "param_3": "unused",
                "param_4": "shift_amount",
                "iVar1": "exponent",
                "uVar2": "significand_1",
                "uVar3": "significand_2",
                "uVar4": "temp",
                "uVar5": "shifted_exponent",
                "uVar6": "difference",
                "iVar7": "leading_zeroes",
                "bVar8": "comparison_result"
            },
            "code": "\nuint calculate_float_00081730(uint float_bits_1,uint float_bits_2,undefined4 unused,uint shift_amount)\n\n{\n  int exponent;\n  uint significand_1;\n  uint significand_2;\n  uint temp;\n  uint shifted_exponent;\n  uint difference;\n  int leading_zeroes;\n  bool comparison_result;\n  \n  significand_1 = float_bits_2 ^ 0x80000000;\n  temp = float_bits_1 << 1;\n  comparison_result = temp == 0;\n  if (!comparison_result) {\n    shift_amount = float_bits_2 << 1;\n    comparison_result = shift_amount == 0;\n  }\n  if (!comparison_result) {\n    comparison_result = temp == shift_amount;\n  }\n  leading_zeroes = (int)temp >> 0x18;\n  if (!comparison_result) {\n    comparison_result = leading_zeroes == -1;\n  }\n  if (!comparison_result) {\n    comparison_result = (int)shift_amount >> 0x18 == -1;\n  }\n  if (comparison_result) {\n    exponent = (int)(float_bits_2 << 1) >> 0x18;\n    if (leading_zeroes == -1 || exponent == -1) {\n      temp = significand_1;\n      if (leading_zeroes == -1) {\n        temp = float_bits_1;\n      }\n      if (leading_zeroes != -1 || exponent != -1) {\n        significand_1 = temp;\n      }\n      comparison_result = (temp & 0x7fffff) == 0;\n      if (comparison_result) {\n        comparison_result = (significand_1 & 0x7fffff) == 0;\n      }\n      if (comparison_result) {\n        comparison_result = temp == significand_1;\n      }\n      if (!comparison_result) {\n        temp = temp | 0x400000;\n      }\n      return temp;\n    }\n    if (((float_bits_1 ^ significand_1) & 0x7fffffff) != 0) {\n      if (temp == 0) {\n        float_bits_1 = significand_1;\n      }\n      return float_bits_1;\n    }\n    if (float_bits_1 != significand_1) {\n      return 0;\n    }\n    if ((temp & 0xff000000) == 0) {\n      significand_1 = float_bits_1 << 1;\n      if ((float_bits_1 & 0x80000000) != 0) {\n        significand_1 = significand_1 | 0x80000000;\n      }\n      return significand_1;\n    }\n    if (temp < 0xfe000000) {\n      return float_bits_1 + 0x800000;\n    }\n    float_bits_1 = float_bits_1 & 0x80000000;\nLAB_0008186a:\n    return float_bits_1 | 0x7f800000;\n  }\n  temp = temp >> 0x18;\n  shift_amount = shift_amount >> 0x18;\n  difference = shift_amount - temp;\n  comparison_result = difference != 0;\n  shifted_exponent = temp;\n  if (comparison_result && temp <= shift_amount) {\n    shifted_exponent = temp + difference;\n  }\n  if (comparison_result && temp <= shift_amount) {\n    significand_1 = significand_1 ^ float_bits_1;\n  }\n  if (comparison_result && temp <= shift_amount) {\n    float_bits_1 = float_bits_1 ^ significand_1;\n  }\n  if (comparison_result && temp <= shift_amount) {\n    significand_1 = significand_1 ^ float_bits_1;\n  }\n  if (shift_amount < temp) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return float_bits_1;\n  }\n  temp = float_bits_1 & 0xffffff | 0x800000;\n  if ((float_bits_1 & 0x80000000) != 0) {\n    temp = -temp;\n  }\n  significand_2 = significand_1 & 0xffffff | 0x800000;\n  if ((significand_1 & 0x80000000) != 0) {\n    significand_2 = -significand_2;\n  }\n  if (shifted_exponent == difference) {\n    significand_2 = significand_2 ^ 0x800000;\n    if (shifted_exponent == 0) {\n      temp = temp ^ 0x800000;\n      shifted_exponent = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  temp = temp + ((int)significand_2 >> (difference & 0xff));\n  significand_2 = significand_2 << (0x20 - difference & 0xff);\n  float_bits_1 = temp & 0x80000000;\n  if ((int)temp < 0) {\n    comparison_result = significand_2 != 0;\n    significand_2 = -significand_2;\n    temp = -temp - (uint)comparison_result;\n  }\n  if (temp < 0x800000) {\n    significand_1 = significand_2 & 0x80000000;\n    significand_2 = significand_2 << 1;\n    temp = temp * 2 + (uint)(significand_1 != 0);\n    significand_1 = shifted_exponent - 2;\n    if ((temp & 0x800000) == 0) {\n      leading_zeroes = count_leading_zeroes(temp);\n      difference = leading_zeroes - 8;\n      temp = temp << (difference & 0xff);\n      if ((int)significand_1 < (int)difference) {\n        temp = temp >> (-(significand_1 - difference) & 0xff);\n      }\n      else {\n        temp = temp + (significand_1 - difference) * 0x800000;\n      }\n      return temp | float_bits_1;\n    }\n  }\n  else {\n    significand_1 = shifted_exponent - 1;\n    if (0xffffff < temp) {\n      significand_1 = temp & 1;\n      temp = temp >> 1;\n      significand_2 = (uint)(significand_1 != 0) << 0x1f | significand_2 >> 1;\n      significand_1 = shifted_exponent;\n      if (0xfd < shifted_exponent) goto LAB_0008186a;\n    }\n  }\n  temp = temp + significand_1 * 0x800000 + (uint)(0x7fffffff < significand_2);\n  if (significand_2 == 0x80000000) {\n    temp = temp & 0xfffffffe;\n  }\n  return temp | float_bits_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081730",
            "calling": [
                "FUN_000805d0"
            ],
            "imported": false,
            "current_name": "calculate_float_00081730"
        },
        "FUN_00080ab8": {
            "renaming": {
                "FUN_00080ab8": "do_nothing_00080ab8"
            },
            "code": "\nvoid do_nothing_00080ab8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080ab8",
            "calling": [
                "FUN_00080ce0"
            ],
            "imported": false,
            "current_name": "do_nothing_00080ab8"
        },
        "FUN_00081734": {
            "renaming": {
                "FUN_00081734": "calculate_float_00081734",
                "param_1": "float1",
                "param_2": "float2",
                "param_3": "undefined4",
                "param_4": "float3",
                "iVar1": "result",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "uVar5": "temp4",
                "iVar6": "temp5",
                "bVar7": "temp6"
            },
            "code": "\nuint calculate_float_00081734(uint float1,uint float2,undefined4 undefined4,uint float3)\n\n{\n  int result;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  int temp5;\n  bool temp6;\n  \n  temp2 = float1 << 1;\n  temp6 = temp2 == 0;\n  if (!temp6) {\n    float3 = float2 << 1;\n    temp6 = float3 == 0;\n  }\n  if (!temp6) {\n    temp6 = temp2 == float3;\n  }\n  temp5 = (int)temp2 >> 0x18;\n  if (!temp6) {\n    temp6 = temp5 == -1;\n  }\n  if (!temp6) {\n    temp6 = (int)float3 >> 0x18 == -1;\n  }\n  if (temp6) {\n    result = (int)(float2 << 1) >> 0x18;\n    if (temp5 == -1 || result == -1) {\n      temp2 = float2;\n      if (temp5 == -1) {\n        temp2 = float1;\n      }\n      if (temp5 != -1 || result != -1) {\n        float2 = temp2;\n      }\n      temp6 = (temp2 & 0x7fffff) == 0;\n      if (temp6) {\n        temp6 = (float2 & 0x7fffff) == 0;\n      }\n      if (temp6) {\n        temp6 = temp2 == float2;\n      }\n      if (!temp6) {\n        temp2 = temp2 | 0x400000;\n      }\n      return temp2;\n    }\n    if (((float1 ^ float2) & 0x7fffffff) != 0) {\n      if (temp2 == 0) {\n        float1 = float2;\n      }\n      return float1;\n    }\n    if (float1 != float2) {\n      return 0;\n    }\n    if ((temp2 & 0xff000000) == 0) {\n      temp2 = float1 << 1;\n      if ((float1 & 0x80000000) != 0) {\n        temp2 = temp2 | 0x80000000;\n      }\n      return temp2;\n    }\n    if (temp2 < 0xfe000000) {\n      return float1 + 0x800000;\n    }\n    float1 = float1 & 0x80000000;\nLAB_0008186a:\n    return float1 | 0x7f800000;\n  }\n  temp2 = temp2 >> 0x18;\n  float3 = float3 >> 0x18;\n  temp4 = float3 - temp2;\n  temp6 = temp4 != 0;\n  temp3 = temp2;\n  if (temp6 && temp2 <= float3) {\n    temp3 = temp2 + temp4;\n  }\n  if (temp6 && temp2 <= float3) {\n    float2 = float2 ^ float1;\n  }\n  if (temp6 && temp2 <= float3) {\n    float1 = float1 ^ float2;\n  }\n  if (temp6 && temp2 <= float3) {\n    float2 = float2 ^ float1;\n  }\n  if (float3 < temp2) {\n    temp4 = -temp4;\n  }\n  if (0x19 < temp4) {\n    return float1;\n  }\n  temp2 = float1 & 0xffffff | 0x800000;\n  if ((float1 & 0x80000000) != 0) {\n    temp2 = -temp2;\n  }\n  temp1 = float2 & 0xffffff | 0x800000;\n  if ((float2 & 0x80000000) != 0) {\n    temp1 = -temp1;\n  }\n  if (temp3 == temp4) {\n    temp1 = temp1 ^ 0x800000;\n    if (temp3 == 0) {\n      temp2 = temp2 ^ 0x800000;\n      temp3 = 1;\n    }\n    else {\n      temp4 = temp4 - 1;\n    }\n  }\n  temp2 = temp2 + ((int)temp1 >> (temp4 & 0xff));\n  temp1 = temp1 << (0x20 - temp4 & 0xff);\n  float1 = temp2 & 0x80000000;\n  if ((int)temp2 < 0) {\n    temp6 = temp1 != 0;\n    temp1 = -temp1;\n    temp2 = -temp2 - (uint)temp6;\n  }\n  if (temp2 < 0x800000) {\n    temp4 = temp1 & 0x80000000;\n    temp1 = temp1 << 1;\n    temp2 = temp2 * 2 + (uint)(temp4 != 0);\n    temp4 = temp3 - 2;\n    if ((temp2 & 0x800000) == 0) {\n      temp5 = count_leading_zeroes(temp2);\n      temp3 = temp5 - 8;\n      temp2 = temp2 << (temp3 & 0xff);\n      if ((int)temp4 < (int)temp3) {\n        temp2 = temp2 >> (-(temp4 - temp3) & 0xff);\n      }\n      else {\n        temp2 = temp2 + (temp4 - temp3) * 0x800000;\n      }\n      return temp2 | float1;\n    }\n  }\n  else {\n    temp4 = temp3 - 1;\n    if (0xffffff < temp2) {\n      temp4 = temp2 & 1;\n      temp2 = temp2 >> 1;\n      temp1 = (uint)(temp4 != 0) << 0x1f | temp1 >> 1;\n      temp4 = temp3;\n      if (0xfd < temp3) goto LAB_0008186a;\n    }\n  }\n  temp2 = temp2 + temp4 * 0x800000 + (uint)(0x7fffffff < temp1);\n  if (temp1 == 0x80000000) {\n    temp2 = temp2 & 0xfffffffe;\n  }\n  return temp2 | float1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081734",
            "calling": [
                "FUN_000805d0"
            ],
            "imported": false,
            "current_name": "calculate_float_00081734"
        },
        "FUN_00084728": {
            "renaming": {
                "FUN_00084728": "processReturnValue_00084728",
                "param_1": "output",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "puVar1": "pointer",
                "iVar2": "returnValue"
            },
            "code": "void processReturnValue_00084728(int *output, undefined4 arg2, undefined4 arg3, undefined4 arg4)\n{\n    undefined *pointer = PTR_DAT_0008474c;\n    *(undefined4 *)PTR_DAT_0008474c = 0;\n    int returnValue = returnZero_000811c6(arg2, arg3, arg4);\n    if (returnValue == -1 && *(int *)pointer != 0)\n    {\n        *output = *(int *)pointer;\n        return;\n    }\n    return;\n}",
            "called": [
                "FUN_000811c6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00084728",
            "calling": [],
            "imported": false,
            "current_name": "processReturnValue_00084728"
        },
        "FUN_00083c40": {
            "renaming": {
                "FUN_00083c40": "process_input_00083c40",
                "param_1": "param1",
                "param_2": "input_length",
                "param_3": "input_buffer",
                "uVar1": "value1",
                "iVar2": "var1",
                "uVar3": "value3",
                "pbVar4": "byte_ptr1",
                "uVar5": "value2",
                "local_1c": "current_byte",
                "abStack_1b": "byte_array"
            },
            "code": "uint process_input_00083c40(uint param1, uint input_length, byte **input_buffer)\n{\n  uint value1;\n  int var1;\n  uint value2;\n  byte *byte_ptr1;\n  uint value3;\n  byte current_byte;\n  byte byte_array[3];\n  if (-1 < (int)((uint)*(ushort *)(input_buffer + 3) << 0x12)) {\n    *(ushort *)(input_buffer + 3) = *(ushort *)(input_buffer + 3) | 0x2000;\n    input_buffer[0x19] = (byte *)((uint)input_buffer[0x19] | 0x2000);\n  }\n  value1 = get_first_value();\n  if ((value1 == 1) && (input_length - 1 < 0xff)) {\n    value3 = input_length & 0xff;\n    current_byte = (byte)value3;\n  }\n  else {\n    value1 = process_data(param1, &current_byte, input_length, input_buffer + 0x17);\n    if (value1 == 0xffffffff) {\n      *(ushort *)(input_buffer + 3) = *(ushort *)(input_buffer + 3) | 0x40;\n      return 0xffffffff;\n    }\n    if (value1 == 0) {\n      return input_length;\n    }\n    value3 = (uint)current_byte;\n  }\n  value2 = 0;\n  do {\n    byte_ptr1 = input_buffer[2] + -1;\n    input_buffer[2] = byte_ptr1;\n    if ((int)byte_ptr1 < 0) {\n      if ((int)input_buffer[6] <= (int)byte_ptr1) {\n        **input_buffer = (byte)value3;\n        byte_ptr1 = *input_buffer;\n        value3 = (uint)*byte_ptr1;\n        if (value3 != 10) goto LAB_00083c90;\n      }\n      var1 = process_input_00083c40(param1, value3, input_buffer);\n      if (var1 == -1) {\n        return 0xffffffff;\n      }\n    }\n    else {\n      **input_buffer = (byte)value3;\n      byte_ptr1 = *input_buffer;\nLAB_00083c90:\n      *input_buffer = byte_ptr1 + 1;\n    }\n    if (value1 <= value2 + 1) {\n      return input_length;\n    }\n    value3 = (uint)byte_array[value2];\n    value2 = value2 + 1;\n  } while( true );\n}",
            "called": [
                "FUN_000844c4",
                "FUN_00084298",
                "FUN_0008456c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00083c40",
            "calling": [
                "FUN_00082ac0"
            ],
            "imported": false,
            "current_name": "process_input_00083c40"
        },
        "FUN_000805d0": {
            "renaming": {
                "FUN_000805d0": "process_data_000805d0",
                "puVar1": "undefined_ptr_1",
                "puVar2": "undefined_ptr_2",
                "puVar3": "undefined_ptr_3",
                "puVar4": "undefined_ptr_4",
                "puVar5": "undefined_ptr_5",
                "puVar6": "undefined_ptr_6",
                "puVar7": "undefined_ptr_7",
                "puVar8": "undefined_ptr_8",
                "puVar9": "undefined_ptr_9",
                "uVar10": "short_val",
                "uVar11": "uint_val",
                "uVar12": "float_val_1",
                "uVar13": "float_val_2",
                "uVar14": "float_val_3",
                "iVar15": "int_val_1",
                "iVar16": "int_val_2",
                "iVar17": "int_ptr_val",
                "iVar19": "int_val_4",
                "piVar17": "int_ptr_1"
            },
            "code": "\nvoid process_data_000805d0(void)\n\n{\n  undefined *undefined_ptr_1;\n  undefined *undefined_ptr_2;\n  undefined *undefined_ptr_3;\n  undefined *undefined_ptr_4;\n  undefined *undefined_ptr_5;\n  undefined *undefined_ptr_6;\n  undefined *undefined_ptr_7;\n  undefined *undefined_ptr_8;\n  undefined *undefined_ptr_9;\n  undefined2 short_val;\n  uint uint_val;\n  undefined4 float_val_1;\n  undefined4 float_val_2;\n  undefined4 float_val_3;\n  int int_val_1;\n  int int_val_2;\n  int *int_ptr_1;\n  undefined4 uVar18;\n  int int_val_4;\n  \n  undefined_ptr_7 = PTR_DAT_0008089c;\n  undefined_ptr_9 = PTR_DAT_00080898;\n  undefined_ptr_8 = PTR_DAT_00080894;\n  undefined_ptr_3 = PTR_DAT_0008087c;\n  undefined_ptr_5 = PTR_DAT_00080878;\n  undefined_ptr_4 = PTR_DAT_00080874;\n  undefined_ptr_2 = PTR_DAT_00080834;\n  undefined_ptr_1 = PTR_DAT_00080830;\n  if ((byte)*PTR_DAT_0008082c < 10) {\n                    /* WARNING: Could not recover jumptable at 0x000805f0. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*(code *)(&switchD_000805f0::switchdataD_000805f4 +\n              (uint)(&switchD_000805f0::switchdataD_000805f4)[(byte)*PTR_DAT_0008082c] * 2))();\n    return;\n  }\n  int_val_2 = *(int *)PTR_DAT_00080894;\n  int_val_1 = int_val_2 - *(int *)PTR_DAT_00080874;\n  if (int_val_1 < 0) {\n    int_val_1 = int_val_1 + 0x3c;\n  }\n  *(int *)PTR_DAT_0008087c = int_val_1;\n  undefined_ptr_6 = PTR_DAT_00080880;\n  uint_val = *(uint *)undefined_ptr_9;\n  int_val_1 = uint_val - *(int *)undefined_ptr_5;\n  *(int *)PTR_DAT_00080880 = int_val_1;\n  if (int_val_1 < 0) {\n    *(int *)undefined_ptr_3 = *(int *)undefined_ptr_3 + -1;\n    *(int *)undefined_ptr_6 = int_val_1 + 0x3c;\n  }\n  int_val_1 = *(int *)undefined_ptr_3;\n  int_val_4 = *(int *)undefined_ptr_6;\n  *(short *)(undefined_ptr_1 + 0x36) = (short)int_val_1;\n  *(short *)(undefined_ptr_1 + 0x38) = (short)int_val_4;\n  if ((int_val_1 == 0) && (int_val_4 == 0)) {\n    *(undefined4 *)PTR_DAT_00080868 = 1;\n    *(undefined4 *)undefined_ptr_4 = 0;\n    *(undefined4 *)undefined_ptr_5 = 0;\n  }\n  undefined_ptr_6 = PTR_DAT_00080888;\n  undefined_ptr_3 = PTR_DAT_00080884;\n  if (*(int *)PTR_DAT_00080884 == int_val_2) {\n    int_val_1 = 1 - uint_val;\n    if (1 < uint_val) {\n      int_val_1 = 0;\n    }\n    *(int *)PTR_DAT_00080888 = int_val_1;\n    if (int_val_1 != 0) goto LAB_00080a08;\n  }\n  else {\nLAB_00080a08:\n    *(int *)undefined_ptr_3 = int_val_2;\n    undefined_ptr_3 = PTR_DAT_00080a50;\n    *(uint *)undefined_ptr_6 = uint_val;\n    *(undefined4 *)undefined_ptr_4 = 0;\n    *(undefined4 *)undefined_ptr_5 = 0;\n    *(undefined4 *)undefined_ptr_3 = 0;\n  }\n  undefined_ptr_6 = PTR_DAT_0008088c;\n  undefined_ptr_3 = PTR_DAT_00080860;\n  int_val_1 = *(int *)undefined_ptr_7;\n  if (int_val_1 == 0) {\n    *(undefined4 *)undefined_ptr_4 = 0;\n    *(undefined4 *)undefined_ptr_5 = 0;\n    int_ptr_1 = (int *)PTR_DAT_0008088c;\nLAB_000808f2:\n    *int_ptr_1 = int_val_1;\n  }\n  else {\n    if (int_val_1 != 1) goto LAB_000808f4;\n    if (*(int *)PTR_DAT_0008088c < *(int *)PTR_DAT_00080860) {\n      uint_val = get_value_from_pointer_thunk_00081714();\n      undefined_ptr_7 = PTR_DAT_00080890;\n      if (*(uint *)PTR_DAT_00080890 < uint_val) {\n        *(int *)undefined_ptr_6 = *(int *)undefined_ptr_6 + 1;\n        int_val_1 = get_value_from_pointer_thunk_00081714();\n        *(int *)undefined_ptr_7 = int_val_1 + 1000;\n      }\n    }\n    if (*(int *)undefined_ptr_6 < *(int *)undefined_ptr_3) goto LAB_000808f4;\n    *(int *)PTR_DAT_0008088c = *(int *)undefined_ptr_3 + 1;\n    int_ptr_1 = (int *)PTR_DAT_00080a20;\n    undefined_ptr_3 = PTR_DAT_00080a1c;\n    if (*(int *)undefined_ptr_4 < *(int *)undefined_ptr_8) {\n      uint_val = get_value_from_pointer_thunk_00081714();\n      undefined_ptr_3 = PTR_DAT_00080890;\n      if (*(uint *)PTR_DAT_00080890 < uint_val) {\n        *(int *)undefined_ptr_5 = *(int *)undefined_ptr_5 + 1;\n        int_val_1 = get_value_from_pointer_thunk_00081714();\n        *(int *)undefined_ptr_3 = int_val_1 + 1000;\n      }\n    }\n    else {\n      if (*(int *)undefined_ptr_4 != *(int *)undefined_ptr_8) goto LAB_000808f4;\n      if (*(int *)undefined_ptr_9 < *(int *)undefined_ptr_5) {\n        int_val_1 = 0;\n        *(undefined4 *)PTR_DAT_00080a1c = 0;\n        goto LAB_000808f2;\n      }\n      uint_val = get_value_from_pointer_thunk_00081714();\n      undefined_ptr_8 = PTR_DAT_00080a54;\n      if (*(uint *)PTR_DAT_00080a54 < uint_val) {\n        *(int *)undefined_ptr_3 = *(int *)undefined_ptr_3 + 1;\n        int_val_1 = get_value_from_pointer_thunk_00081714();\n        *(int *)undefined_ptr_8 = int_val_1 + 1000;\n      }\n    }\n    if (0x3b < *(int *)undefined_ptr_5) {\n      *(undefined4 *)PTR_DAT_00080a1c = 0;\n      *(int *)undefined_ptr_4 = *(int *)undefined_ptr_4 + 1;\n    }\n  }\nLAB_000808f4:\n  uint_val = get_value_from_pointer_thunk_00081714();\n  undefined_ptr_8 = PTR_DAT_00080a60;\n  undefined_ptr_3 = PTR_DAT_00080a5c;\n  undefined_ptr_5 = PTR_DAT_00080a58;\n  undefined_ptr_4 = PTR_DAT_00080a24;\n  if (*(uint *)PTR_DAT_00080a58 < uint_val) {\n    float_val_1 = reverse_bits_0008189c(*(undefined4 *)PTR_DAT_00080a28);\n    float_val_1 = calculate_float_00081730(float_val_1,*(undefined4 *)PTR_DAT_00080a2c);\n    *(undefined4 *)PTR_DAT_00080a30 = float_val_1;\n    undefined_ptr_9 = PTR_DAT_00080a34;\n    uVar18 = *(undefined4 *)PTR_DAT_00080a34;\n    float_val_2 = calculate_float_00081734(float_val_1,uVar18);\n    float_val_2 = calculate_float_00081944(float_val_2,*(undefined4 *)undefined_ptr_8);\n    undefined_ptr_7 = PTR_DAT_00080a64;\n    float_val_2 = calculate_float_00081734(float_val_2,*(undefined4 *)PTR_DAT_00080a64);\n    *(undefined4 *)undefined_ptr_8 = float_val_2;\n    uVar18 = calculate_float_00081730(float_val_1,uVar18);\n    uVar18 = calculate_float_00081944(uVar18,*(undefined4 *)PTR_DAT_00080a38);\n    undefined_ptr_8 = PTR_DAT_00080a3c;\n    uVar18 = calculate_float_00081730(uVar18,*(undefined4 *)PTR_DAT_00080a3c);\n    *(undefined4 *)PTR_DAT_00080a38 = uVar18;\n    float_val_3 = calculate_float_00081944(float_val_1,*(undefined4 *)PTR_DAT_00080a40);\n    float_val_3 = calculate_float_00081734(float_val_3,float_val_2);\n    calculate_float_00081734(float_val_3,uVar18);\n    float_val_3 = convert_to_signed_int_00081cd0();\n    *(undefined4 *)PTR_DAT_00080a44 = float_val_3;\n    float_val_3 = reverse_bits_0008189c();\n    *(undefined4 *)undefined_ptr_9 = float_val_1;\n    *(undefined4 *)undefined_ptr_4 = float_val_3;\n    *(undefined4 *)undefined_ptr_3 = 0;\n    *(undefined4 *)undefined_ptr_7 = float_val_2;\n    *(undefined4 *)undefined_ptr_8 = uVar18;\n    int_val_1 = get_value_from_pointer_thunk_00081714();\n    *(int *)undefined_ptr_5 = int_val_1 + *(int *)undefined_ptr_2;\n  }\n  float_val_1 = reverse_bits_0008189c(*(undefined4 *)undefined_ptr_2);\n  int_val_1 = check_params_and_swap_00081ca8(*(undefined4 *)undefined_ptr_4,float_val_1);\n  if (int_val_1 != 0) {\n    *(undefined4 *)PTR_DAT_00080a24 = float_val_1;\n  }\n  int_val_1 = check_concatenated_params_00081c94(*(undefined4 *)undefined_ptr_4,0);\n  if (int_val_1 != 0) {\n    *(undefined4 *)PTR_DAT_00080a24 = 0;\n  }\n  short_val = validate_input_00081d1c(*(undefined4 *)undefined_ptr_4);\n  int_val_1 = *(int *)undefined_ptr_3;\n  *(undefined2 *)(undefined_ptr_1 + 0x2a) = short_val;\n  *(int *)undefined_ptr_3 = int_val_1 + 1;\n  *(uint *)PTR_DAT_00080a4c = *(ushort *)PTR_DAT_00080a48 & 1 ^ 1;\n  return;\n}\n\n",
            "called": [
                "FUN_000802da",
                "FUN_00081730",
                "FUN_00081894",
                "FUN_00081ca8",
                "FUN_00081d1c",
                "FUN_00081734",
                "FUN_00081c94",
                "thunk_FUN_00081714",
                "FUN_00081944",
                "FUN_0008189c",
                "FUN_0008043e",
                "FUN_00081cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000805d0",
            "calling": [
                "FUN_000816a8"
            ],
            "imported": false,
            "current_name": "process_data_000805d0"
        },
        "FUN_000813e4": {
            "renaming": {
                "FUN_000813e4": "calculate_difference_000813e4",
                "param_1": "input_param",
                "*(int *)(param_1 + 0x10)": "ptr1",
                "*(int *)(*(int *)(param_1 + 0x10) + 0x80)": "ptr2",
                "*(int *)(*(int *)(param_1 + 0x10) + 0x84)": "ptr3",
                "*(int *)(ptr1 + 0x80)": "ptr2",
                "*(int *)(ptr1 + 0x84)": "ptr3"
            },
            "code": "uint calculate_difference_000813e4(int input_param) {\n    int* ptr1 = *(int *)(input_param + 0x10);\n    int* ptr2 = *(int *)(ptr1 + 0x80);\n    int* ptr3 = *(int *)(ptr1 + 0x84);\n    int result = *ptr2 - *ptr3 & 0x7f;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000813e4",
            "calling": [
                "FUN_00080ce0"
            ],
            "imported": false,
            "current_name": "calculate_difference_000813e4"
        },
        "FUN_0008120c": {
            "renaming": {
                "FUN_0008120c": "do_nothing_0008120c"
            },
            "code": "\nvoid do_nothing_0008120c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008120c",
            "calling": [
                "FUN_000816a8"
            ],
            "imported": false,
            "current_name": "do_nothing_0008120c"
        },
        "FUN_00084290": {
            "renaming": {
                "FUN_00084290": "get_dat_value_00084290",
                "DAT_00084294": "data_value"
            },
            "code": "int get_dat_value_00084290(void)\n{\n  return DAT_00084294;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00084290",
            "calling": [
                "FUN_0008456c"
            ],
            "imported": false,
            "current_name": "get_dat_value_00084290"
        },
        "FUN_000846b4": {
            "renaming": {
                "FUN_000846b4": "set_memory_flag_000846b4",
                "param_1": "result",
                "param_2": "start_address",
                "param_3": "end_address",
                "param_4": "flag",
                "puVar1": "ptr",
                "iVar2": "status"
            },
            "code": "void set_memory_flag_000846b4(int *result, int start_address, int end_address, int flag, int size) {\n    undefined *ptr = PTR_DAT_000846d8;\n    *(int *)PTR_DAT_000846d8 = 0;\n    int status = set_memory_flag_000846b4_000811b4(start_address, end_address, end_address, flag, size);\n    if (status == -1 && *(int *)ptr != 0) {\n        *result = *(int *)ptr;\n        return;\n    }\n    return;\n}",
            "called": [
                "FUN_000811b4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000846b4",
            "calling": [
                "FUN_000842a4"
            ],
            "imported": false,
            "current_name": "set_memory_flag_000846b4"
        },
        "FUN_000813a8": {
            "renaming": {
                "FUN_000813a8": "initialize_buffer_000813a8",
                "param_1": "buffer_address",
                "fill_memory_with_value_00082504": "fill_memory_with_value",
                "0": "ZERO",
                "0x80": "BUFFER_SIZE",
                "0x84": "SECOND_VALUE"
            },
            "code": "int initialize_buffer_000813a8(int buffer_address)\n{\n    // Fill buffer with 0s\n    fill_memory_with_value(buffer_address, 0, BUFFER_SIZE);\n    // Set two 4-byte values to 0\n    *(int *)(buffer_address + 0x80) = 0;\n    *(int *)(buffer_address + 0x84) = 0;\n    // Return the buffer address\n    return buffer_address;\n}",
            "called": [
                "FUN_00082504"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000813a8",
            "calling": [
                "FUN_00080c0c"
            ],
            "imported": false,
            "current_name": "initialize_buffer_000813a8"
        },
        "FUN_00083d9c": {
            "renaming": {
                "FUN_00083d9c": "allocate_memory_block_00083d9c",
                "param_1": "memory",
                "param_2": "size",
                "iVar1": "prev_block",
                "uVar2": "header",
                "iVar3": "next_block",
                "uVar4": "block_size",
                "iVar5": "block_start",
                "iVar6": "block_end",
                "uVar7": "block_end_header",
                "iVar8": "heap_start",
                "do_nothing_00082598": "do_nothing_1",
                "DAT_00083f24": "heap_start_address",
                "PTR_DAT_00083f30": "block_size_address",
                "DAT_00083f28": "heap_end_address",
                "do_nothing_0008259c": "do_nothing_2"
            },
            "code": "void allocate_memory_block_00083d9c(void *memory, int size) {\n  if (size == 0) {\n    return;\n  }\n  do_nothing_1();\n  int heap_start = DAT_00083f24;\n  uint header = *(uint *)(size - 4);\n  int block_start = size - 8;\n  uint block_size = header & 0xfffffffe;\n  int block_end = block_start + block_size;\n  uint block_end_header = *(uint *)(block_end + 4) & 0xfffffffc;\n  if (*(int *)(heap_start + 8) == block_end) {\n    block_end_header += block_size;\n    if (-1 < (int)(header << 0x1f)) {\n      block_start -= *(int *)(size - 8);\n      int prev_block = *(int *)(block_start + 0xc);\n      int next_block = *(int *)(block_start + 8);\n      block_end_header += *(int *)(size - 8);\n      *(int *)(next_block + 0xc) = prev_block;\n      *(int *)(prev_block + 8) = next_block;\n    }\n    uint heap_end = *DAT_00083f28;\n    *(uint *)(block_start + 4) = block_end_header | 1;\n    *(int *)(heap_start + 8) = block_start;\n    if (heap_end <= block_end_header) {\n      allocate_memory_block_00083d9c(memory, *PTR_DAT_00083f30);\n    }\n  }\n  else {\n    header = header & 1;\n    *(uint *)(block_end + 4) = block_end_header;\n    if (header == 0) {\n      block_start -= *(int *)(size - 8);\n      int prev_block = *(int *)(block_start + 8);\n      block_size = block_size + *(int *)(size - 8);\n      if (prev_block == heap_start + 8) {\n        header = 1;\n      }\n      else {\n        int next_block = *(int *)(block_start + 0xc);\n        *(int *)(prev_block + 0xc) = next_block;\n        *(int *)(next_block + 8) = prev_block;\n      }\n    }\n    else {\n      header = 0;\n    }\n    if (-1 < *(int *)(block_end + block_end_header + 4) << 0x1f) {\n      block_size += block_end_header;\n      int next_block = *(int *)(block_end + 8);\n      if ((header == 0) && (next_block == DAT_00083f28)) {\n        *(int *)(heap_start + 0x14) = block_start;\n        *(int *)(heap_start + 0x10) = block_start;\n        *(int *)(block_start + 0xc) = next_block;\n        *(int *)(block_start + 8) = next_block;\n        *(uint *)(block_start + 4) = block_size | 1;\n        *(uint *)(block_start + block_size) = block_size;\n        goto LAB_00083e30;\n      }\n      int prev_block = *(int *)(block_end + 0xc);\n      *(int *)(next_block + 0xc) = prev_block;\n      *(int *)(prev_block + 8) = next_block;\n    }\n    *(uint *)(block_start + 4) = block_size | 1;\n    *(uint *)(block_start + block_size) = block_size;\n    if (header == 0) {\n      if (block_size < 0x200) {\n        uint heap_bitmap = *(uint *)(heap_start + 4);\n        int heap_index = heap_start + (block_size & 0xfffffff8);\n        int next_block = *(int *)(heap_index + 8);\n        *(int *)(block_start + 8) = next_block;\n        *(int *)(block_start + 0xc) = heap_index;\n        *(uint *)(heap_start + 4) = heap_bitmap | 1 << ((int)(block_size >> 3) >> 2 & 0xffU);\n        *(int *)(heap_index + 8) = block_start;\n        *(int *)(next_block + 0xc) = block_start;\n        do_nothing_2(memory);\n        return;\n      }\n      uint heap_index = block_size >> 9;\n      if (heap_index < 5) {\n        int block_index = (block_size >> 6) + 0x38;\n        int heap_offset = block_index * 2;\n      }\n      else if (heap_index < 0x15) {\n        int block_index = heap_index + 0x5b;\n        int heap_offset = block_index * 2;\n      }\n      else if (heap_index < 0x55) {\n        int block_index = (block_size >> 0xc) + 0x6e;\n        int heap_offset = block_index * 2;\n      }\n      else if (heap_index < 0x155) {\n        int block_index = (block_size >> 0xf) + 0x77;\n        int heap_offset = block_index * 2;\n      }\n      else if (heap_index < 0x555) {\n        int block_index = (block_size >> 0x12) + 0x7c;\n        int heap_offset = block_index * 2;\n      }\n      else {\n        int heap_offset = 0xfc;\n        int block_index = 0x7e;\n      }\n      int heap_index_address = DAT_00083f24 + heap_offset * 4;\n      int next_block = *(int *)(heap_index_address + 8);\n      if (next_block == heap_index_address) {\n        *(uint *)(heap_start + 4) = *(uint *)(heap_start + 4) | 1 << (block_index >> 2 & 0xffU);\n        heap_index_address = next_block;\n      }\n      else {\n        do {\n          if ((*(uint *)(next_block + 4) & 0xfffffffc) <= block_size) break;\n          next_block = *(int *)(next_block + 8);\n        } while (heap_index_address != next_block);\n        heap_index_address = *(int *)(next_block + 0xc);\n      }\n      *(int *)(block_start + 0xc) = heap_index_address;\n      *(int *)(block_start + 8) = next_block;\n      *(int *)(heap_index_address + 8) = block_start;\n      *(int *)(next_block + 0xc) = block_start;\n    }\n  }\nLAB_00083e30:\n  do_nothing_2(memory);\n  return;\n}",
            "called": [
                "FUN_00083d00",
                "FUN_00082598",
                "FUN_0008259c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00083d9c",
            "calling": [
                "FUN_00083adc",
                "FUN_00083808",
                "FUN_000825b0",
                "FUN_00081e04",
                "FUN_00083f34",
                "FUN_00081e14",
                "FUN_000846a4"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_00083d9c"
        },
        "FUN_00083c08": {
            "renaming": {
                "FUN_00083c08": "do_nothing_00083c08"
            },
            "code": "\nvoid do_nothing_00083c08(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00083c08",
            "calling": [
                "FUN_000846a4"
            ],
            "imported": false,
            "current_name": "do_nothing_00083c08"
        },
        "FUN_00081bf4": {
            "renaming": {
                "FUN_00081bf4": "calculate_result_00081bf4",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar2": "result_1",
                "uVar3": "result_2",
                "uVar4": "combined_result",
                "bVar5": "is_combined_result_zero",
                "bVar1": "is_negative_result"
            },
            "code": "uint calculate_result_00081bf4(uint input_1, uint input_2)\n{\n  bool is_negative_result;\n  uint result_1;\n  uint result_2;\n  uint combined_result;\n  bool is_combined_result_zero;\n  \n  result_1 = input_1 * 2;\n  result_2 = input_2 * 2;\n  \n  if (((int)result_1 >> 0x18 == -1 || (int)result_2 >> 0x18 == -1) &&\n     ((((int)result_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)result_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  \n  combined_result = result_1 | input_2 & 0x7fffffff;\n  is_combined_result_zero = combined_result == 0;\n  if (!is_combined_result_zero) {\n    combined_result = input_1 ^ input_2;\n    is_combined_result_zero = combined_result == 0;\n  }\n  is_negative_result = -1 < (int)combined_result;\n  if (is_negative_result) {\n    input_1 = result_1 + input_2 * -2;\n    is_combined_result_zero = input_1 == 0;\n  }\n  \n  if ((is_negative_result && result_2 <= result_1) && !is_combined_result_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  \n  if (!is_negative_result || result_2 > result_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  \n  if (!is_combined_result_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081bf4",
            "calling": [
                "FUN_00081c5c"
            ],
            "imported": false,
            "current_name": "calculate_result_00081bf4"
        },
        "FUN_00081d7c": {
            "renaming": {
                "FUN_00081d7c": "execute_functions_00081d7c",
                "puVar1": "end_pointer",
                "puVar2": "start_pointer",
                "iVar3": "i",
                "ppcVar4": "function_pointer",
                "iVar5": "num_functions"
            },
            "code": "void execute_functions_00081d7c() {\n  code **function_pointer;\n  int num_functions = (int)PTR_functions_end - (int)PTR_functions_start >> 2;\n  if (num_functions != 0) {\n    function_pointer = (code **)(PTR_functions_start + -4);\n    for (int i = 0; i < num_functions; i++) {\n      function_pointer++;\n      (**function_pointer)();\n    }\n  }\n  undefined *end_pointer = PTR_end_pointer;\n  undefined *start_pointer = PTR_start_pointer;\n  do_nothing();\n  int num_pointers = (int)start_pointer - (int)end_pointer >> 2;\n  if (num_pointers != 0) {\n    function_pointer = (code **)(end_pointer + -4);\n    for (int i = 0; i < num_pointers; i++) {\n      function_pointer++;\n      (**function_pointer)();\n    }\n    return;\n  }\n  return;\n}",
            "called": [
                "FUN_00083974",
                "FUN_00080118",
                "FUN_00085858"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081d7c",
            "calling": [
                "FUN_00080ae4"
            ],
            "imported": false,
            "current_name": "execute_functions_00081d7c"
        },
        "FUN_00081c5c": {
            "renaming": {
                "FUN_00081c5c": "concatenate_params_00081c5c",
                "param_1": "param1",
                "param_2": "param2",
                "CONCAT44": "bitwise_concatenation",
                "calculate_result_00081bf4": "calculate_result"
            },
            "code": "uint64_t concatenate_params_00081c5c(uint32_t param1, uint32_t param2)\n{\n    calculate_result();\n    return ((uint64_t)param2 << 32) | param1;\n}",
            "called": [
                "FUN_00081bf4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081c5c",
            "calling": [
                "FUN_00081c94",
                "FUN_00081c54"
            ],
            "imported": false,
            "current_name": "concatenate_params_00081c5c"
        },
        "FUN_00081388": {
            "renaming": {
                "FUN_00081388": "decrement_and_call_if_zero_00081388",
                "*DAT_000813a0": "*PTR_000813a0",
                "*DAT_000813a4": "*DAT_000813a4",
                "iVar1": "count"
            },
            "code": "void decrement_and_call_if_zero_00081388(void)\n{\n  int count = *DAT_000813a0;\n  if (count != -1) {\n    count--;\n    *DAT_000813a0 = count;\n    if (count == 0) {\n      (*DAT_000813a4)();\n    }\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081388",
            "calling": [],
            "imported": false,
            "current_name": "decrement_and_call_if_zero_00081388"
        },
        "FUN_00082598": {
            "renaming": {
                "FUN_00082598": "do_nothing_00082598"
            },
            "code": "\nvoid do_nothing_00082598(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00082598",
            "calling": [
                "FUN_00083d00",
                "FUN_00083d9c",
                "FUN_000825b0",
                "FUN_00081e14"
            ],
            "imported": false,
            "current_name": "do_nothing_00082598"
        },
        "FUN_00082994": {
            "renaming": {
                "FUN_00082994": "copy_string_00082994",
                "param_1": "destination",
                "param_2": "source",
                "cVar1": "current_char",
                "uVar2": "current_short",
                "puVar3": "src_ptr",
                "puVar4": "dst_ptr",
                "uVar5": "current_word",
                "uVar6": "next_word",
                "puVar7": "destination",
                "bVar8": "is_null_terminator"
            },
            "code": "void copy_string_00082994(uint *destination, uint *source)\n{\n    char current_char;\n    ushort current_short;\n    uint *src_ptr;\n    uint *dst_ptr;\n    uint current_word;\n    uint next_word;\n    bool is_null_terminator;\n\n    if ((((uint)destination ^ (uint)source) & 3) != 0) {\n        do {\n            current_char = *(char *)source;\n            *(char *)destination = current_char;\n            source = (uint *)((int)source + 1);\n            destination = (uint *)((int)destination + 1);\n        } while (current_char != '\\0');\n        return;\n    }\n    if (((uint)source & 3) != 0) {\n        src_ptr = source;\n        if (((uint)source & 1) != 0) {\n            src_ptr = (uint *)((int)source + 1);\n            current_char = *(char *)source;\n            *(char *)destination = current_char;\n            destination = (uint *)((int)destination + 1);\n            if (current_char == '\\0') {\n                return;\n            }\n        }\n        source = src_ptr;\n        if (((uint)src_ptr & 2) != 0) {\n            source = (uint *)((int)src_ptr + 2);\n            current_short = *(ushort *)src_ptr;\n            is_null_terminator = (current_short & 0xff) == 0;\n            if (is_null_terminator) {\n                *(char *)destination = (char)current_short;\n            }\n            else {\n                *(ushort *)destination = current_short;\n                is_null_terminator = (current_short & 0xff00) == 0;\n                destination = (uint *)((int)destination + 2);\n            }\n            if (is_null_terminator) {\n                return;\n            }\n        }\n    }\n    current_word = *source;\n    src_ptr = source + 1;\n    dst_ptr = destination;\n    if (((uint)source & 4) != 0) {\n        if ((current_word + 0xfefefeff & ~current_word & 0x80808080) != 0) goto LAB_000829f8;\n        dst_ptr = destination + 1;\n        *destination = current_word;\n        src_ptr = source + 2;\n        current_word = source[1];\n    }\n    while (true) {\n        next_word = *src_ptr;\n        destination = dst_ptr;\n        if ((current_word + 0xfefefeff & ~current_word & 0x80808080) != 0) break;\n        destination = dst_ptr + 1;\n        *dst_ptr = current_word;\n        current_word = next_word;\n        if ((next_word + 0xfefefeff & ~next_word & 0x80808080) != 0) break;\n        src_ptr = src_ptr + 2;\n        dst_ptr = dst_ptr + 2;\n        *destination = current_word;\n    }\nLAB_000829f8:\n    do {\n        *(char *)destination = (char)current_word;\n        next_word = current_word & 0xff;\n        current_word = current_word >> 8 | current_word << 0x18;\n        destination = (uint *)((int)destination + 1);\n    } while (next_word != 0);\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00082994",
            "calling": [
                "FUN_0008165c"
            ],
            "imported": false,
            "current_name": "copy_string_00082994"
        },
        "FUN_00080c0c": {
            "renaming": {
                "FUN_00080c0c": "initialize_data_buffers_00080c0c",
                "param_1": "buffer1",
                "param_2": "buffer2",
                "param_3": "data",
                "puVar1": "buffer1_ptr",
                "puVar2": "buffer2_ptr",
                "puVar3": "data_buffer1_ptr",
                "puVar4": "data_buffer2_ptr",
                "puVar5": "data_buffer3_ptr",
                "puVar6": "data_buffer4_ptr"
            },
            "code": "void initialize_data_buffers_00080c0c(undefined4 buffer1, undefined4 buffer2, undefined4 data)\n{\n  undefined *buffer1_ptr;\n  undefined *buffer2_ptr;\n  undefined *data_buffer1_ptr;\n  undefined *data_buffer2_ptr;\n  undefined *data_buffer3_ptr;\n  undefined *data_buffer4_ptr;\n\n  buffer2_ptr = PTR_DAT_00080ca4;\n  buffer1_ptr = PTR_DAT_00080ca0;\n  initialize_buffer_000813a8(buffer1_ptr);\n  initialize_buffer_000813a8(buffer2_ptr);\n  data_buffer3_ptr = PTR_DAT_00080cd8;\n  data_buffer1_ptr = PTR_DAT_00080cac;\n  initialize_params_000814e4(PTR_DAT_00080cb0, DAT_00080ca8, 8, 8, buffer1_ptr, buffer2_ptr, data);\n  buffer1_ptr = PTR_DAT_00080cb4;\n  initialize_buffer_000813a8(data_buffer3_ptr);\n  data_buffer4_ptr = PTR_DAT_00080cdc;\n  initialize_buffer_000813a8(data_buffer1_ptr);\n  buffer2_ptr = PTR_DAT_00080cb8;\n  initialize_buffer_000813a8(buffer1_ptr);\n  data_buffer2_ptr = PTR_DAT_00080cbc;\n  initialize_buffer_000813a8(data_buffer4_ptr);\n  initialize_buffer_000813a8(buffer2_ptr);\n  initialize_buffer_000813a8(data_buffer2_ptr);\n  update_data_ptr_000815d4(PTR_DAT_00080cc4, DAT_00080cc0, 0x11, 0x11, data_buffer3_ptr, data_buffer4_ptr);\n  update_data_ptr_000815d4(PTR_DAT_00080ccc, DAT_00080cc8, 0x12, 0x12, data_buffer1_ptr, buffer2_ptr);\n  update_data_ptr_000815d4(PTR_DAT_00080cd4, DAT_00080cd0, 0x14, 0x14, buffer1_ptr, data_buffer2_ptr);\n  return;\n}",
            "called": [
                "FUN_000814e4",
                "FUN_000815d4",
                "FUN_000813a8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080c0c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_data_buffers_00080c0c"
        },
        "FUN_00080d2e": {
            "renaming": {
                "FUN_00080d2e": "set_param_00080d2e",
                "param_1": "base_address",
                "param_2": "value",
                "param_3": "param_type",
                "uVar1": "and_mask",
                "uVar2": "or_mask"
            },
            "code": "void set_param_00080d2e(uint32_t base_address, uint32_t value, uint32_t param_type) {\n  *(uint32_t *)(base_address + 0x44) = value;\n  switch(param_type) {\n    case 0:\n    case 3:\n    case 4:\n    case 5:\n      return;\n    case 1:\n      uint32_t and_mask = *(uint32_t *)(base_address + 0x70) & *(uint32_t *)(base_address + 0x70) & ~value;\n      *(uint32_t *)(base_address + 0x70) = and_mask;\n      break;\n    case 2:\n      uint32_t or_mask = *(uint32_t *)(base_address + 0x70) | value;\n      *(uint32_t *)(base_address + 0x70) = or_mask;\n      break;\n    default:\n      *(uint32_t *)(base_address + 4) = value;\n      return;\n  }\n  *(uint32_t *)(base_address + 4) = value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080d2e",
            "calling": [
                "FUN_00080da0"
            ],
            "imported": false,
            "current_name": "set_param_00080d2e"
        },
        "FUN_00081944": {
            "renaming": {
                "FUN_00081944": "calculate_float_00081944",
                "param_1": "float1",
                "param_2": "float2",
                "param_3": "unknown",
                "param_4": "unknown2",
                "lVar1": "long_var",
                "uVar2": "result",
                "uVar3": "byte1",
                "iVar4": "sum_of_bytes",
                "iVar5": "diff_from_7f",
                "iVar7": "diff_from_ff",
                "uVar6": "multiplied",
                "uVar8": "temp_result",
                "bVar9": "bool1",
                "bVar10": "bool2"
            },
            "code": "\nuint calculate_float_00081944(uint float1,uint float2,undefined4 unknown,uint unknown2)\n\n{\n  longlong long_var;\n  uint result;\n  uint byte1;\n  int sum_of_bytes;\n  int diff_from_7f;\n  uint multiplied;\n  int diff_from_ff;\n  uint temp_result;\n  bool bool1;\n  bool bool2;\n  \n  byte1 = float1 >> 0x17 & 0xff;\n  bool1 = byte1 == 0;\n  if (!bool1) {\n    unknown2 = float2 >> 0x17 & 0xff;\n    bool1 = unknown2 == 0;\n  }\n  if (!bool1) {\n    bool1 = byte1 == 0xff;\n  }\n  if (!bool1) {\n    bool1 = unknown2 == 0xff;\n  }\n  if (bool1) {\n    unknown2 = float2 >> 0x17 & 0xff;\n    if (byte1 == 0xff || unknown2 == 0xff) {\n      bool1 = float1 == 0 || float1 == 0x80000000;\n      result = float2;\n      if (float1 != 0 && float1 != 0x80000000) {\n        bool1 = float2 == 0;\n        result = float1;\n      }\n      if (!bool1) {\n        bool1 = float2 == 0x80000000;\n      }\n      temp_result = result;\n      if (((bool1) || ((byte1 == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((unknown2 == 0xff && (temp_result = float2, (float2 & 0x7fffff) != 0)))) {\n        return temp_result | 0x7fc00000;\n      }\n      result = result ^ float2;\n      goto LAB_00081a94;\n    }\n    bool1 = (float1 & 0x7fffffff) == 0;\n    if (!bool1) {\n      bool1 = (float2 & 0x7fffffff) == 0;\n    }\n    if (bool1) {\n      return (float1 ^ float2) & 0x80000000;\n    }\n    bool1 = byte1 == 0;\n    result = float1 & 0x80000000;\n    while( true ) {\n      if (bool1) {\n        float1 = float1 << 1;\n        bool1 = (float1 & 0x800000) == 0;\n      }\n      if (!bool1) break;\n      byte1 = byte1 - 1;\n    }\n    float1 = float1 | result;\n    bool1 = unknown2 == 0;\n    result = float2 & 0x80000000;\n    while( true ) {\n      if (bool1) {\n        float2 = float2 << 1;\n        bool1 = (float2 & 0x800000) == 0;\n      }\n      if (!bool1) break;\n      unknown2 = unknown2 - 1;\n    }\n    float2 = float2 | result;\n  }\n  sum_of_bytes = byte1 + unknown2;\n  temp_result = float1 ^ float2;\n  byte1 = float1 << 9;\n  bool1 = byte1 == 0;\n  if (!bool1) {\n    float2 = float2 << 9;\n    bool1 = float2 == 0;\n  }\n  if (bool1) {\n    if (byte1 == 0) {\n      float2 = float2 << 9;\n    }\n    result = temp_result & 0x80000000 | float1 & 0x7fffff | float2 >> 9;\n    bool2 = SBORROW4(sum_of_bytes,0x7f);\n    diff_from_7f = sum_of_bytes + -0x7f;\n    bool1 = diff_from_7f == 0;\n    diff_from_ff = diff_from_7f;\n    if (!bool1 && 0x7e < sum_of_bytes) {\n      bool2 = SBORROW4(0xff,diff_from_7f);\n      diff_from_ff = 0xff - diff_from_7f;\n      bool1 = diff_from_7f == 0xff;\n    }\n    if (!bool1 && diff_from_ff < 0 == bool2) {\n      result = result | diff_from_7f * 0x800000;\n    }\n    if (!bool1 && diff_from_ff < 0 == bool2) {\n      return result;\n    }\n    result = result | 0x800000;\n    multiplied = 0;\n    bool2 = SBORROW4(diff_from_7f,1);\n    temp_result = sum_of_bytes - 0x80;\n    bool1 = temp_result == 0;\n    byte1 = temp_result;\n  }\n  else {\n    long_var = (ulonglong)(byte1 >> 5 | 0x8000000) * (ulonglong)(float2 >> 5 | 0x8000000);\n    multiplied = (uint)long_var;\n    result = (uint)((ulonglong)long_var >> 0x20);\n    bool1 = result < 0x800000;\n    if (bool1) {\n      result = result << 1;\n    }\n    if (bool1) {\n      result = result | multiplied >> 0x1f;\n      multiplied = multiplied << 1;\n    }\n    result = temp_result & 0x80000000 | result;\n    temp_result = (sum_of_bytes + -0x7f) - (uint)bool1;\n    bool2 = SBORROW4(temp_result,0xfd);\n    bool1 = temp_result == 0xfd;\n    byte1 = temp_result - 0xfd;\n    if (temp_result < 0xfe) {\n      result = result + temp_result * 0x800000 + (uint)(0x7fffffff < multiplied);\n      if (multiplied == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (bool1 || (int)byte1 < 0 != bool2) {\n    bool1 = (int)(temp_result + 0x19) < 0;\n    if (temp_result == 0xffffffe7 || bool1 != SCARRY4(temp_result,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (temp_result != 0xffffffe7 && bool1 == SCARRY4(temp_result,0x19)) {\n      byte1 = (result << 1) >> (-temp_result & 0xff);\n      temp_result = result << (temp_result + 0x20 & 0xff);\n      byte1 = ((uint)((result & 0x80000000) != 0) << 0x1f | byte1 >> 1) + (uint)((byte)byte1 & 1);\n      if ((multiplied | temp_result << 1) == 0) {\n        byte1 = byte1 & ~(temp_result >> 0x1f);\n      }\n      return byte1;\n    }\n    return result;\n  }\nLAB_00081a94:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081944",
            "calling": [
                "FUN_000805d0"
            ],
            "imported": false,
            "current_name": "calculate_float_00081944"
        },
        "FUN_000844c4": {
            "renaming": {
                "FUN_000844c4": "process_input_000844c4",
                "param_1": "input_length",
                "param_2": "input_value",
                "param_3": "input_array",
                "param_4": "input_flag",
                "uVar1": "flag_value",
                "uVar2": "value",
                "puVar3": "array_ptr",
                "iVar4": "array_offset"
            },
            "code": "uint process_input_000844c4(int input_length, uint input_value, undefined4 *input_array, undefined4 input_flag)\n{\n  ushort flag_value;\n  uint value;\n  undefined *array_ptr;\n  int array_offset;\n  \n  if ((input_length != 0) && (*(int *)(input_length + 0x38) == 0)) {\n    initialize_00083b14();\n  }\n  flag_value = *(ushort *)(input_array + 3);\n  value = (uint)flag_value;\n  input_array[2] = input_array[6];\n  if ((-1 < (int)(value << 0x1c)) || (array_offset = input_array[4], array_offset == 0)) {\n    array_offset = check_and_update_00083808(input_length, input_array, flag_value, value, input_flag);\n    if (array_offset != 0) {\n      return 0xffffffff;\n    }\n    flag_value = *(ushort *)(input_array + 3);\n    array_offset = input_array[4];\n    value = (uint)flag_value;\n  }\n  input_value = input_value & 0xff;\n  if ((int)(value << 0x12) < 0) {\n    array_ptr = (undefined *)*input_array;\n    array_offset = (int)array_ptr - array_offset;\n    if (array_offset < (int)input_array[5]) {\n      goto LAB_000844f6;\n    }\n  }\n  else {\n    input_array[0x19] = input_array[0x19] & 0xffffdfff;\n    array_ptr = (undefined *)*input_array;\n    *(ushort *)(input_array + 3) = flag_value | 0x2000;\n    array_offset = (int)array_ptr - array_offset;\n    if (array_offset < (int)input_array[5]) {\n      goto LAB_000844f6;\n    }\n  }\n  array_offset = process_data_00083adc(input_length, input_array);\n  if (array_offset != 0) {\n    return 0xffffffff;\n  }\n  array_ptr = (undefined *)*input_array;\n  array_offset = 1;\nLAB_000844f8:\n  input_array[2] = input_array[2] + -1;\n  *input_array = array_ptr + 1;\n  *array_ptr = (char)input_value;\n  if (((input_array[5] == array_offset) || (((int)((uint)*(ushort *)(input_array + 3) << 0x1f) < 0 && (input_value == 10)))) && (array_offset = process_data_00083adc(input_length, input_array), array_offset != 0)) {\n    return 0xffffffff;\n  }\n  return input_value;\n}",
            "called": [
                "FUN_00083adc",
                "FUN_00083808",
                "FUN_00083b14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000844c4",
            "calling": [
                "FUN_00083c40"
            ],
            "imported": false,
            "current_name": "process_input_000844c4"
        },
        "FUN_0008189c": {
            "renaming": {
                "FUN_0008189c": "reverse_bits_0008189c",
                "param_1": "abs_num",
                "iVar1": "leading_zeros",
                "uVar2": "shift_amount",
                "uVar3": "sign_bit",
                "iVar4": "initial_val",
                "uVar5": "mask",
                "shifted_num": "shifted_num",
                "carry": "carry",
                "sum": "sum"
            },
            "code": "uint reverse_bits_0008189c(uint num)\n{\n    int leading_zeros = count_leading_zeroes(num);\n    uint shift_amount = leading_zeros - 8;\n    uint sign_bit = num & 0x80000000;\n    uint abs_num = (sign_bit < 0) ? -num : num;\n    if (abs_num == 0)\n        return 0;\n    uint initial_val = ((sign_bit | 0x4b000000) - 0x800000) + shift_amount * -0x800000;\n    if (leading_zeros > 7)\n    {\n        uint mask = 0 << (shift_amount & 0xff);\n        uint shifted_num = abs_num << (shift_amount & 0xff);\n        uint carry = 0U >> (0x20 - shift_amount & 0xff);\n        uint sum = initial_val + shifted_num + carry + (uint)(0x7fffffff < mask);\n        if (mask == 0x80000000)\n            sum = sum & 0xfffffffe;\n        return sum;\n    }\n    uint shifted_num = abs_num << (leading_zeros + 0x18U & 0xff);\n    uint carry = ((int)shifted_num >> 0x1f);\n    uint sum = initial_val + ((abs_num >> (0x20 - (leading_zeros + 0x18U) & 0xff)) - carry);\n    if ((shifted_num & 0x7fffffff) == 0)\n        sum = sum & ~(shifted_num >> 0x1f);\n    return sum;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008189c",
            "calling": [
                "FUN_000805d0"
            ],
            "imported": false,
            "current_name": "reverse_bits_0008189c"
        },
        "FUN_0008234c": {
            "renaming": {
                "FUN_0008234c": "copy_memory_block_0008234c",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "size",
                "puVar1": "dest_ptr",
                "puVar2": "dest_ptr",
                "puVar3": "src_ptr",
                "uVar4": "i",
                "uVar5": "remaining_size",
                "bVar6": "is_aligned"
            },
            "code": "undefined4 *copy_memory_block_0008234c(undefined4 *destination, undefined4 *source, uint32_t size)\n{\n    undefined4 *dest_ptr;\n    undefined4 *src_ptr;\n    uint32_t remaining_size;\n    uint32_t i;\n    bool is_aligned;\n\n    dest_ptr = destination;\n    is_aligned = (((uint32_t)source | (uint32_t)destination) & 3) == 0;\n    if (!is_aligned)\n    {\n        if (size < 8)\n        {\n            remaining_size = size - 4;\n            if (remaining_size > 0)\n            {\n                do\n                {\n                    *dest_ptr++ = *source++;\n                    remaining_size--;\n                } while (remaining_size > 0);\n                *dest_ptr++ = *source++;\n                *dest_ptr++ = *source++;\n                *dest_ptr = *source;\n            }\n            else if (size > 0)\n            {\n                *dest_ptr++ = *source++;\n                if (size > 1)\n                {\n                    *dest_ptr++ = *source++;\n                    if (size > 2)\n                    {\n                        *dest_ptr++ = *source++;\n                    }\n                }\n            }\n            return destination;\n        }\n        if (((uint32_t)source & 3) != 0)\n        {\n            remaining_size = 4 - ((uint32_t)destination & 3);\n            size -= remaining_size;\n            src_ptr = source;\n            if (((uint32_t)destination & 1) != 0)\n            {\n                src_ptr = (undefined4 *)((int)source + 1);\n                destination = (undefined4 *)((int)destination + 1);\n                *(undefined *)destination = *(undefined *)source;\n            }\n            dest_ptr = destination;\n            if ((remaining_size & 2) != 0)\n            {\n                source = (undefined4 *)((int)source + 2);\n                destination = (undefined4 *)((int)destination + 2);\n                *(undefined2 *)dest_ptr = *(undefined2 *)src_ptr;\n            }\n        }\n    }\n    i = size >> 4;\n    remaining_size = size & 0xF;\n    while (i > 0)\n    {\n        *dest_ptr++ = *source++;\n        dest_ptr[0] = source[0];\n        dest_ptr[1] = source[1];\n        dest_ptr[2] = source[2];\n        dest_ptr[3] = source[3];\n        dest_ptr[4] = source[4];\n        dest_ptr[5] = source[5];\n        dest_ptr[6] = source[6];\n        dest_ptr[7] = source[7];\n        dest_ptr[8] = source[8];\n        dest_ptr[9] = source[9];\n        dest_ptr[10] = source[10];\n        dest_ptr[11] = source[11];\n        dest_ptr[12] = source[12];\n        dest_ptr[13] = source[13];\n        dest_ptr[14] = source[14];\n        dest_ptr[15] = source[15];\n        dest_ptr += 16;\n        source += 16;\n        i--;\n    }\n    if (remaining_size > 0)\n    {\n        remaining_size += 12;\n        src_ptr = source;\n        dest_ptr = dest_ptr;\n        if ((remaining_size & 3) != 0)\n        {\n            if ((remaining_size & 1) != 0)\n            {\n                src_ptr = (undefined4 *)((int)source + 1);\n                dest_ptr = (undefined4 *)((int)dest_ptr + 1);\n                *(undefined *)dest_ptr = *(undefined *)src_ptr;\n            }\n            if ((remaining_size & 2) != 0)\n            {\n                *(undefined2 *)dest_ptr = *(undefined2 *)src_ptr;\n            }\n        }\n        else\n        {\n            do\n            {\n                *dest_ptr++ = *src_ptr++;\n                remaining_size -= 4;\n            } while (remaining_size > 0);\n        }\n    }\n    return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008234c",
            "calling": [
                "FUN_00083f34"
            ],
            "imported": false,
            "current_name": "copy_memory_block_0008234c"
        },
        "FUN_00080a68": {
            "renaming": {
                "FUN_00080a68": "initialize_and_add_to_buffer_00080a68",
                "puVar1": "buffer_pointer",
                "PTR_DAT_00080a94": "buffer_start",
                "PTR_s__00080a98": "array_start",
                "DAT_00080aa0": "data_start",
                "DAT_00080a9c": "data_size",
                "PTR_DAT_00080aa4": "buffer_end"
            },
            "code": "void initialize_and_add_to_buffer_00080a68(void)\n{\n  undefined *PTR_DAT_00080a94 = PTR_DAT_00080a94;\n  initialize_array_with_zeroes_00081682(PTR_DAT_00080a94, PTR_s__00080a98);\n  add_to_buffer_00081d5c(PTR_DAT_00080a94, DAT_00080aa0, DAT_00080a9c);\n  undefined *PTR_DAT_00080aa4 = PTR_DAT_00080aa4;\n  PTR_DAT_00080aa4[4] = 0;\n  PTR_DAT_00080aa4[5] = 0;\n  PTR_DAT_00080aa4[6] = 6;\n  *(undefined2 *)(PTR_DAT_00080aa4 + 0x56) = 1000;\n  return;\n}",
            "called": [
                "FUN_00081682",
                "FUN_00081d5c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080a68",
            "calling": [],
            "imported": false,
            "current_name": "initialize_and_add_to_buffer_00080a68"
        },
        "FUN_0008165c": {
            "renaming": {
                "FUN_0008165c": "execute_and_check_reset_memory_0008165c_0008165c",
                "param_1": "memory",
                "param_2": "input",
                "param_3": "size",
                "iVar1": "result",
                "reset_memory_0008160c": "reset_memory",
                "copy_string_00082994": "copy_string"
            },
            "code": "undefined4* execute_and_check_reset_memory_0008165c_0008165c(undefined4* memory, undefined4 input, undefined4 size) {\n  int result = execute_and_check_0008163a(memory, size);\n  if (result == 0) {\n    reset_memory_0008160c(memory);\n  } else {\n    memory[2] = size;\n    copy_string_00082994(*memory, input);\n  }\n  return memory;\n}",
            "called": [
                "FUN_00082994",
                "FUN_0008160c",
                "FUN_0008163a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008165c",
            "calling": [
                "FUN_00081682"
            ],
            "imported": false,
            "current_name": "execute_and_check_reset_memory_0008165c_0008165c"
        },
        "FUN_000815f8": {
            "renaming": {
                "FUN_000815f8": "combine_values_000815f8",
                "param_1": "value1",
                "param_2": "value2"
            },
            "code": "uint16_t combine_values_000815f8(int value1, uint8_t value2)\n{\n    return value2 | (value1 << 8);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000815f8",
            "calling": [
                "FUN_00080410"
            ],
            "imported": false,
            "current_name": "combine_values_000815f8"
        },
        "FUN_00084384": {
            "renaming": {
                "FUN_00084384": "find_char_in_buffer_00084384",
                "param_1": "buffer_start",
                "param_2": "search_char",
                "param_3": "buffer_end",
                "puVar1": "buffer_ptr",
                "uVar2": "modified_char",
                "pcVar3": "char_ptr",
                "pcVar4": "last_char_ptr",
                "bVar5": "found_char"
            },
            "code": "uint * find_char_in_buffer_00084384(uint *buffer_start,char search_char,uint *buffer_end)\n{\n  uint *buffer_ptr;\n  uint buffer_size;\n  char *char_ptr;\n  char *last_char_ptr;\n  bool found_char;\n\n  if (((uint)buffer_start & 3) == 0) {\n    buffer_ptr = buffer_start;\n    if ((uint *)0x3 < buffer_end) {\n      do {\n        uint modified_char = *buffer_start ^ CONCAT22(CONCAT11(search_char,search_char),CONCAT11(search_char,search_char));\n        buffer_ptr = buffer_start;\n        if ((modified_char + 0xfefefeff & ~modified_char & 0x80808080) != 0) break;\n        buffer_end = buffer_end - 1;\n        buffer_ptr = buffer_start + 1;\n        buffer_start = buffer_start + 1;\n      } while ((uint *)0x3 < buffer_end);\n    }\n    buffer_start = buffer_end;\n    last_char_ptr = (char *)((int)buffer_start + -1);\n    if ((buffer_start != (uint *)0x0) && (buffer_start = buffer_ptr, *(char *)buffer_ptr != search_char)) {\n      char_ptr = (char *)0x0;\n      do {\n        buffer_start = (uint *)((int)buffer_start + 1);\n        found_char = char_ptr == last_char_ptr;\n        char_ptr = char_ptr + 1;\n        if (found_char) goto END_SEARCH;\n      } while (*(char *)buffer_start != search_char);\n    }\n  }\n  else if (buffer_end == (uint *)0x0) {\n    buffer_start = (uint *)0x0;\n  }\n  else if (*(char *)buffer_start != search_char) {\n    buffer_ptr = (uint *)((int)buffer_start + 1);\n    buffer_end = (uint *)((int)buffer_end + -1);\n    do {\n      buffer_start = buffer_ptr;\n      if (((uint)buffer_start & 3) == 0) {\n        buffer_ptr = buffer_start;\n        if ((uint *)0x3 < buffer_end) {\n          do {\n            uint modified_char = *buffer_start ^ CONCAT22(CONCAT11(search_char,search_char),CONCAT11(search_char,search_char));\n            buffer_ptr = buffer_start;\n            if ((modified_char + 0xfefefeff & ~modified_char & 0x80808080) != 0) break;\n            buffer_end = buffer_end - 1;\n            buffer_ptr = buffer_start + 1;\n            buffer_start = buffer_start + 1;\n          } while ((uint *)0x3 < buffer_end);\n        }\n        buffer_start = buffer_end;\n        last_char_ptr = (char *)((int)buffer_start + -1);\n        if ((buffer_start != (uint *)0x0) && (buffer_start = buffer_ptr, *(char *)buffer_ptr != search_char)) {\n          char_ptr = (char *)0x0;\n          do {\n            buffer_start = (uint *)((int)buffer_start + 1);\n            found_char = char_ptr == last_char_ptr;\n            char_ptr = char_ptr + 1;\n            if (found_char) goto END_SEARCH;\n          } while (*(char *)buffer_start != search_char);\n        }\n        goto END_SEARCH;\n      }\n      if (buffer_end == (uint *)0x0) goto END_SEARCH;\n      buffer_ptr = (uint *)((int)buffer_start + 1);\n      buffer_end = (uint *)((int)buffer_end + -1);\n    } while (*(char *)buffer_start != search_char);\n  }\n  END_SEARCH:\n  return buffer_start;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00084384",
            "calling": [
                "FUN_00082b38",
                "FUN_00083f34"
            ],
            "imported": false,
            "current_name": "find_char_in_buffer_00084384"
        },
        "FUN_00081034": {
            "renaming": {
                "FUN_00081034": "set_param_value_00081034",
                "param_1": "param_address",
                "param_2": "new_value",
                "param_3": "mask",
                "PTR_": "param_ptr",
                "DAT_": "data"
            },
            "code": "void set_param_value_00081034(int param_address, uint32_t new_value, uint32_t mask) {\n    uint32_t* PTR_ = (uint32_t*)(param_address + 4);\n    *PTR_ = (*PTR_ & ~mask) | (new_value & mask);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081034",
            "calling": [
                "FUN_00080ae4"
            ],
            "imported": false,
            "current_name": "set_param_value_00081034"
        },
        "FUN_00083c0c": {
            "renaming": {
                "FUN_00083c0c": "do_nothing_00083c0c"
            },
            "code": "\nvoid do_nothing_00083c0c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00083c0c",
            "calling": [
                "FUN_000846a4"
            ],
            "imported": false,
            "current_name": "do_nothing_00083c0c"
        },
        "FUN_00083974": {
            "renaming": {
                "FUN_00083974": "addDataToBuffer_00083974",
                "param_1": "data",
                "puVar1": "data_ptr",
                "puVar2": "buffer_ptr",
                "iVar3": "buffer_size",
                "iVar4": "buffer_start"
            },
            "code": "undefined4 addDataToBuffer_00083974(undefined4 data)\n{\n  undefined *data_ptr;\n  undefined4 *buffer_ptr;\n  int buffer_size;\n  int buffer_start;\n  \n  data_ptr = PTR_DAT_00083984;\n  if (DAT_00083980 == 0) {\n    return data;\n  }\n  buffer_start = *(int *)PTR_DAT_0008396c;\n  buffer_ptr = *(undefined4 **)(buffer_start + 0x148);\n  if (buffer_ptr == (undefined4 *)0x0) {\n    buffer_ptr = (undefined4 *)(buffer_start + 0x14c);\n    *(undefined4 **)(buffer_start + 0x148) = buffer_ptr;\n  }\n  buffer_size = buffer_ptr[1];\n  if (0x1f < buffer_size) {\n    if ((DAT_00083970 == 0) ||\n       (buffer_ptr = (undefined4 *)execute_function_with_data_00081df4(400), buffer_ptr == (undefined4 *)0x0)) {\n      return 0xffffffff;\n    }\n    *buffer_ptr = *(undefined4 *)(buffer_start + 0x148);\n    buffer_ptr[1] = 0;\n    buffer_size = 0;\n    *(undefined4 **)(buffer_start + 0x148) = buffer_ptr;\n    buffer_ptr[0x62] = 0;\n    buffer_ptr[99] = 0;\n  }\n  buffer_ptr[1] = buffer_size + 1;\n  buffer_ptr[buffer_size + 2] = data_ptr;\n  return 0;\n}",
            "called": [
                "FUN_00081df4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00083974",
            "calling": [
                "FUN_00081d7c"
            ],
            "imported": false,
            "current_name": "addDataToBuffer_00083974"
        },
        "FUN_00084700": {
            "renaming": {
                "FUN_00084700": "get_default_value_00084700",
                "param_1": "output_value",
                "param_2": "input_value_1",
                "param_3": "input_value_2",
                "param_4": "input_value_3",
                "puVar1": "default_value_ptr",
                "iVar2": "default_value"
            },
            "code": "void get_default_value_00084700(int *output_value, int input_value_1, int input_value_2, int input_value_3) {\n    undefined *default_value_ptr;\n    int default_value;\n    default_value_ptr = PTR_DAT_00084724;\n    *(int *)PTR_DAT_00084724 = 0;\n    default_value = get_default_value_00084700_000811c2(input_value_1, input_value_2, input_value_3);\n    if (default_value == -1 && *(int *)default_value_ptr != 0) {\n        *output_value = *(int *)default_value_ptr;\n        return;\n    }\n    return;\n}",
            "called": [
                "FUN_000811c2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00084700",
            "calling": [
                "FUN_00084464",
                "FUN_0008449c"
            ],
            "imported": false,
            "current_name": "get_default_value_00084700"
        },
        "thunk_FUN_00081714": {
            "renaming": {
                "thunk_FUN_00081714": "get_value_from_pointer_thunk_00081714",
                "undefined4": "int",
                "PTR_DAT_0008171c": "pointer_to_value",
                "*(undefined4 *)PTR_DAT_0008171c": "*pointer_to_value"
            },
            "code": "int get_value_from_pointer_thunk_00081714(){\n  int* PTR_DAT_0008171c = (int*)PTR_DAT_0008171c;\n  int value = *(undefined4 *)PTR_DAT_0008171c;\n  return value;\n}",
            "called": [
                "FUN_00081714"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081208",
            "calling": [
                "FUN_00080258",
                "FUN_000804a8",
                "FUN_0008043e",
                "FUN_000805d0"
            ],
            "imported": false,
            "current_name": "get_value_from_pointer_thunk_00081714"
        },
        "FUN_00081ca8": {
            "renaming": {
                "FUN_00081ca8": "check_params_and_swap_00081ca8",
                "in_ZR": "zero",
                "in_CY": "carry",
                "concatenate_params_and_swap_them_00081c54": "concatenate_params_and_swap_them"
            },
            "code": "bool check_params_and_swap_00081ca8(void)\n{\n  undefined zero = 0;\n  undefined carry = 0;\n  concatenate_params_and_swap_them();\n  return !(bool)carry || (bool)zero;\n}",
            "called": [
                "FUN_00081c54"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081ca8",
            "calling": [
                "FUN_000805d0"
            ],
            "imported": false,
            "current_name": "check_params_and_swap_00081ca8"
        },
        "FUN_00081318": {
            "renaming": {
                "FUN_00081318": "process_data_00081318",
                "param_1": "index",
                "param_2": "value",
                "param_3": "param",
                "puVar1": "data_ptr",
                "puVar2": "ptr_2",
                "iVar3": "check_result",
                "uVar4": "data_value",
                "iVar5": "data_index"
            },
            "code": "void process_data_00081318(int index, int value, undefined4 param){\\n  undefined *data_ptr = data_array;\\n  undefined *ptr_2 = pointer_array;\\n  if (data_array[index * 0x1c + 0xc] != \"\\0\") {\\n    if ((pointer_array[index] & 0xf) == 5) {\\n      process_data_00081318_00081210(index,1,param,5,index,value,param);\\n    }\\n    pointer_array[index] = pointer_array[index] & 0xf | (byte)(value << 4);\\n    int data_index = *(int *)(data_ptr + index * 0x1c);\\n    undefined4 data_value = *(undefined4 *)(data_ptr + index * 0x1c + 4);\\n    int check_result = checkParameter(data_index,data_value);\\n    if (check_result == 0) {\\n      if (value != 0) {\\n        *(undefined4 *)(data_index + 100) = data_value;\\n        return;\\n      }\\n      *(undefined4 *)(data_index + 0x60) = data_value;\\n      return;\\n    }\\n    set_values_for_array_and_pointers(data_index,data_value,value,0,1);\\n  }\\n  return;\\n}",
            "called": [
                "FUN_00081210",
                "FUN_00080e04",
                "FUN_00080d7a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081318",
            "calling": [
                "FUN_00080ae4",
                "FUN_00080258",
                "FUN_000801b0",
                "FUN_000804a8",
                "FUN_00080164"
            ],
            "imported": false,
            "current_name": "process_data_00081318"
        },
        "FUN_00081714": {
            "renaming": {
                "FUN_00081714": "getPointerValue_00081714"
            },
            "code": "\nundefined4 getPointerValue_00081714(void)\n\n{\n  return *(undefined4 *)PTR_DAT_0008171c;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081714",
            "calling": [
                "thunk_FUN_00081714"
            ],
            "imported": false,
            "current_name": "getPointerValue_00081714"
        },
        "FUN_0008449c": {
            "renaming": {
                "FUN_0008449c": "set_default_value_0008449c",
                "param_1": "value",
                "param_2": "data",
                "iVar1": "default_value",
                "uVar2": "flag"
            },
            "code": "void set_default_value_0008449c(int value, int* data)\n{\n  int default_value = get_default_value(value, (int)*(short *)(data + 0xe));\n  ushort flag = *(ushort *)(data + 0xc);\n  if (default_value == -1) {\n    flag = flag & 0xefff;\n  }\n  else {\n    flag = flag | 0x1000;\n  }\n  if (default_value != -1) {\n    *(int *)(data + 0x50) = default_value;\n  }\n  *(ushort *)(data + 0xc) = flag;\n  return;\n}",
            "called": [
                "FUN_00084700"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008449c",
            "calling": [],
            "imported": false,
            "current_name": "set_default_value_0008449c"
        },
        "FUN_0008259c": {
            "renaming": {
                "FUN_0008259c": "do_nothing_0008259c"
            },
            "code": "\nvoid do_nothing_0008259c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008259c",
            "calling": [
                "FUN_00083d00",
                "FUN_000825b0",
                "FUN_00083d9c",
                "FUN_00081e14"
            ],
            "imported": false,
            "current_name": "do_nothing_0008259c"
        },
        "FUN_0008477c": {
            "renaming": {
                "FUN_0008477c": "calculate_difference_0008477c",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "multiplierLow",
                "param_4": "multiplierHigh",
                "param_5": "difference",
                "lVar2": "product",
                "uVar1": "productLow"
            },
            "code": "void calculate_difference_0008477c(uint32_t value1, int32_t value2, uint32_t multiplierLow, uint32_t multiplierHigh, int32_t *difference)\n{\n  uint64_t product = div_with_remainder_000847e0();\n  product = product * ((uint64_t)multiplierHigh << 32 | multiplierLow);\n  uint32_t productLow = (uint32_t)product;\n  difference[0] = value1 - productLow;\n  difference[1] = value2 - ((int32_t)(product >> 32)) - (value1 < productLow);\n  return;\n}",
            "called": [
                "FUN_000847e0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008477c",
            "calling": [],
            "imported": false,
            "current_name": "calculate_difference_0008477c"
        },
        "FUN_000801b0": {
            "renaming": {
                "FUN_000801b0": "process_data_000801b0",
                "param_1": "data",
                "bVar1": "is_overflow",
                "uVar2": "function_result_byte",
                "cVar3": "result_char",
                "iVar4": "function_result",
                "bVar5": "byte_counter_copy"
            },
            "code": "int process_data_000801b0(int **data)\n{\n  bool is_overflow = false;\n  undefined byte_counter = 0;\n  char result_char = 0;\n  byte data_len = *(byte *)((int)data + 6);\n  if (data_len > 1) {\n    process_data_000801b0_00081318(data_len,0);\n  }\n  if (*(byte *)((int)data + 5) < 4) {\n    while (true) {\n      int function_result = (**(code **)(**data + 8))();\n      if (function_result == 0) {\n        break;\n      }\n      byte byte_counter_copy = byte_counter;\n      undefined function_result_byte = (**(code **)(**data + 0xc))();\n      result_char = *(char *)((int)data + byte_counter_copy + 9);\n      *(undefined *)((int)data + byte_counter_copy + 9) = function_result_byte;\n      byte_counter_copy++;\n      *(byte *)((int)data + 0x49) = byte_counter_copy;\n      if (byte_counter_copy > 0x3f) {\n        is_overflow = true;\n        break;\n      }\n    }\n  }\n  *(short *)(data + 0x14) = *(short *)(data + 0x14) + 1;\n  if (is_overflow) {\n    result_char = -3;\n    *(short *)(data + 0x15) = *(short *)(data + 0x15) + 1;\n  }\n  else {\n    result_char = *(char *)((int)data + 0x49);\n  }\n  return (int)result_char;\n}",
            "called": [
                "FUN_00081318"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000801b0",
            "calling": [
                "FUN_0008043e"
            ],
            "imported": false,
            "current_name": "process_data_000801b0"
        },
        "FUN_000813c2": {
            "renaming": {
                "FUN_000813c2": "update_buffer_000813c2",
                "param_1": "buffer_address",
                "param_2": "buffer_value",
                "uVar1": "new_buffer_index"
            },
            "code": "void update_buffer_000813c2(int buffer_address, undefined buffer_value) {\n  uint new_buffer_index = *(int *)(buffer_address + 0x80) + 1U & 0x7f;\n  if (new_buffer_index != *(uint *)(buffer_address + 0x84)) {\n    *(undefined *)(buffer_address + *(int *)(buffer_address + 0x80)) = buffer_value;\n    *(uint *)(buffer_address + 0x80) = new_buffer_index;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000813c2",
            "calling": [],
            "imported": false,
            "current_name": "update_buffer_000813c2"
        },
        "FUN_000814e4": {
            "renaming": {
                "FUN_000814e4": "initialize_params_000814e4",
                "param_1": "parameters",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "puVar1": "ptr_array"
            },
            "code": "void initialize_params_000814e4(int *parameters, int param2, char param3, int param4, int param5, int param6)\n{\n    int *ptr_array = PTR_PTR_INITIALIZE;\n    parameters[0] = (int)ptr_array;\n    parameters[1] = 0;\n    parameters[2] = 1000;\n    parameters[3] = param5;\n    parameters[4] = param4;\n    parameters[5] = param6;\n    parameters[6] = param2;\n    *(char *)(parameters + 7) = param3;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000814e4",
            "calling": [
                "FUN_000815d4",
                "FUN_00080c0c"
            ],
            "imported": false,
            "current_name": "initialize_params_000814e4"
        },
        "FUN_00080d54": {
            "renaming": {
                "FUN_00080d54": "set_values_for_parameters_00080d54",
                "param_1": "parameters_array",
                "param_2": "value",
                "param_3": "bit_flags",
                "bVar1": "is_flag_set",
                "0x11": "17",
                "0x18": "24",
                "0x19": "25",
                "0x20": "32",
                "8": "8",
                "9": "9",
                "5": "5"
            },
            "code": "void set_values_for_parameters_00080d54(int *parameters_array, int value, uint32_t bit_flags) {\n  bool is_flag_set;\n  is_flag_set = (int)(bit_flags << 0x1f) < 0;\n  parameters_array[17] = value;\n  if (is_flag_set) {\n    parameters_array[25] = value;\n  }\n  if (!is_flag_set) {\n    parameters_array[24] = value;\n  }\n  is_flag_set = (bit_flags & 10) != 0;\n  if (is_flag_set) {\n    parameters_array[8] = value;\n  }\n  if (!is_flag_set) {\n    parameters_array[9] = value;\n  }\n  if (((int)(bit_flags << 0x1e) < 0) || ((int)(bit_flags << 0x1c) < 0)) {\n    parameters_array[32] = value;\n  }\n  parameters_array[5] = value;\n  *parameters_array = value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080d54",
            "calling": [
                "FUN_00080da0"
            ],
            "imported": false,
            "current_name": "set_values_for_parameters_00080d54"
        },
        "FUN_0008021c": {
            "renaming": {
                "FUN_0008021c": "calculate_checksum_0008021c",
                "param_1": "start_index",
                "param_2": "length",
                "iVar1": "index",
                "uVar2": "xor_value",
                "cVar3": "bit_index",
                "uVar4": "bit_value"
            },
            "code": "uint calculate_checksum_0008021c(int start_index, uint length) {\n  int index;\n  uint xor_value = 0xffff;\n  for (index = start_index; (index - start_index & 0xffU) < length; index = index + 1) {\n    xor_value = xor_value ^ *(byte *)(index + 9);\n    char bit_index = 8;\n    do {\n      uint bit_value = xor_value & 1;\n      xor_value = xor_value >> 1;\n      if (bit_value != 0) {\n        xor_value = xor_value ^ 0xa001;\n      }\n      bit_index = bit_index - 1;\n    } while (bit_index != 0);\n  }\n  return (xor_value & 0xff) << 8 | xor_value >> 8;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008021c",
            "calling": [
                "FUN_00080258"
            ],
            "imported": false,
            "current_name": "calculate_checksum_0008021c"
        },
        "FUN_00082b38": {
            "renaming": {
                "FUN_00082b38": "FUNC_00082b38"
            },
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nbyte * FUNC_00082b38(int param_1,int param_2,byte *******param_3,int **param_4)\n\n{\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  char cVar4;\n  bool bVar5;\n  undefined *puVar6;\n  int iVar7;\n  byte *pbVar8;\n  byte ********ppppppppbVar9;\n  int *piVar10;\n  int iVar11;\n  byte **ppbVar12;\n  char cVar13;\n  byte *******pppppppbVar14;\n  uint uVar15;\n  int **ppiVar16;\n  uint uVar17;\n  uint uVar18;\n  byte *******pppppppbVar19;\n  byte *******pppppppbVar20;\n  byte ********ppppppppbVar21;\n  byte *******pppppppbVar22;\n  int *piVar23;\n  byte *******pppppppbVar24;\n  byte *******pppppppbVar25;\n  uint uVar26;\n  int *piVar27;\n  undefined4 uVar28;\n  byte ********ppppppppbVar29;\n  bool bVar30;\n  longlong lVar31;\n  byte *******local_dc;\n  byte *******local_d4;\n  int **local_c8;\n  byte *local_c4;\n  undefined *local_c0;\n  char local_a1;\n  undefined local_a0;\n  undefined local_9f;\n  byte ********local_9c;\n  byte *******local_98;\n  byte *******local_94;\n  undefined local_90;\n  char cStack_6a;\n  undefined local_69;\n  undefined local_68 [4];\n  byte *******local_64 [16];\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x38) == 0)) {\n    initialize_00083b14();\n  }\n  uVar17 = (uint)*(ushort *)(param_2 + 0xc);\n  if (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x12)) {\n    uVar17 = uVar17 | 0x2000;\n    *(short *)(param_2 + 0xc) = (short)uVar17;\n    *(uint *)(param_2 + 100) = *(uint *)(param_2 + 100) & 0xffffdfff;\n  }\n  if (((int)(uVar17 << 0x1c) < 0) && (*(int *)(param_2 + 0x10) != 0)) {\n    if ((uVar17 & 0x1a) != 10) goto LAB_00082b8a;\n  }\n  else {\n    iVar11 = check_and_update_00083808(param_1,param_2);\n    if (iVar11 != 0) {\n      return (byte *)0xffffffff;\n    }\n    if ((*(ushort *)(param_2 + 0xc) & 0x1a) != 10) goto LAB_00082b8a;\n  }\n  if (-1 < *(short *)(param_2 + 0xe)) {\n    pbVar8 = (byte *)process_data_and_return_negative_if_error_occurs_0008378c(param_1,param_2,param_3,param_4);\n    return pbVar8;\n  }\nLAB_00082b8a:\n  local_c0 = (undefined *)0x0;\n  local_94 = (byte *******)0x0;\n  local_98 = (byte *******)0x0;\n  local_c4 = (byte *)0x0;\n  ppppppppbVar9 = (byte ********)local_68;\n  local_c8 = param_4;\n  local_9c = (byte ********)local_68;\nLAB_00082b9e:\n  pppppppbVar14 = param_3;\n  if ((*(byte *)param_3 != 0) && (*(byte *)param_3 != 0x25)) {\n    do {\n      pppppppbVar14 = (byte *******)((int)pppppppbVar14 + 1);\n      if (*(byte *)pppppppbVar14 == 0) break;\n    } while (*(byte *)pppppppbVar14 != 0x25);\n    pppppppbVar25 = (byte *******)((int)pppppppbVar14 - (int)param_3);\n    if (pppppppbVar25 != (byte *******)0x0) {\n      local_98 = (byte *******)((int)local_98 + 1);\n      local_94 = (byte *******)((int)local_94 + (int)pppppppbVar25);\n      *ppppppppbVar9 = param_3;\n      ppppppppbVar9[1] = pppppppbVar25;\n      if ((int)local_98 < 8) {\n        ppppppppbVar9 = ppppppppbVar9 + 2;\n      }\n      else {\n        if (local_94 == (byte *******)0x0) {\n          local_c4 = local_c4 + (int)pppppppbVar25;\n          ppppppppbVar9 = (byte ********)local_68;\n          local_98 = local_94;\n          goto LAB_00082bee;\n        }\n        iVar11 = process_input_00082ac0(param_1,param_2,&local_9c);\n        ppppppppbVar9 = (byte ********)local_68;\n        if (iVar11 != 0) goto LAB_000833de;\n      }\n      local_c4 = local_c4 + (int)pppppppbVar25;\n    }\n  }\nLAB_00082bee:\n  if (*(byte *)pppppppbVar14 != 0) {\n    local_a1 = '\\0';\n    uVar18 = (uint)*(byte *)((int)pppppppbVar14 + 1);\n    uVar17 = 0;\n    bVar5 = false;\n    bVar2 = false;\n    bVar1 = false;\n    bVar3 = false;\n    bVar30 = false;\n    pppppppbVar25 = (byte *******)0x0;\n    local_d4 = (byte *******)0xffffffff;\n    param_3 = (byte *******)((int)pppppppbVar14 + 1);\nLAB_00082c12:\n    param_3 = (byte *******)((int)param_3 + 1);\nLAB_00082c16:\n    switch(uVar18) {\n    case 0x20:\n      goto switchD_00082c20_caseD_20;\n    default:\n      if (uVar18 != 0) {\n        local_dc = (byte *******)0x1;\n        local_d4 = (byte *******)0x1;\n        ppppppppbVar29 = (byte ********)&local_90;\n        local_90 = (char)uVar18;\n        goto LAB_00083012;\n      }\n      goto LAB_000833d0;\n    case 0x23:\n      bVar3 = true;\n      uVar18 = (uint)*(byte *)param_3;\n      goto LAB_00082c12;\n    case 0x2a:\n      pppppppbVar25 = (byte *******)*local_c8;\n      local_c8 = local_c8 + 1;\n      if ((int)pppppppbVar25 < 0) {\n        pppppppbVar25 = (byte *******)-(int)pppppppbVar25;\n        goto switchD_00082c20_caseD_2d;\n      }\n      uVar18 = (uint)*(byte *)param_3;\n      goto LAB_00082c12;\n    case 0x2b:\n      uVar18 = (uint)*(byte *)param_3;\n      local_a1 = '+';\n      goto LAB_00082c12;\n    case 0x2d:\nswitchD_00082c20_caseD_2d:\n      uVar17 = uVar17 | 4;\n      uVar18 = (uint)*(byte *)param_3;\n      goto LAB_00082c12;\n    case 0x2e:\n      uVar18 = (uint)*(byte *)param_3;\n      pppppppbVar14 = (byte *******)((int)param_3 + 1);\n      if (uVar18 == 0x2a) {\n        uVar18 = (uint)*(byte *)((int)param_3 + 1);\n        local_d4 = (byte *******)*local_c8;\n        local_c8 = local_c8 + 1;\n        param_3 = pppppppbVar14;\n        if ((int)local_d4 < 0) {\n          local_d4 = (byte *******)0xffffffff;\n        }\n        goto LAB_00082c12;\n      }\n      uVar15 = uVar18 - 0x30;\n      if (uVar15 < 10) {\n        uVar26 = 0;\n        do {\n          param_3 = (byte *******)((int)pppppppbVar14 + 1);\n          uVar18 = (uint)*(byte *)pppppppbVar14;\n          uVar26 = uVar15 + uVar26 * 10;\n          uVar15 = uVar18 - 0x30;\n          pppppppbVar14 = param_3;\n        } while (uVar15 < 10);\n        local_d4 = (byte *******)(uVar26 | (int)uVar26 >> 0x1f);\n      }\n      else {\n        local_d4 = (byte *******)0x0;\n        param_3 = pppppppbVar14;\n      }\n      goto LAB_00082c16;\n    case 0x30:\n      uVar17 = uVar17 | 0x80;\n      uVar18 = (uint)*(byte *)param_3;\n      goto LAB_00082c12;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_00082c20_caseD_31;\n    case 0x44:\n      bVar2 = true;\n      if (bVar1 == false) goto LAB_00083028;\nLAB_00082e98:\n      local_c8 = (int **)((int)local_c8 + 7U & 0xfffffff8);\n      piVar23 = *local_c8;\n      piVar27 = local_c8[1];\n      local_c8 = local_c8 + 2;\n      goto LAB_00082eac;\n    case 0x4f:\n      bVar2 = true;\n      if (bVar1 != false) goto LAB_00082d42;\nLAB_00082f2a:\n      iVar11 = (uint)bVar2 << 4;\n      iVar7 = (uint)bVar1 << 5;\n      if ((bVar2 == 0) && (iVar7 = (uint)bVar30 << 6, bVar30 != 0)) {\n        piVar23 = (int *)(uint)*(ushort *)local_c8;\n        local_c8 = local_c8 + 1;\n        piVar27 = (int *)0x0;\n      }\n      else {\n        iVar11 = iVar7;\n        piVar23 = *local_c8;\n        local_c8 = local_c8 + 1;\n        piVar27 = (int *)0x0;\n      }\n      break;\n    case 0x55:\n      bVar2 = true;\n      if (bVar1 != false) goto LAB_00082e62;\nLAB_00082f7c:\n      if ((bVar2) || (bVar30 == false)) {\n        iVar11 = 1;\n        piVar23 = *local_c8;\n        local_c8 = local_c8 + 1;\n        piVar27 = (int *)0x0;\n      }\n      else {\n        piVar27 = (int *)0x0;\n        piVar23 = (int *)(uint)*(ushort *)local_c8;\n        local_c8 = local_c8 + 1;\n        iVar11 = 1;\n      }\n      break;\n    case 0x58:\n      local_c0 = PTR_s_0123456789ABCDEF_000830ec;\n      if (bVar1 == false) goto LAB_00083196;\nLAB_00082fb6:\n      ppiVar16 = (int **)((int)local_c8 + 7U & 0xfffffff8);\n      local_c8 = ppiVar16 + 2;\n      piVar23 = *ppiVar16;\n      piVar27 = ppiVar16[1];\n      goto LAB_00082fca;\n    case 99:\n      piVar23 = *local_c8;\n      local_c8 = local_c8 + 1;\n      local_dc = (byte *******)0x1;\n      local_90 = SUB41(piVar23,0);\n      local_d4 = (byte *******)0x1;\n      ppppppppbVar29 = (byte ********)&local_90;\n      goto LAB_00083012;\n    case 100:\n    case 0x69:\n      if (bVar1 != false) goto LAB_00082e98;\nLAB_00083028:\n      if ((bVar2 == false) && (bVar30 != false)) {\n        piVar23 = (int *)(int)*(short *)local_c8;\n        local_c8 = local_c8 + 1;\n        piVar27 = (int *)((int)piVar23 >> 0x1f);\n      }\n      else {\n        piVar23 = *local_c8;\n        local_c8 = local_c8 + 1;\n        piVar27 = (int *)((int)piVar23 >> 0x1f);\n      }\nLAB_00082eac:\n      if ((int)piVar27 < 0) {\n        bVar30 = piVar23 != (int *)0x0;\n        piVar23 = (int *)-(int)piVar23;\n        piVar27 = (int *)(-(int)piVar27 - (uint)bVar30);\n        local_a1 = '-';\n        cVar4 = '-';\n        iVar11 = 1;\n        goto LAB_00082d6a;\n      }\n      if (-1 < (int)local_d4) {\n        uVar17 = uVar17 & 0xffffff7f;\n      }\n      bVar5 = false;\n      uVar18 = (uint)piVar23 | (uint)piVar27;\n      iVar11 = 1;\n      cVar4 = local_a1;\n      goto joined_r0x00082d78;\n    case 0x68:\n      bVar30 = true;\n      uVar18 = (uint)*(byte *)param_3;\n      goto LAB_00082c12;\n    case 0x6c:\n      uVar18 = (uint)*(byte *)param_3;\n      if (uVar18 == 0x6c) {\n        bVar1 = true;\n        uVar18 = (uint)*(byte *)((int)param_3 + 1);\n        param_3 = (byte *******)((int)param_3 + 1);\n      }\n      else {\n        bVar2 = true;\n      }\n      goto LAB_00082c12;\n    case 0x6e:\n      if (bVar1 == false) {\n        if (bVar2 == false) {\n          if (bVar30) {\n            piVar23 = *local_c8;\n            local_c8 = local_c8 + 1;\n            *(short *)piVar23 = (short)local_c4;\n          }\n          else {\n            ppbVar12 = (byte **)*local_c8;\n            local_c8 = local_c8 + 1;\n            *ppbVar12 = local_c4;\n          }\n        }\n        else {\n          ppbVar12 = (byte **)*local_c8;\n          local_c8 = local_c8 + 1;\n          *ppbVar12 = local_c4;\n        }\n      }\n      else {\n        ppbVar12 = (byte **)*local_c8;\n        local_c8 = local_c8 + 1;\n        *ppbVar12 = local_c4;\n        ppbVar12[1] = (byte *)((int)local_c4 >> 0x1f);\n      }\n      goto LAB_00082b9e;\n    case 0x6f:\n      if (bVar1 == false) goto LAB_00082f2a;\nLAB_00082d42:\n      ppiVar16 = (int **)((int)local_c8 + 7U & 0xfffffff8);\n      local_c8 = ppiVar16 + 2;\n      piVar23 = *ppiVar16;\n      piVar27 = ppiVar16[1];\n      iVar11 = 0;\n      break;\n    case 0x70:\n      local_c0 = PTR_s_0123456789abcdef_000833c4;\n      piVar23 = *local_c8;\n      local_c8 = local_c8 + 1;\n      local_9f = 0x78;\n      bVar5 = true;\n      piVar27 = (int *)0x0;\n      local_a0 = 0x30;\n      iVar11 = 2;\n      break;\n    case 0x71:\n      bVar1 = true;\n      uVar18 = (uint)*(byte *)param_3;\n      goto LAB_00082c12;\n    case 0x73:\n      ppppppppbVar29 = (byte ********)*local_c8;\n      local_a1 = '\\0';\n      local_c8 = local_c8 + 1;\n      if (ppppppppbVar29 != (byte ********)0x0) {\n        if ((int)local_d4 < 0) {\n          local_d4 = (byte *******)count_bytes_with_nonzero_00082a50(ppppppppbVar29);\n          pppppppbVar14 = (byte *******)0x0;\n          cVar4 = local_a1;\n        }\n        else {\n          pppppppbVar14 = (byte *******)find_char_in_buffer_00084384(ppppppppbVar29,0,local_d4);\n          cVar4 = local_a1;\n          if (pppppppbVar14 != (byte *******)0x0) {\n            pppppppbVar20 = (byte *******)((int)pppppppbVar14 - (int)ppppppppbVar29);\n            if ((int)local_d4 <= (int)(byte *******)((int)pppppppbVar14 - (int)ppppppppbVar29)) {\n              pppppppbVar20 = local_d4;\n            }\n            pppppppbVar14 = (byte *******)0x0;\n            local_d4 = pppppppbVar20;\n          }\n        }\n        goto LAB_00082da0;\n      }\n      if ((byte *******)0x5 < local_d4) {\n        local_d4 = (byte *******)0x6;\n      }\n      local_dc = (byte *******)((uint)local_d4 & ~((int)local_d4 >> 0x1f));\n      ppppppppbVar29 = (byte ********)PTR_s__null__00083784;\nLAB_00083012:\n      local_a1 = '\\0';\n      pppppppbVar14 = (byte *******)0x0;\n      goto LAB_00082dba;\n    case 0x75:\n      if (!bVar1) goto LAB_00082f7c;\nLAB_00082e62:\n      ppiVar16 = (int **)((int)local_c8 + 7U & 0xfffffff8);\n      local_c8 = ppiVar16 + 2;\n      piVar23 = *ppiVar16;\n      piVar27 = ppiVar16[1];\n      iVar11 = 1;\n      break;\n    case 0x78:\n      local_c0 = PTR_s_0123456789abcdef_000833c4;\n      if (bVar1 != false) goto LAB_00082fb6;\nLAB_00083196:\n      if ((bVar2 == false) && (bVar30 != false)) {\n        piVar27 = (int *)0x0;\n        piVar23 = (int *)(uint)*(ushort *)local_c8;\n        local_c8 = local_c8 + 1;\n      }\n      else {\n        piVar23 = *local_c8;\n        local_c8 = local_c8 + 1;\n        piVar27 = (int *)0x0;\n      }\nLAB_00082fca:\n      if ((bVar3) && (((uint)piVar23 | (uint)piVar27) != 0)) {\n        bVar5 = true;\n        local_a0 = 0x30;\n        iVar11 = 2;\n        local_9f = (char)uVar18;\n      }\n      else {\n        iVar11 = 2;\n      }\n    }\n    local_a1 = '\\0';\n    cVar4 = '\\0';\nLAB_00082d6a:\n    if (-1 < (int)local_d4) {\n      uVar17 = uVar17 & 0xffffff7f;\n    }\n    uVar18 = (uint)piVar23 | (uint)piVar27;\njoined_r0x00082d78:\n    lVar31 = CONCAT44(piVar27,piVar23);\n    pppppppbVar14 = local_d4;\n    if ((uVar18 == 0) && (local_d4 == (byte *******)0x0)) {\n      ppppppppbVar29 = (byte ********)local_68;\n      if ((iVar11 != 0) || (!bVar3)) goto LAB_00082da0;\n      ppppppppbVar29 = (byte ********)(&cStack_6a + 1);\n      local_69 = '0';\n      goto LAB_00082d9a;\n    }\n    if (iVar11 == 1) {\n      if (piVar27 != (int *)0x0 || (int *)0x9 < piVar23) {\n        ppppppppbVar21 = (byte ********)(&cStack_6a + 1);\n        do {\n          ppppppppbVar29 = ppppppppbVar21;\n          uVar28 = (undefined4)((ulonglong)lVar31 >> 0x20);\n          cVar13 = '\\n';\n          calculate_result_00084750((int)lVar31,uVar28,10,0);\n          *(char *)ppppppppbVar29 = cVar13 + '0';\n          lVar31 = calculate_result_00084750((int)lVar31,uVar28,10,0);\n          ppppppppbVar21 = (byte ********)((int)ppppppppbVar29 + -1);\n        } while (lVar31 != 0);\n        local_d4 = (byte *******)((int)local_68 - (int)ppppppppbVar29);\n        goto LAB_00082da0;\n      }\n      local_69 = (char)piVar23 + '0';\n      ppppppppbVar29 = (byte ********)(&cStack_6a + 1);\n      goto LAB_0008351e;\n    }\n    ppppppppbVar21 = (byte ********)(&cStack_6a + 1);\n    if (iVar11 != 2) goto LAB_0008337e;\n    do {\n      ppppppppbVar29 = ppppppppbVar21;\n      uVar18 = (uint)piVar23 & 0xf;\n      piVar23 = (int *)((uint)piVar23 >> 4 | (int)piVar27 << 0x1c);\n      piVar27 = (int *)((uint)piVar27 >> 4);\n      *(undefined *)ppppppppbVar29 = local_c0[uVar18];\n      ppppppppbVar21 = (byte ********)((int)ppppppppbVar29 + -1);\n    } while (((uint)piVar23 | (uint)piVar27) != 0);\n    local_d4 = (byte *******)((int)local_68 - (int)ppppppppbVar29);\n    goto LAB_00082da0;\n  }\nLAB_000833d0:\n  if (local_94 != (byte *******)0x0) {\n    process_input_00082ac0(param_1,param_2,&local_9c);\n  }\nLAB_000833de:\n  if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n    return (byte *)0xffffffff;\n  }\n  return local_c4;\nLAB_0008337e:\n  do {\n    ppppppppbVar29 = ppppppppbVar21;\n    piVar10 = (int *)((uint)piVar23 >> 3 | (int)piVar27 << 0x1d);\n    piVar27 = (int *)((uint)piVar27 >> 3);\n    iVar11 = ((uint)piVar23 & 7) + 0x30;\n    *(char *)ppppppppbVar29 = (char)iVar11;\n    ppppppppbVar21 = (byte ********)((int)ppppppppbVar29 + -1);\n    piVar23 = piVar10;\n  } while (((uint)piVar10 | (uint)piVar27) != 0);\n  if (bVar3) {\n    if (iVar11 == 0x30) {\nLAB_00082d9a:\n      local_d4 = (byte *******)((int)local_68 - (int)ppppppppbVar29);\n    }\n    else {\n      *(undefined *)((int)ppppppppbVar29 + -1) = 0x30;\n      ppppppppbVar29 = ppppppppbVar21;\n      local_d4 = (byte *******)((int)local_68 - (int)ppppppppbVar21);\n    }\n  }\n  else {\nLAB_0008351e:\n    local_d4 = (byte *******)((int)local_68 - (int)ppppppppbVar29);\n  }\nLAB_00082da0:\n  local_dc = local_d4;\n  if ((int)local_d4 < (int)pppppppbVar14) {\n    local_dc = pppppppbVar14;\n  }\n  if (cVar4 != '\\0') {\n    local_dc = (byte *******)((int)local_dc + 1);\n  }\nLAB_00082dba:\n  pppppppbVar20 = (byte *******)PTR_s__0123456789ABCDEF_000830e8;\n  if (bVar5) {\n    local_dc = (byte *******)((int)local_dc + 2);\n  }\n  if ((uVar17 == 0) &&\n     (pppppppbVar22 = (byte *******)((int)pppppppbVar25 - (int)local_dc), 0 < (int)pppppppbVar22)) {\n    if ((int)pppppppbVar22 < 0x11) {\n      pppppppbVar19 = (byte *******)((int)local_98 + 1);\n      pppppppbVar20 = (byte *******)PTR_s__0123456789ABCDEF_00083710;\n    }\n    else {\n      do {\n        pppppppbVar24 = pppppppbVar22;\n        pppppppbVar22 = (byte *******)((int)local_98 + 1);\n        local_94 = local_94 + 4;\n        *ppppppppbVar9 = pppppppbVar20;\n        ppppppppbVar9[1] = (byte *******)0x10;\n        if ((int)pppppppbVar22 < 8) {\n          pppppppbVar19 = (byte *******)((int)local_98 + 2);\n          ppppppppbVar9 = ppppppppbVar9 + 2;\n          local_98 = pppppppbVar22;\n        }\n        else if (local_94 == (byte *******)0x0) {\n          pppppppbVar19 = (byte *******)0x1;\n          ppppppppbVar9 = (byte ********)local_68;\n          local_98 = local_94;\n        }\n        else {\n          local_98 = pppppppbVar22;\n          iVar11 = process_input_00082ac0(param_1,param_2,&local_9c);\n          if (iVar11 != 0) goto LAB_000833de;\n          pppppppbVar19 = (byte *******)((int)local_98 + 1);\n          ppppppppbVar9 = (byte ********)local_68;\n        }\n        pppppppbVar22 = pppppppbVar24 + -4;\n      } while (0x10 < (int)pppppppbVar22);\n      pppppppbVar22 = pppppppbVar24 + -4;\n    }\n    local_94 = (byte *******)((int)local_94 + (int)pppppppbVar22);\n    *ppppppppbVar9 = pppppppbVar20;\n    ppppppppbVar9[1] = pppppppbVar22;\n    local_98 = pppppppbVar19;\n    if ((int)pppppppbVar19 < 8) {\n      pppppppbVar19 = (byte *******)((int)pppppppbVar19 + 1);\n      ppppppppbVar9 = ppppppppbVar9 + 2;\n    }\n    else if (local_94 == (byte *******)0x0) {\n      pppppppbVar19 = (byte *******)0x1;\n      local_98 = local_94;\n      ppppppppbVar9 = (byte ********)local_68;\n    }\n    else {\n      iVar11 = process_input_00082ac0(param_1,param_2,&local_9c);\n      if (iVar11 != 0) goto LAB_000833de;\n      pppppppbVar19 = (byte *******)((int)local_98 + 1);\n      ppppppppbVar9 = (byte ********)local_68;\n    }\n  }\n  else {\n    pppppppbVar19 = (byte *******)((int)local_98 + 1);\n  }\n  pppppppbVar20 = pppppppbVar19;\n  if (local_a1 != '\\0') {\n    local_94 = (byte *******)((int)local_94 + 1);\n    pppppppbVar20 = (byte *******)0x1;\n    *ppppppppbVar9 = (byte *******)&local_a1;\n    ppppppppbVar9[1] = (byte *******)0x1;\n    if ((int)pppppppbVar19 < 8) {\n      pppppppbVar20 = (byte *******)((int)pppppppbVar19 + 1);\n      local_98 = pppppppbVar19;\n      ppppppppbVar9 = ppppppppbVar9 + 2;\n    }\n    else {\n      local_98 = local_94;\n      ppppppppbVar9 = (byte ********)local_68;\n      if (local_94 != (byte *******)0x0) {\n        local_98 = pppppppbVar19;\n        iVar11 = process_input_00082ac0(param_1,param_2,&local_9c);\n        if (iVar11 != 0) goto LAB_000833de;\n        pppppppbVar20 = (byte *******)((int)local_98 + 1);\n      }\n    }\n  }\n  pppppppbVar22 = pppppppbVar20;\n  pppppppbVar19 = local_98;\n  if (bVar5) {\n    local_94 = (byte *******)((int)local_94 + 2);\n    *ppppppppbVar9 = (byte *******)&local_a0;\n    ppppppppbVar9[1] = (byte *******)0x2;\n    if ((int)pppppppbVar20 < 8) {\n      pppppppbVar22 = (byte *******)((int)pppppppbVar20 + 1);\n      pppppppbVar19 = pppppppbVar20;\n      ppppppppbVar9 = ppppppppbVar9 + 2;\n    }\n    else if (local_94 == (byte *******)0x0) {\n      pppppppbVar22 = (byte *******)0x1;\n      pppppppbVar19 = local_94;\n      ppppppppbVar9 = (byte ********)local_68;\n    }\n    else {\n      local_98 = pppppppbVar20;\n      iVar11 = process_input_00082ac0(param_1,param_2,&local_9c);\n      if (iVar11 != 0) goto LAB_000833de;\n      pppppppbVar22 = (byte *******)((int)local_98 + 1);\n      pppppppbVar19 = local_98;\n      ppppppppbVar9 = (byte ********)local_68;\n    }\n  }\n  puVar6 = PTR_DAT_0008370c;\n  pppppppbVar20 = pppppppbVar22;\n  if ((uVar17 == 0x80) &&\n     (pppppppbVar24 = (byte *******)((int)pppppppbVar25 - (int)local_dc), 0 < (int)pppppppbVar24)) {\n    if (0x10 < (int)pppppppbVar24) {\n      do {\n        while( true ) {\n          pppppppbVar20 = pppppppbVar24;\n          local_98 = (byte *******)((int)pppppppbVar19 + 1);\n          local_94 = local_94 + 4;\n          *ppppppppbVar9 = (byte *******)puVar6;\n          ppppppppbVar9[1] = (byte *******)0x10;\n          if (7 < (int)local_98) break;\n          pppppppbVar22 = (byte *******)((int)pppppppbVar19 + 2);\n          ppppppppbVar9 = ppppppppbVar9 + 2;\nLAB_0008348e:\n          pppppppbVar19 = local_98;\n          pppppppbVar24 = pppppppbVar20 + -4;\n          if ((int)(pppppppbVar20 + -4) < 0x11) goto LAB_000834b4;\n        }\n        if (local_94 != (byte *******)0x0) {\n          iVar11 = process_input_00082ac0(param_1,param_2,&local_9c);\n          if (iVar11 == 0) {\n            pppppppbVar22 = (byte *******)((int)local_98 + 1);\n            ppppppppbVar9 = (byte ********)local_68;\n            goto LAB_0008348e;\n          }\n          goto LAB_000833de;\n        }\n        pppppppbVar22 = (byte *******)0x1;\n        pppppppbVar19 = local_94;\n        pppppppbVar24 = pppppppbVar20 + -4;\n        ppppppppbVar9 = (byte ********)local_68;\n      } while (0x10 < (int)(pppppppbVar20 + -4));\nLAB_000834b4:\n      pppppppbVar24 = pppppppbVar20 + -4;\n    }\n    local_94 = (byte *******)((int)local_94 + (int)pppppppbVar24);\n    *ppppppppbVar9 = (byte *******)puVar6;\n    ppppppppbVar9[1] = pppppppbVar24;\n    if ((int)pppppppbVar22 < 8) {\n      pppppppbVar20 = (byte *******)((int)pppppppbVar22 + 1);\n      pppppppbVar19 = pppppppbVar22;\n      ppppppppbVar9 = ppppppppbVar9 + 2;\n    }\n    else if (local_94 == (byte *******)0x0) {\n      pppppppbVar20 = (byte *******)0x1;\n      pppppppbVar19 = local_94;\n      ppppppppbVar9 = (byte ********)local_68;\n    }\n    else {\n      local_98 = pppppppbVar22;\n      iVar11 = process_input_00082ac0(param_1,param_2,&local_9c);\n      if (iVar11 != 0) goto LAB_000833de;\n      pppppppbVar20 = (byte *******)((int)local_98 + 1);\n      pppppppbVar19 = local_98;\n      ppppppppbVar9 = (byte ********)local_68;\n    }\n  }\n  puVar6 = PTR_DAT_000833c8;\n  pppppppbVar14 = (byte *******)((int)pppppppbVar14 - (int)local_d4);\n  ppppppppbVar21 = (byte ********)local_68;\n  if ((int)pppppppbVar14 < 1) {\nLAB_000832c6:\n    local_94 = (byte *******)((int)local_94 + (int)local_d4);\n    *ppppppppbVar9 = (byte *******)ppppppppbVar29;\n    ppppppppbVar9[1] = local_d4;\n    local_d4 = local_94;\n    local_98 = pppppppbVar20;\n    if ((int)pppppppbVar20 < 8) goto LAB_0008345a;\n    local_98 = local_94;\n    if ((local_94 != (byte *******)0x0) &&\n       (local_98 = pppppppbVar20, iVar11 = process_input_00082ac0(param_1,param_2,&local_9c), iVar11 != 0))\n    goto LAB_000833de;\n  }\n  else {\n    if (0x10 < (int)pppppppbVar14) {\n      do {\n        while( true ) {\n          pppppppbVar22 = pppppppbVar14;\n          local_98 = (byte *******)((int)pppppppbVar19 + 1);\n          local_94 = local_94 + 4;\n          *ppppppppbVar9 = (byte *******)puVar6;\n          ppppppppbVar9[1] = (byte *******)0x10;\n          if (7 < (int)local_98) break;\n          pppppppbVar20 = (byte *******)((int)pppppppbVar19 + 2);\n          ppppppppbVar9 = ppppppppbVar9 + 2;\nLAB_00083282:\n          pppppppbVar19 = local_98;\n          pppppppbVar14 = pppppppbVar22 + -4;\n          if ((int)(pppppppbVar22 + -4) < 0x11) goto LAB_000832aa;\n        }\n        if (local_94 != (byte *******)0x0) {\n          iVar11 = process_input_00082ac0(param_1,param_2,&local_9c);\n          if (iVar11 == 0) {\n            pppppppbVar20 = (byte *******)((int)local_98 + 1);\n            ppppppppbVar9 = (byte ********)local_68;\n            goto LAB_00083282;\n          }\n          goto LAB_000833de;\n        }\n        pppppppbVar20 = (byte *******)0x1;\n        ppppppppbVar9 = (byte ********)local_68;\n        pppppppbVar19 = local_94;\n        pppppppbVar14 = pppppppbVar22 + -4;\n      } while (0x10 < (int)(pppppppbVar22 + -4));\nLAB_000832aa:\n      pppppppbVar14 = pppppppbVar22 + -4;\n    }\n    local_94 = (byte *******)((int)local_94 + (int)pppppppbVar14);\n    *ppppppppbVar9 = (byte *******)puVar6;\n    ppppppppbVar9[1] = pppppppbVar14;\n    if ((int)pppppppbVar20 < 8) {\n      pppppppbVar20 = (byte *******)((int)pppppppbVar20 + 1);\n      ppppppppbVar9 = ppppppppbVar9 + 2;\n      goto LAB_000832c6;\n    }\n    if (local_94 != (byte *******)0x0) {\n      local_98 = pppppppbVar20;\n      iVar11 = process_input_00082ac0(param_1,param_2,&local_9c);\n      if (iVar11 != 0) goto LAB_000833de;\n      pppppppbVar20 = (byte *******)((int)local_98 + 1);\n      ppppppppbVar9 = (byte ********)local_68;\n      goto LAB_000832c6;\n    }\n    local_64[0] = local_d4;\n    local_98 = (byte *******)0x1;\n    ppppppppbVar9 = (byte ********)local_68;\n    local_68 = (undefined  [4])ppppppppbVar29;\nLAB_0008345a:\n    ppppppppbVar21 = ppppppppbVar9 + 2;\n    local_94 = local_d4;\n  }\n  pppppppbVar14 = (byte *******)PTR_s__0123456789ABCDEF_000833cc;\n  if (((uVar17 & 4) != 0) &&\n     (pppppppbVar20 = (byte *******)((int)pppppppbVar25 - (int)local_dc), 0 < (int)pppppppbVar20)) {\n    pppppppbVar22 = local_98;\n    if ((int)pppppppbVar20 < 0x11) {\n      pppppppbVar19 = (byte *******)((int)local_98 + 1);\n      pppppppbVar14 = (byte *******)PTR_s__0123456789ABCDEF_00083788;\n    }\n    else {\n      do {\n        while( true ) {\n          local_98 = (byte *******)((int)pppppppbVar22 + 1);\n          local_94 = local_94 + 4;\n          *ppppppppbVar21 = pppppppbVar14;\n          ppppppppbVar21[1] = (byte *******)0x10;\n          if (7 < (int)local_98) break;\n          pppppppbVar19 = (byte *******)((int)pppppppbVar22 + 2);\n          ppppppppbVar21 = ppppppppbVar21 + 2;\nLAB_00083316:\n          pppppppbVar20 = pppppppbVar20 + -4;\n          pppppppbVar22 = local_98;\n          if ((int)pppppppbVar20 < 0x11) goto LAB_0008333e;\n        }\n        if (local_94 != (byte *******)0x0) {\n          iVar11 = process_input_00082ac0(param_1,param_2,&local_9c);\n          if (iVar11 == 0) {\n            pppppppbVar19 = (byte *******)((int)local_98 + 1);\n            ppppppppbVar21 = (byte ********)local_68;\n            goto LAB_00083316;\n          }\n          goto LAB_000833de;\n        }\n        pppppppbVar20 = pppppppbVar20 + -4;\n        pppppppbVar19 = (byte *******)0x1;\n        pppppppbVar22 = local_94;\n        ppppppppbVar21 = (byte ********)local_68;\n      } while (0x10 < (int)pppppppbVar20);\n    }\nLAB_0008333e:\n    local_94 = (byte *******)((int)local_94 + (int)pppppppbVar20);\n    *ppppppppbVar21 = pppppppbVar14;\n    ppppppppbVar21[1] = pppppppbVar20;\n    local_98 = pppppppbVar19;\n    if (7 < (int)pppppppbVar19) {\n      if (local_94 == (byte *******)0x0) {\n        if ((int)local_dc < (int)pppppppbVar25) {\n          local_dc = pppppppbVar25;\n        }\n        local_c4 = local_c4 + (int)local_dc;\n        goto LAB_00083422;\n      }\n      iVar11 = process_input_00082ac0(param_1,param_2,&local_9c);\n      if (iVar11 != 0) goto LAB_000833de;\n    }\n  }\n  if ((int)local_dc < (int)pppppppbVar25) {\n    local_dc = pppppppbVar25;\n  }\n  local_c4 = local_c4 + (int)local_dc;\n  if ((local_94 != (byte *******)0x0) &&\n     (iVar11 = process_input_00082ac0(param_1,param_2,&local_9c), iVar11 != 0)) goto LAB_000833de;\nLAB_00083422:\n  local_98 = (byte *******)0x0;\n  ppppppppbVar9 = (byte ********)local_68;\n  goto LAB_00082b9e;\nswitchD_00082c20_caseD_31:\n  uVar15 = uVar18 - 0x30;\n  pppppppbVar25 = (byte *******)0x0;\n  pppppppbVar14 = param_3;\n  do {\n    param_3 = (byte *******)((int)pppppppbVar14 + 1);\n    uVar18 = (uint)*(byte *)pppppppbVar14;\n    pppppppbVar25 = (byte *******)(uVar15 + (int)pppppppbVar25 * 10);\n    uVar15 = uVar18 - 0x30;\n    pppppppbVar14 = param_3;\n  } while (uVar15 < 10);\n  goto LAB_00082c16;\nswitchD_00082c20_caseD_20:\n  uVar18 = (uint)*(byte *)param_3;\n  if (local_a1 == '\\0') {\n    local_a1 = ' ';\n  }\n  goto LAB_00082c12;\n}\n\n",
            "called": [
                "FUN_00084384",
                "FUN_00083808",
                "FUN_0008378c",
                "FUN_00083b14",
                "FUN_00084750",
                "FUN_00082ac0",
                "FUN_00082a50"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00082b38",
            "calling": [
                "FUN_0008378c"
            ],
            "imported": false,
            "current_name": "FUNC_00082b38"
        },
        "FUN_00081e04": {
            "renaming": {
                "FUN_00081e04": "allocate_memory_block_00081e04",
                "param_1": "size",
                "*DAT_00081e10": "ptr"
            },
            "code": "void allocate_memory_block_00081e04(void* *DAT_00081e10, int size) {\n  allocate_memory_block_00081e04_00083d9c(*DAT_00081e10, size);\n  return;\n}",
            "called": [
                "FUN_00083d9c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081e04",
            "calling": [
                "FUN_000815fe",
                "FUN_0008160c"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_00081e04"
        },
        "FUN_00084750": {
            "renaming": {
                "FUN_00084750": "calculate_result_00084750",
                "param_1": "first_number",
                "param_2": "second_number",
                "param_3": "third_number",
                "param_4": "fourth_number",
                "iVar1": "result",
                "calculate_difference_000847ac": "calculate_difference"
            },
            "code": "int calculate_result_00084750(int first_number, int second_number, int third_number, int fourth_number) {\n  int result;\n  if ((fourth_number == 0) && (third_number == 0)) {\n    if (second_number != 0 || first_number != 0) {\n      first_number = -1;\n    }\n    result = first_number;\n  }\n  else {\n    result = calculate_difference();\n  }\n  return result;\n}",
            "called": [
                "FUN_000847ac"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00084750",
            "calling": [
                "FUN_00082b38"
            ],
            "imported": false,
            "current_name": "calculate_result_00084750"
        },
        "FUN_00080ae4": {
            "renaming": {
                "FUN_00080ae4": "initialize_and_execute_00080ae4",
                "puVar1": "input_ptr",
                "puVar2": "output_ptr",
                "iVar3": "var1",
                "iVar4": "var2",
                "iVar5": "var3",
                "iVar6": "var4",
                "DAT_00080be8": "input_data",
                "initialize_variables_00080e9c": "initialize_variables",
                "DAT_00080bec": "output_data",
                "execute_functions_00081d7c": "execute_functions",
                "process_data_00081318": "process_data",
                "DAT_00080c00": "var4",
                "DAT_00080bfc": "var3",
                "DAT_00080bf8": "var2",
                "DAT_00080bf4": "var1",
                "process_data_00080da0": "process_data",
                "check_and_set_bit_00080e18": "check_and_set_bit",
                "find_value_at_index_00080f9c": "find_value_at_index",
                "set_bits_in_register_00081042": "set_bits_in_register",
                "set_param_value_00081034": "set_param_value",
                "set_param_value_0008106e": "set_param_value",
                "setParamToMaxValue_00081066": "set_param_to_max_value"
            },
            "code": "void initialize_and_execute_00080ae4(void)\n{\n  uint *input_ptr;\n  undefined4 *output_ptr;\n  int i;\n  int count = 0;\n  int DAT_00080bf4;\n  int DAT_00080bf8;\n  int DAT_00080bfc;\n  int DAT_00080c00;\n  \n  input_ptr = DAT_00080be8;\n  initialize_variables();\n  output_ptr = DAT_00080bec;\n  DAT_00080bec[1] = *input_ptr / 1000 - 1;\n  *(undefined *)(DAT_00080bec + 0x23) = 0xf0;\n  output_ptr[2] = 0;\n  *output_ptr = 7;\n  execute_functions();\n  while (count != 0x4f) {\n    DAT_00080c00 = DAT_00080bfc;\n    DAT_00080bfc = DAT_00080bf8;\n    DAT_00080bf8 = DAT_00080bf4;\n    DAT_00080bf4 = count;\n    process_data(count, 0);\n    count++;\n  }\n  *(undefined4 *)(DAT_00080bf4 + 0xa0) = 0xffffffff;\n  *(undefined4 *)(DAT_00080bf8 + 0xa0) = 0xffffffff;\n  *(undefined4 *)(DAT_00080bfc + 0xa0) = 0xffffffff;\n  *(undefined4 *)(DAT_00080c00 + 0xa0) = 0xffffffff;\n  process_data(DAT_00080bf4, 1, 0x300, 0);\n  process_data(0, 1, 0, 0);\n  process_data(DAT_00080bf4, 1, 0xc00, 0);\n  process_data(DAT_00080bf4, 1, 0x3000, 0);\n  process_data(DAT_00080bf8, 2, 0x30, 0);\n  process_data(DAT_00080bfc, 1, 0xc00, 0);\n  process_data(DAT_00080bf4, 1, 3, 0);\n  process_data(DAT_00080bfc, 1, 0xc000, 0);\n  check_and_set_bit(0x25);\n  find_value_at_index(DAT_00080bec[8], *input_ptr, DAT_00080bec[7], 0xc);\n  set_bits_in_register(DAT_00080bec[8], 0, 0x300000, 1);\n  set_param_value(DAT_00080bec[8], 0, 0);\n  set_param_value(DAT_00080bec[8], 0xffffffff);\n  set_param_to_max_value(DAT_00080bec[8]);\n  return;\n}",
            "called": [
                "FUN_00081034",
                "FUN_00080f9c",
                "FUN_00080da0",
                "FUN_00081042",
                "FUN_0008106e",
                "FUN_00080e18",
                "FUN_00081318",
                "FUN_00080e9c",
                "FUN_00081d7c",
                "FUN_00081066"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080ae4",
            "calling": [
                "FUN_000816a8"
            ],
            "imported": false,
            "current_name": "initialize_and_execute_00080ae4"
        },
        "FUN_00081d5c": {
            "renaming": {
                "FUN_00081d5c": "add_to_buffer_00081d5c",
                "param_1": "data",
                "param_2": "index",
                "param_3": "mask",
                "puVar1": "buffer_start",
                "uVar2": "next_index",
                "iVar3": "buffer_ptr",
                "uVar4": "mask_bit"
            },
            "code": "int add_to_buffer_00081d5c(uint32_t data, uint32_t index, uint32_t mask) {\n    int* buffer_start = *(int**)buffer_ptr;\n    if (buffer_start == NULL) {\n        buffer_start = (int*)(*(int*)BUFFER_START_PTR + BUFFER_START_OFFSET);\n        *(int**)buffer_ptr = buffer_start;\n    }\n    uint32_t next_index = buffer_start[1];\n    if (next_index > 31) {\n        if ((BUFFER_OVERFLOW == 0) ||\n           ((buffer_start = (int*)allocate_buffer(400)) == NULL)) {\n            return -1;\n        }\n        *buffer_start = *(int**)buffer_ptr;\n        buffer_start[1] = 0;\n        next_index = 0;\n        *(int**)buffer_ptr = buffer_start;\n        buffer_start[98] = 0;\n        buffer_start[99] = 0;\n    }\n    uint32_t mask_bit = 1 << (next_index & 0xff);\n    buffer_start[next_index + 2] = data;\n    buffer_start[98] |= mask_bit;\n    buffer_start[next_index + 34] = index;\n    buffer_start[99] |= mask_bit;\n    buffer_start[1] = next_index + 1;\n    buffer_start[next_index + 3] = mask;\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081d5c",
            "calling": [
                "FUN_00080a68"
            ],
            "imported": false,
            "current_name": "add_to_buffer_00081d5c"
        },
        "FUN_00082970": {
            "renaming": {
                "FUN_00082970": "add_to_global_00082970",
                "param_1": "result",
                "param_2": "value",
                "puVar1": "global_ptr",
                "iVar2": "previous_value"
            },
            "code": "void add_to_global_00082970(int *result, int value) {\n  undefined *global_ptr;\n  int previous_value;\n\n  global_ptr = PTR_DAT_00082990;\n  *(int *)PTR_DAT_00082990 = 0;\n  previous_value = add_to_global_00082970_and_return_previous_0008118c(value);\n  if ((previous_value == -1) && (*(int *)global_ptr != 0)) {\n    *result = *(int *)global_ptr;\n    return;\n  }\n  return;\n}",
            "called": [
                "FUN_0008118c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00082970",
            "calling": [
                "FUN_00083d00",
                "FUN_00081e14"
            ],
            "imported": false,
            "current_name": "add_to_global_00082970"
        },
        "FUN_000811be": {
            "renaming": {
                "FUN_000811be": "get_one_000811be"
            },
            "code": "int get_one_000811be(void) {\n    return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000811be",
            "calling": [
                "FUN_000846dc"
            ],
            "imported": false,
            "current_name": "get_one_000811be"
        },
        "FUN_00084a80": {
            "renaming": {
                "FUN_00084a80": "FUNC_00084a80"
            },
            "code": "\nundefined8 FUNC_00084a80(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  longlong lVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  bool bVar11;\n  \n  if (param_4 == 0) {\n    if (param_3 <= param_2) {\n      if (param_3 == 0) {\n        param_3 = 1 / 0;\n      }\n      uVar9 = count_leading_zeroes(param_3);\n      if (uVar9 == 0) {\n        param_2 = param_2 - param_3;\n        uVar2 = param_3 >> 0x10;\n        uVar4 = param_3 & 0xffff;\n        uVar7 = 1;\n      }\n      else {\n        param_3 = param_3 << (uVar9 & 0xff);\n        uVar3 = param_2 >> (0x20 - uVar9 & 0xff);\n        uVar2 = param_3 >> 0x10;\n        uVar8 = uVar3 / uVar2;\n        uVar4 = param_3 & 0xffff;\n        uVar7 = uVar4 * uVar8;\n        uVar5 = param_1 >> (0x20 - uVar9 & 0xff) | param_2 << (uVar9 & 0xff);\n        uVar3 = uVar5 >> 0x10 | (uVar3 - uVar2 * uVar8) * 0x10000;\n        param_1 = param_1 << (uVar9 & 0xff);\n        uVar9 = uVar8;\n        if (uVar3 <= uVar7 && uVar7 - uVar3 != 0) {\n          bVar11 = CARRY4(uVar3,param_3);\n          uVar3 = uVar3 + param_3;\n          uVar9 = uVar8 - 1;\n          if ((bVar11 == false) && (uVar3 <= uVar7 && uVar7 - uVar3 != 0)) {\n            uVar9 = uVar8 - 2;\n            uVar3 = uVar3 + param_3;\n          }\n        }\n        uVar6 = (uVar3 - uVar7) / uVar2;\n        uVar8 = uVar4 * uVar6;\n        param_2 = uVar5 & 0xffff | ((uVar3 - uVar7) - uVar2 * uVar6) * 0x10000;\n        uVar7 = uVar6;\n        if (param_2 <= uVar8 && uVar8 - param_2 != 0) {\n          bVar11 = CARRY4(param_2,param_3);\n          param_2 = param_2 + param_3;\n          uVar7 = uVar6 - 1;\n          if ((bVar11 == false) && (param_2 <= uVar8 && uVar8 - param_2 != 0)) {\n            uVar7 = uVar6 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar8;\n        uVar7 = uVar7 | uVar9 << 0x10;\n      }\n      uVar8 = param_2 / uVar2;\n      uVar3 = uVar4 * uVar8;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar2 * uVar8) * 0x10000;\n      uVar9 = uVar8;\n      if (uVar5 <= uVar3 && uVar3 - uVar5 != 0) {\n        bVar11 = CARRY4(uVar5,param_3);\n        uVar5 = uVar5 + param_3;\n        uVar9 = uVar8 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar3 && uVar3 - uVar5 != 0)) {\n          uVar9 = uVar8 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar8 = (uVar5 - uVar3) / uVar2;\n      uVar4 = uVar4 * uVar8;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar3) - uVar2 * uVar8) * 0x10000;\n      uVar2 = uVar8;\n      if (uVar5 <= uVar4 && uVar4 - uVar5 != 0) {\n        uVar2 = uVar8 - 1;\n        if ((CARRY4(uVar5,param_3) == false) &&\n           (uVar5 + param_3 <= uVar4 && uVar4 - (uVar5 + param_3) != 0)) {\n          uVar2 = uVar8 - 2;\n        }\n      }\n      return CONCAT44(uVar7,uVar2 | uVar9 << 0x10);\n    }\n    uVar9 = count_leading_zeroes(param_3);\n    if (uVar9 != 0) {\n      uVar7 = param_1 >> (0x20 - uVar9 & 0xff);\n      param_3 = param_3 << (uVar9 & 0xff);\n      param_1 = param_1 << (uVar9 & 0xff);\n      param_2 = uVar7 | param_2 << (uVar9 & 0xff);\n    }\n    uVar7 = param_3 >> 0x10;\n    uVar2 = param_2 / uVar7;\n    uVar4 = (param_3 & 0xffff) * uVar2;\n    uVar8 = param_1 >> 0x10 | (param_2 - uVar7 * uVar2) * 0x10000;\n    uVar9 = uVar2;\n    if (uVar8 <= uVar4 && uVar4 - uVar8 != 0) {\n      bVar11 = CARRY4(uVar8,param_3);\n      uVar8 = uVar8 + param_3;\n      uVar9 = uVar2 - 1;\n      if ((bVar11 == false) && (uVar8 <= uVar4 && uVar4 - uVar8 != 0)) {\n        uVar9 = uVar2 - 2;\n        uVar8 = uVar8 + param_3;\n      }\n    }\n    uVar5 = (uVar8 - uVar4) / uVar7;\n    uVar2 = (param_3 & 0xffff) * uVar5;\n    uVar4 = param_1 & 0xffff | ((uVar8 - uVar4) - uVar7 * uVar5) * 0x10000;\n    uVar7 = uVar5;\n    if (uVar4 <= uVar2 && uVar2 - uVar4 != 0) {\n      uVar7 = uVar5 - 1;\n      if ((CARRY4(uVar4,param_3) == false) &&\n         (uVar4 + param_3 <= uVar2 && uVar2 - (uVar4 + param_3) != 0)) {\n        uVar7 = uVar5 - 2;\n      }\n    }\n    uVar9 = uVar7 | uVar9 << 0x10;\n    uVar7 = 0;\n  }\n  else {\n    if (param_2 < param_4) {\n      return 0;\n    }\n    uVar9 = count_leading_zeroes(param_4);\n    if (uVar9 == 0) {\n      if ((param_4 < param_2) || (uVar7 = uVar9, param_3 <= param_1)) {\n        return 1;\n      }\n    }\n    else {\n      uVar2 = 0x20 - uVar9;\n      uVar7 = param_2 >> (uVar2 & 0xff);\n      uVar4 = param_4 << (uVar9 & 0xff) | param_3 >> (uVar2 & 0xff);\n      uVar8 = uVar4 >> 0x10;\n      uVar6 = uVar7 / uVar8;\n      uVar5 = (uVar4 & 0xffff) * uVar6;\n      uVar3 = param_1 >> (uVar2 & 0xff) | param_2 << (uVar9 & 0xff);\n      uVar2 = uVar3 >> 0x10 | (uVar7 - uVar8 * uVar6) * 0x10000;\n      uVar7 = uVar6;\n      if (uVar2 <= uVar5 && uVar5 - uVar2 != 0) {\n        bVar11 = CARRY4(uVar2,uVar4);\n        uVar2 = uVar2 + uVar4;\n        uVar7 = uVar6 - 1;\n        if ((bVar11 == false) && (uVar2 <= uVar5 && uVar5 - uVar2 != 0)) {\n          uVar7 = uVar6 - 2;\n          uVar2 = uVar2 + uVar4;\n        }\n      }\n      uVar6 = (uVar2 - uVar5) / uVar8;\n      uVar10 = (uVar4 & 0xffff) * uVar6;\n      uVar8 = uVar3 & 0xffff | ((uVar2 - uVar5) - uVar8 * uVar6) * 0x10000;\n      uVar2 = uVar6;\n      if (uVar8 <= uVar10 && uVar10 - uVar8 != 0) {\n        bVar11 = CARRY4(uVar8,uVar4);\n        uVar8 = uVar8 + uVar4;\n        uVar2 = uVar6 - 1;\n        if ((bVar11 == false) && (uVar8 <= uVar10 && uVar10 - uVar8 != 0)) {\n          uVar2 = uVar6 - 2;\n          uVar8 = uVar8 + uVar4;\n        }\n      }\n      uVar2 = uVar2 | uVar7 << 0x10;\n      lVar1 = (ulonglong)uVar2 * (ulonglong)(param_3 << (uVar9 & 0xff));\n      uVar7 = (uint)((ulonglong)lVar1 >> 0x20);\n      if ((uVar8 - uVar10 < uVar7) ||\n         ((uVar8 - uVar10 == uVar7 && (param_1 << (uVar9 & 0xff) < (uint)lVar1)))) {\n        uVar9 = uVar2 - 1;\n        uVar7 = 0;\n      }\n      else {\n        uVar9 = uVar2;\n        uVar7 = 0;\n      }\n    }\n  }\n  return CONCAT44(uVar7,uVar9);\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00084a80",
            "calling": [
                "FUN_000847ac"
            ],
            "imported": false,
            "current_name": "FUNC_00084a80"
        },
        "FUN_00081c54": {
            "renaming": {
                "FUN_00081c54": "concatenate_params_and_swap_them_00081c54",
                "param_1": "first_param",
                "param_2": "second_param"
            },
            "code": "void concatenate_params_and_swap_them_00081c54(undefined4 first_param, undefined4 second_param)\n{\n    concatenate_params_00081c5c(second_param, first_param);\n    return;\n}",
            "called": [
                "FUN_00081c5c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081c54",
            "calling": [
                "FUN_00081ca8"
            ],
            "imported": false,
            "current_name": "concatenate_params_and_swap_them_00081c54"
        },
        "FUN_0008163a": {
            "renaming": {
                "FUN_0008163a": "execute_and_check_0008163a",
                "*param_1": "*ptr_param",
                "param_2": "param_size",
                "iVar1": "execute_result"
            },
            "code": "int execute_and_check_0008163a(int *ptr_param, uint32_t param_size) {\n  int execute_result;\n  if ((ptr_param[0] == 0) || ((uint32_t)ptr_param[1] < param_size)) {\n    execute_result = execute_function(ptr_param);\n    if (execute_result == 0) {\n      return 0;\n    }\n    if (ptr_param[2] == 0) {\n      *(uint8_t *)*ptr_param = 0;\n    }\n  }\n  return 1;\n}",
            "called": [
                "FUN_00081622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008163a",
            "calling": [
                "FUN_0008165c"
            ],
            "imported": false,
            "current_name": "execute_and_check_0008163a"
        },
        "FUN_000825a0": {
            "renaming": {
                "FUN_000825a0": "execute_function_with_data_pointer_000825a0",
                "param_1": "parameter_1",
                "param_2": "parameter_2",
                "FUN_000825b0": "function",
                "*DAT_000825ac": "data_pointer"
            },
            "code": "void execute_function_with_*execute_function_with_data_pointer_000825a0(void* *execute_function_with_data_pointer_000825a0, int param_1, int param_2)\n{\n  function(**execute_function_with_data_pointer_000825a0, param_1, param_2);\n  return;\n}",
            "called": [
                "FUN_000825b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000825a0",
            "calling": [
                "FUN_00081622"
            ],
            "imported": false,
            "current_name": "execute_function_with_data_pointer_000825a0"
        },
        "FUN_000815d4": {
            "renaming": {
                "FUN_000815d4": "update_data_ptr_000815d4",
                "param_1": "data_ptr",
                "param_2": "data_value",
                "initialize_params_000814e4": "initialize_params",
                "*param_1": "*data_ptr",
                "PTR_PTR_update_data_00081454_1_000815f4": "PTR_PTR_update_data"
            },
            "code": "undefined4 * update_data_ptr_000815d4(undefined4 *data_ptr, undefined4 data_value) {\n    initialize_params();\n    *data_ptr = PTR_PTR_update_data_00081454_1_000815f4;\n    data_ptr[9] = data_value;\n    return data_ptr;\n}",
            "called": [
                "FUN_000814e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000815d4",
            "calling": [
                "FUN_00080c0c"
            ],
            "imported": false,
            "current_name": "update_data_ptr_000815d4"
        },
        "FUN_00081e14": {
            "renaming": {
                "FUN_00081e14": "improved_function_00081e14",
                "param_1": "input_array",
                "param_2": "array_length",
                "uVar1": "temp_var1",
                "puVar2": "temp_ptr1",
                "puVar3": "temp_ptr2",
                "iVar4": "temp_var2",
                "uVar5": "temp_var3",
                "uVar6": "temp_var4",
                "iVar7": "temp_var5",
                "uVar8": "temp_var6",
                "iVar9": "temp_var7",
                "piVar10": "temp_ptr3",
                "uVar11": "temp_var8",
                "iVar12": "temp_var9",
                "iVar13": "temp_var10",
                "piVar14": "temp_ptr4",
                "uVar15": "temp_var11",
                "piVar16": "temp_ptr5",
                "uVar17": "temp_var12",
                "uVar18": "temp_var13"
            },
            "code": "\nint * improved_function_00081e14(undefined4 *input_array,uint array_length)\n\n{\n  uint temp_var1;\n  uint *temp_ptr1;\n  undefined *temp_ptr2;\n  int temp_var2;\n  uint temp_var3;\n  uint temp_var4;\n  int temp_var5;\n  uint temp_var6;\n  int temp_var7;\n  int *temp_ptr3;\n  uint temp_var8;\n  int temp_var9;\n  int temp_var10;\n  int *temp_ptr4;\n  uint temp_var11;\n  int *temp_ptr5;\n  uint temp_var12;\n  uint temp_var13;\n  \n  if (array_length + 0xb < 0x17) {\n    temp_var11 = 0x10;\n    if (0x10 < array_length) goto LAB_00081e7a;\n  }\n  else {\n    temp_var11 = array_length + 0xb & 0xfffffff8;\n    if (((int)temp_var11 < 0) || (temp_var11 < array_length)) {\nLAB_00081e7a:\n      *input_array = 0xc;\n      return (int *)0x0;\n    }\n  }\n  do_nothing_00082598(input_array);\n  temp_var1 = DAT_00082140;\n  if (temp_var11 < 0x1f8) {\n    temp_var10 = *(int *)(DAT_00082140 + temp_var11 + 0xc);\n    if ((temp_var10 != DAT_00082140 + temp_var11) ||\n       (temp_var2 = temp_var10 + 8, temp_var10 = *(int *)(temp_var10 + 0x14), temp_var2 != temp_var10)) {\n      temp_var5 = *(int *)(temp_var10 + 0xc);\n      temp_var7 = (*(uint *)(temp_var10 + 4) & 0xfffffffc) + temp_var10;\n      temp_var11 = *(uint *)(temp_var7 + 4);\n      temp_var2 = *(int *)(temp_var10 + 8);\n      *(int *)(temp_var2 + 0xc) = temp_var5;\n      *(int *)(temp_var5 + 8) = temp_var2;\n      *(uint *)(temp_var7 + 4) = temp_var11 | 1;\n      do_nothing_0008259c(input_array);\n      return (int *)(temp_var10 + 8);\n    }\n    temp_var13 = (temp_var11 >> 3) + 2;\n  }\n  else {\n    temp_var13 = temp_var11 >> 9;\n    if (temp_var13 == 0) {\n      temp_var2 = 0x7e;\n      temp_var10 = 0x3f;\n    }\n    else if (temp_var13 < 5) {\n      temp_var10 = (temp_var11 >> 6) + 0x38;\n      temp_var2 = temp_var10 * 2;\n    }\n    else if (temp_var13 < 0x15) {\n      temp_var10 = temp_var13 + 0x5b;\n      temp_var2 = temp_var10 * 2;\n    }\n    else if (temp_var13 < 0x55) {\n      temp_var10 = (temp_var11 >> 0xc) + 0x6e;\n      temp_var2 = temp_var10 * 2;\n    }\n    else if (temp_var13 < 0x155) {\n      temp_var10 = (temp_var11 >> 0xf) + 0x77;\n      temp_var2 = temp_var10 * 2;\n    }\n    else if (temp_var13 < 0x555) {\n      temp_var10 = (temp_var11 >> 0x12) + 0x7c;\n      temp_var2 = temp_var10 * 2;\n    }\n    else {\n      temp_var2 = 0xfc;\n      temp_var10 = 0x7e;\n    }\n    temp_var5 = DAT_00082140 + temp_var2 * 4;\n    for (temp_var2 = *(int *)(temp_var5 + 0xc); temp_var5 != temp_var2; temp_var2 = *(int *)(temp_var2 + 0xc)) {\n      temp_var13 = *(uint *)(temp_var2 + 4) & 0xfffffffc;\n      temp_var7 = temp_var13 - temp_var11;\n      if (0xf < temp_var7) {\n        temp_var10 = temp_var10 + -1;\n        break;\n      }\n      if (-1 < temp_var7) {\n        temp_var5 = temp_var13 + temp_var2;\n        temp_var11 = *(uint *)(temp_var5 + 4);\n        temp_var7 = *(int *)(temp_var2 + 0xc);\n        temp_var10 = *(int *)(temp_var2 + 8);\n        *(int *)(temp_var10 + 0xc) = temp_var7;\n        *(int *)(temp_var7 + 8) = temp_var10;\n        *(uint *)(temp_var5 + 4) = temp_var11 | 1;\n        do_nothing_0008259c(input_array);\n        return (int *)(temp_var2 + 8);\n      }\n    }\n    temp_var13 = temp_var10 + 1;\n  }\n  temp_var10 = *(int *)(DAT_00082140 + 0x10);\n  temp_var2 = DAT_00082140 + 8;\n  if (temp_var10 == temp_var2) {\n    temp_var3 = *(uint *)(DAT_00082140 + 4);\n  }\n  else {\n    temp_var3 = *(uint *)(temp_var10 + 4);\n    temp_var4 = temp_var3 & 0xfffffffc;\n    temp_var6 = temp_var4 - temp_var11;\n    if (0xf < (int)temp_var6) {\n      temp_var5 = temp_var11 + temp_var10;\n      *(uint *)(temp_var10 + 4) = temp_var11 | 1;\n      *(int *)(temp_var1 + 0x14) = temp_var5;\n      *(int *)(temp_var1 + 0x10) = temp_var5;\n      *(int *)(temp_var5 + 0xc) = temp_var2;\n      *(int *)(temp_var5 + 8) = temp_var2;\n      *(uint *)(temp_var5 + 4) = temp_var6 | 1;\n      *(uint *)(temp_var5 + temp_var6) = temp_var6;\n      do_nothing_0008259c(input_array);\n      return (int *)(temp_var10 + 8);\n    }\n    *(int *)(DAT_00082140 + 0x14) = temp_var2;\n    *(int *)(temp_var1 + 0x10) = temp_var2;\n    if (-1 < (int)temp_var6) {\n      *(uint *)(temp_var4 + temp_var10 + 4) = *(uint *)(temp_var4 + temp_var10 + 4) | 1;\n      do_nothing_0008259c(input_array);\n      return (int *)(temp_var10 + 8);\n    }\n    if (temp_var4 < 0x200) {\n      temp_var7 = temp_var1 + (temp_var3 & 0xfffffff8);\n      temp_var5 = *(int *)(temp_var7 + 8);\n      temp_var3 = 1 << ((int)(temp_var3 >> 3) >> 2 & 0xffU) | *(uint *)(temp_var1 + 4);\n      *(int *)(temp_var10 + 8) = temp_var5;\n      *(int *)(temp_var10 + 0xc) = temp_var7;\n      *(uint *)(temp_var1 + 4) = temp_var3;\n      *(int *)(temp_var7 + 8) = temp_var10;\n      *(int *)(temp_var5 + 0xc) = temp_var10;\n    }\n    else {\n      temp_var6 = temp_var3 >> 9;\n      if (temp_var6 < 5) {\n        temp_var7 = (temp_var3 >> 6) + 0x38;\n        temp_var5 = temp_var7 * 2;\n      }\n      else if (temp_var6 < 0x15) {\n        temp_var7 = temp_var6 + 0x5b;\n        temp_var5 = temp_var7 * 2;\n      }\n      else if (temp_var6 < 0x55) {\n        temp_var7 = (temp_var3 >> 0xc) + 0x6e;\n        temp_var5 = temp_var7 * 2;\n      }\n      else if (temp_var6 < 0x155) {\n        temp_var7 = (temp_var3 >> 0xf) + 0x77;\n        temp_var5 = temp_var7 * 2;\n      }\n      else if (temp_var6 < 0x555) {\n        temp_var7 = (temp_var3 >> 0x12) + 0x7c;\n        temp_var5 = temp_var7 * 2;\n      }\n      else {\n        temp_var5 = 0xfc;\n        temp_var7 = 0x7e;\n      }\n      temp_var5 = temp_var1 + temp_var5 * 4;\n      temp_var9 = *(int *)(temp_var5 + 8);\n      if (temp_var9 == temp_var5) {\n        temp_var3 = *(uint *)(DAT_00082348 + 4) | 1 << (temp_var7 >> 2 & 0xffU);\n        *(uint *)(DAT_00082348 + 4) = temp_var3;\n        temp_var7 = temp_var9;\n      }\n      else {\n        do {\n          temp_var7 = temp_var9;\n          if ((*(uint *)(temp_var9 + 4) & 0xfffffffc) <= temp_var4) break;\n          temp_var9 = *(int *)(temp_var9 + 8);\n          temp_var7 = temp_var9;\n        } while (temp_var5 != temp_var9);\n        temp_var9 = *(int *)(temp_var7 + 0xc);\n        temp_var3 = *(uint *)(temp_var1 + 4);\n      }\n      *(int *)(temp_var10 + 0xc) = temp_var9;\n      *(int *)(temp_var10 + 8) = temp_var7;\n      *(int *)(temp_var9 + 8) = temp_var10;\n      *(int *)(temp_var7 + 0xc) = temp_var10;\n    }\n  }\n  temp_var4 = 1 << ((int)temp_var13 >> 2 & 0xffU);\n  if (temp_var4 <= temp_var3) {\n    if ((temp_var3 & temp_var4) == 0) {\n      temp_var13 = temp_var13 & 0xfffffffc;\n      do {\n        temp_var4 = temp_var4 << 1;\n        temp_var13 = temp_var13 + 4;\n      } while ((temp_var3 & temp_var4) == 0);\n    }\n    do {\n      temp_ptr5 = (int *)(temp_var1 + temp_var13 * 8);\n      temp_ptr4 = temp_ptr5;\n      temp_var3 = temp_var13;\n      do {\n        for (temp_ptr3 = (int *)temp_ptr4[3]; temp_ptr4 != temp_ptr3; temp_ptr3 = (int *)temp_ptr3[3]) {\n          temp_var6 = temp_ptr3[1] & 0xfffffffc;\n          temp_var12 = temp_var6 - temp_var11;\n          if (0xf < (int)temp_var12) {\n            temp_var7 = temp_ptr3[2];\n            temp_var10 = temp_ptr3[3];\n            temp_var5 = temp_var11 + (int)temp_ptr3;\n            temp_ptr3[1] = temp_var11 | 1;\n            *(int *)(temp_var7 + 0xc) = temp_var10;\n            *(int *)(temp_var10 + 8) = temp_var7;\n            *(int *)(temp_var1 + 0x14) = temp_var5;\n            *(int *)(temp_var1 + 0x10) = temp_var5;\n            *(int *)(temp_var5 + 0xc) = temp_var2;\n            *(int *)(temp_var5 + 8) = temp_var2;\n            *(uint *)(temp_var5 + 4) = temp_var12 | 1;\n            *(uint *)(temp_var5 + temp_var12) = temp_var12;\n            do_nothing_0008259c(input_array);\n            return temp_ptr3 + 2;\n          }\n          if (-1 < (int)temp_var12) {\n            temp_var10 = temp_ptr3[2];\n            temp_var2 = temp_ptr3[3];\n            *(uint *)((int)temp_ptr3 + temp_var6 + 4) = *(uint *)((int)temp_ptr3 + temp_var6 + 4) | 1;\n            *(int *)(temp_var10 + 0xc) = temp_var2;\n            *(int *)(temp_var2 + 8) = temp_var10;\n            do_nothing_0008259c(input_array);\n            return temp_ptr3 + 2;\n          }\n        }\n        temp_var3 = temp_var3 + 1;\n        temp_ptr4 = temp_ptr4 + 2;\n      } while ((temp_var3 & 3) != 0);\n      do {\n        temp_var6 = temp_var13 & 3;\n        temp_ptr4 = temp_ptr5 + -2;\n        temp_var13 = temp_var13 - 1;\n        if (temp_var6 == 0) {\n          temp_var6 = *(uint *)(temp_var1 + 4) & ~temp_var4;\n          *(uint *)(temp_var1 + 4) = temp_var6;\n          goto LAB_00082262;\n        }\n        temp_ptr5 = (int *)*temp_ptr5;\n      } while (temp_ptr5 == temp_ptr4);\n      temp_var6 = *(uint *)(temp_var1 + 4);\nLAB_00082262:\n      temp_var4 = temp_var4 * 2;\n      if ((temp_var6 <= temp_var4 && temp_var4 - temp_var6 != 0) || (temp_var13 = temp_var3, temp_var4 == 0)) break;\n      for (; (temp_var6 & temp_var4) == 0; temp_var4 = temp_var4 << 1) {\n        temp_var13 = temp_var13 + 4;\n      }\n    } while( true );\n  }\n  temp_ptr1 = DAT_00082148;\n  temp_var13 = *(uint *)(temp_var1 + 8);\n  temp_var3 = *(uint *)(temp_var13 + 4) & 0xfffffffc;\n  if ((temp_var11 <= temp_var3) && (temp_var6 = temp_var3 - temp_var11, temp_var4 = temp_var13, 0xf < (int)temp_var6))\n  goto LAB_0008211e;\n  temp_var6 = temp_var13 + temp_var3;\n  if (*DAT_00082148 == 0xffffffff) {\n    temp_var12 = temp_var11 + *(int *)PTR_DAT_00082144 + 0x10;\n  }\n  else {\n    temp_var12 = temp_var11 + *(int *)PTR_DAT_00082144 + 0x100f & 0xfffff000;\n  }\n  temp_var4 = add_to_global_00082970(input_array,temp_var12);\n  temp_ptr2 = PTR_DAT_00082154;\n  if ((temp_var4 == 0xffffffff) || ((temp_var4 < temp_var6 && (temp_var13 != temp_var1)))) {\n    temp_var4 = *(uint *)(temp_var1 + 8);\n    temp_var13 = *(uint *)(temp_var4 + 4) & 0xfffffffc;\n  }\n  else {\n    temp_var8 = *(int *)PTR_DAT_00082154 + temp_var12;\n    *(uint *)PTR_DAT_00082154 = temp_var8;\n    if ((temp_var6 == temp_var4) && ((temp_var6 & 0xfff) == 0)) {\n      *(uint *)(*(int *)(temp_var1 + 8) + 4) = temp_var12 + temp_var3 | 1;\n    }\n    else {\n      if (*temp_ptr1 == 0xffffffff) {\n        *DAT_00082148 = temp_var4;\n      }\n      else {\n        *(uint *)temp_ptr2 = temp_var8 + (temp_var4 - temp_var6);\n      }\n      temp_var6 = temp_var4 & 7;\n      if (temp_var6 == 0) {\n        temp_var10 = 0x1000;\n      }\n      else {\n        temp_var4 = temp_var4 + (8 - temp_var6);\n        temp_var10 = 0x1008 - temp_var6;\n      }\n      temp_var10 = temp_var10 - (temp_var12 + temp_var4 & 0xfff);\n      temp_var2 = add_to_global_00082970(input_array,temp_var10);\n      if (temp_var2 == -1) {\n        temp_var6 = 1;\n        temp_var10 = 0;\n      }\n      else {\n        temp_var6 = (temp_var2 - temp_var4) + temp_var10 | 1;\n      }\n      temp_var8 = *(int *)temp_ptr2 + temp_var10;\n      *(uint *)(temp_var1 + 8) = temp_var4;\n      *(uint *)temp_ptr2 = temp_var8;\n      *(uint *)(temp_var4 + 4) = temp_var6;\n      temp_ptr2 = PTR_DAT_00082154;\n      if (temp_var13 != temp_var1) {\n        if (temp_var3 < 0x10) {\n          *(undefined4 *)(temp_var4 + 4) = 1;\n          temp_var13 = 0;\n          goto LAB_00082108;\n        }\n        temp_var3 = temp_var3 - 0xc & 0xfffffff8;\n        *(uint *)(temp_var13 + 4) = temp_var3 | *(uint *)(temp_var13 + 4) & 1;\n        *(undefined4 *)(temp_var13 + temp_var3 + 4) = 5;\n        *(undefined4 *)(temp_var13 + temp_var3 + 8) = 5;\n        if (0xf < temp_var3) {\n          allocate_memory_block_00083d9c(input_array,temp_var13 + 8);\n          temp_var8 = *(uint *)temp_ptr2;\n        }\n      }\n    }\n    temp_var4 = *(uint *)(temp_var1 + 8);\n    if (*(uint *)PTR_DAT_0008214c < temp_var8) {\n      *(uint *)PTR_DAT_0008214c = temp_var8;\n    }\n    if (*(uint *)PTR_DAT_00082150 < temp_var8) {\n      *(uint *)PTR_DAT_00082150 = temp_var8;\n    }\n    temp_var13 = *(uint *)(temp_var4 + 4) & 0xfffffffc;\n  }\nLAB_00082108:\n  temp_var6 = temp_var13 - temp_var11;\n  if ((temp_var13 < temp_var11) || ((int)temp_var6 < 0x10)) {\n    do_nothing_0008259c(input_array);\n    return (int *)0x0;\n  }\nLAB_0008211e:\n  *(uint *)(temp_var4 + 4) = temp_var11 | 1;\n  *(uint *)(temp_var1 + 8) = temp_var11 + temp_var4;\n  *(uint *)(temp_var11 + temp_var4 + 4) = temp_var6 | 1;\n  do_nothing_0008259c(input_array);\n  return (int *)(temp_var4 + 8);\n}\n\n",
            "called": [
                "FUN_00082970",
                "FUN_00083d9c",
                "FUN_00082598",
                "FUN_0008259c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081e14",
            "calling": [
                "FUN_00081df4",
                "FUN_000842a4",
                "FUN_000825b0",
                "FUN_00083f34"
            ],
            "imported": false,
            "current_name": "improved_function_00081e14"
        },
        "FUN_00080164": {
            "renaming": {
                "FUN_00080164": "process_data_00080164",
                "param_1": "data",
                "puVar1": "data_ptr",
                "iVar2": "result"
            },
            "code": "void process_data_00080164(int** data){\n    undefined* data_ptr = PTR_DAT_000801ac;\n    *data = (int*)PTR_DAT_000801ac;\n    (**(code **)(*(int *)data_ptr + 0x18))(PTR_DAT_000801ac);\n    if (1 < *(byte *)((int)data + 6)) {\n        process_data_00080164_00081210(*(byte *)((int)data + 6),1);\n        process_data_00080164_00081318(*(undefined *)((int)data + 6),0);\n    }\n    do {\n        int result = (**(code **)(**data + 0xc))();\n    } while (-1 < result);\n    *(undefined *)((int)data + 0x49) = 0;\n    *(undefined *)((int)data + 0x4a) = 0;\n    *(undefined2 *)(data + 0x15) = 0;\n    *(undefined2 *)((int)data + 0x52) = 0;\n    *(undefined2 *)(data + 0x14) = 0;\n    return;\n}",
            "called": [
                "FUN_00081210",
                "FUN_00081318"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080164",
            "calling": [
                "FUN_000804a8"
            ],
            "imported": false,
            "current_name": "process_data_00080164"
        },
        "FUN_000811cc": {
            "renaming": {
                "FUN_000811cc": "copy_bytes_to_destination_000811cc",
                "param_1": "destination_address",
                "param_2": "source_address",
                "param_3": "num_bytes_to_copy",
                "iVar1": "i"
            },
            "code": "uint copy_bytes_to_destination_000811cc(uint destination_address, int source_address, uint num_bytes_to_copy)\n{\n  int i = 0;\n  for (i = 0; i < (int)num_bytes_to_copy; i++) {\n    do {\n    } while (-1 < *(int *)(DAT_000811ec + 0x14) << 0x1e);\n    *(uint *)(DAT_000811ec + 0x1c) = (uint)*(byte *)(source_address + i);\n  }\n  return num_bytes_to_copy & ~((int)num_bytes_to_copy >> 0x1f);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000811cc",
            "calling": [
                "FUN_00084464"
            ],
            "imported": false,
            "current_name": "copy_bytes_to_destination_000811cc"
        },
        "FUN_000846dc": {
            "renaming": {
                "FUN_000846dc": "get_integer_or_default_000846dc",
                "param_1": "output",
                "param_2": "input",
                "puVar1": "ptr",
                "iVar2": "value"
            },
            "code": "void get_integer_or_default_000846dc(int *output, undefined4 input) {\n  undefined *ptr = PTR_DAT_000846fc;\n  *(undefined4 *)PTR_DAT_000846fc = 0;\n  int value = get_integer_from_input(input);\n  if ((value == -1) && (*(int *)ptr != 0)) {\n    *output = *(int *)ptr;\n    return;\n  }\n  return;\n}",
            "called": [
                "FUN_000811be"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000846dc",
            "calling": [
                "FUN_000842a4"
            ],
            "imported": false,
            "current_name": "get_integer_or_default_000846dc"
        },
        "FUN_00081894": {
            "renaming": {
                "FUN_00081894": "calculate_00081894",
                "param_1": "input",
                "iVar1": "leading_zeroes",
                "uVar2": "shift_amount",
                "iVar3": "multiplier",
                "uVar4": "shifted_input",
                "0U": "shifted_zero",
                "result": "result",
                "carry": "carry"
            },
            "code": "uint calculate_00081894(uint input)\n{\n  int leading_zeroes = count_leading_zeroes(input);\n  int shift_amount = leading_zeroes - 8;\n  int multiplier = shift_amount * -0x800000 + 0x4a800000;\n  if (leading_zeroes > 7)\n  {\n    uint shifted_input = input << (shift_amount & 0xff);\n    uint shifted_zero = 0U >> (0x20 - shift_amount & 0xff);\n    uint carry = (uint)(0x7fffffff < shifted_zero);\n    uint result = multiplier + shifted_input + shifted_zero + carry;\n    if (shifted_zero == 0x80000000)\n    {\n      result = result & 0xfffffffe;\n    }\n    return result;\n  }\n  uint shifted_input = input << (leading_zeroes + 0x18U & 0xff);\n  int shifted_zero = (int)0U >> (0x20 - (leading_zeroes + 0x18U) & 0xff);\n  uint carry = ((int)shifted_input >> 0x1f) - (shifted_input >> 0x1f);\n  uint result = multiplier + ((input >> (0x20 - (leading_zeroes + 0x18U) & 0xff)) - carry);\n  if ((shifted_input & 0x7fffffff) == 0)\n  {\n    result = result & ~(shifted_input >> 0x1f);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081894",
            "calling": [
                "FUN_000805d0"
            ],
            "imported": false,
            "current_name": "calculate_00081894"
        },
        "FUN_000845bc": {
            "renaming": {
                "FUN_000845bc": "write_byte_to_memory_000845bc",
                "param_1": "memory_address",
                "param_2": "byte_address",
                "param_3": "byte_value",
                "undefined4": "int",
                "undefined": "unsigned char",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "int write_byte_to_memory_000845bc(unsigned int *memory_address, unsigned char *byte_address, unsigned int byte_value) {\n  if (byte_address == NULL) {\n    return 0;\n  }\n  if (byte_value < 256) {\n    *byte_address = (unsigned char)byte_value;\n    return 1;\n  }\n  *memory_address = 138;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000845bc",
            "calling": [
                "FUN_0008456c"
            ],
            "imported": false,
            "current_name": "write_byte_to_memory_000845bc"
        },
        "FUN_00085858": {
            "renaming": {
                "FUN_00085858": "do_nothing_00085858"
            },
            "code": "\nvoid do_nothing_00085858(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00085858",
            "calling": [
                "FUN_00081d7c"
            ],
            "imported": false,
            "current_name": "do_nothing_00085858"
        },
        "FUN_00082504": {
            "renaming": {
                "FUN_00082504": "fill_memory_with_value_00082504",
                "param_1": "memory",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "byte_memory",
                "puVar2": "next_byte_memory",
                "uVar3": "value32",
                "uVar4": "remaining_size",
                "bVar5": "is_size_zero",
                "LAB_00082580": "end_of_function"
            },
            "code": "void fill_memory_with_value_00082504(uint32_t *memory, uint8_t value, uint32_t size) {\n    uint8_t *byte_memory = (uint8_t *)memory;\n    uint32_t i;\n    uint32_t remaining_size = size;\n\n    if (((uint32_t)memory & 3) != 0) {\n        if (size == 0) {\n            return;\n        }\n        *byte_memory++ = value;\n        remaining_size--;\n    }\n\n    uint32_t value32 = (value << 24) | (value << 16) | (value << 8) | value;\n\n    for (i = 0; i < remaining_size / 16; i++) {\n        *memory++ = value32;\n        *memory++ = value32;\n        *memory++ = value32;\n        *memory++ = value32;\n    }\n\n    remaining_size &= 0xF;\n\n    for (i = 0; i < remaining_size; i++) {\n        *byte_memory++ = value;\n    }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00082504",
            "calling": [
                "FUN_00083b14",
                "FUN_000813a8"
            ],
            "imported": false,
            "current_name": "fill_memory_with_value_00082504"
        },
        "FUN_000800f4": {
            "renaming": {
                "FUN_000800f4": "check_if_initialized_000800f4",
                "param_1": "input_value",
                "*PTR_DAT_0008010c": "*PTR_TO_INITIALIZED_FLAG",
                "DAT_00080110": "INITIALIZED_VALUE",
                "DAT_00080114": "INITIALIZED_INPUT_VALUE"
            },
            "code": "int check_if_initialized_000800f4(int input_value){\n    if (*PTR_DAT_0008010c == \"\\0\") {\n        if (DAT_00080110 != 0) {\n            input_value = DAT_00080114;\n        }\n        *PTR_DAT_0008010c = 1;\n    }\n    return input_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000800f4",
            "calling": [],
            "imported": false,
            "current_name": "check_if_initialized_000800f4"
        },
        "FUN_0008378c": {
            "renaming": {
                "FUN_0008378c": "process_data_and_return_negative_if_error_occurs_0008378c",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "iVar1": "return_value",
                "iVar2": "process_data_return_value",
                "local_488": "local_array",
                "local_480": "local_variable_1",
                "local_47c": "local_variable_2",
                "local_47a": "local_variable_3",
                "local_478": "local_variable_4",
                "local_474": "local_variable_5",
                "local_470": "local_variable_6",
                "local_46c": "local_variable_7",
                "local_464": "local_variable_8",
                "local_424": "local_variable_9",
                "auStack_420": "local_array_on_stack"
            },
            "code": "int process_data_and_return_negative_if_error_occurs_0008378c(undefined4 input_param_1, int input_param_2)\n{\n  int return_value;\n  int process_data_return_value;\n  undefined *local_array[2];\n  undefined4 local_variable_1;\n  ushort local_variable_2;\n  undefined2 local_variable_3;\n  undefined *local_variable_4;\n  undefined4 local_variable_5;\n  undefined4 local_variable_6;\n  undefined4 local_variable_7;\n  undefined4 local_variable_8;\n  undefined4 local_variable_9;\n  undefined local_array_on_stack[1024];\n  local_variable_9 = *(undefined4 *)(input_param_2 + 100);\n  local_variable_7 = *(undefined4 *)(input_param_2 + 0x1c);\n  local_variable_3 = *(undefined2 *)(input_param_2 + 0xe);\n  local_variable_8 = *(undefined4 *)(input_param_2 + 0x24);\n  local_array[0] = local_array_on_stack;\n  local_variable_2 = *(ushort *)(input_param_2 + 0xc) & 0xfffd;\n  local_variable_1 = 0x400;\n  local_variable_5 = 0x400;\n  local_variable_6 = 0;\n  local_variable_4 = local_array[0];\n  return_value = FUNC_00082b38(input_param_1, local_array);\n  if ((return_value >= 0) || ((process_data_return_value = process_data_00083adc(input_param_1, local_array)) == 0)) {\n    return_value = -1;\n  }\n  if ((int)((uint)local_variable_2 << 0x19) < 0) {\n    *(ushort *)(input_param_2 + 0xc) = *(ushort *)(input_param_2 + 0xc) | 0x40;\n  }\n  return return_value;\n}",
            "called": [
                "FUN_00083adc",
                "FUN_00082b38"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008378c",
            "calling": [
                "FUN_00082b38"
            ],
            "imported": false,
            "current_name": "process_data_and_return_negative_if_error_occurs_0008378c"
        },
        "FUN_00083adc": {
            "renaming": {
                "FUN_00083adc": "process_data_00083adc",
                "param_1": "input_data",
                "param_2": "output_data",
                "piVar1": "chunk_data_ptr",
                "iVar2": "chunk_size_packed_unpacked",
                "uVar3": "chunk_flags",
                "uVar4": "chunk_size_packed",
                "iVar5": "chunk_size_remaining",
                "pcVar6": "unpack_func_ptr",
                "unaff_r4": "result",
                "iVar7": "input_data_size",
                "chunk_data_offset": "chunk_data_ptr_offset",
                "chunk_size_packed_unpacked": "chunk_size_unpacked",
                "chunk_size_packed": "chunk_size_packed",
                "chunk_size_remaining": "chunk_size_remaining",
                "unpack_func_ptr": "unpack_func_ptr",
                "chunk_flags": "chunk_flags",
                "chunk_size_unpacked": "chunk_size_unpacked",
                "chunk_data_ptr": "chunk_data_ptr",
                "initialize_00083b14": "initialize_chunk_processing",
                "LAB_00083a54": "label_00083a54",
                "allocate_memory_block_00083d9c": "allocate_memory_block"
            },
            "code": "undefined4 process_data_00083adc(int *input_data, int *output_data)\n{\n  int *chunk_data_ptr;\n  int chunk_size_remaining;\n  ushort chunk_flags;\n  uint chunk_size_packed;\n  int chunk_size_unpacked;\n  code *unpack_func_ptr;\n  undefined4 result;\n  int input_data_size;\n  \n  if ((input_data != (int *)0x0) && (input_data[0xe] == 0)) {\n    initialize_chunk_processing();\n  }\n  if (*(short *)(output_data + 3) == 0) {\n    return 0;\n  }\n  chunk_flags = *(ushort *)(output_data + 3);\n  chunk_size_packed = (uint)chunk_flags << 0x1c;\n  if ((int)chunk_size_packed < 0) {\n    int chunk_data_offset = output_data[4];\n    if (chunk_data_offset == 0) {\n      return 0;\n    }\n    int chunk_size_packed_unpacked = *output_data;\n    if ((chunk_flags & 3) == 0) {\n      chunk_size_remaining = output_data[5];\n    }\n    else {\n      chunk_size_remaining = 0;\n    }\n    *output_data = chunk_data_offset;\n    chunk_size_unpacked = chunk_size_packed_unpacked - chunk_data_offset;\n    output_data[2] = chunk_size_remaining;\n    do {\n      if (chunk_size_unpacked < 1) {\n        return 0;\n      }\n      chunk_size_remaining = (*(code *)output_data[9])(input_data,output_data[7],chunk_data_offset,chunk_size_unpacked,result);\n      chunk_size_unpacked = chunk_size_unpacked - chunk_size_remaining;\n      chunk_data_offset = chunk_data_offset + chunk_size_remaining;\n    } while (0 < chunk_size_remaining);\n    *(ushort *)(output_data + 3) = chunk_flags | 0x40;\n    return 0xffffffff;\n  }\n  *(ushort *)(output_data + 3) = chunk_flags | 0x800;\n  if ((output_data[1] < 1) && (output_data[0xf] < 1)) {\n    return 0;\n  }\n  unpack_func_ptr = (code *)output_data[10];\n  if (unpack_func_ptr == (code *)0x0) {\n    return 0;\n  }\n  chunk_size_packed = (uint)(chunk_flags | 0x800);\n  input_data_size = *input_data;\n  *input_data = 0;\n  if ((chunk_flags & 0x1000) == 0) {\n    chunk_size_remaining = (*unpack_func_ptr)(input_data,output_data[7],chunk_size_packed & 0x1000,1);\n    if ((chunk_size_remaining == -1) && (chunk_size_unpacked = *input_data, chunk_size_unpacked != 0)) {\n      if ((chunk_size_unpacked == 0x1d) || (chunk_size_unpacked == 0x16)) {\n        *input_data = input_data_size;\n        return 0;\n      }\n      goto LAB_00083a54;\n    }\n    chunk_flags = *(ushort *)(output_data + 3);\n    unpack_func_ptr = (code *)output_data[10];\n  }\n  else {\n    chunk_size_remaining = output_data[0x14];\n  }\n  if (((int)(chunk_size_packed << 0x1d) < 0) && (chunk_size_remaining = chunk_size_remaining - output_data[1], output_data[0xc] != 0)) {\n    chunk_size_remaining = chunk_size_remaining - output_data[0xf];\n  }\n  chunk_size_remaining = (*unpack_func_ptr)(input_data,output_data[7],chunk_size_remaining,0);\n  if (chunk_size_remaining == -1) {\n    chunk_size_unpacked = *input_data;\n    if (chunk_size_unpacked != 0) {\n      if ((chunk_size_unpacked != 0x1d) && (chunk_size_unpacked != 0x16)) {\n        *(ushort *)(output_data + 3) = chunk_flags | 0x40;\n        return 0xffffffff;\n      }\n      *(ushort *)(output_data + 3) = chunk_flags & 0xf7ff;\n      *output_data = output_data[4];\n      output_data[1] = 0;\n      goto LAB_00083a00;\n    }\n    chunk_flags = *(ushort *)(output_data + 3) & 0xf7ff;\n    output_data[1] = 0;\n    *(ushort *)(output_data + 3) = chunk_flags;\n    *output_data = output_data[4];\n  }\n  else {\n    chunk_flags = *(ushort *)(output_data + 3) & 0xf7ff;\n    *output_data = output_data[4];\n    *(ushort *)(output_data + 3) = chunk_flags;\n    output_data[1] = 0;\n  }\n  if ((int)((uint)chunk_flags << 0x13) < 0) {\n    output_data[0x14] = chunk_size_remaining;\n  }\nLAB_00083a00:\n  chunk_data_ptr = (int *)output_data[0xc];\n  *input_data = input_data_size;\n  if (chunk_data_ptr == (int *)0x0) {\n    return 0;\n  }\n  if (chunk_data_ptr != output_data + 0x10) {\n    allocate_memory_block(input_data);\n  }\n  output_data[0xc] = 0;\n  return 0;\n}",
            "called": [
                "FUN_00083b14",
                "FUN_00083d9c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00083adc",
            "calling": [
                "FUN_000844c4",
                "FUN_0008378c",
                "FUN_00083f34",
                "FUN_000846a4"
            ],
            "imported": false,
            "current_name": "process_data_00083adc"
        },
        "FUN_000825b0": {
            "renaming": {
                "FUN_000825b0": "allocate_or_extend_memory_block_000825b0",
                "param_1": "memory_manager",
                "param_2": "memory_block",
                "param_3": "requested_size",
                "iVar1": "current_block",
                "piVar2": "new_block",
                "iVar4": "memory_manager_state",
                "uVar3": "remaining_size",
                "uVar5": "block_size",
                "piVar6": "source",
                "uVar7": "source_size",
                "piVar9": "result_block",
                "uVar8": "aligned_size",
                "iVar10": "next_block",
                "do_nothing_00082598": "do_nothing",
                "do_nothing_0008259c": "notify_memory_manager",
                "improved_function_00081e14": "allocate_initial_memory_block",
                "reverse_copy_00082438": "reverse_copy",
                "allocate_memory_block_00083d9c": "allocate_memory_block"
            },
            "code": "\nint * allocate_or_extend_memory_block_000825b0(undefined4 *memory_manager,int *memory_block,uint requested_size)\n\n{\n  int current_block;\n  int *new_block;\n  uint remaining_size;\n  int memory_manager_state;\n  uint block_size;\n  int *source;\n  uint source_size;\n  uint aligned_size;\n  int *result_block;\n  int next_block;\n  \n  if (memory_block == (int *)0x0) {\n    new_block = (int *)improved_function_00081e14(memory_manager,requested_size);\n    return new_block;\n  }\n  do_nothing_00082598();\n  memory_manager_state = DAT_0008296c;\n  block_size = memory_block[-1];\n  source_size = block_size & 0xfffffffc;\n  new_block = memory_block + -2;\n  if (requested_size + 0xb < 0x17) {\n    aligned_size = 0x10;\n  }\n  else {\n    aligned_size = requested_size + 0xb & 0xfffffff8;\n    if ((int)aligned_size < 0) goto LAB_0008267c;\n  }\n  if (aligned_size < requested_size) {\nLAB_0008267c:\n    *memory_manager = 0xc;\n    return (int *)0x0;\n  }\n  if ((int)source_size < (int)aligned_size) {\n    current_block = (int)new_block + source_size;\n    next_block = *(int *)(DAT_0008296c + 8);\n    if (next_block == current_block) {\n      remaining_size = *(uint *)(next_block + 4) & 0xfffffffc;\n      current_block = next_block;\n      if ((int)(aligned_size + 0x10) <= (int)(remaining_size + source_size)) {\n        *(uint *)(DAT_0008296c + 8) = (int)new_block + aligned_size;\n        *(uint *)((int)new_block + aligned_size + 4) = (remaining_size + source_size) - aligned_size | 1;\n        memory_block[-1] = aligned_size | memory_block[-1] & 1U;\n        do_nothing_0008259c(memory_manager);\n        return memory_block;\n      }\n    }\n    else if ((*(uint *)((*(uint *)(current_block + 4) & 0xfffffffe) + current_block + 4) & 1) == 0) {\n      remaining_size = *(uint *)(current_block + 4) & 0xfffffffc;\n      if ((int)aligned_size <= (int)(remaining_size + source_size)) {\n        next_block = *(int *)(current_block + 0xc);\n        memory_manager_state = *(int *)(current_block + 8);\n        *(int *)(memory_manager_state + 0xc) = next_block;\n        *(int *)(next_block + 8) = memory_manager_state;\n        source_size = remaining_size + source_size;\n        goto LAB_0008268c;\n      }\n    }\n    else {\n      remaining_size = 0;\n      current_block = 0;\n    }\n    if (-1 < (int)(block_size << 0x1f)) {\n      result_block = (int *)((int)new_block - memory_block[-2]);\n      block_size = (result_block[1] & 0xfffffffcU) + source_size;\n      if (current_block != 0) {\n        if (current_block == next_block) {\n          if ((int)(aligned_size + 0x10) <= (int)(remaining_size + block_size)) {\n            new_block = result_block + 2;\n            current_block = *new_block;\n            next_block = result_block[3];\n            source_size = source_size - 4;\n            *(int *)(current_block + 0xc) = next_block;\n            *(int *)(next_block + 8) = current_block;\n            if (source_size < 0x25) {\n              source = new_block;\n              if (0x13 < source_size) {\n                result_block[2] = *memory_block;\n                result_block[3] = memory_block[1];\n                if (source_size < 0x1c) {\n                  memory_block = memory_block + 2;\n                  source = result_block + 4;\n                }\n                else {\n                  result_block[4] = memory_block[2];\n                  result_block[5] = memory_block[3];\n                  if (source_size == 0x24) {\n                    result_block[6] = memory_block[4];\n                    source = memory_block + 5;\n                    memory_block = memory_block + 6;\n                    result_block[7] = *source;\n                    source = result_block + 8;\n                  }\n                  else {\n                    memory_block = memory_block + 4;\n                    source = result_block + 6;\n                  }\n                }\n              }\n              *source = *memory_block;\n              source[1] = memory_block[1];\n              source[2] = memory_block[2];\n            }\n            else {\n              reverse_copy_00082438(new_block,memory_block);\n            }\n            *(uint *)(memory_manager_state + 8) = (int)result_block + aligned_size;\n            *(uint *)((int)result_block + aligned_size + 4) = (remaining_size + block_size) - aligned_size | 1;\n            result_block[1] = aligned_size | result_block[1] & 1U;\n            do_nothing_0008259c(memory_manager);\n            return new_block;\n          }\n        }\n        else {\n          remaining_size = remaining_size + block_size;\n          if ((int)aligned_size <= (int)remaining_size) {\n            next_block = *(int *)(current_block + 0xc);\n            memory_manager_state = *(int *)(current_block + 8);\n            *(int *)(memory_manager_state + 0xc) = next_block;\n            *(int *)(next_block + 8) = memory_manager_state;\n            source = result_block + 2;\n            memory_manager_state = *source;\n            current_block = result_block[3];\n            block_size = source_size - 4;\n            *(int *)(memory_manager_state + 0xc) = current_block;\n            *(int *)(current_block + 8) = memory_manager_state;\n            source_size = remaining_size;\n            if (block_size < 0x25) {\n              new_block = source;\n              if (0x13 < block_size) {\n                result_block[2] = *memory_block;\n                result_block[3] = memory_block[1];\n                if (block_size < 0x1c) {\n                  memory_block = memory_block + 2;\n                  new_block = result_block + 4;\n                }\n                else {\n                  result_block[4] = memory_block[2];\n                  result_block[5] = memory_block[3];\n                  if (block_size == 0x24) {\n                    result_block[6] = memory_block[4];\n                    new_block = memory_block + 5;\n                    memory_block = memory_block + 6;\n                    result_block[7] = *new_block;\n                    new_block = result_block + 8;\n                  }\n                  else {\n                    memory_block = memory_block + 4;\n                    new_block = result_block + 6;\n                  }\n                }\n              }\n              *new_block = *memory_block;\n              new_block[1] = memory_block[1];\n              new_block[2] = memory_block[2];\n              block_size = result_block[1];\n              new_block = result_block;\n              memory_block = source;\n            }\n            else {\n              reverse_copy_00082438(source,memory_block);\n              block_size = result_block[1];\n              new_block = result_block;\n              memory_block = source;\n            }\n            goto LAB_0008268c;\n          }\n        }\n      }\n      if ((int)aligned_size <= (int)block_size) {\n        source = result_block + 2;\n        memory_manager_state = *source;\n        current_block = result_block[3];\n        remaining_size = source_size - 4;\n        *(int *)(memory_manager_state + 0xc) = current_block;\n        *(int *)(current_block + 8) = memory_manager_state;\n        source_size = block_size;\n        if (remaining_size < 0x25) {\n          new_block = source;\n          if (0x13 < remaining_size) {\n            result_block[2] = *memory_block;\n            result_block[3] = memory_block[1];\n            if (remaining_size < 0x1c) {\n              memory_block = memory_block + 2;\n              new_block = result_block + 4;\n            }\n            else {\n              result_block[4] = memory_block[2];\n              result_block[5] = memory_block[3];\n              if (remaining_size == 0x24) {\n                result_block[6] = memory_block[4];\n                new_block = memory_block + 5;\n                memory_block = memory_block + 6;\n                result_block[7] = *new_block;\n                new_block = result_block + 8;\n              }\n              else {\n                memory_block = memory_block + 4;\n                new_block = result_block + 6;\n              }\n            }\n          }\n          *new_block = *memory_block;\n          new_block[1] = memory_block[1];\n          new_block[2] = memory_block[2];\n          block_size = result_block[1];\n          new_block = result_block;\n          memory_block = source;\n        }\n        else {\n          reverse_copy_00082438(source,memory_block);\n          block_size = result_block[1];\n          new_block = result_block;\n          memory_block = source;\n        }\n        goto LAB_0008268c;\n      }\n    }\n    result_block = (int *)improved_function_00081e14(memory_manager,requested_size);\n    if (result_block == (int *)0x0) goto LAB_000826a4;\n    block_size = memory_block[-1];\n    if (result_block + -2 != (int *)((block_size & 0xfffffffe) + (int)new_block)) {\n      source_size = source_size - 4;\n      if (source_size < 0x25) {\n        new_block = memory_block;\n        source = result_block;\n        if (0x13 < source_size) {\n          *result_block = *memory_block;\n          result_block[1] = memory_block[1];\n          if (source_size < 0x1c) {\n            new_block = memory_block + 2;\n            source = result_block + 2;\n          }\n          else {\n            result_block[2] = memory_block[2];\n            result_block[3] = memory_block[3];\n            if (source_size == 0x24) {\n              result_block[4] = memory_block[4];\n              result_block[5] = memory_block[5];\n              new_block = memory_block + 6;\n              source = result_block + 6;\n            }\n            else {\n              new_block = memory_block + 4;\n              source = result_block + 4;\n            }\n          }\n        }\n        *source = *new_block;\n        source[1] = new_block[1];\n        source[2] = new_block[2];\n      }\n      else {\n        reverse_copy_00082438(result_block,memory_block);\n      }\n      allocate_memory_block_00083d9c(memory_manager,memory_block);\n      goto LAB_000826a4;\n    }\n    source_size = source_size + (result_block[-1] & 0xfffffffcU);\n  }\nLAB_0008268c:\n  remaining_size = source_size - aligned_size;\n  result_block = memory_block;\n  if (remaining_size < 0x10) {\n    new_block[1] = block_size & 1 | source_size;\n    *(uint *)((int)new_block + source_size + 4) = *(uint *)((int)new_block + source_size + 4) | 1;\n  }\n  else {\n    new_block[1] = block_size & 1 | aligned_size;\n    *(uint *)((int)new_block + aligned_size + 4) = remaining_size | 1;\n    *(uint *)((int)new_block + remaining_size + aligned_size + 4) = *(uint *)((int)new_block + remaining_size + aligned_size + 4) | 1;\n    allocate_memory_block_00083d9c(memory_manager,(int)new_block + aligned_size + 8);\n  }\nLAB_000826a4:\n  do_nothing_0008259c(memory_manager);\n  return result_block;\n}\n\n",
            "called": [
                "FUN_00082438",
                "FUN_00083d9c",
                "FUN_00082598",
                "FUN_0008259c",
                "FUN_00081e14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000825b0",
            "calling": [
                "FUN_000825a0",
                "FUN_00083f34"
            ],
            "imported": false,
            "current_name": "allocate_or_extend_memory_block_000825b0"
        },
        "FUN_000803d4": {
            "renaming": {
                "FUN_000803d4": "check_value_000803d4",
                "param_1": "input_val",
                "iVar1": "index",
                "threshold": "threshold",
                "PTR_DAT_0008040c": "PTR_DAT_0008040c",
                "*(byte *)(param_1 + 10)": "*(byte *)(input_val + 10)",
                "*(short *)(param_1 + 0x54)": "*(short *)(input_val + 0x54)"
            },
            "code": "int check_value_000803d4(int input_val) {\n    int index = 0;\n    int threshold = (int)((uint)*(byte *)(input_val + 10) << 0x18);\n    if (threshold < 0) {\n        *(short *)(input_val + 0x54) += 1;\n        return 0xfb;\n    }\n    while (index != 8) {\n        if (PTR_DAT_0008040c[index] == *(byte *)(input_val + 10)) {\n            return 0;\n        }\n        index += 1;\n    }\n    *(short *)(input_val + 0x54) += 1;\n    return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000803d4",
            "calling": [
                "FUN_0008043e"
            ],
            "imported": false,
            "current_name": "check_value_000803d4"
        },
        "FUN_0008043e": {
            "renaming": {
                "FUN_0008043e": "check_data_0008043e",
                "param_1": "data",
                "cVar1": "result",
                "uVar2": "ret_value",
                "piVar3": "value_ptr",
                "iVar4": "value_check",
                "unaff_r6": "value",
                "get_value_from_pointer_thunk_00081714": "get_value_from_pointer",
                "process_data_000801b0": "process_data",
                "check_value_000803d4": "check_value",
                "process_values_00080410": "process_values"
            },
            "code": "int check_data_0008043e(int **data)\n{\n  char result = 0;\n  uint8_t data_size = *(uint8_t *)((int)data + 5);\n  uint8_t value = 0;\n  int *value_ptr = (int *)get_value_from_pointer_thunk_00081714();\n  if (data_size < 4) {\n    uint8_t ret_value = (**(code **)(**data + 8))() & 0xff;\n    value = ret_value;\n  }\n  if (data[0x17] < value_ptr) {\n    *(uint8_t *)(data + 2) = 0xff;\n    *(uint8_t *)((int)data + 7) = 0;\n    *(uint16_t *)(data + 0x15) += 1;\n  }\n  else if (7 < value) {\n    process_data(data);\n    int value_check = check_value(data);\n    if (value_check == 0) {\n      if (*(uint8_t *)((int)data + 10) - 3 < 2) {\n        process_values(data);\n      }\n      *(uint8_t *)((int)data + 7) = 0;\n      result = *(char *)((int)data + 0x49);\n    }\n    else {\n      *(uint8_t *)((int)data + 7) = 0;\n      result = (char)value_check;\n    }\n  }\n  return (int)result;\n}",
            "called": [
                "FUN_000801b0",
                "FUN_000803d4",
                "thunk_FUN_00081714",
                "FUN_00080410"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008043e",
            "calling": [
                "FUN_000805d0"
            ],
            "imported": false,
            "current_name": "check_data_0008043e"
        },
        "FUN_0008160c": {
            "renaming": {
                "FUN_0008160c": "reset_memory_0008160c",
                "param_1": "memory",
                "*param_1": "*memory",
                "allocate_memory_block_00081e04": "allocate_memory_block"
            },
            "code": "void reset_memory_0008160c(int *memory){\n  if (*memory != 0) {\n    allocate_memory_block();\n  }\n  *memory = 0;\n  memory[2] = 0;\n  memory[1] = 0;\n  return;\n}",
            "called": [
                "FUN_00081e04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008160c",
            "calling": [
                "FUN_0008165c"
            ],
            "imported": false,
            "current_name": "reset_memory_0008160c"
        },
        "FUN_00080e18": {
            "renaming": {
                "FUN_00080e18": "check_and_set_bit_00080e18",
                "param_1": "bit_position",
                "uVar1": "bit_mask"
            },
            "code": "int check_and_set_bit_00080e18(uint8_t bit_position) {\n  uint32_t bit_mask;\n  if (bit_position < 45) {\n    if (bit_position < 32) {\n      bit_mask = 1 << bit_position;\n      if ((bit_mask & *(uint32_t *)(DAT_00080e58 + 0x18)) != bit_mask) {\n        *(uint32_t *)(DAT_00080e58 + 0x10) = bit_mask;\n      }\n    }\n    else {\n      bit_mask = 1 << (bit_position - 32);\n      if ((bit_mask & *(uint32_t *)(DAT_00080e58 + 0x108)) != bit_mask) {\n        *(uint32_t *)(DAT_00080e58 + 0x100) = bit_mask;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080e18",
            "calling": [
                "FUN_00080ae4",
                "FUN_00081210",
                "FUN_00081508"
            ],
            "imported": false,
            "current_name": "check_and_set_bit_00080e18"
        },
        "FUN_00081184": {
            "renaming": {
                "FUN_00081184": "get_default_value_00081184"
            },
            "code": "int get_default_value_00081184(void) {\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081184",
            "calling": [],
            "imported": false,
            "current_name": "get_default_value_00081184"
        },
        "FUN_00084298": {
            "renaming": {
                "FUN_00084298": "get_first_value_00084298",
                "*DAT_000842a0": "first_value_ptr"
            },
            "code": "int get_first_value_00084298() {\n    return **DAT_000842a0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00084298",
            "calling": [
                "FUN_00083c40"
            ],
            "imported": false,
            "current_name": "get_first_value_00084298"
        },
        "FUN_00081066": {
            "renaming": {
                "FUN_00081066": "setParamToMaxValue_00081066",
                "param_1": "parameter"
            },
            "code": "void setParamToMaxValue_00081066(int parameter)\n{\n  *(undefined4 *)(parameter + 0x14) = 0xffff;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081066",
            "calling": [
                "FUN_00080ae4"
            ],
            "imported": false,
            "current_name": "setParamToMaxValue_00081066"
        },
        "FUN_00081cd0": {
            "renaming": {
                "FUN_00081cd0": "convert_to_signed_int_00081cd0",
                "param_1": "unsigned_int_value",
                "uVar1": "shift_amount",
                "uVar2": "shifted_value",
                "result": "result"
            },
            "code": "uint convert_to_signed_int_00081cd0(uint unsigned_int_value)\n{\n  uint shift_amount;\n  uint shifted_value;\n  uint result;\n  if (unsigned_int_value << 1 < 0x7f000000) {\n    return 0;\n  }\n  shift_amount = (unsigned_int_value << 1) >> 0x18;\n  shifted_value = param_1 << 8 | 0x80000000;\n  if (shift_amount < 0x9f && (0x9e - shift_amount) != 0) {\n    result = shifted_value >> (0x9e - shift_amount & 0xff);\n    if ((unsigned_int_value & 0x80000000) != 0) {\n      result = -result;\n    }\n    return result;\n  }\n  if ((0x9e - shift_amount == 0xffffff9f) && ((unsigned_int_value & 0x7fffff) != 0)) {\n    return 0;\n  }\n  result = unsigned_int_value & 0x80000000;\n  if (result == 0) {\n    result = 0x7fffffff;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081cd0",
            "calling": [
                "FUN_000805d0"
            ],
            "imported": false,
            "current_name": "convert_to_signed_int_00081cd0"
        },
        "FUN_00081df4": {
            "renaming": {
                "FUN_00081df4": "execute_function_with_data_00081df4",
                "param_1": "arg1",
                "FUN_00081e14": "call_function",
                "*DAT_00081e00": "data_pointer"
            },
            "code": "void execute_function_with_data_00081df4(int* *DAT_00081e00, int arg1)\n{\n  call_function(**DAT_00081e00, arg1);\n  return;\n}",
            "called": [
                "FUN_00081e14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081df4",
            "calling": [
                "FUN_00083974"
            ],
            "imported": false,
            "current_name": "execute_function_with_data_00081df4"
        },
        "FUN_00080410": {
            "renaming": {
                "FUN_00080410": "process_values_00080410",
                "param_1": "array_address",
                "param_2": "unused_param1",
                "param_3": "unused_param2",
                "param_4": "unused_param3",
                "uVar1": "combined_value",
                "iVar2": "value_address",
                "bVar3": "index",
                "uVar4": "index_as_uint",
                "iVar5": "array_ptr"
            },
            "code": "void process_values_00080410(int array_address, uint16_t unused_param1, uint16_t unused_param2, uint16_t unused_param3)\n{\n  uint8_t index = 0;\n  while(true)\n  {\n    if (*(uint8_t *)(array_address + 0xb) >> 1 <= index)\n    {\n      break;\n    }\n    uint16_t combined_value = combine_values(*(uint8_t *)(array_address + index * 2 + 3 + 9), *(uint8_t *)(array_address + index * 2 + 3 + 10), array_address + index * 2 + 3, *(uint8_t *)(array_address + 0xb), unused_param3);\n    *(uint16_t *)(*(int *)(array_address + 0x4c) + index * 2) = combined_value;\n    index++;\n  }\n}",
            "called": [
                "FUN_000815f8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080410",
            "calling": [
                "FUN_0008043e"
            ],
            "imported": false,
            "current_name": "process_values_00080410"
        },
        "FUN_00080da0": {
            "renaming": {
                "FUN_00080da0": "process_data_00080da0",
                "param_1": "data",
                "param_2": "data_type",
                "param_3": "data_size",
                "param_4": "flags",
                "bVar1": "is_negative_flag"
            },
            "code": "int process_data_00080da0(int data, int data_type, int data_size, uint32_t flags) {\n  bool is_negative_flag = (int)(flags << 0x1f) < 0;\n  switch(data_type) {\n    case 1:\n    case 2:\n      (*data_processor)(data, data_type, data_size);\n      *(int *)(data + 0x44) = data_size;\n      if (is_negative_flag) {\n        *(int *)(data + 100) = data_size;\n      }\n      if (!is_negative_flag) {\n        *(int *)(data + 0x60) = data_size;\n      }\n      break;\n    case 3:\n      (*data_processor)(data, data_size, flags, data_processor, data);\n      break;\n    case 4:\n    case 5:\n      (*data_processor)(data, data_size, data_type == 5, (flags << 0x1d) >> 0x1f, flags & 1, data_type, data_size);\n      break;\n    default:\n      return 0;\n  }\n  return 1;\n}",
            "called": [
                "FUN_00080d54",
                "FUN_00080d2e",
                "FUN_00080d7a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080da0",
            "calling": [
                "FUN_00080ae4",
                "FUN_00081210"
            ],
            "imported": false,
            "current_name": "process_data_00080da0"
        },
        "FUN_00080258": {
            "renaming": {
                "FUN_00080258": "calculate_checksum_and_process_data_00080258",
                "param_1": "data",
                "param_2": "data_len",
                "param_3": "checksum_start",
                "param_4": "checksum_end",
                "bVar1": "checksum_index",
                "uVar2": "calculated_checksum",
                "iVar3": "result",
                "uVar4": "checksum_value"
            },
            "code": "void calculate_checksum_and_process_data_00080258(int** data, int data_len, int checksum_start, int checksum_end)\n{\n    byte checksum_index = *(byte*)((int)data + checksum_start);\n    uint checksum_value = (uint)checksum_index;\n    uint calculated_checksum = calculate_checksum_0008021c(data, checksum_value, data_len, checksum_end, checksum_end);\n    *(char*)((int)data + checksum_value + 9) = (char)((ushort)calculated_checksum >> 8);\n    *(char*)((int)data + (checksum_value + 1 & 0xff) + 9) = (char)calculated_checksum;\n    *(byte*)((int)data + checksum_start) = checksum_index + 2;\n\n    if (data[0][5] < 4)\n    {\n        (**(code **)(**data + 4))(*data, (int)data + 9, *(undefined*)((int)data + 0x49));\n    }\n\n    if (data[0][6] > 1)\n    {\n        process_data_00081318(data[0][6], 1);\n    }\n\n    if (data[0][5] < 4)\n    {\n        do\n        {\n            int result = (**(code **)(**data + 0xc))();\n        } while (result >= 0);\n    }\n\n    *(undefined*)((int)data + checksum_start) = 0;\n    int thunk_value = get_value_from_pointer_thunk_00081714();\n    data[0][23] = (int*)(thunk_value + (uint)*(ushort*)((int)data + 0x56));\n    *(short*)((int)data + 0x52) = *(short*)((int)data + 0x52) + 1;\n}",
            "called": [
                "FUN_00081318",
                "thunk_FUN_00081714",
                "FUN_0008021c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080258",
            "calling": [
                "FUN_000802da"
            ],
            "imported": false,
            "current_name": "calculate_checksum_and_process_data_00080258"
        },
        "FUN_00081622": {
            "renaming": {
                "FUN_00081622": "execute_function_00081622",
                "param_1": "data_pointer",
                "param_2": "size",
                "param_3": "arg_1",
                "param_4": "arg_2",
                "iVar1": "result"
            },
            "code": "int execute_function_00081622(int *data_pointer, int size, undefined4 arg_1, undefined4 arg_2){\n  int result = execute_function_00081622_with_data_pointer_000825a0(*data_pointer, size + 1, arg_1, arg_2, arg_2);\n  if (result != 0) {\n    *data_pointer = result;\n    data_pointer[1] = size;\n    result = 1;\n  }\n  return result;\n}",
            "called": [
                "FUN_000825a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081622",
            "calling": [
                "FUN_0008163a"
            ],
            "imported": false,
            "current_name": "execute_function_00081622"
        },
        "FUN_00082438": {
            "renaming": {
                "FUN_00082438": "reverse_copy_00082438",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "len",
                "iVar1": "i",
                "puVar2": "dest_ptr",
                "puVar3": "src_ptr",
                "puVar4": "end",
                "uVar5": "remaining_bytes",
                "puVar6": "ptr"
            },
            "code": "void reverse_copy_00082438(uint32_t* dest, uint32_t* src, uint32_t len) {\n    if (src < dest && src + len > dest) {\n        uint8_t* dest_ptr = (uint8_t*)dest + len;\n        uint8_t* src_ptr = (uint8_t*)src + len;\n        while (len--) {\n            *(--dest_ptr) = *(--src_ptr);\n        }\n    } else if (len >= 16 && ((uintptr_t)src & 3) == ((uintptr_t)dest & 3)) {\n        uint32_t* dest_ptr = dest;\n        uint32_t* src_ptr = src;\n        uint32_t* end = (uint32_t*)((uintptr_t)dest + (len & ~15));\n        do {\n            dest_ptr[0] = src_ptr[0];\n            dest_ptr[1] = src_ptr[1];\n            dest_ptr[2] = src_ptr[2];\n            dest_ptr[3] = src_ptr[3];\n            dest_ptr += 4;\n            src_ptr += 4;\n        } while (dest_ptr != end);\n        len &= 15;\n        src = (uint32_t*)src_ptr;\n        dest = (uint32_t*)dest_ptr;\n    }\n    uint8_t* dest_ptr = (uint8_t*)dest;\n    uint8_t* src_ptr = (uint8_t*)src;\n    while (len--) {\n        *(dest_ptr++) = *(src_ptr++);\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00082438",
            "calling": [
                "FUN_000825b0",
                "FUN_00083f34"
            ],
            "imported": false,
            "current_name": "reverse_copy_00082438"
        },
        "FUN_00081508": {
            "renaming": {
                "FUN_00081508": "initialize_device_00081508",
                "param_1": "device_id",
                "param_2": "divisor",
                "param_3": "flags",
                "puVar1": "bit_array",
                "iVar2": "device_info_address",
                "puVar3": "device_info"
            },
            "code": "void initialize_device_00081508(int device_id, uint32_t divisor, uint32_t flags)\n{\n  uint32_t *bit_array;\n  int device_info_address;\n  uint32_t *device_info;\n  \n  check_and_set_bit(DEVICE_STATUS_BIT, &(device_info[DEVICE_INFO_BIT_ARRAY_OFFSET]));\n  device_info = *(uint32_t **)(device_id + DEVICE_INFO_OFFSET);\n  device_info[DEVICE_INFO_DIVISOR_OFFSET] = 0x202;\n  device_info[DEVICE_INFO_FLAGS_OFFSET] = 0xac;\n  bit_array = DEVICE_BIT_ARRAY;\n  device_info[DEVICE_INFO_BIT_ARRAY_INDEX_OFFSET] = flags * (*bit_array / divisor) >> 4;\n  device_info[DEVICE_INFO_REGISTER_1_OFFSET] = 0xffffffff;\n  device_info[DEVICE_INFO_REGISTER_2_OFFSET] = 0x61;\n  bit_array[(uint32_t)(*(char *)(device_id + DEVICE_ID_OFFSET + 0x1c)) >> 5] = 1 << (uint32_t)(*(char *)(device_id + DEVICE_ID_OFFSET + 0x1c) & 0x1f);\n  device_info_address = *(int *)(device_id + DEVICE_INFO_ADDRESS_OFFSET);\n  *(uint32_t *)(device_info_address + DEVICE_INFO_REGISTER_3_OFFSET) = 0;\n  *(uint32_t *)(device_info_address + DEVICE_INFO_REGISTER_4_OFFSET) = 0;\n  device_info_address = *(int *)(device_id + DEVICE_INFO_ADDRESS_OFFSET + 4);\n  *(uint32_t *)(device_info_address + DEVICE_INFO_REGISTER_3_OFFSET) = 0;\n  *(uint32_t *)(device_info_address + DEVICE_INFO_REGISTER_4_OFFSET) = 0;\n  device_info[DEVICE_INFO_COMMAND_OFFSET] = 0x50;\n  return;\n}",
            "called": [
                "FUN_00080e18"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00081508",
            "calling": [],
            "imported": false,
            "current_name": "initialize_device_00081508"
        },
        "FUN_00083808": {
            "renaming": {
                "FUN_00083808": "check_and_update_00083808",
                "*param_1": "*status",
                "*param_2": "*params",
                "uVar1": "status_bit",
                "iVar2": "result",
                "uVar3": "status_int_value",
                "uVar4": "status_value"
            },
            "code": "int check_and_update_00083808(uint16_t *status, int *params) {\n    uint16_t status_value = *(uint16_t *)(params + 3);\n    uint32_t status_int_value = (uint32_t)status_value;\n    int result = 0;\n    if ((*global_pointer != 0) && (*(int *)(*global_pointer + 0x38) == 0)) {\n        initialize_memory_block();\n    }\n    if ((int)(status_int_value << 0x1c) < 0) {\n        result = params[4];\n    }\n    else {\n        if (-1 < (int)(status_int_value << 0x1b)) {\n            *status = 9;\n            *(uint16_t *)(params + 3) = status_value | 0x40;\n            return -1;\n        }\n        if ((int)(status_int_value << 0x1d) < 0) {\n            if ((int *)params[0xc] != (int *)0x0) {\n                if ((int *)params[0xc] != params + 0x10) {\n                    allocate_memory_block(&result);\n                    status_value = *(uint16_t *)(params + 3);\n                }\n                params[0xc] = 0;\n            }\n            result = params[4];\n            status_value = status_value & 0xffdb;\n            *params = result;\n            params[1] = 0;\n        }\n        else {\n            result = params[4];\n        }\n        *(uint16_t *)(params + 3) = status_value | 8;\n        status_int_value = (uint32_t)(status_value | 8);\n    }\n    if ((result == 0) && ((status_int_value & 0x280) != 0x200)) {\n        check_memory_block(status, params);\n        status_int_value = (uint32_t)*(uint16_t *)(params + 3);\n        result = params[4];\n    }\n    uint32_t status_bit = status_int_value & 1;\n    if (status_bit == 0) {\n        if (-1 < (int)(status_int_value << 0x1e)) {\n            status_bit = params[5];\n        }\n        params[2] = status_bit;\n    }\n    else {\n        params[6] = -params[5];\n        params[2] = 0;\n    }\n    if ((result == 0) && ((int)(status_int_value << 0x18) < 0)) {\n        *(uint16_t *)(params + 3) = *(uint16_t *)(params + 3) | 0x40;\n        return -1;\n    }\n    return 0;\n}",
            "called": [
                "FUN_000842a4",
                "FUN_00083b14",
                "FUN_00083d9c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00083808",
            "calling": [
                "FUN_000844c4",
                "FUN_00082b38",
                "FUN_00083f34"
            ],
            "imported": false,
            "current_name": "check_and_update_00083808"
        },
        "FUN_000847e0": {
            "renaming": {
                "FUN_000847e0": "div_with_remainder_000847e0",
                "param_1": "dividend_low",
                "param_2": "dividend_high",
                "param_3": "divisor_low",
                "param_4": "divisor_high",
                "lVar1": "product",
                "uVar2": "quotient_low",
                "uVar3": "quotient_high",
                "uVar4": "divisor_low_shifted",
                "uVar5": "leading_zeroes",
                "uVar6": "partial_product_low",
                "uVar7": "partial_product_high",
                "uVar8": "partial_quotient",
                "uVar9": "is_dividend_negative",
                "uVar10": "remainder_low",
                "uVar11": "partial_product_low2",
                "uVar12": "divisor_low_mask",
                "bVar13": "is_borrow"
            },
            "code": "\nundefined8 div_with_remainder_000847e0(uint dividend_low,uint dividend_high,uint divisor_low,uint divisor_high)\n\n{\n  longlong product;\n  uint quotient_low;\n  uint quotient_high;\n  uint divisor_low_shifted;\n  uint leading_zeroes;\n  uint partial_product_low;\n  uint partial_product_high;\n  uint partial_quotient;\n  uint is_dividend_negative;\n  uint remainder_low;\n  uint partial_product_low2;\n  uint divisor_low_mask;\n  bool is_borrow;\n  \n  if ((int)dividend_high < 0) {\n    is_borrow = dividend_low != 0;\n    dividend_low = -dividend_low;\n    dividend_high = -dividend_high - (uint)is_borrow;\n    is_dividend_negative = 0xffffffff;\n  }\n  else {\n    is_dividend_negative = 0;\n  }\n  if ((int)divisor_high < 0) {\n    is_dividend_negative = ~is_dividend_negative;\n    is_borrow = divisor_low != 0;\n    divisor_low = -divisor_low;\n    divisor_high = -divisor_high - (uint)is_borrow;\n  }\n  if (divisor_high == 0) {\n    if (dividend_high < divisor_low) {\n      leading_zeroes = count_leading_zeroes(divisor_low);\n      if (leading_zeroes != 0) {\n        quotient_low = dividend_low >> (0x20 - leading_zeroes & 0xff);\n        divisor_low = divisor_low << (leading_zeroes & 0xff);\n        dividend_low = dividend_low << (leading_zeroes & 0xff);\n        dividend_high = dividend_high << (leading_zeroes & 0xff) | quotient_low;\n      }\n      quotient_low = divisor_low >> 0x10;\n      quotient_high = dividend_high / quotient_low;\n      partial_product_low = (divisor_low & 0xffff) * quotient_high;\n      remainder_low = dividend_low >> 0x10 | (dividend_high - quotient_low * quotient_high) * 0x10000;\n      leading_zeroes = quotient_high;\n      if (remainder_low <= partial_product_low && partial_product_low - remainder_low != 0) {\n        is_borrow = CARRY4(remainder_low,divisor_low);\n        remainder_low = remainder_low + divisor_low;\n        leading_zeroes = quotient_high - 1;\n        if ((is_borrow == false) && (remainder_low <= partial_product_low && partial_product_low - remainder_low != 0)) {\n          leading_zeroes = quotient_high - 2;\n          remainder_low = remainder_low + divisor_low;\n        }\n      }\n      partial_product_high = (remainder_low - partial_product_low) / quotient_low;\n      quotient_high = (divisor_low & 0xffff) * partial_product_high;\n      partial_product_low = dividend_low & 0xffff | ((remainder_low - partial_product_low) - quotient_low * partial_product_high) * 0x10000;\n      quotient_low = partial_product_high;\n      if (partial_product_low <= quotient_high && quotient_high - partial_product_low != 0) {\n        quotient_low = partial_product_high - 1;\n        if ((CARRY4(partial_product_low,divisor_low) == false) &&\n           (partial_product_low + divisor_low <= quotient_high && quotient_high - (partial_product_low + divisor_low) != 0)) {\n          quotient_low = partial_product_high - 2;\n        }\n      }\n      quotient_high = quotient_low | leading_zeroes << 0x10;\n      remainder_low = 0;\n    }\n    else {\n      if (divisor_low == 0) {\n        divisor_low = 1 / 0;\n      }\n      leading_zeroes = count_leading_zeroes(divisor_low);\n      if (leading_zeroes == 0) {\n        dividend_high = dividend_high - divisor_low;\n        quotient_low = divisor_low >> 0x10;\n        divisor_low_mask = divisor_low & 0xffff;\n        remainder_low = 1;\n      }\n      else {\n        divisor_low = divisor_low << (leading_zeroes & 0xff);\n        quotient_high = dividend_high >> (0x20 - leading_zeroes & 0xff);\n        quotient_low = divisor_low >> 0x10;\n        remainder_low = quotient_high / quotient_low;\n        divisor_low_mask = divisor_low & 0xffff;\n        partial_product_low = divisor_low_mask * remainder_low;\n        partial_product_high = dividend_low >> (0x20 - leading_zeroes & 0xff) | dividend_high << (leading_zeroes & 0xff);\n        quotient_high = partial_product_high >> 0x10 | (quotient_high - quotient_low * remainder_low) * 0x10000;\n        dividend_low = dividend_low << (leading_zeroes & 0xff);\n        leading_zeroes = remainder_low;\n        if (quotient_high <= partial_product_low && partial_product_low - quotient_high != 0) {\n          is_borrow = CARRY4(quotient_high,divisor_low);\n          quotient_high = quotient_high + divisor_low;\n          leading_zeroes = remainder_low - 1;\n          if ((is_borrow == false) && (quotient_high <= partial_product_low && partial_product_low - quotient_high != 0)) {\n            leading_zeroes = remainder_low - 2;\n            quotient_high = quotient_high + divisor_low;\n          }\n        }\n        partial_quotient = (quotient_high - partial_product_low) / quotient_low;\n        divisor_low_shifted = divisor_low_mask * partial_quotient;\n        dividend_high = partial_product_high & 0xffff | ((quotient_high - partial_product_low) - quotient_low * partial_quotient) * 0x10000;\n        remainder_low = partial_quotient;\n        if (dividend_high <= divisor_low_shifted && divisor_low_shifted - dividend_high != 0) {\n          is_borrow = CARRY4(dividend_high,divisor_low);\n          dividend_high = dividend_high + divisor_low;\n          remainder_low = partial_quotient - 1;\n          if ((is_borrow == false) && (dividend_high <= divisor_low_shifted && divisor_low_shifted - dividend_high != 0)) {\n            remainder_low = partial_quotient - 2;\n            dividend_high = dividend_high + divisor_low;\n          }\n        }\n        dividend_high = dividend_high - divisor_low_shifted;\n        remainder_low = remainder_low | leading_zeroes << 0x10;\n      }\n      quotient_high = dividend_high / quotient_low;\n      partial_product_low = divisor_low_mask * quotient_high;\n      partial_product_high = dividend_low >> 0x10 | (dividend_high - quotient_low * quotient_high) * 0x10000;\n      leading_zeroes = quotient_high;\n      if (partial_product_high <= partial_product_low && partial_product_low - partial_product_high != 0) {\n        is_borrow = CARRY4(partial_product_high,divisor_low);\n        partial_product_high = partial_product_high + divisor_low;\n        leading_zeroes = quotient_high - 1;\n        if ((is_borrow == false) && (partial_product_high <= partial_product_low && partial_product_low - partial_product_high != 0)) {\n          leading_zeroes = quotient_high - 2;\n          partial_product_high = partial_product_high + divisor_low;\n        }\n      }\n      divisor_low_shifted = (partial_product_high - partial_product_low) / quotient_low;\n      divisor_low_mask = divisor_low_mask * divisor_low_shifted;\n      quotient_high = dividend_low & 0xffff | ((partial_product_high - partial_product_low) - quotient_low * divisor_low_shifted) * 0x10000;\n      quotient_low = divisor_low_shifted;\n      if (quotient_high <= divisor_low_mask && divisor_low_mask - quotient_high != 0) {\n        quotient_low = divisor_low_shifted - 1;\n        if ((CARRY4(quotient_high,divisor_low) == false) &&\n           (quotient_high + divisor_low <= divisor_low_mask && divisor_low_mask - (quotient_high + divisor_low) != 0)) {\n          quotient_low = divisor_low_shifted - 2;\n        }\n      }\n      quotient_high = quotient_low | leading_zeroes << 0x10;\n    }\n  }\n  else if (dividend_high < divisor_high) {\n    quotient_high = 0;\n    remainder_low = 0;\n  }\n  else {\n    leading_zeroes = count_leading_zeroes(divisor_high);\n    if (leading_zeroes == 0) {\n      if ((divisor_high < dividend_high) || (quotient_high = leading_zeroes, remainder_low = leading_zeroes, divisor_low <= dividend_low)) {\n        quotient_high = 1;\n        remainder_low = 0;\n      }\n    }\n    else {\n      quotient_low = 0x20 - leading_zeroes;\n      partial_product_low = dividend_high >> (quotient_low & 0xff);\n      divisor_low_shifted = divisor_low >> (quotient_low & 0xff) | divisor_high << (leading_zeroes & 0xff);\n      partial_product_high = divisor_low_shifted >> 0x10;\n      quotient_high = partial_product_low / partial_product_high;\n      divisor_low_mask = (divisor_low_shifted & 0xffff) * quotient_high;\n      remainder_low = dividend_high << (leading_zeroes & 0xff) | dividend_low >> (quotient_low & 0xff);\n      partial_product_low = remainder_low >> 0x10 | (partial_product_low - partial_product_high * quotient_high) * 0x10000;\n      quotient_low = quotient_high;\n      if (partial_product_low <= divisor_low_mask && divisor_low_mask - partial_product_low != 0) {\n        is_borrow = CARRY4(partial_product_low,divisor_low_shifted);\n        partial_product_low = partial_product_low + divisor_low_shifted;\n        quotient_low = quotient_high - 1;\n        if ((is_borrow == false) && (partial_product_low <= divisor_low_mask && divisor_low_mask - partial_product_low != 0)) {\n          quotient_low = quotient_high - 2;\n          partial_product_low = partial_product_low + divisor_low_shifted;\n        }\n      }\n      partial_quotient = (partial_product_low - divisor_low_mask) / partial_product_high;\n      partial_product_low2 = (divisor_low_shifted & 0xffff) * partial_quotient;\n      partial_product_low = remainder_low & 0xffff | ((partial_product_low - divisor_low_mask) - partial_product_high * partial_quotient) * 0x10000;\n      quotient_high = partial_quotient;\n      if (partial_product_low <= partial_product_low2 && partial_product_low2 - partial_product_low != 0) {\n        is_borrow = CARRY4(partial_product_low,divisor_low_shifted);\n        partial_product_low = partial_product_low + divisor_low_shifted;\n        quotient_high = partial_quotient - 1;\n        if ((is_borrow == false) && (partial_product_low <= partial_product_low2 && partial_product_low2 - partial_product_low != 0)) {\n          quotient_high = partial_quotient - 2;\n          partial_product_low = partial_product_low + divisor_low_shifted;\n        }\n      }\n      quotient_high = quotient_high | quotient_low << 0x10;\n      product = (ulonglong)quotient_high * (ulonglong)(divisor_low << (leading_zeroes & 0xff));\n      quotient_low = (uint)((ulonglong)product >> 0x20);\n      if ((partial_product_low - partial_product_low2 < quotient_low) ||\n         ((remainder_low = 0, partial_product_low - partial_product_low2 == quotient_low && (dividend_low << (leading_zeroes & 0xff) < (uint)product)))) {\n        quotient_high = quotient_high - 1;\n        remainder_low = 0;\n      }\n    }\n  }\n  if (is_dividend_negative != 0) {\n    is_borrow = quotient_high != 0;\n    quotient_high = -quotient_high;\n    remainder_low = -remainder_low - (uint)is_borrow;\n  }\n  return CONCAT44(remainder_low,quotient_high);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000847e0",
            "calling": [
                "FUN_0008477c"
            ],
            "imported": false,
            "current_name": "div_with_remainder_000847e0"
        },
        "FUN_0008105c": {
            "renaming": {
                "FUN_0008105c": "set_bit_at_position_0008105c",
                "param_1": "position",
                "param_2": "bit_mask",
                "PTR_": "ptr_to_",
                "DAT_": "data_"
            },
            "code": "void set_bit_at_position_0008105c(int position, uint32_t bit_mask) {\n    int* PTR_position = (int*)(position + 0x14);\n    int bit_to_set = 1 << (bit_mask & 0xff);\n    *PTR_position = bit_to_set;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008105c",
            "calling": [
                "FUN_00081210"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_0008105c"
        },
        "FUN_0008456c": {
            "renaming": {
                "FUN_0008456c": "process_data_0008456c",
                "param_1": "data_ptr",
                "param_2": "data_size",
                "param_3": "data_value",
                "param_4": "result_ptr",
                "uVar1": "value",
                "iVar2": "result",
                "pcVar3": "function_ptr",
                "auStack_24": "stack_data"
            },
            "code": "void process_data_0008456c(undefined4 *data_ptr, int data_size, undefined4 data_value, undefined4 *result_ptr) {\n  undefined4 value;\n  int result;\n  code *function_ptr;\n  undefined stack_data[12];\n  \n  if (data_size == 0) {\n    function_ptr = *(code **)PTR_DAT_000845b8;\n    value = get_dat_value_00084290();\n    result = (*function_ptr)(data_ptr, stack_data, 0, value, result_ptr);\n  }\n  else {\n    function_ptr = *(code **)PTR_DAT_000845b8;\n    value = get_dat_value_00084290();\n    result = (*function_ptr)(data_ptr, data_size, data_value, value, result_ptr);\n  }\n  \n  if (result == -1) {\n    *result_ptr = 0;\n    *data_ptr = 0x8a;\n  }\n  return;\n}",
            "called": [
                "FUN_000845bc",
                "FUN_00084290"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008456c",
            "calling": [
                "FUN_00083c40"
            ],
            "imported": false,
            "current_name": "process_data_0008456c"
        },
        "FUN_00080aba": {
            "renaming": {
                "FUN_00080aba": "do_nothing_00080aba"
            },
            "code": "\nvoid do_nothing_00080aba(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080aba",
            "calling": [
                "FUN_00080ce0"
            ],
            "imported": false,
            "current_name": "do_nothing_00080aba"
        },
        "FUN_00080abc": {
            "renaming": {
                "FUN_00080abc": "do_nothing_00080abc"
            },
            "code": "\nvoid do_nothing_00080abc(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080abc",
            "calling": [
                "FUN_00080ce0"
            ],
            "imported": false,
            "current_name": "do_nothing_00080abc"
        },
        "FUN_000811b4": {
            "renaming": {
                "FUN_000811b4": "set_memory_flag_000811b4",
                "param_1": "memory_address",
                "param_2": "flag",
                "*(undefined4 *)(param_2 + 4)": "*(memory_address + 1)"
            },
            "code": "void set_memory_flag_000811b4(int* memory_address, int flag) {\n  *(memory_address + 1) = flag;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000811b4",
            "calling": [
                "FUN_000846b4"
            ],
            "imported": false,
            "current_name": "set_memory_flag_000811b4"
        },
        "FUN_000816d4": {
            "renaming": {
                "FUN_000816d4": "set_default_value_of_pointer_000816d4",
                "DAT_000816dc": "data_pointer"
            },
            "code": "void set_default_value_of_pointer_000816d4(void)\n{\n  int* ptr = (int*)(DAT_000816dc + 4);\n  *ptr = 32768;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000816d4",
            "calling": [
                "FUN_000816a8"
            ],
            "imported": false,
            "current_name": "set_default_value_of_pointer_000816d4"
        },
        "FUN_00083f34": {
            "renaming": {
                "FUN_00083f34": "process_data_00083f34",
                "param_1": "output_buffer",
                "param_2": "input_buffer",
                "param_3": "remaining_bytes",
                "iVar1": "result",
                "uVar2": "bytes_to_copy",
                "uVar3": "input_buffer_flags",
                "uVar4": "bytes_remaining",
                "uVar5": "source_ptr",
                "uVar6": "dest_ptr",
                "uVar7": "temp",
                "uVar8": "bytes_copied",
                "uVar9": "buffer_size",
                "uVar10": "delimiter_pos",
                "uVar11": "bytes_to_send",
                "local_2c": "flag",
                "puVar5": "remaining_bytes_ptr",
                "puVar6": "source_buffer_ptr"
            },
            "code": "\nundefined4 process_data_00083f34(undefined4 *output_buffer,uint *input_buffer,uint **remaining_bytes)\n\n{\n  int result;\n  uint bytes_to_copy;\n  ushort input_buffer_flags;\n  uint bytes_remaining;\n  uint *remaining_bytes_ptr;\n  uint *source_buffer_ptr;\n  uint temp;\n  uint bytes_copied;\n  uint buffer_size;\n  uint delimiter_pos;\n  uint bytes_to_send;\n  uint flag;\n  \n  if (remaining_bytes[2] != (uint *)0x0) {\n    input_buffer_flags = *(ushort *)(input_buffer + 3);\n    bytes_remaining = (uint)input_buffer_flags;\n    if (((int)(bytes_remaining << 0x1c) < 0) && (input_buffer[4] != 0)) {\n      source_buffer_ptr = *remaining_bytes;\n      bytes_to_copy = DAT_00084244;\n    }\n    else {\n      result = check_and_update_00083808(output_buffer,input_buffer);\n      if (result != 0) {\n        return 0xffffffff;\n      }\n      input_buffer_flags = *(ushort *)(input_buffer + 3);\n      bytes_remaining = (uint)input_buffer_flags;\n      source_buffer_ptr = *remaining_bytes;\n      bytes_to_copy = DAT_00084244;\n    }\n    DAT_00084244 = bytes_to_copy;\n    if ((input_buffer_flags & 2) == 0) {\n      bytes_to_copy = bytes_remaining & 2;\n      bytes_copied = bytes_remaining & 1;\n      temp = bytes_to_copy;\n      delimiter_pos = bytes_to_copy;\n      flag = bytes_to_copy;\n      buffer_size = bytes_copied;\n      if (bytes_copied == 0) {\n        while( true ) {\n          while (bytes_copied == 0) {\n            buffer_size = *source_buffer_ptr;\n            remaining_bytes_ptr = source_buffer_ptr + 1;\n            source_buffer_ptr = source_buffer_ptr + 2;\n            bytes_copied = *remaining_bytes_ptr;\n          }\n          bytes_to_copy = input_buffer[2];\n          if ((int)(bytes_remaining << 0x16) < 0) {\n            if (bytes_copied < bytes_to_copy) {\n              bytes_remaining = *input_buffer;\n              bytes_to_copy = bytes_copied;\n            }\n            else if ((bytes_remaining & 0x480) == 0) {\n              bytes_remaining = *input_buffer;\n            }\n            else {\n              result = *input_buffer - input_buffer[4];\n              bytes_to_copy = result + 1 + bytes_copied;\n              temp = (int)(input_buffer[5] * 3) / 2;\n              if (bytes_to_copy <= temp) {\n                bytes_to_copy = temp;\n              }\n              if ((int)(bytes_remaining << 0x15) < 0) {\n                temp = improved_function_00081e14(output_buffer,bytes_to_copy);\n                if (temp == 0) {\n                  *output_buffer = 0xc;\n                  input_buffer_flags = *(ushort *)(input_buffer + 3);\n                  goto LAB_00084030;\n                }\n                copy_memory_block_0008234c(temp,input_buffer[4],result);\n                *(ushort *)(input_buffer + 3) = *(ushort *)(input_buffer + 3) & 0xfb7f | 0x80;\n              }\n              else {\n                temp = allocate_or_extend_memory_block_000825b0(output_buffer);\n                if (temp == 0) {\n                  allocate_memory_block_00083d9c(output_buffer,input_buffer[4]);\n                  input_buffer_flags = *(ushort *)(input_buffer + 3) & 0xff7f;\n                  *output_buffer = 0xc;\n                  goto LAB_00084030;\n                }\n              }\n              bytes_remaining = temp + result;\n              input_buffer[4] = temp;\n              input_buffer[5] = bytes_to_copy;\n              *input_buffer = bytes_remaining;\n              input_buffer[2] = bytes_to_copy - result;\n              bytes_to_copy = bytes_copied;\n            }\n            reverse_copy_00082438(bytes_remaining,buffer_size,bytes_to_copy);\n            input_buffer[2] = input_buffer[2] - bytes_to_copy;\n            *input_buffer = *input_buffer + bytes_to_copy;\n            bytes_to_copy = bytes_copied;\n          }\n          else if ((input_buffer[4] < *input_buffer) || (bytes_remaining = input_buffer[5], bytes_copied < bytes_remaining)) {\n            if (bytes_copied < bytes_to_copy) {\n              bytes_to_copy = bytes_copied;\n            }\n            reverse_copy_00082438(*input_buffer,buffer_size,bytes_to_copy);\n            bytes_remaining = input_buffer[2];\n            input_buffer[2] = bytes_remaining - bytes_to_copy;\n            *input_buffer = *input_buffer + bytes_to_copy;\n            if ((bytes_remaining - bytes_to_copy == 0) && (result = process_data_00083f34_00083adc(output_buffer,input_buffer), result != 0))\n            goto LAB_0008402e;\n          }\n          else {\n            bytes_to_copy = 0x7fffffff;\n            if (bytes_copied < 0x7fffffff) {\n              bytes_to_copy = bytes_copied;\n            }\n            bytes_to_copy = (*(code *)input_buffer[9])(output_buffer,input_buffer[7],buffer_size,(bytes_to_copy / bytes_remaining) * bytes_remaining);\n            if ((int)bytes_to_copy < 1) goto LAB_0008402e;\n          }\n          remaining_bytes_ptr = remaining_bytes[2];\n          bytes_copied = bytes_copied - bytes_to_copy;\n          remaining_bytes[2] = (uint *)((int)remaining_bytes_ptr - bytes_to_copy);\n          if ((uint *)((int)remaining_bytes_ptr - bytes_to_copy) == (uint *)0x0) break;\n          bytes_remaining = (uint)*(ushort *)(input_buffer + 3);\n          buffer_size = buffer_size + bytes_to_copy;\n        }\n      }\n      else {\n        do {\n          while (bytes_to_copy == 0) {\n            delimiter_pos = *source_buffer_ptr;\n            bytes_to_copy = source_buffer_ptr[1];\n            flag = 0;\n            source_buffer_ptr = source_buffer_ptr + 2;\n          }\n          if (flag == 0) {\n            result = find_char_in_buffer_00084384(delimiter_pos,10,bytes_to_copy);\n            if (result == 0) {\n              temp = bytes_to_copy + 1;\n              flag = 1;\n            }\n            else {\n              temp = (result + 1) - delimiter_pos;\n              flag = 1;\n            }\n          }\n          bytes_copied = *input_buffer;\n          bytes_remaining = temp;\n          if (bytes_to_copy <= temp) {\n            bytes_remaining = bytes_to_copy;\n          }\n          buffer_size = input_buffer[5];\n          if ((input_buffer[4] < bytes_copied) && (bytes_to_send = input_buffer[2] + buffer_size, (int)bytes_to_send < (int)bytes_remaining)) {\n            reverse_copy_00082438(bytes_copied,delimiter_pos,bytes_to_send);\n            *input_buffer = *input_buffer + bytes_to_send;\n            result = process_data_00083f34_00083adc(output_buffer,input_buffer);\n            if (result != 0) goto LAB_0008402e;\n          }\n          else if ((int)bytes_remaining < (int)buffer_size) {\n            reverse_copy_00082438(bytes_copied,delimiter_pos,bytes_remaining);\n            input_buffer[2] = input_buffer[2] - bytes_remaining;\n            *input_buffer = bytes_remaining + *input_buffer;\n            bytes_to_send = bytes_remaining;\n          }\n          else {\n            bytes_to_send = (*(code *)input_buffer[9])(output_buffer,input_buffer[7],delimiter_pos,buffer_size);\n            if ((int)bytes_to_send < 1) goto LAB_0008402e;\n          }\n          temp = temp - bytes_to_send;\n          if ((temp == 0) && (result = process_data_00083f34_00083adc(output_buffer,input_buffer), flag = temp, result != 0))\n          goto LAB_0008402e;\n          remaining_bytes_ptr = remaining_bytes[2];\n          delimiter_pos = delimiter_pos + bytes_to_send;\n          bytes_to_copy = bytes_to_copy - bytes_to_send;\n          remaining_bytes[2] = (uint *)((int)remaining_bytes_ptr - bytes_to_send);\n        } while ((uint *)((int)remaining_bytes_ptr - bytes_to_send) != (uint *)0x0);\n      }\n    }\n    else {\n      temp = 0;\n      bytes_remaining = 0;\n      do {\n        while( true ) {\n          delimiter_pos = bytes_remaining;\n          if (bytes_to_copy <= bytes_remaining) {\n            delimiter_pos = bytes_to_copy;\n          }\n          if (bytes_remaining != 0) break;\n          temp = *source_buffer_ptr;\n          bytes_remaining = source_buffer_ptr[1];\n          source_buffer_ptr = source_buffer_ptr + 2;\n        }\n        result = (*(code *)input_buffer[9])(output_buffer,input_buffer[7],temp,delimiter_pos);\n        if (result < 1) {\nLAB_0008402e:\n          input_buffer_flags = *(ushort *)(input_buffer + 3);\nLAB_00084030:\n          *(ushort *)(input_buffer + 3) = input_buffer_flags | 0x40;\n          return 0xffffffff;\n        }\n        remaining_bytes_ptr = remaining_bytes[2];\n        temp = temp + result;\n        bytes_remaining = bytes_remaining - result;\n        remaining_bytes[2] = (uint *)((int)remaining_bytes_ptr - result);\n      } while ((uint *)((int)remaining_bytes_ptr - result) != (uint *)0x0);\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00082438",
                "FUN_00083adc",
                "FUN_00084384",
                "FUN_00083808",
                "FUN_0008234c",
                "FUN_00083d9c",
                "FUN_000825b0",
                "FUN_00081e14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00083f34",
            "calling": [
                "FUN_00082ac0"
            ],
            "imported": false,
            "current_name": "process_data_00083f34"
        },
        "FUN_00080d7a": {
            "renaming": {
                "FUN_00080d7a": "set_values_for_array_and_pointers_00080d7a",
                "param_1": "arr",
                "param_2": "value",
                "param_3": "check1",
                "param_4": "check2",
                "param_5": "check3",
                "0x11": "17",
                "0x18": "24",
                "0x19": "25",
                "0x15": "21",
                "0x14": "20",
                "0xd": "13",
                "0xc": "12",
                "4": "4",
                "*param_1": "*arr"
            },
            "code": "void set_values_for_array_and_pointers_00080d7a(int* arr, int value, int check1, int check2, int check3) {\n  arr[17] = value;\n  if (check3 == 0) {\n    arr[24] = value;\n  }\n  else {\n    arr[25] = value;\n  }\n  if (check2 == 0) {\n    arr[21] = value;\n  }\n  else {\n    arr[20] = value;\n  }\n  if (check1 == 0) {\n    arr[13] = value;\n  }\n  else {\n    arr[12] = value;\n  }\n  arr[4] = value;\n  *arr = value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080d7a",
            "calling": [
                "FUN_00080da0",
                "FUN_00081318"
            ],
            "imported": false,
            "current_name": "set_values_for_array_and_pointers_00080d7a"
        },
        "FUN_00080e9c": {
            "renaming": {
                "FUN_00080e9c": "initialize_variables_00080e9c",
                "puVar1": "int_ptr1",
                "iVar2": "var1",
                "*(undefined4 *)(DAT_00080f0c + 0x20)": "*(int *)(DAT_00080f0c + 0x20)",
                "*(uint *)(DAT_00080f0c + 0x30)": "*int_ptr2",
                "*DAT_00080f20": "*PTR_DAT_00080f20"
            },
            "code": "void initialize_variables_00080e9c(void)\n{\n    int *int_ptr1;\n    int *(uint *)(DAT_00080f0c + 0x30);\n    int var1;\n    int var2;\n    \n    int_ptr1 = PTR_DAT_00080f08;\n    *PTR_DAT_00080f08 = 0x400;\n    int_ptr1[0x80] = 0x400;\n    \n    var1 = DAT_00080f0c;\n    if (-1 < *(undefined4 *)(DAT_00080f0c + 0x20) << 7)\n    {\n        *(undefined4 *)(DAT_00080f0c + 0x20) = DAT_00080f14;\n        while (-1 < *(int *)(var1 + 0x68) << 0x1f)\n        {\n        }\n    }\n    *(int *)(var1 + 0x20) = DAT_00080f10;\n    while (-1 < *(int *)(var1 + 0x68) << 0xf)\n    {\n    }\n    \n    int_ptr2 = (int *)(DAT_00080f0c + 0x30);\n    *(uint *)(DAT_00080f0c + 0x30) = *(uint *)(DAT_00080f0c + 0x30) & 0xfffffffc | 1;\n    while (-1 < *(int *)(var1 + 0x68) << 0x1c)\n    {\n    }\n    *(int *)(DAT_00080f0c + 0x28) = DAT_00080f18;\n    while (-1 < *(int *)(var1 + 0x68) << 0x1e)\n    {\n    }\n    \n    *(uint *)(DAT_00080f0c + 0x30) = 0x11;\n    while (-1 < *(int *)(var1 + 0x68) << 0x1c)\n    {\n    }\n    *(uint *)(DAT_00080f0c + 0x30) = 0x12;\n    while (-1 < *(int *)(var1 + 0x68) << 0x1c)\n    {\n    }\n    \n    *DAT_00080f20 = DAT_00080f1c;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00080e9c",
            "calling": [
                "FUN_00080ae4"
            ],
            "imported": false,
            "current_name": "initialize_variables_00080e9c"
        },
        "FUN_00084464": {
            "renaming": {
                "FUN_00084464": "process_data_00084464",
                "param_1": "output",
                "param_2": "input_address",
                "param_3": "default_value",
                "param_4": "default_value_length",
                "sVar1": "data_length",
                "puVar2": "destination",
                "iVar3": "result",
                "uVar4": "data_flag"
            },
            "code": "void process_data_00084464(int *output, int input_address, int default_value, int default_value_length) {\n  short data_length = *(short *)(input_address + 0xe);\n  ushort uVar4 = *(ushort *)(input_address + 0xc);\n  if ((int)((uint)uVar4 << 0x17) < 0) {\n    get_default_value(output, data_length, default_value, default_value_length);\n    uVar4 = *(ushort *)(input_address + 0xc);\n  }\n  *(ushort *)(input_address + 0xc) = uVar4 & 0xefff;\n  undefined *destination = PTR_DAT_000845fc;\n  *(undefined4 *)PTR_DAT_000845fc = 0;\n  int result = copy_data_to_destination(data_length, output, default_value, default_value_length, unaff_r4, unaff_r5, unaff_r6, in_lr);\n  if ((result == -1) && (*(int *)destination != 0)) {\n    *output = *(int *)destination;\n    return;\n  }\n  return;\n}",
            "called": [
                "FUN_000811cc",
                "FUN_00084700"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00084464",
            "calling": [],
            "imported": false,
            "current_name": "process_data_00084464"
        },
        "FUN_000811ae": {
            "renaming": {
                "FUN_000811ae": "get_error_code_000811ae"
            },
            "code": "unsigned int get_error_code_000811ae(void)\n{\n    return 0xFFFFFFFF;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000811ae",
            "calling": [],
            "imported": false,
            "current_name": "get_error_code_000811ae"
        },
        "FUN_0008118c": {
            "renaming": {
                "FUN_0008118c": "add_to_global_and_return_previous_0008118c",
                "param_1": "new_value",
                "puVar1": "global_ptr",
                "iVar2": "previous_value"
            },
            "code": "int add_to_global_and_return_previous_0008118c(int new_value)\n{\n  undefined *global_ptr;\n  int previous_value;\n  global_ptr = PTR_DAT_000811a0;\n  if (*(int *)PTR_DAT_000811a0 == 0) {\n    *(undefined4 *)PTR_DAT_000811a0 = DAT_000811a4;\n  }\n  previous_value = *(int *)global_ptr;\n  *(int *)global_ptr = new_value + previous_value;\n  return previous_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008118c",
            "calling": [
                "FUN_00082970"
            ],
            "imported": false,
            "current_name": "add_to_global_and_return_previous_0008118c"
        },
        "FUN_00082a50": {
            "renaming": {
                "FUN_00082a50": "count_bytes_with_nonzero_00082a50",
                "param_1": "input",
                "iVar1": "count",
                "puVar2": "ptr",
                "uVar3": "value",
                "bVar4": "is_byte_zero"
            },
            "code": "int count_bytes_with_nonzero_00082a50(uint input) {\n  int count = 0;\n  uint *ptr = (uint *)(input & 0xfffffffc);\n  int offset = -(input & 3);\n  uint value = *ptr;\n  if ((input & 3) != 0) {\n    value |= 0xffffffffU >> ((offset + 4U & 0x1f) << 3);\n  }\n  while (ptr++, (value + 0xfefefeff & ~value & 0x80808080) == 0) {\n    offset += 4;\n    value = *ptr;\n  }\n  bool is_byte_zero = (value & 0xff) == 0;\n  if (!is_byte_zero) {\n    offset++;\n    is_byte_zero = (value & 0xff00) == 0;\n  }\n  if (!is_byte_zero) {\n    offset++;\n    is_byte_zero = (value & 0xff0000) == 0;\n  }\n  if (!is_byte_zero) {\n    offset++;\n  }\n  return offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00082a50",
            "calling": [
                "FUN_00081682",
                "FUN_00082b38"
            ],
            "imported": false,
            "current_name": "count_bytes_with_nonzero_00082a50"
        },
        "FUN_0008106e": {
            "renaming": {
                "FUN_0008106e": "set_param_value_0008106e",
                "param_1": "param_index",
                "param_2": "param_value",
                "*(undefined4 *)(param_1 + 0x28)": "*(int *)(param_index + PARAM_OFFSET)"
            },
            "code": "void set_param_value_0008106e(int param_index, int param_value)\n{\n  *(int *)(param_index + PARAM_OFFSET) = param_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0008106e",
            "calling": [
                "FUN_00080ae4"
            ],
            "imported": false,
            "current_name": "set_param_value_0008106e"
        },
        "FUN_000811c2": {
            "renaming": {
                "FUN_000811c2": "get_default_value_000811c2",
                "undefined4": "int",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int get_default_value_000811c2(void)\n{\n    int default_value = 0;\n    return default_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000811c2",
            "calling": [
                "FUN_00084700"
            ],
            "imported": false,
            "current_name": "get_default_value_000811c2"
        },
        "FUN_000811c6": {
            "renaming": {
                "FUN_000811c6": "returnZero_000811c6"
            },
            "code": "int returnZero_000811c6(void)\n{\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000811c6",
            "calling": [
                "FUN_00084728"
            ],
            "imported": false,
            "current_name": "returnZero_000811c6"
        },
        "FUN_00083d00": {
            "renaming": {
                "FUN_00083d00": "allocate_memory_block_00083d00",
                "param_1": "address",
                "param_2": "size",
                "iVar1": "data_section",
                "puVar2": "ptr_data_section",
                "iVar3": "old_block_start",
                "uVar4": "aligned_size",
                "iVar5": "block_start",
                "add_to_global_00082970": "add_to_global"
            },
            "code": "int allocate_memory_block_00083d00(void* address, int size)\n{\n  int data_section = DAT_00083d90;\n  do_nothing_00082598();\n  uint32_t aligned_size = (*(uint32_t *)(*(int *)(data_section + 8) + 4) & 0xfffffffc);\n  int block_start = ((aligned_size - size) + 0xfef & 0xfffff000) - 0x1000;\n  if (0xfff < block_start) {\n    int new_block_end = add_to_global_00082970(address, 0);\n    if (new_block_end == *(int *)(data_section + 8) + aligned_size) {\n      int new_block_start = add_to_global_00082970(address, -block_start);\n      undefined *ptr_data_section = PTR_DAT_00083d94;\n      if (new_block_start != -1) {\n        int old_block_start = *(int *)PTR_DAT_00083d94;\n        *(uint32_t *)(*(int *)(data_section + 8) + 4) = aligned_size - block_start | 1;\n        *(int *)ptr_data_section = old_block_start - block_start;\n        do_nothing_0008259c(address);\n        return 1;\n      }\n      block_start = add_to_global_00082970(address, 0);\n      ptr_data_section = PTR_DAT_00083d94;\n      uint32_t new_block_size = block_start - *(int *)(data_section + 8);\n      if (0xf < (int)new_block_size) {\n        int old_block_start = *DAT_00083d98;\n        *(uint32_t *)(*(int *)(data_section + 8) + 4) = new_block_size | 1;\n        *(int *)ptr_data_section = block_start - old_block_start;\n      }\n    }\n  }\n  do_nothing_0008259c(address);\n  return 0;\n}",
            "called": [
                "FUN_00082970",
                "FUN_00082598",
                "FUN_0008259c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00083d00",
            "calling": [
                "FUN_00083d9c"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_00083d00"
        }
    },
    "used_tokens": 121914,
    "layers": [
        [
            "FUN_00081042",
            "FUN_00081d1c",
            "FUN_000847ac",
            "FUN_00080118",
            "FUN_00080f24",
            "FUN_00080e04",
            "FUN_00080f9c",
            "FUN_00081454",
            "FUN_000813e4",
            "FUN_00084290",
            "FUN_00081bf4",
            "FUN_00081d7c",
            "FUN_00081388",
            "FUN_00082994",
            "FUN_00080d2e",
            "FUN_0008189c",
            "FUN_0008234c",
            "FUN_000815f8",
            "FUN_00084384",
            "FUN_00081034",
            "thunk_FUN_00081714",
            "FUN_00081714",
            "FUN_0008477c",
            "FUN_000813c2",
            "FUN_000814e4",
            "FUN_00080d54",
            "FUN_0008021c",
            "FUN_00081d5c",
            "FUN_000811be",
            "FUN_000825a0",
            "FUN_000811cc",
            "FUN_00081894",
            "FUN_000845bc",
            "FUN_00082504",
            "FUN_000800f4",
            "FUN_000803d4",
            "FUN_00080e18",
            "FUN_00081184",
            "FUN_00084298",
            "FUN_00081066",
            "FUN_00081cd0",
            "FUN_00081df4",
            "FUN_00080da0",
            "FUN_00082438",
            "FUN_0008105c",
            "FUN_000811b4",
            "FUN_000816d4",
            "FUN_00080d7a",
            "FUN_00080e9c",
            "FUN_000811ae",
            "FUN_0008118c",
            "FUN_00082a50",
            "FUN_0008106e",
            "FUN_000811c2",
            "FUN_000811c6"
        ],
        [
            "FUN_00080ce0",
            "FUN_00083b14",
            "FUN_00081210",
            "FUN_00084728",
            "FUN_000846b4",
            "FUN_000813a8",
            "FUN_00081c5c",
            "FUN_00083974",
            "FUN_00084700",
            "FUN_00084750",
            "FUN_00082970",
            "FUN_000815d4",
            "FUN_000846dc",
            "FUN_00080410",
            "FUN_00081622",
            "FUN_00081508",
            "FUN_0008456c"
        ],
        [
            "FUN_00081c94",
            "FUN_000842a4",
            "FUN_00080c0c",
            "FUN_00081318",
            "FUN_0008449c",
            "FUN_00081c54",
            "FUN_0008163a",
            "FUN_00084464",
            "FUN_00083d00"
        ],
        [
            "FUN_00083d9c",
            "FUN_00081ca8",
            "FUN_000801b0",
            "FUN_00080ae4",
            "FUN_00080164",
            "FUN_00080258"
        ],
        [
            "FUN_000804a8",
            "FUN_000802da",
            "FUN_00081e04",
            "FUN_00083adc",
            "FUN_0008043e",
            "FUN_00083808"
        ],
        [
            "FUN_000816a8",
            "FUN_000815fe",
            "FUN_000846a4",
            "FUN_000844c4",
            "FUN_0008378c",
            "FUN_0008160c"
        ],
        [
            "FUN_00083c40",
            "FUN_0008165c"
        ],
        [
            "FUN_00082ac0",
            "FUN_00081682"
        ],
        [
            "FUN_00080a68"
        ],
        [
            "FUN_00081730",
            "FUN_00081734",
            "FUN_00081944",
            "FUN_00081714",
            "FUN_00082b38",
            "FUN_00084a80",
            "FUN_00081e14",
            "FUN_000847e0"
        ],
        [
            "FUN_000805d0",
            "FUN_000825b0"
        ],
        [
            "FUN_00083f34"
        ]
    ],
    "locked_functions": []
}