{
    "functions": {
        "setTx": {
            "renaming": {}, 
            "code": "\nvoid __thiscall HardwareSerial::setTx(HardwareSerial *this,uint32_t _tx)\n\n{\n  PinName PVar1;\n  \n  if (_tx < 0x3c) {\n    PVar1 = PTR_digitalPin_08005b50[_tx];\n  }\n  else {\n    PVar1 = NC;\n  }\n  (this->_serial).pin_tx = PVar1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005b3c", 
            "calling": [
                "HardwareSerial"
            ], 
            "imported": false, 
            "current_name": "setTx"
        }, 
        "HAL_RCC_GetSysClockFreq": {
            "renaming": {}, 
            "code": "\nuint HAL_RCC_GetSysClockFreq(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  undefined2 local_1c;\n  byte abStack_18 [4];\n  undefined4 uStack_14;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = *(undefined4 *)(PTR__etext_08003ac4 + 8);\n  uStack_10 = *(undefined4 *)(PTR__etext_08003ac4 + 4);\n  uStack_14 = *(undefined4 *)PTR__etext_08003ac4;\n  local_1c = *(undefined2 *)(PTR__etext_08003ac4 + 0x10);\n  uVar2 = *(uint *)(DAT_08003ac8 + 4);\n  uVar1 = DAT_08003ad0;\n  if ((uVar2 & 0xc) == 8) {\n    if ((uVar2 & 0x10000) == 0) {\n      uVar1 = DAT_08003acc * (uint)abStack_18[(uVar2 << 10) >> 0x1c];\n    }\n    else {\n      uVar1 = (DAT_08003ad0 * abStack_18[(uVar2 << 10) >> 0x1c]) /\n              (uint)*(byte *)((int)&local_1c - ((*(int *)(DAT_08003ac8 + 4) << 0xe) >> 0x1f));\n    }\n  }\n  return uVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003a68", 
            "calling": [
                "HAL_RCC_ClockConfig"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetSysClockFreq"
        }, 
        "HAL_NVIC_SetPriorityGrouping": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)\n\n{\n  *(uint32_t *)(DAT_08002490 + 0xc) =\n       (PriorityGroup & 7) << 8 | *(uint *)(DAT_08002490 + 0xc) & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002470", 
            "calling": [
                "premain", 
                "HAL_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_SetPriorityGrouping"
        }, 
        "I2C_SlaveTransmit_TXE": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  byte *pbVar2;\n  \n  HVar1 = hi2c->State;\n  if (hi2c->XferCount != 0) {\n    pbVar2 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = pbVar2 + 1;\n    hi2c->Instance->DR = (uint)*pbVar2;\n    hi2c->XferCount = hi2c->XferCount - 1;\n    if ((hi2c->XferCount == 0) && (HVar1 == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n      hi2c->PreviousState = 0x21;\n      hi2c->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(hi2c);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002c54", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_SlaveTransmit_TXE"
        }, 
        "set_pin_configured": {
            "renaming": {}, 
            "code": "\nvoid set_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)((int)pin << 0x18) >> 0x1c;\n  map[uVar1] = map[uVar1] | 1 << ((int)pin & 0xfU);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800480a", 
            "calling": [
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "set_pin_configured"
        }, 
        "get_pin_id": {
            "renaming": {}, 
            "code": "\nuint8_t get_pin_id(uint16_t pin)\n\n{\n  uint uVar1;\n  uint8_t uVar2;\n  \n  uVar2 = '\\0';\n  for (uVar1 = (uint)pin; uVar1 != 1; uVar1 = uVar1 >> 1) {\n    uVar2 = uVar2 + '\\x01';\n  }\n  return uVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005f8c", 
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ], 
            "imported": false, 
            "current_name": "get_pin_id"
        }, 
        "HAL_ADC_DeInit": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_ADC_DeInit(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  \n  if (hadc == (ADC_HandleTypeDef *)0x0) {\n    HVar1 = HAL_ERROR;\n  }\n  else {\n    hadc->State = hadc->State | 2;\n    HVar1 = ADC_ConversionStop_Disable(hadc);\n    if (HVar1 == HAL_OK) {\n      hadc->Instance->SR = 0xffffffe0;\n      hadc->Instance->CR1 = DAT_08002340 & hadc->Instance->CR1;\n      hadc->Instance->CR2 = DAT_08002344 & hadc->Instance->CR2;\n      hadc->Instance->SMPR1 = hadc->Instance->SMPR1 & 0xff000000;\n      hadc->Instance->SMPR2 = hadc->Instance->SMPR2 & 0xc0000000;\n      hadc->Instance->JOFR1 = hadc->Instance->JOFR1 & 0xfffff000;\n      hadc->Instance->JOFR2 = hadc->Instance->JOFR2 & 0xfffff000;\n      hadc->Instance->JOFR3 = hadc->Instance->JOFR3 & 0xfffff000;\n      hadc->Instance->JOFR4 = hadc->Instance->JOFR4 & 0xfffff000;\n      hadc->Instance->HTR = hadc->Instance->HTR & 0xfffff000;\n      hadc->Instance->LTR = hadc->Instance->LTR & 0xfffff000;\n      hadc->Instance->SQR1 = hadc->Instance->SQR1 & 0xff000000;\n      hadc->Instance->SQR1 = hadc->Instance->SQR1 & 0xff000000;\n      hadc->Instance->SQR2 = hadc->Instance->SQR2 & 0xc0000000;\n      hadc->Instance->SQR3 = hadc->Instance->SQR3 & 0xc0000000;\n      hadc->Instance->JSQR = hadc->Instance->JSQR & 0xffc00000;\n      hadc->Instance->JSQR = hadc->Instance->JSQR & 0xffc00000;\n      HAL_ADC_MspDeInit(hadc);\n      hadc->ErrorCode = 0;\n      hadc->State = 0;\n    }\n    hadc->Lock = HAL_UNLOCKED;\n  }\n  return HVar1;\n}\n\n", 
            "called": [
                "ADC_ConversionStop_Disable", 
                "HAL_ADC_MspDeInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800224c", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_DeInit"
        }, 
        "TIM_CCxNChannelCmd": {
            "renaming": {}, 
            "code": "\nvoid TIM_CCxNChannelCmd(TIM_TypeDef *TIMx,uint32_t Channel,uint32_t ChannelNState)\n\n{\n  TIMx->CCER = TIMx->CCER & ~(4 << (Channel & 0xff));\n  TIMx->CCER = TIMx->CCER | ChannelNState << (Channel & 0xff);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004110", 
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ], 
            "imported": false, 
            "current_name": "TIM_CCxNChannelCmd"
        }, 
        "pinmap_function": {
            "renaming": {}, 
            "code": "\nuint32_t pinmap_function(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  uint32_t uVar1;\n  \n  if (pin == NC) {\n    return 0xffffffff;\n  }\n  uVar1 = pinmap_find_function(pin,map);\n  return uVar1;\n}\n\n", 
            "called": [
                "pinmap_find_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004cce", 
            "calling": [
                "get_adc_channel", 
                "uart_init", 
                "pwm_stop", 
                "get_pwm_channel"
            ], 
            "imported": false, 
            "current_name": "pinmap_function"
        }, 
        "EXTI0_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI0_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006074", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI0_IRQHandler"
        }, 
        "HAL_TIMEx_BreakCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800417a", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIMEx_BreakCallback"
        }, 
        "get_i2c_obj": {
            "renaming": {}, 
            "code": "\ni2c_t * get_i2c_obj(I2C_HandleTypeDef *hi2c)\n\n{\n  return (i2c_t *)&hi2c[-1].EventCount;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004e70", 
            "calling": [
                "HAL_I2C_AddrCallback", 
                "HAL_I2C_ErrorCallback", 
                "HAL_I2C_ListenCpltCallback"
            ], 
            "imported": false, 
            "current_name": "get_i2c_obj"
        }, 
        "HAL_SYSTICK_Callback": {
            "renaming": {}, 
            "code": "\nvoid HAL_SYSTICK_Callback(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002580", 
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_Callback"
        }, 
        "frame_dummy": {
            "renaming": {}, 
            "code": "\nvoid frame_dummy(void)\n\n{\n  if (DAT_08000164 == 0) {\n    if ((*(int *)PTR__edata_08000170 != 0) && (DAT_08000174 != (code *)0x0)) {\n                    /* WARNING: Could not recover jumptable at 0x08000160. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*DAT_08000174)();\n      return;\n    }\n    return;\n  }\n  if ((*(int *)PTR__edata_08000170 != 0) && (DAT_08000174 != (code *)0x0)) {\n                    /* WARNING: Could not recover jumptable at 0x08000158. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*DAT_08000174)(PTR__edata_08000170,PTR_object_8672_0800016c);\n    return;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000130", 
            "calling": [], 
            "imported": false, 
            "current_name": "frame_dummy"
        }, 
        "__aeabi_dcmpgt": {
            "renaming": {}, 
            "code": "\nbool __aeabi_dcmpgt(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cdrcmple();\n  return in_CY == '\\0';\n}\n\n", 
            "called": [
                "__aeabi_cdrcmple"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000a18", 
            "calling": [
                "Compute", 
                "loop", 
                "printFloat", 
                "Initialize", 
                "SetOutputLimits"
            ], 
            "imported": false, 
            "current_name": "__aeabi_dcmpgt"
        }, 
        "HAL_UART_GetState": {
            "renaming": {}, 
            "code": "\nHAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)\n\n{\n  return huart->RxState | huart->gState;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080047e8", 
            "calling": [
                "serial_tx_active", 
                "serial_rx_active"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_GetState"
        }, 
        "_vfiprintf_r": {
            "renaming": {}, 
            "code": "\nint _vfiprintf_r(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  int iVar3;\n  void *pvVar4;\n  int *piVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  int unaff_r9;\n  int iVar8;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 local_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  local_8c = param_4;\n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == PTR___sf_fake_stdin_080065a0) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR___sf_fake_stdout_080065a8) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR___sf_fake_stderr_080065ac) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar8 = __swsetup_r(param_1,param_2), iVar8 != 0)) {\n    return -1;\n  }\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar6 = param_3;\nLAB_080063d6:\n  pbVar7 = pbVar6;\n  if (*pbVar7 != 0) goto LAB_0800648c;\n  goto LAB_080063e0;\nLAB_0800648c:\n  pbVar6 = pbVar7 + 1;\n  if (*pbVar7 != 0x25) goto LAB_080063d6;\nLAB_080063e0:\n  iVar8 = (int)pbVar7 - (int)param_3;\n  if (iVar8 != 0) {\n    iVar3 = __sfputs_r(param_1,param_2,param_3,iVar8);\n    if (iVar3 == -1) {\nLAB_08006580:\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar8;\n  }\n  if (*pbVar7 == 0) goto LAB_08006580;\n  local_88 = 0;\n  local_7c = 0;\n  local_84 = -1;\n  local_80 = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar6 = pbVar7 + 1;\n  while( true ) {\n    pvVar4 = memchr(PTR_s___0__080065a4,(uint)*pbVar6,5);\n    puVar2 = PTR_DAT_080065b0;\n    param_3 = pbVar6 + 1;\n    if (pvVar4 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar4 - (int)PTR_s___0__080065a4 & 0xffU) | local_88;\n    pbVar6 = param_3;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar6 == 0x2a) {\n    piVar5 = local_8c + 1;\n    iVar8 = *local_8c;\n    local_8c = piVar5;\n    if (-1 < iVar8) goto LAB_080064b0;\n    local_7c = -iVar8;\n    local_88 = local_88 | 2;\n  }\n  else {\n    bVar1 = false;\n    iVar8 = local_7c;\n    param_3 = pbVar6;\n    while( true ) {\n      if (9 < *param_3 - 0x30) break;\n      iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n      bVar1 = true;\n      param_3 = param_3 + 1;\n    }\n    if (bVar1) {\nLAB_080064b0:\n      local_7c = iVar8;\n    }\n  }\n  if (*param_3 == 0x2e) {\n    if (param_3[1] == 0x2a) {\n      param_3 = param_3 + 2;\n      piVar5 = local_8c + 1;\n      local_84 = *local_8c;\n      local_8c = piVar5;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n    }\n    else {\n      bVar1 = false;\n      iVar8 = 0;\n      local_84 = 0;\n      while( true ) {\n        param_3 = param_3 + 1;\n        if (9 < *param_3 - 0x30) break;\n        iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar8;\n      }\n    }\n  }\n  pvVar4 = memchr(PTR_DAT_080065b0,(uint)*param_3,3);\n  if (pvVar4 != (void *)0x0) {\n    param_3 = param_3 + 1;\n    local_88 = local_88 | 0x40 << ((int)pvVar4 - (int)puVar2 & 0xffU);\n  }\n  local_70 = *param_3;\n  param_3 = param_3 + 1;\n  pvVar4 = memchr(PTR_s_efgEFG_080065b4,(uint)local_70,6);\n  if (pvVar4 == (void *)0x0) {\n    iVar8 = _printf_i(param_1,&local_88,param_2,DAT_080065bc,&local_8c);\n  }\n  else {\n    iVar8 = param_1;\n    if (DAT_080065b8 == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar8 = unaff_r9;\n      goto LAB_08006532;\n    }\n  }\n  if (iVar8 == -1) goto LAB_08006580;\nLAB_08006532:\n  local_74 = local_74 + iVar8;\n  pbVar6 = param_3;\n  unaff_r9 = iVar8;\n  goto LAB_080063d6;\n}\n\n", 
            "called": [
                "memchr", 
                "_printf_i", 
                "__sfputs_r", 
                "__swsetup_r", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006394", 
            "calling": [
                "fiprintf", 
                "iprintf"
            ], 
            "imported": false, 
            "current_name": "_vfiprintf_r"
        }, 
        "readData": {
            "renaming": {}, 
            "code": "\nulong __thiscall MAX31855::readData(MAX31855 *this)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  digitalWrite((uint)this->cs,0);\n  uVar3 = 0;\n  for (uVar2 = 0x1f; -1 < (int)uVar2; uVar2 = uVar2 - 1) {\n    digitalWrite((uint)this->sck,1);\n    iVar1 = digitalRead((uint)this->so);\n    if (iVar1 != 0) {\n      uVar3 = uVar3 | 1 << (uVar2 & 0xff);\n    }\n    digitalWrite((uint)this->sck,0);\n  }\n  digitalWrite((uint)this->cs,1);\n  return uVar3;\n}\n\n", 
            "called": [
                "digitalWrite", 
                "digitalRead"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080015b2", 
            "calling": [
                "readThermocouple"
            ], 
            "imported": false, 
            "current_name": "readData"
        }, 
        "HAL_RCC_GetPCLK2Freq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCC_GetPCLK2Freq(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = HAL_RCC_GetHCLKFreq();\n  return uVar1 >> PTR_APBPrescTable_08003c8c[(uint)(*(int *)(DAT_08003c88 + 4) << 0x12) >> 0x1d];\n}\n\n", 
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003c70", 
            "calling": [
                "UART_SetConfig", 
                "HAL_RCCEx_GetPeriphCLKFreq"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetPCLK2Freq"
        }, 
        "I2C_MasterTransmit_BTF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)\n\n{\n  uint32_t uVar1;\n  byte *pbVar2;\n  \n  uVar1 = hi2c->XferOptions;\n  if (hi2c->State == HAL_I2C_STATE_BUSY_TX) {\n    if (hi2c->XferCount == 0) {\n      if (((uVar1 == 4) || (uVar1 == 8)) || (uVar1 == 0xffff0000)) {\n        hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n        hi2c->PreviousState = 0;\n        hi2c->State = HAL_I2C_STATE_READY;\n        if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n          hi2c->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(hi2c);\n        }\n        else {\n          hi2c->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(hi2c);\n        }\n      }\n      else {\n        hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n        hi2c->PreviousState = 0x11;\n        hi2c->Mode = HAL_I2C_MODE_NONE;\n        hi2c->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(hi2c);\n      }\n    }\n    else {\n      pbVar2 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = pbVar2 + 1;\n      hi2c->Instance->DR = (uint)*pbVar2;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_MemTxCpltCallback", 
                "HAL_I2C_MasterTxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002efc", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_MasterTransmit_BTF"
        }, 
        "pinmap_pin": {
            "renaming": {}, 
            "code": "\nPinName_conflict pinmap_pin(void *peripheral,PinMap_conflict *map)\n\n{\n  PinName_conflict PVar1;\n  \n  if (peripheral != (void *)0x0) {\n    PVar1 = pinmap_find_pin(peripheral,map);\n    return PVar1;\n  }\n  return NC;\n}\n\n", 
            "called": [
                "pinmap_find_pin"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004ca2", 
            "calling": [
                "uart_debug_init", 
                "HardwareSerial"
            ], 
            "imported": false, 
            "current_name": "pinmap_pin"
        }, 
        "HAL_InitTick": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_InitTick(uint32_t TickPriority)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = HAL_SYSTICK_Config((uint32_t)\n                             ((ulonglong)*(uint *)PTR_SystemCoreClock_08001c80 /\n                             (1000 / (ulonglong)(byte)*PTR_uwTickFreq_08001c7c)));\n  if (uVar1 != 0) {\n    return HAL_ERROR;\n  }\n  if (0xf < TickPriority) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,TickPriority,0);\n  *(uint32_t *)PTR_uwTickPrio_08001c84 = TickPriority;\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_SYSTICK_Config", 
                "HAL_NVIC_SetPriority"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001c3c", 
            "calling": [
                "HAL_RCC_ClockConfig", 
                "HAL_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_InitTick"
        }, 
        "timer_disable_clock": {
            "renaming": {}, 
            "code": "\nvoid timer_disable_clock(TIM_HandleTypeDef *htim)\n\n{\n  if (htim->Instance == DAT_08004de4) {\n    *(uint *)(DAT_08004df0 + 0x18) = *(uint *)(DAT_08004df0 + 0x18) & 0xfffff7ff;\n  }\n  if (htim->Instance == (TIM_TypeDef *)0x40000000) {\n    *(uint *)(DAT_08004df0 + 0x1c) = *(uint *)(DAT_08004df0 + 0x1c) & 0xfffffffe;\n  }\n  if (htim->Instance == DAT_08004de8) {\n    *(uint *)(DAT_08004df0 + 0x1c) = *(uint *)(DAT_08004df0 + 0x1c) & 0xfffffffd;\n  }\n  if (htim->Instance == DAT_08004dec) {\n    *(uint *)(DAT_08004df0 + 0x1c) = *(uint *)(DAT_08004df0 + 0x1c) & 0xfffffffb;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004d90", 
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ], 
            "imported": false, 
            "current_name": "timer_disable_clock"
        }, 
        "HAL_RCC_GetHCLKFreq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCC_GetHCLKFreq(void)\n\n{\n  return *(uint32_t *)PTR_SystemCoreClock_08003c4c;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003c44", 
            "calling": [
                "HAL_RCC_GetPCLK2Freq", 
                "SystemClock_Config", 
                "HAL_RCC_GetPCLK1Freq"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetHCLKFreq"
        }, 
        "HAL_I2C_SlaveRxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002ca4", 
            "calling": [
                "I2C_SlaveReceive_RXNE", 
                "I2C_Slave_STOPF"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_SlaveRxCpltCallback"
        }, 
        "I2C_MasterTransmit_TXE": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  byte *pbVar2;\n  uint32_t uVar3;\n  \n  HVar1 = hi2c->State;\n  uVar3 = hi2c->XferOptions;\n  if ((hi2c->XferSize == 0) && (HVar1 == HAL_I2C_STATE_BUSY_TX)) {\n    if ((uVar3 == 4) || ((uVar3 == 8 || (uVar3 == 0xffff0000)))) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n      hi2c->PreviousState = 0;\n      hi2c->State = HAL_I2C_STATE_READY;\n      if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n        hi2c->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(hi2c);\n      }\n      else {\n        hi2c->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(hi2c);\n      }\n    }\n    else {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n      hi2c->PreviousState = 0x11;\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      hi2c->State = HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(hi2c);\n    }\n  }\n  else if ((HVar1 == HAL_I2C_STATE_BUSY_TX) ||\n          ((hi2c->Mode == HAL_I2C_MODE_MEM && (HVar1 == HAL_I2C_STATE_BUSY_RX)))) {\n    if (hi2c->XferCount == 0) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n    }\n    else if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n      if (hi2c->EventCount == 0) {\n        if (hi2c->MemaddSize == 1) {\n          hi2c->Instance->DR = hi2c->Memaddress & 0xff;\n          hi2c->EventCount = hi2c->EventCount + 2;\n        }\n        else {\n          hi2c->Instance->DR = (hi2c->Memaddress << 0x10) >> 0x18;\n          hi2c->EventCount = hi2c->EventCount + 1;\n        }\n      }\n      else if (hi2c->EventCount == 1) {\n        hi2c->Instance->DR = hi2c->Memaddress & 0xff;\n        hi2c->EventCount = hi2c->EventCount + 1;\n      }\n      else if (hi2c->EventCount == 2) {\n        if (hi2c->State == HAL_I2C_STATE_BUSY_RX) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x100;\n        }\n        else if (hi2c->State == HAL_I2C_STATE_BUSY_TX) {\n          pbVar2 = hi2c->pBuffPtr;\n          hi2c->pBuffPtr = pbVar2 + 1;\n          hi2c->Instance->DR = (uint)*pbVar2;\n          hi2c->XferCount = hi2c->XferCount - 1;\n        }\n      }\n    }\n    else {\n      pbVar2 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = pbVar2 + 1;\n      hi2c->Instance->DR = (uint)*pbVar2;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_MasterTxCpltCallback", 
                "HAL_I2C_MemTxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002db2", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_MasterTransmit_TXE"
        }, 
        "startForkserver": {
            "renaming": {}, 
            "code": "\nint startForkserver(int ticks)\n\n{\n  uint32_t uVar1;\n  \n  if (*(int *)PTR_noHyperCall_08000b04 != 0) {\n    return 0;\n  }\n  uVar1 = aflCall(1,ticks,0);\n  return uVar1;\n}\n\n", 
            "called": [
                "aflCall"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000aec", 
            "calling": [
                "setup"
            ], 
            "imported": false, 
            "current_name": "startForkserver"
        }, 
        "__sinit": {
            "renaming": {}, 
            "code": "\nvoid __sinit(int param_1)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  bool bVar3;\n  \n  if (*(int *)(param_1 + 0x18) == 0) {\n    *(undefined4 *)(param_1 + 0x48) = 0;\n    *(undefined4 *)(param_1 + 0x4c) = 0;\n    *(undefined4 *)(param_1 + 0x50) = 0;\n    iVar2 = *(int *)PTR__global_impure_ptr_08006d0c;\n    *(undefined4 *)(param_1 + 0x28) = DAT_08006d10;\n    bVar3 = param_1 == iVar2;\n    if (bVar3) {\n      iVar2 = 1;\n    }\n    if (bVar3) {\n      *(int *)(param_1 + 0x18) = iVar2;\n    }\n    uVar1 = __sfp();\n    *(undefined4 *)(param_1 + 4) = uVar1;\n    uVar1 = __sfp(param_1);\n    *(undefined4 *)(param_1 + 8) = uVar1;\n    uVar1 = __sfp(param_1);\n    *(undefined4 *)(param_1 + 0xc) = uVar1;\n    std_isra_0(*(undefined4 *)(param_1 + 4),4,0);\n    std_isra_0(*(undefined4 *)(param_1 + 8),9,1);\n    std_isra_0(*(undefined4 *)(param_1 + 0xc),0x12,2);\n    *(undefined4 *)(param_1 + 0x18) = 1;\n  }\n  return;\n}\n\n", 
            "called": [
                "std.isra.0", 
                "__sfp"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006cb4", 
            "calling": [
                "_fflush_r", 
                "__swbuf_r", 
                "__sfp", 
                "__swsetup_r", 
                "iprintf", 
                "_vfiprintf_r"
            ], 
            "imported": false, 
            "current_name": "__sinit"
        }, 
        "__aeabi_f2d": {
            "renaming": {}, 
            "code": "\nulonglong __aeabi_f2d(uint param_1,undefined4 param_2,undefined4 param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint in_r12;\n  bool bVar8;\n  bool bVar9;\n  bool bVar10;\n  \n  uVar5 = param_1 << 1;\n  bVar9 = uVar5 == 0;\n  uVar1 = (uint)((param_1 & 0x80000000) != 0) << 0x1f;\n  uVar4 = (uint)((int)uVar5 >> 3) >> 1;\n  uVar3 = uVar1 | uVar4;\n  param_1 = param_1 << 0x1d;\n  if (!bVar9) {\n    param_4 = uVar5 & 0xff000000;\n    bVar9 = param_4 == 0;\n  }\n  if (!bVar9) {\n    bVar9 = param_4 == 0xff000000;\n  }\n  if (!bVar9) {\n    return CONCAT44(uVar3,param_1) ^ 0x3800000000000000;\n  }\n  if (uVar5 == 0 || param_4 == 0xff000000) {\n    return CONCAT44(uVar3,param_1);\n  }\n  uVar2 = param_1;\n  uVar5 = uVar4;\n  if (uVar4 == 0) {\n    uVar2 = 0;\n    uVar5 = param_1;\n  }\n  iVar6 = count_leading_zeroes(uVar5);\n  if (uVar4 == 0) {\n    iVar6 = iVar6 + 0x20;\n  }\n  uVar7 = iVar6 - 0xb;\n  bVar10 = SBORROW4(uVar7,0x20);\n  uVar4 = iVar6 - 0x2b;\n  bVar9 = (int)uVar4 < 0;\n  bVar8 = uVar4 == 0;\n  if ((int)uVar7 < 0x20) {\n    bVar10 = SCARRY4(uVar4,0xc);\n    iVar6 = iVar6 + -0x1f;\n    bVar9 = iVar6 < 0;\n    bVar8 = iVar6 == 0;\n    uVar4 = uVar7;\n    if (!bVar8 && bVar9 == bVar10) {\n      uVar2 = uVar5 << (uVar7 & 0xff);\n      uVar5 = uVar5 >> (0xcU - iVar6 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar8 || bVar9 != bVar10) {\n    in_r12 = 0x20 - uVar4;\n  }\n  uVar5 = uVar5 << (uVar4 & 0xff);\n  if (bVar8 || bVar9 != bVar10) {\n    uVar5 = uVar5 | uVar2 >> (in_r12 & 0xff);\n  }\n  if (bVar8 || bVar9 != bVar10) {\n    uVar2 = uVar2 << (uVar4 & 0xff);\n  }\nLAB_08000318:\n  if ((int)uVar7 < 0x381) {\n    return CONCAT44(uVar5 + (0x380 - uVar7) * 0x100000 | uVar1,uVar2);\n  }\n  uVar4 = ~(0x380 - uVar7);\n  if ((int)uVar4 < 0x1f) {\n    iVar6 = uVar4 - 0x13;\n    if (iVar6 != 0 && iVar6 < 0 == SCARRY4(uVar4 - 0x1f,0xc)) {\n      return CONCAT44(uVar3,uVar2 >> (0x20 - (0xcU - iVar6) & 0xff) | uVar5 << (0xcU - iVar6 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar4 = uVar4 + 1;\n    return CONCAT44(uVar1 | uVar5 >> (uVar4 & 0xff),\n                    uVar2 >> (uVar4 & 0xff) | uVar5 << (0x20 - uVar4 & 0xff));\n  }\n  return CONCAT44(uVar3,uVar5 >> (uVar4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000450", 
            "calling": [], 
            "imported": false, 
            "current_name": "__aeabi_f2d"
        }, 
        "delay": {
            "renaming": {}, 
            "code": "\nvoid delay(uint32_t ms)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080058e8", 
            "calling": [
                "setup"
            ], 
            "imported": false, 
            "current_name": "delay"
        }, 
        "HAL_NVIC_SetPriority": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_SetPriority(IRQn_Type_conflict IRQn,uint32_t PreemptPriority,uint32_t SubPriority)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  uVar1 = (uint)IRQn;\n  uVar2 = (uint)(*(int *)(DAT_080024f0 + 0xc) << 0x15) >> 0x1d;\n  uVar3 = 7 - uVar2;\n  if (3 < uVar3) {\n    uVar3 = 4;\n  }\n  if (uVar2 + 4 < 7) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = uVar2 - 3;\n  }\n  uVar2 = (PreemptPriority & (1 << (uVar3 & 0xff)) - 1U) << (uVar2 & 0xff) |\n          (1 << (uVar2 & 0xff)) - 1U & SubPriority;\n  if ((int)uVar1 < 0) {\n    *(char *)(DAT_080024f4 + (uVar1 & 0xf)) = (char)(uVar2 << 4);\n  }\n  else {\n    *(char *)(uVar1 + 0xe000e400) = (char)(uVar2 << 4);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002494", 
            "calling": [
                "HAL_InitTick", 
                "SystemClock_Config", 
                "uart_attach_tx_callback", 
                "uart_attach_rx_callback"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_SetPriority"
        }, 
        "GetCurrentMilli": {
            "renaming": {}, 
            "code": "\nuint32_t GetCurrentMilli(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = HAL_GetTick();\n  return uVar1;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004b94", 
            "calling": [
                "millis"
            ], 
            "imported": false, 
            "current_name": "GetCurrentMilli"
        }, 
        "UART_DMAAbortOnError": {
            "renaming": {}, 
            "code": "\nvoid UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)\n\n{\n  UART_HandleTypeDef *huart;\n  \n  huart = (UART_HandleTypeDef *)hdma->Parent;\n  huart->RxXferCount = 0;\n  huart->TxXferCount = 0;\n  HAL_UART_ErrorCallback(huart);\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_ErrorCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080047d8", 
            "calling": [], 
            "imported": false, 
            "current_name": "UART_DMAAbortOnError"
        }, 
        "_write": {
            "renaming": {}, 
            "code": "\nint _write(int file_UNUSED,char *ptr,int len)\n\n{\n  size_t sVar1;\n  \n  sVar1 = uart_debug_write((uint8_t *)ptr,len);\n  return sVar1;\n}\n\n", 
            "called": [
                "uart_debug_write"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005730", 
            "calling": [
                "_write_r"
            ], 
            "imported": false, 
            "current_name": "_write"
        }, 
        "FUN_080006d4": {
            "renaming": {}, 
            "code": "\nulonglong FUN_080006d4(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint in_r12;\n  bool bVar4;\n  \n  uVar2 = in_r12 & param_4 >> 0x14;\n  if (unaff_r4 != in_r12 && uVar2 != in_r12) {\n    bVar4 = (param_1 | param_2 << 1) == 0;\n    if (!bVar4) {\n      bVar4 = (param_3 | param_4 << 1) == 0;\n    }\n    if (bVar4) {\n      return (ulonglong)((param_2 ^ param_4) & 0x80000000) << 0x20;\n    }\n    if (unaff_r4 == 0) {\n      uVar3 = param_2 & 0x80000000;\n      do {\n        uVar1 = param_1 & 0x80000000;\n        param_1 = param_1 << 1;\n        param_2 = param_2 * 2 + (uint)(uVar1 != 0);\n      } while ((param_2 & 0x100000) == 0);\n      param_2 = param_2 | uVar3;\n      if (uVar2 != 0) {\n        return CONCAT44(param_2,param_1);\n      }\n    }\n    do {\n      uVar2 = param_3 & 0x80000000;\n      param_3 = param_3 << 1;\n      param_4 = param_4 * 2 + (uint)(uVar2 != 0);\n    } while ((param_4 & 0x100000) == 0);\n    return CONCAT44(param_2,param_1);\n  }\n  bVar4 = (param_1 | param_2 << 1) == 0;\n  if (bVar4) {\n    param_2 = param_4;\n    param_1 = param_3;\n  }\n  if (!bVar4) {\n    bVar4 = (param_3 | param_4 << 1) == 0;\n  }\n  uVar3 = param_2;\n  if (((!bVar4) && ((unaff_r4 != in_r12 || ((param_1 | param_2 << 0xc) == 0)))) &&\n     ((uVar2 != in_r12 || (param_1 = param_3, uVar3 = param_4, (param_3 | param_4 << 0xc) == 0)))) {\n    return (ulonglong)((param_2 ^ param_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(uVar3,param_1) | 0x7ff8000000000000;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": false, 
            "entrypoint": "0x080006d4", 
            "calling": [
                "__muldf3"
            ], 
            "imported": false, 
            "current_name": "FUN_080006d4"
        }, 
        "I2C_SlaveTransmit_BTF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)\n\n{\n  byte *pbVar1;\n  \n  if (hi2c->XferCount != 0) {\n    pbVar1 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = pbVar1 + 1;\n    hi2c->Instance->DR = (uint)*pbVar1;\n    hi2c->XferCount = hi2c->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002ab8", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_SlaveTransmit_BTF"
        }, 
        "digital_io_write": {
            "renaming": {}, 
            "code": "\nvoid digital_io_write(GPIO_TypeDef *port,uint32_t pin,uint32_t val)\n\n{\n  if (val == 0) {\n    HAL_GPIO_WritePin(port,(uint16_t)pin,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(port,(uint16_t)pin,GPIO_PIN_SET);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_WritePin"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004c30", 
            "calling": [
                "digitalWrite"
            ], 
            "imported": false, 
            "current_name": "digital_io_write"
        }, 
        "HAL_I2C_ListenCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  i2c_t *piVar1;\n  uint uVar2;\n  \n  piVar1 = get_i2c_obj(hi2c);\n  if (((piVar1->i2c_onSlaveReceive != (_func_void_uint8_t_ptr_int *)0x0) &&\n      (piVar1->slaveMode == '\\x01')) &&\n     (uVar2 = 0x20 - *(byte *)&(piVar1->handle).XferSize & 0xff, uVar2 != 0)) {\n    (*piVar1->i2c_onSlaveReceive)(piVar1->i2cTxRxBuffer,uVar2);\n  }\n  HAL_I2C_EnableListen_IT(hi2c);\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_EnableListen_IT", 
                "get_i2c_obj"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004ec4", 
            "calling": [
                "I2C_Slave_AF", 
                "I2C_Slave_STOPF", 
                "I2C_ITError"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_ListenCpltCallback"
        }, 
        "EXTI1_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI1_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(2);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800607e", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI1_IRQHandler"
        }, 
        "hw_config_init": {
            "renaming": {}, 
            "code": "\nvoid hw_config_init(void)\n\n{\n  HAL_Init();\n  SystemClock_Config();\n  return;\n}\n\n", 
            "called": [
                "SystemClock_Config", 
                "HAL_Init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004c52", 
            "calling": [
                "init"
            ], 
            "imported": false, 
            "current_name": "hw_config_init"
        }, 
        "I2C_Master_ADD10": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)\n\n{\n  hi2c->Instance->DR = hi2c->Devaddress & 0xff;\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080028d2", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Master_ADD10"
        }, 
        "HAL_TIM_TriggerCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003f16", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_TriggerCallback"
        }, 
        "ADC_ConversionStop_Disable": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict ADC_ConversionStop_Disable(ADC_HandleTypeDef *hadc)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  ADC_TypeDef *pAVar3;\n  \n  pAVar3 = hadc->Instance;\n  if ((pAVar3->CR2 & 1) == 0) {\n    return HAL_OK;\n  }\n  pAVar3->CR2 = pAVar3->CR2 & 0xfffffffe;\n  uVar1 = HAL_GetTick();\n  do {\n    if ((hadc->Instance->CR2 & 1) == 0) {\n      return HAL_OK;\n    }\n    uVar2 = HAL_GetTick();\n  } while (uVar2 - uVar1 < 3);\n  hadc->State = hadc->State | 0x10;\n  hadc->ErrorCode = hadc->ErrorCode | 1;\n  return HAL_ERROR;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080020f0", 
            "calling": [
                "HAL_ADC_DeInit", 
                "HAL_ADCEx_Calibration_Start", 
                "HAL_ADC_Init", 
                "HAL_ADC_Stop"
            ], 
            "imported": false, 
            "current_name": "ADC_ConversionStop_Disable"
        }, 
        "UART_EndTransmit_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict UART_EndTransmit_IT(UART_HandleTypeDef *huart)\n\n{\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xffffffbf;\n  huart->gState = HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(huart);\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_UART_TxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080045fe", 
            "calling": [
                "HAL_UART_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "UART_EndTransmit_IT"
        }, 
        "TIM2_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM2_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_08004e44 + 4) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_08004e44 + 4));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004e34", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM2_IRQHandler"
        }, 
        "_GLOBAL__sub_I_Serial2": {
            "renaming": {}, 
            "code": "\nvoid _GLOBAL__sub_I_Serial2(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n", 
            "called": [
                "__static_initialization_and_destruction_0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005bd4", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I_Serial2"
        }, 
        "__sfputc_r": {
            "renaming": {}, 
            "code": "\nuint __sfputc_r(undefined4 param_1,byte param_2,byte **param_3)\n\n{\n  uint uVar1;\n  byte *pbVar2;\n  \n  pbVar2 = param_3[2] + -1;\n  param_3[2] = pbVar2;\n  if (((int)pbVar2 < 0) && (((int)pbVar2 < (int)param_3[6] || (param_2 == 10)))) {\n    uVar1 = __swbuf_r();\n    return uVar1;\n  }\n  pbVar2 = *param_3;\n  *param_3 = pbVar2 + 1;\n  *pbVar2 = param_2;\n  return (uint)param_2;\n}\n\n", 
            "called": [
                "__swbuf_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006344", 
            "calling": [
                "__sfputs_r"
            ], 
            "imported": false, 
            "current_name": "__sfputc_r"
        }, 
        "I2C_SlaveReceive_RXNE": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  uint8_t *puVar2;\n  \n  HVar1 = hi2c->State;\n  if (hi2c->XferCount != 0) {\n    puVar2 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar2 + 1;\n    *puVar2 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n    if ((hi2c->XferCount == 0) && (HVar1 == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n      hi2c->PreviousState = 0x22;\n      hi2c->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(hi2c);\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002ca6", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_SlaveReceive_RXNE"
        }, 
        "setRowOffsets": {
            "renaming": {}, 
            "code": "\nvoid __thiscall\nLiquidCrystal::setRowOffsets(LiquidCrystal *this,int row0,int row1,int row2,int row3)\n\n{\n  this->_row_offsets[0] = (uint8_t)row0;\n  this->_row_offsets[1] = (uint8_t)row1;\n  this->_row_offsets[2] = (uint8_t)row2;\n  this->_row_offsets[3] = (uint8_t)row3;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001294", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "setRowOffsets"
        }, 
        "USB_HP_CAN1_TX_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid USB_HP_CAN1_TX_IRQHandler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001c30", 
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "USB_HP_CAN1_TX_IRQHandler"
        }, 
        "__ledf2": {
            "renaming": {}, 
            "code": "\nuint __ledf2(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  \n  if (((int)(param_2 << 1) >> 0x15 == -1 || (int)(param_4 << 1) >> 0x15 == -1) &&\n     ((((int)(param_2 << 1) >> 0x15 == -1 && ((param_1 | param_2 << 0xc) != 0)) ||\n      (((int)(param_4 << 1) >> 0x15 == -1 && ((param_3 | param_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  bVar2 = (param_1 | param_2 << 1) == 0;\n  if (bVar2) {\n    bVar2 = (param_3 | param_4 << 1) == 0;\n  }\n  if (!bVar2) {\n    bVar2 = param_2 == param_4;\n  }\n  if (bVar2) {\n    bVar2 = param_1 == param_3;\n  }\n  if (!bVar2) {\n    uVar1 = param_2 ^ param_4;\n    bVar2 = uVar1 == 0;\n    if (-1 < (int)uVar1) {\n      bVar2 = param_2 == param_4;\n    }\n    bVar3 = -1 < (int)uVar1 && param_4 <= param_2;\n    if (bVar2) {\n      bVar3 = param_3 <= param_1;\n    }\n    param_4 = (int)param_4 >> 0x1f;\n    if (!bVar3) {\n      param_4 = ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000924", 
            "calling": [], 
            "imported": false, 
            "current_name": "__ledf2"
        }, 
        "HAL_TIM_PeriodElapsedCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n\n{\n  stimer_t *psVar1;\n  \n  psVar1 = get_timer_obj(htim);\n  if (psVar1->irqHandle != (_func_void_stimer_t_ptr *)0x0) {\n    (*psVar1->irqHandle)(psVar1);\n  }\n  return;\n}\n\n", 
            "called": [
                "get_timer_obj"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004e12", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PeriodElapsedCallback"
        }, 
        "_isatty": {
            "renaming": {}, 
            "code": "\nint _isatty(int file_UNUSED)\n\n{\n  return 1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005724", 
            "calling": [
                "_isatty_r"
            ], 
            "imported": false, 
            "current_name": "_isatty"
        }, 
        "I2C_MasterReceive_RXNE": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)\n\n{\n  uint8_t *puVar1;\n  \n  if (hi2c->State == HAL_I2C_STATE_BUSY_RX) {\n    if (hi2c->XferCount < 4) {\n      if (hi2c->XferCount - 2 < 2) {\n        if (hi2c->XferOptions == 2) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        }\n        else {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x800;\n        }\n        hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n      }\n      else {\n        if (hi2c->XferOptions == 2) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        }\n        else {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n        }\n        hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n        puVar1 = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = puVar1 + 1;\n        *puVar1 = (uint8_t)hi2c->Instance->DR;\n        hi2c->XferCount = hi2c->XferCount - 1;\n        hi2c->State = HAL_I2C_STATE_READY;\n        hi2c->PreviousState = 0;\n        if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n          hi2c->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(hi2c);\n        }\n        else {\n          hi2c->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(hi2c);\n        }\n      }\n    }\n    else {\n      puVar1 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = puVar1 + 1;\n      *puVar1 = (uint8_t)hi2c->Instance->DR;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_MemRxCpltCallback", 
                "HAL_I2C_MasterRxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002f9c", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_MasterReceive_RXNE"
        }, 
        "HAL_IncTick": {
            "renaming": {}, 
            "code": "\nvoid HAL_IncTick(void)\n\n{\n  *(uint *)PTR_uwTick_08001cbc = (uint)(byte)*PTR_uwTickFreq_08001cc0 + *(int *)PTR_uwTick_08001cbc;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001cac", 
            "calling": [
                "SysTick_Handler"
            ], 
            "imported": false, 
            "current_name": "HAL_IncTick"
        }, 
        "fiprintf": {
            "renaming": {}, 
            "code": "\nint fiprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  uStack_8 = in_r2;\n  uStack_4 = in_r3;\n  iVar1 = _vfiprintf_r(*(undefined4 *)PTR__impure_ptr_08006194,__stream,__format,&uStack_8,__stream,\n                       &uStack_8);\n  return iVar1;\n}\n\n", 
            "called": [
                "_vfiprintf_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006174", 
            "calling": [
                "__assert_func"
            ], 
            "imported": false, 
            "current_name": "fiprintf"
        }, 
        "__fixunsdfsi": {
            "renaming": {}, 
            "code": "\nuint __fixunsdfsi(uint param_1,uint param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  \n  if ((param_2 & 0x80000000) != 0) {\n    return 0;\n  }\n  iVar1 = param_2 * 2 + 0x200000;\n  if (param_2 * 2 < 0xffe00000) {\n    if (-1 < iVar1) {\n      return 0;\n    }\n    uVar2 = -(iVar1 >> 0x15) - 0x3e1;\n    if (-1 < (int)uVar2) {\n      return (param_2 << 0xb | 0x80000000 | param_1 >> 0x15) >> (uVar2 & 0xff);\n    }\n  }\n  else if ((param_1 | param_2 << 0xc) != 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000aa8", 
            "calling": [
                "printFloat"
            ], 
            "imported": false, 
            "current_name": "__fixunsdfsi"
        }, 
        "__sfputs_r": {
            "renaming": {}, 
            "code": "\nint __sfputs_r(undefined4 param_1,undefined4 param_2,undefined *param_3,int param_4)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  int iVar3;\n  \n  puVar2 = param_3 + param_4;\n  iVar3 = param_4;\n  do {\n    if (param_3 == puVar2) {\n      return 0;\n    }\n    iVar1 = __sfputc_r(param_1,*param_3,param_2,param_4,iVar3);\n    param_4 = iVar1 + 1;\n    param_3 = param_3 + 1;\n  } while (param_4 != 0);\n  return iVar1;\n}\n\n", 
            "called": [
                "__sfputc_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006370", 
            "calling": [
                "_vfiprintf_r"
            ], 
            "imported": false, 
            "current_name": "__sfputs_r"
        }, 
        "__aeabi_cdcmpeq": {
            "renaming": {}, 
            "code": "\nundefined4 __aeabi_cdcmpeq(undefined4 param_1)\n\n{\n  __eqdf2();\n  return param_1;\n}\n\n", 
            "called": [
                "__eqdf2"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080009b8", 
            "calling": [
                "__aeabi_dcmpeq", 
                "__aeabi_dcmple", 
                "__aeabi_dcmplt", 
                "__aeabi_cdrcmple"
            ], 
            "imported": false, 
            "current_name": "__aeabi_cdcmpeq"
        }, 
        "HAL_MspInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_MspInit(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001c3a", 
            "calling": [
                "HAL_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_MspInit"
        }, 
        "ADC_Enable": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict ADC_Enable(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  ADC_TypeDef *pAVar4;\n  uint32_t wait_loop_index;\n  \n  pAVar4 = hadc->Instance;\n  if ((pAVar4->CR2 & 1) == 0) {\n    pAVar4->CR2 = pAVar4->CR2 | 1;\n    for (wait_loop_index =\n              (uint32_t)\n              ((ulonglong)DAT_08002000 * (ulonglong)*(uint *)PTR_SystemCoreClock_08001ffc >> 0x32);\n        wait_loop_index != 0; wait_loop_index = wait_loop_index - 1) {\n    }\n    uVar2 = HAL_GetTick();\n    do {\n      if ((hadc->Instance->CR2 & 1) != 0) {\n        return HAL_OK;\n      }\n      uVar3 = HAL_GetTick();\n    } while (uVar3 - uVar2 < 3);\n    hadc->State = hadc->State | 0x10;\n    hadc->ErrorCode = hadc->ErrorCode | 1;\n    hadc->Lock = HAL_UNLOCKED;\n    HVar1 = HAL_ERROR;\n  }\n  else {\n    HVar1 = HAL_OK;\n  }\n  return HVar1;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001f84", 
            "calling": [
                "HAL_ADC_Start", 
                "HAL_ADCEx_Calibration_Start"
            ], 
            "imported": false, 
            "current_name": "ADC_Enable"
        }, 
        "HAL_I2C_AbortCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800316a", 
            "calling": [
                "I2C_ITError", 
                "I2C_DMAAbort"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_AbortCpltCallback"
        }, 
        "__aeabi_cdrcmple": {
            "renaming": {}, 
            "code": "\nvoid __aeabi_cdrcmple(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  __aeabi_cdcmpeq(param_3,param_4,param_1,param_2);\n  return;\n}\n\n", 
            "called": [
                "__aeabi_cdcmpeq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080009a8", 
            "calling": [
                "__aeabi_dcmpge", 
                "__aeabi_dcmpgt"
            ], 
            "imported": false, 
            "current_name": "__aeabi_cdrcmple"
        }, 
        "HAL_ADCEx_Calibration_Start": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  ADC_TypeDef *pAVar4;\n  uint uVar5;\n  uint32_t wait_loop_index;\n  \n  if (hadc->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  hadc->Lock = HAL_LOCKED;\n  HVar1 = ADC_ConversionStop_Disable(hadc);\n  if (HVar1 == HAL_OK) {\n    hadc->State = hadc->State & 0xffffeefd | 2;\n    uVar5 = *(uint *)PTR_SystemCoreClock_0800246c;\n    uVar2 = HAL_RCCEx_GetPeriphCLKFreq(2);\n    for (wait_loop_index = uVar5 / uVar2 << 1; wait_loop_index != 0;\n        wait_loop_index = wait_loop_index - 1) {\n    }\n    ADC_Enable(hadc);\n    hadc->Instance->CR2 = hadc->Instance->CR2 | 8;\n    uVar2 = HAL_GetTick();\n    while (pAVar4 = hadc->Instance, (pAVar4->CR2 & 8) != 0) {\n      uVar3 = HAL_GetTick();\n      if (10 < uVar3 - uVar2) {\n        hadc->State = hadc->State & 0xffffffed | 0x10;\n        hadc->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    pAVar4->CR2 = pAVar4->CR2 | 4;\n    uVar2 = HAL_GetTick();\n    while ((hadc->Instance->CR2 & 4) != 0) {\n      uVar3 = HAL_GetTick();\n      if (10 < uVar3 - uVar2) {\n        hadc->State = hadc->State & 0xffffffed | 0x10;\n        hadc->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    hadc->State = hadc->State & 0xfffffffc | 1;\n  }\n  hadc->Lock = HAL_UNLOCKED;\n  return HVar1;\n}\n\n", 
            "called": [
                "ADC_ConversionStop_Disable", 
                "HAL_RCCEx_GetPeriphCLKFreq", 
                "HAL_GetTick", 
                "ADC_Enable"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002384", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADCEx_Calibration_Start"
        }, 
        "HAL_ADC_MspDeInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_ADC_MspDeInit(ADC_HandleTypeDef *hadc)\n\n{\n  int iVar1;\n  \n  iVar1 = DAT_08004a48;\n  if (hadc->Instance != DAT_08004a40) {\n    if (hadc->Instance == DAT_08004a44) {\n      *(uint *)(DAT_08004a48 + 0xc) = *(uint *)(DAT_08004a48 + 0xc) | 0x400;\n      *(uint *)(iVar1 + 0xc) = *(uint *)(iVar1 + 0xc) & 0xfffffbff;\n      *(uint *)(iVar1 + 0x18) = *(uint *)(iVar1 + 0x18) & 0xfffffbff;\n      *(uint *)(iVar1 + 0x18) = *(uint *)(iVar1 + 0x18) & 0xfffffbff;\n    }\n    return;\n  }\n  *(uint *)(DAT_08004a48 + 0xc) = *(uint *)(DAT_08004a48 + 0xc) | 0x200;\n  *(uint *)(iVar1 + 0xc) = *(uint *)(iVar1 + 0xc) & 0xfffffdff;\n  *(uint *)(iVar1 + 0x18) = *(uint *)(iVar1 + 0x18) & 0xfffffdff;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080049f0", 
            "calling": [
                "HAL_ADC_DeInit"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_MspDeInit"
        }, 
        "__unorddf2": {
            "renaming": {}, 
            "code": "\nundefined4 __unorddf2(uint param_1,int param_2,uint param_3,int param_4)\n\n{\n  if ((((param_2 << 1) >> 0x15 != -1) || ((param_1 | param_2 << 0xc) == 0)) &&\n     (((param_4 << 1) >> 0x15 != -1 || ((param_3 | param_4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000a2c", 
            "calling": [
                "printFloat"
            ], 
            "imported": false, 
            "current_name": "__unorddf2"
        }, 
        "HAL_TIM_OC_DelayElapsedCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)\n\n{\n  stimer_t *psVar1;\n  \n  psVar1 = get_timer_obj(htim);\n  if ((psVar1->irqHandleOC != (_func_void_stimer_t_ptr_uint32_t *)0x0) &&\n     (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*psVar1->irqHandleOC)(psVar1,0);\n  }\n  return;\n}\n\n", 
            "called": [
                "get_timer_obj"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004df8", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_OC_DelayElapsedCallback"
        }, 
        "IPAddress": {
            "renaming": {}, 
            "code": "\nIPAddress * __thiscall\nIPAddress::IPAddress\n          (IPAddress *this,uint8_t first_octet,uint8_t second_octet,uint8_t third_octet,\n          uint8_t fourth_octet)\n\n{\n  (this->super_Printable)._vptr_Printable = (_func_int_varargs **)PTR_DAT_08005c34;\n  (this->_address).bytes[0] = first_octet;\n  (this->_address).bytes[1] = second_octet;\n  (this->_address).bytes[2] = third_octet;\n  (this->_address).bytes[3] = fourth_octet;\n  return this;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005c1c", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "IPAddress"
        }, 
        "_rx_complete_irq": {
            "renaming": {}, 
            "code": "\nvoid HardwareSerial::_rx_complete_irq(serial_t_conflict *obj)\n\n{\n  int iVar1;\n  ushort uVar2;\n  uchar c;\n  \n  iVar1 = uart_getc((serial_t *)obj,&c);\n  if ((iVar1 == 0) && (uVar2 = obj->rx_head + 1 & 0x3f, uVar2 != obj->rx_tail)) {\n    obj->rx_buff[obj->rx_head] = c;\n    obj->rx_head = uVar2;\n  }\n  return;\n}\n\n", 
            "called": [
                "uart_getc"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800598a", 
            "calling": [], 
            "imported": false, 
            "current_name": "_rx_complete_irq"
        }, 
        "HAL_TIMEx_PWMN_Stop": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim,uint32_t Channel)\n\n{\n  TIM_TypeDef *pTVar1;\n  \n  TIM_CCxNChannelCmd(htim->Instance,Channel,0);\n  pTVar1 = htim->Instance;\n  if (((pTVar1->CCER & 0x1111) == 0) && ((pTVar1->CCER & 0x444) == 0)) {\n    pTVar1->BDTR = pTVar1->BDTR & 0xffff7fff;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->CCER & 0x1111) == 0) && ((pTVar1->CCER & 0x444) == 0)) {\n    pTVar1->CR1 = pTVar1->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "TIM_CCxNChannelCmd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800412c", 
            "calling": [
                "pwm_stop"
            ], 
            "imported": false, 
            "current_name": "HAL_TIMEx_PWMN_Stop"
        }, 
        "USART3_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid USART3_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART3_IRQn);\n  if (*(UART_HandleTypeDef **)(PTR_uart_handlers_080056d4 + 8) != (UART_HandleTypeDef *)0x0) {\n    HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_080056d4 + 8));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_NVIC_ClearPendingIRQ", 
                "HAL_UART_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080056c0", 
            "calling": [], 
            "imported": false, 
            "current_name": "USART3_IRQHandler"
        }, 
        "SetMode": {
            "renaming": {}, 
            "code": "\nvoid __thiscall PID::SetMode(PID *this,int Mode)\n\n{\n  bool bVar1;\n  \n  if (Mode == 1) {\n    bVar1 = true;\n    if (this->inAuto == false) {\n      Initialize(this);\n    }\n  }\n  else {\n    bVar1 = false;\n  }\n  this->inAuto = bVar1;\n  return;\n}\n\n", 
            "called": [
                "Initialize"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001a44", 
            "calling": [
                "loop"
            ], 
            "imported": false, 
            "current_name": "SetMode"
        }, 
        "_init": {
            "renaming": {}, 
            "code": "\nvoid _init(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007328", 
            "calling": [
                "__libc_init_array", 
                "__do_global_dtors_aux"
            ], 
            "imported": false, 
            "current_name": "_init"
        }, 
        "__swsetup_r": {
            "renaming": {}, 
            "code": "\nuint __swsetup_r(undefined4 *param_1,undefined4 *param_2)\n\n{\n  uint uVar1;\n  ushort uVar2;\n  int iVar3;\n  \n  iVar3 = *(int *)PTR__impure_ptr_08006ab0;\n  if ((iVar3 != 0) && (*(int *)(iVar3 + 0x18) == 0)) {\n    __sinit(iVar3);\n  }\n  if (param_2 == (undefined4 *)PTR___sf_fake_stdin_08006ab4) {\n    param_2 = *(undefined4 **)(iVar3 + 4);\n  }\n  else if (param_2 == (undefined4 *)PTR___sf_fake_stdout_08006ab8) {\n    param_2 = *(undefined4 **)(iVar3 + 8);\n  }\n  else if (param_2 == (undefined4 *)PTR___sf_fake_stderr_08006abc) {\n    param_2 = *(undefined4 **)(iVar3 + 0xc);\n  }\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar1 = (uint)uVar2;\n  if (-1 < (int)(uVar1 << 0x1c)) {\n    if (-1 < (int)(uVar1 << 0x1b)) {\n      *param_1 = 9;\n      goto LAB_08006a14;\n    }\n    if ((int)(uVar1 << 0x1d) < 0) {\n      if ((undefined4 *)param_2[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] != param_2 + 0x11) {\n          _free_r(param_1);\n        }\n        param_2[0xd] = 0;\n      }\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xffdb;\n      param_2[1] = 0;\n      *param_2 = param_2[4];\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] == 0) && ((*(ushort *)(param_2 + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(param_1,param_2);\n  }\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar1 = uVar2 & 1;\n  if ((uVar2 & 1) == 0) {\n    if (-1 < (int)((uint)uVar2 << 0x1e)) {\n      uVar1 = param_2[5];\n    }\n    param_2[2] = uVar1;\n  }\n  else {\n    param_2[2] = 0;\n    param_2[6] = -param_2[5];\n  }\n  if (param_2[4] == 0) {\n    uVar2 = *(ushort *)(param_2 + 3);\n    uVar1 = (int)(short)uVar2 & 0x80;\n    if (uVar1 != 0) {\nLAB_08006a14:\n      *(ushort *)(param_2 + 3) = uVar2 | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n", 
            "called": [
                "__smakebuf_r", 
                "__sinit", 
                "_free_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080069e4", 
            "calling": [
                "__swbuf_r", 
                "_vfiprintf_r"
            ], 
            "imported": false, 
            "current_name": "__swsetup_r"
        }, 
        "HAL_RCCEx_PeriphCLKConfig": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef_conflict *PeriphClkInit)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint uVar5;\n  bool bVar6;\n  uint32_t tmpreg;\n  \n  if ((PeriphClkInit->PeriphClockSelection & 1) != 0) {\n    bVar6 = (*(uint *)(DAT_08003d98 + 0x1c) & 0x10000000) == 0;\n    if (bVar6) {\n      *(uint *)(DAT_08003d98 + 0x1c) = *(uint *)(DAT_08003d98 + 0x1c) | 0x10000000;\n    }\n    if ((*DAT_08003d9c & 0x100) == 0) {\n      *DAT_08003d9c = *DAT_08003d9c | 0x100;\n      uVar3 = HAL_GetTick();\n      while ((*DAT_08003d9c & 0x100) == 0) {\n        uVar4 = HAL_GetTick();\n        if (100 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    puVar2 = DAT_08003da0;\n    iVar1 = DAT_08003d98;\n    uVar5 = *(uint *)(DAT_08003d98 + 0x20) & 0x300;\n    if ((uVar5 != 0) && (uVar5 != (PeriphClkInit->RTCClockSelection & 0x300))) {\n      uVar5 = *(uint *)(DAT_08003d98 + 0x20);\n      *DAT_08003da0 = 1;\n      *puVar2 = 0;\n      *(uint *)(iVar1 + 0x20) = uVar5 & 0xfffffcff;\n      if ((uVar5 & 1) != 0) {\n        uVar3 = HAL_GetTick();\n        while ((*(uint *)(DAT_08003d98 + 0x20) & 2) == 0) {\n          uVar4 = HAL_GetTick();\n          if (5000 < uVar4 - uVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    iVar1 = DAT_08003d98;\n    *(uint *)(DAT_08003d98 + 0x20) =\n         *(uint *)(DAT_08003d98 + 0x20) & 0xfffffcff | PeriphClkInit->RTCClockSelection;\n    if (bVar6) {\n      *(uint *)(iVar1 + 0x1c) = *(uint *)(iVar1 + 0x1c) & 0xefffffff;\n    }\n  }\n  if ((PeriphClkInit->PeriphClockSelection & 2) != 0) {\n    *(uint *)(DAT_08003d98 + 4) =\n         *(uint *)(DAT_08003d98 + 4) & 0xffff3fff | PeriphClkInit->AdcClockSelection;\n  }\n  if ((PeriphClkInit->PeriphClockSelection & 0x10) != 0) {\n    *(uint *)(DAT_08003d98 + 4) =\n         *(uint *)(DAT_08003d98 + 4) & 0xffbfffff | PeriphClkInit->UsbClockSelection;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003c90", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_RCCEx_PeriphCLKConfig"
        }, 
        "get_adc_channel": {
            "renaming": {}, 
            "code": "\nuint32_t get_adc_channel(PinName_conflict pin)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = pinmap_function(pin,(PinMap_conflict *)PTR_PinMap_ADC_08004944);\n  uVar1 = (uVar1 << 0xc) >> 0x1b;\n  if (0x10 < uVar1 - 1) {\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n", 
            "called": [
                "pinmap_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800492c", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "get_adc_channel"
        }, 
        "__floatundidf": {
            "renaming": {}, 
            "code": "\nulonglong __floatundidf(uint param_1,uint param_2)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  bool bVar11;\n  \n  if ((param_1 | param_2) == 0) {\n    return CONCAT44(param_2,param_1);\n  }\n  iVar7 = 0x432;\n  uVar8 = param_2 >> 0x16;\n  if (uVar8 != 0) {\n    iVar7 = 3;\n    if (param_2 >> 0x19 != 0) {\n      iVar7 = 6;\n    }\n    if (param_2 >> 0x1c != 0) {\n      iVar7 = iVar7 + 3;\n    }\n    uVar4 = iVar7 - ((int)param_2 >> 0x1f);\n    uVar8 = param_1 << (0x20 - uVar4 & 0xff);\n    param_1 = param_1 >> (uVar4 & 0xff) | param_2 << (0x20 - uVar4 & 0xff);\n    param_2 = param_2 >> (uVar4 & 0xff);\n    iVar7 = uVar4 + 0x432;\n  }\n  if (0xfffff < param_2) {\n    if (0x1fffff < param_2) {\n      uVar4 = param_2 & 1;\n      param_2 = param_2 >> 1;\n      bVar1 = (byte)param_1;\n      param_1 = (uint)(uVar4 != 0) << 0x1f | param_1 >> 1;\n      uVar8 = (uint)(bVar1 & 1) << 0x1f | uVar8 >> 1;\n      iVar7 = iVar7 + 1;\n      if (0xffbfffff < (uint)(iVar7 * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_080002a0:\n    bVar10 = 0x7fffffff < uVar8;\n    if (uVar8 == 0x80000000) {\n      bVar10 = (param_1 & 1) != 0;\n    }\n    return CONCAT44(param_2 + iVar7 * 0x100000 + (uint)CARRY4(param_1,(uint)bVar10),param_1 + bVar10\n                   );\n  }\n  bVar9 = (uVar8 & 0x80000000) != 0;\n  uVar8 = uVar8 << 1;\n  uVar4 = param_1 * 2;\n  bVar10 = CARRY4(param_1,param_1);\n  param_1 = param_1 * 2 + (uint)bVar9;\n  param_2 = param_2 * 2 + (uint)(bVar10 || CARRY4(uVar4,(uint)bVar9));\n  iVar7 = iVar7 + -1;\n  if ((param_2 & 0x100000) != 0) goto LAB_080002a0;\n  uVar2 = param_1;\n  uVar4 = param_2;\n  if (param_2 == 0) {\n    uVar2 = 0;\n    uVar4 = param_1;\n  }\n  iVar5 = count_leading_zeroes(uVar4);\n  if (param_2 == 0) {\n    iVar5 = iVar5 + 0x20;\n  }\n  uVar6 = iVar5 - 0xb;\n  bVar11 = SBORROW4(uVar6,0x20);\n  uVar3 = iVar5 - 0x2b;\n  bVar10 = (int)uVar3 < 0;\n  bVar9 = uVar3 == 0;\n  if ((int)uVar6 < 0x20) {\n    bVar11 = SCARRY4(uVar3,0xc);\n    iVar5 = iVar5 + -0x1f;\n    bVar10 = iVar5 < 0;\n    bVar9 = iVar5 == 0;\n    uVar3 = uVar6;\n    if (!bVar9 && bVar10 == bVar11) {\n      uVar2 = uVar4 << (uVar6 & 0xff);\n      uVar4 = uVar4 >> (0xcU - iVar5 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar9 || bVar10 != bVar11) {\n    uVar8 = 0x20 - uVar3;\n  }\n  uVar4 = uVar4 << (uVar3 & 0xff);\n  if (bVar9 || bVar10 != bVar11) {\n    uVar4 = uVar4 | uVar2 >> (uVar8 & 0xff);\n  }\n  if (bVar9 || bVar10 != bVar11) {\n    uVar2 = uVar2 << (uVar3 & 0xff);\n  }\nLAB_08000318:\n  if ((int)uVar6 <= iVar7) {\n    return CONCAT44(uVar4 + (iVar7 - uVar6) * 0x100000,uVar2);\n  }\n  uVar8 = ~(iVar7 - uVar6);\n  if (0x1e < (int)uVar8) {\n    return (ulonglong)(uVar4 >> (uVar8 - 0x1f & 0xff));\n  }\n  iVar7 = uVar8 - 0x13;\n  if (iVar7 == 0 || iVar7 < 0 != SCARRY4(uVar8 - 0x1f,0xc)) {\n    uVar8 = uVar8 + 1;\n    return CONCAT44(uVar4 >> (uVar8 & 0xff),uVar2 >> (uVar8 & 0xff) | uVar4 << (0x20 - uVar8 & 0xff)\n                   );\n  }\n  return (ulonglong)(uVar2 >> (0x20 - (0xcU - iVar7) & 0xff) | uVar4 << (0xcU - iVar7 & 0xff));\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800048c", 
            "calling": [], 
            "imported": false, 
            "current_name": "__floatundidf"
        }, 
        "HAL_ADC_Start": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_ADC_Start(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  ADC_TypeDef *pAVar2;\n  \n  if (hadc->Lock != HAL_LOCKED) {\n    hadc->Lock = HAL_LOCKED;\n    HVar1 = ADC_Enable(hadc);\n    if (HVar1 == HAL_OK) {\n      hadc->State = hadc->State & 0xfffffcfe | 0x100;\n      pAVar2 = hadc->Instance;\n      if ((pAVar2 == DAT_080020e8) && ((DAT_080020e8[-0xd].JOFR1 & 0xf0000) != 0)) {\n        hadc->State = hadc->State | 0x100000;\n        if ((*(uint *)(DAT_080020ec + 4) & 0x400) != 0) {\n          hadc->State = hadc->State & 0xffffcfff | 0x1000;\n        }\n      }\n      else {\n        hadc->State = hadc->State & 0xffefffff;\n        if ((pAVar2->CR1 & 0x400) != 0) {\n          hadc->State = hadc->State & 0xffffcfff | 0x1000;\n        }\n      }\n      if ((hadc->State & 0x1000) == 0) {\n        hadc->ErrorCode = 0;\n      }\n      else {\n        hadc->ErrorCode = hadc->ErrorCode & 0xfffffff9;\n      }\n      hadc->Lock = HAL_UNLOCKED;\n      pAVar2->SR = 0xfffffffd;\n      pAVar2 = hadc->Instance;\n      if (((pAVar2->CR2 & 0xe0000) == 0xe0000) &&\n         ((pAVar2 != DAT_080020e8 || ((DAT_080020e8[-0xd].JOFR1 & 0xf0000) == 0)))) {\n        pAVar2->CR2 = pAVar2->CR2 | 0x500000;\n      }\n      else {\n        pAVar2->CR2 = pAVar2->CR2 | 0x100000;\n      }\n    }\n    else {\n      hadc->Lock = HAL_UNLOCKED;\n    }\n    return HVar1;\n  }\n  return HAL_BUSY;\n}\n\n", 
            "called": [
                "ADC_Enable"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002004", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_Start"
        }, 
        "HAL_ADC_GetState": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_ADC_GetState(ADC_HandleTypeDef *hadc)\n\n{\n  return hadc->State;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001f80", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_GetState"
        }, 
        "HAL_ADC_Stop": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_ADC_Stop(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  \n  if (hadc->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  hadc->Lock = HAL_LOCKED;\n  HVar1 = ADC_ConversionStop_Disable(hadc);\n  if (HVar1 == HAL_OK) {\n    hadc->State = hadc->State & 0xffffeefe | 1;\n  }\n  hadc->Lock = HAL_UNLOCKED;\n  return HVar1;\n}\n\n", 
            "called": [
                "ADC_ConversionStop_Disable"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002348", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_Stop"
        }, 
        "available": {
            "renaming": {}, 
            "code": "\nint __thiscall HardwareSerial::available(HardwareSerial *this)\n\n{\n  return ((this->_serial).rx_head + 0x40) - (uint)(this->_serial).rx_tail & 0x3f;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800591e", 
            "calling": [
                "serialEventRun"
            ], 
            "imported": false, 
            "current_name": "available"
        }, 
        "EXTI15_10_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI15_10_IRQHandler(void)\n\n{\n  uint uVar1;\n  \n  for (uVar1 = 0x400; uVar1 < 0x8001; uVar1 = uVar1 << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)uVar1);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080060bc", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI15_10_IRQHandler"
        }, 
        "__malloc_lock": {
            "renaming": {}, 
            "code": "\nvoid __malloc_lock(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006eac", 
            "calling": [
                "_malloc_r", 
                "_free_r"
            ], 
            "imported": false, 
            "current_name": "__malloc_lock"
        }, 
        "__aeabi_dadd": {
            "renaming": {}, 
            "code": "\nulonglong __aeabi_dadd(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar7 = param_2 << 1;\n  uVar9 = param_4 << 1;\n  bVar13 = ((param_2 ^ param_4) & 0x7fffffff) == 0;\n  bVar14 = bVar13 && param_1 == param_3;\n  if (!bVar13 || param_1 != param_3) {\n    bVar14 = (uVar7 | param_1) == 0;\n  }\n  if (!bVar14) {\n    bVar14 = (uVar9 | param_3) == 0;\n  }\n  iVar6 = (int)uVar7 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar6 == -1;\n  }\n  iVar1 = (int)uVar9 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar1 == -1;\n  }\n  if (bVar14) {\n    if (iVar6 == -1 || iVar1 == -1) {\n      uVar9 = param_4;\n      uVar7 = param_3;\n      if (iVar6 == -1) {\n        uVar9 = param_2;\n        uVar7 = param_1;\n      }\n      if (iVar6 != -1 || iVar1 != -1) {\n        param_3 = uVar7;\n        param_4 = uVar9;\n      }\n      bVar14 = (uVar7 | uVar9 << 0xc) == 0;\n      if (bVar14) {\n        bVar14 = (param_3 | param_4 << 0xc) == 0;\n      }\n      if (bVar14) {\n        bVar14 = uVar9 == param_4;\n      }\n      if (!bVar14) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar7);\n    }\n    if (((param_2 ^ param_4) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((uVar7 | param_1) == 0) {\n        param_1 = param_3;\n        param_2 = param_4;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 != param_4) {\n      return 0;\n    }\n    if (uVar7 >> 0x15 == 0) {\n      bVar14 = (param_1 & 0x80000000) != 0;\n      uVar9 = param_2 * 2 + (uint)bVar14;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar9 = uVar9 | 0x80000000;\n      }\n      return CONCAT44(uVar9,param_1 << 1);\n    }\n    if (uVar7 < 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 = param_2 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(param_2 | 0x7ff00000) << 0x20;\n  }\n  uVar7 = uVar7 >> 0x15;\n  uVar9 = uVar9 >> 0x15;\n  uVar10 = uVar9 - uVar7;\n  bVar14 = uVar10 != 0;\n  if (uVar9 < uVar7) {\n    uVar10 = -uVar10;\n  }\n  uVar8 = param_1;\n  uVar5 = param_2;\n  if (bVar14 && uVar7 <= uVar9) {\n    uVar7 = uVar7 + uVar10;\n    uVar8 = param_3;\n    uVar5 = param_4;\n    param_3 = param_1;\n    param_4 = param_2;\n  }\n  if (0x36 < uVar10) {\n    return CONCAT44(uVar5,uVar8);\n  }\n  uVar9 = uVar5 & 0xfffff | 0x100000;\n  if ((uVar5 & 0x80000000) != 0) {\n    bVar14 = uVar8 != 0;\n    uVar8 = -uVar8;\n    uVar9 = -uVar9 - (uint)bVar14;\n  }\n  uVar5 = param_4 & 0xfffff | 0x100000;\n  if ((param_4 & 0x80000000) != 0) {\n    bVar14 = param_3 != 0;\n    param_3 = -param_3;\n    uVar5 = -uVar5 - (uint)bVar14;\n  }\n  if (uVar7 == uVar10) {\n    uVar5 = uVar5 ^ 0x100000;\n    if (uVar7 == 0) {\n      uVar9 = uVar9 ^ 0x100000;\n      uVar7 = 1;\n    }\n    else {\n      uVar10 = uVar10 - 1;\n    }\n  }\n  uVar12 = -uVar10 + 0x20;\n  if ((int)uVar10 < 0x21) {\n    uVar11 = param_3 << (uVar12 & 0xff);\n    param_3 = param_3 >> (uVar10 & 0xff);\n    uVar3 = uVar8 + param_3;\n    uVar4 = uVar5 << (uVar12 & 0xff);\n    uVar12 = uVar3 + uVar4;\n    uVar9 = uVar9 + CARRY4(uVar8,param_3) + ((int)uVar5 >> (uVar10 & 0xff)) +\n            (uint)CARRY4(uVar3,uVar4);\n  }\n  else {\n    uVar11 = uVar5 << (-uVar10 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      uVar11 = uVar11 | 2;\n    }\n    uVar5 = (int)uVar5 >> (uVar10 - 0x20 & 0xff);\n    uVar12 = uVar8 + uVar5;\n    uVar9 = uVar9 + ((int)uVar5 >> 0x1f) + (uint)CARRY4(uVar8,uVar5);\n  }\n  param_2 = uVar9 & 0x80000000;\n  uVar10 = uVar9;\n  if ((int)uVar9 < 0) {\n    bVar14 = uVar11 == 0;\n    uVar11 = -uVar11;\n    uVar10 = -uVar12;\n    uVar12 = -(uint)!bVar14 - uVar12;\n    uVar10 = -(uint)(bVar14 <= uVar10) - uVar9;\n  }\n  if (0xfffff < uVar10) {\n    uVar8 = uVar7 - 1;\n    if (0x1fffff < uVar10) {\n      uVar9 = uVar10 & 1;\n      uVar10 = uVar10 >> 1;\n      bVar2 = (byte)uVar12;\n      uVar12 = (uint)(uVar9 != 0) << 0x1f | uVar12 >> 1;\n      uVar11 = (uint)(bVar2 & 1) << 0x1f | uVar11 >> 1;\n      uVar8 = uVar7;\n      if (0xffbfffff < uVar7 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    bVar14 = 0x7fffffff < uVar11;\n    if (uVar11 == 0x80000000) {\n      bVar14 = (uVar12 & 1) != 0;\n    }\n    return CONCAT44(uVar10 + uVar8 * 0x100000 + (uint)CARRY4(uVar12,(uint)bVar14) | param_2,\n                    uVar12 + bVar14);\n  }\n  bVar13 = (uVar11 & 0x80000000) != 0;\n  uVar11 = uVar11 << 1;\n  uVar8 = uVar12 * 2;\n  bVar14 = CARRY4(uVar12,uVar12);\n  uVar12 = uVar12 * 2 + (uint)bVar13;\n  uVar10 = uVar10 * 2 + (uint)(bVar14 || CARRY4(uVar8,(uint)bVar13));\n  uVar8 = uVar7 - 2;\n  if ((uVar10 & 0x100000) != 0) goto LAB_080002a0;\n  uVar5 = uVar12;\n  uVar7 = uVar10;\n  if (uVar10 == 0) {\n    uVar5 = 0;\n    uVar7 = uVar12;\n  }\n  iVar6 = count_leading_zeroes(uVar7);\n  if (uVar10 == 0) {\n    iVar6 = iVar6 + 0x20;\n  }\n  uVar12 = iVar6 - 0xb;\n  bVar15 = SBORROW4(uVar12,0x20);\n  uVar10 = iVar6 - 0x2b;\n  bVar14 = (int)uVar10 < 0;\n  bVar13 = uVar10 == 0;\n  if ((int)uVar12 < 0x20) {\n    bVar15 = SCARRY4(uVar10,0xc);\n    iVar6 = iVar6 + -0x1f;\n    bVar14 = iVar6 < 0;\n    bVar13 = iVar6 == 0;\n    uVar10 = uVar12;\n    if (!bVar13 && bVar14 == bVar15) {\n      uVar5 = uVar7 << (uVar12 & 0xff);\n      uVar7 = uVar7 >> (0xcU - iVar6 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar11 = 0x20 - uVar10;\n  }\n  uVar7 = uVar7 << (uVar10 & 0xff);\n  if (bVar13 || bVar14 != bVar15) {\n    uVar7 = uVar7 | uVar5 >> (uVar11 & 0xff);\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar5 = uVar5 << (uVar10 & 0xff);\n  }\nLAB_08000318:\n  if ((int)uVar12 <= (int)uVar8) {\n    return CONCAT44(uVar7 + (uVar8 - uVar12) * 0x100000 | param_2,uVar5);\n  }\n  uVar10 = ~(uVar8 - uVar12);\n  if ((int)uVar10 < 0x1f) {\n    iVar6 = uVar10 - 0x13;\n    if (iVar6 != 0 && iVar6 < 0 == SCARRY4(uVar10 - 0x1f,0xc)) {\n      return CONCAT44(uVar9,uVar5 >> (0x20 - (0xcU - iVar6) & 0xff) | uVar7 << (0xcU - iVar6 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar10 = uVar10 + 1;\n    return CONCAT44(param_2 | uVar7 >> (uVar10 & 0xff),\n                    uVar5 >> (uVar10 & 0xff) | uVar7 << (0x20 - uVar10 & 0xff));\n  }\n  return CONCAT44(uVar9,uVar7 >> (uVar10 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000194", 
            "calling": [
                "readThermocouple", 
                "Compute", 
                "loop", 
                "printFloat", 
                "__aeabi_drsub"
            ], 
            "imported": false, 
            "current_name": "__aeabi_dadd"
        }, 
        "strlen": {
            "renaming": {}, 
            "code": "\nsize_t strlen(char *__s)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar3 = __s;\n  do {\n    pcVar2 = pcVar3 + 1;\n    cVar1 = *pcVar3;\n    pcVar3 = pcVar2;\n  } while (cVar1 != '\\0');\n  return (size_t)(pcVar2 + (-1 - (int)__s));\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000178", 
            "calling": [
                "print", 
                "printNumber"
            ], 
            "imported": false, 
            "current_name": "strlen"
        }, 
        "HAL_TIM_PWM_DeInit": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)\n\n{\n  TIM_TypeDef *pTVar1;\n  \n  htim->State = HAL_TIM_STATE_BUSY;\n  pTVar1 = htim->Instance;\n  if (((pTVar1->CCER & 0x1111) == 0) && ((pTVar1->CCER & 0x444) == 0)) {\n    pTVar1->CR1 = pTVar1->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(htim);\n  htim->State = HAL_TIM_STATE_RESET;\n  htim->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003ed8", 
            "calling": [
                "pwm_stop"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_DeInit"
        }, 
        "HAL_UART_ErrorCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)\n\n{\n  uint32_t tmpval;\n  \n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005650", 
            "calling": [
                "HAL_UART_IRQHandler", 
                "UART_DMAAbortOnError"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_ErrorCallback"
        }, 
        "loop": {
            "renaming": {}, 
            "code": "\nvoid loop(void)\n\n{\n  char cVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  uint32_t uVar4;\n  undefined *puVar5;\n  int iVar6;\n  undefined4 extraout_r1;\n  uint uVar7;\n  int digits;\n  int digits_00;\n  int digits_01;\n  undefined8 uVar8;\n  undefined4 in_stack_ffffffe4;\n  \n  uVar4 = millis();\n  if (*(uint *)PTR_nextRead_08000f50 < uVar4) {\n    *(uint *)PTR_nextRead_08000f50 = *(uint *)PTR_nextRead_08000f50 + 1000;\n    puVar5 = PTR_thermocouple_08000f74;\n    MAX31855::readThermocouple((MAX31855 *)PTR_thermocouple_08000f74,CELSIUS);\n    puVar2 = PTR_input_08000f6c;\n    *(undefined **)PTR_input_08000f6c = puVar5;\n    *(undefined4 *)(puVar2 + 4) = extraout_r1;\n    iVar6 = __aeabi_dcmpeq();\n    if (((iVar6 != 0) ||\n        (iVar6 = __aeabi_dcmpeq(puVar5,extraout_r1,DAT_08000f20,DAT_08000f24), iVar6 != 0)) ||\n       (iVar6 = __aeabi_dcmpeq(puVar5,extraout_r1,DAT_08000f28,DAT_08000f2c), iVar6 != 0)) {\n      *PTR_reflowState_08000f64 = 7;\n      *PTR_reflowStatus_08000f58 = 0;\n    }\n  }\n  uVar4 = millis();\n  if (*(uint *)PTR_nextCheck_08000f54 < uVar4) {\n    *(uint *)PTR_nextCheck_08000f54 = *(uint *)PTR_nextCheck_08000f54 + 1000;\n    if (*PTR_reflowStatus_08000f58 == '\\x01') {\n      uVar4 = *(uint32_t *)PTR_ledRedPin_08000f5c;\n      iVar6 = digitalRead(uVar4);\n      uVar7 = count_leading_zeroes(iVar6);\n      digitalWrite(uVar4,uVar7 >> 5);\n      iVar6 = *(int *)PTR_timerSeconds_08000f78;\n      *(int *)PTR_timerSeconds_08000f78 = iVar6 + 1;\n      puVar2 = PTR_Serial2_08000f7c;\n      Print::print((Print *)PTR_Serial2_08000f7c,iVar6 + 1,10);\n      puVar5 = PTR_DAT_08000f80;\n      Print::print((Print *)puVar2,PTR_DAT_08000f80);\n      Print::print((Print *)puVar2,(double)CONCAT44(in_stack_ffffffe4,2),digits);\n      Print::print((Print *)puVar2,puVar5);\n      Print::print((Print *)puVar2,(double)CONCAT44(in_stack_ffffffe4,2),digits_00);\n      Print::print((Print *)puVar2,puVar5);\n      Print::println((Print *)puVar2,(double)CONCAT44(in_stack_ffffffe4,2),digits_01);\n    }\n    else {\n      digitalWrite(*(uint32_t *)PTR_ledRedPin_08000f5c,1);\n    }\n    puVar2 = PTR_lcd_08000f60;\n    LiquidCrystal::clear((LiquidCrystal *)PTR_lcd_08000f60);\n    puVar3 = PTR_reflowState_08000f64;\n    Print::print((Print *)puVar2,\n                 *(char **)(PTR_lcdMessagesReflowStatus_08000f68 +\n                           (uint)(byte)*PTR_reflowState_08000f64 * 4));\n    LiquidCrystal::setCursor((LiquidCrystal *)puVar2,'\\0','\\x01');\n    puVar5 = PTR_lcd_08000f60;\n    if (*puVar3 == '\\a') {\n      Print::print((Print *)puVar2,PTR_s_TC_Error__08000f8c);\n    }\n    else {\n      Print::print((Print *)PTR_lcd_08000f60,(double)CONCAT44(in_stack_ffffffe4,2),2);\n      LiquidCrystal::write((LiquidCrystal *)puVar5,'\\0');\n      Print::print((Print *)puVar5,PTR_DAT_08000f70);\n    }\n  }\n  if ((byte)*PTR_reflowState_08000f64 < 8) {\n                    /* WARNING: Could not recover jumptable at 0x08000d5c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*(code *)(&switchD_08000d5c::switchdataD_08000d60 +\n              (&switchD_08000d5c::switchdataD_08000d60)[(byte)*PTR_reflowState_08000f64]))();\n    return;\n  }\n  if ((*PTR_switchStatus_08001274 == '\\x01') && (*PTR_reflowStatus_0800126c == '\\x01')) {\n    *PTR_reflowStatus_0800126c = 0;\n    *PTR_reflowState_08001258 = 0;\n  }\n  cVar1 = *PTR_debounceState_08001278;\n  if (cVar1 == '\\x01') {\n    uVar4 = analogRead(*(uint32_t *)PTR_switchPin_08001280);\n    if (uVar4 == 0) {\n      uVar4 = millis();\n      if (0x32 < uVar4 - *(int *)PTR_lastDebounceTime_08001284) {\n        *PTR_debounceState_08001278 = 2;\n      }\n    }\n    else {\n      *PTR_debounceState_08001278 = 0;\n    }\n  }\n  else if (cVar1 == '\\0') {\n    *PTR_switchStatus_08001274 = 0;\n    uVar4 = analogRead(*(uint32_t *)PTR_switchPin_08001280);\n    if (uVar4 == 0) {\n      uVar4 = millis();\n      *(uint32_t *)PTR_lastDebounceTime_08001284 = uVar4;\n      *PTR_debounceState_08001278 = 1;\n    }\n  }\n  else if ((cVar1 == '\\x02') &&\n          (uVar4 = analogRead(*(uint32_t *)PTR_switchPin_08001280), uVar4 != 0)) {\n    *PTR_switchStatus_08001274 = 1;\n    *PTR_debounceState_08001278 = 0;\n  }\n  if (*PTR_reflowStatus_0800126c == '\\x01') {\n    uVar4 = millis();\n    PID::Compute((PID *)PTR_reflowOvenPID_08001250);\n    if (*(uint *)PTR_windowSize_0800128c < uVar4 - *(int *)PTR_windowStartTime_08001288) {\n      *(uint *)PTR_windowStartTime_08001288 =\n           *(int *)PTR_windowStartTime_08001288 + *(uint *)PTR_windowSize_0800128c;\n    }\n    uVar8 = __floatunsidf(uVar4 - *(int *)PTR_windowStartTime_08001288);\n    iVar6 = __aeabi_dcmplt((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),\n                           *(undefined4 *)PTR_output_08001290,\n                           *(undefined4 *)(PTR_output_08001290 + 4));\n    if (iVar6 == 0) {\n      digitalWrite(*(uint32_t *)PTR_ssrPin_0800127c,0);\n    }\n    else {\n      digitalWrite(*(uint32_t *)PTR_ssrPin_0800127c,1);\n    }\n  }\n  else {\n    digitalWrite(*(uint32_t *)PTR_ssrPin_0800127c,0);\n  }\n  return;\n}\n\n", 
            "called": [
                "SetMode", 
                "digitalWrite", 
                "SetTunings", 
                "__aeabi_dcmple", 
                "println", 
                "millis", 
                "__aeabi_dcmpeq", 
                "SetSampleTime", 
                "print", 
                "analogRead", 
                "setCursor", 
                "clear", 
                "print", 
                "__aeabi_dadd", 
                "__aeabi_dcmpgt", 
                "__floatsidf", 
                "readThermocouple", 
                "println", 
                "__aeabi_dcmpge", 
                "write", 
                "SetOutputLimits", 
                "Compute", 
                "digitalRead", 
                "__aeabi_dcmplt", 
                "__floatunsidf", 
                "print"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000cd0", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "loop"
        }, 
        "_exit": {
            "renaming": {}, 
            "code": "\nvoid _exit(int status_UNUSED)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [
                "_exit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800573c", 
            "calling": [
                "_exit", 
                "abort"
            ], 
            "imported": false, 
            "current_name": "_exit"
        }, 
        "_close_r": {
            "renaming": {}, 
            "code": "\nvoid _close_r(int *param_1,int param_2)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_08007000;\n  *(undefined4 *)PTR_errno_08007000 = 0;\n  iVar2 = _close(param_2);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_close"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006fe4", 
            "calling": [
                "__sclose"
            ], 
            "imported": false, 
            "current_name": "_close_r"
        }, 
        "_sbrk_r": {
            "renaming": {}, 
            "code": "\nvoid _sbrk_r(int *param_1,int param_2)\n\n{\n  undefined *puVar1;\n  caddr_t pcVar2;\n  \n  puVar1 = PTR_errno_0800693c;\n  *(undefined4 *)PTR_errno_0800693c = 0;\n  pcVar2 = _sbrk(param_2);\n  if ((pcVar2 == (caddr_t)0xffffffff) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_sbrk"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006920", 
            "calling": [
                "_malloc_r"
            ], 
            "imported": false, 
            "current_name": "_sbrk_r"
        }, 
        "_read_r": {
            "renaming": {}, 
            "code": "\nvoid _read_r(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_0800708c;\n  *(undefined4 *)PTR_errno_0800708c = 0;\n  iVar2 = _read(param_2,param_3,param_4);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_read"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800706c", 
            "calling": [
                "__sread"
            ], 
            "imported": false, 
            "current_name": "_read_r"
        }, 
        "__libc_init_array": {
            "renaming": {}, 
            "code": "\nvoid __libc_init_array(void)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  int iVar3;\n  \n  puVar1 = PTR___preinit_array_end_080061d0;\n  iVar2 = (int)PTR___preinit_array_end_080061d4 - (int)PTR___preinit_array_end_080061d0;\n  for (iVar3 = 0; iVar3 != iVar2 >> 2; iVar3 = iVar3 + 1) {\n    (**(code **)(puVar1 + iVar3 * 4))();\n  }\n  _init();\n  puVar1 = PTR___preinit_array_end_080061d8;\n  iVar2 = (int)PTR___do_global_dtors_aux_fini_array_entry_080061dc -\n          (int)PTR___preinit_array_end_080061d8;\n  for (iVar3 = 0; iVar3 != iVar2 >> 2; iVar3 = iVar3 + 1) {\n    (**(code **)(puVar1 + iVar3 * 4))();\n  }\n  return;\n}\n\n", 
            "called": [
                "premain", 
                "_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006198", 
            "calling": [
                "Reset_Handler"
            ], 
            "imported": false, 
            "current_name": "__libc_init_array"
        }, 
        "HAL_I2C_SlaveTxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002c52", 
            "calling": [
                "I2C_Slave_AF", 
                "I2C_SlaveTransmit_TXE"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_SlaveTxCpltCallback"
        }, 
        "SetOutputLimits": {
            "renaming": {}, 
            "code": "\nvoid PID::SetOutputLimits(PID *this,double Min,double Max)\n\n{\n  int iVar1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  double *pdVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  \n  iVar1 = __aeabi_dcmpge();\n  if (iVar1 == 0) {\n    *(undefined4 *)&this->outMin = in_r2;\n    *(undefined4 *)((int)&this->outMin + 4) = in_r3;\n    this->outMax = Min;\n    if (this->inAuto != false) {\n      pdVar2 = this->myOutput;\n      iVar1 = __aeabi_dcmplt(Min._0_4_,Min._4_4_,*(undefined4 *)pdVar2,\n                             *(undefined4 *)((int)pdVar2 + 4));\n      if (iVar1 == 0) {\n        iVar1 = __aeabi_dcmpgt();\n        if (iVar1 != 0) {\n          *(undefined4 *)pdVar2 = in_r2;\n          *(undefined4 *)((int)pdVar2 + 4) = in_r3;\n        }\n      }\n      else {\n        *pdVar2 = Min;\n      }\n      uVar3 = *(undefined4 *)&this->outputSum;\n      uVar4 = *(undefined4 *)((int)&this->outputSum + 4);\n      uVar5 = *(undefined4 *)&this->outMax;\n      uVar6 = *(undefined4 *)((int)&this->outMax + 4);\n      iVar1 = __aeabi_dcmpgt(uVar3,uVar4,uVar5,uVar6);\n      if (iVar1 != 0) {\n        *(undefined4 *)&this->outputSum = uVar5;\n        *(undefined4 *)((int)&this->outputSum + 4) = uVar6;\n        return;\n      }\n      uVar5 = *(undefined4 *)&this->outMin;\n      uVar6 = *(undefined4 *)((int)&this->outMin + 4);\n      iVar1 = __aeabi_dcmplt(uVar3,uVar4,uVar5,uVar6);\n      if (iVar1 != 0) {\n        *(undefined4 *)&this->outputSum = uVar5;\n        *(undefined4 *)((int)&this->outputSum + 4) = uVar6;\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "__aeabi_dcmpge", 
                "__aeabi_dcmpgt", 
                "__aeabi_dcmplt"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001960", 
            "calling": [
                "PID", 
                "loop"
            ], 
            "imported": false, 
            "current_name": "SetOutputLimits"
        }, 
        "HAL_UART_TxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)\n\n{\n  byte bVar1;\n  int iVar3;\n  int iVar4;\n  uint uVar2;\n  \n  bVar1 = uart_index(huart);\n  uVar2 = (uint)bVar1;\n  iVar4 = *(int *)(PTR_tx_callback_obj_08005644 + uVar2 * 4);\n  if ((uVar2 < 5) &&\n     (iVar3 = (**(code **)(PTR_tx_callback_08005648 + uVar2 * 4))(iVar4), iVar3 != -1)) {\n    HAL_UART_Transmit_IT\n              (*(UART_HandleTypeDef **)\n                (PTR_uart_handlers_0800564c + (uint)*(byte *)(iVar4 + 0x44) * 4),\n               (uint8_t *)(*(int *)(iVar4 + 100) + (uint)*(ushort *)(iVar4 + 0x6a)),1);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_Transmit_IT", 
                "uart_index"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005604", 
            "calling": [
                "UART_EndTransmit_IT"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_TxCpltCallback"
        }, 
        "_getpid_r": {
            "renaming": {}, 
            "code": "\n__pid_t _getpid_r(void)\n\n{\n  return 1;\n}\n\n", 
            "called": [
                "_getpid"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006f34", 
            "calling": [
                "_raise_r"
            ], 
            "imported": false, 
            "current_name": "_getpid_r"
        }, 
        "__sclose": {
            "renaming": {}, 
            "code": "\nvoid __sclose(undefined4 param_1,int param_2)\n\n{\n  _close_r(param_1,(int)*(short *)(param_2 + 0xe));\n  return;\n}\n\n", 
            "called": [
                "_close_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006fb6", 
            "calling": [], 
            "imported": false, 
            "current_name": "__sclose"
        }, 
        "HAL_RCC_GetPCLK1Freq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCC_GetPCLK1Freq(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = HAL_RCC_GetHCLKFreq();\n  return uVar1 >> PTR_APBPrescTable_08003c6c[(uint)(*(int *)(DAT_08003c68 + 4) << 0x15) >> 0x1d];\n}\n\n", 
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003c50", 
            "calling": [
                "UART_SetConfig"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetPCLK1Freq"
        }, 
        "__static_initialization_and_destruction_0": {
            "renaming": {}, 
            "code": "\nvoid __static_initialization_and_destruction_0(int __initialize_p,int __priority)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = PTR_gpio_irq_conf_08006068;\n  if (__initialize_p != 1) {\n    return;\n  }\n  if (__priority == 0xffff) {\n    *PTR_gpio_irq_conf_08006068 = 6;\n    *(undefined4 *)(puVar1 + 0xc) = 0;\n    puVar1[0x14] = 7;\n    *(undefined4 *)(puVar1 + 0x20) = 0;\n    puVar1[0x28] = 8;\n    *(undefined4 *)(puVar1 + 0x34) = 0;\n    puVar1[0x3c] = 9;\n    *(undefined4 *)(puVar1 + 0x48) = 0;\n    puVar1[0x50] = 10;\n    *(undefined4 *)(puVar1 + 0x5c) = 0;\n    puVar1[100] = 0x17;\n    *(undefined4 *)(puVar1 + 0x70) = 0;\n    puVar1[0x78] = 0x17;\n    *(undefined4 *)(puVar1 + 0x84) = 0;\n    puVar1[0x8c] = 0x17;\n    *(undefined4 *)(puVar1 + 0x98) = 0;\n    puVar1[0xa0] = 0x17;\n    *(undefined4 *)(puVar1 + 0xac) = 0;\n    puVar1[0xb4] = 0x17;\n    *(undefined4 *)(puVar1 + 0xc0) = 0;\n    puVar1[200] = 0x28;\n    *(undefined4 *)(puVar1 + 0xd4) = 0;\n    puVar1[0xdc] = 0x28;\n    *(undefined4 *)(puVar1 + 0xe8) = 0;\n    puVar1[0xf0] = 0x28;\n    *(undefined4 *)(puVar1 + 0xfc) = 0;\n    puVar1[0x104] = 0x28;\n    *(undefined4 *)(puVar1 + 0x110) = 0;\n    puVar1[0x118] = 0x28;\n    *(undefined4 *)(puVar1 + 0x124) = 0;\n    puVar1[300] = 0x28;\n    *(undefined4 *)(puVar1 + 0x138) = 0;\n    __aeabi_atexit(0,DAT_08006070,PTR___dso_handle_0800606c);\n  }\n  return;\n}\n\n", 
            "called": [
                "__aeabi_atexit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005fc8", 
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ], 
            "imported": false, 
            "current_name": "__static_initialization_and_destruction_0"
        }, 
        "UART_Receive_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict UART_Receive_IT(UART_HandleTypeDef *huart)\n\n{\n  byte *pbVar1;\n  uint16_t uVar2;\n  uint8_t *puVar3;\n  \n  if (huart->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((huart->Init).WordLength == 0x1000) {\n    if ((huart->Init).Parity == 0) {\n      *(ushort *)huart->pRxBuffPtr = (ushort)((huart->Instance->DR << 0x17) >> 0x17);\n      huart->pRxBuffPtr = huart->pRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)huart->pRxBuffPtr = (ushort)huart->Instance->DR & 0xff;\n      huart->pRxBuffPtr = huart->pRxBuffPtr + 1;\n    }\n  }\n  else if ((huart->Init).Parity == 0) {\n    puVar3 = huart->pRxBuffPtr;\n    huart->pRxBuffPtr = puVar3 + 1;\n    *puVar3 = (uint8_t)huart->Instance->DR;\n  }\n  else {\n    pbVar1 = huart->pRxBuffPtr;\n    huart->pRxBuffPtr = pbVar1 + 1;\n    *pbVar1 = (byte)huart->Instance->DR & 0x7f;\n  }\n  uVar2 = huart->RxXferCount - 1;\n  huart->RxXferCount = uVar2;\n  if (uVar2 != 0) {\n    return HAL_OK;\n  }\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xffffffdf;\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xfffffeff;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffffe;\n  huart->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(huart);\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_UART_RxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004618", 
            "calling": [
                "HAL_UART_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "UART_Receive_IT"
        }, 
        "FUN_080008ba": {
            "renaming": {}, 
            "code": "\nulonglong FUN_080008ba(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint in_r12;\n  bool bVar4;\n  \n  uVar2 = in_r12 & param_4 >> 0x14;\n  uVar3 = param_2;\n  if (unaff_r4 != in_r12 || uVar2 != in_r12) {\n    if (unaff_r4 == in_r12) {\n      if (((param_1 | param_2 << 0xc) == 0) && (param_1 = param_3, uVar3 = param_4, uVar2 != in_r12)\n         ) {\nLAB_0800072c:\n        return (ulonglong)((param_2 ^ param_4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (uVar2 == in_r12) {\n      param_1 = param_3;\n      uVar3 = param_4;\n      if ((param_3 | param_4 << 0xc) == 0) {\nLAB_080006f0:\n        return (ulonglong)((param_2 ^ param_4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      bVar4 = (param_1 | param_2 << 1) == 0;\n      if (!bVar4) {\n        bVar4 = (param_3 | param_4 << 1) == 0;\n      }\n      if (!bVar4) {\n        if (unaff_r4 == 0) {\n          uVar3 = param_2 & 0x80000000;\n          do {\n            uVar1 = param_1 & 0x80000000;\n            param_1 = param_1 << 1;\n            param_2 = param_2 * 2 + (uint)(uVar1 != 0);\n          } while ((param_2 & 0x100000) == 0);\n          param_2 = param_2 | uVar3;\n          if (uVar2 != 0) {\n            return CONCAT44(param_2,param_1);\n          }\n        }\n        do {\n          uVar3 = param_3 & 0x80000000;\n          param_3 = param_3 << 1;\n          param_4 = param_4 * 2 + (uint)(uVar3 != 0);\n        } while ((param_4 & 0x100000) == 0);\n        return CONCAT44(param_2,param_1);\n      }\n      if ((param_1 | param_2 << 1) != 0) goto LAB_0800072c;\n      if ((param_3 | param_4 << 1) != 0) goto LAB_080006f0;\n    }\n  }\n  return CONCAT44(uVar3,param_1) | 0x7ff8000000000000;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": false, 
            "entrypoint": "0x080008ba", 
            "calling": [
                "__divdf3"
            ], 
            "imported": false, 
            "current_name": "FUN_080008ba"
        }, 
        "SetControllerDirection": {
            "renaming": {}, 
            "code": "\nvoid __thiscall PID::SetControllerDirection(PID *this,int Direction)\n\n{\n  double dVar1;\n  \n  if ((this->inAuto != false) && (this->controllerDirection != Direction)) {\n    dVar1 = (double)__subdf3(0,0,*(undefined4 *)&this->kp,*(undefined4 *)((int)&this->kp + 4));\n    this->kp = dVar1;\n    dVar1 = (double)__subdf3(0,0,*(undefined4 *)&this->ki,*(undefined4 *)((int)&this->ki + 4));\n    this->ki = dVar1;\n    dVar1 = (double)__subdf3(0,0,*(undefined4 *)&this->kd,*(undefined4 *)((int)&this->kd + 4));\n    this->kd = dVar1;\n  }\n  this->controllerDirection = Direction;\n  return;\n}\n\n", 
            "called": [
                "__subdf3"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001a66", 
            "calling": [
                "PID"
            ], 
            "imported": false, 
            "current_name": "SetControllerDirection"
        }, 
        "HAL_GetTick": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_GetTick(void)\n\n{\n  return *(uint32_t *)PTR_uwTick_08001ccc;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001cc4", 
            "calling": [
                "GetCurrentMilli", 
                "HAL_ADC_PollForConversion", 
                "ADC_ConversionStop_Disable", 
                "UART_WaitOnFlagUntilTimeout", 
                "HAL_RCCEx_PeriphCLKConfig", 
                "uart_debug_write", 
                "HAL_ADCEx_Calibration_Start", 
                "HAL_RCC_ClockConfig", 
                "ADC_Enable", 
                "HAL_RCC_OscConfig", 
                "HAL_UART_Transmit"
            ], 
            "imported": false, 
            "current_name": "HAL_GetTick"
        }, 
        "EXTI9_5_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI9_5_IRQHandler(void)\n\n{\n  uint uVar1;\n  \n  for (uVar1 = 0x20; uVar1 < 0x201; uVar1 = uVar1 << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)uVar1);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080060a6", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI9_5_IRQHandler"
        }, 
        "I2C_Master_SB": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_Master_SB(I2C_HandleTypeDef *hi2c)\n\n{\n  if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n    if (hi2c->EventCount == 0) {\n      hi2c->Instance->DR = hi2c->Devaddress & 0xfe;\n    }\n    else {\n      hi2c->Instance->DR = hi2c->Devaddress & 0xff | 1;\n    }\n  }\n  else if ((hi2c->Init).AddressingMode == 0x4000) {\n    if (hi2c->State == HAL_I2C_STATE_BUSY_TX) {\n      hi2c->Instance->DR = hi2c->Devaddress & 0xfe;\n    }\n    else {\n      hi2c->Instance->DR = hi2c->Devaddress & 0xff | 1;\n    }\n  }\n  else if (hi2c->EventCount == 0) {\n    hi2c->Instance->DR = (hi2c->Devaddress << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (hi2c->EventCount == 1) {\n    hi2c->Instance->DR = (hi2c->Devaddress << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002848", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Master_SB"
        }, 
        "TIM_CCxChannelCmd": {
            "renaming": {}, 
            "code": "\nvoid TIM_CCxChannelCmd(TIM_TypeDef *TIMx,uint32_t Channel,uint32_t ChannelState)\n\n{\n  TIMx->CCER = TIMx->CCER & ~(1 << (Channel & 0xff));\n  TIMx->CCER = TIMx->CCER | ChannelState << (Channel & 0xff);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004092", 
            "calling": [
                "HAL_TIM_PWM_Stop"
            ], 
            "imported": false, 
            "current_name": "TIM_CCxChannelCmd"
        }, 
        "__eqdf2": {
            "renaming": {}, 
            "code": "\nuint __eqdf2(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  \n  if (((int)(param_2 << 1) >> 0x15 == -1 || (int)(param_4 << 1) >> 0x15 == -1) &&\n     ((((int)(param_2 << 1) >> 0x15 == -1 && ((param_1 | param_2 << 0xc) != 0)) ||\n      (((int)(param_4 << 1) >> 0x15 == -1 && ((param_3 | param_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  bVar2 = (param_1 | param_2 << 1) == 0;\n  if (bVar2) {\n    bVar2 = (param_3 | param_4 << 1) == 0;\n  }\n  if (!bVar2) {\n    bVar2 = param_2 == param_4;\n  }\n  if (bVar2) {\n    bVar2 = param_1 == param_3;\n  }\n  if (!bVar2) {\n    uVar1 = param_2 ^ param_4;\n    bVar2 = uVar1 == 0;\n    if (-1 < (int)uVar1) {\n      bVar2 = param_2 == param_4;\n    }\n    bVar3 = -1 < (int)uVar1 && param_4 <= param_2;\n    if (bVar2) {\n      bVar3 = param_3 <= param_1;\n    }\n    param_4 = (int)param_4 >> 0x1f;\n    if (!bVar3) {\n      param_4 = ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800092c", 
            "calling": [
                "__aeabi_cdcmpeq"
            ], 
            "imported": false, 
            "current_name": "__eqdf2"
        }, 
        "get_timer_obj": {
            "renaming": {}, 
            "code": "\nstimer_t * get_timer_obj(TIM_HandleTypeDef *htim)\n\n{\n  return (stimer_t *)&htim[-1].Lock;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004df4", 
            "calling": [
                "HAL_TIM_OC_DelayElapsedCallback", 
                "HAL_TIM_PeriodElapsedCallback"
            ], 
            "imported": false, 
            "current_name": "get_timer_obj"
        }, 
        "I2C1_EV_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid I2C1_EV_IRQHandler(void)\n\n{\n  HAL_I2C_EV_IRQHandler(*(I2C_HandleTypeDef **)PTR_i2c_handles_08004f18);\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004f0c", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C1_EV_IRQHandler"
        }, 
        "abort": {
            "renaming": {}, 
            "code": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n  raise(6);\n                    /* WARNING: Subroutine does not return */\n  _exit(1);\n}\n\n", 
            "called": [
                "raise", 
                "_exit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006ac0", 
            "calling": [
                "__throw_bad_function_call", 
                "__assert_func"
            ], 
            "imported": false, 
            "current_name": "abort"
        }, 
        "get_GPIO_Port": {
            "renaming": {}, 
            "code": "\nGPIO_TypeDef * get_GPIO_Port(uint32_t port_idx)\n\n{\n  switch(port_idx) {\n  case 0:\n    return DAT_08004870;\n  case 1:\n    return DAT_08004880;\n  case 2:\n    return DAT_08004874;\n  case 3:\n    return DAT_08004878;\n  case 4:\n    return DAT_0800487c;\n  default:\n    return (GPIO_TypeDef *)0x0;\n  }\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004848", 
            "calling": [
                "digitalWrite", 
                "digitalRead"
            ], 
            "imported": false, 
            "current_name": "get_GPIO_Port"
        }, 
        "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm": {
            "renaming": {}, 
            "code": "\nvoid _GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n", 
            "called": [
                "__static_initialization_and_destruction_0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006104", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
        }, 
        "_isatty_r": {
            "renaming": {}, 
            "code": "\nvoid _isatty_r(int *param_1,int param_2)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_08007044;\n  *(undefined4 *)PTR_errno_08007044 = 0;\n  iVar2 = _isatty(param_2);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_isatty"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007028", 
            "calling": [
                "__smakebuf_r"
            ], 
            "imported": false, 
            "current_name": "_isatty_r"
        }, 
        "aflCall": {
            "renaming": {}, 
            "code": "\nuint32_t aflCall(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000ae8", 
            "calling": [
                "startForkserver"
            ], 
            "imported": false, 
            "current_name": "aflCall"
        }, 
        "HAL_GPIO_EXTI_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)\n\n{\n  if ((*(uint *)(DAT_08002844 + 0x14) & (uint)GPIO_Pin) != 0) {\n    *(uint *)(DAT_08002844 + 0x14) = (uint)GPIO_Pin;\n    HAL_GPIO_EXTI_Callback(GPIO_Pin);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800282c", 
            "calling": [
                "EXTI1_IRQHandler", 
                "EXTI9_5_IRQHandler", 
                "EXTI15_10_IRQHandler", 
                "EXTI0_IRQHandler", 
                "EXTI2_IRQHandler", 
                "EXTI3_IRQHandler", 
                "EXTI4_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_EXTI_IRQHandler"
        }, 
        "__sread": {
            "renaming": {}, 
            "code": "\nvoid __sread(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  bool bVar3;\n  \n  iVar1 = _read_r(param_1,(int)*(short *)(param_2 + 0xe));\n  bVar3 = -1 < iVar1;\n  if (bVar3) {\n    uVar2 = *(int *)(param_2 + 0x54) + iVar1;\n  }\n  else {\n    uVar2 = *(ushort *)(param_2 + 0xc) & 0xffffefff;\n  }\n  if (bVar3) {\n    *(uint *)(param_2 + 0x54) = uVar2;\n  }\n  if (!bVar3) {\n    *(short *)(param_2 + 0xc) = (short)uVar2;\n  }\n  return;\n}\n\n", 
            "called": [
                "_read_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006f38", 
            "calling": [], 
            "imported": false, 
            "current_name": "__sread"
        }, 
        "Reset_Handler": {
            "renaming": {}, 
            "code": "\nvoid Reset_Handler(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (iVar1 = 0; puVar2 = (undefined4 *)PTR_completed_8667_08001c28,\n      PTR___dso_handle_08001c20 + iVar1 < PTR__edata_08001c24; iVar1 = iVar1 + 4) {\n    *(undefined4 *)(PTR___dso_handle_08001c20 + iVar1) =\n         *(undefined4 *)(PTR__sidata_08001c1c + iVar1);\n  }\n  for (; puVar2 < PTR__ebss_08001c2c; puVar2 = puVar2 + 1) {\n    *puVar2 = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  UNRECOVERED_JUMPTABLE = (code *)0x8001c1a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08001c1a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n", 
            "called": [
                "SystemInit", 
                "main", 
                "__libc_init_array"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001be8", 
            "calling": [], 
            "imported": false, 
            "current_name": "Reset_Handler"
        }, 
        "HAL_ADC_ConfigChannel": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc,ADC_ChannelConfTypeDef *sConfig)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint uVar2;\n  ADC_TypeDef *pAVar3;\n  uint32_t wait_loop_index;\n  \n  if (hadc->Lock == HAL_LOCKED) {\n    HVar1 = HAL_BUSY;\n  }\n  else {\n    hadc->Lock = HAL_LOCKED;\n    uVar2 = sConfig->Rank;\n    if (uVar2 < 7) {\n      uVar2 = uVar2 * 5 - 5;\n      hadc->Instance->SQR3 =\n           sConfig->Channel << (uVar2 & 0xff) | hadc->Instance->SQR3 & ~(0x1f << (uVar2 & 0xff));\n    }\n    else if (uVar2 < 0xd) {\n      uVar2 = uVar2 * 5 - 0x23;\n      hadc->Instance->SQR2 =\n           sConfig->Channel << (uVar2 & 0xff) | hadc->Instance->SQR2 & ~(0x1f << (uVar2 & 0xff));\n    }\n    else {\n      uVar2 = uVar2 * 5 - 0x41;\n      hadc->Instance->SQR1 =\n           sConfig->Channel << (uVar2 & 0xff) | hadc->Instance->SQR1 & ~(0x1f << (uVar2 & 0xff));\n    }\n    uVar2 = sConfig->Channel;\n    if (uVar2 < 10) {\n      hadc->Instance->SMPR2 =\n           sConfig->SamplingTime << (uVar2 * 3 & 0xff) |\n           hadc->Instance->SMPR2 & ~(7 << (uVar2 * 3 & 0xff));\n    }\n    else {\n      uVar2 = uVar2 * 3 - 0x1e;\n      hadc->Instance->SMPR1 =\n           sConfig->SamplingTime << (uVar2 & 0xff) | hadc->Instance->SMPR1 & ~(7 << (uVar2 & 0xff));\n    }\n    if (sConfig->Channel - 0x10 < 2) {\n      pAVar3 = hadc->Instance;\n      if (pAVar3 == DAT_08001f74) {\n        if ((pAVar3->CR2 & 0x800000) == 0) {\n          pAVar3->CR2 = pAVar3->CR2 | 0x800000;\n          if (sConfig->Channel == 0x10) {\n            for (wait_loop_index =\n                      (uint)((ulonglong)DAT_08001f7c *\n                             (ulonglong)*(uint *)PTR_SystemCoreClock_08001f78 >> 0x32) * 10;\n                wait_loop_index != 0; wait_loop_index = wait_loop_index - 1) {\n            }\n            HVar1 = HAL_OK;\n          }\n          else {\n            HVar1 = HAL_OK;\n          }\n        }\n        else {\n          HVar1 = HAL_OK;\n        }\n      }\n      else {\n        hadc->State = hadc->State | 0x20;\n        HVar1 = HAL_ERROR;\n      }\n    }\n    else {\n      HVar1 = HAL_OK;\n    }\n    hadc->Lock = HAL_UNLOCKED;\n  }\n  return HVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001e48", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_ConfigChannel"
        }, 
        "pinMode": {
            "renaming": {}, 
            "code": "\nvoid pinMode(uint32_t ulPin,uint32_t ulMode)\n\n{\n  _Bool _Var1;\n  PinName_conflict pin;\n  \n  if (ulPin < 0x3c) {\n    pin = PTR_digitalPin_08005838[ulPin];\n  }\n  else {\n    pin = NC;\n  }\n  if (pin != NC) {\n    _Var1 = is_pin_configured(pin,(uint32_t *)PTR_g_anOutputPinConfigured_0800583c);\n    if (_Var1) {\n      _Var1 = pin_in_pinmap(pin,(PinMap_conflict *)PTR_PinMap_PWM_08005840);\n      if (_Var1) {\n        pwm_stop(pin);\n      }\n      reset_pin_configured(pin,(uint32_t *)PTR_g_anOutputPinConfigured_0800583c);\n    }\n    switch(ulMode) {\n    case 0:\n      digital_io_init(pin,0,0);\n      break;\n    case 1:\n      digital_io_init(pin,1,0);\n      break;\n    case 2:\n      digital_io_init(pin,0,1);\n      break;\n    case 3:\n      digital_io_init(pin,0,2);\n    }\n    set_pin_configured(pin,(uint32_t *)PTR_g_digPinConfigured_08005844);\n  }\n  return;\n}\n\n", 
            "called": [
                "set_pin_configured", 
                "pin_in_pinmap", 
                "is_pin_configured", 
                "reset_pin_configured", 
                "digital_io_init", 
                "pwm_stop"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080057b4", 
            "calling": [
                "MAX31855", 
                "begin", 
                "setup"
            ], 
            "imported": false, 
            "current_name": "pinMode"
        }, 
        "set_GPIO_Port_Clock": {
            "renaming": {}, 
            "code": "\nGPIO_TypeDef * set_GPIO_Port_Clock(uint32_t port_idx)\n\n{\n  GPIO_TypeDef *pGVar1;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  \n  switch(port_idx) {\n  case 0:\n    *(uint *)(DAT_08004914 + 0x18) = *(uint *)(DAT_08004914 + 0x18) | 4;\n    pGVar1 = DAT_08004918;\n    break;\n  case 1:\n    *(uint *)(DAT_08004914 + 0x18) = *(uint *)(DAT_08004914 + 0x18) | 8;\n    pGVar1 = DAT_0800491c;\n    break;\n  case 2:\n    *(uint *)(DAT_08004914 + 0x18) = *(uint *)(DAT_08004914 + 0x18) | 0x10;\n    pGVar1 = DAT_08004920;\n    break;\n  case 3:\n    *(uint *)(DAT_08004914 + 0x18) = *(uint *)(DAT_08004914 + 0x18) | 0x20;\n    pGVar1 = DAT_08004924;\n    break;\n  case 4:\n    *(uint *)(DAT_08004914 + 0x18) = *(uint *)(DAT_08004914 + 0x18) | 0x40;\n    pGVar1 = DAT_08004928;\n    break;\n  default:\n    pGVar1 = (GPIO_TypeDef *)0x0;\n  }\n  return pGVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004884", 
            "calling": [
                "HAL_ADC_MspInit", 
                "uart_init", 
                "digital_io_init"
            ], 
            "imported": false, 
            "current_name": "set_GPIO_Port_Clock"
        }, 
        "_write_r": {
            "renaming": {}, 
            "code": "\nvoid _write_r(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_08006fe0;\n  *(undefined4 *)PTR_errno_08006fe0 = 0;\n  iVar2 = _write(param_2,param_3,param_4);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_write"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006fc0", 
            "calling": [
                "__swrite"
            ], 
            "imported": false, 
            "current_name": "_write_r"
        }, 
        "MAX31855": {
            "renaming": {}, 
            "code": "\nMAX31855 * __thiscall MAX31855::MAX31855(MAX31855 *this,uchar SO,uchar CS,uchar SCK)\n\n{\n  this->so = SO;\n  this->cs = CS;\n  this->sck = SCK;\n  pinMode((uint)SO,0);\n  pinMode((uint)this->cs,1);\n  pinMode((uint)this->sck,1);\n  digitalWrite((uint)this->cs,1);\n  digitalWrite((uint)this->sck,0);\n  return this;\n}\n\n", 
            "called": [
                "digitalWrite", 
                "pinMode"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800157c", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "MAX31855"
        }, 
        "HAL_I2C_MemTxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002db0", 
            "calling": [
                "I2C_MasterTransmit_TXE", 
                "I2C_MasterTransmit_BTF"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_MemTxCpltCallback"
        }, 
        "uart_debug_write": {
            "renaming": {}, 
            "code": "\nsize_t uart_debug_write(uint8_t *data,uint32_t size)\n\n{\n  PinName_conflict pin;\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  void *pvVar3;\n  uint32_t uVar4;\n  uint uVar5;\n  \n  uVar2 = HAL_GetTick();\n  pin = PTR_digitalPin_0800547c[1];\n  pvVar3 = pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_UART_TX_08005480);\n  if (pvVar3 == (void *)0x0) {\n    return 0;\n  }\n  uVar5 = 0;\n  while ((uVar5 < 5 &&\n         ((*(int *)(PTR_uart_handlers_08005484 + uVar5 * 4) == 0 ||\n          (pvVar3 = pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_UART_TX_08005480),\n          **(void ***)(PTR_uart_handlers_08005484 + uVar5 * 4) != pvVar3))))) {\n    uVar5 = uVar5 + 1 & 0xff;\n  }\n  if (4 < uVar5) {\n    if ((4 < (byte)PTR_serial_debug_08005488[0x44]) &&\n       (uart_debug_init(), 4 < (byte)PTR_serial_debug_08005488[0x44])) {\n      return 0;\n    }\n    uVar5 = (uint)(byte)PTR_serial_debug_08005488[0x44];\n  }\n  do {\n    HVar1 = HAL_UART_Transmit(*(UART_HandleTypeDef **)(PTR_uart_handlers_08005484 + uVar5 * 4),data,\n                              (uint16_t)size,1000);\n    if (HVar1 == HAL_OK) {\n      return size;\n    }\n    uVar4 = HAL_GetTick();\n  } while (uVar4 - uVar2 < 1000);\n  return 0;\n}\n\n", 
            "called": [
                "uart_debug_init", 
                "pinmap_peripheral", 
                "HAL_GetTick", 
                "HAL_UART_Transmit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080053d4", 
            "calling": [
                "_write"
            ], 
            "imported": false, 
            "current_name": "uart_debug_write"
        }, 
        "HAL_SYSTICK_CLKSourceConfig": {
            "renaming": {}, 
            "code": "\nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)\n\n{\n  if (CLKSource != 4) {\n    *DAT_0800257c = *DAT_0800257c & 0xfffffffb;\n    return;\n  }\n  *DAT_0800257c = *DAT_0800257c | 4;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002560", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_CLKSourceConfig"
        }, 
        "LiquidCrystal": {
            "renaming": {}, 
            "code": "\nLiquidCrystal * __thiscall\nLiquidCrystal::LiquidCrystal\n          (LiquidCrystal *this,uint8_t rs,uint8_t enable,uint8_t d0,uint8_t d1,uint8_t d2,uint8_t d3\n          )\n\n{\n  (this->super_Print).write_error = 0;\n  (this->super_Print)._vptr_Print = (_func_int_varargs **)PTR_PTR_write_1_0800154c;\n  init(this,'\\x01',rs,0xff,enable,d0,d1,d2,d3,'\\0','\\0','\\0','\\0');\n  return this;\n}\n\n", 
            "called": [
                "init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001510", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "LiquidCrystal"
        }, 
        "setRx": {
            "renaming": {}, 
            "code": "\nvoid __thiscall HardwareSerial::setRx(HardwareSerial *this,uint32_t _rx)\n\n{\n  PinName PVar1;\n  \n  if (_rx < 0x3c) {\n    PVar1 = PTR_digitalPin_08005b38[_rx];\n  }\n  else {\n    PVar1 = NC;\n  }\n  (this->_serial).pin_rx = PVar1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005b24", 
            "calling": [
                "HardwareSerial"
            ], 
            "imported": false, 
            "current_name": "setRx"
        }, 
        "_GLOBAL__sub_I_lcdMessagesReflowStatus": {
            "renaming": {}, 
            "code": "\nvoid _GLOBAL__sub_I_lcdMessagesReflowStatus(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n", 
            "called": [
                "__static_initialization_and_destruction_0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000cbc", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I_lcdMessagesReflowStatus"
        }, 
        "I2C2_EV_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid I2C2_EV_IRQHandler(void)\n\n{\n  HAL_I2C_EV_IRQHandler(*(I2C_HandleTypeDef **)(PTR_i2c_handles_08004f38 + 4));\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004f2c", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C2_EV_IRQHandler"
        }, 
        "flush": {
            "renaming": {}, 
            "code": "\nvoid __thiscall HardwareSerial::flush(HardwareSerial *this)\n\n{\n  if (this->_written != false) {\n    do {\n    } while ((this->_serial).tx_head != (this->_serial).tx_tail);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005976", 
            "calling": [], 
            "imported": false, 
            "current_name": "flush"
        }, 
        "HAL_RTC_AlarmAEventCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)\n\n{\n  if (*(code **)PTR_RTCUserCallback_08004d28 != (code *)0x0) {\n    (**(code **)PTR_RTCUserCallback_08004d28)(*(undefined4 *)PTR_callbackUserData_08004d2c);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004d18", 
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_RTC_AlarmAEventCallback"
        }, 
        "_sbrk": {
            "renaming": {}, 
            "code": "\ncaddr_t _sbrk(int incr)\n\n{\n  caddr_t pcVar1;\n  caddr_t pcVar2;\n  \n  if (*(int *)PTR_heap_end_08005708 == 0) {\n    *(undefined **)PTR_heap_end_08005708 = PTR__ebss_0800570c;\n  }\n  pcVar1 = *(caddr_t *)PTR_heap_end_08005708;\n  pcVar2 = pcVar1 + incr;\n  if (pcVar2 <= &stack0x00000000) {\n    *(caddr_t *)PTR_heap_end_08005708 = pcVar2;\n    return pcVar1;\n  }\n  *(undefined4 *)PTR_errno_08005710 = 0xc;\n  return (caddr_t)0xffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080056d8", 
            "calling": [
                "_sbrk_r"
            ], 
            "imported": false, 
            "current_name": "_sbrk"
        }, 
        "UART_EndRxTransfer": {
            "renaming": {}, 
            "code": "\nvoid UART_EndRxTransfer(UART_HandleTypeDef *huart)\n\n{\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xfffffedf;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffffe;\n  huart->RxState = HAL_UART_STATE_READY;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800417c", 
            "calling": [
                "HAL_UART_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "UART_EndRxTransfer"
        }, 
        "__cxa_atexit": {
            "renaming": {}, 
            "code": "\nlonglong __cxa_atexit(undefined4 param_1,uint param_2)\n\n{\n  if (DAT_08006170 != 0) {\n    return CONCAT44(param_1,2);\n  }\n  return (ulonglong)param_2 << 0x20;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006158", 
            "calling": [
                "__aeabi_atexit"
            ], 
            "imported": false, 
            "current_name": "__cxa_atexit"
        }, 
        "__aeabi_dcmpeq": {
            "renaming": {}, 
            "code": "\nbool __aeabi_dcmpeq(void)\n\n{\n  char in_ZR;\n  \n  __aeabi_cdcmpeq();\n  return in_ZR != '\\0';\n}\n\n", 
            "called": [
                "__aeabi_cdcmpeq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080009c8", 
            "calling": [
                "loop"
            ], 
            "imported": false, 
            "current_name": "__aeabi_dcmpeq"
        }, 
        "uart_debug_init": {
            "renaming": {}, 
            "code": "\nvoid uart_debug_init(void)\n\n{\n  PinName_conflict pin;\n  undefined *obj;\n  PinName_conflict PVar1;\n  void *pvVar2;\n  \n  pin = PTR_digitalPin_080053c4[1];\n  pvVar2 = pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_UART_TX_080053c8);\n  if (pvVar2 != (void *)0x0) {\n    pvVar2 = pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_UART_TX_080053c8);\n    PVar1 = pinmap_pin(pvVar2,(PinMap_conflict *)PTR_PinMap_UART_RX_080053cc);\n    obj = PTR_serial_debug_080053d0;\n    PTR_serial_debug_080053d0[0x59] = PVar1;\n    obj[0x58] = pin;\n    *(undefined4 *)(obj + 0x48) = 0x2580;\n    *(undefined4 *)(obj + 0x54) = 0;\n    *(undefined4 *)(obj + 0x4c) = 0;\n    *(undefined4 *)(obj + 0x50) = 0;\n    uart_init((serial_t *)obj);\n  }\n  return;\n}\n\n", 
            "called": [
                "pinmap_pin", 
                "uart_init", 
                "pinmap_peripheral"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005384", 
            "calling": [
                "uart_debug_write"
            ], 
            "imported": false, 
            "current_name": "uart_debug_init"
        }, 
        "HAL_DMA_Abort_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)\n\n{\n  undefined4 uVar1;\n  DMA_Channel_TypeDef *pDVar2;\n  \n  if (hdma->State != HAL_DMA_STATE_BUSY) {\n    hdma->ErrorCode = 4;\n    return HAL_ERROR;\n  }\n  hdma->Instance->CCR = hdma->Instance->CCR & 0xfffffff1;\n  hdma->Instance->CCR = hdma->Instance->CCR & 0xfffffffe;\n  pDVar2 = hdma->Instance;\n  if (pDVar2 == DAT_0800261c) {\n    uVar1 = 1;\n  }\n  else if (pDVar2 == (DMA_Channel_TypeDef *)&DAT_0800261c[1].CNDTR) {\n    uVar1 = 0x10;\n  }\n  else if (pDVar2 == (DMA_Channel_TypeDef *)&DAT_0800261c[2].CPAR) {\n    uVar1 = 0x100;\n  }\n  else if (pDVar2 == (DMA_Channel_TypeDef *)&DAT_0800261c[3].CMAR) {\n    uVar1 = 0x1000;\n  }\n  else if (pDVar2 == DAT_0800261c + 5) {\n    uVar1 = 0x10000;\n  }\n  else if (pDVar2 == (DMA_Channel_TypeDef *)&DAT_0800261c[6].CNDTR) {\n    uVar1 = 0x100000;\n  }\n  else {\n    uVar1 = 0x1000000;\n  }\n  *(undefined4 *)(DAT_08002620 + 4) = uVar1;\n  hdma->State = HAL_DMA_STATE_READY;\n  hdma->Lock = HAL_UNLOCKED;\n  if (hdma->XferAbortCallback != (_func_void___DMA_HandleTypeDef_ptr *)0x0) {\n    (*hdma->XferAbortCallback)(hdma);\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800258c", 
            "calling": [
                "I2C_ITError", 
                "HAL_UART_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_DMA_Abort_IT"
        }, 
        "HAL_UART_MspInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_MspInit(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004418", 
            "calling": [
                "HAL_UART_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_MspInit"
        }, 
        "_fwalk_reent": {
            "renaming": {}, 
            "code": "\nuint _fwalk_reent(int param_1,code *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  uint uVar1;\n  int iVar2;\n  int *piVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  \n  uVar5 = 0;\n  for (piVar3 = (int *)(param_1 + 0x48); piVar3 != (int *)0x0; piVar3 = (int *)*piVar3) {\n    iVar4 = piVar3[2];\n    iVar6 = piVar3[1];\n    while (iVar6 = iVar6 + -1, -1 < iVar6) {\n      if ((1 < *(ushort *)(iVar4 + 0xc)) && (iVar2 = *(short *)(iVar4 + 0xe) + 1, iVar2 != 0)) {\n        uVar1 = (*param_2)(param_1,iVar4,param_3,iVar2,param_4);\n        uVar5 = uVar5 | uVar1;\n      }\n      iVar4 = iVar4 + 0x68;\n    }\n  }\n  return uVar5;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006d8c", 
            "calling": [
                "_cleanup_r"
            ], 
            "imported": false, 
            "current_name": "_fwalk_reent"
        }, 
        "pinmap_peripheral": {
            "renaming": {}, 
            "code": "\nvoid * pinmap_peripheral(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  void *pvVar1;\n  \n  if (pin != NC) {\n    pvVar1 = pinmap_find_peripheral(pin,map);\n    return pvVar1;\n  }\n  return (void *)0x0;\n}\n\n", 
            "called": [
                "pinmap_find_peripheral"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004c78", 
            "calling": [
                "uart_debug_init", 
                "adc_read_value", 
                "uart_debug_write", 
                "uart_init", 
                "pwm_stop"
            ], 
            "imported": false, 
            "current_name": "pinmap_peripheral"
        }, 
        "SystemInit": {
            "renaming": {}, 
            "code": "\nvoid SystemInit(void)\n\n{\n  uint *puVar1;\n  \n  puVar1 = DAT_08004d84;\n  *DAT_08004d84 = *DAT_08004d84 | 1;\n  puVar1[1] = DAT_08004d88 & puVar1[1];\n  *puVar1 = *puVar1 & 0xfef6ffff;\n  *puVar1 = *puVar1 & 0xfffbffff;\n  puVar1[1] = puVar1[1] & 0xff80ffff;\n  puVar1[2] = 0x9f0000;\n  *(undefined4 *)(DAT_08004d8c + 8) = 0x8000000;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004d44", 
            "calling": [
                "Reset_Handler"
            ], 
            "imported": false, 
            "current_name": "SystemInit"
        }, 
        "uart_getc": {
            "renaming": {}, 
            "code": "\nint uart_getc(serial_t *obj,uchar *c)\n\n{\n  uint8_t uVar1;\n  \n  if (obj == (serial_t *)0x0) {\n    return -1;\n  }\n  uVar1 = serial_rx_active(obj);\n  if (uVar1 == '\\0') {\n    *c = obj->recv;\n    HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_0800550c + (uint)obj->index * 4),\n                        &obj->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n", 
            "called": [
                "serial_rx_active", 
                "HAL_UART_Receive_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080054d4", 
            "calling": [
                "_rx_complete_irq"
            ], 
            "imported": false, 
            "current_name": "uart_getc"
        }, 
        "readThermocouple": {
            "renaming": {}, 
            "code": "\ndouble __thiscall MAX31855::readThermocouple(MAX31855 *this,unit_t unit)\n\n{\n  ulong uVar1;\n  uint uVar2;\n  double extraout_d0;\n  double extraout_d0_00;\n  double dVar3;\n  ulonglong uVar4;\n  undefined8 uVar5;\n  \n  uVar1 = readData(this);\n  if ((uVar1 & 0x10000) == 0) {\n    uVar2 = uVar1 >> 0x12;\n    uVar4 = __floatunsidf(uVar2 & 0x1fff);\n    if ((uVar2 & 0x2000) != 0) {\n      uVar5 = __floatunsidf(~uVar2 & 0x1fff);\n      uVar4 = __aeabi_dadd((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),0,DAT_080016a0);\n      uVar4 = uVar4 & 0xffffffff | (ulonglong)((int)(uVar4 >> 0x20) + 0x80000000) << 0x20;\n    }\n    uVar5 = __muldf3((int)uVar4,(int)(uVar4 >> 0x20),0,DAT_080016a4);\n    dVar3 = extraout_d0_00;\n    if (unit == FAHRENHEIT) {\n      uVar5 = __muldf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),0,DAT_080016a8);\n      uVar5 = __divdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),0,DAT_080016ac);\n      dVar3 = (double)__aeabi_dadd((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),0,DAT_080016b0);\n      return dVar3;\n    }\n  }\n  else {\n    uVar2 = uVar1 & 7;\n    if (uVar2 == 2) {\n      return extraout_d0;\n    }\n    if (uVar2 == 4) {\n      return extraout_d0;\n    }\n    dVar3 = extraout_d0;\n    if (uVar2 != 1) {\n      return extraout_d0;\n    }\n  }\n  return dVar3;\n}\n\n", 
            "called": [
                "__muldf3", 
                "readData", 
                "__aeabi_dadd", 
                "__floatunsidf", 
                "__divdf3"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080015f8", 
            "calling": [
                "loop"
            ], 
            "imported": false, 
            "current_name": "readThermocouple"
        }, 
        "uart_attach_rx_callback": {
            "renaming": {}, 
            "code": "\nvoid uart_attach_rx_callback(serial_t *obj,_func_void_serial_t_ptr *callback)\n\n{\n  byte bVar1;\n  uint8_t uVar2;\n  \n  if (obj != (serial_t *)0x0) {\n    uVar2 = serial_rx_active(obj);\n    if (uVar2 == '\\0') {\n      bVar1 = obj->index;\n      *(_func_void_serial_t_ptr **)(PTR_rx_callback_0800555c + (uint)bVar1 * 4) = callback;\n      *(serial_t **)(PTR_rx_callback_obj_08005560 + (uint)bVar1 * 4) = obj;\n      HAL_NVIC_SetPriority(obj->irq,0,1);\n      HAL_NVIC_EnableIRQ(obj->irq);\n      HAL_UART_Receive_IT(*(UART_HandleTypeDef **)\n                           (PTR_uart_handlers_08005564 + (uint)obj->index * 4),&obj->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_NVIC_EnableIRQ", 
                "serial_rx_active", 
                "HAL_UART_Receive_IT", 
                "HAL_NVIC_SetPriority"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005510", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "uart_attach_rx_callback"
        }, 
        "operator()": {
            "renaming": {}, 
            "code": "\nvoid __thiscall std::function<void()>::operator__(function_void___ *this)\n\n{\n  if ((this->super__Function_base)._M_manager != (_Manager_type)0x0) {\n    (*this->_M_invoker)((_Any_data *)this);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __throw_bad_function_call();\n}\n\n", 
            "called": [
                "__throw_bad_function_call"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080060d4", 
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ], 
            "imported": false, 
            "current_name": "operator()"
        }, 
        "pinmap_merge_peripheral": {
            "renaming": {}, 
            "code": "\nvoid * pinmap_merge_peripheral(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004d06", 
            "calling": [
                "uart_init"
            ], 
            "imported": false, 
            "current_name": "pinmap_merge_peripheral"
        }, 
        "HAL_I2C_AddrCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c,uint8_t TransferDirection,uint16_t AddrMatchCode)\n\n{\n  i2c_t *piVar1;\n  \n  piVar1 = get_i2c_obj(hi2c);\n  if ((uint)AddrMatchCode == (hi2c->Init).OwnAddress1) {\n    if (TransferDirection == '\\0') {\n      piVar1->i2cTxRxBufferSize = '\\0';\n      piVar1->slaveMode = '\\0';\n      if (piVar1->i2c_onSlaveTransmit != (_func_void *)0x0) {\n        (*piVar1->i2c_onSlaveTransmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT\n                (hi2c,piVar1->i2cTxRxBuffer,(ushort)piVar1->i2cTxRxBufferSize,8);\n      return;\n    }\n    piVar1->slaveMode = '\\x01';\n    HAL_I2C_Slave_Sequential_Receive_IT(hi2c,piVar1->i2cTxRxBuffer,0x20,8);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_Slave_Sequential_Receive_IT", 
                "get_i2c_obj", 
                "HAL_I2C_Slave_Sequential_Transmit_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004e74", 
            "calling": [
                "I2C_Slave_ADDR"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_AddrCallback"
        }, 
        "UART_SetConfig": {
            "renaming": {}, 
            "code": "\nvoid UART_SetConfig(UART_HandleTypeDef *huart)\n\n{\n  ulonglong uVar1;\n  uint uVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint32_t uVar5;\n  uint32_t uVar6;\n  uint32_t uVar7;\n  uint32_t uVar8;\n  uint32_t uVar9;\n  uint32_t uVar10;\n  uint32_t uVar11;\n  USART_TypeDef *pUVar12;\n  \n  huart->Instance->CR2 = huart->Instance->CR2 & 0xffffcfff | (huart->Init).StopBits;\n  huart->Instance->CR1 =\n       (huart->Init).WordLength | (huart->Init).Parity | (huart->Init).Mode |\n       huart->Instance->CR1 & 0xffffe9f3;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffcff | (huart->Init).HwFlowCtl;\n  pUVar12 = huart->Instance;\n  if (pUVar12 != DAT_080043ac) {\n    uVar3 = HAL_RCC_GetPCLK1Freq();\n    uVar2 = DAT_080043b0;\n    uVar8 = (huart->Init).BaudRate;\n    uVar1 = (ulonglong)DAT_080043b0;\n    uVar4 = HAL_RCC_GetPCLK1Freq();\n    uVar9 = (huart->Init).BaudRate;\n    uVar5 = HAL_RCC_GetPCLK1Freq();\n    uVar10 = (huart->Init).BaudRate;\n    uVar6 = HAL_RCC_GetPCLK1Freq();\n    uVar11 = (huart->Init).BaudRate;\n    uVar7 = HAL_RCC_GetPCLK1Freq();\n    pUVar12->BRR = ((uint)((int)((ulonglong)uVar2 *\n                                 (ulonglong)\n                                 (((uVar6 * 0x19) / (uVar11 << 2) +\n                                  (uint)((ulonglong)uVar2 *\n                                         ((ulonglong)(uVar7 * 0x19) /\n                                         (ulonglong)((huart->Init).BaudRate << 2)) >> 0x25) * -100)\n                                  * 0x10 + 0x32) >> 0x20) << 0x17) >> 0x1c) +\n                   ((uint)((ulonglong)uVar2 *\n                           (ulonglong)\n                           (((uVar4 * 0x19) / (uVar9 << 2) +\n                            (uint)((ulonglong)uVar2 *\n                                   ((ulonglong)(uVar5 * 0x19) / (ulonglong)(uVar10 << 2)) >> 0x25) *\n                            -100) * 0x10 + 0x32) >> 0x25) & 0xf0) +\n                   (uint)(uVar1 * ((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 << 2)) >> 0x25) *\n                   0x10;\n    return;\n  }\n  uVar3 = HAL_RCC_GetPCLK2Freq();\n  uVar2 = DAT_080043b0;\n  uVar8 = (huart->Init).BaudRate;\n  uVar1 = (ulonglong)DAT_080043b0;\n  uVar4 = HAL_RCC_GetPCLK2Freq();\n  uVar9 = (huart->Init).BaudRate;\n  uVar5 = HAL_RCC_GetPCLK2Freq();\n  uVar10 = (huart->Init).BaudRate;\n  uVar6 = HAL_RCC_GetPCLK2Freq();\n  uVar11 = (huart->Init).BaudRate;\n  uVar7 = HAL_RCC_GetPCLK2Freq();\n  pUVar12->BRR = ((uint)((int)((ulonglong)uVar2 *\n                               (ulonglong)\n                               (((uVar6 * 0x19) / (uVar11 << 2) +\n                                (uint)((ulonglong)uVar2 *\n                                       ((ulonglong)(uVar7 * 0x19) /\n                                       (ulonglong)((huart->Init).BaudRate << 2)) >> 0x25) * -100) *\n                                0x10 + 0x32) >> 0x20) << 0x17) >> 0x1c) +\n                 ((uint)((ulonglong)uVar2 *\n                         (ulonglong)\n                         (((uVar4 * 0x19) / (uVar9 << 2) +\n                          (uint)((ulonglong)uVar2 *\n                                 ((ulonglong)(uVar5 * 0x19) / (ulonglong)(uVar10 << 2)) >> 0x25) *\n                          -100) * 0x10 + 0x32) >> 0x25) & 0xf0) +\n                 (uint)(uVar1 * ((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 << 2)) >> 0x25) *\n                 0x10;\n  return;\n}\n\n", 
            "called": [
                "HAL_RCC_GetPCLK2Freq", 
                "HAL_RCC_GetPCLK1Freq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004204", 
            "calling": [
                "HAL_UART_Init"
            ], 
            "imported": false, 
            "current_name": "UART_SetConfig"
        }, 
        "is_pin_configured": {
            "renaming": {}, 
            "code": "\n_Bool is_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  return (_Bool)((byte)(map[(uint)((int)pin << 0x18) >> 0x1c] >> ((int)pin & 0xfU)) & 1);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080047f4", 
            "calling": [
                "digitalWrite", 
                "pinMode", 
                "digitalRead"
            ], 
            "imported": false, 
            "current_name": "is_pin_configured"
        }, 
        "reset_pin_configured": {
            "renaming": {}, 
            "code": "\nvoid reset_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)((int)pin << 0x18) >> 0x1c;\n  map[uVar1] = map[uVar1] & ~(1 << ((int)pin & 0xfU));\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004828", 
            "calling": [
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "reset_pin_configured"
        }, 
        "__aeabi_dcmpge": {
            "renaming": {}, 
            "code": "\nbool __aeabi_dcmpge(void)\n\n{\n  undefined in_ZR;\n  undefined in_CY;\n  \n  __aeabi_cdrcmple();\n  return !(bool)in_CY || (bool)in_ZR;\n}\n\n", 
            "called": [
                "__aeabi_cdrcmple"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000a04", 
            "calling": [
                "loop", 
                "SetOutputLimits"
            ], 
            "imported": false, 
            "current_name": "__aeabi_dcmpge"
        }, 
        "_kill_r": {
            "renaming": {}, 
            "code": "\nvoid _kill_r(int *param_1,int param_2,int param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_08006f30;\n  *(undefined4 *)PTR_errno_08006f30 = 0;\n  iVar2 = _kill(param_2,param_3);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_kill"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006f10", 
            "calling": [
                "_raise_r"
            ], 
            "imported": false, 
            "current_name": "_kill_r"
        }, 
        "HAL_RCC_ClockConfig": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_RCC_ClockConfig(RCC_ClkInitTypeDef_conflict *RCC_ClkInitStruct,uint32_t FLatency)\n\n{\n  uint *puVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  uint uVar4;\n  \n  puVar1 = DAT_08003c34;\n  if (((*DAT_08003c34 & 7) < FLatency) &&\n     (*DAT_08003c34 = *DAT_08003c34 & 0xfffffff8 | FLatency, FLatency != (*puVar1 & 7))) {\n    return HAL_ERROR;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 2) != 0) {\n    DAT_08003c38[1] = DAT_08003c38[1] & 0xffffff0f | RCC_ClkInitStruct->AHBCLKDivider;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 1) != 0) {\n    uVar4 = RCC_ClkInitStruct->SYSCLKSource;\n    if (uVar4 == 1) {\n      if ((*DAT_08003c38 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((uVar4 != 2) && ((*DAT_08003c38 & 2) == 0)) {\n      return HAL_ERROR;\n    }\n    DAT_08003c38[1] = uVar4 | DAT_08003c38[1] & 0xfffffffc;\n    uVar2 = HAL_GetTick();\n    if (RCC_ClkInitStruct->SYSCLKSource == 1) {\n      while ((DAT_08003c38[1] & 0xc) != 4) {\n        uVar3 = HAL_GetTick();\n        if (5000 < uVar3 - uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else if (RCC_ClkInitStruct->SYSCLKSource == 2) {\n      while ((DAT_08003c38[1] & 0xc) != 8) {\n        uVar3 = HAL_GetTick();\n        if (5000 < uVar3 - uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      while ((DAT_08003c38[1] & 0xc) != 0) {\n        uVar3 = HAL_GetTick();\n        if (5000 < uVar3 - uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  puVar1 = DAT_08003c34;\n  if ((FLatency < (*DAT_08003c34 & 7)) &&\n     (*DAT_08003c34 = *DAT_08003c34 & 0xfffffff8 | FLatency, FLatency != (*puVar1 & 7))) {\n    return HAL_ERROR;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 4) != 0) {\n    DAT_08003c38[1] = DAT_08003c38[1] & 0xfffff8ff | RCC_ClkInitStruct->APB1CLKDivider;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 8) != 0) {\n    DAT_08003c38[1] = DAT_08003c38[1] & 0xffffc7ff | RCC_ClkInitStruct->APB2CLKDivider << 3;\n  }\n  uVar4 = HAL_RCC_GetSysClockFreq();\n  *(uint *)PTR_SystemCoreClock_08003c40 =\n       uVar4 >> PTR_AHBPrescTable_08003c3c[(DAT_08003c38[1] << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_RCC_GetSysClockFreq", 
                "HAL_InitTick", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003ad4", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_ClockConfig"
        }, 
        "print": {
            "renaming": {}, 
            "code": "\nsize_t Print::print(Print *this,double n,int digits)\n\n{\n  size_t sVar1;\n  undefined4 in_stack_fffffff4;\n  \n  sVar1 = printFloat(this,(double)CONCAT44(in_stack_fffffff4,(uint)n._0_1_),n._0_1_);\n  return sVar1;\n}\n\n", 
            "called": [
                "printFloat"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005f2c", 
            "calling": [
                "loop", 
                "println"
            ], 
            "imported": false, 
            "current_name": "print"
        }, 
        "__swhatbuf_r": {
            "renaming": {}, 
            "code": "\nundefined4 __swhatbuf_r(undefined4 param_1,int param_2,undefined4 *param_3,uint *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_4c [4];\n  uint local_48;\n  \n  if ((*(short *)(param_2 + 0xe) < 0) ||\n     (iVar1 = _fstat_r(param_1,(int)*(short *)(param_2 + 0xe),auStack_4c), iVar1 < 0)) {\n    *param_4 = 0;\n    if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x18) < 0) {\n      uVar2 = 0x40;\n      goto LAB_08006e08;\n    }\n  }\n  else {\n    *param_4 = (uint)((local_48 & 0xf000) == 0x2000);\n  }\n  uVar2 = 0x400;\nLAB_08006e08:\n  *param_3 = uVar2;\n  return 0;\n}\n\n", 
            "called": [
                "_fstat_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006dc8", 
            "calling": [
                "__smakebuf_r"
            ], 
            "imported": false, 
            "current_name": "__swhatbuf_r"
        }, 
        "pinmap_find_peripheral": {
            "renaming": {}, 
            "code": "\nvoid * pinmap_find_peripheral(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map->pin == NC) {\n      return (void *)0x0;\n    }\n    if (map->pin == pin) break;\n    map = map + 1;\n  }\n  return map->peripheral;\n}\n\n", 
            "called": [
                "pinmap_find_peripheral"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004c5e", 
            "calling": [
                "pinmap_find_peripheral", 
                "pinmap_peripheral"
            ], 
            "imported": false, 
            "current_name": "pinmap_find_peripheral"
        }, 
        "HAL_I2C_ErrorCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  i2c_t *piVar1;\n  \n  piVar1 = get_i2c_obj(hi2c);\n  if (piVar1->isMaster == '\\0') {\n    HAL_I2C_EnableListen_IT(hi2c);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_EnableListen_IT", 
                "get_i2c_obj"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004ef4", 
            "calling": [
                "I2C_ITError", 
                "I2C_DMAAbort"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_ErrorCallback"
        }, 
        "I2C_SlaveReceive_BTF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)\n\n{\n  uint8_t *puVar1;\n  \n  if (hi2c->XferCount != 0) {\n    puVar1 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar1 + 1;\n    *puVar1 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002ad8", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_SlaveReceive_BTF"
        }, 
        "HAL_I2C_MasterTxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002c4e", 
            "calling": [
                "I2C_MasterTransmit_TXE", 
                "I2C_MasterTransmit_BTF"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_MasterTxCpltCallback"
        }, 
        "_fstat_r": {
            "renaming": {}, 
            "code": "\nvoid _fstat_r(int *param_1,int param_2,stat *param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_08007024;\n  *(undefined4 *)PTR_errno_08007024 = 0;\n  iVar2 = _fstat(param_2,param_3);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_fstat"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007004", 
            "calling": [
                "__swhatbuf_r"
            ], 
            "imported": false, 
            "current_name": "_fstat_r"
        }, 
        "__malloc_unlock": {
            "renaming": {}, 
            "code": "\nvoid __malloc_unlock(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006eae", 
            "calling": [
                "_malloc_r", 
                "_free_r"
            ], 
            "imported": false, 
            "current_name": "__malloc_unlock"
        }, 
        "setup": {
            "renaming": {}, 
            "code": "\nvoid setup(void)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *this;\n  uint32_t uVar3;\n  \n  puVar1 = PTR_ssrPin_08000c90;\n  digitalWrite(*(uint32_t *)PTR_ssrPin_08000c90,0);\n  pinMode(*(uint32_t *)puVar1,1);\n  puVar1 = PTR_buzzerPin_08000c94;\n  digitalWrite(*(uint32_t *)PTR_buzzerPin_08000c94,0);\n  pinMode(*(uint32_t *)puVar1,1);\n  puVar2 = PTR_ledRedPin_08000c98;\n  digitalWrite(*(uint32_t *)PTR_ledRedPin_08000c98,0);\n  pinMode(*(uint32_t *)puVar2,1);\n  digitalWrite(*(uint32_t *)puVar1,1);\n  this = PTR_lcd_08000c9c;\n  LiquidCrystal::begin((LiquidCrystal *)PTR_lcd_08000c9c,'\\b','\\x02','\\0');\n  LiquidCrystal::createChar((LiquidCrystal *)this,'\\0',PTR_degree_08000ca0);\n  LiquidCrystal::clear((LiquidCrystal *)this);\n  Print::print((Print *)this,PTR_s_Reflow_08000ca4);\n  LiquidCrystal::setCursor((LiquidCrystal *)this,'\\0','\\x01');\n  Print::print((Print *)this,PTR_s_Oven_1_2_08000ca8);\n  digitalWrite(*(uint32_t *)puVar1,0);\n  delay(0x9c4);\n  LiquidCrystal::clear((LiquidCrystal *)this);\n  HardwareSerial::begin((HardwareSerial *)PTR_Serial2_08000cac,0xe100,'\\x06');\n  digitalWrite(*(uint32_t *)puVar2,1);\n  *(undefined4 *)PTR_windowSize_08000cb0 = 2000;\n  uVar3 = millis();\n  *(uint32_t *)PTR_nextCheck_08000cb4 = uVar3;\n  uVar3 = millis();\n  *(uint32_t *)PTR_nextRead_08000cb8 = uVar3;\n  startForkserver(0);\n  return;\n}\n\n", 
            "called": [
                "begin", 
                "digitalWrite", 
                "pinMode", 
                "print", 
                "delay", 
                "setCursor", 
                "clear", 
                "createChar", 
                "startForkserver", 
                "begin", 
                "millis"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000bcc", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "setup"
        }, 
        "RTC_Alarm_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid RTC_Alarm_IRQHandler(void)\n\n{\n  HAL_RTC_AlarmIRQHandler((RTC_HandleTypeDef *)PTR_RtcHandle_08004d3c);\n  return;\n}\n\n", 
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004d30", 
            "calling": [], 
            "imported": false, 
            "current_name": "RTC_Alarm_IRQHandler"
        }, 
        "USART1_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid USART1_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART1_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)PTR_uart_handlers_080056a4);\n  return;\n}\n\n", 
            "called": [
                "HAL_NVIC_ClearPendingIRQ", 
                "HAL_UART_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005690", 
            "calling": [], 
            "imported": false, 
            "current_name": "USART1_IRQHandler"
        }, 
        "UART_Transmit_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict UART_Transmit_IT(UART_HandleTypeDef *huart)\n\n{\n  uint16_t uVar1;\n  byte *pbVar2;\n  \n  if (huart->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((huart->Init).WordLength == 0x1000) {\n    huart->Instance->DR = *(ushort *)huart->pTxBuffPtr & 0x1ff;\n    if ((huart->Init).Parity == 0) {\n      huart->pTxBuffPtr = huart->pTxBuffPtr + 2;\n    }\n    else {\n      huart->pTxBuffPtr = huart->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    pbVar2 = huart->pTxBuffPtr;\n    huart->pTxBuffPtr = pbVar2 + 1;\n    huart->Instance->DR = (uint)*pbVar2;\n  }\n  uVar1 = huart->TxXferCount - 1;\n  huart->TxXferCount = uVar1;\n  if (uVar1 == 0) {\n    huart->Instance->CR1 = huart->Instance->CR1 & 0xffffff7f;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004198", 
            "calling": [
                "HAL_UART_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "UART_Transmit_IT"
        }, 
        "adc_read_value": {
            "renaming": {}, 
            "code": "\nuint16_t adc_read_value(PinName_conflict pin)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint16_t uhADCxConvertedValue;\n  ADC_ChannelConfTypeDef AdcChannelConf;\n  ADC_HandleTypeDef AdcHandle;\n  \n  memset(&AdcHandle,0,0x30);\n  AdcChannelConf.Channel = 0;\n  AdcChannelConf.Rank = 0;\n  AdcChannelConf.SamplingTime = 0;\n  uhADCxConvertedValue = 0;\n  AdcHandle.Instance =\n       (ADC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_ADC_08004b2c);\n  if (AdcHandle.Instance == (ADC_TypeDef *)0x0) {\n    uhADCxConvertedValue = 0;\n  }\n  else {\n    AdcHandle.Init.DataAlign = 0;\n    AdcHandle.Init.ScanConvMode = 0;\n    AdcHandle.Init.ContinuousConvMode = 0;\n    AdcHandle.Init.DiscontinuousConvMode = 0;\n    AdcHandle.Init.ExternalTrigConv = 0xe0000;\n    AdcHandle.State = 0;\n    AdcHandle.Init.NbrOfConversion = 1;\n    AdcHandle.Init.NbrOfDiscConversion = 0;\n    *PTR_g_current_pin_08004b30 = pin;\n    HVar1 = HAL_ADC_Init(&AdcHandle);\n    if (HVar1 == HAL_OK) {\n      AdcChannelConf.Channel = get_adc_channel(pin);\n      if (AdcChannelConf.Channel < 0x12) {\n        AdcChannelConf.Rank = 1;\n        AdcChannelConf.SamplingTime = 2;\n        HVar1 = HAL_ADC_ConfigChannel(&AdcHandle,&AdcChannelConf);\n        if (HVar1 == HAL_OK) {\n          HVar1 = HAL_ADCEx_Calibration_Start(&AdcHandle);\n          if (HVar1 == HAL_OK) {\n            HVar1 = HAL_ADC_Start(&AdcHandle);\n            if (HVar1 == HAL_OK) {\n              HVar1 = HAL_ADC_PollForConversion(&AdcHandle,10);\n              if (HVar1 == HAL_OK) {\n                uVar2 = HAL_ADC_GetState(&AdcHandle);\n                if ((uVar2 & 0x200) != 0) {\n                  uVar2 = HAL_ADC_GetValue(&AdcHandle);\n                  uhADCxConvertedValue = (uint16_t)uVar2;\n                }\n                HVar1 = HAL_ADC_Stop(&AdcHandle);\n                if (HVar1 == HAL_OK) {\n                  HVar1 = HAL_ADC_DeInit(&AdcHandle);\n                  if (HVar1 != HAL_OK) {\n                    uhADCxConvertedValue = 0;\n                  }\n                }\n                else {\n                  uhADCxConvertedValue = 0;\n                }\n              }\n              else {\n                uhADCxConvertedValue = 0;\n              }\n            }\n            else {\n              uhADCxConvertedValue = 0;\n            }\n          }\n          else {\n            uhADCxConvertedValue = 0;\n          }\n        }\n        else {\n          uhADCxConvertedValue = 0;\n        }\n      }\n      else {\n        uhADCxConvertedValue = 0;\n      }\n    }\n    else {\n      uhADCxConvertedValue = 0;\n    }\n  }\n  return uhADCxConvertedValue;\n}\n\n", 
            "called": [
                "memset", 
                "get_adc_channel", 
                "HAL_ADC_PollForConversion", 
                "HAL_ADC_Start", 
                "HAL_ADC_DeInit", 
                "HAL_ADC_GetState", 
                "HAL_ADC_ConfigChannel", 
                "HAL_ADCEx_Calibration_Start", 
                "HAL_ADC_Init", 
                "HAL_ADC_Stop", 
                "pinmap_peripheral", 
                "HAL_ADC_GetValue"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004a4c", 
            "calling": [
                "analogRead"
            ], 
            "imported": false, 
            "current_name": "adc_read_value"
        }, 
        "HAL_GPIO_EXTI_Callback": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n\n{\n  byte bVar1;\n  \n  bVar1 = get_pin_id(GPIO_Pin);\n  if (*(int *)(PTR_gpio_irq_conf_08006100 + (uint)bVar1 * 0x14 + 0xc) != 0) {\n    std::function<void()>::operator__\n              ((function_void___ *)(PTR_gpio_irq_conf_08006100 + (uint)bVar1 * 0x14 + 4));\n  }\n  return;\n}\n\n", 
            "called": [
                "operator()", 
                "get_pin_id"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080060e4", 
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_EXTI_Callback"
        }, 
        "__divdf3": {
            "renaming": {}, 
            "code": "\nulonglong __divdf3(undefined4 param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  uint unaff_r5;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  bool bVar14;\n  bool bVar15;\n  bool bVar16;\n  ulonglong uVar17;\n  \n  uVar17 = CONCAT44(param_2,param_1);\n  uVar13 = 0x7ff;\n  uVar7 = param_2 >> 0x14 & 0x7ff;\n  bVar14 = uVar7 == 0;\n  if (!bVar14) {\n    unaff_r5 = param_4 >> 0x14 & 0x7ff;\n    bVar14 = unaff_r5 == 0;\n  }\n  if (!bVar14) {\n    bVar14 = uVar7 == 0x7ff;\n  }\n  if (!bVar14) {\n    bVar14 = unaff_r5 == 0x7ff;\n  }\n  if (bVar14) {\n    uVar17 = FUN_080008ba();\n  }\n  uVar9 = (uint)(uVar17 >> 0x20);\n  uVar11 = (uint)uVar17;\n  iVar8 = uVar7 - unaff_r5;\n  if ((param_3 | param_4 << 0xc) == 0) {\n    uVar7 = (uVar9 ^ param_4) & 0x80000000 | uVar9 & 0xfffff;\n    bVar16 = SCARRY4(iVar8,uVar13 >> 1);\n    uVar9 = iVar8 + (uVar13 >> 1);\n    bVar14 = (int)uVar9 < 0;\n    bVar15 = uVar9 == 0;\n    if (!bVar15 && bVar14 == bVar16) {\n      bVar16 = SBORROW4(uVar13,uVar9);\n      bVar14 = (int)(uVar13 - uVar9) < 0;\n      bVar15 = uVar13 == uVar9;\n    }\n    if (!bVar15 && bVar14 == bVar16) {\n      uVar7 = uVar7 | uVar9 * 0x100000;\n    }\n    if (!bVar15 && bVar14 == bVar16) {\n      return uVar17 & 0xffffffff | (ulonglong)uVar7 << 0x20;\n    }\n    uVar7 = uVar7 | 0x100000;\n    uVar13 = 0;\n    bVar15 = SBORROW4(uVar9,1);\n    uVar9 = uVar9 - 1;\n    bVar14 = uVar9 == 0;\n    uVar3 = uVar9;\n  }\n  else {\n    uVar3 = (param_4 << 0xc) >> 4 | 0x10000000 | param_3 >> 0x18;\n    uVar13 = param_3 << 8;\n    uVar10 = (uVar9 << 0xc) >> 4 | 0x10000000 | uVar11 >> 0x18;\n    uVar11 = uVar11 * 0x100;\n    uVar7 = (uVar9 ^ param_4) & 0x80000000;\n    bVar14 = uVar3 <= uVar10;\n    if (uVar10 == uVar3) {\n      bVar14 = uVar13 <= uVar11;\n    }\n    iVar8 = iVar8 + (uint)bVar14;\n    uVar9 = iVar8 + 0x3fd;\n    if (bVar14 == false) {\n      uVar3 = uVar3 >> 1;\n      uVar13 = (uint)((param_3 >> 0x18 & 1) != 0) << 0x1f | uVar13 >> 1;\n    }\n    uVar12 = uVar11 - uVar13;\n    uVar10 = (uVar10 - uVar3) - (uint)(uVar11 < uVar13);\n    uVar4 = uVar3 >> 1;\n    uVar1 = (uint)((uVar3 & 1) != 0) << 0x1f | uVar13 >> 1;\n    uVar11 = 0x100000;\n    uVar3 = 0x80000;\n    while( true ) {\n      bVar14 = uVar1 <= uVar12;\n      if (uVar4 < uVar10 || uVar10 - uVar4 < (uint)bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar11 = uVar11 | uVar3;\n        uVar10 = (uVar10 - uVar4) - (uint)!bVar14;\n      }\n      uVar5 = uVar4 >> 1;\n      uVar1 = (uint)((uVar4 & 1) != 0) << 0x1f | uVar1 >> 1;\n      bVar15 = uVar1 <= uVar12;\n      bVar14 = uVar10 - uVar5 < (uint)bVar15;\n      uVar13 = uVar10;\n      if (uVar5 < uVar10 || bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar13 = (uVar10 - uVar5) - (uint)!bVar15;\n      }\n      if (uVar5 < uVar10 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 1;\n      }\n      uVar10 = uVar4 >> 2;\n      uVar2 = (uint)((uVar5 & 1) != 0) << 0x1f | uVar1 >> 1;\n      bVar15 = uVar2 <= uVar12;\n      bVar14 = uVar13 - uVar10 < (uint)bVar15;\n      uVar5 = uVar13;\n      if (uVar10 < uVar13 || bVar14) {\n        uVar12 = uVar12 - uVar2;\n        uVar5 = (uVar13 - uVar10) - (uint)!bVar15;\n      }\n      if (uVar10 < uVar13 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 2;\n      }\n      uVar6 = uVar4 >> 3;\n      uVar1 = (uint)((uVar10 & 1) != 0) << 0x1f | uVar2 >> 1;\n      bVar15 = uVar1 <= uVar12;\n      bVar14 = uVar5 - uVar6 < (uint)bVar15;\n      uVar10 = uVar5;\n      if (uVar6 < uVar5 || bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar10 = (uVar5 - uVar6) - (uint)!bVar15;\n      }\n      if (uVar6 < uVar5 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 3;\n      }\n      uVar13 = uVar10 | uVar12;\n      if (uVar13 == 0) break;\n      uVar10 = uVar10 << 4 | uVar12 >> 0x1c;\n      uVar12 = uVar12 << 4;\n      uVar4 = uVar4 & 0xfffffff8 | uVar1 >> 0x1d;\n      uVar1 = (uVar2 >> 1) << 3;\n      uVar3 = uVar3 >> 4;\n      if (uVar3 == 0) {\n        uVar6 = uVar4;\n        if ((uVar7 & 0x100000) != 0) goto LAB_0800086a;\n        uVar7 = uVar7 | uVar11;\n        uVar11 = 0;\n        uVar3 = 0x80000000;\n      }\n    }\n    if ((uVar7 & 0x100000) == 0) {\n      uVar7 = uVar7 | uVar11;\n      uVar11 = 0;\n    }\nLAB_0800086a:\n    bVar16 = 0xfc < uVar9;\n    bVar15 = SBORROW4(uVar9,0xfd);\n    uVar4 = iVar8 + 0x300;\n    bVar14 = uVar4 == 0;\n    uVar3 = uVar4;\n    if (bVar16 && !bVar14) {\n      bVar16 = 0x6ff < uVar4;\n      bVar15 = SBORROW4(uVar4,0x700);\n      uVar3 = iVar8 - 0x400;\n      bVar14 = uVar4 == 0x700;\n    }\n    if (!bVar16 || bVar14) {\n      bVar14 = uVar6 <= uVar10;\n      if (uVar10 == uVar6) {\n        bVar14 = uVar1 <= uVar12;\n      }\n      if (uVar10 == uVar6 && uVar12 == uVar1) {\n        bVar14 = (uVar11 & 1) != 0;\n      }\n      return CONCAT44(uVar7 + uVar9 * 0x100000 + (uint)CARRY4(uVar11,(uint)bVar14),uVar11 + bVar14);\n    }\n  }\n  if (!bVar14 && (int)uVar3 < 0 == bVar15) {\n    return (ulonglong)(uVar7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bVar16 = SCARRY4(uVar9,0x36);\n  bVar14 = (int)(uVar9 + 0x36) < 0;\n  bVar15 = uVar9 == 0xffffffca;\n  if (bVar15 || bVar14 != bVar16) {\n    uVar11 = 0;\n  }\n  if (bVar15 || bVar14 != bVar16) {\n    uVar7 = uVar7 & 0x80000000;\n  }\n  if (bVar15 || bVar14 != bVar16) {\n    return CONCAT44(uVar7,uVar11);\n  }\n  uVar3 = -uVar9;\n  uVar10 = uVar3 - 0x20;\n  if (0x1f < (int)uVar3) {\n    uVar3 = uVar11 >> (uVar10 & 0xff) | uVar7 << (0x20 - uVar10 & 0xff);\n    uVar9 = (uVar7 >> (uVar10 & 0xff) & ~((uVar7 & 0x80000000) >> (uVar10 & 0xff))) -\n            ((int)uVar3 >> 0x1f);\n    if ((uVar13 | uVar11 << (0x20 - uVar10 & 0xff) | uVar3 << 1) == 0) {\n      uVar9 = uVar9 & ~(uVar3 >> 0x1f);\n    }\n    return CONCAT44(uVar7,uVar9) & 0x80000000ffffffff;\n  }\n  iVar8 = uVar3 - 0x14;\n  if (iVar8 != 0 && iVar8 < 0 == SCARRY4(uVar10,0xc)) {\n    uVar9 = 0xc - iVar8;\n    uVar3 = uVar11 << (uVar9 & 0xff);\n    uVar11 = uVar11 >> (0x20 - uVar9 & 0xff) | uVar7 << (uVar9 & 0xff);\n    uVar9 = uVar11 + -((int)uVar3 >> 0x1f);\n    if ((uVar13 | uVar3 << 1) == 0) {\n      uVar9 = uVar9 & ~(uVar3 >> 0x1f);\n    }\n    return CONCAT44((uVar7 & 0x80000000) + (uint)CARRY4(uVar11,-((int)uVar3 >> 0x1f)),uVar9);\n  }\n  uVar10 = uVar11 << (uVar9 + 0x20 & 0xff);\n  uVar11 = uVar11 >> (uVar3 & 0xff) | uVar7 << (uVar9 + 0x20 & 0xff);\n  uVar9 = uVar11 + -((int)uVar10 >> 0x1f);\n  if ((uVar13 | uVar10 << 1) == 0) {\n    uVar9 = uVar9 & ~(uVar10 >> 0x1f);\n  }\n  return CONCAT44((uVar7 & 0x80000000) +\n                  ((uVar7 & 0x7fffffff) >> (uVar3 & 0xff)) +\n                  (uint)CARRY4(uVar11,-((int)uVar10 >> 0x1f)),uVar9);\n}\n\n", 
            "called": [
                "FUN_080008ba"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800074c", 
            "calling": [
                "readThermocouple", 
                "SetSampleTime", 
                "SetTunings", 
                "printFloat"
            ], 
            "imported": false, 
            "current_name": "__divdf3"
        }, 
        "_GLOBAL__sub_I__ZN9IPAddressC2Ev": {
            "renaming": {}, 
            "code": "\nvoid _GLOBAL__sub_I__ZN9IPAddressC2Ev(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n", 
            "called": [
                "__static_initialization_and_destruction_0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005c64", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
        }, 
        "HAL_TIM_PWM_PulseFinishedCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003f14", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_PulseFinishedCallback"
        }, 
        "_read": {
            "renaming": {}, 
            "code": "\nint _read(int file_UNUSED,char *ptr_UNUSED,int len_UNUSED)\n\n{\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800572c", 
            "calling": [
                "_read_r"
            ], 
            "imported": false, 
            "current_name": "_read"
        }, 
        "iprintf": {
            "renaming": {}, 
            "code": "\nint iprintf(char *__format,...)\n\n{\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  int iVar1;\n  char *pcVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  iVar1 = *(int *)PTR__impure_ptr_0800691c;\n  pcVar2 = __format;\n  uStack_c = in_r1;\n  uStack_8 = in_r2;\n  uStack_4 = in_r3;\n  if ((iVar1 != 0) && (*(int *)(iVar1 + 0x18) == 0)) {\n    __sinit(iVar1);\n  }\n  iVar1 = _vfiprintf_r(iVar1,*(undefined4 *)(iVar1 + 8),__format,&uStack_c,pcVar2,&uStack_c);\n  return iVar1;\n}\n\n", 
            "called": [
                "__sinit", 
                "_vfiprintf_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080068f0", 
            "calling": [
                "uart_init"
            ], 
            "imported": false, 
            "current_name": "iprintf"
        }, 
        "pulseEnable": {
            "renaming": {}, 
            "code": "\nvoid __thiscall LiquidCrystal::pulseEnable(LiquidCrystal *this)\n\n{\n  digitalWrite((uint)this->_enable_pin,0);\n  digitalWrite((uint)this->_enable_pin,1);\n  digitalWrite((uint)this->_enable_pin,0);\n  return;\n}\n\n", 
            "called": [
                "digitalWrite"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080012a2", 
            "calling": [
                "write8bits", 
                "write4bits"
            ], 
            "imported": false, 
            "current_name": "pulseEnable"
        }, 
        "I2C_Slave_STOPF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  I2C_TypeDef *pIVar2;\n  uint8_t *puVar3;\n  uint32_t tmpreg;\n  \n  HVar1 = hi2c->State;\n  hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 | 1;\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n  pIVar2 = hi2c->Instance;\n  if ((pIVar2->CR2 & 0x800) != 0) {\n    if ((hi2c->State == HAL_I2C_STATE_BUSY_RX) || (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      hi2c->XferCount = (uint16_t)hi2c->hdmarx->Instance->CNDTR;\n    }\n    else {\n      hi2c->XferCount = (uint16_t)hi2c->hdmatx->Instance->CNDTR;\n    }\n  }\n  if (hi2c->XferCount != 0) {\n    if ((pIVar2->SR1 & 4) != 0) {\n      puVar3 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = puVar3 + 1;\n      *puVar3 = (uint8_t)pIVar2->DR;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n    if ((hi2c->Instance->SR1 & 0x40) != 0) {\n      puVar3 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = puVar3 + 1;\n      *puVar3 = (uint8_t)hi2c->Instance->DR;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n    hi2c->ErrorCode = hi2c->ErrorCode | 4;\n  }\n  if (hi2c->ErrorCode == 0) {\n    if (((HVar1 == HAL_I2C_STATE_LISTEN) || (HVar1 == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (HVar1 == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c->XferOptions = DAT_080033b4;\n      hi2c->PreviousState = 0;\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(hi2c);\n    }\n    else if ((hi2c->PreviousState == 0x22) || (HVar1 == HAL_I2C_STATE_BUSY_RX)) {\n      hi2c->PreviousState = 0;\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(hi2c);\n    }\n  }\n  else {\n    I2C_ITError(hi2c);\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "I2C_ITError", 
                "HAL_I2C_ListenCpltCallback", 
                "HAL_I2C_SlaveRxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080032b4", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Slave_STOPF"
        }, 
        "HAL_TIM_PWM_MspDeInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)\n\n{\n  timer_disable_clock(htim);\n  return;\n}\n\n", 
            "called": [
                "timer_disable_clock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004b34", 
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_MspDeInit"
        }, 
        "digital_io_init": {
            "renaming": {}, 
            "code": "\nvoid digital_io_init(PinName_conflict pin,uint32_t mode,uint32_t pull)\n\n{\n  uint uVar1;\n  GPIO_TypeDef *GPIOx;\n  uint32_t tmpreg;\n  GPIO_InitTypeDef GPIO_InitStructure;\n  \n  uVar1 = (uint)pin;\n  GPIOx = set_GPIO_Port_Clock((uVar1 << 0x18) >> 0x1c);\n  GPIO_InitStructure.Pin = 1 << (uVar1 & 0xf) & 0xffff;\n  GPIO_InitStructure.Speed = 3;\n  *(uint *)(DAT_08004c28 + 0x18) = *(uint *)(DAT_08004c28 + 0x18) | 1;\n  if ((uVar1 - 0xd & 0xff) < 2) {\n    *(uint *)(DAT_08004c2c + 4) = *(uint *)(DAT_08004c2c + 4) & 0xf8ffffff | 0x4000000;\n  }\n  if (((uVar1 == 0xf) || (uVar1 == 0x13)) || (uVar1 == 0x14)) {\n    *(uint *)(DAT_08004c2c + 4) = *(uint *)(DAT_08004c2c + 4) & 0xf8ffffff | 0x2000000;\n  }\n  GPIO_InitStructure.Mode = mode;\n  GPIO_InitStructure.Pull = pull;\n  HAL_GPIO_Init(GPIOx,&GPIO_InitStructure);\n  return;\n}\n\n", 
            "called": [
                "set_GPIO_Port_Clock", 
                "HAL_GPIO_Init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004bb0", 
            "calling": [
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "digital_io_init"
        }, 
        "Initialize": {
            "renaming": {}, 
            "code": "\nvoid __thiscall PID::Initialize(PID *this)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  \n  uVar3 = *(undefined4 *)this->myOutput;\n  uVar4 = *(undefined4 *)((int)this->myOutput + 4);\n  *(undefined4 *)&this->outputSum = uVar3;\n  *(undefined4 *)((int)&this->outputSum + 4) = uVar4;\n  uVar2 = *(undefined4 *)((int)this->myInput + 4);\n  *(undefined4 *)&this->lastInput = *(undefined4 *)this->myInput;\n  *(undefined4 *)((int)&this->lastInput + 4) = uVar2;\n  uVar2 = *(undefined4 *)&this->outMax;\n  uVar5 = *(undefined4 *)((int)&this->outMax + 4);\n  iVar1 = __aeabi_dcmpgt(uVar3,uVar4,uVar2,uVar5);\n  if (iVar1 == 0) {\n    uVar2 = *(undefined4 *)&this->outMin;\n    uVar5 = *(undefined4 *)((int)&this->outMin + 4);\n    iVar1 = __aeabi_dcmplt(uVar3,uVar4,uVar2,uVar5);\n    if (iVar1 != 0) {\n      *(undefined4 *)&this->outputSum = uVar2;\n      *(undefined4 *)((int)&this->outputSum + 4) = uVar5;\n    }\n    return;\n  }\n  *(undefined4 *)&this->outputSum = uVar2;\n  *(undefined4 *)((int)&this->outputSum + 4) = uVar5;\n  return;\n}\n\n", 
            "called": [
                "__aeabi_dcmpgt", 
                "__aeabi_dcmplt"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080019f6", 
            "calling": [
                "SetMode"
            ], 
            "imported": false, 
            "current_name": "Initialize"
        }, 
        "uart_index": {
            "renaming": {}, 
            "code": "\nuint8_t uart_index(UART_HandleTypeDef *huart)\n\n{\n  uint uVar1;\n  \n  if (huart == (UART_HandleTypeDef *)0x0) {\n    uVar1 = 5;\n  }\n  else {\n    uVar1 = 0;\n    while( true ) {\n      if (4 < uVar1) {\n        return (uint8_t)uVar1;\n      }\n      if (huart == *(UART_HandleTypeDef **)(PTR_uart_handlers_080055dc + uVar1 * 4)) break;\n      uVar1 = uVar1 + 1 & 0xff;\n    }\n  }\n  return (uint8_t)uVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080055bc", 
            "calling": [
                "HAL_UART_RxCpltCallback", 
                "HAL_UART_TxCpltCallback"
            ], 
            "imported": false, 
            "current_name": "uart_index"
        }, 
        "__floatunsidf": {
            "renaming": {}, 
            "code": "\nulonglong __floatunsidf(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  uint in_r12;\n  bool bVar5;\n  bool bVar6;\n  bool bVar7;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  uVar1 = 0;\n  iVar3 = count_leading_zeroes(param_1);\n  uVar4 = iVar3 + 0x15;\n  bVar7 = SBORROW4(uVar4,0x20);\n  uVar2 = iVar3 - 0xb;\n  bVar5 = (int)uVar2 < 0;\n  bVar6 = uVar2 == 0;\n  if ((int)uVar4 < 0x20) {\n    bVar7 = SCARRY4(uVar2,0xc);\n    iVar3 = iVar3 + 1;\n    bVar5 = iVar3 < 0;\n    bVar6 = iVar3 == 0;\n    uVar2 = uVar4;\n    if (!bVar6 && bVar5 == bVar7) {\n      uVar1 = param_1 << (uVar4 & 0xff);\n      param_1 = param_1 >> (0xcU - iVar3 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar6 || bVar5 != bVar7) {\n    in_r12 = 0x20 - uVar2;\n  }\n  param_1 = param_1 << (uVar2 & 0xff);\n  if (bVar6 || bVar5 != bVar7) {\n    param_1 = param_1 | 0U >> (in_r12 & 0xff);\n  }\n  if (bVar6 || bVar5 != bVar7) {\n    uVar1 = 0 << (uVar2 & 0xff);\n  }\nLAB_08000318:\n  if ((int)uVar4 < 0x433) {\n    return CONCAT44(param_1 + (0x432 - uVar4) * 0x100000,uVar1);\n  }\n  uVar2 = ~(0x432 - uVar4);\n  if (0x1e < (int)uVar2) {\n    return (ulonglong)(param_1 >> (uVar2 - 0x1f & 0xff));\n  }\n  iVar3 = uVar2 - 0x13;\n  if (iVar3 == 0 || iVar3 < 0 != SCARRY4(uVar2 - 0x1f,0xc)) {\n    uVar2 = uVar2 + 1;\n    return CONCAT44(param_1 >> (uVar2 & 0xff),\n                    uVar1 >> (uVar2 & 0xff) | param_1 << (0x20 - uVar2 & 0xff));\n  }\n  return (ulonglong)(uVar1 >> (0x20 - (0xcU - iVar3) & 0xff) | param_1 << (0xcU - iVar3 & 0xff));\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800040c", 
            "calling": [
                "readThermocouple", 
                "SetSampleTime", 
                "loop", 
                "SetTunings", 
                "printFloat"
            ], 
            "imported": false, 
            "current_name": "__floatunsidf"
        }, 
        "_printf_common": {
            "renaming": {}, 
            "code": "\nundefined4\n_printf_common(undefined4 param_1,uint *param_2,uint *param_3,undefined4 param_4,code *param_5)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  bool bVar4;\n  \n  uVar2 = param_2[4];\n  if ((int)param_2[4] < (int)param_2[2]) {\n    uVar2 = param_2[2];\n  }\n  *param_3 = uVar2;\n  if (*(char *)((int)param_2 + 0x43) != '\\0') {\n    *param_3 = uVar2 + 1;\n  }\n  if ((int)(*param_2 << 0x1a) < 0) {\n    *param_3 = *param_3 + 2;\n  }\n  uVar2 = *param_2 & 6;\n  if (uVar2 == 0) {\n    for (; (int)uVar2 < (int)(param_2[3] - *param_3); uVar2 = uVar2 + 1) {\n      iVar1 = (*param_5)(param_1,param_4,(int)param_2 + 0x19,1);\n      if (iVar1 == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  uVar2 = (uint)*(byte *)((int)param_2 + 0x43);\n  if (uVar2 != 0) {\n    uVar2 = 1;\n  }\n  uVar3 = uVar2;\n  if ((int)(*param_2 << 0x1a) < 0) {\n    *(undefined *)((int)param_2 + uVar2 + 0x43) = 0x30;\n    uVar3 = uVar2 + 2;\n    *(undefined *)((int)param_2 + uVar2 + 0x44) = *(undefined *)((int)param_2 + 0x45);\n  }\n  iVar1 = (*param_5)(param_1,param_4,(int)param_2 + 0x43,uVar3);\n  if (iVar1 != -1) {\n    uVar2 = param_2[3];\n    bVar4 = (*param_2 & 6) != 4;\n    if (bVar4) {\n      uVar2 = 0;\n    }\n    uVar3 = 0;\n    if (!bVar4) {\n      uVar2 = uVar2 - *param_3;\n    }\n    if (!bVar4) {\n      uVar2 = uVar2 & ~((int)uVar2 >> 0x1f);\n    }\n    if ((int)param_2[4] < (int)param_2[2]) {\n      uVar2 = uVar2 + (param_2[2] - param_2[4]);\n    }\n    while( true ) {\n      if (uVar2 == uVar3) {\n        return 0;\n      }\n      iVar1 = (*param_5)(param_1,param_4,(int)param_2 + 0x1a,1);\n      if (iVar1 == -1) break;\n      uVar3 = uVar3 + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080065c0", 
            "calling": [
                "_printf_i"
            ], 
            "imported": false, 
            "current_name": "_printf_common"
        }, 
        "write4bits": {
            "renaming": {}, 
            "code": "\nvoid __thiscall LiquidCrystal::write4bits(LiquidCrystal *this,uint8_t value)\n\n{\n  uint uVar1;\n  \n  for (uVar1 = 0; (int)uVar1 < 4; uVar1 = uVar1 + 1) {\n    digitalWrite((uint)this->_data_pins[uVar1],(int)(uint)value >> (uVar1 & 0xff) & 1);\n  }\n  pulseEnable(this);\n  return;\n}\n\n", 
            "called": [
                "pulseEnable", 
                "digitalWrite"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080012c0", 
            "calling": [
                "send", 
                "begin"
            ], 
            "imported": false, 
            "current_name": "write4bits"
        }, 
        "EXTI3_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI3_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(8);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006092", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI3_IRQHandler"
        }, 
        "__gedf2": {
            "renaming": {}, 
            "code": "\nuint __gedf2(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  \n  if (((int)(param_2 << 1) >> 0x15 == -1 || (int)(param_4 << 1) >> 0x15 == -1) &&\n     ((((int)(param_2 << 1) >> 0x15 == -1 && ((param_1 | param_2 << 0xc) != 0)) ||\n      (((int)(param_4 << 1) >> 0x15 == -1 && ((param_3 | param_4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  bVar2 = (param_1 | param_2 << 1) == 0;\n  if (bVar2) {\n    bVar2 = (param_3 | param_4 << 1) == 0;\n  }\n  if (!bVar2) {\n    bVar2 = param_2 == param_4;\n  }\n  if (bVar2) {\n    bVar2 = param_1 == param_3;\n  }\n  if (!bVar2) {\n    uVar1 = param_2 ^ param_4;\n    bVar2 = uVar1 == 0;\n    if (-1 < (int)uVar1) {\n      bVar2 = param_2 == param_4;\n    }\n    bVar3 = -1 < (int)uVar1 && param_4 <= param_2;\n    if (bVar2) {\n      bVar3 = param_3 <= param_1;\n    }\n    param_4 = (int)param_4 >> 0x1f;\n    if (!bVar3) {\n      param_4 = ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800091c", 
            "calling": [], 
            "imported": false, 
            "current_name": "__gedf2"
        }, 
        "HardwareSerial": {
            "renaming": {}, 
            "code": "\nHardwareSerial * __thiscall HardwareSerial::HardwareSerial(HardwareSerial *this,void *peripheral)\n\n{\n  PinName_conflict PVar1;\n  EVP_PKEY_CTX *extraout_r1;\n  EVP_PKEY_CTX *ctx;\n  EVP_PKEY_CTX *extraout_r1_00;\n  \n  (this->super_Stream).super_Print.write_error = 0;\n  (this->super_Stream)._timeout = 1000;\n  (this->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)PTR_PTR_write_1_08005ba0;\n  if (this == (HardwareSerial *)PTR_Serial2_08005ba4) {\n    setRx(this,0);\n    setTx(this,1);\n    ctx = extraout_r1_00;\n  }\n  else {\n    PVar1 = pinmap_pin(peripheral,(PinMap_conflict *)PTR_PinMap_UART_RX_08005ba8);\n    (this->_serial).pin_rx = PVar1;\n    PVar1 = pinmap_pin(peripheral,(PinMap_conflict *)PTR_PinMap_UART_TX_08005bac);\n    (this->_serial).pin_tx = PVar1;\n    ctx = extraout_r1;\n  }\n  init(this,ctx);\n  return this;\n}\n\n", 
            "called": [
                "setTx", 
                "pinmap_pin", 
                "setRx", 
                "init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005b54", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "HardwareSerial"
        }, 
        "write": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005c86 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nsize_t __thiscall Print::write(Print *this,uint8_t *buffer,size_t size)\n\n{\n  Print *pPVar1;\n  size_t sVar2;\n  \n  sVar2 = 0;\n  pPVar1 = this;\n  while( true ) {\n    if (size == 0) {\n      return sVar2;\n    }\n    pPVar1 = (Print *)(**this->_vptr_Print)(pPVar1,(uint)*buffer);\n    if (pPVar1 == (Print *)0x0) break;\n    sVar2 = sVar2 + 1;\n    buffer = buffer + 1;\n    size = size - 1;\n  }\n  return sVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005c72", 
            "calling": [], 
            "imported": false, 
            "current_name": "write"
        }, 
        "I2C_Master_ADDR": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)\n\n{\n  uint32_t uVar1;\n  I2C_TypeDef *pIVar2;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  \n  uVar1 = hi2c->XferOptions;\n  if ((hi2c->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((hi2c->EventCount != 0 || (hi2c->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((hi2c->EventCount == 0) && ((hi2c->Init).AddressingMode == 0xc000)) {\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x100;\n      hi2c->EventCount = hi2c->EventCount + 1;\n    }\n    else {\n      if (hi2c->XferCount == 0) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n      }\n      else if (hi2c->XferCount == 1) {\n        if (uVar1 == 0xffff0000) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n          pIVar2 = hi2c->Instance;\n          if ((pIVar2->CR2 & 0x800) == 0) {\n            pIVar2->CR1 = pIVar2->CR1 | 0x200;\n          }\n          else {\n            pIVar2->CR1 = pIVar2->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((uVar1 == 4) || (uVar1 == 8)) || (hi2c->PreviousState == 0x12)) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n        }\n        else if (hi2c->XferOptions == 2) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        }\n        else {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (hi2c->XferCount == 2) {\n        if (hi2c->XferOptions == 2) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        }\n        else {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x800;\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n        }\n        pIVar2 = hi2c->Instance;\n        if ((pIVar2->CR2 & 0x800) != 0) {\n          pIVar2->CR2 = pIVar2->CR2 | 0x1000;\n        }\n      }\n      else {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        pIVar2 = hi2c->Instance;\n        if ((pIVar2->CR2 & 0x800) != 0) {\n          pIVar2->CR2 = pIVar2->CR2 | 0x1000;\n        }\n      }\n      hi2c->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080028de", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Master_ADDR"
        }, 
        "I2C2_ER_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid I2C2_ER_IRQHandler(void)\n\n{\n  HAL_I2C_ER_IRQHandler(*(I2C_HandleTypeDef **)(PTR_i2c_handles_08004f48 + 4));\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004f3c", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C2_ER_IRQHandler"
        }, 
        "HAL_SYSTICK_Config": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 = DAT_08002538;\n  if (TicksNumb - 1 < 0x1000000) {\n    DAT_08002538[1] = TicksNumb - 1;\n    *(undefined *)(DAT_0800253c + 0x23) = 0xf0;\n    puVar1[2] = 0;\n    *puVar1 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002514", 
            "calling": [
                "HAL_InitTick", 
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_Config"
        }, 
        "init": {
            "renaming": {}, 
            "code": "\nint __thiscall HardwareSerial::init(HardwareSerial *this,EVP_PKEY_CTX *ctx)\n\n{\n  (this->_serial).rx_buff = this->_rx_buffer;\n  (this->_serial).rx_head = 0;\n  (this->_serial).rx_tail = 0;\n  (this->_serial).tx_buff = this->_tx_buffer;\n  (this->_serial).tx_head = 0;\n  (this->_serial).tx_tail = 0;\n  return (int)this;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005a44", 
            "calling": [
                "HardwareSerial"
            ], 
            "imported": false, 
            "current_name": "init"
        }, 
        "HAL_UART_RxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n\n{\n  byte bVar1;\n  uint uVar2;\n  \n  bVar1 = uart_index(huart);\n  uVar2 = (uint)bVar1;\n  if (uVar2 < 5) {\n    (**(code **)(PTR_rx_callback_080055fc + uVar2 * 4))\n              (*(undefined4 *)(PTR_rx_callback_obj_08005600 + uVar2 * 4));\n  }\n  return;\n}\n\n", 
            "called": [
                "uart_index"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080055e0", 
            "calling": [
                "UART_Receive_IT"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_RxCpltCallback"
        }, 
        "_Error_Handler": {
            "renaming": {}, 
            "code": "\nvoid _Error_Handler(char *msg,int val)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [
                "_Error_Handler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004d40", 
            "calling": [
                "SystemClock_Config", 
                "_Error_Handler"
            ], 
            "imported": false, 
            "current_name": "_Error_Handler"
        }, 
        "__smakebuf_r": {
            "renaming": {}, 
            "code": "\nvoid __smakebuf_r(int param_1,int *param_2)\n\n{\n  ushort uVar1;\n  int iVar2;\n  int local_18;\n  int *local_14;\n  \n  if (-1 < (int)((uint)*(ushort *)(param_2 + 3) << 0x1e)) {\n    local_18 = param_1;\n    local_14 = param_2;\n    uVar1 = __swhatbuf_r(param_1,param_2,&local_18,&local_14);\n    iVar2 = _malloc_r(param_1,local_18);\n    if (iVar2 != 0) {\n      *(undefined4 *)(param_1 + 0x28) = DAT_08006e8c;\n      *param_2 = iVar2;\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 0x80;\n      param_2[4] = iVar2;\n      param_2[5] = local_18;\n      if ((local_14 != (int *)0x0) &&\n         (iVar2 = _isatty_r(param_1,(int)*(short *)((int)param_2 + 0xe)), iVar2 != 0)) {\n        *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(param_2 + 3) = uVar1 | *(ushort *)(param_2 + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(param_2 + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xfffc | 2;\n  }\n  *param_2 = (int)param_2 + 0x47;\n  param_2[4] = (int)param_2 + 0x47;\n  param_2[5] = 1;\n  return;\n}\n\n", 
            "called": [
                "_malloc_r", 
                "__swhatbuf_r", 
                "_isatty_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006e10", 
            "calling": [
                "__swsetup_r"
            ], 
            "imported": false, 
            "current_name": "__smakebuf_r"
        }, 
        "HAL_TIM_IC_CaptureCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003f12", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_IC_CaptureCallback"
        }, 
        "SysTick_Handler": {
            "renaming": {}, 
            "code": "\nvoid SysTick_Handler(void)\n\n{\n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  noOsSystickHandler();\n  return;\n}\n\n", 
            "called": [
                "HAL_SYSTICK_IRQHandler", 
                "noOsSystickHandler", 
                "HAL_IncTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004b9e", 
            "calling": [], 
            "imported": false, 
            "current_name": "SysTick_Handler"
        }, 
        "__muldf3": {
            "renaming": {}, 
            "code": "\nulonglong __muldf3(undefined4 param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  ulonglong uVar1;\n  longlong lVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint unaff_r5;\n  uint uVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  uVar12 = CONCAT44(param_2,param_1);\n  uVar7 = 0x7ff;\n  uVar4 = param_2 >> 0x14 & 0x7ff;\n  bVar9 = uVar4 == 0;\n  if (!bVar9) {\n    unaff_r5 = param_4 >> 0x14 & 0x7ff;\n    bVar9 = unaff_r5 == 0;\n  }\n  if (!bVar9) {\n    bVar9 = uVar4 == 0x7ff;\n  }\n  if (!bVar9) {\n    bVar9 = unaff_r5 == 0x7ff;\n  }\n  if (bVar9) {\n    uVar12 = FUN_080006d4();\n  }\n  uVar3 = (uint)(uVar12 >> 0x20);\n  iVar5 = uVar4 + unaff_r5;\n  uVar4 = uVar3 ^ param_4;\n  uVar3 = uVar3 & ~(uVar7 << 0x15);\n  param_4 = param_4 & ~(uVar7 << 0x15);\n  bVar9 = ((uint)uVar12 | uVar3 << 0xc) == 0;\n  if (!bVar9) {\n    bVar9 = (param_3 | param_4 << 0xc) == 0;\n  }\n  uVar3 = uVar3 | 0x100000;\n  param_4 = param_4 | 0x100000;\n  if (bVar9) {\n    param_3 = (uint)uVar12 | param_3;\n    param_4 = (uVar4 & 0x80000000 | uVar3) ^ param_4;\n    uVar4 = uVar7 >> 1;\n    bVar11 = SBORROW4(iVar5,uVar4);\n    uVar6 = iVar5 - uVar4;\n    bVar9 = uVar6 == 0;\n    uVar3 = uVar6;\n    if (!bVar9 && (int)uVar4 <= iVar5) {\n      bVar11 = SBORROW4(uVar7,uVar6);\n      uVar3 = uVar7 - uVar6;\n      bVar9 = uVar7 == uVar6;\n    }\n    if (!bVar9 && (int)uVar3 < 0 == bVar11) {\n      param_4 = param_4 | uVar6 * 0x100000;\n    }\n    if (!bVar9 && (int)uVar3 < 0 == bVar11) {\n      return CONCAT44(param_4,param_3);\n    }\n    param_4 = param_4 | 0x100000;\n    uVar7 = 0;\n    bVar11 = SBORROW4(uVar6,1);\n    uVar6 = uVar6 - 1;\n    bVar9 = uVar6 == 0;\n    uVar4 = uVar6;\n  }\n  else {\n    uVar1 = (uVar12 & 0xffffffff) * (ulonglong)param_3;\n    uVar12 = (uVar12 & 0xffffffff) * (ulonglong)param_4 +\n             (ulonglong)uVar3 * (ulonglong)param_3 + (uVar1 >> 0x20);\n    uVar8 = (uint)uVar12;\n    lVar2 = (ulonglong)uVar3 * (ulonglong)param_4 + (uVar12 >> 0x20);\n    uVar7 = (uint)lVar2;\n    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);\n    if ((int)uVar1 != 0) {\n      uVar8 = uVar8 | 1;\n    }\n    uVar6 = (iVar5 + -0x3ff) - (uint)(uVar3 < 0x200);\n    if (uVar3 < 0x200) {\n      bVar9 = (uVar8 & 0x80000000) != 0;\n      uVar8 = uVar8 << 1;\n      lVar2 = CONCAT44(uVar3 * 2 + (uint)(CARRY4(uVar7,uVar7) || CARRY4(uVar7 * 2,(uint)bVar9)),\n                       uVar7 * 2 + (uint)bVar9);\n    }\n    param_4 = uVar4 & 0x80000000 | (int)((ulonglong)lVar2 >> 0x20) << 0xb | (uint)lVar2 >> 0x15;\n    param_3 = (uint)lVar2 << 0xb | uVar8 >> 0x15;\n    uVar7 = uVar8 * 0x800;\n    bVar10 = 0xfc < uVar6;\n    bVar11 = SBORROW4(uVar6,0xfd);\n    uVar3 = uVar6 - 0xfd;\n    bVar9 = uVar3 == 0;\n    uVar4 = uVar3;\n    if (bVar10 && !bVar9) {\n      bVar10 = 0x6ff < uVar3;\n      bVar11 = SBORROW4(uVar3,0x700);\n      uVar4 = uVar6 - 0x7fd;\n      bVar9 = uVar3 == 0x700;\n    }\n    if (!bVar10 || bVar9) {\n      bVar9 = 0x7fffffff < uVar7;\n      if (uVar7 == 0x80000000) {\n        bVar9 = (uVar8 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(param_4 + uVar6 * 0x100000 + (uint)CARRY4(param_3,(uint)bVar9),param_3 + bVar9\n                     );\n    }\n  }\n  if (!bVar9 && (int)uVar4 < 0 == bVar11) {\n    return (ulonglong)(param_4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bVar10 = SCARRY4(uVar6,0x36);\n  bVar9 = (int)(uVar6 + 0x36) < 0;\n  bVar11 = uVar6 == 0xffffffca;\n  if (bVar11 || bVar9 != bVar10) {\n    param_3 = 0;\n  }\n  if (bVar11 || bVar9 != bVar10) {\n    param_4 = param_4 & 0x80000000;\n  }\n  if (bVar11 || bVar9 != bVar10) {\n    return CONCAT44(param_4,param_3);\n  }\n  uVar4 = -uVar6;\n  uVar3 = uVar4 - 0x20;\n  if (0x1f < (int)uVar4) {\n    uVar6 = param_3 >> (uVar3 & 0xff) | param_4 << (0x20 - uVar3 & 0xff);\n    uVar4 = (param_4 >> (uVar3 & 0xff) & ~((param_4 & 0x80000000) >> (uVar3 & 0xff))) -\n            ((int)uVar6 >> 0x1f);\n    if ((uVar7 | param_3 << (0x20 - uVar3 & 0xff) | uVar6 << 1) == 0) {\n      uVar4 = uVar4 & ~(uVar6 >> 0x1f);\n    }\n    return CONCAT44(param_4,uVar4) & 0x80000000ffffffff;\n  }\n  iVar5 = uVar4 - 0x14;\n  if (iVar5 == 0 || iVar5 < 0 != SCARRY4(uVar3,0xc)) {\n    uVar8 = param_3 << (uVar6 + 0x20 & 0xff);\n    uVar3 = param_3 >> (uVar4 & 0xff) | param_4 << (uVar6 + 0x20 & 0xff);\n    uVar6 = uVar3 + -((int)uVar8 >> 0x1f);\n    if ((uVar7 | uVar8 << 1) == 0) {\n      uVar6 = uVar6 & ~(uVar8 >> 0x1f);\n    }\n    return CONCAT44((param_4 & 0x80000000) +\n                    ((param_4 & 0x7fffffff) >> (uVar4 & 0xff)) +\n                    (uint)CARRY4(uVar3,-((int)uVar8 >> 0x1f)),uVar6);\n  }\n  uVar4 = 0xc - iVar5;\n  uVar6 = param_3 << (uVar4 & 0xff);\n  uVar4 = param_3 >> (0x20 - uVar4 & 0xff) | param_4 << (uVar4 & 0xff);\n  uVar3 = uVar4 + -((int)uVar6 >> 0x1f);\n  if ((uVar7 | uVar6 << 1) == 0) {\n    uVar3 = uVar3 & ~(uVar6 >> 0x1f);\n  }\n  return CONCAT44((param_4 & 0x80000000) + (uint)CARRY4(uVar4,-((int)uVar6 >> 0x1f)),uVar3);\n}\n\n", 
            "called": [
                "FUN_080006d4"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080004f8", 
            "calling": [
                "readThermocouple", 
                "SetSampleTime", 
                "Compute", 
                "SetTunings", 
                "printFloat"
            ], 
            "imported": false, 
            "current_name": "__muldf3"
        }, 
        "uart_attach_tx_callback": {
            "renaming": {}, 
            "code": "\nvoid uart_attach_tx_callback(serial_t *obj,_func_int_serial_t_ptr *callback)\n\n{\n  byte bVar1;\n  \n  if (obj != (serial_t *)0x0) {\n    bVar1 = obj->index;\n    *(_func_int_serial_t_ptr **)(PTR_tx_callback_080055b0 + (uint)bVar1 * 4) = callback;\n    *(serial_t **)(PTR_tx_callback_obj_080055b4 + (uint)bVar1 * 4) = obj;\n    HAL_NVIC_SetPriority(obj->irq,0,2);\n    HAL_NVIC_EnableIRQ(obj->irq);\n    HAL_UART_Transmit_IT\n              (*(UART_HandleTypeDef **)(PTR_uart_handlers_080055b8 + (uint)obj->index * 4),\n               obj->tx_buff + obj->tx_tail,1);\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_Transmit_IT", 
                "HAL_NVIC_EnableIRQ", 
                "HAL_NVIC_SetPriority"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005568", 
            "calling": [
                "write"
            ], 
            "imported": false, 
            "current_name": "uart_attach_tx_callback"
        }, 
        "__throw_bad_function_call": {
            "renaming": {}, 
            "code": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n/* std::__throw_bad_function_call() */\n\nvoid std::__throw_bad_function_call(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
            "called": [
                "abort"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007090", 
            "calling": [
                "operator()"
            ], 
            "imported": false, 
            "current_name": "__throw_bad_function_call"
        }, 
        "RCC_Delay": {
            "renaming": {}, 
            "code": "\nvoid RCC_Delay(uint32_t mdelay)\n\n{\n  bool bVar1;\n  uint32_t Delay;\n  \n  Delay = mdelay * (uint)((ulonglong)DAT_08003684 * (ulonglong)*(uint *)PTR_SystemCoreClock_08003680\n                         >> 0x29);\n  do {\n    bVar1 = Delay != 0;\n    Delay = Delay - 1;\n  } while (bVar1);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800365c", 
            "calling": [
                "HAL_RCC_OscConfig"
            ], 
            "imported": false, 
            "current_name": "RCC_Delay"
        }, 
        "_lseek_r": {
            "renaming": {}, 
            "code": "\nvoid _lseek_r(int *param_1,int param_2,int param_3,int param_4)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_08007068;\n  *(undefined4 *)PTR_errno_08007068 = 0;\n  iVar2 = _lseek(param_2,param_3,param_4);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_lseek"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007048", 
            "calling": [
                "__sseek", 
                "__swrite"
            ], 
            "imported": false, 
            "current_name": "_lseek_r"
        }, 
        "printTo": {
            "renaming": {}, 
            "code": "\nsize_t __thiscall IPAddress::printTo(IPAddress *this,Print *p)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  int iVar3;\n  int iVar4;\n  \n  iVar4 = 0;\n  for (iVar3 = 0; iVar3 < 3; iVar3 = iVar3 + 1) {\n    sVar1 = Print::print(p,(this->_address).bytes[iVar3],10);\n    sVar2 = Print::print(p,'.');\n    iVar4 = iVar4 + sVar1 + sVar2;\n  }\n  sVar1 = Print::print(p,(this->_address).bytes[3],10);\n  return sVar1 + iVar4;\n}\n\n", 
            "called": [
                "print", 
                "print"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005be2", 
            "calling": [], 
            "imported": false, 
            "current_name": "printTo"
        }, 
        "__sfmoreglue": {
            "renaming": {}, 
            "code": "\nundefined4 * __sfmoreglue(undefined4 param_1,int param_2)\n\n{\n  undefined4 *puVar1;\n  int iVar2;\n  \n  iVar2 = (param_2 + -1) * 0x68;\n  puVar1 = (undefined4 *)_malloc_r(param_1,iVar2 + 0x74);\n  if (puVar1 != (undefined4 *)0x0) {\n    *puVar1 = 0;\n    puVar1[1] = param_2;\n    puVar1[2] = puVar1 + 3;\n    memset(puVar1 + 3,0,iVar2 + 0x68);\n  }\n  return puVar1;\n}\n\n", 
            "called": [
                "_malloc_r", 
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006c88", 
            "calling": [
                "__sfp"
            ], 
            "imported": false, 
            "current_name": "__sfmoreglue"
        }, 
        "pinmap_find_pin": {
            "renaming": {}, 
            "code": "\nPinName_conflict pinmap_find_pin(void *peripheral,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map->peripheral == (void *)0x0) {\n      return NC;\n    }\n    if (map->peripheral == peripheral) break;\n    map = map + 1;\n  }\n  return map->pin;\n}\n\n", 
            "called": [
                "pinmap_find_pin"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004c8a", 
            "calling": [
                "pinmap_find_pin", 
                "pinmap_pin"
            ], 
            "imported": false, 
            "current_name": "pinmap_find_pin"
        }, 
        "_raise_r": {
            "renaming": {}, 
            "code": "\nundefined4 _raise_r(undefined4 *param_1,uint param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t _Var1;\n  undefined4 uVar2;\n  int iVar3;\n  code *pcVar4;\n  \n  if (0x1f < param_2) {\n    *param_1 = 0x16;\n    return 0xffffffff;\n  }\n  iVar3 = param_1[0x11];\n  if ((iVar3 != 0) && (pcVar4 = *(code **)(iVar3 + param_2 * 4), pcVar4 != (code *)0x0)) {\n    if (pcVar4 != (code *)0x1) {\n      if (pcVar4 == (code *)0xffffffff) {\n        *param_1 = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(iVar3 + param_2 * 4) = 0;\n      (*pcVar4)(param_2);\n    }\n    return 0;\n  }\n  _Var1 = _getpid_r();\n  uVar2 = _kill_r(param_1,_Var1,param_2,param_4);\n  return uVar2;\n}\n\n", 
            "called": [
                "_getpid_r", 
                "_kill_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006eb0", 
            "calling": [
                "raise"
            ], 
            "imported": false, 
            "current_name": "_raise_r"
        }, 
        "_GLOBAL__sub_I_ctype_byname": {
            "renaming": {}, 
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::_GLOBAL__sub_I_ctype_byname(void)\n\n{\n  if (-1 < *(int *)PTR_id_08007308 << 0x1f) {\n    *(undefined4 *)PTR_id_08007308 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800730c << 0x1f) {\n    *(undefined4 *)PTR_id_0800730c = 1;\n  }\n  if (-1 < *(int *)PTR_id_08007310 << 0x1f) {\n    *(undefined4 *)PTR_id_08007310 = 1;\n  }\n  if (-1 < *(int *)PTR_id_08007314 << 0x1f) {\n    *(undefined4 *)PTR_id_08007314 = 1;\n  }\n  if (-1 < *(int *)PTR_id_08007318 << 0x1f) {\n    *(undefined4 *)PTR_id_08007318 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800731c << 0x1f) {\n    *(undefined4 *)PTR_id_0800731c = 1;\n  }\n  if (-1 < *(int *)PTR_id_08007320 << 0x1f) {\n    *(undefined4 *)PTR_id_08007320 = 1;\n  }\n  if (-1 < *(int *)PTR_id_08007324 << 0x1f) {\n    *(undefined4 *)PTR_id_08007324 = 1;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080072a4", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I_ctype_byname"
        }, 
        "_close": {
            "renaming": {}, 
            "code": "\nint _close(int file_UNUSED)\n\n{\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005714", 
            "calling": [
                "_close_r"
            ], 
            "imported": false, 
            "current_name": "_close"
        }, 
        "begin": {
            "renaming": {}, 
            "code": "\nvoid __thiscall HardwareSerial::begin(HardwareSerial *this,ulong baud,byte config)\n\n{\n  byte bVar1;\n  int iVar2;\n  \n  (this->_serial).baudrate = baud;\n  this->_config = config;\n  bVar1 = config & 7;\n  if (bVar1 == 4) {\n    iVar2 = 7;\n  }\n  else if (bVar1 == 6) {\n    iVar2 = 8;\n  }\n  else if (bVar1 == 2) {\n    iVar2 = 6;\n  }\n  else {\n    iVar2 = 0;\n  }\n  if ((config & 0x30) == 0x30) {\n    (this->_serial).parity = 0x600;\n    iVar2 = iVar2 + 1;\n  }\n  else if ((config & 0x20) == 0) {\n    (this->_serial).parity = 0;\n  }\n  else {\n    (this->_serial).parity = 0x400;\n    iVar2 = iVar2 + 1;\n  }\n  if ((config & 8) == 0) {\n    (this->_serial).stopbits = 0;\n  }\n  else {\n    (this->_serial).stopbits = 0x2000;\n  }\n  if (iVar2 == 8) {\n    (this->_serial).databits = 0;\n  }\n  else if (iVar2 == 9) {\n    (this->_serial).databits = 0x1000;\n  }\n  else {\n    iVar2 = 0;\n  }\n  if (iVar2 != 0) {\n    uart_init((serial_t *)&this->_serial);\n    uart_attach_rx_callback((serial_t *)&this->_serial,DAT_08005b14);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __assert_func(PTR_s__home_bo__arduino15_packages_STM_08005b20,299,PTR___PRETTY_FUNTION___08005b1c\n                ,PTR_s_databits__0_08005b18);\n}\n\n",
            "called": [
                "uart_init", 
                "__assert_func", 
                "uart_attach_rx_callback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005a68", 
            "calling": [
                "setup"
            ], 
            "imported": false, 
            "current_name": "begin"
        }, 
        "EXTI4_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI4_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(0x10);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800609c", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI4_IRQHandler"
        }, 
        "serial_tx_active": {
            "renaming": {}, 
            "code": "\nuint8_t serial_tx_active(serial_t *obj)\n\n{\n  HAL_UART_StateTypeDef HVar1;\n  \n  HVar1 = HAL_UART_GetState(*(UART_HandleTypeDef **)\n                             (PTR_uart_handlers_080054d0 + (uint)obj->index * 4));\n  return (HVar1 & 0x21U) == 0x21;\n}\n\n", 
            "called": [
                "HAL_UART_GetState"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080054b0", 
            "calling": [
                "write"
            ], 
            "imported": false, 
            "current_name": "serial_tx_active"
        }, 
        "HAL_UART_Init": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_UART_Init(UART_HandleTypeDef *huart)\n\n{\n  if (huart != (UART_HandleTypeDef *)0x0) {\n    if (huart->gState == HAL_UART_STATE_RESET) {\n      huart->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(huart);\n    }\n    huart->gState = HAL_UART_STATE_BUSY;\n    huart->Instance->CR1 = huart->Instance->CR1 & 0xffffdfff;\n    UART_SetConfig(huart);\n    huart->Instance->CR2 = huart->Instance->CR2 & 0xffffb7ff;\n    huart->Instance->CR3 = huart->Instance->CR3 & 0xffffffd5;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x2000;\n    huart->ErrorCode = 0;\n    huart->gState = HAL_UART_STATE_READY;\n    huart->RxState = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n", 
            "called": [
                "HAL_UART_MspInit", 
                "UART_SetConfig"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800441a", 
            "calling": [
                "uart_init"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_Init"
        }, 
        "_tx_complete_irq": {
            "renaming": {}, 
            "code": "\nint HardwareSerial::_tx_complete_irq(serial_t_conflict *obj)\n\n{\n  ushort uVar1;\n  uint16_t uVar2;\n  int iVar3;\n  \n  iVar3 = obj->tx_tail + 1;\n  uVar1 = (ushort)iVar3;\n  uVar2 = uVar1 & 0x7f;\n  if (iVar3 == 0) {\n    uVar2 = -(-uVar1 & 0x7f);\n  }\n  obj->tx_tail = uVar2;\n  if (obj->tx_head != obj->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080058ea", 
            "calling": [], 
            "imported": false, 
            "current_name": "_tx_complete_irq"
        }, 
        "HAL_UART_Transmit_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_UART_Transmit_IT(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size)\n\n{\n  if (huart->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (pData == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (Size == 0) {\n    return HAL_ERROR;\n  }\n  if (huart->Lock != HAL_LOCKED) {\n    huart->pTxBuffPtr = pData;\n    huart->TxXferSize = Size;\n    huart->TxXferCount = Size;\n    huart->ErrorCode = 0;\n    huart->gState = HAL_UART_STATE_BUSY_TX;\n    huart->Lock = HAL_UNLOCKED;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800455a", 
            "calling": [
                "uart_attach_tx_callback", 
                "HAL_UART_TxCpltCallback"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_Transmit_IT"
        }, 
        "__subdf3": {
            "renaming": {}, 
            "code": "\nulonglong __subdf3(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar6 = param_4 ^ 0x80000000;\n  uVar9 = param_2 << 1;\n  param_4 = param_4 << 1;\n  bVar13 = ((param_2 ^ uVar6) & 0x7fffffff) == 0;\n  bVar14 = bVar13 && param_1 == param_3;\n  if (!bVar13 || param_1 != param_3) {\n    bVar14 = (uVar9 | param_1) == 0;\n  }\n  if (!bVar14) {\n    bVar14 = (param_4 | param_3) == 0;\n  }\n  iVar8 = (int)uVar9 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar8 == -1;\n  }\n  iVar1 = (int)param_4 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar1 == -1;\n  }\n  if (bVar14) {\n    if (iVar8 == -1 || iVar1 == -1) {\n      uVar9 = uVar6;\n      uVar11 = param_3;\n      if (iVar8 == -1) {\n        uVar9 = param_2;\n        uVar11 = param_1;\n      }\n      if (iVar8 != -1 || iVar1 != -1) {\n        param_3 = uVar11;\n        uVar6 = uVar9;\n      }\n      bVar14 = (uVar11 | uVar9 << 0xc) == 0;\n      if (bVar14) {\n        bVar14 = (param_3 | uVar6 << 0xc) == 0;\n      }\n      if (bVar14) {\n        bVar14 = uVar9 == uVar6;\n      }\n      if (!bVar14) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar11);\n    }\n    if (((param_2 ^ uVar6) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((uVar9 | param_1) == 0) {\n        param_1 = param_3;\n        param_2 = uVar6;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 != uVar6) {\n      return 0;\n    }\n    if (uVar9 >> 0x15 == 0) {\n      bVar14 = (param_1 & 0x80000000) != 0;\n      uVar6 = param_2 * 2 + (uint)bVar14;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar6 = uVar6 | 0x80000000;\n      }\n      return CONCAT44(uVar6,param_1 << 1);\n    }\n    if (uVar9 < 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 = param_2 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(param_2 | 0x7ff00000) << 0x20;\n  }\n  uVar9 = uVar9 >> 0x15;\n  param_4 = param_4 >> 0x15;\n  uVar11 = param_4 - uVar9;\n  bVar14 = uVar11 != 0;\n  if (param_4 < uVar9) {\n    uVar11 = -uVar11;\n  }\n  uVar10 = param_1;\n  uVar7 = param_2;\n  if (bVar14 && uVar9 <= param_4) {\n    uVar9 = uVar9 + uVar11;\n    uVar10 = param_3;\n    uVar7 = uVar6;\n    param_3 = param_1;\n    uVar6 = param_2;\n  }\n  if (0x36 < uVar11) {\n    return CONCAT44(uVar7,uVar10);\n  }\n  uVar4 = uVar7 & 0xfffff | 0x100000;\n  if ((uVar7 & 0x80000000) != 0) {\n    bVar14 = uVar10 != 0;\n    uVar10 = -uVar10;\n    uVar4 = -uVar4 - (uint)bVar14;\n  }\n  uVar7 = uVar6 & 0xfffff | 0x100000;\n  if ((uVar6 & 0x80000000) != 0) {\n    bVar14 = param_3 != 0;\n    param_3 = -param_3;\n    uVar7 = -uVar7 - (uint)bVar14;\n  }\n  if (uVar9 == uVar11) {\n    uVar7 = uVar7 ^ 0x100000;\n    if (uVar9 == 0) {\n      uVar4 = uVar4 ^ 0x100000;\n      uVar9 = 1;\n    }\n    else {\n      uVar11 = uVar11 - 1;\n    }\n  }\n  uVar6 = -uVar11 + 0x20;\n  if ((int)uVar11 < 0x21) {\n    uVar12 = param_3 << (uVar6 & 0xff);\n    param_3 = param_3 >> (uVar11 & 0xff);\n    uVar3 = uVar10 + param_3;\n    uVar5 = uVar7 << (uVar6 & 0xff);\n    uVar6 = uVar3 + uVar5;\n    uVar4 = uVar4 + CARRY4(uVar10,param_3) + ((int)uVar7 >> (uVar11 & 0xff)) +\n            (uint)CARRY4(uVar3,uVar5);\n  }\n  else {\n    uVar12 = uVar7 << (-uVar11 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      uVar12 = uVar12 | 2;\n    }\n    uVar7 = (int)uVar7 >> (uVar11 - 0x20 & 0xff);\n    uVar6 = uVar10 + uVar7;\n    uVar4 = uVar4 + ((int)uVar7 >> 0x1f) + (uint)CARRY4(uVar10,uVar7);\n  }\n  param_2 = uVar4 & 0x80000000;\n  uVar11 = uVar4;\n  if ((int)uVar4 < 0) {\n    bVar14 = uVar12 == 0;\n    uVar12 = -uVar12;\n    uVar11 = -uVar6;\n    uVar6 = -(uint)!bVar14 - uVar6;\n    uVar11 = -(uint)(bVar14 <= uVar11) - uVar4;\n  }\n  if (0xfffff < uVar11) {\n    uVar10 = uVar9 - 1;\n    if (0x1fffff < uVar11) {\n      uVar10 = uVar11 & 1;\n      uVar11 = uVar11 >> 1;\n      bVar2 = (byte)uVar6;\n      uVar6 = (uint)(uVar10 != 0) << 0x1f | uVar6 >> 1;\n      uVar12 = (uint)(bVar2 & 1) << 0x1f | uVar12 >> 1;\n      uVar10 = uVar9;\n      if (0xffbfffff < uVar9 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    bVar14 = 0x7fffffff < uVar12;\n    if (uVar12 == 0x80000000) {\n      bVar14 = (uVar6 & 1) != 0;\n    }\n    return CONCAT44(uVar11 + uVar10 * 0x100000 + (uint)CARRY4(uVar6,(uint)bVar14) | param_2,\n                    uVar6 + bVar14);\n  }\n  bVar13 = (uVar12 & 0x80000000) != 0;\n  uVar12 = uVar12 << 1;\n  uVar10 = uVar6 * 2;\n  bVar14 = CARRY4(uVar6,uVar6);\n  uVar6 = uVar6 * 2 + (uint)bVar13;\n  uVar11 = uVar11 * 2 + (uint)(bVar14 || CARRY4(uVar10,(uint)bVar13));\n  uVar10 = uVar9 - 2;\n  if ((uVar11 & 0x100000) != 0) goto LAB_080002a0;\n  uVar7 = uVar6;\n  uVar9 = uVar11;\n  if (uVar11 == 0) {\n    uVar7 = 0;\n    uVar9 = uVar6;\n  }\n  iVar8 = count_leading_zeroes(uVar9);\n  if (uVar11 == 0) {\n    iVar8 = iVar8 + 0x20;\n  }\n  uVar11 = iVar8 - 0xb;\n  bVar15 = SBORROW4(uVar11,0x20);\n  uVar6 = iVar8 - 0x2b;\n  bVar14 = (int)uVar6 < 0;\n  bVar13 = uVar6 == 0;\n  if ((int)uVar11 < 0x20) {\n    bVar15 = SCARRY4(uVar6,0xc);\n    iVar8 = iVar8 + -0x1f;\n    bVar14 = iVar8 < 0;\n    bVar13 = iVar8 == 0;\n    uVar6 = uVar11;\n    if (!bVar13 && bVar14 == bVar15) {\n      uVar7 = uVar9 << (uVar11 & 0xff);\n      uVar9 = uVar9 >> (0xcU - iVar8 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar12 = 0x20 - uVar6;\n  }\n  uVar9 = uVar9 << (uVar6 & 0xff);\n  if (bVar13 || bVar14 != bVar15) {\n    uVar9 = uVar9 | uVar7 >> (uVar12 & 0xff);\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar7 = uVar7 << (uVar6 & 0xff);\n  }\nLAB_08000318:\n  if ((int)uVar11 <= (int)uVar10) {\n    return CONCAT44(uVar9 + (uVar10 - uVar11) * 0x100000 | param_2,uVar7);\n  }\n  uVar6 = ~(uVar10 - uVar11);\n  if ((int)uVar6 < 0x1f) {\n    iVar8 = uVar6 - 0x13;\n    if (iVar8 != 0 && iVar8 < 0 == SCARRY4(uVar6 - 0x1f,0xc)) {\n      return CONCAT44(uVar4,uVar7 >> (0x20 - (0xcU - iVar8) & 0xff) | uVar9 << (0xcU - iVar8 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar6 = uVar6 + 1;\n    return CONCAT44(param_2 | uVar9 >> (uVar6 & 0xff),\n                    uVar7 >> (uVar6 & 0xff) | uVar9 << (0x20 - uVar6 & 0xff));\n  }\n  return CONCAT44(uVar4,uVar9 >> (uVar6 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000190", 
            "calling": [
                "Compute", 
                "SetControllerDirection", 
                "SetTunings", 
                "printFloat"
            ], 
            "imported": false, 
            "current_name": "__subdf3"
        }, 
        "__aeabi_l2d": {
            "renaming": {}, 
            "code": "\nulonglong __aeabi_l2d(uint param_1,uint param_2)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  uint uVar9;\n  bool bVar10;\n  bool bVar11;\n  bool bVar12;\n  \n  if ((param_1 | param_2) == 0) {\n    return CONCAT44(param_2,param_1);\n  }\n  uVar8 = param_2 & 0x80000000;\n  uVar3 = param_2;\n  if ((int)uVar8 < 0) {\n    bVar11 = param_1 != 0;\n    param_1 = -param_1;\n    uVar3 = -param_2 - (uint)bVar11;\n  }\n  iVar7 = 0x432;\n  uVar9 = uVar3 >> 0x16;\n  if (uVar9 != 0) {\n    iVar7 = 3;\n    if (uVar3 >> 0x19 != 0) {\n      iVar7 = 6;\n    }\n    if (uVar3 >> 0x1c != 0) {\n      iVar7 = iVar7 + 3;\n    }\n    uVar4 = iVar7 - ((int)uVar3 >> 0x1f);\n    uVar9 = param_1 << (0x20 - uVar4 & 0xff);\n    param_1 = param_1 >> (uVar4 & 0xff) | uVar3 << (0x20 - uVar4 & 0xff);\n    uVar3 = uVar3 >> (uVar4 & 0xff);\n    iVar7 = uVar4 + 0x432;\n  }\n  if (0xfffff < uVar3) {\n    if (0x1fffff < uVar3) {\n      uVar4 = uVar3 & 1;\n      uVar3 = uVar3 >> 1;\n      bVar1 = (byte)param_1;\n      param_1 = (uint)(uVar4 != 0) << 0x1f | param_1 >> 1;\n      uVar9 = (uint)(bVar1 & 1) << 0x1f | uVar9 >> 1;\n      iVar7 = iVar7 + 1;\n      if (0xffbfffff < (uint)(iVar7 * 0x200000)) {\n        return (ulonglong)(uVar8 | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_080002a0:\n    bVar11 = 0x7fffffff < uVar9;\n    if (uVar9 == 0x80000000) {\n      bVar11 = (param_1 & 1) != 0;\n    }\n    return CONCAT44(uVar3 + iVar7 * 0x100000 + (uint)CARRY4(param_1,(uint)bVar11) | uVar8,\n                    param_1 + bVar11);\n  }\n  bVar10 = (uVar9 & 0x80000000) != 0;\n  uVar9 = uVar9 << 1;\n  uVar4 = param_1 * 2;\n  bVar11 = CARRY4(param_1,param_1);\n  param_1 = param_1 * 2 + (uint)bVar10;\n  uVar3 = uVar3 * 2 + (uint)(bVar11 || CARRY4(uVar4,(uint)bVar10));\n  iVar7 = iVar7 + -1;\n  if ((uVar3 & 0x100000) != 0) goto LAB_080002a0;\n  uVar2 = param_1;\n  uVar4 = uVar3;\n  if (uVar3 == 0) {\n    uVar2 = 0;\n    uVar4 = param_1;\n  }\n  iVar5 = count_leading_zeroes(uVar4);\n  if (uVar3 == 0) {\n    iVar5 = iVar5 + 0x20;\n  }\n  uVar6 = iVar5 - 0xb;\n  bVar12 = SBORROW4(uVar6,0x20);\n  uVar3 = iVar5 - 0x2b;\n  bVar11 = (int)uVar3 < 0;\n  bVar10 = uVar3 == 0;\n  if ((int)uVar6 < 0x20) {\n    bVar12 = SCARRY4(uVar3,0xc);\n    iVar5 = iVar5 + -0x1f;\n    bVar11 = iVar5 < 0;\n    bVar10 = iVar5 == 0;\n    uVar3 = uVar6;\n    if (!bVar10 && bVar11 == bVar12) {\n      uVar2 = uVar4 << (uVar6 & 0xff);\n      uVar4 = uVar4 >> (0xcU - iVar5 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar10 || bVar11 != bVar12) {\n    uVar9 = 0x20 - uVar3;\n  }\n  uVar4 = uVar4 << (uVar3 & 0xff);\n  if (bVar10 || bVar11 != bVar12) {\n    uVar4 = uVar4 | uVar2 >> (uVar9 & 0xff);\n  }\n  if (bVar10 || bVar11 != bVar12) {\n    uVar2 = uVar2 << (uVar3 & 0xff);\n  }\nLAB_08000318:\n  if ((int)uVar6 <= iVar7) {\n    return CONCAT44(uVar4 + (iVar7 - uVar6) * 0x100000 | uVar8,uVar2);\n  }\n  uVar3 = ~(iVar7 - uVar6);\n  if (0x1e < (int)uVar3) {\n    return CONCAT44(param_2,uVar4 >> (uVar3 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  iVar7 = uVar3 - 0x13;\n  if (iVar7 == 0 || iVar7 < 0 != SCARRY4(uVar3 - 0x1f,0xc)) {\n    uVar3 = uVar3 + 1;\n    return CONCAT44(uVar8 | uVar4 >> (uVar3 & 0xff),\n                    uVar2 >> (uVar3 & 0xff) | uVar4 << (0x20 - uVar3 & 0xff));\n  }\n  return CONCAT44(param_2,uVar2 >> (0x20 - (0xcU - iVar7) & 0xff) | uVar4 << (0xcU - iVar7 & 0xff))\n         & 0x80000000ffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800049c", 
            "calling": [], 
            "imported": false, 
            "current_name": "__aeabi_l2d"
        }, 
        "analogRead": {
            "renaming": {}, 
            "code": "\nuint32_t analogRead(uint32_t ulPin)\n\n{\n  bool bVar1;\n  PinName_conflict pin;\n  uint16_t uVar2;\n  uint32_t uVar3;\n  uint uVar4;\n  \n  if (ulPin < 0xe) {\n    if (ulPin + 0x2e < 0x3c) {\n      bVar1 = true;\n    }\n    else {\n      bVar1 = false;\n    }\n  }\n  else {\n    bVar1 = ulPin < 0x3c;\n  }\n  if (bVar1) {\n    if (ulPin < 0xe) {\n      ulPin = ulPin + 0x2e;\n    }\n    pin = PTR_digitalPin_080057ac[ulPin];\n  }\n  else {\n    pin = NC;\n  }\n  if (pin == NC) {\n    uVar3 = 0;\n  }\n  else {\n    uVar2 = adc_read_value(pin);\n    uVar3 = (uint32_t)uVar2;\n    uVar4 = *(uint *)PTR__readResolution_080057b0;\n    if (uVar4 != 0xc) {\n      if (uVar4 < 0xc) {\n        return (uint)(uVar2 >> (0xc - uVar4 & 0xff));\n      }\n      return uVar3 << (uVar4 - 0xc & 0xff);\n    }\n  }\n  return uVar3;\n}\n\n", 
            "called": [
                "adc_read_value"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005754", 
            "calling": [
                "loop"
            ], 
            "imported": false, 
            "current_name": "analogRead"
        }, 
        "printFloat": {
            "renaming": {}, 
            "code": "\nsize_t Print::printFloat(Print *this,double number,uint8_t digits)\n\n{\n  int iVar1;\n  ulong n;\n  size_t sVar2;\n  size_t sVar3;\n  byte bVar4;\n  longlong lVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  \n  iVar1 = __unorddf2();\n  if (iVar1 == 0) {\n    iVar1 = __unorddf2();\n    if ((iVar1 == 0) && (iVar1 = __aeabi_dcmple(), iVar1 == 0)) {\n      sVar3 = print(this,PTR_DAT_08005f20);\n    }\n    else {\n      iVar1 = __aeabi_dcmpgt();\n      if (iVar1 == 0) {\n        iVar1 = __aeabi_dcmplt();\n        if (iVar1 == 0) {\n          iVar1 = __aeabi_dcmplt();\n          if (iVar1 == 0) {\n            sVar3 = 0;\n          }\n          else {\n            sVar3 = print(this,'-');\n          }\n          lVar5 = (ulonglong)DAT_08005f14 << 0x20;\n          for (bVar4 = 0; bVar4 < number._0_1_; bVar4 = bVar4 + 1) {\n            lVar5 = __divdf3((int)lVar5,(int)((ulonglong)lVar5 >> 0x20),0,DAT_08005f18);\n          }\n          uVar6 = __aeabi_dadd();\n          n = __fixunsdfsi();\n          uVar7 = __floatunsidf();\n          uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),(int)uVar7,\n                           (int)((ulonglong)uVar7 >> 0x20));\n          sVar2 = print(this,n,10);\n          sVar3 = sVar3 + sVar2;\n          if (number._0_1_ != 0) {\n            sVar2 = print(this,PTR_DAT_08005f28);\n            sVar3 = sVar3 + sVar2;\n          }\n          while( true ) {\n            if (number._0_1_ == 0) break;\n            uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),0,DAT_08005f18);\n            iVar1 = __fixdfsi();\n            sVar2 = print(this,iVar1,10);\n            sVar3 = sVar3 + sVar2;\n            uVar7 = __floatsidf(iVar1);\n            uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),(int)uVar7,\n                             (int)((ulonglong)uVar7 >> 0x20));\n            number._0_1_ = number._0_1_ - 1;\n          }\n        }\n        else {\n          sVar3 = print(this,PTR_DAT_08005f24);\n        }\n      }\n      else {\n        sVar3 = print(this,PTR_DAT_08005f24);\n      }\n    }\n  }\n  else {\n    sVar3 = print(this,PTR_DAT_08005f1c);\n  }\n  return sVar3;\n}\n\n", 
            "called": [
                "print", 
                "__aeabi_dcmple", 
                "__divdf3", 
                "__fixunsdfsi", 
                "print", 
                "__muldf3", 
                "__subdf3", 
                "__aeabi_dadd", 
                "print", 
                "__unorddf2", 
                "__aeabi_dcmpgt", 
                "__aeabi_dcmplt", 
                "__floatunsidf", 
                "print", 
                "__fixdfsi", 
                "__floatsidf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005da8", 
            "calling": [
                "print"
            ], 
            "imported": false, 
            "current_name": "printFloat"
        }, 
        "_cleanup_r": {
            "renaming": {}, 
            "code": "\nvoid _cleanup_r(undefined4 param_1)\n\n{\n  _fwalk_reent(param_1,DAT_08006c3c);\n  return;\n}\n\n", 
            "called": [
                "_fwalk_reent"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006c34", 
            "calling": [], 
            "imported": false, 
            "current_name": "_cleanup_r"
        }, 
        "_kill": {
            "renaming": {}, 
            "code": "\nint _kill(int pid_UNUSED,int sig_UNUSED)\n\n{\n  *(undefined4 *)PTR_errno_0800574c = 0x16;\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005740", 
            "calling": [
                "_kill_r"
            ], 
            "imported": false, 
            "current_name": "_kill"
        }, 
        "HAL_NVIC_ClearPendingIRQ": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type_conflict IRQn)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)IRQn;\n  if (-1 < (int)uVar1) {\n    *(int *)(DAT_0800255c + ((uVar1 >> 5) + 0x60) * 4) = 1 << (uVar1 & 0x1f);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002540", 
            "calling": [
                "USART2_IRQHandler", 
                "USART3_IRQHandler", 
                "USART1_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_ClearPendingIRQ"
        }, 
        "_fstat": {
            "renaming": {}, 
            "code": "\nint _fstat(int file_UNUSED,stat *st)\n\n{\n  st->st_mode = 0x2000;\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800571a", 
            "calling": [
                "_fstat_r"
            ], 
            "imported": false, 
            "current_name": "_fstat"
        }, 
        "write8bits": {
            "renaming": {}, 
            "code": "\nvoid __thiscall LiquidCrystal::write8bits(LiquidCrystal *this,uint8_t value)\n\n{\n  uint uVar1;\n  \n  for (uVar1 = 0; (int)uVar1 < 8; uVar1 = uVar1 + 1) {\n    digitalWrite((uint)this->_data_pins[uVar1],(int)(uint)value >> (uVar1 & 0xff) & 1);\n  }\n  pulseEnable(this);\n  return;\n}\n\n", 
            "called": [
                "pulseEnable", 
                "digitalWrite"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080012e8", 
            "calling": [
                "send"
            ], 
            "imported": false, 
            "current_name": "write8bits"
        }, 
        "HAL_UART_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_IRQHandler(UART_HandleTypeDef *huart)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint uVar2;\n  USART_TypeDef *pUVar3;\n  uint uVar4;\n  uint uVar5;\n  \n  pUVar3 = huart->Instance;\n  uVar5 = pUVar3->SR;\n  uVar2 = pUVar3->CR1;\n  if ((((uVar5 & 0xf) == 0) && ((uVar5 & 0x20) != 0)) && ((uVar2 & 0x20) != 0)) {\n    UART_Receive_IT(huart);\n    return;\n  }\n  if (((uVar5 & 0xf) == 0) || ((uVar4 = pUVar3->CR3 & 1, uVar4 == 0 && ((uVar2 & 0x120) == 0)))) {\n    if (((uVar5 & 0x80) != 0) && ((uVar2 & 0x80) != 0)) {\n      UART_Transmit_IT(huart);\n      return;\n    }\n    if (((uVar5 & 0x40) != 0) && ((uVar2 & 0x40) != 0)) {\n      UART_EndTransmit_IT(huart);\n    }\n  }\n  else {\n    if (((uVar5 & 1) != 0) && ((uVar2 & 0x100) != 0)) {\n      huart->ErrorCode = huart->ErrorCode | 1;\n    }\n    if (((uVar5 & 4) != 0) && (uVar4 != 0)) {\n      huart->ErrorCode = huart->ErrorCode | 2;\n    }\n    if (((uVar5 & 2) != 0) && (uVar4 != 0)) {\n      huart->ErrorCode = huart->ErrorCode | 4;\n    }\n    if (((uVar5 & 8) != 0) && (uVar4 != 0)) {\n      huart->ErrorCode = huart->ErrorCode | 8;\n    }\n    if (huart->ErrorCode != 0) {\n      if (((uVar5 & 0x20) != 0) && ((uVar2 & 0x20) != 0)) {\n        UART_Receive_IT(huart);\n      }\n      if (((huart->ErrorCode & 8) == 0) && ((huart->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(huart);\n        huart->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(huart);\n      pUVar3 = huart->Instance;\n      if ((pUVar3->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      pUVar3->CR3 = pUVar3->CR3 & 0xffffffbf;\n      if (huart->hdmarx == (DMA_HandleTypeDef *)0x0) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      huart->hdmarx->XferAbortCallback = DAT_080047d4;\n      HVar1 = HAL_DMA_Abort_IT(huart->hdmarx);\n      if (HVar1 != HAL_OK) {\n        (*huart->hdmarx->XferAbortCallback)(huart->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_ErrorCallback", 
                "UART_Transmit_IT", 
                "HAL_DMA_Abort_IT", 
                "UART_EndTransmit_IT", 
                "UART_EndRxTransfer", 
                "UART_Receive_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080046b8", 
            "calling": [
                "USART2_IRQHandler", 
                "USART3_IRQHandler", 
                "USART1_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_IRQHandler"
        }, 
        "__aeabi_drsub": {
            "renaming": {}, 
            "code": "\nulonglong __aeabi_drsub(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar4 = param_2 ^ 0x80000000;\n  uVar7 = param_2 << 1;\n  uVar9 = param_4 << 1;\n  bVar13 = ((uVar4 ^ param_4) & 0x7fffffff) == 0;\n  bVar14 = bVar13 && param_1 == param_3;\n  if (!bVar13 || param_1 != param_3) {\n    bVar14 = (uVar7 | param_1) == 0;\n  }\n  if (!bVar14) {\n    bVar14 = (uVar9 | param_3) == 0;\n  }\n  iVar6 = (int)uVar7 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar6 == -1;\n  }\n  iVar1 = (int)uVar9 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar1 == -1;\n  }\n  if (bVar14) {\n    if (iVar6 == -1 || iVar1 == -1) {\n      uVar9 = param_4;\n      uVar7 = param_3;\n      if (iVar6 == -1) {\n        uVar9 = uVar4;\n        uVar7 = param_1;\n      }\n      if (iVar6 != -1 || iVar1 != -1) {\n        param_3 = uVar7;\n        param_4 = uVar9;\n      }\n      bVar14 = (uVar7 | uVar9 << 0xc) == 0;\n      if (bVar14) {\n        bVar14 = (param_3 | param_4 << 0xc) == 0;\n      }\n      if (bVar14) {\n        bVar14 = uVar9 == param_4;\n      }\n      if (!bVar14) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar7);\n    }\n    if (((uVar4 ^ param_4) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((uVar7 | param_1) == 0) {\n        param_1 = param_3;\n        uVar4 = param_4;\n      }\n      return CONCAT44(uVar4,param_1);\n    }\n    if (uVar4 != param_4) {\n      return 0;\n    }\n    if (uVar7 >> 0x15 == 0) {\n      bVar14 = (param_1 & 0x80000000) != 0;\n      uVar9 = param_2 * 2 + (uint)bVar14;\n      if (CARRY4(uVar4,uVar4) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar9 = uVar9 | 0x80000000;\n      }\n      return CONCAT44(uVar9,param_1 << 1);\n    }\n    if (uVar7 < 0xffc00000) {\n      return CONCAT44(uVar4 + 0x100000,param_1);\n    }\n    uVar4 = uVar4 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(uVar4 | 0x7ff00000) << 0x20;\n  }\n  uVar7 = uVar7 >> 0x15;\n  uVar9 = uVar9 >> 0x15;\n  uVar10 = uVar9 - uVar7;\n  bVar14 = uVar10 != 0;\n  if (uVar9 < uVar7) {\n    uVar10 = -uVar10;\n  }\n  uVar8 = param_1;\n  uVar12 = uVar4;\n  if (bVar14 && uVar7 <= uVar9) {\n    uVar7 = uVar7 + uVar10;\n    uVar8 = param_3;\n    uVar12 = param_4;\n    param_3 = param_1;\n    param_4 = uVar4;\n  }\n  if (0x36 < uVar10) {\n    return CONCAT44(uVar12,uVar8);\n  }\n  uVar9 = uVar12 & 0xfffff | 0x100000;\n  if ((uVar12 & 0x80000000) != 0) {\n    bVar14 = uVar8 != 0;\n    uVar8 = -uVar8;\n    uVar9 = -uVar9 - (uint)bVar14;\n  }\n  uVar4 = param_4 & 0xfffff | 0x100000;\n  if ((param_4 & 0x80000000) != 0) {\n    bVar14 = param_3 != 0;\n    param_3 = -param_3;\n    uVar4 = -uVar4 - (uint)bVar14;\n  }\n  if (uVar7 == uVar10) {\n    uVar4 = uVar4 ^ 0x100000;\n    if (uVar7 == 0) {\n      uVar9 = uVar9 ^ 0x100000;\n      uVar7 = 1;\n    }\n    else {\n      uVar10 = uVar10 - 1;\n    }\n  }\n  uVar12 = -uVar10 + 0x20;\n  if ((int)uVar10 < 0x21) {\n    uVar11 = param_3 << (uVar12 & 0xff);\n    param_3 = param_3 >> (uVar10 & 0xff);\n    uVar3 = uVar8 + param_3;\n    uVar5 = uVar4 << (uVar12 & 0xff);\n    uVar12 = uVar3 + uVar5;\n    uVar9 = uVar9 + CARRY4(uVar8,param_3) + ((int)uVar4 >> (uVar10 & 0xff)) +\n            (uint)CARRY4(uVar3,uVar5);\n  }\n  else {\n    uVar11 = uVar4 << (-uVar10 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      uVar11 = uVar11 | 2;\n    }\n    uVar4 = (int)uVar4 >> (uVar10 - 0x20 & 0xff);\n    uVar12 = uVar8 + uVar4;\n    uVar9 = uVar9 + ((int)uVar4 >> 0x1f) + (uint)CARRY4(uVar8,uVar4);\n  }\n  uVar4 = uVar9 & 0x80000000;\n  uVar10 = uVar9;\n  if ((int)uVar9 < 0) {\n    bVar14 = uVar11 == 0;\n    uVar11 = -uVar11;\n    uVar10 = -uVar12;\n    uVar12 = -(uint)!bVar14 - uVar12;\n    uVar10 = -(uint)(bVar14 <= uVar10) - uVar9;\n  }\n  if (0xfffff < uVar10) {\n    uVar8 = uVar7 - 1;\n    if (0x1fffff < uVar10) {\n      uVar9 = uVar10 & 1;\n      uVar10 = uVar10 >> 1;\n      bVar2 = (byte)uVar12;\n      uVar12 = (uint)(uVar9 != 0) << 0x1f | uVar12 >> 1;\n      uVar11 = (uint)(bVar2 & 1) << 0x1f | uVar11 >> 1;\n      uVar8 = uVar7;\n      if (0xffbfffff < uVar7 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    bVar14 = 0x7fffffff < uVar11;\n    if (uVar11 == 0x80000000) {\n      bVar14 = (uVar12 & 1) != 0;\n    }\n    return CONCAT44(uVar10 + uVar8 * 0x100000 + (uint)CARRY4(uVar12,(uint)bVar14) | uVar4,\n                    uVar12 + bVar14);\n  }\n  bVar13 = (uVar11 & 0x80000000) != 0;\n  uVar11 = uVar11 << 1;\n  uVar8 = uVar12 * 2;\n  bVar14 = CARRY4(uVar12,uVar12);\n  uVar12 = uVar12 * 2 + (uint)bVar13;\n  uVar10 = uVar10 * 2 + (uint)(bVar14 || CARRY4(uVar8,(uint)bVar13));\n  uVar8 = uVar7 - 2;\n  if ((uVar10 & 0x100000) != 0) goto LAB_080002a0;\n  uVar3 = uVar12;\n  uVar7 = uVar10;\n  if (uVar10 == 0) {\n    uVar3 = 0;\n    uVar7 = uVar12;\n  }\n  iVar6 = count_leading_zeroes(uVar7);\n  if (uVar10 == 0) {\n    iVar6 = iVar6 + 0x20;\n  }\n  uVar12 = iVar6 - 0xb;\n  bVar15 = SBORROW4(uVar12,0x20);\n  uVar10 = iVar6 - 0x2b;\n  bVar14 = (int)uVar10 < 0;\n  bVar13 = uVar10 == 0;\n  if ((int)uVar12 < 0x20) {\n    bVar15 = SCARRY4(uVar10,0xc);\n    iVar6 = iVar6 + -0x1f;\n    bVar14 = iVar6 < 0;\n    bVar13 = iVar6 == 0;\n    uVar10 = uVar12;\n    if (!bVar13 && bVar14 == bVar15) {\n      uVar3 = uVar7 << (uVar12 & 0xff);\n      uVar7 = uVar7 >> (0xcU - iVar6 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar11 = 0x20 - uVar10;\n  }\n  uVar7 = uVar7 << (uVar10 & 0xff);\n  if (bVar13 || bVar14 != bVar15) {\n    uVar7 = uVar7 | uVar3 >> (uVar11 & 0xff);\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar3 = uVar3 << (uVar10 & 0xff);\n  }\nLAB_08000318:\n  if ((int)uVar12 <= (int)uVar8) {\n    return CONCAT44(uVar7 + (uVar8 - uVar12) * 0x100000 | uVar4,uVar3);\n  }\n  uVar10 = ~(uVar8 - uVar12);\n  if ((int)uVar10 < 0x1f) {\n    iVar6 = uVar10 - 0x13;\n    if (iVar6 != 0 && iVar6 < 0 == SCARRY4(uVar10 - 0x1f,0xc)) {\n      return CONCAT44(uVar9,uVar3 >> (0x20 - (0xcU - iVar6) & 0xff) | uVar7 << (0xcU - iVar6 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar10 = uVar10 + 1;\n    return CONCAT44(uVar4 | uVar7 >> (uVar10 & 0xff),\n                    uVar3 >> (uVar10 & 0xff) | uVar7 << (0x20 - uVar10 & 0xff));\n  }\n  return CONCAT44(uVar9,uVar7 >> (uVar10 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n", 
            "called": [
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000188", 
            "calling": [], 
            "imported": false, 
            "current_name": "__aeabi_drsub"
        }, 
        "HAL_TIM_PWM_Stop": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim,uint32_t Channel)\n\n{\n  TIM_TypeDef *pTVar1;\n  \n  TIM_CCxChannelCmd(htim->Instance,Channel,0);\n  pTVar1 = htim->Instance;\n  if (((pTVar1 == DAT_0800410c) && ((pTVar1->CCER & 0x1111) == 0)) && ((pTVar1->CCER & 0x444) == 0))\n  {\n    pTVar1->BDTR = pTVar1->BDTR & 0xffff7fff;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->CCER & 0x1111) == 0) && ((pTVar1->CCER & 0x444) == 0)) {\n    pTVar1->CR1 = pTVar1->CR1 & 0xfffffffe;\n  }\n  htim->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n", 
            "called": [
                "TIM_CCxChannelCmd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080040b0", 
            "calling": [
                "pwm_stop"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_Stop"
        }, 
        "HAL_RTC_AlarmIRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)\n\n{\n  if (((hrtc->Instance->CRH & 2) != 0) && ((hrtc->Instance->CRL & 2) != 0)) {\n    HAL_RTC_AlarmAEventCallback(hrtc);\n    hrtc->Instance->CRL = 0xfffffffd;\n  }\n  *(undefined4 *)(DAT_08003ed4 + 0x14) = 0x20000;\n  hrtc->State = HAL_RTC_STATE_READY;\n  return;\n}\n\n", 
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003ea0", 
            "calling": [
                "RTC_Alarm_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_RTC_AlarmIRQHandler"
        }, 
        "display": {
            "renaming": {}, 
            "code": "\nvoid __thiscall LiquidCrystal::display(LiquidCrystal *this)\n\n{\n  byte bVar1;\n  \n  bVar1 = this->_displaycontrol;\n  this->_displaycontrol = bVar1 | 4;\n  send(this,bVar1 | 0xc,'\\0');\n  return;\n}\n\n", 
            "called": [
                "send"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800138e", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "display"
        }, 
        "EXTI2_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI2_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(4);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006088", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI2_IRQHandler"
        }, 
        "HAL_I2C_Slave_Sequential_Receive_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_I2C_Slave_Sequential_Receive_IT\n          (I2C_HandleTypeDef *hi2c,uint8_t *pData,uint16_t Size,uint32_t XferOptions)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  I2C_TypeDef *pIVar2;\n  uint32_t tmpreg;\n  \n  if (hi2c->State == HAL_I2C_STATE_LISTEN) {\n    if (pData == (uint8_t *)0x0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (Size == 0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (hi2c->Lock == HAL_LOCKED) {\n      HVar1 = HAL_BUSY;\n    }\n    else {\n      hi2c->Lock = HAL_LOCKED;\n      pIVar2 = hi2c->Instance;\n      if ((pIVar2->CR1 & 1) == 0) {\n        pIVar2->CR1 = pIVar2->CR1 | 1;\n      }\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffff7ff;\n      hi2c->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      hi2c->Mode = HAL_I2C_MODE_SLAVE;\n      HVar1 = HAL_OK;\n      hi2c->ErrorCode = 0;\n      hi2c->pBuffPtr = pData;\n      hi2c->XferCount = Size;\n      hi2c->XferOptions = XferOptions;\n      hi2c->XferSize = hi2c->XferCount;\n      hi2c->Lock = HAL_UNLOCKED;\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 = HAL_BUSY;\n  }\n  return HVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002b84", 
            "calling": [
                "HAL_I2C_AddrCallback"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_Slave_Sequential_Receive_IT"
        }, 
        "PID": {
            "renaming": {}, 
            "code": "\nPID * __thiscall\nPID::PID(PID *this,double *Input,double *Output,double *Setpoint,double Kp,double Ki,double Kd,\n        int ControllerDirection)\n\n{\n  PID(this,Input,Output,Setpoint,Kp,Ki,Kd,1,ControllerDirection);\n  return this;\n}\n\n", 
            "called": [
                "PID"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001b18", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "PID"
        }, 
        "_getpid": {
            "renaming": {}, 
            "code": "\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005750", 
            "calling": [
                "_getpid_r"
            ], 
            "imported": false, 
            "current_name": "_getpid"
        }, 
        "I2C_MasterReceive_BTF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)\n\n{\n  uint32_t uVar1;\n  uint8_t *puVar2;\n  \n  uVar1 = hi2c->XferOptions;\n  if (hi2c->XferCount == 3) {\n    if (((uVar1 == 4) || (uVar1 == 8)) || (uVar1 == 0xffff0000)) {\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n    }\n    puVar2 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar2 + 1;\n    *puVar2 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n  }\n  else if (hi2c->XferCount == 2) {\n    if (((uVar1 == 4) || (uVar1 == 8)) || (uVar1 == 0xffff0000)) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffcff;\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n    }\n    else {\n      if (uVar1 == 2) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n      }\n      else {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n      }\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffcff;\n    }\n    puVar2 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar2 + 1;\n    *puVar2 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n    puVar2 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar2 + 1;\n    *puVar2 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->PreviousState = 0;\n    if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(hi2c);\n    }\n    else {\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(hi2c);\n    }\n  }\n  else {\n    puVar2 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar2 + 1;\n    *puVar2 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_MemRxCpltCallback", 
                "HAL_I2C_MasterRxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800306c", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_MasterReceive_BTF"
        }, 
        "TIM3_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM3_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_08004e58 + 8) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_08004e58 + 8));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004e48", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM3_IRQHandler"
        }, 
        "peek": {
            "renaming": {}, 
            "code": "\nint __thiscall HardwareSerial::peek(HardwareSerial *this)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)(this->_serial).rx_tail;\n  if ((this->_serial).rx_head != uVar1) {\n    return (uint)(this->_serial).rx_buff[uVar1];\n  }\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005932", 
            "calling": [], 
            "imported": false, 
            "current_name": "peek"
        }, 
        "HAL_UART_Receive_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_UART_Receive_IT(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size)\n\n{\n  if (huart->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (pData == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (Size == 0) {\n    return HAL_ERROR;\n  }\n  if (huart->Lock != HAL_LOCKED) {\n    huart->pRxBuffPtr = pData;\n    huart->RxXferSize = Size;\n    huart->RxXferCount = Size;\n    huart->ErrorCode = 0;\n    huart->RxState = HAL_UART_STATE_BUSY_RX;\n    huart->Lock = HAL_UNLOCKED;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x100;\n    huart->Instance->CR3 = huart->Instance->CR3 | 1;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x20;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080045a2", 
            "calling": [
                "uart_getc", 
                "uart_attach_rx_callback"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_Receive_IT"
        }, 
        "I2C_Slave_ADDR": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c)\n\n{\n  uint16_t AddrMatchCode;\n  \n  if ((hi2c->Instance->SR2 & 0x80) == 0) {\n    AddrMatchCode = *(uint16_t *)&(hi2c->Init).OwnAddress1;\n  }\n  else {\n    AddrMatchCode = *(uint16_t *)&(hi2c->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(hi2c,(hi2c->Instance->SR2 & 4) == 0,AddrMatchCode);\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_AddrCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002cf2", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Slave_ADDR"
        }, 
        "memchr": {
            "renaming": {}, 
            "code": "\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n  byte *pbVar1;\n  byte *pbVar2;\n  \n  pbVar1 = (byte *)__s;\n  do {\n    pbVar2 = pbVar1;\n    if (pbVar2 == (byte *)(__n + (int)__s)) {\n      return (void *)0x0;\n    }\n    pbVar1 = pbVar2 + 1;\n  } while ((uint)*pbVar2 != (__c & 0xffU));\n  return pbVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006e90", 
            "calling": [
                "_printf_i", 
                "_vfiprintf_r"
            ], 
            "imported": false, 
            "current_name": "memchr"
        }, 
        "I2C1_ER_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid I2C1_ER_IRQHandler(void)\n\n{\n  HAL_I2C_ER_IRQHandler(*(I2C_HandleTypeDef **)PTR_i2c_handles_08004f28);\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004f1c", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C1_ER_IRQHandler"
        }, 
        "__sflush_r": {
            "renaming": {}, 
            "code": "\nundefined4 __sflush_r(uint *param_1,int *param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  uint uVar3;\n  ushort uVar4;\n  int iVar5;\n  code *pcVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  \n  uVar4 = *(ushort *)(param_2 + 3);\n  uVar3 = (uint)uVar4;\n  if ((int)(uVar3 << 0x1c) < 0) {\n    iVar1 = param_2[4];\n    if (iVar1 != 0) {\n      iVar5 = uVar3 << 0x1e;\n      bVar9 = iVar5 != 0;\n      if (bVar9) {\n        iVar5 = 0;\n      }\n      iVar7 = *param_2;\n      if (!bVar9) {\n        iVar5 = param_2[5];\n      }\n      *param_2 = iVar1;\n      param_2[2] = iVar5;\n      for (iVar7 = iVar7 - iVar1; 0 < iVar7; iVar7 = iVar7 - iVar5) {\n        iVar5 = (*(code *)param_2[10])(param_1,param_2[8],iVar1,iVar7);\n        if (iVar5 < 1) {\n          uVar4 = *(ushort *)(param_2 + 3);\n          goto LAB_08006bc6;\n        }\n        iVar1 = iVar1 + iVar5;\n      }\n    }\n  }\n  else if (((0 < param_2[1]) || (0 < param_2[0x10])) &&\n          (pcVar6 = (code *)param_2[0xb], pcVar6 != (code *)0x0)) {\n    uVar8 = *param_1;\n    *param_1 = 0;\n    if ((uVar4 & 0x1000) == 0) {\n      iVar1 = (*pcVar6)(param_1,param_2[8],uVar3 & 0x1000,1);\n      if ((iVar1 == -1) && (uVar3 = *param_1, uVar3 != 0)) {\n        if ((uVar3 != 0x1d) && (uVar3 != 0x16)) {\n          *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *param_1 = uVar8;\n        return 0;\n      }\n    }\n    else {\n      iVar1 = param_2[0x15];\n    }\n    if (((int)((uint)*(ushort *)(param_2 + 3) << 0x1d) < 0) &&\n       (iVar1 = iVar1 - param_2[1], param_2[0xd] != 0)) {\n      iVar1 = iVar1 - param_2[0x10];\n    }\n    iVar1 = (*(code *)param_2[0xb])(param_1,param_2[8],iVar1,0);\n    uVar4 = *(ushort *)(param_2 + 3);\n    if ((iVar1 == -1) &&\n       ((0x1d < *param_1 || (-1 < (int)((DAT_08006bdc >> (*param_1 & 0xff)) << 0x1f))))) {\nLAB_08006bc6:\n      *(ushort *)(param_2 + 3) = uVar4 | 0x40;\n      return 0xffffffff;\n    }\n    param_2[1] = 0;\n    *param_2 = param_2[4];\n    if (((int)((uint)uVar4 << 0x13) < 0) && ((iVar1 != -1 || (*param_1 == 0)))) {\n      param_2[0x15] = iVar1;\n    }\n    piVar2 = (int *)param_2[0xd];\n    *param_1 = uVar8;\n    if (piVar2 != (int *)0x0) {\n      if (piVar2 != param_2 + 0x11) {\n        _free_r(param_1);\n      }\n      param_2[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n", 
            "called": [
                "_free_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006ad0", 
            "calling": [
                "_fflush_r"
            ], 
            "imported": false, 
            "current_name": "__sflush_r"
        }, 
        "TIM4_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM4_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_08004e6c + 0xc) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_08004e6c + 0xc));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004e5c", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM4_IRQHandler"
        }, 
        "__floatsidf": {
            "renaming": {}, 
            "code": "\nulonglong __floatsidf(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  uint in_r12;\n  bool bVar7;\n  bool bVar8;\n  bool bVar9;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  uVar6 = param_1 & 0x80000000;\n  uVar2 = param_1;\n  if ((int)uVar6 < 0) {\n    uVar2 = -param_1;\n  }\n  uVar1 = 0;\n  iVar4 = count_leading_zeroes(uVar2);\n  uVar5 = iVar4 + 0x15;\n  bVar9 = SBORROW4(uVar5,0x20);\n  uVar3 = iVar4 - 0xb;\n  bVar7 = (int)uVar3 < 0;\n  bVar8 = uVar3 == 0;\n  if ((int)uVar5 < 0x20) {\n    bVar9 = SCARRY4(uVar3,0xc);\n    iVar4 = iVar4 + 1;\n    bVar7 = iVar4 < 0;\n    bVar8 = iVar4 == 0;\n    uVar3 = uVar5;\n    if (!bVar8 && bVar7 == bVar9) {\n      uVar1 = uVar2 << (uVar5 & 0xff);\n      uVar2 = uVar2 >> (0xcU - iVar4 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar8 || bVar7 != bVar9) {\n    in_r12 = 0x20 - uVar3;\n  }\n  uVar2 = uVar2 << (uVar3 & 0xff);\n  if (bVar8 || bVar7 != bVar9) {\n    uVar2 = uVar2 | 0U >> (in_r12 & 0xff);\n  }\n  if (bVar8 || bVar7 != bVar9) {\n    uVar1 = 0 << (uVar3 & 0xff);\n  }\nLAB_08000318:\n  if ((int)uVar5 < 0x433) {\n    return CONCAT44(uVar2 + (0x432 - uVar5) * 0x100000 | uVar6,uVar1);\n  }\n  uVar3 = ~(0x432 - uVar5);\n  if (0x1e < (int)uVar3) {\n    return CONCAT44(param_1,uVar2 >> (uVar3 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  iVar4 = uVar3 - 0x13;\n  if (iVar4 == 0 || iVar4 < 0 != SCARRY4(uVar3 - 0x1f,0xc)) {\n    uVar3 = uVar3 + 1;\n    return CONCAT44(uVar6 | uVar2 >> (uVar3 & 0xff),\n                    uVar1 >> (uVar3 & 0xff) | uVar2 << (0x20 - uVar3 & 0xff));\n  }\n  return CONCAT44(param_1,uVar1 >> (0x20 - (0xcU - iVar4) & 0xff) | uVar2 << (0xcU - iVar4 & 0xff))\n         & 0x80000000ffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800042c", 
            "calling": [
                "SetSampleTime", 
                "loop", 
                "printFloat"
            ], 
            "imported": false, 
            "current_name": "__floatsidf"
        }, 
        "__aeabi_dcmple": {
            "renaming": {}, 
            "code": "\nbool __aeabi_dcmple(void)\n\n{\n  undefined in_ZR;\n  undefined in_CY;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)in_CY || (bool)in_ZR;\n}\n\n", 
            "called": [
                "__aeabi_cdcmpeq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080009f0", 
            "calling": [
                "loop", 
                "printFloat"
            ], 
            "imported": false, 
            "current_name": "__aeabi_dcmple"
        }, 
        "noOsSystickHandler": {
            "renaming": {}, 
            "code": "\nvoid noOsSystickHandler(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004b9c", 
            "calling": [
                "SysTick_Handler"
            ], 
            "imported": false, 
            "current_name": "noOsSystickHandler"
        }, 
        "_printf_i": {
            "renaming": {}, 
            "code": "\nuint _printf_i(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint *puVar3;\n  void *pvVar4;\n  int iVar5;\n  undefined *puVar6;\n  uint uVar7;\n  uint **ppuVar8;\n  uint uVar9;\n  uint uVar10;\n  undefined *puVar11;\n  undefined *__s;\n  uint local_24 [2];\n  \n  bVar1 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  if (bVar1 != 0x6e) {\n    if (bVar1 < 0x6f) {\n      if (bVar1 != 99) {\n        if (bVar1 < 100) {\n          if (bVar1 == 0) goto LAB_0800686a;\n          if (bVar1 != 0x58) goto LAB_080066e0;\n          *(undefined *)((int)param_2 + 0x45) = 0x58;\n          puVar6 = PTR_s_0123456789ABCDEF_080068ec;\nLAB_080067fa:\n          uVar7 = *param_2;\n          puVar3 = *param_5;\n          *param_5 = puVar3 + 1;\n          if (((uVar7 & 0x80) == 0) && ((int)(uVar7 << 0x19) < 0)) {\n            uVar9 = (uint)*(ushort *)puVar3;\n          }\n          else {\n            uVar9 = *puVar3;\n          }\n          if ((int)(uVar7 << 0x1f) < 0) {\n            *param_2 = uVar7 | 0x20;\n          }\n          if (uVar9 == 0) {\n            *param_2 = *param_2 & 0xffffffdf;\n          }\n          uVar7 = 0x10;\nLAB_08006790:\n          *(undefined *)((int)param_2 + 0x43) = 0;\n        }\n        else {\n          if ((bVar1 != 100) && (bVar1 != 0x69)) goto LAB_080066e0;\n          uVar9 = *param_2;\n          puVar3 = *param_5;\n          if ((uVar9 & 0x80) == 0) {\n            *param_5 = puVar3 + 1;\n            if ((uVar9 & 0x40) == 0) goto LAB_08006700;\n            uVar9 = (uint)(short)*(ushort *)puVar3;\n          }\n          else {\n            *param_5 = puVar3 + 1;\nLAB_08006700:\n            uVar9 = *puVar3;\n          }\n          if ((int)uVar9 < 0) {\n            uVar9 = -uVar9;\n            *(undefined *)((int)param_2 + 0x43) = 0x2d;\n          }\n          uVar7 = 10;\n          puVar6 = PTR_s_0123456789ABCDEF_080068ec;\n        }\n        uVar10 = param_2[1];\n        param_2[2] = uVar10;\n        puVar11 = __s;\n        if ((int)uVar10 < 0) {\n          if (uVar9 != 0) goto LAB_0800682e;\nLAB_080068dc:\n          *(undefined *)((int)param_2 + 0x42) = *puVar6;\n          puVar11 = (undefined *)((int)param_2 + 0x42);\n        }\n        else {\n          *param_2 = *param_2 & 0xfffffffb;\n          if (uVar9 == 0) {\n            if (uVar10 != 0) goto LAB_080068dc;\n          }\n          else {\nLAB_0800682e:\n            do {\n              uVar10 = uVar9 / uVar7;\n              puVar11 = puVar11 + -1;\n              *puVar11 = puVar6[uVar9 - uVar7 * uVar10];\n              uVar9 = uVar10;\n            } while (uVar10 != 0);\n          }\n        }\n        if (((uVar7 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4]))\n        {\n          puVar11[-1] = 0x30;\n          puVar11 = puVar11 + -1;\n        }\n        param_2[4] = (int)__s - (int)puVar11;\n        __s = puVar11;\n        goto LAB_080067d6;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      *(char *)((int)param_2 + 0x42) = (char)*puVar3;\nLAB_08006740:\n      __s = (undefined *)((int)param_2 + 0x42);\n      uVar9 = 1;\n    }\n    else {\n      if (bVar1 != 0x73) {\n        if (bVar1 < 0x74) {\n          if (bVar1 == 0x6f) {\nLAB_08006766:\n            uVar9 = *param_2;\n            puVar3 = *param_5;\n            if ((uVar9 & 0x80) == 0) {\n              *param_5 = puVar3 + 1;\n              if ((uVar9 & 0x40) == 0) goto LAB_08006774;\n              uVar9 = (uint)*(ushort *)puVar3;\n            }\n            else {\n              *param_5 = puVar3 + 1;\nLAB_08006774:\n              uVar9 = *puVar3;\n            }\n            puVar6 = PTR_s_0123456789ABCDEF_080068ec;\n            if (bVar1 == 0x6f) {\n              uVar7 = 8;\n            }\n            else {\n              uVar7 = 10;\n            }\n            goto LAB_08006790;\n          }\n          if (bVar1 == 0x70) {\n            *param_2 = *param_2 | 0x20;\nLAB_08006726:\n            puVar6 = PTR_s_0123456789abcdef_080068e8;\n            *(undefined *)((int)param_2 + 0x45) = 0x78;\n            goto LAB_080067fa;\n          }\n        }\n        else {\n          if (bVar1 == 0x75) goto LAB_08006766;\n          if (bVar1 == 0x78) goto LAB_08006726;\n        }\nLAB_080066e0:\n        *(byte *)((int)param_2 + 0x42) = bVar1;\n        goto LAB_08006740;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      __s = (undefined *)*puVar3;\n      pvVar4 = memchr(__s,0,param_2[1]);\n      if (pvVar4 != (void *)0x0) {\n        param_2[1] = (int)pvVar4 - (int)__s;\n      }\n      uVar9 = param_2[1];\n    }\n    param_2[4] = uVar9;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_080067d6;\n  }\n  uVar9 = *param_2;\n  ppuVar8 = (uint **)*param_5;\n  uVar7 = param_2[5];\n  if ((uVar9 & 0x80) == 0) {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\n    if ((uVar9 & 0x40) == 0) goto LAB_08006856;\n    *(short *)puVar3 = (short)uVar7;\n  }\n  else {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\nLAB_08006856:\n    *puVar3 = uVar7;\n  }\nLAB_0800686a:\n  param_2[4] = 0;\nLAB_080067d6:\n  iVar2 = _printf_common(param_1,param_2,local_24,param_3,param_4);\n  if ((iVar2 == -1) || (iVar2 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar2 == -1)) {\nLAB_080067ea:\n    uVar9 = 0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar2 = 0; iVar2 < (int)(param_2[3] - local_24[0]); iVar2 = iVar2 + 1) {\n        iVar5 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar5 == -1) goto LAB_080067ea;\n      }\n    }\n    uVar9 = param_2[3];\n    if ((int)param_2[3] < (int)local_24[0]) {\n      uVar9 = local_24[0];\n    }\n  }\n  return uVar9;\n}\n\n", 
            "called": [
                "memchr", 
                "_printf_common"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080066b0", 
            "calling": [
                "_vfiprintf_r"
            ], 
            "imported": false, 
            "current_name": "_printf_i"
        }, 
        "digitalRead": {
            "renaming": {}, 
            "code": "\nint digitalRead(uint32_t ulPin)\n\n{\n  _Bool _Var1;\n  GPIO_TypeDef *port;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  if (ulPin < 0x3c) {\n    uVar3 = (uint)(char)PTR_digitalPin_080058d8[ulPin];\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  if (uVar3 == 0xffffffff) {\n    uVar3 = 0;\n  }\n  else {\n    _Var1 = is_pin_configured((PinName_conflict)uVar3,(uint32_t *)PTR_g_digPinConfigured_080058dc);\n    if (_Var1) {\n      port = get_GPIO_Port((uVar3 << 0x18) >> 0x1c);\n      uVar2 = digital_io_read(port,1 << (uVar3 & 0xf) & 0xffff);\n      uVar3 = uVar2 & 0xff;\n    }\n    else {\n      uVar3 = 0;\n    }\n  }\n  if (uVar3 != 0) {\n    uVar3 = 1;\n  }\n  return uVar3;\n}\n\n", 
            "called": [
                "is_pin_configured", 
                "get_GPIO_Port", 
                "digital_io_read"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005890", 
            "calling": [
                "loop", 
                "readData"
            ], 
            "imported": false, 
            "current_name": "digitalRead"
        }, 
        "HAL_UART_Transmit": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_UART_Transmit(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size,uint32_t Timeout)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t Tickstart;\n  \n  if (huart->gState == HAL_UART_STATE_READY) {\n    if (pData == (uint8_t *)0x0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (Size == 0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (huart->Lock == HAL_LOCKED) {\n      HVar1 = HAL_BUSY;\n    }\n    else {\n      huart->Lock = HAL_LOCKED;\n      huart->ErrorCode = 0;\n      huart->gState = HAL_UART_STATE_BUSY_TX;\n      Tickstart = HAL_GetTick();\n      huart->TxXferSize = Size;\n      huart->TxXferCount = Size;\n      while (huart->TxXferCount != 0) {\n        huart->TxXferCount = huart->TxXferCount - 1;\n        if ((huart->Init).WordLength == 0x1000) {\n          HVar1 = UART_WaitOnFlagUntilTimeout(huart,0x80,RESET,Tickstart,Timeout);\n          if (HVar1 != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          huart->Instance->DR = *(ushort *)pData & 0x1ff;\n          if ((huart->Init).Parity == 0) {\n            pData = (uint8_t *)((int)pData + 2);\n          }\n          else {\n            pData = (uint8_t *)((int)pData + 1);\n          }\n        }\n        else {\n          HVar1 = UART_WaitOnFlagUntilTimeout(huart,0x80,RESET,Tickstart,Timeout);\n          if (HVar1 != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          huart->Instance->DR = (uint)*pData;\n          pData = (uint8_t *)((int)pData + 1);\n        }\n      }\n      HVar1 = UART_WaitOnFlagUntilTimeout(huart,0x40,RESET,Tickstart,Timeout);\n      if (HVar1 == HAL_OK) {\n        huart->gState = HAL_UART_STATE_READY;\n        huart->Lock = HAL_UNLOCKED;\n      }\n      else {\n        HVar1 = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    HVar1 = HAL_BUSY;\n  }\n  return HVar1;\n}\n\n", 
            "called": [
                "UART_WaitOnFlagUntilTimeout", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004478", 
            "calling": [
                "uart_debug_write"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_Transmit"
        }, 
        "digital_io_read": {
            "renaming": {}, 
            "code": "\nuint32_t digital_io_read(GPIO_TypeDef *port,uint32_t pin)\n\n{\n  GPIO_PinState GVar1;\n  \n  GVar1 = HAL_GPIO_ReadPin(port,(uint16_t)pin);\n  return (uint)GVar1;\n}\n\n", 
            "called": [
                "HAL_GPIO_ReadPin"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004c48", 
            "calling": [
                "digitalRead"
            ], 
            "imported": false, 
            "current_name": "digital_io_read"
        }, 
        "main": {
            "renaming": {}, 
            "code": "\nint main(void)\n\n{\n  initVariant();\n  setup();\n  do {\n    do {\n      loop();\n    } while (DAT_08005f88 == 0);\n    serialEventRun();\n  } while( true );\n}\n\n", 
            "called": [
                "initVariant", 
                "loop", 
                "serialEventRun", 
                "setup"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005f6c", 
            "calling": [
                "Reset_Handler"
            ], 
            "imported": false, 
            "current_name": "main"
        }, 
        "_free_r": {
            "renaming": {}, 
            "code": "\nvoid _free_r(undefined4 *param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined *puVar1;\n  int **extraout_r1;\n  int **ppiVar2;\n  int **ppiVar3;\n  int *piVar4;\n  int **ppiVar5;\n  int **ppiVar6;\n  int **ppiVar7;\n  \n  if (param_2 == 0) {\n    return;\n  }\n  ppiVar7 = (int **)(param_2 + -4);\n  if (*(int *)(param_2 + -4) < 0) {\n    ppiVar7 = (int **)((int)ppiVar7 + *(int *)(param_2 + -4));\n  }\n  __malloc_lock();\n  puVar1 = PTR___malloc_free_list_08006284;\n  ppiVar5 = *(int ***)PTR___malloc_free_list_08006284;\n  if (ppiVar5 == (int **)0x0) {\n    ppiVar7[1] = (int *)0x0;\n    *(int ***)puVar1 = ppiVar7;\n    ppiVar2 = extraout_r1;\n    ppiVar3 = (int **)puVar1;\n  }\n  else if (ppiVar7 < ppiVar5) {\n    ppiVar2 = (int **)*ppiVar7;\n    ppiVar3 = (int **)((int)ppiVar7 + (int)ppiVar2);\n    if (ppiVar5 == ppiVar3) {\n      piVar4 = *ppiVar5;\n      ppiVar5 = (int **)ppiVar5[1];\n      ppiVar3 = (int **)((int)piVar4 + (int)ppiVar2);\n      *ppiVar7 = (int *)ppiVar3;\n    }\n    ppiVar7[1] = (int *)ppiVar5;\n    *(int ***)puVar1 = ppiVar7;\n  }\n  else {\n    do {\n      ppiVar6 = ppiVar5;\n      ppiVar3 = (int **)ppiVar6[1];\n      if (ppiVar3 == (int **)0x0) break;\n      ppiVar5 = ppiVar3;\n    } while (ppiVar3 <= ppiVar7);\n    ppiVar2 = (int **)*ppiVar6;\n    if ((int **)((int)ppiVar6 + (int)ppiVar2) == ppiVar7) {\n      ppiVar2 = (int **)((int)ppiVar2 + (int)*ppiVar7);\n      *ppiVar6 = (int *)ppiVar2;\n      if (ppiVar3 == (int **)((int)ppiVar6 + (int)ppiVar2)) {\n        piVar4 = *ppiVar3;\n        ppiVar3 = (int **)ppiVar3[1];\n        ppiVar2 = (int **)((int)ppiVar2 + (int)piVar4);\n        *ppiVar6 = (int *)ppiVar2;\n        ppiVar6[1] = (int *)ppiVar3;\n      }\n    }\n    else if (ppiVar7 < (int **)((int)ppiVar6 + (int)ppiVar2)) {\n      *param_1 = 0xc;\n    }\n    else {\n      ppiVar2 = (int **)((int)ppiVar7 + (int)*ppiVar7);\n      if (ppiVar3 == ppiVar2) {\n        piVar4 = *ppiVar3;\n        ppiVar3 = (int **)ppiVar3[1];\n        ppiVar2 = (int **)((int)piVar4 + (int)*ppiVar7);\n        *ppiVar7 = (int *)ppiVar2;\n      }\n      ppiVar7[1] = (int *)ppiVar3;\n      ppiVar6[1] = (int *)ppiVar7;\n    }\n  }\n  __malloc_unlock(param_1,ppiVar2,ppiVar3,param_4);\n  return;\n}\n\n", 
            "called": [
                "__malloc_lock", 
                "__malloc_unlock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080061f0", 
            "calling": [
                "__sflush_r", 
                "__swsetup_r"
            ], 
            "imported": false, 
            "current_name": "_free_r"
        }, 
        "std.isra.0": {
            "renaming": {}, 
            "code": "\nvoid std_isra_0(undefined4 *param_1,undefined2 param_2,undefined2 param_3)\n\n{\n  undefined4 uVar1;\n  \n  *param_1 = 0;\n  param_1[1] = 0;\n  param_1[2] = 0;\n  *(undefined2 *)(param_1 + 3) = param_2;\n  param_1[0x19] = 0;\n  *(undefined2 *)((int)param_1 + 0xe) = param_3;\n  param_1[4] = 0;\n  param_1[5] = 0;\n  param_1[6] = 0;\n  memset(param_1 + 0x17,0,8);\n  uVar1 = DAT_08006c78;\n  param_1[8] = param_1;\n  param_1[9] = uVar1;\n  param_1[10] = DAT_08006c7c;\n  param_1[0xb] = DAT_08006c80;\n  param_1[0xc] = DAT_08006c84;\n  return;\n}\n\n", 
            "called": [
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006c40", 
            "calling": [
                "__sinit"
            ], 
            "imported": false, 
            "current_name": "std.isra.0"
        }, 
        "HAL_GPIO_Init": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_Init(GPIO_TypeDef *GPIOx,GPIO_InitTypeDef *GPIO_Init)\n\n{\n  GPIO_TypeDef *pGVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint32_t uVar7;\n  int iVar8;\n  uint uVar9;\n  int iVar10;\n  uint32_t tmpreg;\n  \n  uVar7 = 0;\n  uVar5 = 0;\n  do {\n    if (0xf < uVar5) {\n      return;\n    }\n    uVar3 = 1 << (uVar5 & 0xff);\n    uVar4 = GPIO_Init->Pin & uVar3;\n    if (uVar3 == uVar4) {\n      uVar6 = GPIO_Init->Mode;\n      if (uVar6 == 0x12) {\n        uVar7 = GPIO_Init->Speed + 0xc;\n      }\n      else if (uVar6 < 0x13) {\n        if (uVar6 == 2) {\n          uVar7 = GPIO_Init->Speed + 8;\n        }\n        else if (uVar6 < 3) {\n          if (uVar6 == 0) goto LAB_08002776;\n          if (uVar6 == 1) {\n            uVar7 = GPIO_Init->Speed;\n          }\n        }\n        else if (uVar6 == 3) {\n          uVar7 = 0;\n        }\n        else if (uVar6 == 0x11) {\n          uVar7 = GPIO_Init->Speed + 4;\n        }\n      }\n      else {\n        if (uVar6 != DAT_08002804) {\n          if (DAT_08002804 < uVar6) {\n            if (uVar6 == DAT_08002808) goto LAB_08002776;\n            uVar9 = DAT_08002808 + 0x10000;\n            uVar2 = DAT_08002808;\n          }\n          else {\n            uVar9 = DAT_08002804 - 0x100000;\n            uVar2 = DAT_08002804;\n          }\n          if ((uVar6 != uVar9) && (uVar6 != uVar2 - 0xf0000)) goto LAB_0800263a;\n        }\nLAB_08002776:\n        if (GPIO_Init->Pull == 0) {\n          uVar7 = 4;\n        }\n        else if (GPIO_Init->Pull == 1) {\n          GPIOx->BSRR = uVar3;\n          uVar7 = 8;\n        }\n        else {\n          GPIOx->BRR = uVar3;\n          uVar7 = 8;\n        }\n      }\nLAB_0800263a:\n      uVar3 = uVar5;\n      pGVar1 = GPIOx;\n      if (0xff < uVar4) {\n        uVar3 = uVar5 - 8;\n        pGVar1 = (GPIO_TypeDef *)&GPIOx->CRH;\n      }\n      pGVar1->CRL = pGVar1->CRL & ~(0xf << (uVar3 << 2 & 0xff)) | uVar7 << (uVar3 << 2 & 0xff);\n      if ((GPIO_Init->Mode & 0x10000000) != 0) {\n        *(uint *)(DAT_080027f8 + 0x18) = *(uint *)(DAT_080027f8 + 0x18) | 1;\n        iVar8 = (uVar5 & 3) << 2;\n        if (GPIOx == DAT_0800280c) {\n          iVar10 = 0;\n        }\n        else if (GPIOx == (GPIO_TypeDef *)&DAT_0800280c[0x24].BSRR) {\n          iVar10 = 1;\n        }\n        else if (GPIOx == (GPIO_TypeDef *)&DAT_0800280c[0x49].CRH) {\n          iVar10 = 2;\n        }\n        else if (GPIOx == (GPIO_TypeDef *)&DAT_0800280c[0x6d].BRR) {\n          iVar10 = 3;\n        }\n        else {\n          iVar10 = 4;\n        }\n        *(uint *)(DAT_080027fc + ((uVar5 >> 2) + 2) * 4) =\n             *(uint *)(DAT_080027fc + ((uVar5 >> 2) + 2) * 4) & ~(0xf << iVar8) | iVar10 << iVar8;\n        if ((GPIO_Init->Mode & 0x10000) == 0) {\n          *DAT_08002800 = *DAT_08002800 & ~uVar4;\n        }\n        else {\n          *DAT_08002800 = *DAT_08002800 | uVar4;\n        }\n        if ((GPIO_Init->Mode & 0x20000) == 0) {\n          DAT_08002800[1] = DAT_08002800[1] & ~uVar4;\n        }\n        else {\n          DAT_08002800[1] = DAT_08002800[1] | uVar4;\n        }\n        if ((GPIO_Init->Mode & 0x100000) == 0) {\n          DAT_08002800[2] = DAT_08002800[2] & ~uVar4;\n        }\n        else {\n          DAT_08002800[2] = DAT_08002800[2] | uVar4;\n        }\n        if ((GPIO_Init->Mode & 0x200000) == 0) {\n          DAT_08002800[3] = DAT_08002800[3] & ~uVar4;\n        }\n        else {\n          DAT_08002800[3] = uVar4 | DAT_08002800[3];\n        }\n      }\n    }\n    uVar5 = uVar5 + 1;\n  } while( true );\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002624", 
            "calling": [
                "HAL_ADC_MspInit", 
                "uart_init", 
                "digital_io_init"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_Init"
        }, 
        "HAL_RCCEx_GetPeriphCLKFreq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)\n\n{\n  uint32_t uVar1;\n  uint uVar2;\n  uint8_t aPredivFactorTable [2];\n  uint8_t aPLLMULFactorTable [16];\n  \n  aPLLMULFactorTable._12_4_ = *(undefined4 *)(PTR_DAT_08003e8c + 8);\n  aPLLMULFactorTable._8_4_ = *(undefined4 *)(PTR_DAT_08003e8c + 4);\n  aPLLMULFactorTable._4_4_ = *(undefined4 *)PTR_DAT_08003e8c;\n  aPredivFactorTable = *(uint8_t (*) [2])(PTR_DAT_08003e8c + 0x10);\n  if (PeriphClk == 2) {\n    uVar1 = HAL_RCC_GetPCLK2Freq();\n    uVar1 = uVar1 / ((((DAT_08003e90[1] << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (PeriphClk == 0x10) {\n    if ((*DAT_08003e90 & 0x1000000) == 0) {\n      uVar1 = 0;\n    }\n    else {\n      uVar2 = DAT_08003e9c;\n      if ((DAT_08003e90[1] & 0x10000) != 0) {\n        uVar2 = DAT_08003e94 / aPredivFactorTable[-((int)(DAT_08003e90[1] << 0xe) >> 0x1f)];\n      }\n      uVar1 = uVar2 * aPLLMULFactorTable[(DAT_08003e90[1] << 10) >> 0x1c];\n      if ((DAT_08003e90[1] & 0x400000) == 0) {\n        uVar1 = (uint32_t)((ulonglong)DAT_08003e98 * (ulonglong)(uVar1 * 2) >> 0x21);\n      }\n    }\n  }\n  else if (PeriphClk == 1) {\n    if ((DAT_08003e90[8] & 0x302) == 0x102) {\n      uVar1 = 0x8000;\n    }\n    else {\n      uVar2 = DAT_08003e90[8] & 0x300;\n      if ((uVar2 == 0x200) && ((DAT_08003e90[9] & 2) != 0)) {\n        uVar1 = 32000;\n      }\n      else if (uVar2 == 0x300) {\n        if ((*DAT_08003e90 & 0x20000) == 0) {\n          uVar1 = 0;\n        }\n        else {\n          uVar1 = 0xf424;\n        }\n      }\n      else {\n        uVar1 = 0;\n      }\n    }\n  }\n  else {\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n", 
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003da4", 
            "calling": [
                "HAL_ADC_PollForConversion", 
                "HAL_ADCEx_Calibration_Start"
            ], 
            "imported": false, 
            "current_name": "HAL_RCCEx_GetPeriphCLKFreq"
        }, 
        "__assert_func": {
            "renaming": {}, 
            "code": "\nvoid __assert_func(undefined4 param_1,undefined4 param_2,undefined *param_3,undefined4 param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  \n  puVar1 = PTR_s__08006154;\n  puVar2 = PTR_s__08006154;\n  if (param_3 != (undefined *)0x0) {\n    puVar1 = param_3;\n    puVar2 = PTR_s___function__0800614c;\n  }\n  fiprintf(*(FILE **)(*(int *)PTR__impure_ptr_08006148 + 0xc),\n           PTR_s_assertion___s__failed__file___s__08006150,param_4,param_1,param_2,puVar2,puVar1,\n           param_4);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
            "called": [
                "fiprintf", 
                "abort"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800611c", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "__assert_func"
        }, 
        "raise": {
            "renaming": {}, 
            "code": "\nint raise(int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 = _raise_r(*(undefined4 *)PTR__impure_ptr_08006f0c,__sig);\n  return iVar1;\n}\n\n", 
            "called": [
                "_raise_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006f00", 
            "calling": [
                "abort"
            ], 
            "imported": false, 
            "current_name": "raise"
        }, 
        "HAL_ADC_Init": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_ADC_Init(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint32_t uVar5;\n  \n  if (hadc == (ADC_HandleTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (hadc->State == 0) {\n    hadc->ErrorCode = 0;\n    hadc->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(hadc);\n  }\n  HVar1 = ADC_ConversionStop_Disable(hadc);\n  uVar4 = hadc->State & 0x10;\n  if ((uVar4 == 0) && (HVar1 == HAL_OK)) {\n    hadc->State = hadc->State & 0xffffeefd | 2;\n    uVar5 = (hadc->Init).ContinuousConvMode;\n    uVar3 = (hadc->Init).DataAlign | (hadc->Init).ExternalTrigConv | uVar5 << 1;\n    uVar2 = (hadc->Init).ScanConvMode;\n    if (uVar2 == 0x100) {\n      uVar4 = 0x100;\n    }\n    else if (uVar2 == 1) {\n      uVar4 = 0x100;\n    }\n    if ((hadc->Init).DiscontinuousConvMode == 1) {\n      if (uVar5 == 0) {\n        uVar4 = uVar4 | ((hadc->Init).NbrOfDiscConversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        hadc->State = hadc->State | 0x20;\n        hadc->ErrorCode = hadc->ErrorCode | 1;\n      }\n    }\n    hadc->Instance->CR1 = uVar4 | hadc->Instance->CR1 & 0xffff16ff;\n    hadc->Instance->CR2 = DAT_08002244 & hadc->Instance->CR2 | uVar3;\n    uVar2 = (hadc->Init).ScanConvMode;\n    if ((uVar2 == 0x100) || (uVar2 == 1)) {\n      uVar4 = ((hadc->Init).NbrOfConversion - 1) * 0x100000;\n    }\n    else {\n      uVar4 = 0;\n    }\n    hadc->Instance->SQR1 = uVar4 | hadc->Instance->SQR1 & 0xff0fffff;\n    if (uVar3 != (DAT_08002248 & hadc->Instance->CR2)) {\n      hadc->State = hadc->State & 0xffffffed | 0x10;\n      hadc->ErrorCode = hadc->ErrorCode | 1;\n      return HAL_ERROR;\n    }\n    hadc->ErrorCode = 0;\n    hadc->State = hadc->State & 0xfffffffc | 1;\n    return HAL_OK;\n  }\n  hadc->State = hadc->State | 0x10;\n  return HAL_ERROR;\n}\n\n", 
            "called": [
                "HAL_ADC_MspInit", 
                "ADC_ConversionStop_Disable"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800213c", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_Init"
        }, 
        "UART_WaitOnFlagUntilTimeout": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nUART_WaitOnFlagUntilTimeout\n          (UART_HandleTypeDef *huart,uint32_t Flag,FlagStatus Status,uint32_t Tickstart,\n          uint32_t Timeout)\n\n{\n  uint32_t uVar1;\n  \n  do {\n    if (((Flag & ~huart->Instance->SR) == 0) != (bool)Status) {\n      return HAL_OK;\n    }\n  } while ((Timeout == 0xffffffff) ||\n          ((Timeout != 0 && (uVar1 = HAL_GetTick(), uVar1 - Tickstart <= Timeout))));\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xfffffe5f;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffffe;\n  huart->gState = HAL_UART_STATE_READY;\n  huart->RxState = HAL_UART_STATE_READY;\n  huart->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080043b4", 
            "calling": [
                "HAL_UART_Transmit"
            ], 
            "imported": false, 
            "current_name": "UART_WaitOnFlagUntilTimeout"
        }, 
        "uart_init": {
            "renaming": {}, 
            "code": "\nvoid uart_init(serial_t *obj)\n\n{\n  USART_TypeDef *pUVar1;\n  USART_TypeDef *pUVar2;\n  USART_TypeDef *pUVar3;\n  void *a;\n  void *b;\n  USART_TypeDef *pUVar4;\n  GPIO_TypeDef *pGVar5;\n  uint32_t uVar6;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj != (serial_t *)0x0) {\n    a = pinmap_peripheral(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08005204);\n    b = pinmap_peripheral(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08005208);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_UART_pin_has_0800521c);\n    }\n    else {\n      pUVar4 = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      obj->uart = pUVar4;\n      pUVar3 = DAT_08005214;\n      pUVar2 = DAT_08005210;\n      pUVar1 = DAT_0800520c;\n      if (pUVar4 == (USART_TypeDef *)0x0) {\n        iprintf(PTR_s_ERROR__U_S_ART_pins_mismatch_08005220);\n      }\n      else {\n        if (pUVar4 == DAT_0800520c) {\n          DAT_0800520c[0x7b7].BRR = DAT_0800520c[0x7b7].BRR | 0x4000;\n          pUVar1[0x7b7].BRR = pUVar1[0x7b7].BRR & 0xffffbfff;\n          pUVar1[0x7b7].CR3 = pUVar1[0x7b7].CR3 | 0x4000;\n          obj->index = '\\0';\n          obj->irq = USART1_IRQn;\n        }\n        else if (pUVar4 == DAT_08005210) {\n          DAT_08005210[0x106e].BRR = DAT_08005210[0x106e].BRR | 0x20000;\n          pUVar2[0x106e].BRR = pUVar2[0x106e].BRR & 0xfffdffff;\n          pUVar2[0x106e].CR3 = pUVar2[0x106e].CR3 | 0x20000;\n          obj->index = '\\x01';\n          obj->irq = USART2_IRQn;\n        }\n        else if (pUVar4 == DAT_08005214) {\n          DAT_08005214[0x1049].CR3 = DAT_08005214[0x1049].CR3 | 0x40000;\n          pUVar3[0x1049].CR3 = pUVar3[0x1049].CR3 & 0xfffbffff;\n          pUVar3[0x104a].DR = pUVar3[0x104a].DR | 0x40000;\n          obj->index = '\\x02';\n          obj->irq = USART3_IRQn;\n        }\n        pGVar5 = set_GPIO_Port_Clock((uint)((int)obj->pin_rx << 0x18) >> 0x1c);\n        uVar6 = pinmap_function(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08005208);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_rx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar6 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Pull = (uVar6 << 0x1a) >> 0x1e;\n        *(uint *)(DAT_08005218 + 0x18) = *(uint *)(DAT_08005218 + 0x18) | 1;\n        switch((uVar6 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xf8ffffff | 0x4000000;\n        }\n        GPIO_InitStruct.Speed = 3;\n        HAL_GPIO_Init(pGVar5,&GPIO_InitStruct);\n        pGVar5 = set_GPIO_Port_Clock((uint)((int)obj->pin_tx << 0x18) >> 0x1c);\n        uVar6 = pinmap_function(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08005204);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_tx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar6 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Pull = (uVar6 << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(pGVar5,&GPIO_InitStruct);\n        *(UART_HandleTypeDef **)(PTR_uart_handlers_08005228 + (uint)obj->index * 4) = &obj->handle;\n        (obj->handle).Instance = obj->uart;\n        (obj->handle).Init.BaudRate = obj->baudrate;\n        (obj->handle).Init.WordLength = obj->databits;\n        (obj->handle).Init.StopBits = obj->stopbits;\n        (obj->handle).Init.Parity = obj->parity;\n        (obj->handle).Init.Mode = 0xc;\n        (obj->handle).Init.HwFlowCtl = 0;\n        (obj->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&obj->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "pinmap_function", 
                "set_GPIO_Port_Clock", 
                "HAL_GPIO_Init", 
                "pinmap_peripheral", 
                "pinmap_merge_peripheral", 
                "iprintf", 
                "HAL_UART_Init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004f4c", 
            "calling": [
                "begin", 
                "uart_debug_init"
            ], 
            "imported": false, 
            "current_name": "uart_init"
        }, 
        "__sseek": {
            "renaming": {}, 
            "code": "\nvoid __sseek(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  ushort uVar2;\n  bool bVar3;\n  \n  iVar1 = _lseek_r(param_1,(int)*(short *)(param_2 + 0xe));\n  bVar3 = iVar1 == -1;\n  if (bVar3) {\n    uVar2 = *(ushort *)(param_2 + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(param_2 + 0x54) = iVar1;\n    uVar2 = *(ushort *)(param_2 + 0xc) | 0x1000;\n  }\n  if (bVar3) {\n    *(ushort *)(param_2 + 0xc) = uVar2;\n  }\n  if (!bVar3) {\n    *(ushort *)(param_2 + 0xc) = uVar2;\n  }\n  return;\n}\n\n", 
            "called": [
                "_lseek_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006f92", 
            "calling": [], 
            "imported": false, 
            "current_name": "__sseek"
        }, 
        "initVariant": {
            "renaming": {}, 
            "code": "\nvoid initVariant(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005f5c", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "initVariant"
        }, 
        "HAL_ADC_MspInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_ADC_MspInit(ADC_HandleTypeDef *hadc)\n\n{\n  undefined *puVar1;\n  GPIO_TypeDef *GPIOx;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (hadc->Instance == DAT_080049e0) {\n    *(uint *)(DAT_080049ec + 0x18) = *(uint *)(DAT_080049ec + 0x18) | 0x200;\n  }\n  else if (hadc->Instance == DAT_080049e4) {\n    *(uint *)(DAT_080049ec + 0x18) = *(uint *)(DAT_080049ec + 0x18) | 0x400;\n  }\n  puVar1 = PTR_g_current_pin_080049e8;\n  GPIOx = set_GPIO_Port_Clock((uint)((int)(char)*PTR_g_current_pin_080049e8 << 0x18) >> 0x1c);\n  GPIO_InitStruct.Pin = 1 << (*puVar1 & 0xf) & 0xffff;\n  GPIO_InitStruct.Mode = 3;\n  GPIO_InitStruct.Pull = 0;\n  HAL_GPIO_Init(GPIOx,&GPIO_InitStruct);\n  return;\n}\n\n", 
            "called": [
                "set_GPIO_Port_Clock", 
                "HAL_GPIO_Init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004974", 
            "calling": [
                "HAL_ADC_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_MspInit"
        }, 
        "pwm_stop": {
            "renaming": {}, 
            "code": "\nvoid pwm_stop(PinName_conflict pin)\n\n{\n  uint32_t Channel;\n  uint32_t uVar1;\n  TIM_HandleTypeDef timHandle;\n  \n  timHandle.Instance =\n       (TIM_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_PWM_08004b90);\n  if ((timHandle.Instance != (TIM_TypeDef *)0x0) &&\n     ((((Channel = get_pwm_channel(pin), Channel == 0 || (Channel == 4)) || (Channel == 8)) ||\n      ((Channel == 0xc || (Channel == 0x18)))))) {\n    uVar1 = pinmap_function(pin,(PinMap_conflict *)PTR_PinMap_PWM_08004b90);\n    if ((uVar1 & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timHandle,Channel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timHandle,Channel);\n    }\n    HAL_TIM_PWM_DeInit(&timHandle);\n  }\n  return;\n}\n\n", 
            "called": [
                "pinmap_function", 
                "HAL_TIMEx_PWMN_Stop", 
                "HAL_TIM_PWM_Stop", 
                "pinmap_peripheral", 
                "HAL_TIM_PWM_DeInit", 
                "get_pwm_channel"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004b3c", 
            "calling": [
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "pwm_stop"
        }, 
        "_lseek": {
            "renaming": {}, 
            "code": "\nint _lseek(int file_UNUSED,int ptr_UNUSED,int dir_UNUSED)\n\n{\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005728", 
            "calling": [
                "_lseek_r"
            ], 
            "imported": false, 
            "current_name": "_lseek"
        }, 
        "get_pwm_channel": {
            "renaming": {}, 
            "code": "\nuint32_t get_pwm_channel(PinName_conflict pin)\n\n{\n  uint32_t uVar1;\n  uint uVar2;\n  \n  uVar1 = pinmap_function(pin,(PinMap_conflict *)PTR_PinMap_PWM_08004970);\n  uVar2 = (uVar1 << 0xc) >> 0x1b;\n  if (uVar2 == 3) {\n    return 8;\n  }\n  if (uVar2 != 4) {\n    if (uVar2 != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n", 
            "called": [
                "pinmap_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004948", 
            "calling": [
                "pwm_stop"
            ], 
            "imported": false, 
            "current_name": "get_pwm_channel"
        }, 
        "read": {
            "renaming": {}, 
            "code": "\nssize_t __thiscall HardwareSerial::read(HardwareSerial *this,int __fd,void *__buf,size_t __nbytes)\n\n{\n  byte bVar1;\n  ushort uVar2;\n  \n  uVar2 = (this->_serial).rx_tail;\n  if ((uint)(this->_serial).rx_head != (uint)uVar2) {\n    bVar1 = (this->_serial).rx_buff[uVar2];\n    (this->_serial).rx_tail = uVar2 + 1 & 0x3f;\n    return (uint)bVar1;\n  }\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800594e", 
            "calling": [], 
            "imported": false, 
            "current_name": "read"
        }, 
        "HAL_TIM_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)\n\n{\n  TIM_TypeDef *pTVar1;\n  \n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 2) != 0) && ((pTVar1->DIER & 2) != 0)) {\n    pTVar1->SR = 0xfffffffd;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((htim->Instance->CCMR1 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 4) != 0) && ((pTVar1->DIER & 4) != 0)) {\n    pTVar1->SR = 0xfffffffb;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((htim->Instance->CCMR1 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 8) != 0) && ((pTVar1->DIER & 8) != 0)) {\n    pTVar1->SR = 0xfffffff7;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((htim->Instance->CCMR2 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 0x10) != 0) && ((pTVar1->DIER & 0x10) != 0)) {\n    pTVar1->SR = 0xffffffef;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((htim->Instance->CCMR2 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 1) != 0) && ((pTVar1->DIER & 1) != 0)) {\n    pTVar1->SR = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(htim);\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 0x80) != 0) && ((pTVar1->DIER & 0x80) != 0)) {\n    pTVar1->SR = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(htim);\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 0x40) != 0) && ((pTVar1->DIER & 0x40) != 0)) {\n    pTVar1->SR = 0xffffffbf;\n    HAL_TIM_TriggerCallback(htim);\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 0x20) != 0) && ((pTVar1->DIER & 0x20) != 0)) {\n    pTVar1->SR = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(htim);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_PWM_PulseFinishedCallback", 
                "HAL_TIM_OC_DelayElapsedCallback", 
                "HAL_TIMEx_CommutationCallback", 
                "HAL_TIM_IC_CaptureCallback", 
                "HAL_TIMEx_BreakCallback", 
                "HAL_TIM_TriggerCallback", 
                "HAL_TIM_PeriodElapsedCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003f18", 
            "calling": [
                "TIM4_IRQHandler", 
                "TIM1_UP_IRQHandler", 
                "TIM3_IRQHandler", 
                "TIM2_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_IRQHandler"
        }, 
        "__fixdfsi": {
            "renaming": {}, 
            "code": "\nuint __fixdfsi(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  uint uVar3;\n  \n  iVar2 = param_2 * 2 + 0x200000;\n  if (param_2 * 2 < 0xffe00000) {\n    if (-1 < iVar2) {\n      return 0;\n    }\n    uVar1 = iVar2 >> 0x15;\n    uVar3 = -uVar1 - 0x3e1;\n    if (uVar1 < 0xfffffc20 && uVar3 != 0) {\n      uVar1 = (param_2 << 0xb | 0x80000000 | param_1 >> 0x15) >> (uVar3 & 0xff);\n      if ((param_2 & 0x80000000) != 0) {\n        uVar1 = -uVar1;\n      }\n      return uVar1;\n    }\n  }\n  else if ((param_1 | param_2 << 0xc) != 0) {\n    return 0;\n  }\n  param_2 = param_2 & 0x80000000;\n  if (param_2 == 0) {\n    param_2 = 0x7fffffff;\n  }\n  return param_2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000a58", 
            "calling": [
                "printFloat"
            ], 
            "imported": false, 
            "current_name": "__fixdfsi"
        }, 
        "HAL_Init": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_Init(void)\n\n{\n  *DAT_08001ca8 = *DAT_08001ca8 | 0x10;\n  HAL_NVIC_SetPriorityGrouping(3);\n  HAL_InitTick(0xf);\n  HAL_MspInit();\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_NVIC_SetPriorityGrouping", 
                "HAL_InitTick", 
                "HAL_MspInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001c88", 
            "calling": [
                "hw_config_init"
            ], 
            "imported": false, 
            "current_name": "HAL_Init"
        }, 
        "HAL_SYSTICK_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_SYSTICK_IRQHandler(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n", 
            "called": [
                "HAL_SYSTICK_Callback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002582", 
            "calling": [
                "SysTick_Handler"
            ], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_IRQHandler"
        }, 
        "HAL_RCC_OscConfig": {
            "renaming": {}, 
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nHAL_StatusTypeDef_conflict HAL_RCC_OscConfig(RCC_OscInitTypeDef_conflict *RCC_OscInitStruct)\n\n{\n  uint *puVar1;\n  uint *puVar2;\n  HAL_StatusTypeDef_conflict HVar3;\n  uint32_t uVar4;\n  uint32_t uVar5;\n  bool bVar6;\n  uint32_t tmpreg;\n  \n  puVar1 = DAT_08003948;\n  if ((RCC_OscInitStruct->OscillatorType & 1) != 0) {\n    if (((DAT_08003948[1] & 0xc) == 4) ||\n       (((DAT_08003948[1] & 0xc) == 8 && ((DAT_08003948[1] & 0x10000) != 0)))) {\n      if (((*DAT_08003948 & 0x20000) != 0) && (RCC_OscInitStruct->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      uVar5 = RCC_OscInitStruct->HSEState;\n      if (uVar5 == 0x10000) {\n        *DAT_08003948 = *DAT_08003948 | 0x10000;\n      }\n      else if (uVar5 == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (uVar5 == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        *DAT_08003948 = *DAT_08003948 & 0xfffeffff;\n        *puVar1 = *puVar1 & 0xfffbffff;\n      }\n      if (RCC_OscInitStruct->HSEState == 0) {\n        uVar5 = HAL_GetTick();\n        while ((*DAT_08003948 & 0x20000) != 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar5) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        uVar5 = HAL_GetTick();\n        while ((*DAT_08003948 & 0x20000) == 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar5) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 2) != 0) {\n    if (((DAT_08003948[1] & 0xc) == 0) ||\n       (((DAT_08003948[1] & 0xc) == 8 && ((DAT_08003948[1] & 0x10000) == 0)))) {\n      if (((*DAT_08003948 & 2) != 0) && (RCC_OscInitStruct->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      *DAT_08003948 = *DAT_08003948 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n    else if (RCC_OscInitStruct->HSIState == 0) {\n      *DAT_0800394c = 0;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_08003948 & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_0800394c = 1;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_08003948 & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_08003948 = *DAT_08003948 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 8) != 0) {\n    if (RCC_OscInitStruct->LSIState == 0) {\n      *DAT_08003950 = 0;\n      uVar5 = HAL_GetTick();\n      while ((DAT_08003948[9] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08003950 = 1;\n      uVar5 = HAL_GetTick();\n      while ((DAT_08003948[9] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 4) != 0) {\n    bVar6 = (DAT_08003948[7] & 0x10000000) == 0;\n    if (bVar6) {\n      DAT_08003948[7] = DAT_08003948[7] | 0x10000000;\n    }\n    if ((*DAT_08003954 & 0x100) == 0) {\n      *DAT_08003954 = *DAT_08003954 | 0x100;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_08003954 & 0x100) == 0) {\n        uVar4 = HAL_GetTick();\n        if (100 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    puVar2 = DAT_08003a60;\n    puVar1 = DAT_08003948;\n    uVar5 = RCC_OscInitStruct->LSEState;\n    if (uVar5 == 1) {\n      DAT_08003948[8] = DAT_08003948[8] | 1;\n    }\n    else if (uVar5 == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (uVar5 == 5) {\n      DAT_08003a60[8] = DAT_08003a60[8] | 4;\n      puVar2[8] = puVar2[8] | 1;\n    }\n    else {\n      DAT_08003948[8] = DAT_08003948[8] & 0xfffffffe;\n      puVar1[8] = puVar1[8] & 0xfffffffb;\n    }\n    if (RCC_OscInitStruct->LSEState == 0) {\n      uVar5 = HAL_GetTick();\n      while ((DAT_08003a60[8] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uVar5 = HAL_GetTick();\n      while ((DAT_08003948[8] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (bVar6) {\n      DAT_08003a60[7] = DAT_08003a60[7] & 0xefffffff;\n    }\n  }\n  uVar5 = (RCC_OscInitStruct->PLL).PLLState;\n  if (uVar5 == 0) {\n    HVar3 = HAL_OK;\n  }\n  else if ((DAT_08003a60[1] & 0xc) == 8) {\n    HVar3 = HAL_ERROR;\n  }\n  else if (uVar5 == 2) {\n    *DAT_08003a64 = 0;\n    uVar5 = HAL_GetTick();\n    do {\n      if ((*DAT_08003a60 & 0x2000000) == 0) {\n        if ((RCC_OscInitStruct->PLL).PLLSource == 0x10000) {\n          DAT_08003a60[1] = DAT_08003a60[1] & 0xfffdffff | RCC_OscInitStruct->HSEPredivValue;\n        }\n        DAT_08003a60[1] =\n             DAT_08003a60[1] & 0xffc2ffff |\n             (RCC_OscInitStruct->PLL).PLLSource | (RCC_OscInitStruct->PLL).PLLMUL;\n        *DAT_08003a64 = 1;\n        uVar5 = HAL_GetTick();\n        do {\n          if ((*DAT_08003a60 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          uVar4 = HAL_GetTick();\n        } while (uVar4 - uVar5 < 3);\n        return HAL_TIMEOUT;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar5 < 3);\n    HVar3 = HAL_TIMEOUT;\n  }\n  else {\n    *DAT_08003a64 = 0;\n    uVar5 = HAL_GetTick();\n    do {\n      if ((*DAT_08003a60 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar5 < 3);\n    HVar3 = HAL_TIMEOUT;\n  }\n  return HVar3;\n}\n\n", 
            "called": [
                "RCC_Delay", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003688", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_OscConfig"
        }, 
        "memset": {
            "renaming": {}, 
            "code": "\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  undefined *puVar1;\n  \n  for (puVar1 = (undefined *)__s; puVar1 != (undefined *)(__n + (int)__s); puVar1 = puVar1 + 1) {\n    *puVar1 = (char)__c;\n  }\n  return __s;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080061e0", 
            "calling": [
                "std.isra.0", 
                "adc_read_value", 
                "__sfmoreglue", 
                "__sfp"
            ], 
            "imported": false, 
            "current_name": "memset"
        }, 
        "__aeabi_dcmplt": {
            "renaming": {}, 
            "code": "\nbool __aeabi_dcmplt(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cdcmpeq();\n  return in_CY == '\\0';\n}\n\n", 
            "called": [
                "__aeabi_cdcmpeq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080009dc", 
            "calling": [
                "Compute", 
                "loop", 
                "SetTunings", 
                "printFloat", 
                "Initialize", 
                "SetOutputLimits"
            ], 
            "imported": false, 
            "current_name": "__aeabi_dcmplt"
        }, 
        "HAL_TIMEx_CommutationCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004178", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIMEx_CommutationCallback"
        }, 
        "I2C_Slave_AF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict I2C_Slave_AF(I2C_HandleTypeDef *hi2c)\n\n{\n  if (((hi2c->XferOptions == 4) || (hi2c->XferOptions == 8)) &&\n     (hi2c->State == HAL_I2C_STATE_LISTEN)) {\n    hi2c->XferOptions = DAT_08002dac;\n    hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n    hi2c->Instance->SR1 = 0xfffffbff;\n    hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n    hi2c->PreviousState = 0;\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(hi2c);\n  }\n  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX) {\n    hi2c->XferOptions = DAT_08002dac;\n    hi2c->PreviousState = 0x21;\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n    hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n    hi2c->Instance->SR1 = 0xfffffbff;\n    hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(hi2c);\n  }\n  else {\n    hi2c->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_SlaveTxCpltCallback", 
                "HAL_I2C_ListenCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002d1c", 
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Slave_AF"
        }, 
        "setCursor": {
            "renaming": {}, 
            "code": "\nvoid __thiscall LiquidCrystal::setCursor(LiquidCrystal *this,uint8_t col,uint8_t row)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)row;\n  if (3 < uVar1) {\n    uVar1 = 3;\n  }\n  if (this->_numlines <= uVar1) {\n    uVar1 = this->_numlines - 1 & 0xff;\n  }\n  send(this,col + this->_row_offsets[uVar1] | 0x80,'\\0');\n  return;\n}\n\n", 
            "called": [
                "send"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001366", 
            "calling": [
                "loop", 
                "setup"
            ], 
            "imported": false, 
            "current_name": "setCursor"
        }, 
        "millis": {
            "renaming": {}, 
            "code": "\nuint32_t millis(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = GetCurrentMilli();\n  return uVar1;\n}\n\n", 
            "called": [
                "GetCurrentMilli"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080058e0", 
            "calling": [
                "Compute", 
                "PID", 
                "loop", 
                "setup"
            ], 
            "imported": false, 
            "current_name": "millis"
        }, 
        "send": {
            "renaming": {}, 
            "code": "\nvoid __thiscall LiquidCrystal::send(LiquidCrystal *this,uint8_t value,uint8_t mode)\n\n{\n  digitalWrite((uint)this->_rs_pin,(uint)mode);\n  if (this->_rw_pin != 0xff) {\n    digitalWrite((uint)this->_rw_pin,0);\n  }\n  if ((this->_displayfunction & 0x10) == 0) {\n    write4bits(this,value >> 4);\n    write4bits(this,value);\n    return;\n  }\n  write8bits(this,value);\n  return;\n}\n\n", 
            "called": [
                "digitalWrite", 
                "write8bits", 
                "write4bits"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001310", 
            "calling": [
                "setCursor", 
                "clear", 
                "createChar", 
                "write", 
                "display", 
                "begin"
            ], 
            "imported": false, 
            "current_name": "send"
        }, 
        "I2C_ITError": {
            "renaming": {}, 
            "code": "\nvoid I2C_ITError(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint8_t *puVar2;\n  I2C_TypeDef *pIVar3;\n  \n  if ((byte)hi2c->State - 0x29 < 2) {\n    hi2c->PreviousState = 0;\n    hi2c->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((hi2c->State != HAL_I2C_STATE_ABORT) && ((hi2c->Instance->CR2 & 0x800) == 0)) {\n      hi2c->State = HAL_I2C_STATE_READY;\n    }\n    hi2c->PreviousState = 0;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n  }\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffff7ff;\n  pIVar3 = hi2c->Instance;\n  if ((pIVar3->CR2 & 0x800) == 0) {\n    if (hi2c->State == HAL_I2C_STATE_ABORT) {\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->ErrorCode = 0;\n      if ((pIVar3->SR1 & 0x40) != 0) {\n        puVar2 = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = puVar2 + 1;\n        *puVar2 = (uint8_t)pIVar3->DR;\n      }\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(hi2c);\n    }\n    else {\n      if ((pIVar3->SR1 & 0x40) != 0) {\n        puVar2 = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = puVar2 + 1;\n        *puVar2 = (uint8_t)pIVar3->DR;\n      }\n      HAL_I2C_ErrorCallback(hi2c);\n    }\n  }\n  else {\n    pIVar3->CR2 = pIVar3->CR2 & 0xfffff7ff;\n    if (hi2c->hdmatx->State == HAL_DMA_STATE_READY) {\n      hi2c->hdmarx->XferAbortCallback = DAT_080032ac;\n      HVar1 = HAL_DMA_Abort_IT(hi2c->hdmarx);\n      if (HVar1 != HAL_OK) {\n        if ((hi2c->Instance->SR1 & 0x40) != 0) {\n          puVar2 = hi2c->pBuffPtr;\n          hi2c->pBuffPtr = puVar2 + 1;\n          *puVar2 = (uint8_t)hi2c->Instance->DR;\n        }\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n        hi2c->State = HAL_I2C_STATE_READY;\n        (*hi2c->hdmarx->XferAbortCallback)(hi2c->hdmarx);\n      }\n    }\n    else {\n      hi2c->hdmatx->XferAbortCallback = DAT_080032ac;\n      HVar1 = HAL_DMA_Abort_IT(hi2c->hdmatx);\n      if (HVar1 != HAL_OK) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n        hi2c->State = HAL_I2C_STATE_READY;\n        (*hi2c->hdmatx->XferAbortCallback)(hi2c->hdmatx);\n      }\n    }\n  }\n  if ((hi2c->State == HAL_I2C_STATE_LISTEN) && ((hi2c->ErrorCode & 4) != 0)) {\n    hi2c->XferOptions = DAT_080032b0;\n    hi2c->PreviousState = 0;\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(hi2c);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_DMA_Abort_IT", 
                "HAL_I2C_ErrorCallback", 
                "HAL_I2C_AbortCpltCallback", 
                "HAL_I2C_ListenCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800316c", 
            "calling": [
                "I2C_Slave_STOPF", 
                "HAL_I2C_ER_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_ITError"
        }, 
        "HAL_I2C_Slave_Sequential_Transmit_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict\nHAL_I2C_Slave_Sequential_Transmit_IT\n          (I2C_HandleTypeDef *hi2c,uint8_t *pData,uint16_t Size,uint32_t XferOptions)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  I2C_TypeDef *pIVar2;\n  uint32_t tmpreg;\n  \n  if (hi2c->State == HAL_I2C_STATE_LISTEN) {\n    if (pData == (uint8_t *)0x0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (Size == 0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (hi2c->Lock == HAL_LOCKED) {\n      HVar1 = HAL_BUSY;\n    }\n    else {\n      hi2c->Lock = HAL_LOCKED;\n      pIVar2 = hi2c->Instance;\n      if ((pIVar2->CR1 & 1) == 0) {\n        pIVar2->CR1 = pIVar2->CR1 | 1;\n      }\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffff7ff;\n      hi2c->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      hi2c->Mode = HAL_I2C_MODE_SLAVE;\n      HVar1 = HAL_OK;\n      hi2c->ErrorCode = 0;\n      hi2c->pBuffPtr = pData;\n      hi2c->XferCount = Size;\n      hi2c->XferOptions = XferOptions;\n      hi2c->XferSize = hi2c->XferCount;\n      hi2c->Lock = HAL_UNLOCKED;\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 = HAL_BUSY;\n  }\n  return HVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002af8", 
            "calling": [
                "HAL_I2C_AddrCallback"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_Slave_Sequential_Transmit_IT"
        }, 
        "pin_in_pinmap": {
            "renaming": {}, 
            "code": "\n_Bool pin_in_pinmap(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  if (pin == NC) {\n    return false;\n  }\n  while( true ) {\n    if (map->pin == NC) {\n      return false;\n    }\n    if (pin == map->pin) break;\n    map = map + 1;\n  }\n  return true;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004ce2", 
            "calling": [
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "pin_in_pinmap"
        }, 
        "HAL_I2C_EV_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)\n\n{\n  I2C_TypeDef *pIVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  pIVar1 = hi2c->Instance;\n  uVar4 = pIVar1->SR2;\n  uVar2 = pIVar1->SR1;\n  uVar3 = pIVar1->CR2;\n  if ((hi2c->Mode == HAL_I2C_MODE_MASTER) || (hi2c->Mode == HAL_I2C_MODE_MEM)) {\n    if (((uVar2 & 0x10001) == 0) || ((uVar3 & 0x200) == 0)) {\n      if (((DAT_08003518 & uVar2) == 0) || ((uVar3 & 0x200) == 0)) {\n        if (((DAT_08003504 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n          I2C_Master_ADDR(hi2c);\n        }\n      }\n      else {\n        I2C_Master_ADD10(hi2c);\n      }\n    }\n    else {\n      I2C_Master_SB(hi2c);\n    }\n    if ((DAT_0800350c & uVar4) == 0) {\n      if ((((DAT_0800351c & uVar2) != 0) && ((uVar3 & 0x400) != 0)) && ((DAT_08003514 & uVar2) == 0)\n         ) {\n        I2C_MasterReceive_RXNE(hi2c);\n        return;\n      }\n      if (((DAT_08003514 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(hi2c);\n        return;\n      }\n    }\n    else {\n      if ((((DAT_08003510 & uVar2) != 0) && ((uVar3 & 0x400) != 0)) && ((DAT_08003514 & uVar2) == 0)\n         ) {\n        I2C_MasterTransmit_TXE(hi2c);\n        return;\n      }\n      if (((DAT_08003514 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(hi2c);\n        return;\n      }\n    }\n  }\n  else {\n    if (((DAT_08003504 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n      I2C_Slave_ADDR(hi2c);\n      return;\n    }\n    if (((DAT_08003508 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n      I2C_Slave_STOPF(hi2c);\n      return;\n    }\n    if ((DAT_0800350c & uVar4) == 0) {\n      if ((((DAT_0800351c & uVar2) != 0) && ((uVar3 & 0x400) != 0)) && ((DAT_08003514 & uVar2) == 0)\n         ) {\n        I2C_SlaveReceive_RXNE(hi2c);\n        return;\n      }\n      if (((DAT_08003514 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(hi2c);\n      }\n    }\n    else {\n      if ((((DAT_08003510 & uVar2) != 0) && ((uVar3 & 0x400) != 0)) && ((DAT_08003514 & uVar2) == 0)\n         ) {\n        I2C_SlaveTransmit_TXE(hi2c);\n        return;\n      }\n      if (((DAT_08003514 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(hi2c);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "I2C_Master_SB", 
                "I2C_SlaveReceive_BTF", 
                "I2C_MasterTransmit_TXE", 
                "I2C_MasterTransmit_BTF", 
                "I2C_Master_ADDR", 
                "I2C_SlaveTransmit_TXE", 
                "I2C_SlaveTransmit_BTF", 
                "I2C_MasterReceive_BTF", 
                "I2C_SlaveReceive_RXNE", 
                "I2C_Slave_STOPF", 
                "I2C_Slave_ADDR", 
                "I2C_Master_ADD10", 
                "I2C_MasterReceive_RXNE"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080033b8", 
            "calling": [
                "I2C1_EV_IRQHandler", 
                "I2C2_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_EV_IRQHandler"
        }, 
        "_malloc_r": {
            "renaming": {}, 
            "code": "\nuint _malloc_r(undefined4 *param_1,uint param_2)\n\n{\n  undefined *puVar1;\n  undefined4 uVar2;\n  uint *puVar3;\n  int iVar4;\n  uint *puVar5;\n  uint uVar6;\n  uint *puVar7;\n  uint uVar8;\n  \n  uVar8 = (param_2 + 3 & 0xfffffffc) + 8;\n  if (uVar8 < 0xc) {\n    uVar8 = 0xc;\n  }\n  if (((int)uVar8 < 0) || (uVar8 < param_2)) {\n    *param_1 = 0xc;\n  }\n  else {\n    __malloc_lock();\n    puVar1 = PTR___malloc_sbrk_start_08006340;\n    puVar3 = *(uint **)PTR___malloc_free_list_0800633c;\n    puVar7 = *(uint **)PTR___malloc_free_list_0800633c;\n    while (puVar5 = puVar3, puVar5 != (uint *)0x0) {\n      uVar6 = *puVar5 - uVar8;\n      if (-1 < (int)uVar6) {\n        if (uVar6 < 0xc) {\n          if (puVar7 == puVar5) {\n            uVar8 = puVar7[1];\n            *(uint *)PTR___malloc_free_list_0800633c = uVar8;\n          }\n          else {\n            uVar8 = puVar5[1];\n          }\n          if (puVar7 != puVar5) {\n            puVar7[1] = uVar8;\n            puVar7 = puVar5;\n          }\n        }\n        else {\n          *puVar5 = uVar6;\n          *(uint *)((int)puVar5 + uVar6) = uVar8;\n          puVar7 = (uint *)((int)puVar5 + uVar6);\n        }\n        goto LAB_080062ec;\n      }\n      puVar7 = puVar5;\n      puVar3 = (uint *)puVar5[1];\n    }\n    if (*(int *)PTR___malloc_sbrk_start_08006340 == 0) {\n      uVar2 = _sbrk_r(param_1);\n      *(undefined4 *)puVar1 = uVar2;\n    }\n    puVar3 = (uint *)_sbrk_r(param_1,uVar8);\n    if ((puVar3 != (uint *)0xffffffff) &&\n       ((puVar7 = (uint *)((int)puVar3 + 3U & 0xfffffffc), puVar3 == puVar7 ||\n        (iVar4 = _sbrk_r(param_1,(int)puVar7 - (int)puVar3), iVar4 != -1)))) {\n      *puVar7 = uVar8;\nLAB_080062ec:\n      __malloc_unlock(param_1);\n      uVar8 = (int)puVar7 + 0xbU & 0xfffffff8;\n      iVar4 = uVar8 - (int)(puVar7 + 1);\n      if (iVar4 != 0) {\n        *(int *)((int)puVar7 + iVar4) = -iVar4;\n        return uVar8;\n      }\n      return uVar8;\n    }\n    *param_1 = 0xc;\n    __malloc_unlock(param_1);\n  }\n  return 0;\n}\n\n", 
            "called": [
                "__malloc_lock", 
                "_sbrk_r", 
                "__malloc_unlock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006288", 
            "calling": [
                "__smakebuf_r", 
                "__sfmoreglue"
            ], 
            "imported": false, 
            "current_name": "_malloc_r"
        }, 
        "I2C_DMAAbort": {
            "renaming": {}, 
            "code": "\nvoid I2C_DMAAbort(DMA_HandleTypeDef *hdma)\n\n{\n  I2C_HandleTypeDef *hi2c;\n  \n  hi2c = (I2C_HandleTypeDef *)hdma->Parent;\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n  hi2c->XferCount = 0;\n  hi2c->hdmatx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  hi2c->hdmarx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  if (hi2c->State != HAL_I2C_STATE_ABORT) {\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n    hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n    HAL_I2C_ErrorCallback(hi2c);\n    return;\n  }\n  hi2c->State = HAL_I2C_STATE_READY;\n  hi2c->Mode = HAL_I2C_MODE_NONE;\n  hi2c->ErrorCode = 0;\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n  HAL_I2C_AbortCpltCallback(hi2c);\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_ErrorCallback", 
                "HAL_I2C_AbortCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080035fc", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C_DMAAbort"
        }, 
        "println": {
            "renaming": {}, 
            "code": "\nsize_t Print::println(Print *this,double num,int digits)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  uint in_stack_ffffffec;\n  \n  sVar1 = print(this,(double)((ulonglong)num & 0xffffffff | (ulonglong)in_stack_ffffffec << 0x20),\n                num._0_4_);\n  sVar2 = println(this);\n  return sVar2 + sVar1;\n}\n\n", 
            "called": [
                "println", 
                "print"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005f40", 
            "calling": [
                "loop"
            ], 
            "imported": false, 
            "current_name": "println"
        }, 
        "__swrite": {
            "renaming": {}, 
            "code": "\nvoid __swrite(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x17) < 0) {\n    _lseek_r(param_1,(int)*(short *)(param_2 + 0xe),0,2);\n  }\n  *(ushort *)(param_2 + 0xc) = *(ushort *)(param_2 + 0xc) & 0xefff;\n  _write_r(param_1,(int)*(short *)(param_2 + 0xe),param_3,param_4);\n  return;\n}\n\n", 
            "called": [
                "_write_r", 
                "_lseek_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006f5a", 
            "calling": [], 
            "imported": false, 
            "current_name": "__swrite"
        }, 
        "HAL_I2C_MemRxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002f9a", 
            "calling": [
                "I2C_MasterReceive_BTF", 
                "I2C_MasterReceive_RXNE"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_MemRxCpltCallback"
        }, 
        "USART2_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid USART2_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART2_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_080056bc + 4));\n  return;\n}\n\n", 
            "called": [
                "HAL_NVIC_ClearPendingIRQ", 
                "HAL_UART_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080056a8", 
            "calling": [], 
            "imported": false, 
            "current_name": "USART2_IRQHandler"
        }, 
        "HAL_ADC_GetValue": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_ADC_GetValue(ADC_HandleTypeDef *hadc)\n\n{\n  return hadc->Instance->DR;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001e40", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_GetValue"
        }, 
        "HAL_GPIO_WritePin": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin,GPIO_PinState PinState)\n\n{\n  if (PinState == GPIO_PIN_RESET) {\n    GPIOx->BSRR = (uint)GPIO_Pin << 0x10;\n    return;\n  }\n  GPIOx->BSRR = (uint)GPIO_Pin;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800281e", 
            "calling": [
                "digital_io_write"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_WritePin"
        }, 
        "premain": {
            "renaming": {}, 
            "code": "\nvoid premain(void)\n\n{\n  EVP_PKEY_CTX *ctx;\n  \n  ctx = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(ctx);\n  return;\n}\n\n", 
            "called": [
                "HAL_NVIC_SetPriorityGrouping", 
                "init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005f5e", 
            "calling": [
                "__libc_init_array"
            ], 
            "imported": false, 
            "current_name": "premain"
        }, 
        "serial_rx_active": {
            "renaming": {}, 
            "code": "\nuint8_t serial_rx_active(serial_t *obj)\n\n{\n  HAL_UART_StateTypeDef HVar1;\n  \n  HVar1 = HAL_UART_GetState(*(UART_HandleTypeDef **)\n                             (PTR_uart_handlers_080054ac + (uint)obj->index * 4));\n  return (HVar1 & 0x22U) == 0x22;\n}\n\n", 
            "called": [
                "HAL_UART_GetState"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800548c", 
            "calling": [
                "uart_getc", 
                "uart_attach_rx_callback"
            ], 
            "imported": false, 
            "current_name": "serial_rx_active"
        }, 
        "createChar": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08001574 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __thiscall LiquidCrystal::createChar(LiquidCrystal *this,uint8_t location,uint8_t *charmap)\n\n{\n  int iVar1;\n  \n  send(this,(byte)((location & 7) << 3) | 0x40,'\\0');\n  for (iVar1 = 0; iVar1 < 8; iVar1 = iVar1 + 1) {\n    (**(this->super_Print)._vptr_Print)(this,(uint)charmap[iVar1]);\n  }\n  return;\n}\n\n", 
            "called": [
                "send"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001550", 
            "calling": [
                "setup"
            ], 
            "imported": false, 
            "current_name": "createChar"
        }, 
        "clear": {
            "renaming": {}, 
            "code": "\nvoid __thiscall LiquidCrystal::clear(LiquidCrystal *this)\n\n{\n  send(this,'\\x01','\\0');\n  return;\n}\n\n", 
            "called": [
                "send"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800135a", 
            "calling": [
                "loop", 
                "begin", 
                "setup"
            ], 
            "imported": false, 
            "current_name": "clear"
        }, 
        "HAL_I2C_EnableListen_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)\n\n{\n  I2C_TypeDef *pIVar1;\n  \n  if (hi2c->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  hi2c->State = HAL_I2C_STATE_LISTEN;\n  pIVar1 = hi2c->Instance;\n  if ((pIVar1->CR1 & 1) == 0) {\n    pIVar1->CR1 = pIVar1->CR1 | 1;\n  }\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n  hi2c->Instance->CR2 = hi2c->Instance->CR2 | 0x300;\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002c10", 
            "calling": [
                "HAL_I2C_ErrorCallback", 
                "HAL_I2C_ListenCpltCallback"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_EnableListen_IT"
        }, 
        "SystemClock_Config": {
            "renaming": {}, 
            "code": "\nvoid SystemClock_Config(void)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  RCC_PeriphCLKInitTypeDef PeriphClkInit;\n  RCC_ClkInitTypeDef RCC_ClkInitStruct;\n  RCC_OscInitTypeDef RCC_OscInitStruct;\n  \n  RCC_OscInitStruct.OscillatorType = 2;\n  RCC_OscInitStruct.HSIState = 1;\n  RCC_OscInitStruct.HSICalibrationValue = 0x10;\n  RCC_OscInitStruct.PLL.PLLState = 2;\n  RCC_OscInitStruct.PLL.PLLSource = 0;\n  RCC_OscInitStruct.PLL.PLLMUL = 0x380000;\n  HVar1 = HAL_RCC_OscConfig((RCC_OscInitTypeDef_conflict *)&RCC_OscInitStruct);\n  if (HVar1 != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08001be4,0x88);\n  }\n  RCC_ClkInitStruct.ClockType = 0xf;\n  RCC_ClkInitStruct.SYSCLKSource = 2;\n  RCC_ClkInitStruct.AHBCLKDivider = 0;\n  RCC_ClkInitStruct.APB1CLKDivider = 0x400;\n  RCC_ClkInitStruct.APB2CLKDivider = 0;\n  HVar1 = HAL_RCC_ClockConfig((RCC_ClkInitTypeDef_conflict *)&RCC_ClkInitStruct,2);\n  if (HVar1 != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08001be4,0x95);\n  }\n  PeriphClkInit.PeriphClockSelection = 2;\n  PeriphClkInit.AdcClockSelection = 0x8000;\n  HVar1 = HAL_RCCEx_PeriphCLKConfig((RCC_PeriphCLKInitTypeDef_conflict *)&PeriphClkInit);\n  if (HVar1 != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08001be4,0x9c);\n  }\n  uVar2 = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config((uint)((ulonglong)DAT_08001be0 * (ulonglong)uVar2 >> 0x26));\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n", 
            "called": [
                "HAL_SYSTICK_Config", 
                "HAL_SYSTICK_CLKSourceConfig", 
                "HAL_RCCEx_PeriphCLKConfig", 
                "HAL_RCC_ClockConfig", 
                "HAL_NVIC_SetPriority", 
                "_Error_Handler", 
                "HAL_RCC_OscConfig", 
                "HAL_RCC_GetHCLKFreq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001b48", 
            "calling": [
                "hw_config_init"
            ], 
            "imported": false, 
            "current_name": "SystemClock_Config"
        }, 
        "__aeabi_atexit": {
            "renaming": {}, 
            "code": "\nvoid __aeabi_atexit(undefined4 param_1,undefined4 param_2)\n\n{\n  __cxa_atexit(param_2,param_1);\n  return;\n}\n\n", 
            "called": [
                "__cxa_atexit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006112", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "__aeabi_atexit"
        }, 
        "__swbuf_r": {
            "renaming": {}, 
            "code": "\nuint __swbuf_r(int param_1,uint param_2,int *param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined *puVar3;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_3 == (int *)PTR___sf_fake_stdin_080069d8) {\n    param_3 = *(int **)(param_1 + 4);\n  }\n  else if (param_3 == (int *)PTR___sf_fake_stdout_080069dc) {\n    param_3 = *(int **)(param_1 + 8);\n  }\n  else if (param_3 == (int *)PTR___sf_fake_stderr_080069e0) {\n    param_3 = *(int **)(param_1 + 0xc);\n  }\n  param_3[2] = param_3[6];\n  uVar2 = (uint)*(ushort *)(param_3 + 3);\n  iVar1 = uVar2 << 0x1c;\n  if (((iVar1 < 0) && (uVar2 = param_3[4], uVar2 != 0)) ||\n     (iVar1 = __swsetup_r(param_1,param_3,iVar1,uVar2,param_4), iVar1 == 0)) {\n    param_2 = param_2 & 0xff;\n    iVar1 = *param_3 - param_3[4];\n    if ((iVar1 < param_3[5]) || (iVar1 = _fflush_r(param_1,param_3), iVar1 == 0)) {\n      param_3[2] = param_3[2] + -1;\n      puVar3 = (undefined *)*param_3;\n      *param_3 = (int)(puVar3 + 1);\n      *puVar3 = (char)param_2;\n      if (iVar1 + 1 != param_3[5]) {\n        if (-1 < (int)((uint)*(ushort *)(param_3 + 3) << 0x1f)) {\n          return param_2;\n        }\n        if (param_2 != 10) {\n          return param_2;\n        }\n      }\n      iVar1 = _fflush_r(param_1,param_3);\n      if (iVar1 == 0) {\n        return param_2;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n", 
            "called": [
                "_fflush_r", 
                "__swsetup_r", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006940", 
            "calling": [
                "__sfputc_r"
            ], 
            "imported": false, 
            "current_name": "__swbuf_r"
        }, 
        "printNumber": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005d38 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nsize_t __thiscall Print::printNumber(Print *this,ulong n,uint8_t base)\n\n{\n  char cVar1;\n  size_t sVar2;\n  size_t sVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  char *__s;\n  char buf [33];\n  \n  uVar5 = (uint)base;\n  buf[32] = '\\0';\n  if (uVar5 < 2) {\n    uVar5 = 10;\n  }\n  __s = buf + 0x20;\n  do {\n    uVar6 = n / uVar5;\n    uVar4 = (n & 0xff) - (uVar6 * uVar5 & 0xff) & 0xff;\n    __s = __s + -1;\n    cVar1 = (char)uVar4;\n    if (uVar4 < 10) {\n      cVar1 = cVar1 + '0';\n    }\n    else {\n      cVar1 = cVar1 + '7';\n    }\n    *__s = cVar1;\n    n = uVar6;\n  } while (uVar6 != 0);\n  if (__s == (char *)0x0) {\n    sVar3 = 0;\n  }\n  else {\n    sVar2 = strlen(__s);\n    sVar3 = (*this->_vptr_Print[1])(sVar2,__s,sVar2);\n  }\n  return sVar3;\n}\n\n", 
            "called": [
                "strlen"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005ce8", 
            "calling": [
                "print", 
                "print"
            ], 
            "imported": false, 
            "current_name": "printNumber"
        }, 
        "HAL_I2C_ER_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  I2C_TypeDef *pIVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  pIVar2 = hi2c->Instance;\n  uVar3 = pIVar2->SR1;\n  uVar4 = pIVar2->CR2;\n  if (((uVar3 & DAT_080035f8) != 0) && ((uVar4 & 0x100) != 0)) {\n    hi2c->ErrorCode = hi2c->ErrorCode | 1;\n    pIVar2->SR1 = 0xfffffeff;\n    hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x8000;\n  }\n  if (((uVar3 & 0x10200) != 0) && ((uVar4 & 0x100) != 0)) {\n    hi2c->ErrorCode = hi2c->ErrorCode | 2;\n    hi2c->Instance->SR1 = 0xfffffdff;\n  }\n  if (((uVar3 & 0x10400) != 0) && ((uVar4 & 0x100) != 0)) {\n    HVar1 = hi2c->State;\n    if (((hi2c->Mode == HAL_I2C_MODE_SLAVE) && (hi2c->XferCount == 0)) &&\n       (((HVar1 == HAL_I2C_STATE_BUSY_TX || (HVar1 == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((HVar1 == HAL_I2C_STATE_LISTEN && (hi2c->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(hi2c);\n    }\n    else {\n      hi2c->ErrorCode = hi2c->ErrorCode | 4;\n      if (hi2c->Mode == HAL_I2C_MODE_MASTER) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n      }\n      hi2c->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((uVar3 & 0x10800) != 0) && ((uVar4 & 0x100) != 0)) {\n    hi2c->ErrorCode = hi2c->ErrorCode | 8;\n    hi2c->Instance->SR1 = 0xfffff7ff;\n  }\n  if (hi2c->ErrorCode != 0) {\n    I2C_ITError(hi2c);\n  }\n  return;\n}\n\n", 
            "called": [
                "I2C_Slave_AF", 
                "I2C_ITError"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003520", 
            "calling": [
                "I2C1_ER_IRQHandler", 
                "I2C2_ER_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_ER_IRQHandler"
        }, 
        "HAL_ADC_PollForConversion": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef_conflict HAL_ADC_PollForConversion(ADC_HandleTypeDef *hadc,uint32_t Timeout)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  int iVar4;\n  ADC_TypeDef *pAVar5;\n  uint uVar6;\n  uint32_t Conversion_Timeout_CPU_cycles;\n  \n  Conversion_Timeout_CPU_cycles = 0;\n  uVar2 = HAL_GetTick();\n  pAVar5 = hadc->Instance;\n  if ((pAVar5->CR2 & 0x100) == 0) {\n    if (((pAVar5->CR1 & 0x100) == 0) && ((pAVar5->SQR1 & 0xf00000) == 0)) {\n      do {\n        if ((hadc->Instance->SR & 2) != 0) goto LAB_08001de2;\n      } while ((Timeout == 0xffffffff) ||\n              ((Timeout != 0 && (uVar3 = HAL_GetTick(), uVar3 - uVar2 <= Timeout))));\n      hadc->State = hadc->State | 4;\n      hadc->Lock = HAL_UNLOCKED;\n      HVar1 = HAL_TIMEOUT;\n    }\n    else {\n      uVar6 = *(uint *)PTR_SystemCoreClock_08001e2c;\n      uVar3 = HAL_RCCEx_GetPeriphCLKFreq(2);\n      pAVar5 = hadc->Instance;\n      if (((pAVar5->SMPR2 & DAT_08001e30) == 0) &&\n         ((pAVar5->SMPR1 & DAT_08001e30 + 0xdc000000) == 0)) {\n        if ((pAVar5->SMPR2 & DAT_08001e34) == 0) {\n          if ((pAVar5->SMPR1 & DAT_08001e38) == 0) {\n            iVar4 = 0x14;\n          }\n          else {\n            iVar4 = 0x29;\n          }\n        }\n        else {\n          iVar4 = 0x29;\n        }\n      }\n      else if (((pAVar5->SMPR2 & DAT_08001e34) == 0) &&\n              ((pAVar5->SMPR1 & DAT_08001e34 + 0xee000000) == 0)) {\n        iVar4 = 0x54;\n      }\n      else if ((DAT_08001e3c & pAVar5->SMPR2) == 0) {\n        if ((DAT_08001e3c & pAVar5->SMPR1) == 0) {\n          iVar4 = 0x54;\n        }\n        else {\n          iVar4 = 0xfc;\n        }\n      }\n      else {\n        iVar4 = 0xfc;\n      }\n      uVar6 = (uVar6 / uVar3) * iVar4;\n      for (; Conversion_Timeout_CPU_cycles <= uVar6 && uVar6 - Conversion_Timeout_CPU_cycles != 0;\n          Conversion_Timeout_CPU_cycles = Conversion_Timeout_CPU_cycles + 1) {\n        if ((Timeout != 0xffffffff) &&\n           ((Timeout == 0 || (uVar3 = HAL_GetTick(), Timeout < uVar3 - uVar2)))) {\n          hadc->State = hadc->State | 4;\n          hadc->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nLAB_08001de2:\n      hadc->Instance->SR = 0xffffffed;\n      hadc->State = hadc->State | 0x200;\n      if ((hadc->Instance->CR2 & 0xe0000) == 0xe0000) {\n        if ((hadc->Init).ContinuousConvMode == 0) {\n          hadc->State = hadc->State & 0xfffffeff;\n          if ((hadc->State & 0x1000) == 0) {\n            hadc->State = hadc->State | 1;\n            HVar1 = HAL_OK;\n          }\n          else {\n            HVar1 = HAL_OK;\n          }\n        }\n        else {\n          HVar1 = HAL_OK;\n        }\n      }\n      else {\n        HVar1 = HAL_OK;\n      }\n    }\n  }\n  else {\n    hadc->State = hadc->State | 0x20;\n    hadc->Lock = HAL_UNLOCKED;\n    HVar1 = HAL_ERROR;\n  }\n  return HVar1;\n}\n\n", 
            "called": [
                "HAL_RCCEx_GetPeriphCLKFreq", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001cd0", 
            "calling": [
                "adc_read_value"
            ], 
            "imported": false, 
            "current_name": "HAL_ADC_PollForConversion"
        }, 
        "SetSampleTime": {
            "renaming": {}, 
            "code": "\nvoid __thiscall PID::SetSampleTime(PID *this,int NewSampleTime)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  double dVar4;\n  \n  if (0 < NewSampleTime) {\n    uVar2 = __floatsidf(NewSampleTime);\n    uVar3 = __floatunsidf(this->SampleTime);\n    uVar2 = __divdf3((int)uVar2,(int)((ulonglong)uVar2 >> 0x20),(int)uVar3,\n                     (int)((ulonglong)uVar3 >> 0x20));\n    uVar1 = (undefined4)((ulonglong)uVar2 >> 0x20);\n    dVar4 = (double)__muldf3((int)uVar2,uVar1,*(undefined4 *)&this->ki,\n                             *(undefined4 *)((int)&this->ki + 4));\n    this->ki = dVar4;\n    dVar4 = (double)__divdf3(*(undefined4 *)&this->kd,*(undefined4 *)((int)&this->kd + 4),(int)uVar2\n                             ,uVar1);\n    this->kd = dVar4;\n    this->SampleTime = NewSampleTime;\n  }\n  return;\n}\n\n", 
            "called": [
                "__muldf3", 
                "__floatunsidf", 
                "__divdf3", 
                "__floatsidf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001918", 
            "calling": [
                "loop"
            ], 
            "imported": false, 
            "current_name": "SetSampleTime"
        }, 
        "SetTunings": {
            "renaming": {}, 
            "code": "\nvoid PID::SetTunings(PID *this,double Kp,double Ki,double Kd)\n\n{\n  undefined4 in_stack_ffffffec;\n  \n  SetTunings(this,Kp,Ki,(double)CONCAT44(in_stack_ffffffec,this->pOn),this->pOn);\n  return;\n}\n\n", 
            "called": [
                "SetTunings"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080018f8", 
            "calling": [
                "loop"
            ], 
            "imported": false, 
            "current_name": "SetTunings"
        }, 
        "__tcf_0": {
            "renaming": {}, 
            "code": "\nvoid __tcf_0(void *param_1)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  \n  puVar1 = PTR___malloc_free_list_08005fc0;\n  while (puVar2 = puVar1, puVar2 != PTR_gpio_irq_conf_08005fc4) {\n    puVar1 = puVar2 + -0x14;\n    if (*(code **)(puVar2 + -8) != (code *)0x0) {\n      (**(code **)(puVar2 + -8))(puVar2 + -0x10,puVar2 + -0x10,3);\n    }\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005fa0", 
            "calling": [], 
            "imported": false, 
            "current_name": "__tcf_0"
        }, 
        "__do_global_dtors_aux": {
            "renaming": {}, 
            "code": "\nundefined * __do_global_dtors_aux(undefined *param_1)\n\n{\n  if (*PTR_completed_8667_08000124 == '\\0') {\n    if (DAT_08000128 != 0) {\n      param_1 = PTR__init_0800012c;\n    }\n    *PTR_completed_8667_08000124 = 1;\n  }\n  return param_1;\n}\n\n", 
            "called": [
                "_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800010c", 
            "calling": [], 
            "imported": false, 
            "current_name": "__do_global_dtors_aux"
        }, 
        "HAL_GPIO_ReadPin": {
            "renaming": {}, 
            "code": "\nGPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin)\n\n{\n  if (((uint)GPIO_Pin & GPIOx->IDR) == 0) {\n    return GPIO_PIN_RESET;\n  }\n  return GPIO_PIN_SET;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002810", 
            "calling": [
                "digital_io_read"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_ReadPin"
        }, 
        "Compute": {
            "renaming": {}, 
            "code": "\nbool __thiscall PID::Compute(PID *this)\n\n{\n  bool bVar1;\n  uint32_t uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  undefined4 uVar9;\n  undefined4 uVar10;\n  char cVar11;\n  undefined4 uVar12;\n  undefined4 uVar13;\n  undefined4 uVar14;\n  undefined8 uVar15;\n  undefined8 uVar16;\n  undefined8 uVar17;\n  double dVar18;\n  double dVar19;\n  undefined4 local_38;\n  undefined4 uStack_34;\n  \n  cVar11 = this->inAuto;\n  if ((bool)cVar11 != false) {\n    uVar2 = millis();\n    if (uVar2 - this->lastTime < this->SampleTime) {\n      cVar11 = '\\0';\n    }\n    else {\n      uVar5 = *(undefined4 *)this->myInput;\n      uVar8 = *(undefined4 *)((int)this->myInput + 4);\n      uVar15 = __subdf3(*(undefined4 *)this->mySetpoint,*(undefined4 *)((int)this->mySetpoint + 4));\n      uVar14 = (undefined4)((ulonglong)uVar15 >> 0x20);\n      uVar16 = __subdf3(uVar5,uVar8,*(undefined4 *)&this->lastInput,\n                        *(undefined4 *)((int)&this->lastInput + 4));\n      uVar4 = (undefined4)((ulonglong)uVar16 >> 0x20);\n      uVar17 = __muldf3((int)uVar15,uVar14,*(undefined4 *)&this->ki,\n                        *(undefined4 *)((int)&this->ki + 4));\n      dVar18 = (double)__aeabi_dadd((int)uVar17,(int)((ulonglong)uVar17 >> 0x20),\n                                    *(undefined4 *)&this->outputSum,\n                                    *(undefined4 *)((int)&this->outputSum + 4));\n      this->outputSum = dVar18;\n      bVar1 = this->pOnE;\n      if (bVar1 == false) {\n        uVar17 = __muldf3((int)uVar16,uVar4,*(undefined4 *)&this->kp,\n                          *(undefined4 *)((int)&this->kp + 4));\n        dVar18 = (double)__subdf3(SUB84(dVar18,0),(int)((ulonglong)dVar18 >> 0x20),(int)uVar17,\n                                  (int)((ulonglong)uVar17 >> 0x20));\n        this->outputSum = dVar18;\n      }\n      uVar6 = *(undefined4 *)&this->outputSum;\n      uVar9 = *(undefined4 *)((int)&this->outputSum + 4);\n      uVar12 = *(undefined4 *)&this->outMax;\n      uVar13 = *(undefined4 *)((int)&this->outMax + 4);\n      dVar18 = this->outMax;\n      iVar3 = __aeabi_dcmpgt(uVar6,uVar9,uVar12,uVar13);\n      if (iVar3 == 0) {\n        uVar7 = *(undefined4 *)&this->outMin;\n        uVar10 = *(undefined4 *)((int)&this->outMin + 4);\n        iVar3 = __aeabi_dcmplt(uVar6,uVar9);\n        if (iVar3 != 0) {\n          *(undefined4 *)&this->outputSum = uVar7;\n          *(undefined4 *)((int)&this->outputSum + 4) = uVar10;\n        }\n      }\n      else {\n        *(undefined4 *)&this->outputSum = uVar12;\n        *(undefined4 *)((int)&this->outputSum + 4) = uVar13;\n      }\n      if (bVar1 == false) {\n        uVar15 = 0;\n      }\n      else {\n        uVar15 = __muldf3((int)uVar15,uVar14,*(undefined4 *)&this->kp,\n                          *(undefined4 *)((int)&this->kp + 4));\n      }\n      uStack_34 = (undefined4)((ulonglong)uVar15 >> 0x20);\n      local_38 = (undefined4)uVar15;\n      uVar14 = *(undefined4 *)&this->outputSum;\n      uVar6 = *(undefined4 *)((int)&this->outputSum + 4);\n      uVar15 = __muldf3((int)uVar16,uVar4,*(undefined4 *)&this->kd,\n                        *(undefined4 *)((int)&this->kd + 4));\n      uVar15 = __subdf3(uVar14,uVar6,(int)uVar15,(int)((ulonglong)uVar15 >> 0x20));\n      dVar19 = (double)__aeabi_dadd(local_38,uStack_34,(int)uVar15,(int)((ulonglong)uVar15 >> 0x20))\n      ;\n      uVar14 = (undefined4)((ulonglong)dVar19 >> 0x20);\n      iVar3 = __aeabi_dcmplt(uVar12,uVar13,SUB84(dVar19,0),uVar14);\n      if (iVar3 == 0) {\n        dVar18 = this->outMin;\n        iVar3 = __aeabi_dcmplt(SUB84(dVar19,0),uVar14,*(undefined4 *)&this->outMin,\n                               *(undefined4 *)((int)&this->outMin + 4));\n        if (iVar3 == 0) {\n          dVar18 = dVar19;\n        }\n      }\n      *this->myOutput = dVar18;\n      *(undefined4 *)&this->lastInput = uVar5;\n      *(undefined4 *)((int)&this->lastInput + 4) = uVar8;\n      this->lastTime = uVar2;\n    }\n  }\n  return (bool)cVar11;\n}\n\n", 
            "called": [
                "__muldf3", 
                "__subdf3", 
                "__aeabi_dadd", 
                "__aeabi_dcmpgt", 
                "__aeabi_dcmplt", 
                "millis"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080016b4", 
            "calling": [
                "loop"
            ], 
            "imported": false, 
            "current_name": "Compute"
        }, 
        "_fini": {
            "renaming": {}, 
            "code": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007334", 
            "calling": [], 
            "imported": false, 
            "current_name": "_fini"
        }, 
        "HAL_I2C_MasterRxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002c50", 
            "calling": [
                "I2C_MasterReceive_BTF", 
                "I2C_MasterReceive_RXNE"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_MasterRxCpltCallback"
        }, 
        "digitalWrite": {
            "renaming": {}, 
            "code": "\nvoid digitalWrite(uint32_t ulPin,uint32_t ulVal)\n\n{\n  _Bool _Var1;\n  GPIO_TypeDef *port;\n  uint uVar2;\n  \n  if (ulPin < 0x3c) {\n    uVar2 = (uint)(char)PTR_digitalPin_08005888[ulPin];\n  }\n  else {\n    uVar2 = 0xffffffff;\n  }\n  if ((uVar2 != 0xffffffff) &&\n     (_Var1 = is_pin_configured((PinName_conflict)uVar2,(uint32_t *)PTR_g_digPinConfigured_0800588c)\n     , _Var1)) {\n    port = get_GPIO_Port((uVar2 << 0x18) >> 0x1c);\n    digital_io_write(port,1 << (uVar2 & 0xf) & 0xffff,ulVal);\n  }\n  return;\n}\n\n", 
            "called": [
                "digital_io_write", 
                "is_pin_configured", 
                "get_GPIO_Port"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005848", 
            "calling": [
                "pulseEnable", 
                "MAX31855", 
                "loop", 
                "readData", 
                "send", 
                "write8bits", 
                "begin", 
                "write4bits", 
                "setup"
            ], 
            "imported": false, 
            "current_name": "digitalWrite"
        }, 
        "pinmap_find_function": {
            "renaming": {}, 
            "code": "\nuint32_t pinmap_find_function(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map->pin == NC) {\n      return 0xffffffff;\n    }\n    if (map->pin == pin) break;\n    map = map + 1;\n  }\n  return map->function;\n}\n\n", 
            "called": [
                "pinmap_find_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004cb2", 
            "calling": [
                "pinmap_function", 
                "pinmap_find_function"
            ], 
            "imported": false, 
            "current_name": "pinmap_find_function"
        }, 
        "serialEventRun": {
            "renaming": {}, 
            "code": "\nvoid serialEventRun(void)\n\n{\n  if (DAT_08005a3c != 0) {\n    HardwareSerial::available((HardwareSerial *)PTR_Serial2_08005a40);\n  }\n  return;\n}\n\n", 
            "called": [
                "available"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005a18", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "serialEventRun"
        }, 
        "_fflush_r": {
            "renaming": {}, 
            "code": "\nundefined4 _fflush_r(int param_1,undefined *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uVar1;\n  \n  if (*(int *)(param_2 + 0x10) != 0) {\n    if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n      __sinit();\n    }\n    if (param_2 == PTR___sf_fake_stdin_08006c28) {\n      param_2 = *(undefined **)(param_1 + 4);\n    }\n    else if (param_2 == PTR___sf_fake_stdout_08006c2c) {\n      param_2 = *(undefined **)(param_1 + 8);\n    }\n    else if (param_2 == PTR___sf_fake_stderr_08006c30) {\n      param_2 = *(undefined **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 0xc) != 0) {\n      uVar1 = __sflush_r(param_1,param_2,param_3,param_4);\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n", 
            "called": [
                "__sflush_r", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006be0", 
            "calling": [
                "__swbuf_r"
            ], 
            "imported": false, 
            "current_name": "_fflush_r"
        }, 
        "__sfp": {
            "renaming": {}, 
            "code": "\nint * __sfp(undefined4 *param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int iVar3;\n  int **ppiVar4;\n  \n  iVar3 = *(int *)PTR__global_impure_ptr_08006d88;\n  if (*(int *)(iVar3 + 0x18) == 0) {\n    __sinit(iVar3);\n  }\n  ppiVar4 = (int **)(iVar3 + 0x48);\n  do {\n    piVar2 = ppiVar4[2];\n    piVar1 = ppiVar4[1];\n    while (piVar1 = (int *)((int)piVar1 + -1), -1 < (int)piVar1) {\n      if (*(short *)(piVar2 + 3) == 0) {\n        *(undefined2 *)((int)piVar2 + 0xe) = 0xffff;\n        piVar2[0x19] = 0;\n        *(undefined2 *)(piVar2 + 3) = 1;\n        *piVar2 = 0;\n        piVar2[2] = 0;\n        piVar2[1] = 0;\n        piVar2[4] = 0;\n        piVar2[5] = 0;\n        piVar2[6] = 0;\n        memset(piVar2 + 0x17,0,8);\n        piVar2[0xd] = 0;\n        piVar2[0xe] = 0;\n        piVar2[0x12] = 0;\n        piVar2[0x13] = 0;\n        return piVar2;\n      }\n      piVar2 = piVar2 + 0x1a;\n    }\n    if (*ppiVar4 == (int *)0x0) {\n      piVar1 = (int *)__sfmoreglue(param_1,4);\n      *ppiVar4 = piVar1;\n      if (piVar1 == (int *)0x0) {\n        *param_1 = 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar4 = (int **)*ppiVar4;\n  } while( true );\n}\n\n", 
            "called": [
                "memset", 
                "__sfmoreglue", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006d14", 
            "calling": [
                "__sinit"
            ], 
            "imported": false, 
            "current_name": "__sfp"
        }, 
        "HAL_NVIC_EnableIRQ": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_EnableIRQ(IRQn_Type_conflict IRQn)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)IRQn;\n  if (-1 < (int)uVar1) {\n    *(int *)(DAT_08002510 + (uVar1 >> 5) * 4) = 1 << (uVar1 & 0x1f);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080024f8", 
            "calling": [
                "uart_attach_tx_callback", 
                "uart_attach_rx_callback"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_EnableIRQ"
        }, 
        "TIM1_UP_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM1_UP_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)PTR_timer_handles_08004e30 != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)PTR_timer_handles_08004e30);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004e20", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM1_UP_IRQHandler"
        }
    }, 
    "locked_functions": [], 
    "used_tokens": 0, 
    "layers": []
}