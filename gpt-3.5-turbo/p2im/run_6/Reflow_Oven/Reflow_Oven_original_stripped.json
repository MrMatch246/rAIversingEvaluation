{
    "functions": {
        "FUN_08002470": {
            "renaming": {
                "FUN_08002470": "set_priority_group_08002470",
                "PriorityGroup": "priority_group",
                "DAT_08002490": "priority_register",
                "uint32_t*": "pointer_to_uint32_t",
                "uint32_t": "uint32_t",
                "*(uint32_t *)(DAT_08002490 + 0xc)": "priority_register",
                "priority_group": "priority_group",
                "priority_mask": "priority_mask",
                "priority_bits": "priority_bits",
                "priority_value": "priority_value"
            },
            "code": "void set_priority_group_08002470(uint32_t priority_group){\n    uint32_t* DAT_08002490 = (uint32_t*)(DAT_08002490 + 0xc);\n    uint32_t priority_mask = *(uint32_t*)(DAT_08002490 + 0xc) & 0xf8ff;\n    uint32_t priority_bits = (priority_group & 7) << 8;\n    uint32_t priority_value = priority_bits | priority_mask | 0x5fa0000;\n    *DAT_08002490 = priority_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002470",
            "calling": [
                "HAL_Init",
                "premain"
            ],
            "imported": false,
            "current_name": "set_priority_group_08002470"
        },
        "FUN_08007004": {
            "renaming": {
                "FUN_08007004": "get_file_status_08007004",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "status_info",
                "puVar1": "error_ptr",
                "iVar2": "status_code"
            },
            "code": "void get_file_status_08007004(int *error_code, int file_descriptor, stat *status_info) {\n                      undefined *error_ptr;\n                      int status_code;\n                      error_ptr = PTR_errno_08007024;\n                      *(undefined4 *)PTR_errno_08007024 = 0;\n                      status_code = _fstat(file_descriptor, status_info);\n                      if ((status_code == -1) && (*(int *)error_ptr != 0)) {\n                        *error_code = *(int *)error_ptr;\n                      }\n                    }",
            "called": [
                "_fstat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007004",
            "calling": [
                "__swhatbuf_r"
            ],
            "imported": false,
            "current_name": "get_file_status_08007004"
        },
        "FUN_08006394": {
            "renaming": {
                "FUN_08006394": "print_formatted_output_08006394",
                "param_1": "stream_pointer",
                "param_2": "format_string",
                "param_3": "args",
                "param_4": "args_pointer",
                "bVar1": "is_digit",
                "puVar2": "digits",
                "iVar3": "chars_written",
                "pvVar4": "char_ptr",
                "piVar5": "int_ptr",
                "pbVar6": "format_ptr",
                "pbVar7": "current_char",
                "unaff_r9": "temp_var",
                "iVar8": "return_value",
                "local_8c": "args_pointer_copy",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "width",
                "local_7c": "arg_number",
                "local_74": "total_chars_written",
                "local_70": "conversion_char",
                "local_6f": "space_char",
                "local_6e": "plus_char",
                "local_45": "sign_char",
                "local_30": "zero_char"
            },
            "code": "\nint print_formatted_output_08006394(int stream_pointer,undefined *format_string,byte *args,int *args_pointer)\n\n{\n  bool is_digit;\n  undefined *digits;\n  int chars_written;\n  void *char_ptr;\n  int *int_ptr;\n  byte *format_ptr;\n  byte *current_char;\n  int temp_var;\n  int return_value;\n  int *args_pointer_copy;\n  uint flags;\n  int precision;\n  undefined4 width;\n  int arg_number;\n  int total_chars_written;\n  byte conversion_char;\n  undefined space_char;\n  undefined plus_char;\n  undefined sign_char;\n  undefined4 zero_char;\n  \n  args_pointer_copy = args_pointer;\n  if ((stream_pointer != 0) && (*(int *)(stream_pointer + 0x18) == 0)) {\n    __sinit();\n  }\n  if (format_string == PTR___sf_fake_stdin_080065a0) {\n    format_string = *(undefined **)(stream_pointer + 4);\n  }\n  else if (format_string == PTR___sf_fake_stdout_080065a8) {\n    format_string = *(undefined **)(stream_pointer + 8);\n  }\n  else if (format_string == PTR___sf_fake_stderr_080065ac) {\n    format_string = *(undefined **)(stream_pointer + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(format_string + 0xc) << 0x1c)) || (*(int *)(format_string + 0x10) == 0)) &&\n     (return_value = __swsetup_r(stream_pointer,format_string), return_value != 0)) {\n    return -1;\n  }\n  total_chars_written = 0;\n  space_char = 0x20;\n  plus_char = 0x30;\n  format_ptr = args;\nLAB_080063d6:\n  current_char = format_ptr;\n  if (*current_char != 0) goto LAB_0800648c;\n  goto LAB_080063e0;\nLAB_0800648c:\n  format_ptr = current_char + 1;\n  if (*current_char != 0x25) goto LAB_080063d6;\nLAB_080063e0:\n  return_value = (int)current_char - (int)args;\n  if (return_value != 0) {\n    chars_written = __sfputs_r(stream_pointer,format_string,args,return_value);\n    if (chars_written == -1) {\nLAB_08006580:\n      if ((int)((uint)*(ushort *)(format_string + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return total_chars_written;\n    }\n    total_chars_written = total_chars_written + return_value;\n  }\n  if (*current_char == 0) goto LAB_08006580;\n  flags = 0;\n  arg_number = 0;\n  precision = -1;\n  width = 0;\n  sign_char = 0;\n  zero_char = 0;\n  format_ptr = current_char + 1;\n  while( true ) {\n    char_ptr = memchr(PTR_s___0__080065a4,(uint)*format_ptr,5);\n    digits = PTR_DAT_080065b0;\n    args = format_ptr + 1;\n    if (char_ptr == (void *)0x0) break;\n    flags = 1 << ((int)char_ptr - (int)PTR_s___0__080065a4 & 0xffU) | flags;\n    format_ptr = args;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    sign_char = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    sign_char = 0x2b;\n  }\n  if (*format_ptr == 0x2a) {\n    int_ptr = args_pointer_copy + 1;\n    return_value = *args_pointer_copy;\n    args_pointer_copy = int_ptr;\n    if (-1 < return_value) goto LAB_080064b0;\n    arg_number = -return_value;\n    flags = flags | 2;\n  }\n  else {\n    is_digit = false;\n    return_value = arg_number;\n    args = format_ptr;\n    while( true ) {\n      if (9 < *args - 0x30) break;\n      return_value = return_value * 10 + (*args - 0x30);\n      is_digit = true;\n      args = args + 1;\n    }\n    if (is_digit) {\nLAB_080064b0:\n      arg_number = return_value;\n    }\n  }\n  if (*args == 0x2e) {\n    if (args[1] == 0x2a) {\n      args = args + 2;\n      int_ptr = args_pointer_copy + 1;\n      precision = *args_pointer_copy;\n      args_pointer_copy = int_ptr;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      is_digit = false;\n      return_value = 0;\n      precision = 0;\n      while( true ) {\n        args = args + 1;\n        if (9 < *args - 0x30) break;\n        return_value = return_value * 10 + (*args - 0x30);\n        is_digit = true;\n      }\n      if (is_digit) {\n        precision = return_value;\n      }\n    }\n  }\n  char_ptr = memchr(PTR_DAT_080065b0,(uint)*args,3);\n  if (char_ptr != (void *)0x0) {\n    args = args + 1;\n    flags = flags | 0x40 << ((int)char_ptr - (int)digits & 0xffU);\n  }\n  conversion_char = *args;\n  args = args + 1;\n  char_ptr = memchr(PTR_s_efgEFG_080065b4,(uint)conversion_char,6);\n  if (char_ptr == (void *)0x0) {\n    return_value = _printf_i(stream_pointer,&flags,format_string,DAT_080065bc,&args_pointer_copy);\n  }\n  else {\n    return_value = stream_pointer;\n    if (DAT_080065b8 == 0) {\n      args_pointer_copy = (int *)(((int)args_pointer_copy + 7U & 0xfffffff8) + 8);\n      return_value = temp_var;\n      goto LAB_08006532;\n    }\n  }\n  if (return_value == -1) goto LAB_08006580;\nLAB_08006532:\n  total_chars_written = total_chars_written + return_value;\n  format_ptr = args;\n  temp_var = return_value;\n  goto LAB_080063d6;\n}\n\n",
            "called": [
                "__sfputs_r",
                "__swsetup_r",
                "_printf_i",
                "__sinit",
                "memchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006394",
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "imported": false,
            "current_name": "print_formatted_output_08006394"
        },
        "FUN_080035fc": {
            "renaming": {
                "FUN_080035fc": "reset_I2C_state_080035fc",
                "hdma": "i2c_handle",
                "hi2c": "i2c",
                "Parent": "parent",
                "Instance": "instance",
                "CR1": "cr1",
                "XferCount": "xfer_count",
                "hdmatx": "tx_dma_handle",
                "XferAbortCallback": "xfer_abort_callback",
                "hdmarx": "rx_dma_handle",
                "State": "state",
                "HAL_I2C_STATE_ABORT": "HAL_I2C_STATE_ABORT",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "Mode": "mode",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "ErrorCode": "error_code",
                "HAL_I2C_ErrorCallback": "i2c_error_callback",
                "HAL_I2C_AbortCpltCallback": "i2c_abort_complete_callback"
            },
            "code": "void reset_I2C_state_080035fc(I2C_HandleTypeDef *i2c_handle)\n{\n  \n  I2C_HandleTypeDef *i2c;\n  \n  i2c = (I2C_HandleTypeDef *)i2c_handle->Parent;\n  i2c->Instance->CR1 &= ~(1 << 10);\n  i2c->XferCount = 0;\n  i2c->hdmatx->XferAbortCallback = NULL;\n  i2c->hdmarx->XferAbortCallback = NULL;\n  \n  if (i2c->State != HAL_I2C_STATE_ABORT) {\n    i2c->State = HAL_I2C_STATE_READY;\n    i2c->Mode = HAL_I2C_MODE_NONE;\n    i2c->Instance->CR1 &= ~(1 << 0);\n    HAL_I2C_ErrorCallback(i2c);\n    return;\n  }\n  \n  i2c->State = HAL_I2C_STATE_READY;\n  i2c->Mode = HAL_I2C_MODE_NONE;\n  i2c->ErrorCode = 0;\n  i2c->Instance->CR1 &= ~(1 << 0);\n  HAL_I2C_AbortCpltCallback(i2c);\n  return;\n}",
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035fc",
            "calling": [],
            "imported": false,
            "current_name": "reset_I2C_state_080035fc"
        },
        "FUN_08005740": {
            "renaming": {
                "FUN_08005740": "set_errno_to_22_08005740",
                "pid_UNUSED": "pid_unused",
                "sig_UNUSED": "sig_unused",
                "PTR_errno_0800574c": "PTR_errno_0800574c"
            },
            "code": "int set_errno_to_22_08005740(int pid_unused, int sig_unused) {\n    *(undefined4 *)PTR_errno_0800574c = 22;\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005740",
            "calling": [
                "_kill_r"
            ],
            "imported": false,
            "current_name": "set_errno_to_22_08005740"
        },
        "FUN_08006158": {
            "renaming": {
                "FUN_08006158": "get_result_08006158",
                "param_1": "input_param1",
                "param_2": "input_param2"
            },
            "code": "unsigned long long get_result_08006158(uint32_t input_param1, uint32_t input_param2)\n{\n  if (DAT_08006170 != 0) {\n    return CONCAT44(input_param1, 2);\n  }\n  return (unsigned long long)input_param2 << 0x20;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006158",
            "calling": [
                "__aeabi_atexit"
            ],
            "imported": false,
            "current_name": "get_result_08006158"
        },
        "FUN_08006d8c": {
            "renaming": {
                "FUN_08006d8c": "iterate_over_data_structure_08006d8c",
                "param_1": "starting_address",
                "param_2": "callback_function",
                "param_3": "param_3",
                "param_4": "param_4",
                "piVar3": "current_item_address",
                "iVar4": "item_address",
                "iVar6": "item_count",
                "uVar1": "callback_result",
                "uVar5": "result"
            },
            "code": "uint iterate_over_data_structure_08006d8c(int starting_address, code *callback_function, undefined4 param_3, undefined4 param_4) {\n  uint result = 0;\n  int *current_item_address;\n  int item_address;\n  int item_count;\n  int item_offset;\n  uint callback_result;\n  current_item_address = (int *)(starting_address + 0x48);\n  while (current_item_address != (int *)0x0) {\n    item_address = current_item_address[2];\n    item_count = current_item_address[1];\n    while (item_count > 0) {\n      item_offset = *(ushort *)(item_address + 0xc);\n      if (item_offset > 1) {\n        item_offset = *(short *)(item_address + 0xe) + 1;\n        if (item_offset != 0) {\n          callback_result = (*callback_function)(starting_address, item_address, param_3, item_offset, param_4);\n          result |= callback_result;\n        }\n      }\n      item_address += 0x68;\n      item_count--;\n    }\n    current_item_address = (int *)*current_item_address;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d8c",
            "calling": [
                "_cleanup_r"
            ],
            "imported": false,
            "current_name": "iterate_over_data_structure_08006d8c"
        },
        "FUN_08004f2c": {
            "renaming": {
                "FUN_08004f2c": "handle_I2C_event_08004f2c",
                "PTR_i2c_handles_08004f38": "PTR_i2c_handles",
                "i2c_handle": "i2c_handle"
            },
            "code": "void handle_I2C_event_08004f2c(void)\n{\n  I2C_HandleTypeDef* i2c_handle = *(I2C_HandleTypeDef **)(PTR_i2c_handles_08004f38_08004f38 + 4);\n  HAL_I2C_EV_IRQHandler(i2c_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f2c",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_event_08004f2c"
        },
        "FUN_08003688": {
            "renaming": {
                "FUN_08003688": "configure_RCC_Oscillator_08003688",
                "RCC_OscInitStruct": "osc_init",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "HVar3": "status",
                "uVar4": "current_time",
                "uVar5": "state",
                "bVar6": "flag",
                "tmpreg": "temp_reg"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nHAL_StatusTypeDef_conflict configure_RCC_Oscillator_08003688(RCC_OscInitTypeDef_conflict *osc_init)\n\n{\n  uint *ptr1;\n  uint *ptr2;\n  HAL_StatusTypeDef_conflict status;\n  uint32_t current_time;\n  uint32_t state;\n  bool flag;\n  uint32_t temp_reg;\n  \n  ptr1 = DAT_08003948;\n  if ((osc_init->OscillatorType & 1) != 0) {\n    if (((DAT_08003948[1] & 0xc) == 4) ||\n       (((DAT_08003948[1] & 0xc) == 8 && ((DAT_08003948[1] & 0x10000) != 0)))) {\n      if (((*DAT_08003948 & 0x20000) != 0) && (osc_init->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      state = osc_init->HSEState;\n      if (state == 0x10000) {\n        *DAT_08003948 = *DAT_08003948 | 0x10000;\n      }\n      else if (state == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (state == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        *DAT_08003948 = *DAT_08003948 & 0xfffeffff;\n        *ptr1 = *ptr1 & 0xfffbffff;\n      }\n      if (osc_init->HSEState == 0) {\n        state = HAL_GetTick();\n        while ((*DAT_08003948 & 0x20000) != 0) {\n          current_time = HAL_GetTick();\n          if (100 < current_time - state) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        state = HAL_GetTick();\n        while ((*DAT_08003948 & 0x20000) == 0) {\n          current_time = HAL_GetTick();\n          if (100 < current_time - state) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((osc_init->OscillatorType & 2) != 0) {\n    if (((DAT_08003948[1] & 0xc) == 0) ||\n       (((DAT_08003948[1] & 0xc) == 8 && ((DAT_08003948[1] & 0x10000) == 0)))) {\n      if (((*DAT_08003948 & 2) != 0) && (osc_init->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      *DAT_08003948 = *DAT_08003948 & 0xffffff07 | osc_init->HSICalibrationValue << 3;\n    }\n    else if (osc_init->HSIState == 0) {\n      *DAT_0800394c = 0;\n      state = HAL_GetTick();\n      while ((*DAT_08003948 & 2) != 0) {\n        current_time = HAL_GetTick();\n        if (2 < current_time - state) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_0800394c = 1;\n      state = HAL_GetTick();\n      while ((*DAT_08003948 & 2) == 0) {\n        current_time = HAL_GetTick();\n        if (2 < current_time - state) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_08003948 = *DAT_08003948 & 0xffffff07 | osc_init->HSICalibrationValue << 3;\n    }\n  }\n  if ((osc_init->OscillatorType & 8) != 0) {\n    if (osc_init->LSIState == 0) {\n      *DAT_08003950 = 0;\n      state = HAL_GetTick();\n      while ((DAT_08003948[9] & 2) != 0) {\n        current_time = HAL_GetTick();\n        if (2 < current_time - state) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08003950 = 1;\n      state = HAL_GetTick();\n      while ((DAT_08003948[9] & 2) == 0) {\n        current_time = HAL_GetTick();\n        if (2 < current_time - state) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((osc_init->OscillatorType & 4) != 0) {\n    flag = (DAT_08003948[7] & 0x10000000) == 0;\n    if (flag) {\n      DAT_08003948[7] = DAT_08003948[7] | 0x10000000;\n    }\n    if ((*DAT_08003954 & 0x100) == 0) {\n      *DAT_08003954 = *DAT_08003954 | 0x100;\n      state = HAL_GetTick();\n      while ((*DAT_08003954 & 0x100) == 0) {\n        current_time = HAL_GetTick();\n        if (100 < current_time - state) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    ptr2 = DAT_08003a60;\n    ptr1 = DAT_08003948;\n    state = osc_init->LSEState;\n    if (state == 1) {\n      DAT_08003948[8] = DAT_08003948[8] | 1;\n    }\n    else if (state == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (state == 5) {\n      DAT_08003a60[8] = DAT_08003a60[8] | 4;\n      ptr2[8] = ptr2[8] | 1;\n    }\n    else {\n      DAT_08003948[8] = DAT_08003948[8] & 0xfffffffe;\n      ptr1[8] = ptr1[8] & 0xfffffffb;\n    }\n    if (osc_init->LSEState == 0) {\n      state = HAL_GetTick();\n      while ((DAT_08003a60[8] & 2) != 0) {\n        current_time = HAL_GetTick();\n        if (5000 < current_time - state) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      state = HAL_GetTick();\n      while ((DAT_08003948[8] & 2) == 0) {\n        current_time = HAL_GetTick();\n        if (5000 < current_time - state) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (flag) {\n      DAT_08003a60[7] = DAT_08003a60[7] & 0xefffffff;\n    }\n  }\n  state = (osc_init->PLL).PLLState;\n  if (state == 0) {\n    status = HAL_OK;\n  }\n  else if ((DAT_08003a60[1] & 0xc) == 8) {\n    status = HAL_ERROR;\n  }\n  else if (state == 2) {\n    *DAT_08003a64 = 0;\n    state = HAL_GetTick();\n    do {\n      if ((*DAT_08003a60 & 0x2000000) == 0) {\n        if ((osc_init->PLL).PLLSource == 0x10000) {\n          DAT_08003a60[1] = DAT_08003a60[1] & 0xfffdffff | osc_init->HSEPredivValue;\n        }\n        DAT_08003a60[1] =\n             DAT_08003a60[1] & 0xffc2ffff |\n             (osc_init->PLL).PLLSource | (osc_init->PLL).PLLMUL;\n        *DAT_08003a64 = 1;\n        state = HAL_GetTick();\n        do {\n          if ((*DAT_08003a60 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          current_time = HAL_GetTick();\n        } while (current_time - state < 3);\n        return HAL_TIMEOUT;\n      }\n      current_time = HAL_GetTick();\n    } while (current_time - state < 3);\n    status = HAL_TIMEOUT;\n  }\n  else {\n    *DAT_08003a64 = 0;\n    state = HAL_GetTick();\n    do {\n      if ((*DAT_08003a60 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      current_time = HAL_GetTick();\n    } while (current_time - state < 3);\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003688",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configure_RCC_Oscillator_08003688"
        },
        "FUN_08004ec4": {
            "renaming": {
                "FUN_08004ec4": "enable_I2C_slave_mode_and_call_onSlaveReceive_callback_08004ec4",
                "hi2c": "i2c_handle",
                "piVar1": "i2c_object",
                "uVar2": "num_bytes_to_receive",
                "i2c_onSlaveReceive": "onSlaveReceive_callback",
                "slaveMode": "is_slave_mode_enabled",
                "handle": "i2c_handle",
                "XferSize": "transfer_size",
                "i2cTxRxBuffer": "i2c_transmit_receive_buffer"
            },
            "code": "void enable_I2C_slave_mode_and_call_onSlaveReceive_callback_08004ec4(I2C_HandleTypeDef *i2c_handle)\n{\n  i2c_t *i2c_object;\n  uint8_t num_bytes_to_receive;\n  i2c_object = get_i2c_object_from_handle(i2c_handle);\n  if (((i2c_object->onSlaveReceive_callback != NULL) && (i2c_object->is_slave_mode_enabled == true)) &&\n     ((num_bytes_to_receive = 0x20 - *(uint8_t *)&(i2c_object->handle).XferSize & 0xff) != 0)) {\n    (*i2c_object->onSlaveReceive_callback)(i2c_object->i2cTxRxBuffer,num_bytes_to_receive);\n  }\n  HAL_I2C_EnableListen_IT(i2c_handle);\n  return;\n}",
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ec4",
            "calling": [
                "I2C_Slave_AF",
                "I2C_Slave_STOPF",
                "I2C_ITError"
            ],
            "imported": false,
            "current_name": "enable_I2C_slave_mode_and_call_onSlaveReceive_callback_08004ec4"
        },
        "FUN_08000178": {
            "renaming": {
                "FUN_08000178": "find_string_length_08000178",
                "__s": "str",
                "pcVar3": "current_ptr",
                "pcVar2": "next_ptr",
                "cVar1": "current_char"
            },
            "code": "size_t find_string_length_08000178(char* str){\n    char current_char;\n    char* current_ptr = str;\n    while((current_char = *current_ptr) != \"\\0\"){\n        current_ptr++;\n    }\n    return (size_t)(current_ptr - str);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000178",
            "calling": [
                "printNumber",
                "print"
            ],
            "imported": false,
            "current_name": "find_string_length_08000178"
        },
        "FUN_08004418": {
            "renaming": {
                "FUN_08004418": "do_nothing_08004418"
            },
            "code": "\nvoid do_nothing_08004418(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004418",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_08004418"
        },
        "FUN_08006c88": {
            "renaming": {
                "FUN_08006c88": "allocate_memory_08006c88",
                "param_1": "num_blocks",
                "param_2": "block_size",
                "puVar1": "memory_block",
                "iVar2": "total_size"
            },
            "code": "undefined4 * allocate_memory_08006c88(int num_blocks, int block_size)\n{\n  undefined4 *memory_block;\n  int total_size = (num_blocks - 1) * 0x68;\n  memory_block = (undefined4 *)_malloc_r(num_blocks, total_size + 0x74);\n  if (memory_block != (undefined4 *)0x0) {\n    *memory_block = 0;\n    memory_block[1] = num_blocks;\n    memory_block[2] = memory_block + 3;\n    memset(memory_block + 3, 0, total_size + 0x68);\n  }\n  return memory_block;\n}",
            "called": [
                "memset",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c88",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "allocate_memory_08006c88"
        },
        "FUN_080060e4": {
            "renaming": {
                "FUN_080060e4": "process_gpio_interrupt_080060e4",
                "GPIO_Pin": "pin_number",
                "bVar1": "pin_id",
                "PTR_gpio_irq_conf_08006100": "gpio_irq_conf"
            },
            "code": "void process_gpio_interrupt_080060e4(uint16_t pin_number) {\n  uint8_t pin_id = get_pin_id(pin_number);\n  if (*(int *)(PTR_gpio_irq_conf_08006100 + (uint)pin_id * 0x14 + 0xc) != 0) {\n    std::function<void()>::operator__((function_void___ *)(PTR_gpio_irq_conf_08006100 + (uint)pin_id * 0x14 + 4));\n  }\n  return;\n}",
            "called": [
                "get_pin_id",
                "operator()"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080060e4",
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "imported": false,
            "current_name": "process_gpio_interrupt_080060e4"
        },
        "FUN_0800258c": {
            "renaming": {
                "FUN_0800258c": "dma_handle_transfer_complete_0800258c",
                "hdma": "dma_handle",
                "uVar1": "status",
                "pDVar2": "channel",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "HAL_StatusTypeDef dma_handle_transfer_complete_0800258c(DMA_HandleTypeDef *dma_handle)\n{\n  HAL_StatusTypeDef status;\n  DMA_Channel_TypeDef *channel;\n  // Check if DMA is not busy\n  if (dma_handle->State != HAL_DMA_STATE_BUSY) {\n    dma_handle->ErrorCode = 4;\n    return HAL_ERROR;\n  }\n  // Disable DMA channel\n  dma_handle->Instance->CCR &= ~DMA_CCR_EN;\n  // Map channel to a value\n  if (dma_handle->Instance == PTR_DAT_0800261c) {\n    status = 1;\n  }\n  else if (dma_handle->Instance == (DMA_Channel_TypeDef *)&PTR_DAT_0800261c[1].CNDTR) {\n    status = 0x10;\n  }\n  else if (dma_handle->Instance == (DMA_Channel_TypeDef *)&PTR_DAT_0800261c[2].CPAR) {\n    status = 0x100;\n  }\n  else if (dma_handle->Instance == (DMA_Channel_TypeDef *)&PTR_DAT_0800261c[3].CMAR) {\n    status = 0x1000;\n  }\n  else if (dma_handle->Instance == PTR_DAT_0800261c + 5) {\n    status = 0x10000;\n  }\n  else if (dma_handle->Instance == (DMA_Channel_TypeDef *)&PTR_DAT_0800261c[6].CNDTR) {\n    status = 0x100000;\n  }\n  else {\n    status = 0x1000000;\n  }\n  // Set transfer complete status\n  PTR_DAT_08002620[1] = status;\n  // Reset DMA handle\n  dma_handle->State = HAL_DMA_STATE_READY;\n  dma_handle->Lock = HAL_UNLOCKED;\n  // Call XferAbortCallback if not null\n  if (dma_handle->XferAbortCallback != (void (*)(DMA_HandleTypeDef *))0x0) {\n    (*dma_handle->XferAbortCallback)(dma_handle);\n    return HAL_OK;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800258c",
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "dma_handle_transfer_complete_0800258c"
        },
        "FUN_08004e20": {
            "renaming": {
                "FUN_08004e20": "handle_timer_interrupt_08004e20",
                "PTR_timer_handles_08004e30": "timer_handles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt_request"
            },
            "code": "void handle_timer_interrupt_08004e20(void)\n{\n    TIM_HandleTypeDef** PTR_timer_handles_08004e30 = (TIM_HandleTypeDef**)PTR_PTR_timer_handles_08004e30_08004e30;\n    if (*PTR_timer_handles_08004e30 != NULL) {\n        HAL_TIM_IRQHandler(*PTR_timer_handles_08004e30);\n    }\n    return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e20",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08004e20"
        },
        "FUN_0800573c": {
            "renaming": {
                "FUN_0800573c": "wait_for_status_0800573c",
                "status_UNUSED": "status_unused"
            },
            "code": "void wait_for_status_0800573c(int status_unused)\n{\n    while (true) {\n        // Do nothing, just wait for status\n    }\n}",
            "called": [
                "_exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800573c",
            "calling": [
                "_exit",
                "abort"
            ],
            "imported": false,
            "current_name": "wait_for_status_0800573c"
        },
        "FUN_080032b4": {
            "renaming": {
                "FUN_080032b4": "handle_I2C_interrupt_080032b4",
                "*hi2c": "*handle",
                "HVar1": "state",
                "pIVar2": "instance",
                "puVar3": "buffer_ptr",
                "tmpreg": "tmpreg"
            },
            "code": "HAL_StatusTypeDef_conflict handle_I2C_interrupt_080032b4(I2C_HandleTypeDef *hi2c) {\n  HAL_I2C_StateTypeDef state = hi2c->State;\n  I2C_TypeDef *instance = hi2c->Instance;\n  uint8_t *buffer_ptr;\n  uint32_t tmpreg;\n  instance->CR2 &= 0xfffff8ff;\n  instance->CR1 |= 1;\n  instance->CR1 &= 0xfffffbff;\n  if ((instance->CR2 & 0x800) != 0) {\n    if ((state == HAL_I2C_STATE_BUSY_RX) || (state == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      hi2c->XferCount = (uint16_t)hi2c->hdmarx->Instance->CNDTR;\n    }\n    else {\n      hi2c->XferCount = (uint16_t)hi2c->hdmatx->Instance->CNDTR;\n    }\n  }\n  if (hi2c->XferCount != 0) {\n    if ((instance->SR1 & 4) != 0) {\n      buffer_ptr = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = buffer_ptr + 1;\n      *buffer_ptr = (uint8_t)instance->DR;\n      hi2c->XferCount--;\n    }\n    if ((instance->SR1 & 0x40) != 0) {\n      buffer_ptr = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = buffer_ptr + 1;\n      *buffer_ptr = (uint8_t)instance->DR;\n      hi2c->XferCount--;\n    }\n    hi2c->ErrorCode |= 4;\n  }\n  if (hi2c->ErrorCode == 0) {\n    if (((state == HAL_I2C_STATE_LISTEN) || (state == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (state == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c->XferOptions = handle_I2C_interrupt_080032b4;\n      hi2c->PreviousState = 0;\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(hi2c);\n    }\n    else if ((hi2c->PreviousState == 0x22) || (state == HAL_I2C_STATE_BUSY_RX)) {\n      hi2c->PreviousState = 0;\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(hi2c);\n    }\n  }\n  else {\n    I2C_ITError(hi2c);\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError",
                "HAL_I2C_ListenCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080032b4",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_I2C_interrupt_080032b4"
        },
        "FUN_08004d06": {
            "renaming": {
                "FUN_08004d06": "returnNonNull_08004d06",
                "a": "ptr1",
                "b": "ptr2"
            },
            "code": "void * returnNonNull_08004d06(void *ptr1, void *ptr2)\n{\n  if (ptr1 != ptr2) {\n    if (ptr1 == NULL) {\n      return ptr2;\n    }\n    if (ptr2 == NULL) {\n      return ptr1;\n    }\n    ptr1 = NULL;\n  }\n  return ptr1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d06",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "returnNonNull_08004d06"
        },
        "FUN_080056d8": {
            "renaming": {
                "FUN_080056d8": "allocate_memory_080056d8",
                "incr": "increment",
                "pcVar1": "current_pointer",
                "pcVar2": "new_pointer"
            },
            "code": "caddr_t allocate_memory_080056d8(int increment)\n{\n  caddr_t current_pointer;\n  caddr_t new_pointer;\n  \n  if (*(int *)PTR_heap_end_08005708 == 0) {\n    *(undefined **)PTR_heap_end_08005708 = PTR__ebss_0800570c;\n  }\n  current_pointer = *(caddr_t *)PTR_heap_end_08005708;\n  new_pointer = current_pointer + increment;\n  if (new_pointer <= &stack0x00000000) {\n    *(caddr_t *)PTR_heap_end_08005708 = new_pointer;\n    return current_pointer;\n  }\n  *(undefined4 *)PTR_errno_08005710 = 0xc;\n  return (caddr_t)0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080056d8",
            "calling": [
                "_sbrk_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_080056d8"
        },
        "FUN_080019f6": {
            "renaming": {
                "FUN_080019f6": "calculatePID_080019f6",
                "this": "pid",
                "iVar1": "comparison_result",
                "uVar2": "output_min",
                "uVar3": "output_value_1",
                "uVar4": "output_value_2",
                "uVar5": "out_max_2",
                "myOutput": "output_ptr",
                "myInput": "input_ptr",
                "lastInput": "last_input",
                "outMax": "output_max",
                "outMin": "output_min"
            },
            "code": "void __thiscall calculatePID_080019f6(PID *pid)\n{\n  int comparison_result;\n  undefined4 output_value_1;\n  undefined4 output_value_2;\n  undefined4 input_value_1;\n  undefined4 input_value_2;\n  undefined4 out_max_1;\n  undefined4 out_max_2;\n  undefined4 out_min_1;\n  undefined4 out_min_2;\n  output_value_1 = *(undefined4 *)pid->myOutput;\n  output_value_2 = *(undefined4 *)((int)pid->myOutput + 4);\n  *(undefined4 *)&pid->outputSum = output_value_1;\n  *(undefined4 *)((int)&pid->outputSum + 4) = output_value_2;\n  input_value_2 = *(undefined4 *)((int)pid->myInput + 4);\n  *(undefined4 *)&pid->lastInput = *(undefined4 *)pid->myInput;\n  *(undefined4 *)((int)&pid->lastInput + 4) = input_value_2;\n  out_max_1 = *(undefined4 *)&pid->outMax;\n  out_max_2 = *(undefined4 *)((int)&pid->outMax + 4);\n  comparison_result = __aeabi_dcmpgt(output_value_1, output_value_2, out_max_1, out_max_2);\n  if (comparison_result == 0) {\n    out_min_1 = *(undefined4 *)&pid->outMin;\n    out_min_2 = *(undefined4 *)((int)&pid->outMin + 4);\n    comparison_result = __aeabi_dcmplt(output_value_1, output_value_2, out_min_1, out_min_2);\n    if (comparison_result != 0) {\n      *(undefined4 *)&pid->outputSum = out_min_1;\n      *(undefined4 *)((int)&pid->outputSum + 4) = out_min_2;\n    }\n    return;\n  }\n  *(undefined4 *)&pid->outputSum = out_max_1;\n  *(undefined4 *)((int)&pid->outputSum + 4) = out_max_2;\n  return;\n}",
            "called": [
                "__aeabi_dcmplt",
                "__aeabi_dcmpgt"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080019f6",
            "calling": [
                "SetMode"
            ],
            "imported": false,
            "current_name": "calculatePID_080019f6"
        },
        "FUN_08002f9c": {
            "renaming": {
                "FUN_08002f9c": "handle_i2c_rx_08002f9c",
                "*hi2c": "*i2c_handle",
                "puVar1": "buffer_ptr"
            },
            "code": "HAL_StatusTypeDef handle_i2c_rx_08002f9c(I2C_HandleTypeDef *i2c_handle)\n{\n  uint8_t *buffer_ptr;\n  \n  if (i2c_handle->State == HAL_I2C_STATE_BUSY_RX) {\n    if (i2c_handle->XferCount < 4) {\n      if (i2c_handle->XferCount - 2 < 2) {\n        if (i2c_handle->XferOptions == 2) {\n          i2c_handle->Instance->CR1 |= 0x400;\n        }\n        else {\n          i2c_handle->Instance->CR1 &= 0xfffffbff;\n          i2c_handle->Instance->CR1 |= 0x800;\n        }\n        i2c_handle->Instance->CR2 &= 0xfffffbff;\n      }\n      else {\n        if (i2c_handle->XferOptions == 2) {\n          i2c_handle->Instance->CR1 |= 0x400;\n        }\n        else {\n          i2c_handle->Instance->CR1 &= 0xfffffbff;\n        }\n        i2c_handle->Instance->CR2 &= 0xfffff8ff;\n        buffer_ptr = i2c_handle->pBuffPtr;\n        i2c_handle->pBuffPtr = buffer_ptr + 1;\n        *buffer_ptr = (uint8_t)i2c_handle->Instance->DR;\n        i2c_handle->XferCount--;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        i2c_handle->PreviousState = 0;\n        if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n          i2c_handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(i2c_handle);\n        }\n        else {\n          i2c_handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(i2c_handle);\n        }\n      }\n    }\n    else {\n      buffer_ptr = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = buffer_ptr + 1;\n      *buffer_ptr = (uint8_t)i2c_handle->Instance->DR;\n      i2c_handle->XferCount--;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f9c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_rx_08002f9c"
        },
        "FUN_08005510": {
            "renaming": {
                "FUN_08005510": "receive_data_08005510",
                "obj": "serial_obj",
                "callback": "callback_func",
                "uVar2": "rx_active_val",
                "bVar1": "byte_val",
                "PTR_rx_callback_0800555c": "rx_callback_ptr",
                "PTR_rx_callback_obj_08005560": "rx_callback_obj_ptr",
                "PTR_uart_handlers_08005564": "uart_handlers_ptr"
            },
            "code": "void receive_data_08005510(serial_t *serial_obj, _func_void_serial_t_ptr *callback_func)\n{\n  byte byte_val;\n  uint8_t rx_active_val;\n  \n  if (serial_obj != NULL) {\n    rx_active_val = serial_rx_active(serial_obj);\n    if (rx_active_val == 0) {\n      byte_val = serial_obj->index;\n      *(_func_void_serial_t_ptr **)(PTR_rx_callback_0800555c + (uint)byte_val * 4) = callback_func;\n      *(serial_t **)(PTR_rx_callback_obj_08005560 + (uint)byte_val * 4) = serial_obj;\n      HAL_NVIC_SetPriority(serial_obj->irq, 0, 1);\n      HAL_NVIC_EnableIRQ(serial_obj->irq);\n      HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08005564 + (uint)serial_obj->index * 4), &serial_obj->recv, 1);\n    }\n    return;\n  }\n  return;\n}",
            "called": [
                "serial_rx_active",
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005510",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "receive_data_08005510"
        },
        "FUN_08002f9a": {
            "renaming": {
                "FUN_08002f9a": "do_nothing_08002f9a"
            },
            "code": "\nvoid do_nothing_08002f9a(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f9a",
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "imported": false,
            "current_name": "do_nothing_08002f9a"
        },
        "FUN_08005750": {
            "renaming": {
                "FUN_08005750": "get_pid_08005750"
            },
            "code": "__pid_t get_pid_08005750(void)\n{\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005750",
            "calling": [
                "_getpid_r"
            ],
            "imported": false,
            "current_name": "get_pid_08005750"
        },
        "FUN_08002cf2": {
            "renaming": {
                "FUN_08002cf2": "i2c_handle_address_match_08002cf2",
                "*hi2c": "*i2c_handle",
                "AddrMatchCode": "address_match_code",
                "hi2c->Instance->SR2": "i2c_handle->Instance->SR2",
                "hi2c->Init": "i2c_handle->Init",
                "hi2c->Init.OwnAddress1": "i2c_handle->Init.OwnAddress1",
                "hi2c->Init.OwnAddress2": "i2c_handle->Init.OwnAddress2"
            },
            "code": "HAL_StatusTypeDef i2c_handle_address_match_08002cf2(I2C_HandleTypeDef *i2c_handle) {\n  uint16_t address_match_code;\n  if ((i2c_handle->Instance->SR2 & 0x80) == 0) {\n    address_match_code = *(uint16_t *)&(i2c_handle->Init).OwnAddress1;\n  }\n  else {\n    address_match_code = *(uint16_t *)&(i2c_handle->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2c_handle, (i2c_handle->Instance->SR2 & 4) == 0, address_match_code);\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002cf2",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_address_match_08002cf2"
        },
        "FUN_08006288": {
            "renaming": {
                "FUN_08006288": "allocate_memory_block_08006288",
                "param_1": "mem_size",
                "param_2": "block_size",
                "puVar1": "current_brk",
                "uVar2": "brk",
                "puVar3": "free_list",
                "iVar4": "remaining_space",
                "puVar5": "block",
                "puVar7": "previous_free_block",
                "uVar6": "remaining_block_size",
                "uVar8": "aligned_block_size"
            },
            "code": "uint allocate_memory_block_08006288(undefined4 *mem_size, uint block_size)\n{\n  uint aligned_block_size = (block_size + 3 & 0xfffffffc) + 8;\n  if (aligned_block_size < 0xc) {\n    aligned_block_size = 0xc;\n  }\n  if (((int)aligned_block_size < 0) || (aligned_block_size < block_size)) {\n    *mem_size = 0xc;\n  }\n  else {\n    __malloc_lock();\n    void *current_brk = PTR___malloc_sbrk_start_08006340;\n    uint *free_list = *(uint **)PTR___malloc_free_list_0800633c;\n    uint *previous_free_block = *(uint **)PTR___malloc_free_list_0800633c;\n    while (uint *block = free_list, block != (uint *)0x0) {\n      uint remaining_block_size = *block - aligned_block_size;\n      if (-1 < (int)remaining_block_size) {\n        if (remaining_block_size < 0xc) {\n          if (previous_free_block == block) {\n            uint next_block = previous_free_block[1];\n            *(uint *)PTR___malloc_free_list_0800633c = next_block;\n          }\n          else {\n            uint next_block = block[1];\n          }\n          if (previous_free_block != block) {\n            previous_free_block[1] = next_block;\n            previous_free_block = block;\n          }\n        }\n        else {\n          *block = remaining_block_size;\n          *(uint *)((int)block + remaining_block_size) = aligned_block_size;\n          previous_free_block = (uint *)((int)block + remaining_block_size);\n        }\n        goto LAB_080062ec;\n      }\n      previous_free_block = block;\n      free_list = (uint *)block[1];\n    }\n    if (*(int *)PTR___malloc_sbrk_start_08006340 == 0) {\n      uint brk = _sbrk_r(mem_size);\n      *(void **)current_brk = brk;\n    }\n    uint *new_block = (uint *)_sbrk_r(mem_size,aligned_block_size);\n    if ((new_block != (uint *)0xffffffff) &&\n       ((previous_free_block = (uint *)((int)new_block + 3U & 0xfffffffc), new_block == previous_free_block ||\n        (_sbrk_r(mem_size,(int)previous_free_block - (int)new_block) != -1)))) {\n      *previous_free_block = aligned_block_size;\nLAB_080062ec:\n      __malloc_unlock(mem_size);\n      uint aligned_block_end = (int)previous_free_block + 0xbU & 0xfffffff8;\n      int remaining_space = aligned_block_end - (int)(previous_free_block + 1);\n      if (remaining_space != 0) {\n        *(int *)((int)previous_free_block + remaining_space) = -remaining_space;\n        return aligned_block_end;\n      }\n      return aligned_block_end;\n    }\n    *mem_size = 0xc;\n    __malloc_unlock(mem_size);\n  }\n  return 0;\n}",
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006288",
            "calling": [
                "__smakebuf_r",
                "__sfmoreglue"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_08006288"
        },
        "FUN_08000188": {
            "renaming": {
                "FUN_08000188": "calculate_double_precision_value_08000188",
                "param_1": "value_1",
                "param_2": "value_2",
                "param_3": "value_3",
                "param_4": "value_4",
                "iVar1": "shift_amount_2",
                "bVar2": "least_significant_bit",
                "uVar3": "sum_1",
                "uVar4": "mask_1",
                "uVar5": "sum_2",
                "iVar6": "shift_amount_1",
                "uVar7": "shifted_value_2",
                "uVar8": "value_1_copy",
                "uVar9": "shifted_value_1",
                "uVar10": "difference",
                "uVar11": "shifted_bit",
                "uVar12": "sum",
                "bVar13": "is_negative_1",
                "bVar14": "is_negative_2",
                "bVar15": "is_negative_3"
            },
            "code": "\nulonglong calculate_double_precision_value_08000188(uint value_1,uint value_2,uint value_3,uint value_4)\n\n{\n  int shift_amount_2;\n  byte least_significant_bit;\n  uint sum_1;\n  uint mask_1;\n  uint sum_2;\n  int shift_amount_1;\n  uint shifted_value_2;\n  uint value_1_copy;\n  uint shifted_value_1;\n  uint difference;\n  uint shifted_bit;\n  uint sum;\n  bool is_negative_1;\n  bool is_negative_2;\n  bool is_negative_3;\n  \n  mask_1 = value_2 ^ 0x80000000;\n  shifted_value_2 = value_2 << 1;\n  shifted_value_1 = value_4 << 1;\n  is_negative_1 = ((mask_1 ^ value_4) & 0x7fffffff) == 0;\n  is_negative_2 = is_negative_1 && value_1 == value_3;\n  if (!is_negative_1 || value_1 != value_3) {\n    is_negative_2 = (shifted_value_2 | value_1) == 0;\n  }\n  if (!is_negative_2) {\n    is_negative_2 = (shifted_value_1 | value_3) == 0;\n  }\n  shift_amount_1 = (int)shifted_value_2 >> 0x15;\n  if (!is_negative_2) {\n    is_negative_2 = shift_amount_1 == -1;\n  }\n  shift_amount_2 = (int)shifted_value_1 >> 0x15;\n  if (!is_negative_2) {\n    is_negative_2 = shift_amount_2 == -1;\n  }\n  if (is_negative_2) {\n    if (shift_amount_1 == -1 || shift_amount_2 == -1) {\n      shifted_value_1 = value_4;\n      shifted_value_2 = value_3;\n      if (shift_amount_1 == -1) {\n        shifted_value_1 = mask_1;\n        shifted_value_2 = value_1;\n      }\n      if (shift_amount_1 != -1 || shift_amount_2 != -1) {\n        value_3 = shifted_value_2;\n        value_4 = shifted_value_1;\n      }\n      is_negative_2 = (shifted_value_2 | shifted_value_1 << 0xc) == 0;\n      if (is_negative_2) {\n        is_negative_2 = (value_3 | value_4 << 0xc) == 0;\n      }\n      if (is_negative_2) {\n        is_negative_2 = shifted_value_1 == value_4;\n      }\n      if (!is_negative_2) {\n        shifted_value_1 = shifted_value_1 | 0x80000;\n      }\n      return CONCAT44(shifted_value_1,shifted_value_2);\n    }\n    if (((mask_1 ^ value_4) & 0x7fffffff) != 0 || value_1 != value_3) {\n      if ((shifted_value_2 | value_1) == 0) {\n        value_1 = value_3;\n        mask_1 = value_4;\n      }\n      return CONCAT44(mask_1,value_1);\n    }\n    if (mask_1 != value_4) {\n      return 0;\n    }\n    if (shifted_value_2 >> 0x15 == 0) {\n      is_negative_2 = (value_1 & 0x80000000) != 0;\n      shifted_value_1 = value_2 * 2 + (uint)is_negative_2;\n      if (CARRY4(mask_1,mask_1) || CARRY4(value_2 * 2,(uint)is_negative_2)) {\n        shifted_value_1 = shifted_value_1 | 0x80000000;\n      }\n      return CONCAT44(shifted_value_1,value_1 << 1);\n    }\n    if (shifted_value_2 < 0xffc00000) {\n      return CONCAT44(mask_1 + 0x100000,value_1);\n    }\n    mask_1 = mask_1 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(mask_1 | 0x7ff00000) << 0x20;\n  }\n  shifted_value_2 = shifted_value_2 >> 0x15;\n  shifted_value_1 = shifted_value_1 >> 0x15;\n  difference = shifted_value_1 - shifted_value_2;\n  is_negative_2 = difference != 0;\n  if (shifted_value_1 < shifted_value_2) {\n    difference = -difference;\n  }\n  value_1_copy = value_1;\n  sum = mask_1;\n  if (is_negative_2 && shifted_value_2 <= shifted_value_1) {\n    shifted_value_2 = shifted_value_2 + difference;\n    value_1_copy = value_3;\n    sum = value_4;\n    value_3 = value_1;\n    value_4 = mask_1;\n  }\n  if (0x36 < difference) {\n    return CONCAT44(sum,value_1_copy);\n  }\n  shifted_value_1 = sum & 0xfffff | 0x100000;\n  if ((sum & 0x80000000) != 0) {\n    is_negative_2 = value_1_copy != 0;\n    value_1_copy = -value_1_copy;\n    shifted_value_1 = -shifted_value_1 - (uint)is_negative_2;\n  }\n  mask_1 = value_4 & 0xfffff | 0x100000;\n  if ((value_4 & 0x80000000) != 0) {\n    is_negative_2 = value_3 != 0;\n    value_3 = -value_3;\n    mask_1 = -mask_1 - (uint)is_negative_2;\n  }\n  if (shifted_value_2 == difference) {\n    mask_1 = mask_1 ^ 0x100000;\n    if (shifted_value_2 == 0) {\n      shifted_value_1 = shifted_value_1 ^ 0x100000;\n      shifted_value_2 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  sum = -difference + 0x20;\n  if ((int)difference < 0x21) {\n    shifted_bit = value_3 << (sum & 0xff);\n    value_3 = value_3 >> (difference & 0xff);\n    sum_1 = value_1_copy + value_3;\n    sum_2 = mask_1 << (sum & 0xff);\n    sum = sum_1 + sum_2;\n    shifted_value_1 = shifted_value_1 + CARRY4(value_1_copy,value_3) + ((int)mask_1 >> (difference & 0xff)) +\n            (uint)CARRY4(sum_1,sum_2);\n  }\n  else {\n    shifted_bit = mask_1 << (-difference + 0x40 & 0xff);\n    if (value_3 != 0) {\n      shifted_bit = shifted_bit | 2;\n    }\n    mask_1 = (int)mask_1 >> (difference - 0x20 & 0xff);\n    sum = value_1_copy + mask_1;\n    shifted_value_1 = shifted_value_1 + ((int)mask_1 >> 0x1f) + (uint)CARRY4(value_1_copy,mask_1);\n  }\n  mask_1 = shifted_value_1 & 0x80000000;\n  difference = shifted_value_1;\n  if ((int)shifted_value_1 < 0) {\n    is_negative_2 = shifted_bit == 0;\n    shifted_bit = -shifted_bit;\n    difference = -sum;\n    sum = -(uint)!is_negative_2 - sum;\n    difference = -(uint)(is_negative_2 <= difference) - shifted_value_1;\n  }\n  if (0xfffff < difference) {\n    value_1_copy = shifted_value_2 - 1;\n    if (0x1fffff < difference) {\n      shifted_value_1 = difference & 1;\n      difference = difference >> 1;\n      least_significant_bit = (byte)sum;\n      sum = (uint)(shifted_value_1 != 0) << 0x1f | sum >> 1;\n      shifted_bit = (uint)(least_significant_bit & 1) << 0x1f | shifted_bit >> 1;\n      value_1_copy = shifted_value_2;\n      if (0xffbfffff < shifted_value_2 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    is_negative_2 = 0x7fffffff < shifted_bit;\n    if (shifted_bit == 0x80000000) {\n      is_negative_2 = (sum & 1) != 0;\n    }\n    return CONCAT44(difference + value_1_copy * 0x100000 + (uint)CARRY4(sum,(uint)is_negative_2) | mask_1,\n                    sum + is_negative_2);\n  }\n  is_negative_1 = (shifted_bit & 0x80000000) != 0;\n  shifted_bit = shifted_bit << 1;\n  value_1_copy = sum * 2;\n  is_negative_2 = CARRY4(sum,sum);\n  sum = sum * 2 + (uint)is_negative_1;\n  difference = difference * 2 + (uint)(is_negative_2 || CARRY4(value_1_copy,(uint)is_negative_1));\n  value_1_copy = shifted_value_2 - 2;\n  if ((difference & 0x100000) != 0) goto LAB_080002a0;\n  sum_1 = sum;\n  shifted_value_2 = difference;\n  if (difference == 0) {\n    sum_1 = 0;\n    shifted_value_2 = sum;\n  }\n  shift_amount_1 = count_leading_zeroes(shifted_value_2);\n  if (difference == 0) {\n    shift_amount_1 = shift_amount_1 + 0x20;\n  }\n  sum = shift_amount_1 - 0xb;\n  is_negative_3 = SBORROW4(sum,0x20);\n  difference = shift_amount_1 - 0x2b;\n  is_negative_2 = (int)difference < 0;\n  is_negative_1 = difference == 0;\n  if ((int)sum < 0x20) {\n    is_negative_3 = SCARRY4(difference,0xc);\n    shift_amount_1 = shift_amount_1 + -0x1f;\n    is_negative_2 = shift_amount_1 < 0;\n    is_negative_1 = shift_amount_1 == 0;\n    difference = sum;\n    if (!is_negative_1 && is_negative_2 == is_negative_3) {\n      sum_1 = shifted_value_2 << (sum & 0xff);\n      shifted_value_2 = shifted_value_2 >> (0xcU - shift_amount_1 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (is_negative_1 || is_negative_2 != is_negative_3) {\n    shifted_bit = 0x20 - difference;\n  }\n  shifted_value_2 = shifted_value_2 << (difference & 0xff);\n  if (is_negative_1 || is_negative_2 != is_negative_3) {\n    shifted_value_2 = shifted_value_2 | sum_1 >> (shifted_bit & 0xff);\n  }\n  if (is_negative_1 || is_negative_2 != is_negative_3) {\n    sum_1 = sum_1 << (difference & 0xff);\n  }\nLAB_08000318:\n  if ((int)sum <= (int)value_1_copy) {\n    return CONCAT44(shifted_value_2 + (value_1_copy - sum) * 0x100000 | mask_1,sum_1);\n  }\n  difference = ~(value_1_copy - sum);\n  if ((int)difference < 0x1f) {\n    shift_amount_1 = difference - 0x13;\n    if (shift_amount_1 != 0 && shift_amount_1 < 0 == SCARRY4(difference - 0x1f,0xc)) {\n      return CONCAT44(shifted_value_1,sum_1 >> (0x20 - (0xcU - shift_amount_1) & 0xff) | shifted_value_2 << (0xcU - shift_amount_1 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    difference = difference + 1;\n    return CONCAT44(mask_1 | shifted_value_2 >> (difference & 0xff),\n                    sum_1 >> (difference & 0xff) | shifted_value_2 << (0x20 - difference & 0xff));\n  }\n  return CONCAT44(shifted_value_1,shifted_value_2 >> (difference - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000188",
            "calling": [],
            "imported": false,
            "current_name": "calculate_double_precision_value_08000188"
        },
        "FUN_08002004": {
            "renaming": {
                "FUN_08002004": "enable_ADC_08002004",
                "*hadc": "*adc",
                "HVar1": "status",
                "pAVar2": "instance"
            },
            "code": "HAL_StatusTypeDef_conflict enable_ADC_08002004(ADC_HandleTypeDef *adc)\n{\n  HAL_StatusTypeDef_conflict status;\n  ADC_TypeDef *instance;\n  if (adc->Lock != HAL_LOCKED) {\n    adc->Lock = HAL_LOCKED;\n    status = ADC_Enable(adc);\n    if (status == HAL_OK) {\n      adc->State = (adc->State & 0xfffffcfe) | 0x100;\n      instance = adc->Instance;\n      if ((instance == PTR_080020e8) && ((PTR_080020e8[-0xd].JOFR1 & 0xf0000) != 0)) {\n        adc->State |= 0x100000;\n        if ((*(uint *)(PTR_080020ec + 4) & 0x400) != 0) {\n          adc->State = (adc->State & 0xffffcfff) | 0x1000;\n        }\n      }\n      else {\n        adc->State &= 0xffefffff;\n        if ((instance->CR1 & 0x400) != 0) {\n          adc->State = (adc->State & 0xffffcfff) | 0x1000;\n        }\n      }\n      if ((adc->State & 0x1000) == 0) {\n        adc->ErrorCode = 0;\n      }\n      else {\n        adc->ErrorCode &= 0xfffffff9;\n      }\n      adc->Lock = HAL_UNLOCKED;\n      instance->SR = 0xfffffffd;\n      instance = adc->Instance;\n      if (((instance->CR2 & 0xe0000) == 0xe0000) &&\n         ((instance != PTR_080020e8 || ((PTR_080020e8[-0xd].JOFR1 & 0xf0000) == 0)))) {\n        instance->CR2 |= 0x500000;\n      }\n      else {\n        instance->CR2 |= 0x100000;\n      }\n    }\n    else {\n      adc->Lock = HAL_UNLOCKED;\n    }\n    return status;\n  }\n  return HAL_BUSY;\n}",
            "called": [
                "ADC_Enable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002004",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "enable_ADC_08002004"
        },
        "FUN_08004f3c": {
            "renaming": {
                "FUN_08004f3c": "handle_i2c_errors_08004f3c",
                "PTR_i2c_handles_08004f48": "i2c_handles_ptr"
            },
            "code": "void handle_i2c_errors_08004f3c(I2C_HandleTypeDef **PTR_i2c_handles_08004f48){\n  HAL_I2C_ER_IRQHandler(*PTR_i2c_handles_08004f48);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f3c",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_errors_08004f3c"
        },
        "FUN_08005754": {
            "renaming": {
                "FUN_08005754": "read_adc_value_08005754",
                "ulPin": "pin_number",
                "bVar1": "is_valid_pin",
                "pin": "pin_name",
                "uVar2": "adc_value",
                "uVar3": "adc_result",
                "uVar4": "read_resolution",
                "PTR_digitalPin_080057ac": "digitalPin",
                "PTR__readResolution_080057b0": "readResolution_080057b0"
            },
            "code": "uint32_t read_adc_value_08005754(uint32_t pin_number) {\n  bool is_valid_pin = false;\n  PinName_conflict pin_name;\n  uint16_t adc_value;\n  uint read_resolution;\n\n  if (pin_number < 14) {\n    if (pin_number + 46 < 60) {\n      is_valid_pin = true;\n    }\n  } else {\n    is_valid_pin = pin_number < 60;\n  }\n\n  if (is_valid_pin) {\n    if (pin_number < 14) {\n      pin_number += 46;\n    }\n    pin_name = PTR_digitalPin_080057ac[pin_number];\n  } else {\n    pin_name = NC;\n  }\n\n  if (pin_name == NC) {\n    adc_value = 0;\n  } else {\n    adc_value = adc_read_value(pin_name);\n    read_resolution = *(uint *)PTR__readResolution_080057b0;\n    if (read_resolution != 12) {\n      if (read_resolution < 12) {\n        return (uint)(adc_value >> (12 - read_resolution & 0xff));\n      }\n      return adc_value << (read_resolution - 12 & 0xff);\n    }\n  }\n  return adc_value;\n}",
            "called": [
                "adc_read_value"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005754",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "read_adc_value_08005754"
        },
        "FUN_08005fc8": {
            "renaming": {
                "FUN_08005fc8": "initialize_gpio_irq_configuration_08005fc8",
                "__initialize_p": "should_initialize",
                "__priority": "priority",
                "puVar1": "gpio_irq_configuration"
            },
            "code": "void initialize_gpio_irq_configuration_08005fc8(int should_initialize, int priority) {\n  undefined *gpio_irq_configuration = PTR_gpio_irq_conf_08006068;\n  if (should_initialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    *gpio_irq_configuration = 6;\n    *(undefined4 *)(gpio_irq_configuration + 0xc) = 0;\n    gpio_irq_configuration[0x14] = 7;\n    *(undefined4 *)(gpio_irq_configuration + 0x20) = 0;\n    gpio_irq_configuration[0x28] = 8;\n    *(undefined4 *)(gpio_irq_configuration + 0x34) = 0;\n    gpio_irq_configuration[0x3c] = 9;\n    *(undefined4 *)(gpio_irq_configuration + 0x48) = 0;\n    gpio_irq_configuration[0x50] = 10;\n    *(undefined4 *)(gpio_irq_configuration + 0x5c) = 0;\n    gpio_irq_configuration[0x64] = 0x17;\n    *(undefined4 *)(gpio_irq_configuration + 0x70) = 0;\n    gpio_irq_configuration[0x78] = 0x17;\n    *(undefined4 *)(gpio_irq_configuration + 0x84) = 0;\n    gpio_irq_configuration[0x8c] = 0x17;\n    *(undefined4 *)(gpio_irq_configuration + 0x98) = 0;\n    gpio_irq_configuration[0xa0] = 0x17;\n    *(undefined4 *)(gpio_irq_configuration + 0xac) = 0;\n    gpio_irq_configuration[0xb4] = 0x17;\n    *(undefined4 *)(gpio_irq_configuration + 0xc0) = 0;\n    gpio_irq_configuration[0xc8] = 0x28;\n    *(undefined4 *)(gpio_irq_configuration + 0xd4) = 0;\n    gpio_irq_configuration[0xdc] = 0x28;\n    *(undefined4 *)(gpio_irq_configuration + 0xe8) = 0;\n    gpio_irq_configuration[0xf0] = 0x28;\n    *(undefined4 *)(gpio_irq_configuration + 0xfc) = 0;\n    gpio_irq_configuration[0x104] = 0x28;\n    *(undefined4 *)(gpio_irq_configuration + 0x110) = 0;\n    gpio_irq_configuration[0x118] = 0x28;\n    *(undefined4 *)(gpio_irq_configuration + 0x124) = 0;\n    gpio_irq_configuration[0x12c] = 0x28;\n    *(undefined4 *)(gpio_irq_configuration + 0x138) = 0;\n    __aeabi_atexit(0, DAT_08006070, PTR___dso_handle_0800606c);\n  }\n  return;\n}",
            "called": [
                "__aeabi_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005fc8",
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "imported": false,
            "current_name": "initialize_gpio_irq_configuration_08005fc8"
        },
        "FUN_08002ab8": {
            "renaming": {
                "FUN_08002ab8": "readNextByteFromI2CBuffer_08002ab8",
                "*hi2c": "*i2cHandle",
                "pbVar1": "bufferPtr",
                "hi2c->pBuffPtr": "i2cHandle->pBuffPtr",
                "hi2c->Instance->DR": "i2cHandle->Instance->DR",
                "hi2c->XferCount": "i2cHandle->XferCount"
            },
            "code": "HAL_StatusTypeDef readNextByteFromI2CBuffer_08002ab8(I2C_HandleTypeDef *i2cHandle)\n{\n  byte *bufferPtr;\n  if (i2cHandle->XferCount != 0) {\n    bufferPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPtr + 1;\n    i2cHandle->Instance->DR = (uint)*bufferPtr;\n    i2cHandle->XferCount--;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ab8",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "readNextByteFromI2CBuffer_08002ab8"
        },
        "FUN_080068f0": {
            "renaming": {
                "FUN_080068f0": "format_string_080068f0",
                "__format": "format",
                "pcVar2": "arg_list",
                "in_r1": "arg1",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3"
            },
            "code": "int format_string_080068f0(char *format, ...)\n{\n  int impure_ptr = *(int *)PTR__impure_ptr_0800691c;\n  char *arg_list = format;\n  undefined4 arg1 = 0;\n  undefined4 arg2 = 0;\n  undefined4 arg3 = 0;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  int result = _vfformat_string_080068f0_r(impure_ptr, *(undefined4 *)(impure_ptr + 8), format, &arg1, arg_list, &arg1);\n  return result;\n}",
            "called": [
                "__sinit",
                "_vfiprintf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080068f0",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "format_string_080068f0"
        },
        "FUN_080066b0": {
            "renaming": {
                "FUN_080066b0": "print_formatted_output_080066b0",
                "param_1": "stream",
                "param_2": "format",
                "param_3": "width",
                "param_4": "print_func",
                "param_5": "args_ptr",
                "bVar1": "format_char",
                "iVar2": "result",
                "puVar3": "arg_ptr",
                "pvVar4": "end_ptr",
                "iVar5": "print_result",
                "puVar6": "digit_chars",
                "uVar7": "format_flags",
                "uVar9": "arg_val",
                "uVar10": "divisor",
                "puVar11": "digit_ptr",
                "__s": "format_str",
                "local_24": "field_width"
            },
            "code": "\nuint print_formatted_output_080066b0(undefined4 stream,uint *format,undefined4 width,code *print_func,uint **args_ptr)\n\n{\n  byte format_char;\n  int result;\n  uint *arg_ptr;\n  void *end_ptr;\n  int print_result;\n  undefined *digit_chars;\n  uint format_flags;\n  uint **ppuVar8;\n  uint arg_val;\n  uint divisor;\n  undefined *digit_ptr;\n  undefined *format_str;\n  uint field_width [2];\n  \n  format_char = *(byte *)(format + 6);\n  format_str = (undefined *)((int)format + 0x43);\n  if (format_char != 0x6e) {\n    if (format_char < 0x6f) {\n      if (format_char != 99) {\n        if (format_char < 100) {\n          if (format_char == 0) goto LAB_0800686a;\n          if (format_char != 0x58) goto LAB_080066e0;\n          *(undefined *)((int)format + 0x45) = 0x58;\n          digit_chars = PTR_s_0123456789ABCDEF_080068ec;\nLAB_080067fa:\n          format_flags = *format;\n          arg_ptr = *args_ptr;\n          *args_ptr = arg_ptr + 1;\n          if (((format_flags & 0x80) == 0) && ((int)(format_flags << 0x19) < 0)) {\n            arg_val = (uint)*(ushort *)arg_ptr;\n          }\n          else {\n            arg_val = *arg_ptr;\n          }\n          if ((int)(format_flags << 0x1f) < 0) {\n            *format = format_flags | 0x20;\n          }\n          if (arg_val == 0) {\n            *format = *format & 0xffffffdf;\n          }\n          format_flags = 0x10;\nLAB_08006790:\n          *(undefined *)((int)format + 0x43) = 0;\n        }\n        else {\n          if ((format_char != 100) && (format_char != 0x69)) goto LAB_080066e0;\n          arg_val = *format;\n          arg_ptr = *args_ptr;\n          if ((arg_val & 0x80) == 0) {\n            *args_ptr = arg_ptr + 1;\n            if ((arg_val & 0x40) == 0) goto LAB_08006700;\n            arg_val = (uint)(short)*(ushort *)arg_ptr;\n          }\n          else {\n            *args_ptr = arg_ptr + 1;\nLAB_08006700:\n            arg_val = *arg_ptr;\n          }\n          if ((int)arg_val < 0) {\n            arg_val = -arg_val;\n            *(undefined *)((int)format + 0x43) = 0x2d;\n          }\n          format_flags = 10;\n          digit_chars = PTR_s_0123456789ABCDEF_080068ec;\n        }\n        divisor = format[1];\n        format[2] = divisor;\n        digit_ptr = format_str;\n        if ((int)divisor < 0) {\n          if (arg_val != 0) goto LAB_0800682e;\nLAB_080068dc:\n          *(undefined *)((int)format + 0x42) = *digit_chars;\n          digit_ptr = (undefined *)((int)format + 0x42);\n        }\n        else {\n          *format = *format & 0xfffffffb;\n          if (arg_val == 0) {\n            if (divisor != 0) goto LAB_080068dc;\n          }\n          else {\nLAB_0800682e:\n            do {\n              divisor = arg_val / format_flags;\n              digit_ptr = digit_ptr + -1;\n              *digit_ptr = digit_chars[arg_val - format_flags * divisor];\n              arg_val = divisor;\n            } while (divisor != 0);\n          }\n        }\n        if (((format_flags == 8) && ((int)(*format << 0x1f) < 0)) && ((int)format[1] <= (int)format[4]))\n        {\n          digit_ptr[-1] = 0x30;\n          digit_ptr = digit_ptr + -1;\n        }\n        format[4] = (int)format_str - (int)digit_ptr;\n        format_str = digit_ptr;\n        goto LAB_080067d6;\n      }\n      arg_ptr = *args_ptr;\n      *args_ptr = arg_ptr + 1;\n      *(char *)((int)format + 0x42) = (char)*arg_ptr;\nLAB_08006740:\n      format_str = (undefined *)((int)format + 0x42);\n      arg_val = 1;\n    }\n    else {\n      if (format_char != 0x73) {\n        if (format_char < 0x74) {\n          if (format_char == 0x6f) {\nLAB_08006766:\n            arg_val = *format;\n            arg_ptr = *args_ptr;\n            if ((arg_val & 0x80) == 0) {\n              *args_ptr = arg_ptr + 1;\n              if ((arg_val & 0x40) == 0) goto LAB_08006774;\n              arg_val = (uint)*(ushort *)arg_ptr;\n            }\n            else {\n              *args_ptr = arg_ptr + 1;\nLAB_08006774:\n              arg_val = *arg_ptr;\n            }\n            digit_chars = PTR_s_0123456789ABCDEF_080068ec;\n            if (format_char == 0x6f) {\n              format_flags = 8;\n            }\n            else {\n              format_flags = 10;\n            }\n            goto LAB_08006790;\n          }\n          if (format_char == 0x70) {\n            *format = *format | 0x20;\nLAB_08006726:\n            digit_chars = PTR_s_0123456789abcdef_080068e8;\n            *(undefined *)((int)format + 0x45) = 0x78;\n            goto LAB_080067fa;\n          }\n        }\n        else {\n          if (format_char == 0x75) goto LAB_08006766;\n          if (format_char == 0x78) goto LAB_08006726;\n        }\nLAB_080066e0:\n        *(byte *)((int)format + 0x42) = format_char;\n        goto LAB_08006740;\n      }\n      arg_ptr = *args_ptr;\n      *args_ptr = arg_ptr + 1;\n      format_str = (undefined *)*arg_ptr;\n      end_ptr = memchr(format_str,0,format[1]);\n      if (end_ptr != (void *)0x0) {\n        format[1] = (int)end_ptr - (int)format_str;\n      }\n      arg_val = format[1];\n    }\n    format[4] = arg_val;\n    *(undefined *)((int)format + 0x43) = 0;\n    goto LAB_080067d6;\n  }\n  arg_val = *format;\n  ppuVar8 = (uint **)*args_ptr;\n  format_flags = format[5];\n  if ((arg_val & 0x80) == 0) {\n    *args_ptr = (uint *)(ppuVar8 + 1);\n    arg_ptr = *ppuVar8;\n    if ((arg_val & 0x40) == 0) goto LAB_08006856;\n    *(short *)arg_ptr = (short)format_flags;\n  }\n  else {\n    *args_ptr = (uint *)(ppuVar8 + 1);\n    arg_ptr = *ppuVar8;\nLAB_08006856:\n    *arg_ptr = format_flags;\n  }\nLAB_0800686a:\n  format[4] = 0;\nLAB_080067d6:\n  result = _printf_common(stream,format,field_width,width,print_func);\n  if ((result == -1) || (result = (*print_func)(stream,width,format_str,format[4]), result == -1)) {\nLAB_080067ea:\n    arg_val = 0xffffffff;\n  }\n  else {\n    if ((int)(*format << 0x1e) < 0) {\n      for (result = 0; result < (int)(format[3] - field_width[0]); result = result + 1) {\n        print_result = (*print_func)(stream,width,(int)format + 0x19,1);\n        if (print_result == -1) goto LAB_080067ea;\n      }\n    }\n    arg_val = format[3];\n    if ((int)format[3] < (int)field_width[0]) {\n      arg_val = field_width[0];\n    }\n  }\n  return arg_val;\n}\n\n",
            "called": [
                "_printf_common",
                "memchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080066b0",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "print_formatted_output_080066b0"
        },
        "FUN_08002c52": {
            "renaming": {
                "FUN_08002c52": "do_nothing_08002c52"
            },
            "code": "\nvoid do_nothing_08002c52(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c52",
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "imported": false,
            "current_name": "do_nothing_08002c52"
        },
        "FUN_0800138e": {
            "renaming": {
                "FUN_0800138e": "setControlBit_0800138e",
                "_FUN_0800138econtrol": "_controlByte"
            },
            "code": "void __thiscall LiquidCrystal::setControlBit_0800138e(LiquidCrystal *lcd){\\n  byte controlByte = lcd->_controlByte;\\n  lcd->_controlByte = controlByte | 0b00000100;\\n  send(lcd, controlByte | 0b00001100, \"\\0\");\\n  return;\\n}",
            "called": [
                "send"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800138e",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "setControlBit_0800138e"
        },
        "FUN_08002c50": {
            "renaming": {
                "FUN_08002c50": "do_nothing_08002c50"
            },
            "code": "\nvoid do_nothing_08002c50(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c50",
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "imported": false,
            "current_name": "do_nothing_08002c50"
        },
        "FUN_0800598a": {
            "renaming": {
                "FUN_0800598a": "receive_serial_data_0800598a",
                "obj": "serial_object",
                "iVar1": "uart_read_status",
                "uVar2": "next_rx_head",
                "c": "received_char"
            },
            "code": "void receive_serial_data_0800598a(serial_t_conflict *serial_object) {\n  int uart_read_status;\n  ushort next_rx_head;\n  uchar received_char;\n  \n  uart_read_status = uart_getc((serial_t *)serial_object, &received_char);\n  if ((uart_read_status == 0) && (next_rx_head = serial_object->rx_head + 1 & 0x3f, next_rx_head != serial_object->rx_tail)) {\n    serial_object->rx_buff[serial_object->rx_head] = received_char;\n    serial_object->rx_head = next_rx_head;\n  }\n  return;\n}",
            "called": [
                "uart_getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800598a",
            "calling": [],
            "imported": false,
            "current_name": "receive_serial_data_0800598a"
        },
        "FUN_08001c88": {
            "renaming": {
                "FUN_08001c88": "updateHardwareConfiguration_08001c88",
                "DAT_08001ca8": "data_register",
                "HAL_NVIC_SetPriorityGrouping": "HAL_PRIORITY_GROUP_3",
                "FUN_08001c88Tick": "updateHardwareConfigurationTick"
            },
            "code": "HAL_StatusTypeDef_conflict updateHardwareConfiguration_08001c88(void) \\n\\\n{\\n\\\n  *DAT_08001ca8 = *DAT_08001ca8 | 0x10; \\n\\\n  HAL_NVIC_SetPriorityGrouping(HAL_PRIORITY_GROUP_3); \\n\\\n  updateHardwareConfiguration_08001c88Tick(0xf); \\n\\\n  HAL_MspInit(); \\n\\\n  return HAL_OK; \\n\\\n}",
            "called": [
                "HAL_MspInit",
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_InitTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c88",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "updateHardwareConfiguration_08001c88"
        },
        "FUN_08004e34": {
            "renaming": {
                "FUN_08004e34": "handle_timer_interrupt_if_set_08004e34",
                "PTR_timer_handles_08004e44": "PTR_timer_handles",
                "TIM_HandleTypeDef": "timer_handle",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt",
                "DAT_08004e44": "DAT_08004e44"
            },
            "code": "void handle_timer_interrupt_if_set_08004e34(void)\n{\n  TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef **)(PTR_timer_handles_08004e44_08004e44 + 4);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e34",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_if_set_08004e34"
        },
        "FUN_08001a44": {
            "renaming": {
                "__thiscall PID::FUN_08001a44": "setAutoMode",
                "this": "pid",
                "Mode": "mode",
                "bVar1": "autoMode",
                "inAuto": "autoEnabled",
                "FUN_08001a44": "setAutoMode_08001a44"
            },
            "code": "void __thiscall PID::setAutoMode_08001a44(PID *pid, int mode)\n{\n    bool autoMode;\n    if (mode == 1) {\n        autoMode = true;\n        if (pid->inAuto == false) {\n            initialize(pid);\n        }\n    }\n    else {\n        autoMode = false;\n    }\n    pid->inAuto = autoMode;\n    return;\n}",
            "called": [
                "Initialize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001a44",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "setAutoMode_08001a44"
        },
        "FUN_08002c54": {
            "renaming": {
                "FUN_08002c54": "send_byte_08002c54",
                "*hi2c": "*i2c_handle",
                "HVar1": "i2c_state",
                "pbVar2": "data_buffer",
                "hi2c->State": "i2c_handle->State",
                "hi2c->XferCount": "i2c_handle->XferCount",
                "hi2c->pBuffPtr": "i2c_handle->pBuffPtr",
                "hi2c->Instance->DR": "i2c_handle->Instance->DR",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "HAL_I2C_STATE_BUSY_TX_LISTEN",
                "hi2c->Instance->CR2": "i2c_handle->Instance->CR2",
                "hi2c->PreviousState": "i2c_handle->PreviousState",
                "0x21": "0x21",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "HAL_I2C_SlaveTxCpltCallback": "HAL_I2C_SlaveTxCpltCallback",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef_conflict send_byte_08002c54(I2C_HandleTypeDef *i2c_handle)\n{\n  HAL_I2C_StateTypeDef i2c_state;\n  uint8_t *data_buffer;\n  i2c_state = i2c_handle->State;\n  if (i2c_handle->XferCount != 0)\n  {\n    data_buffer = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = data_buffer + 1;\n    i2c_handle->Instance->DR = (uint8_t)*data_buffer;\n    i2c_handle->XferCount--;\n    if ((i2c_handle->XferCount == 0) && (i2c_state == HAL_I2C_STATE_BUSY_TX_LISTEN))\n    {\n      i2c_handle->Instance->CR2 &= 0xfffffbff;\n      i2c_handle->PreviousState = 0x21;\n      i2c_handle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(i2c_handle);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c54",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "send_byte_08002c54"
        },
        "FUN_080043b4": {
            "renaming": {
                "FUN_080043b4": "check_UART_flag_080043b4",
                "huart": "UART_handle",
                "Flag": "flag",
                "Status": "status",
                "Tickstart": "tick_start",
                "Timeout": "timeout",
                "uVar1": "current_time",
                "SR": "status_register",
                "gState": "global_state",
                "RxState": "receive_state",
                "Lock": "lock"
            },
            "code": "HAL_StatusTypeDef check_UART_flag_080043b4(UART_HandleTypeDef *UART_handle, uint32_t flag, FlagStatus status, uint32_t tick_start, uint32_t timeout)\n{\n  uint32_t current_time;\n\n  do {\n    bool flag_status = ((flag & ~UART_handle->Instance->SR) == 0);\n    if (flag_status != (bool)status) {\n      return HAL_OK;\n    }\n  } while ((timeout == 0xffffffff) || ((timeout != 0 && (current_time = HAL_GetTick(), current_time - tick_start <= timeout))));\n\n  UART_handle->Instance->CR1 &= 0xfffffe5f;\n  UART_handle->Instance->CR3 &= 0xfffffffe;\n  UART_handle->gState = HAL_UART_STATE_READY;\n  UART_handle->RxState = HAL_UART_STATE_READY;\n  UART_handle->Lock = HAL_UNLOCKED;\n\n  return HAL_TIMEOUT;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080043b4",
            "calling": [
                "HAL_UART_Transmit"
            ],
            "imported": false,
            "current_name": "check_UART_flag_080043b4"
        },
        "FUN_0800441a": {
            "renaming": {
                "FUN_0800441a": "initUART_0800441a",
                "*huart": "*uart",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "huart": "uart",
                "gState": "globalState",
                "Lock": "lock",
                "HAL_UART_MspInit": "initUARTMSP",
                "Instance": "instance",
                "CR1": "controlRegister1",
                "UART_SetConfig": "setUARTConfig",
                "CR2": "controlRegister2",
                "CR3": "controlRegister3",
                "ErrorCode": "error",
                "RxState": "receiveState"
            },
            "code": "HAL_StatusTypeDef initUART_0800441a(UART_HandleTypeDef *uart)\n{\n    if (uart != NULL)\n    {\n        if (uart->gState == HAL_UART_STATE_RESET)\n        {\n            uart->Lock = HAL_UNLOCKED;\n            HAL_UART_MspInit(uart);\n        }\n        uart->gState = HAL_UART_STATE_BUSY;\n        uart->Instance->CR1 &= ~(1 << 13);\n        UART_SetConfig(uart);\n        uart->Instance->CR2 &= ~(1 << 11);\n        uart->Instance->CR3 &= ~(1 << 2);\n        uart->Instance->CR1 |= (1 << 13);\n        uart->ErrorCode = HAL_UART_ERROR_NONE;\n        uart->gState = HAL_UART_STATE_READY;\n        uart->RxState = HAL_UART_STATE_READY;\n        return HAL_OK;\n    }\n    return HAL_ERROR;\n}",
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800441a",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "initUART_0800441a"
        },
        "FUN_08004d18": {
            "renaming": {
                "FUN_08004d18": "call_RTC_user_callback_08004d18",
                "hrtc": "RTC_HandleTypeDef* hrtc",
                "PTR_RTCUserCallback_08004d28": "code** user_callback_ptr",
                "PTR_callbackUserData_08004d2c": "undefined4* callback_user_data_ptr",
                "code": "function_pointer"
            },
            "code": "void call_RTC_user_callback_08004d18(RTC_HandleTypeDef *hrtc)\n{\n  code* user_callback = *(code**)PTR_RTCUserCallback_08004d28;\n  if (user_callback != (code*)0x0) {\n    (*user_callback)(*(undefined4*)PTR_callbackUserData_08004d2c);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d18",
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "imported": false,
            "current_name": "call_RTC_user_callback_08004d18"
        },
        "FUN_080006d4": {
            "renaming": {
                "FUN_080006d4": "calculate_result_080006d4",
                "param_1": "a",
                "param_2": "b",
                "param_3": "c",
                "param_4": "d",
                "uVar1": "temp3",
                "unaff_r4": "b",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "in_r12": "mask",
                "bVar4": "flag1"
            },
            "code": "ulonglong calculate_result_080006d4(uint a, uint b, uint c, uint d)\n{\n  uint temp1, temp2;\n  uint mask = 0x80000000;\n  bool flag1, flag2;\n\n  temp1 = d >> 0x14;\n  if (b != c && temp1 != c) {\n    flag1 = (a | (b << 1)) == 0;\n    if (!flag1) {\n      flag1 = (c | (d << 1)) == 0;\n    }\n    if (flag1) {\n      return (ulonglong)((b ^ d) & mask) << 0x20;\n    }\n    if (b == 0) {\n      uint temp3 = b & mask;\n      do {\n        uint temp4 = a & mask;\n        a = a << 1;\n        b = b * 2 + (uint)(temp4 != 0);\n      } while ((b & 0x100000) == 0);\n      b = b | temp3;\n      if (temp1 != 0) {\n        return CONCAT44(b,a);\n      }\n    }\n    do {\n      temp1 = c & mask;\n      c = c << 1;\n      d = d * 2 + (uint)(temp1 != 0);\n    } while ((d & 0x100000) == 0);\n    return CONCAT44(b,a);\n  }\n  flag1 = (a | (b << 1)) == 0;\n  if (flag1) {\n    b = d;\n    a = c;\n  }\n  if (!flag1) {\n    flag1 = (c | (d << 1)) == 0;\n  }\n  temp2 = b;\n  if (((!flag1) && ((b != c || ((a | (b << 0xc)) == 0)))) && ((temp1 != c || (a = c, temp2 = d, (c | (d << 0xc)) == 0)))) {\n    return (ulonglong)((b ^ d) & mask | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(temp2,a) | 0x7ff8000000000000;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080006d4",
            "calling": [
                "__muldf3"
            ],
            "imported": false,
            "current_name": "calculate_result_080006d4"
        },
        "FUN_08000190": {
            "renaming": {
                "FUN_08000190": "calculate_result_08000190",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "shifted_input_4",
                "bVar2": "last_bit",
                "uVar3": "sum_1",
                "uVar4": "sum_1_with_carry",
                "uVar5": "sum_2",
                "uVar6": "result_2",
                "uVar7": "result_1",
                "iVar8": "shifted_input_2",
                "uVar9": "abs_difference",
                "uVar10": "abs_difference_minus_2",
                "uVar11": "abs_difference_minus_1",
                "uVar12": "temp",
                "bVar13": "is_negative",
                "bVar14": "condition_met",
                "bVar15": "is_overflow"
            },
            "code": "\nulonglong calculate_result_08000190(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  int shifted_input_4;\n  byte last_bit;\n  uint sum_1;\n  uint sum_1_with_carry;\n  uint sum_2;\n  uint result_2;\n  uint result_1;\n  int shifted_input_2;\n  uint abs_difference;\n  uint abs_difference_minus_2;\n  uint abs_difference_minus_1;\n  uint temp;\n  bool is_negative;\n  bool condition_met;\n  bool is_overflow;\n  \n  result_2 = input_4 ^ 0x80000000;\n  abs_difference = input_2 << 1;\n  input_4 = input_4 << 1;\n  is_negative = ((input_2 ^ result_2) & 0x7fffffff) == 0;\n  condition_met = is_negative && input_1 == input_3;\n  if (!is_negative || input_1 != input_3) {\n    condition_met = (abs_difference | input_1) == 0;\n  }\n  if (!condition_met) {\n    condition_met = (input_4 | input_3) == 0;\n  }\n  shifted_input_2 = (int)abs_difference >> 0x15;\n  if (!condition_met) {\n    condition_met = shifted_input_2 == -1;\n  }\n  shifted_input_4 = (int)input_4 >> 0x15;\n  if (!condition_met) {\n    condition_met = shifted_input_4 == -1;\n  }\n  if (condition_met) {\n    if (shifted_input_2 == -1 || shifted_input_4 == -1) {\n      abs_difference = result_2;\n      abs_difference_minus_1 = input_3;\n      if (shifted_input_2 == -1) {\n        abs_difference = input_2;\n        abs_difference_minus_1 = input_1;\n      }\n      if (shifted_input_2 != -1 || shifted_input_4 != -1) {\n        input_3 = abs_difference_minus_1;\n        result_2 = abs_difference;\n      }\n      condition_met = (abs_difference_minus_1 | abs_difference << 0xc) == 0;\n      if (condition_met) {\n        condition_met = (input_3 | result_2 << 0xc) == 0;\n      }\n      if (condition_met) {\n        condition_met = abs_difference == result_2;\n      }\n      if (!condition_met) {\n        abs_difference = abs_difference | 0x80000;\n      }\n      return CONCAT44(abs_difference,abs_difference_minus_1);\n    }\n    if (((input_2 ^ result_2) & 0x7fffffff) != 0 || input_1 != input_3) {\n      if ((abs_difference | input_1) == 0) {\n        input_1 = input_3;\n        input_2 = result_2;\n      }\n      return CONCAT44(input_2,input_1);\n    }\n    if (input_2 != result_2) {\n      return 0;\n    }\n    if (abs_difference >> 0x15 == 0) {\n      condition_met = (input_1 & 0x80000000) != 0;\n      result_2 = input_2 * 2 + (uint)condition_met;\n      if (CARRY4(input_2,input_2) || CARRY4(input_2 * 2,(uint)condition_met)) {\n        result_2 = result_2 | 0x80000000;\n      }\n      return CONCAT44(result_2,input_1 << 1);\n    }\n    if (abs_difference < 0xffc00000) {\n      return CONCAT44(input_2 + 0x100000,input_1);\n    }\n    input_2 = input_2 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(input_2 | 0x7ff00000) << 0x20;\n  }\n  abs_difference = abs_difference >> 0x15;\n  input_4 = input_4 >> 0x15;\n  abs_difference_minus_1 = input_4 - abs_difference;\n  condition_met = abs_difference_minus_1 != 0;\n  if (input_4 < abs_difference) {\n    abs_difference_minus_1 = -abs_difference_minus_1;\n  }\n  abs_difference_minus_2 = input_1;\n  result_1 = input_2;\n  if (condition_met && abs_difference <= input_4) {\n    abs_difference = abs_difference + abs_difference_minus_1;\n    abs_difference_minus_2 = input_3;\n    result_1 = result_2;\n    input_3 = input_1;\n    result_2 = input_2;\n  }\n  if (0x36 < abs_difference_minus_1) {\n    return CONCAT44(result_1,abs_difference_minus_2);\n  }\n  sum_1_with_carry = result_1 & 0xfffff | 0x100000;\n  if ((result_1 & 0x80000000) != 0) {\n    condition_met = abs_difference_minus_2 != 0;\n    abs_difference_minus_2 = -abs_difference_minus_2;\n    sum_1_with_carry = -sum_1_with_carry - (uint)condition_met;\n  }\n  result_1 = result_2 & 0xfffff | 0x100000;\n  if ((result_2 & 0x80000000) != 0) {\n    condition_met = input_3 != 0;\n    input_3 = -input_3;\n    result_1 = -result_1 - (uint)condition_met;\n  }\n  if (abs_difference == abs_difference_minus_1) {\n    result_1 = result_1 ^ 0x100000;\n    if (abs_difference == 0) {\n      sum_1_with_carry = sum_1_with_carry ^ 0x100000;\n      abs_difference = 1;\n    }\n    else {\n      abs_difference_minus_1 = abs_difference_minus_1 - 1;\n    }\n  }\n  result_2 = -abs_difference_minus_1 + 0x20;\n  if ((int)abs_difference_minus_1 < 0x21) {\n    temp = input_3 << (result_2 & 0xff);\n    input_3 = input_3 >> (abs_difference_minus_1 & 0xff);\n    sum_1 = abs_difference_minus_2 + input_3;\n    sum_2 = result_1 << (result_2 & 0xff);\n    result_2 = sum_1 + sum_2;\n    sum_1_with_carry = sum_1_with_carry + CARRY4(abs_difference_minus_2,input_3) + ((int)result_1 >> (abs_difference_minus_1 & 0xff)) +\n            (uint)CARRY4(sum_1,sum_2);\n  }\n  else {\n    temp = result_1 << (-abs_difference_minus_1 + 0x40 & 0xff);\n    if (input_3 != 0) {\n      temp = temp | 2;\n    }\n    result_1 = (int)result_1 >> (abs_difference_minus_1 - 0x20 & 0xff);\n    result_2 = abs_difference_minus_2 + result_1;\n    sum_1_with_carry = sum_1_with_carry + ((int)result_1 >> 0x1f) + (uint)CARRY4(abs_difference_minus_2,result_1);\n  }\n  input_2 = sum_1_with_carry & 0x80000000;\n  abs_difference_minus_1 = sum_1_with_carry;\n  if ((int)sum_1_with_carry < 0) {\n    condition_met = temp == 0;\n    temp = -temp;\n    abs_difference_minus_1 = -result_2;\n    result_2 = -(uint)!condition_met - result_2;\n    abs_difference_minus_1 = -(uint)(condition_met <= abs_difference_minus_1) - sum_1_with_carry;\n  }\n  if (0xfffff < abs_difference_minus_1) {\n    abs_difference_minus_2 = abs_difference - 1;\n    if (0x1fffff < abs_difference_minus_1) {\n      abs_difference_minus_2 = abs_difference_minus_1 & 1;\n      abs_difference_minus_1 = abs_difference_minus_1 >> 1;\n      last_bit = (byte)result_2;\n      result_2 = (uint)(abs_difference_minus_2 != 0) << 0x1f | result_2 >> 1;\n      temp = (uint)(last_bit & 1) << 0x1f | temp >> 1;\n      abs_difference_minus_2 = abs_difference;\n      if (0xffbfffff < abs_difference * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    condition_met = 0x7fffffff < temp;\n    if (temp == 0x80000000) {\n      condition_met = (result_2 & 1) != 0;\n    }\n    return CONCAT44(abs_difference_minus_1 + abs_difference_minus_2 * 0x100000 + (uint)CARRY4(result_2,(uint)condition_met) | input_2,\n                    result_2 + condition_met);\n  }\n  is_negative = (temp & 0x80000000) != 0;\n  temp = temp << 1;\n  abs_difference_minus_2 = result_2 * 2;\n  condition_met = CARRY4(result_2,result_2);\n  result_2 = result_2 * 2 + (uint)is_negative;\n  abs_difference_minus_1 = abs_difference_minus_1 * 2 + (uint)(condition_met || CARRY4(abs_difference_minus_2,(uint)is_negative));\n  abs_difference_minus_2 = abs_difference - 2;\n  if ((abs_difference_minus_1 & 0x100000) != 0) goto LAB_080002a0;\n  result_1 = result_2;\n  abs_difference = abs_difference_minus_1;\n  if (abs_difference_minus_1 == 0) {\n    result_1 = 0;\n    abs_difference = result_2;\n  }\n  shifted_input_2 = count_leading_zeroes(abs_difference);\n  if (abs_difference_minus_1 == 0) {\n    shifted_input_2 = shifted_input_2 + 0x20;\n  }\n  abs_difference_minus_1 = shifted_input_2 - 0xb;\n  is_overflow = SBORROW4(abs_difference_minus_1,0x20);\n  result_2 = shifted_input_2 - 0x2b;\n  condition_met = (int)result_2 < 0;\n  is_negative = result_2 == 0;\n  if ((int)abs_difference_minus_1 < 0x20) {\n    is_overflow = SCARRY4(result_2,0xc);\n    shifted_input_2 = shifted_input_2 + -0x1f;\n    condition_met = shifted_input_2 < 0;\n    is_negative = shifted_input_2 == 0;\n    result_2 = abs_difference_minus_1;\n    if (!is_negative && condition_met == is_overflow) {\n      result_1 = abs_difference << (abs_difference_minus_1 & 0xff);\n      abs_difference = abs_difference >> (0xcU - shifted_input_2 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (is_negative || condition_met != is_overflow) {\n    temp = 0x20 - result_2;\n  }\n  abs_difference = abs_difference << (result_2 & 0xff);\n  if (is_negative || condition_met != is_overflow) {\n    abs_difference = abs_difference | result_1 >> (temp & 0xff);\n  }\n  if (is_negative || condition_met != is_overflow) {\n    result_1 = result_1 << (result_2 & 0xff);\n  }\nLAB_08000318:\n  if ((int)abs_difference_minus_1 <= (int)abs_difference_minus_2) {\n    return CONCAT44(abs_difference + (abs_difference_minus_2 - abs_difference_minus_1) * 0x100000 | input_2,result_1);\n  }\n  result_2 = ~(abs_difference_minus_2 - abs_difference_minus_1);\n  if ((int)result_2 < 0x1f) {\n    shifted_input_2 = result_2 - 0x13;\n    if (shifted_input_2 != 0 && shifted_input_2 < 0 == SCARRY4(result_2 - 0x1f,0xc)) {\n      return CONCAT44(sum_1_with_carry,result_1 >> (0x20 - (0xcU - shifted_input_2) & 0xff) | abs_difference << (0xcU - shifted_input_2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    result_2 = result_2 + 1;\n    return CONCAT44(input_2 | abs_difference >> (result_2 & 0xff),\n                    result_1 >> (result_2 & 0xff) | abs_difference << (0x20 - result_2 & 0xff));\n  }\n  return CONCAT44(sum_1_with_carry,abs_difference >> (result_2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000190",
            "calling": [
                "SetControllerDirection",
                "Compute",
                "printFloat",
                "SetTunings"
            ],
            "imported": false,
            "current_name": "calculate_result_08000190"
        },
        "FUN_08006174": {
            "renaming": {
                "FUN_08006174": "format_output_08006174",
                "__stream": "stream",
                "__format": "format",
                "iVar1": "result",
                "in_r2": "arg1",
                "in_r3": "arg2",
                "uStack_8": "stack_arg1",
                "uStack_4": "stack_arg2"
            },
            "code": "int format_output_08006174(FILE *stream, char *format, ...)\n{\n  int result;\n  undefined4 arg1;\n  undefined4 arg2;\n  undefined4 stack_arg1;\n  undefined4 stack_arg2;\n  \n  stack_arg1 = arg1;\n  stack_arg2 = arg2;\n  result = _vformat_output_08006174_r(*(undefined4 *)PTR__impure_ptr_08006194, stream, format, &stack_arg1, stream, &stack_arg2);\n  return result;\n}",
            "called": [
                "_vfiprintf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006174",
            "calling": [
                "__assert_func"
            ],
            "imported": false,
            "current_name": "format_output_08006174"
        },
        "FUN_08007028": {
            "renaming": {
                "FUN_08007028": "checkIfTerminal_08007028",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "puVar1": "errorPointer",
                "iVar2": "isTerminal"
            },
            "code": "void checkIfTerminal_08007028(int *errorCode, int fileDescriptor)\n{\n  undefined *errorPointer;\n  int isTerminal;\n  errorPointer = PTR_errno_08007044;\n  *(undefined4 *)PTR_errno_08007044 = 0;\n  isTerminal = _isatty(fileDescriptor);\n  if ((isTerminal == -1) && (*(int *)errorPointer != 0)) {\n    *errorCode = *(int *)errorPointer;\n  }\n  return;\n}",
            "called": [
                "_isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007028",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "checkIfTerminal_08007028"
        },
        "FUN_08000194": {
            "renaming": {
                "FUN_08000194": "calculate_numbers_08000194",
                "param_1": "number1",
                "param_2": "number2",
                "param_3": "number3",
                "param_4": "number4",
                "iVar1": "shifted_number2",
                "bVar2": "lsb",
                "uVar3": "sum1",
                "uVar4": "sum2",
                "uVar5": "shifted_number4",
                "iVar6": "shifted_number2",
                "uVar7": "shifted_number2",
                "uVar8": "number1",
                "uVar9": "shifted_number4",
                "uVar10": "difference",
                "uVar11": "shifted_sum1",
                "uVar12": "sum",
                "bVar13": "is_negative",
                "bVar14": "condition",
                "bVar15": "is_overflow"
            },
            "code": "\nulonglong calculate_numbers_08000194(uint number1,uint number2,uint number3,uint number4)\n\n{\n  int shifted_number2;\n  byte lsb;\n  uint sum1;\n  uint sum2;\n  uint shifted_number4;\n  int shifted_number2;\n  uint shifted_number2;\n  uint number1;\n  uint shifted_number4;\n  uint difference;\n  uint shifted_sum1;\n  uint sum;\n  bool is_negative;\n  bool condition;\n  bool is_overflow;\n  \n  shifted_number2 = number2 << 1;\n  shifted_number4 = number4 << 1;\n  is_negative = ((number2 ^ number4) & 0x7fffffff) == 0;\n  condition = is_negative && number1 == number3;\n  if (!is_negative || number1 != number3) {\n    condition = (shifted_number2 | number1) == 0;\n  }\n  if (!condition) {\n    condition = (shifted_number4 | number3) == 0;\n  }\n  shifted_number2 = (int)shifted_number2 >> 0x15;\n  if (!condition) {\n    condition = shifted_number2 == -1;\n  }\n  shifted_number2 = (int)shifted_number4 >> 0x15;\n  if (!condition) {\n    condition = shifted_number2 == -1;\n  }\n  if (condition) {\n    if (shifted_number2 == -1 || shifted_number2 == -1) {\n      shifted_number4 = number4;\n      shifted_number2 = number3;\n      if (shifted_number2 == -1) {\n        shifted_number4 = number2;\n        shifted_number2 = number1;\n      }\n      if (shifted_number2 != -1 || shifted_number2 != -1) {\n        number3 = shifted_number2;\n        number4 = shifted_number4;\n      }\n      condition = (shifted_number2 | shifted_number4 << 0xc) == 0;\n      if (condition) {\n        condition = (number3 | number4 << 0xc) == 0;\n      }\n      if (condition) {\n        condition = shifted_number4 == number4;\n      }\n      if (!condition) {\n        shifted_number4 = shifted_number4 | 0x80000;\n      }\n      return CONCAT44(shifted_number4,shifted_number2);\n    }\n    if (((number2 ^ number4) & 0x7fffffff) != 0 || number1 != number3) {\n      if ((shifted_number2 | number1) == 0) {\n        number1 = number3;\n        number2 = number4;\n      }\n      return CONCAT44(number2,number1);\n    }\n    if (number2 != number4) {\n      return 0;\n    }\n    if (shifted_number2 >> 0x15 == 0) {\n      condition = (number1 & 0x80000000) != 0;\n      shifted_number4 = number2 * 2 + (uint)condition;\n      if (CARRY4(number2,number2) || CARRY4(number2 * 2,(uint)condition)) {\n        shifted_number4 = shifted_number4 | 0x80000000;\n      }\n      return CONCAT44(shifted_number4,number1 << 1);\n    }\n    if (shifted_number2 < 0xffc00000) {\n      return CONCAT44(number2 + 0x100000,number1);\n    }\n    number2 = number2 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(number2 | 0x7ff00000) << 0x20;\n  }\n  shifted_number2 = shifted_number2 >> 0x15;\n  shifted_number4 = shifted_number4 >> 0x15;\n  difference = shifted_number4 - shifted_number2;\n  condition = difference != 0;\n  if (shifted_number4 < shifted_number2) {\n    difference = -difference;\n  }\n  number1 = number1;\n  shifted_number4 = number2;\n  if (condition && shifted_number2 <= shifted_number4) {\n    shifted_number2 = shifted_number2 + difference;\n    number1 = number3;\n    shifted_number4 = number4;\n    number3 = number1;\n    number4 = number2;\n  }\n  if (0x36 < difference) {\n    return CONCAT44(shifted_number4,number1);\n  }\n  shifted_number4 = shifted_number4 & 0xfffff | 0x100000;\n  if ((shifted_number4 & 0x80000000) != 0) {\n    condition = number1 != 0;\n    number1 = -number1;\n    shifted_number4 = -shifted_number4 - (uint)condition;\n  }\n  shifted_number4 = number4 & 0xfffff | 0x100000;\n  if ((number4 & 0x80000000) != 0) {\n    condition = number3 != 0;\n    number3 = -number3;\n    shifted_number4 = -shifted_number4 - (uint)condition;\n  }\n  if (shifted_number2 == difference) {\n    shifted_number4 = shifted_number4 ^ 0x100000;\n    if (shifted_number2 == 0) {\n      shifted_number4 = shifted_number4 ^ 0x100000;\n      shifted_number2 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  sum = -difference + 0x20;\n  if ((int)difference < 0x21) {\n    shifted_sum1 = number3 << (sum & 0xff);\n    number3 = number3 >> (difference & 0xff);\n    sum1 = number1 + number3;\n    sum2 = shifted_number4 << (sum & 0xff);\n    sum = sum1 + sum2;\n    shifted_number4 = shifted_number4 + CARRY4(number1,number3) + ((int)shifted_number4 >> (difference & 0xff)) +\n            (uint)CARRY4(sum1,sum2);\n  }\n  else {\n    shifted_sum1 = shifted_number4 << (-difference + 0x40 & 0xff);\n    if (number3 != 0) {\n      shifted_sum1 = shifted_sum1 | 2;\n    }\n    shifted_number4 = (int)shifted_number4 >> (difference - 0x20 & 0xff);\n    sum = number1 + shifted_number4;\n    shifted_number4 = shifted_number4 + ((int)shifted_number4 >> 0x1f) + (uint)CARRY4(number1,shifted_number4);\n  }\n  number2 = shifted_number4 & 0x80000000;\n  difference = shifted_number4;\n  if ((int)shifted_number4 < 0) {\n    condition = shifted_sum1 == 0;\n    shifted_sum1 = -shifted_sum1;\n    difference = -sum;\n    sum = -(uint)!condition - sum;\n    difference = -(uint)(condition <= difference) - shifted_number4;\n  }\n  if (0xfffff < difference) {\n    number1 = shifted_number2 - 1;\n    if (0x1fffff < difference) {\n      shifted_number4 = difference & 1;\n      difference = difference >> 1;\n      lsb = (byte)sum;\n      sum = (uint)(shifted_number4 != 0) << 0x1f | sum >> 1;\n      shifted_sum1 = (uint)(lsb & 1) << 0x1f | shifted_sum1 >> 1;\n      number1 = shifted_number2;\n      if (0xffbfffff < shifted_number2 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    condition = 0x7fffffff < shifted_sum1;\n    if (shifted_sum1 == 0x80000000) {\n      condition = (sum & 1) != 0;\n    }\n    return CONCAT44(difference + number1 * 0x100000 + (uint)CARRY4(sum,(uint)condition) | number2,\n                    sum + condition);\n  }\n  is_negative = (shifted_sum1 & 0x80000000) != 0;\n  shifted_sum1 = shifted_sum1 << 1;\n  number1 = sum * 2;\n  condition = CARRY4(sum,sum);\n  sum = sum * 2 + (uint)is_negative;\n  difference = difference * 2 + (uint)(condition || CARRY4(number1,(uint)is_negative));\n  number1 = shifted_number2 - 2;\n  if ((difference & 0x100000) != 0) goto LAB_080002a0;\n  shifted_number4 = sum;\n  shifted_number2 = difference;\n  if (difference == 0) {\n    shifted_number4 = 0;\n    shifted_number2 = sum;\n  }\n  shifted_number2 = count_leading_zeroes(shifted_number2);\n  if (difference == 0) {\n    shifted_number2 = shifted_number2 + 0x20;\n  }\n  sum = shifted_number2 - 0xb;\n  is_overflow = SBORROW4(sum,0x20);\n  difference = shifted_number2 - 0x2b;\n  condition = (int)difference < 0;\n  is_negative = difference == 0;\n  if ((int)sum < 0x20) {\n    is_overflow = SCARRY4(difference,0xc);\n    shifted_number2 = shifted_number2 + -0x1f;\n    condition = shifted_number2 < 0;\n    is_negative = shifted_number2 == 0;\n    difference = sum;\n    if (!is_negative && condition == is_overflow) {\n      shifted_number4 = shifted_number2 << (sum & 0xff);\n      shifted_number2 = shifted_number2 >> (0xcU - shifted_number2 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (is_negative || condition != is_overflow) {\n    shifted_sum1 = 0x20 - difference;\n  }\n  shifted_number2 = shifted_number2 << (difference & 0xff);\n  if (is_negative || condition != is_overflow) {\n    shifted_number2 = shifted_number2 | shifted_number4 >> (shifted_sum1 & 0xff);\n  }\n  if (is_negative || condition != is_overflow) {\n    shifted_number4 = shifted_number4 << (difference & 0xff);\n  }\nLAB_08000318:\n  if ((int)sum <= (int)number1) {\n    return CONCAT44(shifted_number2 + (number1 - sum) * 0x100000 | number2,shifted_number4);\n  }\n  difference = ~(number1 - sum);\n  if ((int)difference < 0x1f) {\n    shifted_number2 = difference - 0x13;\n    if (shifted_number2 != 0 && shifted_number2 < 0 == SCARRY4(difference - 0x1f,0xc)) {\n      return CONCAT44(shifted_number4,shifted_number4 >> (0x20 - (0xcU - shifted_number2) & 0xff) | shifted_number2 << (0xcU - shifted_number2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    difference = difference + 1;\n    return CONCAT44(number2 | shifted_number2 >> (difference & 0xff),\n                    shifted_number4 >> (difference & 0xff) | shifted_number2 << (0x20 - difference & 0xff));\n  }\n  return CONCAT44(shifted_number4,shifted_number2 >> (difference - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000194",
            "calling": [
                "__aeabi_drsub",
                "Compute",
                "printFloat",
                "readThermocouple",
                "loop"
            ],
            "imported": false,
            "current_name": "calculate_numbers_08000194"
        },
        "FUN_08002494": {
            "renaming": {
                "FUN_08002494": "configure_interrupt_08002494",
                "IRQn": "irq",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "uVar1": "irq_num",
                "uVar2": "priority_shift",
                "uVar3": "preempt_bits"
            },
            "code": "void configure_interrupt_08002494(IRQn_Type_conflict irq, uint32_t preempt_priority, uint32_t sub_priority) {\n  uint8_t priority_shift = (*(int *)(DAT_080024f0 + 0xc) << 0x15) >> 0x1d;\n  uint8_t preempt_bits = 7 - priority_shift;\n  if (preempt_bits > 3) {\n    preempt_bits = 4;\n  }\n  uint8_t sub_bits = 0;\n  if (priority_shift + 4 < 7) {\n    preempt_bits = 0;\n  }\n  else {\n    preempt_bits = priority_shift - 3;\n  }\n  preempt_bits = (preempt_priority & (1 << (preempt_bits & 0xff)) - 1U) << (sub_bits & 0xff) | (1 << (sub_bits & 0xff)) - 1U & sub_priority;\n  if ((int)irq < 0) {\n    *(char *)(DAT_080024f4 + (irq & 0xf)) = (char)(preempt_bits << 4);\n  }\n  else {\n    *(char *)(irq + 0xe000e400) = (char)(preempt_bits << 4);\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002494",
            "calling": [
                "SystemClock_Config",
                "uart_attach_tx_callback",
                "HAL_InitTick",
                "uart_attach_rx_callback"
            ],
            "imported": false,
            "current_name": "configure_interrupt_08002494"
        },
        "FUN_08002c4e": {
            "renaming": {
                "FUN_08002c4e": "do_nothing_08002c4e"
            },
            "code": "\nvoid do_nothing_08002c4e(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c4e",
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "imported": false,
            "current_name": "do_nothing_08002c4e"
        },
        "FUN_08004f4c": {
            "renaming": {
                "FUN_08004f4c": "initialize_uart_08004f4c",
                "obj": "serial",
                "pUVar1": "usart_1",
                "pUVar2": "usart_2",
                "pUVar3": "usart_3",
                "pUVar4": "selected_usart",
                "pGVar5": "gpio",
                "uVar6": "pin_function",
                "tmpreg": "tmp_register",
                "tmpreg_1": "tmp_register_1",
                "tmpreg_2": "tmp_register_2",
                "tmpreg_3": "tmp_register_3",
                "GPIO_InitStruct": "gpio_init",
                "PinMap_conflict": "pinmap_conflict"
            },
            "code": "\nvoid initialize_uart_08004f4c(serial_t *serial)\n\n{\n  USART_TypeDef *usart_1;\n  USART_TypeDef *usart_2;\n  USART_TypeDef *usart_3;\n  void *a;\n  void *b;\n  USART_TypeDef *selected_usart;\n  GPIO_TypeDef *gpio;\n  uint32_t pin_function;\n  uint32_t tmp_register;\n  uint32_t tmp_register_1;\n  uint32_t tmp_register_2;\n  uint32_t tmp_register_3;\n  GPIO_InitTypeDef gpio_init;\n  \n  if (serial != (serial_t *)0x0) {\n    a = pinmap_peripheral(serial->pin_tx,(pinmap_conflict *)PTR_PinMap_UART_TX_08005204);\n    b = pinmap_peripheral(serial->pin_rx,(pinmap_conflict *)PTR_PinMap_UART_RX_08005208);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_UART_pin_has_0800521c);\n    }\n    else {\n      selected_usart = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      serial->uart = selected_usart;\n      usart_3 = DAT_08005214;\n      usart_2 = DAT_08005210;\n      usart_1 = DAT_0800520c;\n      if (selected_usart == (USART_TypeDef *)0x0) {\n        iprintf(PTR_s_ERROR__U_S_ART_pins_mismatch_08005220);\n      }\n      else {\n        if (selected_usart == DAT_0800520c) {\n          DAT_0800520c[0x7b7].BRR = DAT_0800520c[0x7b7].BRR | 0x4000;\n          usart_1[0x7b7].BRR = usart_1[0x7b7].BRR & 0xffffbfff;\n          usart_1[0x7b7].CR3 = usart_1[0x7b7].CR3 | 0x4000;\n          serial->index = '\\0';\n          serial->irq = USART1_IRQn;\n        }\n        else if (selected_usart == DAT_08005210) {\n          DAT_08005210[0x106e].BRR = DAT_08005210[0x106e].BRR | 0x20000;\n          usart_2[0x106e].BRR = usart_2[0x106e].BRR & 0xfffdffff;\n          usart_2[0x106e].CR3 = usart_2[0x106e].CR3 | 0x20000;\n          serial->index = '\\x01';\n          serial->irq = USART2_IRQn;\n        }\n        else if (selected_usart == DAT_08005214) {\n          DAT_08005214[0x1049].CR3 = DAT_08005214[0x1049].CR3 | 0x40000;\n          usart_3[0x1049].CR3 = usart_3[0x1049].CR3 & 0xfffbffff;\n          usart_3[0x104a].DR = usart_3[0x104a].DR | 0x40000;\n          serial->index = '\\x02';\n          serial->irq = USART3_IRQn;\n        }\n        gpio = set_GPIO_Port_Clock((uint)((int)serial->pin_rx << 0x18) >> 0x1c);\n        pin_function = pinmap_function(serial->pin_rx,(pinmap_conflict *)PTR_PinMap_UART_RX_08005208);\n        gpio_init.Pin = 1 << (serial->pin_rx & 0xfU) & 0xffff;\n        gpio_init.Mode = (pin_function >> 3 & 1) << 4 | pin_function & 7;\n        gpio_init.Pull = (pin_function << 0x1a) >> 0x1e;\n        *(uint *)(DAT_08005218 + 0x18) = *(uint *)(DAT_08005218 + 0x18) | 1;\n        switch((pin_function << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08005224 + 4) = *(uint *)(DAT_08005224 + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_08005380 + 4) = *(uint *)(DAT_08005380 + 4) & 0xf8ffffff | 0x4000000;\n        }\n        gpio_init.Speed = 3;\n        HAL_GPIO_Init(gpio,&gpio_init);\n        gpio = set_GPIO_Port_Clock((uint)((int)serial->pin_tx << 0x18) >> 0x1c);\n        pin_function = pinmap_function(serial->pin_tx,(pinmap_conflict *)PTR_PinMap_UART_TX_08005204);\n        gpio_init.Pin = 1 << (serial->pin_tx & 0xfU) & 0xffff;\n        gpio_init.Mode = (pin_function >> 3 & 1) << 4 | pin_function & 7;\n        gpio_init.Pull = (pin_function << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(gpio,&gpio_init);\n        *(UART_HandleTypeDef **)(PTR_uart_handlers_08005228 + (uint)serial->index * 4) = &serial->handle;\n        (serial->handle).Instance = serial->uart;\n        (serial->handle).Init.BaudRate = serial->baudrate;\n        (serial->handle).Init.WordLength = serial->databits;\n        (serial->handle).Init.StopBits = serial->stopbits;\n        (serial->handle).Init.Parity = serial->parity;\n        (serial->handle).Init.Mode = 0xc;\n        (serial->handle).Init.HwFlowCtl = 0;\n        (serial->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&serial->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "pinmap_merge_peripheral",
                "HAL_GPIO_Init",
                "pinmap_peripheral",
                "pinmap_function",
                "set_GPIO_Port_Clock",
                "iprintf",
                "HAL_UART_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f4c",
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_08004f4c"
        },
        "FUN_080055bc": {
            "renaming": {
                "FUN_080055bc": "get_uart_index_080055bc",
                "huart": "uart_handler",
                "uVar1": "index"
            },
            "code": "uint8_t get_uart_index_080055bc(UART_HandleTypeDef *uart_handler)\n{\n  uint8_t index = 0;\n  if (uart_handler == NULL) {\n    index = 5;\n  }\n  else {\n    while( true ) {\n      if (index > 4) {\n        return index;\n      }\n      if (uart_handler == *(UART_HandleTypeDef **)(PTR_uart_handlers_080055dc + index * 4)) {\n        break;\n      }\n      index++;\n    }\n  }\n  return index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080055bc",
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "imported": false,
            "current_name": "get_uart_index_080055bc"
        },
        "FUN_08001960": {
            "renaming": {
                "FUN_08001960": "updateOutputLimits_08001960",
                "this": "pid",
                "Min": "minOutput",
                "Max": "maxOutput",
                "iVar1": "outputIsBounded",
                "in_r2": "minOutput._0_4_",
                "in_r3": "minOutput._4_4_",
                "pdVar2": "output",
                "uVar3": "outputSum._0_4_",
                "uVar4": "outputSum._4_4_",
                "uVar5": "outMax._0_4_",
                "uVar6": "outMax._4_4_"
            },
            "code": "void updateOutputLimits_08001960(PID *pid, double minOutput, double maxOutput) {\n  int outputIsBounded = __aeabi_dcmpge(maxOutput, minOutput);\n  if (outputIsBounded == 0) {\n    pid->outMin = minOutput;\n    pid->outMax = maxOutput;\n    if (pid->inAuto) {\n      double *output = pid->myOutput;\n      int outputIsBelowMin = __aeabi_dcmplt(minOutput._0_4_, minOutput._4_4_, *(undefined4 *)output, *(undefined4 *)((int)output + 4));\n      if (outputIsBelowMin) {\n        *output = minOutput;\n      } else {\n        int outputIsAboveMax = __aeabi_dcmpgt(maxOutput._0_4_, maxOutput._4_4_, *(undefined4 *)output, *(undefined4 *)((int)output + 4));\n        if (outputIsAboveMax) {\n          *output = maxOutput;\n        }\n      }\n      double outputSum = pid->outputSum;\n      int outputSumIsAboveMax = __aeabi_dcmpgt(outputSum._0_4_, outputSum._4_4_, maxOutput._0_4_, maxOutput._4_4_);\n      if (outputSumIsAboveMax) {\n        pid->outputSum = maxOutput;\n      }\n      int outputSumIsBelowMin = __aeabi_dcmplt(outputSum._0_4_, outputSum._4_4_, minOutput._0_4_, minOutput._4_4_);\n      if (outputSumIsBelowMin) {\n        pid->outputSum = minOutput;\n      }\n    }\n  }\n}",
            "called": [
                "__aeabi_dcmplt",
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001960",
            "calling": [
                "PID",
                "loop"
            ],
            "imported": false,
            "current_name": "updateOutputLimits_08001960"
        },
        "FUN_08004ca2": {
            "renaming": {
                "FUN_08004ca2": "find_pin_for_peripheral_08004ca2",
                "PVar1": "pin",
                "peripheral": "peripheral_ptr",
                "map": "pin_map"
            },
            "code": "PinName_conflict find_pin_for_peripheral_08004ca2(void *peripheral, PinMap_conflict *map) {\n\tif (peripheral != NULL) {\n\t\tPinName_conflict pin = pinmap_find_pin(peripheral, map);\n\t\treturn pin;\n\t}\n\treturn NC;\n}",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ca2",
            "calling": [
                "HardwareSerial",
                "uart_debug_init"
            ],
            "imported": false,
            "current_name": "find_pin_for_peripheral_08004ca2"
        },
        "FUN_08002810": {
            "renaming": {
                "FUN_08002810": "check_GPIO_Pin_08002810",
                "GPIO_PinState": "GPIO_PinState",
                "GPIO_TypeDef": "GPIO_TypeDef",
                "GPIOx": "GPIOx",
                "uint16_t": "uint16_t",
                "GPIO_Pin": "GPIO_Pin",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "GPIO_PinState check_GPIO_Pin_08002810(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin) {\n  if ((GPIO_Pin & GPIOx->IDR) == 0) {\n    return GPIO_PIN_RESET;\n  }\n  return GPIO_PIN_SET;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002810",
            "calling": [
                "digital_io_read"
            ],
            "imported": false,
            "current_name": "check_GPIO_Pin_08002810"
        },
        "FUN_0800224c": {
            "renaming": {
                "FUN_0800224c": "stop_ADC_conversion_0800224c",
                "*hadc": "*hadc",
                "HVar1": "status",
                "PTR_DAT_08002340": "PTR_DAT_08002340",
                "PTR_DAT_08002344": "PTR_DAT_08002344"
            },
            "code": "HAL_StatusTypeDef_conflict stop_ADC_conversion_0800224c(ADC_HandleTypeDef *hadc)\n{\n  HAL_StatusTypeDef_conflict status;\n  if (hadc == NULL) {\n    status = HAL_ERROR;\n  }\n  else {\n    hadc->State |= 2;\n    status = ADC_ConversionStop_Disable(hadc);\n    if (status == HAL_OK) {\n      hadc->Instance->SR = 0xffffffe0;\n      hadc->Instance->CR1 = PTR_DAT_08002340 & hadc->Instance->CR1;\n      hadc->Instance->CR2 = PTR_DAT_08002344 & hadc->Instance->CR2;\n      hadc->Instance->SMPR1 &= 0xff000000;\n      hadc->Instance->SMPR2 &= 0xc0000000;\n      hadc->Instance->JOFR1 &= 0xfffff000;\n      hadc->Instance->JOFR2 &= 0xfffff000;\n      hadc->Instance->JOFR3 &= 0xfffff000;\n      hadc->Instance->JOFR4 &= 0xfffff000;\n      hadc->Instance->HTR &= 0xfffff000;\n      hadc->Instance->LTR &= 0xfffff000;\n      hadc->Instance->SQR1 &= 0xff000000;\n      hadc->Instance->SQR2 &= 0xc0000000;\n      hadc->Instance->SQR3 &= 0xc0000000;\n      hadc->Instance->JSQR &= 0xffc00000;\n      HAL_ADC_MspDeInit(hadc);\n      hadc->ErrorCode = 0;\n      hadc->State = 0;\n    }\n    hadc->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}",
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800224c",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "stop_ADC_conversion_0800224c"
        },
        "FUN_080054b0": {
            "renaming": {
                "FUN_080054b0": "is_uart_transmit_complete_080054b0",
                "*obj": "*serial",
                "HVar1": "uart_state"
            },
            "code": "bool is_uart_transmit_complete_080054b0(serial_t *serial) { \\n\\\n                        HAL_UART_StateTypeDef uart_state = HAL_UART_GetState(*((UART_HandleTypeDef **)(PTR_uart_handlers_080054d0 + (uint)serial->index * 4))); \\n\\\n                        return ((uart_state & 0x21U) == 0x21); \\n\\\n                      }",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080054b0",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "is_uart_transmit_complete_080054b0"
        },
        "FUN_08006f00": {
            "renaming": {
                "FUN_08006f00": "signal_handler_08006f00",
                "__sig": "signal",
                "iVar1": "return_value"
            },
            "code": "int signal_handler_08006f00(int signal) {\n  int return_value;\n  return_value = _signal_handler_08006f00_r(*(undefined4 *)PTR__impure_ptr_08006f0c, signal);\n  return return_value;\n}",
            "called": [
                "_raise_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006f00",
            "calling": [
                "abort"
            ],
            "imported": false,
            "current_name": "signal_handler_08006f00"
        },
        "FUN_080016b4": {
            "renaming": {
                "__thiscall PID::FUN_080016b4": "calculatePID",
                "this": "pid",
                "bVar1": "inAuto",
                "uVar2": "currentTime",
                "iVar3": "comparisonResult",
                "uVar4": "tempVar1",
                "uVar5": "input",
                "uVar6": "outputSumLow",
                "uVar7": "outMinLow",
                "uVar8": "inputHigh",
                "uVar9": "outputSumHigh",
                "uVar10": "outMinHigh",
                "uVar12": "outMaxLow",
                "uVar13": "outMaxHigh",
                "uVar14": "setPointHigh",
                "uVar15": "errorHigh",
                "uVar16": "dInputHigh",
                "uVar17": "tempVar2",
                "uStack_34": "errorLow",
                "local_38": "kpErrorLow",
                "cVar11": "inAutoChar",
                "dVar18": "output",
                "dVar19": "tempVar3",
                "FUN_080016b4": "calculatePID_080016b4"
            },
            "code": "bool __thiscall calculatePID_080016b4(PID *pid) {\n  bool inAuto = pid->inAuto;\n  if (!inAuto) {\n    return false;\n  }\n  uint32_t currentTime = millis();\n  uint32_t timeDifference = currentTime - pid->lastTime;\n  if (timeDifference < pid->SampleTime) {\n    return false;\n  }\n  double input = *pid->myInput;\n  double setPoint = *pid->mySetpoint;\n  double lastInput = pid->lastInput;\n  double outputSum = pid->outputSum;\n  double kp = pid->kp;\n  double ki = pid->ki;\n  double kd = pid->kd;\n  double outMin = pid->outMin;\n  double outMax = pid->outMax;\n  double error = setPoint - input;\n  outputSum += ki * error * timeDifference;\n  if (outputSum > outMax) {\n    outputSum = outMax;\n  }\n  else if (outputSum < outMin) {\n    outputSum = outMin;\n  }\n  double dInput = input - lastInput;\n  double output = kp * error + outputSum - kd * dInput / timeDifference;\n  if (output > outMax) {\n    output = outMax;\n  }\n  else if (output < outMin) {\n    output = outMin;\n  }\n  *pid->myOutput = output;\n  pid->lastInput = input;\n  pid->lastTime = currentTime;\n  return true;\n}",
            "called": [
                "__aeabi_dadd",
                "millis",
                "__subdf3",
                "__aeabi_dcmplt",
                "__muldf3",
                "__aeabi_dcmpgt"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080016b4",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "calculatePID_080016b4"
        },
        "FUN_08004e48": {
            "renaming": {
                "FUN_08004e48": "handle_timer_interrupt_08004e48",
                "PTR_timer_handles_08004e58": "PTR_timer_handles",
                "TIM_HandleTypeDef": "TIMHandle",
                "HAL_TIM_IRQHandler": "handle_TIM_interrupt",
                "timer_handle": "current_timer_handle"
            },
            "code": "void handle_timer_interrupt_08004e48(void)\n{\n  TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef **)(PTR_timer_handles_08004e58_08004e58 + 8);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e48",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08004e48"
        },
        "FUN_0800074c": {
            "renaming": {
                "FUN_0800074c": "calculate_float_0800074c",
                "param_1": "sign_and_exponent",
                "param_2": "mantissa_high",
                "param_3": "mantissa_low",
                "param_4": "sign_and_exponent_other",
                "uVar1": "temp_1",
                "uVar2": "temp_2",
                "uVar3": "temp_3",
                "uVar4": "temp_4",
                "uVar5": "temp_5",
                "uVar6": "temp_6",
                "uVar7": "sign_and_exponent_result",
                "iVar8": "exponent_diff",
                "uVar9": "exponent_sum",
                "unaff_r5": "sign_and_exponent_other_result",
                "uVar10": "mantissa_high_result",
                "uVar11": "mantissa_low_result",
                "uVar12": "mantissa_diff",
                "uVar13": "mantissa_mask",
                "bVar14": "condition_1",
                "bVar15": "condition_2",
                "bVar16": "condition_3"
            },
            "code": "\nulonglong calculate_float_0800074c(undefined4 sign_and_exponent,uint mantissa_high,uint mantissa_low,uint sign_and_exponent_other)\n\n{\n  uint temp_1;\n  uint temp_2;\n  uint temp_3;\n  uint temp_4;\n  uint temp_5;\n  uint temp_6;\n  uint sign_and_exponent_result;\n  int exponent_diff;\n  uint exponent_sum;\n  uint sign_and_exponent_other_result;\n  uint mantissa_high_result;\n  uint mantissa_low_result;\n  uint mantissa_diff;\n  uint mantissa_mask;\n  bool condition_1;\n  bool condition_2;\n  bool condition_3;\n  ulonglong temp_17;\n  \n  temp_17 = CONCAT44(mantissa_high,sign_and_exponent);\n  mantissa_mask = 0x7ff;\n  sign_and_exponent_result = mantissa_high >> 0x14 & 0x7ff;\n  condition_1 = sign_and_exponent_result == 0;\n  if (!condition_1) {\n    sign_and_exponent_other_result = sign_and_exponent_other >> 0x14 & 0x7ff;\n    condition_1 = sign_and_exponent_other_result == 0;\n  }\n  if (!condition_1) {\n    condition_1 = sign_and_exponent_result == 0x7ff;\n  }\n  if (!condition_1) {\n    condition_1 = sign_and_exponent_other_result == 0x7ff;\n  }\n  if (condition_1) {\n    temp_17 = convert_float_to_int_bits_080008ba();\n  }\n  exponent_sum = (uint)(temp_17 >> 0x20);\n  mantissa_low_result = (uint)temp_17;\n  exponent_diff = sign_and_exponent_result - sign_and_exponent_other_result;\n  if ((mantissa_low | sign_and_exponent_other << 0xc) == 0) {\n    sign_and_exponent_result = (exponent_sum ^ sign_and_exponent_other) & 0x80000000 | exponent_sum & 0xfffff;\n    condition_3 = SCARRY4(exponent_diff,mantissa_mask >> 1);\n    exponent_sum = exponent_diff + (mantissa_mask >> 1);\n    condition_1 = (int)exponent_sum < 0;\n    condition_2 = exponent_sum == 0;\n    if (!condition_2 && condition_1 == condition_3) {\n      condition_3 = SBORROW4(mantissa_mask,exponent_sum);\n      condition_1 = (int)(mantissa_mask - exponent_sum) < 0;\n      condition_2 = mantissa_mask == exponent_sum;\n    }\n    if (!condition_2 && condition_1 == condition_3) {\n      sign_and_exponent_result = sign_and_exponent_result | exponent_sum * 0x100000;\n    }\n    if (!condition_2 && condition_1 == condition_3) {\n      return temp_17 & 0xffffffff | (ulonglong)sign_and_exponent_result << 0x20;\n    }\n    sign_and_exponent_result = sign_and_exponent_result | 0x100000;\n    mantissa_mask = 0;\n    condition_2 = SBORROW4(exponent_sum,1);\n    exponent_sum = exponent_sum - 1;\n    condition_1 = exponent_sum == 0;\n    temp_3 = exponent_sum;\n  }\n  else {\n    temp_3 = (sign_and_exponent_other << 0xc) >> 4 | 0x10000000 | mantissa_low >> 0x18;\n    mantissa_mask = mantissa_low << 8;\n    mantissa_high_result = (exponent_sum << 0xc) >> 4 | 0x10000000 | mantissa_low_result >> 0x18;\n    mantissa_low_result = mantissa_low_result * 0x100;\n    sign_and_exponent_result = (exponent_sum ^ sign_and_exponent_other) & 0x80000000;\n    condition_1 = temp_3 <= mantissa_high_result;\n    if (mantissa_high_result == temp_3) {\n      condition_1 = mantissa_mask <= mantissa_low_result;\n    }\n    exponent_diff = exponent_diff + (uint)condition_1;\n    exponent_sum = exponent_diff + 0x3fd;\n    if (condition_1 == false) {\n      temp_3 = temp_3 >> 1;\n      mantissa_mask = (uint)((mantissa_low >> 0x18 & 1) != 0) << 0x1f | mantissa_mask >> 1;\n    }\n    mantissa_diff = mantissa_low_result - mantissa_mask;\n    mantissa_high_result = (mantissa_high_result - temp_3) - (uint)(mantissa_low_result < mantissa_mask);\n    temp_4 = temp_3 >> 1;\n    temp_1 = (uint)((temp_3 & 1) != 0) << 0x1f | mantissa_mask >> 1;\n    mantissa_low_result = 0x100000;\n    temp_3 = 0x80000;\n    while( true ) {\n      condition_1 = temp_1 <= mantissa_diff;\n      if (temp_4 < mantissa_high_result || mantissa_high_result - temp_4 < (uint)condition_1) {\n        mantissa_diff = mantissa_diff - temp_1;\n        mantissa_low_result = mantissa_low_result | temp_3;\n        mantissa_high_result = (mantissa_high_result - temp_4) - (uint)!condition_1;\n      }\n      temp_5 = temp_4 >> 1;\n      temp_1 = (uint)((temp_4 & 1) != 0) << 0x1f | temp_1 >> 1;\n      condition_2 = temp_1 <= mantissa_diff;\n      condition_1 = mantissa_high_result - temp_5 < (uint)condition_2;\n      mantissa_mask = mantissa_high_result;\n      if (temp_5 < mantissa_high_result || condition_1) {\n        mantissa_diff = mantissa_diff - temp_1;\n        mantissa_mask = (mantissa_high_result - temp_5) - (uint)!condition_2;\n      }\n      if (temp_5 < mantissa_high_result || condition_1) {\n        mantissa_low_result = mantissa_low_result | temp_3 >> 1;\n      }\n      mantissa_high_result = temp_4 >> 2;\n      temp_2 = (uint)((temp_5 & 1) != 0) << 0x1f | temp_1 >> 1;\n      condition_2 = temp_2 <= mantissa_diff;\n      condition_1 = mantissa_mask - mantissa_high_result < (uint)condition_2;\n      temp_5 = mantissa_mask;\n      if (mantissa_high_result < mantissa_mask || condition_1) {\n        mantissa_diff = mantissa_diff - temp_2;\n        temp_5 = (mantissa_mask - mantissa_high_result) - (uint)!condition_2;\n      }\n      if (mantissa_high_result < mantissa_mask || condition_1) {\n        mantissa_low_result = mantissa_low_result | temp_3 >> 2;\n      }\n      temp_6 = temp_4 >> 3;\n      temp_1 = (uint)((mantissa_high_result & 1) != 0) << 0x1f | temp_2 >> 1;\n      condition_2 = temp_1 <= mantissa_diff;\n      condition_1 = temp_5 - temp_6 < (uint)condition_2;\n      mantissa_high_result = temp_5;\n      if (temp_6 < temp_5 || condition_1) {\n        mantissa_diff = mantissa_diff - temp_1;\n        mantissa_high_result = (temp_5 - temp_6) - (uint)!condition_2;\n      }\n      if (temp_6 < temp_5 || condition_1) {\n        mantissa_low_result = mantissa_low_result | temp_3 >> 3;\n      }\n      mantissa_mask = mantissa_high_result | mantissa_diff;\n      if (mantissa_mask == 0) break;\n      mantissa_high_result = mantissa_high_result << 4 | mantissa_diff >> 0x1c;\n      mantissa_diff = mantissa_diff << 4;\n      temp_4 = temp_4 & 0xfffffff8 | temp_1 >> 0x1d;\n      temp_1 = (temp_2 >> 1) << 3;\n      temp_3 = temp_3 >> 4;\n      if (temp_3 == 0) {\n        temp_6 = temp_4;\n        if ((sign_and_exponent_result & 0x100000) != 0) goto LAB_0800086a;\n        sign_and_exponent_result = sign_and_exponent_result | mantissa_low_result;\n        mantissa_low_result = 0;\n        temp_3 = 0x80000000;\n      }\n    }\n    if ((sign_and_exponent_result & 0x100000) == 0) {\n      sign_and_exponent_result = sign_and_exponent_result | mantissa_low_result;\n      mantissa_low_result = 0;\n    }\nLAB_0800086a:\n    condition_3 = 0xfc < exponent_sum;\n    condition_2 = SBORROW4(exponent_sum,0xfd);\n    temp_4 = exponent_diff + 0x300;\n    condition_1 = temp_4 == 0;\n    temp_3 = temp_4;\n    if (condition_3 && !condition_1) {\n      condition_3 = 0x6ff < temp_4;\n      condition_2 = SBORROW4(temp_4,0x700);\n      temp_3 = exponent_diff - 0x400;\n      condition_1 = temp_4 == 0x700;\n    }\n    if (!condition_3 || condition_1) {\n      condition_1 = temp_6 <= mantissa_high_result;\n      if (mantissa_high_result == temp_6) {\n        condition_1 = temp_1 <= mantissa_diff;\n      }\n      if (mantissa_high_result == temp_6 && mantissa_diff == temp_1) {\n        condition_1 = (mantissa_low_result & 1) != 0;\n      }\n      return CONCAT44(sign_and_exponent_result + exponent_sum * 0x100000 + (uint)CARRY4(mantissa_low_result,(uint)condition_1),mantissa_low_result + condition_1);\n    }\n  }\n  if (!condition_1 && (int)temp_3 < 0 == condition_2) {\n    return (ulonglong)(sign_and_exponent_result & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  condition_3 = SCARRY4(exponent_sum,0x36);\n  condition_1 = (int)(exponent_sum + 0x36) < 0;\n  condition_2 = exponent_sum == 0xffffffca;\n  if (condition_2 || condition_1 != condition_3) {\n    mantissa_low_result = 0;\n  }\n  if (condition_2 || condition_1 != condition_3) {\n    sign_and_exponent_result = sign_and_exponent_result & 0x80000000;\n  }\n  if (condition_2 || condition_1 != condition_3) {\n    return CONCAT44(sign_and_exponent_result,mantissa_low_result);\n  }\n  temp_3 = -exponent_sum;\n  mantissa_high_result = temp_3 - 0x20;\n  if (0x1f < (int)temp_3) {\n    temp_3 = mantissa_low_result >> (mantissa_high_result & 0xff) | sign_and_exponent_result << (0x20 - mantissa_high_result & 0xff);\n    exponent_sum = (sign_and_exponent_result >> (mantissa_high_result & 0xff) & ~((sign_and_exponent_result & 0x80000000) >> (mantissa_high_result & 0xff))) -\n            ((int)temp_3 >> 0x1f);\n    if ((mantissa_mask | mantissa_low_result << (0x20 - mantissa_high_result & 0xff) | temp_3 << 1) == 0) {\n      exponent_sum = exponent_sum & ~(temp_3 >> 0x1f);\n    }\n    return CONCAT44(sign_and_exponent_result,exponent_sum) & 0x80000000ffffffff;\n  }\n  exponent_diff = temp_3 - 0x14;\n  if (exponent_diff != 0 && exponent_diff < 0 == SCARRY4(mantissa_high_result,0xc)) {\n    exponent_sum = 0xc - exponent_diff;\n    temp_3 = mantissa_low_result << (exponent_sum & 0xff);\n    mantissa_low_result = mantissa_low_result >> (0x20 - exponent_sum & 0xff) | sign_and_exponent_result << (exponent_sum & 0xff);\n    exponent_sum = mantissa_low_result + -((int)temp_3 >> 0x1f);\n    if ((mantissa_mask | temp_3 << 1) == 0) {\n      exponent_sum = exponent_sum & ~(temp_3 >> 0x1f);\n    }\n    return CONCAT44((sign_and_exponent_result & 0x80000000) + (uint)CARRY4(mantissa_low_result,-((int)temp_3 >> 0x1f)),exponent_sum);\n  }\n  mantissa_high_result = mantissa_low_result << (exponent_sum + 0x20 & 0xff);\n  mantissa_low_result = mantissa_low_result >> (temp_3 & 0xff) | sign_and_exponent_result << (exponent_sum + 0x20 & 0xff);\n  exponent_sum = mantissa_low_result + -((int)mantissa_high_result >> 0x1f);\n  if ((mantissa_mask | mantissa_high_result << 1) == 0) {\n    exponent_sum = exponent_sum & ~(mantissa_high_result >> 0x1f);\n  }\n  return CONCAT44((sign_and_exponent_result & 0x80000000) +\n                  ((sign_and_exponent_result & 0x7fffffff) >> (temp_3 & 0xff)) +\n                  (uint)CARRY4(mantissa_low_result,-((int)mantissa_high_result >> 0x1f)),exponent_sum);\n}\n\n",
            "called": [
                "FUN_080008ba"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800074c",
            "calling": [
                "SetSampleTime",
                "printFloat",
                "readThermocouple",
                "SetTunings"
            ],
            "imported": false,
            "current_name": "calculate_float_0800074c"
        },
        "FUN_080018f8": {
            "renaming": {
                "PID::FUN_080018f8": "calculatePID",
                "this": "pid",
                "Kp": "Kp",
                "Ki": "Ki",
                "Kd": "Kd",
                "in_stack_ffffffec": "pOn",
                "this->pOn": "pid->pOn",
                "FUN_080018f8": "calculatePID_080018f8"
            },
            "code": "void calculatePID_080018f8(PID *pid, double Kp, double Ki, double Kd)\n{\n  double pOn = pid->pOn;\n  double modified_Ki = Ki * pOn;\n  double modified_Kd = Kd / pOn;\n  calculatePID_080018f8(pid, Kp, modified_Ki, modified_Kd, pOn);\n  return;\n}",
            "called": [
                "SetTunings"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080018f8",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "calculatePID_080018f8"
        },
        "FUN_08005890": {
            "renaming": {
                "FUN_08005890": "read_digital_pin_08005890",
                "ulPin": "pin",
                "_Var1": "is_pin_configured",
                "port": "port",
                "uVar2": "read_value",
                "uVar3": "digital_pin",
                "PTR_digitalPin_080058d8": "PTR_digital_pin_array",
                "PTR_g_digPinConfigured_080058dc": "PTR_pin_config_array"
            },
            "code": "int read_digital_pin_08005890(uint32_t pin)\n{\n  _Bool is_pin_configured;\n  GPIO_TypeDef *port;\n  uint32_t digital_pin;\n  uint read_value;\n  \n  if (pin < 0x3c) {\n    digital_pin = (uint)(char)PTR_digitalPin_080058d8[pin];\n  }\n  else {\n    digital_pin = 0xffffffff;\n  }\n  if (digital_pin == 0xffffffff) {\n    read_value = 0;\n  }\n  else {\n    is_pin_configured = is_pin_configured((PinName_conflict)digital_pin, (uint32_t *)PTR_g_digPinConfigured_080058dc);\n    if (is_pin_configured) {\n      port = get_GPIO_Port((digital_pin << 0x18) >> 0x1c);\n      read_value = digital_io_read(port,1 << (digital_pin & 0xf) & 0xffff);\n      read_value = read_value & 0xff;\n    }\n    else {\n      read_value = 0;\n    }\n  }\n  if (read_value != 0) {\n    read_value = 1;\n  }\n  return read_value;\n}",
            "called": [
                "is_pin_configured",
                "get_GPIO_Port",
                "digital_io_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005890",
            "calling": [
                "readData",
                "loop"
            ],
            "imported": false,
            "current_name": "read_digital_pin_08005890"
        },
        "FUN_08005da0": {
            "renaming": {
                "FUN_08005da0": "print_08005da0",
                "this": "print_obj",
                "b": "character",
                "base": "base",
                "sVar1": "result"
            },
            "code": "size_t __thiscall Print::print_08005da0(Print *print_08005da0_obj, uchar character, int base) {\n  size_t result = print_08005da0(print_08005da0_obj, (uint)character, base);\n  return result;\n}",
            "called": [
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005da0",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "print_08005da0"
        },
        "FUN_08004cb2": {
            "renaming": {
                "FUN_08004cb2": "find_pin_function_08004cb2",
                "pin": "target_pin",
                "map": "pin_map"
            },
            "code": "uint32_t find_pin_function_08004cb2(PinName_conflict pin, PinMap_conflict *pin_map) { \n    while (true) {\n        if (pin_map->pin == NC) {\n            return 0xffffffff;\n        }\n        if (pin_map->pin == pin) {\n            break;\n        }\n        pin_map += 1;\n    }\n    return pin_map->function;\n}",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004cb2",
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "imported": false,
            "current_name": "find_pin_function_08004cb2"
        },
        "FUN_08004ef4": {
            "renaming": {
                "FUN_08004ef4": "enable_i2c_listen_mode_08004ef4",
                "*hi2c": "*i2c_handler",
                "piVar1": "i2c_object",
                "get_i2c_obj": "get_i2c_object",
                "isMaster": "is_master"
            },
            "code": "void enable_i2c_listen_mode_08004ef4(I2C_HandleTypeDef *i2c_handler)\\n{\\n  i2c_t *i2c_object = get_i2c_object(i2c_handler);\\n  if (i2c_object->is_master == \"\\0\") {\\n    HAL_I2C_EnableListen_IT(i2c_handler);\\n  }\\n  return;\\n}",
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ef4",
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "imported": false,
            "current_name": "enable_i2c_listen_mode_08004ef4"
        },
        "FUN_08001294": {
            "renaming": {
                "FUN_08001294": "set_row_offsets_08001294",
                "this": "lcd",
                "row0": "row_offset_0",
                "row1": "row_offset_1",
                "row2": "row_offset_2",
                "row3": "row_offset_3",
                "_row_offsets": "row_offsets"
            },
            "code": "void __thiscall set_row_offsets_08001294(LiquidCrystal *lcd, int row_offset_0, int row_offset_1, int row_offset_2, int row_offset_3) {\n  lcd->row_offsets[0] = (uint8_t)row_offset_0;\n  lcd->row_offsets[1] = (uint8_t)row_offset_1;\n  lcd->row_offsets[2] = (uint8_t)row_offset_2;\n  lcd->row_offsets[3] = (uint8_t)row_offset_3;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001294",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "set_row_offsets_08001294"
        },
        "FUN_08002384": {
            "renaming": {
                "FUN_08002384": "halt_on_adc_conversion_error_08002384",
                "hadc": "adc_handle",
                "HVar1": "status",
                "uVar2": "clock_freq",
                "uVar3": "current_time",
                "pAVar4": "adc_instance",
                "uVar5": "unused_var",
                "wait_loop_index": "wait_loop_index"
            },
            "code": "HAL_StatusTypeDef_conflict halt_on_adc_conversion_error_08002384(ADC_HandleTypeDef *adc_handle)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t clock_freq, wait_loop_index;\n  ADC_TypeDef *adc_instance;\n\n  if (adc_handle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  adc_handle->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(adc_handle);\n  if (status == HAL_OK) {\n    adc_handle->State = (adc_handle->State & 0xffffeefd) | 2;\n    clock_freq = *(uint32_t *)PTR_SystemCoreClock_0800246c;\n    clock_freq = HAL_RCCEx_GetPeriphCLKFreq(2);\n    wait_loop_index = clock_freq / clock_freq << 1;\n    while (wait_loop_index != 0) {\n        wait_loop_index--;\n    }\n    ADC_Enable(adc_handle);\n    adc_instance = adc_handle->Instance;\n    adc_instance->CR2 |= 8;\n    uint32_t start_time = HAL_GetTick();\n    while ((adc_instance->CR2 & 8) != 0) {\n        uint32_t current_time = HAL_GetTick();\n        if (10 < current_time - start_time) {\n            adc_handle->State = (adc_handle->State & 0xffffffed) | 0x10;\n            adc_handle->Lock = HAL_UNLOCKED;\n            return HAL_ERROR;\n        }\n    }\n    adc_instance->CR2 |= 4;\n    start_time = HAL_GetTick();\n    while ((adc_instance->CR2 & 4) != 0) {\n        uint32_t current_time = HAL_GetTick();\n        if (10 < current_time - start_time) {\n            adc_handle->State = (adc_handle->State & 0xffffffed) | 0x10;\n            adc_handle->Lock = HAL_UNLOCKED;\n            return HAL_ERROR;\n        }\n    }\n    adc_handle->State = (adc_handle->State & 0xfffffffc) | 1;\n  }\n  adc_handle->Lock = HAL_UNLOCKED;\n  return status;\n}",
            "called": [
                "ADC_ConversionStop_Disable",
                "ADC_Enable",
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002384",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "halt_on_adc_conversion_error_08002384"
        },
        "FUN_08005650": {
            "renaming": {
                "FUN_08005650": "initialize_uart_08005650",
                "huart": "uart_handler",
                "tmpval": "temp_value"
            },
            "code": "void initialize_uart_08005650(UART_HandleTypeDef *uart_handler)\n{\n  uint32_t temp_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005650",
            "calling": [
                "HAL_UART_IRQHandler",
                "UART_DMAAbortOnError"
            ],
            "imported": false,
            "current_name": "initialize_uart_08005650"
        },
        "FUN_08006fb6": {
            "renaming": {
                "FUN_08006fb6": "close_file_descriptor_08006fb6",
                "param_1": "file_descriptor",
                "param_2": "short_offset"
            },
            "code": "void close_file_descriptor_08006fb6(int file_descriptor, int short_offset) {\n  _close_r(file_descriptor, (int)*(short *)(short_offset + 0xe));\n  return;\n}",
            "called": [
                "_close_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006fb6",
            "calling": [],
            "imported": false,
            "current_name": "close_file_descriptor_08006fb6"
        },
        "FUN_08002ad8": {
            "renaming": {
                "FUN_08002ad8": "transfer_byte_08002ad8",
                "*hi2c": "*i2c_handle",
                "puVar1": "buff_ptr",
                "hi2c->XferCount": "i2c_handle->XferCount",
                "hi2c->pBuffPtr": "i2c_handle->pBuffPtr",
                "hi2c->Instance->DR": "i2c_handle->Instance->DR"
            },
            "code": "HAL_StatusTypeDef transfer_byte_08002ad8(I2C_HandleTypeDef *i2c_handle)\n{\n  uint8_t *buff_ptr;\n  if (i2c_handle->XferCount != 0) {\n    buff_ptr = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = buff_ptr + 1;\n    *buff_ptr = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->XferCount--;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ad8",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "transfer_byte_08002ad8"
        },
        "FUN_08004204": {
            "renaming": {
                "FUN_08004204": "configure_uart_08004204",
                "huart": "uart_handle",
                "Instance": "uart_instance",
                "Init": "uart_init",
                "StopBits": "stop_bits",
                "WordLength": "word_length",
                "Parity": "parity",
                "Mode": "mode",
                "HwFlowCtl": "hw_flow_control",
                "USART_TypeDef": "uart_typedef",
                "DAT_080043ac": "USART1",
                "DAT_080043b0": "16"
            },
            "code": "void configure_uart_08004204(UART_HandleTypeDef *huart)\n{\n  uint32_t pclk_freq;\n  uint32_t baud_rate;\n  uint32_t mantissa;\n  uint32_t fraction;\n  USART_TypeDef *uart_instance;\n  \n  // Configure UART stop bits\n  huart->Instance->CR2 = (huart->Instance->CR2 & 0xffffcfff) | (huart->Init).StopBits;\n  \n  // Configure UART word length, parity, and mode\n  huart->Instance->CR1 = (huart->Init).WordLength | (huart->Init).Parity | (huart->Init).Mode | (huart->Instance->CR1 & 0xffffe9f3);\n  \n  // Configure UART hardware flow control\n  huart->Instance->CR3 = (huart->Instance->CR3 & 0xfffffcff) | (huart->Init).HwFlowCtl;\n  \n  // Calculate UART baud rate\n  uart_instance = huart->Instance;\n  if (uart_instance != DAT_080043ac) {\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n  } else {\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n  }\n  baud_rate = (huart->Init).BaudRate;\n  mantissa = ((pclk_freq * 2) + baud_rate) / (baud_rate * 4);\n  fraction = ((pclk_freq * 2) + baud_rate - (mantissa * baud_rate * 4)) / (baud_rate * 4 / DAT_080043b0);\n  uart_instance->BRR = (mantissa << 4) | fraction;\n}\n",
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004204",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "configure_uart_08004204"
        },
        "FUN_08005da8": {
            "renaming": {
                "FUN_08005da8": "print_double_08005da8",
                "this": "printer",
                "number": "number",
                "digits": "digits",
                "iVar1": "is_nan",
                "n": "integer_part",
                "sVar2": "digits_printed",
                "sVar3": "digits_printed",
                "bVar4": "digit",
                "lVar5": "fractional_part",
                "uVar6": "fractional_part",
                "uVar7": "fractional_part"
            },
            "code": "size_t print_double_08005da8(Print *printer, double number, uint8_t digits) {\n  int is_nan = isnan(number);\n  if (is_nan) {\n    return print(printer, \"NaN\");\n  }\n  int is_inf = isinf(number);\n  if (is_inf) {\n    if (number > 0) {\n      return print(printer, \"Inf\");\n    } else {\n      return print(printer, \"-Inf\");\n    }\n  }\n  if (number == 0) {\n    return print(printer, '0');\n  }\n  int is_negative = number < 0;\n  if (is_negative) {\n    number = -number;\n    print(printer, '-');\n  }\n  int integer_part = (int)number;\n  double fractional_part = number - integer_part;\n  size_t digits_printed = print(printer, integer_part);\n  if (digits > 0) {\n    print(printer, '.');\n    for (uint8_t i = 0; i < digits; i++) {\n      fractional_part *= 10;\n      int digit = (int)fractional_part;\n      digits_printed += print(printer, digit);\n      fractional_part -= digit;\n    }\n  }\n  return digits_printed;\n}",
            "called": [
                "__unorddf2",
                "__aeabi_dadd",
                "print",
                "__floatsidf",
                "print",
                "__divdf3",
                "print",
                "__subdf3",
                "__aeabi_dcmplt",
                "__fixunsdfsi",
                "__fixdfsi",
                "__muldf3",
                "__floatunsidf",
                "__aeabi_dcmpgt",
                "print",
                "__aeabi_dcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005da8",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "print_double_08005da8"
        },
        "FUN_080045fe": {
            "renaming": {
                "FUN_080045fe": "set_uart_to_ready_state_080045fe",
                "*huart": "*uart_handler",
                "Instance": "uart_instance",
                "CR1": "control_register_1",
                "gState": "global_state",
                "HAL_UART_TxCpltCallback": "transmission_complete_callback",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "HAL_StatusTypeDef set_uart_to_ready_state_080045fe(UART_HandleTypeDef *huart)\n{\n  huart->Instance->CR1 &= ~(1 << 6);\n  huart->gState = HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(huart);\n  return HAL_OK;\n}",
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045fe",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_uart_to_ready_state_080045fe"
        },
        "FUN_08005f2c": {
            "renaming": {
                "FUN_08005f2c": "print_double_with_precision_08005f2c",
                "this": "printer",
                "n": "number",
                "digits": "precision",
                "sVar1": "result",
                "in_stack_fffffff4": "integer_part",
                "FUN_08005f2cFloat": "print_float_with_precision"
            },
            "code": "size_t print_double_with_precision_08005f2c(Print *printer,double number,int precision)\n{\n  size_t result;\n  uint32_t integer_part = (uint32_t)number;\n  double fractional_part = number - integer_part;\n\n  // Printing integer part\n  result = printer->print(integer_part);\n\n  // Printing decimal point\n  result += printer->print('.');\n\n  // Printing fractional part\n  for (int i = 0; i < precision; i++) {\n    fractional_part *= 10;\n    uint8_t digit = (uint8_t)fractional_part;\n    result += printer->print(digit);\n    fractional_part -= digit;\n  }\n\n  return result;\n}",
            "called": [
                "printFloat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005f2c",
            "calling": [
                "loop",
                "println"
            ],
            "imported": false,
            "current_name": "print_double_with_precision_08005f2c"
        },
        "FUN_080055e0": {
            "renaming": {
                "FUN_080055e0": "process_uart_data_080055e0",
                "huart": "uart_handle",
                "bVar1": "uart_index_value",
                "uVar2": "callback_pointer",
                "PTR_rx_callback_080055fc": "callback_pointer_base",
                "PTR_rx_callback_obj_08005600": "callback_object_pointer_base",
                "code": "callback_function_pointer",
                "*(code **)(PTR_rx_callback_080055fc + uVar2 * 4)": "callback_function_pointer",
                "*(undefined4 *)(PTR_rx_callback_obj_08005600 + uVar2 * 4)": "callback_object_pointer",
                "uVar2 < 5": "uart_index_value < 5"
            },
            "code": "void process_uart_data_080055e0(UART_HandleTypeDef *huart) {\n  uint8_t uart_index_value = uart_index(huart);\n  uint32_t callback_pointer = PTR_rx_callback_080055fc + uart_index_value * 4;\n  uint32_t callback_obj_pointer = PTR_rx_callback_obj_08005600 + uart_index_value * 4;\n  if (uart_index_value < 5) {\n    code* *(code **)(PTR_rx_callback_080055fc + uVar2 * 4) = *(code**)callback_pointer;\n    *(code **)(PTR_rx_callback_080055fc + uVar2 * 4)(*(uint32_t*)callback_obj_pointer);\n  }\n  return;\n}",
            "called": [
                "uart_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080055e0",
            "calling": [
                "UART_Receive_IT"
            ],
            "imported": false,
            "current_name": "process_uart_data_080055e0"
        },
        "FUN_08005f40": {
            "renaming": {
                "FUN_08005f40": "08005f40_08005f40",
                "this": "printer",
                "num": "num",
                "digits": "precision",
                "sVar1": "num_bytes_printed",
                "sVar2": "additional_bytes",
                "in_stack_ffffffec": "shifted_precision",
                "print": "print"
            },
            "code": "size_t 08005f40_08005f40(Print *printer, double num, int precision) {\n    size_t num_bytes_printed;\n    uint64_t masked_num = ((uint64_t) num) & 0xffffffff;\n    uint64_t shifted_precision = ((uint64_t) precision) << 0x20;\n    masked_num |= shifted_precision;\n    num_bytes_printed = print(printer, masked_num, num._0_4_);\n    size_t additional_bytes = 08005f40_08005f40(printer);\n    return additional_bytes + num_bytes_printed;\n}",
            "called": [
                "print",
                "println"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005f40",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "08005f40_08005f40"
        },
        "FUN_08006f10": {
            "renaming": {
                "FUN_08006f10": "kill_process_and_set_errno_08006f10",
                "param_1": "errno_ptr",
                "param_2": "process_id",
                "param_3": "signal_num",
                "puVar1": "original_errno_ptr",
                "iVar2": "kill_result"
            },
            "code": "void kill_process_and_set_errno_08006f10(int *errno_ptr, int process_id, int signal_num)\n{\n  int kill_result;\n  int *original_errno_ptr;\n  original_errno_ptr = PTR_errno_08006f30;\n  *(int *)PTR_errno_08006f30 = 0;\n  kill_result = _kill(process_id, signal_num);\n  if ((kill_result == -1) && (*(int *)original_errno_ptr != 0)) {\n    *errno_ptr = *(int *)original_errno_ptr;\n  }\n  return;\n}",
            "called": [
                "_kill"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006f10",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "kill_process_and_set_errno_08006f10"
        },
        "FUN_0800213c": {
            "renaming": {
                "FUN_0800213c": "configure_ADC_0800213c",
                "hadc": "adc_handle",
                "HVar1": "status",
                "uVar2": "uVar2",
                "uVar3": "uVar3",
                "uVar4": "uVar4",
                "uVar5": "uVar5",
                "state": "state",
                "continuousConvMode": "continuous_conv_mode",
                "nbrOfDiscConversion": "nbr_of_disc_conversion",
                "nbrOfConversion": "nbr_of_conversion",
                "dataAlign": "data_align",
                "externalTrigConv": "external_trig_conv",
                "scanConvMode": "scan_conv_mode",
                "config1": "config1",
                "config2": "config2",
                "sqr1": "sqr1"
            },
            "code": "HAL_StatusTypeDef_conflict configure_ADC_0800213c(ADC_HandleTypeDef *adc_handle)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t state;\n  uint32_t config1;\n  uint32_t config2;\n  uint32_t sqr1;\n  uint32_t continuous_conv_mode;\n  uint32_t nbr_of_disc_conversion;\n  uint32_t nbr_of_conversion;\n  uint32_t data_align;\n  uint32_t external_trig_conv;\n  uint32_t scan_conv_mode;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint32_t uVar5;\n\n  if (adc_handle == NULL) {\n    return HAL_ERROR;\n  }\n  if (adc_handle->State == 0) {\n    adc_handle->ErrorCode = 0;\n    adc_handle->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(adc_handle);\n  }\n  status = ADC_ConversionStop_Disable(adc_handle);\n  state = adc_handle->State & 0x10;\n  if ((state == 0) && (status == HAL_OK)) {\n    adc_handle->State = adc_handle->State & 0xffffeefd | 2;\n    continuous_conv_mode = (adc_handle->Init).ContinuousConvMode;\n    data_align = (adc_handle->Init).DataAlign;\n    external_trig_conv = (adc_handle->Init).ExternalTrigConv;\n    uVar5 = continuous_conv_mode << 1;\n    uVar3 = data_align | external_trig_conv | uVar5;\n    scan_conv_mode = (adc_handle->Init).ScanConvMode;\n    if (scan_conv_mode == 0x100 || scan_conv_mode == 1) {\n      nbr_of_conversion = (adc_handle->Init).NbrOfConversion - 1;\n      uVar4 = nbr_of_conversion * 0x100000;\n    }\n    else {\n      uVar4 = 0;\n    }\n    if ((adc_handle->Init).DiscontinuousConvMode == 1) {\n      if (continuous_conv_mode == 0) {\n        nbr_of_disc_conversion = (adc_handle->Init).NbrOfDiscConversion - 1;\n        uVar4 = uVar4 | nbr_of_disc_conversion * 0x2000 | 0x800;\n      }\n      else {\n        adc_handle->State = adc_handle->State | 0x20;\n        adc_handle->ErrorCode = adc_handle->ErrorCode | 1;\n      }\n    }\n    config1 = uVar4 | adc_handle->Instance->CR1 & 0xffff16ff;\n    config2 = (adc_handle->Init).DMAContinuousRequests | (adc_handle->Init).EOCSelection;\n    config2 = config2 | (adc_handle->Init).NbrOfDiscConversion << 13;\n    sqr1 = adc_handle->Instance->SQR1 & 0xff0fffff | uVar4;\n    if (uVar3 != (adc_handle->Instance->CR2 & 0x1c0000 | (adc_handle->Init).ExtTrigger)) {\n      adc_handle->State = adc_handle->State & 0xffffffed | 0x10;\n      adc_handle->ErrorCode = adc_handle->ErrorCode | 1;\n      return HAL_ERROR;\n    }\n    adc_handle->Instance->CR1 = config1;\n    adc_handle->Instance->CR2 = config2 | adc_handle->Instance->CR2 & 0xfffffff0;\n    adc_handle->Instance->SQR1 = sqr1;\n    adc_handle->ErrorCode = 0;\n    adc_handle->State = adc_handle->State & 0xfffffffc | 1;\n    return HAL_OK;\n  }\n  adc_handle->State = adc_handle->State | 0x10;\n  return HAL_ERROR;\n}",
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800213c",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "configure_ADC_0800213c"
        },
        "FUN_0800455a": {
            "renaming": {
                "FUN_0800455a": "check_uart_ready_and_transmit_0800455a",
                "*huart": "*huart",
                "*pData": "*data",
                "Size": "size",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_BUSY": "HAL_BUSY",
                "uint8_t": "uint8_t",
                "NULL": "NULL",
                "HAL_ERROR": "HAL_ERROR",
                "huart->pTxBuffPtr": "huart->pTxBuffPtr",
                "huart->TxXferSize": "huart->TxXferSize",
                "huart->TxXferCount": "huart->TxXferCount",
                "huart->ErrorCode": "huart->ErrorCode",
                "HAL_UART_STATE_BUSY_TX": "HAL_UART_STATE_BUSY_TX",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "huart->Instance->CR1": "huart->Instance->CR1",
                "|=": "|=",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef check_uart_ready_and_transmit_0800455a(UART_HandleTypeDef *huart, uint8_t *data, uint16_t size)\n{\n    if (huart->gState != HAL_UART_STATE_READY) {\n        return HAL_BUSY;\n    }\n    if (data == NULL) {\n        return HAL_ERROR;\n    }\n    if (size == 0) {\n        return HAL_ERROR;\n    }\n    if (huart->Lock != HAL_LOCKED) {\n        huart->pTxBuffPtr = data;\n        huart->TxXferSize = size;\n        huart->TxXferCount = size;\n        huart->ErrorCode = 0;\n        huart->gState = HAL_UART_STATE_BUSY_TX;\n        huart->Lock = HAL_UNLOCKED;\n        huart->Instance->CR1 |= 0x80;\n        return HAL_OK;\n    }\n    return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800455a",
            "calling": [
                "HAL_UART_TxCpltCallback",
                "uart_attach_tx_callback"
            ],
            "imported": false,
            "current_name": "check_uart_ready_and_transmit_0800455a"
        },
        "FUN_08004d30": {
            "renaming": {
                "FUN_08004d30": "handle_rtc_alarm_08004d30",
                "PTR_RtcHandle_08004d3c": "rtc_handle",
                "HAL_RTC_AlarmIRQHandler": "handle_rtc_alarm_irq"
            },
            "code": "void handle_rtc_alarm_08004d30(void)\n{\n  RTC_HandleTypeDef* PTR_RtcHandle_08004d3c = (RTC_HandleTypeDef*)PTR_RtcHandle_08004d3c;\n  HAL_RTC_AlarmIRQHandler(PTR_RtcHandle_08004d3c);\n  return;\n}",
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d30",
            "calling": [],
            "imported": false,
            "current_name": "handle_rtc_alarm_08004d30"
        },
        "FUN_08001a66": {
            "renaming": {
                "FUN_08001a66": "update_controller_parameters_08001a66",
                "this": "controller",
                "Direction": "new_direction",
                "dVar1": "new_value",
                "kp": "proportional_gain",
                "ki": "integral_gain",
                "kd": "derivative_gain",
                "inAuto": "in_auto",
                "controllerDirection": "controller_direction"
            },
            "code": "void __thiscall update_controller_parameters_08001a66(PID *controller, int new_direction)\n{\n    double new_kp, new_ki, new_kd;\n    if ((controller->in_auto != false) && (controller->controller_direction != new_direction)) {\n        new_kp = -controller->kp;\n        new_ki = -controller->ki;\n        new_kd = -controller->kd;\n        controller->kp = new_kp;\n        controller->ki = new_ki;\n        controller->kd = new_kd;\n    }\n    controller->controller_direction = new_direction;\n    return;\n}",
            "called": [
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001a66",
            "calling": [
                "PID"
            ],
            "imported": false,
            "current_name": "update_controller_parameters_08001a66"
        },
        "FUN_08003c44": {
            "renaming": {
                "FUN_08003c44": "getSystemCoreClock_08003c44",
                "PTR_SystemCoreClock_08003c4c": "systemCoreClockPtr"
            },
            "code": "uint32_t getSystemCoreClock_08003c44(void)\n{\n  uint32_t* PTR_SystemCoreClock_08003c4c = (uint32_t*)PTR_SystemCoreClock_08003c4c;\n  return *PTR_SystemCoreClock_08003c4c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003c44",
            "calling": [
                "SystemClock_Config",
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "imported": false,
            "current_name": "getSystemCoreClock_08003c44"
        },
        "FUN_08006074": {
            "renaming": {
                "FUN_08006074": "handle_external_interrupt_08006074"
            },
            "code": "void handle_external_interrupt_08006074(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006074",
            "calling": [],
            "imported": false,
            "current_name": "handle_external_interrupt_08006074"
        },
        "FUN_080028d2": {
            "renaming": {
                "FUN_080028d2": "configureI2CDeviceAddress_080028d2",
                "*hi2c": "*i2c_handler",
                "hi2c": "i2c_handler",
                "Devaddress": "device_address",
                "& 0xff": " & 0xFF",
                "Instance": "i2c_handler->Instance",
                "DR": "i2c_handler->Instance->DR",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "HAL_StatusTypeDef configureI2CDeviceAddress_080028d2(I2C_HandleTypeDef *i2c_handler)\n{\n  uint8_t device_address = i2c_handler->Devaddress & 0xFF;\n  i2c_handler->Instance->DR = device_address;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080028d2",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "configureI2CDeviceAddress_080028d2"
        },
        "FUN_08000a18": {
            "renaming": {
                "FUN_08000a18": "is_end_of_string_08000a18",
                "in_CY": "current_char"
            },
            "code": "bool is_end_of_string_08000a18(void)\n{\n  char current_char;\n  __aeabi_cdrcmple();\n  return current_char == '\\0';\n}",
            "called": [
                "__aeabi_cdrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a18",
            "calling": [
                "SetOutputLimits",
                "Compute",
                "printFloat",
                "Initialize",
                "loop"
            ],
            "imported": false,
            "current_name": "is_end_of_string_08000a18"
        },
        "FUN_08005384": {
            "renaming": {
                "FUN_08005384": "initialize_uart_debug_08005384",
                "PinName_conflict pin": "PinName_conflict uart_tx_pin",
                "undefined *obj": "undefined *serial_debug_obj",
                "PinName_conflict PVar1": "PinName_conflict uart_rx_pin",
                "void *pvVar2": "void *peripheral",
                "PTR_digitalPin_080053c4": "digitalPin_1",
                "PTR_PinMap_UART_TX_080053c8": "PinMap_UART_TX",
                "PTR_PinMap_UART_RX_080053cc": "PinMap_UART_RX",
                "PTR_serial_debug_080053d0": "serial_debug"
            },
            "code": "void initialize_uart_debug_08005384(void)\n{\n  PinName_conflict uart_tx_pin = PTR_digitalPin_080053c4;\n  void *peripheral = pinmap_peripheral(uart_tx_pin, (PinMap_conflict *)PTR_PinMap_UART_TX_080053c8);\n  if (peripheral != (void *)0x0) {\n    PinName_conflict uart_rx_pin = pinmap_pin(peripheral, (PinMap_conflict *)PTR_PinMap_UART_RX_080053cc);\n    undefined *PTR_serial_debug_080053d0_obj = PTR_serial_debug_080053d0;\n    PTR_serial_debug_080053d0[0x59] = uart_rx_pin;\n    PTR_serial_debug_080053d0[0x58] = uart_tx_pin;\n    *(undefined4 *)(PTR_serial_debug_080053d0 + 0x48) = 0x2580;\n    *(undefined4 *)(PTR_serial_debug_080053d0 + 0x54) = 0;\n    *(undefined4 *)(PTR_serial_debug_080053d0 + 0x4c) = 0;\n    *(undefined4 *)(PTR_serial_debug_080053d0 + 0x50) = 0;\n    uart_init((serial_t *)PTR_serial_debug_080053d0_obj);\n  }\n  return;\n}",
            "called": [
                "pinmap_pin",
                "pinmap_peripheral",
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005384",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "initialize_uart_debug_08005384"
        },
        "FUN_08005b3c": {
            "renaming": {
                "__thiscall HardwareSerial::FUN_08005b3c": "setSerialPin",
                "this": "serial",
                "_tx": "tx_pin",
                "PVar1": "pin",
                "PTR_digitalPin_08005b50": "digitalPin",
                "FUN_08005b3c": "setSerialPin_08005b3c"
            },
            "code": "void __thiscall setSerialPin_08005b3c(HardwareSerial *serial, uint32_t tx_pin) {\n    PinName pin;\n    if (tx_pin < 0x3c) {\n        pin = PTR_digitalPin_08005b50[tx_pin];\n    }\n    else {\n        pin = NC;\n    }\n    (serial->_serial).pin_tx = pin;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b3c",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "setSerialPin_08005b3c"
        },
        "FUN_0800091c": {
            "renaming": {
                "FUN_0800091c": "compare_uints_0800091c",
                "param_1": "first_num",
                "param_2": "first_num_shifted",
                "param_3": "second_num",
                "param_4": "second_num_shifted",
                "uVar1": "xor_result",
                "bVar2": "is_first_num_zero",
                "bVar3": "is_second_num_less_than_or_equal_to_first_num"
            },
            "code": "uint compare_uints_0800091c(uint first_num, uint first_num_shifted, uint second_num, uint second_num_shifted)\n{\n  bool is_first_num_zero = (first_num | first_num_shifted << 1) == 0;\n  bool is_second_num_zero = (second_num | second_num_shifted << 1) == 0;\n  bool is_first_num_equal_second_num = first_num == second_num;\n  bool is_first_num_shifted_negative = (int)(first_num_shifted << 1) >> 0x15 == -1;\n  bool is_second_num_shifted_negative = (int)(second_num_shifted << 1) >> 0x15 == -1;\n\n  if ((is_first_num_shifted_negative || is_second_num_shifted_negative) && ((is_first_num_shifted_negative && !is_first_num_zero) || (is_second_num_shifted_negative && !is_second_num_zero))) {\n    return 0xffffffff;\n  }\n\n  if (!is_first_num_zero && !is_second_num_zero && !is_first_num_equal_second_num) {\n    uint xor_result = first_num_shifted ^ second_num_shifted;\n    bool is_xor_result_zero = xor_result == 0;\n    bool is_xor_result_positive = -1 < (int)xor_result;\n    bool is_second_num_less_than_or_equal_to_first_num = second_num <= first_num;\n    bool is_third_num_less_than_or_equal_to_fourth_num = second_num_less_than_or_equal_to_first_num ? false : true;\n    if (is_xor_result_zero) {\n      is_third_num_less_than_or_equal_to_fourth_num = third_num <= first_num;\n    }\n    uint result = (int)second_num_shifted >> 0x1f;\n    if (!is_third_num_less_than_or_equal_to_fourth_num) {\n      result = ~result;\n    }\n    return result | 1;\n  }\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800091c",
            "calling": [],
            "imported": false,
            "current_name": "compare_uints_0800091c"
        },
        "FUN_080046b8": {
            "renaming": {
                "FUN_080046b8": "uart_handler_080046b8",
                "huart": "uart",
                "HVar1": "status",
                "uVar2": "cr1",
                "pUVar3": "uart->Instance",
                "uVar4": "cr3",
                "uVar5": "sr"
            },
            "code": "void uart_handler_080046b8(UART_HandleTypeDef *uart)\n{\n    HAL_StatusTypeDef status;\n    uint32_t sr;\n    uint32_t cr1;\n    uint32_t cr3;\n\n    sr = uart->Instance->SR;\n    cr1 = uart->Instance->CR1;\n    cr3 = uart->Instance->CR3;\n\n    if ((sr & USART_SR_RXNE) && (cr1 & USART_CR1_RXNEIE)) {\n        HAL_UART_Receive_IT(uart);\n        return;\n    }\n\n    if ((sr & USART_SR_TXE) && (cr1 & USART_CR1_TXEIE)) {\n        HAL_UART_Transmit_IT(uart);\n        return;\n    }\n\n    if ((sr & USART_SR_TC) && (cr1 & USART_CR1_TCIE)) {\n        HAL_UART_EndTransmit_IT(uart);\n        return;\n    }\n\n    if (sr & (USART_SR_NE | USART_SR_FE | USART_SR_PE | USART_SR_ORE)) {\n        if ((sr & USART_SR_RXNE) && (cr1 & USART_CR1_RXNEIE)) {\n            HAL_UART_Receive_IT(uart);\n        }\n        if (!(cr3 & USART_CR3_EIE) || !(sr & USART_SR_ORE)) {\n            HAL_UART_ErrorCallback(uart);\n            return;\n        }\n        HAL_UART_EndRxTransfer(uart);\n        uart->Instance->CR3 &= ~USART_CR3_EIE;\n        if (uart->hdmarx) {\n            uart->hdmarx->XferAbortCallback = uart->hdmarx_abort_callback;\n            status = HAL_DMA_Abort_IT(uart->hdmarx);\n            if (status != HAL_OK) {\n                uart->hdmarx->XferAbortCallback(uart->hdmarx);\n                return;\n            }\n        }\n    }\n}\n",
            "called": [
                "HAL_UART_ErrorCallback",
                "UART_Receive_IT",
                "UART_EndRxTransfer",
                "UART_EndTransmit_IT",
                "HAL_DMA_Abort_IT",
                "UART_Transmit_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080046b8",
            "calling": [
                "USART1_IRQHandler",
                "USART3_IRQHandler",
                "USART2_IRQHandler"
            ],
            "imported": false,
            "current_name": "uart_handler_080046b8"
        },
        "FUN_08004c8a": {
            "renaming": {
                "FUN_08004c8a": "find_pin_name_conflict_08004c8a",
                "peripheral": "peripheral",
                "map": "map_array",
                "PinName_conflict": "PinName_conflict",
                "PinMap_conflict": "PinMap_conflict",
                "NC": "NC"
            },
            "code": "PinName_conflict find_pin_name_conflict_08004c8a(void *peripheral, PinMap_conflict *map_array)\n{\n  while (true) {\n    if (map_array->peripheral == (void *)0x0) {\n      return NC;\n    }\n    if (map_array->peripheral == peripheral) {\n      break;\n    }\n    map_array++;\n  }\n  return map_array->pin;\n}",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c8a",
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "imported": false,
            "current_name": "find_pin_name_conflict_08004c8a"
        },
        "FUN_08001cd0": {
            "renaming": {
                "FUN_08001cd0": "perform_analog_conversion_08001cd0",
                "*hadc": "*adc_handle",
                "Timeout": "timeout_in_ms",
                "HVar1": "status",
                "uVar2": "start_time",
                "pAVar5": "adc_instance",
                "uVar6": "clock_frequency",
                "Conversion_Timeout_CPU_cycles": "conversion_timeout_cycles",
                "uVar3": "peripheral_clock_frequency",
                "iVar4": "sample_rate"
            },
            "code": "HAL_StatusTypeDef_conflict perform_analog_conversion_08001cd0(ADC_HandleTypeDef *adc_handle, uint32_t timeout_in_ms)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t start_time = HAL_GetTick();\n  ADC_TypeDef *adc_instance = adc_handle->Instance;\n  uint32_t conversion_timeout_cycles = 0;\n  \n  if ((adc_instance->CR2 & 0x100) == 0) {\n    if (((adc_instance->CR1 & 0x100) == 0) && ((adc_instance->SQR1 & 0xf00000) == 0)) {\n      do {\n        if ((adc_handle->Instance->SR & 2) != 0) goto conversion_complete;\n      } while ((timeout_in_ms == 0xffffffff) || ((timeout_in_ms != 0 && (HAL_GetTick() - start_time <= timeout_in_ms))));\n      adc_handle->State = adc_handle->State | 4;\n      adc_handle->Lock = HAL_UNLOCKED;\n      status = HAL_TIMEOUT;\n    }\n    else {\n      uint32_t clock_frequency = *(uint *)PTR_SystemCoreClock_08001e2c;\n      uint32_t peripheral_clock_frequency = HAL_RCCEx_GetPeriphCLKFreq(2);\n      uint32_t sample_rate = 0;\n      if (((adc_instance->SMPR2 & DAT_08001e30) == 0) && ((adc_instance->SMPR1 & DAT_08001e30 + 0xdc000000) == 0)) {\n        if ((adc_instance->SMPR2 & DAT_08001e34) == 0) {\n          if ((adc_instance->SMPR1 & DAT_08001e38) == 0) {\n            sample_rate = 0x14;\n          }\n          else {\n            sample_rate = 0x29;\n          }\n        }\n        else {\n          sample_rate = 0x29;\n        }\n      }\n      else if (((adc_instance->SMPR2 & DAT_08001e34) == 0) && ((adc_instance->SMPR1 & DAT_08001e34 + 0xee000000) == 0)) {\n        sample_rate = 0x54;\n      }\n      else if ((DAT_08001e3c & adc_instance->SMPR2) == 0) {\n        if ((DAT_08001e3c & adc_instance->SMPR1) == 0) {\n          sample_rate = 0x54;\n        }\n        else {\n          sample_rate = 0xfc;\n        }\n      }\n      else {\n        sample_rate = 0xfc;\n      }\n      sample_rate = (clock_frequency / peripheral_clock_frequency) * sample_rate;\n      for (; conversion_timeout_cycles <= sample_rate && sample_rate - conversion_timeout_cycles != 0; conversion_timeout_cycles = conversion_timeout_cycles + 1) {\n        if ((timeout_in_ms != 0xffffffff) && ((timeout_in_ms == 0 || (HAL_GetTick() - start_time > timeout_in_ms)))) {\n          adc_handle->State = adc_handle->State | 4;\n          adc_handle->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nconversion_complete:\n      adc_handle->Instance->SR = 0xffffffed;\n      adc_handle->State = adc_handle->State | 0x200;\n      if ((adc_handle->Instance->CR2 & 0xe0000) == 0xe0000) {\n        if ((adc_handle->Init).ContinuousConvMode == 0) {\n          adc_handle->State = adc_handle->State & 0xfffffeff;\n          if ((adc_handle->State & 0x1000) == 0) {\n            adc_handle->State = adc_handle->State | 1;\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        status = HAL_OK;\n      }\n    }\n  }\n  else {\n    adc_handle->State = adc_handle->State | 0x20;\n    adc_handle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001cd0",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "perform_analog_conversion_08001cd0"
        },
        "FUN_08004178": {
            "renaming": {
                "FUN_08004178": "do_nothing_08004178"
            },
            "code": "\nvoid do_nothing_08004178(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004178",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08004178"
        },
        "FUN_08000130": {
            "renaming": {
                "FUN_08000130": "execute_function_if_initialized_08000130",
                "DAT_08000164": "is_initialized",
                "PTR__edata_08000170": "edata_ptr",
                "DAT_08000174": "func_ptr",
                "PTR_object_8672_0800016c": "object_ptr"
            },
            "code": "void execute_function_if_initialized_08000130(void)\n{\n  bool DAT_08000164 = DAT_08000164;\n  if (!DAT_08000164) {\n    return;\n  }\n\n  int* PTR__edata_08000170 = (int*) PTR__edata_08000170;\n  code* DAT_08000174 = DAT_08000174;\n\n  if (PTR__edata_08000170 && DAT_08000174) {\n    DAT_08000174(PTR__edata_08000170, PTR_object_8672_0800016c);\n  }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000130",
            "calling": [],
            "imported": false,
            "current_name": "execute_function_if_initialized_08000130"
        },
        "FUN_08004a4c": {
            "renaming": {
                "FUN_08004a4c": "read_analog_pin_08004a4c",
                "pin": "pin",
                "HVar1": "status",
                "uVar2": "value",
                "uhADCxConvertedValue": "converted_value",
                "AdcChannelConf": "channel_config",
                "AdcHandle": "adc_handle"
            },
            "code": "uint16_t read_analog_pin_08004a4c(PinName_conflict pin)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t value;\n  uint16_t converted_value;\n  ADC_ChannelConfTypeDef channel_config;\n  ADC_HandleTypeDef adc_handle;\n  \n  memset(&adc_handle, 0, sizeof(ADC_HandleTypeDef));\n  channel_config.Channel = 0;\n  channel_config.Rank = 0;\n  channel_config.SamplingTime = 0;\n  converted_value = 0;\n  adc_handle.Instance = (ADC_TypeDef *)pinmap_peripheral(pin, (PinMap_conflict *)PTR_PinMap_ADC_08004b2c);\n  if (adc_handle.Instance == (ADC_TypeDef *)0x0) {\n    converted_value = 0;\n  }\n  else {\n    adc_handle.Init.DataAlign = ADC_DATAALIGN_RIGHT;\n    adc_handle.Init.ScanConvMode = DISABLE;\n    adc_handle.Init.ContinuousConvMode = DISABLE;\n    adc_handle.Init.DiscontinuousConvMode = DISABLE;\n    adc_handle.Init.ExternalTrigConv = ADC_SOFTWARE_START;\n    adc_handle.State = 0;\n    adc_handle.Init.NbrOfConversion = 1;\n    adc_handle.Init.NbrOfDiscConversion = 0;\n    *g_current_pin = pin;\n    status = HAL_ADC_Init(&adc_handle);\n    if (status == HAL_OK) {\n      channel_config.Channel = get_adc_channel(pin);\n      if (channel_config.Channel < 0x12) {\n        channel_config.Rank = 1;\n        channel_config.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;\n        status = HAL_ADC_ConfigChannel(&adc_handle, &channel_config);\n        if (status == HAL_OK) {\n          status = HAL_ADCEx_Calibration_Start(&adc_handle);\n          if (status == HAL_OK) {\n            status = HAL_ADC_Start(&adc_handle);\n            if (status == HAL_OK) {\n              status = HAL_ADC_PollForConversion(&adc_handle, 10);\n              if (status == HAL_OK) {\n                value = HAL_ADC_GetState(&adc_handle);\n                if ((value & ADC_FLAG_EOC) != 0) {\n                  value = HAL_ADC_GetValue(&adc_handle);\n                  converted_value = (uint16_t)value;\n                }\n                status = HAL_ADC_Stop(&adc_handle);\n                if (status == HAL_OK) {\n                  status = HAL_ADC_DeInit(&adc_handle);\n                  if (status != HAL_OK) {\n                    converted_value = 0;\n                  }\n                }\n                else {\n                  converted_value = 0;\n                }\n              }\n              else {\n                converted_value = 0;\n              }\n            }\n            else {\n              converted_value = 0;\n            }\n          }\n          else {\n            converted_value = 0;\n          }\n        }\n        else {\n          converted_value = 0;\n        }\n      }\n      else {\n        converted_value = 0;\n      }\n    }\n    else {\n      converted_value = 0;\n    }\n  }\n  return converted_value;\n}",
            "called": [
                "get_adc_channel",
                "HAL_ADC_GetValue",
                "HAL_ADC_Start",
                "memset",
                "HAL_ADC_GetState",
                "pinmap_peripheral",
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_DeInit",
                "HAL_ADC_ConfigChannel",
                "HAL_ADC_Stop",
                "HAL_ADC_PollForConversion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a4c",
            "calling": [
                "analogRead"
            ],
            "imported": false,
            "current_name": "read_analog_pin_08004a4c"
        },
        "FUN_08006112": {
            "renaming": {
                "FUN_08006112": "register_exit_handler_08006112",
                "param_1": "handler_func",
                "param_2": "handler_arg",
                "__cxa_atexit": "__register_atexit_handler"
            },
            "code": "void register_exit_handler_08006112(void (*handler_func)(void), void *handler_arg)\n{\n  __cxa_atexit(handler_arg, handler_func);\n  return;\n}",
            "called": [
                "__cxa_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006112",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "register_exit_handler_08006112"
        },
        "FUN_08004974": {
            "renaming": {
                "FUN_08004974": "set_GPIO_Pin_Mode_08004974",
                "*hadc": "*adc_handle",
                "puVar1": "current_pin_ptr",
                "GPIOx": "gpio_port",
                "tmpreg": "tmpreg",
                "tmpreg_1": "tmpreg_1",
                "GPIO_InitStruct": "gpio_init_struct"
            },
            "code": "void set_GPIO_Pin_Mode_08004974(ADC_HandleTypeDef *adc_handle)\n{\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  GPIO_InitTypeDef gpio_init_struct;\n  if (adc_handle->Instance == ADC1) {\n    *(uint *)(g_current_pin + 0x18) = *(uint *)(g_current_pin + 0x18) | 0x200;\n  }\n  else if (adc_handle->Instance == ADC2) {\n    *(uint *)(g_current_pin + 0x18) = *(uint *)(g_current_pin + 0x18) | 0x400;\n  }\n  uint8_t *current_pin = current_pin_ptr;\n  GPIO_TypeDef *gpio_port = set_GPIO_Port_Clock((uint)((int)(char)*current_pin << 0x18) >> 0x1c);\n  gpio_init_struct.Pin = 1 << (*current_pin & 0xf) & 0xffff;\n  gpio_init_struct.Mode = GPIO_MODE_ANALOG;\n  gpio_init_struct.Pull = GPIO_NOPULL;\n  HAL_GPIO_Init(gpio_port,&gpio_init_struct);\n  return;\n}",
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004974",
            "calling": [
                "HAL_ADC_Init"
            ],
            "imported": false,
            "current_name": "set_GPIO_Pin_Mode_08004974"
        },
        "FUN_08003520": {
            "renaming": {
                "FUN_08003520": "handle_i2c_errors_08003520",
                "hi2c": "i2c_handler",
                "HVar1": "i2c_state",
                "pIVar2": "i2c_instance",
                "uVar3": "sr1",
                "uVar4": "cr2",
                "DAT_080035f8": "I2C_SR1_BUS_ERROR",
                "0x100": "I2C_CR2_AUTOEND_MODE",
                "1": "I2C_ERROR_BUS",
                "0x10200": "I2C_SR1_AF",
                "2": "I2C_ERROR_ACKF",
                "0x10400": "I2C_SR1_TIMEOUT",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "HAL_I2C_STATE_BUSY_TX_LISTEN",
                "0x21": "HAL_I2C_STATE_LISTEN",
                "4": "I2C_ERROR_TIMEOUT",
                "8": "I2C_ERROR_ARLO",
                "HAL_I2C_MODE_SLAVE": "HAL_I2C_MODE_SLAVE",
                "HAL_I2C_MODE_MASTER": "HAL_I2C_MODE_MASTER",
                "I2C_ITError": "I2C_ITError"
            },
            "code": "void handle_i2c_errors_08003520(I2C_HandleTypeDef *i2c_handler)\n{\n  HAL_I2C_StateTypeDef i2c_state;\n  I2C_TypeDef *i2c_instance;\n  uint16_t sr1, cr2;\n  i2c_instance = i2c_handler->Instance;\n  sr1 = i2c_instance->SR1;\n  cr2 = i2c_instance->CR2;\n\n  if (((sr1 & DAT_080035f8) != 0) && ((cr2 & I2C_CR2_AUTOEND_MODE) != 0)) {\n    i2c_handler->ErrorCode |= I2C_ERROR_BUS;\n    i2c_instance->SR1 = 0xfffffeff;\n    i2c_instance->CR1 |= I2C_CR1_STOP;\n  }\n\n  if (((sr1 & I2C_SR1_AF) != 0) && ((cr2 & I2C_CR2_AUTOEND_MODE) != 0)) {\n    i2c_handler->ErrorCode |= I2C_ERROR_ACKF;\n    i2c_instance->SR1 = 0xfffffdff;\n  }\n\n  if (((sr1 & I2C_SR1_TIMEOUT) != 0) && ((cr2 & I2C_CR2_AUTOEND_MODE) != 0)) {\n    i2c_state = i2c_handler->State;\n    if (((i2c_handler->Mode == HAL_I2C_MODE_SLAVE) && (i2c_handler->XferCount == 0)) && (((i2c_state == HAL_I2C_STATE_BUSY_TX || (i2c_state == HAL_I2C_STATE_BUSY_TX_LISTEN)) || ((i2c_state == HAL_I2C_STATE_LISTEN && (i2c_handler->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(i2c_handler);\n    }\n    else {\n      i2c_handler->ErrorCode |= I2C_ERROR_TIMEOUT;\n      if (i2c_handler->Mode == HAL_I2C_MODE_MASTER) {\n        i2c_instance->CR1 |= I2C_CR1_STOP;\n      }\n      i2c_instance->SR1 = 0xfffffbff;\n    }\n  }\n\n  if (((sr1 & I2C_SR1_ARLO) != 0) && ((cr2 & I2C_CR2_AUTOEND_MODE) != 0)) {\n    i2c_handler->ErrorCode |= I2C_ERROR_ARLO;\n    i2c_instance->SR1 = 0xfffff7ff;\n  }\n\n  if (i2c_handler->ErrorCode != 0) {\n    I2C_ITError(i2c_handler);\n  }\n  return;\n}",
            "called": [
                "I2C_Slave_AF",
                "I2C_ITError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003520",
            "calling": [
                "I2C2_ER_IRQHandler",
                "I2C1_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_errors_08003520"
        },
        "FUN_08002ca6": {
            "renaming": {
                "FUN_08002ca6": "i2c_data_transfer_08002ca6",
                "*hi2c": "*i2c_handle",
                "HVar1": "current_state",
                "*puVar2": "*buffer_ptr"
            },
            "code": "HAL_StatusTypeDef i2c_data_transfer_08002ca6(I2C_HandleTypeDef *i2c_handle) {\\n\\\n    HAL_I2C_StateTypeDef current_state = i2c_handle->State;\\n\\\n    if (i2c_handle->XferCount != 0) {\\n\\\n        uint8_t *buffer_ptr = i2c_handle->pBuffPtr;\\n\\\n        i2c_handle->pBuffPtr = buffer_ptr + 1;\\n\\\n        *buffer_ptr = (uint8_t)i2c_handle->Instance->DR;\\n\\\n        i2c_handle->XferCount--;\\n\\\n        if ((i2c_handle->XferCount == 0) && (current_state == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\\n\\\n            i2c_handle->Instance->CR2 &= 0xfffffbff;\\n\\\n            i2c_handle->PreviousState = 0x22;\\n\\\n            i2c_handle->State = HAL_I2C_STATE_LISTEN;\\n\\\n            HAL_I2C_SlaveRxCpltCallback(i2c_handle);\\n\\\n        }\\n\\\n    }\\n\\\n    return HAL_OK;\\n\\\n    }",
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ca6",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_data_transfer_08002ca6"
        },
        "FUN_08002ca4": {
            "renaming": {
                "FUN_08002ca4": "do_nothing_08002ca4"
            },
            "code": "\nvoid do_nothing_08002ca4(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ca4",
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "do_nothing_08002ca4"
        },
        "FUN_08007328": {
            "renaming": {
                "FUN_08007328": "do_nothing_08007328"
            },
            "code": "\nvoid do_nothing_08007328(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007328",
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux"
            ],
            "imported": false,
            "current_name": "do_nothing_08007328"
        },
        "FUN_08005b54": {
            "renaming": {
                "FUN_08005b54::FUN_08005b54": "initialize_serial_connection",
                "this": "serial_object",
                "peripheral": "peripheral",
                "PVar1": "rx_pin",
                "extraout_r1": "ctx",
                "extraout_r1_00": "ctx",
                "(this->super_Stream).super_Print.write_error": "serial_object->super_Stream.super_Print.write_error",
                "(this->super_Stream)._timeout": "serial_object->super_Stream._timeout",
                "(this->super_Stream).super_Print._vptr_Print": "serial_object->super_Stream.super_Print._vptr_Print",
                "this == (FUN_08005b54*)PTR_Serial2_08005ba4": "serial_object == (FUN_08005b54*)Serial2_ptr",
                "setRx(this,0)": "setRx(serial_object, 0)",
                "setTx(this,1)": "setTx(serial_object, 1)",
                "PVar1 = pinmap_pin(peripheral,(PinMap_conflict *)PTR_PinMap_UART_RX_08005ba8)": "rx_pin = pinmap_pin(peripheral, (PinMap_conflict*)PinMap_UART_RX_ptr)",
                "(this->_serial).pin_rx": "serial_object->_serial.pin_rx",
                "PVar1 = pinmap_pin(peripheral,(PinMap_conflict *)PTR_PinMap_UART_TX_08005bac)": "serial_object->_serial.pin_tx = pinmap_pin(peripheral, (PinMap_conflict*)PinMap_UART_TX_ptr)",
                "init(this,ctx)": "init(serial_object, ctx)",
                "return this;": "return serial_object;",
                "FUN_08005b54": "initialize_serial_connection_08005b54"
            },
            "code": "initialize_serial_connection_08005b54* __thiscall initialize_serial_connection_08005b54(initialize_serial_connection_08005b54* serial_object, void* peripheral) {\n    PinName rx_pin;\n    EVP_PKEY_CTX* ctx;\n    serial_object->super_Stream.super_Print.write_error = 0;\n    serial_object->super_Stream._timeout = 1000;\n    serial_object->super_Stream.super_Print._vptr_Print = (_func_int_varargs**)write_1_08005ba0_ptr;\n    if (this == (initialize_serial_connection_08005b54*)PTR_Serial2_08005ba4) {\n        setRx(serial_object, 0);\n        setTx(serial_object, 1);\n        ctx = extraout_r1_00;\n    }\n    else {\n        PVar1 = pinmap_pin(peripheral,(PinMap_conflict *)PTR_PinMap_UART_RX_08005ba8);\n        serial_object->_serial.pin_rx = rx_pin;\n        PVar1 = pinmap_pin(peripheral,(PinMap_conflict *)PTR_PinMap_UART_TX_08005bac);\n        ctx = extraout_r1;\n    }\n    init(serial_object, ctx);\n    return serial_object;\n}",
            "called": [
                "pinmap_pin",
                "setTx",
                "setRx",
                "init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b54",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_serial_connection_08005b54"
        },
        "FUN_08004618": {
            "renaming": {
                "FUN_08004618": "receive_data_08004618",
                "*huart": "*uart",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "pbVar1": "rx_byte",
                "uVar2": "rx_word",
                "puVar3": "rx_byte",
                "huart->RxState": "uart->RxState",
                "HAL_UART_STATE_BUSY_RX": "HAL_UART_STATE_BUSY_RX",
                "huart->Init": "uart->Init",
                "UART_WORDLENGTH_9B": "UART_WORDLENGTH_9B",
                "UART_PARITY_NONE": "UART_PARITY_NONE",
                "huart->Instance->DR": "uart->Instance->DR",
                "huart->pRxBuffPtr": "uart->pRxBuffPtr",
                "huart->RxXferCount": "uart->RxXferCount",
                "HAL_OK": "HAL_OK",
                "uart->Instance->CR1": "uart->Instance->CR1",
                "uart->Instance->CR3": "uart->Instance->CR3",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_UART_RxCpltCallback": "HAL_UART_RxCpltCallback"
            },
            "code": "HAL_StatusTypeDef receive_data_08004618(UART_HandleTypeDef *uart)\n{\n  uint8_t *rx_byte;\n  uint16_t rx_word;\n\n  if (uart->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n\n  if ((uart->Init).WordLength == UART_WORDLENGTH_9B) {\n    if ((uart->Init).Parity == UART_PARITY_NONE) {\n      rx_word = (uint16_t)((uart->Instance->DR << 0x17) >> 0x17);\n      *(uint16_t *)uart->pRxBuffPtr = rx_word;\n      uart->pRxBuffPtr += 2;\n    }\n    else {\n      rx_word = (uint16_t)(uart->Instance->DR & 0xff);\n      *(uint16_t *)uart->pRxBuffPtr = rx_word;\n      uart->pRxBuffPtr += 1;\n    }\n  }\n  else if ((uart->Init).Parity == UART_PARITY_NONE) {\n    rx_byte = uart->pRxBuffPtr;\n    uart->pRxBuffPtr = rx_byte + 1;\n    *rx_byte = (uint8_t)uart->Instance->DR;\n  }\n  else {\n    rx_byte = uart->pRxBuffPtr;\n    uart->pRxBuffPtr = rx_byte + 1;\n    *rx_byte = (uint8_t)(uart->Instance->DR & 0x7f);\n  }\n\n  uart->RxXferCount--;\n  if (uart->RxXferCount != 0) {\n    return HAL_OK;\n  }\n\n  uart->Instance->CR1 &= 0xffffffdf;\n  uart->Instance->CR1 &= 0xfffffeff;\n  uart->Instance->CR3 &= 0xfffffffe;\n  uart->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uart);\n  return HAL_OK;\n}",
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004618",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_data_08004618"
        },
        "FUN_080060a6": {
            "renaming": {
                "FUN_080060a6": "handle_external_interrupts_080060a6",
                "uVar1": "interrupt_pin_mask",
                "PTR_": "unchanged",
                "DAT_": "unchanged"
            },
            "code": "void handle_external_interrupts_080060a6(void)\n{\n  uint16_t interrupt_pin_mask = 0x20;\n  uint16_t max_pin_mask = 0x201;\n  while (interrupt_pin_mask < max_pin_mask) {\n    HAL_GPIO_EXTI_IRQHandler(interrupt_pin_mask);\n    interrupt_pin_mask = interrupt_pin_mask << 1;\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080060a6",
            "calling": [],
            "imported": false,
            "current_name": "handle_external_interrupts_080060a6"
        },
        "FUN_08001c30": {
            "renaming": {
                "FUN_08001c30": "infinite_loop_08001c30"
            },
            "code": "void infinite_loop_08001c30(void)\n{\n  while( true ) {\n    // code block intentionally left blank\n  }\n}",
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c30",
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "imported": false,
            "current_name": "infinite_loop_08001c30"
        },
        "FUN_08005c72": {
            "renaming": {
                "__thiscall Print::FUN_08005c72": "size_t Print::printBuffer",
                "this": "printObject",
                "buffer": "buffer",
                "size": "bufferSize",
                "pPVar1": "currentPrintObject",
                "sVar2": "bytesPrinted",
                "FUN_08005c72": "printBuffer_08005c72"
            },
            "code": "size_t Print::printBuffer_08005c72(Print *printObject, uint8_t *buffer, size_t bufferSize) {\n  Print *currentPrintObject = printObject;\n  size_t bytesPrinted = 0;\n  while(bufferSize > 0) {\n    currentPrintObject = (Print *)(*printObject->_vptr_Print)(currentPrintObject, (uint)*buffer);\n    if (currentPrintObject == (Print *)0x0) {\n      break;\n    }\n    bytesPrinted++;\n    buffer++;\n    bufferSize--;\n  }\n  return bytesPrinted;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005c72",
            "calling": [],
            "imported": false,
            "current_name": "printBuffer_08005c72"
        },
        "FUN_08006c40": {
            "renaming": {
                "std_isra_0": "initialize_data",
                "*param_1": "data",
                "param_2": "initial_value_1",
                "param_3": "initial_value_2",
                "uVar1": "temp",
                "DAT_08006c78": "temp_1",
                "DAT_08006c7c": "temp_2",
                "DAT_08006c80": "temp_3",
                "DAT_08006c84": "temp_4",
                "FUN_08006c40": "initialize_data_08006c40"
            },
            "code": "void initialize_data_08006c40(undefined4 *data, undefined2 initial_value_1, undefined2 initial_value_2)\n{\n    *data = 0;\n    data[1] = 0;\n    data[2] = 0;\n    *(undefined2 *)(data + 3) = initial_value_1;\n    data[25] = 0;\n    *(undefined2 *)((int)data + 0xe) = initial_value_2;\n    data[4] = 0;\n    data[5] = 0;\n    data[6] = 0;\n    memset(data + 23, 0, 8);\n    data[8] = data;\n    data[9] = DAT_08006c78;\n    data[10] = DAT_08006c7c;\n    data[11] = DAT_08006c80;\n    data[12] = DAT_08006c84;\n    return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c40",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_data_08006c40"
        },
        "FUN_0800048c": {
            "renaming": {
                "FUN_0800048c": "calculate_0800048c",
                "param_1": "a",
                "param_2": "b",
                "iVar7": "int_2",
                "uVar8": "uint_5",
                "uVar4": "uint_3",
                "bVar1": "byte_1",
                "bVar9": "bool_1",
                "bVar10": "bool_2",
                "bVar11": "bool_3"
            },
            "code": "ulonglong calculate_0800048c(uint a, uint b)\n{\n    byte byte_1;\n    uint uint_1;\n    uint uint_2;\n    uint uint_3;\n    int int_1;\n    uint uint_4;\n    int int_2;\n    uint uint_5;\n    bool bool_1;\n    bool bool_2;\n    bool bool_3;\n    if ((a | b) == 0) {\n        return CONCAT44(b, a);\n    }\n    int_2 = 1074;\n    uint_5 = b >> 22;\n    if (uint_5 != 0) {\n        int_2 = 3;\n        if (b >> 25 != 0) {\n            int_2 = 6;\n        }\n        if (b >> 28 != 0) {\n            int_2 += 3;\n        }\n        uint_3 = int_2 - ((int)b >> 31);\n        uint_5 = a << (32 - uint_3 & 0xff);\n        a = a >> (uint_3 & 0xff) | b << (32 - uint_3 & 0xff);\n        b = b >> (uint_3 & 0xff);\n        int_2 = uint_3 + 1074;\n    }\n    if (0xfffff < b) {\n        if (0x1fffff < b) {\n            uint_3 = b & 1;\n            b = b >> 1;\n            byte_1 = (byte)a;\n            a = (uint)(uint_3 != 0) << 31 | a >> 1;\n            uint_5 = (uint)(byte_1 & 1) << 31 | uint_5 >> 1;\n            int_2 += 1;\n            if (0xffbfffff < (uint)(int_2 * 0x200000)) {\n                return 0x7ff0000000000000;\n            }\n        }\n    }\n    while ((b & 0x100000) != 0) {\n        uint_3 = 0x100000;\n        uint_4 = uint_5 + int_2 * 0x100000 + (uint)CARRY4(a, 1);\n        a += 1;\n        bool_1 = 0x7fffffff < uint_5;\n        if (uint_5 == 0x80000000) {\n            bool_1 = (a & 1) != 0;\n        }\n        uint_5 = (uint)bool_1 << 31 | uint_5 >> 1;\n        int_2 += 1;\n        if (0xffbfffff < (uint)(int_2 * 0x200000)) {\n            return 0x7ff0000000000000;\n        }\n        b = b - uint_3;\n    }\n    uint_1 = a;\n    uint_3 = b;\n    if (b == 0) {\n        uint_1 = 0;\n        uint_3 = a;\n    }\n    int_1 = count_leading_zeroes(uint_3);\n    if (b == 0) {\n        int_1 = int_1 + 32;\n    }\n    uint_4 = int_1 - 11;\n    bool_3 = SBORROW4(uint_4, 32);\n    uint_2 = int_1 - 43;\n    bool_2 = (int)uint_2 < 0;\n    bool_1 = uint_2 == 0;\n    if ((int)uint_4 < 32) {\n        bool_3 = SCARRY4(uint_2, 12);\n        int_1 -= 31;\n        bool_2 = int_1 < 0;\n        bool_1 = int_1 == 0;\n        uint_4 = uint_4;\n        if (!bool_1 && bool_2 == bool_3) {\n            uint_5 = uint_3 << (uint_4 & 0xff);\n            uint_3 = uint_3 >> (12 - int_1 & 0xff) | uint_1 << (int_1 & 0xff);\n            goto LAB_08000318;\n        }\n    }\n    if (bool_1 || bool_2 != bool_3) {\n        uint_5 = 32 - uint_4;\n    }\n    uint_3 = uint_3 << (uint_4 & 0xff);\n    if (bool_1 || bool_2 != bool_3) {\n        uint_3 = uint_3 | uint_1 >> (uint_5 & 0xff);\n    }\n    if (bool_1 || bool_2 != bool_3) {\n        uint_1 = uint_1 << (uint_4 & 0xff);\n    }\nLAB_08000318:\n    if ((int)uint_4 <= int_2) {\n        return CONCAT44(uint_3 + (int_2 - uint_4) * 0x100000, uint_1);\n    }\n    uint_5 = ~(int_2 - uint_4);\n    if (0x1e < (int)uint_5) {\n        return (ulonglong)(uint_3 >> (uint_5 - 31 & 0xff));\n    }\n    int_2 = uint_5 - 19;\n    if (int_2 == 0 || int_2 < 0 != SCARRY4(uint_5 - 31, 12)) {\n        uint_5 += 1;\n        return CONCAT44(uint_3 >> (uint_5 & 0xff), uint_1 >> (uint_5 & 0xff) | uint_3 << (32 - uint_5 & 0xff));\n    }\n    return (ulonglong)(uint_1 >> (32 - (12 - int_2) & 0xff) | uint_3 << (12 - int_2 & 0xff));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800048c",
            "calling": [],
            "imported": false,
            "current_name": "calculate_0800048c"
        },
        "FUN_0800157c": {
            "renaming": {
                "FUN_0800157c::FUN_0800157c": "initialize_pins",
                "this": "self",
                "SO": "so_pin",
                "CS": "cs_pin",
                "SCK": "sck_pin",
                "FUN_0800157c": "initialize_pins_0800157c"
            },
            "code": "initialize_pins_0800157c* __thiscall initialize_pins_0800157c(initialize_pins_0800157c* this, uchar so_pin, uchar cs_pin, uchar sck_pin)\n{\n  this->so = so_pin;\n  this->cs = cs_pin;\n  this->sck = sck_pin;\n  pinMode((uint)so_pin, INPUT);\n  pinMode((uint)cs_pin, OUTPUT);\n  pinMode((uint)sck_pin, OUTPUT);\n  digitalWrite((uint)cs_pin, HIGH);\n  digitalWrite((uint)sck_pin, LOW);\n  return this;\n}",
            "called": [
                "digitalWrite",
                "pinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800157c",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_pins_0800157c"
        },
        "FUN_080045a2": {
            "renaming": {
                "FUN_080045a2": "uart_receive_080045a2",
                "*huart": "*uart_handle",
                "*pData": "*data",
                "Size": "size",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_BUSY": "HAL_BUSY",
                "(uint8_t *)0x0": "NULL",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_LOCKED": "HAL_LOCKED",
                "pRxBuffPtr": "p_rx_buff_ptr",
                "RxXferSize": "rx_xfer_size",
                "RxXferCount": "rx_xfer_count",
                "ErrorCode": "error_code",
                "HAL_UART_STATE_BUSY_RX": "HAL_UART_STATE_BUSY_RX",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "Instance": "instance",
                "CR1": "CR1",
                "CR3": "CR3",
                "USART_CR1_RXNEIE": "USART_CR1_RXNEIE",
                "USART_CR3_EIE": "USART_CR3_EIE",
                "USART_CR1_RE": "USART_CR1_RE"
            },
            "code": "HAL_StatusTypeDef uart_receive_080045a2(UART_HandleTypeDef *uart_handle, uint8_t *data, uint16_t size)\n{\n    if (uart_handle->RxState != HAL_UART_STATE_READY) {\n        return HAL_BUSY;\n    }\n    if (data == NULL) {\n        return HAL_ERROR;\n    }\n    if (size == 0) {\n        return HAL_ERROR;\n    }\n    if (uart_handle->Lock != HAL_LOCKED) {\n        uart_handle->pRxBuffPtr = data;\n        uart_handle->RxXferSize = size;\n        uart_handle->RxXferCount = size;\n        uart_handle->ErrorCode = 0;\n        uart_handle->RxState = HAL_UART_STATE_BUSY_RX;\n        uart_handle->Lock = HAL_UNLOCKED;\n        uart_handle->Instance->CR1 |= USART_CR1_RXNEIE;\n        uart_handle->Instance->CR3 |= USART_CR3_EIE;\n        uart_handle->Instance->CR1 |= USART_CR1_RE;\n        return HAL_OK;\n    }\n    return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045a2",
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "imported": false,
            "current_name": "uart_receive_080045a2"
        },
        "FUN_08001c32": {
            "renaming": {
                "FUN_08001c32": "initialize_EVP_PKEY_CTX_08001c32",
                "ctx": "pkey_ctx",
                "hw_config_FUN_08001c32": "hardware_config"
            },
            "code": "int initialize_EVP_PKEY_CTX_08001c32(EVP_PKEY_CTX *pkey_ctx) {\n  hardware_config();\n  return (int)pkey_ctx;\n}",
            "called": [
                "hw_config_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c32",
            "calling": [
                "premain"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_08001c32"
        },
        "FUN_080047e8": {
            "renaming": {
                "FUN_080047e8": "get_uart_state_080047e8",
                "*huart": "*uart_handle",
                "huart": "uart_handle",
                "RxState": "receive_state",
                "gState": "general_state"
            },
            "code": "HAL_UART_StateTypeDef get_uart_state_080047e8(UART_HandleTypeDef *uart_handle)\n{\n  HAL_UART_StateTypeDef receive_state = uart_handle->RxState;\n  HAL_UART_StateTypeDef general_state = uart_handle->gState;\n  return receive_state | general_state;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047e8",
            "calling": [
                "serial_rx_active",
                "serial_tx_active"
            ],
            "imported": false,
            "current_name": "get_uart_state_080047e8"
        },
        "FUN_080057b4": {
            "renaming": {
                "FUN_080057b4": "configure_pin_080057b4",
                "ulPin": "pin_number",
                "ulMode": "mode",
                "_Var1": "is_pin_output",
                "pin": "pin_name",
                "PTR_digitalPin_08005838": "digitalPin_ptr_array",
                "NC": "NC",
                "is_pin_configured": "is_pin_configured",
                "PTR_g_anOutputPinConfigured_0800583c": "output_pin_configured_ptr",
                "pin_in_pinmap": "pin_in_pinmap",
                "PinMap_PWM_08005840": "pwm_pinmap_ptr",
                "pwm_stop": "pwm_stop",
                "reset_pin_configured": "reset_pin_configured",
                "digital_io_init": "digital_io_init",
                "PTR_g_digPinConfigured_08005844": "dig_pin_configured_ptr"
            },
            "code": "void configure_pin_080057b4(uint32_t pin_number, uint32_t mode)\n{\n  bool is_pin_output = false;\n  PinName_conflict pin_name;\n  if (pin_number < 0x3c) {\n    pin_name = PTR_digitalPin_08005838[pin_number];\n  }\n  else {\n    pin_name = NC;\n  }\n  if (pin_name != NC) {\n    is_pin_output = is_pin_configured(pin_name, (uint32_t *)PTR_g_anOutputPinConfigured_0800583c);\n    if (is_pin_output && pin_in_pinmap(pin_name, (PinMap_conflict *)pwm_pinmap_ptr)) {\n      pwm_stop(pin_name);\n    }\n    reset_pin_configured(pin_name, (uint32_t *)PTR_g_anOutputPinConfigured_0800583c);\n    switch (mode) {\n    case 0:\n      digital_io_init(pin_name, 0, 0);\n      break;\n    case 1:\n      digital_io_init(pin_name, 1, 0);\n      break;\n    case 2:\n      digital_io_init(pin_name, 0, 1);\n      break;\n    case 3:\n      digital_io_init(pin_name, 0, 2);\n      break;\n    }\n    set_pin_configured(pin_name, (uint32_t *)PTR_g_digPinConfigured_08005844);\n  }\n  return;\n}",
            "called": [
                "digital_io_init",
                "pwm_stop",
                "is_pin_configured",
                "reset_pin_configured",
                "pin_in_pinmap",
                "set_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080057b4",
            "calling": [
                "setup",
                "MAX31855",
                "begin"
            ],
            "imported": false,
            "current_name": "configure_pin_080057b4"
        },
        "FUN_08007334": {
            "renaming": {
                "FUN_08007334": "do_nothing_08007334"
            },
            "code": "\nvoid do_nothing_08007334(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007334",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08007334"
        },
        "FUN_08001b18": {
            "renaming": {
                "FUN_08001b18": "create_controller_08001b18",
                "this": "controller",
                "Input": "input",
                "Output": "output",
                "Setpoint": "setpoint",
                "Kp": "kp",
                "Ki": "ki",
                "Kd": "kd",
                "ControllerDirection": "controller_direction"
            },
            "code": "Controller* create_controller_08001b18(Controller* controller, double* input, double* output, double* setpoint, double kp, double ki, double kd, int controller_direction)\n{\n    initialize_controller(controller, input, output, setpoint, kp, ki, kd, 1, controller_direction);\n    return controller;\n}\n\nvoid initialize_controller(Controller* controller, double* input, double* output, double* setpoint, double kp, double ki, double kd, bool p_on_e, int controller_direction)\n{\n    controller->input = input;\n    controller->output = output;\n    controller->setpoint = setpoint;\n    controller->kp = kp;\n    controller->ki = ki;\n    controller->kd = kd;\n    controller->p_on_e = p_on_e;\n    controller->controller_direction = controller_direction;\n}\n",
            "called": [
                "PID"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001b18",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "create_controller_08001b18"
        },
        "FUN_0800092c": {
            "renaming": {
                "FUN_0800092c": "check_for_collision_0800092c",
                "param_1": "x1",
                "param_2": "y1",
                "param_3": "x2",
                "param_4": "y2_is_greater_than_y1",
                "bVar2": "x_diff_is_negative",
                "bVar3": "y_diff_is_negative",
                "uVar1": "x_diff"
            },
            "code": "uint check_for_collision_0800092c(uint x1, uint y1, uint x2, uint y2) {\n  bool x_collision = (x1 | x2 << 1) == 0;\n  bool y_collision = (y1 | y2 << 1) == 0;\n  if (x_collision && y_collision) {\n    return 1;\n  }\n  if (x2 == x1 && y2 == y1) {\n    return 1;\n  }\n  uint x_diff = x2 ^ x1;\n  bool x_diff_is_negative = -1 < (int)x_diff;\n  bool y_diff_is_negative = -1 < (int)(y2 ^ y1);\n  bool x2_is_greater_than_x1 = x2 >= x1;\n  bool y2_is_greater_than_y1 = y2 >= y1;\n  if (x_diff == 0 || (x_diff_is_negative && x2_is_greater_than_x1)) {\n    if (y2_is_greater_than_y1) {\n      return 0x1;\n    }\n    else {\n      return ~((int)y2 >> 0x1f) | 0x1;\n    }\n  }\n  else {\n    if (y_diff_is_negative && y2_is_greater_than_y1) {\n      return 0x1;\n    }\n    else {\n      return ~((int)x_diff >> 0x1f) | 0x1;\n    }\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800092c",
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "imported": false,
            "current_name": "check_for_collision_0800092c"
        },
        "FUN_08005d8a": {
            "renaming": {
                "__thiscall Print::FUN_08005d8a": "print_number",
                "this": "this",
                "n": "number",
                "base": "base",
                "sVar1": "size",
                "FUN_08005d8aNumber": "print_number_base",
                "PTR_": "PTR_",
                "DAT_": "DAT_",
                "FUN_08005d8a": "print_number_08005d8a"
            },
            "code": "size_t Print::print_number_08005d8a(Print *this, ulong number, int base) {\n    size_t size;\n    if (base != 0) {\n        size = print_number_08005d8a_base(this, number, (uint8_t) base);\n    } else {\n        size = (**this->_vptr_Print)(this, number & 0xff);\n    }\n    return size;\n}\n",
            "called": [
                "printNumber"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d8a",
            "calling": [
                "print",
                "printFloat"
            ],
            "imported": false,
            "current_name": "print_number_08005d8a"
        },
        "FUN_08002560": {
            "renaming": {
                "FUN_08002560": "set_clk_source_08002560",
                "CLKSource": "clk_source",
                "*DAT_0800257c": "*clk_register"
            },
            "code": "void set_clk_source_08002560(uint32_t clk_source)\n{\n    if (clk_source != 4) {\n        *DAT_0800257c &= ~0x04;\n    } else {\n        *DAT_0800257c |= 0x04;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002560",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_clk_source_08002560"
        },
        "FUN_08006e90": {
            "renaming": {
                "FUN_08006e90": "find_byte_08006e90",
                "__s": "data",
                "__c": "byte_to_find",
                "__n": "data_size",
                "pbVar1": "current_byte",
                "pbVar2": "end_of_data"
            },
            "code": "void * find_byte_08006e90(void * data, int byte_to_find, size_t data_size) {\n  unsigned char * current_byte = (unsigned char *)data;\n  unsigned char * end_of_data = (unsigned char *)(data_size + (int)data);\n  while (current_byte != end_of_data && *current_byte != (byte_to_find & 0xff)) {\n    current_byte++;\n  }\n  if (current_byte == end_of_data) {\n    return (void *)0x0;\n  }\n  return current_byte;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e90",
            "calling": [
                "_printf_i",
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "find_byte_08006e90"
        },
        "FUN_0800417a": {
            "renaming": {
                "FUN_0800417a": "do_nothing_0800417a"
            },
            "code": "\nvoid do_nothing_0800417a(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800417a",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_0800417a"
        },
        "FUN_08006920": {
            "renaming": {
                "FUN_08006920": "allocate_memory_08006920",
                "param_1": "error_code",
                "param_2": "size",
                "puVar1": "error_ptr",
                "pcVar2": "memory_ptr"
            },
            "code": "void allocate_memory_08006920(int *error_code, int size) {\n  undefined *error_ptr;\n  caddr_t memory_ptr;\n  error_ptr = PTR_errno_0800693c;\n  *(undefined4 *)PTR_errno_0800693c = 0;\n  memory_ptr = _sbrk(size);\n  if ((memory_ptr == (caddr_t)0xffffffff) && (*(int *)error_ptr != 0)) {\n    *error_code = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_sbrk"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006920",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08006920"
        },
        "FUN_080008ba": {
            "renaming": {
                "FUN_080008ba": "convert_float_to_int_bits_080008ba",
                "param_1": "float_sign",
                "param_2": "float_exponent",
                "param_3": "float_mantissa",
                "param_4": "float_rounding_mode",
                "uVar1": "sign",
                "unaff_r4": "float_mask",
                "uVar2": "mask",
                "uVar3": "float_mantissa_copy",
                "in_r12": "float_mask",
                "bVar4": "is_exponent_zero"
            },
            "code": "ulonglong convert_float_to_int_bits_080008ba(uint float_sign, uint float_exponent, uint float_mantissa, uint float_rounding_mode) {\n  uint float_mask = float_rounding_mode & float_mantissa >> 0x14;\n  uint float_mantissa_copy = float_exponent;\n  if (float_sign != float_rounding_mode || float_mask != float_rounding_mode) {\n    if (float_sign == float_rounding_mode) {\n      if (((float_exponent | float_mantissa << 0xc) == 0) && (float_exponent = float_mantissa_copy, float_mask != float_rounding_mode)) {\n        return (ulonglong)((float_exponent ^ float_mantissa) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (float_mask == float_rounding_mode) {\n      float_exponent = float_mantissa_copy;\n      if ((float_mantissa_copy | float_rounding_mode << 0xc) == 0) {\n        return (ulonglong)((float_exponent ^ float_mantissa) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      bool is_exponent_zero = (float_exponent | float_mantissa << 1) == 0;\n      if (!is_exponent_zero) {\n        is_exponent_zero = (float_mantissa_copy | float_rounding_mode << 1) == 0;\n      }\n      if (!is_exponent_zero) {\n        if (float_sign == 0) {\n          uint mask = float_mantissa_copy & 0x80000000;\n          do {\n            uint sign = float_exponent & 0x80000000;\n            float_exponent = float_exponent << 1;\n            float_mantissa = float_mantissa * 2 + (uint)(sign != 0);\n          } while ((float_mantissa & 0x100000) == 0);\n          float_mantissa = float_mantissa | mask;\n          if (float_mask != 0) {\n            return CONCAT44(float_mantissa, float_exponent);\n          }\n        }\n        do {\n          uint mask = float_mantissa_copy & 0x80000000;\n          float_mantissa_copy = float_mantissa_copy << 1;\n          float_rounding_mode = float_rounding_mode * 2 + (uint)(mask != 0);\n        } while ((float_rounding_mode & 0x100000) == 0);\n        return CONCAT44(float_mantissa, float_exponent);\n      }\n      if ((float_exponent | float_mantissa << 1) != 0) {\n        return (ulonglong)((float_exponent ^ float_mantissa) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n      if ((float_mantissa_copy | float_rounding_mode << 1) != 0) {\n        return (ulonglong)((float_exponent ^ float_mantissa) & 0x80000000) << 0x20;\n      }\n    }\n  }\n  return CONCAT44(float_mantissa_copy, float_exponent) | 0x7ff8000000000000;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080008ba",
            "calling": [
                "__divdf3"
            ],
            "imported": false,
            "current_name": "convert_float_to_int_bits_080008ba"
        },
        "FUN_08002d1c": {
            "renaming": {
                "FUN_08002d1c": "handle_I2C_events_08002d1c",
                "*hi2c": "*handle",
                "hi2c->XferOptions": "handle->transfer_options",
                "hi2c->State": "handle->state",
                "hi2c->Instance": "handle->instance",
                "hi2c->PreviousState": "handle->previous_state",
                "hi2c->Mode": "handle->mode",
                "HAL_I2C_LISTEN_COMPLETE_CB_ID": "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SLAVE_TX_COMPLETE_CB_ID": "HAL_I2C_SlaveTxCpltCallback"
            },
            "code": "HAL_StatusTypeDef handle_I2C_events_08002d1c(I2C_HandleTypeDef *handle)\n{\n    if (((handle->transfer_options == 4) || (handle->transfer_options == 8)) && (handle->state == HAL_I2C_STATE_LISTEN)) {\n        handle->transfer_options = DATA_08002dac;\n        handle->instance->CR2 = handle->instance->CR2 & 0xfffff8ff;\n        handle->instance->SR1 = 0xfffffbff;\n        handle->instance->CR1 = handle->instance->CR1 & 0xfffffbff;\n        handle->previous_state = 0;\n        handle->state = HAL_I2C_STATE_READY;\n        handle->mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_ListenCpltCallback(handle);\n    }\n    else if (handle->state == HAL_I2C_STATE_BUSY_TX) {\n        handle->transfer_options = DATA_08002dac;\n        handle->previous_state = 0x21;\n        handle->state = HAL_I2C_STATE_READY;\n        handle->mode = HAL_I2C_MODE_NONE;\n        handle->instance->CR2 = handle->instance->CR2 & 0xfffff8ff;\n        handle->instance->SR1 = 0xfffffbff;\n        handle->instance->CR1 = handle->instance->CR1 & 0xfffffbff;\n        HAL_I2C_SlaveTxCpltCallback(handle);\n    }\n    else {\n        handle->instance->SR1 = 0xfffffbff;\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d1c",
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_I2C_events_08002d1c"
        },
        "FUN_08005714": {
            "renaming": {
                "FUN_08005714": "return_error_08005714",
                "file_UNUSED": "unused_file"
            },
            "code": "int return_error_08005714(int unused_file)\n{\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005714",
            "calling": [
                "_close_r"
            ],
            "imported": false,
            "current_name": "return_error_08005714"
        },
        "FUN_08003da4": {
            "renaming": {
                "FUN_08003da4": "calculatePeripheralClockFrequency_08003da4",
                "PeriphClk": "peripheralClock",
                "uVar1": "frequency",
                "uVar2": "multiplier",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable"
            },
            "code": "uint32_t calculatePeripheralClockFrequency_08003da4(uint32_t peripheralClock)\n{\n    uint32_t frequency = 0;\n    uint8_t predivFactorTable[2];\n    uint8_t pllMulFactorTable[16];\n\n    pllMulFactorTable[0] = *(undefined4 *)(PTR_DAT_08003e8c);\n    pllMulFactorTable[1] = *(undefined4 *)(PTR_DAT_08003e8c + 4);\n    pllMulFactorTable[2] = *(undefined4 *)(PTR_DAT_08003e8c + 8);\n    predivFactorTable = *(uint8_t (*) [2])(PTR_DAT_08003e8c + 0x10);\n\n    if (peripheralClock == 2)\n    {\n        frequency = HAL_RCC_GetPCLK2Freq();\n        frequency = frequency / ((((DAT_08003e90[1] << 0x10) >> 0x1e) + 1) * 2);\n    }\n    else if (peripheralClock == 0x10)\n    {\n        if ((*DAT_08003e90 & 0x1000000) == 0)\n        {\n            frequency = 0;\n        }\n        else\n        {\n            uint32_t multiplier = pllMulFactorTable[(DAT_08003e90[1] << 10) >> 0x1c];\n            uint32_t prediv = predivFactorTable[-((int)(DAT_08003e90[1] << 0xe) >> 0x1f)];\n            uint32_t vcoFrequency = DAT_08003e9c / prediv * multiplier;\n\n            if ((DAT_08003e90[1] & 0x400000) == 0)\n            {\n                frequency = (uint32_t)((ulonglong)DAT_08003e98 * (ulonglong)(vcoFrequency * 2) >> 0x21);\n            }\n            else\n            {\n                frequency = vcoFrequency;\n            }\n        }\n    }\n    else if (peripheralClock == 1)\n    {\n        if ((DAT_08003e90[8] & 0x302) == 0x102)\n        {\n            frequency = 0x8000;\n        }\n        else\n        {\n            uint32_t uVar2 = DAT_08003e90[8] & 0x300;\n            if ((uVar2 == 0x200) && ((DAT_08003e90[9] & 2) != 0))\n            {\n                frequency = 32000;\n            }\n            else if (uVar2 == 0x300)\n            {\n                if ((*DAT_08003e90 & 0x20000) == 0)\n                {\n                    frequency = 0;\n                }\n                else\n                {\n                    frequency = 0xf424;\n                }\n            }\n            else\n            {\n                frequency = 0;\n            }\n        }\n    }\n    return frequency;\n}",
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003da4",
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_PollForConversion"
            ],
            "imported": false,
            "current_name": "calculatePeripheralClockFrequency_08003da4"
        },
        "FUN_08005a44": {
            "renaming": {
                "FUN_08005a44": "initializeSerial_08005a44",
                "this": "serial",
                "ctx": "context",
                "_serial": "serial",
                "rx_buff": "rxBuffer",
                "_rx_buffer": "rxBufferPtr",
                "rx_head": "rxHead",
                "rx_tail": "rxTail",
                "tx_buff": "txBuffer",
                "_tx_buffer": "txBufferPtr",
                "tx_head": "txHead",
                "tx_tail": "txTail"
            },
            "code": "int __thiscall initializeSerial_08005a44(HardwareSerial *serial,EVP_PKEY_CTX *context){\n  serial->rx_buff = serial->_rx_buffer;\n  serial->rx_head = 0;\n  serial->rx_tail = 0;\n  serial->tx_buff = serial->_tx_buffer;\n  serial->tx_head = 0;\n  serial->tx_tail = 0;\n  return (int)serial;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a44",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "initializeSerial_08005a44"
        },
        "FUN_080009dc": {
            "renaming": {
                "FUN_080009dc": "is_end_of_string_080009dc",
                "in_CY": "current_char"
            },
            "code": "bool is_end_of_string_080009dc(void)\\n{\\n  char current_char;\\n  __aeabi_cdcmpeq();\\n  return current_char == \"\\0\";\\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009dc",
            "calling": [
                "SetOutputLimits",
                "Compute",
                "printFloat",
                "Initialize",
                "SetTunings",
                "loop"
            ],
            "imported": false,
            "current_name": "is_end_of_string_080009dc"
        },
        "FUN_0800417c": {
            "renaming": {
                "FUN_0800417c": "reset_uart_state_0800417c",
                "huart": "uart_handle",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "RxState": "receive_state",
                "HAL_UART_STATE_READY": "ready_state"
            },
            "code": "void reset_uart_state_0800417c(UART_HandleTypeDef *uart_handle) {\n  uart_handle->Instance->CR1 &= ~(1 << 5);\n  uart_handle->Instance->CR3 &= ~(1);\n  uart_handle->RxState = HAL_UART_STATE_READY;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800417c",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "reset_uart_state_0800417c"
        },
        "FUN_08004b94": {
            "renaming": {
                "FUN_08004b94": "get_current_tick_08004b94",
                "uVar1": "current_tick"
            },
            "code": "uint32_t get_current_tick_08004b94(void)\n{\n  uint32_t current_tick = HAL_GetTick();\n  return current_tick;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b94",
            "calling": [
                "millis"
            ],
            "imported": false,
            "current_name": "get_current_tick_08004b94"
        },
        "FUN_080058e0": {
            "renaming": {
                "FUN_080058e0": "get_current_milli_seconds_080058e0",
                "uVar1": "current_milli_seconds"
            },
            "code": "uint32_t get_current_milli_seconds_080058e0(void)\n{\n  uint32_t current_milli_seconds = GetCurrentMilli();\n  return current_milli_seconds;\n}",
            "called": [
                "GetCurrentMilli"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058e0",
            "calling": [
                "setup",
                "Compute",
                "PID",
                "loop"
            ],
            "imported": false,
            "current_name": "get_current_milli_seconds_080058e0"
        },
        "FUN_08001918": {
            "renaming": {
                "__thiscall PID::FUN_08001918": "calculate_pid_constants",
                "this": "this_pid",
                "NewSampleTime": "new_sample_time",
                "uVar1": "ki_divisor_integer_part",
                "uVar2": "new_sample_time_double",
                "uVar3": "old_sample_time_double",
                "dVar4": "temp_result",
                "this->SampleTime": "this_pid->sample_time",
                "this->ki": "this_pid->ki",
                "&this->ki + 4": "address_of_second_half_of_this_pid->ki",
                "&this->kd": "address_of_first_half_of_this_pid->kd",
                "&this->kd + 4": "address_of_second_half_of_this_pid->kd",
                "FUN_08001918": "calculate_pid_constants_08001918"
            },
            "code": "void __thiscall calculate_pid_constants_08001918(PID* this_pid, int new_sample_time)\n{\n    if (new_sample_time > 0) {\n        double new_sample_time_double = (double)new_sample_time;\n        double old_sample_time_double = (double)this_pid->sample_time;\n        double ki_divisor = new_sample_time_double / old_sample_time_double;\n        double kd_dividend = (double)this_pid->kd / old_sample_time_double;\n        double ki_product = ki_divisor * (double)this_pid->ki;\n        double kd_quotient = kd_dividend / new_sample_time_double;\n        this_pid->ki = ki_product;\n        this_pid->kd = kd_quotient;\n        this_pid->sample_time = new_sample_time;\n    }\n    return;\n}",
            "called": [
                "__floatsidf",
                "__divdf3",
                "__muldf3",
                "__floatunsidf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001918",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "calculate_pid_constants_08001918"
        },
        "FUN_0800611c": {
            "renaming": {
                "FUN_0800611c": "assertion_failed_0800611c",
                "param_1": "file",
                "param_2": "line",
                "param_3": "function",
                "param_4": "assertion",
                "puVar1": "message",
                "puVar2": "assertion_string"
            },
            "code": "void assertion_failed_0800611c(const char* file, int line, const char* function, const char* assertion, const char* message) {\n    const char* assertion_string = assertion ? assertion : \"(no assertion)\";\n    const char* message_string = message ? message : \"\";\n    fprintf(stderr, \"Assertion failed: %s, file %s, line %d%s%s\\n\", assertion_string, file, line, function, message_string);\n    abort();\n}",
            "called": [
                "fiprintf",
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800611c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "assertion_failed_0800611c"
        },
        "FUN_0800049c": {
            "renaming": {
                "FUN_0800049c": "calculate_0800049c",
                "param_1": "dividend",
                "param_2": "divisor",
                "bVar1": "is_quotient_bit_carry",
                "uVar2": "quotient",
                "uVar3": "remainder",
                "uVar4": "shifted_remainder",
                "iVar5": "leading_zero_count",
                "uVar6": "quotient_bits",
                "iVar7": "shift_count",
                "uVar8": "sign_bit",
                "uVar9": "temp",
                "bVar10": "is_shift_count_negative",
                "bVar11": "is_quotient_bit_set",
                "bVar12": "is_shift_count_overflow"
            },
            "code": "ulonglong calculate_0800049c(uint dividend, uint divisor)\n{\n    byte is_divisor_negative;\n    uint quotient_bits;\n    uint quotient;\n    uint remainder;\n    int shift_count;\n    uint sign_bit;\n    bool is_quotient_overflow;\n    bool is_quotient_bit_set;\n    bool is_quotient_bit_carry;\n\n    if ((dividend | divisor) == 0) {\n        return CONCAT44(divisor, dividend);\n    }\n\n    sign_bit = divisor & 0x80000000;\n    remainder = divisor;\n    if ((int)sign_bit < 0) {\n        is_divisor_negative = dividend != 0;\n        dividend = -dividend;\n        remainder = -divisor - (uint)is_divisor_negative;\n    }\n\n    quotient_bits = remainder >> 0x16;\n    if (quotient_bits != 0) {\n        shift_count = 0x432;\n        if (remainder >> 0x19 != 0) {\n            shift_count = 6;\n        }\n        if (remainder >> 0x1c != 0) {\n            shift_count += 3;\n        }\n        quotient_bits = shift_count - ((int)remainder >> 0x1f);\n        quotient = dividend << (0x20 - quotient_bits & 0xff);\n        dividend = dividend >> (quotient_bits & 0xff) | remainder << (0x20 - quotient_bits & 0xff);\n        remainder = remainder >> (quotient_bits & 0xff);\n        shift_count = quotient_bits + 0x432;\n    }\n\n    if (0xfffff < remainder) {\n        if (0x1fffff < remainder) {\n            is_quotient_bit_set = (remainder & 1) != 0;\n            remainder = remainder >> 1;\n            is_quotient_bit_carry = (dividend & 1) != 0;\n            quotient = (uint)is_quotient_bit_set << 0x1f | dividend >> 1;\n            is_quotient_overflow = 0xffbfffff < (uint)(shift_count * 0x200000);\n            if (is_quotient_overflow) {\n                return (ulonglong)(sign_bit | 0x7ff00000) << 0x20;\n            }\n        }\n\n        while (remainder >= divisor) {\n            remainder -= divisor;\n            is_quotient_bit_set = true;\n            is_quotient_bit_carry = (dividend & 0x80000000) != 0;\n            dividend = dividend << 1 | (uint)is_quotient_bit_carry;\n            quotient = quotient << 1 | (uint)is_quotient_bit_set;\n            if (remainder < divisor) {\n                break;\n            }\n        }\n        return CONCAT44(remainder + shift_count * 0x100000 | sign_bit, quotient);\n    }\n\n    while (remainder < 0x100000) {\n        remainder <<= 1;\n        is_quotient_bit_set = false;\n        is_quotient_bit_carry = (dividend & 0x80000000) != 0;\n        dividend = dividend << 1 | (uint)is_quotient_bit_carry;\n        quotient = quotient << 1 | (uint)is_quotient_bit_set;\n        shift_count--;\n        if (remainder >= 0x100000) {\n            break;\n        }\n    }\n\n    if (shift_count <= 0) {\n        return CONCAT44(remainder | sign_bit, quotient);\n    }\n\n    shift_count = ~(shift_count - 1);\n    if (shift_count > 0x1e) {\n        return CONCAT44(divisor, remainder >> (shift_count - 0x1f & 0xff)) & 0x80000000ffffffff;\n    }\n\n    if (shift_count == 0 || shift_count < 0 != SCARRY4(shift_count - 0x1f, 0xc)) {\n        shift_count++;\n        return CONCAT44(sign_bit | remainder >> (shift_count & 0xff), quotient >> (shift_count & 0xff) | remainder << (0x20 - shift_count & 0xff));\n    }\n\n    return CONCAT44(divisor, quotient >> (0x20 - (0xcU - shift_count) & 0xff) | remainder << (0xcU - shift_count & 0xff)) & 0x80000000ffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800049c",
            "calling": [],
            "imported": false,
            "current_name": "calculate_0800049c"
        },
        "FUN_080047f4": {
            "renaming": {
                "FUN_080047f4": "isPinHigh_080047f4",
                "pin": "pinName",
                "map": "mapPtr",
                "byte": "uint8_t",
                "uint": "uint32_t"
            },
            "code": "_Bool isPinHigh_080047f4(PinName_conflict pin, uint32_t *map) {\n    uint32_t pinIndex = (int)pin << 24u >> 28u;\n    uint32_t pinMask = (1u << pinIndex);\n    uint32_t maskedValue = map[pinIndex] & pinMask;\n    return (_Bool)(maskedValue != 0);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047f4",
            "calling": [
                "digitalWrite",
                "digitalRead",
                "pinMode"
            ],
            "imported": false,
            "current_name": "isPinHigh_080047f4"
        },
        "FUN_08002c10": {
            "renaming": {
                "FUN_08002c10": "listen_i2c_08002c10",
                "hi2c": "i2c",
                "pIVar1": "i2c_instance",
                "HAL_I2C_STATE_READY": "I2C_READY",
                "HAL_I2C_STATE_LISTEN": "I2C_LISTEN",
                "HAL_BUSY": "I2C_BUSY",
                "HAL_OK": "I2C_OK",
                "CR1": "i2c_control_register_1",
                "CR2": "i2c_control_register_2"
            },
            "code": "HAL_StatusTypeDef listen_i2c_08002c10(I2C_HandleTypeDef *i2c)\n{\n  I2C_TypeDef *i2c_instance;\n  \n  if (i2c->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  i2c->State = HAL_I2C_STATE_LISTEN;\n  i2c_instance = i2c->Instance;\n  if ((i2c_instance->CR1 & 1) == 0) {\n    i2c_instance->CR1 |= 1;\n  }\n  i2c_instance->CR1 |= 0x400;\n  i2c_instance->CR2 |= 0x300;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c10",
            "calling": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "imported": false,
            "current_name": "listen_i2c_08002c10"
        },
        "FUN_080009f0": {
            "renaming": {
                "FUN_080009f0": "is_not_equal_to_zero_or_both_are_zero_080009f0",
                "in_ZR": "is_zero",
                "in_CY": "is_not_zero",
                "__aeabi_cdcmpeq": "are_equal"
            },
            "code": "bool is_not_equal_to_zero_or_both_are_zero_080009f0(void)\n{\n  bool are_equal = __aeabi_cdcmpeq();\n  return !(bool)in_CY || (bool)in_ZR;\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009f0",
            "calling": [
                "printFloat",
                "loop"
            ],
            "imported": false,
            "current_name": "is_not_equal_to_zero_or_both_are_zero_080009f0"
        },
        "FUN_0800134e": {
            "renaming": {
                "FUN_0800134e": "send_value_0800134e",
                "this": "lcd",
                "value": "val"
            },
            "code": "size_t __thiscall LiquidCrystal::send_value_0800134e(LiquidCrystal *lcd,uint8_t value)\n{\n  send(lcd,value,'\\x01');\n  return 1;\n}",
            "called": [
                "send"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800134e",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "send_value_0800134e"
        },
        "FUN_08006be0": {
            "renaming": {
                "FUN_08006be0": "flush_if_buffer_full_08006be0",
                "param_1": "file_descriptor",
                "param_2": "stream",
                "param_3": "mode",
                "param_4": "flags",
                "uVar1": "result"
            },
            "code": "int flush_if_buffer_full_08006be0(int file_descriptor, char* stream, int mode, int flags) {\n    if (*(int *)(stream + 0x10) != 0) {\n        if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n            __sinit();\n        }\n        if (stream == PTR___sf_fake_stdin_08006c28) {\n            stream = *(char **)(file_descriptor + 4);\n        }\n        else if (stream == PTR___sf_fake_stdout_08006c2c) {\n            stream = *(char **)(file_descriptor + 8);\n        }\n        else if (stream == PTR___sf_fake_stderr_08006c30) {\n            stream = *(char **)(file_descriptor + 0xc);\n        }\n        if (*(short *)(stream + 0xc) != 0) {\n            int result = __sflush_r(file_descriptor, stream, mode, flags);\n            return result;\n        }\n    }\n    return 0;\n}",
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006be0",
            "calling": [
                "__swbuf_r"
            ],
            "imported": false,
            "current_name": "flush_if_buffer_full_08006be0"
        },
        "FUN_080012e8": {
            "renaming": {
                "FUN_080012e8": "writeToDataPins_080012e8",
                "this": "lcd",
                "value": "value",
                "uVar1": "bitIndex",
                "_data_pins": "_data_pins",
                "pulseEnable": "pulseEnable",
                "digitalWrite": "digitalWrite"
            },
            "code": "void __thiscall LiquidCrystal::writeToDataPins_080012e8(LiquidCrystal *lcd,uint8_t value)\n{\n  uint8_t bitIndex;\n  for (bitIndex = 0; bitIndex < 8; bitIndex++) {\n    uint8_t bitValue = (value >> bitIndex) & 1;\n    uint8_t dataPin = lcd->_data_pins[bitIndex];\n    digitalWrite((uint)dataPin, (int)bitValue);\n  }\n  pulseEnable(lcd);\n  return;\n}",
            "called": [
                "digitalWrite",
                "pulseEnable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080012e8",
            "calling": [
                "send"
            ],
            "imported": false,
            "current_name": "writeToDataPins_080012e8"
        },
        "FUN_080058e8": {
            "renaming": {
                "FUN_080058e8": "do_nothing_080058e8"
            },
            "code": "\nvoid do_nothing_080058e8(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058e8",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "do_nothing_080058e8"
        },
        "FUN_08006370": {
            "renaming": {
                "FUN_08006370": "write_data_to_stream_08006370",
                "param_1": "file_descriptor",
                "param_2": "mode",
                "param_3": "data",
                "param_4": "size",
                "iVar1": "result",
                "puVar2": "end_of_data",
                "iVar3": "bytes_written"
            },
            "code": "int write_data_to_stream_08006370(int file_descriptor, int mode, void *data, int size) {\n  int bytes_written = 0;\n  void *end_of_data = data + size;\n  while (data != end_of_data) {\n    if (data == end_of_data) {\n      return 0;\n    }\n    int result = __sfputc_r(file_descriptor, *data, mode, size, bytes_written);\n    size = result + 1;\n    data++;\n    bytes_written = result;\n  }\n  return bytes_written;\n}",
            "called": [
                "__sfputc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006370",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "write_data_to_stream_08006370"
        },
        "FUN_080024f8": {
            "renaming": {
                "FUN_080024f8": "set_interrupt_priority_080024f8",
                "IRQn": "interrupt",
                "uVar1": "interrupt_index",
                "DAT_08002510": "interrupt_register_base_address",
                "interrupt_register_index": "interrupt_register_index",
                "interrupt_register_bit": "interrupt_register_bit"
            },
            "code": "void set_interrupt_priority_080024f8(IRQn_Type_conflict interrupt)\n{\n    uint32_t interrupt_index = (uint32_t)interrupt;\n    if (interrupt_index >= 0)\n    {\n        uint32_t interrupt_register_index = interrupt_index >> 5;\n        uint32_t interrupt_register_bit = 1 << (interrupt_index & 0x1f);\n        *(int *)(DAT_08002510 + interrupt_register_index * 4) = interrupt_register_bit;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080024f8",
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_080024f8"
        },
        "FUN_0800594e": {
            "renaming": {
                "__thiscall HardwareSerial::FUN_0800594e": "readByteFromBuffer",
                "*this": "serialInstance",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numberOfBytes",
                "bVar1": "byteToReturn",
                "uVar2": "tail",
                "_serial": "serialInstance->_serial",
                "rx_tail": "(serialInstance->_serial).rx_tail",
                "rx_head": "(serialInstance->_serial).rx_head",
                "rx_buff": "(serialInstance->_serial).rx_buff",
                "FUN_0800594e": "readByteFromBuffer_0800594e"
            },
            "code": "ssize_t __thiscall HardwareSerial::readByteFromBuffer_0800594e(HardwareSerial *serialInstance, int fileDescriptor, void *buffer, size_t numberOfBytes) {\n  byte byteToReturn;\n  ushort tail = (serialInstance->_serial).rx_tail;\n  if ((uint)(serialInstance->_serial).rx_head != (uint)tail) {\n    byteToReturn = (serialInstance->_serial).rx_buff[tail];\n    (serialInstance->_serial).rx_tail = (tail + 1) & 0x3f;\n    return (uint)byteToReturn;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800594e",
            "calling": [],
            "imported": false,
            "current_name": "readByteFromBuffer_0800594e"
        },
        "FUN_080056a8": {
            "renaming": {
                "FUN_080056a8": "handle_USART2_interrupt_080056a8",
                "PTR_uart_handlers_080056bc": "uart_handlers",
                "USART2_IRQn": "USART2_interrupt",
                "UART_HandleTypeDef": "UART_handler",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt"
            },
            "code": "void handle_USART2_interrupt_080056a8(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART2_IRQn);\n  HAL_UART_IRQHandler(*PTR_uart_handlers_080056bc[1]);\n  return;\n}",
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080056a8",
            "calling": [],
            "imported": false,
            "current_name": "handle_USART2_interrupt_080056a8"
        },
        "FUN_08001ab0": {
            "renaming": {
                "FUN_08001ab0": "PIDController_08001ab0",
                "this": "self",
                "Input": "input",
                "Output": "output",
                "Setpoint": "setpoint",
                "Kp": "kp",
                "Ki": "ki",
                "Kd": "kd",
                "POn": "pon",
                "ControllerDirection": "controller_direction",
                "uVar1": "current_time",
                "POn_00": "pon_00",
                "in_stack_ffffffe8": "output_upper_limit",
                "in_stack_ffffffec": "output_lower_limit",
                "in_stack_fffffff4": "kp"
            },
            "code": "PIDController_08001ab0 * __thiscall PIDController_08001ab0::PIDController_08001ab0(PIDController_08001ab0 *this,double *input,double *output,double *setpoint,double kp,double ki,double kd, int pon,int controller_direction)\n{\n  uint32_t current_time;\n  int pon_00;\n  undefined4 output_upper_limit;\n  undefined4 output_lower_limit;\n  \n  this->my_output = output;\n  this->my_input = input;\n  this->my_setpoint = setpoint;\n  this->is_auto_mode = false;\n  set_output_limits(this,(double)CONCAT44(DAT_08001b14,DAT_08001b10), (double)CONCAT44(output_upper_limit,output_lower_limit));\n  this->sample_time = 100;\n  set_controller_direction(this,controller_direction);\n  set_tunings(this,ki,kd,(double)CONCAT44(pon_00,kp),pon);\n  current_time = millis();\n  this->last_time = current_time - this->sample_time;\n  return this;\n}",
            "called": [
                "SetControllerDirection",
                "millis",
                "SetOutputLimits",
                "SetTunings"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001ab0",
            "calling": [
                "PID"
            ],
            "imported": false,
            "current_name": "PIDController_08001ab0"
        },
        "FUN_08006ac0": {
            "renaming": {
                "FUN_08006ac0": "exit_with_signal_08006ac0",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void exit_with_signal_08006ac0(int signal) {\n  raise(signal);\n  _exit(1);\n}",
            "called": [
                "raise",
                "_exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ac0",
            "calling": [
                "__assert_func",
                "__throw_bad_function_call"
            ],
            "imported": false,
            "current_name": "exit_with_signal_08006ac0"
        },
        "FUN_08007220": {
            "renaming": {
                "std::ctype_byname<wchar_t>::FUN_08007220": "set_ctype_flags",
                "PTR_id_08007284": "flag_1",
                "PTR_id_08007288": "flag_2",
                "PTR_id_0800728c": "flag_3",
                "PTR_id_08007290": "flag_4",
                "PTR_id_08007294": "flag_5",
                "PTR_id_08007298": "flag_6",
                "PTR_id_0800729c": "flag_7",
                "PTR_id_080072a0": "flag_8",
                "FUN_08007220": "set_ctype_flags_08007220"
            },
            "code": "void set_ctype_flags_08007220() {\n  if (*(int *)PTR_id_08007284 < 0) {\n    *(undefined4 *)PTR_id_08007284 = 1;\n  }\n  if (*(int *)PTR_id_08007288 < 0) {\n    *(undefined4 *)PTR_id_08007288 = 1;\n  }\n  if (*(int *)PTR_id_0800728c < 0) {\n    *(undefined4 *)PTR_id_0800728c = 1;\n  }\n  if (*(int *)PTR_id_08007290 < 0) {\n    *(undefined4 *)PTR_id_08007290 = 1;\n  }\n  if (*(int *)PTR_id_08007294 < 0) {\n    *(undefined4 *)PTR_id_08007294 = 1;\n  }\n  if (*(int *)PTR_id_08007298 < 0) {\n    *(undefined4 *)PTR_id_08007298 = 1;\n  }\n  if (*(int *)PTR_id_0800729c < 0) {\n    *(undefined4 *)PTR_id_0800729c = 1;\n  }\n  if (*(int *)PTR_id_080072a0 < 0) {\n    *(undefined4 *)PTR_id_080072a0 = 1;\n  }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007220",
            "calling": [],
            "imported": false,
            "current_name": "set_ctype_flags_08007220"
        },
        "FUN_08004198": {
            "renaming": {
                "FUN_08004198": "send_data_08004198",
                "*huart": "*uart",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "uVar1": "data_length",
                "pbVar2": "data_pointer"
            },
            "code": "HAL_StatusTypeDef send_data_08004198(UART_HandleTypeDef *uart)\n{\n  uint16_t data_length;\n  byte *data_pointer;\n  \n  if (uart->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  \n  data_length = (uart->Init).WordLength;\n  if (data_length == 0x1000) {\n    uart->Instance->DR = *(ushort *)uart->pTxBuffPtr & 0x1ff;\n    if ((uart->Init).Parity == 0) {\n      uart->pTxBuffPtr = uart->pTxBuffPtr + 2;\n    }\n    else {\n      uart->pTxBuffPtr = uart->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    data_pointer = uart->pTxBuffPtr;\n    uart->pTxBuffPtr = data_pointer + 1;\n    uart->Instance->DR = (uint)*data_pointer;\n  }\n  \n  data_length = uart->TxXferCount - 1;\n  uart->TxXferCount = data_length;\n  if (data_length == 0) {\n    uart->Instance->CR1 = uart->Instance->CR1 & 0xffffff7f;\n    uart->Instance->CR1 = uart->Instance->CR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004198",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "send_data_08004198"
        },
        "FUN_08001c3c": {
            "renaming": {
                "FUN_08001c3c": "configureSysTickTimer_08001c3c",
                "TickPriority": "tickPriority",
                "uVar1": "systickConfig",
                "HAL_SYSTICK_Config": "HAL_SYSTICK_Config",
                "PTR_SystemCoreClock_08001c80": "PTR_SystemCoreClock_08001c80",
                "PTR_uwTickFreq_08001c7c": "PTR_uwTickFreq_08001c7c",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_NVIC_SetPriority": "HAL_NVIC_SetPriority",
                "SysTick_IRQn": "SysTick_IRQn",
                "PTR_uwTickPrio_08001c84": "PTR_uwTickPrio_08001c84",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef configureSysTickTimer_08001c3c(uint32_t tickPriority)\n{\n  uint32_t clockSpeed = *(uint *)PTR_SystemCoreClock_08001c80;\n  uint32_t tickFrequency = (1000 / (ulonglong)(byte)*PTR_uwTickFreq_08001c7c);\n  uint32_t systickConfig = clockSpeed / tickFrequency;\n  HAL_StatusTypeDef status = HAL_SYSTICK_Config(systickConfig);\n  if (status != HAL_OK) {\n    return HAL_ERROR;\n  }\n  if (tickPriority > 0xf) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn, tickPriority, 0);\n  *(uint32_t *)PTR_uwTickPrio_08001c84 = tickPriority;\n  return HAL_OK;\n}",
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c3c",
            "calling": [
                "HAL_Init",
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "configureSysTickTimer_08001c3c"
        },
        "FUN_08001c3a": {
            "renaming": {
                "FUN_08001c3a": "do_nothing_08001c3a"
            },
            "code": "\nvoid do_nothing_08001c3a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c3a",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_08001c3a"
        },
        "FUN_08000a2c": {
            "renaming": {
                "FUN_08000a2c": "is_valid_input_08000a2c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4"
            },
            "code": "int is_valid_input_08000a2c(uint32_t input1, int input2, uint32_t input3, int input4) {\n    if ((((input2 << 1) >> 0x15) != -1 || ((input1 | (input2 << 0xc)) == 0)) && (((input4 << 1) >> 0x15) != -1 || ((input3 | (input4 << 0xc)) == 0))) {\n        return 0;\n    }\n    return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a2c",
            "calling": [
                "printFloat"
            ],
            "imported": false,
            "current_name": "is_valid_input_08000a2c"
        },
        "FUN_08001366": {
            "renaming": {
                "FUN_08001366": "setCursor_08001366",
                "this": "instance",
                "col": "column",
                "row": "row",
                "uVar1": "limited_row",
                "_numlines": "max_row",
                "_row_offsets": "offset",
                "send": "send",
                "position": "position"
            },
            "code": "void __thiscall LiquidCrystal::setCursor_08001366(LiquidCrystal *this, uint8_t column, uint8_t row) {\\n  uint8_t limited_row = (row > 3) ? 3 : row;\\n  uint8_t max_row = this->_numlines - 1;\\n  uint8_t selected_row = (limited_row > max_row) ? max_row : limited_row;\\n  uint8_t offset = this->_row_offsets[selected_row];\\n  uint8_t position = col + offset | 0x80;\\n  send(this, position, \"\\0\");\\n  return;\\n}",
            "called": [
                "send"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001366",
            "calling": [
                "setup",
                "loop"
            ],
            "imported": false,
            "current_name": "setCursor_08001366"
        },
        "FUN_08005848": {
            "renaming": {
                "FUN_08005848": "write_digital_pin_08005848",
                "ulPin": "pin_number",
                "ulVal": "pin_value",
                "_Var1": "is_pin_configured_result",
                "port": "gpio_port",
                "uVar2": "pin_number_mapped",
                "PTR_digitalPin_08005888": "digital_pin_mapping_table",
                "PTR_g_digPinConfigured_0800588c": "digital_pin_configured",
                "GPIO_TypeDef": "GPIO_TypeDef",
                "PinName_conflict": "PinName_conflict",
                "get_GPIO_Port": "get_GPIO_Port",
                "digital_io_write": "digital_io_write"
            },
            "code": "void write_digital_pin_08005848(uint32_t pin_number, uint32_t pin_value)\n{\n    bool is_pin_configured_result;\n    GPIO_TypeDef *gpio_port;\n    uint32_t pin_number_mapped;\n\n    if (pin_number < 60) {\n        pin_number_mapped = (uint32_t)(char)PTR_digitalPin_08005888[pin_number];\n    }\n    else {\n        pin_number_mapped = 0xffffffff;\n    }\n\n    if ((pin_number_mapped != 0xffffffff) &&\n        (is_pin_configured_result = is_pin_configured((PinName_conflict)pin_number_mapped, &PTR_g_digPinConfigured_0800588c[pin_number_mapped]), is_pin_configured_result)) {\n        gpio_port = get_GPIO_Port((pin_number_mapped << 24) >> 28);\n        digital_io_write(gpio_port, 1 << (pin_number_mapped & 0xf) & 0xffff, pin_value);\n    }\n}\n",
            "called": [
                "is_pin_configured",
                "digital_io_write",
                "get_GPIO_Port"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005848",
            "calling": [
                "readData",
                "write4bits",
                "send",
                "setup",
                "MAX31855",
                "begin",
                "write8bits",
                "pulseEnable",
                "loop"
            ],
            "imported": false,
            "current_name": "write_digital_pin_08005848"
        },
        "FUN_08000ae8": {
            "renaming": {
                "FUN_08000ae8": "read_hardware_08000ae8",
                "a0": "hardware_address",
                "a1": "data",
                "a2": "error_code",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "uint32_t read_hardware_08000ae8(uint32_t hardware_address, uint32_t data, int32_t error_code) {\n\tsoftware_interrupt(SYSTEM_CALL_READ_HARDWARE);\n\treturn hardware_address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000ae8",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "read_hardware_08000ae8"
        },
        "FUN_08003ed8": {
            "renaming": {
                "FUN_08003ed8": "reset_timer_08003ed8",
                "htim": "timer",
                "pTVar1": "timer_instance",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "HAL_TIM_STATE_RESET": "HAL_TIM_STATE_RESET",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_OK": "HAL_OK",
                "CCER": "CCER",
                "CR1": "CR1",
                "HAL_TIM_PWM_MspDeInit": "HAL_TIM_PWM_MspDeInit"
            },
            "code": "HAL_StatusTypeDef reset_timer_08003ed8(TIM_HandleTypeDef *timer)\n{\n  TIM_TypeDef *timer_instance;\n  timer->State = HAL_TIM_STATE_BUSY;\n  timer_instance = timer->Instance;\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 = timer_instance->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(timer);\n  timer->State = HAL_TIM_STATE_RESET;\n  timer->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}",
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ed8",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "reset_timer_08003ed8"
        },
        "FUN_080061e0": {
            "renaming": {
                "FUN_080061e0": "memset_080061e0",
                "__s": "destination",
                "__c": "value",
                "__n": "num",
                "puVar1": "ptr"
            },
            "code": "void * memset_080061e0(void *destination, int value, size_t num) {\\n\\\n  unsigned char *ptr = (unsigned char *)destination;\\n\\\n  for (size_t i = 0; i < num; i++) {\\n\\\n    ptr[i] = (unsigned char)value;\\n\\\n  }\\n\\\n  return destination;\\n\\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080061e0",
            "calling": [
                "__sfp",
                "adc_read_value",
                "std.isra.0",
                "__sfmoreglue"
            ],
            "imported": false,
            "current_name": "memset_080061e0"
        },
        "FUN_08004f0c": {
            "renaming": {
                "FUN_08004f0c": "handle_i2c_events_08004f0c",
                "PTR_i2c_handles_08004f18": "i2c_handles"
            },
            "code": "void handle_i2c_events_08004f0c(I2C_HandleTypeDef** PTR_i2c_handles_08004f18) {\n  HAL_I2C_EV_IRQHandler(*PTR_i2c_handles_08004f18);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f0c",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_events_08004f0c"
        },
        "FUN_08005604": {
            "renaming": {
                "FUN_08005604": "transmit_uart_data_08005604",
                "*huart": "*uart_handler",
                "bVar1": "uart_index",
                "uVar2": "uart_index_uint",
                "iVar3": "callback_result",
                "iVar4": "callback_obj",
                "PTR_tx_callback_obj_08005644": "PTR_tx_callback_obj",
                "PTR_tx_callback_08005648": "PTR_tx_callback",
                "PTR_uart_handlers_0800564c": "PTR_uart_handlers"
            },
            "code": "void transmit_uart_data_08005604(UART_HandleTypeDef *uart_handler) {\n  uint8_t uart_index = get_uart_index(uart_handler);\n  if (uart_index < 5) {\n    int callback_obj = *(int *)(PTR_tx_callback_08005648_obj_08005644_08005644 + uart_index * 4);\n    code *callback = **(code **)(PTR_tx_callback_08005648_08005648 + uart_index * 4);\n    int callback_result = callback(callback_obj);\n    if (callback_result != -1) {\n      uint8_t *data = (uint8_t *)(*(int *)(callback_obj + 100) + (uint)*(ushort *)(callback_obj + 0x6a));\n      uint8_t *handler_index = (uint8_t *)(callback_obj + 0x44);\n      UART_HandleTypeDef *handler = *(UART_HandleTypeDef **)(PTR_uart_handlers_0800564c_0800564c + (uint)*handler_index * 4);\n      HAL_UART_Transmit_IT(handler, data, 1);\n    }\n  }\n}\n",
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005604",
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "imported": false,
            "current_name": "transmit_uart_data_08005604"
        },
        "FUN_08005724": {
            "renaming": {
                "FUN_08005724": "alwaysReturnsOne_08005724",
                "file_UNUSED": "fileDescriptor"
            },
            "code": "int alwaysReturnsOne_08005724(int fileDescriptor)\n{\n    return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005724",
            "calling": [
                "_isatty_r"
            ],
            "imported": false,
            "current_name": "alwaysReturnsOne_08005724"
        },
        "FUN_08005728": {
            "renaming": {
                "FUN_08005728": "count_files_in_directory_08005728",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "pointer",
                "dir_UNUSED": "directory"
            },
            "code": "int count_files_in_directory_08005728(int file_descriptor, int pointer, int directory) {\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005728",
            "calling": [
                "_lseek_r"
            ],
            "imported": false,
            "current_name": "count_files_in_directory_08005728"
        },
        "FUN_0800135a": {
            "renaming": {
                "__thiscall LiquidCrystal::FUN_0800135a": "send_control_signal",
                "this": "lcd",
                "PTR_": "PTR_",
                "DAT_": "DAT_",
                "FUN_0800135a": "send_control_signal_0800135a"
            },
            "code": "void send_control_signal_0800135a(LiquidCrystal *lcd){\n  char control_signal = '\\x01';\n  char null_char = '\\0';\n  send(lcd, control_signal, null_char);\n  return;\n}",
            "called": [
                "send"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800135a",
            "calling": [
                "setup",
                "begin",
                "loop"
            ],
            "imported": false,
            "current_name": "send_control_signal_0800135a"
        },
        "FUN_08005c96": {
            "renaming": {
                "__thiscall Print::FUN_08005c96": "size_t Print::printString",
                "this": "this",
                "str": "stringToPrint",
                "sVar1": "stringLength",
                "sVar2": "bytesWritten",
                "FUN_08005c96": "printString_08005c96"
            },
            "code": "size_t Print::printString_08005c96(Print *this, char *stringToPrint) {\n\tsize_t stringLength;\n\tsize_t bytesWritten;\n\tif (stringToPrint != nullptr) {\n\t\tstringLength = strlen(stringToPrint);\n\t\tbytesWritten = (*this->_vptr_Print[1])(stringLength, stringToPrint, stringLength);\n\t\treturn bytesWritten;\n\t}\n\treturn 0;\n}",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005c96",
            "calling": [
                "setup",
                "printFloat",
                "println",
                "loop"
            ],
            "imported": false,
            "current_name": "printString_08005c96"
        },
        "FUN_0800571a": {
            "renaming": {
                "FUN_0800571a": "set_file_mode_to_directory_0800571a",
                "file_UNUSED": "unused_file",
                "st": "file_stat",
                "st->st_mode": "file_stat->st_mode"
            },
            "code": "int set_file_mode_to_directory_0800571a(stat *file_stat){\n    file_stat->st_mode = 0x2000;\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800571a",
            "calling": [
                "_fstat_r"
            ],
            "imported": false,
            "current_name": "set_file_mode_to_directory_0800571a"
        },
        "FUN_08002efc": {
            "renaming": {
                "FUN_08002efc": "handle_i2c_transfer_08002efc",
                "*hi2c": "*handle",
                "uVar1": "transfer_options",
                "pbVar2": "buffer_ptr"
            },
            "code": "HAL_StatusTypeDef handle_i2c_transfer_08002efc(I2C_HandleTypeDef *handle)\n{\n    uint32_t transfer_options = handle->XferOptions;\n    if (handle->State == HAL_I2C_STATE_BUSY_TX) {\n        if (handle->XferCount == 0) {\n            if (((transfer_options == 4) || (transfer_options == 8)) || (transfer_options == 0xffff0000)) {\n                handle->Instance->CR2 = handle->Instance->CR2 & 0xfffff8ff;\n                handle->Instance->CR1 = handle->Instance->CR1 | 0x200;\n                handle->PreviousState = 0;\n                handle->State = HAL_I2C_STATE_READY;\n                if (handle->Mode == HAL_I2C_MODE_MEM) {\n                    handle->Mode = HAL_I2C_MODE_NONE;\n                    HAL_I2C_MemTxCpltCallback(handle);\n                }\n                else {\n                    handle->Mode = HAL_I2C_MODE_NONE;\n                    HAL_I2C_MasterTxCpltCallback(handle);\n                }\n            }\n            else {\n                handle->Instance->CR2 = handle->Instance->CR2 & 0xfffff8ff;\n                handle->PreviousState = 0x11;\n                handle->Mode = HAL_I2C_MODE_NONE;\n                handle->State = HAL_I2C_STATE_READY;\n                HAL_I2C_MasterTxCpltCallback(handle);\n            }\n        }\n        else {\n            uint8_t *buffer_ptr = handle->pBuffPtr;\n            handle->pBuffPtr = buffer_ptr + 1;\n            handle->Instance->DR = (uint)*buffer_ptr;\n            handle->XferCount = handle->XferCount - 1;\n        }\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002efc",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_transfer_08002efc"
        },
        "FUN_0800365c": {
            "renaming": {
                "FUN_0800365c": "delay_0800365c",
                "mdelay": "milliseconds",
                "Delay": "cycles",
                "bVar1": "delay_complete"
            },
            "code": "void delay_0800365c(uint32_t milliseconds)\n{\n  bool delay_0800365c_complete;\n  uint32_t cycles = milliseconds * (uint)((ulonglong)DAT_08003684 * (ulonglong)*(uint *)PTR_SystemCoreClock_08003680 >> 0x29);\n  do {\n    delay_0800365c_complete = cycles == 0;\n    cycles--;\n  } while (!delay_0800365c_complete);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800365c",
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "imported": false,
            "current_name": "delay_0800365c"
        },
        "FUN_08006ad0": {
            "renaming": {
                "FUN_08006ad0": "process_data_08006ad0",
                "param_1": "data",
                "param_2": "params",
                "iVar1": "count",
                "piVar2": "temp",
                "uVar3": "flag",
                "uVar4": "opcode",
                "iVar5": "step",
                "pcVar6": "func",
                "iVar7": "offset",
                "uVar8": "total",
                "bVar9": "is_negative",
                "LAB_08006bc6": "error_exit"
            },
            "code": "uint32_t process_data_08006ad0(uint32_t *data, int *params) {\n    int count, step, offset, total, result, *temp;\n    uint32_t flag, opcode, *func;\n    bool is_negative;\n    flag = *(uint16_t *)(params + 6);\n    count = (int)flag;\n    if ((count << 0x1c) < 0) {\n        offset = params[8];\n        if (offset != 0) {\n            step = count << 0x1e;\n            is_negative = step == 0;\n            if (is_negative) {\n                step = 0;\n            }\n            total = params[0];\n            if (!is_negative) {\n                total = params[10];\n            }\n            params[0] = offset;\n            params[4] = total;\n            for (total = total - offset; total > 0; total = total - step) {\n                func = (uint32_t *)(params[0x14]);\n                result = (*func)(data, params[0xc], offset, total);\n                if (result < 1) {\n                    flag = *(uint16_t *)(params + 6);\n                    goto LAB_08006bc6;\n                }\n                offset = offset + result;\n            }\n        }\n    }\n    else {\n        if (((params[1] > 0) || (params[0x10] > 0)) && ((func = (uint32_t *)(params[0xb])) != NULL)) {\n            opcode = *data;\n            *data = 0;\n            if ((flag & 0x1000) == 0) {\n                result = (*func)(data, params[0xc], flag & 0x1000, 1);\n                if ((result == -1) && ((opcode = *data) != 0)) {\n                    if ((opcode != 0x1d) && (opcode != 0x16)) {\n                        *(uint16_t *)(params + 6) = *(uint16_t *)(params + 6) | 0x40;\n                        return 0xffffffff;\n                    }\n                    *data = opcode;\n                    return 0;\n                }\n            }\n            else {\n                result = params[0x15];\n            }\n            if (((int)((uint)*(uint16_t *)(params + 6) << 0x1d) < 0) && ((result = result - params[1]) != 0) && (params[0xd] != 0)) {\n                result = result - params[0x10];\n            }\n            result = (*(uint32_t *)(params[0xb]))(data, params[0xc], result, 0);\n            flag = *(uint16_t *)(params + 6);\n            if ((result == -1) && ((opcode = *data) > 0x1d || ((DAT_08006bdc >> (opcode & 0xff)) << 0x1f) >= 0)) {\n                *(uint16_t *)(params + 6) = flag | 0x40;\n                return 0xffffffff;\n            }\n            params[1] = 0;\n            params[0] = params[8];\n            if (((int)((uint)flag << 0x13) < 0) && ((result != -1) || (*data == 0))) {\n                params[0x15] = result;\n            }\n            temp = (int *)(params[0xd]);\n            *data = opcode;\n            if (temp != NULL) {\n                if (temp != params + 0x11) {\n                    free(temp);\n                }\n                params[0xd] = 0;\n                return 0;\n            }\n        }\n    }\n    return 0;\n}\n",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ad0",
            "calling": [
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "process_data_08006ad0"
        },
        "FUN_080033b8": {
            "renaming": {
                "FUN_080033b8": "i2c_handle_event_080033b8",
                "*hi2c": "*i2c_handle",
                "I2C_HandleTypeDef": "i2c_handle_t",
                "hi2c": "i2c_handle",
                "I2C_TypeDef": "i2c_instance_t",
                "pIVar1": "i2c_instance",
                "uVar2": "sr1",
                "uVar3": "cr2",
                "uVar4": "sr2",
                "I2C_SR1_SB": "0x0001",
                "I2C_CR2_START": "0x0001",
                "I2C_SR1_ADDR": "0x0002",
                "I2C_SR1_TXE": "0x0080",
                "I2C_SR1_BTF": "0x0040",
                "I2C_SR2_MSL": "0x0001",
                "I2C_SR1_RXNE": "0x0040",
                "I2C_SR1_STOPF": "0x0010",
                "I2C_SR2_TRA": "0x0004",
                "I2C_Master_ADDR": "i2c_master_addr",
                "I2C_Master_ADD10": "i2c_master_add10",
                "I2C_Master_SB": "i2c_master_sb",
                "I2C_MasterReceive_RXNE": "i2c_master_receive_rxne",
                "I2C_MasterReceive_BTF": "i2c_master_receive_btf",
                "I2C_MasterTransmit_TXE": "i2c_master_transmit_txe",
                "I2C_MasterTransmit_BTF": "i2c_master_transmit_btf",
                "I2C_Slave_ADDR": "i2c_slave_addr",
                "I2C_Slave_STOPF": "i2c_slave_stopf",
                "I2C_SlaveReceive_RXNE": "i2c_slave_receive_rxne",
                "I2C_SlaveReceive_BTF": "i2c_slave_receive_btf",
                "I2C_SlaveTransmit_TXE": "i2c_slave_transmit_txe",
                "I2C_SlaveTransmit_BTF": "i2c_slave_transmit_btf"
            },
            "code": "void i2c_handle_event_080033b8(I2C_HandleTypeDef *hi2c) {\n    I2C_TypeDef *i2c_instance = hi2c->Instance;\n    uint32_t sr1 = i2c_instance->SR1;\n    uint32_t sr2 = i2c_instance->SR2;\n    uint32_t cr2 = i2c_instance->CR2;\n\n    if (hi2c->Mode == HAL_I2C_MODE_MASTER || hi2c->Mode == HAL_I2C_MODE_MEM) {\n        if ((sr1 & I2C_SR1_SB) == 0 || (cr2 & I2C_CR2_START) == 0) {\n            if ((I2C_SR1_ADDR & sr1) == 0 || (cr2 & I2C_CR2_START) == 0) {\n                if ((I2C_SR1_TXE & sr1) != 0 && (cr2 & I2C_CR2_START) != 0) {\n                    I2C_MasterTransmit_TXE(hi2c);\n                }\n            } else {\n                I2C_Master_ADD10(hi2c);\n            }\n        } else {\n            I2C_Master_SB(hi2c);\n        }\n\n        if ((sr2 & I2C_SR2_MSL) == 0) {\n            if ((I2C_SR1_ADDR & sr1) != 0 && (cr2 & I2C_CR2_START) != 0 && (I2C_SR1_RXNE & sr1) == 0) {\n                I2C_MasterReceive_RXNE(hi2c);\n            } else if ((I2C_SR1_BTF & sr1) != 0 && (cr2 & I2C_CR2_START) != 0) {\n                I2C_MasterReceive_BTF(hi2c);\n            }\n        } else {\n            if ((I2C_SR1_ADDR & sr1) != 0 && (cr2 & I2C_CR2_START) != 0 && (I2C_SR1_TXE & sr1) == 0) {\n                I2C_MasterTransmit_TXE(hi2c);\n            } else if ((I2C_SR1_BTF & sr1) != 0 && (cr2 & I2C_CR2_START) != 0) {\n                I2C_MasterTransmit_BTF(hi2c);\n            }\n        }\n    } else {\n        if ((I2C_SR1_ADDR & sr1) != 0 && (cr2 & I2C_CR2_START) != 0) {\n            I2C_Slave_ADDR(hi2c);\n        } else if ((I2C_SR1_STOPF & sr1) != 0 && (cr2 & I2C_CR2_START) != 0) {\n            I2C_Slave_STOPF(hi2c);\n        } else if ((sr2 & I2C_SR2_TRA) == 0) {\n            if ((I2C_SR1_RXNE & sr1) != 0 && (cr2 & I2C_CR2_START) != 0) {\n                I2C_SlaveReceive_RXNE(hi2c);\n            } else if ((I2C_SR1_BTF & sr1) != 0 && (cr2 & I2C_CR2_START) != 0) {\n                I2C_SlaveReceive_BTF(hi2c);\n            }\n        } else {\n            if ((I2C_SR1_TXE & sr1) != 0 && (cr2 & I2C_CR2_START) != 0) {\n                I2C_SlaveTransmit_TXE(hi2c);\n            } else if ((I2C_SR1_BTF & sr1) != 0 && (cr2 & I2C_CR2_START) != 0) {\n                I2C_SlaveTransmit_BTF(hi2c);\n            }\n        }\n    }\n}\n",
            "called": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_ADDR",
                "I2C_Slave_STOPF",
                "I2C_Master_ADD10",
                "I2C_SlaveTransmit_BTF",
                "I2C_MasterReceive_BTF",
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE",
                "I2C_SlaveReceive_BTF",
                "I2C_Master_SB",
                "I2C_SlaveTransmit_TXE",
                "I2C_Master_ADDR",
                "I2C_MasterReceive_RXNE"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033b8",
            "calling": [
                "I2C2_EV_IRQHandler",
                "I2C1_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_event_080033b8"
        },
        "FUN_080069e4": {
            "renaming": {
                "FUN_080069e4": "validateStreamType_080069e4",
                "param_1": "streamType",
                "param_2": "streamBuffer",
                "iVar3": "impurePtr",
                "PTR__impure_ptr_08006ab0": "ptr_impure_ptr",
                "PTR___sf_fake_stdin_08006ab4": "ptr___sf_fake_stdin",
                "PTR___sf_fake_stdout_08006ab8": "ptr___sf_fake_stdout",
                "PTR___sf_fake_stderr_08006abc": "ptr___sf_fake_stderr",
                "uVar1": "bufferType2AsInt",
                "uVar2": "bufferType",
                "bufferType": "bufferType",
                "bufferTypeAsInt": "bufferTypeAsInt",
                "bufferType2": "bufferType2",
                "bufferType2AsInt": "bufferType2AsInt",
                "bufferType3": "bufferType3",
                "bufferType3AsInt": "bufferType3AsInt"
            },
            "code": "unsigned int validateStreamType_080069e4(unsigned int *streamType, unsigned int *streamBuffer) {\n  unsigned int impurePtr = *(unsigned int *)PTR__impure_ptr_08006ab0;\n  if ((impurePtr != 0) && (*(unsigned int *)(impurePtr + 0x18) == 0)) {\n    __sinit(impurePtr);\n  }\n  if (streamBuffer == (unsigned int *)PTR___sf_fake_stdin_08006ab4) {\n    streamBuffer = *(unsigned int **)(impurePtr + 4);\n  }\n  else if (streamBuffer == (unsigned int *)PTR___sf_fake_stdout_08006ab8) {\n    streamBuffer = *(unsigned int **)(impurePtr + 8);\n  }\n  else if (streamBuffer == (unsigned int *)PTR___sf_fake_stderr_08006abc) {\n    streamBuffer = *(unsigned int **)(impurePtr + 0xc);\n  }\n  unsigned short bufferType = *(unsigned short *)(streamBuffer + 3);\n  unsigned int bufferTypeAsInt = (unsigned int)bufferType;\n  if (-1 < (int)(bufferTypeAsInt << 0x1c)) {\n    if (-1 < (int)(bufferTypeAsInt << 0x1b)) {\n      *streamType = 9;\n      goto LAB_08006a14;\n    }\n    if ((int)(bufferTypeAsInt << 0x1d) < 0) {\n      if ((unsigned int *)streamBuffer[0xd] != (unsigned int *)0x0) {\n        if ((unsigned int *)streamBuffer[0xd] != streamBuffer + 0x11) {\n          _free_r(streamType);\n        }\n        streamBuffer[0xd] = 0;\n      }\n      *(unsigned short *)(streamBuffer + 3) = *(unsigned short *)(streamBuffer + 3) & 0xffdb;\n      streamBuffer[1] = 0;\n      *streamBuffer = streamBuffer[4];\n    }\n    *(unsigned short *)(streamBuffer + 3) = *(unsigned short *)(streamBuffer + 3) | 8;\n  }\n  if ((streamBuffer[4] == 0) && ((*(unsigned short *)(streamBuffer + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(streamType,streamBuffer);\n  }\n  unsigned short bufferType2 = *(unsigned short *)(streamBuffer + 3);\n  unsigned int bufferType2AsInt = bufferType2 & 1;\n  if ((bufferType2 & 1) == 0) {\n    if (-1 < (int)((unsigned int)bufferType2 << 0x1e)) {\n      bufferType2AsInt = streamBuffer[5];\n    }\n    streamBuffer[2] = bufferType2AsInt;\n  }\n  else {\n    streamBuffer[2] = 0;\n    streamBuffer[6] = -streamBuffer[5];\n  }\n  if (streamBuffer[4] == 0) {\n    unsigned short bufferType3 = *(unsigned short *)(streamBuffer + 3);\n    unsigned int bufferType3AsInt = (int)(short)bufferType3 & 0x80;\n    if (bufferType3AsInt != 0) {\n      *(unsigned short *)(streamBuffer + 3) = bufferType3 | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    bufferType2AsInt = 0;\n  }\n  return bufferType2AsInt;\n}",
            "called": [
                "__sinit",
                "__smakebuf_r",
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080069e4",
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "validateStreamType_080069e4"
        },
        "FUN_080060bc": {
            "renaming": {
                "FUN_080060bc": "process_GPIO_EXTI_IRQHandler_080060bc",
                "uVar1": "pin_number"
            },
            "code": "void process_GPIO_EXTI_IRQHandler_080060bc(void)\n{\n  uint16_t pin_number;\n  for (pin_number = 0x400; pin_number < 0x8001; pin_number = pin_number << 1) {\n    HAL_GPIO_EXTI_IRQHandler(pin_number);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080060bc",
            "calling": [],
            "imported": false,
            "current_name": "process_GPIO_EXTI_IRQHandler_080060bc"
        },
        "FUN_08002580": {
            "renaming": {
                "FUN_08002580": "do_nothing_08002580"
            },
            "code": "\nvoid do_nothing_08002580(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002580",
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08002580"
        },
        "FUN_08004b9e": {
            "renaming": {
                "FUN_08004b9e": "incrementSysTick_08004b9e",
                "noOsSystickHandler": "handleSysTickEvent"
            },
            "code": "void incrementSysTick_08004b9e(void)\n{\n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  handleSysTickEvent();\n  return;\n}",
            "called": [
                "HAL_IncTick",
                "noOsSystickHandler",
                "HAL_SYSTICK_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b9e",
            "calling": [],
            "imported": false,
            "current_name": "incrementSysTick_08004b9e"
        },
        "FUN_08004b9c": {
            "renaming": {
                "FUN_08004b9c": "do_nothing_08004b9c"
            },
            "code": "\nvoid do_nothing_08004b9c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b9c",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "do_nothing_08004b9c"
        },
        "FUN_08006940": {
            "renaming": {
                "FUN_08006940": "process_input_08006940",
                "param_1": "stream_type",
                "param_2": "input_char",
                "param_3": "stream",
                "param_4": "param_4",
                "iVar1": "status",
                "uVar2": "char_count",
                "puVar3": "next_char"
            },
            "code": "uint process_input_08006940(int stream_type, uint input_char, int *stream, undefined4 param_4)\n{\n  int status;\n  uint char_count;\n  undefined *next_char;\n  \n  if ((stream_type != 0) && (*(int *)(stream_type + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == (int *)PTR___sf_fake_stdin_080069d8) {\n    stream = *(int **)(stream_type + 4);\n  }\n  else if (stream == (int *)PTR___sf_fake_stdout_080069dc) {\n    stream = *(int **)(stream_type + 8);\n  }\n  else if (stream == (int *)PTR___sf_fake_stderr_080069e0) {\n    stream = *(int **)(stream_type + 0xc);\n  }\n  stream[2] = stream[6];\n  char_count = (uint)*(ushort *)(stream + 3);\n  status = char_count << 0x1c;\n  if (((status < 0) && (char_count = stream[4], char_count != 0)) ||\n     (status = __swsetup_r(stream_type, stream, status, char_count, param_4), status == 0)) {\n    input_char = input_char & 0xff;\n    status = *stream - stream[4];\n    if ((status < stream[5]) || (status = _fflush_r(stream_type, stream), status == 0)) {\n      stream[2] = stream[2] + -1;\n      next_char = (undefined *)*stream;\n      *stream = (int)(next_char + 1);\n      *next_char = (char)input_char;\n      if (status + 1 != stream[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return input_char;\n        }\n        if (input_char != 10) {\n          return input_char;\n        }\n      }\n      status = _fflush_r(stream_type, stream);\n      if (status == 0) {\n        return input_char;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006940",
            "calling": [
                "__sfputc_r"
            ],
            "imported": false,
            "current_name": "process_input_08006940"
        },
        "FUN_08005730": {
            "renaming": {
                "FUN_08005730": "convert_to_uart_debug_format_08005730",
                "file_UNUSED": "file_unused",
                "ptr": "data",
                "len": "length",
                "sVar1": "converted_data"
            },
            "code": "uint8_t* convert_to_uart_debug_format_08005730(int file_unused, char* data, int length) {\n\treturn uart_debug_convert((uint8_t *)data, length);\n}",
            "called": [
                "uart_debug_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005730",
            "calling": [
                "_write_r"
            ],
            "imported": false,
            "current_name": "convert_to_uart_debug_format_08005730"
        },
        "FUN_080058ea": {
            "renaming": {
                "FUN_080058ea": "getNextTail_080058ea",
                "obj": "serial_data",
                "iVar3": "next_tail",
                "uVar1": "next_tail_ushort",
                "uVar2": "masked_next_tail"
            },
            "code": "int getNextTail_080058ea(serial_t_conflict *serial_data) {\n  int next_tail = serial_data->tx_tail + 1;\n  ushort next_tail_ushort = (ushort)next_tail;\n  uint16_t masked_next_tail = next_tail_ushort & 0x7f;\n  if (next_tail == 0) {\n    masked_next_tail = -(-next_tail_ushort & 0x7f);\n  }\n  serial_data->tx_tail = masked_next_tail;\n  if (serial_data->tx_head != serial_data->tx_tail) {\n    return 0;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058ea",
            "calling": [],
            "imported": false,
            "current_name": "getNextTail_080058ea"
        },
        "FUN_08002582": {
            "renaming": {
                "FUN_08002582": "run_systick_callback_08002582"
            },
            "code": "void run_systick_callback_08002582(void)\n{\n  HAL_SYSTICK_Callback();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002582",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "run_systick_callback_08002582"
        },
        "FUN_08005976": {
            "renaming": {
                "FUN_08005976": "wait_for_tx_complete_08005976",
                "this": "serial_obj",
                "_written": "has_data_to_write",
                "_serial": "tx_buffer",
                "tx_head": "tx_buffer_head",
                "tx_tail": "tx_buffer_tail"
            },
            "code": "void __thiscall HardwareSerial::wait_for_tx_complete_08005976(HardwareSerial *serial_obj)\n{\n  if (serial_obj->has_data_to_write) {\n    while ((serial_obj->tx_buffer_head) != (serial_obj->tx_buffer_tail));\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005976",
            "calling": [],
            "imported": false,
            "current_name": "wait_for_tx_complete_08005976"
        },
        "FUN_08004884": {
            "renaming": {
                "FUN_08004884": "get_GPIO_08004884",
                "port_idx": "port_index",
                "pGVar1": "port",
                "tmpreg": "pin_config",
                "tmpreg_1": "gpio_base_addr",
                "tmpreg_2": "gpio_crh_reg",
                "tmpreg_3": "gpio_crl_reg",
                "tmpreg_4": "unused_variable",
                "DAT_08004914": "gpio_base_addr",
                "DAT_08004918": "GPIOA",
                "DAT_0800491c": "GPIOB",
                "DAT_08004920": "GPIOC",
                "DAT_08004924": "GPIOD",
                "DAT_08004928": "GPIOE"
            },
            "code": "GPIO_TypeDef* get_GPIO_08004884(uint32_t port_index)\n{\n    GPIO_TypeDef* port = NULL;\n    uint32_t* DAT_08004914 = (uint32_t*)0x40000000;\n    uint32_t* gpio_crh_reg = DAT_08004914 + 0x04;\n    uint32_t* gpio_crl_reg = DAT_08004914 + 0x08;\n    uint32_t pin_config = 0;\n\n    switch(port_index)\n    {\n        case 0:\n            pin_config = 0x00000004;\n            port = (GPIO_TypeDef*)0x40010800;\n            break;\n        case 1:\n            pin_config = 0x00000008;\n            port = (GPIO_TypeDef*)0x40010C00;\n            break;\n        case 2:\n            pin_config = 0x00000010;\n            port = (GPIO_TypeDef*)0x40011000;\n            break;\n        case 3:\n            pin_config = 0x00000020;\n            port = (GPIO_TypeDef*)0x40011400;\n            break;\n        case 4:\n            pin_config = 0x00000040;\n            port = (GPIO_TypeDef*)0x40011800;\n            break;\n        default:\n            break;\n    }\n\n    if (port != NULL)\n    {\n        if (port_index < 2)\n        {\n            *gpio_crl_reg |= pin_config;\n        }\n        else\n        {\n            *gpio_crh_reg |= pin_config;\n        }\n    }\n\n    return port;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004884",
            "calling": [
                "digital_io_init",
                "HAL_ADC_MspInit",
                "uart_init"
            ],
            "imported": false,
            "current_name": "get_GPIO_08004884"
        },
        "FUN_08005fa0": {
            "renaming": {
                "FUN_08005fa0": "free_gpio_irq_configurations_08005fa0",
                "param_1": "memory_block",
                "puVar1": "current_block",
                "puVar2": "previous_block"
            },
            "code": "void free_gpio_irq_configurations_08005fa0(void *memory_block)\n{\n  undefined *current_block = PTR___malloc_free_list_08005fc0;\n  while (current_block != PTR_gpio_irq_conf_08005fc4) {\n    undefined *previous_block = current_block - 0x14;\n    if (*(code **)(current_block - 8) != (code *)0x0) {\n      (**(code **)(current_block - 8))(current_block - 0x10, current_block - 0x10, 3);\n    }\n    current_block = previous_block;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005fa0",
            "calling": [],
            "imported": false,
            "current_name": "free_gpio_irq_configurations_08005fa0"
        },
        "FUN_08001be8": {
            "renaming": {
                "FUN_08001be8": "initialize_and_execute_program_08001be8",
                "iVar1": "index",
                "puVar2": "completed",
                "UNRECOVERED_JUMPTABLE": "UNRECOVERED_JUMPTABLE"
            },
            "code": "void initialize_and_execute_program_08001be8(void)\n{\n  int index;\n  undefined4 *completed = (undefined4 *)PTR_completed_8667_08001c28;\n  code *UNRECOVERED_JUMPTABLE;\n  for (index = 0; PTR___dso_handle_08001c20 + index < PTR__edata_08001c24; index += 4) {\n    *(undefined4 *)(PTR___dso_handle_08001c20 + index) = *(undefined4 *)(PTR__sidata_08001c1c + index);\n  }\n  for (; completed < PTR__ebss_08001c2c; completed++) {\n    *completed = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  UNRECOVERED_JUMPTABLE = (code *)0x8001c1a;\n  main();\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}",
            "called": [
                "main",
                "__libc_init_array",
                "SystemInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001be8",
            "calling": [],
            "imported": false,
            "current_name": "initialize_and_execute_program_08001be8"
        },
        "FUN_080061f0": {
            "renaming": {
                "FUN_080061f0": "allocate_memory_block_080061f0",
                "param_1": "error_code",
                "param_2": "block_size",
                "param_3": "unused1",
                "param_4": "unused2",
                "puVar1": "block_header_ptr",
                "extraout_r1": "previous_block_ptr",
                "ppiVar2": "previous_block_ptr",
                "ppiVar3": "current_block_ptr",
                "piVar4": "block_header_ptr",
                "ppiVar5": "free_list_head_ptr",
                "ppiVar6": "free_list_head_ptr",
                "ppiVar7": "current_block_ptr"
            },
            "code": "void allocate_memory_block_080061f0(int *error_code, int block_size, int unused1, int unused2)\n{\n  int **previous_block_ptr;\n  int **current_block_ptr;\n  int *block_header_ptr;\n  int **free_list_head_ptr;\n  \n  if (block_size == 0) {\n    return;\n  }\n  current_block_ptr = (int **)(block_size + -4);\n  if (*(int *)(block_size + -4) < 0) {\n    current_block_ptr = (int **)((int)current_block_ptr + *(int *)(block_size + -4));\n  }\n  __malloc_lock();\n  block_header_ptr = PTR___malloc_free_list_08006284;\n  free_list_head_ptr = *(int ***)PTR___malloc_free_list_08006284;\n  if (free_list_head_ptr == (int **)0x0) {\n    current_block_ptr[1] = (int *)0x0;\n    *(int ***)block_header_ptr = current_block_ptr;\n    previous_block_ptr = current_block_ptr;\n    current_block_ptr = (int **)block_header_ptr;\n  }\n  else if (current_block_ptr < free_list_head_ptr) {\n    previous_block_ptr = (int **)*current_block_ptr;\n    current_block_ptr = (int **)((int)current_block_ptr + (int)previous_block_ptr);\n    if (free_list_head_ptr == current_block_ptr) {\n      block_header_ptr = *free_list_head_ptr;\n      free_list_head_ptr = (int **)free_list_head_ptr[1];\n      current_block_ptr = (int **)((int)block_header_ptr + (int)previous_block_ptr);\n      *current_block_ptr = (int *)block_header_ptr;\n    }\n    current_block_ptr[1] = (int *)free_list_head_ptr;\n    *(int ***)block_header_ptr = current_block_ptr;\n  }\n  else {\n    do {\n      previous_block_ptr = free_list_head_ptr;\n      current_block_ptr = (int **)previous_block_ptr[1];\n      if (current_block_ptr == (int **)0x0) break;\n      free_list_head_ptr = current_block_ptr;\n    } while (current_block_ptr <= current_block_ptr);\n    previous_block_ptr = (int **)*previous_block_ptr;\n    if ((int **)((int)previous_block_ptr + (int)current_block_ptr) == current_block_ptr) {\n      current_block_ptr = (int **)((int)current_block_ptr + (int)*previous_block_ptr);\n      *previous_block_ptr = (int *)current_block_ptr;\n      if (current_block_ptr == (int **)((int)previous_block_ptr + (int)current_block_ptr[1])) {\n        block_header_ptr = *current_block_ptr[1];\n        current_block_ptr[1] = (int *)block_header_ptr[1];\n        current_block_ptr = (int **)((int)current_block_ptr + (int)block_header_ptr);\n        *previous_block_ptr = (int *)current_block_ptr;\n      }\n    }\n    else if (current_block_ptr < (int **)((int)previous_block_ptr + (int)*previous_block_ptr)) {\n      *error_code = 0xc;\n    }\n    else {\n      current_block_ptr = (int **)((int)current_block_ptr + (int)*current_block_ptr);\n      if (current_block_ptr == (int **)current_block_ptr[1]) {\n        block_header_ptr = *current_block_ptr[1];\n        current_block_ptr = (int **)((int)block_header_ptr + (int)*current_block_ptr);\n      }\n      current_block_ptr[1] = (int *)current_block_ptr[1];\n      previous_block_ptr[1] = (int *)current_block_ptr;\n    }\n  }\n  __malloc_unlock(error_code,previous_block_ptr,current_block_ptr,unused2);\n  return;\n}",
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080061f0",
            "calling": [
                "__sflush_r",
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_080061f0"
        },
        "FUN_08002348": {
            "renaming": {
                "FUN_08002348": "stopAndDisableConversion_08002348",
                "*hadc": "*adc",
                "HVar1": "status",
                "Lock": "isLocked",
                "HAL_LOCKED": "1",
                "HAL_UNLOCKED": "0",
                "State": "state",
                "ADC_ConversionStop_Disable": "ADC_ConversionStopAndDisable"
            },
            "code": "HAL_StatusTypeDef_conflict stopAndDisableConversion_08002348(ADC_HandleTypeDef *adc)\n{\n  HAL_StatusTypeDef_conflict status;\n  if (adc->isLocked) {\n    return HAL_BUSY;\n  }\n  adc->isLocked = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(adc);\n  if (status == HAL_OK) {\n    adc->state = adc->state & 0xffffeefe | 1;\n  }\n  adc->isLocked = HAL_UNLOCKED;\n  return status;\n}",
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002348",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "stopAndDisableConversion_08002348"
        },
        "FUN_08004f1c": {
            "renaming": {
                "FUN_08004f1c": "handle_I2C_errors_08004f1c",
                "PTR_i2c_handles_08004f28": "i2c_handle_ptr"
            },
            "code": "void handle_I2C_errors_08004f1c(void)\n{\n  I2C_HandleTypeDef* PTR_i2c_handles_08004f28 = *(I2C_HandleTypeDef **)PTR_i2c_handles_08004f28;\n  HAL_I2C_ER_IRQHandler(PTR_i2c_handles_08004f28);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f1c",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_errors_08004f1c"
        },
        "FUN_080060d4": {
            "renaming": {
                "__thiscall std::function<void()>::operator__": "execute_function",
                "this": "function_ptr",
                "function_void___": "function_ptr",
                "_M_manager": "manager",
                "_M_invoker": "invoker",
                "_Any_data": "any_data",
                "__throw_bad_function_call": "throw_bad_function_call",
                "FUN_080060d4": "execute_function_080060d4"
            },
            "code": "void __thiscall execute_function_080060d4(std::function<void()>::function_void___ *function_ptr) {\n    if ((function_ptr->super__Function_base)._M_manager != (_Manager_type)0x0) {\n        (*function_ptr->_M_invoker)((_Any_data *)function_ptr);\n        return;\n    }\n    __throw_bad_function_call();\n}",
            "called": [
                "__throw_bad_function_call"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080060d4",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "execute_function_080060d4"
        },
        "FUN_08005a68": {
            "renaming": {
                "FUN_08005a68": "setSerialConfig_08005a68",
                "this": "serial",
                "baud": "baudrate",
                "config": "config",
                "bVar1": "parityBits",
                "iVar2": "dataBits",
                "_serial": "_serial",
                "_config": "_config",
                "PTR_s__home_bo__arduino15_packages_STM_08005b20": "PTR_s__home_bo__arduino15_packages_STM_08005b20",
                "DAT_08005b14": "DAT_08005b14",
                "PTR___PRETTY_FUNTION___08005b1c": "PTR___PRETTY_FUNTION___08005b1c",
                "PTR_s_databits__0_08005b18": "PTR_s_databits__0_08005b18"
            },
            "code": "void __thiscall setSerialConfig_08005a68(HardwareSerial *serial, ulong baudrate, byte config) {\n  byte parityBits = config & 0x30;\n  byte dataBits = 0;\n  int stopBits = ((config & 8) == 0) ? 0 : 0x2000;\n  if ((config & 7) == 4) {\n    dataBits = 7;\n  }\n  else if ((config & 7) == 6) {\n    dataBits = 8;\n  }\n  else if ((config & 7) == 2) {\n    dataBits = 6;\n  }\n  if (parityBits == 0x30) {\n    (serial->_serial).parity = 0x600;\n    dataBits++;\n  }\n  else if (parityBits == 0) {\n    (serial->_serial).parity = 0;\n  }\n  else {\n    (serial->_serial).parity = 0x400;\n    dataBits++;\n  }\n  if (dataBits == 8) {\n    (serial->_serial).databits = 0;\n  }\n  else if (dataBits == 9) {\n    (serial->_serial).databits = 0x1000;\n  }\n  else {\n    return;\n  }\n  (serial->_serial).baudrate = baudrate;\n  (serial->_config) = config;\n  uart_init((serial_t *)&(serial->_serial));\n  uart_attach_rx_callback((serial_t *)&(serial->_serial), PTR___PRETTY_FUNTION___08005b1c);\n}\n",
            "called": [
                "__assert_func",
                "uart_attach_rx_callback",
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a68",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "setSerialConfig_08005a68"
        },
        "FUN_08001814": {
            "renaming": {
                "FUN_08001814": "initialize_parameters_08001814",
                "this": "pid_instance",
                "Kp": "proportional_gain",
                "Ki": "integral_gain",
                "Kd": "derivative_gain",
                "POn": "controller_direction",
                "iVar1": "is_less_than_zero",
                "uVar2": "quotient_high",
                "in_r2": "in_register_2",
                "in_r3": "in_register_3",
                "uVar3": "quotient_low",
                "bVar4": "derivative_gain_not_one",
                "uVar5": "sample_time_seconds",
                "dVar6": "proportional_term",
                "dVar7": "integral_term",
                "dVar8": "derivative_term"
            },
            "code": "void PID::initialize_parameters_08001814(PID *pid_instance, double proportional_gain, double integral_gain, double derivative_gain, int controller_direction) {\n    bool proportional_on;\n    double sample_time_seconds;\n    double proportional_term;\n    double integral_term;\n    double derivative_term;\n    \n    proportional_on = derivative_gain != 1;\n    if (proportional_on) {\n        derivative_gain = 0;\n    }\n    pid_instance->proportional_on_error = proportional_on;\n    pid_instance->proportional_gain_display = proportional_gain;\n    pid_instance->integral_gain_display = integral_gain;\n    pid_instance->derivative_gain_display = derivative_gain;\n    sample_time_seconds = (double)pid_instance->SampleTime / 1000;\n    proportional_term = proportional_gain * sample_time_seconds;\n    integral_term = integral_gain / sample_time_seconds;\n    derivative_term = derivative_gain / sample_time_seconds;\n    if (controller_direction == 1) {\n        proportional_term = -proportional_term;\n        integral_term = -integral_term;\n        derivative_term = -derivative_term;\n    }\n    pid_instance->proportional_gain = proportional_term;\n    pid_instance->integral_gain = integral_term;\n    pid_instance->derivative_gain = derivative_term;\n}",
            "called": [
                "__subdf3",
                "__aeabi_dcmplt",
                "__muldf3",
                "__divdf3",
                "__floatunsidf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001814",
            "calling": [
                "SetTunings",
                "PID"
            ],
            "imported": false,
            "current_name": "initialize_parameters_08001814"
        },
        "FUN_080056c0": {
            "renaming": {
                "FUN_080056c0": "handle_UART_interrupt_080056c0",
                "PTR_uart_handlers_080056d4": "PTR_uart_handlers",
                "USART3_IRQn": "UART_interrupt",
                "UART_HandleTypeDef": "UART_handler",
                "uart_handler": "current_UART_handler"
            },
            "code": "void handle_UART_interrupt_080056c0(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART3_IRQn);\n  UART_HandleTypeDef* uart_handler = *(UART_HandleTypeDef**)(PTR_uart_handlers_080056d4_080056d4 + 8);\n  if (uart_handler != NULL)\n  {\n    HAL_UART_IRQHandler(uart_handler);\n  }\n  return;\n}",
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080056c0",
            "calling": [],
            "imported": false,
            "current_name": "handle_UART_interrupt_080056c0"
        },
        "FUN_08000aec": {
            "renaming": {
                "FUN_08000aec": "call_afl_if_not_hypercall_08000aec",
                "ticks": "number_of_ticks",
                "uVar1": "afl_result",
                "aflCall": "call_afl_function"
            },
            "code": "int call_afl_if_not_hypercall_08000aec(int ticks)\n{\n  uint32_t afl_result;\n  if (*(int *)PTR_noHyperCall_08000b04 != 0) {\n    return 0;\n  }\n  afl_result = call_afl_function(1, ticks, 0);\n  return afl_result;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000aec",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "call_afl_if_not_hypercall_08000aec"
        },
        "FUN_0800572c": {
            "renaming": {
                "FUN_0800572c": "calculate_checksum_0800572c",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "data_pointer",
                "len_UNUSED": "data_length"
            },
            "code": "int calculate_checksum_0800572c(int file_descriptor, char *data_pointer, int data_length) {\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800572c",
            "calling": [
                "_read_r"
            ],
            "imported": false,
            "current_name": "calculate_checksum_0800572c"
        },
        "FUN_08004e12": {
            "renaming": {
                "FUN_08004e12": "handle_timer_interrupt_08004e12",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "get_timer_obj": "get_timer_object",
                "irqHandle": "interrupt_handler"
            },
            "code": "void handle_timer_interrupt_08004e12(TIM_HandleTypeDef *timer_handle)\n{\n  stimer_t *timer_obj;\n  timer_obj = get_timer_object(timer_handle);\n  if (timer_obj->interrupt_handler != (_func_void_stimer_t_ptr *)0x0) {\n    (*timer_obj->interrupt_handler)(timer_obj);\n  }\n  return;\n}",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e12",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_08004e12"
        },
        "FUN_08000a58": {
            "renaming": {
                "FUN_08000a58": "calculate_08000a58",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar1": "quotient",
                "iVar2": "temp",
                "uVar3": "remainder"
            },
            "code": "uint calculate_08000a58(uint dividend, uint divisor)\n{\n    uint quotient;\n    int temp;\n    uint remainder;\n\n    temp = divisor * 2 + 0x200000;\n    if (divisor * 2 < 0xffe00000)\n    {\n        if (-1 < temp)\n        {\n            return 0;\n        }\n        quotient = temp >> 0x15;\n        remainder = -quotient - 0x3e1;\n        if (quotient < 0xfffffc20 && remainder != 0)\n        {\n            quotient = (divisor << 0xb | 0x80000000 | dividend >> 0x15) >> (remainder & 0xff);\n            if ((divisor & 0x80000000) != 0)\n            {\n                quotient = -quotient;\n            }\n            return quotient;\n        }\n    }\n    else if ((dividend | divisor << 0xc) != 0)\n    {\n        return 0;\n    }\n    divisor = divisor & 0x80000000;\n    if (divisor == 0)\n    {\n        divisor = 0x7fffffff;\n    }\n    return divisor;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a58",
            "calling": [
                "printFloat"
            ],
            "imported": false,
            "current_name": "calculate_08000a58"
        },
        "FUN_08001b48": {
            "renaming": {
                "FUN_08001b48": "configureSystemClock_08001b48",
                "HVar1": "status",
                "uVar2": "hclkFreq",
                "PeriphClkInit": "periphClkInit",
                "RCC_ClkInitStruct": "clkInit",
                "RCC_OscInitStruct": "oscInit"
            },
            "code": "void configureSystemClock_08001b48(void)\n{\n  HAL_StatusTypeDef status;\n  uint32_t hclkFreq;\n  RCC_PeriphCLKInitTypeDef periphClkInit;\n  RCC_ClkInitTypeDef clkInit;\n  RCC_OscInitTypeDef oscInit;\n  oscInit.OscillatorType = RCC_OSCILLATORTYPE_HSI;\n  oscInit.HSIState = RCC_HSI_ON;\n  oscInit.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;\n  oscInit.PLL.PLLState = RCC_PLL_ON;\n  oscInit.PLL.PLLSource = RCC_PLLSOURCE_HSI;\n  oscInit.PLL.PLLMUL = RCC_PLL_MUL6;\n  status = HAL_RCC_OscConfig(&oscInit);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08001be4,0x88);\n  }\n  clkInit.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;\n  clkInit.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  clkInit.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  clkInit.APB1CLKDivider = RCC_HCLK_DIV2;\n  clkInit.APB2CLKDivider = RCC_HCLK_DIV1;\n  status = HAL_RCC_ClockConfig(&clkInit, FLASH_LATENCY_1);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08001be4,0x95);\n  }\n  periphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;\n  periphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV8;\n  status = HAL_RCCEx_PeriphCLKConfig(&periphClkInit);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08001be4,0x9c);\n  }\n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config((uint32_t)(SYSTICK_PERIOD * hclkFreq));\n  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);\n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n}\n",
            "called": [
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_Config",
                "HAL_RCC_OscConfig",
                "HAL_RCCEx_PeriphCLKConfig",
                "_Error_Handler",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_ClockConfig",
                "HAL_SYSTICK_CLKSourceConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001b48",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "configureSystemClock_08001b48"
        },
        "FUN_08004092": {
            "renaming": {
                "FUN_08004092": "set_channel_state_08004092",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "channel_state",
                "CCER": "cc_enabled_mask",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "void set_channel_state_08004092(TIM_TypeDef *timer, uint32_t channel, uint32_t channel_state) {\n    uint32_t channel_bit = channel & 0xff;\n    uint32_t cc_enabled_mask = ~(1 << channel_bit);\n    timer->CCER &= cc_enabled_mask;\n    timer->CCER |= channel_state << channel_bit;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004092",
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "imported": false,
            "current_name": "set_channel_state_08004092"
        },
        "FUN_08005cd4": {
            "renaming": {
                "FUN_08005cd4": "printAndReturnSize_08005cd4",
                "this": "printObject",
                "c": "stringToPrint",
                "sVar1": "sizeOfPrintedString",
                "sVar2": "sizeOfPrintedStringFromFun"
            },
            "code": "size_t __thiscall Print::printAndReturnSize_08005cd4(Print *printObject,char *stringToPrint)\n{\n  size_t sizeOfPrintedString;\n  sizeOfPrintedString = print(printObject,stringToPrint);\n  size_t sizeOfPrintedStringFromFun = printAndReturnSize_08005cd4(printObject);\n  return sizeOfPrintedStringFromFun + sizeOfPrintedString;\n}",
            "called": [
                "print",
                "println"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cd4",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "printAndReturnSize_08005cd4"
        },
        "FUN_08000450": {
            "renaming": {
                "FUN_08000450": "reverse_bits_08000450",
                "param_1": "num",
                "param_2": "unused1",
                "param_3": "unused2",
                "param_4": "unused3",
                "uVar1": "top_bit",
                "uVar2": "lower_bits",
                "uVar3": "reversed_top_bit",
                "uVar4": "shifted_num",
                "uVar5": "reversed_num",
                "uVar7": "shift_amount",
                "iVar6": "leading_zeros",
                "bVar8": "is_zero_shift",
                "bVar9": "is_extreme_shift",
                "bVar10": "is_negative_shift",
                "in_r12": "unused4"
            },
            "code": "uint64_t reverse_bits_08000450(uint32_t num)\n{\n  uint32_t reversed_num = 0;\n  for (int i = 0; i < 32; i++) {\n    uint32_t bit = (num >> i) & 1;\n    reversed_num |= bit << (31 - i);\n  }\n  uint64_t result = (((uint64_t) reversed_num) << 32) | num;\n  return (reversed_num == 0 || reversed_num == 0xffffffff) ? result : (result ^ 0x3800000000000000);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000450",
            "calling": [],
            "imported": false,
            "current_name": "reverse_bits_08000450"
        },
        "FUN_08005bb0": {
            "renaming": {
                "FUN_08005bb0": "initializeHardwareSerial_08005bb0",
                "__initialize_p": "should_initialize",
                "__priority": "priority_level",
                "PTR_Serial2_08005bd0": "serial2_ptr",
                "DAT_08005bcc": "data_ptr"
            },
            "code": "void initializeHardwareSerial_08005bb0(int should_initialize, int priority_level)\n{\n    if (should_initialize != 1) {\n        return;\n    }\n    if (priority_level == 0xffff) {\n        HardwareSerial::HardwareSerial(&PTR_Serial2_08005bd0, DAT_08005bcc);\n    }\n    return;\n}",
            "called": [
                "HardwareSerial"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bb0",
            "calling": [
                "_GLOBAL__sub_I_Serial2"
            ],
            "imported": false,
            "current_name": "initializeHardwareSerial_08005bb0"
        },
        "FUN_080014ba": {
            "renaming": {
                "__thiscall LiquidCrystal::FUN_080014ba": "setLCDPins",
                "this": "lcd",
                "fourbitmode": "four_bit_mode",
                "rs": "rs_pin",
                "rw": "rw_pin",
                "enable": "enable_pin",
                "d0": "data_pins[0]",
                "d1": "data_pins[1]",
                "d2": "data_pins[2]",
                "d3": "data_pins[3]",
                "d4": "data_pins[4]",
                "d5": "data_pins[5]",
                "d6": "data_pins[6]",
                "d7": "data_pins[7]",
                "_rs_pin": "rs_pin",
                "_rw_pin": "rw_pin",
                "_enable_pin": "enable_pin",
                "_data_pins[0]": "data_pins[0]",
                "_data_pins[1]": "data_pins[1]",
                "_data_pins[2]": "data_pins[2]",
                "_data_pins[3]": "data_pins[3]",
                "_data_pins[4]": "data_pins[4]",
                "_data_pins[5]": "data_pins[5]",
                "_data_pins[6]": "data_pins[6]",
                "_data_pins[7]": "data_pins[7]",
                "fourbitmode == '\\0'": "four_bit_mode == 0",
                "_displayfunction": "display_function",
                "'\\x10'": "0x10",
                "'\\x01'": "0x01",
                "'\\0'": "0x00",
                "begin": "begin",
                "FUN_080014ba": "setLCDPins_080014ba"
            },
            "code": "void setLCDPins_080014ba(LiquidCrystal *lcd, uint8_t four_bit_mode, uint8_t rs_pin, uint8_t rw_pin, uint8_t enable_pin, uint8_t data_pins[8]) {\n  lcd->rs_pin = rs_pin;\n  lcd->rw_pin = rw_pin;\n  lcd->enable_pin = enable_pin;\n  for (int i = 0; i < 8; i++) {\n    lcd->data_pins[i] = data_pins[i];\n  }\n  if (four_bit_mode == 0) {\n    lcd->display_function = 0x10;\n  }\n  else {\n    lcd->display_function = 0x00;\n  }\n  begin(lcd, 0x10, 0x01, 0x00);\n}\n",
            "called": [
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080014ba",
            "calling": [
                "LiquidCrystal"
            ],
            "imported": false,
            "current_name": "setLCDPins_080014ba"
        },
        "FUN_08003c90": {
            "renaming": {
                "FUN_08003c90": "configure_RCC_PeriphCLKInit_08003c90",
                "PeriphClkInit": "PeriphClkInit",
                "iVar1": "i",
                "puVar2": "p",
                "uVar3": "time_start",
                "uVar4": "time_current",
                "uVar5": "selection",
                "bVar6": "flag",
                "tmpreg": "tmpreg"
            },
            "code": "HAL_StatusTypeDef configure_RCC_PeriphCLKInit_08003c90(RCC_PeriphCLKInitTypeDef *PeriphClkInit){\n  int i;\n  uint32_t *p;\n  uint32_t time_start;\n  uint32_t time_current;\n  uint selection;\n  bool flag;\n  uint32_t tmpreg;\n  \n  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) != 0) {\n    flag = (*(uint *)(PTR_DAT_08003d98 + 0x1c) & RCC_BDCR_RTCEN) == 0;\n    if (flag) {\n      *(uint *)(PTR_DAT_08003d98 + 0x1c) = *(uint *)(PTR_DAT_08003d98 + 0x1c) | RCC_BDCR_RTCEN;\n    }\n    if ((*PTR_DAT_08003d9c & RCC_CR_BYPSHAD) == 0) {\n      *PTR_DAT_08003d9c = *PTR_DAT_08003d9c | RCC_CR_BYPSHAD;\n      time_start = HAL_GetTick();\n      while ((*PTR_DAT_08003d9c & RCC_CR_BYPSHAD) == 0) {\n        time_current = HAL_GetTick();\n        if (100 < time_current - time_start) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    p = PTR_DAT_08003da0;\n    i = PTR_DAT_08003d98;\n    selection = *(uint *)(PTR_DAT_08003d98 + RCC_BDCR_OFFSET) & RCC_BDCR_RTCSEL;\n    if ((selection != 0) && (selection != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))) {\n      selection = *(uint *)(PTR_DAT_08003d98 + RCC_BDCR_OFFSET);\n      *PTR_DAT_08003da0 = 1;\n      *p = 0;\n      *(uint *)(i + RCC_BDCR_OFFSET) = selection & RCC_BDCR_RTCSEL_CLEAR;\n      if ((selection & RCC_BDCR_RTCEN) != 0) {\n        time_start = HAL_GetTick();\n        while ((*(uint *)(PTR_DAT_08003d98 + RCC_BDCR_OFFSET) & RCC_BDCR_RTCEN) == 0) {\n          time_current = HAL_GetTick();\n          if (5000 < time_current - time_start) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    i = PTR_DAT_08003d98;\n    *(uint *)(PTR_DAT_08003d98 + RCC_BDCR_OFFSET) = *(uint *)(PTR_DAT_08003d98 + RCC_BDCR_OFFSET) & RCC_BDCR_RTCSEL_CLEAR | PeriphClkInit->RTCClockSelection;\n    if (flag) {\n      *(uint *)(i + 0x1c) = *(uint *)(i + 0x1c) & RCC_BDCR_RTCEN_CLEAR;\n    }\n  }\n  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) != 0) {\n    *(uint *)(PTR_DAT_08003d98 + RCC_CFGR_OFFSET) = *(uint *)(PTR_DAT_08003d98 + RCC_CFGR_OFFSET) & RCC_CFGR_ADCPRE_CLEAR | PeriphClkInit->AdcClockSelection;\n  }\n  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USB) != 0) {\n    *(uint *)(PTR_DAT_08003d98 + RCC_CFGR_OFFSET) = *(uint *)(PTR_DAT_08003d98 + RCC_CFGR_OFFSET) & RCC_CFGR_USBPRE_CLEAR | PeriphClkInit->UsbClockSelection;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003c90",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configure_RCC_PeriphCLKInit_08003c90"
        },
        "FUN_08002514": {
            "renaming": {
                "FUN_08002514": "calculate_ticks_08002514",
                "TicksNumb": "ticks_number",
                "puVar1": "pointer_to_dat",
                "DAT_08002538": "pointer_to_dat",
                "DAT_0800253c": "pointer_to_dat_2"
            },
            "code": "uint32_t calculate_ticks_08002514(uint32_t ticks_number)\n{\n  undefined4 *DAT_08002538 = DAT_08002538;\n  if (ticks_number - 1 < 0x1000000) {\n    DAT_08002538[1] = ticks_number - 1;\n    *(undefined *)(DAT_0800253c + 0x23) = 0xf0;\n    DAT_08002538[2] = 0;\n    *DAT_08002538 = 7;\n    return 0;\n  }\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002514",
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "imported": false,
            "current_name": "calculate_ticks_08002514"
        },
        "FUN_08005c1c": {
            "renaming": {
                "FUN_08005c1c::FUN_08005c1c": "createPrintableIPAddress",
                "first_octet": "firstOctet",
                "second_octet": "secondOctet",
                "third_octet": "thirdOctet",
                "fourth_octet": "fourthOctet",
                "super_Printable": "superPrintable",
                "_vptr_Printable": "_vptrPrintable",
                "_address": "ipAddress",
                "bytes": "octets",
                "FUN_08005c1c": "createPrintableIPAddress_08005c1c"
            },
            "code": "createPrintableIPAddress_08005c1c * __thiscall createPrintableIPAddress_08005c1c(createPrintableIPAddress_08005c1c *this, uint8_t firstOctet, uint8_t secondOctet, uint8_t thirdOctet, uint8_t fourthOctet)\n{\n  (this->superPrintable)._vptrPrintable = (_func_int_varargs **)PTR_DAT_08005c34;\n  (this->_address).bytes[0] = firstOctet;\n  (this->_address).bytes[1] = secondOctet;\n  (this->_address).bytes[2] = thirdOctet;\n  (this->_address).bytes[3] = fourthOctet;\n  return this;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005c1c",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "createPrintableIPAddress_08005c1c"
        },
        "FUN_08006dc8": {
            "renaming": {
                "FUN_08006dc8": "determine_file_type_08006dc8",
                "param_1": "file_descriptor",
                "param_2": "file_info",
                "param_3": "file_type",
                "param_4": "error_code",
                "iVar1": "file_status",
                "uVar2": "type_code",
                "auStack_4c": "stack",
                "local_48": "file_type_mask"
            },
            "code": "int determine_file_type_08006dc8(int file_descriptor, int* file_info, int* file_type, unsigned int* error_code) {\n    int file_status;\n    unsigned int type_code;\n    if ((*(short *)(file_info + 0xe) < 0) ||\n        (file_status = _fstat_r(file_descriptor,(int)*(short *)(file_info + 0xe),&type_code), file_status < 0)) {\n        *error_code = 0;\n        if ((int)((uint)*(ushort *)(file_info + 0xc) << 0x18) < 0) {\n            *file_type = 0x40;\n            goto LAB_08006e08;\n        }\n    }\n    else {\n        *error_code = (unsigned int)((type_code & 0xf000) == 0x2000);\n    }\n    *file_type = 0x400;\nLAB_08006e08:\n    return 0;\n}",
            "called": [
                "_fstat_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006dc8",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "determine_file_type_08006dc8"
        },
        "FUN_0800412c": {
            "renaming": {
                "FUN_0800412c": "disableTimChannel_0800412c",
                "*htim": "timHandle",
                "Channel": "channel",
                "pTVar1": "timInstance",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "TIM_CCxNChannelCmd": "TIM_CCxNChannelCmd",
                "Instance": "Instance",
                "CCER": "CCER",
                "BDTR": "BDTR",
                "CR1": "CR1",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef_conflict disableTimChannel_0800412c(TIM_HandleTypeDef *timHandle, uint32_t channel)\n{\n    TIM_TypeDef *timInstance = timHandle->Instance;\n    TIM_CCxNChannelCmd(timInstance, channel, 0);\n    if (((timInstance->CCER & 0x1111) == 0) && ((timInstance->CCER & 0x444) == 0)) {\n        timInstance->BDTR &= 0xffff7fff;\n    }\n    if (((timInstance->CCER & 0x1111) == 0) && ((timInstance->CCER & 0x444) == 0)) {\n        timInstance->CR1 &= 0xfffffffe;\n    }\n    return HAL_OK;\n}",
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800412c",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "disableTimChannel_0800412c"
        },
        "FUN_08007090": {
            "renaming": {
                "std::FUN_08007090": "abort_if_called",
                "FUN_08007090": "abort_if_called_08007090"
            },
            "code": "void abort_if_called_08007090() {\n    abort();\n}",
            "called": [
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007090",
            "calling": [
                "operator()"
            ],
            "imported": false,
            "current_name": "abort_if_called_08007090"
        },
        "FUN_0800492c": {
            "renaming": {
                "FUN_0800492c": "get_adc_channel_number_0800492c",
                "pin": "pin_name",
                "uVar1": "pin_function",
                "PTR_PinMap_ADC_08004944": "adc_pin_map"
            },
            "code": "uint32_t get_adc_channel_number_0800492c(PinName_conflict pin)\n{\n  uint32_t pin_function = pinmap_function(pin, (PinMap_conflict *)PTR_PinMap_ADC_08004944);\n  uint32_t channel_number = (pin_function << 12) >> 27;\n  if (channel_number > 15) {\n    channel_number = 0;\n  }\n  return channel_number;\n}",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800492c",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_adc_channel_number_0800492c"
        },
        "FUN_08000cbc": {
            "renaming": {
                "FUN_08000cbc": "initialize_static_data_08000cbc"
            },
            "code": "void initialize_static_data_08000cbc(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000cbc",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_08000cbc"
        },
        "FUN_0800480a": {
            "renaming": {
                "FUN_0800480a": "set_pin_state_0800480a",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "pin_index"
            },
            "code": "void set_pin_state_0800480a(PinName_conflict pin, uint32_t *pin_map) {\n  uint32_t pin_index = (uint32_t)pin >> 28;\n  uint32_t pin_bit = (uint32_t)pin & 0x0F;\n  pin_map[pin_index] |= (1 << pin_bit);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800480a",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "set_pin_state_0800480a"
        },
        "FUN_080015f8": {
            "renaming": {
                "MAX31855::FUN_080015f8": "convertTemperature",
                "this": "sensor",
                "unit": "unit",
                "uVar1": "rawData",
                "uVar2": "tempData",
                "uVar4": "temp",
                "uVar5": "tempComp",
                "extraout_d0": "0.0",
                "extraout_d0_00": "NAN",
                "dVar3": "temp",
                "FUN_080015f8": "convertTemperature_080015f8"
            },
            "code": "double __thiscall convertTemperature_080015f8(MAX31855 *sensor, unit_t unit) {\n  ulong rawData = readData(sensor);\n  if ((rawData & 0x10000) != 0) {\n    uint fault = rawData & 7;\n    if (fault == 2 || fault == 4) {\n      return 0.0;\n    }\n    else {\n      return NAN;\n    }\n  }\n  else {\n    uint16_t tempData = rawData >> 0x12;\n    double temp = __floatunsidf(tempData & 0x1fff);\n    if ((tempData & 0x2000) != 0) {\n      double tempComp = __floatunsidf(~tempData & 0x1fff);\n      temp += __aeabi_dadd((int)tempComp, (int)((ulonglong)tempComp >> 0x20), 0, tempComp);\n      temp = temp & 0xffffffff | (ulonglong)((int)(temp >> 0x20) + 0x80000000) << 0x20;\n    }\n    temp = __muldf3((int)temp, (int)((ulonglong)temp >> 0x20), 0, 0.00390625);\n    if (unit == FAHRENHEIT) {\n      temp = __muldf3((int)temp, (int)((ulonglong)temp >> 0x20), 0, 1.8);\n      temp = __divdf3((int)temp, (int)((ulonglong)temp >> 0x20), 0, 1.8);\n      temp = __aeabi_dadd((int)temp, (int)((ulonglong)temp >> 0x20), 0, 32.0);\n    }\n    return temp;\n  }\n}",
            "called": [
                "readData",
                "__aeabi_dadd",
                "__muldf3",
                "__divdf3",
                "__floatunsidf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015f8",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "convertTemperature_080015f8"
        },
        "FUN_08005c38": {
            "renaming": {
                "FUN_08005c38": "initializeIPAddress_08005c38",
                "__initialize_p": "shouldInitialize",
                "__priority": "priorityLevel",
                "PTR_INADDR_NONE_08005c60": "PTR_INADDR_NONE",
                "IPAddress": "IPAddress"
            },
            "code": "void initializeIPAddress_08005c38(int shouldInitialize, int priorityLevel) {\n  if (shouldInitialize == 1 && priorityLevel == 0xffff) {\n    IPAddress::IPAddress((IPAddress *)PTR_INADDR_NONE_08005c60_08005c60, '\\0', '\\0', '\\0', '\\0');\n    return;\n  }\n  return;\n}",
            "called": [
                "IPAddress"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005c38",
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "imported": false,
            "current_name": "initializeIPAddress_08005c38"
        },
        "FUN_08005f8c": {
            "renaming": {
                "FUN_08005f8c": "getPinBitPosition_08005f8c",
                "pin": "pin",
                "uVar1": "pinCopy",
                "uVar2": "bitPosition"
            },
            "code": "uint8_t getPinBitPosition_08005f8c(uint16_t pin) {\n  uint16_t pinCopy = pin;\n  uint8_t bitPosition = 0;\n  while(pinCopy >>= 1) bitPosition++;\n  return bitPosition;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005f8c",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "getPinBitPosition_08005f8c"
        },
        "FUN_08006f5a": {
            "renaming": {
                "FUN_08006f5a": "write_to_file_at_offset_08006f5a",
                "param_1": "file_descriptor",
                "param_2": "offset",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "position": "file_position",
                "PTR_short_1": "offset",
                "PTR_ushort_2": "position"
            },
            "code": "void write_to_file_at_offset_08006f5a(int file_descriptor, int PTR_short_1, void* buffer, int buffer_size) {\n    int PTR_ushort_2 = (int)((uint)*(ushort *)(PTR_short_1 + 0xc) << 0x17);\n    if (PTR_ushort_2 < 0) {\n        _lseek_r(file_descriptor, (int)*(short *)(PTR_short_1 + 0xe), 0, 2);\n    }\n    *(ushort *)(PTR_short_1 + 0xc) &= 0xefff;\n    _write_r(file_descriptor, (int)*(short *)(PTR_short_1 + 0xe), buffer, buffer_size);\n}",
            "called": [
                "_lseek_r",
                "_write_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006f5a",
            "calling": [],
            "imported": false,
            "current_name": "write_to_file_at_offset_08006f5a"
        },
        "FUN_08000b08": {
            "renaming": {
                "FUN_08000b08": "initializeComponents_08000b08",
                "__initialize_p": "is_initialized",
                "__priority": "priority_level",
                "PID": "oven_pid",
                "PTR_reflowOvenPID_08000b9c": "oven_pid_ptr",
                "PTR_input_08000b98": "input_ptr",
                "PTR_output_08000b94": "output_ptr",
                "PTR_setpoint_08000b90": "setpoint_ptr",
                "PTR_kp_08000b8c": "kp_ptr",
                "PTR_ki_08000b88": "ki_ptr",
                "PTR_kd_08000b84": "kd_ptr",
                "LiquidCrystal": "lcd",
                "PTR_lcd_08000bb8": "lcd_ptr",
                "PTR_lcdRsPin_08000ba0": "lcd_rs_pin_ptr",
                "PTR_lcdEPin_08000ba4": "lcd_e_pin_ptr",
                "PTR_lcdD4Pin_08000ba8": "lcd_d4_pin_ptr",
                "PTR_lcdD5Pin_08000bac": "lcd_d5_pin_ptr",
                "PTR_lcdD6Pin_08000bb0": "lcd_d6_pin_ptr",
                "PTR_lcdD7Pin_08000bb4": "lcd_d7_pin_ptr",
                "MAX31855": "thermocouple",
                "PTR_thermocouple_08000bc8": "thermocouple_ptr",
                "PTR_thermocoupleSOPin_08000bc4": "thermocouple_so_pin_ptr",
                "PTR_thermocoupleCSPin_08000bc0": "thermocouple_cs_pin_ptr",
                "PTR_thermocoupleCLKPin_08000bbc": "thermocouple_clk_pin_ptr"
            },
            "code": "void initializeComponents_08000b08(int is_initialized, int priority_level) {\n  if ((is_initialized == 1) && (priority_level == 0xffff)) {\n    PID oven_pid(PTR_reflowOvenPID_08000b9c, PTR_input_08000b98, PTR_output_08000b94, PTR_setpoint_08000b90, *PTR_kp_08000b8c, *PTR_ki_08000b88, *PTR_kd_08000b84, 0);\n    LiquidCrystal lcd(PTR_lcd_08000bb8, *PTR_lcdRsPin_08000ba0, *PTR_lcdEPin_08000ba4, *PTR_lcdD4Pin_08000ba8, *PTR_lcdD5Pin_08000bac, *PTR_lcdD6Pin_08000bb0, *PTR_lcdD7Pin_08000bb4);\n    MAX31855 thermocouple(PTR_thermocouple_08000bc8, *PTR_thermocoupleSOPin_08000bc4, *PTR_thermocoupleCSPin_08000bc0, *PTR_thermocoupleCLKPin_08000bbc);\n  }\n}",
            "called": [
                "MAX31855",
                "LiquidCrystal",
                "PID"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000b08",
            "calling": [
                "_GLOBAL__sub_I_lcdMessagesReflowStatus"
            ],
            "imported": false,
            "current_name": "initializeComponents_08000b08"
        },
        "FUN_08006cb4": {
            "renaming": {
                "FUN_08006cb4": "initialize_param_08006cb4",
                "param_1": "param",
                "uVar1": "sfp1",
                "iVar2": "global_impure_ptr",
                "bVar3": "is_global_impure_ptr"
            },
            "code": "void initialize_param_08006cb4(int param){\n                        undefined4 sfp1;\n                        undefined4 sfp2;\n                        undefined4 sfp3;\n                        int global_impure_ptr = *(int *)PTR__global_impure_ptr_08006d0c;\n                        bool is_global_impure_ptr = param == global_impure_ptr;\n                        if (*(int *)(param + 0x18) == 0) {\n                            *(undefined4 *)(param + 0x48) = 0;\n                            *(undefined4 *)(param + 0x4c) = 0;\n                            *(undefined4 *)(param + 0x50) = 0;\n                            *(undefined4 *)(param + 0x28) = DAT_08006d10;\n                            if (is_global_impure_ptr) {\n                                *(int *)(param + 0x18) = 1;\n                            }\n                            sfp1 = __sfp();\n                            *(undefined4 *)(param + 4) = sfp1;\n                            sfp2 = __sfp(param);\n                            *(undefined4 *)(param + 8) = sfp2;\n                            sfp3 = __sfp(param);\n                            *(undefined4 *)(param + 0xc) = sfp3;\n                            std_isra_0(*(undefined4 *)(param + 4),4,0);\n                            std_isra_0(*(undefined4 *)(param + 8),9,1);\n                            std_isra_0(*(undefined4 *)(param + 0xc),0x12,2);\n                            *(int *)(param + 0x18) = 1;\n                        }\n                    }",
            "called": [
                "__sfp",
                "std.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006cb4",
            "calling": [
                "__sfp",
                "__swbuf_r",
                "_fflush_r",
                "__swsetup_r",
                "_vfiprintf_r",
                "iprintf"
            ],
            "imported": false,
            "current_name": "initialize_param_08006cb4"
        },
        "FUN_08004c5e": {
            "renaming": {
                "FUN_08004c5e": "find_peripheral_from_pin_08004c5e",
                "PinName_conflict": "pin_name",
                "PinMap_conflict": "pin_map",
                "map": "current_pin_map",
                "NC": "NoConnection",
                "PTR_": "PTR_ (unchanged)",
                "DAT_": "DAT_ (unchanged)"
            },
            "code": "void * find_peripheral_from_pin_08004c5e(PinName_conflict pin, PinMap_conflict *map)\n{\n  while(true) {\n    if (map->pin == NC) {\n      return (void *)0x0;\n    }\n    if (map->pin == pin) {\n        break;\n    }\n    map = map + 1;\n  }\n  return map->peripheral;\n}",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c5e",
            "calling": [
                "pinmap_peripheral",
                "pinmap_find_peripheral"
            ],
            "imported": false,
            "current_name": "find_peripheral_from_pin_08004c5e"
        },
        "FUN_08007098": {
            "renaming": {
                "std::ctype_byname<char>::FUN_08007098": "set_c_type_flags",
                "PTR_id_0800712c": "ptr_id_0800712c",
                "PTR_id_08007130": "ptr_id_08007130",
                "PTR_id_08007134": "ptr_id_08007134",
                "PTR_id_08007138": "ptr_id_08007138",
                "PTR_id_0800713c": "ptr_id_0800713c",
                "PTR_id_08007140": "ptr_id_08007140",
                "PTR_id_08007144": "ptr_id_08007144",
                "PTR_id_08007148": "ptr_id_08007148",
                "PTR_id_0800714c": "ptr_id_0800714c",
                "PTR_id_08007150": "ptr_id_08007150",
                "PTR_id_08007154": "ptr_id_08007154",
                "PTR_id_08007158": "ptr_id_08007158",
                "FUN_08007098": "set_c_type_flags_08007098"
            },
            "code": "void set_c_type_flags_08007098(void)\n{\n    int* PTR_id_0800712c = (int*) PTR_id_0800712c;\n    int* PTR_id_08007130 = (int*) PTR_id_08007130;\n    int* PTR_id_08007134 = (int*) PTR_id_08007134;\n    int* PTR_id_08007138 = (int*) PTR_id_08007138;\n    int* PTR_id_0800713c = (int*) PTR_id_0800713c;\n    int* PTR_id_08007140 = (int*) PTR_id_08007140;\n    int* PTR_id_08007144 = (int*) PTR_id_08007144;\n    int* PTR_id_08007148 = (int*) PTR_id_08007148;\n    int* PTR_id_0800714c = (int*) PTR_id_0800714c;\n    int* PTR_id_08007150 = (int*) PTR_id_08007150;\n    int* PTR_id_08007154 = (int*) PTR_id_08007154;\n    int* PTR_id_08007158 = (int*) PTR_id_08007158;\n\n    if (*PTR_id_0800712c < 0)\n    {\n        *PTR_id_0800712c = 1;\n    }\n    if (*PTR_id_08007130 < 0)\n    {\n        *PTR_id_08007130 = 1;\n    }\n    if (*PTR_id_08007134 < 0)\n    {\n        *PTR_id_08007134 = 1;\n    }\n    if (*PTR_id_08007138 < 0)\n    {\n        *PTR_id_08007138 = 1;\n    }\n    if (*PTR_id_0800713c < 0)\n    {\n        *PTR_id_0800713c = 1;\n    }\n    if (*PTR_id_08007140 < 0)\n    {\n        *PTR_id_08007140 = 1;\n    }\n    if (*PTR_id_08007144 < 0)\n    {\n        *PTR_id_08007144 = 1;\n    }\n    if (*PTR_id_08007148 < 0)\n    {\n        *PTR_id_08007148 = 1;\n    }\n    if (*PTR_id_0800714c < 0)\n    {\n        *PTR_id_0800714c = 1;\n    }\n    if (*PTR_id_08007150 < 0)\n    {\n        *PTR_id_08007150 = 1;\n    }\n    if (*PTR_id_08007154 < 0)\n    {\n        *PTR_id_08007154 = 1;\n    }\n    if (*PTR_id_08007158 < 0)\n    {\n        *PTR_id_08007158 = 1;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007098",
            "calling": [],
            "imported": false,
            "current_name": "set_c_type_flags_08007098"
        },
        "FUN_08004b3c": {
            "renaming": {
                "FUN_08004b3c": "stop_pwm_signal_08004b3c",
                "pin": "pin_name",
                "Channel": "channel",
                "uVar1": "function_code",
                "timHandle": "tim_handle"
            },
            "code": "void stop_pwm_signal_08004b3c(PinName_conflict pin)\n{\n  uint32_t channel;\n  uint32_t function_code;\n  TIM_HandleTypeDef tim_handle;\n  tim_handle.Instance = (TIM_TypeDef *)pinmap_peripheral(pin, (PinMap_conflict *)PTR_PinMap_PWM_08004b90);\n  if ((tim_handle.Instance != (TIM_TypeDef *)0x0) && ((((channel = get_pwm_channel(pin), channel == 0 || (channel == 4)) || (channel == 8)) || ((channel == 0xc || (channel == 0x18))))))\n  {\n    function_code = pinmap_function(pin, (PinMap_conflict *)PTR_PinMap_PWM_08004b90);\n    if ((function_code & 0x100000) == 0)\n    {\n      HAL_TIM_PWM_Stop(&tim_handle, channel);\n    }\n    else\n    {\n      HAL_TIMEx_PWMN_Stop(&tim_handle, channel);\n    }\n    HAL_TIM_PWM_DeInit(&tim_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIMEx_PWMN_Stop",
                "HAL_TIM_PWM_Stop",
                "pinmap_peripheral",
                "pinmap_function",
                "HAL_TIM_PWM_DeInit",
                "get_pwm_channel"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b3c",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "stop_pwm_signal_08004b3c"
        },
        "FUN_08001550": {
            "renaming": {
                "FUN_08001550": "printCharacterMap_08001550",
                "this": "lcd",
                "location": "location",
                "charmap": "charmap",
                "iVar1": "index",
                "send": "send",
                "(byte)((location & 7) << 3) | 0x40": "baseAddress",
                "(uint)charmap[iVar1]": "(uint)charmap[index]",
                "return;": "return;"
            },
            "code": "void __thiscall LiquidCrystal::printCharacterMap_08001550(LiquidCrystal *lcd, uint8_t location, uint8_t *charmap) {\\n  int index;\\n  uint8_t baseAddress = ((location & 7) << 3) | 0x40;\\n  send(lcd, baseAddress, \"\\0\");\\n  for (index = 0; index < 8; index++) {\\n    (**(lcd->super_Print)._vptr_Print)(lcd, (uint)charmap[index]);\\n  }\\n  return;\\n}",
            "called": [
                "send"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001550",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "printCharacterMap_08001550"
        },
        "FUN_08000cd0": {
            "renaming": {
                "FUN_08000cd0": "reflow_oven_controller_08000cd0",
                "uVar4": "current_time",
                "extraout_r1": "temperature_reading",
                "iVar6": "comparison_result",
                "uVar7": "number_of_leading_zeroes",
                "puVar2": "serial_port",
                "puVar5": "print_text",
                "in_stack_ffffffe4": "stack_variable",
                "CELSIUS": "celsius"
            },
            "code": "\nvoid reflow_oven_controller_08000cd0(void)\n\n{\n  char cVar1;\n  undefined *serial_port;\n  undefined *puVar3;\n  uint32_t current_time;\n  undefined *print_text;\n  int comparison_result;\n  undefined4 temperature_reading;\n  uint number_of_leading_zeroes;\n  int digits;\n  int digits_00;\n  int digits_01;\n  undefined8 uVar8;\n  undefined4 stack_variable;\n  \n  current_time = millis();\n  if (*(uint *)PTR_nextRead_08000f50 < current_time) {\n    *(uint *)PTR_nextRead_08000f50 = *(uint *)PTR_nextRead_08000f50 + 1000;\n    print_text = PTR_thermocouple_08000f74;\n    MAX31855::readThermocouple((MAX31855 *)PTR_thermocouple_08000f74,celsius);\n    serial_port = PTR_input_08000f6c;\n    *(undefined **)PTR_input_08000f6c = print_text;\n    *(undefined4 *)(serial_port + 4) = temperature_reading;\n    comparison_result = __aeabi_dcmpeq();\n    if (((comparison_result != 0) ||\n        (comparison_result = __aeabi_dcmpeq(print_text,temperature_reading,DAT_08000f20,DAT_08000f24), comparison_result != 0)) ||\n       (comparison_result = __aeabi_dcmpeq(print_text,temperature_reading,DAT_08000f28,DAT_08000f2c), comparison_result != 0)) {\n      *PTR_reflowState_08000f64 = 7;\n      *PTR_reflowStatus_08000f58 = 0;\n    }\n  }\n  current_time = millis();\n  if (*(uint *)PTR_nextCheck_08000f54 < current_time) {\n    *(uint *)PTR_nextCheck_08000f54 = *(uint *)PTR_nextCheck_08000f54 + 1000;\n    if (*PTR_reflowStatus_08000f58 == '\\x01') {\n      current_time = *(uint32_t *)PTR_ledRedPin_08000f5c;\n      comparison_result = digitalRead(current_time);\n      number_of_leading_zeroes = count_leading_zeroes(comparison_result);\n      digitalWrite(current_time,number_of_leading_zeroes >> 5);\n      comparison_result = *(int *)PTR_timerSeconds_08000f78;\n      *(int *)PTR_timerSeconds_08000f78 = comparison_result + 1;\n      serial_port = PTR_Serial2_08000f7c;\n      Print::print((Print *)PTR_Serial2_08000f7c,comparison_result + 1,10);\n      print_text = PTR_DAT_08000f80;\n      Print::print((Print *)serial_port,PTR_DAT_08000f80);\n      Print::print((Print *)serial_port,(double)CONCAT44(stack_variable,2),digits);\n      Print::print((Print *)serial_port,print_text);\n      Print::print((Print *)serial_port,(double)CONCAT44(stack_variable,2),digits_00);\n      Print::print((Print *)serial_port,print_text);\n      Print::println((Print *)serial_port,(double)CONCAT44(stack_variable,2),digits_01);\n    }\n    else {\n      digitalWrite(*(uint32_t *)PTR_ledRedPin_08000f5c,1);\n    }\n    serial_port = PTR_lcd_08000f60;\n    LiquidCrystal::clear((LiquidCrystal *)PTR_lcd_08000f60);\n    puVar3 = PTR_reflowState_08000f64;\n    Print::print((Print *)serial_port,\n                 *(char **)(PTR_lcdMessagesReflowStatus_08000f68 +\n                           (uint)(byte)*PTR_reflowState_08000f64 * 4));\n    LiquidCrystal::setCursor((LiquidCrystal *)serial_port,'\\0','\\x01');\n    print_text = PTR_lcd_08000f60;\n    if (*puVar3 == '\\a') {\n      Print::print((Print *)serial_port,PTR_s_TC_Error__08000f8c);\n    }\n    else {\n      Print::print((Print *)PTR_lcd_08000f60,(double)CONCAT44(stack_variable,2),2);\n      LiquidCrystal::write((LiquidCrystal *)print_text,'\\0');\n      Print::print((Print *)print_text,PTR_DAT_08000f70);\n    }\n  }\n  if ((byte)*PTR_reflowState_08000f64 < 8) {\n                    /* WARNING: Could not recover jumptable at 0x08000d5c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*(code *)(&switchD_08000d5c::switchdataD_08000d60 +\n              (&switchD_08000d5c::switchdataD_08000d60)[(byte)*PTR_reflowState_08000f64]))();\n    return;\n  }\n  if ((*PTR_switchStatus_08001274 == '\\x01') && (*PTR_reflowStatus_0800126c == '\\x01')) {\n    *PTR_reflowStatus_0800126c = 0;\n    *PTR_reflowState_08001258 = 0;\n  }\n  cVar1 = *PTR_debounceState_08001278;\n  if (cVar1 == '\\x01') {\n    current_time = analogRead(*(uint32_t *)PTR_switchPin_08001280);\n    if (current_time == 0) {\n      current_time = millis();\n      if (0x32 < current_time - *(int *)PTR_lastDebounceTime_08001284) {\n        *PTR_debounceState_08001278 = 2;\n      }\n    }\n    else {\n      *PTR_debounceState_08001278 = 0;\n    }\n  }\n  else if (cVar1 == '\\0') {\n    *PTR_switchStatus_08001274 = 0;\n    current_time = analogRead(*(uint32_t *)PTR_switchPin_08001280);\n    if (current_time == 0) {\n      current_time = millis();\n      *(uint32_t *)PTR_lastDebounceTime_08001284 = current_time;\n      *PTR_debounceState_08001278 = 1;\n    }\n  }\n  else if ((cVar1 == '\\x02') &&\n          (current_time = analogRead(*(uint32_t *)PTR_switchPin_08001280), current_time != 0)) {\n    *PTR_switchStatus_08001274 = 1;\n    *PTR_debounceState_08001278 = 0;\n  }\n  if (*PTR_reflowStatus_0800126c == '\\x01') {\n    current_time = millis();\n    PID::Compute((PID *)PTR_reflowOvenPID_08001250);\n    if (*(uint *)PTR_windowSize_0800128c < current_time - *(int *)PTR_windowStartTime_08001288) {\n      *(uint *)PTR_windowStartTime_08001288 =\n           *(int *)PTR_windowStartTime_08001288 + *(uint *)PTR_windowSize_0800128c;\n    }\n    uVar8 = __floatunsidf(current_time - *(int *)PTR_windowStartTime_08001288);\n    comparison_result = __aeabi_dcmplt((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),\n                           *(undefined4 *)PTR_output_08001290,\n                           *(undefined4 *)(PTR_output_08001290 + 4));\n    if (comparison_result == 0) {\n      digitalWrite(*(uint32_t *)PTR_ssrPin_0800127c,0);\n    }\n    else {\n      digitalWrite(*(uint32_t *)PTR_ssrPin_0800127c,1);\n    }\n  }\n  else {\n    digitalWrite(*(uint32_t *)PTR_ssrPin_0800127c,0);\n  }\n  return;\n}\n\n",
            "called": [
                "print",
                "__aeabi_dadd",
                "millis",
                "print",
                "SetMode",
                "__aeabi_dcmpeq",
                "__aeabi_dcmpge",
                "__aeabi_dcmplt",
                "setCursor",
                "analogRead",
                "digitalRead",
                "println",
                "SetTunings",
                "__aeabi_dcmpgt",
                "__aeabi_dcmple",
                "println",
                "write",
                "SetSampleTime",
                "__floatsidf",
                "digitalWrite",
                "SetOutputLimits",
                "Compute",
                "clear",
                "print",
                "readThermocouple",
                "__floatunsidf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000cd0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "reflow_oven_controller_08000cd0"
        },
        "FUN_08001310": {
            "renaming": {
                "FUN_08001310": "updateDisplay_08001310",
                "this": "lcd",
                "value": "data",
                "mode": "rs",
                "_rs_pin": "_rs_pin",
                "_rw_pin": "_rw_pin",
                "_displayfunction": "_displayfunction",
                "write4bits": "write4bits",
                "write8bits": "write8bits",
                "0xff": "LOW",
                "uint8_t": "uint"
            },
            "code": "void __thiscall LiquidCrystal::updateDisplay_08001310(LiquidCrystal *lcd,uint8_t value,uint8_t mode)\n{\n  digitalWrite((uint)lcd->_rs_pin,(uint)mode);\n  if (lcd->_rw_pin != 0xff) {\n    digitalWrite((uint)lcd->_rw_pin,LOW);\n  }\n  if ((lcd->_displayfunction & FUNTION_SET_8BITMODE) == 0) {\n    write4bits(lcd,value >> 4);\n    write4bits(lcd,value);\n    return;\n  }\n  write8bits(lcd,value);\n  return;\n}",
            "called": [
                "write4bits",
                "digitalWrite",
                "write8bits"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001310",
            "calling": [
                "clear",
                "createChar",
                "write",
                "display",
                "begin",
                "setCursor"
            ],
            "imported": false,
            "current_name": "updateDisplay_08001310"
        },
        "FUN_080009a8": {
            "renaming": {
                "FUN_080009a8": "compare_double_values_080009a8",
                "param_1": "first_value",
                "param_2": "second_value",
                "param_3": "PTR_DAT_080009a8",
                "param_4": "PTR_DAT_080009a8"
            },
            "code": "void compare_double_values_080009a8(double first_value, double second_value) {\n  __aeabi_cdcmpeq(first_value, second_value, PTR_DAT_080009a8, PTR_DAT_080009a8);\n  return;\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009a8",
            "calling": [
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "imported": false,
            "current_name": "compare_double_values_080009a8"
        },
        "FUN_08004d90": {
            "renaming": {
                "FUN_08004d90": "update_TIM_status_08004d90",
                "htim": "TIM_handle",
                "DAT_08004de4": "TIM2",
                "DAT_08004de8": "TIM3",
                "DAT_08004dec": "TIM4",
                "DAT_08004df0": "TIM_status_register"
            },
            "code": "void update_TIM_status_08004d90(TIM_HandleTypeDef *htim)\n{\n    uint32_t *DAT_08004df0 = (uint32_t *)0x08004df0;\n    if (htim->Instance == DAT_08004de4) {\n        *DAT_08004df0 &= 0xfffff7ff;\n    }\n    if (htim->Instance == DAT_08004de8) {\n        *DAT_08004df0 &= 0xfffffffe;\n    }\n    if (htim->Instance == DAT_08004dec) {\n        *DAT_08004df0 &= 0xfffffffd;\n    }\n    if (htim->Instance == TIM5) {\n        *DAT_08004df0 &= 0xfffffffb;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d90",
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "imported": false,
            "current_name": "update_TIM_status_08004d90"
        },
        "FUN_08005ce8": {
            "renaming": {
                "__thiscall Print::FUN_08005ce8": "print_number_in_base",
                "this": "print_object",
                "n": "number",
                "base": "base",
                "cVar1": "digit",
                "sVar2": "length",
                "sVar3": "total_length",
                "uVar4": "remainder",
                "uVar5": "base_value",
                "uVar6": "divisor",
                "__s": "buffer",
                "buf": "buffer_array",
                "FUN_08005ce8": "print_number_in_base_08005ce8"
            },
            "code": "size_t __thiscall print_number_in_base_08005ce8(Print *print_object, ulong number, uint8_t base) {\n  char digit;\n  size_t length;\n  size_t total_length;\n  uint remainder;\n  uint divisor;\n  char *buffer;\n  char buffer_array[33];\n  uint base_value = (uint)base;\n  buffer_array[32] = '\\0';\n  if (base_value < 2) {\n    base_value = 10;\n  }\n  buffer = buffer_array + 0x20;\n  do {\n    divisor = number / base_value;\n    remainder = (number & 0xff) - (divisor * base_value & 0xff) & 0xff;\n    buffer = buffer - 1;\n    digit = (char)remainder;\n    if (remainder < 10) {\n      digit = digit + '0';\n    }\n    else {\n      digit = digit + '7';\n    }\n    *buffer = digit;\n    number = divisor;\n  } while (divisor != 0);\n  if (buffer == (char *)0x0) {\n    total_length = 0;\n  }\n  else {\n    length = strlen(buffer);\n    total_length = (*print_object->_vptr_Print[1])(length, buffer, length);\n  }\n  return total_length;\n}",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005ce8",
            "calling": [
                "print",
                "print"
            ],
            "imported": false,
            "current_name": "print_number_in_base_08005ce8"
        },
        "FUN_0800316c": {
            "renaming": {
                "FUN_0800316c": "i2c_handle_event_0800316c",
                "*hi2c": "*handle",
                "HVar1": "status",
                "*puVar2": "*buffer",
                "*pIVar3": "*instance"
            },
            "code": "void i2c_handle_event_0800316c(I2C_HandleTypeDef *handle)\n{\n  HAL_StatusTypeDef status;\n  uint8_t *buffer;\n  I2C_TypeDef *instance;\n\n  if ((uint8_t)handle->State - 0x29 < 2) {\n    handle->PreviousState = 0;\n    handle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((handle->State != HAL_I2C_STATE_ABORT) && ((handle->Instance->CR2 & 0x800) == 0)) {\n      handle->State = HAL_I2C_STATE_READY;\n    }\n    handle->PreviousState = 0;\n    handle->Mode = HAL_I2C_MODE_NONE;\n  }\n\n  handle->Instance->CR1 = handle->Instance->CR1 & 0xfffff7ff;\n  instance = handle->Instance;\n\n  if ((instance->CR2 & 0x800) == 0) {\n    if (handle->State == HAL_I2C_STATE_ABORT) {\n      handle->State = HAL_I2C_STATE_READY;\n      handle->ErrorCode = 0;\n      if ((instance->SR1 & 0x40) != 0) {\n        buffer = handle->pBuffPtr;\n        handle->pBuffPtr = buffer + 1;\n        *buffer = (uint8_t)instance->DR;\n      }\n      handle->Instance->CR1 = handle->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(handle);\n    }\n    else {\n      if ((instance->SR1 & 0x40) != 0) {\n        buffer = handle->pBuffPtr;\n        handle->pBuffPtr = buffer + 1;\n        *buffer = (uint8_t)instance->DR;\n      }\n      HAL_I2C_ErrorCallback(handle);\n    }\n  }\n  else {\n    instance->CR2 = instance->CR2 & 0xfffff7ff;\n    if (handle->hdmatx->State == HAL_DMA_STATE_READY) {\n      handle->hdmarx->XferAbortCallback = i2c_handle_transfer_abort;\n      status = HAL_DMA_Abort_IT(handle->hdmarx);\n      if (status != HAL_OK) {\n        if ((instance->SR1 & 0x40) != 0) {\n          buffer = handle->pBuffPtr;\n          handle->pBuffPtr = buffer + 1;\n          *buffer = (uint8_t)instance->DR;\n        }\n        instance->CR1 = instance->CR1 & 0xfffffffe;\n        handle->State = HAL_I2C_STATE_READY;\n        (*handle->hdmarx->XferAbortCallback)(handle->hdmarx);\n      }\n    }\n    else {\n      handle->hdmatx->XferAbortCallback = i2c_handle_transfer_abort;\n      status = HAL_DMA_Abort_IT(handle->hdmatx);\n      if (status != HAL_OK) {\n        instance->CR1 = instance->CR1 & 0xfffffffe;\n        handle->State = HAL_I2C_STATE_READY;\n        (*handle->hdmatx->XferAbortCallback)(handle->hdmatx);\n      }\n    }\n  }\n\n  if ((handle->State == HAL_I2C_STATE_LISTEN) && ((handle->ErrorCode & 4) != 0)) {\n    handle->XferOptions = I2C_FIRST_FRAME;\n    handle->PreviousState = 0;\n    handle->State = HAL_I2C_STATE_READY;\n    handle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(handle);\n  }\n  return;\n}",
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_DMA_Abort_IT",
                "HAL_I2C_ListenCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800316c",
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "i2c_handle_event_0800316c"
        },
        "FUN_08004828": {
            "renaming": {
                "FUN_08004828": "clear_pin_from_map_08004828",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "pin_index",
                "mask": "pin_mask"
            },
            "code": "void clear_pin_from_map_08004828(PinName_conflict pin, uint32_t *map) {\n  uint32_t pin_index = ((uint32_t)pin << 24) >> 28;\n  uint32_t mask = ~(1 << ((uint32_t)pin & 0xF));\n  map[pin_index] &= mask;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004828",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "clear_pin_from_map_08004828"
        },
        "FUN_08004948": {
            "renaming": {
                "FUN_08004948": "get_pwm_pin_function_08004948",
                "PinName_conflict": "pin",
                "uVar1": "function_value",
                "uVar2": "bit_shifted_value"
            },
            "code": "uint32_t get_pwm_pin_function_08004948(PinName_conflict pin)\n{\n  uint32_t function_value = pinmap_function(pin, (PinMap_conflict *)PTR_PinMap_PWM_08004970);\n  uint bit_shifted_value = (function_value << 12) >> 27;\n  if (bit_shifted_value == 3) {\n    return 8;\n  }\n  if (bit_shifted_value != 4) {\n    if (bit_shifted_value != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 12;\n}",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004948",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "get_pwm_pin_function_08004948"
        },
        "FUN_0800316a": {
            "renaming": {
                "FUN_0800316a": "do_nothing_0800316a"
            },
            "code": "\nvoid do_nothing_0800316a(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800316a",
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "imported": false,
            "current_name": "do_nothing_0800316a"
        },
        "FUN_08005b24": {
            "renaming": {
                "FUN_08005b24": "set_rx_pin_08005b24",
                "_rx": "rx_pin_index",
                "PVar1": "rx_pin",
                "PTR_digitalPin_08005b38": "digitalPin"
            },
            "code": "void __thiscall HardwareSerial::set_rx_pin_08005b24(HardwareSerial *this, uint32_t rx_pin_index) {\n    PinName rx_pin;\n    if (rx_pin_index < 0x3c) {\n        rx_pin = PTR_digitalPin_08005b38[rx_pin_index];\n    }\n    else {\n        rx_pin = NC;\n    }\n    (this->_serial).pin_rx = rx_pin;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b24",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "set_rx_pin_08005b24"
        },
        "FUN_080049f0": {
            "renaming": {
                "FUN_080049f0": "set_ADC_interrupt_flag_080049f0",
                "hadc": "adc_handle",
                "iVar1": "adc_instance_address",
                "DAT_08004a48": "PTR_DAT_08004a48",
                "DAT_08004a40": "PTR_DAT_08004a40",
                "DAT_08004a44": "PTR_DAT_08004a44",
                "uint": "unsigned int",
                "adc_interrupt_flag": "adc_interrupt_flag",
                "adc_interrupt_mask_1": "adc_interrupt_mask_1",
                "adc_interrupt_mask_2": "adc_interrupt_mask_2"
            },
            "code": "void set_ADC_interrupt_flag_080049f0(ADC_HandleTypeDef *adc_handle)\n{\n  int adc_instance_address = DAT_08004a48;\n  if (adc_handle->Instance != DAT_08004a40) {\n    if (adc_handle->Instance == DAT_08004a44) {\n      uint *adc_interrupt_flag = (uint *)(adc_instance_address + 0xc);\n      *adc_interrupt_flag = *adc_interrupt_flag | 0x400;\n      uint *adc_interrupt_mask_1 = (uint *)(adc_instance_address + 0xc);\n      *adc_interrupt_mask_1 = *adc_interrupt_mask_1 & 0xfffffbff;\n      uint *adc_interrupt_mask_2 = (uint *)(adc_instance_address + 0x18);\n      *adc_interrupt_mask_2 = *adc_interrupt_mask_2 & 0xfffffbff;\n      *adc_interrupt_mask_2 = *adc_interrupt_mask_2 & 0xfffffbff;\n    }\n    return;\n  }\n  uint *adc_interrupt_flag = (uint *)(adc_instance_address + 0xc);\n  *adc_interrupt_flag = *adc_interrupt_flag | 0x200;\n  uint *adc_interrupt_mask_1 = (uint *)(adc_instance_address + 0xc);\n  *adc_interrupt_mask_1 = *adc_interrupt_mask_1 & 0xfffffdff;\n  uint *adc_interrupt_mask_2 = (uint *)(adc_instance_address + 0x18);\n  *adc_interrupt_mask_2 = *adc_interrupt_mask_2 & 0xfffffdff;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080049f0",
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "imported": false,
            "current_name": "set_ADC_interrupt_flag_080049f0"
        },
        "FUN_08001e40": {
            "renaming": {
                "FUN_08001e40": "get_adc_data_08001e40",
                "hadc": "adc_handler",
                "Instance": "adc_instance",
                "DR": "adc_data"
            },
            "code": "uint32_t get_adc_data_08001e40(ADC_HandleTypeDef *adc_handler)\n{\n    return adc_handler->Instance->DR;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001e40",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_adc_data_08001e40"
        },
        "FUN_08003a68": {
            "renaming": {
                "FUN_08003a68": "calculate_value_08003a68",
                "uVar1": "value_1",
                "uVar2": "value_2",
                "local_1c": "value_3",
                "abStack_18": "value_4",
                "uStack_14": "value_5",
                "uStack_10": "value_6",
                "uStack_c": "value_7"
            },
            "code": "uint calculate_value_08003a68(void)\n{\n  uint value_1;\n  uint value_2;\n  undefined2 value_3;\n  byte value_4 [4];\n  undefined4 value_5;\n  undefined4 value_6;\n  undefined4 value_7;\n  \n  value_7 = *(undefined4 *)(PTR__etext_08003ac4 + 8);\n  value_6 = *(undefined4 *)(PTR__etext_08003ac4 + 4);\n  value_5 = *(undefined4 *)PTR__etext_08003ac4;\n  value_3 = *(undefined2 *)(PTR__etext_08003ac4 + 0x10);\n  value_2 = *(uint *)(DAT_08003ac8 + 4);\n  value_1 = DAT_08003ad0;\n  if ((value_2 & 0xc) == 8) {\n    if ((value_2 & 0x10000) == 0) {\n      value_1 = DAT_08003acc * (uint)value_4[(value_2 << 10) >> 0x1c];\n    }\n    else {\n      value_1 = (DAT_08003ad0 * value_4[(value_2 << 10) >> 0x1c]) /\n              (uint)*(byte *)((int)&value_3 - ((*(int *)(DAT_08003ac8 + 4) << 0xe) >> 0x1f));\n    }\n  }\n  return value_1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a68",
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "calculate_value_08003a68"
        },
        "FUN_080012a2": {
            "renaming": {
                "FUN_080012a2": "pulseEnablePin_080012a2",
                "_enable_pin": "enablePin"
            },
            "code": "void __thiscall LiquidCrystal::pulseEnablePin_080012a2(LiquidCrystal *lcd)\n{\n  digitalWrite((uint)lcd->_enable_pin,LOW);\n  digitalWrite((uint)lcd->_enable_pin,HIGH);\n  digitalWrite((uint)lcd->_enable_pin,LOW);\n  return;\n}",
            "called": [
                "digitalWrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080012a2",
            "calling": [
                "write4bits",
                "write8bits"
            ],
            "imported": false,
            "current_name": "pulseEnablePin_080012a2"
        },
        "FUN_08004c78": {
            "renaming": {
                "FUN_08004c78": "find_peripheral_08004c78",
                "pin": "pin_name",
                "map": "pin_map",
                "pvVar1": "peripheral"
            },
            "code": "void * find_peripheral_08004c78(PinName_conflict pin, PinMap_conflict *pin_map) {\n    void *peripheral;\n    if (pin != NC) {\n        peripheral = pinmap_find_peripheral_08004c78(pin, pin_map);\n        return peripheral;\n    }\n    return (void *) 0x0;\n}",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c78",
            "calling": [
                "pwm_stop",
                "adc_read_value",
                "uart_debug_write",
                "uart_debug_init",
                "uart_init"
            ],
            "imported": false,
            "current_name": "find_peripheral_08004c78"
        },
        "FUN_08005bd4": {
            "renaming": {
                "FUN_08005bd4": "initialize_static_variables_and_destructors_08005bd4"
            },
            "code": "void initialize_static_variables_and_destructors_08005bd4(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bd4",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_and_destructors_08005bd4"
        },
        "FUN_08001e48": {
            "renaming": {
                "FUN_08001e48": "configure_ADC_channel_08001e48",
                "*hadc": "*adc_handle",
                "*sConfig": "*channel_config",
                "HVar1": "status",
                "uVar2": "rank",
                "pAVar3": "adc_instance",
                "wait_loop_index": "wait_loop_index",
                "PTR_SystemCoreClock_08001f78": "SystemCoreClock",
                "DAT_08001f74": "ADC1",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "HAL_StatusTypeDef configure_ADC_channel_08001e48(ADC_HandleTypeDef *adc_handle, ADC_ChannelConfTypeDef *channel_config) {\n  HAL_StatusTypeDef status;\n  uint32_t rank = channel_config->Rank;\n  uint32_t channel = channel_config->Channel;\n  uint32_t sampling_time = channel_config->SamplingTime;\n  ADC_TypeDef *adc_instance = adc_handle->Instance;\n  uint32_t wait_loop_index;\n\n  if (adc_handle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    adc_handle->Lock = HAL_LOCKED;\n    if (rank < 7) {\n      rank = rank * 5 - 5;\n      adc_instance->SQR3 = channel << (rank & 0xff) | adc_instance->SQR3 & ~(0x1f << (rank & 0xff));\n    }\n    else if (rank < 0xd) {\n      rank = rank * 5 - 0x23;\n      adc_instance->SQR2 = channel << (rank & 0xff) | adc_instance->SQR2 & ~(0x1f << (rank & 0xff));\n    }\n    else {\n      rank = rank * 5 - 0x41;\n      adc_instance->SQR1 = channel << (rank & 0xff) | adc_instance->SQR1 & ~(0x1f << (rank & 0xff));\n    }\n    if (channel < 10) {\n      adc_instance->SMPR2 = sampling_time << (channel * 3 & 0xff) | adc_instance->SMPR2 & ~(7 << (channel * 3 & 0xff));\n    }\n    else {\n      channel = channel * 3 - 0x1e;\n      adc_instance->SMPR1 = sampling_time << (channel & 0xff) | adc_instance->SMPR1 & ~(7 << (channel & 0xff));\n    }\n    if (channel - 0x10 < 2) {\n      if (adc_instance == DAT_08001f74) {\n        if ((adc_instance->CR2 & 0x800000) == 0) {\n          adc_instance->CR2 |= 0x800000;\n          if (channel == 0x10) {\n            for (wait_loop_index = (uint32_t)((uint64_t)ADC_CYCLE * (uint64_t)*(uint32_t *)PTR_SystemCoreClock_08001f78 / 0x3b9aca00) * 10; wait_loop_index != 0; wait_loop_index--);\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        adc_handle->State |= 0x20;\n        status = HAL_ERROR;\n      }\n    }\n    else {\n      status = HAL_OK;\n    }\n    adc_handle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001e48",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "configure_ADC_channel_08001e48"
        },
        "FUN_080059c8": {
            "renaming": {
                "__thiscall HardwareSerial::FUN_080059c8": "write_byte",
                "this": "serial",
                "c": "byte_to_write",
                "_written": "is_written",
                "_serial": "serial->_serial",
                "tx_head": "tx_head",
                "uVar2": "is_tx_active",
                "bVar1": "incremented_tx_head",
                "bVar3": "new_tx_head",
                "iVar4": "incremented_tx_head",
                "FUN_080059c8": "write_byte_080059c8"
            },
            "code": "size_t __thiscall HardwareSerial::write_byte_080059c8(HardwareSerial *serial, uint8_t byte_to_write)\n{\n  bool is_written = true;\n  uint tx_head = (uint)(serial->_serial).tx_head;\n  int incremented_tx_head = tx_head + 1;\n  byte new_tx_head = (byte)incremented_tx_head & 0x7f;\n  if (incremented_tx_head == 0) {\n    new_tx_head = -(-new_tx_head & 0x7f);\n  }\n  do {\n  } while ((serial->_serial).tx_tail == (ushort)new_tx_head);\n  (serial->_serial).tx_buff[tx_head] = byte_to_write;\n  (serial->_serial).tx_head = (ushort)new_tx_head;\n  uint8_t is_tx_active = serial_tx_active((serial_t *)&serial->_serial);\n  if (is_tx_active == 0) {\n    uart_attach_tx_callback((serial_t *)&serial->_serial,DAT_08005a14);\n  }\n  return 1;\n}",
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080059c8",
            "calling": [],
            "imported": false,
            "current_name": "write_byte_080059c8"
        },
        "FUN_080009b8": {
            "renaming": {
                "FUN_080009b8": "perform_comparison_080009b8",
                "param_1": "input_value"
            },
            "code": "float32_t perform_comparison_080009b8(float32_t input_value)\n{\n    __eqdf2();\n    return input_value;\n}",
            "called": [
                "__eqdf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009b8",
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_dcmplt",
                "__aeabi_dcmple",
                "__aeabi_cdrcmple"
            ],
            "imported": false,
            "current_name": "perform_comparison_080009b8"
        },
        "FUN_08000aa8": {
            "renaming": {
                "FUN_08000aa8": "calculate_shift_amount_08000aa8",
                "param_1": "dividend",
                "param_2": "divisor",
                "iVar1": "intermediate_value",
                "uVar2": "quotient"
            },
            "code": "uint calculate_shift_amount_08000aa8(uint dividend, uint divisor)\n{\n  int intermediate_value;\n  uint quotient;\n  \n  if ((divisor & 0x80000000) != 0) {\n    return 0;\n  }\n  intermediate_value = divisor * 2 + 0x200000;\n  if (divisor * 2 < 0xffe00000) {\n    if (-1 < intermediate_value) {\n      return 0;\n    }\n    quotient = -(intermediate_value >> 0x15) - 0x3e1;\n    if (-1 < (int)quotient) {\n      return (divisor << 0xb | 0x80000000 | dividend >> 0x15) >> (quotient & 0xff);\n    }\n  }\n  else if ((dividend | divisor << 0xc) != 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000aa8",
            "calling": [
                "printFloat"
            ],
            "imported": false,
            "current_name": "calculate_shift_amount_08000aa8"
        },
        "FUN_08000a04": {
            "renaming": {
                "FUN_08000a04": "is_not_CY_or_ZR_08000a04",
                "in_CY": "is_CY",
                "in_ZR": "in_ZR"
            },
            "code": "bool is_not_CY_or_ZR_08000a04(void)\n{\n  bool is_CY = __aeabi_cdrcmple();\n  return !is_CY || in_ZR;\n}",
            "called": [
                "__aeabi_cdrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a04",
            "calling": [
                "SetOutputLimits",
                "loop"
            ],
            "imported": false,
            "current_name": "is_not_CY_or_ZR_08000a04"
        },
        "FUN_0800010c": {
            "renaming": {
                "FUN_0800010c": "isInitializationCompleted_0800010c",
                "param_1": "initPointer",
                "PTR_completed_8667_08000124": "isCompleted",
                "DAT_08000128": "initValue"
            },
            "code": "bool isInitializationCompleted_0800010c(bool* PTR_completed_8667_08000124, int* DAT_08000128, char* initPointer) {\n    if (*PTR_completed_8667_08000124 == false) {\n        if (*DAT_08000128 != 0) {\n            initPointer = initPointer;\n        }\n        *PTR_completed_8667_08000124 = true;\n    }\n    return initPointer;\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800010c",
            "calling": [],
            "imported": false,
            "current_name": "isInitializationCompleted_0800010c"
        },
        "FUN_08003f14": {
            "renaming": {
                "FUN_08003f14": "do_nothing_08003f14"
            },
            "code": "\nvoid do_nothing_08003f14(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f14",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08003f14"
        },
        "FUN_08001cac": {
            "renaming": {
                "FUN_08001cac": "update_tick_08001cac",
                "PTR_uwTick_08001cbc": "tick_ptr_ptr",
                "PTR_uwTickFreq_08001cc0": "tick_freq_ptr"
            },
            "code": "void update_tick_08001cac(void)\n{\n  uint8_t tick_freq = *PTR_uwTickFreq_08001cc0;\n  uint32_t* tick_ptr = (uint32_t*)PTR_uwTick_08001cbc;\n  *tick_ptr = tick_freq + *tick_ptr;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001cac",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "update_tick_08001cac"
        },
        "FUN_08003f12": {
            "renaming": {
                "FUN_08003f12": "do_nothing_08003f12"
            },
            "code": "\nvoid do_nothing_08003f12(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f12",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08003f12"
        },
        "FUN_08005a18": {
            "renaming": {
                "FUN_08005a18": "check_serial2_availability_08005a18",
                "DAT_08005a3c": "serial2_initialized",
                "PTR_Serial2_08005a40": "serial2"
            },
            "code": "void check_serial2_availability_08005a18(void)\n{\n  if (DAT_08005a3c != 0) {\n    HardwareSerial::available(PTR_Serial2_08005a40);\n  }\n  return;\n}",
            "called": [
                "available"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a18",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "check_serial2_availability_08005a18"
        },
        "FUN_08003f18": {
            "renaming": {
                "FUN_08003f18": "process_timer_interrupt_08003f18",
                "htim": "timer_handle",
                "pTVar1": "timer_instance",
                "SR": "TIM_FLAG",
                "DIER": "TIM_IT",
                "HAL_TIM_ACTIVE_CHANNEL_1": "HAL_TIM_ACTIVE_CHANNEL_1",
                "CCMR1": "TIM_CCMR1",
                "CC1S": "TIM_CCMR1_CC1S"
            },
            "code": "void process_timer_interrupt_08003f18(TIM_HandleTypeDef *timer_handle)\n{\n    TIM_TypeDef *timer_instance = timer_handle->Instance;\n\n    if (((timer_instance->SR & TIM_FLAG_CC1) != 0) && ((timer_instance->DIER & TIM_IT_CC1) != 0)) {\n        timer_instance->SR = ~(TIM_FLAG_CC1);\n        timer_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n        if ((timer_handle->Instance->CCMR1 & TIM_CCMR1_CC1S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(timer_handle);\n            HAL_TIM_PWM_PulseFinishedCallback(timer_handle);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(timer_handle);\n        }\n        timer_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n\n    // Repeat the above block for each channel\n\n    return;\n}",
            "called": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_CommutationCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f18",
            "calling": [
                "TIM2_IRQHandler",
                "TIM4_IRQHandler",
                "TIM1_UP_IRQHandler",
                "TIM3_IRQHandler"
            ],
            "imported": false,
            "current_name": "process_timer_interrupt_08003f18"
        },
        "FUN_08003f16": {
            "renaming": {
                "FUN_08003f16": "do_nothing_08003f16"
            },
            "code": "\nvoid do_nothing_08003f16(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f16",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08003f16"
        },
        "FUN_0800591e": {
            "renaming": {
                "FUN_0800591e": "calculateAvailableData_0800591e",
                "this": "serial",
                "_serial": "serial_data",
                "rx_head": "head_index",
                "rx_tail": "tail_index",
                "available_data": "available_data_size"
            },
            "code": "int __thiscall calculateAvailableData_0800591e(HardwareSerial *serial) {\n    int rx_head = (serial->_serial).rx_head;\n    int rx_tail = (serial->_serial).rx_tail;\n    int available_data = (rx_head + 64 - rx_tail) % 64;\n    return available_data;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800591e",
            "calling": [
                "serialEventRun"
            ],
            "imported": false,
            "current_name": "calculateAvailableData_0800591e"
        },
        "FUN_08006104": {
            "renaming": {
                "FUN_08006104": "initialize_static_variables_08006104"
            },
            "code": "void initialize_static_variables_08006104(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006104",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_08006104"
        },
        "FUN_08002540": {
            "renaming": {
                "FUN_08002540": "set_interrupt_handler_08002540",
                "IRQn": "irq",
                "uVar1": "irq_num",
                "DAT_0800255c": "interrupt_enable_base_addr",
                "word_offset": "interrupt_enable_reg_word_offset",
                "bit_offset": "interrupt_enable_reg_bit_offset",
                "interrupt_enable_reg": "interrupt_enable_reg_ptr"
            },
            "code": "void set_interrupt_handler_08002540(IRQn_Type_conflict irq) {\n  uint32_t irq_num = (uint32_t)irq;\n  if (irq_num >= 0) {\n    uint32_t word_offset = (irq_num >> 5) + 0x60;\n    uint32_t bit_offset = irq_num & 0x1f;\n    uint32_t* interrupt_enable_reg = (uint32_t*)(DAT_0800255c + word_offset * 4);\n    *interrupt_enable_reg = 1 << bit_offset;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002540",
            "calling": [
                "USART1_IRQHandler",
                "USART3_IRQHandler",
                "USART2_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_interrupt_handler_08002540"
        },
        "FUN_08005be2": {
            "renaming": {
                "__thiscall IPAddress::FUN_08005be2": "printIPAddress",
                "*this": "ipAddress",
                "*p": "printer",
                "sVar1": "numPrinted",
                "sVar2": "dotPrinted",
                "iVar3": "i",
                "iVar4": "totalPrinted",
                "FUN_08005be2": "printIPAddress_08005be2"
            },
            "code": "size_t printIPAddress_08005be2(IPAddress *ipAddress, Print *printer) {\n\tsize_t totalPrinted = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tsize_t numPrinted = Print::print(printer, (ipAddress->_address).bytes[i], 10);\n\t\tsize_t dotPrinted = Print::print(printer, '.');\n\t\ttotalPrinted += numPrinted + dotPrinted;\n\t}\n\ttotalPrinted += Print::print(printer, (ipAddress->_address).bytes[3], 10);\n\treturn totalPrinted;\n}",
            "called": [
                "print",
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005be2",
            "calling": [],
            "imported": false,
            "current_name": "printIPAddress_08005be2"
        },
        "FUN_08006344": {
            "renaming": {
                "FUN_08006344": "write_to_buffer_08006344",
                "param_1": "buffer_address",
                "param_2": "character",
                "param_3": "buffer_ptr",
                "uVar1": "status",
                "pbVar2": "current_pos"
            },
            "code": "uint write_to_buffer_08006344(undefined4 buffer_address, byte character, byte **buffer_ptr)\n{\n  uint status;\n  byte *current_pos;\n  current_pos = *buffer_ptr;\n  *buffer_ptr = current_pos + 1;\n  *current_pos = character;\n  if (((int)(*buffer_ptr)[2] + -1 < 0) && (((int)(*buffer_ptr)[2] + -1 < (int)(*buffer_ptr)[6] || (character == 10)))) {\n    status = __swbuf_r();\n    return status;\n  }\n  return (uint)character;\n}",
            "called": [
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006344",
            "calling": [
                "__sfputs_r"
            ],
            "imported": false,
            "current_name": "write_to_buffer_08006344"
        },
        "FUN_080009c8": {
            "renaming": {
                "FUN_080009c8": "is_not_zero_080009c8",
                "in_ZR": "character"
            },
            "code": "bool is_not_zero_080009c8(char character) {\\n  __aeabi_cdcmpeq();\\n  return character != \"\\0\";\\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009c8",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "is_not_zero_080009c8"
        },
        "FUN_08002db2": {
            "renaming": {
                "FUN_08002db2": "handle_I2C_state_08002db2",
                "*hi2c": "*handle",
                "HVar1": "current_state",
                "pbVar2": "buffer_ptr",
                "uVar3": "transfer_options"
            },
            "code": "HAL_StatusTypeDef_conflict handle_I2C_state_08002db2(I2C_HandleTypeDef *hi2c)\n{\n  HAL_I2C_StateTypeDef current_state = hi2c->State;\n  uint32_t transfer_options = hi2c->XferOptions;\n  \n  if ((hi2c->XferSize == 0) && (current_state == HAL_I2C_STATE_BUSY_TX)) {\n    if ((transfer_options == 4) || ((transfer_options == 8 || (transfer_options == 0xffff0000)))) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n      hi2c->PreviousState = 0;\n      hi2c->State = HAL_I2C_STATE_READY;\n      if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n        hi2c->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(hi2c);\n      }\n      else {\n        hi2c->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(hi2c);\n      }\n    }\n    else {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n      hi2c->PreviousState = 0x11;\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      hi2c->State = HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(hi2c);\n    }\n  }\n  else if ((current_state == HAL_I2C_STATE_BUSY_TX) ||\n          ((hi2c->Mode == HAL_I2C_MODE_MEM && (current_state == HAL_I2C_STATE_BUSY_RX)))) {\n    if (hi2c->XferCount == 0) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n    }\n    else if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n      if (hi2c->EventCount == 0) {\n        if (hi2c->MemaddSize == 1) {\n          hi2c->Instance->DR = hi2c->Memaddress & 0xff;\n          hi2c->EventCount = hi2c->EventCount + 2;\n        }\n        else {\n          hi2c->Instance->DR = (hi2c->Memaddress << 0x10) >> 0x18;\n          hi2c->EventCount = hi2c->EventCount + 1;\n        }\n      }\n      else if (hi2c->EventCount == 1) {\n        hi2c->Instance->DR = hi2c->Memaddress & 0xff;\n        hi2c->EventCount = hi2c->EventCount + 1;\n      }\n      else if (hi2c->EventCount == 2) {\n        if (current_state == HAL_I2C_STATE_BUSY_RX) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x100;\n        }\n        else if (current_state == HAL_I2C_STATE_BUSY_TX) {\n          uint8_t *buffer_ptr = hi2c->pBuffPtr;\n          hi2c->pBuffPtr = buffer_ptr + 1;\n          hi2c->Instance->DR = (uint)*buffer_ptr;\n          hi2c->XferCount = hi2c->XferCount - 1;\n        }\n      }\n    }\n    else {\n      uint8_t *buffer_ptr = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = buffer_ptr + 1;\n      hi2c->Instance->DR = (uint)*buffer_ptr;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002db2",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_I2C_state_08002db2"
        },
        "FUN_08005932": {
            "renaming": {
                "FUN_08005932": "readNextByteFromSerialBuffer_08005932",
                "this": "serialObj",
                "uVar1": "tailPos"
            },
            "code": "int readNextByteFromSerialBuffer_08005932(HardwareSerial *serialObj){\n    uint tailPos = (uint)(serialObj->_serial).rx_tail;\n    if ((serialObj->_serial).rx_head != tailPos) {\n        return (uint)(serialObj->_serial).rx_buff[tailPos];\n    }\n    return -1;\n  }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005932",
            "calling": [],
            "imported": false,
            "current_name": "readNextByteFromSerialBuffer_08005932"
        },
        "FUN_08001cc4": {
            "renaming": {
                "FUN_08001cc4": "get_uwTick_08001cc4",
                "PTR_uwTick_08001ccc": "uwTick_ptr"
            },
            "code": "uint32_t get_uwTick_08001cc4(void)\n{\n  uint32_t* PTR_uwTick_08001ccc = (uint32_t*)PTR_uwTick_08001ccc;\n  uint32_t uwTick = *PTR_uwTick_08001ccc;\n  return uwTick;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001cc4",
            "calling": [
                "ADC_ConversionStop_Disable",
                "ADC_Enable",
                "uart_debug_write",
                "HAL_UART_Transmit",
                "HAL_ADCEx_Calibration_Start",
                "HAL_RCC_OscConfig",
                "UART_WaitOnFlagUntilTimeout",
                "HAL_ADC_PollForConversion",
                "HAL_RCCEx_PeriphCLKConfig",
                "GetCurrentMilli",
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "get_uwTick_08001cc4"
        },
        "FUN_08002db0": {
            "renaming": {
                "FUN_08002db0": "do_nothing_08002db0"
            },
            "code": "\nvoid do_nothing_08002db0(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002db0",
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "imported": false,
            "current_name": "do_nothing_08002db0"
        },
        "FUN_08003ea0": {
            "renaming": {
                "FUN_08003ea0": "handle_rtc_alarm_08003ea0",
                "hrtc": "rtc_handle",
                "hrtc->Instance->CRH": "rtc_handle->Instance->ControlRegisterHigh",
                "hrtc->Instance->CRL": "rtc_handle->Instance->ControlRegisterLow",
                "HAL_RTC_AlarmAEventCallback": "handle_rtc_alarm_a_event",
                "DAT_08003ed4": "data_section",
                "is_alarm_a_enabled": "is_alarm_A_enabled",
                "is_alarm_a_flag_set": "is_alarm_A_flag_set"
            },
            "code": "void handle_rtc_alarm_08003ea0(RTC_HandleTypeDef *rtc_handle) {\n  bool is_alarm_a_enabled = (rtc_handle->Instance->CRH & 2) != 0;\n  bool is_alarm_a_flag_set = (rtc_handle->Instance->CRL & 2) != 0;\n  if (is_alarm_a_enabled && is_alarm_a_flag_set) {\n    HAL_RTC_AlarmAEventCallback(rtc_handle);\n    rtc_handle->Instance->CRL = 0xfffffffd;\n  }\n  *(uint32_t *)(DAT_08003ed4 + 0x14) = 0x20000;\n  rtc_handle->State = HAL_RTC_STATE_READY;\n  return;\n}",
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ea0",
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_rtc_alarm_08003ea0"
        },
        "FUN_0800306c": {
            "renaming": {
                "FUN_0800306c": "handleI2CDataTransfer_0800306c",
                "*hi2c": "*i2cHandle",
                "uVar1": "transferOptions",
                "puVar2": "dataPtr"
            },
            "code": "HAL_StatusTypeDef handleI2CDataTransfer_0800306c(I2C_HandleTypeDef *i2cHandle) {\n    uint32_t transferOptions = i2cHandle->XferOptions;\n    if (i2cHandle->XferCount == 3) {\n        if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n        uint8_t *dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n        i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    else if (i2cHandle->XferCount == 2) {\n        if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n            i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffcff;\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else {\n            if (transferOptions == 2) {\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n            }\n            else {\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n            }\n            i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffcff;\n        }\n        uint8_t *dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n        i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n        i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        i2cHandle->PreviousState = 0;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n            i2cHandle->Mode = HAL_I2C_MODE_NONE;\n            HAL_I2C_MemRxCpltCallback(i2cHandle);\n        }\n        else {\n            i2cHandle->Mode = HAL_I2C_MODE_NONE;\n            HAL_I2C_MasterRxCpltCallback(i2cHandle);\n        }\n    }\n    else {\n        uint8_t *dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n        i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800306c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handleI2CDataTransfer_0800306c"
        },
        "FUN_08005c64": {
            "renaming": {
                "FUN_08005c64": "initialize_static_data_and_destructor_08005c64",
                "__static_initialization_and_destruction_0": "initialize_and_destructor"
            },
            "code": "void initialize_static_data_and_destructor_08005c64(void)\n{\n  initialize_and_destructor(1, 0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005c64",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_and_destructor_08005c64"
        },
        "FUN_0800548c": {
            "renaming": {
                "FUN_0800548c": "is_uart_transmit_complete_0800548c",
                "obj": "serial_obj",
                "HVar1": "uart_state",
                "PTR_uart_handlers_080054ac": "UART_HANDLER_PTR",
                "index": "serial_index",
                "uint8_t": "bool",
                "0x22U": "UART_STATE_READY",
                "HAL_UART_StateTypeDef": "UART_State",
                "HAL_UART_GetState": "HAL_UART_GetState",
                "*(UART_HandleTypeDef **)": "*",
                "PTR_uart_handlers_080054ac + (uint)obj->index * 4": "UART_HANDLER_PTR + (uint)serial_obj->index * 4",
                "&": "&",
                "}": "}"
            },
            "code": "bool is_uart_transmit_complete_0800548c(serial_t *serial_obj)\\n\\\n{\\n\\\n  UART_HandleTypeDef *uart_handler = *(UART_HandleTypeDef **)(PTR_uart_handlers_080054ac + (uint)serial_obj->index * 4);\\n\\\n  HAL_UART_StateTypeDef uart_state = HAL_UART_GetState(uart_handler);\\n\\\n  return (uart_state & UART_STATE_MASK) == UART_STATE_READY;\\n\\\n}",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800548c",
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "imported": false,
            "current_name": "is_uart_transmit_complete_0800548c"
        },
        "FUN_08000924": {
            "renaming": {
                "FUN_08000924": "check_parameters_08000924",
                "param_1": "first_param",
                "param_2": "second_param",
                "param_3": "third_param",
                "param_4": "fourth_param",
                "uVar1": "xor_result",
                "bVar2": "are_first_params_zero",
                "bVar3": "is_fourth_param_greater"
            },
            "code": "uint check_parameters_08000924(uint first_param, uint second_param, uint third_param, uint fourth_param)\n{\n    uint result;\n    bool is_negative_first = ((int)(second_param << 1) >> 0x15 == -1);\n    bool is_negative_second = ((int)(fourth_param << 1) >> 0x15 == -1);\n    \n    if ((is_negative_first || is_negative_second) && ((is_negative_first && ((first_param | second_param << 0xc) != 0)) || ((is_negative_second && ((third_param | fourth_param << 0xc) != 0)))) {\n        return 1;\n    }\n    \n    bool are_first_params_zero = (first_param | second_param << 1) == 0;\n    bool are_second_params_zero = (third_param | fourth_param << 1) == 0;\n    bool are_params_equal = (second_param == fourth_param) && (first_param == third_param);\n    \n    if (!(are_first_params_zero || are_second_params_zero || are_params_equal)) {\n        uint xor_result = second_param ^ fourth_param;\n        bool is_xor_result_zero = xor_result == 0;\n        bool is_xor_result_positive = -1 < (int)xor_result;\n        bool is_fourth_param_greater = (is_xor_result_positive && fourth_param <= second_param);\n        bool is_third_param_smaller = (is_xor_result_zero || is_fourth_param_greater) && (third_param <= first_param);\n        \n        int shift = (int)fourth_param >> 0x1f;\n        if (!is_third_param_smaller) {\n            shift = ~shift;\n        }\n        result = shift | 1;\n    }\n    else {\n        result = 0;\n    }\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000924",
            "calling": [],
            "imported": false,
            "current_name": "check_parameters_08000924"
        },
        "FUN_08006c34": {
            "renaming": {
                "FUN_08006c34": "walk_reentrantly_and_free_resources_08006c34",
                "param_1": "reentrancy_structure",
                "DAT_08006c3c": "global_free_function"
            },
            "code": "void walk_reentrantly_and_free_resources_08006c34(void* reentrancy_structure)\n{\n  _fwalk_reent(reentrancy_structure, DAT_08006c3c);\n  return;\n}",
            "called": [
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c34",
            "calling": [],
            "imported": false,
            "current_name": "walk_reentrantly_and_free_resources_08006c34"
        },
        "FUN_080072a4": {
            "renaming": {
                "std::ctype_byname<char>::FUN_080072a4": "set_ptr_values",
                "FUN_080072a4": "set_ptr_values_080072a4"
            },
            "code": "void set_ptr_values_080072a4(void)\n{\n    if (*(int *)PTR_id_08007308 < 0)\n    {\n        *(undefined4 *)PTR_id_08007308 = 1;\n    }\n    if (*(int *)PTR_id_0800730c < 0)\n    {\n        *(undefined4 *)PTR_id_0800730c = 1;\n    }\n    if (*(int *)PTR_id_08007310 < 0)\n    {\n        *(undefined4 *)PTR_id_08007310 = 1;\n    }\n    if (*(int *)PTR_id_08007314 < 0)\n    {\n        *(undefined4 *)PTR_id_08007314 = 1;\n    }\n    if (*(int *)PTR_id_08007318 < 0)\n    {\n        *(undefined4 *)PTR_id_08007318 = 1;\n    }\n    if (*(int *)PTR_id_0800731c < 0)\n    {\n        *(undefined4 *)PTR_id_0800731c = 1;\n    }\n    if (*(int *)PTR_id_08007320 < 0)\n    {\n        *(undefined4 *)PTR_id_08007320 = 1;\n    }\n    if (*(int *)PTR_id_08007324 < 0)\n    {\n        *(undefined4 *)PTR_id_08007324 = 1;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072a4",
            "calling": [],
            "imported": false,
            "current_name": "set_ptr_values_080072a4"
        },
        "FUN_08004848": {
            "renaming": {
                "FUN_08004848": "get_gpio_type_08004848",
                "port_idx": "port_index",
                "DAT_08004870": "port_0_type",
                "DAT_08004880": "port_1_type",
                "DAT_08004874": "port_2_type",
                "DAT_08004878": "port_3_type",
                "DAT_0800487c": "port_4_type"
            },
            "code": "GPIO_TypeDef * get_gpio_type_08004848(uint32_t port_idx)\n{\n  switch(port_idx) {\n  case 0:\n    return DAT_08004870;\n  case 1:\n    return DAT_08004880;\n  case 2:\n    return DAT_08004874;\n  case 3:\n    return DAT_08004878;\n  case 4:\n    return DAT_0800487c;\n  default:\n    return (GPIO_TypeDef *)0x0;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004848",
            "calling": [
                "digitalWrite",
                "digitalRead"
            ],
            "imported": false,
            "current_name": "get_gpio_type_08004848"
        },
        "FUN_08005d82": {
            "renaming": {
                "FUN_08005d82": "print_integer_08005d82",
                "this": "print_object",
                "n": "number",
                "base": "base",
                "sVar1": "result"
            },
            "code": "size_t __thiscall Print::print_integer_08005d82(Print *print_object,int number,int base)\n{\n  size_t result;\n  \n  result = print_integer_08005d82(print_object, number, base);\n  return result;\n}",
            "called": [
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d82",
            "calling": [
                "printFloat",
                "loop"
            ],
            "imported": false,
            "current_name": "print_integer_08005d82"
        },
        "FUN_08006f92": {
            "renaming": {
                "FUN_08006f92": "seek_and_update_08006f92",
                "param_1": "file_descriptor",
                "param_2": "metadata_ptr",
                "iVar1": "seek_result",
                "uVar2": "metadata_flags",
                "bVar3": "seek_failed"
            },
            "code": "void seek_and_update_08006f92(int file_descriptor,int metadata_ptr)\n{\n  int seek_result;\n  ushort metadata_flags;\n  bool seek_failed;\n  \n  seek_result = _lseek_r(file_descriptor,(int)*(short *)(metadata_ptr + 0xe));\n  seek_failed = seek_result == -1;\n  if (seek_failed) {\n    metadata_flags = *(ushort *)(metadata_ptr + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(metadata_ptr + 0x54) = seek_result;\n    metadata_flags = *(ushort *)(metadata_ptr + 0xc) | 0x1000;\n  }\n  if (seek_failed) {\n    *(ushort *)(metadata_ptr + 0xc) = metadata_flags;\n  }\n  if (!seek_failed) {\n    *(ushort *)(metadata_ptr + 0xc) = metadata_flags;\n  }\n  return;\n}",
            "called": [
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006f92",
            "calling": [],
            "imported": false,
            "current_name": "seek_and_update_08006f92"
        },
        "FUN_080012c0": {
            "renaming": {
                "FUN_080012c0": "writeToDataPins_080012c0",
                "this": "lcd",
                "value": "data",
                "uVar1": "i"
            },
            "code": "void __thiscall LiquidCrystal::writeToDataPins_080012c0(LiquidCrystal *this, uint8_t value) {\n  for (uint8_t i = 0; i < 4; i++) {\n    digitalWrite((uint)this->_data_pins[i], (int)(uint)value >> (i & 0xff) & 1);\n  }\n  pulseEnable(this);\n  return;\n}",
            "called": [
                "digitalWrite",
                "pulseEnable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080012c0",
            "calling": [
                "send",
                "begin"
            ],
            "imported": false,
            "current_name": "writeToDataPins_080012c0"
        },
        "FUN_08001f80": {
            "renaming": {
                "FUN_08001f80": "get_adc_state_08001f80",
                "hadc": "adc_handle"
            },
            "code": "uint32_t get_adc_state_08001f80(ADC_HandleTypeDef* adc_handle) {\n    return adc_handle->State;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001f80",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_adc_state_08001f80"
        },
        "FUN_08001f84": {
            "renaming": {
                "FUN_08001f84": "check_ADC_status_08001f84",
                "*hadc": "*hadc",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "current_time",
                "pAVar4": "adc_instance",
                "wait_loop_index": "i"
            },
            "code": "HAL_StatusTypeDef_conflict check_ADC_status_08001f84(ADC_HandleTypeDef *hadc)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t wait_time;\n  uint32_t start_time;\n  ADC_TypeDef *adc_instance;\n\n  adc_instance = hadc->Instance;\n  if ((adc_instance->CR2 & 1) == 0) {\n    adc_instance->CR2 = adc_instance->CR2 | 1;\n    wait_time = (uint32_t)((uint64_t)DAT_08002000 * (uint64_t)*(uint *)PTR_SystemCoreClock_08001ffc >> 0x32);\n    for (uint32_t i = 0; i < wait_time; i++) {\n    }\n    start_time = HAL_GetTick();\n    do {\n      if ((hadc->Instance->CR2 & 1) != 0) {\n        return HAL_OK;\n      }\n      uint32_t current_time = HAL_GetTick();\n    } while (current_time - start_time < 3);\n    hadc->State |= 0x10;\n    hadc->ErrorCode |= 1;\n    hadc->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  else {\n    status = HAL_OK;\n  }\n  return status;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001f84",
            "calling": [
                "HAL_ADC_Start",
                "HAL_ADCEx_Calibration_Start"
            ],
            "imported": false,
            "current_name": "check_ADC_status_08001f84"
        },
        "FUN_08000bcc": {
            "renaming": {
                "FUN_08000bcc": "initializeSystem_08000bcc",
                "puVar1": "pinPtr",
                "puVar2": "ledPinPtr",
                "this": "lcdPtr",
                "uVar3": "currentTime",
                "ssrPin": "ssrPin",
                "buzzerPin": "buzzerPin",
                "ledRedPin": "ledRedPin"
            },
            "code": "void initializeSystem_08000bcc(void)\n{\n  uint32_t ssrPin;\n  uint32_t buzzerPin;\n  uint32_t ledRedPin;\n  LiquidCrystal lcd(8, 9, 4, 5, 6, 7);\n\n  ssrPin = *PTR_ssrPin_08000c90;\n  digitalWrite(ssrPin, LOW);\n  pinMode(ssrPin, OUTPUT);\n  buzzerPin = *PTR_buzzerPin_08000c94;\n  digitalWrite(buzzerPin, LOW);\n  pinMode(buzzerPin, OUTPUT);\n  ledRedPin = *PTR_ledRedPin_08000c98;\n  digitalWrite(ledRedPin, LOW);\n  pinMode(ledRedPin, OUTPUT);\n  digitalWrite(buzzerPin, HIGH);\n  lcd.begin(16, 2);\n  lcd.createChar(0, *PTR_degree_08000ca0);\n  lcd.clear();\n  lcd.print(\"Reflow\");\n  lcd.setCursor(0, 1);\n  lcd.print(\"Oven 1.2\");\n  digitalWrite(buzzerPin, LOW);\n  delay(2500);\n  lcd.clear();\n  Serial2.begin(57600);\n  digitalWrite(ledRedPin, HIGH);\n  *PTR_windowSize_08000cb0 = 2000;\n  *PTR_nextCheck_08000cb4 = millis();\n  *PTR_nextRead_08000cb8 = millis();\n  startForkserver(0);\n}\n",
            "called": [
                "clear",
                "createChar",
                "millis",
                "begin",
                "digitalWrite",
                "setCursor",
                "print",
                "begin",
                "pinMode",
                "startForkserver",
                "delay"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000bcc",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initializeSystem_08000bcc"
        },
        "FUN_080047d8": {
            "renaming": {
                "FUN_080047d8": "reset_uart_errors_080047d8",
                "hdma": "dma_handle",
                "huart": "uart_handle",
                "RxXferCount": "rx_transfer_count",
                "TxXferCount": "tx_transfer_count",
                "HAL_UART_ErrorCallback": "handle_uart_error"
            },
            "code": "void reset_uart_errors_080047d8(DMA_HandleTypeDef *dma_handle)\n{\n  UART_HandleTypeDef *uart_handle;\n  uart_handle = (UART_HandleTypeDef *)dma_handle->Parent;\n  uart_handle->RxXferCount = 0;\n  uart_handle->TxXferCount = 0;\n  HAL_UART_ErrorCallback(uart_handle);\n  return;\n}",
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047d8",
            "calling": [],
            "imported": false,
            "current_name": "reset_uart_errors_080047d8"
        },
        "FUN_0800281e": {
            "renaming": {
                "FUN_0800281e": "set_gpio_pin_state_0800281e",
                "GPIOx": "gpio",
                "GPIO_Pin": "pin_number",
                "PinState": "state",
                "BSRR": "bit_set_reset_register",
                "GPIO_PIN_RESET": "GPIO_PIN_RESET",
                "uint": "uint32_t"
            },
            "code": "void set_gpio_pin_state_0800281e(GPIO_TypeDef *gpio, uint16_t pin_number, GPIO_PinState state)\n{\n  if (state == GPIO_PIN_RESET) {\n    gpio->BSRR = (uint32_t)pin_number << 0x10;\n    return;\n  }\n  gpio->BSRR = (uint32_t)pin_number;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800281e",
            "calling": [
                "digital_io_write"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_0800281e"
        },
        "FUN_08006198": {
            "renaming": {
                "FUN_08006198": "execute_init_functions_08006198",
                "puVar1": "init_func_ptr",
                "iVar2": "num_init_funcs",
                "iVar3": "i",
                "_init": "_init",
                "PTR___preinit_array_end_080061d0": "preinit_array_end",
                "PTR___preinit_array_end_080061d4": "preinit_array_end_4",
                "code": "void",
                "PTR___preinit_array_end_080061d8": "fini_array_end",
                "PTR___do_global_dtors_aux_fini_array_entry_080061dc": "do_global_dtors_aux_fini_array_entry",
                "puVar1 + iVar3 * 4": "*(init_func_ptr + i * 4)",
                "dtor_func_ptr": "fini_array_end",
                "num_dtor_funcs": "num_dtor_funcs",
                "**(code **)(puVar1 + iVar3 * 4))()": "(**(void (**)(void))(init_func_ptr + i * 4))()"
            },
            "code": "void execute_init_functions_08006198(void)\n{\n  void **init_func_ptr = PTR___preinit_array_end_080061d0;\n  int num_init_funcs = (int)PTR___PTR___preinit_array_end_080061d0_080061d4 - (int)PTR___preinit_array_end_080061d0;\n  for (int i = 0; i < num_init_funcs >> 2; i++) {\n    (**(void (**)(void))(init_func_ptr + i * 4))();\n  }\n  _init();\n  void **dtor_func_ptr = PTR___preinit_array_end_080061d8;\n  int num_dtor_funcs = (int)PTR___do_global_dtors_aux_fini_array_entry_080061dc - (int)PTR___preinit_array_end_080061d8;\n  for (int i = 0; i < num_dtor_funcs >> 2; i++) {\n    (**(void (**)(void))(dtor_func_ptr + i * 4))();\n  }\n  return;\n}",
            "called": [
                "premain",
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006198",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "execute_init_functions_08006198"
        },
        "FUN_08006fc0": {
            "renaming": {
                "FUN_08006fc0": "write_to_file_08006fc0",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "puVar1": "errno_ptr",
                "iVar2": "bytes_written"
            },
            "code": "void write_to_file_08006fc0(int *error_code, int file_descriptor, char *buffer, int buffer_size) {\n    undefined *errno_ptr = PTR_errno_08006fe0;\n    *(undefined4 *)PTR_errno_08006fe0 = 0;\n    int bytes_written = _write(file_descriptor, buffer, buffer_size);\n    if ((bytes_written == -1) && (*(int *)errno_ptr != 0)) {\n        *error_code = *(int *)errno_ptr;\n    }\n    return;\n}",
            "called": [
                "_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006fc0",
            "calling": [
                "__swrite"
            ],
            "imported": false,
            "current_name": "write_to_file_08006fc0"
        },
        "FUN_08007048": {
            "renaming": {
                "FUN_08007048": "seek_file_08007048",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "puVar1": "error_ptr",
                "iVar2": "seek_result"
            },
            "code": "void seek_file_08007048(int *error_code, int file_descriptor, int offset, int whence) {\n    int seek_result = 0;\n    int *error_ptr = PTR_errno_08007068;\n    *error_ptr = 0;\n    seek_result = _lseek(file_descriptor, offset, whence);\n    if (seek_result == -1 && *error_ptr != 0) {\n        *error_code = *error_ptr;\n    }\n    return;\n}",
            "called": [
                "_lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007048",
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "imported": false,
            "current_name": "seek_file_08007048"
        },
        "FUN_08003c50": {
            "renaming": {
                "FUN_08003c50": "get_HCLK_frequency_08003c50",
                "uVar1": "HCLK_Frequency",
                "DAT_08003c68": "DAT_offset",
                "PTR_APBPrescTable_08003c6c": "APB_prescaler_table",
                "shift": "APB_prescaler_shift",
                "uVar1 >> PTR_APBPrescTable_08003c6c[(uint)(*(int *)(DAT_08003c68 + 4) << 0x15) >> 0x1d]": "HCLK_Frequency >> APB_prescaler"
            },
            "code": "uint32_t get_HCLK_frequency_08003c50(void)\n{\n  uint32_t HCLK_Frequency = HAL_RCC_GetHCLKFreq();\n  int shift = (*(int *)(DAT_08003c68 + 4) << 0x15) >> 0x1d;\n  uint32_t APB_prescaler = PTR_APBPrescTable_08003c6c[(uint)shift];\n  return uVar1 >> PTR_APBPrescTable_08003c6c[(uint)(*(int *)(DAT_08003c68 + 4) << 0x15) >> 0x1d];\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003c50",
            "calling": [
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "get_HCLK_frequency_08003c50"
        },
        "FUN_080065c0": {
            "renaming": {
                "FUN_080065c0": "process_data_080065c0",
                "param_1": "input_data",
                "param_2": "data_ptr1",
                "param_3": "data_ptr2",
                "param_4": "input_value",
                "param_5": "function_ptr",
                "iVar1": "loop_counter",
                "uVar2": "max_value",
                "uVar3": "current_value",
                "bVar4": "is_valid_data",
                "data_offset": "data_offset"
            },
            "code": "undefined4 process_data_080065c0(undefined4 input_data, uint *data_ptr1, uint *data_ptr2, undefined4 input_value, code *function_ptr)\\n{\\n  int loop_counter;\\n  uint max_value;\\n  uint current_value;\\n  bool is_valid_data;\\n  \\n  max_value = data_ptr1[4];\\n  if ((int)data_ptr1[4] < (int)data_ptr1[2]) {\\n    max_value = data_ptr1[2];\\n  }\\n  *data_ptr2 = max_value;\\n  if (*(char *)((int)data_ptr1 + 0x43) != \"\\0\") {\\n    *data_ptr2 = max_value + 1;\\n  }\\n  if ((int)(*data_ptr1 << 0x1a) < 0) {\\n    *data_ptr2 = *data_ptr2 + 2;\\n  }\\n  current_value = *data_ptr1 & 6;\\n  if (current_value == 0) {\\n    for (; (int)current_value < (int)(data_ptr1[3] - *data_ptr2); current_value = current_value + 1) {\\n      loop_counter = (*function_ptr)(input_data,input_value,(int)data_ptr1 + 0x19,1);\\n      if (loop_counter == -1) {\\n        return 0xffffffff;\\n      }\\n    }\\n  }\\n  current_value = (uint)*(byte *)((int)data_ptr1 + 0x43);\\n  if (current_value != 0) {\\n    current_value = 1;\\n  }\\n  uint data_offset = current_value;\\n  if ((int)(*data_ptr1 << 0x1a) < 0) {\\n    *(undefined *)((int)data_ptr1 + current_value + 0x43) = 0x30;\\n    data_offset = current_value + 2;\\n    *(undefined *)((int)data_ptr1 + current_value + 0x44) = *(undefined *)((int)data_ptr1 + 0x45);\\n  }\\n  loop_counter = (*function_ptr)(input_data,input_value,(int)data_ptr1 + 0x43,data_offset);\\n  if (loop_counter != -1) {\\n    max_value = data_ptr1[3];\\n    is_valid_data = (*data_ptr1 & 6) != 4;\\n    if (is_valid_data) {\\n      max_value = 0;\\n    }\\n    current_value = 0;\\n    if (!is_valid_data) {\\n      max_value = max_value - *data_ptr2;\\n    }\\n    if (!is_valid_data) {\\n      max_value = max_value & ~((int)max_value >> 0x1f);\\n    }\\n    if ((int)data_ptr1[4] < (int)data_ptr1[2]) {\\n      max_value = max_value + (data_ptr1[2] - data_ptr1[4]);\\n    }\\n    while( true ) {\\n      if (max_value == current_value) {\\n        return 0;\\n      }\\n      loop_counter = (*function_ptr)(input_data,input_value,(int)data_ptr1 + 0x1a,1);\\n      if (loop_counter == -1) break;\\n      current_value = current_value + 1;\\n    }\\n  }\\n  return 0xffffffff;\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080065c0",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "process_data_080065c0"
        },
        "FUN_080054d4": {
            "renaming": {
                "FUN_080054d4": "receive_data_from_serial_080054d4",
                "*obj": "*serial_obj",
                "*c": "*received_data",
                "uVar1": "rx_active_flag",
                "obj": "serial_obj",
                "PTR_uart_handlers_0800550c": "PTR_uart_handlers_0800550c",
                "index": "index",
                "recv": "recv",
                "HAL_UART_Receive_IT": "HAL_UART_Receive_IT",
                "UART_HandleTypeDef": "UART_HandleTypeDef"
            },
            "code": "int receive_data_from_serial_080054d4(serial_t *serial_obj, uchar *received_data) {\n  uint8_t rx_active_flag;\n  if (serial_obj == NULL) {\n    return -1;\n  }\n  rx_active_flag = serial_rx_active(serial_obj);\n  if (rx_active_flag == 0) {\n    *received_data = serial_obj->recv;\n    HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_0800550c + (uint)serial_obj->index * 4), &serial_obj->recv, 1);\n    return 0;\n  }\n  return -1;\n}",
            "called": [
                "serial_rx_active",
                "HAL_UART_Receive_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080054d4",
            "calling": [
                "_rx_complete_irq"
            ],
            "imported": false,
            "current_name": "receive_data_from_serial_080054d4"
        },
        "FUN_0800715c": {
            "renaming": {
                "std::ctype_byname<wchar_t>::FUN_0800715c": "set_ptr_id_values_to_1",
                "*PTR_id_080071f0": "*ptr_id_1",
                "*PTR_id_080071f4": "*ptr_id_2",
                "*PTR_id_080071f8": "*ptr_id_3",
                "*PTR_id_080071fc": "*ptr_id_4",
                "*PTR_id_08007200": "*ptr_id_5",
                "*PTR_id_08007204": "*ptr_id_6",
                "*PTR_id_08007208": "*ptr_id_7",
                "*PTR_id_0800720c": "*ptr_id_8",
                "*PTR_id_08007210": "*ptr_id_9",
                "*PTR_id_08007214": "*ptr_id_10",
                "*PTR_id_08007218": "*ptr_id_11",
                "*PTR_id_0800721c": "*ptr_id_12",
                "FUN_0800715c": "set_ptr_id_values_to_1_0800715c"
            },
            "code": "void set_ptr_id_values_to_1_0800715c(void)\n{\n\tif (*(int *)PTR_id_080071f0 < 0)\n\t{\n\t\t*(undefined4 *)PTR_id_080071f0 = 1;\n\t}\n\tif (*(int *)PTR_id_080071f4 < 0)\n\t{\n\t\t*(undefined4 *)PTR_id_080071f4 = 1;\n\t}\n\tif (*(int *)PTR_id_080071f8 < 0)\n\t{\n\t\t*(undefined4 *)PTR_id_080071f8 = 1;\n\t}\n\tif (*(int *)PTR_id_080071fc < 0)\n\t{\n\t\t*(undefined4 *)PTR_id_080071fc = 1;\n\t}\n\tif (*(int *)PTR_id_08007200 < 0)\n\t{\n\t\t*(undefined4 *)PTR_id_08007200 = 1;\n\t}\n\tif (*(int *)PTR_id_08007204 < 0)\n\t{\n\t\t*(undefined4 *)PTR_id_08007204 = 1;\n\t}\n\tif (*(int *)PTR_id_08007208 < 0)\n\t{\n\t\t*(undefined4 *)PTR_id_08007208 = 1;\n\t}\n\tif (*(int *)PTR_id_0800720c < 0)\n\t{\n\t\t*(undefined4 *)PTR_id_0800720c = 1;\n\t}\n\tif (*(int *)PTR_id_08007210 < 0)\n\t{\n\t\t*(undefined4 *)PTR_id_08007210 = 1;\n\t}\n\tif (*(int *)PTR_id_08007214 < 0)\n\t{\n\t\t*(undefined4 *)PTR_id_08007214 = 1;\n\t}\n\tif (*(int *)PTR_id_08007218 < 0)\n\t{\n\t\t*(undefined4 *)PTR_id_08007218 = 1;\n\t}\n\tif (*(int *)PTR_id_0800721c < 0)\n\t{\n\t\t*(undefined4 *)PTR_id_0800721c = 1;\n\t}\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800715c",
            "calling": [],
            "imported": false,
            "current_name": "set_ptr_id_values_to_1_0800715c"
        },
        "FUN_08004d40": {
            "renaming": {
                "FUN_08004d40": "wait_for_input_08004d40",
                "msg": "message",
                "val": "value"
            },
            "code": "void wait_for_input_08004d40(char *message, int value)\n{\n  while(true) {\n    // Do nothing\n  }\n}",
            "called": [
                "_Error_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d40",
            "calling": [
                "SystemClock_Config",
                "_Error_Handler"
            ],
            "imported": false,
            "current_name": "wait_for_input_08004d40"
        },
        "FUN_08004d44": {
            "renaming": {
                "FUN_08004d44": "set_bit_08004d44",
                "puVar1": "ptr_data"
            },
            "code": "void set_bit_08004d44(uint *data)\n{\n  uint *ptr_data = data;\n  *ptr_data |= 1;\n  ptr_data[1] &= DAT_08004d88;\n  *ptr_data &= 0xfef6ffff;\n  *ptr_data &= 0xfffbffff;\n  ptr_data[1] &= 0xff80ffff;\n  ptr_data[2] = 0x9f0000;\n  *(uint *)(DAT_08004d8c + 8) = 0x8000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d44",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "set_bit_08004d44"
        },
        "FUN_0800282c": {
            "renaming": {
                "FUN_0800282c": "update_GPIO_Pin_0800282c",
                "GPIO_Pin": "pin",
                "PTR_08002844": "DAT_08002844",
                "DAT_08002844": "DAT_08002844",
                "uint": "unsigned int",
                "pin_ptr": "pin_pointer",
                "pin_mask": "pin_mask"
            },
            "code": "void update_GPIO_Pin_0800282c(uint16_t pin) {\n  uint* pin_ptr = (uint*)(PTR_08002844 + 0x14);\n  uint pin_mask = (uint)pin;\n  if ((*pin_ptr & pin_mask) != 0) {\n    *pin_ptr = pin_mask;\n    HAL_GPIO_EXTI_Callback(pin);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800282c",
            "calling": [
                "EXTI1_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI4_IRQHandler",
                "EXTI15_10_IRQHandler",
                "EXTI9_5_IRQHandler"
            ],
            "imported": false,
            "current_name": "update_GPIO_Pin_0800282c"
        },
        "FUN_080015b2": {
            "renaming": {
                "MAX31855::FUN_080015b2": "readMAX31855",
                "this": "sensor",
                "iVar1": "readBit",
                "uVar2": "i",
                "uVar3": "readValue",
                "FUN_080015b2": "readMAX31855_080015b2"
            },
            "code": "unsigned long readMAX31855_080015b2(MAX31855 *sensor)\\n\\\n{\\n\\\n  int readBit;\\n\\\n  uint32_t readValue = 0;\\n\\\n  digitalWrite(sensor->cs, LOW);\\n\\\n  for (int i = 31; i >= 0; i--) {\\n\\\n    digitalWrite(sensor->sck, HIGH);\\n\\\n    readBit = digitalRead(sensor->so);\\n\\\n    if (readBit != 0) {\\n\\\n      readValue |= (uint32_t)1 << i;\\n\\\n    }\\n\\\n    digitalWrite(sensor->sck, LOW);\\n\\\n  }\\n\\\n  digitalWrite(sensor->cs, HIGH);\\n\\\n  return (unsigned long)readValue;\\n\\\n}",
            "called": [
                "digitalWrite",
                "digitalRead"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015b2",
            "calling": [
                "readThermocouple"
            ],
            "imported": false,
            "current_name": "readMAX31855_080015b2"
        },
        "FUN_0800040c": {
            "renaming": {
                "FUN_0800040c": "reverse_bits_0800040c",
                "param_1": "num",
                "uVar1": "shifted_num_high",
                "uVar2": "shift_amount",
                "iVar3": "leading_zeroes",
                "uVar4": "temp",
                "in_r12": "inverse_shift_amount",
                "bVar5": "shift_difference_is_negative",
                "bVar6": "shift_difference_is_zero",
                "bVar7": "temp_bool"
            },
            "code": "ulonglong reverse_bits_0800040c(uint num) {\n  if (num == 0) {\n    return 0;\n  }\n  uint leading_zeroes = count_leading_zeroes(num);\n  uint shift_amount = leading_zeroes + 21;\n  bool shift_condition = shift_amount < 32;\n  uint shifted_num = shift_condition ? (num << (shift_amount & 0xff)) : 0;\n  uint remaining_bits = shift_condition ? (num >> ((12 - leading_zeroes) & 0xff)) : (num << (leading_zeroes & 0xff));\n  if (shift_condition == false) {\n    remaining_bits |= 0U >> ((32 - leading_zeroes) & 0xff);\n  }\n  if (shift_condition == false) {\n    shifted_num = 0 << (leading_zeroes & 0xff);\n  }\n  if (shift_amount < 1075) {\n    return CONCAT44(remaining_bits + (1074 - shift_amount) * 0x100000, shifted_num);\n  }\n  uint inverse_shift_amount = ~(1074 - shift_amount);\n  if (30 < inverse_shift_amount) {\n    return (ulonglong)(remaining_bits >> ((inverse_shift_amount - 31) & 0xff));\n  }\n  int shift_difference = inverse_shift_amount - 19;\n  if (shift_difference == 0 || shift_difference < 0 != SCARRY4(inverse_shift_amount - 31, 12)) {\n    inverse_shift_amount++;\n    return CONCAT44(remaining_bits >> (inverse_shift_amount & 0xff), shifted_num >> (inverse_shift_amount & 0xff) | remaining_bits << ((32 - inverse_shift_amount) & 0xff));\n  }\n  return (ulonglong)(shifted_num >> ((32 - (12 - shift_difference)) & 0xff) | remaining_bits << (shift_difference & 0xff));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800040c",
            "calling": [
                "SetSampleTime",
                "printFloat",
                "readThermocouple",
                "SetTunings",
                "loop"
            ],
            "imported": false,
            "current_name": "reverse_bits_0800040c"
        },
        "FUN_08006088": {
            "renaming": {
                "FUN_08006088": "handle_GPIO_interrupt_08006088",
                "PTR_button_pin": "button_pin"
            },
            "code": "void handle_GPIO_interrupt_08006088(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(PTR_button_pin);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006088",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_interrupt_08006088"
        },
        "FUN_08006eb0": {
            "renaming": {
                "FUN_08006eb0": "execute_function_08006eb0",
                "*param_1": "*result",
                "param_2": "parameter_index",
                "param_3": "error_code",
                "param_4": "signal_code",
                "_Var1": "process_id",
                "uVar2": "kill_result",
                "iVar3": "function_pointer",
                "pcVar4": "function_code_pointer"
            },
            "code": "int execute_function_08006eb0(int *result, uint parameter_index, int error_code, int signal_code) {\n  __pid_t process_id;\n  int function_pointer;\n  code *function_code_pointer;\n  if (parameter_index > 31) {\n    *result = 22;\n    return -1;\n  }\n  function_pointer = result[17];\n  if (function_pointer != 0 && (function_code_pointer = *(code **)(function_pointer + parameter_index * 4), function_code_pointer != (code *)0x0)) {\n    if (function_code_pointer != (code *)0x1) {\n      if (function_code_pointer == (code *)-1) {\n        *result = 22;\n        return 1;\n      }\n      *(undefined4 *)(function_pointer + parameter_index * 4) = 0;\n      (*function_code_pointer)(parameter_index);\n    }\n    return 0;\n  }\n  process_id = _getpid_r();\n  int kill_result = _kill_r(result, process_id, parameter_index, signal_code);\n  return kill_result;\n}",
            "called": [
                "_getpid_r",
                "_kill_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006eb0",
            "calling": [
                "raise"
            ],
            "imported": false,
            "current_name": "execute_function_08006eb0"
        },
        "FUN_08004e5c": {
            "renaming": {
                "FUN_08004e5c": "handle_timer_interrupt_08004e5c",
                "PTR_timer_handles_08004e6c": "PTR_timer_handles_08004e6c",
                "TIM_HandleTypeDef": "TIM_HandleTypeDef",
                "HAL_TIM_IRQHandler": "HAL_TIM_IRQHandler"
            },
            "code": "void handle_timer_interrupt_08004e5c(void)\n{\n  TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef **)(PTR_timer_handles_08004e6c + 0xc);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e5c",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08004e5c"
        },
        "FUN_08004df4": {
            "renaming": {
                "FUN_08004df4": "get_stimer_from_timer_handle_08004df4",
                "htim": "timer_handle",
                "stimer_t": "stimer",
                "previous_timer_handle": "previous_timer_handle"
            },
            "code": "stimer_t* get_stimer_from_timer_handle_08004df4(TIM_HandleTypeDef* timer_handle)\n{\n  TIM_HandleTypeDef* previous_timer_handle = timer_handle - 1;\n  stimer_t* stimer = (stimer_t*)&previous_timer_handle->Lock;\n  return stimer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004df4",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "imported": false,
            "current_name": "get_stimer_from_timer_handle_08004df4"
        },
        "FUN_08004bb0": {
            "renaming": {
                "FUN_08004bb0": "initialize_gpio_pin_08004bb0",
                "pin": "pin_name",
                "mode": "pin_mode",
                "pull": "pin_pull",
                "GPIOx": "gpio_port",
                "uVar1": "port_index",
                "GPIO_InitStructure": "gpio_init_structure"
            },
            "code": "void initialize_gpio_pin_08004bb0(PinName_conflict pin, uint32_t mode, uint32_t pull)\n{\n  uint port_index = (uint)pin;\n  GPIO_TypeDef *GPIOx = set_GPIO_Port_Clock((port_index << 0x18) >> 0x1c);\n  GPIO_InitTypeDef GPIO_InitStructure;\n  GPIO_InitStructure.Pin = 1 << (port_index & 0xf) & 0xffff;\n  GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;\n  *(uint *)(DAT_08004c28 + 0x18) |= 1;\n  if ((port_index - 0xd & 0xff) < 2) {\n    *(uint *)(DAT_08004c2c + 4) &= 0xf8ffffff;\n    *(uint *)(DAT_08004c2c + 4) |= 0x4000000;\n  }\n  if (((port_index == 0xf) || (port_index == 0x13)) || (port_index == 0x14)) {\n    *(uint *)(DAT_08004c2c + 4) &= 0xf8ffffff;\n    *(uint *)(DAT_08004c2c + 4) |= 0x2000000;\n  }\n  GPIO_InitStructure.Mode = mode;\n  GPIO_InitStructure.Pull = pull;\n  HAL_GPIO_Init(GPIOx,&GPIO_InitStructure);\n  return;\n}",
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004bb0",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "initialize_gpio_pin_08004bb0"
        },
        "FUN_08004df8": {
            "renaming": {
                "FUN_08004df8": "handle_timer_interrupt_08004df8",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "irqHandleOC": "interrupt_handle_OC"
            },
            "code": "void handle_timer_interrupt_08004df8(TIM_HandleTypeDef *timer_handle) {\n  stimer_t *timer_obj;\n  timer_obj = get_timer_object(timer_handle);\n  if ((timer_obj->interrupt_handle_OC != (_func_void_stimer_t_ptr_uint32_t *)0x0) && (timer_handle->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timer_obj->interrupt_handle_OC)(timer_obj,0);\n  }\n  return;\n}",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004df8",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_08004df8"
        },
        "FUN_08001510": {
            "renaming": {
                "FUN_08001510::FUN_08001510": "create_printer",
                "this": "printer",
                "rs": "register_select",
                "enable": "enable_pin",
                "d0": "data_pin_0",
                "d1": "data_pin_1",
                "d2": "data_pin_2",
                "d3": "data_pin_3",
                "super_Print": "super_printer",
                "_vptr_Print": "virtual_pointer_Print",
                "init": "initialize",
                "FUN_08001510": "create_printer_08001510"
            },
            "code": "class Printer {\n  public:\n    uint8_t write_error;\n    _func_int_varargs **_vptr_Print;\n};\n\nPrinter * create_printer_08001510(Printer *printer, uint8_t rs, uint8_t enable, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3) {\n  Printer super_Print;\n  super_Print.write_error = 0;\n  super_Print._vptr_Print = (_func_int_varargs **)PTR_PTR_write_1_0800154c;\n  init(printer, '\\x01', rs, 0xff, enable, d0, d1, d2, d3, '\\0', '\\0', '\\0', '\\0');\n  return printer;\n}\n",
            "called": [
                "init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001510",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "create_printer_08001510"
        },
        "FUN_08002af8": {
            "renaming": {
                "FUN_08002af8": "i2c_handle_listen_08002af8",
                "hi2c": "handle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transfer_options",
                "HVar1": "status",
                "pIVar2": "instance",
                "tmpreg": "N/A"
            },
            "code": "HAL_StatusTypeDef_conflict i2c_handle_listen_08002af8(I2C_HandleTypeDef *handle, uint8_t *data, uint16_t size, uint32_t transfer_options) {\n    HAL_StatusTypeDef_conflict status = HAL_BUSY;\n    I2C_TypeDef *instance;\n\n    if (handle->State == HAL_I2C_STATE_LISTEN) {\n        if (data == NULL || size == 0 || handle->Lock == HAL_LOCKED) {\n            status = HAL_ERROR;\n        } else {\n            handle->Lock = HAL_LOCKED;\n            instance = handle->Instance;\n            if ((instance->CR1 & 1) == 0) {\n                instance->CR1 |= 1;\n            }\n            instance->CR1 &= 0xfffff7ff;\n            handle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n            handle->Mode = HAL_I2C_MODE_SLAVE;\n            status = HAL_OK;\n            handle->ErrorCode = 0;\n            handle->pBuffPtr = data;\n            handle->XferCount = size;\n            handle->XferOptions = transfer_options;\n            handle->XferSize = handle->XferCount;\n            handle->Lock = HAL_UNLOCKED;\n            instance->CR2 |= 0x700;\n        }\n    }\n    return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002af8",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "i2c_handle_listen_08002af8"
        },
        "FUN_080028de": {
            "renaming": {
                "FUN_080028de": "handle_i2c_events_080028de",
                "*hi2c": "*i2c_handle",
                "uVar1": "transfer_options",
                "pIVar2": "i2c_instance",
                "tmpreg": "cr1_value",
                "tmpreg_1": "cr2_value",
                "tmpreg_2": "transfer_count",
                "tmpreg_3": "addressing_mode",
                "tmpreg_4": "previous_state",
                "tmpreg_5": "event_count"
            },
            "code": "HAL_StatusTypeDef_conflict handle_i2c_events_080028de(I2C_HandleTypeDef *i2c_handle) {\n    uint32_t transfer_options = i2c_handle->XferOptions;\n    I2C_TypeDef *i2c_instance = i2c_handle->Instance;\n    uint32_t transfer_count = i2c_handle->XferCount;\n    uint32_t addressing_mode = (i2c_handle->Init).AddressingMode;\n    uint32_t previous_state = i2c_handle->PreviousState;\n    uint32_t event_count = i2c_handle->EventCount;\n    uint32_t cr1_value = i2c_instance->CR1;\n    uint32_t cr2_value = i2c_instance->CR2;\n\n    if (i2c_handle->State == HAL_I2C_STATE_BUSY_RX && (event_count != 0 || i2c_handle->Mode != HAL_I2C_MODE_MEM)) {\n        if (event_count == 0 && addressing_mode == 0xc000) {\n            cr1_value |= 0x100;\n            event_count++;\n        }\n        else {\n            if (transfer_count == 0) {\n                cr1_value |= 0x200;\n            }\n            else if (transfer_count == 1) {\n                if (transfer_options == 0xffff0000) {\n                    cr1_value &= 0xfffffbff;\n                    if ((cr2_value & 0x800) == 0) {\n                        cr1_value |= 0x200;\n                    }\n                    else {\n                        cr1_value &= 0xfffffbff;\n                    }\n                }\n                else if (transfer_options == 4 || transfer_options == 8 || previous_state == 0x12) {\n                    cr1_value &= 0xfffffbff;\n                    cr1_value |= 0x200;\n                }\n                else if (transfer_options == 2) {\n                    cr1_value |= 0x400;\n                }\n                else {\n                    cr1_value &= 0xfffffbff;\n                }\n            }\n            else if (transfer_count == 2) {\n                if (transfer_options == 2) {\n                    cr1_value |= 0x400;\n                }\n                else {\n                    cr1_value |= 0x800;\n                    cr1_value &= 0xfffffbff;\n                }\n                if ((cr2_value & 0x800) != 0) {\n                    cr2_value |= 0x1000;\n                }\n            }\n            else {\n                cr1_value |= 0x400;\n                if ((cr2_value & 0x800) != 0) {\n                    cr2_value |= 0x1000;\n                }\n            }\n            event_count = 0;\n        }\n    }\n    i2c_instance->CR1 = cr1_value;\n    i2c_instance->CR2 = cr2_value;\n    i2c_handle->EventCount = event_count;\n    return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080028de",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_events_080028de"
        },
        "FUN_08002848": {
            "renaming": {
                "FUN_08002848": "i2c_handle_mem_mode_08002848",
                "*hi2c": "*i2c_handle",
                "hi2c->Mode": "i2c_handle->Mode",
                "hi2c->EventCount": "i2c_handle->EventCount",
                "hi2c->Instance": "i2c_handle->Instance",
                "(hi2c->Init).AddressingMode": "i2c_handle->Init.AddressingMode",
                "hi2c->State": "i2c_handle->State",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "hi2c->Devaddress": "i2c_handle->Devaddress",
                "hi2c->Instance->DR": "i2c_handle->Instance->DR",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_StateTypeDef",
                "HAL_I2C_MODE_MEM": "uint8_t"
            },
            "code": "HAL_StatusTypeDef i2c_handle_mem_mode_08002848(I2C_HandleTypeDef *i2c_handle) {\n    uint8_t dev_address = i2c_handle->Devaddress;\n    uint8_t mem_mode_event_count = i2c_handle->EventCount;\n    I2C_TypeDef *i2c_instance = i2c_handle->Instance;\n    uint16_t addressing_mode = i2c_handle->Init.AddressingMode;\n    HAL_I2C_StateTypeDef i2c_state = i2c_handle->State;\n    if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n        if (mem_mode_event_count == 0) {\n            i2c_instance->DR = dev_address & 0xFE;\n        }\n        else {\n            i2c_instance->DR = dev_address & 0xFF | 1;\n        }\n    }\n    else if (addressing_mode == 0x4000) {\n        if (i2c_state == HAL_I2C_STATE_BUSY_TX) {\n            i2c_instance->DR = dev_address & 0xFE;\n        }\n        else {\n            i2c_instance->DR = dev_address & 0xFF | 1;\n        }\n    }\n    else if (mem_mode_event_count == 0) {\n        i2c_instance->DR = (dev_address << 16) >> 23 & 6 | 0xF0;\n    }\n    else if (mem_mode_event_count == 1) {\n        i2c_instance->DR = (dev_address << 16) >> 23 & 6 | 0xF1;\n    }\n    return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002848",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_mem_mode_08002848"
        },
        "FUN_08004e70": {
            "renaming": {
                "FUN_08004e70": "get_i2c_t_ptr_08004e70",
                "hi2c": "i2c_handle",
                "i2c_t": "i2c_struct",
                "EventCount": "event_count_offset"
            },
            "code": "i2c_t * get_i2c_t_ptr_08004e70(I2C_HandleTypeDef * i2c_handle)\n{\n    int event_count_offset = -1 * sizeof(uint32_t);\n    return (i2c_t *)&i2c_handle[event_count_offset];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e70",
            "calling": [
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "imported": false,
            "current_name": "get_i2c_t_ptr_08004e70"
        },
        "FUN_080020f0": {
            "renaming": {
                "FUN_080020f0": "check_adc_conversion_complete_080020f0",
                "*hadc": "*adc_handle",
                "uVar1": "start_time",
                "uVar2": "current_time",
                "*pAVar3": "*adc_instance",
                "pAVar3": "adc_instance"
            },
            "code": "HAL_StatusTypeDef check_adc_conversion_complete_080020f0(ADC_HandleTypeDef *adc_handle)\n{\n  uint32_t start_time = HAL_GetTick();\n  uint32_t current_time;\n  ADC_TypeDef *adc_instance = adc_handle->Instance;\n  if ((adc_instance->CR2 & 1) == 0) {\n    return HAL_OK;\n  }\n  adc_instance->CR2 &= 0xfffffffe;\n  do {\n    if ((adc_handle->Instance->CR2 & 1) == 0) {\n      return HAL_OK;\n    }\n    current_time = HAL_GetTick();\n  } while (current_time - start_time < 3);\n  adc_handle->State |= 0x10;\n  adc_handle->ErrorCode |= 1;\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080020f0",
            "calling": [
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_DeInit",
                "HAL_ADC_Stop"
            ],
            "imported": false,
            "current_name": "check_adc_conversion_complete_080020f0"
        },
        "FUN_08006e10": {
            "renaming": {
                "FUN_08006e10": "initialize_file_descriptor_08006e10",
                "param_1": "fd",
                "param_2": "file_descriptor_info",
                "uVar1": "flags",
                "iVar2": "size",
                "local_18": "fd_copy",
                "local_14": "fd_info_copy",
                "DAT_08006e8c": "default_value",
                "PTR_malloc_r": "_malloc_r",
                "_isatty_r": "_is_terminal_r"
            },
            "code": "void initialize_file_descriptor_08006e10(int fd, int *file_descriptor_info)\n{\n    ushort flags;\n    int size;\n    int *local_fd_info;\n\n    if (-1 < (int)((uint)*(ushort *)(file_descriptor_info + 3) << 0x1e)) {\n        local_fd_info = file_descriptor_info;\n        flags = __swhatbuf_r(fd, file_descriptor_info, &size, &local_fd_info);\n        int *memory_ptr = PTR_malloc_r(fd, size);\n        if (memory_ptr != 0) {\n            *(undefined4 *)(fd + 0x28) = DAT_08006e8c;\n            *file_descriptor_info = memory_ptr;\n            *(ushort *)(file_descriptor_info + 3) = *(ushort *)(file_descriptor_info + 3) | 0x80;\n            file_descriptor_info[4] = memory_ptr;\n            file_descriptor_info[5] = size;\n            if ((local_fd_info != (int *)0x0) && (_isatty_r(fd,(int)*(short *)((int)file_descriptor_info + 0xe)) != 0)) {\n                *(ushort *)(file_descriptor_info + 3) = *(ushort *)(file_descriptor_info + 3) & 0xfffc | 1;\n            }\n            *(ushort *)(file_descriptor_info + 3) = flags | *(ushort *)(file_descriptor_info + 3);\n            return;\n        }\n        if ((int)(short)*(ushort *)(file_descriptor_info + 3) << 0x16 < 0) {\n            return;\n        }\n        *(ushort *)(file_descriptor_info + 3) = *(ushort *)(file_descriptor_info + 3) & 0xfffc | 2;\n    }\n    *file_descriptor_info = (int)file_descriptor_info + 0x47;\n    file_descriptor_info[4] = (int)file_descriptor_info + 0x47;\n    file_descriptor_info[5] = 1;\n    return;\n}",
            "called": [
                "_malloc_r",
                "_isatty_r",
                "__swhatbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e10",
            "calling": [
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "initialize_file_descriptor_08006e10"
        },
        "FUN_0800607e": {
            "renaming": {
                "FUN_0800607e": "handle_GPIO_interrupt_0800607e",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void handle_GPIO_interrupt_0800607e(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800607e",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_interrupt_0800607e"
        },
        "FUN_08004e74": {
            "renaming": {
                "FUN_08004e74": "i2c_transfer_08004e74",
                "hi2c": "i2c_handler",
                "TransferDirection": "transfer_direction",
                "AddrMatchCode": "address_match_code",
                "piVar1": "i2c_obj",
                "get_i2c_obj": "get_i2c_object",
                "i2c_t": "i2c_type",
                "i2cTxRxBufferSize": "buffer_size",
                "slaveMode": "slave_mode",
                "i2c_onSlaveTransmit": "on_slave_transmit",
                "i2cTxRxBuffer": "buffer",
                "HAL_I2C_Slave_Sequential_Transmit_IT": "i2c_slave_transmit",
                "HAL_I2C_Slave_Sequential_Receive_IT": "i2c_slave_receive"
            },
            "code": "void i2c_transfer_08004e74(I2C_HandleTypeDef *hi2c, uint8_t transfer_direction, uint16_t address_match_code) {\\n  i2c_t *i2c_obj = get_i2c_obj(hi2c);\\n  if ((uint)address_match_code == (hi2c->Init).OwnAddress1) {\\n    if (transfer_direction == \"\\0\") {\\n      i2c_obj->i2cTxRxBufferSize = \"\\0\";\\n      i2c_obj->slaveMode = \"\\0\";\\n      if (i2c_obj->i2c_onSlaveTransmit != (_func_void *)0x0) {\\n        (*i2c_obj->i2c_onSlaveTransmit)();\\n      }\\n      HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_obj->i2cTxRxBuffer, (ushort)i2c_obj->i2cTxRxBufferSize, 8);\\n      return;\\n    }\\n    i2c_obj->slaveMode = \"\\x01\";\\n    HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_obj->i2cTxRxBuffer, 0x20, 8);\\n  }\\n  return;\\n}",
            "called": [
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e74",
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08004e74"
        },
        "FUN_08004c30": {
            "renaming": {
                "FUN_08004c30": "set_gpio_pin_state_08004c30",
                "port": "gpio_port",
                "pin": "gpio_pin_number",
                "val": "gpio_pin_state",
                "GPIO_TypeDef": "gpio_port_type",
                "GPIO_PIN_RESET": "gpio_pin_reset_state",
                "GPIO_PIN_SET": "gpio_pin_set_state"
            },
            "code": "void set_gpio_pin_state_08004c30(GPIO_TypeDef *gpio_port, uint32_t gpio_pin_number, uint32_t gpio_pin_state) {\n  if (gpio_pin_state == 0) {\n    HAL_GPIO_WritePin(gpio_port, (uint16_t)gpio_pin_number, GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpio_port, (uint16_t)gpio_pin_number, GPIO_PIN_SET);\n  return;\n}",
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c30",
            "calling": [
                "digitalWrite"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_08004c30"
        },
        "FUN_08006092": {
            "renaming": {
                "FUN_08006092": "handle_gpio_exti_interrupt_08006092"
            },
            "code": "void handle_gpio_exti_interrupt_08006092(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(8);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006092",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_interrupt_08006092"
        },
        "FUN_08006f38": {
            "renaming": {
                "FUN_08006f38": "read_and_update_data_from_file_08006f38",
                "param_1": "file_descriptor",
                "param_2": "data_struct_address",
                "iVar1": "bytes_read",
                "uVar2": "new_data_offset",
                "bVar3": "is_bytes_read_positive"
            },
            "code": "void read_and_update_data_from_file_08006f38(int file_descriptor, int data_struct_address) {\n  int bytes_read = _read_r(file_descriptor, (int)*(short *)(data_struct_address + 0xe));\n  bool is_bytes_read_positive = bytes_read >= 0;\n  if (is_bytes_read_positive) {\n    uint new_data_offset = *(int *)(data_struct_address + 0x54) + bytes_read;\n    *(uint *)(data_struct_address + 0x54) = new_data_offset;\n  }\n  else {\n    uint error_flag = *(ushort *)(data_struct_address + 0xc) & 0xffffefff;\n    *(short *)(data_struct_address + 0xc) = (short)error_flag;\n  }\n}",
            "called": [
                "_read_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006f38",
            "calling": [],
            "imported": false,
            "current_name": "read_and_update_data_from_file_08006f38"
        },
        "FUN_08004cce": {
            "renaming": {
                "FUN_08004cce": "find_pin_function_08004cce",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "function_index"
            },
            "code": "uint32_t find_pin_function_08004cce(PinName_conflict pin, PinMap_conflict *pin_map) {\n  uint32_t function_index;\n  if (pin == NC) {\n    return 0xffffffff;\n  }\n  function_index = pinmap_find_function(pin, pin_map);\n  return function_index;\n}",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004cce",
            "calling": [
                "pwm_stop",
                "get_adc_channel",
                "get_pwm_channel",
                "uart_init"
            ],
            "imported": false,
            "current_name": "find_pin_function_08004cce"
        },
        "FUN_08006eac": {
            "renaming": {
                "FUN_08006eac": "do_nothing_08006eac"
            },
            "code": "\nvoid do_nothing_08006eac(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006eac",
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "imported": false,
            "current_name": "do_nothing_08006eac"
        },
        "FUN_08006f34": {
            "renaming": {
                "FUN_08006f34": "get_process_id_08006f34"
            },
            "code": "__pid_t get_process_id_08006f34(void)\n{\n  return 1;\n}",
            "called": [
                "_getpid"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006f34",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "get_process_id_08006f34"
        },
        "FUN_08006eae": {
            "renaming": {
                "FUN_08006eae": "do_nothing_08006eae"
            },
            "code": "\nvoid do_nothing_08006eae(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006eae",
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "imported": false,
            "current_name": "do_nothing_08006eae"
        },
        "FUN_08005f5c": {
            "renaming": {
                "FUN_08005f5c": "do_nothing_08005f5c"
            },
            "code": "\nvoid do_nothing_08005f5c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005f5c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "do_nothing_08005f5c"
        },
        "FUN_08006fe4": {
            "renaming": {
                "FUN_08006fe4": "close_file_08006fe4",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "puVar1": "error_ptr",
                "iVar2": "result"
            },
            "code": "void close_file_08006fe4(int *error_code, int file_descriptor) {\n  undefined *error_ptr;\n  int result;\n  error_ptr = PTR_errno_08007000;\n  *(undefined4 *)PTR_errno_08007000 = 0;\n  result = _close(file_descriptor);\n  if ((result == -1) && (*(int *)error_ptr != 0)) {\n    *error_code = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006fe4",
            "calling": [
                "__sclose"
            ],
            "imported": false,
            "current_name": "close_file_08006fe4"
        },
        "FUN_08003ad4": {
            "renaming": {
                "FUN_08003ad4": "configureClock_08003ad4",
                "RCC_ClkInitStruct_conflict": "clockInit",
                "FLatency": "flashLatency",
                "DAT_08003c34": "FLASH_ACR",
                "puVar1": "",
                "uVar2": "",
                "uVar3": "",
                "uVar4": "",
                "RCC_ClkInitStruct": "clockInit",
                "ClockType": "ClockType",
                "AHBCLKDivider": "AHBCLKDivider",
                "SYSCLKSource": "SYSCLKSource",
                "DAT_08003c38": "",
                "APB1CLKDivider": "APB1CLKDivider",
                "APB2CLKDivider": "APB2CLKDivider",
                "PTR_SystemCoreClock_08003c40": "",
                "PTR_AHBPrescTable_08003c3c": ""
            },
            "code": "HAL_StatusTypeDef configureClock_08003ad4(RCC_ClkInitTypeDef *clockInit, uint32_t flashLatency) {\n\tuint32_t *DAT_08003c34 = DAT_08003c34;\n\tuint32_t tickStart;\n\tuint32_t sysclkSource;\n\tuint32_t sysclkReadyFlag;\n\t\n\tif (((*DAT_08003c34 & 7) < flashLatency) && (*DAT_08003c34 = *DAT_08003c34 & 0xfffffff8 | flashLatency, flashLatency != (*DAT_08003c34 & 7))) {\n\t\treturn HAL_ERROR;\n\t}\n\tif ((clockInit->ClockType & RCC_CLOCKTYPE_HCLK) != 0) {\n\t\tRCC->CFGR &= ~(RCC_CFGR_HPRE);\n\t\tRCC->CFGR |= clockInit->AHBCLKDivider;\n\t}\n\tif ((clockInit->ClockType & RCC_CLOCKTYPE_SYSCLK) != 0) {\n\t\tsysclkSource = clockInit->SYSCLKSource;\n\t\tif (sysclkSource == RCC_SYSCLKSOURCE_PLLCLK) {\n\t\t\tsysclkReadyFlag = RCC_FLAG_PLLRDY;\n\t\t} else if (sysclkSource == RCC_SYSCLKSOURCE_HSE) {\n\t\t\tsysclkReadyFlag = RCC_FLAG_HSERDY;\n\t\t} else {\n\t\t\tsysclkReadyFlag = RCC_FLAG_HSIREADY;\n\t\t}\n\t\tRCC->CFGR &= ~(RCC_CFGR_SW);\n\t\tRCC->CFGR |= (uint32_t)sysclkSource;\n\t\ttickStart = HAL_GetTick();\n\t\twhile ((RCC->CFGR & RCC_CFGR_SWS) != sysclkReadyFlag) {\n\t\t\tif ((HAL_GetTick() - tickStart) > 5000) {\n\t\t\t\treturn HAL_TIMEOUT;\n\t\t\t}\n\t\t}\n\t}\n\tif ((flashLatency < (*DAT_08003c34 & 7)) && (*DAT_08003c34 = *DAT_08003c34 & 0xfffffff8 | flashLatency, flashLatency != (*DAT_08003c34 & 7))) {\n\t\treturn HAL_ERROR;\n\t}\n\tif ((clockInit->ClockType & RCC_CLOCKTYPE_PCLK1) != 0) {\n\t\tRCC->CFGR &= ~(RCC_CFGR_PPRE1);\n\t\tRCC->CFGR |= (clockInit->APB1CLKDivider << 10);\n\t}\n\tif ((clockInit->ClockType & RCC_CLOCKTYPE_PCLK2) != 0) {\n\t\tRCC->CFGR &= ~(RCC_CFGR_PPRE2);\n\t\tRCC->CFGR |= (clockInit->APB2CLKDivider << 13);\n\t}\n\tSystemCoreClockUpdate();\n\treturn HAL_OK;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ad4",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configureClock_08003ad4"
        },
        "FUN_08004110": {
            "renaming": {
                "FUN_08004110": "update_channel_state_08004110",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "new_channel_state"
            },
            "code": "void update_channel_state_08004110(TIM_TypeDef *timer, uint32_t channel, uint32_t new_channel_state) {\n  uint32_t channel_bit_position = channel & 0xff;\n  uint32_t channel_state_mask = ~(4 << channel_bit_position);\n  timer->CCER &= channel_state_mask;\n  timer->CCER |= new_channel_state << channel_bit_position;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004110",
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "imported": false,
            "current_name": "update_channel_state_08004110"
        },
        "FUN_08004ce2": {
            "renaming": {
                "FUN_08004ce2": "check_pin_is_not_NC_08004ce2",
                "pin": "pin_name",
                "map": "pin_map",
                "PinMap_conflict": "Pin_map",
                "PinName_conflict": "Pin_name",
                "NC": "Not_connected",
                "return false;": "return false;",
                "return true;": "return true;",
                "if (pin == NC)": "if (pin == Not_connected)",
                "if (map->pin == NC)": "if (pin_map->pin == Not_connected)",
                "if (pin == map->pin) break;": "if (pin_name == pin_map->pin) {\n      break;\n    }",
                "map = map + 1;": "pin_map++;"
            },
            "code": "_Bool check_pin_is_not_NC_08004ce2(PinName_conflict pin, PinMap_conflict *pin_map) {\n  if (pin == NC) {\n    return false;\n  }\n  while (true) {\n    if (pin_map->pin == NC) {\n      return false;\n    }\n    if (pin == pin_map->pin) {\n      break;\n    }\n    pin_map++;\n  }\n  return true;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ce2",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "check_pin_is_not_NC_08004ce2"
        },
        "FUN_08005568": {
            "renaming": {
                "FUN_08005568": "transmit_serial_data_08005568",
                "obj": "serial_object",
                "callback": "callback_function",
                "bVar1": "serial_index",
                "PTR_tx_callback_080055b0": "tx_callback_ptr",
                "PTR_tx_callback_obj_080055b4": "tx_callback_obj_ptr",
                "PTR_uart_handlers_080055b8": "uart_handler_ptr"
            },
            "code": "void transmit_serial_data_08005568(serial_t *serial_object, _func_int_serial_t_ptr *callback_function){\n    if (serial_object != NULL) {\n        uint8_t serial_index = serial_object->index;\n        _func_int_serial_t_ptr **PTR_tx_callback_080055b0 = (PTR_tx_callback_080055b0 + (serial_index * 4));\n        *PTR_tx_callback_080055b0 = callback_function;\n        serial_t **PTR_tx_callback_obj_080055b4 = (PTR_tx_callback_obj_080055b4 + (serial_index * 4));\n        *PTR_tx_callback_obj_080055b4 = serial_object;\n        HAL_NVIC_SetPriority(serial_object->irq, 0, 2);\n        HAL_NVIC_EnableIRQ(serial_object->irq);\n        UART_HandleTypeDef **PTR_uart_handlers_080055b8 = (PTR_uart_handlers_080055b8 + (serial_object->index * 4));\n        HAL_UART_Transmit_IT(*PTR_uart_handlers_080055b8, (serial_object->tx_buff + serial_object->tx_tail), 1);\n    }\n}",
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005568",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "transmit_serial_data_08005568"
        },
        "FUN_08004478": {
            "renaming": {
                "FUN_08004478": "UART_Transmit_08004478",
                "huart": "handle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "start_time"
            },
            "code": "HAL_StatusTypeDef UART_Transmit_08004478(UART_HandleTypeDef *huart, uint8_t *data, uint16_t size, uint32_t timeout)\n{\n  HAL_StatusTypeDef status;\n  uint32_t start_time;\n  if (huart->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == NULL || size == 0 || huart->Lock == HAL_LOCKED) {\n    return HAL_ERROR;\n  }\n  huart->Lock = HAL_LOCKED;\n  huart->ErrorCode = 0;\n  huart->gState = HAL_UART_STATE_BUSY_TX;\n  start_time = HAL_GetTick();\n  huart->TxXferSize = size;\n  huart->TxXferCount = size;\n  while (huart->TxXferCount > 0) {\n    huart->TxXferCount--;\n    if (huart->Init.WordLength == UART_WORDLENGTH_9B) {\n      status = UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, start_time, timeout);\n      if (status != HAL_OK) {\n        return HAL_TIMEOUT;\n      }\n      huart->Instance->DR = *(uint16_t *)data & 0x1FF;\n      data += (huart->Init.Parity == UART_PARITY_NONE) ? 2 : 1;\n    }\n    else {\n      status = UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, start_time, timeout);\n      if (status != HAL_OK) {\n        return HAL_TIMEOUT;\n      }\n      huart->Instance->DR = *data++;\n    }\n  }\n  status = UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, start_time, timeout);\n  huart->gState = HAL_UART_STATE_READY;\n  huart->Lock = HAL_UNLOCKED;\n  return (status == HAL_OK) ? HAL_OK : HAL_TIMEOUT;\n}",
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004478",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "UART_Transmit_08004478"
        },
        "FUN_08005f5e": {
            "renaming": {
                "FUN_08005f5e": "initialize_EVP_PKEY_context_08005f5e",
                "ctx": "context"
            },
            "code": "void initialize_EVP_PKEY_context_08005f5e(void)\n{\n  EVP_PKEY_CTX *context;\n  context = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(context);\n  return;\n}",
            "called": [
                "init",
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005f5e",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_context_08005f5e"
        },
        "FUN_08005cb6": {
            "renaming": {
                "__thiscall Print::FUN_08005cb6": "print_character",
                "this": "print_obj",
                "c": "character",
                "sVar1": "size",
                "FUN_08005cb6": "print_character_08005cb6"
            },
            "code": "size_t print_character_08005cb6(Print *print_obj, char character) {\n  size_t size;\n  size = (**print_obj->_vptr_Print)(print_obj, (int)character);\n  return size;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cb6",
            "calling": [
                "printTo",
                "print",
                "printFloat"
            ],
            "imported": false,
            "current_name": "print_character_08005cb6"
        },
        "FUN_08003c70": {
            "renaming": {
                "FUN_08003c70": "get_HCLK_frequency_08003c70",
                "uVar1": "frequency",
                "DAT_08003c88": "data_address",
                "PTR_APBPrescTable_08003c8c": "prescaler_table",
                "prescaler_index": "index",
                "prescaler_value": "value"
            },
            "code": "uint32_t get_HCLK_frequency_08003c70(void)\n{\n  uint32_t frequency = HAL_RCC_GetHCLKFreq();\n  uint32_t prescaler_index = (uint)(*(int *)(DAT_08003c88 + 4) << 0x12) >> 0x1d;\n  uint32_t prescaler_value = PTR_APBPrescTable_08003c8c[prescaler_index];\n  return frequency >> prescaler_value;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003c70",
            "calling": [
                "UART_SetConfig",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "imported": false,
            "current_name": "get_HCLK_frequency_08003c70"
        },
        "FUN_080053d4": {
            "renaming": {
                "FUN_080053d4": "send_data_over_uart_080053d4",
                "*data": "data",
                "size": "size",
                "PinName_conflict": "PinName",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "uVar2": "start_time",
                "PTR_digitalPin_0800547c": "digitalPinToPinName",
                "pvVar3": "peripheral",
                "PinMap_conflict": "PinMap_UART_TX",
                "uVar5": "handler_index",
                "PTR_uart_handlers_08005484": "uart_handlers",
                "PTR_serial_debug_08005488": "serial_debug",
                "HVar1": "status",
                "uVar4": "current_time"
            },
            "code": "size_t send_data_over_uart_080053d4(uint8_t *data, uint32_t size)\n{\n  PinName pin_name;\n  HAL_StatusTypeDef status;\n  uint32_t start_time = HAL_GetTick();\n  pin_name = PTR_digitalPin_0800547c(PIN_SERIAL_TX);\n  void *peripheral = pinmap_peripheral(pin_name, &PinMap_UART_TX);\n  if (peripheral == NULL) {\n    return 0;\n  }\n  uint handler_index = 0;\n  while ((handler_index < 5 && ((*(int *)(PTR_uart_handlers_08005484 + handler_index * 4) == 0 || (peripheral = pinmap_peripheral(pin_name, &PinMap_UART_TX), **(void ***)(PTR_uart_handlers_08005484 + handler_index * 4) != peripheral))))) {\n    handler_index++;\n  }\n  if (handler_index > 4) {\n    if ((PTR_PTR_serial_debug_08005488_08005488[0x44] > 4) && (uart_debug_init(), PTR_PTR_serial_debug_08005488_08005488[0x44] > 4)) {\n      return 0;\n    }\n    handler_index = PTR_PTR_serial_debug_08005488_08005488[0x44];\n  }\n  do {\n    status = HAL_UART_Transmit(*(UART_HandleTypeDef **)(PTR_uart_handlers_08005484 + handler_index * 4), data, (uint16_t)size, 1000);\n    if (status == HAL_OK) {\n      return size;\n    }\n  } while (HAL_GetTick() - start_time < 1000);\n  return 0;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_UART_Transmit",
                "pinmap_peripheral",
                "uart_debug_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053d4",
            "calling": [
                "_write"
            ],
            "imported": false,
            "current_name": "send_data_over_uart_080053d4"
        },
        "FUN_08002b84": {
            "renaming": {
                "FUN_08002b84": "listen_mode_handler_08002b84",
                "hi2c": "i2c_handle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transfer_options",
                "HVar1": "status",
                "pIVar2": "i2c_instance",
                "tmpreg": "tmpreg"
            },
            "code": "HAL_StatusTypeDef_conflict listen_mode_handler_08002b84(I2C_HandleTypeDef *i2c_handle, uint8_t *data, uint16_t size, uint32_t transfer_options)\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef *i2c_instance;\n  uint32_t tmpreg;\n  \n  if (i2c_handle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == NULL) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2c_handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2c_handle->Lock = HAL_LOCKED;\n      i2c_instance = i2c_handle->Instance;\n      if ((i2c_instance->CR1 & 1) == 0) {\n        i2c_instance->CR1 = i2c_instance->CR1 | 1;\n      }\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffff7ff;\n      i2c_handle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2c_handle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2c_handle->ErrorCode = 0;\n      i2c_handle->pBuffPtr = data;\n      i2c_handle->XferCount = size;\n      i2c_handle->XferOptions = transfer_options;\n      i2c_handle->XferSize = i2c_handle->XferCount;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002b84",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "listen_mode_handler_08002b84"
        },
        "FUN_08004c48": {
            "renaming": {
                "FUN_08004c48": "read_gpio_pin_state_08004c48",
                "port": "gpio_port",
                "pin": "pin_number",
                "GVar1": "pin_state"
            },
            "code": "uint32_t read_gpio_pin_state_08004c48(GPIO_TypeDef *gpio_port, uint32_t pin_number)\n{\n  GPIO_PinState pin_state;\n  pin_state = HAL_GPIO_ReadPin(gpio_port, (uint16_t)pin_number);\n  return (uint32_t)pin_state;\n}",
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c48",
            "calling": [
                "digitalRead"
            ],
            "imported": false,
            "current_name": "read_gpio_pin_state_08004c48"
        },
        "FUN_0800042c": {
            "renaming": {
                "FUN_0800042c": "get_concatenated_value_0800042c",
                "param_1": "input",
                "uVar1": "first_half_upper",
                "uVar2": "abs_input",
                "uVar3": "shift_amount",
                "iVar4": "leading_zero_count",
                "uVar5": "shift_amount_complement",
                "uVar6": "sign_bit",
                "in_r12": "shift_amount_inverse",
                "bVar7": "shift_amount_adjusted_negative",
                "bVar8": "shift_amount_adjusted_zero",
                "bVar9": "shift_amount_adjusted_positive"
            },
            "code": "unsigned long long get_concatenated_value_0800042c(uint32_t input)\n{\n  uint32_t abs_input = input;\n  uint32_t sign_bit = input & 0x80000000;\n  if (abs_input == 0)\n    return 0;\n  if ((int)sign_bit < 0)\n    abs_input = -input;\n  uint32_t leading_zero_count = count_leading_zeroes(abs_input);\n  uint32_t shift_amount = leading_zero_count + 21;\n  if (shift_amount < 32)\n  {\n    shift_amount = 12 - leading_zero_count;\n    if (shift_amount > 0)\n      return ((unsigned long long)abs_input << shift_amount) | ((unsigned long long)sign_bit);\n  }\n  uint32_t shift_amount_complement = 32 - shift_amount;\n  uint32_t first_half = ((unsigned long long)abs_input << shift_amount) | ((unsigned long long)0U >> shift_amount_complement);\n  uint32_t second_half = 0U << shift_amount;\n  if (shift_amount < 1043)\n    return ((unsigned long long)first_half) + ((unsigned long long)(1042 - shift_amount) << 20) | ((unsigned long long)sign_bit);\n  uint32_t shift_amount_inverse = ~(1042 - shift_amount);\n  if (shift_amount_inverse > 30)\n    return ((unsigned long long)input) & 0x80000000ffffffff;\n  uint32_t shift_amount_adjusted = shift_amount_inverse - 19;\n  if (shift_amount_adjusted == 0 || (shift_amount_inverse - 31 < 0) != (shift_amount_adjusted < 0))\n  {\n    shift_amount_inverse++;\n    return ((unsigned long long)sign_bit | ((unsigned long long)abs_input >> shift_amount_inverse)) + ((unsigned long long)first_half << (32 - shift_amount_inverse));\n  }\n  return ((unsigned long long)input) & 0x80000000ffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800042c",
            "calling": [
                "SetSampleTime",
                "printFloat",
                "loop"
            ],
            "imported": false,
            "current_name": "get_concatenated_value_0800042c"
        },
        "FUN_08005f6c": {
            "renaming": {
                "FUN_08005f6c": "main_loop_08005f6c",
                "initVariant": "initialize_variant",
                "setup": "setup_board",
                "loop": "execute_loop",
                "DAT_08005f88": "data",
                "serialEventRun": "run_serial_event"
            },
            "code": "int main_loop_08005f6c(void)\n{\n  initialize_variant();\n  setup_board();\n  do {\n    do {\n      execute_loop();\n    } while (DAT_08005f88 == 0);\n    run_serial_event();\n  } while( true );\n}",
            "called": [
                "setup",
                "serialEventRun",
                "initVariant",
                "loop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005f6c",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "main_loop_08005f6c"
        },
        "FUN_08005690": {
            "renaming": {
                "FUN_08005690": "handle_USART1_interrupt_08005690",
                "PTR_uart_handlers_080056a4": "PTR_uart_handlers",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "HAL_UART_IRQHandler": "handle_UART_IRQ",
                "UART_HandleTypeDef": "UART_handler"
            },
            "code": "void handle_USART1_interrupt_08005690(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART1_IRQn);\n  UART_HandleTypeDef* uart_handler = *(UART_HandleTypeDef**)PTR_uart_handlers_080056a4_080056a4;\n  HAL_UART_IRQHandler(uart_handler);\n  return;\n}",
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005690",
            "calling": [],
            "imported": false,
            "current_name": "handle_USART1_interrupt_08005690"
        },
        "FUN_08005cc0": {
            "renaming": {
                "__thiscall Print::FUN_08005cc0": "printMessage",
                "sVar1": "messageLength",
                "FUN_08005cc0": "printMessage_08005cc0"
            },
            "code": "size_t Print::printMessage_08005cc0(Print *this)\n{\n  size_t messageLength;\n  messageLength = (*this->_vptr_Print[1])(this,PTR_DAT_08005cd0,2);\n  return messageLength;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cc0",
            "calling": [
                "println",
                "println"
            ],
            "imported": false,
            "current_name": "printMessage_08005cc0"
        },
        "FUN_0800706c": {
            "renaming": {
                "FUN_0800706c": "read_file_0800706c",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "puVar1": "error_ptr",
                "iVar2": "read_result"
            },
            "code": "void read_file_0800706c(int *error_code, int file_descriptor, char *buffer, int buffer_size) {\n  int read_result;\n  int *error_ptr = PTR_errno_0800708c;\n  *error_ptr = 0;\n  read_result = _read(file_descriptor, buffer, buffer_size);\n  if ((read_result == -1) && (*(int *)error_ptr != 0)) {\n    *error_code = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800706c",
            "calling": [
                "__sread"
            ],
            "imported": false,
            "current_name": "read_file_0800706c"
        },
        "FUN_08002624": {
            "renaming": {
                "FUN_08002624": "configure_GPIO_08002624",
                "GPIOx": "GPIO_port",
                "GPIO_Init": "config",
                "uVar2": "temp1",
                "uVar3": "pin_mask",
                "uVar4": "pin_config",
                "uVar5": "i",
                "uVar6": "mode_bits",
                "uVar7": "speed_bits",
                "iVar8": "bit_offset",
                "uVar9": "temp2",
                "iVar10": "port_index",
                "tmpreg": "temp3",
                "pGVar1": "port_config_reg",
                "DAT_080027f8": "port_event_reg",
                "DAT_0800280c": "GPIOA",
                "DAT_080027fc": "port_config_index_reg",
                "DAT_08002800": "port_config_bits_reg"
            },
            "code": "void configure_GPIO_08002624(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *config) {\n  uint32_t pin_mask;\n  uint32_t speed_bits;\n  uint32_t crl_mask;\n  uint32_t mode_bits;\n  uint32_t pull_bits;\n  uint32_t crl_offset;\n  uint32_t port_index;\n  uint32_t port_mode_bits;\n  uint32_t port_config_bits;\n  uint32_t port_config_reg;\n  uint32_t port_config_offset;\n\n  for (uint32_t i = 0; i <= 15; i++) {\n    pin_mask = 1 << i;\n    if (config->Pin & pin_mask) {\n      speed_bits = 0;\n      mode_bits = config->Mode;\n      pull_bits = 0;\n      if (mode_bits == GPIO_MODE_OUTPUT_50_MHZ) {\n        speed_bits = GPIO_SPEED_FREQ_HIGH;\n      } else if (mode_bits < GPIO_MODE_ANALOG) {\n        if (mode_bits == GPIO_MODE_OUTPUT_PP) {\n          speed_bits = GPIO_SPEED_FREQ_LOW;\n        } else if (mode_bits == GPIO_MODE_INPUT) {\n          pull_bits = GPIO_NOPULL;\n        } else if (mode_bits == GPIO_MODE_IT_RISING_FALLING) {\n          pull_bits = GPIO_NOPULL;\n        }\n      } else {\n        port_mode_bits = mode_bits & GPIO_MODE_INPUT_OUTPUT;\n        port_config_bits = (mode_bits & GPIO_MODE_EVT_MASK) >> 16U;\n        if (port_mode_bits == GPIO_MODE_OUTPUT_PP || port_mode_bits == GPIO_MODE_OUTPUT_OD) {\n          speed_bits = GPIO_SPEED_FREQ_LOW;\n        }\n        if (port_mode_bits == GPIO_MODE_INPUT_OUTPUT || port_mode_bits == GPIO_MODE_OUTPUT_OD) {\n          if (port_config_bits == GPIO_MODE_EVT_RISING) {\n            pull_bits = GPIO_PULLUP;\n          } else if (port_config_bits == GPIO_MODE_EVT_FALLING) {\n            pull_bits = GPIO_PULLDOWN;\n          } else if (port_config_bits == GPIO_MODE_EVT_RISING_FALLING) {\n            pull_bits = GPIO_PULLUPDOWN;\n          }\n        }\n      }\n      crl_offset = (i < 8) ? i * 4 : (i - 8) * 4;\n      crl_mask = ~(0xFU << crl_offset);\n      port_index = (i < 8) ? 0 : 1;\n      port_config_reg = (port_index == 0) ? &GPIOx->CRL : &GPIOx->CRH;\n      port_config_offset = (port_index == 0) ? 0 : 8;\n      port_config_reg &= crl_mask;\n      port_config_reg |= (speed_bits | pull_bits | (mode_bits << port_config_offset)) << crl_offset;\n    }\n  }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002624",
            "calling": [
                "digital_io_init",
                "HAL_ADC_MspInit",
                "uart_init"
            ],
            "imported": false,
            "current_name": "configure_GPIO_08002624"
        },
        "FUN_0800609c": {
            "renaming": {
                "FUN_0800609c": "handle_gpio_exti_interrupt_0800609c",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void handle_gpio_exti_interrupt_0800609c(void)\n{\n  uint32_t gpio_pin = GPIO_PIN_4;\n  HAL_GPIO_EXTI_IRQHandler(gpio_pin);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800609c",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_interrupt_0800609c"
        },
        "FUN_080040b0": {
            "renaming": {
                "FUN_080040b0": "disable_timer_channel_080040b0",
                "htim": "timer_handle",
                "Channel": "channel",
                "pTVar1": "timer_instance",
                "DAT_0800410c": "timer_instance_ptr"
            },
            "code": "HAL_StatusTypeDef_conflict disable_timer_channel_080040b0(TIM_HandleTypeDef *timer_handle, uint32_t channel) {\n  TIM_TypeDef *timer_instance;\n  TIM_CCxChannelCmd(timer_handle->Instance, channel, 0);\n  timer_instance = timer_handle->Instance;\n  if (((timer_instance == DAT_0800410c) && ((timer_instance->CCER & 0x1111) == 0)) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->BDTR = timer_instance->BDTR & 0xffff7fff;\n  }\n  timer_instance = timer_handle->Instance;\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 = timer_instance->CR1 & 0xfffffffe;\n  }\n  timer_handle->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040b0",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "disable_timer_channel_080040b0"
        },
        "FUN_08005d42": {
            "renaming": {
                "__thiscall Print::FUN_08005d42": "print_number",
                "this": "print_obj",
                "n": "number",
                "base": "base",
                "sVar1": "size1",
                "sVar2": "size2",
                "FUN_08005d42Number": "print_number",
                "uint8_t": "unsigned_char",
                "FUN_08005d42": "print_number_08005d42"
            },
            "code": "size_t print_number_08005d42(Print *print_obj, long number, int base) {\n  size_t sVar1;\n  size_t sVar2;\n  if (base == 0) {\n    sVar1 = (**print_obj->_vptr_Print)(print_obj,number & 0xff);\n    return sVar1;\n  }\n  if (base != 10) {\n    sVar1 = print_number_08005d42(print_obj,number,(uint8_t)base);\n    return sVar1;\n  }\n  if (number >= 0) {\n    sVar1 = print_number_08005d42(print_obj,number,'\\n');\n    return sVar1;\n  }\n  sVar1 = print_number_08005d42(print_obj,'-');\n  sVar2 = print_number_08005d42(print_obj,-number,'\\n');\n  return sVar2 + sVar1;\n}",
            "called": [
                "printNumber",
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d42",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "print_number_08005d42"
        },
        "FUN_08004b34": {
            "renaming": {
                "FUN_08004b34": "disable_timer_clock_08004b34",
                "htim": "timer_handle"
            },
            "code": "void disable_timer_clock_08004b34(TIM_HandleTypeDef *timer_handle)\n{\n  timer_disable_clock(timer_handle);\n  return;\n}",
            "called": [
                "timer_disable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b34",
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "imported": false,
            "current_name": "disable_timer_clock_08004b34"
        },
        "FUN_08004c52": {
            "renaming": {
                "FUN_08004c52": "initialize_HAL_and_SystemClock_08004c52"
            },
            "code": "void initialize_HAL_and_SystemClock_08004c52(void)\n{\n  HAL_Init();\n  SystemClock_Config();\n  return;\n}",
            "called": [
                "SystemClock_Config",
                "HAL_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c52",
            "calling": [
                "init"
            ],
            "imported": false,
            "current_name": "initialize_HAL_and_SystemClock_08004c52"
        },
        "FUN_080013a4": {
            "renaming": {
                "FUN_080013a4": "initializeLCD_080013a4",
                "this": "lcd",
                "cols": "numCols",
                "lines": "numRows",
                "dotsize": "charSize",
                "iVar1": "i",
                "iVar2": "i",
                "_displayfunction": "_displayFunction",
                "_numlines": "_numLines",
                "setRowOffsets": "setRowOffsets",
                "_rs_pin": "_rsPin",
                "_rw_pin": "_rwPin",
                "_enable_pin": "_enablePin",
                "_data_pins": "_dataPins",
                "write4bits": "write4Bits",
                "send": "send",
                "_displaycontrol": "_displayControl",
                "display": "display",
                "clear": "clear",
                "_displaymode": "_displayMode"
            },
            "code": "void __thiscall initializeLCD_080013a4(LiquidCrystal *lcd, uint8_t numCols, uint8_t numRows, uint8_t charSize) {\n  int i;\n\n  if (numRows > 1) {\n    lcd->_displayfunction |= 0x08;\n  }\n  lcd->_numlines = numRows;\n  setRowOffsets(lcd, 0, 0x40, (uint)numCols, numCols + 0x40);\n  if ((charSize != 0) && (numRows == 1)) {\n    lcd->_displayfunction |= 0x04;\n  }\n  pinMode((uint)lcd->_rs_pin, OUTPUT);\n  if (lcd->_rw_pin != 0xff) {\n    pinMode((uint)lcd->_rw_pin, OUTPUT);\n  }\n  pinMode((uint)lcd->_enable_pin, OUTPUT);\n  i = 0;\n  while (i < 4) {\n    if ((lcd->_displayfunction & 0x10) == 0) {\n      pinMode((uint)lcd->_data_pins[i], OUTPUT);\n    }\n    else {\n      pinMode((uint)lcd->_data_pins[i + 4], OUTPUT);\n    }\n    i++;\n  }\n  digitalWrite((uint)lcd->_rs_pin, LOW);\n  digitalWrite((uint)lcd->_enable_pin, LOW);\n  if (lcd->_rw_pin != 0xff) {\n    digitalWrite((uint)lcd->_rw_pin, LOW);\n  }\n  if ((lcd->_displayfunction & 0x10) == 0) {\n    write4bits(lcd, 0x03);\n    write4bits(lcd, 0x03);\n    write4bits(lcd, 0x03);\n    write4bits(lcd, 0x02);\n  }\n  else {\n    send(lcd, lcd->_displayfunction | 0x20, 0);\n    send(lcd, lcd->_displayfunction | 0x20, 0);\n    send(lcd, lcd->_displayfunction | 0x20, 0);\n  }\n  send(lcd, lcd->_displayfunction | 0x20, 0);\n  lcd->_displaycontrol = 0x04;\n  display(lcd);\n  clear(lcd);\n  lcd->_displaymode = 0x02;\n  send(lcd, 0x06, 0);\n}\n",
            "called": [
                "clear",
                "write4bits",
                "send",
                "setRowOffsets",
                "display",
                "digitalWrite",
                "pinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080013a4",
            "calling": [
                "setup",
                "init"
            ],
            "imported": false,
            "current_name": "initializeLCD_080013a4"
        },
        "FUN_08006d14": {
            "renaming": {
                "FUN_08006d14": "reset_array_if_full_08006d14",
                "param_1": "error_code",
                "piVar1": "current_array",
                "piVar2": "next_array",
                "iVar3": "global_ptr",
                "ppiVar4": "next_array_ptr"
            },
            "code": "int* reset_array_if_full_08006d14(undefined4* error_code)\n{\n  int* current_array;\n  int* next_array;\n  int global_ptr = *(int*)PTR__global_impure_ptr_08006d88;\n  if (*(int*)(global_ptr + 0x18) == 0)\n  {\n    __sinit(global_ptr);\n  }\n  next_array = (int*)(global_ptr + 0x48);\n  do\n  {\n    current_array = next_array[1];\n    while (current_array = (int*)((int)current_array - 1), -1 < (int)current_array)\n    {\n      if (*(short*)(next_array[2] + 3) == 0)\n      {\n        *(undefined2*)((int)next_array[2] + 0xe) = 0xffff;\n        next_array[2][0x19] = 0;\n        *(undefined2*)(next_array[2] + 3) = 1;\n        *next_array[2] = 0;\n        next_array[2][2] = 0;\n        next_array[2][1] = 0;\n        next_array[2][4] = 0;\n        next_array[2][5] = 0;\n        next_array[2][6] = 0;\n        memset(next_array[2] + 0x17, 0, 8);\n        next_array[2][0xd] = 0;\n        next_array[2][0xe] = 0;\n        next_array[2][0x12] = 0;\n        next_array[2][0x13] = 0;\n        return next_array[2];\n      }\n      next_array[2] += 0x1a;\n    }\n    if (*next_array == (int*)0x0)\n    {\n      current_array = (int*)__sfmoreglue(error_code, 4);\n      *next_array = current_array;\n      if (current_array == (int*)0x0)\n      {\n        *error_code = 0xc;\n        return (int*)0x0;\n      }\n    }\n    next_array = (int**)*next_array;\n  } while (true);\n}",
            "called": [
                "memset",
                "__sinit",
                "__sfmoreglue"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d14",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "reset_array_if_full_08006d14"
        },
        "FUN_080004f8": {
            "renaming": {
                "FUN_080004f8": "calculate_result_080004f8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "result1",
                "param_4": "result2",
                "uVar1": "temp1",
                "lVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "iVar5": "temp5",
                "uVar6": "temp6",
                "unaff_r5": "temp7",
                "uVar7": "temp8",
                "uVar8": "temp9",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3",
                "uVar12": "combined_input"
            },
            "code": "\nulonglong calculate_result_080004f8(undefined4 input1,uint input2,uint result1,uint result2)\n\n{\n  ulonglong temp1;\n  longlong temp2;\n  uint temp3;\n  uint temp4;\n  int temp5;\n  uint temp6;\n  uint temp7;\n  uint temp8;\n  uint temp9;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  ulonglong combined_input;\n  \n  combined_input = CONCAT44(input2,input1);\n  temp8 = 0x7ff;\n  temp4 = input2 >> 0x14 & 0x7ff;\n  flag1 = temp4 == 0;\n  if (!flag1) {\n    temp7 = result2 >> 0x14 & 0x7ff;\n    flag1 = temp7 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp4 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp7 == 0x7ff;\n  }\n  if (flag1) {\n    combined_input = calculate_result_080004f8_080006d4();\n  }\n  temp3 = (uint)(combined_input >> 0x20);\n  temp5 = temp4 + temp7;\n  temp4 = temp3 ^ result2;\n  temp3 = temp3 & ~(temp8 << 0x15);\n  result2 = result2 & ~(temp8 << 0x15);\n  flag1 = ((uint)combined_input | temp3 << 0xc) == 0;\n  if (!flag1) {\n    flag1 = (result1 | result2 << 0xc) == 0;\n  }\n  temp3 = temp3 | 0x100000;\n  result2 = result2 | 0x100000;\n  if (flag1) {\n    result1 = (uint)combined_input | result1;\n    result2 = (temp4 & 0x80000000 | temp3) ^ result2;\n    temp4 = temp8 >> 1;\n    flag3 = SBORROW4(temp5,temp4);\n    temp6 = temp5 - temp4;\n    flag1 = temp6 == 0;\n    temp3 = temp6;\n    if (!flag1 && (int)temp4 <= temp5) {\n      flag3 = SBORROW4(temp8,temp6);\n      temp3 = temp8 - temp6;\n      flag1 = temp8 == temp6;\n    }\n    if (!flag1 && (int)temp3 < 0 == flag3) {\n      result2 = result2 | temp6 * 0x100000;\n    }\n    if (!flag1 && (int)temp3 < 0 == flag3) {\n      return CONCAT44(result2,result1);\n    }\n    result2 = result2 | 0x100000;\n    temp8 = 0;\n    flag3 = SBORROW4(temp6,1);\n    temp6 = temp6 - 1;\n    flag1 = temp6 == 0;\n    temp4 = temp6;\n  }\n  else {\n    temp1 = (combined_input & 0xffffffff) * (ulonglong)result1;\n    combined_input = (combined_input & 0xffffffff) * (ulonglong)result2 +\n             (ulonglong)temp3 * (ulonglong)result1 + (temp1 >> 0x20);\n    temp9 = (uint)combined_input;\n    temp2 = (ulonglong)temp3 * (ulonglong)result2 + (combined_input >> 0x20);\n    temp8 = (uint)temp2;\n    temp3 = (uint)((ulonglong)temp2 >> 0x20);\n    if ((int)temp1 != 0) {\n      temp9 = temp9 | 1;\n    }\n    temp6 = (temp5 + -0x3ff) - (uint)(temp3 < 0x200);\n    if (temp3 < 0x200) {\n      flag1 = (temp9 & 0x80000000) != 0;\n      temp9 = temp9 << 1;\n      temp2 = CONCAT44(temp3 * 2 + (uint)(CARRY4(temp8,temp8) || CARRY4(temp8 * 2,(uint)flag1)),\n                       temp8 * 2 + (uint)flag1);\n    }\n    result2 = temp4 & 0x80000000 | (int)((ulonglong)temp2 >> 0x20) << 0xb | (uint)temp2 >> 0x15;\n    result1 = (uint)temp2 << 0xb | temp9 >> 0x15;\n    temp8 = temp9 * 0x800;\n    flag2 = 0xfc < temp6;\n    flag3 = SBORROW4(temp6,0xfd);\n    temp3 = temp6 - 0xfd;\n    flag1 = temp3 == 0;\n    temp4 = temp3;\n    if (flag2 && !flag1) {\n      flag2 = 0x6ff < temp3;\n      flag3 = SBORROW4(temp3,0x700);\n      temp4 = temp6 - 0x7fd;\n      flag1 = temp3 == 0x700;\n    }\n    if (!flag2 || flag1) {\n      flag1 = 0x7fffffff < temp8;\n      if (temp8 == 0x80000000) {\n        flag1 = (temp9 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(result2 + temp6 * 0x100000 + (uint)CARRY4(result1,(uint)flag1),result1 + flag1\n                     );\n    }\n  }\n  if (!flag1 && (int)temp4 < 0 == flag3) {\n    return (ulonglong)(result2 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag2 = SCARRY4(temp6,0x36);\n  flag1 = (int)(temp6 + 0x36) < 0;\n  flag3 = temp6 == 0xffffffca;\n  if (flag3 || flag1 != flag2) {\n    result1 = 0;\n  }\n  if (flag3 || flag1 != flag2) {\n    result2 = result2 & 0x80000000;\n  }\n  if (flag3 || flag1 != flag2) {\n    return CONCAT44(result2,result1);\n  }\n  temp4 = -temp6;\n  temp3 = temp4 - 0x20;\n  if (0x1f < (int)temp4) {\n    temp6 = result1 >> (temp3 & 0xff) | result2 << (0x20 - temp3 & 0xff);\n    temp4 = (result2 >> (temp3 & 0xff) & ~((result2 & 0x80000000) >> (temp3 & 0xff))) -\n            ((int)temp6 >> 0x1f);\n    if ((temp8 | result1 << (0x20 - temp3 & 0xff) | temp6 << 1) == 0) {\n      temp4 = temp4 & ~(temp6 >> 0x1f);\n    }\n    return CONCAT44(result2,temp4) & 0x80000000ffffffff;\n  }\n  temp5 = temp4 - 0x14;\n  if (temp5 == 0 || temp5 < 0 != SCARRY4(temp3,0xc)) {\n    temp9 = result1 << (temp6 + 0x20 & 0xff);\n    temp3 = result1 >> (temp4 & 0xff) | result2 << (temp6 + 0x20 & 0xff);\n    temp6 = temp3 + -((int)temp9 >> 0x1f);\n    if ((temp8 | temp9 << 1) == 0) {\n      temp6 = temp6 & ~(temp9 >> 0x1f);\n    }\n    return CONCAT44((result2 & 0x80000000) +\n                    ((result2 & 0x7fffffff) >> (temp4 & 0xff)) +\n                    (uint)CARRY4(temp3,-((int)temp9 >> 0x1f)),temp6);\n  }\n  temp4 = 0xc - temp5;\n  temp6 = result1 << (temp4 & 0xff);\n  temp4 = result1 >> (0x20 - temp4 & 0xff) | result2 << (temp4 & 0xff);\n  temp3 = temp4 + -((int)temp6 >> 0x1f);\n  if ((temp8 | temp6 << 1) == 0) {\n    temp3 = temp3 & ~(temp6 >> 0x1f);\n  }\n  return CONCAT44((result2 & 0x80000000) + (uint)CARRY4(temp4,-((int)temp6 >> 0x1f)),temp3);\n}\n\n",
            "called": [
                "FUN_080006d4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004f8",
            "calling": [
                "SetSampleTime",
                "Compute",
                "printFloat",
                "readThermocouple",
                "SetTunings"
            ],
            "imported": false,
            "current_name": "calculate_result_080004f8"
        }
    },
    "used_tokens": 294007,
    "layers": [
        [
            "FUN_08002470",
            "FUN_08007004",
            "FUN_080035fc",
            "FUN_08005740",
            "FUN_08006158",
            "FUN_08006d8c",
            "FUN_08004f2c",
            "FUN_08004ec4",
            "FUN_08000178",
            "FUN_08006c88",
            "FUN_080060e4",
            "FUN_0800258c",
            "FUN_08004e20",
            "FUN_0800573c",
            "FUN_080032b4",
            "FUN_08004d06",
            "FUN_080056d8",
            "FUN_080019f6",
            "FUN_08002f9c",
            "FUN_08005510",
            "FUN_08005750",
            "FUN_08002cf2",
            "FUN_08006288",
            "FUN_08002004",
            "FUN_08004f3c",
            "FUN_08005754",
            "FUN_08005fc8",
            "FUN_08002ab8",
            "FUN_0800598a",
            "FUN_08004e34",
            "FUN_08001a44",
            "FUN_08002c54",
            "FUN_080043b4",
            "FUN_0800441a",
            "FUN_08004d18",
            "FUN_080006d4",
            "FUN_08007028",
            "FUN_08002494",
            "FUN_080055bc",
            "FUN_08001960",
            "FUN_08004ca2",
            "FUN_08002810",
            "FUN_0800224c",
            "FUN_080054b0",
            "FUN_080016b4",
            "FUN_08004e48",
            "FUN_08005890",
            "FUN_08004cb2",
            "FUN_08004ef4",
            "FUN_08001294",
            "FUN_08002384",
            "FUN_08005650",
            "FUN_08006fb6",
            "FUN_08002ad8",
            "FUN_08004204",
            "FUN_08005da8",
            "FUN_080045fe",
            "FUN_080055e0",
            "FUN_08006f10",
            "FUN_0800213c",
            "FUN_0800455a",
            "FUN_08004d30",
            "FUN_08001a66",
            "FUN_08003c44",
            "FUN_08006074",
            "FUN_080028d2",
            "FUN_08000a18",
            "FUN_08005384",
            "FUN_08005b3c",
            "FUN_0800091c",
            "FUN_080046b8",
            "FUN_08004c8a",
            "FUN_08001cd0",
            "FUN_08000130",
            "FUN_08004a4c",
            "FUN_08006112",
            "FUN_08004974",
            "FUN_08003520",
            "FUN_08002ca6",
            "FUN_08004618",
            "FUN_080060a6",
            "FUN_08001c30",
            "FUN_08005c72",
            "FUN_0800048c",
            "FUN_080045a2",
            "FUN_080047e8",
            "FUN_080057b4",
            "FUN_0800092c",
            "FUN_08002560",
            "FUN_08006e90",
            "FUN_08006920",
            "FUN_080008ba",
            "FUN_08002d1c",
            "FUN_08005714",
            "FUN_08003da4",
            "FUN_08005a44",
            "FUN_080009dc",
            "FUN_0800417c",
            "FUN_08004b94",
            "FUN_080058e0",
            "FUN_08001918",
            "FUN_0800611c",
            "FUN_0800049c",
            "FUN_080047f4",
            "FUN_08002c10",
            "FUN_080009f0",
            "FUN_0800134e",
            "FUN_08006be0",
            "FUN_080012e8",
            "FUN_08006370",
            "FUN_080024f8",
            "FUN_0800594e",
            "FUN_080056a8",
            "FUN_08006ac0",
            "FUN_08007220",
            "FUN_08004198",
            "FUN_08001c3c",
            "FUN_08000a2c",
            "FUN_08001366",
            "FUN_08005848",
            "FUN_08000ae8",
            "FUN_08003ed8",
            "FUN_080061e0",
            "FUN_08004f0c",
            "FUN_08005604",
            "FUN_08005724",
            "FUN_08005728",
            "FUN_0800135a",
            "FUN_08005c96",
            "FUN_0800571a",
            "FUN_08002efc",
            "FUN_0800365c",
            "FUN_08006ad0",
            "FUN_080033b8",
            "FUN_080069e4",
            "FUN_080060bc",
            "FUN_08004b9e",
            "FUN_08006940",
            "FUN_080058ea",
            "FUN_08002582",
            "FUN_08005976",
            "FUN_08004884",
            "FUN_08005fa0",
            "FUN_08001be8",
            "FUN_080061f0",
            "FUN_08002348",
            "FUN_08004f1c",
            "FUN_08005a68",
            "FUN_08001814",
            "FUN_080056c0",
            "FUN_08000aec",
            "FUN_0800572c",
            "FUN_08004e12",
            "FUN_08000a58",
            "FUN_08001b48",
            "FUN_08004092",
            "FUN_08000450",
            "FUN_08005bb0",
            "FUN_080014ba",
            "FUN_08003c90",
            "FUN_08002514",
            "FUN_08005c1c",
            "FUN_08006dc8",
            "FUN_0800412c",
            "FUN_0800492c",
            "FUN_08000cbc",
            "FUN_0800480a",
            "FUN_080015f8",
            "FUN_08005c38",
            "FUN_08005f8c",
            "FUN_08006f5a",
            "FUN_08000b08",
            "FUN_08006cb4",
            "FUN_08004c5e",
            "FUN_08007098",
            "FUN_08004b3c",
            "FUN_08001550",
            "FUN_08001310",
            "FUN_080009a8",
            "FUN_08004d90",
            "FUN_08005ce8",
            "FUN_0800316c",
            "FUN_08004828",
            "FUN_08004948",
            "FUN_08005b24",
            "FUN_080049f0",
            "FUN_08001e40",
            "FUN_08003a68",
            "FUN_080012a2",
            "FUN_08004c78",
            "FUN_08005bd4",
            "FUN_08001e48",
            "FUN_080059c8",
            "FUN_080009b8",
            "FUN_08000aa8",
            "FUN_08000a04",
            "FUN_0800010c",
            "FUN_08001cac",
            "FUN_08005a18",
            "FUN_08003f18",
            "FUN_0800591e",
            "FUN_08006104",
            "FUN_08002540",
            "FUN_08005be2",
            "FUN_08006344",
            "FUN_080009c8",
            "FUN_08002db2",
            "FUN_08005932",
            "FUN_08001cc4",
            "FUN_08003ea0",
            "FUN_0800306c",
            "FUN_08005c64",
            "FUN_0800548c",
            "FUN_08000924",
            "FUN_08006c34",
            "FUN_080072a4",
            "FUN_08004848",
            "FUN_08006f92",
            "FUN_080012c0",
            "FUN_08001f80",
            "FUN_08001f84",
            "FUN_08000bcc",
            "FUN_080047d8",
            "FUN_0800281e",
            "FUN_08006198",
            "FUN_08006fc0",
            "FUN_08007048",
            "FUN_08003c50",
            "FUN_080065c0",
            "FUN_080054d4",
            "FUN_0800715c",
            "FUN_08004d40",
            "FUN_08004d44",
            "FUN_0800282c",
            "FUN_080015b2",
            "FUN_0800040c",
            "FUN_08006088",
            "FUN_08006eb0",
            "FUN_08004e5c",
            "FUN_08004df4",
            "FUN_08004bb0",
            "FUN_08004df8",
            "FUN_08002af8",
            "FUN_080028de",
            "FUN_08002848",
            "FUN_08004e70",
            "FUN_080020f0",
            "FUN_08006e10",
            "FUN_0800607e",
            "FUN_08004e74",
            "FUN_08004c30",
            "FUN_08006092",
            "FUN_08006f38",
            "FUN_08004cce",
            "FUN_08006f34",
            "FUN_08006fe4",
            "FUN_08003ad4",
            "FUN_08004110",
            "FUN_08004ce2",
            "FUN_08005568",
            "FUN_08004478",
            "FUN_08005f5e",
            "FUN_08005cb6",
            "FUN_08003c70",
            "FUN_080053d4",
            "FUN_08002b84",
            "FUN_08004c48",
            "FUN_0800042c",
            "FUN_08005f6c",
            "FUN_08005690",
            "FUN_08005cc0",
            "FUN_0800706c",
            "FUN_08002624",
            "FUN_0800609c",
            "FUN_080040b0",
            "FUN_08004b34",
            "FUN_08004c52",
            "FUN_080013a4",
            "FUN_08006d14"
        ],
        [
            "FUN_080068f0",
            "FUN_0800138e",
            "FUN_08001c88",
            "FUN_08006174",
            "FUN_08006f00",
            "FUN_080018f8",
            "FUN_08005da0",
            "FUN_08005f2c",
            "FUN_08005f40",
            "FUN_08005b54",
            "FUN_08006c40",
            "FUN_0800157c",
            "FUN_08001c32",
            "FUN_08001b18",
            "FUN_08005d8a",
            "FUN_08001ab0",
            "FUN_08005730",
            "FUN_080060d4",
            "FUN_08005cd4",
            "FUN_08007090",
            "FUN_08005d82",
            "FUN_08001510",
            "FUN_08005d42"
        ],
        [
            "FUN_08006394",
            "FUN_08003688",
            "FUN_08000188",
            "FUN_080066b0",
            "FUN_08000190",
            "FUN_08000194",
            "FUN_08004f4c",
            "FUN_0800074c",
            "FUN_08000cd0",
            "FUN_080004f8"
        ]
    ],
    "locked_functions": []
}