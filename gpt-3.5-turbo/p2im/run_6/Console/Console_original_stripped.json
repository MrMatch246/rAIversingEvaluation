{
    "functions": {
        "FUN_000026c0": {
            "renaming": {
                "FUN_000026c0": "clear_rtc_alarm_callback_000026c0",
                "PTR_rtc_callback_000026d4": "rtc_callback_ptr"
            },
            "code": "void clear_rtc_alarm_callback_000026c0(void)\n{\n  rtt_clear_alarm();\n  *(undefined4 *)PTR_rtc_callback_000026d4 = 0;\n  return;\n}",
            "called": [
                "rtt_clear_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "clear_rtc_alarm_callback_000026c0"
        },
        "FUN_00004bd0": {
            "renaming": {
                "FUN_00004bd0": "allocate_memory_00004bd0",
                "param_1": "reent",
                "param_2": "size",
                "puVar1": "start_of_heap",
                "pvVar2": "new_break",
                "puVar3": "free_block",
                "iVar4": "block_size",
                "uVar5": "block_size_difference",
                "puVar6": "current_block",
                "uVar7": "adjusted_size"
            },
            "code": "uint allocate_memory_00004bd0(_reent *reent, uint size)\n{\n  uint *free_block, *prev_block;\n  uint adjusted_size = (size + 3) & 0xfffffffc) + 8;\n  if (adjusted_size < 0xc) {\n    adjusted_size = 0xc;\n  }\n  if (((int)adjusted_size < 0) || (adjusted_size < size)) {\n    reent->_errno = 0xc;\n  }\n  else {\n    __malloc_lock();\n    uint *current_block = *(uint **)PTR___malloc_free_list_00004c7c;\n    prev_block = *(uint **)PTR___malloc_free_list_00004c7c;\n    while (current_block != (uint *)0x0) {\n      uint block_size = *current_block - adjusted_size;\n      if (block_size >= 0 && block_size <= 0xb) {\n        free_block = current_block[1];\n        if (prev_block == current_block) {\n          *(uint **)PTR___malloc_free_list_00004c7c = free_block;\n        }\n        if (prev_block != current_block) {\n          prev_block[1] = free_block;\n        }\n        goto done;\n      }\n      prev_block = current_block;\n      current_block = (uint *)current_block[1];\n    }\n    if (*(int *)PTR___malloc_sbrk_start_00004c80 == 0) {\n      void *new_break = _sbrk_r(reent,0);\n      *(void **)PTR___malloc_sbrk_start_00004c80 = new_break;\n    }\n    free_block = (uint *)_sbrk_r(reent,adjusted_size);\n    if ((free_block != (uint *)0xffffffff) && ((current_block = (uint *)((int)free_block + 3U & 0xfffffffc), free_block == current_block || (_sbrk_r(reent,(int)current_block - (int)free_block) != (void *)0xffffffff)))) {\n      *current_block = adjusted_size;\n      goto done;\n    }\n    reent->_errno = 0xc;\n    __malloc_unlock(reent);\n    return 0;\n  }\n  done:\n  __malloc_unlock(reent);\n  uint aligned_address = (int)free_block + 0xbU & 0xfffffff8;\n  int block_size = aligned_address - (int)(free_block + 1);\n  if (block_size == 0) {\n    return aligned_address;\n  }\n  *(uint *)((int)free_block + block_size) = (int)(free_block + 1) - aligned_address;\n  return aligned_address;\n}",
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004bd0",
            "calling": [
                "_tzset_unlocked_r",
                "__submore",
                "_realloc_r",
                "__sfmoreglue",
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00004bd0"
        },
        "FUN_00000794": {
            "renaming": {
                "FUN_00000794": "disable_interrupts_and_remove_thread_from_schedule_00000794",
                "PTR_sched_threads_000007d0": "sched_threads",
                "PTR_sched_active_pid_000007cc": "sched_active_pid",
                "PTR_sched_num_threads_000007d4": "sched_num_threads",
                "PTR_sched_active_thread_000007d8": "sched_active_thread"
            },
            "code": "void disable_interrupts_and_remove_thread_from_schedule_00000794() {\n  disable_interrupts();\n  thread_t* active_thread = *(thread_t**)PTR_PTR_sched_active_thread_000007d8_000007d8;\n  *(undefined4 *)(PTR_PTR_sched_threads_000007d0_000007d0 + *(short *)PTR_PTR_sched_active_pid_000007cc_000007cc * 4) = 0;\n  int* num_threads = (int*) PTR_PTR_sched_num_threads_000007d4_000007d4;\n  *num_threads = *num_threads - 1;\n  sched_set_status(active_thread, 0);\n  *(undefined4 *)PTR_PTR_sched_active_thread_000007d8_000007d8 = 0;\n  cpu_switch_context_exit();\n}",
            "called": [
                "cpu_switch_context_exit",
                "irq_disable",
                "sched_set_status"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000794",
            "calling": [],
            "imported": false,
            "current_name": "disable_interrupts_and_remove_thread_from_schedule_00000794"
        },
        "FUN_000064bc": {
            "renaming": {
                "FUN_000064bc": "process_data_000064bc",
                "param_1": "data",
                "param_2": "flags",
                "param_3": "buffer",
                "param_4": "callback",
                "puVar1": "PTR_DAT_00006568",
                "iVar2": "callback_return_value",
                "iVar7": "num_processed_bytes",
                "uVar3": "current_flag_value",
                "ppbVar4": "current_buffer",
                "pbVar5": "previous_buffer",
                "unaff_r6": "next_buffer",
                "pbVar6": "current_char"
            },
            "code": "int process_data_000064bc(int data, uint *flags, byte **buffer, int *callback) {\\n\\\n  byte **current_buffer = buffer;\\n\\\n  int num_processed_bytes = 0;\\n\\\n  int callback_return_value = 0;\\n\\\n  uint current_flag_value = flags[2];\\n\\\n  if (current_flag_value == 0) {\\n\\\n    if (flags[6] == 0) {\\n\\\n      current_flag_value = 1;\\n\\\n    }\\n\\\n    else {\\n\\\n      current_flag_value = 0xffffffff;\\n\\\n    }\\n\\\n    flags[2] = current_flag_value;\\n\\\n  }\\n\\\n  if (-1 < (int)(*flags << 0x1b)) {\\n\\\n    byte **next_buffer = (byte **)*callback;\\n\\\n    *callback = next_buffer + 1;\\n\\\n    current_buffer = next_buffer;\\n\\\n  }\\n\\\n  while (true) {\\n\\\n    uint current_flag = flags[6];\\n\\\n    if (current_flag != 0) {\\n\\\n      if (current_flag == 1) {\\n\\\n        char current_char = *(char *)(flags[5] + (uint)**current_buffer);\\n\\\n        if (current_char == \"\\0\") {\\n\\\n          if (num_processed_bytes == 0) {\\n\\\n            return 1;\\n\\\n          }\\n\\\n          if (((*flags & 0x10) == 0) && (flags[3] = flags[3] + 1, flags[6] != 0)) {\\n\\\n            *buffer = 0;\\n\\\n          }\\n\\\n          flags[4] = num_processed_bytes + flags[4];\\n\\\n          return 0;\\n\\\n        }\\n\\\n      }\\n\\\n      else if ((current_flag != 2) || ((int)((uint)(byte)*PTR_DAT_00006568[**current_buffer] << 0x1c) < 0)) {\\n\\\n        if (num_processed_bytes == 0) {\\n\\\n          return 1;\\n\\\n        }\\n\\\n        if (((*flags & 0x10) == 0) && (flags[3] = flags[3] + 1, flags[6] != 0)) {\\n\\\n          *buffer = 0;\\n\\\n        }\\n\\\n        flags[4] = num_processed_bytes + flags[4];\\n\\\n        return 0;\\n\\\n      }\\n\\\n    }\\n\\\n    byte *next_buffer = *current_buffer;\\n\\\n    if (-1 < (int)(*flags << 0x1b)) {\\n\\\n      next_buffer = *current_buffer + 1;\\n\\\n      **current_buffer = **current_buffer;\\n\\\n    }\\n\\\n    byte *previous_buffer = (*current_buffer)[1];\\n\\\n    *current_buffer = *current_buffer + 1;\\n\\\n    uint remaining_bytes = flags[2] - 1;\\n\\\n    (*current_buffer)[1] = previous_buffer + -1;\\n\\\n    num_processed_bytes = num_processed_bytes + 1;\\n\\\n    flags[2] = remaining_bytes;\\n\\\n    current_buffer = &next_buffer;\\n\\\n    if ((remaining_bytes == 0) || (((int)(previous_buffer + -1) < 1) && ((callback_return_value = (*(code *)flags[0x60])(data, current_buffer, remaining_bytes, (code *)flags[0x60], callback)), callback_return_value != 0))) {\\n\\\n      if (num_processed_bytes == 0) {\\n\\\n          return 1;\\n\\\n        }\\n\\\n        if (((*flags & 0x10) == 0) && (flags[3] = flags[3] + 1, flags[6] != 0)) {\\n\\\n          *buffer = 0;\\n\\\n        }\\n\\\n        flags[4] = num_processed_bytes + flags[4];\\n\\\n        return 0;\\n\\\n    }\\n\\\n  }\\n\\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000064bc",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "process_data_000064bc"
        },
        "FUN_00002970": {
            "renaming": {
                "FUN_00002970": "clear_rtt_interrupt_flag_00002970",
                "rtt": "real_time_clock",
                "DAT_00002990": "dat_00002990"
            },
            "code": "void clear_rtt_interrupt_flag_00002970(void)\n{\n  RTC_Type *real_time_clock;\n  uint32_t *DAT_00002990 = (uint32_t*)DAT_00002990;\n  DAT_00002990[5] = DAT_00002990[5] & 0xffffffef;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002970",
            "calling": [
                "rtc_poweroff"
            ],
            "imported": false,
            "current_name": "clear_rtt_interrupt_flag_00002970"
        },
        "FUN_00000dc0": {
            "renaming": {
                "FUN_00000dc0": "initialize_default_settings_00000dc0"
            },
            "code": "void initialize_default_settings_00000dc0(void)\n{\n  initialize_default_settings_00000dc0();\n  return;\n}",
            "called": [
                "dummy_handler_default"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dc0",
            "calling": [],
            "imported": false,
            "current_name": "initialize_default_settings_00000dc0"
        },
        "FUN_00000ca0": {
            "renaming": {
                "FUN_00000ca0": "usage_fault_handler_00000ca0",
                "PTR_s_USAGE_FAULT_HANDLER_00000cac": "usage_fault_handler"
            },
            "code": "void usage_fault_handler_00000ca0(void)\n{\n    core_panic(PANIC_USAGE_FAULT, usage_fault_handler_00000ca0);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ca0",
            "calling": [],
            "imported": false,
            "current_name": "usage_fault_handler_00000ca0"
        },
        "FUN_00000d0c": {
            "renaming": {
                "FUN_00000d0c": "enable_irq_interrupts_if_privileged_00000d0c",
                "state": "irq_state",
                "bVar1": "is_privileged_mode"
            },
            "code": "void enable_irq_interrupts_if_privileged_00000d0c(uint state)\n{\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    enableIRQinterrupts((state & 1) == 1);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d0c",
            "calling": [
                "kinetis_mcg_init",
                "_sbrk_r",
                "thread_create",
                "mutex_unlock",
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "enable_irq_interrupts_if_privileged_00000d0c"
        },
        "FUN_00003d94": {
            "renaming": {
                "FUN_00003d94": "write_sensor_data_00003d94",
                "dev": "sensor",
                "data": "data",
                "iVar1": "result",
                "saul_reg_t": "sensor_register_t",
                "phydat_t": "sensor_data_t",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int write_sensor_data_00003d94(saul_reg_t *sensor, phydat_t *data)\n{\n  int result;\n  if (sensor == NULL) {\n    result = -19;\n  }\n  else {\n    result = (*sensor->driver->write)(sensor->dev, data);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d94",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "write_sensor_data_00003d94"
        },
        "FUN_0000579c": {
            "renaming": {
                "FUN_0000579c": "releaseRecursiveMallocLock_0000579c"
            },
            "code": "void releaseRecursiveMallocLock_0000579c(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___malloc_recursive_mutex_000057a4);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000579c",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "releaseRecursiveMallocLock_0000579c"
        },
        "FUN_000015d0": {
            "renaming": {
                "FUN_000015d0": "send_data_via_uart_000015d0",
                "uart": "uart_index",
                "data": "data_buffer",
                "len": "data_length",
                "iVar1": "uart_config_ptr",
                "dev": "uart_device",
                "i": "loop_index"
            },
            "code": "void send_data_via_uart_000015d0(uart_t uart, uint8_t *data, size_t len) {\n  int uart_config_ptr = *(int *)(PTR_uart_config_00001624 + uart * 0x20);\n  UART_Type *uart_device = (UART_Type *)uart_config_ptr;\n  for (size_t i = 0; i < len; i++) {\n    while (uart_device->STAT & UART_STAT_TX_FULL);\n    uart_device->DATA = data[i];\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000015d0",
            "calling": [
                "uart_stdio_write"
            ],
            "imported": false,
            "current_name": "send_data_via_uart_000015d0"
        },
        "FUN_00004cdc": {
            "renaming": {
                "FUN_00004cdc": "print_string_00004cdc",
                "param_1": "stream",
                "param_2": "string_address",
                "cVar1": "current_char",
                "iVar2": "retarget_lock_acquired",
                "pcVar3": "string_pointer",
                "ppcVar4": "stream_pointer",
                "uVar5": "return_value",
                "pcVar6": "stream_buffer"
            },
            "code": "undefined4 print_string_00004cdc(int stream,int string_address){\n  char current_char;\n  int retarget_lock_acquired;\n  char *string_pointer;\n  char **stream_pointer;\n  undefined4 return_value;\n  char *stream_buffer;\n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  stream_pointer = *(char ***)(stream + 8);\n  if (*(int *)(stream + 0x18) == 0) {\n    __sinit(stream);\n  }\n  if (stream_pointer == (char **)PTR___sf_fake_stdin_00004dac) {\n    stream_pointer = *(char ***)(stream + 4);\n  }\n  else if (stream_pointer == (char **)PTR___sf_fake_stdout_00004db0) {\n    stream_pointer = *(char ***)(stream + 8);\n  }\n  else if (stream_pointer == (char **)PTR___sf_fake_stderr_00004db4) {\n    stream_pointer = *(char ***)(stream + 0xc);\n  }\n  retarget_lock_acquired = (-1 < (int)stream_pointer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream_pointer + 3) << 0x16));\n  if (retarget_lock_acquired) {\n    __retarget_lock_acquire_recursive(stream_pointer[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(stream_pointer + 3) << 0x1c) < 0) && (stream_pointer[4] != (char *)0x0)) || (__swsetup_r(stream,stream_pointer) == 0)) {\n    string_pointer = (char *)(string_address - 1);\n    do {\n      while( true ) {\n        string_pointer = string_pointer + 1;\n        current_char = *string_pointer;\n        stream_buffer = stream_pointer[2] + -1;\n        stream_pointer[2] = stream_buffer;\n        if (current_char == '\\0') {\n          if (-1 < (int)stream_buffer) {\n            string_pointer = *stream_pointer;\n            return_value = 10;\n            *stream_pointer = string_pointer + 1;\n            *string_pointer = '\\n';\n            goto LAB_00004d64;\n          }\n          if (__swbuf_r(stream,10,stream_pointer) == -1) {\n            goto LAB_00004d60;\n          }\n          return_value = 10;\n          goto LAB_00004d64;\n        }\n        if (((int)stream_buffer < 0) && (((int)stream_buffer < (int)stream_pointer[6] || (current_char == '\\n')))) break;\n        stream_buffer = *stream_pointer;\n        *stream_pointer = stream_buffer + 1;\n        *stream_buffer = current_char;\n      }\n    } while (__swbuf_r(stream,current_char,stream_pointer) != -1);\n  }\nLAB_00004d60:\n  return_value = 0xffffffff;\nLAB_00004d64:\n  if (retarget_lock_acquired) {\n    __retarget_lock_release_recursive(stream_pointer[0x16]);\n  }\n  return return_value;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__swbuf_r",
                "__swsetup_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cdc",
            "calling": [
                "puts"
            ],
            "imported": false,
            "current_name": "print_string_00004cdc"
        },
        "FUN_00005e68": {
            "renaming": {
                "FUN_00005e68": "scan_formatted_input_00005e68",
                "__s": "buffer",
                "__format": "format",
                "iVar1": "result",
                "in_r2": "unknown4",
                "in_r3": "unknown5",
                "local_80": "buffer_start",
                "local_7c": "buffer_size",
                "local_74": "short_arg",
                "local_72": "short_arg2",
                "local_70": "buffer_end",
                "local_6c": "arg_size",
                "local_5c": "unknown1",
                "local_4c": "unknown2",
                "local_38": "unknown3",
                "uStack_8": "args",
                "uStack_4": "unknown5",
                "PTR__impure_ptr_00005eb8": "PTR__impure_ptr_00005eb8",
                "DAT_00005eb4": "DAT_00005eb4"
            },
            "code": "int scan_formatted_input_00005e68(char *buffer, char *format, ...) {\n  int result;\n  va_list args;\n  char *buffer_start = buffer;\n  char *buffer_end = buffer;\n  size_t buffer_size;\n  short int short_arg;\n  short int short_arg2 = -1;\n  size_t arg_size;\n  int unknown1 = DAT_00005eb4;\n  int unknown2 = 0;\n  int unknown3 = 0;\n  int unknown4;\n  int unknown5;\n  va_start(args, format);\n  buffer_size = strlen(buffer);\n  arg_size = buffer_size;\n  unknown4 = va_arg(args, int);\n  unknown5 = va_arg(args, int);\n  result = __ssvfiscanf_r(*PTR__impure_ptr_00005eb8, &buffer_start, format, &unknown4);\n  va_end(args);\n  return result;\n}\n",
            "called": [
                "__ssvfiscanf_r",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e68",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "scan_formatted_input_00005e68"
        },
        "FUN_00000dcc": {
            "renaming": {
                "FUN_00000dcc": "initialize_data_00000dcc",
                "DAT_00000df0": "data_array"
            },
            "code": "void initialize_data_00000dcc(void)\n{\n    int* DAT_00000df0 = DAT_00000df0;\n    DAT_00000df0[7] = 0xc520;\n    DAT_00000df0[7] = 0xd928;\n    *DAT_00000df0 = 0xd2;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dcc",
            "calling": [
                "pre_startup"
            ],
            "imported": false,
            "current_name": "initialize_data_00000dcc"
        },
        "FUN_0000285c": {
            "renaming": {
                "FUN_0000285c": "set_RTC_counter_0000285c",
                "DAT_00002890": "counter_array",
                "puVar1": "counter_ptr",
                "rtt": "rtc"
            },
            "code": "void set_RTC_counter_0000285c(uint32_t counter)\n{\n  uint32_t *counter_ptr;\n  RTC_Type *rtc;\n  \n  counter_ptr = DAT_00002890;\n  DAT_00002890[5] = DAT_00002890[5] & 0xffffffef;\n  *counter_ptr = counter;\n  counter_ptr[5] = counter_ptr[5] | 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000285c",
            "calling": [
                "rtc_set_time"
            ],
            "imported": false,
            "current_name": "set_RTC_counter_0000285c"
        },
        "FUN_00000e58": {
            "renaming": {
                "FUN_00000e58": "loopWithDisabledInterrupts_00000e58"
            },
            "code": "void loopWithDisabledInterrupts_00000e58(void)\n{\n  irq_disable();\n  while(true)\n  {\n     //Do nothing block with infinite loop\n  }\n}",
            "called": [
                "irq_disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e58",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "loopWithDisabledInterrupts_00000e58"
        },
        "FUN_00001778": {
            "renaming": {
                "FUN_00001778": "set_bit_and_clear_other_bits_00001778",
                "DAT_000017d0": "data_ptr",
                "DAT_000017d8": "bit_clear_data"
            },
            "code": "void set_bit_and_clear_other_bits_00001778(void)\n{\n  byte* DAT_000017d0 = (byte *)(DAT_000017d0 + 1);\n  *DAT_000017d0 = (*DAT_000017d0 & 0xcf) | 0x20;\n  bit_clear8(DAT_000017d8, 0x02);\n  return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001778",
            "calling": [
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "set_bit_and_clear_other_bits_00001778"
        },
        "FUN_000026d8": {
            "renaming": {
                "FUN_000026d8": "turn_on_rtt_000026d8",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "void turn_on_rtt_000026d8(void)\n{\n  rtt_poweron();\n  return;\n}",
            "called": [
                "rtt_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026d8",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "turn_on_rtt_000026d8"
        },
        "FUN_00000566": {
            "renaming": {
                "FUN_00000566": "count_leading_zeroes_in_32bit_00000566",
                "v": "num",
                "bVar1": "byte1",
                "bVar2": "byte2",
                "bVar3": "byte3",
                "bVar4": "byte4",
                "uVar5": "leading_zeroes"
            },
            "code": "uint count_leading_zeroes_in_32bit_00000566(uint num) {\n  byte byte1 = (byte)num;\n  byte byte2 = (byte)(num >> 8);\n  byte byte3 = (byte)(num >> 16);\n  byte byte4 = (byte)(num >> 24);\n  uint leading_zeroes = count_leading_zeroes(((((((byte1 & 1) << 1 | byte1 >> 1 & 1) << 1 | byte1 >> 2 & 1) << 1 | byte1 >> 3 & 1) << 1 | byte1 >> 4 & 1) << 1 | byte1 >> 5 & 1) << 1 | byte1 >> 6 & 1) << 1 | byte1 >> 7) << 24 | ((((((byte2 & 1) << 1 | byte2 >> 1 & 1) << 1 | byte2 >> 2 & 1) << 1 | byte2 >> 3 & 1) << 1 | byte2 >> 4 & 1) << 1 | byte2 >> 5 & 1) << 1 | byte2 >> 6 & 1) << 16 | ((((((byte3 & 1) << 1 | byte3 >> 1 & 1) << 1 | byte3 >> 2 & 1) << 1 | byte3 >> 3 & 1) << 1 | byte3 >> 4 & 1) << 1 | byte3 >> 5 & 1) << 1 | byte3 >> 6 & 1) << 8 | ((((((byte4 & 1) << 1 | byte4 >> 1 & 1) << 1 | byte4 >> 2 & 1) << 1 | byte4 >> 3 & 1) << 1 | byte4 >> 4 & 1) << 1 | byte4 >> 5 & 1) << 1 | byte4 >> 6 & 1) << 0;\n  if (num == 0) {\n    leading_zeroes = 0xffffffff;\n  }\n  return leading_zeroes;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000566",
            "calling": [
                "sched_run"
            ],
            "imported": false,
            "current_name": "count_leading_zeroes_in_32bit_00000566"
        },
        "FUN_00001d08": {
            "renaming": {
                "FUN_00001d08": "calculate_address_from_bit_and_ptr_00001d08",
                "ptr": "ptr",
                "bit": "bit"
            },
            "code": "void * calculate_address_from_bit_and_ptr_00001d08(void *ptr,uintptr_t bit)\n{\n  uintptr_t upper_bits = (uintptr_t)ptr & 0xf0000000;\n  uintptr_t lower_bits = (uintptr_t)ptr & 0xfffff;\n  uintptr_t offset = (bit * 4) + (lower_bits << 5) + 0x2000000;\n  return (void *)(upper_bits | offset);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d08",
            "calling": [
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_address_from_bit_and_ptr_00001d08"
        },
        "FUN_000031fc": {
            "renaming": {
                "FUN_000031fc": "calculate_day_of_week_000031fc",
                "year": "input_year",
                "month": "input_month",
                "day": "input_day",
                "bVar1": "month_adjustment",
                "iVar2": "month_adjusted",
                "iVar3": "year_adjusted",
                "DAT_00003280": "century",
                "PTR_t_00003284": "month_offsets",
                "byte": "month_adjustment_data_type",
                "uint": "year_adjustment_data_type",
                "longlong": "long_long_data_type",
                "ulonglong": "unsigned_long_long_data_type"
            },
            "code": "int calculate_day_of_week_000031fc(int year, int month, int day) {\n    int month_adjusted;\n    int year_adjusted;\n    int DAT_00003280 = 0x6;\n    if (month < 3) {\n        month_adjusted = 1;\n        year_adjusted = year - 1;\n    } else {\n        month_adjusted = month;\n        year_adjusted = year;\n    }\n    int DAT_00003280_adjusted = year_adjusted / 100;\n    int year_within_DAT_00003280 = year_adjusted % 100;\n    int day_of_week = day + (13 * (month_adjusted + 1)) / 5 + year_within_DAT_00003280 + year_within_DAT_00003280 / 4 + DAT_00003280_adjusted / 4 + 5 * DAT_00003280_adjusted;\n    return day_of_week % 7;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031fc",
            "calling": [
                "_parse_time"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_000031fc"
        },
        "FUN_000016ec": {
            "renaming": {
                "FUN_000016ec": "set_bit_at_position_000016ec",
                "ptr": "data",
                "bit": "position",
                "puVar1": "bitband_address"
            },
            "code": "void set_bit_at_position_000016ec(uint8_t *data, uint8_t position) {\n  uint32_t *bitband_address = bitband_addr(data, (uint32_t)position);\n  *bitband_address = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016ec",
            "calling": [
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpi"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_000016ec"
        },
        "FUN_00004e8c": {
            "renaming": {
                "_strtol_l_isra_0": "convert_string_to_long_int",
                "param_1": "result",
                "param_2": "str",
                "param_3": "end_ptr",
                "param_4": "base",
                "uVar1": "digit_count",
                "uVar2": "current_char",
                "uVar3": "is_hex",
                "uVar4": "digit_value",
                "iVar5": "status",
                "uVar6": "max_value",
                "uVar7": "max_digit_count",
                "pbVar8": "previous_char",
                "pbVar9": "current_char",
                "FUN_00004e8c": "convert_string_to_long_int_00004e8c"
            },
            "code": "uint convert_string_to_long_int_00004e8c(undefined4 *result, byte *str, byte **end_ptr, uint base) {\n  uint digit_value;\n  uint is_negative = 0;\n  uint max_value;\n  int digit_count = 0;\n  uint value = 0;\n  byte *current_char;\n  byte *start_ptr = str;\n  \n  while (isspace(*str)) {\n    str++;\n  }\n  \n  if (*str == '-') {\n    is_negative = 1;\n    str++;\n  } else if (*str == '+') {\n    str++;\n  }\n  \n  if (base == 0) {\n    if (*str != '0') {\n      base = 10;\n    } else if (*(str + 1) == 'x' || *(str + 1) == 'X') {\n      base = 16;\n      str += 2;\n    } else {\n      base = 8;\n    }\n  } else if (base == 16 && *str == '0' && (*(str + 1) == 'x' || *(str + 1) == 'X')) {\n    str += 2;\n  }\n  \n  max_value = UINT_MAX / base;\n  \n  while (isxdigit(*str)) {\n    if (isdigit(*str)) {\n      digit_value = *str - '0';\n    } else {\n      digit_value = toupper(*str) - 'A' + 10;\n    }\n    \n    if (digit_value >= base) {\n      break;\n    }\n    \n    if (digit_count > 0 || digit_value > 0) {\n      if (value > max_value) {\n        digit_count = -1;\n        break;\n      }\n      value *= base;\n      value += digit_value;\n      digit_count++;\n    }\n    \n    str++;\n  }\n  \n  if (digit_count == -1) {\n    *result = UINT_MAX;\n    if (end_ptr == NULL) {\n      return UINT_MAX;\n    }\n  } else {\n    if (is_negative) {\n      value = -value;\n    }\n    \n    if (end_ptr == NULL) {\n      return value;\n    }\n    \n    if (digit_count == 0) {\n      start_ptr--;\n    }\n    \n    *end_ptr = start_ptr;\n  }\n  \n  *result = value;\n  return value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e8c",
            "calling": [
                "_strtol_r",
                "strtol"
            ],
            "imported": false,
            "current_name": "convert_string_to_long_int_00004e8c"
        },
        "FUN_00005100": {
            "renaming": {
                "FUN_00005100": "call_impure_ptr_function_00005100",
                "FUN_00005100_r": "impure_ptr_function"
            },
            "code": "void call_impure_ptr_function_00005100(void)\n{\n  impure_ptr_function(*(undefined4 *)PTR__impure_ptr_00005108);\n  return;\n}",
            "called": [
                "_tzset_unlocked_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005100",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "call_impure_ptr_function_00005100"
        },
        "FUN_00005584": {
            "renaming": {
                "FUN_00005584_t": "DivisionResult",
                "FUN_00005584": "divide_00005584",
                "__numer": "dividend",
                "__denom": "divisor",
                "in_r2": "quotient",
                "iVar1": "remainder",
                "uVar2": "uVar2"
            },
            "code": "typedef struct {\n    uint32_t quotient;\n    int32_t remainder;\n} DivisionResult;\n\nDivisionResult divide_00005584(int32_t divide_00005584nd, int32_t divisor) {\n    uint32_t quotient = (uint32_t)divide_00005584nd / divisor;\n    int32_t remainder = divide_00005584nd - divisor * quotient;\n    if (divide_00005584nd < 0) {\n        if (remainder > 0) {\n            quotient--;\n            remainder += divisor;\n        }\n    }\n    else if (remainder < 0) {\n        quotient++;\n        remainder -= divisor;\n    }\n    DivisionResult result = {quotient, remainder};\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005584",
            "calling": [
                "validate_structure"
            ],
            "imported": false,
            "current_name": "divide_00005584"
        },
        "FUN_00000cb0": {
            "renaming": {
                "FUN_00000cb0": "debug_monitor_handler_00000cb0",
                "PANIC_DEBUG_MON": "panic_debug_mon",
                "PTR_s_DEBUG_MON_HANDLER_00000cbc": "debug_monitor_handler_ptr"
            },
            "code": "void debug_monitor_handler_00000cb0(void)\n{\n  core_panic(PANIC_DEBUG_MON, debug_monitor_handler_00000cb0);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cb0",
            "calling": [],
            "imported": false,
            "current_name": "debug_monitor_handler_00000cb0"
        },
        "FUN_00004248": {
            "renaming": {
                "FUN_00004248": "allocate_memory_00004248",
                "param_1": "size_of_data_block",
                "param_2": "num_of_blocks",
                "puVar1": "memory_block_ptr",
                "iVar2": "total_size_of_blocks"
            },
            "code": "undefined4* allocate_memory_00004248(int size_of_data_block, int num_of_blocks) {\n  undefined4 *memory_block_ptr;\n  int total_size_of_blocks = (num_of_blocks - 1) * 0x68;\n  memory_block_ptr = (undefined4 *) _malloc_r(size_of_data_block, total_size_of_blocks + 0x74);\n  if (memory_block_ptr != (undefined4 *) 0x0) {\n    *memory_block_ptr = 0;\n    memory_block_ptr[1] = num_of_blocks;\n    memory_block_ptr[2] = memory_block_ptr + 3;\n    memset(memory_block_ptr + 3, 0, total_size_of_blocks + 0x68);\n  }\n  return memory_block_ptr;\n}",
            "called": [
                "memset",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004248",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "allocate_memory_00004248"
        },
        "FUN_00000f5c": {
            "renaming": {
                "FUN_00000f5c": "run_main_00000f5c",
                "auto_init": "auto_initialize",
                "iprintf": "print_string"
            },
            "code": "void * run_main_00000f5c(void *arg)\n{\n  auto_initialize();\n  print_string(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  main();\n  return (void *)0x0;\n}",
            "called": [
                "iprintf",
                "main",
                "auto_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f5c",
            "calling": [],
            "imported": false,
            "current_name": "run_main_00000f5c"
        },
        "FUN_00001da2": {
            "renaming": {
                "FUN_00001da2": "get_pin_value_00001da2",
                "pin": "gpio_pin",
                "pin_value": "pin_value"
            },
            "code": "int get_pin_value_00001da2(gpio_t pin) {\n    int pin_value = (pin >> 6) & 7;\n    return pin_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001da2",
            "calling": [
                "clk_en",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "get_pin_value_00001da2"
        },
        "FUN_00001ec4": {
            "renaming": {
                "FUN_00001ec4": "write_context_to_map_00001ec4",
                "port": "port_number",
                "pin": "pin_number",
                "ctx_00": "context"
            },
            "code": "void write_context_to_map_00001ec4(int port_number, int pin_number)\n{\n  int context = get_context(port_number, pin_number);\n  write_to_map(port_number, pin_number, context);\n  return;\n}",
            "called": [
                "write_map",
                "get_ctx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ec4",
            "calling": [
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "write_context_to_map_00001ec4"
        },
        "FUN_00002744": {
            "renaming": {
                "FUN_00002744": "set_interrupt_priority_00002744",
                "IRQn": "irq",
                "priority": "priority",
                "DAT_00002790": "interrupt_priority_base",
                "DAT_00002794": "interrupt_priority_base_dma"
            },
            "code": "void set_interrupt_priority_00002744(IRQn_Type irq, uint32_t priority) {\n  if (irq < DMA0_IRQn) {\n    *(char *)(((byte)irq & 0xf) + DAT_00002790 + 0x14) = (char)((priority & 0xff) << 4);\n  }\n  else {\n    *(char *)(irq + DAT_00002794 + 0x300) = (char)((priority & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002744",
            "calling": [
                "rtt_set_alarm"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_00002744"
        },
        "FUN_00002624": {
            "renaming": {
                "FUN_00002624": "convert_rtt_counter_to_gmtime_00002624",
                "time": "converted_time",
                "t": "counter"
            },
            "code": "int convert_rtt_counter_to_gmtime_00002624(tm *converted_time)\n{\n  time_t counter;\n  counter.seconds = rtt_get_counter();\n  counter.nanoseconds = 0;\n  gmtime_r(&counter, converted_time);\n  return 0;\n}",
            "called": [
                "rtt_get_counter",
                "gmtime_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002624",
            "calling": [
                "_rtc_gettime"
            ],
            "imported": false,
            "current_name": "convert_rtt_counter_to_gmtime_00002624"
        },
        "FUN_00001e0c": {
            "renaming": {
                "FUN_00001e0c": "get_pin_value_00001e0c",
                "port": "port_num",
                "pin": "pin_num",
                "PTR_isr_map_00001e40": "pin_address",
                "uint": "uint32_t",
                "shift": "shift_amount",
                "pin_value": "pin_value"
            },
            "code": "int get_pin_value_00001e0c(int port_num, int pin_num) {\n    uint32_t* PTR_isr_map_00001e40 = (uint32_t*)(PTR_isr_map_00001e40 + ((pin_num >> 3) + port_num * 4) * 4);\n    int shift_amount = (pin_num & 7U) << 2;\n    uint32_t pin_value = *PTR_isr_map_00001e40 >> shift_amount & 0xf;\n    return pin_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e0c",
            "calling": [
                "ctx_clear",
                "irq_handler"
            ],
            "imported": false,
            "current_name": "get_pin_value_00001e0c"
        },
        "FUN_00000ef8": {
            "renaming": {
                "FUN_00000ef8": "do_nothing_00000ef8"
            },
            "code": "\nvoid do_nothing_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ef8",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "do_nothing_00000ef8"
        },
        "FUN_000041d0": {
            "renaming": {
                "FUN_000041d0": "walk_file_000041d0",
                "__stream": "file_pointer",
                "iVar1": "result",
                "PTR__global_impure_ptr_000041e8": "global_impure_ptr",
                "DAT_000041ec": "dat",
                "_FUN_000041d0_r": "_walk_file_r",
                "PTR__impure_ptr_000041f0": "impure_ptr"
            },
            "code": "int walk_file_000041d0(FILE *file_pointer) {\n  int result;\n  if (file_pointer == NULL) {\n    result = _fwalk_reent(*(unsigned int *)PTR__PTR__global_PTR__impure_ptr_000041f0_000041e8_000041e8,DAT_000041ec);\n    return result;\n  }\n  result = _walk_file_000041d0_r(*(unsigned int *)PTR__PTR__impure_ptr_000041f0_000041f0,file_pointer);\n  return result;\n}",
            "called": [
                "_fflush_r",
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041d0",
            "calling": [
                "print_prompt",
                "lflush"
            ],
            "imported": false,
            "current_name": "walk_file_000041d0"
        },
        "FUN_0000459c": {
            "renaming": {
                "FUN_0000459c": "execute_fini_array_0000459c",
                "param_1": "context",
                "puVar1": "pointer_1",
                "puVar2": "pointer_2",
                "iVar3": "num_fini_functions",
                "ppcVar4": "fini_functions",
                "iVar5": "i",
                "num_remaining_fini_functions": "num_remaining_fini_functions"
            },
            "code": "void execute_fini_array_0000459c(EVP_PKEY_CTX *context)\n{\n    int num_fini_functions = (int)PTR___fini_array_end_000045d8 - (int)PTR___fini_array_end_000045d4;\n    code **fini_functions = (code **)PTR___fini_array_end_000045d4;\n    for (int i = 0; i < num_fini_functions >> 2; i++) {\n        context = (EVP_PKEY_CTX *)(*fini_functions)();\n        fini_functions++;\n    }\n    _init(context);\n    fini_functions = (code **)PTR___fini_array_end_000045dc;\n    int num_remaining_fini_functions = (int)PTR___fini_array_end_000045e0 - (int)PTR___fini_array_end_000045dc;\n    for (int i = 0; i < num_remaining_fini_functions >> 2; i++) {\n        (*fini_functions)();\n        fini_functions++;\n    }\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000459c",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "execute_fini_array_0000459c"
        },
        "FUN_000014c4": {
            "renaming": {
                "FUN_000014c4": "configure_uart_000014c4",
                "uart": "uart_t",
                "baudrate": "uint32_t",
                "pbVar1": "config",
                "uVar2": "config_value",
                "uVar3": "divisor",
                "txfifo_size": "txfifo_size",
                "brfa": "brfa",
                "ubd": "ubd",
                "clk": "clk",
                "dev": "dev",
                "PTR_uart_config_000015cc": "uart_config"
            },
            "code": "void configure_uart_000014c4(uart_t uart, uint32_t baudrate) {\n  byte *config = *(byte **)(PTR_uart_config_000015cc + uart * 0x20);\n  uint32_t config_value = *(uint *)(PTR_uart_config_000015cc + uart * 0x20 + 4);\n  config[3] &= 0xf3;\n  config[2] = PTR_uart_config_000015cc[uart * 0x20 + 0x1d];\n  uint32_t divisor = config_value / (baudrate << 4);\n  config[0] = (byte)(divisor >> 8) & 0x1f;\n  config[1] = (byte)divisor;\n  config[10] = (byte)((config_value << 2) / baudrate + 1 >> 1) & 0x1f;\n  config[0x10] |= 0x88;\n  if ((config[0x10] & 0x70) == 0) {\n    config[0x13] = 0;\n  }\n  else {\n    config[0x13] = (char)(2 << (config[0x10] >> 4 & 7)) - 1;\n  }\n  config[0x15] = 1;\n  config[0x11] = 0xc0;\n  config[3] |= 0x2c;\n  NVIC_EnableIRQ(PTR_uart_config_000015cc[uart * 0x20 + 0x14]);\n  return;\n}",
            "called": [
                "NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000014c4",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "configure_uart_000014c4"
        },
        "FUN_00004b34": {
            "renaming": {
                "FUN_00004b34": "allocate_memory_00004b34",
                "param_1": "error_code",
                "param_2": "size",
                "param_3": "zero",
                "param_4": "zero2",
                "puVar1": "pointer_to_memory",
                "piVar2": "pointer_to_block_size",
                "extraout_r1": "temp_pointer",
                "ppiVar3": "prev_block_size",
                "ppiVar4": "prev_block_pointer",
                "ppiVar5": "free_list_pointer",
                "ppiVar6": "lower_bound_pointer",
                "bVar7": "is_same_as_next"
            },
            "code": "void allocate_memory_00004b34(int *error_code, int size, int zero, int zero2)\n{\n  int **lower_bound;\n  int **free_list;\n  int **prev_free_list;\n  int **prev_block;\n  bool is_same_as_next;\n  \n  if (size == 0) {\n    return;\n  }\n  \n  lower_bound = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    lower_bound = (int **)((int)lower_bound + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  free_list = *(int ***)PTR___malloc_free_list_00004bcc;\n  prev_free_list = (int **)0x0;\n  \n  while ((free_list != (int **)0x0) && (free_list < lower_bound)) {\n    prev_free_list = free_list;\n    free_list = (int **)free_list[1];\n  }\n  \n  prev_block = (int **)*prev_free_list;\n  is_same_as_next = (int **)((int)prev_free_list + (int)prev_block) == lower_bound;\n  \n  if (is_same_as_next) {\n    prev_block = (int **)*free_list;\n    free_list = (int **)free_list[1];\n  }\n  \n  lower_bound[1] = (int *)free_list;\n  if (is_same_as_next) {\n    lower_bound = (int **)((int)lower_bound + (int)prev_block);\n    *prev_free_list = (int *)lower_bound;\n  }\n  else {\n    prev_free_list[1] = (int *)lower_bound;\n  }\n  __malloc_unlock(error_code,prev_block,prev_free_list,zero2);\n  return;\n}",
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004b34",
            "calling": [
                "__ssrefill_r",
                "_realloc_r",
                "__srefill_r",
                "__sflush_r",
                "free",
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00004b34"
        },
        "FUN_000004f2": {
            "renaming": {
                "FUN_000004f2": "set_error_and_return_invalid_offset_000004f2",
                "r": "reent",
                "fd": "file_descriptor",
                "pos": "position",
                "dir": "direction"
            },
            "code": "_off_t set_error_and_return_invalid_offset_000004f2(_reent *reent, int file_descriptor, _off_t position, int direction) {\n  reent->_errno = 0x13;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004f2",
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "imported": false,
            "current_name": "set_error_and_return_invalid_offset_000004f2"
        },
        "FUN_0000423c": {
            "renaming": {
                "FUN_0000423c": "walk_filesystem_and_free_resources_reentrantly_0000423c",
                "param_1": "reentrancy_structure"
            },
            "code": "void walk_filesystem_and_free_resources_reentrantly_0000423c(void* reentrancy_structure){\n  _fwalk_reent(reentrancy_structure, DAT_00004244);\n  return;\n}",
            "called": [
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000423c",
            "calling": [],
            "imported": false,
            "current_name": "walk_filesystem_and_free_resources_reentrantly_0000423c"
        },
        "FUN_00004e66": {
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "__s1": "string1",
                "__s2": "string2",
                "__n": "length",
                "pbVar1": "byte_ptr1",
                "pbVar2": "byte_ptr2",
                "uVar3": "current_char"
            },
            "code": "int compare_strings_00004e66(char* string1, char* string2, size_t length) {\n    byte* byte_ptr1;\n    byte* byte_ptr2;\n    uint32_t current_char;\n    \n    if (length != 0) {\n        byte_ptr2 = (byte*)(string2 + length - 1);\n        byte_ptr1 = (byte*)string1;\n        do {\n            current_char = (uint32_t)*byte_ptr1;\n            byte_ptr2++;\n            if ((current_char != *byte_ptr2) || (byte_ptr1 + 1 == (byte*)(string1 + length))) {\n                break;\n            }\n            byte_ptr1++;\n        } while (current_char != 0);\n        length = current_char - *byte_ptr2;\n    }\n    return length;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e66",
            "calling": [
                "_findenv_r",
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e66"
        },
        "FUN_00005ecc": {
            "renaming": {
                "FUN_00005ecc": "find_string_length_00005ecc",
                "__s": "input_string",
                "pcVar3": "current_ptr",
                "pcVar2": "next_ptr",
                "cVar1": "current_char"
            },
            "code": "size_t find_string_length_00005ecc(char* input_string) {\n  char current_char;\n  char* current_ptr = input_string;\n  \n  do {\n    current_char = *current_ptr;\n    current_ptr++;\n  } while (current_char != \"\\0\");\n  \n  size_t string_length = (size_t)(current_ptr - 1 - (int)input_string);\n  \n  return string_length;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ecc",
            "calling": [
                "_tzset_unlocked_r",
                "siscanf"
            ],
            "imported": false,
            "current_name": "find_string_length_00005ecc"
        },
        "FUN_0000129c": {
            "renaming": {
                "_FUN_0000129c": "lock_mutex",
                "mutex": "mutex",
                "FUN_0000129c": "lock_mutex_0000129c"
            },
            "code": "void lock_mutex_0000129c(mutex_t *mutex)\n{\n  lock_mutex_0000129c_with_timeout(mutex, 1);\n  return;\n}",
            "called": [
                "_mutex_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000129c",
            "calling": [
                "isrpipe_read"
            ],
            "imported": false,
            "current_name": "lock_mutex_0000129c"
        },
        "FUN_00001628": {
            "renaming": {
                "FUN_00001628": "transmit_data_00001628",
                "uart": "uart_t",
                "dev": "uart_config",
                "data": "data",
                "PTR_uart_config_00001680": "PTR_uart_config_00001680",
                "PTR_config_00001684": "PTR_config_00001684"
            },
            "code": "void transmit_data_00001628(uart_t uart)\n{\n  uint8_t data;\n  UART_Type *uart_config;\n  \n  uart_config = (UART_Type *)(*(uint32_t *)(PTR_uart_config_00001680 + uart * 0x20));\n  \n  if (((*(uint8_t *)(uart_config + 4) & 0x20) != 0) && (*(uint32_t *)(PTR_config_00001684 + uart * 8) != 0)) \n  {\n    (*(void (**)(uint32_t, uint8_t))(PTR_config_00001684 + uart * 8))( *(uint32_t *)(PTR_config_00001684 + uart * 8 + 4),*(uint8_t *)(uart_config + 7));\n  }\n  cortexm_isr_end();\n  return;\n}",
            "called": [
                "cortexm_isr_end"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001628",
            "calling": [
                "isr_uart0_rx_tx"
            ],
            "imported": false,
            "current_name": "transmit_data_00001628"
        },
        "FUN_00001748": {
            "renaming": {
                "FUN_00001748": "set_kinetis_mcg_fll_factor_00001748",
                "factor": "new_factor",
                "DAT_00001774": "PTR_DAT_00001774",
                "KINETIS_MCG_FLL_FACTOR_2929": "FLL_FACTOR_2929"
            },
            "code": "void set_kinetis_mcg_fll_factor_00001748(kinetis_mcg_fll_t factor) {\n  kinetis_mcg_fll_t *fll_factor_ptr = (kinetis_mcg_fll_t *)(DAT_00001774 + 3);\n  kinetis_mcg_fll_t current_fll_factor = *fll_factor_ptr;\n  kinetis_mcg_fll_t new_fll_factor = factor | (current_fll_factor & ~KINETIS_MCG_FLL_FACTOR_2929);\n  *fll_factor_ptr = new_fll_factor;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001748",
            "calling": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "set_kinetis_mcg_fll_factor_00001748"
        },
        "FUN_0000294c": {
            "renaming": {
                "FUN_0000294c": "set_rtc_alarm_0000294c",
                "DAT_0000296c": "DAT_RTC_ALARM_REGISTER_ADDRESS",
                "PTR_": "rtc_instance",
                "DAT_": "alarm_",
                "rtt": "rtc_instance",
                "*(uint *)(DAT_0000296c + 0x14)": "alarm_register_value",
                "*(uint *)(DAT_0000296c + 0x14) | 0x10": "alarm_register_value | DAT_RTC_ALARM_BITMASK"
            },
            "code": "void set_rtc_alarm_0000294c(void)\n{\n  RTC_Type *PTR_ = PTR_RTC;\n  uint32_t DAT_register_address = DAT_0000296c;\n  uint32_t *(uint *)(DAT_0000296c + 0x14) = *(uint32_t *)(DAT_register_address);\n  uint32_t DAT_bitmask = DAT_RTC_ALARM_BITMASK;\n  *(uint32_t *)(DAT_register_address) = *(uint *)(DAT_0000296c + 0x14) | DAT_bitmask;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000294c",
            "calling": [
                "rtt_init",
                "rtc_poweron"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_0000294c"
        },
        "FUN_00005790": {
            "renaming": {
                "FUN_00005790": "acquire_malloc_recursive_mutex_00005790",
                "PTR___lock___malloc_recursive_mutex_00005798": "malloc_recursive_mutex"
            },
            "code": "void acquire_malloc_recursive_mutex_00005790(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___malloc_recursive_mutex_00005798);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005790",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "acquire_malloc_recursive_mutex_00005790"
        },
        "FUN_00000534": {
            "renaming": {
                "FUN_00000534": "check_standard_file_descriptor_00000534",
                "r": "reent",
                "fd": "file_descriptor",
                "iVar1": "is_standard_file_descriptor"
            },
            "code": "int check_standard_file_descriptor_00000534(_reent *reent, int file_descriptor) {\n    int is_standard_file_descriptor;\n    reent->_errno = 0;\n    if (file_descriptor == STDIN_FILENO || file_descriptor == STDOUT_FILENO || file_descriptor == STDERR_FILENO) {\n        is_standard_file_descriptor = 1;\n    } else {\n        is_standard_file_descriptor = 0;\n    }\n    return is_standard_file_descriptor;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000534",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_standard_file_descriptor_00000534"
        },
        "FUN_000017dc": {
            "renaming": {
                "FUN_000017dc": "set_bit_and_check_flag_000017dc",
                "DAT_00001820": "data_register_1",
                "DAT_00001824": "data_register_2",
                "DAT_00001828": "data_register_3"
            },
            "code": "void set_bit_and_check_flag_000017dc(void)\n{\n  set_bit32(DAT_00001820, 29);\n  if ((*(uint *)(DAT_00001824 + 16) & 0x100) == 0) {\n    *(uint *)(DAT_00001824 + 16) = 0x104;\n  }\n  *DAT_00001828 = *DAT_00001828 & 0xfff3ffff | 0x80000;\n  return;\n}",
            "called": [
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000017dc",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_bit_and_check_flag_000017dc"
        },
        "FUN_00000410": {
            "renaming": {
                "FUN_00000410": "print_uart_stdio_00000410",
                "ctx": "context",
                "uart_stdioFUN_00000410": "uart_stdio"
            },
            "code": "int print_uart_stdio_00000410(EVP_PKEY_CTX *context) {\n  uart_stdio();\n  return (int)context;\n}",
            "called": [
                "uart_stdio_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000410",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "print_uart_stdio_00000410"
        },
        "FUN_000005ca": {
            "renaming": {
                "FUN_000005ca": "remove_second_000005ca",
                "list": "first_node",
                "plVar1": "second_next"
            },
            "code": "clist_node_t* remove_second_000005ca(clist_node_t* list)\n{\n  list_node* second_next = NULL;\n  clist_node_t* first = NULL;\n  \n  if (list->next == NULL)\n  {\n    second_next = NULL;\n  }\n  else\n  {\n    second_next = list->next->next;\n    if (second_next == list->next)\n    {\n      list->next = NULL;\n    }\n    else\n    {\n      list->next->next = second_next->next;\n    }\n  }\n  return second_next;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000005ca",
            "calling": [
                "sched_set_status"
            ],
            "imported": false,
            "current_name": "remove_second_000005ca"
        },
        "FUN_000043da": {
            "renaming": {
                "FUN_000043da": "process_data_000043da",
                "param_1": "data_address",
                "param_2": "processor",
                "param_3": "param_3",
                "param_4": "param_4",
                "piVar3": "current_data",
                "uVar5": "result",
                "iVar6": "count",
                "iVar4": "current_item",
                "uVar1": "processed_data"
            },
            "code": "uint process_data_000043da(int data_address, code* processor, undefined4 param_3, undefined4 param_4)\n{\n  uint result = 0;\n  int* current_data = (int*)(data_address + 0x48);\n  do {\n    int count = current_data[1];\n    int current_item = current_data[2];\n    while (count-- > 0) {\n      if (*(ushort*)(current_item + 0xc) > 1 && *(short*)(current_item + 0xe) != 0) {\n        uint processed_data = (*processor)(data_address, current_item, param_3, *(short*)(current_item + 0xe) + 1, param_4);\n        result |= processed_data;\n      }\n      current_item += 0x68;\n    }\n    current_data = (int*)*current_data;\n  } while (current_data != (int*)0x0);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043da",
            "calling": [
                "_cleanup_r",
                "fflush"
            ],
            "imported": false,
            "current_name": "process_data_000043da"
        },
        "FUN_00005ff8": {
            "renaming": {
                "FUN_00005ff8": "release_recursive_mutex_00005ff8",
                "PTR___lock___env_recursive_mutex_00006000": "lock_env_recursive_mutex"
            },
            "code": "void release_recursive_mutex_00005ff8(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___env_recursive_mutex_00006000);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ff8",
            "calling": [
                "_findenv_r"
            ],
            "imported": false,
            "current_name": "release_recursive_mutex_00005ff8"
        },
        "FUN_00006754": {
            "renaming": {
                "FUN_00006754": "flush_if_buffer_full_00006754",
                "param_1": "file",
                "iVar1": "flush_result",
                "ushort": "unsigned_short"
            },
            "code": "int flush_if_buffer_full_00006754(FILE *file) {\n  int flush_result;\n  if ((*(ushort *)&file->_IO_read_base & 9) == 9) {\n    flush_result = fflush(file);\n    return flush_result;\n  }\n  return 0;\n}",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006754",
            "calling": [],
            "imported": false,
            "current_name": "flush_if_buffer_full_00006754"
        },
        "FUN_00002714": {
            "renaming": {
                "FUN_00002714": "setInterruptPriority_00002714",
                "IRQn": "interrupt",
                "DAT_00002740": "interruptRegisterBaseAddress"
            },
            "code": "void setInterruptPriority_00002714(IRQn_Type interrupt)\n{\n    int* interruptRegister = (int*)(DAT_00002740 + ((uint)(int)interrupt >> 5) * 4);\n    int bitPosition = IRQn & 0x1fU;\n    int interruptBit = 1 << bitPosition;\n    *interruptRegister = interruptBit;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002714",
            "calling": [
                "rtt_set_alarm"
            ],
            "imported": false,
            "current_name": "setInterruptPriority_00002714"
        },
        "FUN_000020e0": {
            "renaming": {
                "FUN_000020e0": "handle_irq_000020e0",
                "DAT_000020f0": "interrupt_data"
            },
            "code": "void handle_irq_000020e0(void)\n{\n  irq_handler(DAT_000020f0, 2);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020e0",
            "calling": [],
            "imported": false,
            "current_name": "handle_irq_000020e0"
        },
        "FUN_00004f80": {
            "renaming": {
                "FUN_00004f80": "parse_integer_00004f80",
                "param_1": "result",
                "param_2": "input_string",
                "param_3": "end_pointer",
                "param_4": "base",
                "uVar1": "running_value",
                "uVar2": "digit_value",
                "uVar3": "is_negative",
                "uVar4": "current_digit",
                "uVar6": "overflow_threshold",
                "uVar7": "shift_amount",
                "iVar5": "read_status",
                "pbVar8": "temp_ptr",
                "pbVar9": "string_ptr"
            },
            "code": "uint parse_integer_00004f80(undefined4 *result, byte *input_string, byte **end_pointer, uint base) {\n  uint digit_value;\n  uint is_negative;\n  uint overflow_threshold;\n  int read_status;\n  uint running_value;\n  uint shift_amount;\n  byte *string_ptr;\n  byte *temp_ptr;\n\n  string_ptr = input_string;\n  do {\n    temp_ptr = string_ptr;\n    string_ptr = temp_ptr + 1;\n    digit_value = (uint)*temp_ptr;\n    is_negative = (byte)PTR_DAT_00004f7c[digit_value] & 8;\n  } while ((PTR_DAT_00004f7c[digit_value] & 8) != 0);\n\n  if (digit_value == 0x2d) {\n    digit_value = (uint)*string_ptr;\n    is_negative = 1;\n    string_ptr = temp_ptr + 2;\n  }\n  else if (digit_value == 0x2b) {\n    digit_value = (uint)*string_ptr;\n    string_ptr = temp_ptr + 2;\n  }\n\n  if (base == 0) {\n    if (digit_value != 0x30) {\n      base = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((base != 16) || (digit_value != 0x30)) {\n    goto LAB_00004ed6;\n  }\n\n  if ((*string_ptr & 0xdf) == 0x58) {\n    digit_value = (uint)string_ptr[1];\n    base = 16;\n    string_ptr += 2;\n  }\n  else {\n    digit_value = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\n\nLAB_00004ed6:\n  overflow_threshold = is_negative + 0x7fffffff;\n  read_status = 0;\n  shift_amount = overflow_threshold / base;\n  running_value = 0;\n\n  do {\n    uint current_digit = digit_value - 0x30;\n    if (9 < current_digit) {\n      if (digit_value - 0x41 < 0x1a) {\n        current_digit = digit_value - 0x37;\n      }\n      else {\n        if (0x19 < digit_value - 0x61) break;\n        current_digit = digit_value - 0x57;\n      }\n    }\n\n    if ((int)base <= (int)current_digit) break;\n\n    if (read_status != -1) {\n      if ((shift_amount < running_value) || ((shift_amount == running_value && ((int)(overflow_threshold - base * shift_amount) < (int)current_digit))))) {\n        read_status = -1;\n      }\n      else {\n        running_value = running_value * base + current_digit;\n        read_status = 1;\n      }\n    }\n\n    digit_value = (uint)*string_ptr;\n    string_ptr += 1;\n\n  } while(true);\n\n  if (read_status == -1) {\n    *result = 0x22;\n    running_value = overflow_threshold;\n    if (end_pointer == (byte **)0x0) {\n      return overflow_threshold;\n    }\n  }\n  else {\n    if (is_negative != 0) {\n      running_value = -running_value;\n    }\n    if (end_pointer == (byte **)0x0) {\n      return running_value;\n    }\n    if (read_status == 0) {\n      goto LAB_00004f64;\n    }\n  }\n  temp_ptr = string_ptr - 1;\nLAB_00004f64:\n  *end_pointer = temp_ptr;\n  return running_value;\n}",
            "called": [
                "_strtol_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f80",
            "calling": [],
            "imported": false,
            "current_name": "parse_integer_00004f80"
        },
        "FUN_00005fec": {
            "renaming": {
                "FUN_00005fec": "acquire_recursive_lock_00005fec",
                "PTR___lock___env_recursive_mutex_00005ff4": "PTR_recursive_lock"
            },
            "code": "void acquire_recursive_lock_00005fec(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___env_recursive_mutex_00005ff4);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fec",
            "calling": [
                "_findenv_r"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_00005fec"
        },
        "FUN_00004f84": {
            "renaming": {
                "FUN_00004f84": "parse_long_00004f84",
                "__nptr": "input_string",
                "__endptr": "end_pointer",
                "__base": "base",
                "lVar1": "result"
            },
            "code": "long parse_long_00004f84(char* input_string, char** end_pointer, int base) {\n  long result = strtol(*(int*)PTR__impure_ptr_00004f94, input_string, end_pointer, base);\n  return result;\n}",
            "called": [
                "_strtol_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f84",
            "calling": [
                "atoi",
                "_parse_time"
            ],
            "imported": false,
            "current_name": "parse_long_00004f84"
        },
        "FUN_000028f0": {
            "renaming": {
                "FUN_000028f0": "get_RTC_Type_value_000028f0",
                "rtt": "rtc_type_ptr",
                "DAT_0000290c": "DAT_RTC_Type"
            },
            "code": "uint32_t get_RTC_Type_value_000028f0(void)\n{\n  RTC_Type *rtc_type_ptr = (RTC_Type *)(DAT_0000290c + 8);\n  uint32_t rtc_type_value = *(uint32_t *)(rtc_type_ptr);\n  return rtc_type_value + 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000028f0",
            "calling": [
                "rtc_get_alarm"
            ],
            "imported": false,
            "current_name": "get_RTC_Type_value_000028f0"
        },
        "FUN_00004f98": {
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "param_1": "year",
                "puVar1": "tzinfo",
                "uVar2": "result",
                "uVar3": "temp",
                "iVar4": "day_offset",
                "puVar5": "month_info",
                "iVar6": "days_since_1900",
                "uVar7": "leap_year_offset",
                "iVar8": "day_of_week",
                "iVar9": "day_offset_adjustment",
                "uVar10": "leap_year_count"
            },
            "code": "uint32_t calculate_day_of_week_00004f98(uint32_t year)\n{\n    uint32_t* tzinfo = (uint32_t*)__gettzinfo();\n    if (year < 0x7b2)\n    {\n        return 0;\n    }\n    else\n    {\n        uint32_t leap_year_count = count_leading_zeroes(year % 400);\n        uint32_t days_since_1900 = (year - 0x7b2) * 365 + ((year - 0x7b1) >> 2) - (year - 0x641) / 100 + (year - 0x5b9) / 400 + leap_year_count;\n        tzinfo[1] = year;\n        uint32_t* month_info = tzinfo;\n        do\n        {\n            uint32_t month_days = month_info[5];\n            if (month_info[2] == 'J')\n            {\n                bool is_leap_year = ((year & 3) == 0) && (year % 100 != 0) || (year % 400 == 0);\n                month_days += days_since_1900 + (is_leap_year ? 1 : 0) - 1;\n            }\n            else if (month_info[2] == 'D')\n            {\n                month_days += days_since_1900;\n            }\n            else\n            {\n                uint32_t leap_year_offset = leap_year_count >> 5;\n                if (((year & 3) == 0) && (year % 100 != 0))\n                {\n                    leap_year_offset = 1;\n                }\n                uint32_t month_offset = 0;\n                for (int i = 1; i < month_info[3]; i++)\n                {\n                    month_offset += *(int32_t*)(PTR___month_lengths_000050e4 + i * 4 + leap_year_offset * 0x30 + -4);\n                }\n                uint32_t day_offset = month_info[10] + month_offset + month_info[6];\n                int32_t day_of_week = (day_offset + 4) % 7;\n                month_days += day_offset + (day_of_week < month_info[4] ? month_info[4] - day_of_week : 7 - day_of_week + month_info[4]);\n            }\n            month_info[8] = month_days;\n            month_info[9] = month_days >> 31;\n            month_info += 10;\n        } while (tzinfo + 0x14 != month_info);\n        uint32_t days_since_epoch = tzinfo[9];\n        uint32_t epoch_leap_year_count = tzinfo[0x13];\n        *tzinfo = (uint32_t)((int)((days_since_epoch - epoch_leap_year_count) - (tzinfo[8] < tzinfo[0x12])) < 0 != (SBORROW4(days_since_epoch, epoch_leap_year_count) != SBORROW4(days_since_epoch - epoch_leap_year_count, (uint32_t)(tzinfo[8] < tzinfo[0x12]))));\n        return 1;\n    }\n}",
            "called": [
                "__gettzinfo"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f98",
            "calling": [
                "mktime",
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_00004f98"
        },
        "FUN_00004dee": {
            "renaming": {
                "FUN_00004dee": "write_to_file_00004dee",
                "param_1": "reent",
                "param_2": "fd",
                "param_3": "data",
                "param_4": "size",
                "flag": "fd_flag"
            },
            "code": "void write_to_file_00004dee(_reent *reent, int fd, void *data, size_t size) {\n    ushort *flag = (ushort *)(fd + 0xc);\n    if ((int)((uint)*flag << 0x17) < 0) {\n        _lseek_r(reent, (int)*(short *)(fd + 0xe), 0, 2);\n    }\n    *flag = *flag & 0xefff;\n    _write_r(reent, (int)*(short *)(fd + 0xe), data, size);\n}",
            "called": [
                "_lseek_r",
                "_write_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dee",
            "calling": [],
            "imported": false,
            "current_name": "write_to_file_00004dee"
        },
        "FUN_00000fec": {
            "renaming": {
                "FUN_00000fec": "initialize_circular_buffer_00000fec",
                "cib_t": "circular_buffer_t",
                "size": "buffer_size",
                "c": "temp_buffer",
                "PTR_assert_crash_message_00001030": "assert_crash_message",
                "read_count": "read_count",
                "write_count": "write_count",
                "mask": "mask"
            },
            "code": "void initialize_circular_buffer_00000fec(circular_buffer_t *buffer, uint32_t size)\n{\n  circular_buffer_t temp_buffer;\n  if ((size & (size - 1)) != 0) {\n    core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_00001030);\n  }\n  buffer->read_count = 0;\n  buffer->write_count = 0;\n  buffer->mask = size - 1;\n  return;\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000fec",
            "calling": [
                "thread_create"
            ],
            "imported": false,
            "current_name": "initialize_circular_buffer_00000fec"
        },
        "FUN_00000428": {
            "renaming": {
                "FUN_00000428": "allocate_memory_00000428",
                "r": "reent",
                "incr": "increment",
                "state_00": "state_before",
                "state": "state_after",
                "res": "result"
            },
            "code": "void * allocate_memory_00000428(_reent *reent, ptrdiff_t increment)\n{\n  uint state_before;\n  uint state_after;\n  void *result;\n  \n  state_before = irq_disable();\n  result = *(void **)PTR_heap_top_00000484;\n  if ((PTR__eram_00000488 < (undefined *)(increment + *(int *)PTR_heap_top_00000484)) ||\n     ((undefined *)(increment + *(int *)PTR_heap_top_00000484) < PTR__sheap_0000048c)) \n  {\n    reent->_errno = 0xc;\n    result = (void *)0xffffffff;\n  }\n  else \n  {\n    *(ptrdiff_t *)PTR_heap_top_00000484 = increment + *(int *)PTR_heap_top_00000484;\n  }\n  state_after = irq_restore(state_before);\n  return result;\n}",
            "called": [
                "irq_disable",
                "irq_restore"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000428",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00000428"
        },
        "FUN_000039e8": {
            "renaming": {
                "FUN_000039e8": "getClassFromId_000039e8"
            },
            "code": "char * getClassFromId_000039e8(uint8_t class_id)\n{\n    char *class_name = PTR_s_CLASS_UNKNOWN_00003d20;\n\n    switch(class_id) {\n        case '\\0':\n            class_name = PTR_s_CLASS_UNDEF_00003cc0;\n            break;\n        case '@':\n            class_name = PTR_s_ACT_ANY_00003cc4;\n            break;\n        case 'B':\n            class_name = PTR_s_ACT_LED_RGB_00003cc8;\n            break;\n        case 'C':\n            class_name = PTR_s_ACT_SERVO_00003ccc;\n            break;\n        case 'D':\n            class_name = PTR_s_ACT_MOTOR_00003cd0;\n            break;\n        case 'E':\n            class_name = PTR_s_ACT_SWITCH_00003cd4;\n            break;\n        case 'F':\n            class_name = PTR_s_ACT_DIMMER_00003cd8;\n            break;\n        case 0x80:\n            class_name = PTR_s_SENSE_ANY_00003cdc;\n            break;\n        case 0x81:\n            class_name = PTR_s_SENSE_BTN_00003ce0;\n            break;\n        case 0x82:\n            class_name = PTR_s_SENSE_TEMP_00003ce4;\n            break;\n        case 0x83:\n            class_name = PTR_s_SENSE_HUM_00003ce8;\n            break;\n        case 0x84:\n            class_name = PTR_s_SENSE_LIGHT_00003cec;\n            break;\n        case 0x85:\n            class_name = PTR_s_SENSE_ACCEL_00003cf0;\n            break;\n        case 0x86:\n            class_name = PTR_s_SENSE_MAG_00003cf4;\n            break;\n        case 0x87:\n            class_name = PTR_s_SENSE_GYRO_00003cf8;\n            break;\n        case 0x88:\n            class_name = PTR_s_SENSE_COLOR_00003cfc;\n            break;\n        case 0x89:\n            class_name = PTR_s_SENSE_PRESS_00003d00;\n            break;\n        case 0x8a:\n            class_name = PTR_s_SENSE_ANALOG_00003d04;\n            break;\n        case 0x8b:\n            class_name = PTR_s_SENSE_UV_00003d08;\n            break;\n        case 0x8c:\n            class_name = PTR_s_SENSE_OBJTEMP_00003d0c;\n            break;\n        case 0x8d:\n            class_name = PTR_s_SENSE_PULSE_COUNT_00003d10;\n            break;\n        case 0x8e:\n            class_name = PTR_s_SENSE_DISTANCE_00003d14;\n            break;\n        case 0x8f:\n            class_name = PTR_s_SENSE_CO2_00003d18;\n            break;\n        case 0xff:\n            return PTR_s_CLASS_ANY_00003d1c;\n        default:\n            break;\n    }\n    return class_name;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000039e8",
            "calling": [
                "probe",
                "list"
            ],
            "imported": false,
            "current_name": "getClassFromId_000039e8"
        },
        "FUN_00000e38": {
            "renaming": {
                "FUN_00000e38": "send_data_over_uart_00000e38",
                "buffer": "data_buffer",
                "len": "buffer_len"
            },
            "code": "int send_data_over_uart_00000e38(char *data_buffer, int buffer_len) {\n  uart_write(0, (uint8_t *)data_buffer, buffer_len);\n  return buffer_len;\n}",
            "called": [
                "uart_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e38",
            "calling": [
                "_write_r"
            ],
            "imported": false,
            "current_name": "send_data_over_uart_00000e38"
        },
        "FUN_00002294": {
            "renaming": {
                "FUN_00002294": "is_ring_buffer_full_00002294",
                "rb": "ring_buffer",
                "uVar2": "buffer_size",
                "bVar3": "is_full",
                "bVar1": "is_buffer_full"
            },
            "code": "bool is_ring_buffer_full_00002294(tsrb_t *ring_buffer)\n{\n  uint32_t buffer_size = ring_buffer->size;\n  bool is_full = (ring_buffer->writes - ring_buffer->reads == buffer_size);\n  return is_full;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002294",
            "calling": [
                "tsrb_add_one"
            ],
            "imported": false,
            "current_name": "is_ring_buffer_full_00002294"
        },
        "FUN_00003e9e": {
            "renaming": {
                "FUN_00003e9e": "format_integer_to_decimal_fixed_point_00003e9e",
                "out": "output_buffer",
                "val": "input_value",
                "fp_digits": "fixed_point_digits",
                "sVar1": "formatted_size"
            },
            "code": "size_t format_integer_to_decimal_fixed_point_00003e9e(char *output_buffer, int16_t input_value, int fixed_point_digits) {\n  size_t formatted_size = fmt_s32_dfp(output_buffer, (int)input_value, fixed_point_digits);\n  return formatted_size;\n}",
            "called": [
                "fmt_s32_dfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e9e",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "format_integer_to_decimal_fixed_point_00003e9e"
        },
        "FUN_00003378": {
            "renaming": {
                "FUN_00003378": "print_formatted_time_00003378",
                "time": "time",
                "PTR_s__04i__02i__02i__02i__02i__02i_000033bc": "iprintf_format_string",
                "tm_year": "year",
                "tm_mon": "month",
                "tm_mday": "day",
                "tm_hour": "hour",
                "tm_min": "minute",
                "tm_sec": "second"
            },
            "code": "int print_formatted_time_00003378(tm *time)\n{\n  int year_offset = 1900;\n  int year = time->tm_year + year_offset;\n  int month = time->tm_mon + 1;\n  int day = time->tm_mday;\n  int hour = time->tm_hour;\n  int minute = time->tm_min;\n  int second = time->tm_sec;\n  iprintf(\"%04d-%02d-%02d %02d:%02d:%02d\\n\", year, month, day, hour, minute, second);\n  return 0;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003378",
            "calling": [
                "_rtc_getalarm",
                "_rtc_gettime"
            ],
            "imported": false,
            "current_name": "print_formatted_time_00003378"
        },
        "FUN_00006768": {
            "renaming": {
                "FUN_00006768": "file_io_handler_00006768",
                "param_1": "file",
                "param_2": "stream",
                "param_3": "buffer_size",
                "param_4": "flags",
                "uVar1": "mode",
                "iVar2": "result",
                "uVar3": "ret_value",
                "uVar4": "mode_flags",
                "uVar5": "buffer_size_uint"
            },
            "code": "undefined4 file_io_handler_00006768(undefined4 *file, undefined4 *stream, undefined4 buffer_size, undefined4 flags)\n{\n    undefined2 mode;\n    int result;\n    undefined4 ret_value;\n    ushort mode_flags;\n    uint buffer_size_uint;\n\n    if ((file != (undefined4 *)0x0) && (file[6] == 0)) {\n        __sinit();\n    }\n\n    if (stream == (undefined4 *)PTR___sf_fake_stdin_00006868) {\n        stream = (undefined4 *)file[1];\n    }\n    else if (stream == (undefined4 *)PTR___sf_fake_stdout_0000686c) {\n        stream = (undefined4 *)file[2];\n    }\n    else if (stream == (undefined4 *)PTR___sf_fake_stderr_00006870) {\n        stream = (undefined4 *)file[3];\n    }\n\n    mode_flags = *(ushort *)(stream + 3);\n    stream[1] = 0;\n    buffer_size_uint = (uint)*(ushort *)(stream + 3);\n\n    if ((int)(buffer_size_uint << 0x1a) < 0) {\n        return 0xffffffff;\n    }\n\n    if ((int)(buffer_size_uint << 0x1d) < 0) {\n        if ((undefined4 *)stream[0xd] != (undefined4 *)0x0) {\n            if ((undefined4 *)stream[0xd] != stream + 0x11) {\n                _free_r(file);\n            }\n            stream[1] = stream[0x10];\n            stream[0xd] = 0;\n            if (stream[0x10] != 0) {\n                *stream = stream[0xf];\n                return 0;\n            }\n        }\n    }\n    else {\n        if (-1 < (int)(buffer_size_uint << 0x1b)) {\n            *file = 9;\n            mode_flags = mode_flags | 0x40;\n            goto LAB_000067b8;\n        }\n        if ((int)(buffer_size_uint << 0x1c) < 0) {\n            result = _fflush_r(file, stream, buffer_size_uint << 0x1c, buffer_size_uint, flags);\n            if (result != 0) {\n                return 0xffffffff;\n            }\n            stream[2] = 0;\n            *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xfff7;\n            stream[6] = 0;\n        }\n        *(ushort *)(stream + 3) = *(ushort *)(stream + 3) | 4;\n    }\n\n    if (stream[4] == 0) {\n        __smakebuf_r(file, stream);\n    }\n\n    mode_flags = *(ushort *)(stream + 3);\n    mode = *(undefined2 *)(stream + 3);\n\n    if ((mode_flags & 3) != 0) {\n        *(undefined2 *)(stream + 3) = 1;\n        _fwalk(*(undefined4 *)PTR__global_impure_ptr_00006874, DAT_00006878);\n        *(undefined2 *)(stream + 3) = mode;\n        if ((mode_flags & 9) == 9) {\n            __sflush_r(file, stream);\n        }\n    }\n\n    ret_value = stream[4];\n    *stream = ret_value;\n    result = (*(code *)stream[9])(file, stream[8], ret_value, stream[5]);\n    stream[1] = result;\n\n    if (0 < result) {\n        return 0;\n    }\n\n    mode_flags = *(ushort *)(stream + 3);\n\n    if (result != 0) {\n        ret_value = 0;\n    }\n    else {\n        mode_flags = mode_flags | 0x20;\n    }\n\n    if (result != 0) {\n        stream[1] = ret_value;\n        mode_flags = mode_flags | 0x40;\n    }\n\n    *(ushort *)(stream + 3) = mode_flags;\n    return 0xffffffff;\n}",
            "called": [
                "_fwalk",
                "__sflush_r",
                "_free_r",
                "_fflush_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006768",
            "calling": [
                "__srget_r"
            ],
            "imported": false,
            "current_name": "file_io_handler_00006768"
        },
        "FUN_00000db0": {
            "renaming": {
                "FUN_00000db0": "disable_watchdog_and_fix_cpu_errata_00000db0",
                "wdog_disable": "disable_watchdog",
                "cpu_errata_fixes": "fix_cpu_errata"
            },
            "code": "void disable_watchdog_and_fix_cpu_errata_00000db0(void)\n{\n  disable_watchdog();\n  fix_cpu_errata();\n  return;\n}",
            "called": [
                "wdog_disable",
                "cpu_errata_fixes"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000db0",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "disable_watchdog_and_fix_cpu_errata_00000db0"
        },
        "FUN_00002600": {
            "renaming": {
                "FUN_00002600": "set_rtt_counter_00002600",
                "time": "time_value",
                "counter": "counter_value"
            },
            "code": "int set_rtt_counter_00002600(tm *time_info)\n{\n    uint32_t counter_value;\n    time_t time;\n    time = mktime((tm *)time_info);\n    rtt_set_counter(time);\n    return 0;\n}",
            "called": [
                "rtt_set_counter",
                "mktime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002600",
            "calling": [
                "_rtc_settime"
            ],
            "imported": false,
            "current_name": "set_rtt_counter_00002600"
        },
        "FUN_00003810": {
            "renaming": {
                "FUN_00003810": "get_unit_name_00003810",
                "unit": "unit",
                "pcVar1": "unit_name",
                "PTR_DAT_00003914": "PTR_DEFAULT_UNIT_NAME",
                "PTR_DAT_000038cc": "PTR_UNIT_02_NAME",
                "PTR_DAT_000038d0": "PTR_UNIT_03_NAME",
                "PTR_DAT_000038d4": "PTR_UNIT_04_NAME",
                "PTR_PTR_s_R_000038d8": "PTR_UNIT_05_NAME",
                "PTR_DAT_000038dc": "PTR_UNIT_06_NAME",
                "PTR_DAT_000038e0": "PTR_UNIT_07_NAME",
                "PTR_DAT_000038e4": "PTR_UNIT_08_NAME",
                "PTR_DAT_000038e8": "PTR_UNIT_09_NAME",
                "PTR_DAT_000038ec": "PTR_UNIT_0A_NAME",
                "PTR_DAT_000038f0": "PTR_UNIT_0B_NAME",
                "PTR_DAT_000038f4": "PTR_UNIT_0C_NAME",
                "PTR_DAT_000038f8": "PTR_UNIT_0D_NAME",
                "PTR_DAT_000038fc": "PTR_UNIT_0E_NAME",
                "PTR_DAT_00003900": "PTR_UNIT_0F_NAME",
                "PTR_DAT_00003904": "PTR_UNIT_10_NAME",
                "PTR_DAT_0000390c": "PTR_UNIT_11_NAME",
                "PTR_DAT_00003910": "PTR_UNIT_13_NAME"
            },
            "code": "char* get_unit_name_00003810(uint8_t unit) {\n    char* unit_name;\n    switch(unit) {\n        case 0x02:\n            unit_name = PTR_DAT_000038cc;\n            break;\n        case 0x03:\n            unit_name = PTR_DAT_000038d0;\n            break;\n        case 0x04:\n            unit_name = PTR_DAT_000038d4;\n            break;\n        case 0x05:\n            unit_name = PTR_PTR_s_R_000038d8;\n            break;\n        case 0x06:\n            unit_name = PTR_DAT_000038dc;\n            break;\n        case 0x07:\n            unit_name = PTR_DAT_000038e0;\n            break;\n        case 0x08:\n            unit_name = PTR_DAT_000038e4;\n            break;\n        case 0x09:\n            unit_name = PTR_DAT_000038e8;\n            break;\n        case 0x0a:\n            unit_name = PTR_DAT_000038ec;\n            break;\n        case 0x0b:\n            unit_name = PTR_DAT_000038f0;\n            break;\n        case 0x0c:\n            unit_name = PTR_DAT_000038f4;\n            break;\n        case 0x0d:\n            unit_name = PTR_DAT_000038f8;\n            break;\n        case 0x0e:\n            unit_name = PTR_DAT_000038fc;\n            break;\n        case 0x0f:\n            unit_name = PTR_DAT_00003900;\n            break;\n        case 0x10:\n            unit_name = PTR_DAT_00003904;\n            break;\n        case 0x11:\n            unit_name = PTR_DAT_0000390c;\n            break;\n        case 0x13:\n            unit_name = PTR_DAT_00003910;\n            break;\n        case 0x15:\n            unit_name = PTR_UNIT_15_NAME;\n            break;\n        default:\n            unit_name = PTR_DAT_00003914;\n            break;\n    }\n    return unit_name;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003810",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "get_unit_name_00003810"
        },
        "FUN_0000041c": {
            "renaming": {
                "FUN_0000041c": "do_nothing_0000041c"
            },
            "code": "\nvoid do_nothing_0000041c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000041c",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0000041c"
        },
        "FUN_00000ed8": {
            "renaming": {
                "FUN_00000ed8": "printPointerValue_00000ed8",
                "in_lr": "pointerValue",
                "lr_ptr": "pointerAddress"
            },
            "code": "void printPointerValue_00000ed8(uint32_t *lr_ptr)\n{\n  undefined4 in_lr = *lr_ptr;\n  iprintf(PTR_DAT_00000ef4,in_lr);\n  return;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ed8",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "printPointerValue_00000ed8"
        },
        "FUN_000031e0": {
            "renaming": {
                "FUN_000031e0": "print_alarm_000031e0",
                "arg": "arg",
                "PTR_s_The_alarm_rang_000031f8": "alarm_message"
            },
            "code": "void print_alarm_000031e0(void *arg)\n{\n  const char* PTR_s_The_alarm_rang_000031f8 = PTR_s_The_alarm_rang_000031f8;\n  puts(PTR_s_The_alarm_rang_000031f8);\n  return;\n}",
            "called": [
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031e0",
            "calling": [],
            "imported": false,
            "current_name": "print_alarm_000031e0"
        },
        "FUN_000004d4": {
            "renaming": {
                "FUN_000004d4": "set_errno_to_19_if_file_descriptor_invalid_000004d4",
                "r": "reent",
                "fd": "file_descriptor",
                "_errno": "_error_number"
            },
            "code": "int set_errno_to_19_if_file_descriptor_invalid_000004d4(_reent *reent, int file_descriptor) {\n  reent->_errno = 0x13;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004d4",
            "calling": [
                "__sclose"
            ],
            "imported": false,
            "current_name": "set_errno_to_19_if_file_descriptor_invalid_000004d4"
        },
        "FUN_000020f4": {
            "renaming": {
                "FUN_000020f4": "handle_irq_000020f4",
                "DAT_00002104": "irq_num"
            },
            "code": "void handle_irq_000020f4(void)\n{\n  irq_handler(DAT_00002104=DAT_DAT_00002104, priority=3);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020f4",
            "calling": [],
            "imported": false,
            "current_name": "handle_irq_000020f4"
        },
        "FUN_0000687c": {
            "renaming": {
                "FUN_0000687c": "reverse_and_copy_0000687c",
                "param_1": "size",
                "param_2": "data",
                "pbVar1": "result",
                "uVar2": "end_value",
                "iVar3": "i",
                "uVar4": "current_byte",
                "uVar5": "byte_value",
                "uVar6": "end_value",
                "bVar7": "is_caret"
            },
            "code": "byte* reverse_and_copy_0000687c(int size, byte* data) {\n  byte* result;\n  uint current_byte = (uint)*data;\n  bool is_caret = current_byte == 0x5e;\n  if (is_caret) {\n    current_byte = (uint)data[1];\n    data += 2;\n  }\n  else {\n    data++;\n  }\n  int i = size - 1;\n  do {\n    i++;\n    *(bool*)i = is_caret;\n  } while (i != size + 0xff);\n  if (current_byte == 0) {\n    result = data - 1;\n  }\n  else {\n    do {\n      uint byte_value = current_byte;\n      *(bool*)(size + byte_value) = !is_caret;\n      data++;\n      while (true) {\n        current_byte = (uint)data[-1];\n        if (current_byte != 0x2d) break;\n        uint end_value = (uint)*data;\n        if ((end_value == 0x5d) || (current_byte > end_value)) goto LAB_000068aa;\n        do {\n          current_byte++;\n          *(bool*)(size + current_byte) = !is_caret;\n        } while (current_byte < end_value);\n        int difference = ~byte_value + end_value;\n        if (end_value <= byte_value) {\n          difference = 0;\n        }\n        byte_value = byte_value + 1 + difference;\n        data += 2;\n      }\n      result = data - 1;\n    } while ((current_byte != 0x5d) && (result = data - 1, current_byte != 0));\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000687c",
            "calling": [
                "_scanf_i",
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "reverse_and_copy_0000687c"
        },
        "FUN_00004dea": {
            "renaming": {
                "FUN_00004dea": "returnZero_00004dea"
            },
            "code": "int returnZero_00004dea(void) { return 0; }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dea",
            "calling": [],
            "imported": false,
            "current_name": "returnZero_00004dea"
        },
        "FUN_00005edc": {
            "renaming": {
                "_strtoul_l_isra_0": "convert_string_to_unsigned_integer",
                "param_1": "output",
                "param_2": "string",
                "param_3": "end_ptr",
                "param_4": "base",
                "uVar1": "current_value",
                "uVar2": "digit_value",
                "bVar3": "is_digit",
                "iVar4": "comparison",
                "uVar5": "temp_value",
                "uVar6": "max_value",
                "pbVar7": "current_position",
                "pbVar8": "start_position",
                "PTR_DAT_00005fd0": "digit_table",
                "UINT_MAX": "max_unsigned_int",
                "FUN_00005edc": "convert_string_to_unsigned_integer_00005edc"
            },
            "code": "uint convert_string_to_unsigned_integer_00005edc(undefined4 *output, byte *string, byte **end_ptr, uint base) {\n  uint digit_value;\n  uint current_value;\n  byte current_char;\n  byte *current_position;\n  byte *start_position;\n  bool is_negative;\n  uint max_value;\n  uint max_digit_value;\n\n  current_position = string;\n  while (is_digit(*current_position) == false) {\n    if (*current_position == '-') {\n      is_negative = true;\n      current_position++;\n    }\n    else if (*current_position == '+') {\n      is_negative = false;\n      current_position++;\n    }\n    else {\n      break;\n    }\n  }\n\n  if (base == 0) {\n    if (*current_position != '0') {\n      base = 10;\n    }\n    else if (to_upper(*(current_position + 1)) == 'X') {\n      base = 16;\n      current_position += 2;\n    }\n    else {\n      base = 8;\n    }\n  }\n\n  digit_value = 0;\n  current_value = 0;\n  max_value = UINT_MAX / base;\n  max_digit_value = UINT_MAX % base;\n  start_position = current_position;\n  while (true) {\n    current_char = *current_position;\n    if (is_digit(current_char)) {\n      digit_value = current_char - '0';\n    }\n    else if (is_upper_alpha(current_char)) {\n      digit_value = current_char - 'A' + 10;\n    }\n    else if (is_lower_alpha(current_char)) {\n      digit_value = current_char - 'a' + 10;\n    }\n    else {\n      break;\n    }\n\n    if (digit_value >= base) {\n      break;\n    }\n    if (current_value > max_value || (current_value == max_value && digit_value > max_digit_value)) {\n      current_value = UINT_MAX;\n      break;\n    }\n    current_value = current_value * base + digit_value;\n    current_position++;\n  }\n\n  if (current_value == UINT_MAX) {\n    *output = '\"';\n    if (end_ptr == NULL) {\n      return UINT_MAX;\n    }\n  }\n  else {\n    if (is_negative) {\n      current_value = -current_value;\n    }\n    if (end_ptr == NULL) {\n      return current_value;\n    }\n    if (start_position == current_position) {\n      goto LAB_00005fb8;\n    }\n  }\n  *end_ptr = current_position;\n  LAB_00005fb8:\n  return current_value;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005edc",
            "calling": [
                "_strtoul_r",
                "strtoul"
            ],
            "imported": false,
            "current_name": "convert_string_to_unsigned_integer_00005edc"
        },
        "FUN_00001eea": {
            "renaming": {
                "FUN_00001eea": "configure_gpio_pin_00001eea",
                "pin": "gpio_pin",
                "mode": "gpio_mode",
                "uVar1": "pin_number",
                "pGVar2": "gpio_pin",
                "pPVar3": "port",
                "iVar4": "pin_index"
            },
            "code": "int configure_gpio_pin_00001eea(gpio_t pin, gpio_mode_t mode) {\n  uint32_t pin_number;\n  GPIO_Type *gpio_pin;\n  PORT_Type *port;\n  int pin_index;\n\n  configure_gpio_pin_00001eea_port(pin, 0);\n\n  if (mode < GPIO_IN) {\n    pin_number = pin_number(pin);\n    gpio_pin = gpio(pin);\n    gpio_pin->PDDR |= 1 << (pin_number & 0xff);\n  } else {\n    pin_number = pin_number(pin);\n    gpio_pin = gpio(pin);\n    gpio_pin->PDDR &= ~(1 << (pin_number & 0xff));\n  }\n\n  port = port(pin);\n  pin_index = pin_number(pin);\n  port->PCR[pin_index] = (byte)mode & 0x23 | 0x100;\n  return 0;\n}",
            "called": [
                "port",
                "gpio",
                "gpio_init_port",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001eea",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "configure_gpio_pin_00001eea"
        },
        "FUN_000023a4": {
            "renaming": {
                "FUN_000023a4": "run_shell_command_000023a4",
                "line_buf": "command_buffer",
                "PTR_s_Welcome_to_RIOT__000023c4": "welcome_message",
                "shell_command_t": "shell_command",
                "startForkserver": "start_fork_server"
            },
            "code": "void run_shell_command_000023a4(void)\n{\n  char command_buffer[128];\n  start_fork_server(0);\n  puts(PTR_s_Welcome_to_RIOT__000023c4);\n  shell_run((shell_command_t *)0x0, command_buffer, 0x80);\n}",
            "called": [
                "shell_run",
                "puts",
                "startForkserver"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023a4",
            "calling": [
                "main_trampoline"
            ],
            "imported": false,
            "current_name": "run_shell_command_000023a4"
        },
        "FUN_0000240c": {
            "renaming": {
                "FUN_0000240c": "remove_node_0000240c",
                "list": "head",
                "plVar1": "node_to_remove"
            },
            "code": "list_node_t* remove_node_0000240c(list_node_t* head)\n{\n  list_node_t* node_to_remove;\n  node_to_remove = head->next;\n  if (node_to_remove != NULL)\n  {\n    head->next = node_to_remove->next;\n  }\n  return node_to_remove;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000240c",
            "calling": [
                "mutex_unlock"
            ],
            "imported": false,
            "current_name": "remove_node_0000240c"
        },
        "FUN_00004280": {
            "renaming": {
                "FUN_00004280": "release_recursive_mutex_00004280"
            },
            "code": "void release_recursive_mutex_00004280(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___sfp_recursive_mutex_00004288);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004280",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "release_recursive_mutex_00004280"
        },
        "FUN_00001448": {
            "renaming": {
                "FUN_00001448": "initialize_uart_00001448",
                "uart": "uart_gpio",
                "PTR_uart_config_000014c0": "uart_config",
                "gpio_init_port": "initialize_gpio_port",
                "rx_gpio": "uart_rx_gpio",
                "rx_config": "uart_rx_config",
                "tx_gpio": "uart_tx_gpio",
                "tx_config": "uart_tx_config"
            },
            "code": "void initialize_uart_00001448(gpio_t uart_gpio, uint32_t PTR_uart_config_000014c0) {\n    short uart_rx_pin = *(short *)(PTR_PTR_uart_config_000014c0_000014c0 + uart_gpio * 0x20 + 8);\n    short uart_tx_pin = *(short *)(PTR_PTR_uart_config_000014c0_000014c0 + uart_gpio * 0x20 + 10);\n    \n    if (uart_rx_pin != -1) {\n        gpio_t rx_gpio = *(gpio_t *)(PTR_PTR_uart_config_000014c0_000014c0 + uart_gpio * 0x20 + 8);\n        uint32_t rx_config = *(uint32_t *)(PTR_PTR_uart_config_000014c0_000014c0 + uart_gpio * 0x20 + 0xc);\n        gpio_init_port(rx_gpio, rx_config);\n    }\n    if (uart_tx_pin != -1) {\n        gpio_t tx_gpio = *(gpio_t *)(PTR_PTR_uart_config_000014c0_000014c0 + uart_gpio * 0x20 + 10);\n        uint32_t tx_config = *(uint32_t *)(PTR_PTR_uart_config_000014c0_000014c0 + uart_gpio * 0x20 + 0x10);\n        gpio_init_port(tx_gpio, tx_config);\n    }\n}",
            "called": [
                "gpio_init_port"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001448",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_00001448"
        },
        "FUN_00001688": {
            "renaming": {
                "FUN_00001688": "handle_uart_interrupt_00001688"
            },
            "code": "void handle_uart_interrupt_00001688(void)\n{\n  irq_handler_uart(0);\n  return;\n}",
            "called": [
                "irq_handler_uart"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001688",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_00001688"
        },
        "FUN_00004042": {
            "renaming": {
                "FUN_00004042": "convert_string_to_long_00004042",
                "__nptr": "string_to_convert",
                "lVar1": "converted_value"
            },
            "code": "long convert_string_to_long_00004042(char* string_to_convert) {\n    long converted_value = strtol(string_to_convert, (char**)0x0, 10);\n    return converted_value;\n}",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004042",
            "calling": [
                "read",
                "write"
            ],
            "imported": false,
            "current_name": "convert_string_to_long_00004042"
        },
        "FUN_00000cf0": {
            "renaming": {
                "FUN_00000cf0": "getIRQinterruptState_00000cf0",
                "uVar2": "interruptState",
                "bVar1": "isPrivileged",
                "isCurrentModePrivileged": "isCurrentModePrivileged",
                "isIRQinterruptsEnabled": "isIRQinterruptsEnabled",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "uint32_t getIRQinterruptState_00000cf0(void)\n{\n  bool isPrivileged;\n  uint32_t interruptState;\n\n  enableIRQinterrupts();\n  interruptState = 0;\n  isPrivileged = (bool)isCurrentModePrivileged();\n  if (isPrivileged) {\n    interruptState = isIRQinterruptsEnabled();\n  }\n  return interruptState;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cf0",
            "calling": [
                "cpu_switch_context_exit"
            ],
            "imported": false,
            "current_name": "getIRQinterruptState_00000cf0"
        },
        "FUN_00006cd4": {
            "renaming": {
                "FUN_00006cd4": "do_nothing_00006cd4"
            },
            "code": "\nvoid do_nothing_00006cd4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006cd4",
            "calling": [
                "__aeabi_ldivmod"
            ],
            "imported": false,
            "current_name": "do_nothing_00006cd4"
        },
        "FUN_00000f8c": {
            "renaming": {
                "FUN_00000f8c": "initialize_threads_00000f8c",
                "irq_disable": "disable_interrupts",
                "thread_create": "create_thread",
                "PTR_idle_stack_00000fdc": "idle_stack",
                "PTR_main_stack_00000fe8": "main_stack",
                "PTR_idle_name_00000fd4": "idle_name",
                "PTR_main_name_00000fe0": "main_name",
                "DAT_00000fd8": "THREAD_PRIORITY_LOW",
                "DAT_00000fe4": "THREAD_PRIORITY_NORMAL",
                "cpu_switch_context_exit": "context_switch"
            },
            "code": "void initialize_threads_00000f8c(void)\n{\n  disable_interrupts();\n  create_thread(PTR_idle_stack_00000fdc, 0x100, DAT_00000fd8, THREAD_MODE_DEFAULT, 0, NULL, PTR_idle_name_00000fd4);\n  create_thread(PTR_main_stack_00000fe8, 0x600, DAT_00000fe4, THREAD_MODE_DEFAULT, 0, NULL, PTR_main_name_00000fe0);\n  context_switch();\n}\n",
            "called": [
                "cpu_switch_context_exit",
                "irq_disable",
                "thread_create"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f8c",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "initialize_threads_00000f8c"
        },
        "FUN_00002894": {
            "renaming": {
                "FUN_00002894": "set_alarm_00002894",
                "alarm": "alarm_time",
                "cb": "callback",
                "arg": "callback_arg",
                "iVar1": "data",
                "DAT_000028e8": "data_section_start_address",
                "PTR_rtt_callback_000028ec": "rtt_callback_ptr",
                "rtt": "RTC"
            },
            "code": "void set_alarm_00002894(uint32_t alarm_time, rtt_callback_t callback, void *callback_arg) {\n  int data = DAT_000028e8;\n  *(uint *)(data + 0x1c) &= 0xfffffffb;\n  *(uint32_t *)(data + 8) = alarm_time - 1;\n  *(rtt_callback_t *)PTR_rtt_callback_000028ec = callback;\n  *(void **)(PTR_rtt_callback_000028ec + 4) = callback_arg;\n  *(uint *)(data + 0x1c) |= 4;\n  NVIC_SetPriority(RTC_IRQn,10);\n  NVIC_EnableIRQ(RTC_IRQn);\n  return;\n}",
            "called": [
                "NVIC_SetPriority",
                "NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002894",
            "calling": [
                "rtc_set_alarm"
            ],
            "imported": false,
            "current_name": "set_alarm_00002894"
        },
        "FUN_00004158": {
            "renaming": {
                "FUN_00004158": "flush_output_buffer_00004158",
                "param_1": "file_descriptor",
                "param_2": "stream",
                "uVar1": "result"
            },
            "code": "int flush_output_buffer_00004158(int file_descriptor, char *stream) {\n  int result;\n  if (*(int *)(stream + 0x10) != 0) {\n    if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n      __initialize_stream(stream);\n    }\n    if (stream == PTR___sf_fake_stdin_000041c4) {\n      stream = *(char **)(file_descriptor + 4);\n    }\n    else if (stream == PTR___sf_fake_stdout_000041c8) {\n      stream = *(char **)(file_descriptor + 8);\n    }\n    else if (stream == PTR___sf_fake_stderr_000041cc) {\n      stream = *(char **)(file_descriptor + 0xc);\n    }\n    if (*(short *)(stream + 0xc) != 0) {\n      if ((*(int *)(stream + 100) << 0x1f) >= 0 && (*(short *)(stream + 0xc) << 0x16) >= 0) {\n        __retarget_lock_acquire_recursive(*(int *)(stream + 0x58));\n      }\n      result = __flush_buffer_r(file_descriptor, stream);\n      if (*(int *)(stream + 100) << 0x1f < 0 || *(short *)(stream + 0xc) << 0x16 < 0) {\n        return result;\n      }\n      __retarget_lock_release_recursive(*(int *)(stream + 0x58));\n      return result;\n    }\n  }\n  return 0;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__sflush_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004158",
            "calling": [
                "__swbuf_r",
                "__srefill_r",
                "fflush"
            ],
            "imported": false,
            "current_name": "flush_output_buffer_00004158"
        },
        "FUN_00002654": {
            "renaming": {
                "FUN_00002654": "set_rtc_alarm_00002654",
                "time": "alarm_time",
                "cb": "callback",
                "arg": "argument"
            },
            "code": "int set_rtc_alarm_00002654(tm *time, rtc_alarm_cb_t callback, void *argument)\n{\n  uint32_t alarm_time = mktime((tm *)time);\n  *(rtc_alarm_cb_t *)PTR_rtc_callback_00002688 = callback;\n  rtt_set_alarm(alarm_time, DAT_0000268c, argument);\n  return 0;\n}",
            "called": [
                "mktime",
                "rtt_set_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002654",
            "calling": [
                "_rtc_setalarm"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_00002654"
        },
        "FUN_00000aa8": {
            "renaming": {
                "FUN_00000aa8": "handle_hard_fault_00000aa8",
                "sp": "stack_pointer",
                "corrupted": "corrupted_stack",
                "exc_return": "exception_return",
                "r4_to_r11_stack": "registers",
                "iVar1": "stack_left",
                "uVar2": "bfar_value",
                "uVar3": "mmfar_value",
                "uVar4": "cfsr_bits",
                "uVar5": "hfsr_value",
                "uVar6": "dfsr_value",
                "uVar7": "afsr_value",
                "uVar8": "r0",
                "uVar9": "r1",
                "uVar10": "r2",
                "uVar11": "r3",
                "uVar12": "r12",
                "psr": "psr",
                "lr": "lr",
                "r12": "r12",
                "r3": "r3",
                "r2": "r2",
                "r1": "r1",
                "r0": "r0",
                "afsr": "afsr",
                "dfsr": "dfsr",
                "hfsr": "hfsr",
                "cfsr": "cfsr",
                "mmfar": "mmfar",
                "bfar": "bfar",
                "orig_sp": "orig_sp",
                "pc": "pc",
                "PTR_isr_stack_00000c28": "PTR_isr_stack_00000c28",
                "DAT_00000c2c": "DAT_00000c2c",
                "PTR_s__ISR_stack_overflowed_00000c30": "PTR_s__ISR_stack_overflowed_00000c30",
                "PTR_s__Context_before_hardfault__00000c38": "PTR_s__Context_before_hardfault__00000c38",
                "PTR_s__r0__0x_08lx_r1__0x_08lx_r2__0x__00000c3c": "PTR_s__r0__0x_08lx_r1__0x_08lx_r2__0x__00000c3c",
                "PTR_s__r12__0x_08lx_lr__0x_08lx_pc__0x_00000c40": "PTR_s__r12__0x_08lx_lr__0x_08lx_pc__0x_00000c40",
                "PTR_s_Stack_pointer_corrupted__reset_t_00000c34": "PTR_s_Stack_pointer_corrupted__reset_t_00000c34",
                "PTR_s_FSR_FAR__00000c44": "PTR_s_FSR_FAR__00000c44",
                "PTR_s__CFSR__0x_08lx_00000c48": "PTR_s__CFSR__0x_08lx_00000c48",
                "PTR_s__HFSR__0x_08lx_00000c4c": "PTR_s__HFSR__0x_08lx_00000c4c",
                "PTR_s__DFSR__0x_08lx_00000c50": "PTR_s__DFSR__0x_08lx_00000c50",
                "PTR_s__AFSR__0x_08lx_00000c54": "PTR_s__AFSR__0x_08lx_00000c54",
                "PTR_BFARVALID_MASK_00000c58": "PTR_BFARVALID_MASK_00000c58",
                "PTR_s__BFAR__0x_08lx_00000c5c": "PTR_s__BFAR__0x_08lx_00000c5c",
                "PTR_MMARVALID_MASK_00000c60": "PTR_MMARVALID_MASK_00000c60",
                "PTR_s_MMFAR__0x_08lx_00000c64": "PTR_s_MMFAR__0x_08lx_00000c64",
                "PTR_DAT_00000c68": "PTR_DAT_00000c68",
                "PTR_s_EXC_RET__0x_08lx_00000c6c": "PTR_s_EXC_RET__0x_08lx_00000c6c",
                "PTR_s_Attempting_to_reconstruct_state_f_00000c70": "PTR_s_Attempting_to_reconstruct_state_f_00000c70",
                "PTR_s_In_GDB__set__pc_0x_lx_frame_0_bt_00000c74": "PTR_s_In_GDB__set__pc_0x_lx_frame_0_bt_00000c74",
                "PTR_s__ISR_stack_overflowed_by_at_leas_00000c78": "PTR_s__ISR_stack_overflowed_by_at_leas_00000c78",
                "software_bkpt": "software_bkpt",
                "core_panic": "core_panic",
                "PANIC_HARD_FAULT": "PANIC_HARD_FAULT",
                "PTR_s_HARD_FAULT_HANDLER_00000c7c": "PTR_s_HARD_FAULT_HANDLER_00000c7c",
                "DAT_00000c24": "DAT_00000c24"
            },
            "code": "void handle_hard_fault_00000aa8(uint32_t *stack_pointer, uint32_t corrupted_stack, uint32_t exception_return, uint32_t *registers)\n{\n    int stack_left;\n    uint32_t psr;\n    uint32_t lr;\n    uint32_t r12;\n    uint32_t r3;\n    uint32_t r2;\n    uint32_t r1;\n    uint32_t r0;\n    uint32_t afsr;\n    uint32_t dfsr;\n    uint32_t hfsr;\n    uint32_t cfsr;\n    uint32_t mmfar;\n    uint32_t bfar;\n    uint32_t *orig_sp;\n    uint32_t pc;\n\n    uint32_t cfsr_bits = *(uint *)(DAT_00000c24 + 0x28);\n    uint32_t bfar_value = *(uint *)(DAT_00000c24 + 0x38);\n    uint32_t mmfar_value = *(uint *)(DAT_00000c24 + 0x34);\n    uint32_t hfsr_value = *(uint *)(DAT_00000c24 + 0x2c);\n    uint32_t dfsr_value = *(uint *)(DAT_00000c24 + 0x30);\n    uint32_t afsr_value = *(uint *)(DAT_00000c24 + 0x3c);\n    pc = 0;\n    if (*(int *)PTR_isr_stack_00000c28 != DAT_00000c2c) {\n        puts(PTR_s__ISR_stack_overflowed_00000c30);\n    }\n    if (corrupted_stack == 0) {\n        r0 = *stack_pointer;\n        r1 = stack_pointer[1];\n        r2 = stack_pointer[2];\n        r3 = stack_pointer[4];\n        r12 = stack_pointer[5];\n        pc = stack_pointer[6];\n        puts(PTR_s__Context_before_hardfault__00000c38);\n        iprintf(PTR_s__r0__0x_08lx_r1__0x_08lx_r2__0x__00000c3c, r0, r1, r2);\n        iprintf(PTR_s__r12__0x_08lx_lr__0x_08lx_pc__0x_00000c40, r12, r3, pc);\n    }\n    else {\n        puts(PTR_s_Stack_pointer_corrupted__reset_t_00000c34);\n    }\n    puts(PTR_s_FSR_FAR__00000c44);\n    iprintf(PTR_s__CFSR__0x_08lx_00000c48, cfsr_bits);\n    iprintf(PTR_s__HFSR__0x_08lx_00000c4c, hfsr_value);\n    iprintf(PTR_s__DFSR__0x_08lx_00000c50, dfsr_value);\n    iprintf(PTR_s__AFSR__0x_08lx_00000c54, afsr_value);\n    if ((cfsr_bits & *(uint *)PTR_BFARVALID_MASK_00000c58) != 0) {\n        iprintf(PTR_s__BFAR__0x_08lx_00000c5c, bfar_value);\n    }\n    if ((cfsr_bits & *(uint *)PTR_MMARVALID_MASK_00000c60) != 0) {\n        iprintf(PTR_s_MMFAR__0x_08lx_00000c64, mmfar_value);\n    }\n    puts(PTR_DAT_00000c68);\n    iprintf(PTR_s_EXC_RET__0x_08lx_00000c6c, exception_return);\n    if (corrupted_stack == 0) {\n        puts(PTR_s_Attempting_to_reconstruct_state_f_00000c70);\n        iprintf(PTR_s_In_GDB__set__pc_0x_lx_frame_0_bt_00000c74, pc);\n        stack_left = _stack_size_left(0x158);\n        if (stack_left < 0) {\n            iprintf(PTR_s__ISR_stack_overflowed_by_at_leas_00000c78, -stack_left);\n        }\n    }\n    software_bkpt(1);\n    core_panic(PANIC_HARD_FAULT, PTR_s_HARD_FAULT_HANDLER_00000c7c);\n}",
            "called": [
                "iprintf",
                "puts",
                "core_panic",
                "_stack_size_left"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000aa8",
            "calling": [
                "hard_fault_default"
            ],
            "imported": false,
            "current_name": "handle_hard_fault_00000aa8"
        },
        "FUN_00002538": {
            "renaming": {
                "FUN_00002538": "setIRQnPriority_00002538",
                "IRQn": "irq_number",
                "priority": "irq_priority",
                "DAT_00002584": "priority_base_address",
                "DAT_00002588": "priority_base_address2"
            },
            "code": "void setIRQnPriority_00002538(IRQn_Type IRQn, uint32_t priority) {\n  if (IRQn < DMA0_IRQn) {\n    char* priority_address = (char*)(((byte)IRQn & 0xf) + DAT_00002584 + 0x14);\n    char priority_value = (char)((priority & 0xff) << 4);\n    *priority_address = priority_value;\n  }\n  else {\n    char* priority_address = (char*)(IRQn + DAT_00002588 + 0x300);\n    char priority_value = (char)((priority & 0xff) << 4);\n    *priority_address = priority_value;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002538",
            "calling": [
                "cortexm_init"
            ],
            "imported": false,
            "current_name": "setIRQnPriority_00002538"
        },
        "FUN_00004c84": {
            "renaming": {
                "FUN_00004c84": "print_formatted_string_00004c84",
                "__format": "format_string",
                "in_r1": "arg1",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "iVar1": "impure_ptr",
                "pcVar2": "format",
                "uStack_c": "stack_var1",
                "uStack_8": "stack_var2",
                "uStack_4": "stack_var3"
            },
            "code": "int print_formatted_string_00004c84(char *format_string, ...)\n{\n  int impure_ptr = *(int *)PTR__impure_ptr_00004cb0;\n  char *format = format_string;\n  undefined4 arg1;\n  undefined4 arg2;\n  undefined4 arg3;\n  undefined4 stack_var1;\n  undefined4 stack_var2;\n  undefined4 stack_var3;\n  arg1 = stack_var1;\n  arg2 = stack_var2;\n  arg3 = stack_var3;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  int result = _vfprintf_r(impure_ptr,*(undefined4 *)(impure_ptr + 8),format_string,&arg1,format,&arg1);\n  return result;\n}",
            "called": [
                "_vfprintf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004c84",
            "calling": [
                "phydat_dump",
                "_print_time",
                "ps",
                "write",
                "cpu_print_last_instruction",
                "list",
                "main_trampoline",
                "read",
                "print_help",
                "hard_fault_handler",
                "_rtc_handler",
                "core_panic",
                "_saul",
                "handle_input_line",
                "probe"
            ],
            "imported": false,
            "current_name": "print_formatted_string_00004c84"
        },
        "FUN_0000305c": {
            "renaming": {
                "FUN_0000305c": "write_data_to_device_0000305c",
                "argc": "num_of_args",
                "argv": "args",
                "iVar1": "arg_count",
                "data": "data_to_write",
                "dim": "data_dim",
                "dev": "device",
                "num": "device_num"
            },
            "code": "void write_data_to_device_0000305c(int num_of_args, char **args) {\n  int arg_count;\n  phydat_t data_to_write;\n  int data_dim;\n  saul_reg_t *device;\n  int device_num;\n  int i;\n  \n  if (num_of_args < 4) {\n    iprintf(PTR_s_usage___s__s__device_id___value_0_00003154, *args, args[1]);\n  }\n  else {\n    device_num = atoi(args[2]);\n    device = saul_reg_find_nth(device_num);\n    if (device == (saul_reg_t *)0x0) {\n      puts(PTR_s_error__undefined_device_given_00003158);\n    }\n    else {\n      memset(&data_to_write, 0, 8);\n      if (5 < num_of_args) {\n        num_of_args = 6;\n      }\n      data_dim = num_of_args + -3;\n      for (i = 0; i < data_dim; i = i + 1) {\n        arg_count = atoi(args[i + 3]);\n        data_to_write.val[i] = (int16_t)arg_count;\n      }\n      iprintf(PTR_s_Writing_to_device___i____s_0000315c, device_num, device->name);\n      phydat_dump(&data_to_write, (uint8_t)data_dim);\n      arg_count = saul_reg_write_data_to_device_0000305c(device, &data_to_write);\n      if (arg_count < 1) {\n        if (arg_count == -0x86) {\n          iprintf(PTR_s_error__device___i_is_not_writabl_00003160, device_num);\n        }\n        else {\n          iprintf(PTR_s_error__failure_to_write_data_to_device_0000305c_to_devic_00003164, device_num);\n        }\n      }\n      else {\n        iprintf(PTR_s_data_successfully_written_to_dev_00003168, device_num);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "phydat_dump",
                "saul_reg_find_nth",
                "atoi",
                "iprintf",
                "saul_reg_write",
                "memset",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000305c",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "write_data_to_device_0000305c"
        },
        "FUN_000012b4": {
            "renaming": {
                "FUN_000012b4": "add_char_to_tsrb_buffer_000012b4",
                "isrpipe": "isrpipe",
                "c": "new_char",
                "iVar1": "add_result",
                "res": "not_changed"
            },
            "code": "int add_char_to_tsrb_buffer_000012b4(isrpipe_t *isrpipe, char new_char) {\n  int add_result;\n  add_result = tsrb_add_one(&isrpipe->tsrb, new_char);\n  mutex_unlock(&isrpipe->mutex);\n  return add_result;\n}",
            "called": [
                "tsrb_add_one",
                "mutex_unlock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012b4",
            "calling": [],
            "imported": false,
            "current_name": "add_char_to_tsrb_buffer_000012b4"
        },
        "FUN_00005b34": {
            "renaming": {
                "FUN_00005b34": "print_formatted_output_00005b34",
                "param_1": "stream",
                "param_2": "format",
                "param_3": "width",
                "param_4": "print_function",
                "param_5": "args",
                "bVar1": "is_divisible",
                "bVar2": "format_char",
                "puVar3": "digits",
                "iVar4": "result",
                "pcVar5": "output",
                "pvVar6": "null_byte",
                "iVar7": "byte_written",
                "__s": "buffer",
                "uVar8": "value",
                "puVar9": "arg_ptr",
                "uVar10": "base",
                "ppuVar11": "arg_list_ptr",
                "uVar12": "precision",
                "puVar13": "buffer_ptr",
                "puVar14": "original_arg_ptr",
                "uVar15": "flags",
                "local_24": "min_field_width"
            },
            "code": "\ncode * print_formatted_output_00005b34(undefined4 stream,uint *format,undefined4 width,code *print_function,uint **args)\n\n{\n  bool is_divisible;\n  byte format_char;\n  undefined *digits;\n  int result;\n  code *output;\n  void *null_byte;\n  int byte_written;\n  undefined *buffer;\n  uint value;\n  uint *arg_ptr;\n  uint base;\n  uint **arg_list_ptr;\n  uint precision;\n  undefined *buffer_ptr;\n  uint *original_arg_ptr;\n  undefined4 flags;\n  code *min_field_width;\n  \n  digits = PTR_s_0123456789ABCDEF_00005d78;\n  format_char = *(byte *)(format + 6);\n  buffer = (undefined *)((int)format + 0x43);\n  original_arg_ptr = format;\n  flags = width;\n  min_field_width = print_function;\n  if (0x78 < format_char) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)format + 0x42) = format_char;\nLAB_00005bdc:\n    buffer = (undefined *)((int)format + 0x42);\n    value = 1;\nLAB_00005d28:\n    format[4] = value;\n    *(undefined *)((int)format + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (format_char < 99) {\n    if (format_char == 0) goto LAB_00005d06;\n    if (format_char == 0x58) {\n      *(undefined *)((int)format + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(format_char) {\n  case 99:\n    value = **args;\n    *args = *args + 1;\n    *(char *)((int)format + 0x42) = (char)value;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    base = *format;\n    arg_ptr = *args;\n    if ((int)(base << 0x18) < 0) {\n      value = *arg_ptr;\n      *args = arg_ptr + 1;\n    }\n    else {\n      value = *arg_ptr;\n      *args = arg_ptr + 1;\n      if ((base & 0x40) != 0) {\n        value = (uint)(short)value;\n      }\n    }\n    if ((int)value < 0) {\n      value = -value;\n      *(undefined *)((int)format + 0x43) = 0x2d;\n    }\n    base = 10;\n    digits = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    arg_list_ptr = (uint **)*args;\n    base = *format;\n    value = format[5];\n    *args = (uint *)(arg_list_ptr + 1);\n    arg_ptr = *arg_list_ptr;\n    if (((int)(base << 0x18) < 0) || (-1 < (int)(base << 0x19))) {\n      *arg_ptr = value;\n    }\n    else {\n      *(short *)arg_ptr = (short)value;\n    }\nLAB_00005d06:\n    format[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    arg_ptr = *args;\n    value = *format;\n    *args = arg_ptr + 1;\n    if (((int)(value << 0x18) < 0) || (-1 < (int)(value << 0x19))) {\n      value = *arg_ptr;\n    }\n    else {\n      value = (uint)*(ushort *)arg_ptr;\n    }\n    digits = PTR_s_0123456789ABCDEF_00005d78;\n    if (format_char == 0x6f) {\n      base = 8;\n    }\n    else {\n      base = 10;\n    }\n    break;\n  case 0x70:\n    *format = *format | 0x20;\n  case 0x78:\n    digits = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)format + 0x45) = 0x78;\nLAB_00005ca8:\n    base = *format;\n    value = **args;\n    *args = *args + 1;\n    if ((-1 < (int)(base << 0x18)) && ((int)(base << 0x19) < 0)) {\n      value = value & 0xffff;\n    }\n    if ((int)(base << 0x1f) < 0) {\n      *format = base | 0x20;\n    }\n    if (value == 0) {\n      *format = *format & 0xffffffdf;\n    }\n    base = 0x10;\n    break;\n  case 0x73:\n    arg_ptr = *args;\n    *args = arg_ptr + 1;\n    buffer = (undefined *)*arg_ptr;\n    null_byte = memchr(buffer,0,format[1]);\n    if (null_byte != (void *)0x0) {\n      format[1] = (int)null_byte - (int)buffer;\n    }\n    value = format[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)format + 0x43) = 0;\nLAB_00005c36:\n  precision = format[1];\n  format[2] = precision;\n  if (-1 < (int)precision) {\n    *format = *format & 0xfffffffb;\n  }\n  buffer_ptr = buffer;\n  if ((value != 0) || (precision != 0)) {\n    do {\n      buffer_ptr = buffer_ptr + -1;\n      *buffer_ptr = digits[value - base * (value / base)];\n      is_divisible = base <= value;\n      value = value / base;\n    } while (is_divisible);\n  }\n  if (((base == 8) && ((int)(*format << 0x1f) < 0)) && ((int)format[1] <= (int)format[4])) {\n    buffer_ptr[-1] = 0x30;\n    buffer_ptr = buffer_ptr + -1;\n  }\n  format[4] = (int)buffer - (int)buffer_ptr;\n  buffer = buffer_ptr;\nLAB_00005c84:\n  result = _printf_common(stream,format,&min_field_width,width,print_function,original_arg_ptr,flags);\n  if ((result == -1) || (result = (*print_function)(stream,width,buffer,format[4]), result == -1)) {\nLAB_00005c98:\n    output = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*format << 0x1e) < 0) {\n      for (result = 0; result < (int)(format[3] - (int)min_field_width); result = result + 1) {\n        byte_written = (*print_function)(stream,width,(int)format + 0x19,1);\n        if (byte_written == -1) goto LAB_00005c98;\n      }\n    }\n    output = (code *)format[3];\n    if ((int)(code *)format[3] < (int)min_field_width) {\n      output = min_field_width;\n    }\n  }\n  return output;\n}\n\n",
            "called": [
                "_printf_common",
                "memchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005b34",
            "calling": [
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "print_formatted_output_00005b34"
        },
        "FUN_0000058e": {
            "renaming": {
                "FUN_0000058e": "insert_node_at_end_0000058e",
                "list": "head",
                "new_node": "new_node",
                "list->next": "head->next",
                "list_node": "clist_node_t",
                "new_node->next": "new_node->next"
            },
            "code": "void insert_node_at_end_0000058e(clist_node_t *head, clist_node_t *new_node) {\n  if (head->next == NULL) {\n    new_node->next = new_node;\n  }\n  else {\n    new_node->next = head->next;\n    head->next = new_node;\n  }\n  head->next = new_node;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000058e",
            "calling": [
                "sched_set_status"
            ],
            "imported": false,
            "current_name": "insert_node_at_end_0000058e"
        },
        "FUN_0000656c": {
            "renaming": {
                "FUN_0000656c": "parse_and_transform_input_0000656c",
                "param_1": "input_state",
                "param_2": "input_params",
                "param_3": "input_data",
                "param_4": "output_buffer",
                "pvVar1": "memchr_result",
                "iVar2": "memchr_result_index",
                "uVar3": "parse_result",
                "pcVar4": "output_function",
                "uVar5": "input_param_flags",
                "pbVar6": "input_byte",
                "puVar8": "output_buffer_pointer",
                "puVar9": "input_data_pointer",
                "puVar10": "output_data_pointer",
                "puVar11": "output_data_start",
                "unaff_r9": "output_data_offset",
                "iVar12": "loop_index",
                "local_34": "output_data_templates"
            },
            "code": "\nundefined4 parse_and_transform_input_0000656c(undefined4 input_state,uint *input_params,byte **input_data,undefined4 *output_buffer)\n\n{\n  void *memchr_result;\n  int memchr_result_index;\n  undefined4 parse_result;\n  code *output_function;\n  uint input_param_flags;\n  byte *input_byte;\n  uint uVar7;\n  undefined4 *output_buffer_pointer;\n  uint *input_data_pointer;\n  uint *output_data_pointer;\n  uint *output_data_start;\n  int output_data_offset;\n  int loop_index;\n  void *output_data_templates [4];\n  \n  output_data_templates[0] = *(void **)PTR_PTR_DAT_00006744;\n  output_data_templates[1] = (void *)*(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  output_data_templates[2] = (void *)*(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  output_function = DAT_0000674c;\n  if (input_params[6] != 3) {\n    output_function = DAT_00006748;\n  }\n  uVar7 = input_params[2];\n  input_param_flags = uVar7 - 1;\n  if (0x15c < input_param_flags) {\n    output_data_offset = uVar7 - 0x15d;\n    uVar7 = 0x15d;\n  }\n  if (0x15c < input_param_flags) {\n    input_params[2] = uVar7;\n  }\n  output_data_start = input_params + 7;\n  if (input_param_flags < 0x15d) {\n    output_data_offset = 0;\n  }\n  *input_params = *input_params | 0xd00;\n  loop_index = 0;\n  output_data_pointer = output_data_start;\n  do {\n    memchr_result = memchr(output_data_templates[loop_index],(uint)**input_data,2);\n    if (memchr_result != (void *)0x0) {\n      if (loop_index == 1) {\n        if (input_params[1] == 0) {\n          input_params[1] = 8;\n          *input_params = *input_params | 0x200;\n        }\n        input_param_flags = *input_params & 0xfffffaff;\nLAB_000065f4:\n        *input_params = input_param_flags;\n      }\n      else if (loop_index == 2) {\n        if ((*input_params & 0x600) != 0x200) goto LAB_00006624;\n        input_params[1] = 0x10;\n        input_param_flags = *input_params | 0x100;\n        goto LAB_000065f4;\n      }\n      input_param_flags = input_params[2];\n      input_params[2] = input_param_flags - 1;\n      if (input_param_flags != 0) {\n        input_byte = *input_data;\n        *input_data = input_byte + 1;\n        input_data_pointer = (uint *)((int)output_data_pointer + 1);\n        *(byte *)output_data_pointer = *input_byte;\n        input_byte = input_data[1];\n        input_data[1] = input_byte + -1;\n        output_data_pointer = input_data_pointer;\n        if (((int)(input_byte + -1) < 1) &&\n           (memchr_result_index = (*(code *)input_params[0x60])(input_state,input_data), memchr_result_index != 0)) {\n          loop_index = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    loop_index = loop_index + 1;\n  } while (loop_index != 3);\n  if (input_params[1] == 0) {\n    input_params[1] = 10;\n  }\n  __sccl(input_params[5],(int)PTR_DAT_00006750 - input_params[1]);\n  loop_index = 0;\n  while( true ) {\n    input_data_pointer = output_data_pointer;\n    if (input_params[2] == 0) break;\n    input_byte = *input_data;\n    input_param_flags = (uint)*input_byte;\n    if (*(char *)(input_params[5] + input_param_flags) == '\\0') break;\n    if ((input_param_flags == 0x30) && ((int)(*input_params << 0x14) < 0)) {\n      loop_index = loop_index + 1;\n      if (output_data_offset != 0) {\n        output_data_offset = output_data_offset + -1;\n        input_params[2] = input_params[2] + 1;\n      }\n    }\n    else {\n      *input_params = *input_params & 0xfffff6ff;\n      input_data_pointer = (uint *)((int)output_data_pointer + 1);\n      *(byte *)output_data_pointer = *input_byte;\n    }\n    input_byte = input_data[1];\n    input_data[1] = input_byte + -1;\n    if ((int)(input_byte + -1) < 1) {\n      memchr_result_index = (*(code *)input_params[0x60])(input_state,input_data);\n      if (memchr_result_index != 0) break;\n    }\n    else {\n      *input_data = *input_data + 1;\n    }\n    input_params[2] = input_params[2] - 1;\n    output_data_pointer = input_data_pointer;\n  }\nLAB_000066ca:\n  if ((int)(*input_params << 0x17) < 0) {\n    if (output_data_start < input_data_pointer) {\n      (*(code *)input_params[0x5f])(input_state,*(byte *)((int)input_data_pointer + -1),input_data);\n      input_data_pointer = (uint *)((int)input_data_pointer + -1);\n    }\n    if (input_data_pointer == output_data_start) {\n      return 1;\n    }\n  }\n  if ((*input_params & 0x10) == 0) {\n    *(byte *)input_data_pointer = 0;\n    parse_result = (*output_function)(input_state,output_data_start,0,input_params[1]);\n    output_buffer_pointer = (undefined4 *)*output_buffer;\n    input_param_flags = *input_params;\n    *output_buffer = output_buffer_pointer + 1;\n    output_buffer_pointer = (undefined4 *)*output_buffer_pointer;\n    if ((input_param_flags & 0x20) == 0) {\n      if ((int)(input_param_flags << 0x1f) < 0) {\n        *(short *)output_buffer_pointer = (short)parse_result;\n      }\n      else {\n        *output_buffer_pointer = parse_result;\n      }\n    }\n    else {\n      *output_buffer_pointer = parse_result;\n    }\n    input_params[3] = input_params[3] + 1;\n  }\n  input_params[4] = (uint)((int)input_data_pointer + input_params[4] + (loop_index - (int)output_data_start));\n  return 0;\n}\n\n",
            "called": [
                "__sccl",
                "memchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000656c",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "parse_and_transform_input_0000656c"
        },
        "FUN_000025f4": {
            "renaming": {
                "FUN_000025f4": "initialize_real_time_trace_000025f4",
                "rtt_init": "initialize_rtt"
            },
            "code": "void initialize_real_time_trace_000025f4(void)\n{\n  initialize_rtt();\n  return;\n}",
            "called": [
                "rtt_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000025f4",
            "calling": [
                "periph_init"
            ],
            "imported": false,
            "current_name": "initialize_real_time_trace_000025f4"
        },
        "FUN_00001ddc": {
            "renaming": {
                "FUN_00001ddc": "set_gpio_pin_00001ddc",
                "pin": "gpio_pin",
                "iVar1": "port_number",
                "port_num": "get_port_number",
                "DAT_00001e08": "register_address",
                "bit_set32": "set_bit_in_register"
            },
            "code": "void set_gpio_pin_00001ddc(gpio_t pin) {\n  int port_number = get_port_number(pin);\n  set_bit_in_register(DAT_00001e08, (char)port_number + 10);\n  return;\n}",
            "called": [
                "port_num",
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ddc",
            "calling": [
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_00001ddc"
        },
        "FUN_00002ecc": {
            "renaming": {
                "FUN_00002ecc": "read_sensor_data_00002ecc",
                "num": "sensor_num",
                "dev": "sensor_device",
                "iVar1": "read_status",
                "pcVar2": "sensor_type",
                "pcVar3": "sensor_name",
                "res": "sensor_data",
                "dim": "data_dim"
            },
            "code": "void read_sensor_data_00002ecc(int sensor_num, saul_reg_t *sensor_device) {\n  int read_status;\n  char *sensor_name;\n  char *sensor_type;\n  phydat_t sensor_data;\n  int data_dim;\n  read_status = saul_reg_read(sensor_device, &sensor_data);\n  if (read_status < 1) {\n    iprintf(PTR_s_error__failed_to_read_from_device_00002f28, sensor_num);\n  }\n  else {\n    sensor_name = sensor_device->name;\n    sensor_type = saul_class_to_str(sensor_device->driver->type);\n    iprintf(PTR_s_Reading_from___i___s__s__00002f2c, sensor_num, sensor_name, sensor_type);\n    phydat_dump(&sensor_data, (uint8_t)read_status);\n  }\n  return;\n}",
            "called": [
                "phydat_dump",
                "saul_reg_read",
                "iprintf",
                "saul_class_to_str"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002ecc",
            "calling": [
                "read",
                "probe_all"
            ],
            "imported": false,
            "current_name": "read_sensor_data_00002ecc"
        },
        "FUN_00000d76": {
            "renaming": {
                "FUN_00000d76": "clear_bit_00000d76",
                "ptr": "data",
                "bit": "bit_position",
                "puVar1": "bit_address"
            },
            "code": "void clear_bit_00000d76(uint32_t *data, uint8_t bit_position)\n{\n  uint32_t *bit_address = (uint32_t *)bitband_addr(data, (uint)bit_position);\n  *bit_address = 0;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d76",
            "calling": [
                "cpu_errata_fixes"
            ],
            "imported": false,
            "current_name": "clear_bit_00000d76"
        },
        "FUN_000057a8": {
            "renaming": {
                "FUN_000057a8": "write_to_buffer_000057a8",
                "param_1": "file_descriptor",
                "param_2": "character",
                "param_3": "buffer_ptr",
                "iVar1": "buffer_length",
                "puVar2": "current_char_ptr"
            },
            "code": "int write_to_buffer_000057a8(undefined4 file_descriptor, int character, undefined4 *buffer_ptr)\n{\n  int buffer_length = buffer_ptr[2] - 1;\n  buffer_ptr[2] = buffer_length;\n  if ((buffer_length < 0) && ((buffer_length < (int)buffer_ptr[6] || (character == 10)))) {\n    int result = __swbuf_r();\n    return result;\n  }\n  undefined *current_char_ptr = (undefined *)*buffer_ptr;\n  *buffer_ptr = current_char_ptr + 1;\n  *current_char_ptr = (char)character;\n  return character;\n}",
            "called": [
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057a8",
            "calling": [
                "__sfputs_r"
            ],
            "imported": false,
            "current_name": "write_to_buffer_000057a8"
        },
        "FUN_00004298": {
            "renaming": {
                "FUN_00004298": "release_recursive_mutex_00004298",
                "PTR___lock___sinit_recursive_mutex_000042a0": "sinit_recursive_mutex"
            },
            "code": "void release_recursive_mutex_00004298(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___sinit_recursive_mutex_000042a0);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004298",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "release_recursive_mutex_00004298"
        },
        "FUN_00001696": {
            "renaming": {
                "FUN_00001696": "calculate_virtual_address_00001696",
                "ptr": "ptr",
                "bit": "bit",
                "uint": "uintptr_t",
                "upper_bits": "upper_bits",
                "lower_bits": "lower_bits",
                "offset": "offset",
                "result": "result"
            },
            "code": "void * calculate_virtual_address_00001696(void *ptr, uintptr_t bit)\n{\n    uintptr_t upper_bits = ((uintptr_t)ptr & 0xf0000000);\n    uintptr_t lower_bits = ((uintptr_t)ptr & 0xfffff) << 5;\n    uintptr_t offset = 0x2000000;\n    uintptr_t result = (bit * 4) + upper_bits + lower_bits + offset;\n    return (void *)result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001696",
            "calling": [
                "bit_set8",
                "bit_clear8",
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_virtual_address_00001696"
        },
        "FUN_000008b8": {
            "renaming": {
                "FUN_000008b8": "count_words_in_heap_000008b8",
                "num_used_words": "num_used_words",
                "ptr": "current_word_ptr",
                "PTR_isr_stack_000008f4": "isr_stack_ptr",
                "DAT_000008f8": "word_pattern",
                "PTR_heap_top_000008fc": "heap_top_ptr"
            },
            "code": "int count_words_in_heap_000008b8()\n{\n  ptrdiff_t num_used_words;\n  uint32_t *current_word_ptr;\n\n  for (current_word_ptr = (uint32_t *)PTR_isr_stack_000008f4;\n      (*current_word_ptr == DAT_000008f8 && (current_word_ptr < PTR_heap_top_000008fc)); current_word_ptr++) {\n  }\n  return ((int)PTR_heap_top_000008fc - (int)current_word_ptr) & ~3;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000008b8",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "count_words_in_heap_000008b8"
        },
        "FUN_000024bc": {
            "renaming": {
                "FUN_000024bc": "acquire_mutex_000024bc",
                "mutex": "mutex",
                "state": "state",
                "plVar2": "node",
                "process_priority": "priority",
                "irqstate": "irqstate",
                "__m____": "__m____",
                "next": "next",
                "process": "thread",
                "bVar1": "bVar1"
            },
            "code": "void acquire_mutex_000024bc(mutex_t *mutex)\n{\n  uint state = disable_interrupts();\n  if (mutex->queue.next == NULL) {\n    restore_interrupts(state);\n  }\n  else if (mutex->queue.next == (list_node *)-1) {\n    mutex->queue.next = NULL;\n    restore_interrupts(state);\n  }\n  else {\n    list_node_t *node = list_remove_head(&mutex->queue);\n    thread_t *thread = (thread_t *)(node - 2);\n    set_thread_status(thread, THREAD_STATUS_BLOCKED);\n    if (mutex->queue.next == NULL) {\n      mutex->queue.next = (list_node *)-1;\n    }\n    uint16_t priority = *(uint16_t *)((int)&node[-1].next + 1);\n    restore_interrupts(state);\n    switch_to_thread(priority);\n  }\n}",
            "called": [
                "irq_disable",
                "irq_restore",
                "sched_set_status",
                "list_remove_head",
                "sched_switch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000024bc",
            "calling": [
                "isrpipe_write_one"
            ],
            "imported": false,
            "current_name": "acquire_mutex_000024bc"
        },
        "FUN_00000490": {
            "renaming": {
                "FUN_00000490": "read_from_uart_00000490",
                "r": "reent_ptr",
                "fd": "file_descriptor",
                "buffer": "buffer",
                "count": "count",
                "iVar1": "bytes_read"
            },
            "code": "_ssize_t read_from_uart_00000490(_reent *reent_ptr, int file_descriptor, void *buffer, size_t count)\n{\n  int bytes_read;\n  \n  bytes_read = uart_stdio_read((char *)buffer, count);\n  return bytes_read;\n}",
            "called": [
                "uart_stdio_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000490",
            "calling": [
                "__sread"
            ],
            "imported": false,
            "current_name": "read_from_uart_00000490"
        },
        "FUN_0000091c": {
            "renaming": {
                "FUN_0000091c": "get_isr_stack_pointer_0000091c",
                "PTR_isr_stack_0000092c": "isr_stack_pointer"
            },
            "code": "void * get_isr_stack_pointer_0000091c(void)\n{\n    return PTR_isr_stack_0000092c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000091c",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "get_isr_stack_pointer_0000091c"
        },
        "FUN_00005d80": {
            "renaming": {
                "FUN_00005d80": "writeChar_00005d80",
                "param_1": "stream",
                "param_2": "c",
                "param_3": "buffer",
                "iVar1": "count",
                "puVar2": "ptr"
            },
            "code": "uint writeChar_00005d80(int stream, uint c, undefined4 *buffer){\n  int count;\n  undefined *ptr;\n\n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n\n  if (buffer == (undefined4 *)PTR___sf_fake_stdin_00005e04) {\n    buffer = *(undefined4 **)(stream + 4);\n  }\n  else if (buffer == (undefined4 *)PTR___sf_fake_stdout_00005e08) {\n    buffer = *(undefined4 **)(stream + 8);\n  }\n  else if (buffer == (undefined4 *)PTR___sf_fake_stderr_00005e0c) {\n    buffer = *(undefined4 **)(stream + 0xc);\n  }\n\n  if ((-1 < (int)(buffer[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(buffer + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(buffer[0x16]);\n  }\n\n  count = buffer[2] + -1;\n  buffer[2] = count;\n\n  if ((count < 0) && ((count < (int)buffer[6] || ((c & 0xff) == 10)))) {\n    c = __swbuf_r(stream, c, buffer);\n  }\n  else {\n    ptr = (undefined *)*buffer;\n    *buffer = ptr + 1;\n    *ptr = (char)c;\n    c = c & 0xff;\n  }\n\n  if ((-1 < (int)(buffer[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(buffer + 3) << 0x16))) {\n    __retarget_lock_release_recursive(buffer[0x16]);\n  }\n\n  return c;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__swbuf_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005d80",
            "calling": [
                "putchar"
            ],
            "imported": false,
            "current_name": "writeChar_00005d80"
        },
        "FUN_00001f80": {
            "renaming": {
                "FUN_00001f80": "configure_gpio_pin_00001f80",
                "pin": "gpio_pin",
                "pcr": "pin_config_register",
                "pPVar1": "port_ptr",
                "iVar2": "pin_num",
                "uVar3": "previous_pcr_value",
                "isr_state": "interrupt_state",
                "clk_en": "enable_clock",
                "port": "get_port",
                "ctx_clear": "clear_ctx",
                "pin_00": "pin_num"
            },
            "code": "void configure_gpio_pin_00001f80(gpio_t pin, uint32_t pcr) {\n  PORT_Type *port_ptr;\n  int pin_num;\n  uint32_t previous_pcr_value;\n  uint32_t isr_state;\n  \n  enable_clock(pin);\n  port_ptr = get_port(pin);\n  pin_num = get_pin_num(pin);\n  previous_pcr_value = port_ptr->PCR[pin_num];\n  port_ptr->PCR[pin_num] = pcr;\n  if ((previous_pcr_value & 0xf0000) != 0) {\n    int port_num = get_port_num(pin);\n    int pin_num = get_pin_num(pin);\n    clear_ctx(port_num, pin_num);\n  }\n  return;\n}",
            "called": [
                "ctx_clear",
                "clk_en",
                "port",
                "port_num",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001f80",
            "calling": [
                "gpio_init",
                "uart_init_pins"
            ],
            "imported": false,
            "current_name": "configure_gpio_pin_00001f80"
        },
        "FUN_00000e64": {
            "renaming": {
                "FUN_00000e64": "initialize_cpu_and_gpio_00000e64",
                "DAT_00000ed0": "thread_list_offset",
                "DAT_00000ed4": "gpio_base_address",
                "thread_add_to_list": "thread_list_base_address"
            },
            "code": "void initialize_cpu_and_gpio_00000e64(void)\n{\n  uint32_t* thread_list_ptr = (uint32_t*) (thread_add_to_list + DAT_00000ed0 + 4);\n  *thread_list_ptr = *thread_list_ptr | 0x200;\n  uint32_t* gpio_ptr = (uint32_t*) (DAT_00000ed4 + 0x48);\n  *gpio_ptr = *gpio_ptr & 0xfefff8ff;\n  cpu_init();\n  gpio_init(0x2056, GPIO_OUT);\n  gpio_init(0x511a, GPIO_OUT);\n  gpio_init(0x2055, GPIO_OUT);\n  gpio_set(0x2056);\n  gpio_set(0x511a);\n  gpio_set(0x2055);\n  return;\n}",
            "called": [
                "gpio_set",
                "gpio_init",
                "cpu_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e64",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "initialize_cpu_and_gpio_00000e64"
        },
        "FUN_000026e4": {
            "renaming": {
                "FUN_000026e4": "power_off_rtt_000026e4",
                "rtt_poweroff": "rtt_poweroff"
            },
            "code": "void power_off_rtt_000026e4(void)\n{\n    rtt_poweroff();\n    return;\n}",
            "called": [
                "rtt_poweroff"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026e4",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "power_off_rtt_000026e4"
        },
        "FUN_00000d44": {
            "renaming": {
                "FUN_00000d44": "get_virtual_address_00000d44",
                "ptr": "memory_address",
                "bit": "bit_offset"
            },
            "code": "void * get_virtual_address_00000d44(void *memory_address, uintptr_t bit_offset) {\n    uintptr_t shifted_memory_address = (uintptr_t)memory_address;\n    uintptr_t high_bits = shifted_memory_address & 0xf0000000;\n    uintptr_t low_bits = shifted_memory_address & 0xfffff;\n    uintptr_t offset = (bit_offset * 4) + (high_bits | (low_bits << 5)) + 0x2000000;\n    return (void *)offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d44",
            "calling": [
                "bit_clear32"
            ],
            "imported": false,
            "current_name": "get_virtual_address_00000d44"
        },
        "FUN_00000698": {
            "renaming": {
                "FUN_00000698": "update_process_status_00000698",
                "process": "process_thread",
                "status": "new_status",
                "PTR_sched_runqueues_00000730": "ptr_sched_runqueues",
                "PTR_runqueue_bitcache_00000734": "ptr_runqueue_bitcache",
                "uint": "unsigned_int"
            },
            "code": "void update_process_status_00000698(thread_t *process, uint new_status) {\n    if (new_status < 9) {\n        if ((process->status > 8) && (clist_lpop((clist_node_t *)(PTR_sched_runqueues_00000730 + (uint)process->priority * 4)), *(int *)(PTR_sched_runqueues_00000730 + (uint)process->priority * 4) == 0)) {\n            *(uint *)PTR_runqueue_bitcache_00000734 &= ~(1 << process->priority);\n        }\n    }\n    else if (process->status < 9) {\n        clist_rpush((clist_node_t *)(PTR_sched_runqueues_00000730 + (uint)process->priority * 4), &process->rq_entry);\n        *(uint *)PTR_runqueue_bitcache_00000734 |= 1 << process->priority;\n    }\n    process->status = (uint8_t)new_status;\n}",
            "called": [
                "clist_lpop",
                "clist_rpush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000698",
            "calling": [
                "thread_create",
                "mutex_unlock",
                "sched_task_exit",
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "update_process_status_00000698"
        },
        "FUN_00000cd0": {
            "renaming": {
                "FUN_00000cd0": "get_IRQ_interrupts_enabled_status_00000cd0",
                "uVar2": "interrupts_enabled_status",
                "bVar1": "is_privileged_mode",
                "mask": "mask",
                "result": "result"
            },
            "code": "uint get_IRQ_interrupts_enabled_status_00000cd0(void)\n{\n    bool is_privileged_mode = (bool)isCurrentModePrivileged();\n    uint interrupts_enabled_status = 0;\n    if (is_privileged_mode) {\n        interrupts_enabled_status = isIRQinterruptsEnabled();\n    }\n    disableIRQinterrupts();\n    return interrupts_enabled_status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cd0",
            "calling": [
                "kinetis_mcg_init",
                "pm_off",
                "_sbrk_r",
                "thread_create",
                "mutex_unlock",
                "sched_task_exit",
                "_mutex_lock",
                "core_panic",
                "kernel_init"
            ],
            "imported": false,
            "current_name": "get_IRQ_interrupts_enabled_status_00000cd0"
        },
        "FUN_00000cc0": {
            "renaming": {
                "FUN_00000cc0": "panic_handler_00000cc0",
                "PTR_s_DUMMY_HANDLER_00000ccc": "dummy_handler"
            },
            "code": "void panic_handler_00000cc0(void)\n{\n    core_panic(PANIC_DUMMY_HANDLER, PTR_s_DUMMY_HANDLER_00000ccc);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cc0",
            "calling": [
                "dummy_handler"
            ],
            "imported": false,
            "current_name": "panic_handler_00000cc0"
        },
        "FUN_00002994": {
            "renaming": {
                "FUN_00002994": "check_rtt_interrupt_triggered_00002994",
                "DAT_000029f8": "rtt_data",
                "PTR_rtt_callback_000029fc": "rtt_callback",
                "iVar1": "rtt_data",
                "rtt": "not used",
                "rtt_flags": "rtt_flags",
                "rtt_ctrl": "rtt_ctrl"
            },
            "code": "void check_rtt_interrupt_triggered_00002994(void)\n{\n  int DAT_000029f8 = DAT_000029f8;\n  uint *rtt_flags = (uint *)(DAT_000029f8 + 0x14);\n  int *PTR_rtt_callback_000029fc = (int *)PTR_PTR_rtt_callback_000029fc_000029fc;\n  \n  if ((*rtt_flags & 4) && (*PTR_rtt_callback_000029fc != 0)) {\n    uint *rtt_ctrl = (uint *)(DAT_000029f8 + 0x1c);\n    *rtt_ctrl &= 0xfffffffb;\n    (*(void (*)(uint32_t))(*PTR_rtt_callback_000029fc))(PTR_rtt_callback_000029fc[1]);\n  }\n  \n  if ((*rtt_flags & 2) && (PTR_rtt_callback_000029fc[2] != 0)) {\n    (*(void (*)(uint32_t))PTR_rtt_callback_000029fc[2])(PTR_rtt_callback_000029fc[3]);\n  }\n  \n  cortexm_isr_end();\n  return;\n}",
            "called": [
                "cortexm_isr_end"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002994",
            "calling": [],
            "imported": false,
            "current_name": "check_rtt_interrupt_triggered_00002994"
        },
        "FUN_00000d2a": {
            "renaming": {
                "FUN_00000d2a": "get_current_exception_number_if_privileged_00000d2a",
                "uVar2": "current_exception_number",
                "bVar1": "is_privileged_mode"
            },
            "code": "uint32_t get_current_exception_number_if_privileged_00000d2a(void)\n{\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  uint32_t current_exception_number = 0;\n  if (is_privileged_mode) {\n    current_exception_number = getCurrentExceptionNumber();\n    current_exception_number = current_exception_number & 0x1f;\n  }\n  return current_exception_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d2a",
            "calling": [
                "sched_switch"
            ],
            "imported": false,
            "current_name": "get_current_exception_number_if_privileged_00000d2a"
        },
        "FUN_00001ff6": {
            "renaming": {
                "FUN_00001ff6": "set_gpio_pin_high_00001ff6",
                "pin": "gpio_pin",
                "uVar1": "pin_number",
                "pGVar2": "gpio_pin"
            },
            "code": "void set_gpio_pin_high_00001ff6(gpio_t pin)\n{\n  uint32_t pin_number = pin_num(pin);\n  GPIO_Type *gpio_pin = gpio(pin);\n  gpio_pin->PSOR = 1 << (pin_number & 0xff);\n  return;\n}",
            "called": [
                "gpio",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ff6",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_high_00001ff6"
        },
        "FUN_000013b8": {
            "renaming": {
                "FUN_000013b8": "initialize_uart_000013b8",
                "uart": "uart_num",
                "baudrate": "baud_rate",
                "rx_cb": "rx_callback",
                "arg": "callback_args",
                "core_panic": "panic",
                "PANIC_ASSERT_FAIL": "assertion_failure",
                "PTR_assert_crash_message_0000143c": "ASSERT_CRASH_MESSAGE",
                "PTR_config_00001440": "CONFIG_RX_CALLBACK",
                "PTR_uart_config_00001444": "UART_CONFIG_BASE_ADDRESS",
                "FUN_000013b8_pins": "initialize_uart_pins",
                "FUN_000013b8_uart": "initialize_uart_module"
            },
            "code": "int initialize_uart_000013b8(uart_t uart, uint32_t baudrate, uart_rx_cb_t rx_callback, void *callback_args) {\\n\\\n  int result = 0;\\n\\\n  if (uart != 0) {\\n\\\n    core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_0000143c);\\n\\\n  }\\n\\\n  *(uart_rx_cb_t *)PTR_config_00001440 = rx_callback;\\n\\\n  *(void **)CONFIG_CALLBACK_ARGS = callback_args;\\n\\\n  initialize_uart_000013b8_pins(0);\\n\\\n  bit_set32(*(uint32_t **)PTR_uart_config_00001444 + 0x18, PTR_uart_config_00001444[0x1c]);\\n\\\n  if (PTR_uart_config_00001444[0x1e] == \"\\0\") {\\n\\\n    initialize_uart_000013b8_module(0, baudrate);\\n\\\n  }\\n\\\n  else {\\n\\\n    result = -1;\\n\\\n  }\\n\\\n  return result;\\n\\\n}",
            "called": [
                "uart_init_pins",
                "uart_init_uart",
                "core_panic",
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000013b8",
            "calling": [
                "uart_stdio_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_000013b8"
        },
        "FUN_00000f80": {
            "renaming": {
                "FUN_00000f80": "infinite_loop_00000f80",
                "arg": "arg"
            },
            "code": "void *infinite_loop_00000f80(void *arg)\n{\n  while(true)\n  {\n    // Do nothing\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f80",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_00000f80"
        },
        "FUN_00002a88": {
            "renaming": {
                "FUN_00002a88": "print_shell_commands_00002a88",
                "command_list": "input_command_list",
                "i": "index",
                "entry": "current_command"
            },
            "code": "void print_shell_commands_00002a88(shell_command_t *command_list)\n{\n  shell_command_t *command_lists[2];\n  uint32_t index;\n  shell_command_t *current_command;\n  iprintf(\"%s\\t%s\\n\", \"Command\", \"Description\");\n  puts(\"--------------------------------------------------\");\n  command_lists[0] = command_list;\n  command_lists[1] = (shell_command_t *)PTR__shell_command_list_00002b0c;\n  for (index = 0; index < 2; index++) {\n    current_command = command_lists[index];\n    if (current_command != (shell_command_t *)0x0) {\n      for (; current_command->name != (char *)0x0; current_command++) {\n        iprintf(\"%s\\t%s\\n\", current_command->name, current_command->desc);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "iprintf",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a88",
            "calling": [
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "print_shell_commands_00002a88"
        },
        "FUN_00002f30": {
            "renaming": {
                "FUN_00002f30": "print_saul_reg_devices_00002f30",
                "i": "device_count",
                "dev": "current_device"
            },
            "code": "void print_saul_reg_devices_00002f30(void)\n{\n  int device_count = 0;\n  saul_reg_t *current_device = *(saul_reg_t **)PTR_saul_reg_00002f6c;\n  while (current_device != (saul_reg_t *)0x0) {\n    probe(device_count, current_device);\n    puts(PTR_DAT_00002f70);\n    device_count++;\n    current_device = current_device->next;\n  }\n  return;\n}",
            "called": [
                "puts",
                "probe"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f30",
            "calling": [
                "read"
            ],
            "imported": false,
            "current_name": "print_saul_reg_devices_00002f30"
        },
        "FUN_00001e44": {
            "renaming": {
                "FUN_00001e44": "set_pin_context_00001e44",
                "port": "port_num",
                "pin": "pin_num",
                "ctx": "context",
                "iVar1": "pin_offset",
                "PTR_isr_map_00001ec0": "isr_map_ptr",
                "uint": "unsigned int",
                "mask": "mask"
            },
            "code": "void set_pin_context_00001e44(int port_num, int pin_num, int context) {\n    int pin_offset = pin_num >> 3;\n    uint *PTR_isr_map_00001ec0 = PTR_isr_map_00001ec0 + (pin_offset + port_num * 4) * 4;\n    uint mask = 0xf << ((pin_num & 7U) << 2);\n    *PTR_isr_map_00001ec0 = (*PTR_isr_map_00001ec0 & ~mask) | (context << ((pin_num & 7U) << 2));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e44",
            "calling": [
                "ctx_clear"
            ],
            "imported": false,
            "current_name": "set_pin_context_00001e44"
        },
        "FUN_00001318": {
            "renaming": {
                "FUN_00001318": "set_interrupt_priority_00001318",
                "IRQn": "interrupt",
                "DAT_00001344": "interrupt_enable_reg",
                "interrupt_bit_mask": "interrupt_bit_mask"
            },
            "code": "void set_interrupt_priority_00001318(IRQn_Type interrupt)\n{\n    int* DAT_00001344 = (int*)(DAT_00001344 + ((uint)(int)interrupt >> 5) * 4);\n    int interrupt_bit_mask = 1 << (interrupt & 0x1fU);\n    *DAT_00001344 = interrupt_bit_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001318",
            "calling": [
                "uart_init_uart"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_00001318"
        },
        "FUN_00000900": {
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "pvVar1": "main_stack_pointer",
                "result": "result",
                "msp": "msp"
            },
            "code": "void *get_main_stack_pointer_00000900(void)\n{\n  void *main_stack_pointer;\n  main_stack_pointer = (void *)getMainStackPointer();\n  return main_stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000900",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "get_main_stack_pointer_00000900"
        },
        "FUN_00004274": {
            "renaming": {
                "FUN_00004274": "acquire_recursive_lock_00004274",
                "PTR___lock___sfp_recursive_mutex_0000427c": "sfp_recursive_mutex"
            },
            "code": "void acquire_recursive_lock_00004274(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___sfp_recursive_mutex_0000427c);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004274",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_00004274"
        },
        "FUN_00002fe0": {
            "renaming": {
                "FUN_00002fe0": "device_probe_00002fe0",
                "argc": "argument_count",
                "argv": "argument_values",
                "dev_00": "device_pointer",
                "dev": "device",
                "num": "device_number",
                "PTR_s_usage___s__s__device_id__all_00003050": "usage_string",
                "PTR_DAT_00003054": "all_devices_string",
                "saul_reg_t": "device_registry",
                "atoi": "string_to_integer",
                "saul_reg_find_nth": "find_device_by_number",
                "PTR_s_error__undefined_device_id_given_00003058": "undefined_device_error_string",
                "probe_all": "probe_all_devices",
                "probe": "probe_device"
            },
            "code": "void device_probe_00002fe0(int argc, char **argv) {\n  int device_id;\n  saul_reg_t *device;\n  if (argc < 3) {\n    iprintf(PTR_s_usage___s__s__device_id__all_00003050, *argv, argv[1]);\n  }\n  else {\n    if (!strcmp(argv[2], PTR_DAT_00003054)) {\n      probe_all();\n    }\n    else {\n      device_id = atoi(argv[2]);\n      device = saul_reg_find_nth(device_id);\n      if (device == (saul_reg_t *)0x0) {\n        puts(PTR_s_error__undefined_device_id_given_00003058);\n      }\n      else {\n        probe(device_id, device);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "saul_reg_find_nth",
                "atoi",
                "iprintf",
                "probe_all",
                "strcmp",
                "puts",
                "probe"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002fe0",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "device_probe_00002fe0"
        },
        "FUN_00001dc0": {
            "renaming": {
                "FUN_00001dc0": "get_gpio_pin_number_00001dc0",
                "pin": "gpio_pin",
                "MAX_PIN_NUMBER": "max_pin_number"
            },
            "code": "int get_gpio_pin_number_00001dc0(gpio_t pin)\n{\n    const int MAX_PIN_NUMBER = 0x3f;\n    return pin & MAX_PIN_NUMBER;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001dc0",
            "calling": [
                "gpio_set",
                "gpio_init",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "get_gpio_pin_number_00001dc0"
        },
        "FUN_00000df4": {
            "renaming": {
                "FUN_00000df4": "initialize_uart_00000df4",
                "DAT_00000e10": "parity",
                "PTR_uart_stdio_isrpipe_00000e0c": "stop_bits"
            },
            "code": "void initialize_uart_00000df4(void)\n{\n  int baud_rate = 115200;\n  int clock_freq = 80000000;\n  int DAT_00000e10 = 0;\n  int PTR_uart_stdio_isrpipe_00000e0c = 1;\n  uart_init(0, baud_rate, clock_freq, DAT_00000e10, PTR_uart_stdio_isrpipe_00000e0c);\n  return;\n}",
            "called": [
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000df4",
            "calling": [
                "_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_00000df4"
        },
        "FUN_00002400": {
            "renaming": {
                "FUN_00002400": "do_nothing_00002400"
            },
            "code": "\nvoid do_nothing_00002400(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002400",
            "calling": [
                "main_trampoline"
            ],
            "imported": false,
            "current_name": "do_nothing_00002400"
        },
        "FUN_00002eb4": {
            "renaming": {
                "FUN_00002eb4": "print_status_00002eb4",
                "argc": "num_args",
                "argv": "arg_list",
                "ps": "print_status"
            },
            "code": "int print_status_00002eb4(int num_args, char **arg_list) {\n  print_status_00002eb4();\n  return 0;\n}",
            "called": [
                "ps"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002eb4",
            "calling": [],
            "imported": false,
            "current_name": "print_status_00002eb4"
        },
        "FUN_0000328c": {
            "renaming": {
                "FUN_0000328c": "parse_time_string_0000328c",
                "argv": "time_str",
                "time": "time_struct",
                "lVar1": "time_value",
                "end": "end_ptr",
                "i": "short_value",
                "dow": "calculate_day_of_week"
            },
            "code": "int parse_time_string_0000328c(char **time_str, tm *time_struct) {\n  long time_value;\n  int day_of_week;\n  char *end_ptr;\n  short short_value;\n\n  time_value = strtol(*time_str, &end_ptr, 10);\n  short_value = (short)time_value;\n  time_struct->tm_year = short_value - 1900;\n\n  time_value = strtol(end_ptr + 1, &end_ptr, 10);\n  short_value = (short)time_value;\n  time_struct->tm_mon = short_value - 1;\n\n  time_value = strtol(end_ptr + 1, &end_ptr, 10);\n  time_struct->tm_mday = (int)time_value;\n\n  time_value = strtol(*(time_str + 1), &end_ptr, 10);\n  time_struct->tm_hour = (int)time_value;\n\n  time_value = strtol(end_ptr + 1, &end_ptr, 10);\n  time_struct->tm_min = (int)time_value;\n\n  time_value = strtol(end_ptr + 1, &end_ptr, 10);\n  time_struct->tm_sec = (int)time_value;\n\n  day_of_week = calculate_day_of_week(time_struct->tm_year + 1900, time_struct->tm_mon + 1, time_struct->tm_mday);\n  time_struct->tm_wday = day_of_week;\n  time_struct->tm_isdst = -1;\n  return 0;\n}",
            "called": [
                "dow",
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000328c",
            "calling": [
                "_rtc_setalarm",
                "_rtc_settime"
            ],
            "imported": false,
            "current_name": "parse_time_string_0000328c"
        },
        "FUN_000041f4": {
            "renaming": {
                "FUN_000041f4": "initialize_data_structure_000041f4",
                "param_1": "data_structure",
                "param_2": "data_1",
                "param_3": "data_2",
                "*param_1": "*data_structure",
                "param_1[1]": "data_structure[1]",
                "param_1[2]": "data_structure[2]",
                "*(undefined2 *)(param_1 + 3)": "data_structure[3]",
                "param_1[4]": "data_structure[4]",
                "param_1[5]": "data_structure[5]",
                "param_1[6]": "data_structure[6]",
                "memset(param_1 + 0x17,0,8)": "memset(data_structure + 7, 0, 8)",
                "param_1[9]": "PTR_DAT_0000422c",
                "param_1[10]": "PTR_DAT_00004230",
                "param_1[11]": "PTR_DAT_00004234",
                "param_1[12]": "PTR_DAT_00004238",
                "param_1[8]": "data_structure"
            },
            "code": "void initialize_data_structure_000041f4(undefined4 *data_structure, undefined2 data_1, undefined2 data_2)\n{\n    *data_structure = 0;\n    data_structure[1] = 0;\n    data_structure[2] = 0;\n    data_structure[3] = data_1;\n    data_structure[4] = 0;\n    data_structure[5] = 0;\n    data_structure[6] = 0;\n    memset(data_structure + 7, 0, 8);\n    data_structure[9] = PTR_DAT_0000422c;\n    data_structure[10] = PTR_DAT_00004230;\n    data_structure[11] = PTR_DAT_00004234;\n    data_structure[12] = PTR_DAT_00004238;\n    data_structure[8] = data_structure;\n}\n",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041f4",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_000041f4"
        },
        "FUN_0000316c": {
            "renaming": {
                "FUN_0000316c": "handle_arguments_0000316c",
                "argc": "argument_count",
                "argv": "arguments",
                "list": "list_directory",
                "PTR_DAT_000031d4": "FILE_READ",
                "read": "read_file",
                "PTR_s_write_000031d8": "FILE_WRITE",
                "write": "write_file",
                "iprintf": "print_usage",
                "PTR_s_usage___s_read_write_000031dc": "USAGE_MESSAGE"
            },
            "code": "int handle_arguments_0000316c(int argument_count, char **arguments)\n{\n  int comparison_result;\n  if (argument_count < 2) {\n    list_directory();\n  }\n  else {\n    comparison_result = strcmp(arguments[1],PTR_DAT_000031d4);\n    if (comparison_result == 0) {\n      read_file(argument_count,arguments);\n    }\n    else {\n      comparison_result = strcmp(arguments[1],PTR_s_write_000031d8);\n      if (comparison_result == 0) {\n        write_file(argument_count,arguments);\n      }\n      else {\n        print_usage(PTR_s_usage___s_read_write_000031dc,*arguments);\n      }\n    }\n  }\n  return 0;\n}",
            "called": [
                "read",
                "iprintf",
                "strcmp",
                "write",
                "list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000316c",
            "calling": [],
            "imported": false,
            "current_name": "handle_arguments_0000316c"
        },
        "FUN_000026f0": {
            "renaming": {
                "FUN_000026f0": "check_rtc_callback_000026f0",
                "arg": "argument",
                "PTR_rtc_callback_00002710": "callback_ptr",
                "int": "int",
                "code": "code",
                "callback_function": "callback_function"
            },
            "code": "void check_rtc_callback_000026f0(void *argument)\n{\n  int *PTR_rtc_callback_00002710 = (int *)PTR_rtc_callback_00002710;\n  if (*PTR_rtc_callback_00002710 != 0) {\n    code *callback_function = *(code **)PTR_rtc_callback_00002710;\n    (*callback_function)(argument);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026f0",
            "calling": [],
            "imported": false,
            "current_name": "check_rtc_callback_000026f0"
        },
        "FUN_0000510c": {
            "renaming": {
                "FUN_0000510c": "set_time_zone_info_0000510c",
                "param_1": "env_buf",
                "puVar1": "prev_tzenv",
                "puVar2": "tzname_buf",
                "puVar3": "tzname_ptr",
                "iVar4": "tzinfo",
                "pcVar5": "tzenv_val",
                "__ptr": "prev_tzname_buf",
                "sVar6": "tzenv_val_len",
                "pcVar7": "tzenv_val_ptr",
                "iVar8": "scan_res",
                "iVar9": "scan_res_2",
                "uVar10": "day_offset",
                "cVar11": "date_type",
                "bVar12": "is_first_date",
                "puVar13": "date_parts_ptr",
                "piVar14": "date_parts_read",
                "puVar15": "time_parts_ptr",
                "piVar16": "time_parts_read",
                "local_3c": "month",
                "local_3a": "day",
                "local_38": "year",
                "local_36": "hour",
                "local_34": "min",
                "local_32": "sec",
                "local_30": "scan_offset",
                "local_2c": "strtoul_end_ptr"
            },
            "code": "\nvoid set_time_zone_info_0000510c(undefined4 env_buf)\n\n{\n  undefined *prev_tzenv;\n  undefined *tzname_buf;\n  undefined *tzname_ptr;\n  int tzinfo;\n  char *tzenv_val;\n  void *prev_tzname_buf;\n  size_t tzenv_val_len;\n  char *tzenv_val_ptr;\n  int scan_res;\n  int scan_res_2;\n  ulong day_offset;\n  char date_type;\n  bool is_first_date;\n  ushort *date_parts_ptr;\n  int *date_parts_read;\n  ushort *time_parts_ptr;\n  int *time_parts_read;\n  ushort month;\n  ushort day;\n  ushort year;\n  ushort hour;\n  ushort min;\n  ushort sec;\n  int scan_offset;\n  char *strtoul_end_ptr [2];\n  \n  tzinfo = __gettzinfo();\n  prev_tzenv = PTR_prev_tzenv_000053d8;\n  tzenv_val = (char *)_getenv_r(env_buf,PTR_DAT_000053d4);\n  tzname_buf = PTR_LAB_00007a5e_1_000053e0;\n  if (tzenv_val == (char *)0x0) {\n    *(undefined4 *)PTR__timezone_000053dc = 0;\n    *(undefined4 *)PTR__daylight_000053e4 = 0;\n    tzname_ptr = PTR__tzname_000053e8;\n    prev_tzname_buf = *(void **)prev_tzenv;\n    *(undefined **)PTR__tzname_000053e8 = tzname_buf;\n    *(undefined **)(tzname_ptr + 4) = tzname_buf;\n    free(prev_tzname_buf);\n    *(undefined4 *)prev_tzenv = 0;\n  }\n  else if ((*(char **)prev_tzenv == (char *)0x0) ||\n          (scan_res = strcmp(tzenv_val,*(char **)prev_tzenv), scan_res != 0)) {\n    free(*(void **)prev_tzenv);\n    tzenv_val_len = strlen(tzenv_val);\n    tzenv_val_ptr = (char *)_malloc_r(env_buf,tzenv_val_len + 1);\n    *(char **)prev_tzenv = tzenv_val_ptr;\n    if (tzenv_val_ptr != (char *)0x0) {\n      strcpy(tzenv_val_ptr,tzenv_val);\n    }\n    if (*tzenv_val == ':') {\n      tzenv_val = tzenv_val + 1;\n    }\n    scan_res = siscanf(tzenv_val,PTR_s__10__0_9_____n_000053f0,PTR___tzname_std_000053ec,&scan_offset);\n    if (0 < scan_res) {\n      tzenv_val_ptr = tzenv_val + scan_offset;\n      if (tzenv_val[scan_offset] == '-') {\n        tzenv_val_ptr = tzenv_val_ptr + 1;\n        scan_res = -1;\n      }\n      else {\n        if (tzenv_val[scan_offset] == '+') {\n          tzenv_val_ptr = tzenv_val_ptr + 1;\n        }\n        scan_res = 1;\n      }\n      day = 0;\n      year = 0;\n      date_parts_ptr = &day;\n      date_parts_read = &scan_offset;\n      time_parts_ptr = &year;\n      time_parts_read = &scan_offset;\n      scan_res_2 = siscanf(tzenv_val_ptr,PTR_s__hu_n__hu_n__hu_n_000053f4,&month,&scan_offset,&day,\n                      &scan_offset,&year,&scan_offset);\n      prev_tzenv = PTR___tzname_dst_00005400;\n      if (0 < scan_res_2) {\n        *(uint *)(tzinfo + 0x28) =\n             ((uint)month * 0xe10 + (uint)day * 0x3c + (uint)year) * scan_res;\n        tzname_buf = PTR__tzname_000053e8;\n        *(undefined **)PTR__tzname_000053e8 = PTR___tzname_std_000053ec;\n        tzenv_val_ptr = tzenv_val_ptr + scan_offset;\n        scan_res = siscanf(tzenv_val_ptr,PTR_s__10__0_9_____n_000053f0,prev_tzenv,&scan_offset,date_parts_ptr,date_parts_read,\n                        time_parts_ptr,time_parts_read);\n        if (scan_res < 1) {\n          *(undefined4 *)(tzname_buf + 4) = *(undefined4 *)tzname_buf;\n          *(undefined4 *)PTR__timezone_000053dc = *(undefined4 *)(tzinfo + 0x28);\n          *(undefined4 *)PTR__daylight_000053e4 = 0;\n        }\n        else {\n          *(undefined **)(tzname_buf + 4) = prev_tzenv;\n          tzenv_val = tzenv_val_ptr + scan_offset;\n          if (tzenv_val_ptr[scan_offset] == '-') {\n            tzenv_val = tzenv_val + 1;\n            scan_res = -1;\n          }\n          else {\n            if (tzenv_val_ptr[scan_offset] == '+') {\n              tzenv_val = tzenv_val + 1;\n            }\n            scan_res = 1;\n          }\n          month = 0;\n          day = 0;\n          year = 0;\n          scan_offset = 0;\n          scan_res_2 = siscanf(tzenv_val,PTR_s__hu_n__hu_n__hu_n_000053f4,&month,&scan_offset,&day,\n                          &scan_offset,&year,&scan_offset);\n          if (scan_res_2 < 1) {\n            scan_res = *(int *)(tzinfo + 0x28) + -0xe10;\n          }\n          else {\n            scan_res = ((uint)month * 0xe10 + (uint)day * 0x3c + (uint)year) * scan_res;\n          }\n          *(int *)(tzinfo + 0x50) = scan_res;\n          tzenv_val = tzenv_val + scan_offset;\n          is_first_date = false;\n          scan_res = tzinfo;\n          while( true ) {\n            if (*tzenv_val == ',') {\n              tzenv_val = tzenv_val + 1;\n            }\n            date_type = *tzenv_val;\n            if (date_type == 'M') {\n              scan_res_2 = siscanf(tzenv_val,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&hour,&scan_offset,&min\n                              ,&scan_offset,&sec,&scan_offset);\n              if (scan_res_2 != 3) {\n                return;\n              }\n              if (0xb < hour - 1) {\n                return;\n              }\n              if (4 < min - 1) {\n                return;\n              }\n              if (6 < sec) {\n                return;\n              }\n              *(uint *)(scan_res + 0xc) = (uint)hour;\n              *(uint *)(scan_res + 0x10) = (uint)min;\n              *(undefined *)(scan_res + 8) = 0x4d;\n              *(uint *)(scan_res + 0x14) = (uint)sec;\n              tzenv_val_ptr = tzenv_val + scan_offset;\n            }\n            else {\n              if (date_type == 'J') {\n                tzenv_val = tzenv_val + 1;\n              }\n              else {\n                date_type = 'D';\n              }\n              day_offset = strtoul(tzenv_val,strtoul_end_ptr,10);\n              sec = (ushort)day_offset;\n              tzenv_val_ptr = strtoul_end_ptr[0];\n              if (strtoul_end_ptr[0] == tzenv_val) {\n                if (is_first_date) {\n                  *(undefined *)(tzinfo + 0x30) = 0x4d;\n                  *(undefined4 *)(tzinfo + 0x34) = 0xb;\n                  *(undefined4 *)(tzinfo + 0x38) = 1;\n                  *(undefined4 *)(tzinfo + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(tzinfo + 8) = 0x4d;\n                  *(undefined4 *)(tzinfo + 0xc) = 3;\n                  *(undefined4 *)(tzinfo + 0x10) = 2;\n                  *(undefined4 *)(tzinfo + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(scan_res + 8) = date_type;\n                *(ulong *)(scan_res + 0x14) = day_offset & 0xffff;\n              }\n            }\n            month = 2;\n            day = 0;\n            year = 0;\n            scan_offset = 0;\n            if (*tzenv_val_ptr == '/') {\n              siscanf(tzenv_val_ptr,PTR_DAT_000053fc,&month,&scan_offset,&day,&scan_offset,&year,\n                      &scan_offset);\n            }\n            *(uint *)(scan_res + 0x18) =\n                 (uint)month * 0xe10 + (uint)day * 0x3c + (uint)year;\n            scan_res = scan_res + 0x28;\n            tzenv_val = tzenv_val_ptr + scan_offset;\n            if (is_first_date) break;\n            is_first_date = true;\n          }\n          __tzcalc_limits(*(undefined4 *)(tzinfo + 4));\n          scan_res = *(int *)(tzinfo + 0x28);\n          *(int *)PTR__timezone_000053dc = scan_res;\n          scan_res = *(int *)(tzinfo + 0x50) - scan_res;\n          if (scan_res != 0) {\n            scan_res = 1;\n          }\n          *(int *)PTR__daylight_000053e4 = scan_res;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "__gettzinfo",
                "__tzcalc_limits",
                "_getenv_r",
                "strcpy",
                "siscanf",
                "strlen",
                "strcmp",
                "free",
                "_malloc_r",
                "strtoul"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000510c",
            "calling": [
                "_tzset_unlocked"
            ],
            "imported": false,
            "current_name": "set_time_zone_info_0000510c"
        },
        "FUN_000057d2": {
            "renaming": {
                "FUN_000057d2": "copy_string_to_buffer_000057d2",
                "param_1": "file_descriptor",
                "param_2": "flags",
                "param_3": "source_string",
                "param_4": "buffer_size",
                "iVar1": "chars_written",
                "puVar2": "end_of_string",
                "iVar3": "chars_written"
            },
            "code": "int copy_string_to_buffer_000057d2(int file_descriptor, int flags, char *source_string, int buffer_size)\n{\n  int chars_written = 0;\n  char *end_of_string = source_string + buffer_size;\n  while (source_string != end_of_string)\n  {\n    if (source_string == end_of_string)\n    {\n      return 0;\n    }\n    chars_written = __sfputc_r(file_descriptor, *source_string, flags, buffer_size, chars_written);\n    buffer_size = chars_written + 1;\n    source_string = source_string + 1;\n  }\n  return chars_written;\n}",
            "called": [
                "__sfputc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057d2",
            "calling": [
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "copy_string_to_buffer_000057d2"
        },
        "FUN_00000958": {
            "renaming": {
                "FUN_00000958": "schedule_active_thread_00000958",
                "PTR_sched_active_thread_00000970": "sched_active_thread",
                "PTR_sched_active_thread_0000098c": "sched_active_thread",
                "unaff_r11": "r11_register",
                "unaff_r10": "r10_register",
                "unaff_r9": "r9_register",
                "unaff_r8": "r8_register",
                "unaff_r7": "r7_register",
                "unaff_r6": "r6_register",
                "unaff_r5": "r5_register",
                "unaff_r4": "r4_register",
                "in_lr": "lr_register",
                "bVar1": "is_privileged_mode",
                "iVar2": "process_stack_pointer",
                "UNRECOVERED_JUMPTABLE": "jump_table",
                "ppcVar3": "function_pointer"
            },
            "code": "void schedule_active_thread_00000958(void)\n{\n  bool is_privileged_mode;\n  int process_stack_pointer;\n  code *jump_table;\n  code **function_pointer;\n  undefined4 lr_register;\n  undefined4 r4_register;\n  undefined4 r5_register;\n  undefined4 r6_register;\n  undefined4 r7_register;\n  undefined4 r8_register;\n  undefined4 r9_register;\n  undefined4 r10_register;\n  undefined4 r11_register;\n  \n  process_stack_pointer = getProcessStackPointer();\n  *(undefined4 *)(process_stack_pointer - 4) = r11_register;\n  *(undefined4 *)(process_stack_pointer - 8) = r10_register;\n  *(undefined4 *)(process_stack_pointer - 0xc) = r9_register;\n  *(undefined4 *)(process_stack_pointer - 0x10) = r8_register;\n  *(undefined4 *)(process_stack_pointer - 0x14) = r7_register;\n  *(undefined4 *)(process_stack_pointer - 0x18) = r6_register;\n  *(undefined4 *)(process_stack_pointer - 0x1c) = r5_register;\n  *(undefined4 *)(process_stack_pointer - 0x20) = r4_register;\n  *(undefined4 *)(process_stack_pointer - 0x24) = lr_register;\n  **(int **)PTR_PTR_sched_active_thread_0000098c_00000970 = (int)(undefined4 *)(process_stack_pointer - 0x24);\n  isr_svc();\n  sched_run();\n  jump_table = *(code **)**(undefined4 **)PTR_PTR_sched_active_thread_0000098c_00000970;\n  function_pointer = (code **)**(undefined4 **)PTR_PTR_sched_active_thread_0000098c_00000970 + 9;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    setProcessStackPointer(function_pointer);\n  }\n  (*jump_table)(jump_table,function_pointer);\n  return;\n}",
            "called": [
                "isr_svc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000958",
            "calling": [],
            "imported": false,
            "current_name": "schedule_active_thread_00000958"
        },
        "FUN_000056b8": {
            "renaming": {
                "FUN_000056b8": "check_file_type_000056b8",
                "param_1": "reent",
                "param_2": "file_descriptor",
                "param_3": "file_type",
                "param_4": "error_code",
                "iVar1": "status",
                "uVar2": "file_type_value",
                "sStack_68": "file_status"
            },
            "code": "int check_file_type_000056b8(_reent *reent, int file_descriptor, uint32_t *file_type, uint32_t *error_code)\n{\n    int status;\n    struct stat file_status;\n    status = fstat(file_descriptor, &file_status);\n    if ((file_status.st_mode & S_IFMT) == S_IFREG)\n    {\n        *file_type = FILE_TYPE_REGULAR;\n    }\n    else if ((file_status.st_mode & S_IFMT) == S_IFDIR)\n    {\n        *file_type = FILE_TYPE_DIRECTORY;\n    }\n    else if ((file_status.st_mode & S_IFMT) == S_IFLNK)\n    {\n        *file_type = FILE_TYPE_SYMLINK;\n    }\n    else\n    {\n        *file_type = FILE_TYPE_OTHER;\n    }\n    if (status < 0)\n    {\n        *error_code = FILE_ERROR;\n        return -1;\n    }\n    *error_code = FILE_OK;\n    return 0;\n}",
            "called": [
                "_fstat_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b8",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_file_type_000056b8"
        },
        "FUN_00001a18": {
            "renaming": {
                "FUN_00001a18": "enable_pll_and_set_mode_to_4_00001a18",
                "DAT_00001a34": "pll_enable_byte",
                "PTR_current_mode_00001a38": "current_mode_ptr",
                "bit_set8": "set_bit_in_byte",
                "kinetis_mcg_disable_pll": "disable_pll"
            },
            "code": "void enable_pll_and_set_mode_to_4_00001a18(void)\n{\n  set_bit_in_byte(DAT_00001a34, 0x01);\n  disable_pll();\n  *PTR_current_mode_00001a38 = 4;\n  return;\n}",
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a18",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "enable_pll_and_set_mode_to_4_00001a18"
        },
        "FUN_00000d9c": {
            "renaming": {
                "FUN_00000d9c": "clear_null_terminator_00000d9c",
                "DAT_00000dac": "data_buffer"
            },
            "code": "void clear_null_terminator_00000d9c(void)\n{\n  bit_clear32(DAT_00000dac, '\\0');\n  return;\n}",
            "called": [
                "bit_clear32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d9c",
            "calling": [
                "pre_startup"
            ],
            "imported": false,
            "current_name": "clear_null_terminator_00000d9c"
        },
        "FUN_00003ff4": {
            "renaming": {
                "FUN_00003ff4": "shift_and_pad_string_00003ff4",
                "out": "output",
                "in_len": "input_length",
                "pad_len": "padded_length",
                "pad_char": "padding_character",
                "sVar1": "padded_length_or_input_length",
                "n": "not_used"
            },
            "code": "size_t shift_and_pad_string_00003ff4(char *output, size_t input_length, size_t padded_length, char padding_character)\n{\n  size_t padded_length_or_input_length;\n  if ((input_length < padded_length) && (output != NULL)) {\n    memmove(output + (padded_length - input_length), output, input_length);\n    memset(output, (uint)(byte)padding_character, padded_length - input_length);\n    padded_length_or_input_length = padded_length;\n  } else {\n    padded_length_or_input_length = input_length;\n  }\n  return padded_length_or_input_length;\n}",
            "called": [
                "memset",
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ff4",
            "calling": [
                "fmt_s32_dfp"
            ],
            "imported": false,
            "current_name": "shift_and_pad_string_00003ff4"
        },
        "FUN_00004634": {
            "renaming": {
                "FUN_00004634": "update_date_00004634",
                "param_1": "date_components",
                "param_2": "days_to_add",
                "param_3": "unused",
                "puVar1": "days_in_month",
                "iVar2": "days_in_current_month",
                "uVar3": "year",
                "uVar4": "temp",
                "iVar5": "days_in_february",
                "bVar6": "is_negative",
                "local_20": "quotient",
                "local_1c": "remainder",
                "uStack_18": "unused"
            },
            "code": "\nvoid update_date_00004634(uint *date_components,uint days_to_add,undefined4 unused)\n\n{\n  undefined *days_in_month;\n  int days_in_current_month;\n  uint year;\n  uint temp;\n  int days_in_february;\n  bool is_negative;\n  uint *quotient;\n  uint remainder;\n  undefined4 unused;\n  \n  quotient = date_components;\n  remainder = days_to_add;\n  unused = unused;\n  if (0x3b < *date_components) {\n    div((int)&quotient,*date_components);\n    year = date_components[1] + (int)quotient;\n    date_components[1] = year;\n    if ((int)remainder < 0) {\n      year = year - 1;\n      *date_components = remainder + 0x3c;\n    }\n    else {\n      *date_components = remainder;\n    }\n    if ((int)remainder < 0) {\n      date_components[1] = year;\n    }\n  }\n  if (0x3b < date_components[1]) {\n    div((int)&quotient,date_components[1]);\n    is_negative = (int)remainder < 0;\n    temp = date_components[2] + (int)quotient;\n    date_components[2] = temp;\n    year = remainder;\n    if (is_negative) {\n      year = remainder + 0x3c;\n      temp = temp - 1;\n    }\n    if (!is_negative) {\n      date_components[1] = year;\n    }\n    if (is_negative) {\n      date_components[1] = year;\n    }\n    if (is_negative) {\n      date_components[2] = temp;\n    }\n  }\n  if (0x17 < date_components[2]) {\n    div((int)&quotient,date_components[2]);\n    is_negative = (int)remainder < 0;\n    temp = date_components[3] + (int)quotient;\n    date_components[3] = temp;\n    year = remainder;\n    if (is_negative) {\n      year = remainder + 0x18;\n      temp = temp - 1;\n    }\n    if (!is_negative) {\n      date_components[2] = year;\n    }\n    if (is_negative) {\n      date_components[2] = year;\n    }\n    if (is_negative) {\n      date_components[3] = temp;\n    }\n  }\n  if (0xb < date_components[4]) {\n    div((int)&quotient,date_components[4]);\n    is_negative = (int)remainder < 0;\n    year = date_components[5] + (int)quotient;\n    date_components[5] = year;\n    if (is_negative) {\n      remainder = remainder + 0xc;\n      year = year - 1;\n    }\n    if (!is_negative) {\n      date_components[4] = remainder;\n    }\n    if (is_negative) {\n      date_components[4] = remainder;\n    }\n    if (is_negative) {\n      date_components[5] = year;\n    }\n  }\n  days_in_month = PTR_DAYS_IN_MONTH_000047e0;\n  year = date_components[5];\n  if ((year & 3) == 0) {\n    if (year == (year / 100) * 100) {\n      if ((year + 0x76c) % 400 == 0) {\n        days_in_february = 0x1d;\n      }\n      else {\n        days_in_february = 0x1c;\n      }\n    }\n    else {\n      days_in_february = 0x1d;\n    }\n  }\n  else {\n    days_in_february = 0x1c;\n  }\n  if ((int)date_components[3] < 1) {\n    while ((int)date_components[3] < 1) {\n      year = date_components[4];\n      date_components[4] = year - 1;\n      if (year - 1 == 0xffffffff) {\n        temp = date_components[5];\n        year = temp - 1;\n        date_components[4] = 0xb;\n        date_components[5] = year;\n        if ((year & 3) == 0) {\n          if (year == (year / 100) * 100) {\n            if ((temp + 0x76b) % 400 == 0) {\n              days_in_february = 0x1d;\n            }\n            else {\n              days_in_february = 0x1c;\n            }\n          }\n          else {\n            days_in_february = 0x1d;\n          }\n        }\n        else {\n          days_in_february = 0x1c;\n        }\n      }\n      days_in_current_month = days_in_february;\n      if (date_components[4] != 1) {\n        days_in_current_month = *(int *)(days_in_month + date_components[4] * 4);\n      }\n      date_components[3] = days_in_current_month + date_components[3];\n    }\n  }\n  else {\n    while( true ) {\n      year = date_components[4];\n      days_in_current_month = days_in_february;\n      if (year != 1) {\n        days_in_current_month = *(int *)(days_in_month + year * 4);\n      }\n      if ((int)date_components[3] <= days_in_current_month) break;\n      date_components[3] = date_components[3] - days_in_current_month;\n      date_components[4] = year + 1;\n      if (year + 1 == 0xc) {\n        temp = date_components[5];\n        year = temp + 1;\n        date_components[4] = 0;\n        date_components[5] = year;\n        if ((year & 3) == 0) {\n          if (year % 100 == 0) {\n            if ((temp + 0x76d) % 400 == 0) {\n              days_in_february = 0x1d;\n            }\n            else {\n              days_in_february = 0x1c;\n            }\n          }\n          else {\n            days_in_february = 0x1d;\n          }\n        }\n        else {\n          days_in_february = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "div"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004634",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "update_date_00004634"
        },
        "FUN_00001d5e": {
            "renaming": {
                "FUN_00001d5e": "get_port_from_pin_00001d5e",
                "pin": "gpio_pin",
                "PORT_Type": "PortType",
                "PORT_BASE_ADDRESS": "PortBaseAddress",
                "PIN_PORT_MASK": "PinPortMask",
                "pin_port_offset": "PinPortOffset"
            },
            "code": "PORT_Type* get_port_from_pin_00001d5e(gpio_t pin) {\n    const uint32_t PORT_BASE_ADDRESS = 0x40048000;\n    const uint32_t PIN_PORT_MASK = 0x7000;\n    uint32_t pin_port_offset = pin & PIN_PORT_MASK;\n    return (PORT_Type*)(pin_port_offset | PORT_BASE_ADDRESS);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d5e",
            "calling": [
                "gpio_init",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "get_port_from_pin_00001d5e"
        },
        "FUN_0000191c": {
            "renaming": {
                "FUN_0000191c": "initialize_system_clock_0000191c",
                "kinetis_mcg_enable_osc": "enable_external_oscillator",
                "kinetis_mcg_set_fll_factor": "set_fll_factor",
                "*DAT_00001958": "*status_register",
                "DAT_00001958": "status_register",
                "*PTR_current_mode_0000195c": "*current_mode_ptr"
            },
            "code": "void initialize_system_clock_0000191c(void)\n{\n  enable_external_oscillator();\n  set_fll_factor(FLL_FACTOR_1920);\n  *DAT_00001958 &= 0x3b;\n  while ((DAT_00001958[6] & 0xc) != 0);\n  *PTR_current_mode_0000195c = 1;\n  return;\n}",
            "called": [
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_enable_osc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000191c",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "initialize_system_clock_0000191c"
        },
        "FUN_000050f4": {
            "renaming": {
                "FUN_000050f4": "release_time_zone_mutex_000050f4",
                "PTR___lock___tz_mutex_000050fc": "time_zone_mutex"
            },
            "code": "void release_time_zone_mutex_000050f4(void)\n{\n  __retarget_lock_release(PTR___lock___tz_mutex_000050fc);\n  return;\n}",
            "called": [
                "__retarget_lock_release"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050f4",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "release_time_zone_mutex_000050f4"
        },
        "FUN_00000c80": {
            "renaming": {
                "FUN_00000c80": "memory_management_handler_00000c80",
                "PTR_s_MEM_MANAGE_HANDLER_00000c8c": "memory_management_handler"
            },
            "code": "void memory_management_handler_00000c80(void)\n{\n    core_panic(PANIC_MEM_MANAGE, memory_management_handler_00000c80);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000c80",
            "calling": [],
            "imported": false,
            "current_name": "memory_management_handler_00000c80"
        },
        "FUN_00000a40": {
            "renaming": {
                "FUN_00000a40": "calculateStackOffset_00000a40",
                "required": "requiredOffset",
                "auStack_18": "stackFrame",
                "sp": "stackPointer"
            },
            "code": "int calculateStackOffset_00000a40(uint32_t required){\n\tundefined stackFrame[12];\n\tuint32_t *stackPointer;\n\tstackPointer = &stackFrame[0];\n\treturn (int)(stackPointer + (-(int)PTR_isr_stack_00000a60 - required));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a40",
            "calling": [
                "hard_fault_handler"
            ],
            "imported": false,
            "current_name": "calculateStackOffset_00000a40"
        },
        "FUN_00005a58": {
            "renaming": {
                "FUN_00005a58": "encode_string_00005a58",
                "param_1": "input",
                "param_2": "output_len",
                "param_3": "output",
                "param_4": "unknown",
                "param_5": "callback",
                "iVar1": "i",
                "uVar2": "result",
                "uVar3": "max_output_len",
                "uVar4": "remaining_output_len",
                "bVar5": "is_index_4_set",
                "current_index": "current_index"
            },
            "code": "undefined4 encode_string_00005a58(undefined4 input, uint *output_len, uint *output, undefined4 unknown, code *callback)\\n\\\n{\\n\\\n    int i;\\n\\\n    undefined4 result;\\n\\\n    uint max_output_len = param_2[4];\\n\\\n    if ((int)param_2[4] < (int)param_2[2]) {\\n\\\n        max_output_len = param_2[2];\\n\\\n    }\\n\\\n    *output_len = max_output_len;\\n\\\n    if (*(char *)((int)param_2 + 0x43) != \"\\0\") {\\n\\\n        *output_len = max_output_len + 1;\\n\\\n    }\\n\\\n    if ((int)(*param_2 << 0x1a) < 0) {\\n\\\n        *output_len = *output_len + 2;\\n\\\n    }\\n\\\n    uint current_index = *param_2 & 6;\\n\\\n    if (current_index == 0) {\\n\\\n        for (; (int)current_index < (int)(param_2[3] - *output_len); current_index++) {\\n\\\n            int callback_result = (*callback)(input, unknown, (int)param_2 + 0x19, 1);\\n\\\n            if (callback_result == -1) goto LAB_00005afc;\\n\\\n        }\\n\\\n    }\\n\\\n    current_index = (uint)*(byte *)((int)param_2 + 0x43);\\n\\\n    if (current_index != 0) {\\n\\\n        current_index = 1;\\n\\\n    }\\n\\\n    if ((int)(*param_2 << 0x1a) < 0) {\\n\\\n        *(undefined *)((int)param_2 + current_index + 0x43) = 0x30;\\n\\\n        *(undefined *)((int)param_2 + current_index + 0x44) = *(undefined *)((int)param_2 + 0x45);\\n\\\n        current_index += 2;\\n\\\n    }\\n\\\n    int callback_result = (*callback)(input, unknown, (int)param_2 + 0x43, current_index);\\n\\\n    if (callback_result == -1) {\\n\\\n        goto LAB_00005afc;\\n\\\n    }\\n\\\n    uint remaining_output_len = param_2[3];\\n\\\n    bool is_index_4_set = (*param_2 & 6) == 4;\\n\\\n    if (is_index_4_set) {\\n\\\n        remaining_output_len = remaining_output_len - *output_len;\\n\\\n    }\\n\\\n    if (is_index_4_set) {\\n\\\n        remaining_output_len = remaining_output_len & ~((int)remaining_output_len >> 0x1f);\\n\\\n    }\\n\\\n    else {\\n\\\n        remaining_output_len = 0;\\n\\\n    }\\n\\\n    if ((int)param_2[4] < (int)param_2[2]) {\\n\\\n        remaining_output_len = remaining_output_len + (param_2[2] - param_2[4]);\\n\\\n    }\\n\\\n    for (i = 0; remaining_output_len != i; i++) {\\n\\\n        int callback_result = (*callback)(input, unknown, (int)param_2 + 0x1a, 1);\\n\\\n        if (callback_result == -1) goto LAB_00005afc;\\n\\\n    }\\n\\\n    result = 0;\\n\\\n    goto LAB_00005b08;\\n\\\nLAB_00005afc:\\n\\\n    result = 0xffffffff;\\n\\\nLAB_00005b08:\\n\\\n    return result;\\n\\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005a58",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "encode_string_00005a58"
        },
        "FUN_000056b0": {
            "renaming": {
                "FUN_000056b0": "getTimeZoneInfo_000056b0",
                "PTR_tzinfo_000056b4": "timeZoneInfoPtr"
            },
            "code": "const char* getTimeZoneInfo_000056b0(void) {\n  return PTR_tzinfo_000056b4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b0",
            "calling": [
                "mktime",
                "__tzcalc_limits",
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "getTimeZoneInfo_000056b0"
        },
        "FUN_00003d24": {
            "renaming": {
                "FUN_00003d24": "get_saul_reg_at_position_00003d24",
                "pos": "position",
                "i": "i",
                "tmp": "current"
            },
            "code": "saul_reg_t* get_saul_reg_at_position_00003d24(int position){\n    int i = 0;\n    saul_reg_t* current = *(saul_reg_t**)PTR_saul_reg_00003d60;\n    while(current != (saul_reg_t*)0x0 && i < position){\n        current = current->next;\n        i++;\n    }\n    return current;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d24",
            "calling": [
                "read",
                "write"
            ],
            "imported": false,
            "current_name": "get_saul_reg_at_position_00003d24"
        },
        "FUN_000060cc": {
            "renaming": {
                "FUN_000060cc": "allocate_memory_block_000060cc",
                "param_1": "block_size",
                "param_2": "old_block",
                "param_3": "new_block_size",
                "param_4": "alignment",
                "pvVar1": "new_block",
                "pvVar2": "old_block_size"
            },
            "code": "void * allocate_memory_block_000060cc(size_t block_size, void *old_block, size_t new_block_size, size_t alignment) {\n\tvoid *new_block;\n\tif (old_block != NULL) {\n\t\tif (new_block_size == 0) {\n\t\t\tfree(old_block);\n\t\t\tnew_block = NULL;\n\t\t}\n\t\telse {\n\t\t\tsize_t old_block_size = malloc_usable_size(old_block);\n\t\t\tnew_block = old_block;\n\t\t\tif (old_block_size < new_block_size) {\n\t\t\t\tnew_block = malloc(block_size);\n\t\t\t\tif (new_block != NULL) {\n\t\t\t\t\tmemcpy(new_block, old_block, new_block_size);\n\t\t\t\t\tfree(old_block);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tnew_block = malloc(block_size);\n\t}\n\treturn new_block;\n}",
            "called": [
                "_free_r",
                "_malloc_r",
                "memcpy",
                "_malloc_usable_size_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060cc",
            "calling": [
                "__submore"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_000060cc"
        },
        "FUN_000022be": {
            "renaming": {
                "FUN_000022be": "write_to_ring_buffer_000022be",
                "rb": "ring_buffer",
                "c": "data",
                "uVar1": "next_write_index",
                "buf": "buffer",
                "size": "buffer_size",
                "writes": "write_index"
            },
            "code": "void write_to_ring_buffer_000022be(tsrb_t *ring_buffer, char data) {\n    uint32_t next_write_index = ring_buffer->writes;\n    ring_buffer->writes = next_write_index + 1;\n    uint32_t buffer_index = next_write_index & (ring_buffer->size - 1);\n    ring_buffer->buf[buffer_index] = data;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022be",
            "calling": [
                "tsrb_add_one"
            ],
            "imported": false,
            "current_name": "write_to_ring_buffer_000022be"
        },
        "FUN_00003dc4": {
            "renaming": {
                "FUN_00003dc4": "calculate_num_digits_00003dc4",
                "out": "output_string",
                "val": "input_number",
                "local_20": "power_of_ten",
                "ptr": "current_char",
                "tmp": "digit",
                "len": "num_digits"
            },
            "code": "size_t calculate_num_digits_00003dc4(char *output_string, uint32_t input_number) {\n    uint32_t power_of_ten = 1;\n    char *current_char = output_string;\n    size_t num_digits = 1;\n    if (DAT_00003e50 < input_number) {\n        num_digits = 10;\n    }\n    else {\n        while (power_of_ten <= input_number) {\n            power_of_ten *= 10;\n            num_digits++;\n        }\n    }\n    if (output_string != (char *)0x0) {\n        current_char += num_digits;\n        uint32_t remaining_digits = input_number;\n        do {\n            current_char--;\n            uint32_t digit = remaining_digits % 10;\n            *current_char = digit + '0';\n            remaining_digits = remaining_digits / 10;\n        } while (remaining_digits != 0);\n    }\n    return num_digits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003dc4",
            "calling": [
                "fmt_s32_dec"
            ],
            "imported": false,
            "current_name": "calculate_num_digits_00003dc4"
        },
        "FUN_00002108": {
            "renaming": {
                "FUN_00002108": "handle_irq_00002108",
                "DAT_00002118": "data_ptr"
            },
            "code": "void handle_irq_00002108(void)\n{\n  irq_handler(DAT_00002118, 4);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002108",
            "calling": [],
            "imported": false,
            "current_name": "handle_irq_00002108"
        },
        "FUN_00000c90": {
            "renaming": {
                "FUN_00000c90": "handle_bus_fault_00000c90",
                "PTR_s_BUS_FAULT_HANDLER_00000c9c": "bus_fault_handler"
            },
            "code": "void handle_bus_fault_00000c90(void)\n{\n\tcore_panic(PANIC_BUS_FAULT, PTR_s_BUS_FAULT_HANDLER_00000c9c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000c90",
            "calling": [],
            "imported": false,
            "current_name": "handle_bus_fault_00000c90"
        },
        "FUN_00001d80": {
            "renaming": {
                "FUN_00001d80": "get_gpio_address_from_pin_00001d80",
                "pin": "pin_number",
                "GPIO_Type": "GPIO_register_type",
                "PIN_MASK": "pin_mask",
                "GPIO_BASE": "gpio_base_address",
                "pin_offset": "pin_offset_within_gpio_register",
                "gpio_address": "gpio_register_address"
            },
            "code": "GPIO_Type* get_gpio_address_from_pin_00001d80(get_gpio_address_from_pin_00001d80_t pin) {\n    const uint32_t GPIO_BASE = 0x400ff000;\n    const uint32_t PIN_MASK = 0x1c0;\n    uint32_t pin_offset = pin & PIN_MASK;\n    GPIO_Type* gpio_address = (GPIO_Type*)(pin_offset | GPIO_BASE);\n    return gpio_address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d80",
            "calling": [
                "gpio_set",
                "gpio_init"
            ],
            "imported": false,
            "current_name": "get_gpio_address_from_pin_00001d80"
        },
        "FUN_000033c0": {
            "renaming": {
                "FUN_000033c0": "get_alarm_status_000033c0",
                "iVar1": "status",
                "t": "alarm_time",
                "PTR_s_rtc__error_getting_alarm_000033f0": "PTR_s_rtc_error_getting_alarm"
            },
            "code": "int get_alarm_status_000033c0(void)\n{\n  int status;\n  tm alarm_time;\n\n  status = rtc_get_alarm(&alarm_time);\n  if (status != 0) {\n    puts(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    print_alarm_time(&alarm_time);\n  }\n  return (uint)(status != 0);\n}",
            "called": [
                "rtc_get_alarm",
                "_print_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "get_alarm_status_000033c0"
        },
        "FUN_00002b10": {
            "renaming": {
                "FUN_00002b10": "parse_command_00002b10",
                "command_list": "command_list",
                "line": "command_string",
                "iVar1": "iVar1",
                "pcVar2": "pcVar2",
                "local_48": "local_48",
                "local_44": "current_command",
                "handler": "handler",
                "argv": "args",
                "local_34": "local_34",
                "quote_char": "quote_char",
                "d": "d",
                "c": "c",
                "arg": "arg",
                "i": "i",
                "contains_esc_seq": "contains_escape_seq",
                "argc": "arg_count",
                "pos": "command_pos"
            },
            "code": "void parse_command_00002b10(shell_command_t *command_list, char *command_string) {\\n    int arg_count = 0;\\n    int contains_escape_seq = 0;\\n    char quote_char;\\n    char *command_pos = command_string;\\n    char **args;\\n    uint i;\\n    shell_command_t *current_command;\\n    shell_command_handler_t handler;\\n    \\n    while (*command_pos != \"\\0\") {\\n        if (*command_pos > 0x20) {\\n            if (*command_pos == \"\\\"\" || *command_pos == \"\\\"\") {\\n                quote_char = *command_pos;\\n                do {\\n                    command_pos++;\\n                    if (*command_pos == \"\\0\") {\\n                        puts(PTR_INCORRECT_QUOTING_00002d88);\\n                        return;\\n                    }\\n                    if (*command_pos == \"\\\\\") {\\n                        contains_escape_seq++;\\n                        command_pos++;\\n                        if (*command_pos == \"\\0\") {\\n                            puts(PTR_INCORRECT_QUOTING_00002d88);\\n                            return;\\n                        }\\n                    }\\n                } while (quote_char != *command_pos);\\n                if (*(command_pos + 1) > 0x20) {\\n                    puts(PTR_INCORRECT_QUOTING_00002d88);\\n                    return;\\n                }\\n            }\\n            else {\\n                do {\\n                    if (*command_pos == \"\\\\\") {\\n                        contains_escape_seq++;\\n                        command_pos++;\\n                        if (*command_pos == \"\\0\") {\\n                            puts(PTR_INCORRECT_QUOTING_00002d88);\\n                            return;\\n                        }\\n                    }\\n                    command_pos++;\\n                    if (*command_pos == 0x22) {\\n                        puts(PTR_INCORRECT_QUOTING_00002d88);\\n                        return;\\n                    }\\n                } while (*command_pos > 0x20);\\n            }\\n            arg_count++;\\n        }\\n        *command_pos = \"\\0\";\\n        command_pos++;\\n    }\\n    if (arg_count != 0) {\\n        args = (char **)(&command_string - ((arg_count + 1) * 4 + 7 & 0xfffffff8));\\n        *(args + arg_count) = (char *)0x0;\\n        command_pos = command_string;\\n        for (i = 0; i < arg_count; i++) {\\n            while (*command_pos == \"\\0\") {\\n                command_pos++;\\n            }\\n            if (*command_pos == \"\\\"\" || *command_pos == \"\\\"\") {\\n                command_pos++;\\n            }\\n            *(args + i) = command_pos;\\n            while (*command_pos != \"\\0\") {\\n                command_pos++;\\n            }\\n        }\\n        for (char **arg = args; (contains_escape_seq != 0 && *arg != (char *)0x0); arg++) {\\n            for (char *c = *arg; *c != \"\\0\"; c++) {\\n                if (*c == \"\\\\\") {\\n                    for (char *d = c; *d != \"\\0\"; d++) {\\n                        *d = *(d + 1);\\n                    }\\n                    contains_escape_seq--;\\n                    if (contains_escape_seq == 0) {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        current_command = command_list;\\n        handler = find_handler(command_list, *args);\\n        if (handler == (shell_command_handler_t)0x0) {\\n            if (strcmp(PTR_DAT_00002d8c, *args) == 0) {\\n                print_help(current_command);\\n            }\\n            else {\\n                iprintf(PTR_s_shell__command_not_found___s_00002d90, *(undefined4 *)args);\\n            }\\n        }\\n        else {\\n            (*handler)(arg_count, args);\\n        }\\n    }\\n    return;\\n}",
            "called": [
                "iprintf",
                "find_handler",
                "print_help",
                "strcmp",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002b10",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "parse_command_00002b10"
        },
        "FUN_00001b10": {
            "renaming": {
                "FUN_00001b10": "set_kinetis_mcg_mode_00001b10",
                "mode": "mode",
                "PTR_mcg_mode_routing_00001bb4": "mcg_mode_routing_ptr",
                "PTR_current_mode_00001bb0": "current_mode_ptr",
                "iVar1": "result"
            },
            "code": "int set_kinetis_mcg_mode_00001b10(kinetis_mcg_mode_t mode)\n{\n  int result = 0;\n  \n  if (mode < KINETIS_MCG_MODE_NUMOF) {\n    do {\n      uint32_t index = (uint32_t)mode + (uint32_t)(byte)*PTR_current_mode_00001bb0 * 8;\n      switch(PTR_mcg_mode_routing_00001bb4[index])\n      {\n      case 0:\n        kinetis_mcg_set_fei();\n        break;\n      case 1:\n        kinetis_mcg_set_fee();\n        break;\n      case 2:\n        kinetis_mcg_set_fbi();\n        break;\n      case 3:\n        kinetis_mcg_set_fbe();\n        break;\n      case 4:\n        kinetis_mcg_set_blpi();\n        break;\n      case 5:\n        kinetis_mcg_set_blpe();\n        break;\n      case 6:\n        kinetis_mcg_set_pbe();\n        break;\n      case 7:\n        kinetis_mcg_set_pee();\n        break;\n      default:\n        return -1;\n      }\n    } while (mode != *PTR_current_mode_00001bb0);\n  }\n  else {\n    result = -1;\n  }\n  return result;\n}",
            "called": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_pee",
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001b10",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_kinetis_mcg_mode_00001b10"
        },
        "FUN_000047e4": {
            "renaming": {
                "FUN_000047e4": "calculate_time_000047e4",
                "__tp": "time_structure",
                "lVar1": "total_seconds",
                "piVar2": "time_zone_info",
                "uVar3": "days_since_jan1",
                "iVar4": "days_before_month",
                "iVar5": "temp_days_before_month",
                "iVar6": "days_in_month",
                "uVar7": "days_in_year",
                "uVar8": "current_year",
                "uVar9": "days_in_current_year",
                "iVar10": "days_since_jan1_1900",
                "uVar11": "year",
                "uVar12": "is_daylight_saving",
                "uVar13": "is_dst",
                "uVar14": "seconds_since_midnight",
                "bVar16": "is_leap_year"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\ntime_t calculate_time_000047e4(tm *time_structure)\n\n{\n  longlong total_seconds;\n  int *time_zone_info;\n  uint days_since_jan1;\n  int days_before_month;\n  int temp_days_before_month;\n  int days_in_month;\n  uint days_in_year;\n  uint current_year;\n  uint days_in_current_year;\n  int days_since_jan1_1900;\n  uint year;\n  uint is_daylight_saving;\n  uint is_dst;\n  uint seconds_since_midnight;\n  time_t tVar15;\n  bool is_leap_year;\n  \n  time_zone_info = (int *)__gettzinfo();\n  validate_structure(time_structure);\n  year = time_structure->tm_year;\n  days_since_jan1_1900 = time_structure->tm_mday + -1 + *(int *)(PTR__DAYS_BEFORE_MONTH_00004adc + time_structure->tm_mon * 4);\n  if (((1 < time_structure->tm_mon) && ((year & 3) == 0)) &&\n     ((year != (year / 100) * 100 || (year + 0x76c == ((year + 0x76c) / 400) * 400)))) {\n    days_since_jan1_1900 = days_since_jan1_1900 + 1;\n  }\n  time_structure->tm_yday = days_since_jan1_1900;\n  if (20000 < (int)&PTR_rtc_callback_00002710 + year) {\n    return -1;\n  }\n  if ((int)year < 0x47) {\n    if (year != 0x46) {\n      for (current_year = 0x45; (int)year < (int)current_year; current_year = current_year - 1) {\n        if ((current_year & 3) == 0) {\n          if (current_year == (current_year / 100) * 100) {\n            if ((current_year + 0x76c) % 400 == 0) {\n              days_in_month = 0x16e;\n            }\n            else {\n              days_in_month = 0x16d;\n            }\n          }\n          else {\n            days_in_month = 0x16e;\n          }\n        }\n        else {\n          days_in_month = 0x16d;\n        }\n        days_since_jan1_1900 = days_since_jan1_1900 - days_in_month;\n      }\n      if ((current_year & 3) == 0) {\n        if (year == (year / 100) * 100) {\n          days_in_month = 0x16d;\n          if ((year + 0x76c) % 400 == 0) {\n            days_in_month = 0x16e;\n          }\n        }\n        else {\n          days_in_month = 0x16e;\n        }\n      }\n      else {\n        days_in_month = 0x16d;\n      }\n      days_since_jan1_1900 = days_since_jan1_1900 - days_in_month;\n    }\n  }\n  else {\n    current_year = 0x46;\n    do {\n      if ((current_year & 3) == 0) {\n        if (current_year % 100 == 0) {\n          if ((current_year + 0x76c) % 400 == 0) {\n            days_in_month = 0x16e;\n          }\n          else {\n            days_in_month = 0x16d;\n          }\n        }\n        else {\n          days_in_month = 0x16e;\n        }\n      }\n      else {\n        days_in_month = 0x16d;\n      }\n      current_year = current_year + 1;\n      days_since_jan1_1900 = days_since_jan1_1900 + days_in_month;\n    } while (year != current_year);\n  }\n  total_seconds = (longlong)DAT_00004ae0 * (longlong)days_since_jan1_1900 +\n          (longlong)(time_structure->tm_hour * 0xe10 + time_structure->tm_min * 0x3c + time_structure->tm_sec);\n  seconds_since_midnight = (uint)total_seconds;\n  days_in_month = (int)((ulonglong)total_seconds >> 0x20);\n  __tz_lock();\n  _tzset_unlocked();\n  current_year = *(uint *)PTR__daylight_00004ae4;\n  if (*(uint *)PTR__daylight_00004ae4 == 0) {\nLAB_00004934:\n    tVar15 = seconds_since_midnight + time_zone_info[10];\n  }\n  else {\n    is_dst = time_structure->tm_isdst;\n    is_daylight_saving = is_dst;\n    if (0 < (int)is_dst) {\n      is_daylight_saving = 1;\n    }\n    if ((time_zone_info[1] == time_structure->tm_year + 0x76c) || (days_before_month = __tzcalc_limits(), days_before_month != 0)) {\n      days_in_current_year = time_zone_info[0x14];\n      days_since_jan1 = time_zone_info[0x12];\n      days_in_year = time_zone_info[10];\n      current_year = days_since_jan1 - days_in_year;\n      days_before_month = (time_zone_info[0x13] - ((int)days_in_year >> 0x1f)) - (uint)(days_since_jan1 < days_in_year);\n      if (((int)((days_in_month - days_before_month) - (uint)(seconds_since_midnight < current_year)) < 0 ==\n           (SBORROW4(days_in_month,days_before_month) != SBORROW4(days_in_month - days_before_month,(uint)(seconds_since_midnight < current_year)))) &&\n         (temp_days_before_month = (time_zone_info[0x13] - ((int)days_in_current_year >> 0x1f)) - (uint)(days_since_jan1 < days_in_current_year),\n         is_leap_year = seconds_since_midnight < days_since_jan1 - days_in_current_year,\n         (int)((days_in_month - temp_days_before_month) - (uint)is_leap_year) < 0 !=\n         (SBORROW4(days_in_month,temp_days_before_month) != SBORROW4(days_in_month - temp_days_before_month,(uint)is_leap_year)))) goto LAB_00004a88;\n      days_since_jan1 = time_zone_info[8] - days_in_current_year;\n      temp_days_before_month = (time_zone_info[9] - ((int)days_in_current_year >> 0x1f)) - (uint)((uint)time_zone_info[8] < days_in_current_year);\n      if (*time_zone_info != 0) {\n        if ((int)((days_in_month - temp_days_before_month) - (uint)(seconds_since_midnight < days_since_jan1)) < 0 ==\n            (SBORROW4(days_in_month,temp_days_before_month) != SBORROW4(days_in_month - temp_days_before_month,(uint)(seconds_since_midnight < days_since_jan1))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        current_year = 0;\n        if ((int)is_dst < 0) goto LAB_00004934;\nLAB_00004a14:\n        is_dst = is_daylight_saving ^ current_year;\n        is_daylight_saving = current_year;\n        if (is_dst == 1) {\n          if (current_year == 0) {\n            days_in_month = days_in_current_year - days_in_year;\n          }\n          else {\n            days_in_month = days_in_year - days_in_current_year;\n          }\n          days_before_month = time_structure->tm_mday;\n          seconds_since_midnight = seconds_since_midnight + days_in_month;\n          time_structure->tm_sec = time_structure->tm_sec + days_in_month;\n          validate_structure(time_structure);\n          days_before_month = time_structure->tm_mday - days_before_month;\n          if (days_before_month != 0) {\n            if (days_before_month < 2) {\n              if (days_before_month == -2 || days_before_month + 2 < 0 != SCARRY4(days_before_month,2)) {\n                days_before_month = 1;\n              }\n            }\n            else {\n              days_before_month = -1;\n            }\n            days_in_month = days_before_month + time_structure->tm_yday;\n            days_since_jan1_1900 = days_since_jan1_1900 + days_before_month;\n            if (days_in_month < 0) {\n              current_year = year - 1;\n              if ((current_year & 3) == 0) {\n                if (current_year == (current_year / 100) * 100) {\n                  days_in_month = 0x16d;\n                  if ((year + 0x76b) % 400 != 0) {\n                    days_in_month = 0x16c;\n                  }\n                }\n                else {\n                  days_in_month = 0x16d;\n                }\n              }\n              else {\n                days_in_month = 0x16c;\n              }\n            }\n            else {\n              if ((year & 3) == 0) {\n                if (year == (year / 100) * 100) {\n                  days_before_month = 0x16d;\n                  if ((year + 0x76c) % 400 == 0) {\n                    days_before_month = 0x16e;\n                  }\n                }\n                else {\n                  days_before_month = 0x16e;\n                }\n              }\n              else {\n                days_before_month = 0x16d;\n              }\n              if (days_before_month <= days_in_month) {\n                days_in_month = days_in_month - days_before_month;\n              }\n            }\n            time_structure->tm_yday = days_in_month;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((days_in_month - temp_days_before_month) - (uint)(seconds_since_midnight < days_since_jan1)) < 0 !=\n          (SBORROW4(days_in_month,temp_days_before_month) != SBORROW4(days_in_month - temp_days_before_month,(uint)(seconds_since_midnight < days_since_jan1)))) {\nLAB_0000491e:\n        if ((int)((days_in_month - days_before_month) - (uint)(seconds_since_midnight < current_year)) < 0 ==\n            (SBORROW4(days_in_month,days_before_month) != SBORROW4(days_in_month - days_before_month,(uint)(seconds_since_midnight < current_year))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)is_dst) {\n        current_year = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      current_year = is_daylight_saving;\n      if (is_daylight_saving != 1) goto LAB_00004934;\n    }\n    tVar15 = seconds_since_midnight + time_zone_info[0x14];\n    current_year = 1;\n  }\n  __tz_unlock();\n  time_structure->tm_isdst = current_year;\n  time_structure->tm_wday = (days_since_jan1_1900 + 4U) % 7;\n  return tVar15;\n}\n\n",
            "called": [
                "__gettzinfo",
                "__tz_unlock",
                "__tzcalc_limits",
                "validate_structure",
                "__tz_lock",
                "_tzset_unlocked"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000047e4",
            "calling": [
                "rtc_set_time",
                "rtc_set_alarm"
            ],
            "imported": false,
            "current_name": "calculate_time_000047e4"
        },
        "FUN_000023c8": {
            "renaming": {
                "FUN_000023c8": "run_software_interrupt_000023c8",
                "a0": "interrupt_number",
                "a1": "return_value",
                "a2": "error_code"
            },
            "code": "uint32_t run_software_interrupt_000023c8(uint32_t interrupt_number,uint32_t return_value,int32_t error_code){\n  software_interrupt(interrupt_number);\n  return return_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023c8",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "run_software_interrupt_000023c8"
        },
        "FUN_00002e48": {
            "renaming": {
                "FUN_00002e48": "print_greater_than_space_00002e48",
                "PTR__impure_ptr_00002e68": "impure_ptr"
            },
            "code": "void print_greater_than_space_00002e48(void)\n{\n  int* PTR__impure_ptr_00002e68 = *(int *)PTR__PTR__impure_ptr_00002e68_00002e68;\n  FILE* file_ptr = *(FILE **)(PTR__impure_ptr_00002e68 + 8);\n  _putchar('>');\n  _putchar(' ');\n  fflush(file_ptr);\n  return;\n}",
            "called": [
                "_putchar",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e48",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "print_greater_than_space_00002e48"
        },
        "FUN_00000930": {
            "renaming": {
                "FUN_00000930": "enable_interrupt_and_trigger_software_interrupt_00000930",
                "irq_enable": "enable_interrupt",
                "software_interrupt": "trigger_software_interrupt"
            },
            "code": "void enable_interrupt_and_trigger_software_interrupt_00000930(void)\n{\n  enable_interrupt();\n  trigger_software_interrupt(1);\n  while( true )\n  {\n    // Do nothing block with infinite loop\n  }\n}",
            "called": [
                "irq_enable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000930",
            "calling": [
                "sched_task_exit",
                "kernel_init"
            ],
            "imported": false,
            "current_name": "enable_interrupt_and_trigger_software_interrupt_00000930"
        },
        "FUN_00001348": {
            "renaming": {
                "FUN_00001348": "check_for_context_switch_request_00001348",
                "PTR_sched_context_switch_request_0000135c": "context_switch_request"
            },
            "code": "void check_for_context_switch_request_00001348(void)\n{\n    int* PTR_sched_context_switch_request_0000135c = (int*)PTR_sched_PTR_sched_context_switch_request_0000135c_0000135c;\n    if (*PTR_sched_context_switch_request_0000135c != 0) {\n        thread_yield_higher();\n    }\n    return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001348",
            "calling": [
                "irq_handler_uart"
            ],
            "imported": false,
            "current_name": "check_for_context_switch_request_00001348"
        },
        "FUN_00006118": {
            "renaming": {
                "FUN_00006118": "reverse_and_increment_00006118",
                "param_1": "current_index",
                "param_2": "current_value",
                "param_3": "array",
                "param_4": "max_index",
                "iVar1": "index_increment",
                "uVar2": "current_index_value",
                "uVar3": "array_value"
            },
            "code": "uint reverse_and_increment_00006118(uint current_index, uint current_value, uint *array, uint max_index)\n{\n  int index_increment;\n  uint new_value;\n  if (current_value == 0xffffffff) {\n    current_value = 0xffffffff;\n  }\n  else {\n    *(ushort *)(array + 3) = *(ushort *)(array + 3) & 0xffdf;\n    uint current_index_value = array[1];\n    current_value = current_value & 0xff;\n    if (array[0xd] == 0) {\n      uint array_value = *array;\n      if (((array[4] != 0) && (array[4] < array_value)) && (*(byte *)(array_value - 1) == current_value)) {\n        *array = array_value - 1;\n        array[1] = current_index_value + 1;\n        return current_value;\n      }\n      array[0xf] = array_value;\n      array[0x10] = current_index_value;\n      array[0xd] = (uint)(array + 0x11);\n      array[0xe] = 3;\n      *(undefined *)((int)array + 0x46) = (char)current_value;\n      *array = (uint)(undefined *)((int)array + 0x46);\n      current_index_value = 1;\n    }\n    else {\n      if (((int)array[0xe] <= (int)current_index_value) &&\n         (index_increment = __submore(current_index, array, current_index_value, array[0xe], max_index), index_increment != 0))\n      current_value = 0xffffffff;\n      new_value = *array;\n      *array = new_value - 1;\n      *(char *)(new_value - 1) = (char)current_value;\n      current_index_value = array[1] + 1;\n    }\n    array[1] = current_index_value;\n  }\n  return current_value;\n}",
            "called": [
                "__submore"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006118",
            "calling": [],
            "imported": false,
            "current_name": "reverse_and_increment_00006118"
        },
        "FUN_00001d3a": {
            "renaming": {
                "FUN_00001d3a": "set_bit_at_position_00001d3a",
                "ptr": "memory_address",
                "bit": "bit_position",
                "puVar1": "bit_address"
            },
            "code": "void set_bit_at_position_00001d3a(uint32_t *memory_address, uint8_t bit_position)\n{\n    undefined4 *bit_address = (undefined4 *)bitband_addr(memory_address, (uint)bit_position);\n    *bit_address = 1;\n    return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d3a",
            "calling": [
                "clk_en"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_00001d3a"
        },
        "FUN_00002434": {
            "renaming": {
                "FUN_00002434": "acquire_mutex_00002434",
                "*mutex": "*mutex",
                "blocking": "blocking",
                "state": "flags",
                "iVar1": "success",
                "*process": "*waiting_thread",
                "irqstate": "flags",
                "*me": "*current_thread",
                "(mutex->queue).next": "mutex->queue.next",
                "(list_node *)0x0": "NULL",
                "(list_node *)0xffffffff": "(list_node *)-1",
                "PTR_sched_active_thread_000024b8": "get_current_thread()",
                "sched_set_status": "sched_set_status",
                "&process->rq_entry": "&current_thread->rq_entry",
                "thread_add_to_list": "thread_add_to_list",
                "thread_yield_higher": "thread_yield_higher()"
            },
            "code": "int acquire_mutex_00002434(mutex_t *mutex, int blocking)\n{\n    uint32_t flags;\n    int success = 0;\n    thread_t *current_thread = PTR_sched_active_thread_000024b8;\n    thread_t *waiting_thread;\n\n    flags = disable_interrupts();\n\n    if (mutex->queue.next == NULL) {\n        mutex->queue.next = (list_node *)-1;\n        success = 1;\n    } else if (!blocking) {\n        success = 0;\n    } else {\n        sched_set_status(current_thread, THREAD_STATUS_BLOCKED);\n        if (mutex->queue.next == (list_node *)-1) {\n            mutex->queue.next = &current_thread->rq_entry;\n            current_thread->rq_entry.next = NULL;\n        } else {\n            waiting_thread = thread_add_to_list(&mutex->queue, current_thread);\n            thread_yield_higher();\n        }\n        success = 1;\n    }\n\n    restore_interrupts(flags);\n\n    return success;\n}\n",
            "called": [
                "thread_yield_higher",
                "thread_add_to_list",
                "irq_disable",
                "irq_restore",
                "sched_set_status"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002434",
            "calling": [
                "mutex_lock"
            ],
            "imported": false,
            "current_name": "acquire_mutex_00002434"
        },
        "FUN_00005700": {
            "renaming": {
                "FUN_00005700": "allocate_memory_00005700",
                "param_1": "reent",
                "param_2": "ptr",
                "uVar1": "buffer",
                "iVar2": "allocation",
                "local_18": "local_reent",
                "local_14": "local_ptr"
            },
            "code": "void allocate_memory_00005700(_reent *reent, int *ptr) {\n  ushort buffer;\n  int allocation;\n  _reent *local_reent;\n  int *local_ptr;\n  \n  if (-1 < (int)((uint)*(ushort *)(ptr + 3) << 0x1e)) {\n    local_reent = reent;\n    local_ptr = ptr;\n    buffer = __swhatbuf_r(reent, ptr, &local_reent, &local_ptr);\n    allocation = _malloc_r(reent, local_reent);\n    if (allocation != 0) {\n      reent->__cleanup = DAT_0000577c;\n      *ptr = allocation;\n      *(ushort *)(ptr + 3) = *(ushort *)(ptr + 3) | 0x80;\n      ptr[5] = (int)local_reent;\n      ptr[4] = allocation;\n      if ((local_ptr != (int *)0x0) &&\n         (_isatty_r(reent, (int)*(short *)((int)ptr + 0xe)) != 0)) {\n        *(ushort *)(ptr + 3) = *(ushort *)(ptr + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(ptr + 3) = buffer | *(ushort *)(ptr + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(ptr + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(ptr + 3) = *(ushort *)(ptr + 3) & 0xfffc | 2;\n  }\n  *ptr = (int)ptr + 0x47;\n  ptr[4] = (int)ptr + 0x47;\n  ptr[5] = 1;\n  return;\n}",
            "called": [
                "__swhatbuf_r",
                "_malloc_r",
                "_isatty_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005700",
            "calling": [
                "__srefill_r",
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00005700"
        },
        "FUN_00002798": {
            "renaming": {
                "FUN_00002798": "check_for_context_switch_request_00002798",
                "PTR_sched_context_switch_request_000027ac": "context_switch_request"
            },
            "code": "void check_for_context_switch_request_00002798(void)\n{\n  int* PTR_sched_context_switch_request_000027ac = (int*)PTR_sched_PTR_sched_context_switch_request_000027ac_000027ac;\n  if (*PTR_sched_context_switch_request_000027ac != 0) {\n    thread_yield_higher();\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002798",
            "calling": [
                "isr_rtc"
            ],
            "imported": false,
            "current_name": "check_for_context_switch_request_00002798"
        },
        "FUN_00003524": {
            "renaming": {
                "FUN_00003524": "command_handler_00003524",
                "argc": "argument_count",
                "argv": "arguments",
                "iVar1": "result",
                "_rtc_usage": "print_usage",
                "PTR_s_poweron_00003638": "power_on_string",
                "rtc_poweron": "power_on",
                "strncmp": "compare_strings",
                "PTR_s_poweroff_0000363c": "power_off_string",
                "rtc_poweroff": "power_off",
                "PTR_s_clearalarm_00003640": "clear_alarm_string",
                "rtc_clear_alarm": "clear_alarm",
                "PTR_s_getalarm_00003644": "get_alarm_string",
                "_rtc_getalarm": "get_alarm",
                "PTR_s_setalarm_00003648": "set_alarm_string",
                "_rtc_setalarm": "set_alarm",
                "PTR_s_gettime_0000364c": "get_time_string",
                "_rtc_gettime": "get_time",
                "PTR_s_settime_00003650": "set_time_string",
                "_rtc_settime": "set_time",
                "iprintf": "printf"
            },
            "code": "int command_handler_00003524(int argc, char **argv)\n{\n    int result;\n    if (argc < 2) {\n        print_usage();\n        result = 1;\n    }\n    else {\n        int cmp_result = strncmp(argv[1], PTR_s_poweron_00003638, 7);\n        if (cmp_result == 0) {\n            rtc_poweron();\n        }\n        else {\n            cmp_result = strncmp(argv[1], PTR_s_poweroff_0000363c, 8);\n            if (cmp_result == 0) {\n                rtc_poweroff();\n            }\n            else {\n                cmp_result = strncmp(argv[1], PTR_s_clearalarm_00003640, 8);\n                if (cmp_result == 0) {\n                    rtc_clear_alarm();\n                }\n                else {\n                    cmp_result = strncmp(argv[1], PTR_s_getalarm_00003644, 8);\n                    if (cmp_result == 0) {\n                        get_alarm();\n                    }\n                    else {\n                        cmp_result = strncmp(argv[1], PTR_s_setalarm_00003648, 8);\n                        if ((cmp_result == 0) && (argc == 4)) {\n                            set_alarm(argv + 2);\n                        }\n                        else {\n                            cmp_result = strncmp(argv[1], PTR_s_gettime_0000364c, 7);\n                            if (cmp_result == 0) {\n                                get_time();\n                            }\n                            else {\n                                cmp_result = strncmp(argv[1], PTR_s_settime_00003650, 7);\n                                if ((cmp_result != 0) || (argc != 4)) {\n                                    printf(PTR_s_unknown_command_or_missing_param_00003654, argv[1]);\n                                    print_usage();\n                                    return 1;\n                                }\n                                set_time(argv + 2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        result = 0;\n    }\n    return result;\n}",
            "called": [
                "_rtc_setalarm",
                "rtc_poweroff",
                "_rtc_usage",
                "rtc_clear_alarm",
                "iprintf",
                "_rtc_settime",
                "strncmp",
                "_rtc_getalarm",
                "_rtc_gettime",
                "rtc_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003524",
            "calling": [],
            "imported": false,
            "current_name": "command_handler_00003524"
        },
        "FUN_00001bb8": {
            "renaming": {
                "FUN_00001bb8": "set_fll_factor_and_current_mode_00001bb8",
                "DAT_00001c74": "status_register",
                "DAT_00001c78": "data_register_1",
                "DAT_00001c7c": "data_register_2",
                "PTR_current_mode_00001c80": "current_mode_pointer",
                "KINETIS_MCG_FLL_FACTOR_640": "FLL_factor_640",
                "bit_clear8": "clear_bit_in_byte",
                "BIT_0": "0x01",
                "BIT_2": "0x04",
                "BIT_3": "0x08",
                "BIT_4": "0x10",
                "BIT_5": "0x20",
                "BIT_6": "0x40",
                "BIT_0_TO_5_OR_7_TO_8": "0x3F",
                "BIT_6_AND_7": "0xC0",
                "BIT_0_TO_1_OR_3_TO_7_OR_9_TO_10_OR_12_TO_15": "0x3B"
            },
            "code": "void set_fll_factor_and_current_mode_00001bb8(void)\n{\n  if ((DAT_00001c74[1] & BIT_2) != 0) {\n    clear_bit_in_byte(DAT_00001c78, BIT_0);\n  }\n  if ((DAT_00001c74[5] & BIT_6) != 0) {\n    if ((*DAT_00001c74 & BIT_6_AND_7) == 0) {\n      *DAT_00001c74 = *DAT_00001c74 & BIT_0_TO_5_OR_7_TO_8;\n      do {\n      } while ((DAT_00001c74[6] & BIT_2_OR_3) != BIT_3);\n    }\n    clear_bit_in_byte(DAT_00001c7c, BIT_6);\n    do {\n    } while ((DAT_00001c74[6] & BIT_5) != 0);\n  }\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_640);\n  *DAT_00001c74 = *DAT_00001c74 & BIT_0_TO_1_OR_3_TO_7_OR_9_TO_10_OR_12_TO_15 | BIT_2;\n  do {\n  } while ((DAT_00001c74[6] & BIT_4) == 0);\n  do {\n  } while ((DAT_00001c74[6] & BIT_2_OR_3) != 0);\n  *PTR_current_mode_00001c80 = 0;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001bb8",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_fll_factor_and_current_mode_00001bb8"
        },
        "FUN_0000428c": {
            "renaming": {
                "FUN_0000428c": "acquire_recursive_lock_0000428c",
                "PTR___lock___sinit_recursive_mutex_00004294": "sinit_recursive_mutex_lock"
            },
            "code": "void acquire_recursive_lock_0000428c(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___sinit_recursive_mutex_00004294);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000428c",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_0000428c"
        },
        "FUN_0000404c": {
            "renaming": {
                "FUN_0000404c": "process_data_0000404c",
                "param_1": "data",
                "param_2": "params",
                "iVar1": "result",
                "piVar2": "data_pointer",
                "uVar3": "data_length_uint",
                "uVar4": "data_length",
                "iVar5": "block_size_shifted",
                "bVar9": "is_block_size_shifted_zero",
                "iVar7": "data_offset",
                "pcVar6": "process_code",
                "uVar8": "original_data_length",
                "DAT_00004154": "data_mask"
            },
            "code": "int process_data_0000404c(uint *data, int *params) {\n  int result = 0;\n  int data_length = *(ushort *)(params + 3);\n  uint data_length_uint = (uint)data_length;\n  if ((int)(data_length_uint << 0x1c) < 0) {\n    int block_size = params[4];\n    if (block_size != 0) {\n      int block_size_shifted = data_length_uint << 0x1e;\n      bool is_block_size_shifted_zero = block_size_shifted == 0;\n      int data_offset = *params;\n      int block_size_used = is_block_size_shifted_zero ? params[5] : 0;\n      *params = block_size;\n      if (!is_block_size_shifted_zero) {\n        block_size_used = 0;\n      }\n      params[2] = block_size_used;\n      for (data_offset = data_offset - block_size; 0 < data_offset; data_offset = data_offset - block_size_used) {\n        block_size_used = (*(code *)params[10])(data, params[8], block_size, data_offset);\n        if (block_size_used < 1) {\n          *(ushort *)(params + 3) = *(ushort *)(params + 3) | 0x40;\n          return -1;\n        }\n        block_size = block_size + block_size_used;\n      }\n    }\n  }\n  else {\n    if ((params[1] < 1) && (params[0x10] < 1)) {\n      return 0;\n    }\n    code *process_code = (code *)params[0xb];\n    if (process_code == (code *)0x0) {\n      return 0;\n    }\n    uint original_data_length = *data;\n    *data = 0;\n    if ((data_length & 0x1000) == 0) {\n      int process_code_result = (*process_code)(data, params[8], data_length_uint & 0x1000, 1);\n      if ((process_code_result == -1) && (*data != 0)) {\n        if ((*data == 0x1d) || (*data == 0x16)) {\n          *data = original_data_length;\n          return 0;\n        }\n        *(ushort *)(params + 3) = *(ushort *)(params + 3) | 0x40;\n        return process_code_result;\n      }\n    }\n    else {\n      int block_size_used = params[0x15];\n      int block_size = block_size_used - params[1];\n      if (params[0xd] != 0) {\n        block_size = block_size - params[0x10];\n      }\n      int process_code_result = (*(code *)params[0xb])(data, params[8], block_size, 0);\n      if ((process_code_result == -1) && ((0x1d < *data) || (-1 < (int)((*(ushort *)0x41a54 >> (*data & 0xff)) << 0x1f)))) {\n        *(ushort *)(params + 3) = *(ushort *)(params + 3) | 0x40;\n        return process_code_result;\n      }\n      params[1] = 0;\n      *params = params[4];\n      if ((int)((uint)data_length << 0x13) < 0) {\n        if ((process_code_result != -1) || (*data == 0)) {\n          params[0x15] = process_code_result;\n        }\n      }\n      int *data_pointer = (int *)params[0xd];\n      *data = original_data_length;\n      if (data_pointer != (int *)0x0) {\n        if (data_pointer != params + 0x11) {\n          _free_r(data);\n        }\n        params[0xd] = 0;\n        return 0;\n      }\n    }\n  }\n  return result;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000404c",
            "calling": [
                "__srefill_r",
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "process_data_0000404c"
        },
        "FUN_00002f74": {
            "renaming": {
                "FUN_00002f74": "print_saul_devices_info_00002f74",
                "dev": "current_device",
                "i": "device_count",
                "pcVar1": "class_name"
            },
            "code": "void print_saul_devices_info_00002f74(void)\n{\n  char *class_name;\n  int device_count = 0;\n  saul_reg_t *current_device = *(saul_reg_t **)PTR_saul_reg_00002fd0;\n  if (current_device == (saul_reg_t *)0x0) {\n    puts(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    puts(PTR_s_ID_Class_Name_00002fd4);\n  }\n  while (current_device != (saul_reg_t *)0x0) {\n    class_name = saul_class_to_str(current_device->driver->type);\n    iprintf(PTR_s___i__s__s_00002fdc, device_count, class_name, current_device->name);\n    device_count++;\n    current_device = current_device->next;\n  }\n  return;\n}",
            "called": [
                "iprintf",
                "puts",
                "saul_class_to_str"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f74",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "print_saul_devices_info_00002f74"
        },
        "FUN_000010a0": {
            "renaming": {
                "FUN_000010a0": "get_stack_space_000010a0",
                "stack": "stack_pointer",
                "space_free": "free_space",
                "stackp": "stack_ptr"
            },
            "code": "uintptr_t get_stack_space_000010a0(char *stack_pointer) {\n  uintptr_t free_space = 0;\n  uintptr_t *stack_ptr;\n  for (stack_ptr = (uintptr_t *)stack_pointer; (uintptr_t *)*stack_ptr == stack_ptr; stack_ptr++) {\n    // iterate through stack pointer\n  }\n  return (int)stack_ptr - (int)stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010a0",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "get_stack_space_000010a0"
        },
        "FUN_000012e2": {
            "renaming": {
                "FUN_000012e2": "read_from_isrpipe_000012e2",
                "isrpipe_t": "isrpipe",
                "buffer": "data_buffer",
                "count": "buffer_size",
                "iVar1": "read_status",
                "res": "result"
            },
            "code": "int read_from_isrpipe_000012e2(isrpipe_t *isrpipe,char *buffer,size_t count)\n{\n  int read_status;\n  int result;\n  while( true ) {\n    read_status = tsrb_get(&isrpipe->tsrb,buffer,count);\n    if (read_status != 0) break;\n    mutex_lock(&isrpipe->mutex);\n  }\n  return read_status;\n}",
            "called": [
                "mutex_lock",
                "tsrb_get"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012e2",
            "calling": [
                "uart_stdio_read"
            ],
            "imported": false,
            "current_name": "read_from_isrpipe_000012e2"
        },
        "FUN_000056a0": {
            "renaming": {
                "FUN_000056a0": "find_environment_variables_000056a0",
                "param_1": "envp",
                "param_2": "name",
                "param_3": "uStack_c",
                "param_4": "uStack_8",
                "uStack_c": "env",
                "uStack_8": "env"
            },
            "code": "void find_environment_variables_000056a0(const char* envp[], const char* name) {\n\tconst char** env;\n\tfor (env = envp; *env != NULL; ++env) {\n\t\tif (strncmp(*env, name, strlen(name)) == 0) {\n\t\t\treturn *env + strlen(name) + 1;\n\t\t}\n\t}\n\treturn NULL;\n}",
            "called": [
                "_findenv_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056a0",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "find_environment_variables_000056a0"
        },
        "FUN_0000231c": {
            "renaming": {
                "FUN_0000231c": "copy_data_from_tsrb_0000231c",
                "rb": "ring_buffer",
                "dst": "destination_buffer",
                "n": "max_bytes_to_copy",
                "local_20": "dst",
                "tmp": "bytes_copied",
                "iVar2": "is_rb_empty",
                "cVar1": "current_char",
                "_pop": "tsrb_pop"
            },
            "code": "int copy_data_from_tsrb_0000231c(tsrb_t *ring_buffer, char *destination_buffer, size_t max_bytes_to_copy)\n{\n  char current_char;\n  int is_rb_empty;\n  char *dst = destination_buffer;\n  size_t bytes_copied = 0;\n  \n  while ((max_bytes_to_copy != 0 && (is_rb_empty = tsrb_empty(ring_buffer), is_rb_empty == 0))) {\n    current_char = tsrb_pop(ring_buffer);\n    *dst = current_char;\n    max_bytes_to_copy--;\n    bytes_copied++;\n    dst++;\n  }\n  return bytes_copied;\n}",
            "called": [
                "tsrb_empty",
                "_pop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000231c",
            "calling": [
                "isrpipe_read"
            ],
            "imported": false,
            "current_name": "copy_data_from_tsrb_0000231c"
        },
        "FUN_000061cc": {
            "renaming": {
                "FUN_000061cc": "parse_input_000061cc",
                "param_1": "input_format",
                "param_2": "input_buffer",
                "param_3": "current_char",
                "param_4": "output_values",
                "puVar1": "hex_lookup_table",
                "puVar2": "hex_lookup_table_end",
                "iVar3": "result",
                "pvVar4": "hex_lookup_result",
                "uVar5": "current_char_value",
                "pbVar6": "next_char",
                "uVar7": "current_char_code",
                "local_2b0": "output_values_ptr",
                "auStack_2ac": "input_buffer_local",
                "local_1ac": "input_format_flags",
                "local_1a8": "input_format_base",
                "local_1a4": "input_format_width",
                "local_1a0": "parsed_values_count",
                "local_19c": "parsed_bytes_count",
                "local_198": "input_buffer_ptr",
                "local_194": "input_format_type",
                "local_30": "scanf_error_code",
                "local_2c": "scanf_function_ptr"
            },
            "code": "\nint parse_input_000061cc(int input_format,byte **input_buffer,byte *current_char,int **output_values)\n\n{\n  undefined *hex_lookup_table;\n  undefined *hex_lookup_table_end;\n  int result;\n  void *hex_lookup_result;\n  uint current_char_value;\n  byte *next_char;\n  uint current_char_code;\n  int **output_values_ptr;\n  undefined input_buffer_local [256];\n  uint input_format_flags;\n  undefined4 input_format_base;\n  uint input_format_width;\n  int parsed_values_count;\n  int parsed_bytes_count;\n  undefined *input_buffer_ptr;\n  int input_format_type;\n  undefined4 scanf_error_code;\n  code *scanf_function_ptr;\n  \n  hex_lookup_table_end = PTR_DAT_000064b4;\n  hex_lookup_table = PTR_DAT_000064b0;\n  parsed_values_count = 0;\n  parsed_bytes_count = 0;\n  scanf_error_code = DAT_000064a8;\n  scanf_function_ptr = DAT_000064ac;\n  output_values_ptr = output_values;\n  input_buffer_ptr = input_buffer_local;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      current_char_code = (uint)*current_char;\n      if (current_char_code == 0) {\n        return parsed_values_count;\n      }\n      current_char_value = (byte)hex_lookup_table[current_char_code] & 8;\n      next_char = current_char + 1;\n      if ((hex_lookup_table[current_char_code] & 8) == 0) break;\n      while (((current_char = next_char, 0 < (int)input_buffer[1] ||\n              (result = (*scanf_function_ptr)(input_format,input_buffer), result == 0)) &&\n             ((int)((uint)(byte)hex_lookup_table[**input_buffer] << 0x1c) < 0))) {\n        parsed_bytes_count = parsed_bytes_count + 1;\n        input_buffer[1] = input_buffer[1] + -1;\n        *input_buffer = *input_buffer + 1;\n      }\n    }\n    if (current_char_code == 0x25) break;\nLAB_00006352:\n    if (((int)input_buffer[1] < 1) && (result = (*scanf_function_ptr)(input_format,input_buffer), result != 0))\n    goto LAB_00006380;\n    if (**input_buffer != current_char_code) {\n      return parsed_values_count;\n    }\n    *input_buffer = *input_buffer + 1;\n    parsed_bytes_count = parsed_bytes_count + 1;\n    input_buffer[1] = input_buffer[1] + -1;\n    current_char = next_char;\n  }\n  input_format_width = current_char_value;\n  input_format_flags = current_char_value;\n  if (current_char[1] == 0x2a) {\n    next_char = current_char + 2;\n    input_format_flags = 0x10;\n  }\n  while( true ) {\n    current_char_value = (uint)*next_char;\n    if (9 < current_char_value - 0x30) break;\n    next_char = next_char + 1;\n    input_format_width = (input_format_width * 10 + current_char_value) - 0x30;\n  }\n  hex_lookup_result = memchr(PTR_DAT_000064b4,current_char_value,3);\n  if (hex_lookup_result != (void *)0x0) {\n    input_format_flags = 1 << ((int)hex_lookup_result - (int)hex_lookup_table_end & 0xffU) | input_format_flags;\n    next_char = next_char + 1;\n  }\n  current_char = next_char + 1;\n  current_char_value = (uint)*next_char;\n  if (current_char_value < 0x79) {\n    if (0x57 < current_char_value) {\n      switch(current_char_value) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        current_char = (byte *)__sccl(input_buffer_local,current_char);\n        input_format_flags = input_format_flags | 0x40;\n        input_format_type = 1;\n        break;\n      case 99:\n        input_format_flags = input_format_flags | 0x40;\n        input_format_type = 0;\n        break;\n      case 100:\n      case 0x75:\n        input_format_base = 10;\nLAB_000063a0:\n        if (current_char_value < 0x6f) {\n          input_format_type = 3;\n        }\n        else {\n          input_format_type = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        input_format_type = 5;\n        break;\n      case 0x69:\n        input_format_base = 0;\n        input_format_type = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(input_format_flags << 0x1b)) {\n          if ((int)(input_format_flags << 0x1f) < 0) {\n            *(short *)*output_values_ptr = (short)parsed_bytes_count;\n            output_values_ptr = output_values_ptr + 1;\n          }\n          else {\n            **output_values_ptr = parsed_bytes_count;\n            output_values_ptr = output_values_ptr + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        input_format_base = 8;\n        input_format_type = 4;\n        break;\n      case 0x70:\n        input_format_flags = input_format_flags | 0x20;\n      case 0x58:\n      case 0x78:\n        input_format_flags = input_format_flags | 0x200;\n        input_format_base = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        input_format_type = 2;\n      }\nLAB_000063ac:\n      if (((int)input_buffer[1] < 1) && (result = (*scanf_function_ptr)(input_format,input_buffer), result != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(input_format_flags << 0x19)) {\n        while ((int)((uint)(byte)hex_lookup_table[**input_buffer] << 0x1c) < 0) {\n          parsed_bytes_count = parsed_bytes_count + 1;\n          next_char = input_buffer[1];\n          input_buffer[1] = next_char + -1;\n          if ((int)(next_char + -1) < 1) {\n            result = (*scanf_function_ptr)(input_format,input_buffer);\n            if (result != 0) goto LAB_00006380;\n          }\n          else {\n            *input_buffer = *input_buffer + 1;\n          }\n        }\n      }\n      if (input_format_type < 3) {\n        result = _scanf_chars(input_format,&input_format_flags,input_buffer,&output_values_ptr);\n      }\n      else if (input_format_type < 5) {\n        result = _scanf_i(input_format,&input_format_flags,input_buffer,&output_values_ptr);\n      }\n      else {\n        result = input_format;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (result == 1) {\n        return parsed_values_count;\n      }\n      if (result == 2) {\nLAB_00006380:\n        if (parsed_values_count == 0) {\nLAB_00006388:\n          parsed_values_count = -1;\n        }\n        else if ((*(ushort *)(input_buffer + 3) & 0x40) != 0) {\n          parsed_values_count = -1;\n        }\n        return parsed_values_count;\n      }\n      goto LAB_000061f6;\n    }\n    next_char = current_char;\n    if (current_char_value == 0x25) goto LAB_00006352;\n    if (current_char_value < 0x26) {\n      if (current_char_value != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (current_char_value - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  input_format_type = 3;\n  input_format_base = 10;\n  goto LAB_000063ac;\n}\n\n",
            "called": [
                "_scanf_i",
                "__ssrefill_r",
                "__sccl",
                "_scanf_chars",
                "memchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000061cc",
            "calling": [
                "siscanf"
            ],
            "imported": false,
            "current_name": "parse_input_000061cc"
        },
        "FUN_00002690": {
            "renaming": {
                "FUN_00002690": "convert_alarm_time_to_tm_struct_00002690",
                "time": "time_struct",
                "t": "current_time",
                "PTR_": "PTR_ (unchanged)",
                "DAT_": "DAT_ (unchanged)"
            },
            "code": "int convert_alarm_time_to_tm_struct_00002690(tm *time)\n{\n    time_t current_time = rtt_get_alarm();\n    time_t zero_time = 0;\n    gmtime_r(&current_time, time);\n    return 0;\n}",
            "called": [
                "gmtime_r",
                "rtt_get_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002690",
            "calling": [
                "_rtc_getalarm"
            ],
            "imported": false,
            "current_name": "convert_alarm_time_to_tm_struct_00002690"
        },
        "FUN_00006010": {
            "renaming": {
                "FUN_00006010": "find_byte_in_data_00006010",
                "__s": "data",
                "__c": "byte_to_find",
                "__n": "data_size",
                "bVar1": "byte_val",
                "cVar2": "byte_0",
                "cVar3": "byte_1",
                "cVar4": "byte_2",
                "cVar5": "byte_3",
                "pbVar6": "byte_ptr_1",
                "puVar7": "uint_ptr",
                "pbVar8": "byte_ptr_2",
                "uVar9": "byte_to_find_u8",
                "uVar10": "data_offset",
                "uVar11": "data_u32_size",
                "uVar12": "data_u32_xor_reduced",
                "uVar13": "byte_offset",
                "bVar14": "byte_0_set",
                "bVar15": "byte_1_set",
                "bVar16": "byte_2_set",
                "bVar17": "byte_3_set"
            },
            "code": "void* find_byte_in_data_00006010(void* data, int byte_to_find, size_t data_size)\n{\n  uint8_t* byte_data = (uint8_t*)data;\n  uint8_t byte_to_find_u8 = byte_to_find & 0xff;\n  if ((int)data_size < 0x10) {\n    while (data_size > 0) {\n      if (*byte_data == byte_to_find_u8) {\n        return byte_data;\n      }\n      byte_data++;\n      data_size--;\n    }\n    return NULL;\n  }\n  uint8_t* data_end = byte_data + data_size;\n  uint8_t* data_aligned = (uint8_t*)(((uintptr_t)byte_data + 7) & ~7);\n  uint32_t byte_to_find_u32 = byte_to_find_u8;\n  byte_to_find_u32 |= byte_to_find_u32 << 8;\n  byte_to_find_u32 |= byte_to_find_u32 << 16;\n  uint32_t* data_u32 = (uint32_t*)data_aligned;\n  size_t data_u32_size = (size_t)(data_end - (uint8_t*)data_u32);\n  size_t data_u32_size_aligned = data_u32_size & ~7;\n  while (data_u32_size_aligned != 0) {\n    uint32_t data_u32_xor = *data_u32 ^ byte_to_find_u32;\n    uint32_t data_u32_xor_reduced = ((data_u32_xor & 0x7f7f7f7f) + 0x7f7f7f7f) | data_u32_xor;\n    data_u32_xor_reduced = ~data_u32_xor_reduced & 0x80808080;\n    if (data_u32_xor_reduced != 0) {\n      uint8_t* byte_data_xor = (uint8_t*)data_u32;\n      if (data_u32_xor & 0x000000ff) {\n        return byte_data_xor;\n      }\n      if (data_u32_xor & 0x0000ff00) {\n        return byte_data_xor + 1;\n      }\n      if (data_u32_xor & 0x00ff0000) {\n        return byte_data_xor + 2;\n      }\n      return byte_data_xor + 3;\n    }\n    data_u32++;\n    data_u32_size_aligned -= 8;\n  }\n  data_size &= 7;\n  while (data_size > 0) {\n    if (*byte_data == byte_to_find_u8) {\n      return byte_data;\n    }\n    byte_data++;\n    data_size--;\n  }\n  return NULL;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006010",
            "calling": [
                "_scanf_i",
                "__ssvfiscanf_r",
                "_vfprintf_r",
                "_printf_i"
            ],
            "imported": false,
            "current_name": "find_byte_in_data_00006010"
        },
        "FUN_00001cf0": {
            "renaming": {
                "FUN_00001cf0": "check_for_context_switch_request_00001cf0",
                "PTR_sched_context_switch_request_00001d04": "context_switch_request"
            },
            "code": "void check_for_context_switch_request_00001cf0(void)\n{\n    int* PTR_sched_context_switch_request_00001d04 = (int*) PTR_sched_PTR_sched_context_switch_request_00001d04_00001d04;\n    if (*PTR_sched_context_switch_request_00001d04 != 0)\n    {\n        thread_yield_higher();\n    }\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001cf0",
            "calling": [
                "irq_handler"
            ],
            "imported": false,
            "current_name": "check_for_context_switch_request_00001cf0"
        },
        "FUN_00003ec4": {
            "renaming": {
                "FUN_00003ec4": "format_decimal_00003ec4",
                "out": "output",
                "val": "value",
                "fp_digits": "fractional_digits",
                "sVar1": "output_length",
                "val_00": "positive_value",
                "iVar2": "position",
                "div_len": "divisor",
                "abs": "absolute_value",
                "e": "fractional_part",
                "div": "divisor",
                "pos": "position"
            },
            "code": "size_t format_decimal_00003ec4(char *output, int32_t value, int fractional_digits) {\n  size_t output_length;\n  uint32_t positive_value;\n  int32_t absolute_value;\n  uint32_t fractional_part;\n  uint32_t divisor;\n  uint32_t position = 0;\n  if (fractional_digits + 7 < 0 != SCARRY4(fractional_digits,7)) {\n    /* WARNING: Subroutine does not return */\n    core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_00003fec);\n  }\n  if (fractional_digits == 0) {\n    output_length = format_integer(output, value);\n  }\n  else if (fractional_digits < 1) {\n    positive_value = (uint32_t)value;\n    if (value < 0) {\n      absolute_value = -value;\n    }\n    else {\n      absolute_value = value;\n    }\n    divisor = *(uint32_t *)(PTR__tenmap_00003ff0 + fractional_digits * -4);\n    fractional_part = absolute_value % divisor;\n    positive_value = absolute_value / divisor;\n    if (value < 0) {\n      output[position] = '-';\n      position++;\n    }\n    output_length = format_integer(output + position, positive_value);\n    position += output_length;\n    output[position] = '.';\n    position++;\n    output_length = format_integer(output + position, fractional_part);\n    fmt_lpad(output + position, output_length, -fractional_digits, '0');\n    position += output_length;\n    output_length = position;\n  }\n  else {\n    output_length = format_integer(output, value);\n    memset(output + output_length, '0', fractional_digits);\n    output_length += fractional_digits;\n  }\n  return output_length;\n}",
            "called": [
                "fmt_s32_dec",
                "fmt_lpad",
                "memset",
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ec4",
            "calling": [
                "fmt_s16_dfp"
            ],
            "imported": false,
            "current_name": "format_decimal_00003ec4"
        },
        "FUN_00001360": {
            "renaming": {
                "FUN_00001360": "calculate_address_00001360",
                "ptr": "PTR_address",
                "bit": "bit_shift"
            },
            "code": "void * calculate_address_00001360(void *PTR_address, uintptr_t bit_shift) {\n    uintptr_t shifted_address = ((uintptr_t)PTR_address & 0xf0000000) | (((uintptr_t)PTR_address & 0xfffff) << 5);\n    uintptr_t calculated_address = (bit_shift * 4) + shifted_address + 0x2000000;\n    return (void *)calculated_address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001360",
            "calling": [
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_address_00001360"
        },
        "FUN_00004622": {
            "renaming": {
                "FUN_00004622": "fill_memory_with_char_00004622",
                "__s": "memory",
                "__c": "character",
                "__n": "size",
                "puVar1": "ptr"
            },
            "code": "void * fill_memory_with_char_00004622(void *memory, int character, size_t size) {\n  char *ptr = (char *)memory;\n  char c = (char)character;\n  for (size_t i = 0; i < size; i++) {\n    *ptr = c;\n    ptr++;\n  }\n  return memory;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004622",
            "calling": [
                "std",
                "__sfmoreglue",
                "fmt_s32_dfp",
                "fmt_lpad",
                "__sfp",
                "write"
            ],
            "imported": false,
            "current_name": "fill_memory_with_char_00004622"
        },
        "FUN_0000093c": {
            "renaming": {
                "FUN_0000093c": "set_flag_on_0000093c",
                "DAT_00000954": "data_ptr",
                "PTR_": "",
                "DAT_": "",
                "uint": "uint32_t",
                "*": "",
                "|": "|=",
                "*(uint *)(DAT_00000954 + 4)": "*flag_ptr",
                "*(uint *)(DAT_00000954 + 4) | 0x10000000": "*flag_ptr |= 0x10000000"
            },
            "code": "void set_flag_on_0000093c(uint32_t *DAT_00000954)\n{\n  uint32_t *(uint *)(DAT_00000954 + 4) = DAT_00000954 + 1;\n  *(uint *)(DAT_00000954 + 4) | 0x10000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000093c",
            "calling": [
                "cortexm_isr_end",
                "_mutex_lock",
                "sched_switch",
                "cortexm_isr_end",
                "cortexm_isr_end"
            ],
            "imported": false,
            "current_name": "set_flag_on_0000093c"
        },
        "FUN_00003658": {
            "renaming": {
                "FUN_00003658": "synchronize_data_00003658",
                "DataSynchronizationBarrier": "synchronize_memory_barrier",
                "DAT_00003680": "data_pointer",
                "DAT_00003684": "data_value"
            },
            "code": "void synchronize_data_00003658(void)\n{\n    synchronize_memory_barrier(0xf);\n    uint* data_ptr = (uint*)(DAT_00003680 + 0xc);\n    uint DAT_00003684 = DAT_00003684 | (*data_ptr & 0x700);\n    *data_ptr = DAT_00003684;\n    synchronize_memory_barrier(0xf);\n    while(true)\n    {\n        // Do nothing\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003658",
            "calling": [
                "pm_reboot"
            ],
            "imported": false,
            "current_name": "synchronize_data_00003658"
        },
        "FUN_000019c0": {
            "renaming": {
                "FUN_000019c0": "enable_oscillator_and_set_fll_factor_000019c0",
                "kinetis_mcg_enable_osc": "enable_oscillator",
                "kinetis_mcg_set_fll_factor": "set_fll_factor",
                "DAT_00001a0c": "register_address",
                "BIT_0": "oscillator_bit",
                "DAT_00001a10": "register_pointer",
                "BIT_7": "pll_bit",
                "disable_pll": "disable_pll",
                "PTR_current_mode_00001a14": "current_mode_pointer"
            },
            "code": "void enable_oscillator_and_set_fll_factor_000019c0(void)\n{\n  enable_oscillator();\n  set_fll_factor(KINETIS_MCG_FLL_FACTOR_1920);\n  clear_bit(DAT_00001a0c, BIT_0);\n  *DAT_00001a10 = (*DAT_00001a10 & 0x3b) | BIT_7;\n  while ((DAT_00001a10[6] & 0xc) != 8);\n  disable_pll();\n  *PTR_current_mode_00001a14 = 3;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000019c0",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "enable_oscillator_and_set_fll_factor_000019c0"
        },
        "FUN_000060b0": {
            "renaming": {
                "FUN_000060b0": "reverse_copy_000060b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_bytes",
                "puVar1": "temp",
                "puVar2": "source_ptr",
                "puVar3": "destination_ptr"
            },
            "code": "void * reverse_copy_000060b0(void *destination, const void *source, size_t num_bytes){\n    unsigned char *source_ptr = (unsigned char *)source + num_bytes - 1;\n    unsigned char *destination_ptr = (unsigned char *)destination;\n    while (source_ptr >= (unsigned char *)source){\n        *destination_ptr = *source_ptr;\n        source_ptr--;\n        destination_ptr++;\n    }\n    return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060b0",
            "calling": [
                "__submore",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "reverse_copy_000060b0"
        },
        "FUN_00006a14": {
            "renaming": {
                "FUN_00006a14": "division_with_remainder_00006a14",
                "param_1": "dividend",
                "param_2": "dividend_high",
                "param_3": "divisor",
                "param_4": "divisor_high",
                "param_5": "remainder",
                "UNRECOVERED_JUMPTABLE": "udf_handler",
                "uVar1": "quotient_high",
                "uVar2": "pointer_to_quotient_high",
                "uVar3": "pointer_to_quotient_low",
                "uVar4": "shift_amount",
                "uVar5": "remainder_low",
                "uVar6": "quotient_low",
                "uVar7": "temp_1",
                "uVar8": "temp_2",
                "uVar9": "temp_3",
                "uVar10": "temp_4",
                "bVar11": "carry_flag",
                "uVar12": "result"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong division_with_remainder_00006a14(uint dividend,uint dividend_high,uint divisor,uint divisor_high,uint *remainder)\n\n{\n  code *udf_handler;\n  uint quotient_high;\n  uint *ppointer_to_quotient_high;\n  uint *ppointer_to_quotient_low;\n  uint shift_amount;\n  uint remainder_low;\n  uint quotient_low;\n  uint temp_1;\n  uint temp_2;\n  uint temp_3;\n  uint temp_4;\n  bool carry_flag;\n  ulonglong result;\n  \n  if (divisor_high == 0) {\n    if (dividend_high < divisor) {\n      shift_amount = count_leading_zeroes(divisor);\n      if (shift_amount != 0) {\n        divisor = divisor << (shift_amount & 0xff);\n        dividend_high = dividend >> (0x20 - shift_amount & 0xff) | dividend_high << (shift_amount & 0xff);\n        dividend = dividend << (shift_amount & 0xff);\n      }\n      temp_1 = divisor >> 0x10;\n      temp_3 = dividend_high / temp_1;\n      remainder_low = dividend >> 0x10 | (dividend_high - temp_1 * temp_3) * 0x10000;\n      quotient_high = temp_3 * (divisor & 0xffff);\n      quotient_low = temp_3;\n      if (remainder_low <= quotient_high && quotient_high - remainder_low != 0) {\n        carry_flag = CARRY4(divisor,remainder_low);\n        remainder_low = divisor + remainder_low;\n        quotient_low = temp_3 - 1;\n        if ((carry_flag == false) && (remainder_low <= quotient_high && quotient_high - remainder_low != 0)) {\n          quotient_low = temp_3 - 2;\n          remainder_low = remainder_low + divisor;\n        }\n      }\n      temp_3 = (remainder_low - quotient_high) / temp_1;\n      remainder_low = dividend & 0xffff | ((remainder_low - quotient_high) - temp_1 * temp_3) * 0x10000;\n      temp_1 = temp_3 * (divisor & 0xffff);\n      quotient_high = temp_3;\n      if (remainder_low <= temp_1 && temp_1 - remainder_low != 0) {\n        carry_flag = CARRY4(divisor,remainder_low);\n        remainder_low = divisor + remainder_low;\n        quotient_high = temp_3 - 1;\n        if ((carry_flag == false) && (remainder_low <= temp_1 && temp_1 - remainder_low != 0)) {\n          quotient_high = temp_3 - 2;\n          remainder_low = remainder_low + divisor;\n        }\n      }\n      remainder_low = remainder_low - temp_1;\n      ppointer_to_quotient_high = (uint *)(quotient_high | quotient_low << 0x10);\n      ppointer_to_quotient_low = (uint *)0x0;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        udf_handler = (code *)software_udf(0xff,0x6abc);\n        result = (*udf_handler)();\n        return result;\n      }\n      shift_amount = count_leading_zeroes(divisor);\n      if (shift_amount == 0) {\n        dividend_high = dividend_high - divisor;\n        temp_4 = divisor >> 0x10;\n        temp_2 = divisor & 0xffff;\n        ppointer_to_quotient_low = (uint *)0x1;\n      }\n      else {\n        divisor = divisor << (shift_amount & 0xff);\n        temp_4 = divisor >> 0x10;\n        quotient_low = dividend_high >> (0x20 - shift_amount & 0xff);\n        quotient_high = dividend >> (0x20 - shift_amount & 0xff) | dividend_high << (shift_amount & 0xff);\n        remainder_low = quotient_low / temp_4;\n        temp_2 = divisor & 0xffff;\n        temp_3 = quotient_high >> 0x10 | (quotient_low - temp_4 * remainder_low) * 0x10000;\n        temp_1 = remainder_low * temp_2;\n        dividend = dividend << (shift_amount & 0xff);\n        quotient_low = remainder_low;\n        if (temp_3 <= temp_1 && temp_1 - temp_3 != 0) {\n          carry_flag = CARRY4(divisor,temp_3);\n          temp_3 = divisor + temp_3;\n          quotient_low = remainder_low - 1;\n          if ((carry_flag == false) && (temp_3 <= temp_1 && temp_1 - temp_3 != 0)) {\n            quotient_low = remainder_low - 2;\n            temp_3 = temp_3 + divisor;\n          }\n        }\n        remainder_low = (temp_3 - temp_1) / temp_4;\n        dividend_high = quotient_high & 0xffff | ((temp_3 - temp_1) - temp_4 * remainder_low) * 0x10000;\n        temp_1 = remainder_low * temp_2;\n        quotient_high = remainder_low;\n        if (dividend_high <= temp_1 && temp_1 - dividend_high != 0) {\n          carry_flag = CARRY4(divisor,dividend_high);\n          dividend_high = divisor + dividend_high;\n          quotient_high = remainder_low - 1;\n          if ((carry_flag == false) && (dividend_high <= temp_1 && temp_1 - dividend_high != 0)) {\n            quotient_high = remainder_low - 2;\n            dividend_high = dividend_high + divisor;\n          }\n        }\n        dividend_high = dividend_high - temp_1;\n        ppointer_to_quotient_low = (uint *)(quotient_high | quotient_low << 0x10);\n      }\n      temp_1 = dividend_high / temp_4;\n      remainder_low = dividend >> 0x10 | (dividend_high - temp_4 * temp_1) * 0x10000;\n      quotient_high = temp_2 * temp_1;\n      quotient_low = temp_1;\n      if (remainder_low <= quotient_high && quotient_high - remainder_low != 0) {\n        carry_flag = CARRY4(divisor,remainder_low);\n        remainder_low = divisor + remainder_low;\n        quotient_low = temp_1 - 1;\n        if ((carry_flag == false) && (remainder_low <= quotient_high && quotient_high - remainder_low != 0)) {\n          quotient_low = temp_1 - 2;\n          remainder_low = remainder_low + divisor;\n        }\n      }\n      temp_1 = (remainder_low - quotient_high) / temp_4;\n      remainder_low = dividend & 0xffff | ((remainder_low - quotient_high) - temp_4 * temp_1) * 0x10000;\n      temp_2 = temp_2 * temp_1;\n      quotient_high = temp_1;\n      if (remainder_low <= temp_2 && temp_2 - remainder_low != 0) {\n        carry_flag = CARRY4(divisor,remainder_low);\n        remainder_low = divisor + remainder_low;\n        quotient_high = temp_1 - 1;\n        if ((carry_flag == false) && (remainder_low <= temp_2 && temp_2 - remainder_low != 0)) {\n          quotient_high = temp_1 - 2;\n          remainder_low = remainder_low + divisor;\n        }\n      }\n      remainder_low = remainder_low - temp_2;\n      ppointer_to_quotient_high = (uint *)(quotient_high | quotient_low << 0x10);\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = remainder_low >> (shift_amount & 0xff);\n      remainder[1] = 0;\n    }\n  }\n  else if (dividend_high < divisor_high) {\n    ppointer_to_quotient_high = remainder;\n    ppointer_to_quotient_low = remainder;\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = dividend_high;\n      return 0;\n    }\n  }\n  else {\n    ppointer_to_quotient_low = (uint *)count_leading_zeroes(divisor_high);\n    if (ppointer_to_quotient_low != (uint *)0x0) {\n      temp_2 = 0x20 - (int)ppointer_to_quotient_low;\n      remainder_low = divisor >> (temp_2 & 0xff) | divisor_high << ((uint)ppointer_to_quotient_low & 0xff);\n      temp_4 = remainder_low >> 0x10;\n      shift_amount = dividend_high >> (temp_2 & 0xff);\n      quotient_low = dividend >> (temp_2 & 0xff) | dividend_high << ((uint)ppointer_to_quotient_low & 0xff);\n      temp_1 = shift_amount / temp_4;\n      quotient_high = quotient_low >> 0x10 | (shift_amount - temp_4 * temp_1) * 0x10000;\n      temp_3 = temp_1 * (remainder_low & 0xffff);\n      divisor = divisor << ((uint)ppointer_to_quotient_low & 0xff);\n      dividend = dividend << ((uint)ppointer_to_quotient_low & 0xff);\n      shift_amount = temp_1;\n      if (quotient_high <= temp_3 && temp_3 - quotient_high != 0) {\n        carry_flag = CARRY4(remainder_low,quotient_high);\n        quotient_high = remainder_low + quotient_high;\n        shift_amount = temp_1 - 1;\n        if ((carry_flag == false) && (quotient_high <= temp_3 && temp_3 - quotient_high != 0)) {\n          shift_amount = temp_1 - 2;\n          quotient_high = quotient_high + remainder_low;\n        }\n      }\n      temp_1 = (quotient_high - temp_3) / temp_4;\n      quotient_high = quotient_low & 0xffff | ((quotient_high - temp_3) - temp_4 * temp_1) * 0x10000;\n      temp_3 = temp_1 * (remainder_low & 0xffff);\n      quotient_low = temp_1;\n      if (quotient_high <= temp_3 && temp_3 - quotient_high != 0) {\n        carry_flag = CARRY4(remainder_low,quotient_high);\n        quotient_high = remainder_low + quotient_high;\n        quotient_low = temp_1 - 1;\n        if ((carry_flag == false) && (quotient_high <= temp_3 && temp_3 - quotient_high != 0)) {\n          quotient_low = temp_1 - 2;\n          quotient_high = quotient_high + remainder_low;\n        }\n      }\n      quotient_low = quotient_low | shift_amount << 0x10;\n      result = (ulonglong)quotient_low * (ulonglong)divisor;\n      if (CONCAT44(quotient_high - temp_3,dividend) < result) {\n        result = result - CONCAT44(remainder_low,divisor);\n        quotient_low = quotient_low - 1;\n      }\n      if (remainder != (uint *)0x0) {\n        shift_amount = ((quotient_high - temp_3) - (int)(result >> 0x20)) - (uint)(dividend < (uint)result);\n        *remainder = shift_amount << (temp_2 & 0xff) | dividend - (uint)result >> ((uint)ppointer_to_quotient_low & 0xff);\n        remainder[1] = shift_amount >> ((uint)ppointer_to_quotient_low & 0xff);\n      }\n      return (ulonglong)quotient_low;\n    }\n    if ((divisor_high < dividend_high) || (ppointer_to_quotient_high = ppointer_to_quotient_low, divisor <= dividend)) {\n      carry_flag = dividend < divisor;\n      dividend = dividend - divisor;\n      dividend_high = (dividend_high - divisor_high) - (uint)carry_flag;\n      ppointer_to_quotient_high = (uint *)0x1;\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = dividend_high;\n    }\n  }\n  return CONCAT44(ppointer_to_quotient_low,ppointer_to_quotient_high);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006a14",
            "calling": [
                "__aeabi_ldivmod"
            ],
            "imported": false,
            "current_name": "division_with_remainder_00006a14"
        },
        "FUN_000023d0": {
            "renaming": {
                "FUN_000023d0": "execute_afl_call_000023d0",
                "ticks": "ticks",
                "uVar1": "result",
                "PTR_noHyperCall_000023fc": "PTR_noHyperCall_000023fc",
                "aflCall": "aflCall"
            },
            "code": "uint32_t execute_afl_call_000023d0(int ticks) {\n  uint32_t result = 0;\n  if (*(int *)PTR_noHyperCall_000023fc == 0) {\n    result = aflCall(1, ticks, 0);\n  }\n  return result;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023d0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "execute_afl_call_000023d0"
        },
        "FUN_00000a30": {
            "renaming": {
                "FUN_00000a30": "handle_nmi_00000a30",
                "PTR_s_NMI_HANDLER_00000a3c": "nmi_handler"
            },
            "code": "void handle_nmi_00000a30(void)\n{\n    core_panic(PANIC_NMI_HANDLER, PTR_s_NMI_HANDLER_00000a3c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a30",
            "calling": [],
            "imported": false,
            "current_name": "handle_nmi_00000a30"
        },
        "FUN_000034c0": {
            "renaming": {
                "FUN_000034c0": "print_rtc_commands_000034c0",
                "PTR_s_usage__rtc__command___arguments__00003500": "command_usage",
                "PTR_s_commands__00003504": "commands",
                "PTR_s__poweron_power_the_interface_on_00003508": "power_on_msg",
                "PTR_s__poweroff_power_the_interface_of_0000350c": "power_off_msg",
                "PTR_s__clearalarm_deactivate_the_curre_00003510": "deactivate_alarm_msg",
                "PTR_s__getalarm_print_the_currently_al_00003514": "print_current_alarm_msg",
                "PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518": "set_alarm_msg",
                "PTR_s__gettime_print_the_current_time_0000351c": "print_current_time_msg",
                "PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520": "set_time_msg"
            },
            "code": "int print_rtc_commands_000034c0(void)\n{\n    puts(PTR_s_usage__rtc__command___arguments__00003500);\n    puts(PTR_s_commands__00003504);\n    puts(PTR_s__poweron_power_the_interface_on_00003508);\n    puts(PTR_s__poweroff_power_the_interface_of_0000350c);\n    puts(PTR_s__clearalarm_deactivate_the_curre_00003510);\n    puts(PTR_s__getalarm_print_the_currently_al_00003514);\n    puts(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n    puts(PTR_s__gettime_print_the_current_time_0000351c);\n    puts(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n    return 0;\n}",
            "called": [
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000034c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "print_rtc_commands_000034c0"
        },
        "FUN_000050e8": {
            "renaming": {
                "FUN_000050e8": "acquire_time_zone_mutex_000050e8",
                "PTR___lock___tz_mutex_000050f0": "time_zone_mutex"
            },
            "code": "void acquire_time_zone_mutex_000050e8(void)\n{\n  __retarget_lock_acquire(PTR___lock___tz_mutex_000050f0);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050e8",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "acquire_time_zone_mutex_000050e8"
        },
        "FUN_000042a4": {
            "renaming": {
                "FUN_000042a4": "initialize_data_000042a4",
                "param_1": "data_ptr",
                "uVar1": "result",
                "iVar2": "global_impure_ptr_value",
                "bVar3": "is_global_impure_ptr_value_same_as_data_ptr"
            },
            "code": "void initialize_data_000042a4(int data_ptr)\n{\n    acquire_lock();\n    if (*(int *)(data_ptr + DATA_FLAG_OFFSET) == 0) {\n        *(int *)(data_ptr + INT_OFFSET_1) = 0;\n        *(int *)(data_ptr + INT_OFFSET_2) = 0;\n        *(int *)(data_ptr + INT_OFFSET_3) = 0;\n        int global_impure_ptr_value = *(int *)PTR__global_impure_ptr_0000430c;\n        *(int *)(data_ptr + INT_OFFSET_4) = DAT_00004310;\n        bool is_global_impure_ptr_value_same_as_data_ptr = global_impure_ptr_value == data_ptr;\n        if (is_global_impure_ptr_value_same_as_data_ptr) {\n            global_impure_ptr_value = 1;\n        }\n        if (is_global_impure_ptr_value_same_as_data_ptr) {\n            *(int *)(data_ptr + DATA_FLAG_OFFSET) = global_impure_ptr_value;\n        }\n        *(int *)(data_ptr + INT_OFFSET_5) = __sfp(data_ptr);\n        *(int *)(data_ptr + INT_OFFSET_6) = __sfp(data_ptr);\n        *(int *)(data_ptr + INT_OFFSET_7) = __sfp(data_ptr);\n        std(*(int *)(data_ptr + INT_OFFSET_5), 4, 0);\n        std(*(int *)(data_ptr + INT_OFFSET_6), 9, 1);\n        std(*(int *)(data_ptr + INT_OFFSET_7), 0x12, 2);\n        *(int *)(data_ptr + DATA_FLAG_OFFSET) = 1;\n    }\n    release_lock();\n    return;\n}",
            "called": [
                "__sinit_lock_acquire",
                "__sinit_lock_release",
                "std",
                "__sfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000042a4",
            "calling": [
                "__swbuf_r",
                "__srefill_r",
                "_fflush_r",
                "__sfp",
                "_puts_r",
                "getchar",
                "iprintf",
                "putchar",
                "__swsetup_r",
                "_vfprintf_r",
                "__srget_r",
                "_putc_r",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "initialize_data_000042a4"
        },
        "FUN_00000514": {
            "renaming": {
                "FUN_00000514": "set_errno_to_permission_denied_00000514",
                "r": "reent",
                "fd": "file_descriptor",
                "st": "file_status",
                "_errno": "EACCES"
            },
            "code": "int set_errno_to_permission_denied_00000514(_reent *reent, int file_descriptor, stat *file_status)\n{\n  reent->_errno = EACCES;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000514",
            "calling": [
                "__swhatbuf_r"
            ],
            "imported": false,
            "current_name": "set_errno_to_permission_denied_00000514"
        },
        "FUN_00002e9c": {
            "renaming": {
                "FUN_00002e9c": "reboot_system_00002e9c",
                "argc": "argument_count",
                "argv": "arguments"
            },
            "code": "int reboot_system_00002e9c(int argument_count, char **arguments)\n{\n    pm_reboot();\n    return 0;\n}",
            "called": [
                "pm_reboot"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e9c",
            "calling": [],
            "imported": false,
            "current_name": "reboot_system_00002e9c"
        },
        "FUN_00001960": {
            "renaming": {
                "FUN_00001960": "setFllFactorAndMode_00001960",
                "DAT_000019b4": "configRegister",
                "DAT_000019b8": "statusRegister",
                "PTR_current_mode_000019bc": "currentMode"
            },
            "code": "void setFllFactorAndMode_00001960(void)\n{\n  setFllFactor(KINETIS_MCG_FLL_FACTOR_1464);\n  clearBit(DAT_000019b4, 0x01);\n  *DAT_000019b8 = (*DAT_000019b8 & 0x3b) | 0x44;\n  while ((DAT_000019b8[6] & 0xc) != 4);\n  while ((DAT_000019b8[6] & 0x10) == 0);\n  *PTR_current_mode_000019bc = 2;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001960",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "setFllFactorAndMode_00001960"
        },
        "FUN_00000990": {
            "renaming": {
                "FUN_00000990": "do_nothing_00000990"
            },
            "code": "\nvoid do_nothing_00000990(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000990",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "do_nothing_00000990"
        },
        "FUN_00001a3c": {
            "renaming": {
                "FUN_00001a3c": "set_mode_to_5_and_disable_pll_00001a3c",
                "DAT_00001a58": "DAT_current_mode",
                "kinetis_mcg_disable_pll": "disable_pll",
                "PTR_current_mode_00001a5c": "PTR_current_mode"
            },
            "code": "void set_mode_to_5_and_disable_pll_00001a3c(void)\n{\n  set_bit_in_byte(DAT_00001a58, 1);\n  disable_pll();\n  *PTR_current_mode_00001a5c = 5;\n  return;\n}",
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a3c",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_mode_to_5_and_disable_pll_00001a3c"
        },
        "FUN_000045ee": {
            "renaming": {
                "FUN_000045ee": "reverse_copy_000045ee",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_bytes",
                "puVar1": "destination_ptr",
                "puVar2": "source_ptr"
            },
            "code": "void * reverse_copy_000045ee(void *destination, const void *source, size_t num_bytes) {\n  unsigned char *source_ptr = (unsigned char *)source + num_bytes;\n  if ((source < destination) && (destination < source_ptr)) {\n    unsigned char *destination_ptr = (unsigned char *)destination + num_bytes;\n    while (destination != destination_ptr) {\n      source_ptr--;\n      destination_ptr--;\n      *destination_ptr = *source_ptr;\n    }\n  }\n  else {\n    unsigned char *destination_ptr = (unsigned char *)destination - 1;\n    for (; source != source_ptr; source_ptr--) {\n      destination_ptr++;\n      *destination_ptr = *(unsigned char *)source;\n    }\n  }\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ee",
            "calling": [
                "fmt_lpad"
            ],
            "imported": false,
            "current_name": "reverse_copy_000045ee"
        },
        "FUN_00005404": {
            "renaming": {
                "FUN_00005404": "write_to_stream_00005404",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "stream_buffer",
                "param_4": "param_4",
                "iVar1": "buffer_index",
                "uVar2": "buffer_size",
                "puVar3": "buffer_pointer"
            },
            "code": "uint write_to_stream_00005404(int stream, uint character, int *stream_buffer, undefined4 param_4) {\n  int buffer_index;\n  uint buffer_size;\n  undefined *buffer_pointer;\n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_buffer == (int *)PTR___sf_fake_stdin_0000549c) {\n    stream_buffer = *(int **)(stream + 4);\n  }\n  else if (stream_buffer == (int *)PTR___sf_fake_stdout_000054a0) {\n    stream_buffer = *(int **)(stream + 8);\n  }\n  else if (stream_buffer == (int *)PTR___sf_fake_stderr_000054a4) {\n    stream_buffer = *(int **)(stream + 0xc);\n  }\n  stream_buffer[2] = stream_buffer[6];\n  buffer_size = (uint)*(ushort *)(stream_buffer + 3);\n  buffer_index = buffer_size << 0x1c;\n  if (((buffer_index < 0) && (buffer_size = stream_buffer[4], buffer_size != 0)) || (buffer_index = __swsetup_r(stream, stream_buffer, buffer_index, buffer_size, param_4), buffer_index == 0)) {\n    buffer_index = *stream_buffer - stream_buffer[4];\n    character = character & 0xff;\n    if ((buffer_index < stream_buffer[5]) || (buffer_index = _fflush_r(stream, stream_buffer), buffer_index == 0)) {\n      stream_buffer[2] = stream_buffer[2] + -1;\n      buffer_pointer = (undefined *)*stream_buffer;\n      *stream_buffer = (int)(buffer_pointer + 1);\n      *buffer_pointer = (char)character;\n      if (stream_buffer[5] != buffer_index + 1) {\n        if (-1 < (int)((uint)*(ushort *)(stream_buffer + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      buffer_index = _fflush_r(stream, stream_buffer);\n      if (buffer_index == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005404",
            "calling": [
                "_puts_r",
                "__sfputc_r",
                "_putc_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_00005404"
        },
        "FUN_00006974": {
            "renaming": {
                "FUN_00006974": "divide_00006974",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "unused",
                "iVar1": "quotient",
                "local_8": "local_array"
            },
            "code": "int divide_00006974(int divide_00006974nd, int divisor, int *remainder) {\n  int quotient;\n  if (divisor == 0) {\n    if (divide_00006974nd < 0) {\n      divide_00006974nd = 0;\n      divisor = -2147483648;\n    }\n    else if (divide_00006974nd != 0) {\n      divide_00006974nd = 2147483647;\n      divisor = -1;\n    }\n    quotient = __aeabi_idiv0(divide_00006974nd, divisor);\n    return quotient;\n  }\n  if (divide_00006974nd < 0) {\n    quotient = -divide_00006974nd - (int)(divisor != 0);\n    if (*remainder < 0) {\n      quotient = __udivmoddi4(-divide_00006974nd, quotient, -*remainder, -*remainder - (int)(-*remainder != 0), remainder);\n      return -quotient;\n    }\n    quotient = __udivmoddi4(-divide_00006974nd, quotient, *remainder, divisor, remainder);\n    return -quotient;\n  }\n  if (*remainder < 0) {\n    quotient = __udivmoddi4(divide_00006974nd, divisor, -*remainder, -*remainder - (int)(-*remainder != 0), remainder);\n    return -quotient;\n  }\n  quotient = __udivmoddi4(divide_00006974nd, divisor, *remainder);\n  return quotient;\n}",
            "called": [
                "__udivmoddi4",
                "__aeabi_idiv0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006974",
            "calling": [
                "gmtime_r"
            ],
            "imported": false,
            "current_name": "divide_00006974"
        },
        "FUN_00004314": {
            "renaming": {
                "FUN_00004314": "find_free_slot_00004314",
                "param_1": "error_code_ptr",
                "piVar1": "free_slot_ptr",
                "piVar2": "current_slot_ptr",
                "iVar3": "global_impure_ptr_val",
                "ppiVar4": "slot_list_ptr_ptr"
            },
            "code": "int *find_free_slot_00004314(undefined4 *error_code_ptr)\n{\n  int *free_slot_ptr;\n  int *current_slot_ptr;\n  int global_impure_ptr_val;\n  int **slot_list_ptr_ptr;\n  acquire_lock();\n  global_impure_ptr_val = *(int *)global_impure_ptr;\n  if (*(int *)(global_impure_ptr_val + 0x18) == 0) {\n    __sinit(global_impure_ptr_val);\n  }\n  slot_list_ptr_ptr = (int **)(global_impure_ptr_val + 0x48);\n  do {\n    free_slot_ptr = slot_list_ptr_ptr[1];\n    current_slot_ptr = slot_list_ptr_ptr[2];\n    while (free_slot_ptr = (int *)((int)free_slot_ptr + -1), -1 < (int)free_slot_ptr) {\n      if (*(short *)(current_slot_ptr + 3) == 0) {\n        current_slot_ptr[3] = DEFAULT_VALUE;\n        current_slot_ptr[0x19] = 0;\n        __retarget_lock_init_recursive(current_slot_ptr + 0x16);\n        release_lock();\n        current_slot_ptr[1] = 0;\n        current_slot_ptr[2] = 0;\n        current_slot_ptr[4] = 0;\n        current_slot_ptr[5] = 0;\n        *current_slot_ptr = 0;\n        current_slot_ptr[6] = 0;\n        memset(current_slot_ptr + 0x17,0,8);\n        current_slot_ptr[0xd] = 0;\n        current_slot_ptr[0xe] = 0;\n        current_slot_ptr[0x12] = 0;\n        current_slot_ptr[0x13] = 0;\n        return current_slot_ptr;\n      }\n      current_slot_ptr = current_slot_ptr + 0x1a;\n    }\n    if (*slot_list_ptr_ptr == (int *)0x0) {\n      free_slot_ptr = (int *)__sfmoreglue(error_code_ptr,4);\n      *slot_list_ptr_ptr = free_slot_ptr;\n      if (free_slot_ptr == (int *)0x0) {\n        release_lock();\n        *error_code_ptr = 0xc;\n        return (int *)0x0;\n      }\n    }\n    slot_list_ptr_ptr = (int **)*slot_list_ptr_ptr;\n  } while( true );\n}",
            "called": [
                "__sfmoreglue",
                "memset",
                "__sfp_lock_release",
                "__retarget_lock_init_recursive",
                "__sfp_lock_acquire",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004314",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "find_free_slot_00004314"
        },
        "FUN_00005fd4": {
            "renaming": {
                "FUN_00005fd4": "parse_string_to_uint32_00005fd4",
                "param_1": "out_value",
                "param_2": "input_string",
                "param_3": "end_pointer",
                "param_4": "base",
                "uVar1": "digit_value",
                "uVar2": "current_char_value",
                "bVar3": "is_hex",
                "iVar4": "parse_error",
                "uVar5": "digit_value",
                "uVar6": "max_value",
                "pbVar7": "current_char",
                "pbVar8": "next_char"
            },
            "code": "uint parse_string_to_uint32_00005fd4(undefined4 *out_value, byte *input_string, byte **end_pointer, uint base) {\n  uint digit_value;\n  uint max_value;\n  int sign = 1;\n  uint value = 0;\n  byte *current_char = input_string;\n  // Skip leading whitespace\n  while (isspace(*current_char)) {\n    current_char++;\n  }\n  // Handle sign\n  if (*current_char == '-') {\n    sign = -1;\n    current_char++;\n  }\n  else if (*current_char == '+') {\n    current_char++;\n  }\n  // Handle base\n  if (base == 0) {\n    if (*current_char == '0') {\n      base = 8;\n      current_char++;\n      if (toupper(*current_char) == 'X') {\n        base = 16;\n        current_char++;\n      }\n    }\n    else {\n      base = 10;\n    }\n  }\n  else if (base == 16 && *current_char == '0' && toupper(*(current_char + 1)) == 'X') {\n    current_char += 2;\n  }\n  // Parse digits\n  max_value = UINT32_MAX / base;\n  while (isalnum(*current_char)) {\n    if (isdigit(*current_char)) {\n      digit_value = *current_char - '0';\n    }\n    else {\n      digit_value = toupper(*current_char) - 'A' + 10;\n    }\n    if (digit_value >= base) {\n      break;\n    }\n    if (value > max_value) {\n      *out_value = 0;\n      if (end_pointer == NULL) {\n        return UINT32_MAX;\n      }\n      else {\n        *end_pointer = current_char;\n        return UINT32_MAX;\n      }\n    }\n    value = value * base + digit_value;\n    current_char++;\n  }\n  if (end_pointer != NULL) {\n    *end_pointer = current_char;\n  }\n  *out_value = sign * value;\n  return value;\n}",
            "called": [
                "_strtoul_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd4",
            "calling": [],
            "imported": false,
            "current_name": "parse_string_to_uint32_00005fd4"
        },
        "FUN_00004dc8": {
            "renaming": {
                "FUN_00004dc8": "read_file_00004dc8",
                "param_1": "reent",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "size",
                "_Var1": "bytes_read",
                "uVar2": "total_bytes_read",
                "bVar3": "read_successful"
            },
            "code": "void read_file_00004dc8(_reent *reent, int file_descriptor, void *buffer, size_t size) {\n  _ssize_t bytes_read;\n  uint32_t total_bytes_read;\n  bool read_successful;\n\n  bytes_read = _read_r(reent, (int)*(short *)(file_descriptor + 0xe), buffer, size);\n  read_successful = bytes_read >= 0;\n  if (read_successful) {\n    total_bytes_read = *(uint32_t *)(file_descriptor + 0x54) + bytes_read;\n  }\n  else {\n    total_bytes_read = *(uint16_t *)(file_descriptor + 0xc) & 0xffffefff;\n  }\n  if (read_successful) {\n    *(uint32_t *)(file_descriptor + 0x54) = total_bytes_read;\n  }\n  if (!read_successful) {\n    *(uint16_t *)(file_descriptor + 0xc) = (uint16_t)total_bytes_read;\n  }\n}",
            "called": [
                "_read_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dc8",
            "calling": [],
            "imported": false,
            "current_name": "read_file_00004dc8"
        },
        "FUN_00005fd8": {
            "renaming": {
                "FUN_00005fd8": "convert_string_to_ulong_00005fd8",
                "__nptr": "input_string",
                "__endptr": "end_pointer",
                "__base": "base",
                "uVar1": "result",
                "PTR__impure_ptr_00005fe8": "PTR__impure_ptr_00005fe8"
            },
            "code": "unsigned long convert_string_to_ulong_00005fd8(char* input_string, char** end_pointer, int base) {\n  unsigned long result = _convert_string_to_ulong_00005fd8_l_isra_0(*(undefined4*)PTR__impure_ptr_00005fe8, input_string, end_pointer, base);\n  return result;\n}",
            "called": [
                "_strtoul_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd8",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "convert_string_to_ulong_00005fd8"
        },
        "FUN_00005e10": {
            "renaming": {
                "FUN_00005e10": "read_next_byte_00005e10",
                "param_1": "file_descriptor",
                "param_2": "buffer",
                "iVar1": "refill_result",
                "uVar2": "next_byte",
                "pbVar3": "current_byte"
            },
            "code": "uint read_next_byte_00005e10(int file_descriptor, byte **buffer) {\n  int refill_result;\n  uint next_byte;\n  byte *current_byte;\n  \n  if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n    __sinit();\n  }\n  if (buffer == (byte **)original_stdin_ptr) {\n    buffer = *(byte ***)(file_descriptor + 4);\n  }\n  else if (buffer == (byte **)original_stdout_ptr) {\n    buffer = *(byte ***)(file_descriptor + 8);\n  }\n  else if (buffer == (byte **)original_stderr_ptr) {\n    buffer = *(byte ***)(file_descriptor + 0xc);\n  }\n  refill_result = __srefill_r(file_descriptor, buffer);\n  if (refill_result == 0) {\n    buffer[1] = buffer[1] + -1;\n    current_byte = *buffer;\n    *buffer = current_byte + 1;\n    next_byte = (uint)*current_byte;\n  }\n  else {\n    next_byte = 0xffffffff;\n  }\n  return next_byte;\n}",
            "called": [
                "__srefill_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e10",
            "calling": [
                "_getc_r"
            ],
            "imported": false,
            "current_name": "read_next_byte_00005e10"
        },
        "FUN_000033f4": {
            "renaming": {
                "FUN_000033f4": "set_alarm_if_valid_time_000033f4",
                "argv": "arguments",
                "iVar1": "result",
                "now": "time_to_set",
                "_parse_time": "parse_time",
                "rtc_set_alarm": "rtc_set_alarm",
                "DAT_0000343c": "alarm_data",
                "PTR_s_rtc__error_setting_alarm_00003440": "rtc_error_setting_alarm"
            },
            "code": "int set_alarm_if_valid_time_000033f4(char **arguments)\n{\n  int result;\n  tm time_to_set;\n  result = parse_time(arguments, &time_to_set);\n  if (result == 0) {\n    result = rtc_set_alarm(&time_to_set, DAT_0000343c, (void *)0x0);\n    if (result == -1) {\n      puts(PTR_s_rtc__error_setting_alarm_00003440);\n      result = 1;\n    }\n    else {\n      result = 0;\n    }\n  }\n  else {\n    result = 1;\n  }\n  return result;\n}",
            "called": [
                "_parse_time",
                "puts",
                "rtc_set_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033f4",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "set_alarm_if_valid_time_000033f4"
        },
        "FUN_0000443c": {
            "renaming": {
                "FUN_0000443c": "convert_time_to_tm_format_0000443c",
                "__timer": "time",
                "__tp": "tm_struct",
                "iVar1": "quotient",
                "uVar2": "days_since_sunday",
                "uVar3": "remainder_1",
                "uVar4": "leap_year_correction",
                "iVar5": "days_since_new_year",
                "uVar6": "century_correction",
                "uVar9": "days_since_1900",
                "tVar7": "seconds",
                "tVar8": "minutes",
                "DAT_0000458c": "SECONDS_IN_DAY",
                "DAT_00004590": "DAYS_IN_YEAR",
                "DAT_00004594": "YEARS_IN_CENTURY",
                "DAT_00004598": "DAYS_IN_400_YEARS",
                "PTR_DAT_000045a0": "DAYS_IN_MONTH_ARRAY"
            },
            "code": "tm* convert_time_to_tm_format_0000443c(time_t* time, tm* tm_struct) {\n  int quotient;\n  uint remainder_1;\n  uint remainder_2;\n  uint days_since_sunday;\n  int days_since_1900;\n  uint days_since_jan_1;\n  uint leap_year_correction;\n  uint century_correction;\n  uint quad_century_correction;\n  uint days_since_new_year;\n  uint days_in_month;\n  uint month;\n  uint year;\n  time_t seconds = *time;\n  time_t minutes = time[1];\n  quotient = __aeabi_ldivmod(seconds, minutes, PTR_DAT_0000458c, 0);\n  remainder_1 = PTR_DAT_0000458c;\n  __aeabi_ldivmod(seconds, minutes, PTR_DAT_0000458c, 0);\n  bool is_negative = (int)remainder_1 < 0;\n  if (is_negative) {\n    remainder_1 += 0x15180;\n  }\n  if (is_negative) {\n    days_since_sunday = quotient + 0xafa6b;\n  }\n  else {\n    days_since_sunday = quotient + 0xafa6c;\n  }\n  tm_struct->tm_hour = remainder_1 / 0xe10;\n  tm_struct->tm_min = (remainder_1 % 0xe10) / 0x3c;\n  tm_struct->tm_sec = (remainder_1 % 0xe10) % 0x3c;\n  tm_struct->tm_wday = (days_since_sunday + 3) % 7;\n  days_since_jan_1 = days_since_sunday;\n  if ((int)days_since_sunday < 0) {\n    days_since_jan_1 = days_since_sunday - 0x23ab0;\n  }\n  year = PTR_DAT_00004594 * (days_since_jan_1 / PTR_DAT_00004590) + days_since_sunday;\n  leap_year_correction = ((year / 0x8eac + year) - year / 0x5b4) - year / PTR_DAT_00004598;\n  century_correction = leap_year_correction / 0x16d;\n  year = (century_correction / 100 - leap_year_correction / 0x5b4) + year + century_correction * -0x16d;\n  days_since_new_year = leap_year_correction % 0x16d;\n  month = 0;\n  while (days_since_new_year >= 0) {\n    days_in_month = (PTR_DAT_000045a0 >> (month * 2)) & 0x3;\n    days_since_new_year -= days_in_month * 0x20;\n    month++;\n  }\n  month--;\n  days_since_new_year += days_in_month * 0x20;\n  tm_struct->tm_yday = days_since_new_year;\n  tm_struct->tm_mday = days_since_new_year - days_in_month * 0x20 + 1;\n  tm_struct->tm_mon = month;\n  days_since_1900 = year - 1900;\n  quad_century_correction = days_since_1900 / 0x76c;\n  days_since_1900 -= quad_century_correction * 0x76c;\n  if (days_since_1900 < 0) {\n    days_since_1900 += 365 + is_leap_year(1900 + quad_century_correction);\n    quad_century_correction--;\n  }\n  year = days_since_1900 / 100;\n  days_since_1900 -= year * 100;\n  if (days_since_1900 < 0) {\n    days_since_1900 += 365 + is_leap_year(1900 + quad_century_correction * 400 + year);\n    year--;\n  }\n  tm_struct->tm_year = 1900 + quad_century_correction * 400 + year;\n  tm_struct->tm_isdst = 0;\n  return tm_struct;\n}\n",
            "called": [
                "__aeabi_ldivmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000443c",
            "calling": [
                "rtc_get_alarm",
                "rtc_get_time"
            ],
            "imported": false,
            "current_name": "convert_time_to_tm_format_0000443c"
        },
        "FUN_000027b0": {
            "renaming": {
                "FUN_000027b0": "initialize_rtc_000027b0",
                "puVar1": "rtc_data_ptr",
                "rtt": "rtc_module",
                "DAT_00002814": "RTC_DATA",
                "DAT_00002818": "RTC_BASE_ADDRESS",
                "RTC_CTRL_OFFSET": "RTC_CTRL_OFFSET",
                "RTC_CTRL_EN_MASK": "RTC_CTRL_EN_MASK",
                "RTC_FREQ_1024HZ": "RTC_FREQ_1024HZ",
                "RTC_ALARM_VALUE": "RTC_ALARM_VALUE"
            },
            "code": "void initialize_rtc_000027b0(void)\n{\n  uint32_t *rtc_data_ptr;\n  RTC_Type *rtc_module;\n  rtc_data_ptr = DAT_00002814;\n  *(uint32_t *)(DAT_00002818 + RTC_CTRL_OFFSET) |= RTC_CTRL_EN_MASK;\n  rtc_data_ptr[4] = 1;\n  rtc_data_ptr[4] = 0;\n  if ((rtc_data_ptr[5] & 1) != 0) {\n    *rtc_data_ptr = 0;\n  }\n  rtc_data_ptr[4] = RTC_FREQ_1024HZ;\n  rtc_data_ptr[2] = RTC_ALARM_VALUE;\n  rtc_data_ptr[7] = 0;\n  rtc_module = RTC;\n  rtc_module->MODE2.CTRL.reg = RTC_MODE2_CTRL_ENABLE;\n  return;\n}",
            "called": [
                "rtt_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000027b0",
            "calling": [
                "rtc_init"
            ],
            "imported": false,
            "current_name": "initialize_rtc_000027b0"
        },
        "FUN_00005ebc": {
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "current_char",
                "pcVar2": "destination_ptr"
            },
            "code": "char* copy_string_00005ebc(char* destination, char* source)\n{\n  char current_char;\n  char* destination_ptr = destination;\n  do {\n    current_char = *source;\n    *destination_ptr = current_char;\n    source++;\n    destination_ptr++;\n  } while (current_char != '\\0');\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ebc",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "copy_string_00005ebc"
        },
        "FUN_00006192": {
            "renaming": {
                "FUN_00006192": "cleanUpMemory_00006192",
                "param_1": "param1",
                "param_2": "memoryBlock",
                "PTR_": "",
                "DAT_": "",
                "undefined4": "unsigned int",
                "ushort": "unsigned short",
                "ptr1": "ptr1",
                "memoryBlock[0xd]": "ptr1",
                "memoryBlock[0x10]": "memoryBlock[16]",
                "memoryBlock[0xf]": "memoryBlock[15]",
                "*memoryBlock": "memoryBlock[0]",
                "0x0": "NULL",
                "0xffffffff": "0xFFFFFFFF"
            },
            "code": "unsigned int cleanUpMemory_00006192(unsigned int param1, unsigned int *memoryBlock)\n{\n    unsigned int *ptr1 = (unsigned int *)memoryBlock[13];\n    if (ptr1 != NULL)\n    {\n        if (ptr1 != memoryBlock + 17)\n        {\n            free(ptr1);\n        }\n        memoryBlock[1] = memoryBlock[16];\n        memoryBlock[13] = 0;\n        if (memoryBlock[16] != 0)\n        {\n            *memoryBlock = memoryBlock[15];\n            return 0;\n        }\n    }\n    *memoryBlock = memoryBlock[4];\n    memoryBlock[1] = 0;\n    *(unsigned short *)(memoryBlock + 3) = *(unsigned short *)(memoryBlock + 3) | 0x20;\n    return 0xFFFFFFFF;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006192",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "cleanUpMemory_00006192"
        },
        "FUN_00001734": {
            "renaming": {
                "FUN_00001734": "clear_bit_in_byte_00001734",
                "DAT_00001744": "byte",
                "'\\x06'": "bit_position"
            },
            "code": "void clear_bit_in_byte_00001734(DAT_00001744_t *DAT_00001744, uint8_t bit_position) {\n    bit_clear8(DAT_00001744, bit_position);\n    return;\n}",
            "called": [
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001734",
            "calling": [
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi"
            ],
            "imported": false,
            "current_name": "clear_bit_in_byte_00001734"
        },
        "FUN_00000e14": {
            "renaming": {
                "FUN_00000e14": "read_isrpipe_00000e14",
                "buffer": "buffer",
                "count": "count",
                "iVar1": "read_count"
            },
            "code": "int read_isrpipe_00000e14(char *buffer, int count)\n{\n  int read_count = isrpipe_read((isrpipe_t *)PTR_uart_stdio_isrpipe_00000e34, buffer, count);\n  return read_count;\n}",
            "called": [
                "isrpipe_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e14",
            "calling": [
                "_read_r"
            ],
            "imported": false,
            "current_name": "read_isrpipe_00000e14"
        },
        "FUN_0000281c": {
            "renaming": {
                "FUN_0000281c": "read_RTC_value_0000281c",
                "rtt": "rtc",
                "i": "loop_counter",
                "t": "RTC_value"
            },
            "code": "uint32_t read_RTC_value_0000281c(void)\n{\n  RTC_Type *rtc;\n  int i = 0;\n  uint32_t RTC_value;\n  while ((i < 3 && (RTC_value = *DAT_00002858, RTC_value != *DAT_00002858))) {\n    i = i + 1;\n  }\n  return RTC_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000281c",
            "calling": [
                "rtc_get_time"
            ],
            "imported": false,
            "current_name": "read_RTC_value_0000281c"
        },
        "FUN_00002270": {
            "renaming": {
                "FUN_00002270": "is_rb_empty_00002270",
                "rb": "ring_buffer",
                "uVar2": "writes",
                "bVar3": "is_full",
                "bVar1": "is_empty"
            },
            "code": "uint8_t is_rb_empty_00002270(tsrb_t *ring_buffer)\n{\n  uint32_t writes = ring_buffer->writes;\n  bool is_full = (ring_buffer->reads == writes);\n  if (is_full) {\n    writes = 1;\n  }\n  uint8_t is_empty = (uint8_t)writes;\n  if (!is_full) {\n    is_empty = 0;\n  }\n  return is_empty;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002270",
            "calling": [
                "tsrb_get"
            ],
            "imported": false,
            "current_name": "is_rb_empty_00002270"
        },
        "FUN_00005780": {
            "renaming": {
                "FUN_00005780": "process_data_00005780",
                "__ptr": "__data_ptr",
                "_FUN_00005780_r": "_recursive_process_data"
            },
            "code": "void process_data_00005780(void *__data_ptr) {\n  _recursive_process_data_00005780(*(undefined4 *)PTR__impure_ptr_0000578c, __data_ptr);\n  return;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005780",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "process_data_00005780"
        },
        "FUN_000020cc": {
            "renaming": {
                "FUN_000020cc": "handle_irq_000020cc",
                "DAT_000020dc": "data"
            },
            "code": "void handle_irq_000020cc(void)\n{\n  irq_handler(DAT_000020dc, 1);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020cc",
            "calling": [],
            "imported": false,
            "current_name": "handle_irq_000020cc"
        },
        "FUN_00002396": {
            "renaming": {
                "FUN_00002396": "initialize_rtc_00002396",
                "rtc_init": "rtc_initialize"
            },
            "code": "void initialize_rtc_00002396(void)\n{\n    rtc_init();\n    return;\n}",
            "called": [
                "rtc_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002396",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initialize_rtc_00002396"
        },
        "FUN_00004e4a": {
            "renaming": {
                "FUN_00004e4a": "close_file_00004e4a",
                "param_1": "reent",
                "param_2": "file_descriptor"
            },
            "code": "void close_file_00004e4a(_reent *reent,int file_descriptor){\n  _close_r(reent, (int)*(short *)(file_descriptor + 0xe));\n  return;\n}",
            "called": [
                "_close_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e4a",
            "calling": [],
            "imported": false,
            "current_name": "close_file_00004e4a"
        },
        "FUN_00004cb4": {
            "renaming": {
                "FUN_00004cb4": "output_char_00004cb4",
                "__c": "character",
                "in_r3": "register_value",
                "iVar1": "impure_pointer_value",
                "_putc_r": "output_result"
            },
            "code": "int output_char_00004cb4(int character) {\n  undefined4 register_value;\n  int impure_pointer_value = *(int *)PTR__impure_ptr_00004cd8;\n  if ((impure_pointer_value != 0) && (*(int *)(impure_pointer_value + 0x18) == 0)) {\n    __sinit(impure_pointer_value);\n  }\n  int output_result = _putc_r(impure_pointer_value, character, *(undefined4 *)(impure_pointer_value + 8), register_value);\n  return output_result;\n}",
            "called": [
                "_putc_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cb4",
            "calling": [
                "_putchar"
            ],
            "imported": false,
            "current_name": "output_char_00004cb4"
        },
        "FUN_00003478": {
            "renaming": {
                "FUN_00003478": "set_time_if_valid_00003478",
                "argv": "arguments",
                "iVar1": "is_valid_time",
                "now": "current_time",
                "_parse_time": "parse_time",
                "rtc_set_time": "rtc_set_time",
                "PTR_s_rtc__error_setting_time_000034bc": "PTR_s_rtc__error_setting_time_000034bc"
            },
            "code": "int set_time_if_valid_00003478(char **arguments)\n{\n    int is_valid_time;\n    tm current_time;\n    is_valid_time = parse_time(arguments, &current_time);\n    if (is_valid_time == 0)\n    {\n        int time_set_result = rtc_set_time(&current_time);\n        if (time_set_result == -1)\n        {\n            puts(PTR_s_rtc__error_setting_time_000034bc);\n            is_valid_time = 1;\n        }\n        else\n        {\n            is_valid_time = 0;\n        }\n    }\n    else\n    {\n        is_valid_time = 1;\n    }\n    return is_valid_time;\n}",
            "called": [
                "rtc_set_time",
                "_parse_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003478",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "set_time_if_valid_00003478"
        },
        "FUN_00002028": {
            "renaming": {
                "FUN_00002028": "handle_port_interrupt_00002028",
                "port_num": "port_number",
                "uVar2": "interrupt_flags",
                "ctx": "isr_index",
                "status": "N/A",
                "i": "i",
                "PTR_isr_ctx_000020b4": "isr_ctx_ptr",
                "get_ctx": "get_isr_index",
                "DAT_00000000": "N/A"
            },
            "code": "void handle_port_interrupt_00002028(PORT_Type *port,int port_number) {\n  int isr_index;\n  uint32_t interrupt_flags;\n  int i;\n  \n  interrupt_flags = port->ISFR;\n  for (i = 0; i < 0x20; i++) {\n    if (((interrupt_flags & (1 << (i & 0xffU))) != 0) && ((port->PCR[i] & 0xf0000) != 0)) {\n      port->ISFR = (1 << (i & 0xffU));\n      isr_index = get_isr_index(port_number,i);\n      (**(code **)(PTR_isr_ctx_000020b4 + isr_index * 0xc))\n                (*(undefined4 *)(PTR_isr_ctx_000020b4 + isr_index * 0xc + 4));\n    }\n  }\n  end_interrupt();\n  return;\n}",
            "called": [
                "cortexm_isr_end",
                "get_ctx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002028",
            "calling": [
                "isr_porte",
                "isr_portd",
                "isr_portb",
                "isr_portc",
                "isr_porta"
            ],
            "imported": false,
            "current_name": "handle_port_interrupt_00002028"
        },
        "FUN_000016c8": {
            "renaming": {
                "FUN_000016c8": "set_bit_at_position_000016c8",
                "ptr": "memory_address",
                "bit": "bit_position",
                "puVar1": "bit_address"
            },
            "code": "void set_bit_at_position_000016c8(uint32_t *memory_address, uint8_t bit_position)\n{\n  undefined4 *bit_address = (undefined4 *)bitband_addr(memory_address, (uint)bit_position);\n  *bit_address = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016c8",
            "calling": [
                "kinetis_mcg_init_erclk32k"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_000016c8"
        },
        "FUN_00001a60": {
            "renaming": {
                "FUN_00001a60": "check_mode_transition_00001a60",
                "bit_clear8": "clear_bit",
                "bit_set8": "set_bit"
            },
            "code": "void check_mode_transition_00001a60(void)\n{\n  clear_bit(DAT_00001ac4, 0x01);\n  *DAT_00001ac8 = (*DAT_00001ac8 & 0x3f) | 0x80;\n  while ((DAT_00001ac8[6] & 0xc) != 8);\n  set_bit(DAT_00001acc, 0x06);\n  while ((DAT_00001ac8[6] & 0x20) == 0);\n  while ((DAT_00001ac8[6] & 0x40) == 0);\n  *PTR_current_mode_00001ad0 = 6;\n  return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a60",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "check_mode_transition_00001a60"
        },
        "FUN_000004b2": {
            "renaming": {
                "FUN_000004b2": "write_uart_000004b2",
                "r": "reenter",
                "fd": "file_descriptor",
                "data": "data_buffer",
                "count": "buffer_size",
                "iVar1": "write_count"
            },
            "code": "_ssize_t write_uart_000004b2(_reent *reenter, int file_descriptor, void *data_buffer, size_t buffer_size) {\n  int write_count = uart_stdio_write((char *)data_buffer, buffer_size);\n  return write_count;\n}",
            "called": [
                "uart_stdio_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004b2",
            "calling": [
                "__swrite"
            ],
            "imported": false,
            "current_name": "write_uart_000004b2"
        },
        "FUN_0000099c": {
            "renaming": {
                "FUN_0000099c": "initialize_kernel_0000099c",
                "uStack_18": "top_of_stack",
                "top": "stack_top",
                "src": "src_ptr",
                "dst": "dst_ptr"
            },
            "code": "void initialize_kernel_0000099c(void) {\n  uint32_t top_of_stack;\n  uint32_t *stack_top;\n  uint32_t *src_ptr;\n  uint32_t *dst_ptr;\n  stack_top = &top_of_stack;\n  src_ptr = (uint32_t *)PTR__etext_00000a14;\n  pre_startup();\n  dst_ptr = (uint32_t *)PTR_isr_stack_00000a18;\n  while (dst_ptr < &top_of_stack) {\n    *dst_ptr = DAT_00000a1c;\n    dst_ptr++;\n  }\n  dst_ptr = (uint32_t *)PTR_heap_top_00000a20;\n  while (dst_ptr < PTR_sched_num_threads_00000a24) {\n    *dst_ptr = *src_ptr;\n    src_ptr++;\n    dst_ptr++;\n  }\n  dst_ptr = (uint32_t *)PTR_sched_num_threads_00000a28;\n  while (dst_ptr < PTR__sheap_00000a2c) {\n    *dst_ptr = 0;\n    dst_ptr++;\n  }\n  post_startup();\n  board_init();\n  __libc_init_array();\n  kernel_init();\n  return;\n}",
            "called": [
                "pre_startup",
                "board_init",
                "post_startup",
                "kernel_init",
                "__libc_init_array"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000099c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_kernel_0000099c"
        },
        "FUN_00002d94": {
            "renaming": {
                "FUN_00002d94": "read_line_00002d94",
                "buf": "buffer",
                "size": "buffer_size",
                "c_00": "character",
                "bVar1": "byte_value",
                "bVar2": "is_buffer_empty",
                "c": "buffer_index",
                "line_buf_ptr": "current_char_ptr"
            },
            "code": "int read_line_00002d94(char *buffer, size_t buffer_size)\n{\n    int character;\n    byte byte_value;\n    bool is_buffer_empty;\n    int buffer_index;\n    char *current_char_ptr;\n\n    current_char_ptr = buffer;\n    while (true)\n    {\n        if ((int)(buffer_size - 1) <= (int)current_char_ptr - (int)buffer)\n        {\n            return -1;\n        }\n        character = getchar();\n        if (character < 0)\n        {\n            break;\n        }\n        if ((character == 0xd) || (character == 10))\n        {\n            *current_char_ptr = '\\0';\n            _putchar(0xd);\n            _putchar(10);\n            is_buffer_empty = current_char_ptr == buffer;\n            if (is_buffer_empty)\n            {\n                buffer = (char *)0x1;\n            }\n            byte_value = (byte)buffer;\n            if (!is_buffer_empty)\n            {\n                byte_value = 0;\n            }\n            return (uint)byte_value;\n        }\n        if ((character == 8) || (character == 0x7f))\n        {\n            if (current_char_ptr != buffer)\n            {\n                current_char_ptr = current_char_ptr - 1;\n                *current_char_ptr = '\\0';\n                _putchar(8);\n                _putchar(0x20);\n                _putchar(8);\n            }\n        }\n        else\n        {\n            *current_char_ptr = (char)character;\n            _putchar(character);\n            current_char_ptr = current_char_ptr + 1;\n        }\n    }\n    return 1;\n}",
            "called": [
                "getchar",
                "_putchar"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002d94",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "read_line_00002d94"
        },
        "FUN_00003918": {
            "renaming": {
                "FUN_00003918": "get_prefix_from_scale_00003918",
                "scale": "scale",
                "cVar1": "prefix"
            },
            "code": "char get_prefix_from_scale_00003918(int8_t scale)\n{\n  char prefix;\n  switch(scale) {\n    case 2:\n      prefix = 'h';\n      break;\n    case 3:\n      prefix = 'k';\n      break;\n    case 6:\n      prefix = 'M';\n      break;\n    case 9:\n      prefix = 'G';\n      break;\n    case 12:\n      prefix = 'T';\n      break;\n    case 15:\n      prefix = 'P';\n      break;\n    case -15:\n      prefix = 'f';\n      break;\n    case -12:\n      prefix = 'p';\n      break;\n    case -9:\n      prefix = 'n';\n      break;\n    case -6:\n      prefix = 'u';\n      break;\n    case -3:\n      prefix = 'm';\n      break;\n    default:\n      prefix = '\\0';\n      break;\n  }\n  return prefix;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003918",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "get_prefix_from_scale_00003918"
        },
        "FUN_00003d64": {
            "renaming": {
                "FUN_00003d64": "read_sensor_data_00003d64",
                "dev": "sensor",
                "res": "data",
                "iVar1": "result"
            },
            "code": "int read_sensor_data_00003d64(saul_reg_t *sensor, phydat_t *data){\n  int result;\n  if (sensor == NULL) {\n    result = -19;\n  }\n  else {\n    result = (*sensor->driver->read)(sensor->dev, data);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d64",
            "calling": [
                "probe"
            ],
            "imported": false,
            "current_name": "read_sensor_data_00003d64"
        },
        "FUN_00004e52": {
            "renaming": {
                "FUN_00004e52": "compare_strings_00004e52",
                "__s1": "string1",
                "__s2": "string2",
                "bVar1": "current_char_string2",
                "uVar2": "current_char_string1",
                "bVar3": "strings_match"
            },
            "code": "int compare_strings_00004e52(char *string1, char *string2) {\n  byte current_char_string1;\n  uint current_char_string2;\n  bool strings_match = false;\n  do {\n    current_char_string1 = (byte)*string1;\n    current_char_string2 = *string2;\n    if (current_char_string1 != 0) {\n      strings_match = current_char_string1 == current_char_string2;\n    }\n    string1++;\n    string2++;\n  } while (strings_match);\n  return current_char_string1 - current_char_string2;\n}",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e52",
            "calling": [
                "_tzset_unlocked_r",
                "read",
                "find_handler",
                "strcmp",
                "_saul",
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e52"
        },
        "FUN_000010d4": {
            "renaming": {
                "FUN_000010d4": "create_thread_000010d4",
                "stacksize": "stack_size",
                "local_30": "aligned_stack_size",
                "local_2c": "stack_ptr",
                "process": "thread",
                "state_00": "state",
                "stackmax": "stack_top",
                "cb": "unused",
                "total_stacksize": "total_stack_size",
                "stackp": "stack_bottom",
                "i": "pid"
            },
            "code": "kernel_pid_t create_thread_000010d4(char *stack, int stack_size, char priority, int flags, thread_task_func_t function, void *arg, char *name) {\n    uint state;\n    char *stack_ptr;\n    uint aligned_stack_size;\n    thread_t *thread;\n    uintptr_t *stack_bottom;\n    uintptr_t *stack_top;\n    uintptr_t misalignment;\n    int total_stack_size;\n    kernel_pid_t pid = -ENOMEM;\n\n    if ((byte)priority >= 0x10) {\n        return pid;\n    }\n\n    aligned_stack_size = (stack_size - 0x30U) & 0xfffffffc;\n    stack_ptr = stack + (4 - ((uint)stack & 3));\n    total_stack_size = aligned_stack_size + (stack_ptr - stack);\n    thread = (thread_t *)(stack_ptr + aligned_stack_size);\n\n    if ((flags & THREAD_CREATE_STACKTEST) == 0) {\n        *stack_ptr = (uintptr_t)stack_ptr;\n    } else {\n        stack_bottom = (uintptr_t *)stack_ptr;\n        stack_top = (uintptr_t *)(stack_ptr + aligned_stack_size);\n        while (stack_bottom < stack_top) {\n            *stack_bottom++ = (uintptr_t)stack_bottom;\n        }\n    }\n\n    state = irq_disable();\n    pid = sched_find_free_pid();\n\n    if (pid >= 0) {\n        sched_threads[pid] = thread;\n        thread->pid = pid;\n        thread->sp = thread_stack_init(function, arg, stack_ptr, aligned_stack_size);\n        thread->stack_start = stack_ptr;\n        thread->stack_size = total_stack_size;\n        thread->name = name;\n        thread->priority = priority;\n        thread->status = THREAD_STATUS_PENDING;\n        thread->wait_data = NULL;\n        cib_init(&thread->msg_queue, 0);\n        thread->msg_array = NULL;\n        sched_num_threads++;\n\n        if ((flags & THREAD_CREATE_SUSPENDED) == 0) {\n            sched_set_status(thread, THREAD_STATUS_PENDING);\n            if ((flags & THREAD_CREATE_WOUT_YIELD) == 0) {\n                irq_restore(state);\n                sched_switch((ushort)(byte)priority);\n            } else {\n                irq_restore(state);\n            }\n        } else {\n            sched_set_status(thread, THREAD_STATUS_SUSPENDED);\n            irq_restore(state);\n        }\n    } else {\n        irq_restore(state);\n    }\n\n    return pid;\n}",
            "called": [
                "irq_disable",
                "thread_stack_init",
                "cib_init",
                "irq_restore",
                "sched_set_status",
                "sched_switch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010d4",
            "calling": [
                "kernel_init"
            ],
            "imported": false,
            "current_name": "create_thread_000010d4"
        },
        "FUN_000045e4": {
            "renaming": {
                "FUN_000045e4": "do_nothing_000045e4"
            },
            "code": "\nvoid do_nothing_000045e4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e4",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e4"
        },
        "FUN_00000738": {
            "renaming": {
                "FUN_00000738": "check_thread_priority_00000738",
                "other_prio": "new_priority",
                "iVar1": "irq_state",
                "current_prio": "current_priority",
                "active_thread": "active_thread",
                "on_runqueue": "is_on_runqueue"
            },
            "code": "void check_thread_priority_00000738(uint16_t new_priority)\n{\n  int irq_state;\n  uint16_t current_priority;\n  thread_t *active_thread;\n  int is_on_runqueue;\n  \n  active_thread = *(thread_t **)PTR_sched_active_thread_0000078c;\n  current_priority = *(byte *)(active_thread + 4);\n  is_on_runqueue = current_priority < 9;\n  \n  if (is_on_runqueue || new_priority < *(byte *)(active_thread + 5)) {\n    irq_state = irq_is_in();\n    if (irq_state == 0) {\n      thread_yield_higher();\n    }\n    else {\n      *(undefined4 *)PTR_sched_context_switch_request_00000790 = 1;\n    }\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher",
                "irq_is_in"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000738",
            "calling": [
                "thread_create",
                "mutex_unlock"
            ],
            "imported": false,
            "current_name": "check_thread_priority_00000738"
        },
        "FUN_000045e6": {
            "renaming": {
                "FUN_000045e6": "do_nothing_000045e6"
            },
            "code": "\nvoid do_nothing_000045e6(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e6",
            "calling": [
                "__tz_lock"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e6"
        },
        "FUN_00003e58": {
            "renaming": {
                "FUN_00003e58": "convert_integer_to_string_00003e58",
                "out": "output_string",
                "val": "input_integer",
                "local_18": "absolute_integer",
                "local_14": "current_position",
                "negative": "is_negative"
            },
            "code": "size_t convert_integer_to_string_00003e58(char *output_string, int32_t input_integer) {\n  size_t string_length;\n  uint32_t absolute_integer;\n  char *current_position;\n  uint32_t is_negative;\n  \n  absolute_integer = input_integer;\n  current_position = output_string;\n  if (-(input_integer >> 0x1f) != 0) {\n    if (output_string != (char *)0x0) {\n      current_position = output_string + 1;\n      *output_string = '-';\n    }\n    absolute_integer = -input_integer;\n  }\n  string_length = fmt_u32_dec(current_position, absolute_integer);\n  return -(input_integer >> 0x1f) + string_length;\n}",
            "called": [
                "fmt_u32_dec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e58",
            "calling": [
                "fmt_s32_dfp"
            ],
            "imported": false,
            "current_name": "convert_integer_to_string_00003e58"
        },
        "FUN_00004e26": {
            "renaming": {
                "FUN_00004e26": "seek_file_00004e26",
                "param_1": "reent_ptr",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "position",
                "uVar2": "flags",
                "bVar3": "error"
            },
            "code": "void seek_file_00004e26(_reent *reent_ptr, int file_descriptor, _off_t offset, int whence) {\n  _off_t position;\n  ushort flags;\n  bool error;\n  position = _lseek_r(reent_ptr, (int)*(short *)(file_descriptor + 0xe), offset, whence);\n  error = position == -1;\n  if (error) {\n    flags = *(ushort *)(file_descriptor + 0xc) & 0xefff;\n  }\n  else {\n    *(_off_t *)(file_descriptor + 0x54) = position;\n    flags = *(ushort *)(file_descriptor + 0xc) | 0x1000;\n  }\n  if (error) {\n    *(ushort *)(file_descriptor + 0xc) = flags;\n  }\n  if (!error) {\n    *(ushort *)(file_descriptor + 0xc) = flags;\n  }\n  return;\n}",
            "called": [
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e26",
            "calling": [],
            "imported": false,
            "current_name": "seek_file_00004e26"
        },
        "FUN_00000978": {
            "renaming": {
                "FUN_00000978": "run_active_thread_00000978",
                "PTR_sched_active_thread_0000098c": "active_thread_ptr",
                "UNRECOVERED_JUMPTABLE": "jump_table",
                "ppcVar2": "process_stack_pointer",
                "bVar1": "is_privileged_mode"
            },
            "code": "void run_active_thread_00000978(void)\n{\n  bool is_privileged_mode;\n  code *jump_table;\n  code **process_stack_pointer;\n  jump_table = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  process_stack_pointer = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    setProcessStackPointer(process_stack_pointer);\n  }\n  (*jump_table)(jump_table,process_stack_pointer);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000978",
            "calling": [],
            "imported": false,
            "current_name": "run_active_thread_00000978"
        },
        "FUN_000045e8": {
            "renaming": {
                "FUN_000045e8": "do_nothing_000045e8"
            },
            "code": "\nvoid do_nothing_000045e8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e8",
            "calling": [
                "_puts_r",
                "__sinit_lock_acquire",
                "_fflush_r",
                "_vfprintf_r",
                "__sfp_lock_acquire",
                "_putc_r",
                "__malloc_lock",
                "__env_lock",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e8"
        },
        "FUN_000057f8": {
            "renaming": {
                "FUN_000057f8": "print_formatted_string_000057f8",
                "param_1": "stream",
                "param_2": "format_string",
                "param_3": "arguments",
                "param_4": "arg_types",
                "bVar1": "found_digit",
                "puVar2": "hex_chars",
                "puVar3": "length_modifiers",
                "iVar4": "num_chars_written",
                "iVar5": "result",
                "pvVar6": "found_char",
                "piVar7": "next_arg",
                "pbVar8": "current_char",
                "unaff_r7": "stream_copy",
                "pbVar9": "next_char",
                "local_8c": "arg_values",
                "local_88": "flags",
                "local_84": "precision",
                "uStack_80": "width",
                "local_7c": "int_arg",
                "local_74": "total_chars_written",
                "local_70": "specifier",
                "local_6f": "space_char",
                "local_6e": "plus_char",
                "local_45": "sign_char",
                "local_30": "zero_char"
            },
            "code": "\nint print_formatted_string_000057f8(int stream,undefined *format_string,byte *arguments,int *arg_types)\n\n{\n  bool found_digit;\n  undefined *hex_chars;\n  undefined *length_modifiers;\n  int num_chars_written;\n  int result;\n  void *found_char;\n  int *next_arg;\n  byte *current_char;\n  int stream_copy;\n  byte *next_char;\n  int *arg_values;\n  uint flags;\n  int precision;\n  undefined4 width;\n  int int_arg;\n  int total_chars_written;\n  byte specifier;\n  undefined space_char;\n  undefined plus_char;\n  undefined sign_char;\n  undefined4 zero_char;\n  \n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (format_string == PTR___sf_fake_stdin_00005a38) {\n    format_string = *(undefined **)(stream + 4);\n  }\n  else if (format_string == PTR___sf_fake_stdout_00005a3c) {\n    format_string = *(undefined **)(stream + 8);\n  }\n  else if (format_string == PTR___sf_fake_stderr_00005a40) {\n    format_string = *(undefined **)(stream + 0xc);\n  }\n  if ((-1 < *(int *)(format_string + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(format_string + 0xc) << 0x16))) {\n    __retarget_lock_acquire_recursive(*(undefined4 *)(format_string + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(format_string + 0xc) << 0x1c)) || (*(int *)(format_string + 0x10) == 0)) &&\n     (num_chars_written = __swsetup_r(stream,format_string), num_chars_written != 0)) {\n    if ((-1 < *(int *)(format_string + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(format_string + 0xc) << 0x16))) {\n      __retarget_lock_release_recursive(*(undefined4 *)(format_string + 0x58));\n    }\n    return -1;\n  }\n  hex_chars = PTR_s___0__00005a44;\n  total_chars_written = 0;\n  space_char = 0x20;\n  plus_char = 0x30;\n  next_char = arguments;\n  arg_values = arg_types;\nLAB_0000588e:\n  current_char = next_char;\n  if (*current_char != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  next_char = current_char + 1;\n  if (*current_char != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  num_chars_written = (int)current_char - (int)arguments;\n  if (num_chars_written != 0) {\n    result = __sfputs_r(stream,format_string,arguments,num_chars_written);\n    if (result == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(format_string + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(format_string + 0xc) << 0x16))) {\n        __retarget_lock_release_recursive(*(undefined4 *)(format_string + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(format_string + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return total_chars_written;\n    }\n    total_chars_written = total_chars_written + num_chars_written;\n  }\n  if (*current_char == 0) goto LAB_00005a06;\n  precision = -1;\n  width = 0;\n  flags = 0;\n  int_arg = 0;\n  sign_char = 0;\n  zero_char = 0;\n  next_char = current_char + 1;\n  while( true ) {\n    current_char = next_char + 1;\n    found_char = memchr(PTR_s___0__00005a44,(uint)*next_char,5);\n    length_modifiers = PTR_DAT_00005a54;\n    if (found_char == (void *)0x0) break;\n    flags = 1 << ((int)found_char - (int)hex_chars & 0xffU) | flags;\n    next_char = current_char;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    sign_char = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    sign_char = 0x2b;\n  }\n  if (*next_char == 0x2a) {\n    next_arg = arg_values + 1;\n    int_arg = *arg_values;\n    arg_values = next_arg;\n    if (int_arg < 0) {\n      int_arg = -int_arg;\n      flags = flags | 2;\n    }\n  }\n  else {\n    found_digit = false;\n    num_chars_written = int_arg;\n    current_char = next_char;\n    while( true ) {\n      if (9 < *current_char - 0x30) break;\n      num_chars_written = num_chars_written * 10 + (*current_char - 0x30);\n      found_digit = true;\n      current_char = current_char + 1;\n    }\n    if (found_digit) {\n      int_arg = num_chars_written;\n    }\n  }\n  if (*current_char == 0x2e) {\n    if (current_char[1] == 0x2a) {\n      precision = *arg_values;\n      if (precision < 0) {\n        precision = -1;\n      }\n      current_char = current_char + 2;\n      arg_values = arg_values + 1;\n    }\n    else {\n      found_digit = false;\n      precision = 0;\n      num_chars_written = 0;\n      while( true ) {\n        current_char = current_char + 1;\n        if (9 < *current_char - 0x30) break;\n        num_chars_written = num_chars_written * 10 + (*current_char - 0x30);\n        found_digit = true;\n      }\n      if (found_digit) {\n        precision = num_chars_written;\n      }\n    }\n  }\n  found_char = memchr(PTR_DAT_00005a54,(uint)*current_char,3);\n  if (found_char != (void *)0x0) {\n    flags = flags | 0x40 << ((int)found_char - (int)length_modifiers & 0xffU);\n    current_char = current_char + 1;\n  }\n  arguments = current_char + 1;\n  specifier = *current_char;\n  found_char = memchr(PTR_s_efgEFG_00005a48,(uint)specifier,6);\n  if (found_char == (void *)0x0) {\n    num_chars_written = _printf_i(stream,&flags,format_string,DAT_00005a50,&arg_values);\n  }\n  else {\n    num_chars_written = stream;\n    if (DAT_00005a4c == 0) {\n      arg_values = (int *)(((int)arg_values + 7U & 0xfffffff8) + 8);\n      num_chars_written = stream_copy;\n      goto LAB_000059b4;\n    }\n  }\n  if (num_chars_written == -1) goto LAB_00005a06;\nLAB_000059b4:\n  total_chars_written = total_chars_written + num_chars_written;\n  next_char = arguments;\n  stream_copy = num_chars_written;\n  goto LAB_0000588e;\n}\n\n",
            "called": [
                "__sfputs_r",
                "__retarget_lock_acquire_recursive",
                "__swsetup_r",
                "memchr",
                "__retarget_lock_release_recursive",
                "_printf_i",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057f8",
            "calling": [
                "iprintf"
            ],
            "imported": false,
            "current_name": "print_formatted_string_000057f8"
        },
        "FUN_000018bc": {
            "renaming": {
                "FUN_000018bc": "initializeSystemClock_000018bc",
                "DAT_00001910": "portControlRegister",
                "DAT_00001914": "dataRegister",
                "PTR_current_mode_00001918": "currentModePointer"
            },
            "code": "void initializeSystemClock_000018bc(void)\n{\n  setFLLFactor(KINETIS_MCG_FLL_FACTOR_1464);\n  *DAT_00001910 = (*DAT_00001910 & 0x3b) | 0x04;\n  clearBit8(DAT_00001914, 0x01);\n  while ((DAT_00001914[6] & 0x10) == 0);\n  while ((DAT_00001914[6] & 0x0c) != 0);\n  *PTR_current_mode_00001918 = 0;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000018bc",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "initializeSystemClock_000018bc"
        },
        "FUN_00000974": {
            "renaming": {
                "FUN_00000974": "run_active_thread_00000974",
                "PTR_sched_active_thread_0000098c": "sched_active_thread",
                "isCurrentModePrivileged": "is_privileged_mode",
                "setProcessStackPointer": "set_process_stack_pointer",
                "UNRECOVERED_JUMPTABLE": "active_thread_function",
                "ppcVar2": "active_thread_stack_pointer",
                "bVar1": "is_privileged_mode"
            },
            "code": "void run_active_thread_00000974(void)\n{\n  bool is_privileged_mode;\n  code *active_thread_function;\n  code **active_thread_stack_pointer;\n  \n  sched_run();\n  active_thread_function = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  active_thread_stack_pointer = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    setProcessStackPointer(active_thread_stack_pointer);\n  }\n  (*active_thread_function)(active_thread_function,active_thread_stack_pointer);\n  return;\n}\n",
            "called": [
                "sched_run"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000974",
            "calling": [
                "isr_pendsv"
            ],
            "imported": false,
            "current_name": "run_active_thread_00000974"
        },
        "FUN_00000f04": {
            "renaming": {
                "FUN_00000f04": "handle_crash_00000f04",
                "crash_code": "crash_type",
                "crash_message": "message",
                "PTR_crashed_00000f4c": "flag_crashed",
                "PANIC_ASSERT_FAIL": "panic_assert_fail",
                "PTR_s_____RIOT_kernel_panic___s_00000f50": "riot_kernel_panic_message",
                "PTR_DAT_00000f54": "data_message",
                "PTR_s_____halted__00000f58": "halted_message"
            },
            "code": "void handle_crash_00000f04(handle_crash_00000f04_t crash_code, char *crash_message){\n  undefined4 PTR_crashed_00000f4c;\n  undefined4 zero;\n  char *message;\n  handle_crash_00000f04_t crash_type;\n  \n  message = crash_message;\n  crash_type = crash_code;\n  if (*(int *)PTR_crashed_00000f4c == 0) {\n    *(undefined4 *)PTR_crashed_00000f4c = 1;\n    if (crash_code == PANIC_ASSERT_FAIL) {\n      cpu_print_last_instruction();\n    }\n    iprintf(PTR_s_____RIOT_kernel_panic___s_00000f50, message);\n    ps();\n    iprintf(PTR_DAT_00000f54);\n    iprintf(PTR_s_____halted__00000f58);\n  }\n  irq_disable();\n  panic_arch();\n  PTR_crashed_00000f4c = 0xf4d;\n  pm_off();\n  zero = (int)&PTR_crashed_00000f4c + 1;\n  auto_init();\n  iprintf(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  main();\n  return;\n}",
            "called": [
                "irq_disable",
                "ps",
                "iprintf",
                "pm_off",
                "panic_arch",
                "cpu_print_last_instruction"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f04",
            "calling": [
                "thread_add_to_list",
                "bus_fault_default",
                "cib_init",
                "fmt_s32_dfp",
                "uart_init",
                "mem_manage_default",
                "debug_mon_default",
                "hard_fault_handler",
                "dummy_handler_default",
                "nmi_default",
                "usage_fault_default"
            ],
            "imported": false,
            "current_name": "handle_crash_00000f04"
        },
        "FUN_00000610": {
            "renaming": {
                "FUN_00000610": "thread_context_switch_00000610",
                "uVar1": "lsb_bit_index",
                "iVar2": "active_thread_id",
                "iVar3": "next_thread_id",
                "active_thread": "active_thread",
                "nextrq": "nextrq",
                "__m____": "__m____",
                "next_thread": "next_thread",
                "PTR_sched_context_switch_request_00000684": "PTR_sched_context_switch_request_00000684",
                "PTR_sched_active_thread_00000688": "PTR_sched_active_thread_00000688",
                "PTR_runqueue_bitcache_0000068c": "PTR_runqueue_bitcache_0000068c",
                "PTR_FUN_00000610queues_00000690": "PTR_FUN_00000610queues_00000690",
                "PTR_sched_active_pid_00000694": "PTR_sched_active_pid_00000694"
            },
            "code": "int thread_context_switch_00000610(void) {\n  uint32_t active_thread_id;\n  int32_t next_thread_id;\n  thread_t *active_thread;\n  thread_t *next_thread;\n  clist_node_t *__m____;\n  int32_t nextrq;\n  uint32_t lsb_bit_index = bitarithm_lsb(*(uint32_t*)PTR_runqueue_bitcache_0000068c);\n  int32_t *runqueue = *(int32_t **)(PTR_thread_context_switch_00000610queues_00000690 + lsb_bit_index * 4);\n  active_thread_id = *(uint32_t *)PTR_sched_active_thread_00000688;\n  next_thread_id = *(int32_t *)(runqueue + 1);\n  if (active_thread_id == next_thread_id) {\n    return 0;\n  }\n  if (active_thread_id != 0 && *(char *)(active_thread_id + 4) == '\\t') {\n    *(char *)(active_thread_id + 4) = '\\n';\n  }\n  *(char *)(next_thread_id - 4) = 9;\n  *(uint16_t *)PTR_sched_active_pid_00000694 = *(uint16_t *)(next_thread_id - 2);\n  *(uint32_t *)PTR_sched_active_thread_00000688 = next_thread_id - 8;\n  return 1;\n}",
            "called": [
                "bitarithm_lsb"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000610",
            "calling": [
                "isr_svc"
            ],
            "imported": false,
            "current_name": "thread_context_switch_00000610"
        },
        "FUN_00003694": {
            "renaming": {
                "FUN_00003694": "display_sensor_data_00003694",
                "data": "sensor_data",
                "dim": "num_dimensions",
                "sVar1": "length",
                "pcVar2": "unit_str",
                "cVar3": "unit_char",
                "uVar4": "bit_mask",
                "bVar5": "is_bit_set",
                "num": "num_buffer",
                "scale_prefix": "unit_prefix",
                "i": "dimension_index"
            },
            "code": "void display_sensor_data_00003694(phydat_t *sensor_data, uint8_t num_dimensions)\n{\n    size_t length;\n    char *unit_str;\n    char unit_prefix;\n    uint8_t dimension_index;\n\n    if ((sensor_data == NULL) || (num_dimensions > 3)) {\n        puts(Unable_to_display_data_object);\n    }\n    else {\n        iprintf(Data: );\n        for (dimension_index = 0; dimension_index < num_dimensions; dimension_index++) {\n            if (sensor_data->unit < 0x14) {\n                uint bit_mask = 1 << (uint)sensor_data->unit;\n                bool is_bit_set = (bit_mask & 0x1) != 0;\n                char unit_char = (char)(is_bit_set ? 1 : 0);\n                if (!is_bit_set) {\n                    unit_char = 0;\n                }\n                if (unit_char == 0) {\n                    unit_prefix = phydat_prefix_from_scale(sensor_data->scale);\n                }\n                else {\n                    unit_prefix = 0;\n                }\n            }\n            else {\n                unit_prefix = phydat_prefix_from_scale(sensor_data->scale);\n            }\n            iprintf(Data[%u]: , dimension_index);\n            if (num_dimensions < 2) {\n                iprintf(%d, sensor_data->val[dimension_index]);\n            }\n            else {\n                iprintf(%u: %d, dimension_index, sensor_data->val[dimension_index]);\n            }\n            if (unit_prefix == 0) {\n                if (sensor_data->scale == 0) {\n                    iprintf(%d, sensor_data->val[dimension_index]);\n                }\n                else if ((sensor_data->scale + 4 < 0 == SCARRY4((int)sensor_data->scale, 4)) && (sensor_data->scale < 0)) {\n                    length = fmt_s16_dfp(num_buffer, sensor_data->val[dimension_index], (int)sensor_data->scale);\n                    num_buffer[length] = 0;\n                    iprintf(%s, num_buffer);\n                }\n                else {\n                    iprintf(%dE%d, sensor_data->val[dimension_index], (int)sensor_data->scale);\n                }\n            }\n            else {\n                iprintf(%6d%c, sensor_data->val[dimension_index], (char)unit_prefix);\n            }\n            unit_str = phydat_unit_to_str(sensor_data->unit);\n            iprintf(%s, unit_str);\n        }\n    }\n}",
            "called": [
                "fmt_s16_dfp",
                "phydat_unit_to_str",
                "phydat_prefix_from_scale",
                "iprintf",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003694",
            "calling": [
                "write",
                "probe"
            ],
            "imported": false,
            "current_name": "display_sensor_data_00003694"
        },
        "FUN_00002364": {
            "renaming": {
                "FUN_00002364": "is_ring_buffer_full_00002364",
                "rb": "ring_buffer",
                "c": "data",
                "iVar1": "is_full",
                "_push": "push_to_ring_buffer"
            },
            "code": "int is_ring_buffer_full_00002364(tsrb_t *ring_buffer, char data) {\n  int is_full = tsrb_full(ring_buffer);\n  if (is_full == 0) {\n    push_to_ring_buffer(ring_buffer, data);\n    return 0;\n  }\n  else {\n    return -1;\n  }\n}",
            "called": [
                "tsrb_full",
                "_push"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002364",
            "calling": [
                "isrpipe_write_one"
            ],
            "imported": false,
            "current_name": "is_ring_buffer_full_00002364"
        },
        "FUN_00001ad4": {
            "renaming": {
                "FUN_00001ad4": "clear_bitmask_and_wait_until_set_00001ad4",
                "*DAT_00001b08": "data_register",
                "DAT_00001b08": "data_register",
                "*PTR_current_mode_00001b0c": "current_mode_ptr"
            },
            "code": "void clear_bitmask_and_wait_until_set_00001ad4(void)\n{\n  **DAT_00001b08 &= 0x3f;\n  while ((*DAT_00001b08[6] & 0xc) != 0xc);\n  **PTR_current_mode_00001b0c = 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ad4",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "clear_bitmask_and_wait_until_set_00001ad4"
        },
        "FUN_00001274": {
            "renaming": {
                "FUN_00001274": "initialize_system_00001274",
                "DAT_00001298": "PTR_SYSTEM_CONFIG",
                "PTR_DAT_00001298": "PTR_SYSTEM_CONFIG",
                "cortexm_init": "initialize_cortexm",
                "kinetis_mcg_init": "initialize_kinetis_mcg",
                "periph_init": "initialize_peripherals"
            },
            "code": "void initialize_system_00001274(void)\n{\n  initialize_cortexm();\n  *PTR_DAT_00001298 |= 0x28;\n  initialize_kinetis_mcg();\n  initialize_peripherals();\n  return;\n}",
            "called": [
                "cortexm_init",
                "kinetis_mcg_init",
                "periph_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001274",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "initialize_system_00001274"
        },
        "FUN_00002e6c": {
            "renaming": {
                "FUN_00002e6c": "handle_shell_commands_00002e6c",
                "shell_commands": "commands",
                "line_buf": "input_buffer",
                "len": "buffer_length",
                "iVar1": "read_result",
                "res": "input_length"
            },
            "code": "void handle_shell_commands_00002e6c(shell_command_t *commands, char *input_buffer, int buffer_length)\n{\n  int input_length;\n  int read_result;\n  print_prompt();\n  do {\n    input_length = readline(input_buffer, buffer_length);\n    if (input_length == 0) {\n      handle_input_line(commands, input_buffer);\n    }\n    print_prompt();\n  } while (true);\n}",
            "called": [
                "readline",
                "print_prompt",
                "handle_input_line"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e6c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "handle_shell_commands_00002e6c"
        },
        "FUN_00003444": {
            "renaming": {
                "FUN_00003444": "get_rtc_time_or_print_error_00003444",
                "iVar1": "rtc_error_code",
                "t": "current_time",
                "_print_time": "print_current_time"
            },
            "code": "int get_rtc_time_or_print_error_00003444(void)\n{\n  int rtc_error_code;\n  tm current_time;\n  rtc_error_code = rtc_get_time(&current_time);\n  if (rtc_error_code != 0) {\n    puts(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    print_current_time(&current_time);\n  }\n  return (uint)(rtc_error_code != 0);\n}\n",
            "called": [
                "_print_time",
                "rtc_get_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003444",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "get_rtc_time_or_print_error_00003444"
        },
        "FUN_00003688": {
            "renaming": {
                "FUN_00003688": "reset_system_00003688"
            },
            "code": "void reset_system_00003688(void)\n{\n  NVIC_SystemReset();\n  return;\n}",
            "called": [
                "NVIC_SystemReset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003688",
            "calling": [
                "_reboot_handler"
            ],
            "imported": false,
            "current_name": "reset_system_00003688"
        },
        "FUN_00001392": {
            "renaming": {
                "FUN_00001392": "set_bit_at_position_00001392",
                "ptr": "ptr",
                "bit": "bit_position",
                "puVar1": "bit_addr"
            },
            "code": "void set_bit_at_position_00001392(uint32_t *ptr, uint8_t bit_position) {\n  undefined4 *bit_addr = (undefined4 *)bitband_addr(ptr, (uint)bit_position);\n  *bit_addr = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001392",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_00001392"
        },
        "FUN_00002910": {
            "renaming": {
                "FUN_00002910": "reset_rtc_callback_00002910",
                "DAT_00002944": "rtc_address",
                "PTR_rtt_callback_00002948": "rtc_callback"
            },
            "code": "void reset_rtc_callback_00002910(void)\n{\n  int DAT_00002944 = DAT_00002944;\n  uint* PTR_rtt_callback_00002948_enable = (uint*)(DAT_00002944 + 0x1c);\n  *PTR_rtt_callback_00002948_enable &= 0xfffffffb;\n  *(undefined4 *)(DAT_00002944 + 8) = 0;\n  *(undefined4 *)PTR_rtt_callback_00002948 = 0;\n  *(undefined4 *)(PTR_rtt_callback_00002948 + 4) = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002910",
            "calling": [
                "rtc_clear_alarm"
            ],
            "imported": false,
            "current_name": "reset_rtc_callback_00002910"
        },
        "FUN_00004418": {
            "renaming": {
                "FUN_00004418": "getCharFromStream_00004418",
                "PTR__impure_ptr_00004438": "PTR__impure_ptr",
                "_getc_r": "getCharacterFromStream",
                "iVar1": "impurePtrValue",
                "character": "character"
            },
            "code": "int getCharFromStream_00004418(void)\n{\n  int impurePtrValue = *(int *)PTR__impure_ptr_00004438_00004438;\n  if ((impurePtrValue != 0) && (*(int *)(impurePtrValue + 0x18) == 0)) {\n    __sinit(impurePtrValue);\n  }\n  int character = _getc_r(impurePtrValue,*(undefined4 *)(impurePtrValue + 4));\n  return character;\n}",
            "called": [
                "__sinit",
                "_getc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004418",
            "calling": [
                "readline"
            ],
            "imported": false,
            "current_name": "getCharFromStream_00004418"
        },
        "FUN_0000258c": {
            "renaming": {
                "FUN_0000258c": "set_interrupt_priorities_0000258c",
                "i": "interrupt_index"
            },
            "code": "void set_interrupt_priorities_0000258c(void)\n{\n  uint32_t interrupt_index;\n  *(uint32_t *)(DAT_000025ec + 8) = DAT_000025f0;\n  NVIC_SetPriority(PendSV_IRQn, 1);\n  NVIC_SetPriority(SVCall_IRQn, 1);\n  for (interrupt_index = 0; interrupt_index < 0x66; interrupt_index++)\n  {\n    NVIC_SetPriority((IRQn_Type)interrupt_index, 1);\n  }\n  *(uint32_t *)(DAT_000025ec + 0x10) |= 0x10;\n  *(uint32_t *)(DAT_000025ec + 0x14) |= 0x200;\n  return;\n}",
            "called": [
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000258c",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "set_interrupt_priorities_0000258c"
        },
        "FUN_00002a00": {
            "renaming": {
                "FUN_00002a00": "print_character_00002a00",
                "c": "character"
            },
            "code": "void print_character_00002a00(int character) {\n  putchar(character);\n  return;\n}",
            "called": [
                "putchar"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a00",
            "calling": [
                "readline",
                "print_prompt"
            ],
            "imported": false,
            "current_name": "print_character_00002a00"
        },
        "FUN_00000a64": {
            "renaming": {
                "FUN_00000a64": "handleFault_00000a64",
                "sp": "stack_pointer",
                "corrupted": "is_corrupted",
                "unaff_r4": "unaff_r4",
                "unaff_r5": "unaff_r5",
                "unaff_r6": "unaff_r6",
                "unaff_r7": "unaff_r7",
                "unaff_r8": "unaff_r8",
                "unaff_r9": "unaff_r9",
                "unaff_r10": "unaff_r10",
                "unaff_r11": "unaff_r11",
                "in_lr": "in_lr",
                "PTR__eram_00000aa0": "heap_bottom",
                "&stack0x00000000": "stack0x00000000",
                "DAT_00000a9c": "N/A",
                "register0x00000054": "current_heap_top"
            },
            "code": "void handleFault_00000a64(void)\n{\n  uint32_t *stack_pointer;\n  uint32_t is_corrupted;\n  uint32_t unaff_r4;\n  undefined4 unaff_r5;\n  undefined4 unaff_r6;\n  undefined4 unaff_r7;\n  undefined4 unaff_r8;\n  undefined4 unaff_r9;\n  undefined4 unaff_r10;\n  undefined4 unaff_r11;\n  uint in_lr;\n\n  if ((heap_top < &stack0x00000000) || (&stack0x00000000 <= PTR__eram_00000aa0)) {\n    is_corrupted = 1;\n    current_heap_top = (BADSPACEBASE *)heap_top;\n  }\n  else {\n    is_corrupted = 0;\n  }\n  if ((in_lr & 4) == 0) {\n    stack_pointer = (uint32_t *)getMainStackPointer();\n  }\n  else {\n    stack_pointer = (uint32_t *)getProcessStackPointer();\n  }\n  *(undefined4 *)((int)current_heap_top - 4) = unaff_r11;\n  *(undefined4 *)((int)current_heap_top - 8) = unaff_r10;\n  *(undefined4 *)((int)current_heap_top - 0xc) = unaff_r9;\n  *(undefined4 *)((int)current_heap_top - 0x10) = unaff_r8;\n  *(undefined4 *)((int)current_heap_top - 0x14) = unaff_r7;\n  *(undefined4 *)((int)current_heap_top - 0x18) = unaff_r6;\n  *(undefined4 *)((int)current_heap_top - 0x1c) = unaff_r5;\n  *(uint32_t *)((int)current_heap_top - 0x20) = unaff_r4;\n  hard_fault_handler(stack_pointer, is_corrupted, in_lr, (uint32_t *)((int)current_heap_top - 0x20));\n}",
            "called": [
                "hard_fault_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a64",
            "calling": [],
            "imported": false,
            "current_name": "handleFault_00000a64"
        },
        "FUN_000043a0": {
            "renaming": {
                "FUN_000043a0": "processItems_000043a0",
                "param_1": "itemAddress",
                "param_2": "itemProcessor",
                "piVar2": "itemPtr",
                "uVar4": "result",
                "iVar5": "subItemCount",
                "iVar3": "subItemAddress",
                "uVar1": "subItemResult"
            },
            "code": "uint processItems_000043a0(int itemAddress, code *itemProcessor) {\n  uint result = 0;\n  int *itemPtr = (int *)(itemAddress + 0x48);\n  do {\n    int subItemCount = itemPtr[1];\n    int subItemAddress = itemPtr[2];\n    while (subItemCount-- > 0) {\n      if ((*(ushort *)(subItemAddress + 0xc) > 1) && (*(short *)(subItemAddress + 0xe) != -1)) {\n        uint subItemResult = (*itemProcessor)(subItemAddress);\n        result |= subItemResult;\n      }\n      subItemAddress += 0x68;\n    }\n    itemPtr = (int *)*itemPtr;\n  } while (itemPtr != (int *)0x0);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043a0",
            "calling": [
                "__srefill_r"
            ],
            "imported": false,
            "current_name": "processItems_000043a0"
        },
        "FUN_0000211c": {
            "renaming": {
                "FUN_0000211c": "print_thread_info_0000211c",
                "queued_name": "queued_name",
                "stacksz": "stacksz",
                "queued": "queued",
                "sname": "sname",
                "state": "state",
                "p": "thread",
                "isr_sp": "isr_sp",
                "isr_start": "isr_start",
                "isr_usage": "isr_usage",
                "i": "i",
                "overall_used": "overall_used",
                "overall_stacksz": "overall_stacksz"
            },
            "code": "void print_thread_info_0000211c(void) {\n    char queued_name[2] = {0x51, 0x5f};\n    int overall_used = 0;\n    int overall_stacksz = 0x200;\n    printf(\"%s\\t%s\\t%s\\t%s\\n\", \"pid\", \"state\", \"pri\", \"stack\");\n    int isr_usage = thread_isr_stack_usage();\n    void *isr_start = thread_isr_stack_start();\n    void *isr_sp = thread_isr_stack_pointer();\n    printf(\"isr stack: %d/%d bytes used\\nstart: %p\\nsp: %p\\n\", isr_usage, overall_stacksz, isr_start, isr_sp);\n    for (kernel_pid_t i = 1; i < 0x21; i++) {\n        thread_t *thread = *(thread_t **)(PTR_sched_threads_00002258 + i * 4);\n        if (thread) {\n            char *sname = *(char **)(PTR_state_names_0000225c + thread->state * 4);\n            int stacksz = thread->stack_size;\n            overall_stacksz += stacksz;\n            int used = stacksz - thread_measure_stack_free(thread->stack);\n            overall_used += used;\n            printf(\"%d\\t%s\\t%d\\t%c%c\\t%d/%d bytes used\\n\", thread->pid, sname, thread->priority, queued_name[8 < thread->priority], thread->name[0], used, stacksz, thread->entry);\n        }\n    }\n    printf(\"overall stack: %d/%d bytes used\\n\", overall_used, overall_stacksz);\n}\n",
            "called": [
                "thread_isr_stack_pointer",
                "thread_isr_stack_start",
                "iprintf",
                "thread_isr_stack_usage",
                "thread_measure_stack_free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000211c",
            "calling": [
                "_ps_handler",
                "core_panic"
            ],
            "imported": false,
            "current_name": "print_thread_info_0000211c"
        },
        "FUN_0000562c": {
            "renaming": {
                "FUN_0000562c": "find_env_var_0000562c",
                "param_1": "env_lock",
                "param_2": "var_name",
                "param_3": "index",
                "puVar2": "env_var_ptr",
                "ppcVar3": "env_var_ptr_iter",
                "iVar4": "name_comparison_result",
                "pcVar5": "env_var_value",
                "ppcVar6": "env_var_ptr_iter",
                "__n": "name_length",
                "cVar1": "current_char"
            },
            "code": "char* find_env_var_0000562c(int env_lock, char* var_name, int* index) {\n  char current_char;\n  char** env_var_ptr;\n  int name_length;\n  char* env_var_value;\n  char** env_var_ptr_iter;\n  \n  __env_lock();\n  env_var_ptr = PTR_environ_0000569c;\n  env_var_value = var_name;\n  if (*(char ***)PTR_environ_0000569c != (char **)0x0) {\n    do {\n      current_char = *env_var_value;\n      if (current_char == '\\0') {\n        name_length = (int)env_var_value - (int)var_name;\n        env_var_ptr_iter = *(char ***)PTR_environ_0000569c;\n        while( true ) {\n          env_var_ptr = env_var_ptr_iter;\n          if (*env_var_ptr == (char *)0x0) break;\n          if ((strncmp(*env_var_ptr,var_name,name_length) == 0) && ((*env_var_ptr)[name_length] == '=')) {\n            *index = (int)env_var_ptr_iter - *(int *)PTR_environ_0000569c >> 2;\n            __env_unlock(env_lock);\n            return *env_var_ptr + name_length + 1;\n          }\n          env_var_ptr_iter = env_var_ptr + 1;\n        }\n        break;\n      }\n      env_var_value++;\n    } while (current_char != '=');\n  }\n  __env_unlock(env_lock);\n  return (char *)0x0;\n}",
            "called": [
                "__env_unlock",
                "strncmp",
                "__env_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000562c",
            "calling": [
                "_getenv_r"
            ],
            "imported": false,
            "current_name": "find_env_var_0000562c"
        },
        "FUN_000020b8": {
            "renaming": {
                "FUN_000020b8": "handle_interrupt_000020b8",
                "DAT_000020c8": "device_data"
            },
            "code": "void handle_interrupt_000020b8(void)\n{\n  irq_handler(DAT_000020c8, 0);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020b8",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020b8"
        },
        "FUN_00002a18": {
            "renaming": {
                "FUN_00002a18": "find_shell_command_handler_00002a18",
                "command_list": "command_list",
                "command": "command",
                "iVar1": "comparison_result",
                "command_lists": "command_lists",
                "i": "i",
                "entry": "entry"
            },
            "code": "typedef struct shell_command {\n    char *name;\n    shell_command_handler_t handler;\n    char *description;\n} shell_command_t;\n\ntypedef struct shell_command_handler {\n    shell_command_t *command_list;\n    char *command;\n} shell_command_handler_t;\n\nshell_command_handler_t find_shell_command_handler_00002a18(shell_command_t *command_list, char *command) {\n    int comparison_result;\n    shell_command_t *command_lists [2];\n    uint i = 0;\n    shell_command_t *entry;\n    \n    command_lists[0] = command_list;\n    command_lists[1] = (shell_command_t *)PTR__shell_command_list_00002a84;\n    \n    while(i < 2) {\n        entry = command_lists[i];\n        if(entry != NULL) {\n            while(entry->name != NULL) {\n                comparison_result = strcmp(entry->name, command);\n                if(comparison_result == 0) {\n                    return entry->handler;\n                }\n                entry++;\n            }\n        }\n        i++;\n    }\n    return NULL;\n}",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a18",
            "calling": [
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "find_shell_command_handler_00002a18"
        },
        "FUN_000054a8": {
            "renaming": {
                "FUN_000054a8": "convert_ushort_to_uint_with_flags_000054a8",
                "param_1": "output",
                "param_2": "input",
                "uVar1": "input_flags",
                "uVar2": "input_flags_copy",
                "uVar3": "input_value",
                "uVar4": "input_flags_copy2",
                "iVar5": "impure_ptr"
            },
            "code": "uint convert_ushort_to_uint_with_flags_000054a8(uint *output, ushort *input)\n{\n  uint flags = 0;\n  int impure_ptr = *(int *)PTR__impure_ptr_00005574;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  if (input == (ushort *)PTR___sf_fake_stdin_00005578) {\n    input = *(ushort **)(impure_ptr + 4);\n  }\n  else if (input == (ushort *)PTR___sf_fake_stdout_0000557c) {\n    input = *(ushort **)(impure_ptr + 8);\n  }\n  else if (input == (ushort *)PTR___sf_fake_stderr_00005580) {\n    input = *(ushort **)(impure_ptr + 0xc);\n  }\n  uint input_value = (uint)input[3];\n  if (-1 < (int)(input_value << 0x1c)) {\n    if (-1 < (int)(input_value << 0x1b)) {\n      *output = 9;\n      goto LAB_000054d8;\n    }\n    if ((uint *)input[0xd] != (uint *)0x0) {\n      if ((uint *)input[0xd] != input + 0x11) {\n        _free_r(output);\n      }\n      input[0xd] = 0;\n    }\n    input[3] = input[3] & 0xffdb;\n    input[1] = 0;\n    *input = input[4];\n  }\n  if ((input[4] == 0) && ((input[3] & 0x280) != 0x200)) {\n    __smakebuf_r(output,input);\n  }\n  uint input_flags = input[3];\n  uint input_flags_copy = input[3];\n  uint input_flags_copy2 = input_flags_copy & 1;\n  if ((input_flags & 1) == 0) {\n    if (-1 < (int)(input_flags_copy << 0x1e)) {\n      input_flags_copy2 = input[5];\n    }\n    input[2] = input_flags_copy2;\n  }\n  else {\n    input[2] = 0;\n    input[6] = -input[5];\n  }\n  if (input[4] != 0) {\n    return 0;\n  }\n  if ((input_flags & 0x80) == 0) {\n    return input_flags & 0x80;\n  }\nLAB_000054d8:\n  input[3] = input_flags_copy | 0x40;\n  return 0xffffffff;\n}",
            "called": [
                "_free_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000054a8",
            "calling": [
                "_puts_r",
                "__swbuf_r",
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "convert_ushort_to_uint_with_flags_000054a8"
        },
        "FUN_000007dc": {
            "renaming": {
                "FUN_000007dc": "create_thread_stack_000007dc",
                "task_func": "thread_task_func",
                "arg": "argument",
                "stack_start": "stack_start_address",
                "stack_size": "stack_size",
                "uVar1": "stack_size_aligned",
                "stk": "stack_pointer",
                "i_1": "loop_index_1",
                "i": "loop_index_2"
            },
            "code": "char* create_thread_stack_000007dc(thread_task_func_t task_func, void* arg, void* stack_start, int stack_size) {\n    uint32_t* stack_pointer;\n    uint32_t stack_size_aligned;\n    int i;\n\n    stack_size_aligned = (uint32_t)stack_size + (uint32_t)stack_start & 0xfffffffc;\n    stack_pointer = (uint32_t*)(stack_size_aligned - 4);\n    *stack_pointer = 0x77777777;\n\n    if (((uint32_t)stack_pointer & 7) != 0) {\n        stack_pointer = (uint32_t*)(stack_size_aligned - 8);\n        *stack_pointer = 0x88888888;\n    }\n\n    stack_pointer[-1] = 0x1000000;\n    stack_pointer[-2] = (uint32_t)task_func;\n    stack_pointer[-3] = DAT_000008b4;\n    stack_pointer = stack_pointer - 4;\n    *stack_pointer = 0;\n\n    for (i = 3; i > 0; i--) {\n        stack_pointer--;\n        *stack_pointer = i;\n    }\n\n    stack_pointer--;\n    *stack_pointer = (uint32_t)arg;\n\n    for (i = 0xB; i > 3; i--) {\n        stack_pointer--;\n        *stack_pointer = i;\n    }\n\n    stack_pointer[-1] = 0xFFFFFFFD;\n    return (char*)(stack_pointer - 1);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000007dc",
            "calling": [
                "thread_create"
            ],
            "imported": false,
            "current_name": "create_thread_stack_000007dc"
        },
        "FUN_00001710": {
            "renaming": {
                "FUN_00001710": "clear_bit_at_position_00001710",
                "ptr": "data",
                "bit": "bit_position",
                "puVar1": "bitband_address"
            },
            "code": "void clear_bit_at_position_00001710(uint8_t *data, uint8_t bit_position)\n{\n    uint32_t *bitband_address = (uint32_t *)bitband_addr(data, (uint)bit_position);\n    *bitband_address = 0;\n    return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001710",
            "calling": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_disable_pll",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "clear_bit_at_position_00001710"
        },
        "FUN_000045ea": {
            "renaming": {
                "FUN_000045ea": "do_nothing_000045ea"
            },
            "code": "\nvoid do_nothing_000045ea(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ea",
            "calling": [
                "__tz_unlock"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ea"
        },
        "FUN_000045ec": {
            "renaming": {
                "FUN_000045ec": "do_nothing_000045ec"
            },
            "code": "\nvoid do_nothing_000045ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ec",
            "calling": [
                "_puts_r",
                "__sinit_lock_release",
                "__env_unlock",
                "__malloc_unlock",
                "_fflush_r",
                "__sfp_lock_release",
                "_vfprintf_r",
                "_putc_r",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ec"
        },
        "FUN_00001034": {
            "renaming": {
                "FUN_00001034": "insert_thread_into_list_00001034",
                "list_entry": "current_thread",
                "__m____": "temp",
                "new_node": "new_node",
                "my_prio": "thread_priority",
                "local_1c": "current_node"
            },
            "code": "void insert_thread_into_list_00001034(list_node_t *list, thread_t *thread)\n{\n    list_node_t *current_node = list;\n    thread_t *current_thread;\n    clist_node_t *temp;\n    list_node_t *new_node;\n    uint16_t thread_priority;\n    \n    if (thread->status < 9) {\n        while ((current_node->next != NULL && current_node->next->thread_priority <= thread->priority)) {\n            current_node = current_node->next;\n        }\n        thread->rq_entry.next = current_node->next;\n        current_node->next = &thread->rq_entry;\n        return;\n    }\n    core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_0000109c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001034",
            "calling": [
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "insert_thread_into_list_00001034"
        },
        "FUN_000055ac": {
            "renaming": {
                "FUN_000055ac": "read_byte_from_file_000055ac",
                "param_1": "file_handle",
                "param_2": "file_pointer",
                "uVar1": "byte_read",
                "pbVar2": "current_byte"
            },
            "code": "uint read_byte_from_file_000055ac(int file_handle, byte **file_pointer)\n{\n  uint byte_read;\n  byte *current_byte;\n  if ((file_handle != 0) && (*(int *)(file_handle + 0x18) == 0)) {\n    __sinit();\n  }\n  if (file_pointer == (byte **)PTR___sf_fake_stdin_00005620) {\n    file_pointer = *(byte ***)(file_handle + 4);\n  }\n  else if (file_pointer == (byte **)PTR___sf_fake_stdout_00005624) {\n    file_pointer = *(byte ***)(file_handle + 8);\n  }\n  else if (file_pointer == (byte **)PTR___sf_fake_stderr_00005628) {\n    file_pointer = *(byte ***)(file_handle + 0xc);\n  }\n  if ((-1 < (int)file_pointer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(file_pointer + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(file_pointer[0x16]);\n  }\n  current_byte = file_pointer[1];\n  file_pointer[1] = current_byte - 1;\n  if ((int)(current_byte - 1) < 0) {\n    byte_read = __srget_r(file_handle, file_pointer);\n  }\n  else {\n    current_byte = *file_pointer;\n    *file_pointer = current_byte + 1;\n    byte_read = (uint)*current_byte;\n  }\n  if ((-1 < (int)file_pointer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(file_pointer + 3) << 0x16))) {\n    __retarget_lock_release_recursive(file_pointer[0x16]);\n  }\n  return byte_read;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive",
                "__srget_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000055ac",
            "calling": [
                "getchar"
            ],
            "imported": false,
            "current_name": "read_byte_from_file_000055ac"
        },
        "FUN_00006964": {
            "renaming": {
                "FUN_00006964": "calculate_new_index_00006964",
                "param_1": "previous_index",
                "param_2": "array",
                "iVar1": "new_index",
                "*(int *)(param_2 + -4)": "array[previous_index - 1]",
                "iVar1 + *(int *)(param_2 + iVar1)": "new_index + array[new_index]"
            },
            "code": "int calculate_new_index_00006964(int previous_index, int* array) {\n                      int new_index = previous_index - 1;\n                      if (previous_index < 0) {\n                          new_index += array[previous_index - 1];\n                      }\n                      return new_index;\n                  }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006964",
            "calling": [
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "calculate_new_index_00006964"
        },
        "FUN_0000182c": {
            "renaming": {
                "FUN_0000182c": "clearFlagsAndSetBitToZero_0000182c",
                "tmp": "flag"
            },
            "code": "void clearFlagsAndSetBitToZero_0000182c(void)\n{\n  uint8_t flag;\n  flag = 0xd0;\n  DAT_000018b4[8] &= flag;\n  bit_set8(DAT_000018b8, 0);\n  bit_clear8(DAT_000018b4, 1);\n  bit_clear8(DAT_000018b4, 0);\n  return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000182c",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "clearFlagsAndSetBitToZero_0000182c"
        },
        "FUN_00004db8": {
            "renaming": {
                "FUN_00004db8": "reverse_string_00004db8",
                "__s": "string_to_reverse",
                "iVar1": "reversed_string_length",
                "PTR__impure_ptr_00004dc4": "PTR__impure_ptr_00004dc4"
            },
            "code": "int reverse_string_00004db8(char* string_to_reverse)\n{\n  int reversed_string_length = strlen(string_to_reverse);\n  for (int i = 0; i < reversed_string_length / 2; i++) {\n    char temp = string_to_reverse[i];\n    string_to_reverse[i] = string_to_reverse[reversed_string_length - i - 1];\n    string_to_reverse[reversed_string_length - i - 1] = temp;\n  }\n  return reversed_string_length;\n}",
            "called": [
                "_puts_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004db8",
            "calling": [
                "phydat_dump",
                "_rtc_setalarm",
                "_rtc_usage",
                "write",
                "list",
                "main",
                "read",
                "print_help",
                "_rtc_settime",
                "probe_all",
                "_rtc_getalarm",
                "_rtc_gettime",
                "hard_fault_handler",
                "_alarm_handler",
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "reverse_string_00004db8"
        },
        "FUN_000022f0": {
            "renaming": {
                "FUN_000022f0": "read_from_ring_buffer_000022f0",
                "rb": "ring_buffer",
                "uVar1": "read_index",
                "PTR_char_00": "buffer",
                "DAT_00000004": "size",
                "PTR_char_01": "buf"
            },
            "code": "char read_from_ring_buffer_000022f0(tsrb_t *ring_PTR_char_00) {\n  uint32_t read_index = ring_PTR_char_00->reads;\n  ring_PTR_char_00->reads = read_index + 1;\n  uint32_t PTR_char_00_index = read_index & (ring_PTR_char_00->DAT_00000004 - 1);\n  return ring_PTR_char_00->PTR_char_01[PTR_char_00_index];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022f0",
            "calling": [
                "tsrb_get"
            ],
            "imported": false,
            "current_name": "read_from_ring_buffer_000022f0"
        },
        "FUN_00001c84": {
            "renaming": {
                "FUN_00001c84": "initialize_system_clock_00001c84",
                "state": "interrupts_state",
                "mask": "clock_control_register",
                "kinetis_mcg_set_safe_mode": "set_safe_mode",
                "DAT_00001ce8": "data_pointer_1",
                "DAT_00001cec": "data_pointer_2",
                "FUN_00001c84_mcgirclk": "initialize_mcg_internal_reference_clock",
                "FUN_00001c84_erclk32k": "initialize_external_reference_clock",
                "kinetis_mcg_set_mode": "set_mode",
                "KINETIS_MCG_MODE_PEE": "mode_PEE",
                "irq_disable": "disable_interrupts",
                "irq_restore": "restore_interrupts"
            },
            "code": "void initialize_system_clock_00001c84(void)\n{\n  uint32_t state;\n  uint32_t clock_control_register;\n  state = disable_interrupts();\n  set_safe_mode();\n  *(uint32_t *)(DAT_00001ce8 + 0x1044) = 0x220000;\n  DAT_00001cec[0xc] = 0;\n  clock_control_register = *DAT_00001cec & 199 | 0x38;\n  *DAT_00001cec = clock_control_register;\n  DAT_00001cec[4] = 0x13;\n  DAT_00001cec[5] = 0;\n  initialize_mcg_internal_reference_clock();\n  initialize_external_reference_clock();\n  set_mode(KINETIS_MCG_MODE_PEE);\n  restore_interrupts(state);\n  return;\n}",
            "called": [
                "kinetis_mcg_init_erclk32k",
                "irq_disable",
                "irq_restore",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_mode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001c84",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initialize_system_clock_00001c84"
        },
        "FUN_000068f0": {
            "renaming": {
                "FUN_000068f0": "allocate_memory_and_initialize_flash_configuration_field_000068f0",
                "param_1": "size",
                "param_2": "flash_configuration_field_ptr",
                "pvVar1": "new_memory_block",
                "__n": "flash_configuration_field",
                "PTR_DAT_0000000c": "flash_configuration_field_ptr[13]",
                "PTR_DAT_00000044": "flash_configuration_field_ptr + 17",
                "PTR_DAT_00000048": "(int)flash_configuration_field_ptr + 0x46",
                "PTR_DAT_00000049": "(int)flash_configuration_field_ptr + 0x45",
                "PTR_DAT_00000054": "flash_configuration_field_ptr[14]",
                "PTR_DAT_00000058": "(void *)((int)new_memory_block + 0x3fd)",
                "PTR_DAT_0000005c": "void *)((int)new_memory_block + (int)flash_configuration_field)",
                "PTR_DAT_00000060": "flash_configuration_field_ptr[13]",
                "PTR_DAT_00000064": "(void *)((int)flash_configuration_field << 1)",
                "*PTR_DAT_00000000": "*flash_configuration_field_ptr"
            },
            "code": "undefined4 allocate_memory_and_initialize_flash_configuration_field_000068f0(uint32_t size, void **PTR_DAT_00000000)\n{\n  void *new_memory_block;\n  void *flash_configuration_field;\n\n  if ((void **)PTR_DAT_0000000c == PTR_DAT_00000044) {\n    new_memory_block = (void *)_malloc_r(size,0x400);\n    if (new_memory_block != NULL) {\n      PTR_DAT_00000054 = flash_configuration_field;\n      PTR_DAT_0000000c = new_memory_block;\n      *(uint8_t *)((int)new_memory_block + 0x3ff) = *(uint8_t *)(PTR_DAT_00000048);\n      *(uint8_t *)((int)new_memory_block + 0x3fe) = *(uint8_t *)(PTR_DAT_00000049);\n      *(void **)((int)new_memory_block + 0x3fd) = flash_configuration_field_ptr[17];\n      *PTR_DAT_00000000 = PTR_DAT_00000058;\n      return 0;\n    }\n  }\n  else {\n    flash_configuration_field = PTR_DAT_00000054;\n    new_memory_block = (void *)_realloc_r(size,PTR_DAT_0000000c,PTR_DAT_00000064);\n    if (new_memory_block != NULL) {\n      memcpy((PTR_DAT_0000005c,new_memory_block,(size_t)flash_configuration_field);\n      PTR_DAT_0000000c = new_memory_block;\n      PTR_DAT_00000054 = PTR_DAT_00000064;\n      *PTR_DAT_00000000 = (PTR_DAT_0000005c;\n      return 0;\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "_realloc_r",
                "memcpy",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000068f0",
            "calling": [
                "_sungetc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_and_initialize_flash_configuration_field_000068f0"
        }
    },
    "used_tokens": 223968,
    "layers": [
        [
            "FUN_000026c0",
            "FUN_00004bd0",
            "FUN_00000794",
            "FUN_000064bc",
            "FUN_00002970",
            "FUN_00000ca0",
            "FUN_00000d0c",
            "FUN_00003d94",
            "FUN_0000579c",
            "FUN_000015d0",
            "FUN_00004cdc",
            "FUN_00005e68",
            "FUN_00000dcc",
            "FUN_0000285c",
            "FUN_00000e58",
            "FUN_00001778",
            "FUN_000026d8",
            "FUN_00000566",
            "FUN_00001d08",
            "FUN_000031fc",
            "FUN_000016ec",
            "FUN_00004e8c",
            "FUN_00005584",
            "FUN_00000cb0",
            "FUN_00004248",
            "FUN_00000f5c",
            "FUN_00001da2",
            "FUN_00001ec4",
            "FUN_00002744",
            "FUN_00002624",
            "FUN_00001e0c",
            "FUN_0000459c",
            "FUN_000014c4",
            "FUN_00004b34",
            "FUN_000004f2",
            "FUN_0000423c",
            "FUN_00004e66",
            "FUN_00005ecc",
            "FUN_00001628",
            "FUN_00001748",
            "FUN_0000294c",
            "FUN_00005790",
            "FUN_00000534",
            "FUN_000017dc",
            "FUN_000005ca",
            "FUN_000043da",
            "FUN_00005ff8",
            "FUN_00006754",
            "FUN_00002714",
            "FUN_000020e0",
            "FUN_00004f80",
            "FUN_00005fec",
            "FUN_000028f0",
            "FUN_00004f98",
            "FUN_00004dee",
            "FUN_00000fec",
            "FUN_00000428",
            "FUN_000039e8",
            "FUN_00000e38",
            "FUN_00002294",
            "FUN_00003e9e",
            "FUN_00003378",
            "FUN_00006768",
            "FUN_00000db0",
            "FUN_00002600",
            "FUN_00003810",
            "FUN_00000ed8",
            "FUN_000031e0",
            "FUN_000004d4",
            "FUN_000020f4",
            "FUN_0000687c",
            "FUN_00004dea",
            "FUN_00005edc",
            "FUN_000023a4",
            "FUN_0000240c",
            "FUN_00004280",
            "FUN_00001448",
            "FUN_00001688",
            "FUN_00004042",
            "FUN_00000cf0",
            "FUN_00000f8c",
            "FUN_00002894",
            "FUN_00004158",
            "FUN_00002654",
            "FUN_00000aa8",
            "FUN_00002538",
            "FUN_00004c84",
            "FUN_000012b4",
            "FUN_0000058e",
            "FUN_000025f4",
            "FUN_00001ddc",
            "FUN_00002ecc",
            "FUN_00000d76",
            "FUN_000057a8",
            "FUN_00004298",
            "FUN_00001696",
            "FUN_000008b8",
            "FUN_000024bc",
            "FUN_00000490",
            "FUN_0000091c",
            "FUN_00005d80",
            "FUN_00001f80",
            "FUN_00000e64",
            "FUN_000026e4",
            "FUN_00000d44",
            "FUN_00000698",
            "FUN_00000cd0",
            "FUN_00000cc0",
            "FUN_00002994",
            "FUN_00000d2a",
            "FUN_00001ff6",
            "FUN_00000f80",
            "FUN_00002a88",
            "FUN_00002f30",
            "FUN_00001e44",
            "FUN_00001318",
            "FUN_00000900",
            "FUN_00004274",
            "FUN_00002fe0",
            "FUN_00001dc0",
            "FUN_00000df4",
            "FUN_00002eb4",
            "FUN_0000328c",
            "FUN_000041f4",
            "FUN_0000316c",
            "FUN_000026f0",
            "FUN_000057d2",
            "FUN_00000958",
            "FUN_000056b8",
            "FUN_00001a18",
            "FUN_00000d9c",
            "FUN_00003ff4",
            "FUN_00001d5e",
            "FUN_0000191c",
            "FUN_000050f4",
            "FUN_00000c80",
            "FUN_00000a40",
            "FUN_00005a58",
            "FUN_000056b0",
            "FUN_00003d24",
            "FUN_000060cc",
            "FUN_000022be",
            "FUN_00003dc4",
            "FUN_00002108",
            "FUN_00000c90",
            "FUN_00001d80",
            "FUN_000033c0",
            "FUN_00002b10",
            "FUN_00001b10",
            "FUN_000023c8",
            "FUN_00002e48",
            "FUN_00000930",
            "FUN_00001348",
            "FUN_00006118",
            "FUN_00001d3a",
            "FUN_00002434",
            "FUN_00005700",
            "FUN_00002798",
            "FUN_00003524",
            "FUN_00001bb8",
            "FUN_0000428c",
            "FUN_0000404c",
            "FUN_00002f74",
            "FUN_000010a0",
            "FUN_000012e2",
            "FUN_000056a0",
            "FUN_0000231c",
            "FUN_00002690",
            "FUN_00006010",
            "FUN_00001cf0",
            "FUN_00003ec4",
            "FUN_00001360",
            "FUN_00004622",
            "FUN_0000093c",
            "FUN_00003658",
            "FUN_000019c0",
            "FUN_000060b0",
            "FUN_000023d0",
            "FUN_00000a30",
            "FUN_000034c0",
            "FUN_000050e8",
            "FUN_00000514",
            "FUN_00002e9c",
            "FUN_00001960",
            "FUN_00001a3c",
            "FUN_000045ee",
            "FUN_00005404",
            "FUN_00006974",
            "FUN_00005fd4",
            "FUN_00004dc8",
            "FUN_00005e10",
            "FUN_000033f4",
            "FUN_0000443c",
            "FUN_000027b0",
            "FUN_00005ebc",
            "FUN_00006192",
            "FUN_00001734",
            "FUN_00000e14",
            "FUN_0000281c",
            "FUN_00002270",
            "FUN_000020cc",
            "FUN_00002396",
            "FUN_00004e4a",
            "FUN_00004cb4",
            "FUN_00003478",
            "FUN_00002028",
            "FUN_000016c8",
            "FUN_00001a60",
            "FUN_000004b2",
            "FUN_0000099c",
            "FUN_00002d94",
            "FUN_00003918",
            "FUN_00003d64",
            "FUN_00004e52",
            "FUN_000010d4",
            "FUN_00000738",
            "FUN_00003e58",
            "FUN_00004e26",
            "FUN_00000978",
            "FUN_000018bc",
            "FUN_00000974",
            "FUN_00000610",
            "FUN_00003694",
            "FUN_00002364",
            "FUN_00001ad4",
            "FUN_00001274",
            "FUN_00002e6c",
            "FUN_00003444",
            "FUN_00003688",
            "FUN_00001392",
            "FUN_00002910",
            "FUN_00004418",
            "FUN_0000258c",
            "FUN_00002a00",
            "FUN_00000a64",
            "FUN_000043a0",
            "FUN_0000211c",
            "FUN_0000562c",
            "FUN_000020b8",
            "FUN_00002a18",
            "FUN_000054a8",
            "FUN_000007dc",
            "FUN_00001710",
            "FUN_00001034",
            "FUN_000055ac",
            "FUN_00006964",
            "FUN_0000182c",
            "FUN_000022f0",
            "FUN_000068f0"
        ],
        [
            "FUN_00000dc0",
            "FUN_00005100",
            "FUN_000041d0",
            "FUN_0000129c",
            "FUN_00000410",
            "FUN_00004f84",
            "FUN_00001eea",
            "FUN_0000305c",
            "FUN_000013b8",
            "FUN_000042a4",
            "FUN_00004314",
            "FUN_00005fd8",
            "FUN_00005780",
            "FUN_00000f04",
            "FUN_00004db8",
            "FUN_00001c84"
        ],
        [
            "FUN_00005b34",
            "FUN_0000656c",
            "FUN_0000510c",
            "FUN_00004634",
            "FUN_000047e4",
            "FUN_000061cc",
            "FUN_00006a14",
            "FUN_000057f8"
        ]
    ],
    "locked_functions": []
}