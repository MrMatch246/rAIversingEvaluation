{
    "functions": {
        "FUN_000026c0": {
            "renaming": {
                "FUN_000026c0": "initializeData_000026c0",
                "FUN_00002910": "callFunction",
                "PTR_DAT_000026d4": "pointerData"
            },
            "code": "void initializeData_000026c0(void)\n{\n  callFunction();\n  *(undefined4 *)PTR_DAT_000026d4 = 0;\n  return;\n}",
            "called": [
                "FUN_00002910"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "initializeData_000026c0"
        },
        "FUN_00004bd0": {
            "renaming": {
                "FUN_00004bd0": "allocate_memory_block_00004bd0",
                "param_1": "allocated_memory_block",
                "param_2": "requested_size",
                "param_3": "unknown1",
                "param_4": "unknown2",
                "puVar1": "unused_pointer",
                "uVar2": "unused_variable",
                "puVar3": "current_memory_block_pointer",
                "iVar4": "remaining_size",
                "uVar5": "temp_variable",
                "puVar6": "new_memory_block_pointer",
                "uVar7": "aligned_requested_size",
                "PTR_DAT_00004c80": "unused_pointer",
                "PTR_DAT_00004c7c": "memory_block_list_pointer"
            },
            "code": "uint allocate_memory_block_00004bd0(uint *allocated_memory_block, uint requested_size, uint unknown1, uint unknown2)\n{\n  uint *current_memory_block;\n  uint aligned_requested_size;\n  uint remaining_size;\n  uint *previous_memory_block;\n  uint *new_memory_block;\n  \n  aligned_requested_size = (requested_size + 3U & 0xFFFFFFFC) + 8U;\n  if (aligned_requested_size < 0xCU) {\n    aligned_requested_size = 0xCU;\n  }\n  if ((int)aligned_requested_size < 0 || aligned_requested_size < requested_size) {\n    *allocated_memory_block = 0xCU;\n  }\n  else {\n    FUN_00005790();\n    current_memory_block = *(uint **)PTR_DAT_00004c7c;\n    previous_memory_block = *(uint **)PTR_DAT_00004c7c;\n    while (current_memory_block != (uint *)0x0) {\n      remaining_size = *current_memory_block - aligned_requested_size;\n      if ((int)remaining_size >= 0) {\n        if (remaining_size > 0xBU) {\n          *current_memory_block = remaining_size;\n          new_memory_block = (uint *)((int)current_memory_block + remaining_size);\n          *new_memory_block = aligned_requested_size;\n          goto LAB_00004c34;\n        }\n        new_memory_block = (uint *)current_memory_block[1];\n        if (previous_memory_block == current_memory_block) {\n          *(uint **)PTR_DAT_00004c7c = new_memory_block;\n        }\n        if (previous_memory_block != current_memory_block) {\n          previous_memory_block[1] = new_memory_block;\n        }\n        goto LAB_00004c42;\n      }\n      previous_memory_block = current_memory_block;\n      current_memory_block = (uint *)current_memory_block[1];\n    }\n    if (*(int *)PTR_DAT_00004c80 == 0) {\n      *PTR_DAT_00004c80 = FUN_00000428(allocated_memory_block, 0U, previous_memory_block, 0U, unknown2);\n    }\n    new_memory_block = (uint *)FUN_00000428(allocated_memory_block, aligned_requested_size);\n    if (new_memory_block != (uint *)0xFFFFFFFF && ((uint *)((int)new_memory_block + 3U & 0xFFFFFFFC) == new_memory_block || FUN_00000428(allocated_memory_block, (int)((uint *)((int)new_memory_block + 3U & 0xFFFFFFFC) - (int)new_memory_block)) != -1)) {\n      *new_memory_block = aligned_requested_size;\nLAB_00004c42:\n      FUN_0000579c(allocated_memory_block);\n      new_memory_block = (uint *)((int)new_memory_block + 0xBU & 0xFFFFFFF8U);\n      remaining_size = (int)new_memory_block - (int)(new_memory_block + 1);\n      if (remaining_size != 0) {\n        *(uint *)((int)new_memory_block + remaining_size) = (int)(new_memory_block + 1) - (int)new_memory_block;\n      }\n      return (uint)new_memory_block;\n    }\n    *allocated_memory_block = 0xCU;\n    FUN_0000579c(allocated_memory_block);\n  }\n  return 0U;\n}",
            "called": [
                "FUN_00000428",
                "FUN_0000579c",
                "FUN_00005790"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004bd0",
            "calling": [
                "FUN_000068f0",
                "FUN_00005100",
                "FUN_00004248",
                "FUN_000060cc",
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_00004bd0"
        },
        "FUN_00000794": {
            "renaming": {
                "FUN_00000794": "create_integer_array_00000794",
                "extraout_r1": "extra_out",
                "iVar1": "index1",
                "puVar2": "array_ptr",
                "uVar3": "aligned_ptr",
                "iStack_1c": "array_size",
                "iStack_18": "array_index",
                "piStack_14": "array"
            },
            "code": "int * create_integer_array_00000794(void)\n{\n  int extra_out;\n  int index1;\n  undefined4 *array_ptr;\n  uint32_t aligned_ptr;\n  int array_size;\n  int array_index;\n  int *array;\n\n  initialize();\n  *(undefined4 *)(iRam000007d0 + *psRam000007cc * 4) = 0;\n  *piRam000007d4 = *piRam000007d4 - 1;\n  set_to_zero(*puRam000007d8, 0);\n  array_ptr = puRam000007d8;\n  index1 = 0;\n  *puRam000007d8 = 0;\n  allocate_memory();\n  aligned_ptr = (int)array_ptr + index1 & 0xfffffffc;\n  array = (int *)(aligned_ptr - 4);\n  *array = 0x77777777;\n  if (((uint32_t)array & 7) != 0) {\n    array = (int *)(aligned_ptr - 8);\n    *array = 0x88888888;\n  }\n  array[-1] = 0x1000000;\n  array[-2] = index1 << 0xd;\n  array[-3] = DAT_000008b4;\n  array = array - 4;\n  *array = 0;\n  for (array_index = 3; 0 < array_index; array_index = array_index - 1) {\n    array = array - 1;\n    *array = array_index;\n  }\n  array = array - 1;\n  *array = extra_out;\n  for (array_size = 0xb; 3 < array_size; array_size = array_size - 1) {\n    array = array - 1;\n    *array = array_size;\n  }\n  array[-1] = -3;\n  return array - 1;\n}\n",
            "called": [
                "FUN_00000cd0",
                "FUN_00000930",
                "FUN_00000698"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000794",
            "calling": [],
            "imported": false,
            "current_name": "create_integer_array_00000794"
        },
        "FUN_000064bc": {
            "renaming": {
                "FUN_000064bc": "process_data_000064bc",
                "param_1": "input_param",
                "param_2": "data",
                "param_3": "byte_array",
                "param_4": "output_param",
                "puVar1": "byte_array_pointer",
                "iVar2": "loop_result",
                "uVar3": "data_value",
                "ppbVar4": "byte_array_pointer_offset",
                "pbVar5": "byte_array_pointer_offset_2",
                "unaff_r6": "byte_array_pointer_offset_3",
                "pbVar6": "byte_array_offset",
                "iVar7": "loop_count"
            },
            "code": "int process_data_000064bc(uint32_t input_param, uint32_t *data, byte **byte_array, uint32_t *output_param) { \\n\\\n    uint32_t data_value = data[2]; \\n\\\n    if (data[2] == 0) { \\n\\\n        if (data[6] == 0) { \\n\\\n            data_value = 1; \\n\\\n        } \\n\\\n        else { \\n\\\n            data_value = 0xffffffff; \\n\\\n        } \\n\\\n        data[2] = data_value; \\n\\\n    } \\n\\\n    byte **byte_array_pointer = (byte **)PTR_DAT_00006568; \\n\\\n    if (-1 < (int32_t)(*data << 0x1b)) { \\n\\\n        byte **byte_array_pointer_offset = *output_param; \\n\\\n        *output_param = byte_array_pointer_offset + 1; \\n\\\n        *byte_array = *byte_array_pointer_offset; \\n\\\n    } \\n\\\n    int32_t loop_count = 0; \\n\\\n    do { \\n\\\n        data_value = data[6]; \\n\\\n        if (data_value != 0) { \\n\\\n            if (data_value == 1) { \\n\\\n                if (*(char *)(data[5] + (uint32_t)**byte_array) == \"\\0\") { \\n\\\n                    if (loop_count == 0) { \\n\\\n                        return 1; \\n\\\n                    } \\n\\\n                    if (((*data & 0x10) == 0) && (data[3] = data[3] + 1, data[6] != 0)) { \\n\\\n                        **byte_array = 0; \\n\\\n                    } \\n\\\n                    data[4] = loop_count + data[4]; \\n\\\n                    return 0; \\n\\\n                } \\n\\\n            } \\n\\\n            else if ((data_value != 2) || ((int32_t)((uint32_t)(byte)PTR_DAT_00006568[(uint32_t)**byte_array] << 0x1c) < 0)) { \\n\\\n                goto end_of_loop; \\n\\\n            } \\n\\\n        } \\n\\\n        byte *byte_array_pointer_offset = *byte_array; \\n\\\n        if (-1 < (int32_t)(*data << 0x1b)) { \\n\\\n            byte_array_pointer_offset = *byte_array + 1; \\n\\\n            **byte_array = **byte_array_pointer; \\n\\\n        } \\n\\\n        byte *byte_array_pointer_offset_2 = (*byte_array_pointer)[1]; \\n\\\n        *byte_array = *byte_array + 1; \\n\\\n        data_value = data[2] - 1; \\n\\\n        (*byte_array_pointer)[1] = byte_array_pointer_offset_2 - 1; \\n\\\n        loop_count = loop_count + 1; \\n\\\n        data[2] = data_value; \\n\\\n        if ((data_value == 0) || (((int32_t)(byte_array_pointer_offset_2 - 1) < 1 && (iVar2 = (*(code *)data[0x60])(input_param, byte_array, data_value, (code *)data[0x60], output_param), iVar2 != 0)))) { \\n\\\n            goto end_of_loop; \\n\\\n        } \\n\\\n    } while (true); \\n\\\n    end_of_loop: \\n\\\n    return 0; \\n\\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000064bc",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "process_data_000064bc"
        },
        "FUN_00002970": {
            "renaming": {
                "FUN_00002970": "clear_bit_in_uint32_at_offset_from_dat_00002990_00002970",
                "DAT_00002990": "dat_00002990",
                "PTR_": "ptr_"
            },
            "code": "void clear_bit_in_uint32_at_offset_from_dat_00002990_00002970(void)\n{\n  uint32_t* target_ptr = (uint32_t*)(DAT_00002990 + 0x14);\n  uint32_t mask = 0xFFFFFFEF;\n  *target_ptr &= mask;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002970",
            "calling": [
                "FUN_000026e4"
            ],
            "imported": false,
            "current_name": "clear_bit_in_uint32_at_offset_from_dat_00002990_00002970"
        },
        "FUN_00000dc0": {
            "renaming": {
                "FUN_00000dc0": "execute_function_00000dc0",
                "FUN_00000cc0": "call_another_function"
            },
            "code": "void execute_function_00000dc0(void)\n{\n  call_another_function();\n  return;\n}",
            "called": [
                "FUN_00000cc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dc0",
            "calling": [],
            "imported": false,
            "current_name": "execute_function_00000dc0"
        },
        "FUN_00000d0c": {
            "renaming": {
                "FUN_00000d0c": "enableIRQinterrupts_if_privileged_00000d0c",
                "param_1": "interrupt_type",
                "bVar1": "is_privileged"
            },
            "code": "void enableIRQinterrupts_if_privileged_00000d0c(uint32_t interrupt_type) {\n  bool is_privileged = (bool)isCurrentModePrivileged();\n  if (is_privileged) {\n    enableIRQinterrupts((interrupt_type & 1) == 1);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d0c",
            "calling": [
                "FUN_00001c84",
                "FUN_00000428",
                "FUN_000024bc",
                "FUN_000010d4",
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "enableIRQinterrupts_if_privileged_00000d0c"
        },
        "FUN_00003d94": {
            "renaming": {
                "FUN_00003d94": "execute_function_00003d94",
                "param_1": "function_address",
                "param_2": "parameter",
                "uVar1": "result"
            },
            "code": "int execute_function_00003d94(int function_address, int parameter){\n  int result;\n  if (function_address == 0) {\n    result = -19;\n  }\n  else {\n    result = (**(int (**)(int, int))(function_address + 0x4))(*(int *)(function_address + 0x4), parameter);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d94",
            "calling": [
                "FUN_0000305c"
            ],
            "imported": false,
            "current_name": "execute_function_00003d94"
        },
        "FUN_0000579c": {
            "renaming": {
                "FUN_0000579c": "do_nothing_with_ptr_data_0000579c",
                "PTR_DAT_000057a4": "PTR_DATA",
                "do_nothing_000045ec": "do_nothing"
            },
            "code": "void do_nothing_with_ptr_data_0000579c(void)\n{\n  do_nothing(PTR_DAT_000057a4);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000579c",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": false,
            "current_name": "do_nothing_with_ptr_data_0000579c"
        },
        "FUN_000015d0": {
            "renaming": {
                "FUN_000015d0": "copy_data_to_memory_000015d0",
                "param_1": "starting_index",
                "param_2": "memory_index",
                "param_3": "data_length",
                "iVar1": "memory_address",
                "local_c": "i"
            },
            "code": "void copy_data_to_memory_000015d0(int starting_index, int memory_index, uint data_length) {\n  int memory_address = *(int *)(PTR_DAT_00001624 + starting_index * 0x20);\n  for (uint i = 0; i < data_length; i++) {\n    do {\n    } while (-1 < *(char *)(memory_address + 4));\n    *(undefined *)(memory_address + 7) = *(undefined *)(i + memory_index);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000015d0",
            "calling": [
                "FUN_00000e38"
            ],
            "imported": false,
            "current_name": "copy_data_to_memory_000015d0"
        },
        "FUN_00005e68": {
            "renaming": {
                "FUN_00005e68": "process_data_00005e68",
                "param_1": "data1",
                "param_2": "data2",
                "param_3": "data3",
                "param_4": "data4",
                "local_80": "result1",
                "local_7c": "local5",
                "local_74": "constant1",
                "local_72": "constant2",
                "local_70": "local1",
                "uStack_8": "local3",
                "uStack_4": "local4",
                "local_5c": "global_array1",
                "local_4c": "local6",
                "local_38": "local7",
                "local_6c": "result2",
                "FUN_000061cc": "function2",
                "*DAT_00005eb8": "global_pointer1",
                "FUN_00005ecc": "function1"
            },
            "code": "void process_data_00005e68(int data1, int data2, int data3, int data4)\n{\n  int result1;\n  int result2;\n  short constant1 = 0x204;\n  short constant2 = 0xffff;\n  int local1 = data1;\n  int local2 = data1;\n  int local3 = data3;\n  int local4 = data4;\n  result1 = function1();\n  char* local5 = global_array1;\n  int local6 = 0;\n  int local7 = 0;\n  result2 = function2(**DAT_00005eb8, &local1, data2, &local3);\n  return;\n}",
            "called": [
                "FUN_00005ecc",
                "FUN_000061cc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e68",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "process_data_00005e68"
        },
        "FUN_00000dcc": {
            "renaming": {
                "FUN_00000dcc": "set_data_to_memory_00000dcc",
                "DAT_00000df0": "data_pointer"
            },
            "code": "void set_data_to_memory_00000dcc(void)\n{\n  int* DAT_00000df0 = DAT_00000df0;\n  *(DAT_00000df0 + 7) = 0xc520;\n  *(DAT_00000df0 + 7) = 0xd928;\n  *DAT_00000df0 = 0xd2;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dcc",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": false,
            "current_name": "set_data_to_memory_00000dcc"
        },
        "FUN_0000285c": {
            "renaming": {
                "FUN_0000285c": "set_flag_and_value_0000285c",
                "param_1": "value_to_set",
                "puVar1": "data_pointer",
                "DAT_00002890": "PTR_DATA_START"
            },
            "code": "void set_flag_and_value_0000285c(unsigned int value_to_set)\n{\n  unsigned int *data_pointer;\n  data_pointer = DAT_00002890;\n  data_pointer[5] = data_pointer[5] & 0xffffffef;\n  *data_pointer = value_to_set;\n  data_pointer[5] = data_pointer[5] | 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000285c",
            "calling": [
                "FUN_00002600"
            ],
            "imported": false,
            "current_name": "set_flag_and_value_0000285c"
        },
        "FUN_00000e58": {
            "renaming": {
                "FUN_00000e58": "run_indefinitely_00000e58",
                "FUN_00000cd0": "initialize"
            },
            "code": "void run_indefinitely_00000e58(void)\n{\n  initialize();\n  while(true)\n  {\n    // do nothing\n  }\n}",
            "called": [
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e58",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "run_indefinitely_00000e58"
        },
        "FUN_00001778": {
            "renaming": {
                "FUN_00001778": "set_flag_00001778",
                "DAT_000017d0": "data_ptr",
                "DAT_000017d8": "data_len",
                "PTR_": "",
                "*(byte *)(DAT_000017d0 + 1)": "*flag_ptr",
                "FUN_00001710": "send_data"
            },
            "code": "void set_flag_00001778(byte *DAT_000017d0, int DAT_000017d8) {\n  byte *(byte *)(DAT_000017d0 + 1) = DAT_000017d0 + 1;\n  *(byte *)(DAT_000017d0 + 1) = (*(byte *)(DAT_000017d0 + 1) & 0xCF) | 0x20;\n  send_data(DAT_000017d0, DAT_000017d8);\n  return;\n}",
            "called": [
                "FUN_00001710",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001778",
            "calling": [
                "FUN_000019c0",
                "FUN_0000191c"
            ],
            "imported": false,
            "current_name": "set_flag_00001778"
        },
        "FUN_000026d8": {
            "renaming": {
                "FUN_000026d8": "initialize_system_000026d8",
                "FUN_0000294c": "initialize_hardware"
            },
            "code": "void initialize_system_000026d8(void)\n{\n  initialize_hardware();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026d8",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "initialize_system_000026d8"
        },
        "FUN_00000566": {
            "renaming": {
                "FUN_00000566": "leading_zeroes_of_32bit_number_00000566",
                "param_1": "num",
                "bVar1": "byte3",
                "bVar2": "byte0",
                "bVar3": "byte1",
                "bVar4": "byte2",
                "uVar5": "leading_zeroes"
            },
            "code": "#include <stdint.h>\n\nuint32_t leading_zeroes_of_32bit_number_00000566(uint32_t x);\n\nuint32_t leading_zeroes_of_32bit_number_00000566(uint32_t num)\n{\n    uint8_t byte0 = (uint8_t)num;\n    uint8_t byte1 = (uint8_t)(num >> 8);\n    uint8_t byte2 = (uint8_t)(num >> 16);\n    uint8_t byte3 = (uint8_t)(num >> 24);\n\n    uint32_t leading_zeroes = leading_zeroes_of_32bit_number_00000566(\n            ((uint32_t)(byte0 & 0x01) << 31) |\n            ((uint32_t)(byte0 & 0x02) << 29) |\n            ((uint32_t)(byte0 & 0x04) << 27) |\n            ((uint32_t)(byte0 & 0x08) << 25) |\n            ((uint32_t)(byte0 & 0x10) << 23) |\n            ((uint32_t)(byte0 & 0x20) << 21) |\n            ((uint32_t)(byte0 & 0x40) << 19) |\n            ((uint32_t)(byte0 & 0x80) << 17) |\n            ((uint32_t)(byte1 & 0x01) << 15) |\n            ((uint32_t)(byte1 & 0x02) << 13) |\n            ((uint32_t)(byte1 & 0x04) << 11) |\n            ((uint32_t)(byte1 & 0x08) << 9) |\n            ((uint32_t)(byte1 & 0x10) << 7) |\n            ((uint32_t)(byte1 & 0x20) << 5) |\n            ((uint32_t)(byte1 & 0x40) << 3) |\n            ((uint32_t)(byte1 & 0x80) << 1) |\n            ((uint32_t)(byte2 & 0x01) << 23) |\n            ((uint32_t)(byte2 & 0x02) << 21) |\n            ((uint32_t)(byte2 & 0x04) << 19) |\n            ((uint32_t)(byte2 & 0x08) << 17) |\n            ((uint32_t)(byte2 & 0x10) << 15) |\n            ((uint32_t)(byte2 & 0x20) << 13) |\n            ((uint32_t)(byte2 & 0x40) << 11) |\n            ((uint32_t)(byte2 & 0x80) << 9) |\n            ((uint32_t)(byte3 & 0x01) << 7) |\n            ((uint32_t)(byte3 & 0x02) << 5) |\n            ((uint32_t)(byte3 & 0x04) << 3) |\n            ((uint32_t)(byte3 & 0x08) << 1)\n    );\n\n    if (num == 0) {\n        leading_zeroes = 0xffffffff;\n    }\n\n    return leading_zeroes;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000566",
            "calling": [
                "FUN_00000610"
            ],
            "imported": false,
            "current_name": "leading_zeroes_of_32bit_number_00000566"
        },
        "FUN_00001d08": {
            "renaming": {
                "FUN_00001d08": "calculate_offset_00001d08",
                "param_1": "address",
                "param_2": "offset"
            },
            "code": "int calculate_offset_00001d08(uint32_t address, int offset) {\n    uint32_t upper_bits = address & 0xf0000000;\n    uint32_t lower_bits = address & 0xfffff;\n    return offset * 4 + (upper_bits | (lower_bits << 5)) + 0x2000000;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d08",
            "calling": [
                "FUN_00001d3a"
            ],
            "imported": false,
            "current_name": "calculate_offset_00001d08"
        },
        "FUN_000031fc": {
            "renaming": {
                "FUN_000031fc": "calculate_result_000031fc",
                "param_1": "input_value",
                "param_2": "input_range",
                "param_3": "initial_value",
                "iVar2": "range",
                "bVar1": "range_byte",
                "iVar3": "value",
                "DAT_00003280": "DAT_CONSTANT_1",
                "DAT_00003284": "DAT_CONSTANT_2",
                "DAT_00003288": "DAT_CONSTANT_3"
            },
            "code": "int calculate_result_000031fc(int input_value, int input_range, int initial_value) {\n                      int range = input_range;\n                      if (input_range < 3) {\n                        range = 1;\n                      }\n                      byte range_byte = (byte)range;\n                      if (2 < input_range) {\n                        range_byte = 0;\n                      }\n                      input_value = input_value - (uint)range_byte;\n                      int value = input_value;\n                      if (input_value < 0) {\n                        value = input_value + 3;\n                      }\n                      int result = (((value >> 2) + input_value) - (int)((longlong)DAT_00003280 * (longlong)input_value >> 0x25)) +\n                                    (int)((longlong)DAT_00003280 * (longlong)input_value >> 0x27) +\n                                    *(int *)(DAT_00003284 + (input_range + -1) * 4) + initial_value;\n                      return result + (((int)((ulonglong)((longlong)DAT_00003288 * (longlong)result) >> 0x20) +\n                                         result >> 2) - (result >> 0x1f)) * -7;\n                    }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031fc",
            "calling": [
                "FUN_0000328c"
            ],
            "imported": false,
            "current_name": "calculate_result_000031fc"
        },
        "FUN_000016ec": {
            "renaming": {
                "FUN_000016ec": "set_flag_to_true_000016ec",
                "param_1": "address",
                "param_2": "flag",
                "puVar1": "flag_address",
                "*puVar1": "*flag_address",
                "undefined": "unsigned char",
                "undefined4": "int",
                "FUN_00001696": "get_address"
            },
            "code": "void set_flag_to_true_000016ec(int address, unsigned char flag){\n  unsigned char* flag_address = (unsigned char*)get_address(address, flag);\n  *flag_address = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016ec",
            "calling": [
                "FUN_0000182c",
                "FUN_00001a18",
                "FUN_00001a60",
                "FUN_00001778",
                "FUN_00001a3c"
            ],
            "imported": false,
            "current_name": "set_flag_to_true_000016ec"
        },
        "FUN_00005100": {
            "renaming": {
                "FUN_00005100": "parse_data_00005100",
                "puVar1": "pointer1",
                "puVar2": "pointer2",
                "puVar3": "pointer3",
                "uVar4": "var1",
                "iVar5": "var2",
                "pcVar6": "string1",
                "iVar7": "var3",
                "iVar8": "var4",
                "cVar9": "char1",
                "pcVar10": "string2",
                "bVar11": "bool1",
                "puVar12": "pointer4",
                "piVar13": "pointer5",
                "puVar14": "pointer6",
                "piVar15": "pointer7",
                "local_3c": "ushort1",
                "local_3a": "ushort2",
                "local_38": "ushort3",
                "local_36": "ushort4",
                "local_34": "ushort5",
                "local_32": "ushort6",
                "local_30": "var5",
                "local_2c": "string_array1"
            },
            "code": "\nvoid parse_data_00005100(void)\n\n{\n  undefined *pointer1;\n  undefined *pointer2;\n  undefined4 *pointer3;\n  undefined4 var1;\n  int var2;\n  char *string1;\n  int var3;\n  int var4;\n  char char1;\n  char *string2;\n  bool bool1;\n  ushort *pointer4;\n  int *pointer5;\n  ushort *pointer6;\n  int *pointer7;\n  ushort ushort1;\n  ushort ushort2;\n  ushort ushort3;\n  ushort ushort4;\n  ushort ushort5;\n  ushort ushort6;\n  int var5;\n  char *string_array1 [2];\n  \n  var1 = *DAT_00005108;\n  var2 = FUN_000056b0();\n  pointer1 = PTR_DAT_000053d8;\n  string1 = (char *)FUN_000056a0(var1,PTR_DAT_000053d4);\n  pointer2 = PTR_DAT_000053e0;\n  if (string1 == (char *)0x0) {\n    *(undefined4 *)PTR_DAT_000053dc = 0;\n    *(undefined4 *)PTR_DAT_000053e4 = 0;\n    pointer3 = DAT_000053e8;\n    var1 = *(undefined4 *)pointer1;\n    *DAT_000053e8 = pointer2;\n    pointer3[1] = pointer2;\n    FUN_00005780(var1);\n    *(undefined4 *)pointer1 = 0;\n  }\n  else if ((*(int *)pointer1 == 0) || (var3 = FUN_00004e52(), var3 != 0)) {\n    FUN_00005780(*(undefined4 *)pointer1);\n    var3 = FUN_00005ecc(string1);\n    var3 = FUN_00004bd0(var1,var3 + 1);\n    *(int *)pointer1 = var3;\n    if (var3 != 0) {\n      FUN_00005ebc(var3,string1);\n    }\n    if (*string1 == ':') {\n      string1 = string1 + 1;\n    }\n    var3 = FUN_00005e68(string1,PTR_s__10__0_9_____n_000053f0,PTR_DAT_000053ec,&var5);\n    if (0 < var3) {\n      string2 = string1 + var5;\n      if (string1[var5] == '-') {\n        string2 = string2 + 1;\n        var3 = -1;\n      }\n      else {\n        if (string1[var5] == '+') {\n          string2 = string2 + 1;\n        }\n        var3 = 1;\n      }\n      ushort2 = 0;\n      ushort3 = 0;\n      pointer4 = &ushort2;\n      pointer5 = &var5;\n      pointer6 = &ushort3;\n      pointer7 = &var5;\n      var4 = FUN_00005e68(string2,PTR_s__hu_n__hu_n__hu_n_000053f4,&ushort1,&var5,&ushort2,\n                           &var5,&ushort3,&var5);\n      pointer1 = PTR_DAT_00005400;\n      if (0 < var4) {\n        *(uint *)(var2 + 0x28) =\n             ((uint)ushort1 * 0xe10 + (uint)ushort2 * 0x3c + (uint)ushort3) * var3;\n        pointer3 = DAT_000053e8;\n        *DAT_000053e8 = PTR_DAT_000053ec;\n        string2 = string2 + var5;\n        var3 = FUN_00005e68(string2,PTR_s__10__0_9_____n_000053f0,pointer1,&var5,pointer4,pointer5,\n                             pointer6,pointer7);\n        if (var3 < 1) {\n          pointer3[1] = *pointer3;\n          *(undefined4 *)PTR_DAT_000053dc = *(undefined4 *)(var2 + 0x28);\n          *(undefined4 *)PTR_DAT_000053e4 = 0;\n        }\n        else {\n          pointer3[1] = pointer1;\n          string1 = string2 + var5;\n          if (string2[var5] == '-') {\n            string1 = string1 + 1;\n            var3 = -1;\n          }\n          else {\n            if (string2[var5] == '+') {\n              string1 = string1 + 1;\n            }\n            var3 = 1;\n          }\n          ushort1 = 0;\n          ushort2 = 0;\n          ushort3 = 0;\n          var5 = 0;\n          var4 = FUN_00005e68(string1,PTR_s__hu_n__hu_n__hu_n_000053f4,&ushort1,&var5,&ushort2\n                               ,&var5,&ushort3,&var5);\n          if (var4 < 1) {\n            var3 = *(int *)(var2 + 0x28) + -0xe10;\n          }\n          else {\n            var3 = ((uint)ushort1 * 0xe10 + (uint)ushort2 * 0x3c + (uint)ushort3) * var3;\n          }\n          *(int *)(var2 + 0x50) = var3;\n          string1 = string1 + var5;\n          bool1 = false;\n          var3 = var2;\n          while( true ) {\n            if (*string1 == ',') {\n              string1 = string1 + 1;\n            }\n            char1 = *string1;\n            if (char1 == 'M') {\n              var4 = FUN_00005e68(string1,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&ushort4,&var5,\n                                   &ushort5,&var5,&ushort6,&var5);\n              if (var4 != 3) {\n                return;\n              }\n              if (0xb < ushort4 - 1) {\n                return;\n              }\n              if (4 < ushort5 - 1) {\n                return;\n              }\n              if (6 < ushort6) {\n                return;\n              }\n              *(uint *)(var3 + 0xc) = (uint)ushort4;\n              *(uint *)(var3 + 0x10) = (uint)ushort5;\n              *(undefined *)(var3 + 8) = 0x4d;\n              *(uint *)(var3 + 0x14) = (uint)ushort6;\n              string2 = string1 + var5;\n            }\n            else {\n              if (char1 == 'J') {\n                string1 = string1 + 1;\n              }\n              else {\n                char1 = 'D';\n              }\n              ushort6 = FUN_00005fd8(string1,string_array1,10);\n              string2 = string_array1[0];\n              if (string_array1[0] == string1) {\n                if (bool1) {\n                  *(undefined *)(var2 + 0x30) = 0x4d;\n                  *(undefined4 *)(var2 + 0x34) = 0xb;\n                  *(undefined4 *)(var2 + 0x38) = 1;\n                  *(undefined4 *)(var2 + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(var2 + 8) = 0x4d;\n                  *(undefined4 *)(var2 + 0xc) = 3;\n                  *(undefined4 *)(var2 + 0x10) = 2;\n                  *(undefined4 *)(var2 + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(var3 + 8) = char1;\n                *(uint *)(var3 + 0x14) = (uint)ushort6;\n              }\n            }\n            ushort1 = 2;\n            ushort2 = 0;\n            ushort3 = 0;\n            var5 = 0;\n            if (*string2 == '/') {\n              FUN_00005e68(string2,PTR_DAT_000053fc,&ushort1,&var5,&ushort2,&var5,\n                           &ushort3,&var5);\n            }\n            *(uint *)(var3 + 0x18) =\n                 (uint)ushort1 * 0xe10 + (uint)ushort2 * 0x3c + (uint)ushort3;\n            var3 = var3 + 0x28;\n            string1 = string2 + var5;\n            if (bool1) break;\n            bool1 = true;\n          }\n          FUN_00004f98(*(undefined4 *)(var2 + 4));\n          var3 = *(int *)(var2 + 0x28);\n          *(int *)PTR_DAT_000053dc = var3;\n          var3 = *(int *)(var2 + 0x50) - var3;\n          if (var3 != 0) {\n            var3 = 1;\n          }\n          *(int *)PTR_DAT_000053e4 = var3;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005780",
                "FUN_00005ecc",
                "FUN_00004bd0",
                "FUN_00005e68",
                "FUN_00004e52",
                "FUN_00005fd8",
                "FUN_000056b0",
                "FUN_00005ebc",
                "FUN_00004f98",
                "FUN_000056a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005100",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "parse_data_00005100"
        },
        "FUN_00005584": {
            "renaming": {
                "FUN_00005584": "divide_and_remainder_00005584",
                "param_1": "result",
                "param_2": "dividend",
                "param_3": "divisor",
                "uVar1": "remainder",
                "uVar2": "quotient"
            },
            "code": "void divide_and_remainder_00005584(uint *result, uint dividend, uint divisor)\n{\n  uint quotient;\n  uint remainder;\n  quotient = dividend / divisor;\n  remainder = dividend % divisor;\n  if ((int)dividend < 0) {\n    if (0 < (int)remainder) {\n      quotient--;\n      remainder += divisor;\n    }\n  }\n  else if ((int)remainder < 0) {\n    quotient++;\n    remainder -= divisor;\n  }\n  *result = quotient;\n  result[1] = remainder;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005584",
            "calling": [
                "FUN_00004634"
            ],
            "imported": false,
            "current_name": "divide_and_remainder_00005584"
        },
        "FUN_00004248": {
            "renaming": {
                "FUN_00004248": "allocate_memory_for_array_of_structs_00004248",
                "param_1": "base_address",
                "param_2": "array_size",
                "puVar1": "struct_array_ptr",
                "iVar2": "struct_array_size",
                "FUN_00004bd0": "allocate_memory",
                "FUN_00004622": "initialize_struct_array"
            },
            "code": "undefined4 * allocate_memory_for_array_of_structs_00004248(undefined4 base_address, int array_size)\n{\n  undefined4 *struct_array_ptr;\n  int struct_array_size = (array_size - 1) * sizeof(StructType);\n  \n  struct_array_ptr = (undefined4 *)allocate_memory(base_address,struct_array_size + sizeof(int) + sizeof(undefined4 *));\n  if (struct_array_ptr != (undefined4 *)0x0) {\n    *struct_array_ptr = 0;\n    struct_array_ptr[1] = array_size;\n    struct_array_ptr[2] = struct_array_ptr + 3;\n    initialize_struct_array(struct_array_ptr + 3,0,struct_array_size);\n  }\n  return struct_array_ptr;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004248",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "allocate_memory_for_array_of_structs_00004248"
        },
        "FUN_00001da2": {
            "renaming": {
                "FUN_00001da2": "get_bits_from_ushort_00001da2",
                "param_1": "input_value",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "ushort get_bits_from_ushort_00001da2(ushort input_value) {\n    ushort shifted_value = input_value >> 6;\n    ushort masked_value = shifted_value & 7;\n    return masked_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001da2",
            "calling": [
                "FUN_00001f80",
                "FUN_00001ddc"
            ],
            "imported": false,
            "current_name": "get_bits_from_ushort_00001da2"
        },
        "FUN_00001ec4": {
            "renaming": {
                "FUN_00001ec4": "calculateAndPrintResult_00001ec4",
                "param_1": "input1",
                "param_2": "input2",
                "FUN_00001e0c": "calculate",
                "FUN_00001e44": "printResult",
                "uVar1": "result"
            },
            "code": "void calculateAndPrintResult_00001ec4(int input1, int input2)\n{\n  int result = calculate(input1, input2);\n  printResult(input1, input2, result);\n  return;\n}",
            "called": [
                "FUN_00001e44",
                "FUN_00001e0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ec4",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "calculateAndPrintResult_00001ec4"
        },
        "FUN_00002744": {
            "renaming": {
                "FUN_00002744": "set_data_00002744",
                "param_1": "data",
                "param_2": "value",
                "DAT_00002790": "data_offset",
                "DAT_00002794": "data_offset"
            },
            "code": "void set_data_00002744(byte data, uint value) {\n    if (data < 0) {\n        *(char *)((data & 0xf) + DAT_00002790 + 0x14) = (char)((value & 0xff) << 4);\n    }\n    else {\n        *(char *)((char)data + DAT_00002790 + 0x300) = (char)((value & 0xff) << 4);\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002744",
            "calling": [
                "FUN_00002894"
            ],
            "imported": false,
            "current_name": "set_data_00002744"
        },
        "FUN_00002624": {
            "renaming": {
                "FUN_00002624": "copy_data_to_buffer_and_return_zero_00002624",
                "param_1": "buffer",
                "local_10": "result",
                "uStack_c": "counter",
                "FUN_0000281c": "get_data_from_somewhere",
                "FUN_0000443c": "copy_data_to_buffer"
            },
            "code": "int copy_data_to_buffer_and_return_zero_00002624(void* buffer, int size)\n{\n  int result = get_data_from_somewhere();\n  int counter = 0;\n  copy_data_to_buffer(&result, buffer, size);\n  return 0;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_0000281c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002624",
            "calling": [
                "FUN_00003444"
            ],
            "imported": false,
            "current_name": "copy_data_to_buffer_and_return_zero_00002624"
        },
        "FUN_00001e0c": {
            "renaming": {
                "FUN_00001e0c": "get_bits_at_position_00001e0c",
                "param_1": "position",
                "param_2": "data",
                "PTR_DAT_00001e40": "data_pointer"
            },
            "code": "uint get_bits_at_position_00001e0c(int position, uint data) {\n    uint* PTR_DAT_00001e40 = (uint*)(PTR_DAT_00001e40 + ((position >> 3) + position * 4) * 4);\n    uint shifted_data = (*PTR_DAT_00001e40 >> ((data & 7) << 2)) & 0xf;\n    return shifted_data;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e0c",
            "calling": [
                "FUN_00002028",
                "FUN_00001ec4"
            ],
            "imported": false,
            "current_name": "get_bits_at_position_00001e0c"
        },
        "FUN_00000ef8": {
            "renaming": {
                "FUN_00000ef8": "do_nothing_00000ef8"
            },
            "code": "\nvoid do_nothing_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ef8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "do_nothing_00000ef8"
        },
        "FUN_000041d0": {
            "renaming": {
                "FUN_000041d0": "process_data_000041d0",
                "param_1": "data",
                "piVar5": "data_ptr",
                "uVar7": "result",
                "puVar9": "data_ptr_orig",
                "iVar2": "data_ptr",
                "iVar4": "count",
                "iVar6": "data_ptr_inner"
            },
            "code": "uint process_data_000041d0(int data, undefined4 param_2, undefined4 param_3)\n{\n  code *callback_fn = DAT_000041ec;\n  if (data == 0) {\n    int data_ptr = *(int *)PTR_DAT_000041e8;\n    int *piVar5 = (int *)(data_ptr + 0x48);\n    uint result = 0;\n    undefined *data_ptr_orig = PTR_DAT_000041e8;\n    do {\n      int count = piVar5[1];\n      int data_ptr_inner = piVar5[2];\n      while (count = count + -1, -1 < count) {\n        if ((1 < *(ushort *)(data_ptr_inner + 0xc)) && (iVar4 = *(short *)(data_ptr_inner + 0xe) + 1, iVar4 != 0)) {\n          uint callback_result = (*callback_fn)(data_ptr,data_ptr_inner,param_3,iVar4,data_ptr_orig);\n          result = result | callback_result;\n        }\n        data_ptr_inner = data_ptr_inner + 0x68;\n      }\n      piVar5 = (int *)*piVar5;\n    } while (piVar5 != (int *)0x0);\n    return result;\n  }\n  uint result = FUN_00004158(*DAT_000041f0,data);\n  return result;\n}",
            "called": [
                "FUN_00004158"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041d0",
            "calling": [
                "FUN_00002e48"
            ],
            "imported": false,
            "current_name": "process_data_000041d0"
        },
        "FUN_0000459c": {
            "renaming": {
                "FUN_0000459c": "execute_functions_0000459c",
                "puVar1": "start",
                "puVar2": "end",
                "iVar3": "num_functions",
                "ppcVar4": "function_pointers",
                "iVar5": "i"
            },
            "code": "void execute_functions_0000459c(void)\n{\n  undefined *start = PTR_DAT_000045d4;\n  undefined *end = PTR_DAT_000045e0;\n  int num_functions = (int)end - (int)start;\n  code **function_pointers = (code **)start;\n  for (int i = 0; i < num_functions >> 2; i++) {\n    (**function_pointers)();\n    function_pointers++;\n  }\n  FUN_00000410();\n  function_pointers = (code **)PTR_DAT_000045dc;\n  num_functions = (int)PTR_DAT_000045e0 - (int)PTR_DAT_000045dc;\n  for (int i = 0; i < num_functions >> 2; i++) {\n    (**function_pointers)();\n    function_pointers++;\n  }\n  return;\n}",
            "called": [
                "FUN_00000410"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000459c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "execute_functions_0000459c"
        },
        "FUN_000014c4": {
            "renaming": {
                "FUN_000014c4": "set_data_000014c4",
                "param_1": "index",
                "param_2": "value",
                "pbVar1": "data_ptr",
                "uVar2": "data_size",
                "uVar3": "shifted_data",
                "PTR_DAT_000015cc": "data_array"
            },
            "code": "void set_data_000014c4(int index, uint value)\n{\n  byte *data_ptr = *(byte **)(PTR_DAT_000015cc + index * 0x20);\n  uint data_size = *(uint *)(PTR_DAT_000015cc + index * 0x20 + 4);\n  data_ptr[3] = data_ptr[3] & 0xf3;\n  data_ptr[2] = PTR_DAT_000015cc[index * 0x20 + 0x1d];\n  uint shift_size = value << 4;\n  uint shifted_data = data_size / shift_size;\n  *data_ptr = (byte)(shifted_data >> 8) & 0x1f;\n  data_ptr[1] = (byte)shifted_data;\n  data_ptr[10] = (byte)((data_size << 2) / value + 1 >> 1) & 0x1f;\n  data_ptr[0x10] = data_ptr[0x10] | 0x88;\n  if ((data_ptr[0x10] & 0x70) == 0) {\n    data_ptr[0x13] = 0;\n  }\n  else {\n    data_ptr[0x13] = (char)(2 << (data_ptr[0x10] >> 4 & 7)) - 1;\n  }\n  data_ptr[0x15] = 1;\n  data_ptr[0x11] = 0xc0;\n  data_ptr[3] = data_ptr[3] | 0x2c;\n  FUN_00001318((int)(char)PTR_DAT_000015cc[index * 0x20 + 0x14]);\n  return;\n}",
            "called": [
                "FUN_00001318"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000014c4",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "set_data_000014c4"
        },
        "FUN_00004b34": {
            "renaming": {
                "FUN_00004b34": "insert_node_at_end_00004b34",
                "param_1": "head",
                "param_2": "data",
                "param_3": "size",
                "param_4": "error_code",
                "puVar1": "new_node",
                "piVar2": "current_node",
                "extraout_r1": "prev_node",
                "ppiVar3": "is_error",
                "ppiVar4": "prev_node",
                "ppiVar5": "current_node",
                "ppiVar6": "new_node",
                "bVar7": "is_error",
                "PTR_DAT_00004bcc": "head"
            },
            "code": "void insert_node_at_end_00004b34(int *PTR_DAT_00004bcc, int data, int size, int *error_code)\n{\n  int *new_node, *current_node, *prev_node;\n  bool is_error = false;\n\n  if (size == 0) {\n    return;\n  }\n\n  new_node = (int *)malloc(sizeof(int));\n  if (new_node == NULL) {\n    *error_code = 0xC;\n    return;\n  }\n\n  new_node[0] = data;\n  new_node[1] = 0;\n\n  current_node = PTR_DAT_00004bcc;\n  while (current_node != NULL) {\n    prev_node = current_node;\n    current_node = (int *)current_node[1];\n  }\n\n  if (prev_node != NULL) {\n    prev_node[1] = (int)new_node;\n  } else {\n    PTR_DAT_00004bcc = new_node;\n  }\n\n  if (is_error) {\n    free(new_node);\n  }\n\n  *error_code = 0;\n}\n",
            "called": [
                "FUN_0000579c",
                "FUN_00005790"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004b34",
            "calling": [
                "FUN_00005780",
                "FUN_00006192",
                "FUN_0000404c",
                "FUN_00006768",
                "FUN_000054a8",
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "insert_node_at_end_00004b34"
        },
        "FUN_000004f2": {
            "renaming": {
                "FUN_000004f2": "set_param_to_19_000004f2",
                "*param_1": "*param",
                "0x13": "19",
                "0xffffffff": "-1"
            },
            "code": "int set_param_to_19_000004f2(int *param){\n  *param = 19;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004f2",
            "calling": [
                "FUN_00004e26",
                "FUN_00004dee"
            ],
            "imported": false,
            "current_name": "set_param_to_19_000004f2"
        },
        "FUN_00004e66": {
            "renaming": {
                "FUN_00004e66": "compare_byte_arrays_00004e66",
                "param_1": "array1",
                "param_2": "array1_len",
                "param_3": "array2_len",
                "pbVar1": "array1_ptr",
                "pbVar2": "array2_ptr",
                "uVar3": "array1_byte"
            },
            "code": "int compare_byte_arrays_00004e66(byte *array1, int array1_len, byte *array2, int array2_len)\n{\n  byte *array1_ptr = array1;\n  byte *array2_ptr = array2;\n  uint8_t array1_byte;\n  uint8_t array2_byte;\n  \n  if (array2_len != 0) {\n    array2_ptr = (byte *)(array2_len + array2_ptr - 1);\n    array1_ptr = array1;\n    do {\n      array1_byte = (uint8_t)*array1_ptr;\n      array2_ptr = array2_ptr + 1;\n      if ((array1_byte != *array2_ptr) || (array1_ptr + 1 == array1 + array1_len)) break;\n      array1_ptr = array1_ptr + 1;\n    } while (array1_byte != 0);\n    array1_len = array1_byte - *array2_ptr;\n  }\n  return array1_len;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e66",
            "calling": [
                "FUN_00003524",
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "compare_byte_arrays_00004e66"
        },
        "FUN_00005ecc": {
            "renaming": {
                "FUN_00005ecc": "find_end_of_string_00005ecc",
                "param_1": "str",
                "pcVar2": "current_ptr",
                "pcVar3": "current_char_ptr",
                "cVar1": "current_char"
            },
            "code": "char* find_end_of_string_00005ecc(char* str) {\n  char current_char;\n  char* current_ptr = str;\n  do {\n    current_ptr++;\n    current_char = *current_ptr;\n  } while (current_char != '\\0');\n  return current_ptr + (-1 - (int)str);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ecc",
            "calling": [
                "FUN_00005100",
                "FUN_00005e68"
            ],
            "imported": false,
            "current_name": "find_end_of_string_00005ecc"
        },
        "FUN_0000129c": {
            "renaming": {
                "FUN_0000129c": "send_data_to_device_0000129c",
                "param_1": "device_data",
                "FUN_00002434": "transmit_data"
            },
            "code": "void send_data_to_device_0000129c(void* device_data)\n{\n  transmit_data(device_data, 1);\n  return;\n}",
            "called": [
                "FUN_00002434"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000129c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": false,
            "current_name": "send_data_to_device_0000129c"
        },
        "FUN_00001628": {
            "renaming": {
                "FUN_00001628": "check_and_call_function_00001628",
                "param_1": "index",
                "PTR_DAT_00001680": "ptr_1",
                "PTR_DAT_00001684": "ptr_3",
                "byte": "byte",
                "int": "int",
                "code": "code",
                "undefined4": "int",
                "undefined": "undefined",
                "arg1": "arg1",
                "arg2": "arg2"
            },
            "code": "void check_and_call_function_00001628(int index)\n{\n  int* PTR_DAT_00001680 = *(int *)(PTR_DAT_00001680 + index * 0x20);\n  byte* ptr_2 = *(byte *)(PTR_DAT_00001680 + 4);\n  int* PTR_DAT_00001684 = *(int *)(PTR_DAT_00001684 + index * 8);\n  if ((ptr_2 & 0x20) && (PTR_DAT_00001684 != 0)) {\n    code* func_ptr = *(code **)(PTR_DAT_00001684 + index * 8);\n    int arg1 = *(int *)(PTR_DAT_00001684 + index * 8 + 4);\n    undefined arg2 = *(undefined *)(PTR_DAT_00001680 + 7);\n    (*func_ptr)(arg1, arg2);\n  }\n  FUN_00001348();\n  return;\n}",
            "called": [
                "FUN_00001348"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001628",
            "calling": [
                "FUN_00001688"
            ],
            "imported": false,
            "current_name": "check_and_call_function_00001628"
        },
        "FUN_00001748": {
            "renaming": {
                "FUN_00001748": "set_bit_in_byte_00001748",
                "param_1": "bit",
                "DAT_00001774": "byte_ptr"
            },
            "code": "void set_bit_in_byte_00001748(byte bit, byte *DAT_00001774) {\n  byte current_byte_value = *(DAT_00001774 + 3);\n  byte masked_bit = bit | (current_byte_value & 0x1f);\n  *(DAT_00001774 + 3) = masked_bit;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001748",
            "calling": [
                "FUN_000019c0",
                "FUN_00001bb8",
                "FUN_000018bc",
                "FUN_00001960",
                "FUN_0000191c"
            ],
            "imported": false,
            "current_name": "set_bit_in_byte_00001748"
        },
        "FUN_0000294c": {
            "renaming": {
                "FUN_0000294c": "set_flag_for_data_0000294c",
                "DAT_0000296c": "data_start_address",
                "PTR_": "No renaming",
                "data_pointer": "pointer_to_data",
                "data_value": "current_data_value",
                "flag_value": "flag_to_set"
            },
            "code": "void set_flag_for_data_0000294c()\n{\n    uint* data_pointer = (uint*)(DAT_0000296c + 0x14);\n    uint data_value = *data_pointer;\n    uint flag_value = 0x10;\n    *data_pointer = data_value | flag_value;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000294c",
            "calling": [
                "FUN_000027b0",
                "FUN_000026d8"
            ],
            "imported": false,
            "current_name": "set_flag_for_data_0000294c"
        },
        "FUN_00005790": {
            "renaming": {
                "FUN_00005790": "do_nothing_with_pointer_00005790",
                "PTR_DAT_00005798": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_00005790(void)\n{\n  do_nothing(PTR_DAT_00005798);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005790",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00005790"
        },
        "FUN_00000534": {
            "renaming": {
                "FUN_00000534": "is_valid_input_00000534",
                "*param_1": "*input",
                "param_2": "input_len",
                "uVar1": "is_valid"
            },
            "code": "int is_valid_input_00000534(int *input, int input_len) {\n    int is_valid = 0;\n    if (input_len == 0 || input_len == 1 || input_len == 2) {\n        is_valid = 1;\n    }\n    *input = 0;\n    return is_valid;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000534",
            "calling": [
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "is_valid_input_00000534"
        },
        "FUN_000017dc": {
            "renaming": {
                "FUN_000017dc": "initialize_data_000017dc",
                "FUN_000016c8": "set_data",
                "DAT_00001820": "DAT_DATA_START",
                "DAT_00001824": "DAT_CONTROL_BLOCK",
                "DAT_00001828": "DAT_CONTROL_REGISTER"
            },
            "code": "void initialize_data_000017dc(void)\n{\n  set_data(DAT_00001820, 0x1d);\n  if ((*(uint *)(DAT_00001824 + 0x10) & 0x100) == 0) {\n    *(undefined4 *)(DAT_00001824 + 0x10) = 0x104;\n  }\n  *DAT_00001828 = *DAT_00001828 & 0xfff3ffff | 0x80000;\n  return;\n}",
            "called": [
                "FUN_000016c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000017dc",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "initialize_data_000017dc"
        },
        "FUN_00000410": {
            "renaming": {
                "FUN_00000410": "initialize_system_00000410",
                "FUN_00000df4": "call_initialization_function"
            },
            "code": "void initialize_system_00000410(void)\n{\n  call_initialization_function();\n  return;\n}",
            "called": [
                "FUN_00000df4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000410",
            "calling": [
                "FUN_0000459c"
            ],
            "imported": false,
            "current_name": "initialize_system_00000410"
        },
        "FUN_000005ca": {
            "renaming": {
                "FUN_000005ca": "get_next_item_000005ca",
                "param_1": "list_ptr",
                "puVar1": "next_item_ptr"
            },
            "code": "undefined4 * get_next_item_000005ca(int *list_ptr)\n{\n  undefined4 *next_item_ptr;\n  \n  if (*list_ptr == 0) {\n    next_item_ptr = (undefined4 *)0x0;\n  }\n  else {\n    next_item_ptr = *(undefined4 **)*list_ptr;\n    if (next_item_ptr == (undefined4 *)*list_ptr) {\n      *list_ptr = 0;\n    }\n    else {\n      *(undefined4 *)*list_ptr = *next_item_ptr;\n    }\n  }\n  return next_item_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000005ca",
            "calling": [
                "FUN_00000698"
            ],
            "imported": false,
            "current_name": "get_next_item_000005ca"
        },
        "FUN_00005ff8": {
            "renaming": {
                "FUN_00005ff8": "do_nothing_with_data_00005ff8",
                "DAT_00006000": "DAT_DATA",
                "do_nothing_000045ec": "do_nothing"
            },
            "code": "void do_nothing_with_data_00005ff8(void)\n{\n  do_nothing(DAT_00006000);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ff8",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_00005ff8"
        },
        "FUN_00002714": {
            "renaming": {
                "FUN_00002714": "set_bit_in_array_00002714",
                "param_1": "bit_index",
                "DAT_00002740": "array_start",
                "uint": "uint32_t",
                "int": "int32_t",
                "byte": "uint8_t",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "void set_bit_in_array_00002714(uint8_t bit_index) {\n    uint8_t array_index = bit_index >> 5;\n    uint32_t* array_ptr = (uint32_t*)(DAT_00002740 + array_index * 4);\n    uint8_t bit_offset = bit_index & 0x1f;\n    uint32_t mask = 1 << bit_offset;\n    *array_ptr = mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002714",
            "calling": [
                "FUN_00002894"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_00002714"
        },
        "FUN_000020e0": {
            "renaming": {
                "FUN_000020e0": "print_array_elements_count_000020e0",
                "FUN_00002028": "print_count_of_elements",
                "DAT_000020f0": "array"
            },
            "code": "void print_array_elements_count_000020e0(int* DAT_000020f0, int size)\n{\n  print_count_of_elements(DAT_000020f0, size);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020e0",
            "calling": [],
            "imported": false,
            "current_name": "print_array_elements_count_000020e0"
        },
        "FUN_00005fec": {
            "renaming": {
                "FUN_00005fec": "do_nothing_with_data_00005fec",
                "DAT_00005ff4": "DAT_data"
            },
            "code": "void do_nothing_with_data_00005fec(void)\n{\n  do_nothing_with_data_00005fec(DAT_00005ff4);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fec",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_00005fec"
        },
        "FUN_00004f84": {
            "renaming": {
                "FUN_00004f84": "parse_input_00004f84",
                "param_1": "input_string",
                "param_2": "next_char",
                "param_3": "base",
                "uVar1": "result",
                "uVar2": "digit",
                "uVar3": "flag",
                "uVar4": "temp",
                "iVar5": "sign",
                "uVar6": "max",
                "uVar7": "max_div_base",
                "pbVar8": "current_char",
                "pbVar9": "next_char"
            },
            "code": "uint parse_input_00004f84(byte *input_string, byte **next_char, uint base) {\n  uint result = 0;\n  uint sign = 0;\n  byte *current_char = input_string;\n  while ((*current_char >= 0x09 && *current_char <= 0x0D) || *current_char == 0x20) {\n    current_char++;\n  }\n  if (*current_char == 0x2D) {\n    sign = 1;\n    current_char++;\n  }\n  else if (*current_char == 0x2B) {\n    current_char++;\n  }\n  if (base == 0) {\n    if (*current_char != 0x30) {\n      base = 10;\n    }\n    else if ((*(current_char + 1) & 0xDF) == 0x58) {\n      base = 16;\n      current_char += 2;\n    }\n    else {\n      base = 8;\n    }\n  }\n  while (1) {\n    uint digit = 0;\n    if (*current_char >= 0x30 && *current_char <= 0x39) {\n      digit = *current_char - 0x30;\n    }\n    else if (*current_char >= 0x41 && *current_char <= 0x5A) {\n      digit = *current_char - 0x37;\n    }\n    else if (*current_char >= 0x61 && *current_char <= 0x7A) {\n      digit = *current_char - 0x57;\n    }\n    else {\n      break;\n    }\n    if (digit >= base) {\n      break;\n    }\n    if (result > (UINT_MAX - digit) / base) {\n      sign = 1;\n      break;\n    }\n    result = result * base + digit;\n    current_char++;\n  }\n  if (sign) {\n    result = UINT_MAX;\n    if (next_char == NULL) {\n      return UINT_MAX;\n    }\n  }\n  else if (next_char && current_char != input_string) {\n    *next_char = current_char;\n  }\n  return (sign) ? -result : result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f84",
            "calling": [
                "FUN_0000328c",
                "FUN_00004042"
            ],
            "imported": false,
            "current_name": "parse_input_00004f84"
        },
        "FUN_000028f0": {
            "renaming": {
                "FUN_000028f0": "get_offset_from_dataptr_000028f0",
                "DAT_0000290c": "PTR_data",
                "data_ptr": "data_pointer",
                "offset": "data_offset"
            },
            "code": "int get_offset_from_dataptr_000028f0(void)\n{\n  int* data_ptr = (int*)(DAT_0000290c + 8);\n  int offset = *data_ptr + 1;\n  return offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000028f0",
            "calling": [
                "FUN_00002690"
            ],
            "imported": false,
            "current_name": "get_offset_from_dataptr_000028f0"
        },
        "FUN_00004f98": {
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "param_1": "year",
                "puVar1": "calendar_data",
                "uVar2": "result",
                "uVar3": "month",
                "iVar4": "is_leap_year",
                "puVar5": "month_data",
                "iVar6": "days_since_1900",
                "uVar7": "century",
                "iVar8": "month_index",
                "iVar9": "day_of_month"
            },
            "code": "uint32_t calculate_day_of_week_00004f98(uint32_t year) {\n  uint32_t *calendar_data = (uint32_t *)FUN_000056b0();\n  if (year < 0x7b2) {\n    return 0;\n  }\n  else {\n    uint32_t leading_zeroes = count_leading_zeroes(year % 400);\n    uint32_t days_since_1900 = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) + (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n    calendar_data[1] = year;\n    uint32_t *month_data = calendar_data;\n    do {\n      uint32_t month = month_data[5];\n      if (*(char *)(month_data + 2) == 'J') {\n        if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n          if (month < 0x3c) {\n            month = 0;\n          }\n          else {\n            month = 1;\n          }\n        }\n        else {\n          month = 0;\n        }\n        month = month + days_since_1900 + month_data[5] + -1;\n      }\n      else if (*(char *)(month_data + 2) == 'D') {\n        month = days_since_1900 + month_data[5];\n      }\n      else {\n        uint32_t century = leading_zeroes >> 5;\n        if (((year & 3) == 0) && (year % 100 != 0)) {\n          century = 1;\n        }\n        uint32_t month_index = 0;\n        month = days_since_1900;\n        while (true) {\n          month_index = month_index + 1;\n          if (month_data[3] <= month_index) break;\n          month = month + *(int *)(PTR_DAT_000050e4 + month_index * 4 + century * 0x30 + -4);\n        }\n        uint32_t day_of_month = month_data[5] - (month + 4U) % 7;\n        if (day_of_month < 0) {\n          day_of_month = day_of_month + 7;\n        }\n        for (day_of_month = (month_data[4] - 1) * 7 + day_of_month; *(int *)(PTR_DAT_000050e4 + month_index * 4 + century * 0x30 + -4) <= day_of_month; day_of_month = day_of_month + -7) {}\n        month = month + day_of_month;\n      }\n      uint32_t day_number = month_data[10] + DAT_000050e0 * month + month_data[6];\n      month_data[8] = day_number;\n      month_data[9] = (int)day_number >> 0x1f;\n      month_data = month_data + 10;\n    } while (calendar_data + 0x14 != month_data);\n    uint32_t days_since_1900_end = calendar_data[9];\n    uint32_t days_since_1900_start = calendar_data[0x13];\n    *calendar_data = (uint32_t)((int)((days_since_1900_end - days_since_1900_start) - (uint32_t)(calendar_data[8] < calendar_data[0x12])) < 0 != (SBORROW4(days_since_1900_end,days_since_1900_start) != SBORROW4(days_since_1900_end - days_since_1900_start,(uint32_t)(calendar_data[8] < calendar_data[0x12]))));\n    return 1;\n  }\n}",
            "called": [
                "FUN_000056b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f98",
            "calling": [
                "FUN_000047e4",
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_00004f98"
        },
        "FUN_00004dee": {
            "renaming": {
                "FUN_00004dee": "check_and_call_function_00004dee",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "result"
            },
            "code": "int check_and_call_function_00004dee(int param1, int* param2, int param3, int param4) {\n    int result = 0;\n    if ((int)((uint16_t)*(param2 + 0xc) << 0x17) < 0) {\n        call_function(param1, (int16_t)*(param2 + 0xe), 0, 2);\n    }\n    *(uint16_t *)(param2 + 0xc) = *(uint16_t *)(param2 + 0xc) & 0xefff;\n    result = call_another_function(param3, param4);\n    return result;\n}",
            "called": [
                "FUN_00000e38",
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dee",
            "calling": [],
            "imported": false,
            "current_name": "check_and_call_function_00004dee"
        },
        "FUN_00000fec": {
            "renaming": {
                "FUN_00000fec": "initialize_array_to_zero_00000fec",
                "*param_1": "array",
                "param_2": "size"
            },
            "code": "void initialize_array_to_zero_00000fec(uint32_t *array, uint32_t size) {\n    if ((size & (size - 1)) != 0) {\n        assert(0 && \"Size of array must be a power of two\");\n    }\n    array[0] = 0;\n    array[1] = 0;\n    array[2] = size - 1;\n    return;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000fec",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "initialize_array_to_zero_00000fec"
        },
        "FUN_00000428": {
            "renaming": {
                "FUN_00000428": "check_bounds_and_update_00000428",
                "param_1": "param_offset",
                "param_2": "offset_limit",
                "uVar1": "result",
                "local_c": "current_offset"
            },
            "code": "undefined4 check_bounds_and_update_00000428(int *param_offset, int offset_limit)\n{\n  undefined4 result = FUN_00000cd0();\n  int current_offset = *(int *)PTR_Elf32_Rel_ARRAY_00000484;\n  if ((DAT_00000488 < (uint)(offset_limit + current_offset)) || ((uint)(offset_limit + current_offset) < DAT_0000048c)) {\n    *param_offset = 0xc;\n    result = 0xffffffff;\n  }\n  else {\n    *(int *)PTR_Elf32_Rel_ARRAY_00000484 = offset_limit + current_offset;\n  }\n  FUN_00000d0c(result);\n  return result;\n}",
            "called": [
                "FUN_00000d0c",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000428",
            "calling": [
                "FUN_00004bd0"
            ],
            "imported": false,
            "current_name": "check_bounds_and_update_00000428"
        },
        "FUN_000039e8": {
            "renaming": {
                "FUN_000039e8": "getClassType_000039e8",
                "param_1": "inputChar",
                "puVar1": "classType",
                "PTR_s_CLASS_UNKNOWN_00003d20": "classUnknownPtr",
                "DAT_00003cc0": "nullDataPtr",
                "DAT_00003cc4": "atDataPtr",
                "DAT_00003cc8": "bDataPtr",
                "PTR_s_ACT_SERVO_00003ccc": "actServoPtr",
                "PTR_s_ACT_MOTOR_00003cd0": "actMotorPtr",
                "PTR_s_ACT_SWITCH_00003cd4": "actSwitchPtr",
                "PTR_s_ACT_DIMMER_00003cd8": "actDimmerPtr",
                "PTR_s_SENSE_ANY_00003cdc": "senseAnyPtr",
                "PTR_s_SENSE_BTN_00003ce0": "senseBtnPtr",
                "PTR_s_SENSE_TEMP_00003ce4": "senseTempPtr",
                "PTR_s_SENSE_HUM_00003ce8": "senseHumPtr",
                "PTR_s_SENSE_LIGHT_00003cec": "senseLightPtr",
                "PTR_s_SENSE_ACCEL_00003cf0": "senseAccelPtr",
                "PTR_s_SENSE_MAG_00003cf4": "senseMagPtr",
                "PTR_s_SENSE_GYRO_00003cf8": "senseGyroPtr",
                "PTR_s_SENSE_COLOR_00003cfc": "senseColorPtr",
                "PTR_s_SENSE_PRESS_00003d00": "sensePressPtr",
                "PTR_s_SENSE_ANALOG_00003d04": "senseAnalogPtr",
                "PTR_s_SENSE_UV_00003d08": "senseUvPtr",
                "PTR_s_SENSE_OBJTEMP_00003d0c": "senseObjTempPtr",
                "PTR_s_SENSE_PULSE_COUNT_00003d10": "sensePulseCountPtr",
                "PTR_s_SENSE_DISTANCE_00003d14": "senseDistancePtr",
                "PTR_s_SENSE_CO2_00003d18": "senseCo2Ptr"
            },
            "code": "undefined* getClassType_000039e8(char inputChar) {\n  undefined* classType = PTR_s_CLASS_UNKNOWN_00003d20;\n  switch(inputChar) {\n    case '\\0':\n      classType = DAT_00003cc0;\n      break;\n    case '@':\n      classType = DAT_00003cc4;\n      break;\n    case 'B':\n      classType = DAT_00003cc8;\n      break;\n    case 'C':\n      classType = PTR_s_ACT_SERVO_00003ccc;\n      break;\n    case 'D':\n      classType = PTR_s_ACT_MOTOR_00003cd0;\n      break;\n    case 'E':\n      classType = PTR_s_ACT_SWITCH_00003cd4;\n      break;\n    case 'F':\n      classType = PTR_s_ACT_DIMMER_00003cd8;\n      break;\n    case -0x80:\n      classType = PTR_s_SENSE_ANY_00003cdc;\n      break;\n    case -0x7f:\n      classType = PTR_s_SENSE_BTN_00003ce0;\n      break;\n    case -0x7e:\n      classType = PTR_s_SENSE_TEMP_00003ce4;\n      break;\n    case -0x7d:\n      classType = PTR_s_SENSE_HUM_00003ce8;\n      break;\n    case -0x7c:\n      classType = PTR_s_SENSE_LIGHT_00003cec;\n      break;\n    case -0x7b:\n      classType = PTR_s_SENSE_ACCEL_00003cf0;\n      break;\n    case -0x7a:\n      classType = PTR_s_SENSE_MAG_00003cf4;\n      break;\n    case -0x79:\n      classType = PTR_s_SENSE_GYRO_00003cf8;\n      break;\n    case -0x78:\n      classType = PTR_s_SENSE_COLOR_00003cfc;\n      break;\n    case -0x77:\n      classType = PTR_s_SENSE_PRESS_00003d00;\n      break;\n    case -0x76:\n      classType = PTR_s_SENSE_ANALOG_00003d04;\n      break;\n    case -0x75:\n      classType = PTR_s_SENSE_UV_00003d08;\n      break;\n    case -0x74:\n      classType = PTR_s_SENSE_OBJTEMP_00003d0c;\n      break;\n    case -0x73:\n      classType = PTR_s_SENSE_PULSE_COUNT_00003d10;\n      break;\n    case -0x72:\n      classType = PTR_s_SENSE_DISTANCE_00003d14;\n      break;\n    case -0x71:\n      classType = PTR_s_SENSE_CO2_00003d18;\n      break;\n    case ' ': case '!': case '\"': case '#': case '$': case '%': case '&': case '\\'': case '(': case ')': case '*': case '+': case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case ':': case ';': case '<': case '=': case '>': case '?':\n    case 'A': case 'G': case 'H': case 'I': case 'J': case 'K': case 'L': case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R': case 'S': case 'T': case 'U': case 'V': case 'W': case 'X': case 'Y': case 'Z':\n    case '[': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g': case 'h': case 'i': case 'j': case 'k': case 'l': case 'm': case 'n': case 'o': case 'p': case 'q': case 'r': case 's': case 't': case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':\n    case '{': case '|': case '}': case '~': case '\\x7f':\n      break;\n    default:\n      if (inputChar == -1) {\n        return PTR_s_CLASS_ANY_00003d1c;\n      }\n  }\n  return classType;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000039e8",
            "calling": [
                "FUN_00002ecc",
                "FUN_00002f74"
            ],
            "imported": false,
            "current_name": "getClassType_000039e8"
        },
        "FUN_00000e38": {
            "renaming": {
                "FUN_00000e38": "execute_function_00000e38",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "FUN_000015d0": "call_another_function"
            },
            "code": "undefined4 execute_function_00000e38(undefined4 input_param_1, undefined4 input_param_2) {\n  call_another_function(0, input_param_1, input_param_2);\n  return input_param_2;\n}",
            "called": [
                "FUN_000015d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e38",
            "calling": [
                "FUN_00004dee"
            ],
            "imported": false,
            "current_name": "execute_function_00000e38"
        },
        "FUN_00002294": {
            "renaming": {
                "FUN_00002294": "is_valid_range_00002294",
                "param_1": "input",
                "uVar1": "range_status",
                "iVar2": "range",
                "bVar3": "is_within_range"
            },
            "code": "int is_valid_range_00002294(int input)\n{\n  int range = *(int *)(input + 4);\n  bool is_within_range = *(int *)(input + 0xc) - *(int *)(input + 8) == range;\n  if (is_within_range) {\n    range = 1;\n  }\n  else {\n    range = 0;\n  }\n  return range;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002294",
            "calling": [
                "FUN_00002364"
            ],
            "imported": false,
            "current_name": "is_valid_range_00002294"
        },
        "FUN_00003e9e": {
            "renaming": {
                "FUN_00003e9e": "calculate_result_00003e9e",
                "param_1": "input_buffer",
                "param_2": "input_size",
                "param_3": "output_buffer",
                "uVar1": "result",
                "FUN_00003ec4": "calculate"
            },
            "code": "int calculate_result_00003e9e(void *input_buffer, int input_size, void *output_buffer) {\n  int result = calculate(input_buffer, input_size, output_buffer);\n  return result;\n}",
            "called": [
                "FUN_00003ec4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e9e",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "calculate_result_00003e9e"
        },
        "FUN_00003378": {
            "renaming": {
                "FUN_00003378": "process_data_00003378",
                "param_1": "data_array",
                "PTR_s__04i__02i__02i__02i__02i__02i_000033bc": "PTR_s_data_format",
                "param_1[5]": "data_array[5]",
                "param_1[4]": "data_array[4]",
                "param_1[3]": "data_array[3]",
                "param_1[2]": "data_array[2]",
                "param_1[1]": "data_array[1]",
                "*param_1": "data_array[0]"
            },
            "code": "int process_data_00003378(uint32_t *data_array){\n    uint32_t offset = 0x76c;\n    uint32_t size = data_array[4] + 1;\n    uint32_t arg1 = data_array[3];\n    uint32_t arg2 = data_array[2];\n    uint32_t arg3 = data_array[1];\n    uint32_t arg4 = data_array[0];\n    process_data_00003378_helper(PTR_s__04i__02i__02i__02i__02i__02i_000033bc, offset, size, arg1, arg2, arg3, arg4);\n    return 0;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003378",
            "calling": [
                "FUN_000033c0",
                "FUN_00003444"
            ],
            "imported": false,
            "current_name": "process_data_00003378"
        },
        "FUN_00006768": {
            "renaming": {
                "FUN_00006768": "process_data_00006768",
                "param_1": "data",
                "param_2": "info",
                "param_3": "arg_2",
                "param_4": "arg_3",
                "uVar1": "flags",
                "iVar2": "result",
                "uVar3": "temp",
                "uVar4": "length",
                "uVar5": "temp_uint"
            },
            "code": "undefined4 process_data_00006768(undefined4 *data, undefined4 *info, undefined4 arg_2, undefined4 arg_3)\n{\n    undefined2 flags;\n    int result;\n    undefined4 temp;\n    ushort length;\n    uint temp_uint;\n\n    if ((data != NULL) && (data[6] == 0)) {\n        initialize_data();\n    }\n\n    if (info == (undefined4 *)PTR_DAT_00006868) {\n        info = (undefined4 *)data[1];\n    }\n    else if (info == (undefined4 *)PTR_DAT_0000686c) {\n        info = (undefined4 *)data[2];\n    }\n    else if (info == (undefined4 *)PTR_DAT_00006870) {\n        info = (undefined4 *)data[3];\n    }\n\n    length = *(ushort *)(info + 3);\n    info[1] = 0;\n    temp_uint = (uint)length;\n\n    if ((int)(temp_uint << 0x1a) < 0) {\n        return 0xffffffff;\n    }\n    if ((int)(temp_uint << 0x1d) < 0) {\n        if ((undefined4 *)info[0xd] != NULL) {\n            if ((undefined4 *)info[0xd] != info + 0x11) {\n                clean_data(data);\n            }\n            info[1] = info[0x10];\n            info[0xd] = 0;\n            if (info[0x10] != 0) {\n                *info = info[0xf];\n                return 0;\n            }\n        }\n    }\n    else {\n        if ((int)(temp_uint << 0x1b) >= 0) {\n            if ((int)(temp_uint << 0x1c) < 0) {\n                result = process_info(data, info, temp_uint << 0x1c, temp_uint, arg_3);\n                if (result != 0) {\n                    return 0xffffffff;\n                }\n                info[2] = 0;\n                *(ushort *)(info + 3) = *(ushort *)(info + 3) & 0xfff7;\n                info[6] = 0;\n            }\n            else {\n                *(ushort *)(info + 3) = *(ushort *)(info + 3) | 4;\n            }\n        }\n        else {\n            *data = 9;\n            length = length | 0x40;\n            goto LAB_000067b8;\n        }\n    }\n\n    if (info[4] == 0) {\n        process_data_00006768(data, info);\n    }\n\n    length = *(ushort *)(info + 3);\n    flags = *(undefined2 *)(info + 3);\n\n    if ((length & 3) != 0) {\n        *(undefined2 *)(info + 3) = 1;\n        process_data_00006768(*(undefined4 *)PTR_DAT_00006874, PTR_LAB_00006754_1_00006878);\n        *(undefined2 *)(info + 3) = flags;\n        if ((length & 9) == 9) {\n            clean_data(data, info);\n        }\n    }\n\n    temp = info[4];\n    *info = temp;\n    result = (*(code *)info[9])(data, info[8], temp, info[5]);\n    info[1] = result;\n\n    if (result > 0) {\n        return 0;\n    }\n\n    length = *(ushort *)(info + 3);\n\n    if (result != 0) {\n        info[1] = 0;\n        length = length | 0x40;\n    }\n\nLAB_000067b8:\n    *(ushort *)(info + 3) = length;\n    return 0xffffffff;\n}",
            "called": [
                "FUN_00004158",
                "FUN_0000404c",
                "FUN_00004b34",
                "FUN_000043a0",
                "FUN_000042a4",
                "FUN_00005700"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006768",
            "calling": [
                "FUN_00005e10"
            ],
            "imported": false,
            "current_name": "process_data_00006768"
        },
        "FUN_00000db0": {
            "renaming": {
                "FUN_00000db0": "init_system_00000db0",
                "FUN_00000dcc": "initialize_network",
                "FUN_00000d9c": "initialize_memory"
            },
            "code": "void init_system_00000db0(void)\n{\n  initialize_network();\n  initialize_memory();\n  return;\n}",
            "called": [
                "FUN_00000d9c",
                "FUN_00000dcc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000db0",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "init_system_00000db0"
        },
        "FUN_00002600": {
            "renaming": {
                "FUN_00002600": "process_data_00002600",
                "param_1": "data",
                "uVar1": "processed_data",
                "FUN_000047e4": "preprocess_data",
                "FUN_0000285c": "send_data"
            },
            "code": "int process_data_00002600(undefined4 data)\n{\n  undefined4 processed_data;\n  processed_data = preprocess_data_00002600(data);\n  send_data(processed_data);\n  return 0;\n}",
            "called": [
                "FUN_000047e4",
                "FUN_0000285c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002600",
            "calling": [
                "FUN_00003478"
            ],
            "imported": false,
            "current_name": "process_data_00002600"
        },
        "FUN_00003810": {
            "renaming": {
                "FUN_00003810": "get_label_from_param_1_00003810",
                "param_1": "param",
                "puVar1": "label_ptr"
            },
            "code": "undefined* get_label_from_param_1_00003810(undefined param_1)\n{\n    undefined* label_ptr;\n    switch(param_1) {\n        case 2:\n            label_ptr = PTR_LAB_000038cc;\n            break;\n        case 3:\n            label_ptr = PTR_LAB_000038d0;\n            break;\n        case 4:\n            label_ptr = PTR_LAB_000038d4;\n            break;\n        case 5:\n            label_ptr = PTR_LAB_000038d8;\n            break;\n        case 6:\n            label_ptr = PTR_LAB_000038dc;\n            break;\n        case 7:\n            label_ptr = PTR_LAB_000038e0;\n            break;\n        case 8:\n            label_ptr = PTR_LAB_000038e4;\n            break;\n        case 9:\n            label_ptr = PTR_LAB_000038e8;\n            break;\n        case 10:\n            label_ptr = PTR_LAB_000038ec;\n            break;\n        case 0xb:\n            label_ptr = PTR_LAB_000038f0;\n            break;\n        case 0xc:\n            label_ptr = PTR_LAB_000038f4;\n            break;\n        case 0xd:\n            label_ptr = PTR_LAB_000038f8;\n            break;\n        case 0xe:\n            label_ptr = PTR_LAB_000038fc;\n            break;\n        case 0xf:\n            label_ptr = PTR_LAB_00003900;\n            break;\n        case 0x10:\n            label_ptr = PTR_LAB_00003904;\n            break;\n        case 0x11:\n            label_ptr = PTR_LAB_0000390c;\n            break;\n        case 0x13:\n            label_ptr = PTR_LAB_00003910;\n            break;\n        case 0x15:\n            label_ptr = PTR_LAB_00003908;\n    }\n    return label_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003810",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "get_label_from_param_1_00003810"
        },
        "FUN_00000ed8": {
            "renaming": {
                "FUN_00000ed8": "execute_function_00000ed8",
                "in_lr": "return_address",
                "FUN_00004c84": "call_another_function",
                "PTR_DAT_00000ef4": "PTR_DATA"
            },
            "code": "void execute_function_00000ed8(void)\n{\n  undefined4 return_address;\n  call_another_function(PTR_DAT_00000ef4, return_address);\n  return;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ed8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "execute_function_00000ed8"
        },
        "FUN_000031e0": {
            "renaming": {
                "FUN_000031e0": "ring_alarm_000031e0",
                "PTR_s_The_alarm_rang_000031f8": "The_alarm_rang"
            },
            "code": "void ring_alarm_000031e0(void)\n{\n  play_sound(PTR_s_The_alarm_rang_000031f8);\n  return;\n}",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031e0",
            "calling": [],
            "imported": false,
            "current_name": "ring_alarm_000031e0"
        },
        "FUN_000020f4": {
            "renaming": {
                "FUN_000020f4": "print_data_000020f4",
                "FUN_00002028": "print_message",
                "DAT_00002104": "data_array"
            },
            "code": "void print_data_000020f4(void)\n{\n  print_message(DAT_00002104,3);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020f4",
            "calling": [],
            "imported": false,
            "current_name": "print_data_000020f4"
        },
        "FUN_0000687c": {
            "renaming": {
                "FUN_0000687c": "decode_string_0000687c",
                "param_1": "length",
                "param_2": "encoded_string",
                "pbVar1": "decoded_string",
                "uVar2": "range_end",
                "iVar3": "decoded_index",
                "uVar4": "current_char",
                "uVar5": "char_count",
                "uVar6": "range_start",
                "bVar7": "is_inverted"
            },
            "code": "byte* decode_string_0000687c(int length, byte* encoded_string) {\n  byte* decoded_string = encoded_string;\n  uint current_char = (uint)*encoded_string;\n  bool is_inverted = current_char == 0x5e;\n  if (is_inverted) {\n    current_char = (uint)encoded_string[1];\n    decoded_string += 2;\n  }\n  else {\n    decoded_string++;\n  }\n  int decoded_index = length - 1;\n  do {\n    decoded_index++;\n    *(bool*)decoded_index = is_inverted;\n  } while (decoded_index != length + 0xff);\n  if (current_char == 0) {\n    return decoded_string - 1;\n  }\n  else {\n    do {\n      uint char_count = current_char;\n      *(bool*)(length + char_count) = !is_inverted;\n      decoded_string++;\n      while (true) {\n        current_char = (uint)decoded_string[-1];\n        if (current_char != 0x2d) {\n          break;\n        }\n        uint range_end = (uint)*decoded_string;\n        if ((range_end == 0x5d) || ((int)range_end < (int)char_count)) {\n          goto continue_decoding;\n        }\n        do {\n          char_count++;\n          *(bool*)(length + char_count) = !is_inverted;\n        } while ((int)char_count < (int)range_end);\n        int range_length = ~char_count + range_end;\n        if ((int)range_end <= (int)char_count) {\n          range_length = 0;\n        }\n        char_count += 1 + range_length;\n        decoded_string += 2;\n      }\n      return decoded_string - 1;\n    } while ((current_char != 0x5d) && (decoded_string--, current_char != 0));\n  }\n  continue_decoding:\n  return decoded_string;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000687c",
            "calling": [
                "FUN_0000656c",
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "decode_string_0000687c"
        },
        "FUN_00005edc": {
            "renaming": {
                "FUN_00005edc": "parse_input_number_00005edc",
                "param_1": "out_number",
                "param_2": "input_string",
                "param_3": "end_of_input",
                "param_4": "input_base",
                "uVar1": "digit_value",
                "uVar2": "current_char_value",
                "bVar3": "is_hex",
                "iVar4": "parse_error",
                "uVar5": "digit_value",
                "uVar6": "max_digit_value",
                "pbVar7": "current_char",
                "pbVar8": "next_char",
                "PTR_DAT_00005fd0": "digit_value_properties"
            },
            "code": "uint parse_input_number_00005edc(undefined4 *out_number, byte *input_string, byte **end_of_input, uint input_base) {\n    uint digit_value, negative = 0, overflow = 0;\n    byte *current_char = input_string;\n    if (*current_char == '-') {\n        negative = 1;\n        current_char++;\n    }\n    else if (*current_char == '+') {\n        current_char++;\n    }\n    if (input_base == 0) {\n        if (*current_char != '0') {\n            input_base = 10;\n        }\n        else if ((*(current_char + 1) & 0xdf) == 'X') {\n            input_base = 16;\n            current_char += 2;\n        }\n        else {\n            input_base = 8;\n        }\n    }\n    while (*current_char != '\\0') {\n        if (overflow) {\n            break;\n        }\n        if (*current_char >= '0' && *current_char <= '9') {\n            digit_value = *current_char - '0';\n        }\n        else if (*current_char >= 'A' && *current_char <= 'Z') {\n            digit_value = *current_char - 'A' + 10;\n        }\n        else if (*current_char >= 'a' && *current_char <= 'z') {\n            digit_value = *current_char - 'a' + 10;\n        }\n        else {\n            break;\n        }\n        if (digit_value >= input_base) {\n            break;\n        }\n        if (negative) {\n            if (-((int)digit_value) < (int)0x80000000 / (int)input_base) {\n                overflow = 1;\n            }\n            else {\n                *out_number = *out_number * input_base - digit_value;\n            }\n        }\n        else {\n            if (*out_number > (0xffffffff - digit_value) / input_base) {\n                overflow = 1;\n            }\n            else {\n                *out_number = *out_number * input_base + digit_value;\n            }\n        }\n        current_char++;\n    }\n    if (overflow) {\n        *out_number = 0xffffffff;\n        if (end_of_input == NULL) {\n            return 0xffffffff;\n        }\n    }\n    else {\n        if (negative) {\n            *out_number = -*out_number;\n        }\n        if (end_of_input == NULL) {\n            return *out_number;\n        }\n        if (current_char == input_string) {\n            *end_of_input = input_string;\n        }\n        else {\n            *end_of_input = current_char - 1;\n        }\n    }\n    return *out_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005edc",
            "calling": [
                "FUN_00005fd8"
            ],
            "imported": false,
            "current_name": "parse_input_number_00005edc"
        },
        "FUN_00001eea": {
            "renaming": {
                "FUN_00001eea": "set_bit_at_00001eea",
                "param_1": "index",
                "param_2": "bit_value",
                "uVar1": "word_index",
                "iVar2": "word_ptr",
                "iVar3": "bit_index"
            },
            "code": "int set_bit_at_00001eea(uint16_t index, uint8_t bit_value) {\n    uint16_t word_index = index / 32;\n    uint8_t bit_index = index % 32;\n    uint32_t* word_ptr = &PTR_DAT_00002008[word_index];\n    if (bit_value) {\n        *word_ptr |= (1 << bit_index);\n    }\n    else {\n        *word_ptr &= ~(1 << bit_index);\n    }\n    PTR_DAT_00002004[index] = bit_value & 0x23 | 0x100;\n    return 0;\n}",
            "called": [
                "FUN_00001d5e",
                "FUN_00001f80",
                "FUN_00001d80",
                "FUN_00001dc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001eea",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "set_bit_at_00001eea"
        },
        "FUN_000023a4": {
            "renaming": {
                "FUN_000023a4": "get_data_000023a4",
                "uVar1": "data",
                "auStack_88": "buffer",
                "FUN_000023d0": "init_data",
                "FUN_00004db8": "read_data_from_mem",
                "FUN_00002e6c": "get_user_input",
                "software_interrupt": "trigger_interrupt"
            },
            "code": "int get_data_000023a4(void)\n{\n  int data;\n  char buffer[128];\n  init_data(0);\n  read_data_from_mem(data);\n  get_user_input(buffer, 0x80);\n  trigger_interrupt(0x3f);\n  return data;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00002e6c",
                "FUN_000023d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023a4",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "get_data_000023a4"
        },
        "FUN_0000240c": {
            "renaming": {
                "FUN_0000240c": "get_next_pointer_0000240c",
                "param_1": "current_pointer",
                "puVar1": "next_pointer"
            },
            "code": "undefined4* get_next_pointer_0000240c(undefined4 *current_pointer)\n{\n  undefined4 *next_pointer;\n  next_pointer = (undefined4 *)*current_pointer;\n  if (next_pointer != (undefined4 *)0x0) {\n    *current_pointer = *next_pointer;\n  }\n  return next_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000240c",
            "calling": [
                "FUN_000024bc"
            ],
            "imported": false,
            "current_name": "get_next_pointer_0000240c"
        },
        "FUN_00004280": {
            "renaming": {
                "FUN_00004280": "do_nothing_with_pointer_00004280",
                "PTR_DAT_00004288": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_00004280(void)\n{\n  do_nothing(PTR_DAT_00004288);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004280",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00004280"
        },
        "FUN_00001448": {
            "renaming": {
                "FUN_00001448": "check_and_call_function_00001448",
                "param_1": "index",
                "PTR_DAT_000014c0": "data_pointer",
                "first_short": "first_index_value",
                "second_short": "second_index_value",
                "first_undefined2": "first_value",
                "first_undefined4": "second_value",
                "second_undefined2": "third_value",
                "second_undefined4": "fourth_value"
            },
            "code": "void check_and_call_function_00001448(int index)\n{\n    short first_short = *(short *)(PTR_DAT_000014c0 + index * 0x20 + 8);\n    short second_short = *(short *)(PTR_DAT_000014c0 + index * 0x20 + 10);\n\n    if (first_short != -1)\n    {\n        undefined2 first_undefined2 = *(undefined2 *)(PTR_DAT_000014c0 + index * 0x20 + 8);\n        undefined4 first_undefined4 = *(undefined4 *)(PTR_DAT_000014c0 + index * 0x20 + 0xc);\n        FUN_00001f80(first_undefined2, first_undefined4);\n    }\n    if (second_short != -1)\n    {\n        undefined2 second_undefined2 = *(undefined2 *)(PTR_DAT_000014c0 + index * 0x20 + 10);\n        undefined4 second_undefined4 = *(undefined4 *)(PTR_DAT_000014c0 + index * 0x20 + 0x10);\n        FUN_00001f80(second_undefined2, second_undefined4);\n    }\n    return;\n}",
            "called": [
                "FUN_00001f80"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001448",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "check_and_call_function_00001448"
        },
        "FUN_00001688": {
            "renaming": {
                "FUN_00001688": "execute_initialization_00001688",
                "FUN_00001628": "initialize_data_structures"
            },
            "code": "void execute_initialization_00001688(void)\n{\n  initialize_data_structures(0);\n  return;\n}",
            "called": [
                "FUN_00001628"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001688",
            "calling": [],
            "imported": false,
            "current_name": "execute_initialization_00001688"
        },
        "FUN_00004042": {
            "renaming": {
                "FUN_00004042": "print_numbers_00004042",
                "param_1": "number",
                "FUN_00004f84": "print_range"
            },
            "code": "void print_numbers_00004042(undefined4 number)\n{\n  print_range(number, 0, 10);\n  return;\n}",
            "called": [
                "FUN_00004f84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004042",
            "calling": [
                "FUN_0000305c",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "print_numbers_00004042"
        },
        "FUN_00000cf0": {
            "renaming": {
                "FUN_00000cf0": "is_interrupt_enabled_in_privileged_mode_00000cf0",
                "uVar2": "is_interrupt_enabled",
                "bVar1": "is_privileged_mode"
            },
            "code": "bool is_interrupt_enabled_in_privileged_mode_00000cf0(void)\n{\n  bool is_privileged_mode = isCurrentModePrivileged();\n  bool is_interrupt_enabled = false;\n  if (is_privileged_mode) {\n    is_interrupt_enabled = isIRQinterruptsEnabled();\n  }\n  return is_interrupt_enabled;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cf0",
            "calling": [
                "FUN_00000930"
            ],
            "imported": false,
            "current_name": "is_interrupt_enabled_in_privileged_mode_00000cf0"
        },
        "FUN_00000f8c": {
            "renaming": {
                "FUN_00000f8c": "initialize_data_structures_00000f8c",
                "puRam00000fd4": "global_pointer_1",
                "uRam00000fd8": "global_pointer_2",
                "uRam00000fdc": "global_pointer_3",
                "puRam00000fe0": "global_pointer_4",
                "uRam00000fe4": "global_pointer_5",
                "uRam00000fe8": "global_pointer_6",
                "uVar1": "random_value",
                "puVar2": "data_buffer",
                "uVar3": "buffer_size",
                "iStack_24": "stack_variable_1",
                "piStack_20": "stack_variable_2",
                "uStack_1c": "stack_variable_3",
                "local_18": "local_variable_1",
                "local_14": "local_variable_2",
                "local_10": "local_variable_3",
                "FUN_00000cd0": "initialize_system",
                "FUN_000010d4": "allocate_memory",
                "FUN_00000930": "generate_random_number",
                "PTR_s_FAILED_ASSERTION__00001030": "ERROR_MESSAGE_1",
                "handle_error": "handle_error"
            },
            "code": "void initialize_data_structures_00000f8c(void)\n{\n  uint32_t random_value;\n  uint32_t *data_buffer;\n  uint32_t buffer_size;\n  int stack_variable_1;\n  int *stack_variable_2;\n  uint32_t stack_variable_3;\n  uint32_t local_variable_1;\n  uint32_t local_variable_2;\n  uint32_t local_variable_3;\n  \n  initialize_system();\n  local_variable_1 = *global_pointer_1;\n  local_variable_2 = 0;\n  local_variable_3 = global_pointer_2;\n  allocate_memory(global_pointer_3, 0x100, 0xf, 0xc);\n  local_variable_1 = *global_pointer_4;\n  local_variable_2 = 0;\n  local_variable_3 = global_pointer_5;\n  buffer_size = 0xc;\n  allocate_memory(global_pointer_6, 0x600, 7);\n  stack_variable_3 = 0xfd3;\n  random_value = generate_random_number();\n  random_value = random_value >> 0x1e;\n  data_buffer = (uint32_t *)(buffer_size * 0x100);\n  stack_variable_1 = (buffer_size >> 0x1d) << 0x11;\n  stack_variable_2 = &stack_variable_1;\n  if ((random_value & random_value - 1) != 0) {\n    handle_error(3, PTR_s_FAILED_ASSERTION__00001030);\n  }\n  *data_buffer = 0;\n  data_buffer[1] = 0;\n  data_buffer[2] = random_value - 1;\n  return;\n}",
            "called": [
                "FUN_00000cd0",
                "FUN_000010d4",
                "FUN_00000930"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f8c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "initialize_data_structures_00000f8c"
        },
        "FUN_00002894": {
            "renaming": {
                "FUN_00002894": "set_and_call_function_00002894",
                "param_1": "num",
                "param_2": "arg1",
                "param_3": "arg2",
                "iVar1": "data_ptr",
                "*(uint *)(DAT_000028e8 + 0x1c)": "*control_reg",
                "*(int *)(iVar1 + 8)": "*(int *)(data_ptr + 8)",
                "*(undefined4 *)PTR_DAT_000028ec": "*(uint32_t *)PTR_DATA_SECTION_PTR",
                "*(undefined4 *)(PTR_DAT_000028ec + 4)": "*(uint32_t *)(PTR_DATA_SECTION_PTR + 4)",
                "FUN_00002744": "call_function",
                "FUN_00002714": "call_function"
            },
            "code": "void set_and_call_function_00002894(int num, uint32_t arg1, uint32_t arg2) {\n  int data_ptr = DATA_SECTION_START;\n  uint32_t *(uint *)(DAT_000028e8 + 0x1c) = (uint32_t *)(data_ptr + 0x1c);\n  *(uint *)(DAT_000028e8 + 0x1c) &= ~(1 << 2);\n  *(int *)(data_ptr + 8) = num - 1;\n  *(undefined4 *)PTR_DAT_000028ec = arg1;\n  *(undefined4 *)(PTR_DAT_000028ec + 4) = arg2;\n  *(uint *)(DAT_000028e8 + 0x1c) |= 1 << 2;\n  call_function(0x2e, 10);\n  call_function(0x2e);\n  return;\n}",
            "called": [
                "FUN_00002744",
                "FUN_00002714"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002894",
            "calling": [
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "set_and_call_function_00002894"
        },
        "FUN_00004158": {
            "renaming": {
                "FUN_00004158": "process_data_00004158",
                "param_1": "data_size",
                "param_2": "data",
                "uVar1": "result",
                "PTR_DAT_000041c4": "original_data_ptr",
                "PTR_DAT_000041c8": "updated_data_ptr",
                "PTR_DAT_000041cc": "processed_data_ptr"
            },
            "code": "int process_data_00004158(int data_size, char *data){\n    int result;\n    char *data_ptr;\n    \n    if (*(int *)(data + 0x10) != 0) {\n        if ((data_size != 0) && (*(int *)(data_size + 0x18) == 0)) {\n            initialize_data_structure();\n        }\n        if (data == PTR_DAT_000041c4) {\n            data_ptr = *(char **)(data_size + 4);\n        }\n        else if (data == PTR_DAT_000041c8) {\n            data_ptr = *(char **)(data_size + 8);\n        }\n        else if (data == PTR_DAT_000041cc) {\n            data_ptr = *(char **)(data_size + 0xc);\n        }\n        if (*(short *)(data_ptr + 0xc) != 0) {\n            if ((-1 < *(int *)(data_ptr + 100) << 0x1f) && (-1 < (int)*(short *)(data_ptr + 0xc) << 0x16)) {\n                perform_operation_1(*(int *)(data_ptr + 0x58));\n            }\n            result = process_data_00004158_component(data_size, data_ptr);\n            if (*(int *)(data_ptr + 100) << 0x1f < 0) {\n                return result;\n            }\n            if ((int)((uint)*(ushort *)(data_ptr + 0xc) << 0x16) < 0) {\n                return result;\n            }\n            perform_operation_2(*(int *)(data_ptr + 0x58));\n            return result;\n        }\n    }\n    return 0;\n}",
            "called": [
                "FUN_0000404c",
                "FUN_000045ec",
                "FUN_000045e8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004158",
            "calling": [
                "FUN_000041d0",
                "FUN_00006768",
                "FUN_00005404"
            ],
            "imported": false,
            "current_name": "process_data_00004158"
        },
        "FUN_00002654": {
            "renaming": {
                "FUN_00002654": "initialize_data_and_call_function_00002654",
                "param_1": "data1",
                "param_2": "data2",
                "param_3": "data3",
                "uVar1": "result",
                "FUN_000047e4": "call_function_1",
                "PTR_DAT_00002688": "data_pointer_1",
                "FUN_00002894": "call_function_2",
                "PTR_FUN_000026f0_1_0000268c": "function_pointer_1"
            },
            "code": "int initialize_data_and_call_function_00002654(int data1, int data2, int data3) {\n  int result = call_function_1(data1);\n  *(int*)PTR_DAT_00002688 = data2;\n  call_function_2(result, PTR_FUN_000026f0_1_0000268c, data3);\n  return 0;\n}",
            "called": [
                "FUN_00002894",
                "FUN_000047e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002654",
            "calling": [
                "FUN_000033f4"
            ],
            "imported": false,
            "current_name": "initialize_data_and_call_function_00002654"
        },
        "FUN_00002538": {
            "renaming": {
                "FUN_00002538": "set_byte_value_00002538",
                "param_1": "value",
                "param_2": "index",
                "DAT_00002584": "data_array_ptr_1",
                "DAT_00002588": "data_array_ptr_2"
            },
            "code": "void set_byte_value_00002538(byte value, uint index) {\n  if (value < 0) {\n    *(char *)((value & 0xf) + DAT_00002584 + 0x14) = (char)((index & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)value + DAT_00002588 + 0x300) = (char)((index & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002538",
            "calling": [
                "FUN_0000258c"
            ],
            "imported": false,
            "current_name": "set_byte_value_00002538"
        },
        "FUN_00004c84": {
            "renaming": {
                "FUN_00004c84": "process_data_00004c84",
                "param_1": "data_ptr",
                "param_2": "data_size",
                "param_3": "flag_ptr",
                "param_4": "out_ptr",
                "iVar1": "data_offset",
                "uVar2": "data_ptr_copy",
                "uStack_c": "data_size_copy",
                "uStack_8": "flag_copy",
                "uStack_4": "out_copy",
                "*DAT_00004cb0": "PTR_DATA_OFFSET",
                "*(int *)(iVar1 + 0x18)": "*(int *)((char *)data_ptr + 0x18)",
                "FUN_000042a4": "cleanup_data",
                "FUN_000057f8": "process_data_internal"
            },
            "code": "void process_data_00004c84(void *data_ptr, int data_size, int *flag_ptr, int *out_ptr)\n{\n  int data_offset = **DAT_00004cb0;\n  void *data_start = (void *)((char *)data_ptr + data_offset);\n  int flag = *flag_ptr;\n  if ((data_offset != 0) && (*(int *)((char *)data_ptr + 0x18) == 0)) {\n    cleanup_data(data_ptr);\n  }\n  process_data_00004c84_internal(data_start, data_size, flag, out_ptr, data_ptr, &data_offset);\n  return;\n}",
            "called": [
                "FUN_000057f8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004c84",
            "calling": [
                "FUN_00002ecc",
                "FUN_0000305c",
                "FUN_00003524",
                "FUN_00003694",
                "FUN_00002fe0",
                "FUN_00000f04",
                "FUN_00002a88",
                "FUN_0000211c",
                "FUN_00003378",
                "FUN_00002f74",
                "FUN_0000316c",
                "FUN_00000ed8",
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "process_data_00004c84"
        },
        "FUN_0000305c": {
            "renaming": {
                "FUN_0000305c": "write_data_to_device_0000305c",
                "param_1": "num_params",
                "param_2": "params",
                "uVar1": "data",
                "auStack_20": "data_array",
                "local_18": "num_data",
                "local_14": "device_id",
                "local_10": "device_info",
                "local_c": "i",
                "FUN_00004c84": "print_message",
                "FUN_00004042": "get_data",
                "FUN_00003d24": "get_device_id",
                "FUN_00004db8": "print_error_message",
                "FUN_00004622": "initialize_data_array",
                "FUN_00003694": "write_data_to_device",
                "FUN_00003d94": "write_data_to_device"
            },
            "code": "void write_data_to_device_0000305c(int num_params, undefined4 *params){\n  undefined2 data_array[4];\n  uint num_data;\n  int device_id;\n  undefined4 device_info;\n  int i;\n  if (num_params < 4) {\n    print_error_message(PTR_s_usage___s__s__device_id___value_0_00003154, *params, params[1]);\n  }\n  else {\n    device_info = get_device_info(params[2]);\n    device_id = get_device_id(device_info);\n    if (device_id == 0) {\n      print_error_message(PTR_s_error__undefined_device_given_00003158);\n    }\n    else {\n      initialize_data_array(data_array, num_params, params);\n      print_writing_message(PTR_s_Writing_to_device___i____s_0000315c, device_info, *(undefined4 *)(device_id + 8));\n      write_data_to_device_0000305c(data_array, num_data & 0xff);\n      num_data = write_data_to_device_0000305c(device_id, data_array);\n      if (num_data < 1) {\n        if (num_data == -0x86) {\n          print_error_message(PTR_s_error__device___i_is_not_writabl_00003160, device_info);\n        }\n        else {\n          print_error_message(PTR_s_error__failure_to_write_to_devic_00003164, device_info);\n        }\n      }\n      else {\n        print_success_message(PTR_s_data_successfully_written_to_dev_00003168, device_info);\n      }\n    }\n  }\n}\n",
            "called": [
                "FUN_00003d24",
                "FUN_00004db8",
                "FUN_00004042",
                "FUN_00004c84",
                "FUN_00003d94",
                "FUN_00003694",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000305c",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "write_data_to_device_0000305c"
        },
        "FUN_000012b4": {
            "renaming": {
                "FUN_000012b4": "calculate_result_000012b4",
                "param_1": "num",
                "param_2": "str",
                "uVar1": "result",
                "FUN_00002364": "perform_calculation",
                "FUN_000024bc": "finalize_calculation"
            },
            "code": "int calculate_result_000012b4(int num, char* str) {\n    int result = perform_calculation(num + 4, str);\n    finalize_calculation(num);\n    return result;\n}",
            "called": [
                "FUN_000024bc",
                "FUN_00002364"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012b4",
            "calling": [],
            "imported": false,
            "current_name": "calculate_result_000012b4"
        },
        "FUN_00005b34": {
            "renaming": {
                "FUN_00005b34": "parse_and_execute_00005b34",
                "param_1": "input",
                "param_2": "format_specifiers",
                "param_3": "output",
                "param_4": "callback_function",
                "param_5": "arg_list_ptr",
                "bVar1": "is_divisible",
                "bVar2": "format_specifier",
                "puVar3": "hexadecimal_dict",
                "iVar4": "callback_result",
                "pcVar5": "return_value",
                "iVar6": "callback_result_byte",
                "puVar7": "output_buffer",
                "uVar8": "temp_value",
                "puVar9": "arg_list",
                "uVar10": "base",
                "uVar12": "output_buffer_size",
                "puVar13": "output_buffer_ptr",
                "local_24": "format_specifier_ptr"
            },
            "code": "\ncode * parse_and_execute_00005b34(undefined4 input,uint *format_specifiers,undefined4 output,code *callback_function,uint **arg_list_ptr\n                   )\n\n{\n  bool is_divisible;\n  byte format_specifier;\n  undefined *hexadecimal_dict;\n  int callback_result;\n  code *return_value;\n  int callback_result_byte;\n  undefined *output_buffer;\n  uint temp_value;\n  uint *arg_list;\n  uint base;\n  uint **ppuVar11;\n  uint output_buffer_size;\n  undefined *output_buffer_ptr;\n  code *format_specifier_ptr;\n  \n  hexadecimal_dict = PTR_s_0123456789ABCDEF_00005d78;\n  format_specifier = *(byte *)(format_specifiers + 6);\n  output_buffer = (undefined *)((int)format_specifiers + 0x43);\n  format_specifier_ptr = callback_function;\n  if (0x78 < format_specifier) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)format_specifiers + 0x42) = format_specifier;\nLAB_00005bdc:\n    output_buffer = (undefined *)((int)format_specifiers + 0x42);\n    temp_value = 1;\nLAB_00005d28:\n    format_specifiers[4] = temp_value;\n    *(undefined *)((int)format_specifiers + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (format_specifier < 99) {\n    if (format_specifier == 0) goto LAB_00005d06;\n    if (format_specifier == 0x58) {\n      *(undefined *)((int)format_specifiers + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(format_specifier) {\n  case 99:\n    temp_value = **arg_list_ptr;\n    *arg_list_ptr = *arg_list_ptr + 1;\n    *(char *)((int)format_specifiers + 0x42) = (char)temp_value;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    base = *format_specifiers;\n    arg_list = *arg_list_ptr;\n    if ((int)(base << 0x18) < 0) {\n      temp_value = *arg_list;\n      *arg_list_ptr = arg_list + 1;\n    }\n    else {\n      temp_value = *arg_list;\n      *arg_list_ptr = arg_list + 1;\n      if ((base & 0x40) != 0) {\n        temp_value = (uint)(short)temp_value;\n      }\n    }\n    if ((int)temp_value < 0) {\n      temp_value = -temp_value;\n      *(undefined *)((int)format_specifiers + 0x43) = 0x2d;\n    }\n    base = 10;\n    hexadecimal_dict = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*arg_list_ptr;\n    base = *format_specifiers;\n    temp_value = format_specifiers[5];\n    *arg_list_ptr = (uint *)(ppuVar11 + 1);\n    arg_list = *ppuVar11;\n    if (((int)(base << 0x18) < 0) || (-1 < (int)(base << 0x19))) {\n      *arg_list = temp_value;\n    }\n    else {\n      *(short *)arg_list = (short)temp_value;\n    }\nLAB_00005d06:\n    format_specifiers[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    arg_list = *arg_list_ptr;\n    temp_value = *format_specifiers;\n    *arg_list_ptr = arg_list + 1;\n    if (((int)(temp_value << 0x18) < 0) || (-1 < (int)(temp_value << 0x19))) {\n      temp_value = *arg_list;\n    }\n    else {\n      temp_value = (uint)*(ushort *)arg_list;\n    }\n    hexadecimal_dict = PTR_s_0123456789ABCDEF_00005d78;\n    if (format_specifier == 0x6f) {\n      base = 8;\n    }\n    else {\n      base = 10;\n    }\n    break;\n  case 0x70:\n    *format_specifiers = *format_specifiers | 0x20;\n  case 0x78:\n    hexadecimal_dict = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)format_specifiers + 0x45) = 0x78;\nLAB_00005ca8:\n    base = *format_specifiers;\n    temp_value = **arg_list_ptr;\n    *arg_list_ptr = *arg_list_ptr + 1;\n    if ((-1 < (int)(base << 0x18)) && ((int)(base << 0x19) < 0)) {\n      temp_value = temp_value & 0xffff;\n    }\n    if ((int)(base << 0x1f) < 0) {\n      *format_specifiers = base | 0x20;\n    }\n    if (temp_value == 0) {\n      *format_specifiers = *format_specifiers & 0xffffffdf;\n    }\n    base = 0x10;\n    break;\n  case 0x73:\n    arg_list = *arg_list_ptr;\n    *arg_list_ptr = arg_list + 1;\n    output_buffer = (undefined *)*arg_list;\n    callback_result = FUN_00006010(output_buffer,0,format_specifiers[1],arg_list,input,format_specifiers,output);\n    if (callback_result != 0) {\n      format_specifiers[1] = callback_result - (int)output_buffer;\n    }\n    temp_value = format_specifiers[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)format_specifiers + 0x43) = 0;\nLAB_00005c36:\n  output_buffer_size = format_specifiers[1];\n  format_specifiers[2] = output_buffer_size;\n  if (-1 < (int)output_buffer_size) {\n    *format_specifiers = *format_specifiers & 0xfffffffb;\n  }\n  output_buffer_ptr = output_buffer;\n  if ((temp_value != 0) || (output_buffer_size != 0)) {\n    do {\n      output_buffer_ptr = output_buffer_ptr + -1;\n      *output_buffer_ptr = hexadecimal_dict[temp_value - base * (temp_value / base)];\n      is_divisible = base <= temp_value;\n      temp_value = temp_value / base;\n    } while (is_divisible);\n  }\n  if (((base == 8) && ((int)(*format_specifiers << 0x1f) < 0)) && ((int)format_specifiers[1] <= (int)format_specifiers[4])) {\n    output_buffer_ptr[-1] = 0x30;\n    output_buffer_ptr = output_buffer_ptr + -1;\n  }\n  format_specifiers[4] = (int)output_buffer - (int)output_buffer_ptr;\n  output_buffer = output_buffer_ptr;\nLAB_00005c84:\n  callback_result = FUN_00005a58(input,format_specifiers,&format_specifier_ptr,output,callback_function);\n  if ((callback_result == -1) || (callback_result = (*callback_function)(input,output,output_buffer,format_specifiers[4]), callback_result == -1)) {\nLAB_00005c98:\n    return_value = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*format_specifiers << 0x1e) < 0) {\n      for (callback_result = 0; callback_result < (int)(format_specifiers[3] - (int)format_specifier_ptr); callback_result = callback_result + 1) {\n        callback_result_byte = (*callback_function)(input,output,(int)format_specifiers + 0x19,1);\n        if (callback_result_byte == -1) goto LAB_00005c98;\n      }\n    }\n    return_value = (code *)format_specifiers[3];\n    if ((int)(code *)format_specifiers[3] < (int)format_specifier_ptr) {\n      return_value = format_specifier_ptr;\n    }\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_00006010",
                "FUN_00005a58"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005b34",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "parse_and_execute_00005b34"
        },
        "FUN_0000058e": {
            "renaming": {
                "FUN_0000058e": "update_linked_list_0000058e",
                "*param_1": "*head_ptr",
                "*param_2": "*new_node_ptr"
            },
            "code": "void update_linked_list_0000058e(int *head_ptr, undefined4 *new_node_ptr)\n{\n  if (*head_ptr == 0) {\n    *new_node_ptr = new_node_ptr;\n  }\n  else {\n    *new_node_ptr = *(undefined4 *)*head_ptr;\n    *(undefined4 **) *head_ptr = new_node_ptr;\n  }\n  *head_ptr = (int)new_node_ptr;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000058e",
            "calling": [
                "FUN_00000698"
            ],
            "imported": false,
            "current_name": "update_linked_list_0000058e"
        },
        "FUN_0000656c": {
            "renaming": {
                "FUN_0000656c": "process_data_0000656c",
                "param_1": "input",
                "param_2": "params",
                "param_3": "data",
                "param_4": "output",
                "iVar1": "result",
                "uVar2": "value",
                "pcVar3": "callback",
                "uVar4": "flag",
                "pbVar5": "byte_data",
                "uVar6": "len",
                "puVar7": "output_ptr",
                "puVar8": "data_ptr",
                "puVar9": "data_ptr2",
                "puVar10": "params_ptr",
                "unaff_r9": "index",
                "iVar11": "counter",
                "local_34": "constants"
            },
            "code": "\nundefined4 process_data_0000656c(undefined4 input,uint *params,byte **data,undefined4 *output)\n\n{\n  int result;\n  undefined4 value;\n  code *callback;\n  uint flag;\n  byte *byte_data;\n  uint len;\n  undefined4 *output_ptr;\n  uint *data_ptr;\n  uint *data_ptr2;\n  uint *params_ptr;\n  int index;\n  int counter;\n  undefined4 constants [4];\n  \n  constants[0] = *(undefined4 *)PTR_PTR_DAT_00006744;\n  constants[1] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  constants[2] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  callback = (code *)PTR_LAB_00004f80_1_0000674c;\n  if (params[6] != 3) {\n    callback = (code *)PTR_LAB_00005fd4_1_00006748;\n  }\n  len = params[2];\n  flag = len - 1;\n  if (0x15c < flag) {\n    index = len - 0x15d;\n    len = 0x15d;\n  }\n  if (0x15c < flag) {\n    params[2] = len;\n  }\n  params_ptr = params + 7;\n  if (flag < 0x15d) {\n    index = 0;\n  }\n  *params = *params | 0xd00;\n  counter = 0;\n  data_ptr2 = params_ptr;\n  do {\n    result = FUN_00006010(constants[counter],**data,2);\n    if (result != 0) {\n      if (counter == 1) {\n        if (params[1] == 0) {\n          params[1] = 8;\n          *params = *params | 0x200;\n        }\n        flag = *params & 0xfffffaff;\nLAB_000065f4:\n        *params = flag;\n      }\n      else if (counter == 2) {\n        if ((*params & 0x600) != 0x200) goto LAB_00006624;\n        params[1] = 0x10;\n        flag = *params | 0x100;\n        goto LAB_000065f4;\n      }\n      flag = params[2];\n      params[2] = flag - 1;\n      if (flag != 0) {\n        byte_data = *data;\n        *data = byte_data + 1;\n        data_ptr = (uint *)((int)data_ptr2 + 1);\n        *(byte *)data_ptr2 = *byte_data;\n        byte_data = data[1];\n        data[1] = byte_data + -1;\n        data_ptr2 = data_ptr;\n        if (((int)(byte_data + -1) < 1) &&\n           (result = (*(code *)params[0x60])(input,data), result != 0)) {\n          counter = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    counter = counter + 1;\n  } while (counter != 3);\n  if (params[1] == 0) {\n    params[1] = 10;\n  }\n  FUN_0000687c(params[5],(int)PTR_DAT_00006750 - params[1]);\n  counter = 0;\n  while( true ) {\n    data_ptr = data_ptr2;\n    if (params[2] == 0) break;\n    byte_data = *data;\n    flag = (uint)*byte_data;\n    if (*(char *)(params[5] + flag) == '\\0') break;\n    if ((flag == 0x30) && ((int)(*params << 0x14) < 0)) {\n      counter = counter + 1;\n      if (index != 0) {\n        index = index + -1;\n        params[2] = params[2] + 1;\n      }\n    }\n    else {\n      *params = *params & 0xfffff6ff;\n      data_ptr = (uint *)((int)data_ptr2 + 1);\n      *(byte *)data_ptr2 = *byte_data;\n    }\n    byte_data = data[1];\n    data[1] = byte_data + -1;\n    if ((int)(byte_data + -1) < 1) {\n      result = (*(code *)params[0x60])(input,data);\n      if (result != 0) break;\n    }\n    else {\n      *data = *data + 1;\n    }\n    params[2] = params[2] - 1;\n    data_ptr2 = data_ptr;\n  }\nLAB_000066ca:\n  if ((int)(*params << 0x17) < 0) {\n    if (params_ptr < data_ptr) {\n      (*(code *)params[0x5f])(input,*(byte *)((int)data_ptr + -1),data);\n      data_ptr = (uint *)((int)data_ptr + -1);\n    }\n    if (data_ptr == params_ptr) {\n      return 1;\n    }\n  }\n  if ((*params & 0x10) == 0) {\n    *(byte *)data_ptr = 0;\n    value = (*callback)(input,params_ptr,0,params[1]);\n    output_ptr = (undefined4 *)*output;\n    flag = *params;\n    *output = output_ptr + 1;\n    output_ptr = (undefined4 *)*output_ptr;\n    if ((flag & 0x20) == 0) {\n      if ((int)(flag << 0x1f) < 0) {\n        *(short *)output_ptr = (short)value;\n      }\n      else {\n        *output_ptr = value;\n      }\n    }\n    else {\n      *output_ptr = value;\n    }\n    params[3] = params[3] + 1;\n  }\n  params[4] = (uint)((int)data_ptr + params[4] + (counter - (int)params_ptr));\n  return 0;\n}\n\n",
            "called": [
                "FUN_0000687c",
                "FUN_00006010"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000656c",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "process_data_0000656c"
        },
        "FUN_000025f4": {
            "renaming": {
                "FUN_000025f4": "execute_function_000025f4",
                "FUN_000027b0": "call_helper_function"
            },
            "code": "void execute_function_000025f4(void)\n{\n  call_helper_function();\n  return;\n}",
            "called": [
                "FUN_000027b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000025f4",
            "calling": [
                "FUN_00002396"
            ],
            "imported": false,
            "current_name": "execute_function_000025f4"
        },
        "FUN_00001ddc": {
            "renaming": {
                "FUN_00001ddc": "print_char_with_tabulation_00001ddc",
                "param_1": "input_char",
                "cVar1": "processed_char",
                "FUN_00001da2": "process_char",
                "FUN_00001d3a": "print_to_console"
            },
            "code": "void print_char_with_tabulation_00001ddc(undefined2 input_char){\n  char processed_char = process_char(input_char);\n  print_to_console(DAT_00001e08, processed_char + '\t');\n  return;\n}",
            "called": [
                "FUN_00001d3a",
                "FUN_00001da2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ddc",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "print_char_with_tabulation_00001ddc"
        },
        "FUN_00002ecc": {
            "renaming": {
                "FUN_00002ecc": "read_data_from_device_and_print_00002ecc",
                "param_1": "device_address",
                "param_2": "buffer_address",
                "auStack_1c": "buffer",
                "local_14": "read_size",
                "uVar1": "data",
                "uVar2": "type"
            },
            "code": "void read_data_from_device_and_print_00002ecc(int device_address, int buffer_address)\n{\n  int read_size;\n  char buffer[8];\n  read_size = read_data_from_device(device_address, buffer);\n  if (read_size < 1) {\n    print_error(\"error: failed to read from device\", device_address);\n  }\n  else {\n    int data = *(int *)(buffer_address + 8);\n    char* type = get_type_name(*(char *)(*(int *)(buffer_address + 12) + 8));\n    print_message(\"Reading from %d, %s %s\", device_address, data, type);\n    process_data(buffer, read_size & 0xff);\n  }\n  return;\n}",
            "called": [
                "FUN_00003d64",
                "FUN_00004c84",
                "FUN_000039e8",
                "FUN_00003694"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002ecc",
            "calling": [
                "FUN_00002f30",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "read_data_from_device_and_print_00002ecc"
        },
        "FUN_00000d76": {
            "renaming": {
                "FUN_00000d76": "set_first_int_to_zero_00000d76",
                "param_1": "base_address",
                "param_2": "byte_offset",
                "puVar1": "address_of_first_int",
                "FUN_00000d44": "get_address_of_first_int"
            },
            "code": "void set_first_int_to_zero_00000d76(undefined4 base_address, undefined byte_offset)\n{\n  undefined4 *address_of_first_int;\n  address_of_first_int = (undefined4 *)get_address_of_first_int(base_address, byte_offset);\n  *address_of_first_int = 0;\n  return;\n}",
            "called": [
                "FUN_00000d44"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d76",
            "calling": [
                "FUN_00000d9c"
            ],
            "imported": false,
            "current_name": "set_first_int_to_zero_00000d76"
        },
        "FUN_000057a8": {
            "renaming": {
                "FUN_000057a8": "decrement_and_store_char_000057a8",
                "param_1": "count",
                "param_2": "character",
                "param_3": "buffer",
                "iVar1": "new_count",
                "puVar2": "new_buffer"
            },
            "code": "int decrement_and_store_char_000057a8(undefined4 count, int character, undefined4 *buffer) {\n  int new_count = buffer[2] - 1;\n  buffer[2] = new_count;\n  if ((new_count < 0) && ((new_count < (int)buffer[6] || (character == 10)))) {\n    int result = FUN_00005404();\n    return result;\n  }\n  undefined *new_buffer = (undefined *)*buffer;\n  *buffer = new_buffer + 1;\n  *new_buffer = (char)character;\n  return character;\n}",
            "called": [
                "FUN_00005404"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057a8",
            "calling": [
                "FUN_000057d2"
            ],
            "imported": false,
            "current_name": "decrement_and_store_char_000057a8"
        },
        "FUN_00001696": {
            "renaming": {
                "FUN_00001696": "calculate_new_value_00001696",
                "param_1": "input_value",
                "param_2": "multiplier",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int calculate_new_value_00001696(uint32_t input_value, int multiplier) {\n    uint32_t masked_input = input_value & 0xf0000000;\n    uint32_t shifted_input = (input_value & 0xfffff) << 5;\n    int added_value = 0x2000000;\n    return (multiplier * 4) + masked_input + shifted_input + added_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001696",
            "calling": [
                "FUN_00001710",
                "FUN_000016c8",
                "FUN_000016ec"
            ],
            "imported": false,
            "current_name": "calculate_new_value_00001696"
        },
        "FUN_000008b8": {
            "renaming": {
                "FUN_000008b8": "count_Elf32_Rel_ARRAY_items_000008b8",
                "PTR_DAT_000008f4": "rel_item_array_start_ptr",
                "DAT_000008f8": "rel_item_array_value",
                "PTR_Elf32_Rel_ARRAY_000008fc": "rel_item_array_end_ptr",
                "local_c": "rel_item_ptr"
            },
            "code": "int count_Elf32_Rel_ARRAY_items_000008b8(void)\n{\n  int *rel_item_ptr;\n  for (rel_item_ptr = (int *)PTR_DAT_000008f4; (*rel_item_ptr == DAT_000008f8 && (rel_item_ptr < PTR_Elf32_Rel_ARRAY_000008fc)); rel_item_ptr++)\n  {\n  }\n  return ((int)PTR_Elf32_Rel_ARRAY_000008fc - (int)rel_item_ptr >> 2) << 2;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000008b8",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "count_Elf32_Rel_ARRAY_items_000008b8"
        },
        "FUN_000024bc": {
            "renaming": {
                "FUN_000024bc": "process_integer_000024bc",
                "param_1": "input_integer",
                "uVar1": "undefined_value",
                "uVar2": "random_int",
                "iVar3": "processed_integer",
                "FUN_00000cd0": "generate_random_int",
                "FUN_00000d0c": "perform_action",
                "FUN_0000240c": "modify_integer",
                "FUN_00000698": "print_integer",
                "FUN_00000738": "print_character"
            },
            "code": "void process_integer_000024bc(int *input_integer)\n{\n    undefined uVar1;\n    undefined4 random_int = generate_random_int();\n    if (*input_integer == 0) {\n        perform_action(random_int);\n    }\n    else if (*input_integer == -1) {\n        *input_integer = 0;\n        perform_action(random_int);\n    }\n    else {\n        int processed_integer = modify_integer(input_integer);\n        print_integer(processed_integer - 8, 10);\n        if (*input_integer == 0) {\n            *input_integer = -1;\n        }\n        uVar1 = *(undefined *)(processed_integer - 3);\n        perform_action(random_int);\n        print_character(uVar1);\n    }\n    return;\n}",
            "called": [
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_0000240c",
                "FUN_00000738",
                "FUN_00000698"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000024bc",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": false,
            "current_name": "process_integer_000024bc"
        },
        "FUN_00000490": {
            "renaming": {
                "FUN_00000490": "perform_operation_on_params_00000490",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "result",
                "FUN_00000e14": "perform_complex_operation"
            },
            "code": "int perform_operation_on_params_00000490(int param1, int param2, int param3, int param4) {\n  int result = perform_complex_operation(param3, param4);\n  return result;\n}",
            "called": [
                "FUN_00000e14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000490",
            "calling": [
                "FUN_00004dc8"
            ],
            "imported": false,
            "current_name": "perform_operation_on_params_00000490"
        },
        "FUN_0000091c": {
            "renaming": {
                "FUN_0000091c": "get_pointer_data_0000091c",
                "PTR_DAT_0000092c": "pointer_data"
            },
            "code": "const char* get_pointer_data_0000091c() {\n  return PTR_DAT_0000092c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000091c",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_pointer_data_0000091c"
        },
        "FUN_00001f80": {
            "renaming": {
                "FUN_00001f80": "update_data_in_memory_block_00001f80",
                "param_1": "block_start_address",
                "param_2": "new_data",
                "FUN_00001ddc": "initialize_memory_block",
                "FUN_00001d5e": "get_index_of_data_to_update",
                "FUN_00001dc0": "get_offset_of_data_to_update",
                "uVar3": "parameter1",
                "uVar4": "parameter2",
                "uVar5": "current_data"
            },
            "code": "void update_data_in_memory_block_00001f80(undefined2 block_start_address, undefined4 new_data) {\n  int index_of_data_to_update = get_index_of_data_to_update(block_start_address);\n  int offset_of_data_to_update = get_offset_of_data_to_update(block_start_address);\n  uint current_data = *(uint *)(index_of_data_to_update + offset_of_data_to_update * 4);\n  *(undefined4 *)(index_of_data_to_update + offset_of_data_to_update * 4) = new_data;\n  if ((current_data & 0xf0000) != 0) {\n    undefined4 parameter1 = get_parameter1(block_start_address);\n    int parameter2 = get_offset_of_data_to_update(block_start_address);\n    execute_function(parameter1, parameter2);\n  }\n  return;\n}",
            "called": [
                "FUN_00001d5e",
                "FUN_00001ec4",
                "FUN_00001da2",
                "FUN_00001ddc",
                "FUN_00001dc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001f80",
            "calling": [
                "FUN_00001eea",
                "FUN_00001448"
            ],
            "imported": false,
            "current_name": "update_data_in_memory_block_00001f80"
        },
        "FUN_00000e64": {
            "renaming": {
                "FUN_00000e64": "enable_interrupts_00000e64",
                "DAT_00000ed0": "offset1",
                "FUN_00001034": "base_address",
                "DAT_00000ed4": "offset2",
                "FUN_00001274": "enable_timer_interrupts",
                "FUN_00001eea": "enable_gpio_interrupts",
                "FUN_00001ff6": "enable_gpio_interrupt"
            },
            "code": "void enable_interrupts_00000e64()\n{\n    uint* reg1 = (uint*)(FUN_00001034 + DAT_00000ed0 + 4);\n    *reg1 |= 0x200;\n    uint* reg2 = (uint*)(DAT_00000ed4 + 0x48);\n    *reg2 &= 0xfefff8ff;\n    enable_timer_interrupts();\n    enable_gpio_interrupts(0x2056, 0x80);\n    enable_gpio_interrupts(0x511a, 0x80);\n    enable_gpio_interrupts(0x2055, 0x80);\n    enable_gpio_interrupt(0x2056);\n    enable_gpio_interrupt(0x511a);\n    enable_gpio_interrupt(0x2055);\n    return;\n}",
            "called": [
                "FUN_00001eea",
                "FUN_00001274",
                "FUN_00001ff6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e64",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "enable_interrupts_00000e64"
        },
        "FUN_000026e4": {
            "renaming": {
                "FUN_000026e4": "execute_function_000026e4",
                "FUN_00002970": "call_helper_function"
            },
            "code": "void execute_function_000026e4(void)\n{\n  call_helper_function();\n  return;\n}",
            "called": [
                "FUN_00002970"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026e4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "execute_function_000026e4"
        },
        "FUN_00000d44": {
            "renaming": {
                "FUN_00000d44": "calculate_offset_00000d44",
                "param_1": "address",
                "param_2": "offset",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int calculate_offset_00000d44(uint32_t address, int offset) {\n    uint32_t upper_bits = address & 0xf0000000;\n    uint32_t lower_bits = address & 0xfffff;\n    uint32_t shifted_lower_bits = lower_bits << 5;\n    int result = offset * 4 + upper_bits + shifted_lower_bits + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d44",
            "calling": [
                "FUN_00000d76"
            ],
            "imported": false,
            "current_name": "calculate_offset_00000d44"
        },
        "FUN_00000698": {
            "renaming": {
                "FUN_00000698": "update_status_00000698",
                "param_1": "status",
                "param_2": "index",
                "MAX_STATUS": "9",
                "PTR_DAT_00000730": "data_ptr",
                "PTR_DAT_00000734": "status_ptr",
                "*(byte *)(param_1 + 4)": "*(uint8_t*)(index + 4)",
                "FUN_000005ca": "check_data",
                "*(int *)(PTR_DAT_00000730 + (uint)*(byte *)(param_1 + 5) * 4)": "*(uint32_t*)(data_ptr + *(uint8_t*)(index + 5))",
                "*(sbyte *)(param_1 + 5)": "*(uint8_t*)(index + 5)",
                "*status_ptr": "*status_ptr",
                "*(char *)(param_1 + 4)": "*(uint8_t*)(index + 4)",
                "FUN_0000058e": "update_data"
            },
            "code": "void update_status_00000698(int status, uint8_t index)\n{\n    uint8_t MAX_STATUS = 9;\n    uint32_t* PTR_DAT_00000730 = (uint32_t*)0x00000730;\n    uint32_t* PTR_DAT_00000734 = (uint32_t*)0x00000734;\n\n    if (status < MAX_STATUS) {\n        uint8_t min_index = 8;\n        uint8_t current_index = *(uint8_t*)(index + 5);\n        uint32_t* current_PTR_DAT_00000730 = PTR_DAT_00000730 + current_index;\n        if (min_index < *(uint8_t*)(index + 4) && *current_PTR_DAT_00000730 == 0) {\n            *PTR_DAT_00000734 = *PTR_DAT_00000734 & ~(1 << current_index);\n        }\n    }\n    else {\n        if (*(uint8_t*)(index + 4) < MAX_STATUS) {\n            uint32_t* current_PTR_DAT_00000730 = PTR_DAT_00000730 + *(uint8_t*)(index + 5);\n            uint8_t* data = (uint8_t*)(index + 8);\n            *current_PTR_DAT_00000730 = (uint32_t)((*data << 24) | (*(data + 1) << 16) | (*(data + 2) << 8) | *(data + 3));\n            *PTR_DAT_00000734 = *PTR_DAT_00000734 | 1 << *(uint8_t*)(index + 5);\n        }\n    }\n    *(uint8_t*)(index + 4) = (uint8_t)status;\n}",
            "called": [
                "FUN_0000058e",
                "FUN_000005ca"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000698",
            "calling": [
                "FUN_000024bc",
                "FUN_00000794",
                "FUN_000010d4",
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "update_status_00000698"
        },
        "FUN_00000cd0": {
            "renaming": {
                "FUN_00000cd0": "is_interrupts_enabled_in_privileged_mode_00000cd0",
                "uVar2": "is_interrupts_enabled",
                "bVar1": "is_privileged_mode"
            },
            "code": "bool is_interrupts_enabled_in_privileged_mode_00000cd0(void)\n{\n  bool is_privileged_mode = isCurrentModePrivileged();\n  bool is_interrupts_enabled = false;\n  if (is_privileged_mode) {\n    is_interrupts_enabled = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return is_interrupts_enabled;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cd0",
            "calling": [
                "FUN_00001c84",
                "FUN_00000f04",
                "FUN_00000f8c",
                "FUN_00000e58",
                "FUN_00000428",
                "FUN_000024bc",
                "FUN_00000794",
                "FUN_000010d4",
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "is_interrupts_enabled_in_privileged_mode_00000cd0"
        },
        "FUN_00000cc0": {
            "renaming": {
                "FUN_00000cc0": "check_IRQ_interrupts_enabled_00000cc0",
                "uVar2": "is_IRQ_interrupts_enabled",
                "bVar1": "is_privileged_mode",
                "isCurrentModePrivileged": "is_current_mode_privileged",
                "isIRQinterruptsEnabled": "is_IRQ_interrupts_enabled",
                "disableIRQinterrupts": "disable_IRQ_interrupts"
            },
            "code": "bool is_IRQ_interrupts_enabled = false;\nbool is_privileged_mode = check_IRQ_interrupts_enabled_00000cc0();\nif (is_privileged_mode) {\n  is_IRQ_interrupts_enabled = is_IRQ_interrupts_enabled();\n}\ndisable_IRQ_interrupts();\nreturn is_IRQ_interrupts_enabled;",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cc0",
            "calling": [
                "FUN_00000dc0"
            ],
            "imported": false,
            "current_name": "check_IRQ_interrupts_enabled_00000cc0"
        },
        "FUN_00002994": {
            "renaming": {
                "FUN_00002994": "process_data_00002994",
                "iVar1": "data",
                "DAT_000029f8": "data_address",
                "PTR_DAT_000029fc": "callback_ptr",
                "undefined4": "uint",
                "code": "function_pointer",
                "FUN_00002798": "perform_cleanup"
            },
            "code": "void process_data_00002994()\n{\n  int data = DAT_000029f8;\n  if (((*(uint *)(data + 0x14) & 4) != 0) && (*(int *)PTR_DAT_000029fc != 0)) {\n    *(uint *)(data + 0x1c) = *(uint *)(data + 0x1c) & 0xfffffffb;\n    (**(code **)PTR_DAT_000029fc)(*(undefined4 *)(PTR_DAT_000029fc + 4));\n  }\n  if (((*(uint *)(data + 0x14) & 2) != 0) && (*(int *)(PTR_DAT_000029fc + 8) != 0)) {\n    (**(code **)(PTR_DAT_000029fc + 8))(*(undefined4 *)(PTR_DAT_000029fc + 0xc));\n  }\n  perform_cleanup();\n  return;\n}\n",
            "called": [
                "FUN_00002798"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002994",
            "calling": [],
            "imported": false,
            "current_name": "process_data_00002994"
        },
        "FUN_00000d2a": {
            "renaming": {
                "FUN_00000d2a": "get_current_exception_number_if_privileged_mode_00000d2a",
                "bVar1": "is_privileged_mode",
                "uVar2": "current_exception_number"
            },
            "code": "uint get_current_exception_number_if_privileged_mode_00000d2a(void)\n{\n  bool is_privileged_mode;\n  uint current_exception_number;\n  \n  current_exception_number = 0;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    current_exception_number = getCurrentExceptionNumber();\n    current_exception_number = current_exception_number & 0x1f;\n  }\n  return current_exception_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d2a",
            "calling": [
                "FUN_00000738"
            ],
            "imported": false,
            "current_name": "get_current_exception_number_if_privileged_mode_00000d2a"
        },
        "FUN_00001ff6": {
            "renaming": {
                "FUN_00001ff6": "set_bit_in_int_array_00001ff6",
                "param_1": "array_index",
                "uVar1": "bit_index",
                "iVar2": "int_array_ptr",
                "*(int *)(iVar2 + 4)": "bit_mask",
                "FUN_00001dc0": "get_bit_index",
                "FUN_00001d80": "get_int_array_pointer"
            },
            "code": "void set_bit_in_int_array_00001ff6(int array_index) {\n  uint8_t bit_index = get_bit_index(array_index);\n  int* int_array_ptr = get_int_array_pointer(array_index);\n  uint32_t bit_mask = 1 << bit_index;\n  *(int *)(int_array_ptr + 4) = bit_mask;\n  return;\n}",
            "called": [
                "FUN_00001d80",
                "FUN_00001dc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ff6",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "set_bit_in_int_array_00001ff6"
        },
        "FUN_000013b8": {
            "renaming": {
                "FUN_000013b8": "set_data_at_index_000013b8",
                "param_1": "index",
                "param_2": "data",
                "param_3": "status",
                "param_4": "assertion",
                "PTR_s_FAILED_ASSERTION__0000143c": "ERROR_MESSAGE",
                "PTR_DAT_00001440": "DATA_ARRAY",
                "FUN_00000f04": "assert",
                "FUN_00001448": "set_status",
                "FUN_00001392": "set_data",
                "PTR_DAT_00001444": "STATUS_ARRAY"
            },
            "code": "int set_data_at_index_000013b8(int index, int data, int status, int assertion) {\n  if (index != 0) {\n    assert(0 && \"Index out of range\");\n  }\n  int* data_ptr = (int*)(PTR_DAT_00001440 + index * 8);\n  int* status_ptr = (int*)(PTR_DAT_00001440 + index * 8 + 4);\n  set_status(index);\n  set_data(*((int*)(PTR_DAT_00001444 + index * 0x20 + 0x18)), PTR_DAT_00001444[index * 0x20 + 0x1c]);\n  if (PTR_DAT_00001444[index * 0x20 + 0x1e] == 0) {\n    set_data(index, data);\n    return 0;\n  }\n  else {\n    return -1;\n  }\n}",
            "called": [
                "FUN_00000f04",
                "FUN_00001392",
                "FUN_00001448",
                "FUN_000014c4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000013b8",
            "calling": [
                "FUN_00000df4"
            ],
            "imported": false,
            "current_name": "set_data_at_index_000013b8"
        },
        "FUN_00002a88": {
            "renaming": {
                "FUN_00002a88": "print_command_description_00002a88",
                "param_1": "command_array",
                "local_18": "command_info",
                "local_10": "index",
                "local_c": "current_command"
            },
            "code": "void print_command_description_00002a88(int *command_array)\n{\n    int *command_info[2];\n    uint index;\n    int *current_command;\n    print_formatted_text(\"%20s %s\\n\", \"Command\", \"Description\");\n    print_formatted_text(\"%s\\n\", \"----------------------------------------\");\n    print_formatted_text(\"%s\\n\", \"Reboot Commands:\");\n    command_info[0] = command_array;\n    command_info[1] = (int *)PTR_PTR_s_reboot_00002b0c;\n    for (index = 0; index < 2; index++) {\n        current_command = command_info[index];\n        if (current_command != (int *)0x0) {\n            for (; *current_command != 0; current_command = current_command + 3) {\n                print_formatted_text(\"%20s %s\\n\", *current_command, current_command[1]);\n            }\n        }\n    }\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a88",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "print_command_description_00002a88"
        },
        "FUN_00002f30": {
            "renaming": {
                "FUN_00002f30": "iterate_linked_list_00002f30",
                "local_10": "index",
                "local_c": "current_node",
                "PTR_DAT_00002f6c": "current_node_pointer",
                "FUN_00002ecc": "process_node",
                "PTR_DAT_00002f70": "node_printer"
            },
            "code": "void iterate_linked_list_00002f30(void)\n{\n  int index = 0;\n  undefined4 *current_node = *(undefined4 **)PTR_DAT_00002f6c;\n  while (current_node != (undefined4 *)0x0) {\n    process_node(index, current_node);\n    print_node(PTR_DAT_00002f70);\n    index++;\n    current_node = (undefined4 *)*current_node;\n  }\n  return;\n}",
            "called": [
                "FUN_00002ecc",
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f30",
            "calling": [
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "iterate_linked_list_00002f30"
        },
        "FUN_00001e44": {
            "renaming": {
                "FUN_00001e44": "update_bits_at_index_00001e44",
                "param_1": "index",
                "param_2": "bit_position",
                "param_3": "new_bits_value",
                "iVar1": "shifted_bit_position",
                "PTR_DAT_00001ec0": "data_ptr",
                "clear_mask": "clear_mask",
                "set_mask": "set_mask",
                "*target_ptr": "*target_ptr",
                "*data_ptr": "*data_ptr"
            },
            "code": "void update_bits_at_index_00001e44(int index, uint32_t bit_position, uint32_t new_bits_value)\n{\n    uint32_t* PTR_DAT_00001ec0 = (uint32_t*) PTR_DAT_00001ec0;\n    uint32_t shifted_bit_position = bit_position >> 3;\n    uint32_t* target_ptr = PTR_DAT_00001ec0 + (shifted_bit_position + index * 4);\n    uint32_t clear_mask = ~(0xf << ((bit_position & 7) << 2));\n    uint32_t set_mask = new_bits_value << ((bit_position & 7) << 2);\n    *target_ptr = (*target_ptr & clear_mask) | set_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e44",
            "calling": [
                "FUN_00001ec4"
            ],
            "imported": false,
            "current_name": "update_bits_at_index_00001e44"
        },
        "FUN_00001318": {
            "renaming": {
                "FUN_00001318": "set_bit_in_array_00001318",
                "param_1": "bit_index",
                "DAT_00001344": "array_start_ptr"
            },
            "code": "void set_bit_in_array_00001318(uint8_t bit_index) {\n    uint32_t* array_ptr = (uint32_t*)(DAT_00001344 + ((uint32_t)bit_index >> 5) * 4);\n    uint32_t bit_mask = 1 << (bit_index & 0x1f);\n    *array_ptr = bit_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001318",
            "calling": [
                "FUN_000014c4"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_00001318"
        },
        "FUN_00000900": {
            "renaming": {
                "FUN_00000900": "get_stack_pointer_00000900",
                "uVar1": "stack_pointer"
            },
            "code": "unsigned int get_stack_pointer_00000900()\n{\n  unsigned int stack_pointer;\n  stack_pointer = getMainStackPointer();\n  return stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000900",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_stack_pointer_00000900"
        },
        "FUN_00004274": {
            "renaming": {
                "FUN_00004274": "do_nothing_with_pointer_00004274",
                "PTR_DAT_0000427c": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_00004274(void)\n{\n    do_nothing(PTR_DAT_0000427c);\n    return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004274",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00004274"
        },
        "FUN_00002fe0": {
            "renaming": {
                "FUN_00002fe0": "check_device_id_00002fe0",
                "param_1": "num_params",
                "param_2": "params",
                "iVar1": "is_valid_device_id",
                "uVar2": "device_id",
                "PTR_s_usage___s__s__device_id__all_00003050": "usage_string",
                "PTR_DAT_00003054": "valid_device_ids",
                "FUN_00004c84": "print_usage",
                "FUN_00004e52": "get_device_id_status",
                "FUN_00002f30": "process_valid_device_id",
                "FUN_00004042": "get_device_id",
                "FUN_00003d24": "check_device_id_status",
                "PTR_s_error__undefined_device_id_given_00003058": "undefined_device_id_error",
                "FUN_00004db8": "print_error",
                "FUN_00002ecc": "process_device_id"
            },
            "code": "void check_device_id_00002fe0(int num_params, undefined4 *params)\n{\n    int is_valid_device_id;\n    undefined4 device_id;\n\n    if (num_params < 3) {\n        print_usage(PTR_s_usage___s__s__device_id__all_00003050, *params, params[1]);\n    }\n    else {\n        is_valid_device_id = get_device_id_status(params[2], PTR_DAT_00003054);\n        if (is_valid_device_id == 0) {\n            print_error(PTR_s_error__undefined_device_id_given_00003058);\n        }\n        else {\n            device_id = get_device_id(params[2]);\n            int device_id_status = check_device_id_00002fe0_status(device_id);\n            if (device_id_status == 0) {\n                print_error(PTR_s_error__undefined_device_id_given_00003058);\n            }\n            else {\n                process_device_id(device_id, device_id_status);\n            }\n        }\n    }\n    return;\n}",
            "called": [
                "FUN_00002ecc",
                "FUN_00003d24",
                "FUN_00004db8",
                "FUN_00004042",
                "FUN_00004c84",
                "FUN_00002f30",
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002fe0",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "check_device_id_00002fe0"
        },
        "FUN_00001dc0": {
            "renaming": {
                "FUN_00001dc0": "extract_lower_6_bits_00001dc0",
                "param_1": "input",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "ushort extract_lower_6_bits_00001dc0(ushort input)\n{\n    ushort lower_6_bits = input & 0x3f;\n    return lower_6_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001dc0",
            "calling": [
                "FUN_00001eea",
                "FUN_00001f80",
                "FUN_00001ff6"
            ],
            "imported": false,
            "current_name": "extract_lower_6_bits_00001dc0"
        },
        "FUN_00000df4": {
            "renaming": {
                "FUN_00000df4": "initialize_device_00000df4",
                "FUN_000013b8": "set_device_mode",
                "PTR_FUN_000012b4_1_00000e10": "function_pointer",
                "DAT_00000e0c": "data"
            },
            "code": "void initialize_device_00000df4(void)\n{\n  set_device_mode(0, 0x1c200, PTR_FUN_000012b4_1_00000e10, DAT_00000e0c);\n  return;\n}",
            "called": [
                "FUN_000013b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000df4",
            "calling": [
                "FUN_00000410"
            ],
            "imported": false,
            "current_name": "initialize_device_00000df4"
        },
        "FUN_00002400": {
            "renaming": {
                "FUN_00002400": "do_nothing_00002400"
            },
            "code": "\nvoid do_nothing_00002400(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002400",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "do_nothing_00002400"
        },
        "FUN_00002eb4": {
            "renaming": {
                "FUN_00002eb4": "initialize_program_00002eb4",
                "FUN_0000211c": "initialize_data"
            },
            "code": "int initialize_program_00002eb4() {\n  initialize_data();\n  return 0;\n}",
            "called": [
                "FUN_0000211c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002eb4",
            "calling": [],
            "imported": false,
            "current_name": "initialize_program_00002eb4"
        },
        "FUN_0000328c": {
            "renaming": {
                "FUN_0000328c": "decode_data_0000328c",
                "param_1": "data_array",
                "param_2": "decoded_data",
                "iVar1": "decoded_result",
                "local_10": "current_index",
                "local_a": "decoded_value",
                "FUN_00004f84": "decode"
            },
            "code": "int decode_data_0000328c(int *data_array, int *decoded_data) {\n    int current_index = 0;\n    short decoded_value;\n    decoded_value = get_decoded_value(data_array[current_index], &current_index, 10);\n    decoded_data[5] = decoded_value - 0x76c;\n    decoded_value = get_decoded_value(data_array[current_index] + 1, &current_index, 10);\n    decoded_data[4] = decoded_value - 1;\n    decoded_value = get_decoded_value(data_array[current_index] + 1, &current_index, 10);\n    decoded_data[3] = (int)decoded_value;\n    decoded_value = get_decoded_value(data_array[1], &current_index, 10);\n    decoded_data[2] = (int)decoded_value;\n    decoded_value = get_decoded_value(data_array[current_index] + 1, &current_index, 10);\n    decoded_data[1] = (int)decoded_value;\n    decoded_value = get_decoded_value(data_array[current_index] + 1, &current_index, 10);\n    *decoded_data = (int)decoded_value;\n    int decoded_result = decode(decoded_data[5] + 0x76c, decoded_data[4] + 1, decoded_data[3]);\n    decoded_data[6] = decoded_result;\n    decoded_data[8] = -1;\n    return 0;\n}\n\nshort get_decoded_value(int value, int* current_index, int base) {\n    short decoded_value = decode(value, current_index, base);\n    return decoded_value;\n}\n",
            "called": [
                "FUN_000031fc",
                "FUN_00004f84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000328c",
            "calling": [
                "FUN_00003478",
                "FUN_000033f4"
            ],
            "imported": false,
            "current_name": "decode_data_0000328c"
        },
        "FUN_000041f4": {
            "renaming": {
                "FUN_000041f4": "initialize_data_structures_000041f4",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2",
                "puVar1": "pointer_to_label_00004e4a_1_00004238"
            },
            "code": "void initialize_data_structures_000041f4(undefined4 *data, undefined2 value1, undefined2 value2) {\n  data[0] = 0;\n  data[1] = 0;\n  data[2] = 0;\n  data[3] = value1;\n  data[4] = 0;\n  data[5] = 0;\n  data[6] = 0;\n  data[7] = 0;\n  data[8] = data;\n  data[9] = PTR_FUN_00004dc8_1_0000422c;\n  data[10] = DAT_00004230;\n  data[11] = PTR_FUN_00004e26_1_00004234;\n  data[12] = PTR_LAB_00004e4a_1_00004238;\n  data[25] = 0;\n  return;\n}",
            "called": [
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041f4",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "initialize_data_structures_000041f4"
        },
        "FUN_0000316c": {
            "renaming": {
                "FUN_0000316c": "validate_and_execute_0000316c",
                "param_1": "arg_count",
                "param_2": "args",
                "iVar1": "result",
                "FUN_00002f74": "print_error",
                "FUN_00004e52": "compare_strings",
                "PTR_DAT_000031d4": "constant_string1",
                "FUN_00002fe0": "execute_function1",
                "PTR_s_write_000031d8": "constant_string2",
                "FUN_0000305c": "execute_function2",
                "PTR_s_usage___s_read_write_000031dc": "error_message"
            },
            "code": "int validate_and_execute_0000316c(int arg_count, undefined4 *args)\n{\n    int result;\n    if (arg_count < 2) {\n        print_error();\n    }\n    else {\n        result = compare_strings(args[1], PTR_DAT_000031d4);\n        if (result == 0) {\n            execute_function1(arg_count, args);\n        }\n        else {\n            result = compare_strings(args[1], PTR_s_write_000031d8);\n            if (result == 0) {\n                execute_function2(arg_count, args);\n            }\n            else {\n                print_error(PTR_s_usage___s_read_write_000031dc, *args);\n            }\n        }\n    }\n    return 0;\n}",
            "called": [
                "FUN_0000305c",
                "FUN_00004c84",
                "FUN_00004e52",
                "FUN_00002f74",
                "FUN_00002fe0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000316c",
            "calling": [],
            "imported": false,
            "current_name": "validate_and_execute_0000316c"
        },
        "FUN_000026f0": {
            "renaming": {
                "FUN_000026f0": "execute_function_if_not_null_000026f0",
                "param_1": "function_pointer",
                "PTR_DAT_00002710": "function_pointer",
                "**(code **)PTR_DAT_00002710": "*(void (**)())function_pointer",
                "*(int *)PTR_DAT_00002710": "*function_pointer"
            },
            "code": "void execute_function_if_not_null_000026f0(int* PTR_DAT_00002710){\n  if (*(int *)PTR_DAT_00002710 != 0) {\n    (***(code **)PTR_DAT_00002710)();\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026f0",
            "calling": [],
            "imported": false,
            "current_name": "execute_function_if_not_null_000026f0"
        },
        "FUN_000057d2": {
            "renaming": {
                "FUN_000057d2": "process_data_000057d2",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "data",
                "param_4": "data_len",
                "iVar1": "result",
                "puVar2": "end_of_data",
                "iVar3": "current_index",
                "FUN_000057a8": "process_byte"
            },
            "code": "int process_data_000057d2(undefined4 param1, undefined4 param2, undefined* data, int data_len) {\n  int result = 0;\n  undefined* current_byte = data;\n  for (int i = 0; i < data_len; i++) {\n    result = process_byte(param1, *current_byte, param2, i, data_len);\n    current_byte++;\n  }\n  return result;\n}",
            "called": [
                "FUN_000057a8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057d2",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "process_data_000057d2"
        },
        "FUN_000056b8": {
            "renaming": {
                "FUN_000056b8": "check_permissions_and_set_result_000056b8",
                "param_1": "permission_value",
                "param_2": "permission_check",
                "param_3": "result",
                "param_4": "flags",
                "iVar1": "check_result",
                "uVar2": "flag_value",
                "auStack_68": "stack_buffer",
                "local_64": "N/A"
            },
            "code": "int check_permissions_and_set_result_000056b8(int permission_value, int permission_check, int* result, uint* flags) {\n  int check_result;\n  uint flag_value;\n  undefined stack_buffer[4];\n  \n  if ((*(short *)(permission_check + 0xe) < 0) ||\n     (check_result = check_permission_value(permission_value,(int)*(short *)(permission_check + 0xe),stack_buffer), check_result < 0)) {\n    *flags = 0;\n    if ((int)((uint)*(ushort *)(permission_check + 0xc) << 0x18) < 0) {\n      flag_value = 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    flag_value = (uint)((flag_value & 0xf000) == 0x2000);\n  }\n  flag_value = 0x400;\nLAB_000056f8:\n  *result = flag_value;\n  return 0;\n}",
            "called": [
                "FUN_00000514"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b8",
            "calling": [
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "check_permissions_and_set_result_000056b8"
        },
        "FUN_00001a18": {
            "renaming": {
                "FUN_00001a18": "initialize_data_and_set_flag_00001a18",
                "FUN_000016ec": "set_data",
                "FUN_00001734": "set_flag",
                "PTR_DAT_00001a38": "PTR_result",
                "DAT_00001a34": "DAT_buffer"
            },
            "code": "void initialize_data_and_set_flag_00001a18(void)\n{\n  set_data(DAT_00001a34, 1);\n  set_flag();\n  *PTR_DAT_00001a38 = 4;\n  return;\n}",
            "called": [
                "FUN_00001734",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a18",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_data_and_set_flag_00001a18"
        },
        "FUN_00000d9c": {
            "renaming": {
                "FUN_00000d9c": "initialize_data_00000d9c",
                "FUN_00000d76": "set_data_to_zero",
                "DAT_00000dac": "data_ptr"
            },
            "code": "void initialize_data_00000d9c(void)\n{\n    set_data_to_zero(DAT_00000dac, 0);\n    return;\n}",
            "called": [
                "FUN_00000d76"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d9c",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": false,
            "current_name": "initialize_data_00000d9c"
        },
        "FUN_00003ff4": {
            "renaming": {
                "FUN_00003ff4": "calculate_00003ff4",
                "param_1": "start_address",
                "param_2": "end_address",
                "param_3": "offset",
                "param_4": "param_4",
                "uVar1": "result"
            },
            "code": "uint calculate_00003ff4(uint start_address, uint end_address, uint offset, undefined param_4)\n{\n  uint result = end_address;\n  if ((end_address > offset) && (start_address != 0)) {\n    FUN_000045ee((end_address - offset) + start_address,start_address,offset);\n    FUN_00004622(start_address,param_4,end_address - offset);\n  }\n  return result;\n}",
            "called": [
                "FUN_000045ee",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ff4",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": false,
            "current_name": "calculate_00003ff4"
        },
        "FUN_00004634": {
            "renaming": {
                "FUN_00004634": "update_date_00004634",
                "param_1": "date",
                "param_2": "days_to_add",
                "param_3": "unused",
                "puVar1": "month_lengths",
                "iVar2": "days_in_month",
                "uVar3": "day",
                "uVar4": "year",
                "iVar5": "days_in_year",
                "bVar6": "negative_days",
                "local_20": "temp_array",
                "local_1c": "day_of_month",
                "uStack_18": "unused"
            },
            "code": "\nvoid update_date_00004634(uint *date,uint days_to_add,undefined4 unused)\n\n{\n  undefined *month_lengths;\n  int days_in_month;\n  uint day;\n  uint year;\n  int days_in_year;\n  bool negative_days;\n  uint *temp_array;\n  uint day_of_month;\n  undefined4 unused;\n  \n  temp_array = date;\n  day_of_month = days_to_add;\n  unused = unused;\n  if (0x3b < *date) {\n    FUN_00005584(&temp_array,*date,0x3c);\n    day = date[1] + (int)temp_array;\n    date[1] = day;\n    if ((int)day_of_month < 0) {\n      day = day - 1;\n      *date = day_of_month + 0x3c;\n    }\n    else {\n      *date = day_of_month;\n    }\n    if ((int)day_of_month < 0) {\n      date[1] = day;\n    }\n  }\n  if (0x3b < date[1]) {\n    FUN_00005584(&temp_array,date[1],0x3c);\n    negative_days = (int)day_of_month < 0;\n    year = date[2] + (int)temp_array;\n    date[2] = year;\n    day = day_of_month;\n    if (negative_days) {\n      day = day_of_month + 0x3c;\n      year = year - 1;\n    }\n    if (!negative_days) {\n      date[1] = day;\n    }\n    if (negative_days) {\n      date[1] = day;\n    }\n    if (negative_days) {\n      date[2] = year;\n    }\n  }\n  if (0x17 < date[2]) {\n    FUN_00005584(&temp_array,date[2],0x18);\n    negative_days = (int)day_of_month < 0;\n    year = date[3] + (int)temp_array;\n    date[3] = year;\n    day = day_of_month;\n    if (negative_days) {\n      day = day_of_month + 0x18;\n      year = year - 1;\n    }\n    if (!negative_days) {\n      date[2] = day;\n    }\n    if (negative_days) {\n      date[2] = day;\n    }\n    if (negative_days) {\n      date[3] = year;\n    }\n  }\n  if (0xb < date[4]) {\n    FUN_00005584(&temp_array,date[4],0xc);\n    negative_days = (int)day_of_month < 0;\n    day = date[5] + (int)temp_array;\n    date[5] = day;\n    if (negative_days) {\n      day_of_month = day_of_month + 0xc;\n      day = day - 1;\n    }\n    if (!negative_days) {\n      date[4] = day_of_month;\n    }\n    if (negative_days) {\n      date[4] = day_of_month;\n    }\n    if (negative_days) {\n      date[5] = day;\n    }\n  }\n  month_lengths = PTR_DAT_000047e0;\n  day = date[5];\n  if ((day & 3) == 0) {\n    if (day == (day / 100) * 100) {\n      if ((day + 0x76c) % 400 == 0) {\n        days_in_year = 0x1d;\n      }\n      else {\n        days_in_year = 0x1c;\n      }\n    }\n    else {\n      days_in_year = 0x1d;\n    }\n  }\n  else {\n    days_in_year = 0x1c;\n  }\n  if ((int)date[3] < 1) {\n    while ((int)date[3] < 1) {\n      day = date[4];\n      date[4] = day - 1;\n      if (day - 1 == 0xffffffff) {\n        year = date[5];\n        day = year - 1;\n        date[4] = 0xb;\n        date[5] = day;\n        if ((day & 3) == 0) {\n          if (day == (day / 100) * 100) {\n            if ((year + 0x76b) % 400 == 0) {\n              days_in_year = 0x1d;\n            }\n            else {\n              days_in_year = 0x1c;\n            }\n          }\n          else {\n            days_in_year = 0x1d;\n          }\n        }\n        else {\n          days_in_year = 0x1c;\n        }\n      }\n      days_in_month = days_in_year;\n      if (date[4] != 1) {\n        days_in_month = *(int *)(month_lengths + date[4] * 4);\n      }\n      date[3] = days_in_month + date[3];\n    }\n  }\n  else {\n    while( true ) {\n      day = date[4];\n      days_in_month = days_in_year;\n      if (day != 1) {\n        days_in_month = *(int *)(month_lengths + day * 4);\n      }\n      if ((int)date[3] <= days_in_month) break;\n      date[3] = date[3] - days_in_month;\n      date[4] = day + 1;\n      if (day + 1 == 0xc) {\n        year = date[5];\n        day = year + 1;\n        date[4] = 0;\n        date[5] = day;\n        if ((day & 3) == 0) {\n          if (day % 100 == 0) {\n            if ((year + 0x76d) % 400 == 0) {\n              days_in_year = 0x1d;\n            }\n            else {\n              days_in_year = 0x1c;\n            }\n          }\n          else {\n            days_in_year = 0x1d;\n          }\n        }\n        else {\n          days_in_year = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005584"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004634",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "update_date_00004634"
        },
        "FUN_00001d5e": {
            "renaming": {
                "FUN_00001d5e": "get_masked_value_00001d5e",
                "param_1": "input_value",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "uint16_t get_masked_value_00001d5e(ushort input_value)\n{\n    uint16_t mask = 0x7000;\n    uint16_t result = input_value & mask;\n    uint16_t constant = 0x40048000;\n    result |= constant;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d5e",
            "calling": [
                "FUN_00001eea",
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "get_masked_value_00001d5e"
        },
        "FUN_0000191c": {
            "renaming": {
                "FUN_0000191c": "initialize_system_0000191c",
                "FUN_00001778": "initialize_hardware",
                "FUN_00001748": "set_buffer_size",
                "DAT_00001958": "status_register",
                "PTR_DAT_0000195c": "is_initialized"
            },
            "code": "void initialize_system_0000191c(void)\n{\n  initialize_hardware();\n  set_buffer_size(64);\n  *DAT_00001958 = *DAT_00001958 & 0x3b;\n  do {\n  } while ((*DAT_00001958 & 0xc) != 0);\n  *PTR_DAT_0000195c = 1;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001778"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000191c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_system_0000191c"
        },
        "FUN_000050f4": {
            "renaming": {
                "FUN_000050f4": "get_pointer_to_data_000050f4",
                "PTR_DAT_000050fc": "pointer_to_data"
            },
            "code": "const char* get_pointer_to_data_000050f4() {\n  return PTR_DAT_000050fc;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050f4",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_pointer_to_data_000050f4"
        },
        "FUN_00005a58": {
            "renaming": {
                "FUN_00005a58": "encode_string_00005a58",
                "param_1": "str",
                "param_2": "len",
                "param_3": "out_len",
                "param_4": "pad",
                "param_5": "write_fn",
                "iVar1": "i",
                "uVar2": "ret",
                "uVar3": "max_len",
                "uVar4": "str_len",
                "bVar5": "is_unicode",
                "pad_len": "pad_len",
                "uVar7": "remaining_len"
            },
            "code": "undefined4 encode_string_00005a58(undefined4 str, uint *len, uint *out_len, undefined4 pad, code *write_fn)\\n\\\n{\\n\\\n  int i;\\n\\\n  undefined4 ret;\\n\\\n  uint max_len = param_2[4];\\n\\\n  uint str_len = max_len < param_2[2] ? param_2[2] : max_len;\\n\\\n  *param_3 = str_len;\\n\\\n  if (*(char *)((int)param_2 + 0x43) != \"\\0\") {\\n\\\n    *param_3 = str_len + 1;\\n\\\n  }\\n\\\n  if ((int)(*param_2 << 0x1a) < 0) {\\n\\\n    *param_3 = *param_3 + 2;\\n\\\n  }\\n\\\n  uint pad_len = 0;\\n\\\n  uint str_type = *param_2 & 6;\\n\\\n  if (str_type == 0) {\\n\\\n    pad_len = param_2[3] - *param_3;\\n\\\n    for (i = 0; i < (int)pad_len; i++) {\\n\\\n      if ((*write_fn)(str, pad, (int)param_2 + 0x19, 1) == -1) {\\n\\\n        goto LAB_00005afc;\\n\\\n      }\\n\\\n    }\\n\\\n  }\\n\\\n  if (*(byte *)((int)param_2 + 0x43) != 0) {\\n\\\n    pad_len = 1;\\n\\\n  }\\n\\\n  if ((int)(*param_2 << 0x1a) < 0) {\\n\\\n    *(undefined *)((int)param_2 + pad_len + 0x43) = 0x30;\\n\\\n    *(undefined *)((int)param_2 + pad_len + 0x44) = *(undefined *)((int)param_2 + 0x45);\\n\\\n    pad_len += 2;\\n\\\n  }\\n\\\n  if ((*write_fn)(str, pad, (int)param_2 + 0x43, pad_len) == -1) {\\n\\\n    goto LAB_00005afc;\\n\\\n  }\\n\\\n  uint remaining_len = param_2[3];\\n\\\n  bool is_unicode = (str_type == 4);\\n\\\n  if (is_unicode) {\\n\\\n    remaining_len = remaining_len - *param_3;\\n\\\n    remaining_len = remaining_len & ~((int)remaining_len >> 0x1f);\\n\\\n  } else {\\n\\\n    remaining_len = 0;\\n\\\n  }\\n\\\n  if (max_len < param_2[2]) {\\n\\\n    remaining_len = remaining_len + (param_2[2] - max_len);\\n\\\n  }\\n\\\n  for (i = 0; i < (int)remaining_len; i++) {\\n\\\n    if ((*write_fn)(str, pad, (int)param_2 + 0x1a, 1) == -1) {\\n\\\n      goto LAB_00005afc;\\n\\\n    }\\n\\\n  }\\n\\\n  ret = 0;\\n\\\nLAB_00005afc:\\n\\\n  return ret;\\n\\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005a58",
            "calling": [
                "FUN_00005b34"
            ],
            "imported": false,
            "current_name": "encode_string_00005a58"
        },
        "FUN_000056b0": {
            "renaming": {
                "FUN_000056b0": "get_data_000056b0",
                "DAT_000056b4": "data_value"
            },
            "code": "int get_data_000056b0(){\n  return DAT_000056b4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b0",
            "calling": [
                "FUN_000047e4",
                "FUN_00005100",
                "FUN_00004f98"
            ],
            "imported": false,
            "current_name": "get_data_000056b0"
        },
        "FUN_00003d24": {
            "renaming": {
                "FUN_00003d24": "findNthNode_00003d24",
                "param_1": "n",
                "local_10": "count",
                "local_c": "current_node"
            },
            "code": "undefined4* findNthNode_00003d24(int n)\n{\n  int count = 0;\n  undefined4* current_node = *(undefined4**)PTR_DAT_00003d60;\n  while (count < n && current_node != (undefined4*)0x0)\n  {\n    current_node = (undefined4*)*current_node;\n    count++;\n  }\n  return current_node;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d24",
            "calling": [
                "FUN_0000305c",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "findNthNode_00003d24"
        },
        "FUN_000060cc": {
            "renaming": {
                "FUN_000060cc": "process_data_000060cc",
                "param_1": "data_pointer",
                "param_2": "data_size",
                "param_3": "target_size",
                "param_4": "optional_param",
                "uVar1": "result",
                "uVar2": "temp_size",
                "FUN_00004b34": "log_error",
                "FUN_00006964": "get_temp_size",
                "FUN_00004bd0": "process_data"
            },
            "code": "uint process_data_000060cc(undefined4 data_pointer, uint data_size, uint target_size, undefined4 optional_param)\n{\n  uint result;\n  uint temp_size;\n  \n  if (data_size != 0) {\n    if (target_size == 0) {\n      log_error();\n      result = target_size;\n    }\n    else {\n      temp_size = get_temp_size();\n      result = data_size;\n      if ((temp_size < target_size) && (result = process_data_000060cc(data_pointer, target_size), result != 0)) {\n        process_data_000060cc(result, data_size, target_size);\n        log_error(data_pointer, data_size);\n      }\n    }\n    return result;\n  }\n  result = process_data_000060cc(data_pointer, target_size, target_size, optional_param);\n  return result;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_00004b34",
                "FUN_000060b0",
                "FUN_00006964"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060cc",
            "calling": [
                "FUN_000068f0"
            ],
            "imported": false,
            "current_name": "process_data_000060cc"
        },
        "FUN_00003dc4": {
            "renaming": {
                "FUN_00003dc4": "calculate_digits_count_00003dc4",
                "param_1": "num_digits",
                "param_2": "num",
                "local_20": "remainder",
                "local_14": "digits_ptr",
                "local_10": "digits_count",
                "local_c": "result",
                "DAT_00003e50": "MAX_NUM",
                "DAT_00003e54": "MULTIPLIER"
            },
            "code": "int calculate_digits_count_00003dc4(int num_digits, uint num) {\n  uint remainder;\n  char *digits_ptr;\n  uint digits_count;\n  int result;\n  result = 1;\n  if (DAT_00003e50 < num) {\n    result = 10;\n  }\n  else {\n    for (digits_count = 10; digits_count <= num; digits_count = digits_count * 10) {\n      result = result + 1;\n    }\n  }\n  if (num_digits != 0) {\n    digits_ptr = (char *)(result + num_digits);\n    remainder = num;\n    do {\n      digits_ptr = digits_ptr + -1;\n      *digits_ptr = (char)remainder + (char)(uint)((ulonglong)DAT_00003e54 * (ulonglong)remainder >> 0x23) * -10 + '0';\n      remainder = (uint)((ulonglong)DAT_00003e54 * (ulonglong)remainder >> 0x23);\n    } while (remainder != 0);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003dc4",
            "calling": [
                "FUN_00003e58"
            ],
            "imported": false,
            "current_name": "calculate_digits_count_00003dc4"
        },
        "FUN_000022be": {
            "renaming": {
                "FUN_000022be": "increment_and_set_value_at_offset_000022be",
                "param_1": "arr",
                "param_2": "value",
                "uVar1": "index",
                "param_1[3]": "arr[3]",
                "*(undefined *)((uVar1 & param_1[1] - 1U) + *param_1)": "*(undefined *)address",
                "uVar1 + 1": "index + 1",
                "uVar1 & param_1[1] - 1U": "offset",
                "*param_1": "*arr"
            },
            "code": "void increment_and_set_value_at_offset_000022be(int *arr, undefined value) {\n    uint index = arr[3];\n    arr[3] = index + 1;\n    uint offset = index & (arr[1] - 1U);\n    uint address = offset + *arr;\n    *(undefined *)address = value;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022be",
            "calling": [
                "FUN_00002364"
            ],
            "imported": false,
            "current_name": "increment_and_set_value_at_offset_000022be"
        },
        "FUN_00002108": {
            "renaming": {
                "FUN_00002108": "print_data_00002108",
                "FUN_00002028": "print_array",
                "DAT_00002118": "data_array",
                "4": "data_size",
                "PTR_": "no renaming for variables starting with PTR_",
                "DAT_": "no renaming for variables starting with DAT_"
            },
            "code": "void print_data_00002108(void)\n{\n  int* data_ptr = DAT_00002118;\n  int data_size = 4;\n  print_array(data_ptr, data_size);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002108",
            "calling": [],
            "imported": false,
            "current_name": "print_data_00002108"
        },
        "FUN_00001d80": {
            "renaming": {
                "FUN_00001d80": "calculate_checksum_00001d80",
                "param_1": "data",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "uint16_t calculate_checksum_00001d80(uint16_t data) {\n  uint16_t masked_data = data & 0x1C0;\n  uint16_t checksum = masked_data | 0x400FF000;\n  return checksum;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d80",
            "calling": [
                "FUN_00001eea",
                "FUN_00001ff6"
            ],
            "imported": false,
            "current_name": "calculate_checksum_00001d80"
        },
        "FUN_000033c0": {
            "renaming": {
                "FUN_000033c0": "check_alarm_status_000033c0",
                "iVar1": "alarm_status",
                "auStack_2c": "alarm_info",
                "FUN_00002690": "get_alarm_info",
                "FUN_00004db8": "report_error",
                "FUN_00003378": "process_alarm_info"
            },
            "code": "bool check_alarm_status_000033c0(void)\n{\n  int alarm_status;\n  undefined alarm_info [36];\n  \n  alarm_status = get_alarm_info(alarm_info);\n  if (alarm_status != 0) {\n    report_error(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    process_alarm_info(alarm_info);\n  }\n  return alarm_status != 0;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00003378",
                "FUN_00002690"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "check_alarm_status_000033c0"
        },
        "FUN_00002b10": {
            "renaming": {
                "FUN_00002b10": "parse_input_and_execute_command_00002b10",
                "param_1": "input_buffer",
                "param_2": "buffer_size",
                "iVar1": "error_code",
                "pbVar2": "next_char",
                "local_48": "args_and_buffer",
                "local_3c": "command",
                "local_38": "args",
                "local_34": "num_args",
                "local_2d": "quote_char",
                "local_2c": "escape_char",
                "local_28": "current_char",
                "local_24": "arg_ptr",
                "local_20": "i",
                "local_1c": "num_escape_chars",
                "local_18": "num_valid_args",
                "local_14": "current_pos"
            },
            "code": "void parse_input_and_execute_command_00002b10(byte* input_buffer, uint32_t buffer_size) {\n    int num_args = 0;\n    int num_escape_chars = 0;\n    byte* current_pos = input_buffer;\n    while (*current_pos != 0) {\n        if (*current_pos > 0x20) {\n            if (*current_pos == 0x22 || *current_pos == 0x27) {\n                byte quote_char = *current_pos;\n                do {\n                    current_pos++;\n                    if (*current_pos == 0) {\n                        return;\n                    }\n                    if (*current_pos == 0x5c) {\n                        num_escape_chars++;\n                        current_pos++;\n                        if (*current_pos == 0) {\n                            return;\n                        }\n                    }\n                } while (quote_char != *current_pos);\n                if (current_pos[1] > 0x20) {\n                    return;\n                }\n            }\n            else {\n                do {\n                    if (*current_pos == 0x5c) {\n                        num_escape_chars++;\n                        current_pos++;\n                        if (*current_pos == 0) {\n                            return;\n                        }\n                    }\n                    current_pos++;\n                    if (*current_pos == 0x22) {\n                        return;\n                    }\n                } while (*current_pos > 0x20);\n            }\n            num_args++;\n        }\n        *current_pos = 0;\n        current_pos++;\n    }\n    if (num_args != 0) {\n        char* args[num_args];\n        char** current_arg = args;\n        current_pos = input_buffer;\n        for (int i = 0; i < num_args; i++) {\n            while (*current_pos == 0) {\n                current_pos++;\n            }\n            if (*current_pos == 0x22 || *current_pos == 0x27) {\n                current_pos++;\n            }\n            *current_arg = (char*)current_pos;\n            while (*current_pos != 0) {\n                current_pos++;\n            }\n            current_arg++;\n        }\n        for (char** arg = args; *arg != NULL && num_escape_chars != 0; arg++) {\n            for (char* c = *arg; *c != 0; c++) {\n                if (*c == '\\') {\n                    for (char* d = c; *d != 0; d++) {\n                        *d = *(d + 1);\n                    }\n                    num_escape_chars--;\n                    if (num_escape_chars == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n        code* command = (code*)parse_command(input_buffer, args);\n        if (command == NULL) {\n            int error_code = find_error_code(args);\n            if (error_code == 0) {\n                execute_shell_command(args);\n            }\n            else {\n                print_error_message(error_code, args);\n            }\n        }\n        else {\n            (*command)(num_args, args);\n        }\n    }\n}",
            "called": [
                "FUN_00002a18",
                "FUN_00004db8",
                "FUN_00002a88",
                "FUN_00004c84",
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002b10",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "parse_input_and_execute_command_00002b10"
        },
        "FUN_00001b10": {
            "renaming": {
                "FUN_00001b10": "process_byte_00001b10",
                "param_1": "input_byte",
                "uVar1": "result",
                "*PTR_DAT_00001bb0": "*ptr_data_1",
                "PTR_DAT_00001bb0": "ptr_data_1",
                "PTR_DAT_00001bb4": "ptr_data_2"
            },
            "code": "uint32_t process_byte_00001b10(byte input_byte)\n{\n    uint32_t result = 0;\n    if (input_byte < 8) {\n        do {\n            uint32_t ptr_index = (uint32_t)input_byte + (uint32_t)(*PTR_DAT_00001bb0) * 8;\n            switch(PTR_DAT_00001bb4[ptr_index]) {\n                case 0:\n                    result = FUN_000018bc();\n                    break;\n                case 1:\n                    result = FUN_0000191c();\n                    break;\n                case 2:\n                    result = FUN_00001960();\n                    break;\n                case 3:\n                    result = FUN_000019c0();\n                    break;\n                case 4:\n                    result = FUN_00001a18();\n                    break;\n                case 5:\n                    result = FUN_00001a3c();\n                    break;\n                case 6:\n                    result = FUN_00001a60();\n                    break;\n                case 7:\n                    result = FUN_00001ad4();\n                    break;\n                default:\n                    return 0xffffffff;\n            }\n        } while (input_byte != *PTR_DAT_00001bb0);\n    }\n    else {\n        result = 0xffffffff;\n    }\n    return result;\n}",
            "called": [
                "FUN_00001a18",
                "FUN_00001ad4",
                "FUN_000019c0",
                "FUN_00001a60",
                "FUN_00001960",
                "FUN_000018bc",
                "FUN_00001a3c",
                "FUN_0000191c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001b10",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "process_byte_00001b10"
        },
        "FUN_000047e4": {
            "renaming": {
                "FUN_000047e4": "calculate_day_of_week_000047e4",
                "param_1": "date_components",
                "lVar1": "total_days",
                "lVar2": "adjusted_total_days",
                "piVar3": "leap_year_info",
                "uVar4": "tmp1",
                "iVar5": "tmp2",
                "iVar6": "tmp3",
                "iVar7": "tmp4",
                "uVar8": "tmp5",
                "uVar9": "tmp6",
                "uVar10": "tmp7",
                "iVar11": "days_since_jan1",
                "uVar12": "year_day",
                "uVar13": "is_leap_year",
                "uVar14": "days_since_last_leap_year",
                "uVar15": "tmp8",
                "bVar16": "tmp9"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\nundefined8 calculate_day_of_week_000047e4(int *date_components)\n\n{\n  longlong total_days;\n  longlong adjusted_total_days;\n  int *leap_year_info;\n  uint tmp1;\n  int tmp2;\n  int tmp3;\n  int tmp4;\n  uint tmp5;\n  uint tmp6;\n  uint tmp7;\n  int days_since_jan1;\n  uint year_day;\n  uint is_leap_year;\n  uint days_since_last_leap_year;\n  uint tmp8;\n  bool tmp9;\n  \n  leap_year_info = (int *)FUN_000056b0();\n  FUN_00004634(date_components);\n  year_day = date_components[5];\n  days_since_jan1 = date_components[3] + -1 + *(int *)(PTR_DAT_00004adc + date_components[4] * 4);\n  if (((1 < date_components[4]) && ((year_day & 3) == 0)) &&\n     ((year_day != (year_day / 100) * 100 || (year_day + 0x76c == ((year_day + 0x76c) / 400) * 400)))) {\n    days_since_jan1 = days_since_jan1 + 1;\n  }\n  date_components[7] = days_since_jan1;\n  if (20000 < (int)&PTR_DAT_00002710 + year_day) {\n    tmp4 = -1;\n    tmp2 = -1;\n    goto LAB_00004aba;\n  }\n  if ((int)year_day < 0x47) {\n    if (year_day != 0x46) {\n      for (tmp6 = 0x45; (int)year_day < (int)tmp6; tmp6 = tmp6 - 1) {\n        if ((tmp6 & 3) == 0) {\n          if (tmp6 == (tmp6 / 100) * 100) {\n            if ((tmp6 + 0x76c) % 400 == 0) {\n              tmp4 = 0x16e;\n            }\n            else {\n              tmp4 = 0x16d;\n            }\n          }\n          else {\n            tmp4 = 0x16e;\n          }\n        }\n        else {\n          tmp4 = 0x16d;\n        }\n        days_since_jan1 = days_since_jan1 - tmp4;\n      }\n      if ((tmp6 & 3) == 0) {\n        if (year_day == (year_day / 100) * 100) {\n          tmp4 = 0x16d;\n          if ((year_day + 0x76c) % 400 == 0) {\n            tmp4 = 0x16e;\n          }\n        }\n        else {\n          tmp4 = 0x16e;\n        }\n      }\n      else {\n        tmp4 = 0x16d;\n      }\n      days_since_jan1 = days_since_jan1 - tmp4;\n    }\n  }\n  else {\n    tmp6 = 0x46;\n    do {\n      if ((tmp6 & 3) == 0) {\n        if (tmp6 % 100 == 0) {\n          if ((tmp6 + 0x76c) % 400 == 0) {\n            tmp4 = 0x16e;\n          }\n          else {\n            tmp4 = 0x16d;\n          }\n        }\n        else {\n          tmp4 = 0x16e;\n        }\n      }\n      else {\n        tmp4 = 0x16d;\n      }\n      tmp6 = tmp6 + 1;\n      days_since_jan1 = days_since_jan1 + tmp4;\n    } while (year_day != tmp6);\n  }\n  total_days = (longlong)DAT_00004ae0 * (longlong)days_since_jan1 +\n          (longlong)(date_components[2] * 0xe10 + date_components[1] * 0x3c + *date_components);\n  tmp8 = (uint)total_days;\n  tmp4 = (int)((ulonglong)total_days >> 0x20);\n  FUN_000050e8();\n  FUN_00005100();\n  tmp6 = *(uint *)PTR_DAT_00004ae4;\n  if (*(uint *)PTR_DAT_00004ae4 == 0) {\nLAB_00004934:\n    year_day = leap_year_info[10];\n    tmp4 = (uint)total_days + year_day;\n    tmp2 = (int)((ulonglong)total_days >> 0x20) +\n            ((int)year_day >> 0x1f) + (uint)CARRY4((uint)total_days,year_day);\n  }\n  else {\n    days_since_last_leap_year = date_components[8];\n    is_leap_year = days_since_last_leap_year;\n    if (0 < (int)days_since_last_leap_year) {\n      is_leap_year = 1;\n    }\n    if ((leap_year_info[1] == date_components[5] + 0x76c) || (tmp2 = FUN_00004f98(), tmp2 != 0)) {\n      tmp7 = leap_year_info[0x14];\n      tmp1 = leap_year_info[0x12];\n      tmp5 = leap_year_info[10];\n      tmp6 = tmp1 - tmp5;\n      tmp2 = (leap_year_info[0x13] - ((int)tmp5 >> 0x1f)) - (uint)(tmp1 < tmp5);\n      if (((int)((tmp4 - tmp2) - (uint)(tmp8 < tmp6)) < 0 ==\n           (SBORROW4(tmp4,tmp2) != SBORROW4(tmp4 - tmp2,(uint)(tmp8 < tmp6)))) &&\n         (tmp3 = (leap_year_info[0x13] - ((int)tmp7 >> 0x1f)) - (uint)(tmp1 < tmp7),\n         tmp9 = tmp8 < tmp1 - tmp7,\n         (int)((tmp4 - tmp3) - (uint)tmp9) < 0 !=\n         (SBORROW4(tmp4,tmp3) != SBORROW4(tmp4 - tmp3,(uint)tmp9)))) goto LAB_00004a88;\n      tmp1 = leap_year_info[8] - tmp7;\n      tmp3 = (leap_year_info[9] - ((int)tmp7 >> 0x1f)) - (uint)((uint)leap_year_info[8] < tmp7);\n      if (*leap_year_info != 0) {\n        if ((int)((tmp4 - tmp3) - (uint)(tmp8 < tmp1)) < 0 ==\n            (SBORROW4(tmp4,tmp3) != SBORROW4(tmp4 - tmp3,(uint)(tmp8 < tmp1))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        tmp6 = 0;\n        if ((int)days_since_last_leap_year < 0) goto LAB_00004934;\nLAB_00004a14:\n        tmp8 = is_leap_year ^ tmp6;\n        is_leap_year = tmp6;\n        if (tmp8 == 1) {\n          if (tmp6 == 0) {\n            tmp4 = tmp7 - tmp5;\n          }\n          else {\n            tmp4 = tmp5 - tmp7;\n          }\n          tmp2 = date_components[3];\n          *date_components = *date_components + tmp4;\n          adjusted_total_days = total_days + tmp4;\n          FUN_00004634(date_components);\n          tmp2 = date_components[3] - tmp2;\n          total_days = total_days + tmp4;\n          if (tmp2 != 0) {\n            if (tmp2 < 2) {\n              if (tmp2 == -2 || tmp2 + 2 < 0 != SCARRY4(tmp2,2)) {\n                tmp2 = 1;\n              }\n            }\n            else {\n              tmp2 = -1;\n            }\n            tmp4 = tmp2 + date_components[7];\n            days_since_jan1 = days_since_jan1 + tmp2;\n            if (tmp4 < 0) {\n              tmp6 = year_day - 1;\n              if ((tmp6 & 3) == 0) {\n                if (tmp6 == (tmp6 / 100) * 100) {\n                  tmp4 = 0x16d;\n                  if ((year_day + 0x76b) % 400 != 0) {\n                    tmp4 = 0x16c;\n                  }\n                }\n                else {\n                  tmp4 = 0x16d;\n                }\n              }\n              else {\n                tmp4 = 0x16c;\n              }\n            }\n            else {\n              if ((year_day & 3) == 0) {\n                if (year_day == (year_day / 100) * 100) {\n                  tmp2 = 0x16d;\n                  if ((year_day + 0x76c) % 400 == 0) {\n                    tmp2 = 0x16e;\n                  }\n                }\n                else {\n                  tmp2 = 0x16e;\n                }\n              }\n              else {\n                tmp2 = 0x16d;\n              }\n              if (tmp2 <= tmp4) {\n                tmp4 = tmp4 - tmp2;\n              }\n            }\n            date_components[7] = tmp4;\n            total_days = adjusted_total_days;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((tmp4 - tmp3) - (uint)(tmp8 < tmp1)) < 0 !=\n          (SBORROW4(tmp4,tmp3) != SBORROW4(tmp4 - tmp3,(uint)(tmp8 < tmp1)))) {\nLAB_0000491e:\n        if ((int)((tmp4 - tmp2) - (uint)(tmp8 < tmp6)) < 0 ==\n            (SBORROW4(tmp4,tmp2) != SBORROW4(tmp4 - tmp2,(uint)(tmp8 < tmp6))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)days_since_last_leap_year) {\n        tmp6 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      tmp6 = is_leap_year;\n      if (is_leap_year != 1) goto LAB_00004934;\n    }\n    year_day = leap_year_info[0x14];\n    tmp4 = (uint)total_days + year_day;\n    tmp2 = (int)((ulonglong)total_days >> 0x20) +\n            ((int)year_day >> 0x1f) + (uint)CARRY4((uint)total_days,year_day);\n    tmp6 = 1;\n  }\n  FUN_000050f4();\n  date_components[8] = tmp6;\n  date_components[6] = (days_since_jan1 + 4U) % 7;\nLAB_00004aba:\n  return CONCAT44(tmp2,tmp4);\n}\n\n",
            "called": [
                "FUN_00005100",
                "FUN_00004634",
                "FUN_000050f4",
                "FUN_000050e8",
                "FUN_000056b0",
                "FUN_00004f98"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000047e4",
            "calling": [
                "FUN_00002600",
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_000047e4"
        },
        "FUN_000023c8": {
            "renaming": {
                "FUN_000023c8": "trigger_software_interrupt_000023c8"
            },
            "code": "void trigger_software_interrupt_000023c8(void)\n{\n  software_interrupt(0x3f);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023c8",
            "calling": [
                "FUN_000023d0"
            ],
            "imported": false,
            "current_name": "trigger_software_interrupt_000023c8"
        },
        "FUN_00002e48": {
            "renaming": {
                "FUN_00002e48": "print_data_from_pointer_00002e48",
                "FUN_00002a00": "print_int_and_char",
                "FUN_000041d0": "get_data_from_pointer",
                "*DAT_00002e68": "data_pointer",
                "data": "data_value",
                "space": "space_value",
                "data_pointer": "pointer_to_data",
                "data_from_pointer": "data_from_pointer_value"
            },
            "code": "void print_data_from_pointer_00002e48(void)\n{\n  int data = 0x3e;\n  int space = 0x20;\n  int* *DAT_00002e68 = *(int**)(DAT_00002e68 + 8);\n  int data_from_pointer = **DAT_00002e68;\n\n  print_int(data);\n  print_char(space);\n  print_int(data_from_pointer);\n}\n",
            "called": [
                "FUN_000041d0",
                "FUN_00002a00"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e48",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "print_data_from_pointer_00002e48"
        },
        "FUN_00000930": {
            "renaming": {
                "FUN_00000930": "execute_interrupt_and_wait_00000930",
                "FUN_00000cf0": "execute_interrupt",
                "software_interrupt": "wait_infinite_loop"
            },
            "code": "void execute_interrupt_and_wait_00000930(void)\n{\n  execute_interrupt();\n  wait_infinite_loop();\n}\n",
            "called": [
                "FUN_00000cf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000930",
            "calling": [
                "FUN_00000f8c",
                "FUN_00000794"
            ],
            "imported": false,
            "current_name": "execute_interrupt_and_wait_00000930"
        },
        "FUN_00001348": {
            "renaming": {
                "FUN_00001348": "checkForZero_00001348",
                "PTR_DAT_0000135c": "ptr",
                "*PTR_DAT_0000135c": "*ptr"
            },
            "code": "void checkForZero_00001348(void)\n{\n    int *PTR_DAT_0000135c = (int *)PTR_DAT_0000135c;\n    if (*PTR_DAT_0000135c != 0) {\n        FUN_0000093c();\n    }\n    return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001348",
            "calling": [
                "FUN_00001628"
            ],
            "imported": false,
            "current_name": "checkForZero_00001348"
        },
        "FUN_00001d3a": {
            "renaming": {
                "FUN_00001d3a": "set_flag_to_one_00001d3a",
                "param_1": "input_param",
                "param_2": "char_param",
                "puVar1": "int_ptr",
                "*puVar1": "*int_ptr",
                "FUN_00001d08": "get_ptr"
            },
            "code": "void set_flag_to_one_00001d3a(int input_param, char char_param)\n{\n  int* int_ptr;\n  int_ptr = (int*)get_ptr(input_param,char_param);\n  *int_ptr = 1;\n  return;\n}",
            "called": [
                "FUN_00001d08"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d3a",
            "calling": [
                "FUN_00001ddc"
            ],
            "imported": false,
            "current_name": "set_flag_to_one_00001d3a"
        },
        "FUN_00002434": {
            "renaming": {
                "FUN_00002434": "set_or_clear_flag_00002434",
                "param_1": "flag_ptr",
                "param_2": "flag_value",
                "uVar1": "result",
                "iVar2": "temp_ptr"
            },
            "code": "int set_or_clear_flag_00002434(int *flag_ptr, int flag_value) {\n    int result = FUN_00000cd0();\n    if (*flag_ptr == 0) {\n        *flag_ptr = -1;\n        FUN_00000d0c(result);\n        result = 1;\n    }\n    else if (flag_value == 0) {\n        FUN_00000d0c(result);\n        result = 0;\n    }\n    else {\n        int temp_ptr = *(int *)PTR_DAT_000024b8;\n        FUN_00000698(temp_ptr, 2);\n        if (*flag_ptr == -1) {\n            *flag_ptr = temp_ptr + 8;\n            *(undefined4 *)*flag_ptr = 0;\n        }\n        else {\n            FUN_00001034(flag_ptr, temp_ptr);\n        }\n        FUN_00000d0c(result);\n        FUN_0000093c();\n        result = 1;\n    }\n    return result;\n}",
            "called": [
                "FUN_00000d0c",
                "FUN_0000093c",
                "FUN_00000cd0",
                "FUN_00001034",
                "FUN_00000698"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002434",
            "calling": [
                "FUN_0000129c"
            ],
            "imported": false,
            "current_name": "set_or_clear_flag_00002434"
        },
        "FUN_00005700": {
            "renaming": {
                "FUN_00005700": "process_data_00005700",
                "param_1": "data",
                "param_2": "data_array",
                "uVar1": "flag",
                "iVar2": "index",
                "local_18": "local_data",
                "local_14": "local_array"
            },
            "code": "void process_data_00005700(int data, int *data_array)\n{\n  ushort flag;\n  int index;\n  int local_data;\n  int *local_array;\n  \n  if (-1 < (int)((uint)*(ushort *)(data_array + 3) << 0x1e)) {\n    local_data = data;\n    local_array = data_array;\n    flag = process_local_data(data, data_array, &local_data, &local_array);\n    index = validate_data(data, local_data);\n    if (index != 0) {\n      *(undefined **)(data + 0x28) = ptr_data;\n      *data_array = index;\n      *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) | 0x80;\n      data_array[5] = local_data;\n      data_array[4] = index;\n      if ((local_array != (int *)0x0) &&\n         (index = validate_short_data(data, (int)*(short *)((int)data_array + 0xe)), index != 0)) {\n        *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(data_array + 3) = flag | *(ushort *)(data_array + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(data_array + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) & 0xfffc | 2;\n  }\n  *data_array = (int)data_array + 0x47;\n  data_array[4] = (int)data_array + 0x47;\n  data_array[5] = 1;\n  return;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_00000534",
                "FUN_000056b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005700",
            "calling": [
                "FUN_00006768",
                "FUN_000054a8"
            ],
            "imported": false,
            "current_name": "process_data_00005700"
        },
        "FUN_00002798": {
            "renaming": {
                "FUN_00002798": "checkAndExecuteFunction_00002798",
                "PTR_DAT_000027ac": "ptr_data",
                "FUN_0000093c": "executeFunction"
            },
            "code": "void checkAndExecuteFunction_00002798(void)\n{\n  int* PTR_DAT_000027ac = (int*) PTR_DAT_000027ac;\n  if (*PTR_DAT_000027ac != 0)\n  {\n    executeFunction();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002798",
            "calling": [
                "FUN_00002994"
            ],
            "imported": false,
            "current_name": "checkAndExecuteFunction_00002798"
        },
        "FUN_00003524": {
            "renaming": {
                "FUN_00003524": "handle_command_00003524",
                "param_1": "num_args",
                "param_2": "command_ptr",
                "iVar1": "status",
                "uVar2": "result",
                "FUN_000034c0": "print_usage",
                "FUN_000026d8": "print_error",
                "FUN_000026e4": "print_error",
                "FUN_000026c0": "print_error",
                "FUN_000033c0": "print_error",
                "FUN_000033f4": "set_alarm",
                "FUN_00003444": "print_time",
                "FUN_00003478": "set_time",
                "PTR_s_poweron_00003638": "power_on_str",
                "PTR_s_poweroff_0000363c": "power_off_str",
                "PTR_s_clearalarm_00003640": "clear_alarm_str",
                "PTR_s_getalarm_00003644": "get_alarm_str",
                "PTR_s_setalarm_00003648": "set_alarm_str",
                "PTR_s_gettime_0000364c": "get_time_str",
                "PTR_s_settime_00003650": "set_time_str",
                "PTR_s_unknown_command_or_missing_param_00003654": "print_error"
            },
            "code": "int handle_command_00003524(int num_args, int command_ptr)\n{\n  int result;\n  if (num_args < 2) {\n    print_usage();\n    result = 1;\n  }\n  else {\n    int status = execute_command(*(int *)(command_ptr + 4), PTR_s_poweron_00003638, 7);\n    if (status == 0) {\n      PTR_s_unknown_command_or_missing_param_00003654();\n    }\n    else {\n      status = execute_command(*(int *)(command_ptr + 4), PTR_s_poweroff_0000363c, 8);\n      if (status == 0) {\n        PTR_s_unknown_command_or_missing_param_00003654();\n      }\n      else {\n        status = execute_command(*(int *)(command_ptr + 4), PTR_s_clearalarm_00003640, 8);\n        if (status == 0) {\n          PTR_s_unknown_command_or_missing_param_00003654();\n        }\n        else {\n          status = execute_command(*(int *)(command_ptr + 4), PTR_s_getalarm_00003644, 8);\n          if (status == 0) {\n            PTR_s_unknown_command_or_missing_param_00003654();\n          }\n          else {\n            status = execute_command(*(int *)(command_ptr + 4), PTR_s_setalarm_00003648, 8);\n            if ((status == 0) && (num_args == 4)) {\n              set_alarm(command_ptr + 8);\n            }\n            else {\n              status = execute_command(*(int *)(command_ptr + 4), PTR_s_gettime_0000364c, 7);\n              if (status == 0) {\n                print_time();\n              }\n              else {\n                status = execute_command(*(int *)(command_ptr + 4), PTR_s_settime_00003650, 7);\n                if ((status != 0) || (num_args != 4)) {\n                  PTR_s_unknown_command_or_missing_param_00003654();\n                  print_usage();\n                  return 1;\n                }\n                set_time(command_ptr + 8);\n              }\n            }\n          }\n        }\n      }\n    }\n    result = 0;\n  }\n  return result;\n}",
            "called": [
                "FUN_000026e4",
                "FUN_000026c0",
                "FUN_000033c0",
                "FUN_000034c0",
                "FUN_00004e66",
                "FUN_00004c84",
                "FUN_000026d8",
                "FUN_00003444",
                "FUN_00003478",
                "FUN_000033f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003524",
            "calling": [],
            "imported": false,
            "current_name": "handle_command_00003524"
        },
        "FUN_00001bb8": {
            "renaming": {
                "FUN_00001bb8": "check_and_update_data_00001bb8",
                "DAT_00001c74": "data_buffer",
                "DAT_00001c78": "data_update_1",
                "DAT_00001c7c": "data_update_6",
                "PTR_DAT_00001c80": "ptr_data_reset"
            },
            "code": "void check_and_update_data_00001bb8(void)\n{\n    if ((DAT_00001c74[1] & 2) != 0) {\n        update_data(DAT_00001c74[2], 1);\n    }\n    if ((DAT_00001c74[5] & 0x40) != 0) {\n        if ((DAT_00001c74[0] & 0xc0) == 0) {\n            DAT_00001c74[0] = DAT_00001c74[0] & 0x3f | 0x80;\n            while ((DAT_00001c74[6] & 0xc) != 8) {};\n        }\n        update_data(DAT_00001c74[6], 6);\n        while ((DAT_00001c74[6] & 0x20) != 0) {};\n    }\n    update_status(0);\n    DAT_00001c74[0] = DAT_00001c74[0] & 0x3b | 4;\n    while ((DAT_00001c74[6] & 0x10) == 0) {};\n    while ((DAT_00001c74[6] & 0xc) != 0) {};\n    *PTR_DAT_00001c80 = 0;\n    return;\n}",
            "called": [
                "FUN_00001710",
                "FUN_00001748"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001bb8",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "check_and_update_data_00001bb8"
        },
        "FUN_0000428c": {
            "renaming": {
                "FUN_0000428c": "do_nothing_with_data_0000428c",
                "DAT_00004294": "DAT_data"
            },
            "code": "void do_nothing_with_data_0000428c(void)\n{\n  do_nothing(DAT_00004294);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000428c",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_0000428c"
        },
        "FUN_0000404c": {
            "renaming": {
                "FUN_0000404c": "process_data_0000404c",
                "param_1": "data",
                "param_2": "params",
                "iVar1": "result",
                "piVar2": "param_ptr",
                "uVar3": "flag_check",
                "uVar4": "flags",
                "iVar5": "data_size",
                "pcVar6": "processing_function",
                "iVar7": "block_count",
                "uVar8": "data_copy",
                "bVar9": "is_block_processing_required",
                "block_size": "block_size",
                "remaining_data_size": "remaining_data_size",
                "is_data_processing_required": "is_data_processing_required"
            },
            "code": "int process_data_0000404c(uint *data, int *params) {\n  int result = 0;\n  int *param_ptr = NULL;\n  int data_size = 0;\n  int block_size = 0;\n  int block_count = 0;\n  int remaining_data_size = 0;\n  bool is_data_processing_required = false;\n  bool is_block_processing_required = false;\n  ushort flags = *(ushort *)(params + 3);\n  uint flag_check = (uint)flags;\n  if ((int)(flag_check << 0x1c) < 0) {\n    block_size = params[4];\n    if (block_size != 0) {\n      remaining_data_size = (uint)flags << 0x1e;\n      is_block_processing_required = (remaining_data_size == 0);\n      data_size = *params;\n      if (is_block_processing_required) {\n        remaining_data_size = params[5];\n      }\n      *params = block_size;\n      if (!is_block_processing_required) {\n        remaining_data_size = 0;\n      }\n      params[2] = remaining_data_size;\n      for (data_size = data_size - block_size; data_size > 0; data_size = data_size - remaining_data_size) {\n        remaining_data_size = (*(code *)params[10])(data, params[8], block_size, data_size);\n        if (remaining_data_size < 1) {\n          *(ushort *)(params + 3) = flags | 0x40;\n          return -1;\n        }\n        block_size = block_size + remaining_data_size;\n      }\n    }\n  }\n  else {\n    is_data_processing_required = ((params[1] < 1) && (params[0x10] < 1));\n    if (is_data_processing_required) {\n      return 0;\n    }\n    code *processing_function = (code *)params[0xb];\n    if (processing_function == (code *)0x0) {\n      return 0;\n    }\n    uint data_copy = *data;\n    *data = 0;\n    if ((flags & 0x1000) == 0) {\n      block_size = (*processing_function)(data, params[8], (uint)flags & 0x1000, 1);\n      if ((block_size == -1) && (*data != 0)) {\n        if ((*data == 0x1d) || (*data == 0x16)) {\n          *data = data_copy;\n          return 0;\n        }\n        flags = *(ushort *)(params + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      block_size = params[0x15];\n    }\n    if (((int)((uint)flags << 0x1d) < 0) && (params[0xd] != 0)) {\n      block_count = params[0x10];\n      if (block_count < 1) {\n        block_count = 0;\n      }\n      block_size = block_size - params[1] - block_count;\n    }\n    block_size = (*(code *)params[0xb])(data, params[8], block_size, 0);\n    flags = *(ushort *)(params + 3);\n    if ((block_size == -1) && ((0x1d < *data) || (-1 < (int)((flags >> (*data & 0xff)) << 0x1f))))) {\nLAB_00004104:\n      *(ushort *)(params + 3) = flags | 0x40;\n      return block_size;\n    }\n    params[1] = 0;\n    *params = params[4];\n    if (((int)((uint)flags << 0x13) < 0) && ((block_size != -1) || (*data == 0))) {\n      params[0x15] = block_size;\n    }\n    param_ptr = (int *)params[0xd];\n    *data = data_copy;\n    if (param_ptr != (int *)0x0) {\n      if (param_ptr != params + 0x11) {\n        cleanup_data(data);\n      }\n      params[0xd] = 0;\n      return 0;\n    }\n  }\n  return result;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000404c",
            "calling": [
                "FUN_00004158",
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "process_data_0000404c"
        },
        "FUN_00002f74": {
            "renaming": {
                "FUN_00002f74": "print_devices_00002f74",
                "local_18": "device_count",
                "local_14": "device_list",
                "uVar1": "device_info",
                "FUN_000039e8": "get_device_info",
                "FUN_00004c84": "print_device_info"
            },
            "code": "void print_devices_00002f74(void)\n{\n  undefined4 device_info;\n  int device_count;\n  undefined4 *device_list;\n  device_list = *(undefined4 **)PTR_DAT_00002fd0;\n  device_count = 0;\n  if (device_list == (undefined4 *)0x0) {\n    print_error(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    print_info(PTR_s_ID_Class_Name_00002fd4);\n  }\n  for (; device_list != (undefined4 *)0x0; device_list = (undefined4 *)*device_list) {\n    device_info = get_device_info(*(undefined *)(device_list[3] + 8));\n    print_device_info(PTR_s___i__s__s_00002fdc,device_count,device_info,device_list[2]);\n    device_count++;\n  }\n  return;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00004c84",
                "FUN_000039e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f74",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "print_devices_00002f74"
        },
        "FUN_000010a0": {
            "renaming": {
                "FUN_000010a0": "count_elements_000010a0",
                "param_1": "elements",
                "local_c": "current_element"
            },
            "code": "int count_elements_000010a0(int *elements) {\n  int *current_element;\n  for (current_element = elements; (int *)*current_element == current_element; current_element++) {\n  }\n  return (int)current_element - (int)elements;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010a0",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "count_elements_000010a0"
        },
        "FUN_000012e2": {
            "renaming": {
                "FUN_000012e2": "find_first_nonzero_000012e2",
                "param_1": "array_start",
                "param_2": "array_size",
                "param_3": "elem_size",
                "iVar1": "index",
                "FUN_0000231c": "get_element",
                "FUN_0000129c": "process_zero_element"
            },
            "code": "int find_first_nonzero_000012e2(int array_start, int array_size, int elem_size) {\n  int index = 0;\n  while (true) {\n    int element = *(int *)(array_start + (index * elem_size));\n    if (element != 0) {\n      return index;\n    }\n    index++;\n  }\n  return -1;\n}",
            "called": [
                "FUN_0000231c",
                "FUN_0000129c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012e2",
            "calling": [
                "FUN_00000e14"
            ],
            "imported": false,
            "current_name": "find_first_nonzero_000012e2"
        },
        "FUN_000056a0": {
            "renaming": {
                "FUN_000056a0": "process_data_000056a0",
                "param_1": "data",
                "param_2": "p_data2",
                "param_3": "p_data3",
                "param_4": "flag",
                "uStack_c": "data2",
                "uStack_8": "data3",
                "FUN_0000562c": "processData"
            },
            "code": "void process_data_000056a0(int data, int* p_data2, int* p_data3, int flag)\n{\n  int data2 = *p_data2;\n  int data3 = *p_data3;\n  processData(data, data2, &data2, flag, data);\n  return;\n}",
            "called": [
                "FUN_0000562c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056a0",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "process_data_000056a0"
        },
        "FUN_0000231c": {
            "renaming": {
                "FUN_0000231c": "copy_data_to_buffer_0000231c",
                "param_1": "source_address",
                "param_2": "destination_buffer",
                "param_3": "buffer_size",
                "local_20": "current_destination",
                "local_14": "bytes_copied",
                "uVar1": "data",
                "iVar2": "bytes_read"
            },
            "code": "int copy_data_to_buffer_0000231c(undefined4 source_address, undefined *destination_buffer, int buffer_size) {\n  int bytes_copied = 0;\n  undefined *current_destination = destination_buffer;\n  while ((buffer_size != 0 && (bytes_copied = read_data_from_source(source_address), bytes_copied == 0))) {\n    undefined data = get_data_from_source(source_address);\n    *current_destination = data;\n    buffer_size--;\n    current_destination++;\n  }\n  return buffer_size - bytes_copied;\n}",
            "called": [
                "FUN_00002270",
                "FUN_000022f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000231c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": false,
            "current_name": "copy_data_to_buffer_0000231c"
        },
        "FUN_000061cc": {
            "renaming": {
                "FUN_000061cc": "parse_string_000061cc",
                "param_1": "input_length",
                "param_2": "input_ptr",
                "param_3": "format_ptr",
                "param_4": "output_ptr",
                "puVar1": "hex_table",
                "puVar2": "flag_table",
                "iVar3": "result",
                "uVar4": "char_code",
                "pbVar5": "next_char_ptr",
                "uVar6": "current_char_code",
                "local_2b0": "output_ptr_ptr",
                "auStack_2ac": "local_buffer",
                "local_1ac": "flags",
                "local_1a8": "base",
                "local_1a4": "precision",
                "local_1a0": "result_length",
                "local_19c": "value",
                "local_198": "buffer_ptr",
                "local_194": "specifier_type",
                "local_30": "skip_padding_func_ptr",
                "local_2c": "print_func_ptr"
            },
            "code": "\nint parse_string_000061cc(int input_length,byte **input_ptr,byte *format_ptr,int **output_ptr)\n\n{\n  undefined *hex_table;\n  undefined *flag_table;\n  int result;\n  uint char_code;\n  byte *next_char_ptr;\n  uint current_char_code;\n  int **output_ptr_ptr;\n  undefined local_buffer [256];\n  uint flags;\n  undefined4 base;\n  uint precision;\n  int result_length;\n  int value;\n  undefined *buffer_ptr;\n  int specifier_type;\n  undefined *skip_padding_func_ptr;\n  code *print_func_ptr;\n  \n  flag_table = PTR_DAT_000064b4;\n  hex_table = PTR_DAT_000064b0;\n  result_length = 0;\n  value = 0;\n  skip_padding_func_ptr = PTR_LAB_00006118_1_000064a8;\n  print_func_ptr = DAT_000064ac;\n  output_ptr_ptr = output_ptr;\n  buffer_ptr = local_buffer;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      current_char_code = (uint)*format_ptr;\n      if (current_char_code == 0) {\n        return result_length;\n      }\n      char_code = (byte)hex_table[current_char_code] & 8;\n      next_char_ptr = format_ptr + 1;\n      if ((hex_table[current_char_code] & 8) == 0) break;\n      while (((format_ptr = next_char_ptr, 0 < (int)input_ptr[1] ||\n              (result = (*print_func_ptr)(input_length,input_ptr), result == 0)) &&\n             ((int)((uint)(byte)hex_table[**input_ptr] << 0x1c) < 0))) {\n        value = value + 1;\n        input_ptr[1] = input_ptr[1] + -1;\n        *input_ptr = *input_ptr + 1;\n      }\n    }\n    if (current_char_code == 0x25) break;\nLAB_00006352:\n    if (((int)input_ptr[1] < 1) && (result = (*print_func_ptr)(input_length,input_ptr), result != 0))\n    goto LAB_00006380;\n    if (**input_ptr != current_char_code) {\n      return result_length;\n    }\n    *input_ptr = *input_ptr + 1;\n    value = value + 1;\n    input_ptr[1] = input_ptr[1] + -1;\n    format_ptr = next_char_ptr;\n  }\n  precision = char_code;\n  flags = char_code;\n  if (format_ptr[1] == 0x2a) {\n    next_char_ptr = format_ptr + 2;\n    flags = 0x10;\n  }\n  while( true ) {\n    char_code = (uint)*next_char_ptr;\n    if (9 < char_code - 0x30) break;\n    next_char_ptr = next_char_ptr + 1;\n    precision = (precision * 10 + char_code) - 0x30;\n  }\n  result = FUN_00006010(PTR_DAT_000064b4,char_code,3);\n  if (result != 0) {\n    flags = 1 << (result - (int)flag_table & 0xffU) | flags;\n    next_char_ptr = next_char_ptr + 1;\n  }\n  format_ptr = next_char_ptr + 1;\n  char_code = (uint)*next_char_ptr;\n  if (char_code < 0x79) {\n    if (0x57 < char_code) {\n      switch(char_code) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        format_ptr = (byte *)FUN_0000687c(local_buffer,format_ptr);\n        flags = flags | 0x40;\n        specifier_type = 1;\n        break;\n      case 99:\n        flags = flags | 0x40;\n        specifier_type = 0;\n        break;\n      case 100:\n      case 0x75:\n        base = 10;\nLAB_000063a0:\n        if (char_code < 0x6f) {\n          specifier_type = 3;\n        }\n        else {\n          specifier_type = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        specifier_type = 5;\n        break;\n      case 0x69:\n        base = 0;\n        specifier_type = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(flags << 0x1b)) {\n          if ((int)(flags << 0x1f) < 0) {\n            *(short *)*output_ptr_ptr = (short)value;\n            output_ptr_ptr = output_ptr_ptr + 1;\n          }\n          else {\n            **output_ptr_ptr = value;\n            output_ptr_ptr = output_ptr_ptr + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        base = 8;\n        specifier_type = 4;\n        break;\n      case 0x70:\n        flags = flags | 0x20;\n      case 0x58:\n      case 0x78:\n        flags = flags | 0x200;\n        base = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        specifier_type = 2;\n      }\nLAB_000063ac:\n      if (((int)input_ptr[1] < 1) && (result = (*print_func_ptr)(input_length,input_ptr), result != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(flags << 0x19)) {\n        while ((int)((uint)(byte)hex_table[**input_ptr] << 0x1c) < 0) {\n          value = value + 1;\n          next_char_ptr = input_ptr[1];\n          input_ptr[1] = next_char_ptr + -1;\n          if ((int)(next_char_ptr + -1) < 1) {\n            result = (*print_func_ptr)(input_length,input_ptr);\n            if (result != 0) goto LAB_00006380;\n          }\n          else {\n            *input_ptr = *input_ptr + 1;\n          }\n        }\n      }\n      if (specifier_type < 3) {\n        result = FUN_000064bc(input_length,&flags,input_ptr,&output_ptr_ptr);\n      }\n      else if (specifier_type < 5) {\n        result = FUN_0000656c(input_length,&flags,input_ptr,&output_ptr_ptr);\n      }\n      else {\n        result = input_length;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (result == 1) {\n        return result_length;\n      }\n      if (result == 2) {\nLAB_00006380:\n        if (result_length == 0) {\nLAB_00006388:\n          result_length = -1;\n        }\n        else if ((*(ushort *)(input_ptr + 3) & 0x40) != 0) {\n          result_length = -1;\n        }\n        return result_length;\n      }\n      goto LAB_000061f6;\n    }\n    next_char_ptr = format_ptr;\n    if (char_code == 0x25) goto LAB_00006352;\n    if (char_code < 0x26) {\n      if (char_code != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (char_code - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  specifier_type = 3;\n  base = 10;\n  goto LAB_000063ac;\n}\n\n",
            "called": [
                "FUN_0000687c",
                "FUN_00006192",
                "FUN_00006010",
                "FUN_0000656c",
                "FUN_000064bc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000061cc",
            "calling": [
                "FUN_00005e68"
            ],
            "imported": false,
            "current_name": "parse_string_000061cc"
        },
        "FUN_00002690": {
            "renaming": {
                "FUN_00002690": "process_data_00002690",
                "param_1": "input_data",
                "local_10": "local_var_1",
                "uStack_c": "local_var_2",
                "FUN_000028f0": "get_data",
                "FUN_0000443c": "copy_data"
            },
            "code": "int process_data_00002690(undefined4 input_data)\n{\n    undefined4 local_var_1;\n    undefined4 local_var_2;\n\n    local_var_1 = get_data();\n    local_var_2 = 0;\n    copy_data(&local_var_1, input_data);\n    return 0;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_000028f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002690",
            "calling": [
                "FUN_000033c0"
            ],
            "imported": false,
            "current_name": "process_data_00002690"
        },
        "FUN_00006010": {
            "renaming": {
                "FUN_00006010": "find_byte_sequence_00006010",
                "param_1": "data",
                "param_2": "target_byte",
                "param_3": "data_length",
                "bVar1": "current_byte",
                "cVar2": "byte_0",
                "cVar3": "byte_1",
                "cVar4": "byte_2",
                "cVar5": "byte_3",
                "pbVar6": "result_ptr",
                "puVar7": "current_word_ptr",
                "pbVar8": "next_result_ptr",
                "uVar9": "offset",
                "uVar10": "word_count",
                "uVar11": "current_word",
                "uVar12": "byte_mask",
                "bVar13": "byte_0_set",
                "bVar14": "byte_1_set",
                "bVar15": "byte_2_set",
                "bVar16": "byte_3_set"
            },
            "code": "byte * find_byte_sequence_00006010(uint *data, uint target_byte, uint data_length) {\n  byte *result = NULL;\n  uint target_word = target_byte | target_byte << 8 | target_byte << 16 | target_byte << 24;\n  uint *data_end = (uint *)((int)data + data_length);\n  while (data < data_end) {\n    if (*data == target_word) {\n      result = (byte *)data;\n      break;\n    }\n    data++;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006010",
            "calling": [
                "FUN_000061cc",
                "FUN_0000656c",
                "FUN_000057f8",
                "FUN_00005b34"
            ],
            "imported": false,
            "current_name": "find_byte_sequence_00006010"
        },
        "FUN_00001cf0": {
            "renaming": {
                "FUN_00001cf0": "checkAndExecuteFunction_00001cf0",
                "PTR_DAT_00001d04": "ptr",
                "FUN_0000093c": "executeFunction"
            },
            "code": "void checkAndExecuteFunction_00001cf0(void)\n{\n  int* PTR_DAT_00001d04 = (int*) PTR_DAT_00001d04;\n  if (*PTR_DAT_00001d04 != 0) {\n    executeFunction();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001cf0",
            "calling": [
                "FUN_00002028"
            ],
            "imported": false,
            "current_name": "checkAndExecuteFunction_00001cf0"
        },
        "FUN_00003ec4": {
            "renaming": {
                "FUN_00003ec4": "convert_uint_to_string_with_precision_00003ec4",
                "param_1": "output",
                "param_2": "input",
                "param_3": "precision",
                "iVar1": "length",
                "uVar2": "fractional_part_length",
                "uVar3": "quotient",
                "local_10": "remainder",
                "local_c": "output_length",
                "PTR_s_FAILED_ASSERTION__00003fec": "failed_assertion_message",
                "PTR_DAT_00003ff0": "divisor_table"
            },
            "code": "int convert_uint_to_string_with_precision_00003ec4(char *output, uint input, int precision) {\n  int output_length = 0;\n  if (precision + 7 < 0 != SCARRY4(precision,7)) {\n    assert(0 && \"Failed assertion: precision + 7 >= 0\");\n  }\n  if (precision == 0) {\n    output_length = convert_uint_to_string(output, input);\n  }\n  else if (precision < 1) {\n    uint divisor = *(uint *)(PTR_DAT_00003ff0 + precision * -4);\n    uint quotient = input / divisor;\n    uint remainder = input - divisor * quotient;\n    if (remainder < 0) {\n      remainder = -remainder;\n    }\n    if ((quotient == 0) && ((int)input < 0)) {\n      if (output != (char *)0x0) {\n        *output = '-';\n      }\n      output_length = 1;\n    }\n    if (output == (char *)0x0) {\n      output_length = convert_uint_to_string(0, quotient);\n      output_length++;\n    }\n    else {\n      output_length = convert_uint_to_string(output + output_length, quotient);\n      output_length += 1;\n      output[output_length - 1] = '.';\n      uint fractional_part = convert_uint_to_string(output + output_length, remainder);\n      pad_with_zeroes(output + output_length, fractional_part, -precision, '0');\n      output_length = -precision + output_length + fractional_part;\n    }\n  }\n  else {\n    output_length = convert_uint_to_string(output, input);\n    if (output != (char *)0x0) {\n      pad_with_zeroes(output + output_length, 0, precision, '0');\n    }\n    output_length = precision + output_length;\n  }\n  return output_length;\n}",
            "called": [
                "FUN_00003e58",
                "FUN_00000f04",
                "FUN_00003ff4",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ec4",
            "calling": [
                "FUN_00003e9e"
            ],
            "imported": false,
            "current_name": "convert_uint_to_string_with_precision_00003ec4"
        },
        "FUN_00001360": {
            "renaming": {
                "FUN_00001360": "calculate_result_00001360",
                "param_1": "input_value",
                "param_2": "multiplier"
            },
            "code": "int calculate_result_00001360(uint32_t input_value, int multiplier) {\n    uint32_t masked_input = input_value & 0xf0000000;\n    uint32_t shifted_input = (input_value & 0xfffff) << 5;\n    int constant = 0x2000000;\n    return multiplier * 4 + masked_input + shifted_input + constant;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001360",
            "calling": [
                "FUN_00001392"
            ],
            "imported": false,
            "current_name": "calculate_result_00001360"
        },
        "FUN_00004622": {
            "renaming": {
                "FUN_00004622": "set_memory_block_00004622",
                "param_1": "ptr",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "end_ptr"
            },
            "code": "void set_memory_block_00004622(void *ptr, char value, int size) {\n  void *end_ptr = ptr + size;\n  for (; ptr != end_ptr; ptr++) {\n    *ptr = value;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004622",
            "calling": [
                "FUN_00004314",
                "FUN_0000305c",
                "FUN_00003ff4",
                "FUN_00003ec4",
                "FUN_00004248",
                "FUN_000041f4"
            ],
            "imported": false,
            "current_name": "set_memory_block_00004622"
        },
        "FUN_0000093c": {
            "renaming": {
                "FUN_0000093c": "set_flag_on_0000093c",
                "DAT_00000954": "flag_data",
                "PTR_": "no change"
            },
            "code": "void set_flag_on_0000093c(void)\n{\n  uint32_t* flag_ptr = (uint32_t*)(DAT_00000954 + 4);\n  uint32_t flag_mask = 0x10000000;\n  *flag_ptr |= flag_mask;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000093c",
            "calling": [
                "FUN_00002434",
                "FUN_00002798",
                "FUN_00000738",
                "FUN_00001cf0",
                "FUN_00001348"
            ],
            "imported": false,
            "current_name": "set_flag_on_0000093c"
        },
        "FUN_00003658": {
            "renaming": {
                "FUN_00003658": "synchronize_data_00003658",
                "DAT_00003680": "PTR_data",
                "DAT_00003684": "data_value",
                "uint": "unsigned_int",
                "DataSynchronizationBarrier": "synchronize_data_barrier",
                "*": "ptr",
                "&": "bitwise_and",
                "|": "bitwise_or",
                "0xf": "SYNCHRONIZATION_CONSTANT",
                "0x700": "DATA_CONSTANT"
            },
            "code": "void synchronize_data_00003658(void)\n{\n    DataSynchronizationBarrier(0xf);\n    uint* ptr = (uint*)(DAT_00003680 + 0xc);\n    uint val = *ptr & 0x700;\n    *ptr = DAT_00003684 | val;\n    DataSynchronizationBarrier(0xf);\n    while(true)\n    {\n        // Do nothing loop\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003658",
            "calling": [
                "FUN_00003688"
            ],
            "imported": false,
            "current_name": "synchronize_data_00003658"
        },
        "FUN_000019c0": {
            "renaming": {
                "FUN_000019c0": "initialize_device_000019c0",
                "FUN_00001778": "enable_clock",
                "FUN_00001748": "set_buffer_size",
                "FUN_00001710": "set_device_mode",
                "*DAT_00001a10": "device_register",
                "DAT_00001a0c": "device_mode",
                "PTR_DAT_00001a14": "device_status"
            },
            "code": "void initialize_device_000019c0(void)\n{\n    enable_clock();\n    set_buffer_size(0x40);\n    set_DAT_00001a0c(DAT_00001a0c, 1);\n    *DAT_00001a10 = (*DAT_00001a10 & 0x3b) | 0x80;\n    while ((DAT_00001a10[6] & 0xc) != 8);\n    disable_clock();\n    *PTR_DAT_00001a14 = 3;\n    return;\n}",
            "called": [
                "FUN_00001710",
                "FUN_00001748",
                "FUN_00001734",
                "FUN_00001778"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000019c0",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_device_000019c0"
        },
        "FUN_000060b0": {
            "renaming": {
                "FUN_000060b0": "copy_data_000060b0",
                "param_1": "target_index",
                "param_2": "source_data",
                "param_3": "data_length",
                "puVar1": "next_source",
                "puVar2": "source_end",
                "puVar3": "target_start"
            },
            "code": "void copy_data_000060b0(int target_index, undefined *source_data, int data_length)\n{\n  undefined *source_end = source_data + data_length;\n  undefined *target_start = (undefined *)(target_index - 1);\n  if (source_data != source_end) {\n    do {\n      undefined *next_source = source_data + 1;\n      target_start = target_start + 1;\n      *target_start = *source_data;\n      source_data = next_source;\n    } while (next_source != source_end);\n    return;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060b0",
            "calling": [
                "FUN_000068f0",
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "copy_data_000060b0"
        },
        "FUN_00006a14": {
            "renaming": {
                "FUN_00006a14": "calculate_division_and_remainder_00006a14",
                "param_1": "dividend",
                "param_2": "dividend_high",
                "param_3": "divisor",
                "param_4": "divisor_high",
                "param_5": "remainder",
                "UNRECOVERED_JUMPTABLE": "jump_table",
                "uVar1": "quotient_high",
                "puVar2": "quotient_low",
                "puVar3": "temp",
                "uVar4": "leading_zeroes",
                "uVar5": "temp1",
                "uVar6": "temp2",
                "uVar7": "temp3",
                "uVar8": "temp4",
                "uVar9": "temp5",
                "uVar10": "temp6",
                "bVar11": "carry_flag",
                "uVar12": "product"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong calculate_division_and_remainder_00006a14(uint dividend,uint dividend_high,uint divisor,uint divisor_high,uint *remainder)\n\n{\n  code *jump_table;\n  uint quotient_high;\n  uint *quotient_low;\n  uint *temp;\n  uint leading_zeroes;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  bool carry_flag;\n  ulonglong product;\n  \n  if (divisor_high == 0) {\n    if (dividend_high < divisor) {\n      leading_zeroes = count_leading_zeroes(divisor);\n      if (leading_zeroes != 0) {\n        divisor = divisor << (leading_zeroes & 0xff);\n        dividend_high = dividend >> (0x20 - leading_zeroes & 0xff) | dividend_high << (leading_zeroes & 0xff);\n        dividend = dividend << (leading_zeroes & 0xff);\n      }\n      temp3 = divisor >> 0x10;\n      temp5 = dividend_high / temp3;\n      temp1 = dividend >> 0x10 | (dividend_high - temp3 * temp5) * 0x10000;\n      quotient_high = temp5 * (divisor & 0xffff);\n      temp2 = temp5;\n      if (temp1 <= quotient_high && quotient_high - temp1 != 0) {\n        carry_flag = CARRY4(divisor,temp1);\n        temp1 = divisor + temp1;\n        temp2 = temp5 - 1;\n        if ((carry_flag == false) && (temp1 <= quotient_high && quotient_high - temp1 != 0)) {\n          temp2 = temp5 - 2;\n          temp1 = temp1 + divisor;\n        }\n      }\n      temp5 = (temp1 - quotient_high) / temp3;\n      temp1 = dividend & 0xffff | ((temp1 - quotient_high) - temp3 * temp5) * 0x10000;\n      temp3 = temp5 * (divisor & 0xffff);\n      quotient_high = temp5;\n      if (temp1 <= temp3 && temp3 - temp1 != 0) {\n        carry_flag = CARRY4(divisor,temp1);\n        temp1 = divisor + temp1;\n        quotient_high = temp5 - 1;\n        if ((carry_flag == false) && (temp1 <= temp3 && temp3 - temp1 != 0)) {\n          quotient_high = temp5 - 2;\n          temp1 = temp1 + divisor;\n        }\n      }\n      temp1 = temp1 - temp3;\n      quotient_low = (uint *)(quotient_high | temp2 << 0x10);\n      temp = (uint *)0x0;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        jump_table = (code *)software_udf(0xff,0x6abc);\n        product = (*jump_table)();\n        return product;\n      }\n      leading_zeroes = count_leading_zeroes(divisor);\n      if (leading_zeroes == 0) {\n        dividend_high = dividend_high - divisor;\n        temp6 = divisor >> 0x10;\n        temp4 = divisor & 0xffff;\n        temp = (uint *)0x1;\n      }\n      else {\n        divisor = divisor << (leading_zeroes & 0xff);\n        temp6 = divisor >> 0x10;\n        temp2 = dividend_high >> (0x20 - leading_zeroes & 0xff);\n        quotient_high = dividend >> (0x20 - leading_zeroes & 0xff) | dividend_high << (leading_zeroes & 0xff);\n        temp1 = temp2 / temp6;\n        temp4 = divisor & 0xffff;\n        temp5 = quotient_high >> 0x10 | (temp2 - temp6 * temp1) * 0x10000;\n        temp3 = temp1 * temp4;\n        dividend = dividend << (leading_zeroes & 0xff);\n        temp2 = temp1;\n        if (temp5 <= temp3 && temp3 - temp5 != 0) {\n          carry_flag = CARRY4(divisor,temp5);\n          temp5 = divisor + temp5;\n          temp2 = temp1 - 1;\n          if ((carry_flag == false) && (temp5 <= temp3 && temp3 - temp5 != 0)) {\n            temp2 = temp1 - 2;\n            temp5 = temp5 + divisor;\n          }\n        }\n        temp1 = (temp5 - temp3) / temp6;\n        dividend_high = quotient_high & 0xffff | ((temp5 - temp3) - temp6 * temp1) * 0x10000;\n        temp3 = temp1 * temp4;\n        quotient_high = temp1;\n        if (dividend_high <= temp3 && temp3 - dividend_high != 0) {\n          carry_flag = CARRY4(divisor,dividend_high);\n          dividend_high = divisor + dividend_high;\n          quotient_high = temp1 - 1;\n          if ((carry_flag == false) && (dividend_high <= temp3 && temp3 - dividend_high != 0)) {\n            quotient_high = temp1 - 2;\n            dividend_high = dividend_high + divisor;\n          }\n        }\n        dividend_high = dividend_high - temp3;\n        temp = (uint *)(quotient_high | temp2 << 0x10);\n      }\n      temp3 = dividend_high / temp6;\n      temp1 = dividend >> 0x10 | (dividend_high - temp6 * temp3) * 0x10000;\n      quotient_high = temp4 * temp3;\n      temp2 = temp3;\n      if (temp1 <= quotient_high && quotient_high - temp1 != 0) {\n        carry_flag = CARRY4(divisor,temp1);\n        temp1 = divisor + temp1;\n        temp2 = temp3 - 1;\n        if ((carry_flag == false) && (temp1 <= quotient_high && quotient_high - temp1 != 0)) {\n          temp2 = temp3 - 2;\n          temp1 = temp1 + divisor;\n        }\n      }\n      temp3 = (temp1 - quotient_high) / temp6;\n      temp1 = dividend & 0xffff | ((temp1 - quotient_high) - temp6 * temp3) * 0x10000;\n      temp4 = temp4 * temp3;\n      quotient_high = temp3;\n      if (temp1 <= temp4 && temp4 - temp1 != 0) {\n        carry_flag = CARRY4(divisor,temp1);\n        temp1 = divisor + temp1;\n        quotient_high = temp3 - 1;\n        if ((carry_flag == false) && (temp1 <= temp4 && temp4 - temp1 != 0)) {\n          quotient_high = temp3 - 2;\n          temp1 = temp1 + divisor;\n        }\n      }\n      temp1 = temp1 - temp4;\n      quotient_low = (uint *)(quotient_high | temp2 << 0x10);\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = temp1 >> (leading_zeroes & 0xff);\n      remainder[1] = 0;\n    }\n  }\n  else if (dividend_high < divisor_high) {\n    quotient_low = remainder;\n    temp = remainder;\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = dividend_high;\n      return 0;\n    }\n  }\n  else {\n    temp = (uint *)count_leading_zeroes(divisor_high);\n    if (temp != (uint *)0x0) {\n      temp4 = 0x20 - (int)temp;\n      temp1 = divisor >> (temp4 & 0xff) | divisor_high << ((uint)temp & 0xff);\n      temp6 = temp1 >> 0x10;\n      leading_zeroes = dividend_high >> (temp4 & 0xff);\n      temp2 = dividend >> (temp4 & 0xff) | dividend_high << ((uint)temp & 0xff);\n      temp3 = leading_zeroes / temp6;\n      quotient_high = temp2 >> 0x10 | (leading_zeroes - temp6 * temp3) * 0x10000;\n      temp5 = temp3 * (temp1 & 0xffff);\n      divisor = divisor << ((uint)temp & 0xff);\n      dividend = dividend << ((uint)temp & 0xff);\n      leading_zeroes = temp3;\n      if (quotient_high <= temp5 && temp5 - quotient_high != 0) {\n        carry_flag = CARRY4(temp1,quotient_high);\n        quotient_high = temp1 + quotient_high;\n        leading_zeroes = temp3 - 1;\n        if ((carry_flag == false) && (quotient_high <= temp5 && temp5 - quotient_high != 0)) {\n          leading_zeroes = temp3 - 2;\n          quotient_high = quotient_high + temp1;\n        }\n      }\n      temp3 = (quotient_high - temp5) / temp6;\n      quotient_high = temp2 & 0xffff | ((quotient_high - temp5) - temp6 * temp3) * 0x10000;\n      temp5 = temp3 * (temp1 & 0xffff);\n      temp2 = temp3;\n      if (quotient_high <= temp5 && temp5 - quotient_high != 0) {\n        carry_flag = CARRY4(temp1,quotient_high);\n        quotient_high = temp1 + quotient_high;\n        temp2 = temp3 - 1;\n        if ((carry_flag == false) && (quotient_high <= temp5 && temp5 - quotient_high != 0)) {\n          temp2 = temp3 - 2;\n          quotient_high = quotient_high + temp1;\n        }\n      }\n      temp2 = temp2 | leading_zeroes << 0x10;\n      product = (ulonglong)temp2 * (ulonglong)divisor;\n      if (CONCAT44(quotient_high - temp5,dividend) < product) {\n        product = product - CONCAT44(temp1,divisor);\n        temp2 = temp2 - 1;\n      }\n      if (remainder != (uint *)0x0) {\n        leading_zeroes = ((quotient_high - temp5) - (int)(product >> 0x20)) - (uint)(dividend < (uint)product);\n        *remainder = leading_zeroes << (temp4 & 0xff) | dividend - (uint)product >> ((uint)temp & 0xff);\n        remainder[1] = leading_zeroes >> ((uint)temp & 0xff);\n      }\n      return (ulonglong)temp2;\n    }\n    if ((divisor_high < dividend_high) || (quotient_low = temp, divisor <= dividend)) {\n      carry_flag = dividend < divisor;\n      dividend = dividend - divisor;\n      dividend_high = (dividend_high - divisor_high) - (uint)carry_flag;\n      quotient_low = (uint *)0x1;\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = dividend_high;\n    }\n  }\n  return CONCAT44(temp,quotient_low);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006a14",
            "calling": [
                "FUN_00006974"
            ],
            "imported": false,
            "current_name": "calculate_division_and_remainder_00006a14"
        },
        "FUN_000023d0": {
            "renaming": {
                "FUN_000023d0": "check_initialized_000023d0",
                "param_1": "input_parameter",
                "uVar1": "result",
                "is_initialized": "initialized_flag",
                "PTR_DAT_000023fc": "pointer_to_initialized_data"
            },
            "code": "int check_initialized_000023d0(int param_1)\n{\n  int is_initialized = *(int *)PTR_DAT_000023fc;\n  if (is_initialized == 0) {\n    int result = FUN_000023c8(1, param_1, 0);\n    return result;\n  }\n  else {\n    return 0;\n  }\n}",
            "called": [
                "FUN_000023c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023d0",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": false,
            "current_name": "check_initialized_000023d0"
        },
        "FUN_00000a30": {
            "renaming": {
                "FUN_00000a30": "get_stack_pointer_00000a30",
                "auStack_20": "stack_pointer",
                "in_r3": "frame_pointer",
                "FUN_00000f04": "get_frame_pointer",
                "uRam00000a3c": "PTR_FRAME_SIZE",
                "PTR_DAT_00000a60": "DAT_OFFSET"
            },
            "code": "char *get_stack_pointer_00000a30(void)\n{\n  int frame_pointer;\n  char *stack_pointer;\n  frame_pointer = get_frame_pointer();\n  stack_pointer = (char *)(frame_pointer - PTR_FRAME_SIZE - PTR_DAT_00000a60);\n  return stack_pointer;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a30",
            "calling": [],
            "imported": false,
            "current_name": "get_stack_pointer_00000a30"
        },
        "FUN_000034c0": {
            "renaming": {
                "FUN_000034c0": "initialize_rtc_commands_000034c0",
                "PTR_s_usage__rtc__command___arguments__00003500": "usage_command_arguments",
                "PTR_s_commands__00003504": "commands",
                "PTR_s__poweron_power_the_interface_on_00003508": "power_on_interface",
                "PTR_s__poweroff_power_the_interface_of_0000350c": "power_off_interface",
                "PTR_s__clearalarm_deactivate_the_curre_00003510": "deactivate_current_alarm",
                "PTR_s__getalarm_print_the_currently_al_00003514": "print_current_alarm",
                "PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518": "set_alarm",
                "PTR_s__gettime_print_the_current_time_0000351c": "print_current_time",
                "PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520": "set_time"
            },
            "code": "int initialize_rtc_commands_000034c0(void)\n{\n  initialize_rtc_command(PTR_s_usage__rtc__command___arguments__00003500);\n  initialize_rtc_command(PTR_s_commands__00003504);\n  initialize_rtc_command(PTR_s__poweron_power_the_interface_on_00003508);\n  initialize_rtc_command(PTR_s__poweroff_power_the_interface_of_0000350c);\n  initialize_rtc_command(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  initialize_rtc_command(PTR_s__getalarm_print_the_currently_al_00003514);\n  initialize_rtc_command(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  initialize_rtc_command(PTR_s__gettime_print_the_current_time_0000351c);\n  initialize_rtc_command(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000034c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "initialize_rtc_commands_000034c0"
        },
        "FUN_000050e8": {
            "renaming": {
                "FUN_000050e8": "get_pointer_data_000050e8",
                "PTR_DAT_000050f0": "pointer_data"
            },
            "code": "const void * get_pointer_data_000050e8(void)\n{\n  return PTR_DAT_000050f0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050e8",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_pointer_data_000050e8"
        },
        "FUN_000042a4": {
            "renaming": {
                "FUN_000042a4": "initialize_000042a4",
                "param_1": "device",
                "uVar1": "status",
                "iVar2": "firstDevice",
                "bVar3": "isThisFirstDevice"
            },
            "code": "void initialize_000042a4(int device)\n{\n  bool isDeviceInitialized = *(int *)(device + DEVICE_INITIALIZED_OFFSET) == 0;\n  if (isDeviceInitialized) {\n    *(int *)(device + DEVICE_STATUS_1_OFFSET) = 0;\n    *(int *)(device + DEVICE_STATUS_2_OFFSET) = 0;\n    *(int *)(device + DEVICE_STATUS_3_OFFSET) = 0;\n    int firstDevice = *(int *)FIRST_DEVICE_POINTER;\n    char *deviceName = DEVICE_NAME_POINTER;\n    bool isThisFirstDevice = firstDevice == device;\n    if (isThisFirstDevice) {\n      firstDevice = 1;\n    }\n    if (isThisFirstDevice) {\n      *(int *)(device + DEVICE_INITIALIZED_OFFSET) = firstDevice;\n    }\n    int status1 = getDeviceStatus(device);\n    *(int *)(device + STATUS_1_OFFSET) = status1;\n    int status2 = getDeviceStatus(device);\n    *(int *)(device + STATUS_2_OFFSET) = status2;\n    int status3 = getDeviceStatus(device);\n    *(int *)(device + STATUS_3_OFFSET) = status3;\n    setDeviceStatus(status1, 4, 0);\n    setDeviceStatus(status2, 9, 1);\n    setDeviceStatus(status3, 0x12, 2);\n    *(int *)(device + DEVICE_INITIALIZED_OFFSET) = 1;\n  }\n  do_nothing(DAT_000042a0);\n}",
            "called": [
                "FUN_00004314",
                "FUN_000045ec",
                "FUN_0000428c",
                "FUN_000041f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000042a4",
            "calling": [
                "FUN_00004158",
                "FUN_00004418",
                "FUN_00004314",
                "FUN_00004db8",
                "FUN_000057f8",
                "FUN_00006768",
                "FUN_00004c84",
                "FUN_000054a8",
                "FUN_00005404",
                "FUN_00005e10",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "initialize_000042a4"
        },
        "FUN_00000514": {
            "renaming": {
                "FUN_00000514": "set_param_to_19_00000514",
                "*param_1": "*param",
                "0x13": "19",
                "0xffffffff": "-1"
            },
            "code": "int set_param_to_19_00000514(int *param){\n  *param = 19;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000514",
            "calling": [
                "FUN_000056b8"
            ],
            "imported": false,
            "current_name": "set_param_to_19_00000514"
        },
        "FUN_00002e9c": {
            "renaming": {
                "FUN_00002e9c": "start_program_00002e9c",
                "FUN_00003688": "initialize_system"
            },
            "code": "int start_program_00002e9c(void)\n{\n  initialize_system();\n  return 0;\n}",
            "called": [
                "FUN_00003688"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e9c",
            "calling": [],
            "imported": false,
            "current_name": "start_program_00002e9c"
        },
        "FUN_00001960": {
            "renaming": {
                "FUN_00001960": "initialize_system_00001960",
                "FUN_00001748": "set_system_mode",
                "FUN_00001710": "enable_system_interrupts",
                "DAT_000019b4": "interrupt_config",
                "*DAT_000019b8": "system_control_register",
                "*PTR_DAT_000019bc": "system_status_register"
            },
            "code": "void initialize_system_00001960(void) {\n  set_system_mode(0xa0);\n  enable_system_interrupts(DAT_000019b4,1);\n  *DAT_000019b8 = (*DAT_000019b8 & 0x3b) | 0x44;\n  while ((DAT_000019b8[6] & 0xc) != 4);\n  while ((DAT_000019b8[6] & 0x10) == 0);\n  *PTR_DAT_000019bc = 2;\n  return;\n}",
            "called": [
                "FUN_00001710",
                "FUN_00001748"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001960",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_system_00001960"
        },
        "FUN_00000990": {
            "renaming": {
                "FUN_00000990": "do_nothing_00000990"
            },
            "code": "\nvoid do_nothing_00000990(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000990",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "do_nothing_00000990"
        },
        "FUN_00001a3c": {
            "renaming": {
                "FUN_00001a3c": "set_data_and_value_00001a3c",
                "FUN_000016ec": "set_data",
                "FUN_00001734": "set_data",
                "DAT_00001a58": "DAT_value",
                "*PTR_DAT_00001a5c": "*PTR_data"
            },
            "code": "void set_data_and_value_00001a3c(void)\n{\n  set_data(DAT_00001a58, 1);\n  set_data(DAT_offset);\n  *PTR_DAT_00001a5c = 5;\n  return;\n}",
            "called": [
                "FUN_00001734",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a3c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_data_and_value_00001a3c"
        },
        "FUN_000045ee": {
            "renaming": {
                "FUN_000045ee": "reverse_copy_000045ee",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "num_bytes",
                "puVar1": "dst_end",
                "puVar2": "src_end"
            },
            "code": "void reverse_copy_000045ee(void *destination, const void *source, size_t num_bytes) {\n  void *src_end = (void *)((char *)source + num_bytes);\n  if ((source < destination) && (destination < src_end)) {\n    void *dst_end = (void *)((char *)destination + num_bytes);\n    while (dst_end != destination) {\n      src_end = (void *)((char *)src_end - 1);\n      dst_end = (void *)((char *)dst_end - 1);\n      *(char *)dst_end = *(char *)src_end;\n    }\n  }\n  else {\n    destination = (char *)destination - 1;\n    for (; source != src_end; source = (char *)source + 1) {\n      destination = (char *)destination + 1;\n      *(char *)destination = *(char *)source;\n    }\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ee",
            "calling": [
                "FUN_00003ff4"
            ],
            "imported": false,
            "current_name": "reverse_copy_000045ee"
        },
        "FUN_00005404": {
            "renaming": {
                "FUN_00005404": "process_input_00005404",
                "param_1": "buffer_address",
                "param_2": "input_char",
                "param_3": "buffer_ptr",
                "param_4": "param_4",
                "iVar1": "temp_int_1",
                "uVar2": "temp_uint_1",
                "puVar3": "temp_ptr_1"
            },
            "code": "uint process_input_00005404(int buffer_address, uint input_char, int *buffer_ptr, undefined4 param_4)\n{\n    int temp_int_1;\n    uint temp_uint_1;\n    undefined *temp_ptr_1;\n    \n    if ((buffer_address != 0) && (*(int *)(buffer_address + 0x18) == 0)) {\n        initialize_buffer();\n    }\n    \n    if (buffer_ptr == (int *)PTR_DAT_0000549c) {\n        buffer_ptr = *(int **)(buffer_address + 4);\n    }\n    else if (buffer_ptr == (int *)PTR_DAT_000054a0) {\n        buffer_ptr = *(int **)(buffer_address + 8);\n    }\n    else if (buffer_ptr == (int *)PTR_DAT_000054a4) {\n        buffer_ptr = *(int **)(buffer_address + 0xc);\n    }\n    \n    buffer_ptr[2] = buffer_ptr[6];\n    temp_uint_1 = (uint)*(ushort *)(buffer_ptr + 3);\n    temp_int_1 = temp_uint_1 << 0x1c;\n    if (((temp_int_1 < 0) && (temp_uint_1 = buffer_ptr[4], temp_uint_1 != 0)) || (temp_int_1 = check_buffer(buffer_address, buffer_ptr, temp_int_1, temp_uint_1, param_4), temp_int_1 == 0)) {\n        temp_int_1 = *buffer_ptr - buffer_ptr[4];\n        input_char = input_char & 0xff;\n        if ((temp_int_1 < buffer_ptr[5]) || (temp_int_1 = check_input(buffer_address, buffer_ptr), temp_int_1 == 0)) {\n            buffer_ptr[2] = buffer_ptr[2] + -1;\n            temp_ptr_1 = (undefined *)*buffer_ptr;\n            *buffer_ptr = (int)(temp_ptr_1 + 1);\n            *temp_ptr_1 = (char)input_char;\n            if (buffer_ptr[5] != temp_int_1 + 1) {\n                if (-1 < (int)((uint)*(ushort *)(buffer_ptr + 3) << 0x1f)) {\n                    return input_char;\n                }\n                if (input_char != 10) {\n                    return input_char;\n                }\n            }\n            temp_int_1 = check_input(buffer_address, buffer_ptr);\n            if (temp_int_1 == 0) {\n                return input_char;\n            }\n        }\n    }\n    return 0xffffffff;\n}",
            "called": [
                "FUN_00004158",
                "FUN_000054a8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005404",
            "calling": [
                "FUN_00004db8",
                "FUN_000057a8",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "process_input_00005404"
        },
        "FUN_00006974": {
            "renaming": {
                "FUN_00006974": "convert_to_64bit_integer_00006974",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "temp1",
                "uVar2": "result",
                "local_8": "local_array"
            },
            "code": "undefined8 convert_to_64bit_integer_00006974(int input1, int input2, int input3, int input4)\n{\n    int temp1;\n    undefined8 result;\n    undefined local_array[8];\n\n    if ((input4 == 0) && (input3 == 0)) {\n        if (input2 < 0) {\n            input1 = 0;\n            input2 = -0x80000000;\n        }\n        else if (input2 != 0 || input1 != 0) {\n            input2 = 0x7fffffff;\n            input1 = -1;\n        }\n        return CONCAT44(input2, input1);\n    }\n    if (input2 < 0) {\n        temp1 = -input2 - (uint)(input1 != 0);\n        if (input4 < 0) {\n            result = FUN_00006a14(-input1, temp1, -input3, -input4 - (uint)(input3 != 0), local_array);\n            return result;\n        }\n        result = FUN_00006a14(-input1, temp1, input3, input4, local_array);\n        return CONCAT44(-(int)((ulonglong)result >> 0x20) - (uint)((int)result != 0), -(int)result);\n    }\n    if (input4 < 0) {\n        result = FUN_00006a14(input1, input2, -input3, -input4 - (uint)(input3 != 0), local_array);\n        return CONCAT44(-(int)((ulonglong)result >> 0x20) - (uint)((int)result != 0), -(int)result);\n    }\n    result = FUN_00006a14();\n    return result;\n}",
            "called": [
                "FUN_00006a14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006974",
            "calling": [
                "FUN_0000443c"
            ],
            "imported": false,
            "current_name": "convert_to_64bit_integer_00006974"
        },
        "FUN_00004314": {
            "renaming": {
                "FUN_00004314": "find_valid_data_in_memory_00004314",
                "param_1": "error_code_ptr",
                "piVar1": "valid_data_ptr",
                "piVar2": "data_ptr",
                "iVar3": "memory_section_start_address",
                "ppiVar4": "next_memory_section_ptr_ptr",
                "FUN_00004274": "initialize_memory_search",
                "PTR_DAT_00004398": "MEMORY_SECTION_START_ADDRESS_PTR",
                "FUN_000042a4": "initialize_memory_section",
                "SECTION_SIZE_OFFSET": "0x18",
                "NEXT_SECTION_PTR_OFFSET": "0x48",
                "next_valid_data_in_memory": "next_valid_data_in_memory",
                "allocate_memory": "allocate_memory",
                "DATA_SIZE": "4",
                "ALLOCATE_MEMORY_ERROR_CODE": "0xc",
                "FUN_00004248": "allocate_memory"
            },
            "code": "int* find_valid_data_in_memory_00004314(undefinedDATA_SIZE *error_code_ptr){\n  int *valid_data_ptr;\n  int *data_ptr;\n  int memory_section_start_address;\n  int **next_memory_section_ptr_ptr;\n  initialize_memory_search();\n  memory_section_start_address = *(int *)PTR_DAT_0000DATA_SIZE398;\n  if (*(int *)(memory_section_start_address + SECTION_SIZE_OFFSET) == 0){\n    initialize_memory_section(memory_section_start_address);\n  }\n  next_memory_section_ptr_ptr = (int **)(memory_section_start_address + NEXT_SECTION_PTR_OFFSET);\n  do {\n    data_ptr = next_memory_section_ptr_ptr[1];\n    valid_data_ptr = next_valid_data_in_memory(data_ptr, next_memory_section_ptr_ptr);\n    if (valid_data_ptr != NULL){\n      return valid_data_ptr;\n    }\n    if (*next_memory_section_ptr_ptr == (int *)0){\n      valid_data_ptr = (int *)allocate_memory(error_code_ptr, DATA_SIZE);\n      *next_memory_section_ptr_ptr = valid_data_ptr;\n      if (valid_data_ptr == NULL){\n        *error_code_ptr = ALLOCATE_MEMORY_ERROR_CODE;\n        return NULL;\n      }\n    }\n    next_memory_section_ptr_ptr = (int **)*next_memory_section_ptr_ptr;\n  } while( true );\n}",
            "called": [
                "FUN_00004274",
                "FUN_00004280",
                "FUN_000045e4",
                "FUN_00004248",
                "FUN_00004622",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004314",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "find_valid_data_in_memory_00004314"
        },
        "FUN_00004dc8": {
            "renaming": {
                "FUN_00004dc8": "calculate_new_value_and_update_00004dc8",
                "param_1": "input_value",
                "param_2": "input_data",
                "iVar1": "calculated_value",
                "uVar2": "new_value",
                "bVar3": "is_calculated_value_positive"
            },
            "code": "void calculate_new_value_and_update_00004dc8(uint32_t param_1, int32_t param_2)\n{\n  int32_t calculated_value = calculate_value(param_1, (int32_t)*(short *)(param_2 + 0xe));\n  bool is_calculated_value_positive = calculated_value >= 0;\n  uint32_t new_value;\n  if (is_calculated_value_positive) {\n    new_value = *(uint32_t *)(param_2 + 0x54) + calculated_value;\n  }\n  else {\n    new_value = *(uint16_t *)(param_2 + 0xc) & 0xffffefff;\n  }\n  if (is_calculated_value_positive) {\n    *(uint32_t *)(param_2 + 0x54) = new_value;\n  }\n  if (!is_calculated_value_positive) {\n    *(uint16_t *)(param_2 + 0xc) = (uint16_t)new_value;\n  }\n  return;\n}",
            "called": [
                "FUN_00000490"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dc8",
            "calling": [],
            "imported": false,
            "current_name": "calculate_new_value_and_update_00004dc8"
        },
        "FUN_00005fd8": {
            "renaming": {
                "FUN_00005fd8": "execute_function_with_data_pointer_00005fd8",
                "param_1": "parameter_1",
                "param_2": "parameter_2",
                "param_3": "parameter_3",
                "FUN_00005edc": "execute_function",
                "*DAT_00005fe8": "data_pointer"
            },
            "code": "void execute_function_with_*execute_function_with_data_pointer_00005fd8(void* *execute_function_with_data_pointer_00005fd8, int parameter_1, int parameter_2, int parameter_3)\n{\n  execute_function(**execute_function_with_data_pointer_00005fd8, parameter_1, parameter_2, parameter_3);\n  return;\n}",
            "called": [
                "FUN_00005edc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd8",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "execute_function_with_data_pointer_00005fd8"
        },
        "FUN_00005e10": {
            "renaming": {
                "FUN_00005e10": "read_byte_00005e10",
                "param_1": "buffer",
                "param_2": "ptr",
                "iVar1": "status",
                "uVar2": "result",
                "pbVar3": "current_byte"
            },
            "code": "uint read_byte_00005e10(int buffer, byte **ptr) {\n  int status = *(int *)(buffer + 0x18);\n  if(buffer != 0 && status == 0) {\n    initialize();\n  }\n  if(ptr == (byte **)PTR_DAT_00005e5c) {\n    ptr = *(byte ***)(buffer + 4);\n  }\n  else if(ptr == (byte **)PTR_DAT_00005e60) {\n    ptr = *(byte ***)(buffer + 8);\n  }\n  else if(ptr == (byte **)PTR_DAT_00005e64) {\n    ptr = *(byte ***)(buffer + 0xc);\n  }\n  int result = read_byte_00005e10_from_buffer(buffer, ptr);\n  if (result == 0) {\n    (*ptr)[1]--;\n    byte *current_byte = *ptr;\n    *ptr = current_byte + 1;\n    return (uint)*current_byte;\n  }\n  else {\n    return 0xffffffff;\n  }\n}",
            "called": [
                "FUN_00006768",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e10",
            "calling": [
                "FUN_00004418"
            ],
            "imported": false,
            "current_name": "read_byte_00005e10"
        },
        "FUN_000033f4": {
            "renaming": {
                "FUN_000033f4": "set_alarm_000033f4",
                "param_1": "alarm_time",
                "auStack_2c": "alarm_buffer",
                "iVar1": "result",
                "FUN_0000328c": "create_alarm_buffer",
                "FUN_00002654": "set_rtc_alarm",
                "PTR_FUN_000031e0_1_0000343c": "ALARM_SETTING_PTR",
                "FUN_00004db8": "print_error_message",
                "PTR_s_rtc__error_setting_alarm_00003440": "ERROR_SETTING_ALARM_MSG_PTR"
            },
            "code": "int set_alarm_000033f4(int alarm_time){\n  int result;\n  char alarm_buffer[36];\n  result = create_alarm_buffer(alarm_time, alarm_buffer);\n  if (result == 0) {\n    result = set_rtc_alarm(alarm_buffer, PTR_FUN_000031e0_1_0000343c, 0);\n    if (result == -1) {\n      print_error_message(PTR_s_rtc__error_setting_alarm_00003440);\n      result = 1;\n    }\n    else {\n      result = 0;\n    }\n  }\n  else {\n    result = 1;\n  }\n  return result;\n}",
            "called": [
                "FUN_0000328c",
                "FUN_00004db8",
                "FUN_00002654"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033f4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "set_alarm_000033f4"
        },
        "FUN_0000443c": {
            "renaming": {
                "FUN_0000443c": "calculate_date_0000443c",
                "param_1": "date_in_seconds",
                "param_2": "date_components",
                "iVar1": "leap_years",
                "uVar2": "days_since_jan_1",
                "uVar3": "days_since_epoch",
                "uVar4": "month_days",
                "uVar5": "year_in_century",
                "uVar6": "year",
                "uVar7": "month",
                "uVar8": "century",
                "bVar9": "is_leap",
                "DAT_0000458c": "days_offset",
                "DAT_00004590": "years_in_century",
                "DAT_00004594": "days_in_four_years",
                "DAT_00004598": "days_in_hundred_years",
                "count_leading_zeroes": "count_leading_zeros",
                "PTR_DAT_0000461c": "month_days_table"
            },
            "code": "uint * calculate_date_0000443c(uint32_t *date_in_seconds, uint32_t *date_components)\n{\n    uint32_t year = *date_in_seconds;\n    uint32_t month = date_in_seconds[1];\n    uint32_t days_since_epoch = calculate_days_since_epoch(year, month, DAT_0000458c, 0);\n    uint32_t weekday = (days_since_epoch + 3) % 7;\n    uint32_t days_since_1900 = days_since_epoch - 0x23ab0 + (year / DAT_00004590) * 1461 / 4 + (month * 153 + 2) / 5;\n    uint32_t days_since_jan_1 = days_since_1900 - 0x76c;\n    uint32_t leap_years = (year / 100 + 1) * 3 / 4 - 19;\n    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {\n        if (month > 2) {\n            leap_years++;\n        }\n    }\n    uint32_t year_in_century = year % 100;\n    if (year_in_century < 2) {\n        days_since_jan_1++;\n    }\n    uint32_t month_day = days_since_jan_1 - leap_years * 365 - leap_years / 4;\n    uint32_t century = year / 100 + 1;\n    if (year_in_century == 0) {\n        century--;\n    }\n    date_components[0] = month_day % 100;\n    date_components[1] = month_day / 100 % 100;\n    date_components[2] = month_day / 10000;\n    date_components[3] = weekday;\n    date_components[4] = year_in_century + 100 * century;\n    date_components[5] = century;\n    date_components[6] = leap_years;\n    date_components[7] = days_since_jan_1;\n    date_components[8] = 0;\n    return date_components;\n}\n\nuint32_t calculate_days_since_epoch(uint32_t year, uint32_t month, uint32_t days, uint32_t offset)\n{\n    uint32_t days_since_epoch = (year - 1900) * 365 + (year - 1901) / 4 + days - 1;\n    uint32_t month_days = PTR_DAT_0000461c[month - 1];\n    if (month > 2 && is_leap_year(year)) {\n        month_days++;\n    }\n    days_since_epoch += month_days;\n    days_since_epoch += offset;\n    return days_since_epoch;\n}\n\nbool is_leap_year(uint32_t year)\n{\n    return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n}\n",
            "called": [
                "FUN_00006974"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000443c",
            "calling": [
                "FUN_00002624",
                "FUN_00002690"
            ],
            "imported": false,
            "current_name": "calculate_date_0000443c"
        },
        "FUN_000027b0": {
            "renaming": {
                "FUN_000027b0": "set_flag_and_initialize_000027b0",
                "puVar1": "data_address",
                "flag_address": "DAT_00002818",
                "data_address": "DAT_00002814"
            },
            "code": "void set_flag_and_initialize_000027b0(void)\n{\n  uint32_t *flag_address = DAT_00002818;\n  uint32_t *data_address = DAT_00002814;\n  flag_address[0x103c] |= 0x20000000;\n  data_address[4] = 1;\n  data_address[4] = 0;\n  if ((data_address[5] & 1) != 0) {\n    *data_address = 0;\n  }\n  data_address[4] = 0x104;\n  data_address[2] = 0xffffff42;\n  data_address[7] = 0;\n  initialize();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000027b0",
            "calling": [
                "FUN_000025f4"
            ],
            "imported": false,
            "current_name": "set_flag_and_initialize_000027b0"
        },
        "FUN_00005ebc": {
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "param_1": "destination",
                "param_2": "source",
                "cVar1": "current_char"
            },
            "code": "void copy_string_00005ebc(char *destination, char *source)\n{\n  char current_char;\n  do {\n    current_char = *source;\n    *destination = current_char;\n    source++;\n    destination++;\n  } while (current_char != '\\0');\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ebc",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "copy_string_00005ebc"
        },
        "FUN_00006192": {
            "renaming": {
                "FUN_00006192": "process_data_00006192",
                "param_1": "data",
                "param_2": "buffer",
                "undefined4": "int",
                "handle_error": "handle_error",
                "PTR_": "p_",
                "DAT_": "d_"
            },
            "code": "int process_data_00006192(int data, int *buffer)\n{\n    int *PTR_buffer = buffer;\n    if (PTR_buffer[13] != NULL)\n    {\n        if (PTR_buffer[13] != PTR_buffer + 17)\n        {\n            handle_error();\n        }\n        PTR_buffer[1] = PTR_buffer[16];\n        PTR_buffer[13] = NULL;\n        if (PTR_buffer[16] != NULL)\n        {\n            *PTR_buffer = PTR_buffer[15];\n            return 0;\n        }\n    }\n    *PTR_buffer = PTR_buffer[4];\n    PTR_buffer[1] = NULL;\n    *(unsigned short *)(PTR_buffer + 3) |= 0x20;\n    return -1;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006192",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "process_data_00006192"
        },
        "FUN_00001734": {
            "renaming": {
                "FUN_00001734": "initialize_data_buffer_00001734",
                "FUN_00001710": "fill_buffer",
                "DAT_00001744": "data_buffer"
            },
            "code": "void initialize_data_buffer_00001734(void)\n{\n  fill_buffer(DAT_00001744,6);\n  return;\n}",
            "called": [
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001734",
            "calling": [
                "FUN_00001a18",
                "FUN_000019c0",
                "FUN_00001a3c"
            ],
            "imported": false,
            "current_name": "initialize_data_buffer_00001734"
        },
        "FUN_00000e14": {
            "renaming": {
                "FUN_00000e14": "perform_operation_on_params_and_data_00000e14",
                "param_1": "param1",
                "param_2": "param2",
                "uVar1": "result"
            },
            "code": "int perform_operation_on_params_and_data_00000e14(int data, int param1, int param2)\n{\n  int result = perform_complex_operation(DAT_00000e34, param1, param2);\n  return result;\n}",
            "called": [
                "FUN_000012e2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e14",
            "calling": [
                "FUN_00000490"
            ],
            "imported": false,
            "current_name": "perform_operation_on_params_and_data_00000e14"
        },
        "FUN_0000281c": {
            "renaming": {
                "FUN_0000281c": "find_first_nonmatching_value_in_array_0000281c",
                "local_10": "index",
                "local_c": "value",
                "DAT_00002858": "PTR_DATA_ARRAY"
            },
            "code": "int find_first_nonmatching_value_in_array_0000281c(void)\n{\n  int index = 0;\n  int value = 0;\n  while (index < 3 && (value = *DAT_00002858, value != *DAT_00002858)) {\n    index++;\n  }\n  return value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000281c",
            "calling": [
                "FUN_00002624"
            ],
            "imported": false,
            "current_name": "find_first_nonmatching_value_in_array_0000281c"
        },
        "FUN_00002270": {
            "renaming": {
                "FUN_00002270": "are_pointers_equal_00002270",
                "param_1": "ptr_param_1",
                "uVar1": "result",
                "iVar2": "ptr_var_1",
                "bVar3": "are_equal"
            },
            "code": "bool are_pointers_equal_00002270(int ptr_param_1) {\n  int ptr_var_1 = *(int *)(ptr_param_1 + 0xc);\n  bool are_equal = *(int *)(ptr_param_1 + 8) == ptr_var_1;\n  if (are_equal) {\n    ptr_var_1 = 1;\n  }\n  return (bool)ptr_var_1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002270",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": false,
            "current_name": "are_pointers_equal_00002270"
        },
        "FUN_00005780": {
            "renaming": {
                "FUN_00005780": "call_function_with_param_00005780",
                "param_1": "param",
                "*DAT_0000578c": "function_pointer"
            },
            "code": "void call_function_with_param_00005780(void* *DAT_0000578c, int param){\n  *DAT_0000578c(param);\n  return;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005780",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "call_function_with_param_00005780"
        },
        "FUN_000020cc": {
            "renaming": {
                "FUN_000020cc": "initializeDataBuffer_000020cc",
                "FUN_00002028": "writeDataToBuffer",
                "DAT_000020dc": "dataBuffer"
            },
            "code": "void initializeDataBuffer_000020cc(void)\n{\n  writeDataToBuffer(DAT_000020dc,1);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020cc",
            "calling": [],
            "imported": false,
            "current_name": "initializeDataBuffer_000020cc"
        },
        "FUN_00002396": {
            "renaming": {
                "FUN_00002396": "initialize_system_00002396",
                "FUN_000025f4": "call_initialize_peripherals"
            },
            "code": "void initialize_system_00002396(void)\n{\n  call_initialize_peripherals();\n  return;\n}",
            "called": [
                "FUN_000025f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002396",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "initialize_system_00002396"
        },
        "FUN_00004cb4": {
            "renaming": {
                "FUN_00004cb4": "update_param_00004cb4",
                "param_1": "param",
                "puVar1": "ptr1",
                "uVar2": "updated_param",
                "puVar3": "ptr2",
                "unaff_r4": "unaff_r4",
                "iVar4": "index",
                "unaff_r5": "unaff_r5"
            },
            "code": "uint update_param_00004cb4(uint param)\n{\n  uint *ptr1;\n  uint updated_param;\n  uint *ptr2;\n  uint *ptr3;\n  uint index;\n  uint count;\n  \n  index = *data_pointer;\n  if ((index != 0) && (*(int *)(index + 0x18) == 0)) {\n    free_memory(index);\n  }\n  ptr1 = *(uint **)(index + 8);\n  if ((index != 0) && (*(int *)(index + 0x18) == 0)) {\n    free_memory(index);\n  }\n  if (ptr1 == (uint *)data_pointer_1) {\n    ptr1 = *(uint **)(index + 4);\n  }\n  else if (ptr1 == (uint *)data_pointer_2) {\n    ptr1 = *(uint **)(index + 8);\n  }\n  else if (ptr1 == (uint *)data_pointer_3) {\n    ptr1 = *(uint **)(index + 0xc);\n  }\n  if ((-1 < (int)(ptr1[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(ptr1 + 3) << 0x16))) {\n    do_nothing_1(ptr1[0x16]);\n  }\n  count = ptr1[2] - 1;\n  ptr1[2] = count;\n  if (((int)count < 0) && (((int)count < (int)ptr1[6] || (updated_param = param & 0xff, updated_param == 10))))\n  {\n    updated_param = update_param_00004cb4_2(index,param,ptr1,updated_param,unaff_r4,unaff_r5);\n  }\n  else {\n    ptr2 = (uint *)*ptr1;\n    *ptr1 = ptr2 + 1;\n    *ptr2 = (char)param;\n    updated_param = param & 0xff;\n  }\n  if ((-1 < (int)(ptr1[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(ptr1 + 3) << 0x16))) {\n    do_nothing_2(ptr1[0x16]);\n  }\n  return updated_param;\n}",
            "called": [
                "FUN_000045ec",
                "FUN_000045e8",
                "FUN_00005404",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cb4",
            "calling": [
                "FUN_00002a00"
            ],
            "imported": false,
            "current_name": "update_param_00004cb4"
        },
        "FUN_00003478": {
            "renaming": {
                "FUN_00003478": "set_rtc_time_and_check_error_00003478",
                "param_1": "time_to_set",
                "iVar1": "set_rtc_status",
                "uVar2": "return_value",
                "auStack_2c": "rtc_time_buffer",
                "FUN_0000328c": "get_rtc_time_as_string",
                "FUN_00002600": "check_rtc_time",
                "PTR_s_rtc__error_setting_time_000034bc": "rtc_error_message"
            },
            "code": "int set_rtc_time_and_check_error_00003478(int time_to_set){\n  int set_rtc_status;\n  char rtc_time_buffer[36];\n  set_rtc_status = get_rtc_time_as_string(time_to_set, rtc_time_buffer);\n  if (set_rtc_status == 0) {\n    int check_rtc_status = check_rtc_time(rtc_time_buffer);\n    if (check_rtc_status == -1) {\n      print_error_message(PTR_s_rtc__error_setting_time_000034bc);\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n  else {\n    return 1;\n  }\n}",
            "called": [
                "FUN_00002600",
                "FUN_0000328c",
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003478",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "set_rtc_time_and_check_error_00003478"
        },
        "FUN_00002028": {
            "renaming": {
                "<original_function_name>": "process_data",
                "param_1": "data",
                "param_2": "flag",
                "local_c": "index",
                "uVar2": "flag_value",
                "iVar1": "function_index",
                "PTR_DAT_000020b4": "function_data",
                "FUN_00002028": "process_data_00002028"
            },
            "code": "void process_data_00002028(int data, uint32_t flag){\n                      int index;\n                      uint32_t bit_mask;\n                      uint32_t flag_value;\n                      flag_value = *(uint32_t *)(data + 0xa0);\n                      for (index = 0; index < 0x20; index++) {\n                        bit_mask = 1 << (index & 0xff);\n                        if (((flag_value & bit_mask) != 0) && ((*(uint32_t *)(data + index * 4) & 0xf0000) != 0)) {\n                          *(uint32_t *)(data + 0xa0) = bit_mask;\n                          int function_index = get_function_index(flag);\n                          (**(code **)(PTR_DAT_000020b4 + function_index * 0xc))(*(uint32_t *)(PTR_DAT_000020b4 + function_index * 0xc + 4));\n                        }\n                      }\n                      finalize_processing();\n                    }",
            "called": [
                "FUN_00001e0c",
                "FUN_00001cf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002028",
            "calling": [
                "FUN_000020b8",
                "FUN_00002108",
                "FUN_000020f4",
                "FUN_000020cc",
                "FUN_000020e0"
            ],
            "imported": false,
            "current_name": "process_data_00002028"
        },
        "FUN_000016c8": {
            "renaming": {
                "FUN_000016c8": "set_value_at_pointer_to_one_000016c8",
                "param_1": "pointer",
                "param_2": "byte",
                "puVar1": "pointer_to_int"
            },
            "code": "void set_value_at_pointer_to_one_000016c8(void *pointer, unsigned char byte){\n  unsigned int *pointer_to_int = (unsigned int *)pointer;\n  *pointer_to_int = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016c8",
            "calling": [
                "FUN_000017dc"
            ],
            "imported": false,
            "current_name": "set_value_at_pointer_to_one_000016c8"
        },
        "FUN_00001a60": {
            "renaming": {
                "FUN_00001a60": "initialize_data_transmission_00001a60",
                "DAT_00001ac4": "DAT_buffer",
                "*DAT_00001ac8": "*data_control_register",
                "DAT_00001acc": "data_status_register",
                "*PTR_DAT_00001ad0": "*PTR_data_length"
            },
            "code": "void initialize_data_transmission_00001a60(void)\n{\n  set_data_rate(DAT_00001ac4, 1);\n  *DAT_00001ac8 = *DAT_00001ac8 & 0x3f | 0x80;\n  while ((DAT_00001acc[6] & 0xc) != 8);\n  set_data_length(DAT_00001ac4, 6);\n  while ((DAT_00001acc[6] & 0x20) == 0);\n  while ((DAT_00001acc[6] & 0x40) == 0);\n  *PTR_DAT_00001ad0 = 6;\n  return;\n}",
            "called": [
                "FUN_00001710",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a60",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_data_transmission_00001a60"
        },
        "FUN_0000099c": {
            "renaming": {
                "FUN_0000099c": "initialize_memory_0000099c",
                "uStack_18": "uStack_memory_location",
                "local_14": "stack_pointer",
                "local_10": "data_pointer",
                "local_c": "bss_pointer",
                "DAT_00000a14": "DATA_START",
                "FUN_00000db0": "initialize_system",
                "PTR_DAT_00000a18": "RELOCATION_ARRAY_START",
                "DAT_00000a1c": "BSS_DEFAULT_VALUE",
                "PTR_Elf32_Rel_ARRAY_00000a20": "RELOCATION_ARRAY_START",
                "PTR_DAT_00000a24": "RELOCATION_ARRAY_END",
                "PTR_DAT_00000a28": "ZERO_START",
                "DAT_00000a2c": "ZERO_END",
                "do_nothing_00000990": "do_nothing",
                "FUN_00000e64": "initialize_subsystem",
                "FUN_0000459c": "initialize_io",
                "FUN_00000f8c": "initialize_interrupts"
            },
            "code": "void initialize_memory_0000099c(void)\n{\n  undefined4 uStack_memory_location;\n  undefined4 *stack_pointer;\n  undefined4 *data_pointer;\n  undefined4 *bss_pointer;\n\n  stack_pointer = &uStack_memory_location;\n  data_pointer = DAT_00000a14;\n  initialize_system();\n  bss_pointer = (undefined4 *)BSS_START;\n  while (bss_pointer < &uStack_memory_location) {\n    *bss_pointer = DAT_00000a1c;\n    bss_pointer++;\n  }\n  bss_pointer = (undefined4 *)PTR_DAT_00000a18;\n  while (bss_pointer < PTR_DAT_00000a24) {\n    *bss_pointer = *data_pointer;\n    data_pointer++;\n    bss_pointer++;\n  }\n  bss_pointer = (undefined4 *)PTR_DAT_00000a28;\n  while (true) {\n    if (DAT_00000a2c <= bss_pointer) break;\n    *bss_pointer = 0;\n    bss_pointer++;\n  }\n  do_nothing();\n  initialize_subsystem();\n  initialize_io();\n  initialize_interrupts();\n  return;\n}\n",
            "called": [
                "FUN_0000459c",
                "FUN_00000f8c",
                "FUN_00000e64",
                "FUN_00000990",
                "FUN_00000db0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000099c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_memory_0000099c"
        },
        "FUN_00002d94": {
            "renaming": {
                "FUN_00002d94": "reverse_string_00002d94",
                "param_1": "string",
                "param_2": "length",
                "iVar1": "char_value",
                "bVar2": "current_char",
                "bVar3": "is_first_char",
                "local_c": "current_position"
            },
            "code": "uint reverse_string_00002d94(undefined *string, int length)\n{\n  int char_value;\n  byte current_char;\n  bool is_first_char = true;\n  undefined *current_position = string;\n  while(true)\n  {\n    if (length + -1 <= (int)current_position - (int)string)\n    {\n      return 0xffffffff;\n    }\n    char_value = FUN_00004418();\n    if (char_value < 0)\n    {\n      break;\n    }\n    if ((char_value == 0xd) || (char_value == 10))\n    {\n      *current_position = 0;\n      FUN_00002a00(0xd);\n      FUN_00002a00(10);\n      if (is_first_char)\n      {\n        string = (undefined *)0x1;\n      }\n      current_char = (byte)string;\n      if (!is_first_char)\n      {\n        current_char = 0;\n      }\n      return (uint)current_char;\n    }\n    if ((char_value == 8) || (char_value == 0x7f))\n    {\n      if (current_position != string)\n      {\n        current_position = current_position - 1;\n        *current_position = 0;\n        FUN_00002a00(8);\n        FUN_00002a00(0x20);\n        FUN_00002a00(8);\n      }\n    }\n    else\n    {\n      *current_position = (char)char_value;\n      FUN_00002a00(char_value);\n      current_position = current_position + 1;\n      is_first_char = false;\n    }\n  }\n  return 1;\n}",
            "called": [
                "FUN_00004418",
                "FUN_00002a00"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002d94",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "reverse_string_00002d94"
        },
        "FUN_00003918": {
            "renaming": {
                "FUN_00003918": "map_param_to_value_00003918",
                "param_1": "param",
                "uVar1": "value"
            },
            "code": "uint32_t map_param_to_value_00003918(uint32_t param) {\n    uint32_t value;\n    switch(param) {\n        case 2:\n            value = 0x68;\n            break;\n        case 3:\n            value = 0x6b;\n            break;\n        case 6:\n            value = 0x4d;\n            break;\n        case 9:\n            value = 0x47;\n            break;\n        case 0xc:\n            value = 0x54;\n            break;\n        case 0xf:\n            value = 0x50;\n            break;\n        case 0xf1:\n            value = 0x66;\n            break;\n        case 0xf4:\n            value = 0x70;\n            break;\n        case 0xf7:\n            value = 0x6e;\n            break;\n        case 0xfa:\n            value = 0x75;\n            break;\n        case 0xfd:\n            value = 0x6d;\n            break;\n        default:\n            value = 0;\n            break;\n    }\n    return value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003918",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "map_param_to_value_00003918"
        },
        "FUN_00003d64": {
            "renaming": {
                "FUN_00003d64": "execute_function_00003d64",
                "param_1": "function_pointer",
                "param_2": "arg1",
                "uVar1": "result"
            },
            "code": "int execute_function_00003d64(int function_pointer, int arg1){\n  int result;\n  if (function_pointer == 0) {\n    result = -19;\n  }\n  else {\n    result = (***(int ***)(function_pointer + 0xc))(*(int *)(function_pointer + 4), arg1);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d64",
            "calling": [
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "execute_function_00003d64"
        },
        "FUN_00004e52": {
            "renaming": {
                "FUN_00004e52": "compare_bytes_00004e52",
                "param_1": "first_array",
                "param_2": "second_array",
                "uVar2": "first_byte_value",
                "bVar1": "second_byte",
                "bVar3": "bytes_match"
            },
            "code": "int compare_bytes_00004e52(byte *first_array, byte *second_array) {\n  byte first_byte;\n  byte second_byte;\n  bool bytes_match;\n  do {\n    uint first_byte_value = (uint)*first_array;\n    second_byte = *second_array;\n    bytes_match = first_byte_value == 1;\n    if (first_byte_value != 0) {\n      bytes_match = first_byte_value == second_byte;\n    }\n    first_array++;\n    second_array++;\n  } while (bytes_match);\n  return (int)(first_byte - second_byte);\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e52",
            "calling": [
                "FUN_00002a18",
                "FUN_00005100",
                "FUN_00004e52",
                "FUN_00002fe0",
                "FUN_0000316c",
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "compare_bytes_00004e52"
        },
        "FUN_000010d4": {
            "renaming": {
                "FUN_000010d4": "create_data_structure_000010d4",
                "param_1": "data_address",
                "param_2": "data_size",
                "param_3": "data_type",
                "param_4": "data_flags",
                "param_5": "param_5",
                "param_6": "param_6",
                "param_7": "param_7",
                "uVar1": "var1",
                "uVar2": "var2",
                "iVar3": "return_value",
                "uVar4": "var4",
                "puVar5": "data_pointer",
                "local_30": "adjusted_data_size",
                "local_2c": "adjusted_data_address",
                "local_10": "i",
                "local_c": "index_1",
                "local_a": "index_2",
                "PTR_DAT_0000126c": "ptr_data_index",
                "PTR_DAT_00001270": "ptr_data_count"
            },
            "code": "int create_data_structure_000010d4(uint data_address, int data_size, byte data_type, uint data_flags, undefined4 param_5, undefined4 param_6, undefined4 param_7)\n{\n  undefined4 var1;\n  undefined4 var2;\n  int return_value;\n  uint var4;\n  undefined4 *data_pointer;\n  int adjusted_data_size;\n  uint adjusted_data_address;\n  short index_1;\n  short index_2;\n  if (data_type < 0x10) {\n    adjusted_data_size = data_size;\n    adjusted_data_address = data_address;\n    if ((data_address & 3) != 0) {\n      adjusted_data_size = 4 - (data_address & 3);\n      adjusted_data_address = adjusted_data_size + data_address;\n      adjusted_data_size = data_size - adjusted_data_size;\n    }\n    var4 = adjusted_data_size - 0x30U & 0xfffffffc;\n    data_pointer = (undefined4 *)(var4 + adjusted_data_address);\n    if ((data_flags & 8) == 0) {\n      *(uint *)adjusted_data_address = adjusted_data_address;\n    }\n    else {\n      for (uint i = adjusted_data_address; i < var4 + adjusted_data_address; i = i + 4) {\n        *(uint *)i = i;\n      }\n    }\n    var1 = allocate_memory();\n    index_2 = 0;\n    for (index_1 = 1; index_1 < 0x21; index_1 = index_1 + 1) {\n      if (*(int *)(PTR_DAT_0000126c + index_1 * 4) == 0) {\n        index_2 = index_1;\n        break;\n      }\n    }\n    if (index_2 == 0) {\n      deallocate_memory(var1);\n      return_value = -0x8b;\n    }\n    else {\n      *(undefined4 **)(PTR_DAT_0000126c + index_2 * 4) = data_pointer;\n      *(short *)((int)data_pointer + 6) = index_2;\n      var2 = get_value(param_5,param_6,adjusted_data_address,var4);\n      *data_pointer = var2;\n      data_pointer[9] = adjusted_data_address;\n      data_pointer[0xb] = data_size;\n      data_pointer[10] = param_7;\n      *(byte *)((int)data_pointer + 5) = data_type;\n      *(undefined *)(data_pointer + 1) = 0;\n      data_pointer[2] = 0;\n      data_pointer[3] = 0;\n      data_pointer[4] = 0;\n      fill_memory(data_pointer + 5,0);\n      data_pointer[8] = 0;\n      *(int *)PTR_DAT_00001270 = *(int *)PTR_DAT_00001270 + 1;\n      if ((data_flags & 1) == 0) {\n        set_value(data_pointer,10);\n        if ((data_flags & 4) == 0) {\n          deallocate_memory(var1);\n          deallocate_memory(data_type);\n          return_value = data_size;\n        }\n      }\n      else {\n        set_value(data_pointer,1);\n      }\n      deallocate_memory(var1);\n      return_value = index_2;\n    }\n  }\n  else {\n    return_value = -0x16;\n  }\n  return return_value;\n}",
            "called": [
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_00000fec",
                "FUN_000007dc",
                "FUN_00000738",
                "FUN_00000698"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010d4",
            "calling": [
                "FUN_00000f8c"
            ],
            "imported": false,
            "current_name": "create_data_structure_000010d4"
        },
        "FUN_000045e4": {
            "renaming": {
                "FUN_000045e4": "do_nothing_000045e4"
            },
            "code": "\nvoid do_nothing_000045e4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e4",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e4"
        },
        "FUN_00000738": {
            "renaming": {
                "FUN_00000738": "check_param_range_00000738",
                "param_1": "param_value",
                "iVar1": "num_attempts",
                "PTR_DAT_0000078c": "ptr_dat_1",
                "PTR_DAT_00000790": "ptr_dat_2"
            },
            "code": "void check_param_range_00000738(ushort param_value) {\n  int num_attempts = 0;\n  int max_attempts = *(byte *)(*(int *)PTR_DAT_0000078c + 4);\n  int min_param_value = *(byte *)(*(int *)PTR_DAT_0000078c + 5);\n\n  if (max_attempts < 9 || param_value < min_param_value) {\n    num_attempts = FUN_00000d2a();\n    if (num_attempts == 0) {\n      FUN_0000093c();\n    }\n    else {\n      *(undefined4 *)PTR_DAT_00000790 = 1;\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00000d2a",
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000738",
            "calling": [
                "FUN_000024bc",
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "check_param_range_00000738"
        },
        "FUN_00003e58": {
            "renaming": {
                "FUN_00003e58": "reverse_and_negate_00003e58",
                "param_1": "str",
                "param_2": "num",
                "local_18": "reversed_num",
                "local_14": "reversed_str",
                "FUN_00003dc4": "reverse"
            },
            "code": "int reverse_and_negate_00003e58(int* str, int num){\n                      int reversed_num = num;\n                      int* reversed_str = str;\n                      if(num < 0){\n                        if(str != NULL){\n                          reversed_str = str + 1;\n                          *str = '-';\n                        }\n                        reversed_num = -num;\n                      }\n                      int result = reverse(reversed_str, reversed_num);\n                      return (num < 0 ? -1 : 1) * result;\n                    }",
            "called": [
                "FUN_00003dc4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e58",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": false,
            "current_name": "reverse_and_negate_00003e58"
        },
        "FUN_00004e26": {
            "renaming": {
                "FUN_00004e26": "check_value_and_set_flag_00004e26",
                "param_1": "data",
                "param_2": "offset",
                "iVar1": "value",
                "uVar2": "flag",
                "bVar3": "is_value_invalid"
            },
            "code": "void check_value_and_set_flag_00004e26(void* data, int offset)\n{\n  int value = get_value_from_data(data, (int)*(short *)(offset + 0xe));\n  bool is_value_invalid = value == -1;\n  ushort flag = *(ushort *)(offset + 0xc);\n  if (is_value_invalid) {\n    flag &= 0xefff;\n  }\n  else {\n    *(int *)(offset + 0x54) = value;\n    flag |= 0x1000;\n  }\n  *(ushort *)(offset + 0xc) = flag;\n}\n",
            "called": [
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e26",
            "calling": [],
            "imported": false,
            "current_name": "check_value_and_set_flag_00004e26"
        },
        "FUN_000045e8": {
            "renaming": {
                "FUN_000045e8": "do_nothing_000045e8"
            },
            "code": "\nvoid do_nothing_000045e8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e8",
            "calling": [
                "FUN_00004274",
                "FUN_00004158",
                "FUN_00004418",
                "FUN_00004db8",
                "FUN_000057f8",
                "FUN_00005fec",
                "FUN_0000428c",
                "FUN_00005790",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e8"
        },
        "FUN_000057f8": {
            "renaming": {
                "FUN_000057f8": "parse_and_execute_format_string_000057f8",
                "param_1": "arg1",
                "param_2": "format_string",
                "param_3": "output_buffer",
                "param_4": "output_length",
                "puVar1": "percent_sign_position",
                "puVar2": "hexadecimal_position",
                "iVar3": "result",
                "iVar4": "parse_result",
                "piVar5": "next_output_length",
                "bVar6": "digit_found",
                "pbVar7": "current_position",
                "pbVar8": "previous_position",
                "unaff_r7": "previous_parse_result",
                "local_8c": "next_output_length_ptr",
                "local_88": "flags",
                "local_84": "precision",
                "uStack_80": "width",
                "local_7c": "current_output_length",
                "local_74": "total_output_length",
                "local_70": "current_character",
                "local_6f": "space_character",
                "local_6e": "plus_character",
                "local_45": "padding_character",
                "local_30": "null_character"
            },
            "code": "\nint parse_and_execute_format_string_000057f8(int arg1,undefined *format_string,byte *output_buffer,int *output_length)\n\n{\n  undefined *percent_sign_position;\n  undefined *hexadecimal_position;\n  int result;\n  int parse_result;\n  int *next_output_length;\n  bool digit_found;\n  byte *current_position;\n  int previous_parse_result;\n  byte *previous_position;\n  int *next_output_length_ptr;\n  uint flags;\n  int precision;\n  undefined4 width;\n  int current_output_length;\n  int total_output_length;\n  byte current_character;\n  undefined space_character;\n  undefined plus_character;\n  undefined padding_character;\n  undefined4 null_character;\n  \n  if ((arg1 != 0) && (*(int *)(arg1 + 0x18) == 0)) {\n    FUN_000042a4();\n  }\n  if (format_string == PTR_DAT_00005a38) {\n    format_string = *(undefined **)(arg1 + 4);\n  }\n  else if (format_string == PTR_DAT_00005a3c) {\n    format_string = *(undefined **)(arg1 + 8);\n  }\n  else if (format_string == PTR_DAT_00005a40) {\n    format_string = *(undefined **)(arg1 + 0xc);\n  }\n  if ((-1 < *(int *)(format_string + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(format_string + 0xc) << 0x16))) {\n    do_nothing_000045e8(*(undefined4 *)(format_string + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(format_string + 0xc) << 0x1c)) || (*(int *)(format_string + 0x10) == 0)) &&\n     (result = FUN_000054a8(arg1,format_string), result != 0)) {\n    if ((-1 < *(int *)(format_string + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(format_string + 0xc) << 0x16))) {\n      do_nothing_000045ec(*(undefined4 *)(format_string + 0x58));\n    }\n    return -1;\n  }\n  percent_sign_position = PTR_s___0__00005a44;\n  total_output_length = 0;\n  space_character = 0x20;\n  plus_character = 0x30;\n  previous_position = output_buffer;\n  next_output_length_ptr = output_length;\nLAB_0000588e:\n  current_position = previous_position;\n  if (*current_position != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  previous_position = current_position + 1;\n  if (*current_position != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  result = (int)current_position - (int)output_buffer;\n  if (result != 0) {\n    parse_result = FUN_000057d2(arg1,format_string,output_buffer,result);\n    if (parse_result == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(format_string + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(format_string + 0xc) << 0x16))) {\n        do_nothing_000045ec(*(undefined4 *)(format_string + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(format_string + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return total_output_length;\n    }\n    total_output_length = total_output_length + result;\n  }\n  if (*current_position == 0) goto LAB_00005a06;\n  precision = -1;\n  width = 0;\n  flags = 0;\n  current_output_length = 0;\n  padding_character = 0;\n  null_character = 0;\n  previous_position = current_position + 1;\n  while( true ) {\n    current_position = previous_position + 1;\n    result = FUN_00006010(PTR_s___0__00005a44,*previous_position,5);\n    hexadecimal_position = PTR_DAT_00005a54;\n    if (result == 0) break;\n    flags = 1 << (result - (int)percent_sign_position & 0xffU) | flags;\n    previous_position = current_position;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    padding_character = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    padding_character = 0x2b;\n  }\n  if (*previous_position == 0x2a) {\n    next_output_length = next_output_length_ptr + 1;\n    current_output_length = *next_output_length_ptr;\n    next_output_length_ptr = next_output_length;\n    if (current_output_length < 0) {\n      current_output_length = -current_output_length;\n      flags = flags | 2;\n    }\n  }\n  else {\n    digit_found = false;\n    result = current_output_length;\n    current_position = previous_position;\n    while( true ) {\n      if (9 < *current_position - 0x30) break;\n      result = result * 10 + (*current_position - 0x30);\n      digit_found = true;\n      current_position = current_position + 1;\n    }\n    if (digit_found) {\n      current_output_length = result;\n    }\n  }\n  if (*current_position == 0x2e) {\n    if (current_position[1] == 0x2a) {\n      precision = *next_output_length_ptr;\n      if (precision < 0) {\n        precision = -1;\n      }\n      current_position = current_position + 2;\n      next_output_length_ptr = next_output_length_ptr + 1;\n    }\n    else {\n      digit_found = false;\n      precision = 0;\n      result = 0;\n      while( true ) {\n        current_position = current_position + 1;\n        if (9 < *current_position - 0x30) break;\n        result = result * 10 + (*current_position - 0x30);\n        digit_found = true;\n      }\n      if (digit_found) {\n        precision = result;\n      }\n    }\n  }\n  result = FUN_00006010(PTR_DAT_00005a54,*current_position,3);\n  if (result != 0) {\n    flags = flags | 0x40 << (result - (int)hexadecimal_position & 0xffU);\n    current_position = current_position + 1;\n  }\n  output_buffer = current_position + 1;\n  current_character = *current_position;\n  result = FUN_00006010(PTR_s_efgEFG_00005a48,current_character,6);\n  if (result == 0) {\n    result = FUN_00005b34(arg1,&flags,format_string,DAT_00005a50,&next_output_length_ptr);\n  }\n  else {\n    result = arg1;\n    if (DAT_00005a4c == 0) {\n      next_output_length_ptr = (int *)(((int)next_output_length_ptr + 7U & 0xfffffff8) + 8);\n      result = previous_parse_result;\n      goto LAB_000059b4;\n    }\n  }\n  if (result == -1) goto LAB_00005a06;\nLAB_000059b4:\n  total_output_length = total_output_length + result;\n  previous_position = output_buffer;\n  previous_parse_result = result;\n  goto LAB_0000588e;\n}\n\n",
            "called": [
                "FUN_00006010",
                "FUN_000057d2",
                "FUN_000045ec",
                "FUN_000054a8",
                "FUN_00005b34",
                "FUN_000045e8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057f8",
            "calling": [
                "FUN_00004c84"
            ],
            "imported": false,
            "current_name": "parse_and_execute_format_string_000057f8"
        },
        "FUN_000018bc": {
            "renaming": {
                "FUN_000018bc": "initialize_device_000018bc",
                "FUN_00001748": "set_device_mode",
                "DAT_00001910": "device_status_register",
                "FUN_00001710": "wait_for_device_ready",
                "PTR_DAT_00001918": "data_buffer_pointer"
            },
            "code": "void initialize_device_000018bc(void)\n{\n  set_device_mode(0xa0);\n  *DAT_00001910 = (*DAT_00001910 & 0x3b) | 4;\n  wait_for_device_ready();\n  wait_for_device_idle();\n  *PTR_DAT_00001918 = 0;\n  return;\n}",
            "called": [
                "FUN_00001710",
                "FUN_00001748"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000018bc",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_device_000018bc"
        },
        "FUN_00000f04": {
            "renaming": {
                "FUN_00000f04": "process_input_00000f04",
                "param_1": "input_char",
                "param_2": "input_num",
                "piRam00000f4c": "flag_ptr",
                "local_10": "input_num",
                "local_9": "input_char",
                "FUN_00000ed8": "initialize",
                "FUN_00004c84": "write_to_memory",
                "uRam00000f50": "ram_ptr_1",
                "FUN_0000211c": "setup",
                "uRam00000f54": "ram_ptr_2",
                "uRam00000f58": "ram_ptr_3",
                "FUN_00000cd0": "perform_task_1",
                "do_nothing_00000ef8": "do_nothing_1",
                "UNRECOVERED_JUMPTABLE": "jump_table",
                "FUN_00000e58": "perform_task_2",
                "uStack_18": "stack_ptr",
                "do_nothing_00002400": "do_nothing_2",
                "PTR_s_main____This_is_RIOT___Version__2_00000f7c": "PTR_s_main____This_is_RIOT___Version__2_00000f7c",
                "FUN_000023a4": "perform_task_3"
            },
            "code": "void process_input_00000f04(char input_char, unsigned int input_num)\n{\n  unsigned int *flag_ptr = (unsigned int *)0x00000f4c;\n  unsigned int *ram_ptr_1 = (unsigned int *)0x00000f50;\n  unsigned int *ram_ptr_2 = (unsigned int *)0x00000f54;\n  unsigned int *ram_ptr_3 = (unsigned int *)0x00000f58;\n\n  if (*flag_ptr == 0) {\n    *flag_ptr = 1;\n    if (input_char == 0x03) {\n      initialize();\n    }\n    write_to_memory(ram_ptr_1, input_num);\n    setup();\n    write_to_memory(ram_ptr_2);\n    write_to_memory(ram_ptr_3);\n  }\n  perform_task_1();\n  do_nothing_1();\n  jump_table = (void *)0xf4d;\n  perform_task_2();\n  unsigned int *stack_ptr = &stack_ptr + 1;\n  do_nothing_2();\n  write_to_memory(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  perform_task_3();\n  jump_table(0);\n}\n\n",
            "called": [
                "FUN_00000e58",
                "FUN_00000ef8",
                "FUN_00000cd0",
                "FUN_0000211c",
                "FUN_000023a4",
                "FUN_00002400",
                "FUN_00004c84",
                "FUN_00000ed8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f04",
            "calling": [
                "FUN_000013b8",
                "FUN_00000fec",
                "FUN_00003ec4",
                "FUN_00000cc0",
                "FUN_00000a30",
                "FUN_00001034"
            ],
            "imported": false,
            "current_name": "process_input_00000f04"
        },
        "FUN_00000610": {
            "renaming": {
                "FUN_00000610": "initialize_variable_00000610",
                "iVar1": "variable1",
                "iVar2": "variable2",
                "uVar3": "result",
                "calculate_value": "calculate_value",
                "PTR_DAT_00000684": "PTR_DAT_00000684",
                "PTR_DAT_00000688": "PTR_DAT_00000688",
                "PTR_DAT_0000068c": "PTR_DAT_0000068c",
                "PTR_DAT_00000690": "PTR_DAT_00000690",
                "PTR_DAT_00000694": "PTR_DAT_00000694"
            },
            "code": "int initialize_variable_00000610(void)\n{\n  int variable1;\n  int variable2;\n  int result;\n  \n  *(int *)PTR_DAT_00000684 = 0;\n  variable2 = *(int *)PTR_DAT_00000688;\n  variable1 = calculate_value(*(int *)PTR_DAT_0000068c);\n  variable1 = **(int **)(PTR_DAT_00000690 + variable1 * 4);\n  if (variable2 == variable1 + -8) {\n    result = 0;\n  }\n  else {\n    if ((variable2 != 0) && (*(char *)(variable2 + 4) == '\t')) {\n      *(char *)(variable2 + 4) = 10;\n    }\n    *(char *)(variable1 + -4) = 9;\n    *(short *)PTR_DAT_00000694 = *(short *)(variable1 + -2);\n    *(int *)PTR_DAT_00000688 = variable1 + -8;\n    result = 1;\n  }\n  return result;\n}",
            "called": [
                "FUN_00000566"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000610",
            "calling": [],
            "imported": false,
            "current_name": "initialize_variable_00000610"
        },
        "FUN_00003694": {
            "renaming": {
                "FUN_00003694": "display_data_object_00003694",
                "param_1": "data_object_address",
                "param_2": "data_object_size",
                "uVar1": "data_object_type",
                "cVar2": "current_bit",
                "uVar3": "bit_mask",
                "bVar4": "bit_set",
                "auStack_18": "stack_buffer",
                "local_10": "string_length",
                "local_a": "string_buffer",
                "local_9": "current_byte"
            },
            "code": "void display_data_object_00003694(int data_object_address, byte data_object_size) {\n  undefined4 uVar1;\n  char current_bit;\n  uint bit_mask;\n  bool bit_set;\n  undefined stack_buffer [8];\n  int string_length;\n  char string_buffer;\n  byte current_byte;\n  if ((data_object_address == 0) || (3 < data_object_size)) {\n    display_error_message(PTR_s_Unable_to_display_data_object_00003694_000037e4);\n  }\n  else {\n    display_message(PTR_s_Data__000037e8);\n    for (current_byte = 0; current_byte < data_object_size; current_byte++) {\n      if (*(byte *)(data_object_address + 6) < 0x14) {\n        bit_mask = DAT_000037ec & 1 << (uint)*(byte *)(data_object_address + 6);\n        bit_set = bit_mask != 0;\n        if (bit_set) {\n          bit_mask = 1;\n        }\n        current_bit = (char)bit_mask;\n        if (!bit_set) {\n          current_bit = '\\0';\n        }\n        if (current_bit == '\\0') {\n          goto LAB_000036ee;\n        }\n        string_buffer = '\\0';\n      }\n      else {\nLAB_000036ee:\n        string_buffer = get_string_from_address((int)*(char *)(data_object_address + 7));\n      }\n      display_message(PTR_LAB_000037f0);\n      if (data_object_size < 2) {\n        display_message(PTR_s__000037f8);\n      }\n      else {\n        display_message(PTR_s___u__000037f4,current_byte);\n      }\n      if (string_buffer == '\\0') {\n        if (*(char *)(data_object_address + 7) == '\\0') {\n          display_message(PTR_LAB_00003800,(int)*(short *)(data_object_address + (uint)current_byte * 2));\n        }\n        else if ((*(char *)(data_object_address + 7) + 4 < 0 == SCARRY4((int)*(char *)(data_object_address + 7),4)) && (*(char *)(data_object_address + 7) < '\\0')) {\n          string_length = get_string_length(stack_buffer,(int)*(short *)(data_object_address + (uint)current_byte * 2),(int)*(char *)(data_object_address + 7));\n          stack_buffer[string_length] = 0;\n          display_message(PTR_LAB_00003804,stack_buffer);\n        }\n        else {\n          display_message(PTR_s__iE_i_00003808,(int)*(short *)(data_object_address + (uint)current_byte * 2),(int)*(char *)(data_object_address + 7));\n        }\n      }\n      else {\n        display_message(PTR_s__6d__c_000037fc,(int)*(short *)(data_object_address + (uint)current_byte * 2),string_buffer);\n      }\n      uVar1 = get_data_object_type(*(undefined *)(data_object_address + 6));\n      display_message(PTR_LAB_0000380c,uVar1);\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00003810",
                "FUN_00003e9e",
                "FUN_00004c84",
                "FUN_00003918"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003694",
            "calling": [
                "FUN_00002ecc",
                "FUN_0000305c"
            ],
            "imported": false,
            "current_name": "display_data_object_00003694"
        },
        "FUN_00002364": {
            "renaming": {
                "FUN_00002364": "check_and_set_value_00002364",
                "param_1": "value",
                "param_2": "data_ptr",
                "iVar1": "check_result",
                "uVar2": "return_value",
                "FUN_00002294": "check_value",
                "FUN_000022be": "set_value"
            },
            "code": "int check_and_set_value_00002364(int value, void* data_ptr)\n{\n  int check_result = check_value(value);\n  if (check_result == 0) {\n    set_value(data_ptr, value);\n    return 0;\n  }\n  else {\n    return -1;\n  }\n}",
            "called": [
                "FUN_00002294",
                "FUN_000022be"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002364",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": false,
            "current_name": "check_and_set_value_00002364"
        },
        "FUN_00001ad4": {
            "renaming": {
                "FUN_00001ad4": "set_bits_6_and_7_to_0_and_wait_until_bits_2_and_3_are_1_00001ad4",
                "DAT_00001b08": "data_pointer_1",
                "PTR_DAT_00001b0c": "pointer_to_data_pointer_2"
            },
            "code": "void set_bits_6_and_7_to_0_and_wait_until_bits_2_and_3_are_1_00001ad4(void)\n{\n  *DAT_00001b08 = *DAT_00001b08 & 0x3f;\n  do {\n  } while ((DAT_00001b08[6] & 0xc) != 0xc);\n  *PTR_DAT_00001b0c = 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ad4",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_bits_6_and_7_to_0_and_wait_until_bits_2_and_3_are_1_00001ad4"
        },
        "FUN_00001274": {
            "renaming": {
                "FUN_00001274": "initialize_system_00001274",
                "FUN_0000258c": "initialize_network",
                "FUN_00001c84": "initialize_database",
                "FUN_00002396": "initialize_user_interface",
                "*DAT_00001298": "*data_pointer"
            },
            "code": "void initialize_system_00001274(void) {\n  initialize_network();\n  *DAT_00001298 = *DAT_00001298 | 0x28;\n  initialize_database();\n  initialize_user_interface();\n  return;\n}",
            "called": [
                "FUN_00001c84",
                "FUN_0000258c",
                "FUN_00002396"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001274",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "initialize_system_00001274"
        },
        "FUN_00002e6c": {
            "renaming": {
                "FUN_00002e6c": "check_and_copy_data_00002e6c",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "size",
                "iVar1": "result",
                "FUN_00002d94": "check_data",
                "FUN_00002b10": "copy_data",
                "FUN_00002e48": "wait_for_data"
            },
            "code": "void check_and_copy_data_00002e6c(void* destination, void* source, size_t size)\n{\n  while(true) {\n    int result = check_data(source, size);\n    if (result == 0) {\n      copy_data(destination, source);\n    }\n    wait_for_data();\n  }\n}",
            "called": [
                "FUN_00002e48",
                "FUN_00002d94",
                "FUN_00002b10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e6c",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": false,
            "current_name": "check_and_copy_data_00002e6c"
        },
        "FUN_00003444": {
            "renaming": {
                "FUN_00003444": "get_time_error_00003444",
                "iVar1": "error_code",
                "auStack_2c": "time_info",
                "FUN_00002624": "get_time_info",
                "FUN_00004db8": "print_error_message",
                "PTR_s_rtc__error_getting_time_00003474": "PTR_s_rtc__error_getting_time_00003474",
                "FUN_00003378": "process_time_info"
            },
            "code": "bool get_time_error_00003444(void)\n{\n  int error_code;\n  undefined time_info [36];\n  error_code = get_time_info(time_info);\n  if (error_code != 0) {\n    print_error_message(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    process_time_info(time_info);\n  }\n  return error_code != 0;\n}",
            "called": [
                "FUN_00002624",
                "FUN_00004db8",
                "FUN_00003378"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003444",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "get_time_error_00003444"
        },
        "FUN_00003688": {
            "renaming": {
                "FUN_00003688": "execute_function_00003688",
                "FUN_00003658": "call_helper_function"
            },
            "code": "void execute_function_00003688(void)\n{\n  call_helper_function();\n  return;\n}",
            "called": [
                "FUN_00003658"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003688",
            "calling": [
                "FUN_00002e9c"
            ],
            "imported": false,
            "current_name": "execute_function_00003688"
        },
        "FUN_00001392": {
            "renaming": {
                "FUN_00001392": "set_flag_on_success_00001392",
                "param_1": "input1",
                "param_2": "input2",
                "puVar1": "flag_ptr",
                "*puVar1": "*flag_ptr",
                "FUN_00001360": "calculate_result"
            },
            "code": "void set_flag_on_success_00001392(int input1, char input2)\n{\n  int *flag_ptr;\n  flag_ptr = (int *)calculate_result(input1, input2);\n  *flag_ptr = 1;\n  return;\n}",
            "called": [
                "FUN_00001360"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001392",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "set_flag_on_success_00001392"
        },
        "FUN_00002910": {
            "renaming": {
                "FUN_00002910": "clearFlags_00002910",
                "DAT_00002944": "dataAddressGlobal",
                "PTR_DAT_00002948": "globalPtrDataAddress"
            },
            "code": "void clearFlags_00002910(void)\n{\n  int dataAddress = DAT_00002944;\n  *(uint *)(dataAddress + 0x1c) &= 0xfffffffb;\n  *(undefined4 *)(dataAddress + 8) = 0;\n  *(undefined4 *)PTR_DAT_00002948 = 0;\n  *(undefined4 *)(PTR_DAT_00002948 + 4) = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002910",
            "calling": [
                "FUN_000026c0"
            ],
            "imported": false,
            "current_name": "clearFlags_00002910"
        },
        "FUN_00004418": {
            "renaming": {
                "FUN_00004418": "get_next_byte_00004418",
                "uVar1": "next_byte",
                "ppbVar2": "packet_pointer",
                "pbVar3": "current_byte",
                "iVar4": "packet_header"
            },
            "code": "uint get_next_byte_00004418(void)\n{\n  uint next_byte;\n  byte **packet_pointer;\n  byte *current_byte;\n  int packet_header;\n  packet_header = *packet_header_ptr;\n  if (packet_header != 0 && *(int *)(packet_header + 0x18) == 0)\n  {\n    free_packet(packet_header);\n  }\n  packet_pointer = *(byte ***)(packet_header + 4);\n  if (packet_header != 0 && *(int *)(packet_header + 0x18) == 0)\n  {\n    free_packet(packet_header);\n  }\n  if (packet_pointer == (byte **)packet_data_start)\n  {\n    packet_pointer = *(byte ***)(packet_header + 4);\n  }\n  else if (packet_pointer == (byte **)packet_data_end)\n  {\n    packet_pointer = *(byte ***)(packet_header + 8);\n  }\n  else if (packet_pointer == (byte **)packet_data_middle)\n  {\n    packet_pointer = *(byte ***)(packet_header + 0xc);\n  }\n  if ((int)packet_pointer[0x19] >= 0 && (int)((uint)*(ushort *)(packet_pointer + 3)) >= 0)\n  {\n    do_nothing_000045e8(packet_pointer[0x16]);\n  }\n  current_byte = packet_pointer[1];\n  packet_pointer[1] = current_byte - 1;\n  if ((int)(current_byte - 1) < 0)\n  {\n    next_byte = read_packet(packet_header, packet_pointer);\n  }\n  else\n  {\n    current_byte = *packet_pointer;\n    *packet_pointer = current_byte + 1;\n    next_byte = (uint)*current_byte;\n  }\n  if ((int)packet_pointer[0x19] >= 0 && (int)((uint)*(ushort *)(packet_pointer + 3)) >= 0)\n  {\n    do_nothing_000045ec(packet_pointer[0x16]);\n  }\n  return next_byte;\n}",
            "called": [
                "FUN_000045ec",
                "FUN_000045e8",
                "FUN_000042a4",
                "FUN_00005e10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004418",
            "calling": [
                "FUN_00002d94"
            ],
            "imported": false,
            "current_name": "get_next_byte_00004418"
        },
        "FUN_0000258c": {
            "renaming": {
                "FUN_0000258c": "initialize_device_0000258c",
                "local_c": "counter",
                "FUN_00002538": "enable_device"
            },
            "code": "void initialize_device_0000258c(void)\n{\n  uint32_t counter;\n  *(uint32_t *)(DAT_000025ec + 8) = DAT_000025f0;\n  enable_device(0xfffffffe,1);\n  enable_device(0xfffffffb,1);\n  for (counter = 0; counter < 0x66; counter = counter + 1) {\n    enable_device((int)(char)counter,1);\n  }\n  *(uint32_t *)(DAT_000025ec + 0x10) = *(uint32_t *)(DAT_000025ec + 0x10) | 0x10;\n  *(uint32_t *)(DAT_000025ec + 0x14) = *(uint32_t *)(DAT_000025ec + 0x14) | 0x200;\n  return;\n}\n",
            "called": [
                "FUN_00002538"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000258c",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "initialize_device_0000258c"
        },
        "FUN_00002a00": {
            "renaming": {
                "FUN_00002a00": "print_param_1_on_screen_00002a00",
                "param_1": "input_param",
                "FUN_00004cb4": "print_to_screen"
            },
            "code": "void print_param_1_on_screen_00002a00(undefined4 input_param){\n  print_to_screen(input_param);\n  return;\n}",
            "called": [
                "FUN_00004cb4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a00",
            "calling": [
                "FUN_00002e48",
                "FUN_00002d94"
            ],
            "imported": false,
            "current_name": "print_param_1_on_screen_00002a00"
        },
        "FUN_000043a0": {
            "renaming": {
                "FUN_000043a0": "process_data_000043a0",
                "param_1": "data_size",
                "param_2": "data_processor",
                "piVar2": "current_data",
                "uVar4": "processed_data",
                "iVar5": "num_entries",
                "iVar3": "current_entry",
                "uVar1": "processed_entry"
            },
            "code": "uint process_data_000043a0(int data_size, code* data_processor) {\n  uint processed_data = 0;\n  int* current_data = (int*)(data_size + 0x48);\n  do {\n    int num_entries = current_data[1];\n    int current_entry = current_data[2];\n    while (num_entries-- > 0) {\n      ushort entry_type = *(ushort*)(current_entry + 0xc);\n      short entry_value = *(short*)(current_entry + 0xe);\n      if (entry_type > 1 && entry_value != -1) {\n        uint processed_entry = (*data_processor)(current_entry);\n        processed_data |= processed_entry;\n      }\n      current_entry += 0x68;\n    }\n    current_data = (int*)*current_data;\n  } while (current_data != (int*)0x0);\n  return processed_data;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043a0",
            "calling": [
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "process_data_000043a0"
        },
        "FUN_0000211c": {
            "renaming": {
                "FUN_0000211c": "process_data_0000211c",
                "local_40": "magic_number",
                "local_3c": "current_data_size",
                "local_38": "data_offset",
                "local_34": "data_value",
                "local_30": "data_type",
                "local_2c": "current_data",
                "local_28": "isr_stack_bottom",
                "local_24": "isr_stack_top",
                "local_20": "total_memory",
                "local_1a": "i",
                "local_18": "total_interrupts",
                "local_14": "current_data_offset",
                "PTR_s__pid_____21s____9sQ___pri___stac_00002250": "process_data_string_1",
                "PTR_DAT_0000224c": "process_data_data_1",
                "PTR_s_state_00002248": "process_data_state",
                "PTR_s______isr_stack______________6i___00002254": "process_data_string_2",
                "PTR_DAT_00002258": "data_array",
                "DAT_0000225c": "data_values",
                "PTR_s___3hi_____20s_____8s___1s____3i___00002260": "process_current_data_string",
                "PTR_s___5s___21s__13s_6s__6i___5i__0000226c": "print_summary_string",
                "PTR_DAT_00002264": "print_summary_data_1",
                "PTR_DAT_00002268": "print_summary_data_2"
            },
            "code": "void process_data_0000211c(void)\n{\n    uint32_t total_memory = 0;\n    uint32_t total_interrupts = 0;\n    uint16_t magic_number = 0x515f;\n    uint32_t isr_stack_size = 0x200;\n    uint32_t *current_data = NULL;\n    uint32_t current_data_index = 0;\n    uint32_t current_data_size = 0;\n    uint32_t current_data_offset = 0;\n\n    init_process_data_0000211c();\n\n    total_memory += get_total_memory();\n\n    uint32_t *stack_top = get_isr_stack_top();\n    uint32_t *stack_bottom = get_isr_stack_bottom();\n    uint32_t isr_stack_used = (uint32_t)(stack_top - stack_bottom);\n    total_interrupts += isr_stack_used;\n\n    for (uint16_t i = 1; i < 0x21; i++) {\n        current_data = *(uint32_t **)(PTR_DAT_00002258 + i * 4);\n        if (current_data != NULL) {\n            uint8_t data_type = *(uint8_t *)(current_data + 1);\n            uint32_t data_value = *(uint32_t *)(DAT_0000225c + data_type * 4);\n            uint32_t data_offset = (uint32_t)&magic_number + (uint32_t)(8 < data_type);\n            current_data_size = current_data[0xb];\n            total_memory += current_data_size;\n            uint32_t current_data_start = current_data_size - get_data_size(current_data[9]);\n            current_data_offset += current_data_start;\n            total_memory += current_data_start;\n            total_memory += current_data_offset;\n            total_interrupts += current_data[0xb] - get_data_size(current_data[9]);\n            process_current_data(current_data[10], current_data[9], data_value, data_offset, *(uint8_t *)((uint32_t)current_data + 5), current_data[0xb], current_data_offset, current_data[9], *current_data);\n        }\n    }\n\n    print_summary(total_memory, total_interrupts);\n}\n",
            "called": [
                "FUN_0000091c",
                "FUN_00000900",
                "FUN_000010a0",
                "FUN_00004c84",
                "FUN_000008b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000211c",
            "calling": [
                "FUN_00000f04",
                "FUN_00002eb4"
            ],
            "imported": false,
            "current_name": "process_data_0000211c"
        },
        "FUN_0000562c": {
            "renaming": {
                "FUN_0000562c": "find_key_value_pair_index_0000562c",
                "param_1": "key",
                "param_2": "string",
                "param_3": "index_array",
                "cVar1": "current_char",
                "ppiVar2": "array_of_index_arrays",
                "piVar3": "current_index_array",
                "iVar4": "current_index_value",
                "pcVar5": "current_char_pointer",
                "piVar6": "current_index",
                "iVar7": "string_index"
            },
            "code": "int find_key_value_pair_index_0000562c(undefined4 key,char *string,int *index_array)\n{\n  char current_char;\n  int **array_of_index_arrays;\n  int *current_index_array;\n  int string_index;\n  char *current_char_pointer;\n  int *current_index;\n  int current_index_value;\n  \n  initialize_key_value_pair_index_array();\n  array_of_index_arrays = DAT_0000569c;\n  current_char_pointer = string;\n  if (*DAT_0000569c != (int *)0x0) {\n    do {\n      current_char = *current_char_pointer;\n      if (current_char == \"\\0\") {\n        string_index = (int)current_char_pointer - (int)string;\n        current_index_array = *DAT_0000569c;\n        while( true ) {\n          current_index = current_index_array;\n          if (*current_index == 0) break;\n          current_index_value = find_key_value_pair(current_index,string,string_index);\n          current_index_array = current_index + 1;\n          if ((current_index_value == 0) && (current_index_value = *current_index, *(char *)(current_index_value + string_index) == \"=\")) {\n            *index_array = (int)current_index - (int)*array_of_index_arrays >> 2;\n            return current_index_value + string_index + 1;\n          }\n        }\n        break;\n      }\n      current_char_pointer = current_char_pointer + 1;\n    } while (current_char != \"=\");\n  }\n  return 0;\n}",
            "called": [
                "FUN_00005ff8",
                "FUN_00004e66",
                "FUN_00005fec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000562c",
            "calling": [
                "FUN_000056a0"
            ],
            "imported": false,
            "current_name": "find_key_value_pair_index_0000562c"
        },
        "FUN_000020b8": {
            "renaming": {
                "FUN_000020b8": "initialize_data_000020b8",
                "FUN_00002028": "initialize_buffer",
                "DAT_000020c8": "data_buffer"
            },
            "code": "void initialize_data_000020b8(void)\n{\n  initialize_buffer(DAT_000020c8, 0);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020b8",
            "calling": [],
            "imported": false,
            "current_name": "initialize_data_000020b8"
        },
        "FUN_00002a18": {
            "renaming": {
                "FUN_00002a18": "find_value_in_array_00002a18",
                "param_1": "array",
                "param_2": "value_to_find",
                "local_10": "num_arrays",
                "local_c": "current_array",
                "local_18": "arrays",
                "iVar1": "result"
            },
            "code": "int find_value_in_array_00002a18(int *array, int value_to_find)\n{\n  int index = 0;\n  int *current_array;\n  int *arrays[] = {array, PTR_PTR_s_reboot_00002a84};\n  uint num_arrays = sizeof(arrays) / sizeof(arrays[0]);\n  \n  for (int i = 0; i < num_arrays; i++) {\n    current_array = arrays[i];\n    if (current_array != NULL) {\n      for (; *current_array != 0; current_array += 3) {\n        int result = FUN_00004e52(*current_array, value_to_find);\n        if (result == 0) {\n          return current_array[2];\n        }\n      }\n    }\n    index++;\n  }\n  return 0;\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a18",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "find_value_in_array_00002a18"
        },
        "FUN_000054a8": {
            "renaming": {
                "FUN_000054a8": "calculateValue_000054a8",
                "param_1": "result",
                "param_2": "input",
                "uVar1": "highBits",
                "uVar2": "highBits",
                "uVar3": "value",
                "uVar4": "value",
                "iVar5": "iVar"
            },
            "code": "uint calculateValue_000054a8(uint *result, uint *input) {\n  ushort highBits = *(ushort *)(input + 3);\n  uint value = (uint)highBits;\n  uint returnValue;\n  uint iVar;\n  if (*DAT_00005574 != 0 && *(int *)(*DAT_00005574 + 0x18) == 0) {\n    FUN_000042a4(*DAT_00005574);\n  }\n  if (input == (uint *)PTR_DAT_00005578) {\n    input = *(uint **)(*DAT_00005574 + 4);\n  }\n  else if (input == (uint *)PTR_DAT_0000557c) {\n    input = *(uint **)(*DAT_00005574 + 8);\n  }\n  else if (input == (uint *)PTR_DAT_00005580) {\n    input = *(uint **)(*DAT_00005574 + 0xc);\n  }\n  if (-1 < (int)(highBits << 0x1c)) {\n    if (-1 < (int)(highBits << 0x1b)) {\n      *result = 9;\n      returnValue = 0;\n    }\n    else if ((int)(highBits << 0x1d) < 0) {\n      if ((uint *)input[0xd] != (uint *)0x0) {\n        if ((uint *)input[0xd] != input + 0x11) {\n          FUN_00004b34(result);\n        }\n        input[0xd] = 0;\n      }\n      *(ushort *)(input + 3) = *(ushort *)(input + 3) & 0xffdb;\n      input[1] = 0;\n      *input = input[4];\n      returnValue = 0;\n    }\n    else {\n      *(ushort *)(input + 3) = *(ushort *)(input + 3) | 8;\n      returnValue = 0;\n    }\n  }\n  else {\n    if (input[4] == 0 && (*(ushort *)(input + 3) & 0x280) != 0x200) {\n      FUN_00005700(result, input);\n    }\n    if ((highBits & 1) == 0) {\n      if (-1 < (int)(highBits << 0x1e)) {\n        iVar = input[5];\n      }\n      input[2] = iVar;\n    }\n    else {\n      input[2] = 0;\n      input[6] = -input[5];\n    }\n    if (input[4] != 0) {\n      returnValue = 0;\n    }\n    else if ((highBits & 0x80) == 0) {\n      returnValue = highBits & 0x80;\n    }\n    else {\n      *(ushort *)(input + 3) = highBits | 0x40;\n      returnValue = 0xffffffff;\n    }\n  }\n  return returnValue;\n}",
            "called": [
                "FUN_00004b34",
                "FUN_000042a4",
                "FUN_00005700"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000054a8",
            "calling": [
                "FUN_00004db8",
                "FUN_000057f8",
                "FUN_00005404"
            ],
            "imported": false,
            "current_name": "calculateValue_000054a8"
        },
        "FUN_000007dc": {
            "renaming": {
                "FUN_000007dc": "allocate_memory_000007dc",
                "param_1": "size",
                "param_2": "param_2",
                "param_3": "param_3",
                "param_4": "param_4",
                "uVar1": "aligned_size",
                "local_14": "i",
                "local_10": "i",
                "local_c": "allocated_memory"
            },
            "code": "int* allocate_memory_000007dc(uint32_t size, int param_2, int param_3, int param_4)\n{\n  uint32_t aligned_size = (size + param_3) & 0xfffffffc;\n  int* allocated_memory = (int*)(aligned_size - 4);\n  *allocated_memory = 0x77777777;\n  if (((uint32_t)allocated_memory & 7) != 0) {\n    allocated_memory = (int*)(aligned_size - 8);\n    *allocated_memory = 0x88888888;\n  }\n  allocated_memory[-1] = 0x1000000;\n  allocated_memory[-2] = param_2;\n  allocated_memory[-3] = DAT_000008b4;\n  allocated_memory = allocated_memory - 4;\n  *allocated_memory = 0;\n  for (int i = 3; i > 0; i--) {\n    allocated_memory--;\n    *allocated_memory = i;\n  }\n  allocated_memory--;\n  *allocated_memory = param_4;\n  for (int i = 0xb; i > 3; i--) {\n    allocated_memory--;\n    *allocated_memory = i;\n  }\n  allocated_memory[-1] = -3;\n  return allocated_memory - 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000007dc",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "allocate_memory_000007dc"
        },
        "FUN_00001710": {
            "renaming": {
                "FUN_00001710": "clear_buffer_and_return_00001710",
                "param_1": "buffer",
                "param_2": "size",
                "puVar1": "buffer_pointer",
                "*puVar1": "memset(buffer_pointer, 0, size)"
            },
            "code": "void clear_buffer_and_return_00001710(void *buffer, size_t size) {\n  char *buffer_pointer = (char *)buffer;\n  memset(buffer_pointer, 0, size);\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001710",
            "calling": [
                "FUN_0000182c",
                "FUN_000019c0",
                "FUN_00001a60",
                "FUN_00001734",
                "FUN_00001bb8",
                "FUN_000018bc",
                "FUN_00001778",
                "FUN_00001960"
            ],
            "imported": false,
            "current_name": "clear_buffer_and_return_00001710"
        },
        "FUN_000045ec": {
            "renaming": {
                "FUN_000045ec": "do_nothing_000045ec"
            },
            "code": "\nvoid do_nothing_000045ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ec",
            "calling": [
                "FUN_00004280",
                "FUN_00005ff8",
                "FUN_00004158",
                "FUN_00004418",
                "FUN_00004db8",
                "FUN_000057f8",
                "FUN_0000579c",
                "FUN_000042a4",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ec"
        },
        "FUN_00001034": {
            "renaming": {
                "FUN_00001034": "find_and_replace_00001034",
                "param_1": "list",
                "param_2": "list_size",
                "local_1c": "current_node",
                "PTR_s_FAILED_ASSERTION__0000109c": "FAILED_ASSERTION_MSG"
            },
            "code": "void find_and_replace_00001034(int **list, int list_size) {\n  int **current_node;\n  if (list_size > 8) {\n    report_error(3, PTR_s_FAILED_ASSERTION__0000109c);\n  }\n  for (current_node = list; (*current_node != NULL && (get_node_priority(*current_node) <= list_size)); current_node = (int **)*current_node) {\n  }\n  *(int **)(list_size + 8) = *current_node;\n  *current_node = (int *)(int **)(list_size + 8);\n  return;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001034",
            "calling": [
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "find_and_replace_00001034"
        },
        "FUN_00006964": {
            "renaming": {
                "FUN_00006964": "calculate_result_00006964",
                "param_1": "current_result",
                "param_2": "array_ptr",
                "iVar1": "array_index"
            },
            "code": "int calculate_result_00006964(int current_result, int* array_ptr){\n  int array_index = current_result - 4;\n  if (current_result < 0) {\n    array_index += *(array_ptr + array_index);\n  }\n  return array_index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006964",
            "calling": [
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "calculate_result_00006964"
        },
        "FUN_0000182c": {
            "renaming": {
                "FUN_0000182c": "set_byte_to_d0_and_call_two_functions_0000182c",
                "DAT_000018b4": "data_ptr_1",
                "DAT_000018b8": "data_ptr_2",
                "PTR_000018b8": "ptr_to_data_ptr_2",
                "set_bit_at_index_in_byte_and_call_function": "set_bit_and_call_function",
                "byte": "byte_type"
            },
            "code": "void set_byte_to_d0_and_call_two_functions_0000182c(void)\n{\n  byte* ptr = (byte *)(DAT_000018b4 + 8);\n  *ptr = *ptr & 0xd0;\n  FUN_000016ec(PTR_000018b8, 0);\n  set_bit_at_index_in_byte_and_call_function(DAT_000018b4, 1);\n  set_bit_at_index_in_byte_and_call_function(DAT_000018b4, 0);\n  return;\n}",
            "called": [
                "FUN_00001710",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000182c",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "set_byte_to_d0_and_call_two_functions_0000182c"
        },
        "FUN_00004db8": {
            "renaming": {
                "FUN_00004db8": "process_input_00004db8",
                "param_1": "input_len",
                "cVar1": "current_char",
                "iVar2": "result",
                "iVar3": "data_struct_ptr",
                "pcVar4": "char_ptr_1",
                "ppcVar5": "char_ptr_array_1",
                "uVar6": "result",
                "pcVar7": "char_ptr_2",
                "FUN_000042a4": "initialize_data_struct",
                "PTR_DAT_00004dac": "data_struct_ptr_consts[0]",
                "PTR_DAT_00004db0": "data_struct_ptr_consts[1]",
                "PTR_DAT_00004db4": "data_struct_ptr_consts[2]",
                "do_nothing_000045e8": "do_nothing",
                "FUN_000054a8": "write_to_output",
                "FUN_00005404": "write_to_output",
                "char_ptr_2_len": "char_ptr_2_length",
                "char_ptr_3": "char_ptr_3_end"
            },
            "code": "int process_input_00004db8(int input_len) {\n  char current_char;\n  int data_struct_ptr;\n  int result;\n  char *char_ptr_1;\n  char **char_ptr_array_1;\n  int char_ptr_array_1_len;\n  char *char_ptr_2;\n  int char_ptr_2_len;\n  char *char_ptr_3;\n  int char_ptr_3_len;\n\n  data_struct_ptr = *data_struct_ptr_ptr;\n  if ((data_struct_ptr != 0) && (*(int *)(data_struct_ptr + 0x18) == 0)) {\n    initialize_data_struct();\n  }\n\n  char_ptr_array_1 = *(char ***)(data_struct_ptr + 8);\n  if (*(int *)(data_struct_ptr + 0x18) == 0) {\n    initialize_data_struct(data_struct_ptr);\n  }\n\n  if (char_ptr_array_1 == PTR_DAT_00004dac) {\n    char_ptr_array_1 = *(char ***)(data_struct_ptr + 4);\n  }\n  else if (char_ptr_array_1 == PTR_DAT_00004db0) {\n    char_ptr_array_1 = *(char ***)(data_struct_ptr + 8);\n  }\n  else if (char_ptr_array_1 == PTR_DAT_00004db4) {\n    char_ptr_array_1 = *(char ***)(data_struct_ptr + 0xc);\n  }\n\n  if ((-1 < (int)char_ptr_array_1[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(char_ptr_array_1 + 3) << 0x16))) {\n    do_nothing(char_ptr_array_1[0x16]);\n  }\n\n  result = process_input_00004db8_helper(data_struct_ptr, char_ptr_array_1, input_len);\n\n  if ((-1 < (int)char_ptr_array_1[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(char_ptr_array_1 + 3) << 0x16))) {\n    do_nothing(char_ptr_array_1[0x16]);\n  }\n  return result;\n}\n\nint process_input_00004db8_helper(int data_struct_ptr, char **char_ptr_array_1, int input_len) {\n  char current_char;\n  int result;\n  char *char_ptr_1;\n  char *char_ptr_2;\n  char *char_ptr_3;\n\n  char_ptr_1 = *char_ptr_array_1;\n  char_ptr_2 = char_ptr_array_1[2];\n  char_ptr_2_len = char_ptr_array_1[6];\n\n  while(input_len > 0) {\n    current_char = *(char_ptr_1++);\n    char_ptr_3 = char_ptr_2 - 1;\n    char_ptr_array_1[2] = char_ptr_3;\n\n    if (current_char == '\\0') {\n      if (-1 < (int)char_ptr_3) {\n        char_ptr_1 = *char_ptr_array_1;\n        *char_ptr_array_1 = char_ptr_1 + 1;\n        *char_ptr_1 = '\\n';\n        result = 0;\n        goto end;\n      }\n      else {\n        result = write_to_output(data_struct_ptr, '\\n', char_ptr_array_1);\n        if (result == -1) {\n          result = -1;\n          goto end;\n        }\n        goto loop_end;\n      }\n    }\n    else {\n      if (((int)char_ptr_3 < 0) && (((int)char_ptr_3 < char_ptr_2_len || (current_char == '\\n')))) {\n        char_ptr_2 = *char_ptr_array_1;\n        *char_ptr_array_1 = char_ptr_2 + 1;\n        *char_ptr_2 = current_char;\n      }\n      else {\n        result = write_to_output(data_struct_ptr, current_char, char_ptr_array_1);\n        if (result == -1) {\n          result = -1;\n          goto end;\n        }\n      }\n    }\n  }\n  result = 0;\n  goto end;\n\nloop_end:\n  input_len--;\n  if (input_len == 0) {\n    result = 0;\n    goto end;\n  }\n  goto loop_start;\n\nend:\n  return result;\n}\n",
            "called": [
                "FUN_000045ec",
                "FUN_000054a8",
                "FUN_00005404",
                "FUN_000045e8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004db8",
            "calling": [
                "FUN_000034c0",
                "FUN_0000305c",
                "FUN_000023a4",
                "FUN_00003444",
                "FUN_00003694",
                "FUN_000031e0",
                "FUN_00003478",
                "FUN_00002fe0",
                "FUN_000033c0",
                "FUN_00002a88",
                "FUN_00002f30",
                "FUN_00002f74",
                "FUN_000033f4",
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "process_input_00004db8"
        },
        "FUN_000022f0": {
            "renaming": {
                "FUN_000022f0": "increment_value_at_offset_000022f0",
                "param_1": "base_address",
                "uVar1": "offset"
            },
            "code": "undefined increment_value_at_offset_000022f0(int *base_address)\n{\n  uint offset = base_address[2];\n  base_address[2] = offset + 1;\n  return *(undefined *)((offset & base_address[1] - 1U) + *base_address);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022f0",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": false,
            "current_name": "increment_value_at_offset_000022f0"
        },
        "FUN_00001c84": {
            "renaming": {
                "FUN_00001c84": "initialize_system_00001c84",
                "FUN_00000cd0": "get_initial_value",
                "FUN_00001bb8": "set_system_configuration",
                "FUN_0000182c": "configure_system",
                "FUN_000017dc": "enable_interrupts",
                "FUN_00001b10": "set_system_mode",
                "FUN_00000d0c": "finalize_initialization",
                "DAT_00001ce8": "system_data"
            },
            "code": "void initialize_system_00001c84(void)\n{\n  undefined4 function_result = get_initial_value();\n  set_system_configuration();\n  *(undefined4 *)(DAT_00001ce8 + 0x1044) = 0x220000;\n  DAT_00001ce8[0xc] = 0;\n  *DAT_00001ce8 = *DAT_00001ce8 & 199 | 0x38;\n  DAT_00001ce8[4] = 0x13;\n  DAT_00001ce8[5] = 0;\n  configure_system();\n  enable_interrupts();\n  set_system_mode(7);\n  finalize_initialization(function_result);\n  return;\n}",
            "called": [
                "FUN_00000d0c",
                "FUN_0000182c",
                "FUN_00001b10",
                "FUN_00000cd0",
                "FUN_000017dc",
                "FUN_00001bb8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001c84",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "initialize_system_00001c84"
        },
        "FUN_000068f0": {
            "renaming": {
                "FUN_000068f0": "allocate_memory_000068f0",
                "param_1": "address",
                "param_2": "memory",
                "iVar1": "current_address",
                "iVar2": "block_size"
            },
            "code": "int allocate_memory_000068f0(int address, int *memory){\n  int current_address, new_address;\n  \n  if ((int *)memory[13] == memory + 17) {\n    current_address = allocate_block(address, 1024);\n    if (current_address != 0) {\n      memory[14] = 1024;\n      memory[13] = current_address;\n      *(unsigned char *)(current_address + 1023) = *(unsigned char *)((int)memory + 70);\n      *(unsigned char *)(current_address + 1022) = *(unsigned char *)((int)memory + 69);\n      *(int *)(current_address + 1021) = *(int *)(memory + 17);\n      *memory = current_address + 1021;\n      return 0;\n    }\n  }\n  else {\n    int block_size = memory[14];\n    new_address = allocate_block((int *)memory[13], block_size << 1);\n    if (new_address != 0) {\n      copy_memory(new_address + block_size, new_address, block_size);\n      memory[13] = new_address;\n      memory[14] = block_size << 1;\n      *memory = new_address + block_size;\n      return 0;\n    }\n  }\n  return -1;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_000060b0",
                "FUN_000060cc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000068f0",
            "calling": [],
            "imported": false,
            "current_name": "allocate_memory_000068f0"
        }
    },
    "used_tokens": 217364,
    "layers": [
        [
            "FUN_000026c0",
            "FUN_00004bd0",
            "FUN_00000794",
            "FUN_000064bc",
            "FUN_00002970",
            "FUN_00000dc0",
            "FUN_00000d0c",
            "FUN_00003d94",
            "FUN_0000579c",
            "FUN_000015d0",
            "FUN_00005e68",
            "FUN_00000dcc",
            "FUN_0000285c",
            "FUN_00000e58",
            "FUN_00001778",
            "FUN_000026d8",
            "FUN_00000566",
            "FUN_00001d08",
            "FUN_000031fc",
            "FUN_000016ec",
            "FUN_00005584",
            "FUN_00004248",
            "FUN_00001da2",
            "FUN_00001ec4",
            "FUN_00002744",
            "FUN_00002624",
            "FUN_00001e0c",
            "FUN_000041d0",
            "FUN_0000459c",
            "FUN_000014c4",
            "FUN_00004b34",
            "FUN_000004f2",
            "FUN_00004e66",
            "FUN_00005ecc",
            "FUN_0000129c",
            "FUN_00001628",
            "FUN_00001748",
            "FUN_0000294c",
            "FUN_00005790",
            "FUN_00000534",
            "FUN_000017dc",
            "FUN_00000410",
            "FUN_000005ca",
            "FUN_00005ff8",
            "FUN_00002714",
            "FUN_000020e0",
            "FUN_00005fec",
            "FUN_00004f84",
            "FUN_000028f0",
            "FUN_00004f98",
            "FUN_00004dee",
            "FUN_00000fec",
            "FUN_00000428",
            "FUN_000039e8",
            "FUN_00000e38",
            "FUN_00002294",
            "FUN_00003e9e",
            "FUN_00003378",
            "FUN_00006768",
            "FUN_00000db0",
            "FUN_00002600",
            "FUN_00003810",
            "FUN_00000ed8",
            "FUN_000031e0",
            "FUN_000020f4",
            "FUN_0000687c",
            "FUN_00005edc",
            "FUN_00001eea",
            "FUN_000023a4",
            "FUN_0000240c",
            "FUN_00004280",
            "FUN_00001448",
            "FUN_00001688",
            "FUN_00004042",
            "FUN_00000cf0",
            "FUN_00000f8c",
            "FUN_00002894",
            "FUN_00004158",
            "FUN_00002654",
            "FUN_00002538",
            "FUN_00004c84",
            "FUN_0000305c",
            "FUN_000012b4",
            "FUN_0000058e",
            "FUN_000025f4",
            "FUN_00001ddc",
            "FUN_00002ecc",
            "FUN_00000d76",
            "FUN_000057a8",
            "FUN_00001696",
            "FUN_000008b8",
            "FUN_000024bc",
            "FUN_00000490",
            "FUN_0000091c",
            "FUN_00001f80",
            "FUN_00000e64",
            "FUN_000026e4",
            "FUN_00000d44",
            "FUN_00000698",
            "FUN_00000cd0",
            "FUN_00000cc0",
            "FUN_00002994",
            "FUN_00000d2a",
            "FUN_00001ff6",
            "FUN_000013b8",
            "FUN_00002a88",
            "FUN_00002f30",
            "FUN_00001e44",
            "FUN_00001318",
            "FUN_00000900",
            "FUN_00004274",
            "FUN_00002fe0",
            "FUN_00001dc0",
            "FUN_00000df4",
            "FUN_00002eb4",
            "FUN_0000328c",
            "FUN_000041f4",
            "FUN_0000316c",
            "FUN_000026f0",
            "FUN_000057d2",
            "FUN_000056b8",
            "FUN_00001a18",
            "FUN_00000d9c",
            "FUN_00003ff4",
            "FUN_00001d5e",
            "FUN_0000191c",
            "FUN_000050f4",
            "FUN_00005a58",
            "FUN_000056b0",
            "FUN_00003d24",
            "FUN_000060cc",
            "FUN_00003dc4",
            "FUN_000022be",
            "FUN_00002108",
            "FUN_00001d80",
            "FUN_000033c0",
            "FUN_00002b10",
            "FUN_00001b10",
            "FUN_000023c8",
            "FUN_00002e48",
            "FUN_00000930",
            "FUN_00001348",
            "FUN_00001d3a",
            "FUN_00002434",
            "FUN_00005700",
            "FUN_00002798",
            "FUN_00003524",
            "FUN_00001bb8",
            "FUN_0000428c",
            "FUN_0000404c",
            "FUN_00002f74",
            "FUN_000010a0",
            "FUN_000012e2",
            "FUN_000056a0",
            "FUN_0000231c",
            "FUN_00002690",
            "FUN_00006010",
            "FUN_00001cf0",
            "FUN_00003ec4",
            "FUN_00001360",
            "FUN_00004622",
            "FUN_0000093c",
            "FUN_00003658",
            "FUN_000019c0",
            "FUN_000060b0",
            "FUN_000023d0",
            "FUN_00000a30",
            "FUN_000034c0",
            "FUN_000050e8",
            "FUN_000042a4",
            "FUN_00000514",
            "FUN_00002e9c",
            "FUN_00001960",
            "FUN_00001a3c",
            "FUN_000045ee",
            "FUN_00005404",
            "FUN_00006974",
            "FUN_00004314",
            "FUN_00004dc8",
            "FUN_00005fd8",
            "FUN_00005e10",
            "FUN_000033f4",
            "FUN_0000443c",
            "FUN_000027b0",
            "FUN_00005ebc",
            "FUN_00006192",
            "FUN_00001734",
            "FUN_00000e14",
            "FUN_0000281c",
            "FUN_00002270",
            "FUN_00005780",
            "FUN_000020cc",
            "FUN_00002396",
            "FUN_00004cb4",
            "FUN_00003478",
            "FUN_00002028",
            "FUN_000016c8",
            "FUN_00001a60",
            "FUN_0000099c",
            "FUN_00002d94",
            "FUN_00003918",
            "FUN_00003d64",
            "FUN_00004e52",
            "FUN_000010d4",
            "FUN_00000738",
            "FUN_00003e58",
            "FUN_00004e26",
            "FUN_000018bc",
            "FUN_00000f04",
            "FUN_00000610",
            "FUN_00003694",
            "FUN_00002364",
            "FUN_00001ad4",
            "FUN_00001274",
            "FUN_00002e6c",
            "FUN_00003444",
            "FUN_00003688",
            "FUN_00001392",
            "FUN_00002910",
            "FUN_00004418",
            "FUN_0000258c",
            "FUN_00002a00",
            "FUN_000043a0",
            "FUN_0000211c",
            "FUN_0000562c",
            "FUN_000020b8",
            "FUN_00002a18",
            "FUN_000054a8",
            "FUN_000007dc",
            "FUN_00001710",
            "FUN_00001034",
            "FUN_00006964",
            "FUN_0000182c",
            "FUN_00004db8",
            "FUN_000022f0",
            "FUN_00001c84",
            "FUN_000068f0"
        ],
        [
            "FUN_00005100",
            "FUN_00005b34",
            "FUN_0000656c",
            "FUN_00004634",
            "FUN_000047e4",
            "FUN_000061cc",
            "FUN_00006a14",
            "FUN_000057f8"
        ]
    ],
    "locked_functions": []
}