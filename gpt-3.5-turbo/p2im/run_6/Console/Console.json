{
    "functions": {
        "FUN_000026c0": {
            "renaming": {
                "FUN_000026c0": "clear_flags_and_set_ptr_to_null_000026c0",
                "PTR_DAT_000026d4": "pointer_to_data",
                "clear_flags_00002910": "clear_flags"
            },
            "code": "void clear_flags_and_set_ptr_to_null_000026c0(void)\n{\n  clear_flags();\n  *(undefined4 *)PTR_DAT_000026d4 = 0;\n  return;\n}",
            "called": [
                "FUN_00002910"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "clear_flags_and_set_ptr_to_null_000026c0"
        },
        "FUN_00004bd0": {
            "renaming": {
                "FUN_00004bd0": "allocate_memory_00004bd0",
                "param_1": "size_ptr",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "puVar1": "current_ptr",
                "uVar2": "result",
                "puVar3": "previous_ptr",
                "iVar4": "remaining_size",
                "uVar5": "remaining_size",
                "puVar6": "current_ptr",
                "uVar7": "aligned_size"
            },
            "code": "uint allocate_memory_00004bd0(uint *size_ptr, uint size, uint arg3, uint arg4)\n{\n  uint *current_ptr;\n  uint aligned_size;\n  uint remaining_size;\n  uint *previous_ptr;\n  uint result;\n  \n  aligned_size = (size + 3) & 0xfffffffc;\n  aligned_size += 8;\n  if (aligned_size < 0xc) {\n    aligned_size = 0xc;\n  }\n  if ((int)aligned_size < 0 || aligned_size < size) {\n    *size_ptr = 0xc;\n    do_nothing_with_pointer_0000579c(size_ptr);\n    result = 0;\n  }\n  else {\n    do_nothing_with_pointer_00005790();\n    current_ptr = *(uint **)PTR_DAT_00004c7c;\n    previous_ptr = *(uint **)PTR_DAT_00004c7c;\n    while (current_ptr != (uint *)0x0) {\n      remaining_size = *current_ptr - aligned_size;\n      if ((int)remaining_size >= -1) {\n        if (remaining_size > 0xb) {\n          *current_ptr = remaining_size;\n          current_ptr = (uint *)((int)current_ptr + remaining_size);\n          goto LAB_00004c34;\n        }\n        result = current_ptr[1];\n        if (previous_ptr == current_ptr) {\n          *(uint **)PTR_DAT_00004c7c = (uint *)result;\n        }\n        if (previous_ptr != current_ptr) {\n          previous_ptr[1] = result;\n        }\n        goto LAB_00004c42;\n      }\n      previous_ptr = current_ptr;\n      current_ptr = (uint *)current_ptr[1];\n    }\n    if (*(int *)PTR_DAT_00004c80 == 0) {\n      result = check_and_update_param_00000428(size_ptr, 0, previous_ptr, 0, arg4);\n      *(uint *)PTR_DAT_00004c80 = result;\n    }\n    current_ptr = (uint *)check_and_update_param_00000428(size_ptr, aligned_size);\n    if (current_ptr != (uint *)0xffffffff && (current_ptr == (uint *)current_ptr[1] || check_and_update_param_00000428(size_ptr, (int)current_ptr + 3U & 0xfffffffc - (int)current_ptr) != -1)) {\n      *current_ptr = aligned_size;\n      do_nothing_with_pointer_0000579c(size_ptr);\n      result = (int)current_ptr + 0xbU & 0xfffffff8;\n      remaining_size = result - (int)(current_ptr + 1);\n      if (remaining_size != 0) {\n        *(uint *)((int)current_ptr + remaining_size) = (int)(current_ptr + 1) - result;\n      }\n    }\n    else {\n      *size_ptr = 0xc;\n      do_nothing_with_pointer_0000579c(size_ptr);\n      result = 0;\n    }\n  }\n  return result;\n}\n",
            "called": [
                "FUN_0000579c",
                "FUN_00005790",
                "FUN_00000428"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004bd0",
            "calling": [
                "FUN_000068f0",
                "FUN_00005700",
                "FUN_00004248",
                "FUN_00005100",
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "allocate_memory_00004bd0"
        },
        "FUN_00000794": {
            "renaming": {
                "FUN_00000794": "get_updated_stack_pointer_00000794",
                "extraout_r1": "interrupt_enabled",
                "iVar1": "stack_pointer_offset",
                "puVar2": "linked_list_head",
                "uVar3": "aligned_stack_pointer",
                "piStack_14": "stack_pointer",
                "iStack_18": "i",
                "iStack_1c": "i"
            },
            "code": "int * get_updated_stack_pointer_00000794(void)\n{\n  int interrupt_enabled;\n  int stack_pointer_offset;\n  undefined4 *linked_list_head;\n  uint aligned_stack_pointer;\n  int *stack_pointer;\n  int *stack_pointer_copy;\n  int *stack_pointer_copy_start;\n  int i;\n\n  interrupt_enabled = check_interrupt_enabled_00000cd0();\n  *(undefined4 *)(iRam000007d0 + *psRam000007cc * 4) = 0;\n  *piRam000007d4 = *piRam000007d4 - 1;\n  update_linked_list_00000698(*puRam000007d8,0);\n  linked_list_head = puRam000007d8;\n  stack_pointer_offset = 0;\n  *puRam000007d8 = 0;\n  run_interrupt_handler_00000930();\n  aligned_stack_pointer = (int)linked_list_head + stack_pointer_offset & 0xfffffffc;\n  stack_pointer = (int *)(aligned_stack_pointer - 4);\n  *stack_pointer = 0x77777777;\n  if (((uint)stack_pointer & 7) != 0) {\n    stack_pointer = (int *)(aligned_stack_pointer - 8);\n    *stack_pointer = 0x88888888;\n  }\n  stack_pointer[-1] = 0x1000000;\n  stack_pointer[-2] = stack_pointer_offset << 0xd;\n  stack_pointer[-3] = DAT_000008b4;\n  stack_pointer_copy_start = stack_pointer - 4;\n  *stack_pointer_copy_start = 0;\n  for (i = 3; i > 0; i--) {\n    stack_pointer_copy_start--;\n    *stack_pointer_copy_start = i;\n  }\n  stack_pointer_copy = stack_pointer_copy_start - 1;\n  *stack_pointer_copy = interrupt_enabled;\n  for (i = 0xb; i > 3; i--) {\n    stack_pointer_copy--;\n    *stack_pointer_copy = i;\n  }\n  stack_pointer_copy[-1] = -3;\n  return stack_pointer_copy - 1;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000930",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000794",
            "calling": [],
            "imported": false,
            "current_name": "get_updated_stack_pointer_00000794"
        },
        "FUN_000064bc": {
            "renaming": {
                "FUN_000064bc": "process_data_000064bc",
                "param_1": "data_size",
                "param_2": "data",
                "param_3": "data_buffer",
                "param_4": "callback_result",
                "puVar1": "buffer_ptr",
                "iVar2": "callback_status",
                "iVar7": "processed_data_count",
                "ppbVar4": "data_buffer_ptr",
                "pbVar5": "next_data",
                "unaff_r6": "temp_buffer_ptr",
                "pbVar6": "buffer_ptr",
                "uVar3": "buffer_remaining_size"
            },
            "code": "int process_data_000064bc(uint32_t data_size, uint32_t *data, uint8_t **data_buffer, uint32_t *callback_result) {\n  uint8_t *buffer_ptr;\n  uint32_t buffer_remaining_size;\n  uint32_t callback_status = 0;\n  if (data[2] == 0) {\n    if (data[6] == 0) {\n      buffer_remaining_size = 1;\n    }\n    else {\n      buffer_remaining_size = 0xffffffff;\n    }\n    data[2] = buffer_remaining_size;\n  }\n  buffer_ptr = PTR_DAT_00006568;\n  if (-1 < (int)(data[0] << 0x1b)) {\n    uint8_t **data_buffer_ptr = (uint8_t **)*callback_result;\n    *callback_result = data_buffer_ptr + 1;\n    *data_buffer = *data_buffer_ptr;\n  }\n  uint32_t processed_data_count = 0;\n  do {\n    buffer_remaining_size = data[2];\n    if (buffer_remaining_size != 0) {\n      if (buffer_remaining_size == 1) {\n        if (*(char *)(data[5] + (uint)**data_buffer) == '\\0') {\n          if (processed_data_count == 0) {\n            return 1;\n          }\n          if (((data[0] & 0x10) == 0) && (data[3] = data[3] + 1, data[6] != 0)) {\n            *buffer_ptr = 0;\n          }\n          data[4] = processed_data_count + data[4];\n          return 0;\n        }\n      }\n      else if ((buffer_remaining_size != 2) || ((int)((uint)(byte)buffer_ptr[**data_buffer] << 0x1c) < 0))\n        goto LAB_0000654a;\n    }\n    uint8_t *temp_buffer_ptr = buffer_ptr;\n    if (-1 < (int)(data[0] << 0x1b)) {\n      temp_buffer_ptr = buffer_ptr + 1;\n      *buffer_ptr = **data_buffer;\n    }\n    uint8_t *next_data = (*data_buffer) + 1;\n    *data_buffer = next_data;\n    buffer_remaining_size = data[2] - 1;\n    data[2] = buffer_remaining_size;\n    processed_data_count = processed_data_count + 1;\n    buffer_ptr = temp_buffer_ptr;\n    if ((buffer_remaining_size == 0) || (((int)(next_data - 1) < 1) && ((callback_status = (*(code *)data[0x60])(data_size, data_buffer, buffer_remaining_size, (code *)data[0x60], callback_result)) != 0)))\n      goto LAB_0000654a;\n  } while (true);\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000064bc",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "process_data_000064bc"
        },
        "FUN_00002970": {
            "renaming": {
                "FUN_00002970": "clear_bit_in_uint_array_00002970",
                "PTR_DAT_00002990": "array_ptr",
                "DAT_00002990": "array_offset",
                "uint": "unsigned int",
                "current_value": "current_value",
                "mask": "bit_mask",
                "new_value": "new_value"
            },
            "code": "void clear_bit_in_uint_array_00002970(void)\n{\n  uint *PTR_DAT_00002990 = (uint *)(DAT_00002990 + 0x14);\n  uint current_value = *PTR_DAT_00002990;\n  uint mask = 0xffffffef;\n  uint new_value = current_value & mask;\n  *PTR_DAT_00002990 = new_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002970",
            "calling": [
                "FUN_000026e4"
            ],
            "imported": false,
            "current_name": "clear_bit_in_uint_array_00002970"
        },
        "FUN_00000dc0": {
            "renaming": {
                "FUN_00000dc0": "handle_interrupts_and_input_00000dc0",
                "handle_interrupts_and_input_00000cc0": "handle_interrupts_and_input"
            },
            "code": "void handle_interrupts_and_input_00000dc0(void)\n{\n  handle_interrupts_and_input_00000dc0_00000cc0();\n  return;\n}",
            "called": [
                "FUN_00000cc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dc0",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupts_and_input_00000dc0"
        },
        "FUN_00000d0c": {
            "renaming": {
                "FUN_00000d0c": "enableIRQinterrupts_if_privileged_00000d0c",
                "param_1": "interrupt_bit",
                "bVar1": "is_privileged"
            },
            "code": "void enableIRQinterrupts_if_privileged_00000d0c(uint interrupt_bit)\n{\n  bool is_privileged = (bool)isCurrentModePrivileged();\n  if (is_privileged) {\n    enableIRQinterrupts((interrupt_bit & 1) == 1);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d0c",
            "calling": [
                "FUN_000010d4",
                "FUN_000024bc",
                "FUN_00002434",
                "FUN_00001c84",
                "FUN_00000428"
            ],
            "imported": false,
            "current_name": "enableIRQinterrupts_if_privileged_00000d0c"
        },
        "FUN_00003d94": {
            "renaming": {
                "FUN_00003d94": "execute_function_00003d94",
                "param_1": "function_pointer",
                "param_2": "arg2",
                "uVar1": "result"
            },
            "code": "int execute_function_00003d94(int function_pointer, int arg1, int arg2) {\n  int result;\n  if (function_pointer == 0) {\n    result = -19;\n  }\n  else {\n    result = (**(int (**)(int, int))(function_pointer + 0x4)) (arg1, arg2);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d94",
            "calling": [
                "FUN_0000305c"
            ],
            "imported": false,
            "current_name": "execute_function_00003d94"
        },
        "FUN_0000579c": {
            "renaming": {
                "FUN_0000579c": "do_nothing_with_pointer_0000579c",
                "PTR_DAT_000057a4": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_0000579c(void)\n{\n  do_nothing_with_pointer_0000579c(PTR_DAT_000057a4);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000579c",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_0000579c"
        },
        "FUN_000015d0": {
            "renaming": {
                "FUN_000015d0": "copy_data_to_memory_000015d0",
                "param_1": "start_index",
                "param_2": "dest_address",
                "param_3": "num_bytes",
                "iVar1": "source_address",
                "local_c": "i"
            },
            "code": "void copy_data_to_memory_000015d0(int start_index, int dest_address, uint num_bytes)\n{\n  int source_address = *(int *)(PTR_DAT_00001624 + start_index * 0x20);\n  for (uint i = 0; i < num_bytes; i++) {\n    while (-1 < *(char *)(source_address + 4));\n    *(undefined *)(source_address + 7) = *(undefined *)(i + dest_address);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000015d0",
            "calling": [
                "FUN_00000e38"
            ],
            "imported": false,
            "current_name": "copy_data_to_memory_000015d0"
        },
        "FUN_00005e68": {
            "renaming": {
                "FUN_00005e68": "parse_and_execute_command_00005e68",
                "param_1": "command",
                "param_2": "param1",
                "param_3": "param2",
                "param_4": "param3",
                "local_80": "command_copy",
                "local_7c": "end_of_string",
                "local_74": "start_of_string",
                "local_72": "negative_one",
                "local_70": "param1_copy",
                "local_6c": "end_of_string_copy",
                "local_5c": "string_pointer",
                "local_4c": "zero",
                "local_38": "zero2",
                "uStack_8": "param3_copy",
                "uStack_4": "param4_copy",
                "PTR_LAB_00004dea_1_00005eb4": "original_string_pointer",
                "*DAT_00005eb8": "*command_pointer"
            },
            "code": "void parse_and_execute_command_00005e68(int command, int param1, int param2, int param3)\n{\n  int start_of_string = 0x204;\n  int command_copy = command;\n  int param1_copy = command;\n  int param3_copy = param3;\n  int param4_copy = param4;\n  int end_of_string = find_end_of_string();\n  char *string_pointer = PTR_LAB_00004dea_1_00005eb4;\n  int zero = 0;\n  int zero2 = 0;\n  int negative_one = -1;\n  int end_of_string_copy = end_of_string;\n  execute_command(*DAT_00005eb8, &command_copy, param2, &param3_copy);\n  return;\n}",
            "called": [
                "FUN_00005ecc",
                "FUN_000061cc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e68",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "parse_and_execute_command_00005e68"
        },
        "FUN_00000dcc": {
            "renaming": {
                "FUN_00000dcc": "set_data_00000dcc",
                "DAT_00000df0": "data_pointer"
            },
            "code": "void set_data_00000dcc(void)\n{\n  int* DAT_00000df0 = DAT_00000df0;\n  *(DAT_00000df0 + 7) = 0xc520;\n  *(DAT_00000df0 + 7) = 0xd928;\n  *DAT_00000df0 = 0xd2;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dcc",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": false,
            "current_name": "set_data_00000dcc"
        },
        "FUN_0000285c": {
            "renaming": {
                "FUN_0000285c": "set_flag_and_value_0000285c",
                "param_1": "value",
                "puVar1": "flag_ptr"
            },
            "code": "void set_flag_and_value_0000285c(int value) {\n    int *flag_ptr;\n    flag_ptr = DAT_00002890;\n    DAT_00002890[5] &= 0xFFFFFFEF;\n    *flag_ptr = value;\n    flag_ptr[5] |= 0x10;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000285c",
            "calling": [
                "FUN_00002600"
            ],
            "imported": false,
            "current_name": "set_flag_and_value_0000285c"
        },
        "FUN_00000e58": {
            "renaming": {
                "FUN_00000e58": "wait_for_interrupt_00000e58",
                "check_interrupt_enabled_00000cd0": "check_interrupt_enabled"
            },
            "code": "void wait_for_interrupt_00000e58(void)\n{\n  check_interrupt_enabled();\n  while(true)\n  {\n    // Do nothing\n  }\n}",
            "called": [
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e58",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "wait_for_interrupt_00000e58"
        },
        "FUN_00001778": {
            "renaming": {
                "FUN_00001778": "set_bit_in_byte_00001778",
                "DAT_000017d0": "data_offset",
                "DAT_000017d8": "memory_offset",
                "byte": "Byte"
            },
            "code": "void set_bit_in_byte_00001778(void)\n{\n  byte* data_ptr = (byte*)(DAT_000017d0 + 1);\n  *data_ptr = (*data_ptr & 0xCF) | 0x20;\n  clear_memory(DAT_000017d8, 2);\n  return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001778",
            "calling": [
                "FUN_000019c0",
                "FUN_0000191c"
            ],
            "imported": false,
            "current_name": "set_bit_in_byte_00001778"
        },
        "FUN_000026d8": {
            "renaming": {
                "FUN_000026d8": "initialize_data_flag_000026d8",
                "set_flag_for_data_0000294c": "set_data_flag"
            },
            "code": "void initialize_data_flag_000026d8()\n{\n    set_data_flag();\n    return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026d8",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "initialize_data_flag_000026d8"
        },
        "FUN_00000566": {
            "renaming": {
                "FUN_00000566": "count_leading_zero_bits_in_integer_00000566",
                "param_1": "x",
                "bVar1": "byte_3",
                "bVar2": "byte_0",
                "bVar3": "byte_1",
                "bVar4": "byte_2",
                "uVar5": "result"
            },
            "code": "uint32_t count_leading_zero_bits_in_integer_00000566(uint32_t x) {\n  uint32_t result = 0;\n  if ((x & 0xFFFF0000) == 0) { result += 16; x <<= 16; }\n  if ((x & 0xFF000000) == 0) { result += 8; x <<= 8; }\n  if ((x & 0xF0000000) == 0) { result += 4; x <<= 4; }\n  if ((x & 0xC0000000) == 0) { result += 2; x <<= 2; }\n  if ((x & 0x80000000) == 0) { result += 1; }\n  return result;\n}\n\nuint32_t count_leading_zero_bits_in_integer_00000566(int32_t x) {\n  uint8_t b0 = (uint8_t)x;\n  uint8_t b1 = (uint8_t)(x >> 8);\n  uint8_t b2 = (uint8_t)(x >> 16);\n  uint8_t b3 = (uint8_t)(x >> 24);\n  uint32_t combined = ((((((((b0 & 1) << 1 | b0 >> 1 & 1) << 1 | b0 >> 2 & 1) << 1 | b0 >> 3 & 1) << 1 | b0 >> 4 & 1) << 1 | b0 >> 5 & 1) << 1 | b0 >> 6 & 1) << 1 | b0 >> 7) << 24) | ((((((((b1 & 1) << 1 | b1 >> 1 & 1) << 1 | b1 >> 2 & 1) << 1 | b1 >> 3 & 1) << 1 | b1 >> 4 & 1) << 1 | b1 >> 5 & 1) << 1 | b1 >> 6 & 1) << 1 | b1 >> 7) << 16) | ((((((((b2 & 1) << 1 | b2 >> 1 & 1) << 1 | b2 >> 2 & 1) << 1 | b2 >> 3 & 1) << 1 | b2 >> 4 & 1) << 1 | b2 >> 5 & 1) << 1 | b2 >> 6 & 1) << 1 | b2 >> 7) << 8) | ((((((((b3 & 1) << 1 | b3 >> 1 & 1) << 1 | b3 >> 2 & 1) << 1 | b3 >> 3 & 1) << 1 | b3 >> 4 & 1) << 1 | b3 >> 5 & 1) << 1 | b3 >> 6 & 1) << 1 | b3 >> 7);\n  if (x == 0) {\n    return 32;\n  }\n  return count_leading_zero_bits_in_integer_00000566(combined);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000566",
            "calling": [
                "FUN_00000610"
            ],
            "imported": false,
            "current_name": "count_leading_zero_bits_in_integer_00000566"
        },
        "FUN_00001d08": {
            "renaming": {
                "FUN_00001d08": "calculate_value_00001d08",
                "param_1": "input_value",
                "param_2": "multiplier"
            },
            "code": "int calculate_value_00001d08(uint32_t input_value, int multiplier) {\n  uint32_t masked_value = input_value & 0xf0000000;\n  uint32_t shifted_value = (input_value & 0xfffff) << 5;\n  int offset = 0x2000000;\n  return multiplier * 4 + masked_value + shifted_value + offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d08",
            "calling": [
                "FUN_00001d3a"
            ],
            "imported": false,
            "current_name": "calculate_value_00001d08"
        },
        "FUN_000031fc": {
            "renaming": {
                "FUN_000031fc": "calculate_score_000031fc",
                "param_1": "num_players",
                "param_2": "player_score",
                "param_3": "total_score",
                "bVar1": "adjusted_score_byte",
                "iVar2": "adjusted_score",
                "score_contribution": "score_contribution",
                "score_multiplier": "score_multiplier"
            },
            "code": "int calculate_score_000031fc(int num_players, int player_score, int total_score) {\n  int adjusted_score = player_score;\n  if (num_players < 3) {\n    adjusted_score = 1;\n  }\n  if (num_players > 2) {\n    adjusted_score = 0;\n  }\n  adjusted_score = player_score - (uint8_t)adjusted_score;\n  if (adjusted_score < 0) {\n    adjusted_score += 3;\n  }\n  int score_contribution = (((adjusted_score >> 2) + player_score) - (int)((long long)DAT_00003280 * (long long)player_score >> 0x25)) + (int)((long long)DAT_00003280 * (long long)player_score >> 0x27) + *(int *)(DAT_00003284 + (num_players + -1) * 4) + total_score;\n  int score_multiplier = ((int)((unsigned long long)((long long)DAT_00003288 * (long long)score_contribution) >> 0x20) + score_contribution >> 2) - (score_contribution >> 0x1f);\n  return score_contribution + score_multiplier * -7;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031fc",
            "calling": [
                "FUN_0000328c"
            ],
            "imported": false,
            "current_name": "calculate_score_000031fc"
        },
        "FUN_000016ec": {
            "renaming": {
                "FUN_000016ec": "set_offset_to_one_000016ec",
                "param_1": "offset",
                "param_2": "value",
                "puVar1": "offset_ptr",
                "*puVar1": "*offset_ptr"
            },
            "code": "void set_offset_to_one_000016ec(int offset, unsigned char value) {\n  unsigned char *offset_ptr;\n  offset_ptr = (unsigned char *)calculate_offset(offset, value);\n  *offset_ptr = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016ec",
            "calling": [
                "FUN_00001a18",
                "FUN_00001778",
                "FUN_00001a3c",
                "FUN_0000182c",
                "FUN_00001a60"
            ],
            "imported": false,
            "current_name": "set_offset_to_one_000016ec"
        },
        "FUN_00005100": {
            "renaming": {
                "FUN_00005100": "process_data_00005100",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "puVar3": "ptr3",
                "uVar4": "data_value",
                "iVar5": "data_ptr",
                "pcVar6": "param_value",
                "iVar7": "compare_result",
                "iVar8": "parse_result",
                "cVar9": "command_type",
                "pcVar10": "command_string",
                "bVar11": "is_first_command",
                "puVar12": "ushort_ptr1",
                "piVar13": "int_ptr1",
                "puVar14": "ushort_ptr2",
                "piVar15": "int_ptr2",
                "local_3c": "ushort1",
                "local_3a": "ushort2",
                "local_38": "ushort3",
                "local_36": "ushort4",
                "local_34": "ushort5",
                "local_32": "ushort6",
                "local_30": "int1",
                "local_2c": "char_ptr_array"
            },
            "code": "\nvoid process_data_00005100(void)\n\n{\n  undefined *ptr1;\n  undefined *ptr2;\n  undefined4 *ptr3;\n  undefined4 data_value;\n  int data_ptr;\n  char *param_value;\n  int compare_result;\n  int parse_result;\n  char command_type;\n  char *command_string;\n  bool is_first_command;\n  ushort *ushort_ptr1;\n  int *int_ptr1;\n  ushort *ushort_ptr2;\n  int *int_ptr2;\n  ushort ushort1;\n  ushort ushort2;\n  ushort ushort3;\n  ushort ushort4;\n  ushort ushort5;\n  ushort ushort6;\n  int int1;\n  char *char_ptr_array [2];\n  \n  data_value = *DAT_00005108;\n  data_ptr = get_dat_value_000056b0();\n  ptr1 = PTR_DAT_000053d8;\n  param_value = (char *)find_parameter_value_and_update_stack_000056a0(data_value,PTR_DAT_000053d4);\n  ptr2 = PTR_DAT_000053e0;\n  if (param_value == (char *)0x0) {\n    *(undefined4 *)PTR_DAT_000053dc = 0;\n    *(undefined4 *)PTR_DAT_000053e4 = 0;\n    ptr3 = DAT_000053e8;\n    data_value = *(undefined4 *)ptr1;\n    *DAT_000053e8 = ptr2;\n    ptr3[1] = ptr2;\n    add_pointer_to_list_00005780(data_value);\n    *(undefined4 *)ptr1 = 0;\n  }\n  else if ((*(int *)ptr1 == 0) || (compare_result = compare_bytes_00004e52(), compare_result != 0)) {\n    add_pointer_to_list_00005780(*(undefined4 *)ptr1);\n    compare_result = find_end_of_string_00005ecc(param_value);\n    compare_result = allocate_memory_00004bd0(data_value,compare_result + 1);\n    *(int *)ptr1 = compare_result;\n    if (compare_result != 0) {\n      copy_string_00005ebc(compare_result,param_value);\n    }\n    if (*param_value == ':') {\n      param_value = param_value + 1;\n    }\n    compare_result = parse_and_execute_command_00005e68(param_value,PTR_s__10__0_9_____n_000053f0,PTR_DAT_000053ec,&int1);\n    if (0 < compare_result) {\n      command_string = param_value + int1;\n      if (param_value[int1] == '-') {\n        command_string = command_string + 1;\n        compare_result = -1;\n      }\n      else {\n        if (param_value[int1] == '+') {\n          command_string = command_string + 1;\n        }\n        compare_result = 1;\n      }\n      ushort2 = 0;\n      ushort3 = 0;\n      ushort_ptr1 = &ushort2;\n      int_ptr1 = &int1;\n      ushort_ptr2 = &ushort3;\n      int_ptr2 = &int1;\n      parse_result = parse_and_execute_command_00005e68(command_string,PTR_s__hu_n__hu_n__hu_n_000053f4,&ushort1,&int1,&ushort2,\n                           &int1,&ushort3,&int1);\n      ptr1 = PTR_DAT_00005400;\n      if (0 < parse_result) {\n        *(uint *)(data_ptr + 0x28) =\n             ((uint)ushort1 * 0xe10 + (uint)ushort2 * 0x3c + (uint)ushort3) * compare_result;\n        ptr3 = DAT_000053e8;\n        *DAT_000053e8 = PTR_DAT_000053ec;\n        command_string = command_string + int1;\n        compare_result = parse_and_execute_command_00005e68(command_string,PTR_s__10__0_9_____n_000053f0,ptr1,&int1,ushort_ptr1,int_ptr1,\n                             ushort_ptr2,int_ptr2);\n        if (compare_result < 1) {\n          ptr3[1] = *ptr3;\n          *(undefined4 *)PTR_DAT_000053dc = *(undefined4 *)(data_ptr + 0x28);\n          *(undefined4 *)PTR_DAT_000053e4 = 0;\n        }\n        else {\n          ptr3[1] = ptr1;\n          param_value = command_string + int1;\n          if (command_string[int1] == '-') {\n            param_value = param_value + 1;\n            compare_result = -1;\n          }\n          else {\n            if (command_string[int1] == '+') {\n              param_value = param_value + 1;\n            }\n            compare_result = 1;\n          }\n          ushort1 = 0;\n          ushort2 = 0;\n          ushort3 = 0;\n          int1 = 0;\n          parse_result = parse_and_execute_command_00005e68(param_value,PTR_s__hu_n__hu_n__hu_n_000053f4,&ushort1,&int1,&ushort2\n                               ,&int1,&ushort3,&int1);\n          if (parse_result < 1) {\n            compare_result = *(int *)(data_ptr + 0x28) + -0xe10;\n          }\n          else {\n            compare_result = ((uint)ushort1 * 0xe10 + (uint)ushort2 * 0x3c + (uint)ushort3) * compare_result;\n          }\n          *(int *)(data_ptr + 0x50) = compare_result;\n          param_value = param_value + int1;\n          is_first_command = false;\n          compare_result = data_ptr;\n          while( true ) {\n            if (*param_value == ',') {\n              param_value = param_value + 1;\n            }\n            command_type = *param_value;\n            if (command_type == 'M') {\n              parse_result = parse_and_execute_command_00005e68(param_value,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&ushort4,&int1,\n                                   &ushort5,&int1,&ushort6,&int1);\n              if (parse_result != 3) {\n                return;\n              }\n              if (0xb < ushort4 - 1) {\n                return;\n              }\n              if (4 < ushort5 - 1) {\n                return;\n              }\n              if (6 < ushort6) {\n                return;\n              }\n              *(uint *)(compare_result + 0xc) = (uint)ushort4;\n              *(uint *)(compare_result + 0x10) = (uint)ushort5;\n              *(undefined *)(compare_result + 8) = 0x4d;\n              *(uint *)(compare_result + 0x14) = (uint)ushort6;\n              command_string = param_value + int1;\n            }\n            else {\n              if (command_type == 'J') {\n                param_value = param_value + 1;\n              }\n              else {\n                command_type = 'D';\n              }\n              ushort6 = parse_integer_wrapper_00005fd8(param_value,char_ptr_array,10);\n              command_string = char_ptr_array[0];\n              if (char_ptr_array[0] == param_value) {\n                if (is_first_command) {\n                  *(undefined *)(data_ptr + 0x30) = 0x4d;\n                  *(undefined4 *)(data_ptr + 0x34) = 0xb;\n                  *(undefined4 *)(data_ptr + 0x38) = 1;\n                  *(undefined4 *)(data_ptr + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(data_ptr + 8) = 0x4d;\n                  *(undefined4 *)(data_ptr + 0xc) = 3;\n                  *(undefined4 *)(data_ptr + 0x10) = 2;\n                  *(undefined4 *)(data_ptr + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(compare_result + 8) = command_type;\n                *(uint *)(compare_result + 0x14) = (uint)ushort6;\n              }\n            }\n            ushort1 = 2;\n            ushort2 = 0;\n            ushort3 = 0;\n            int1 = 0;\n            if (*command_string == '/') {\n              parse_and_execute_command_00005e68(command_string,PTR_DAT_000053fc,&ushort1,&int1,&ushort2,&int1,\n                           &ushort3,&int1);\n            }\n            *(uint *)(compare_result + 0x18) =\n                 (uint)ushort1 * 0xe10 + (uint)ushort2 * 0x3c + (uint)ushort3;\n            compare_result = compare_result + 0x28;\n            param_value = command_string + int1;\n            if (is_first_command) break;\n            is_first_command = true;\n          }\n          calculate_day_of_week_00004f98(*(undefined4 *)(data_ptr + 4));\n          compare_result = *(int *)(data_ptr + 0x28);\n          *(int *)PTR_DAT_000053dc = compare_result;\n          compare_result = *(int *)(data_ptr + 0x50) - compare_result;\n          if (compare_result != 0) {\n            compare_result = 1;\n          }\n          *(int *)PTR_DAT_000053e4 = compare_result;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005ecc",
                "FUN_00005e68",
                "FUN_00005ebc",
                "FUN_00004e52",
                "FUN_000056a0",
                "FUN_00005780",
                "FUN_00004f98",
                "FUN_000056b0",
                "FUN_00004bd0",
                "FUN_00005fd8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005100",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "process_data_00005100"
        },
        "FUN_00005584": {
            "renaming": {
                "FUN_00005584": "divide_and_remainder_00005584",
                "param_1": "result",
                "param_2": "dividend",
                "param_3": "divisor",
                "uVar1": "remainder",
                "uVar2": "quotient"
            },
            "code": "void divide_and_remainder_00005584(uint *result, uint dividend, uint divisor)\n{\n    uint quotient = dividend / divisor;\n    uint remainder = dividend % divisor;\n\n    if (dividend < 0 && remainder > 0) {\n        quotient--;\n        remainder += divisor;\n    }\n    else if (remainder < 0) {\n        quotient++;\n        remainder -= divisor;\n    }\n\n    *result = quotient;\n    result[1] = remainder;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005584",
            "calling": [
                "FUN_00004634"
            ],
            "imported": false,
            "current_name": "divide_and_remainder_00005584"
        },
        "FUN_00004248": {
            "renaming": {
                "FUN_00004248": "allocate_and_initialize_array_00004248",
                "param_1": "memory_address",
                "param_2": "array_length",
                "puVar1": "array_pointer",
                "iVar2": "array_size"
            },
            "code": "undefined4* allocate_and_initialize_array_00004248(undefined4 memory_address, int array_length)\n{\n    undefined4* array_pointer;\n    int array_size = (array_length - 1) * 0x68;\n    array_pointer = (undefined4*)allocate_memory_00004bd0(memory_address, array_size + 0x74);\n    if (array_pointer != (undefined4*)0x0)\n    {\n        *array_pointer = 0;\n        array_pointer[1] = array_length;\n        array_pointer[2] = array_pointer + 3;\n        fill_array_with_value_00004622(array_pointer + 3, 0, array_size + 0x68);\n    }\n    return array_pointer;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004248",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_array_00004248"
        },
        "FUN_00001da2": {
            "renaming": {
                "FUN_00001da2": "get_bits_from_right_00001da2",
                "param_1": "value",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "ushort get_bits_from_right_00001da2(ushort value, int num_bits) {\n    ushort mask = (1 << num_bits) - 1;\n    return value & mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001da2",
            "calling": [
                "FUN_00001f80",
                "FUN_00001ddc"
            ],
            "imported": false,
            "current_name": "get_bits_from_right_00001da2"
        },
        "FUN_00001ec4": {
            "renaming": {
                "FUN_00001ec4": "extract_bits_and_set_in_memory_00001ec4",
                "param_1": "memory_address",
                "param_2": "bit_index",
                "uVar1": "extracted_bits"
            },
            "code": "void extract_bits_and_set_in_memory_00001ec4(uint32_t* memory_address, uint32_t bit_index)\n{\n  uint32_t extracted_bits = extract_bits_from_memory(memory_address, bit_index);\n  set_bits_in_uint_at_index(memory_address, bit_index, extracted_bits);\n  return;\n}",
            "called": [
                "FUN_00001e44",
                "FUN_00001e0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ec4",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "extract_bits_and_set_in_memory_00001ec4"
        },
        "FUN_00002744": {
            "renaming": {
                "FUN_00002744": "write_to_memory_00002744",
                "param_1": "address",
                "param_2": "data",
                "DAT_00002790": "memory_map",
                "DAT_00002794": "memory_map_2"
            },
            "code": "void write_to_memory_00002744(byte address, uint8_t data) {\n  if (address < 0) {\n    *(char *)((address & 0xf) + DAT_00002790 + 0x14) = (char)((data & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)address + DAT_00002794 + 0x300) = (char)((data & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002744",
            "calling": [
                "FUN_00002894"
            ],
            "imported": false,
            "current_name": "write_to_memory_00002744"
        },
        "FUN_00002624": {
            "renaming": {
                "FUN_00002624": "calculate_date_and_find_first_difference_00002624",
                "param_1": "date",
                "local_10": "first_difference",
                "uStack_c": "result",
                "find_first_difference_in_data_0000281c": "find_first_difference_in_data",
                "calculate_date_0000443c": "calculate_date"
            },
            "code": "int calculate_date_and_find_first_difference_00002624(void *data, int date) {\n    int first_difference = find_first_difference_in_data();\n    int result = 0;\n    calculate_date(&first_difference, date);\n    return result;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_0000281c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002624",
            "calling": [
                "FUN_00003444"
            ],
            "imported": false,
            "current_name": "calculate_date_and_find_first_difference_00002624"
        },
        "FUN_00001e0c": {
            "renaming": {
                "FUN_00001e0c": "extract_bits_from_memory_00001e0c",
                "param_1": "index",
                "param_2": "data",
                "PTR_DAT_00001e40": "memory_address",
                "extracted_bits": "extracted_bits"
            },
            "code": "uint extract_bits_from_memory_00001e0c(int index, uint data)\n{\n    uint* PTR_DAT_00001e40 = PTR_DAT_00001e40 + (((int)data >> 3) + index * 4) * 4;\n    uint extracted_bits = (*PTR_DAT_00001e40 >> ((data & 7) << 2)) & 0xf;\n    return extracted_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e0c",
            "calling": [
                "FUN_00002028",
                "FUN_00001ec4"
            ],
            "imported": false,
            "current_name": "extract_bits_from_memory_00001e0c"
        },
        "FUN_00000ef8": {
            "renaming": {
                "FUN_00000ef8": "do_nothing_00000ef8"
            },
            "code": "\nvoid do_nothing_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ef8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "do_nothing_00000ef8"
        },
        "FUN_000041d0": {
            "renaming": {
                "FUN_000041d0": "process_data_000041d0",
                "param_1": "input",
                "param_2": "param_2",
                "param_3": "param_3",
                "pcVar1": "function_pointer",
                "iVar2": "current_item_index",
                "uVar3": "result",
                "iVar4": "item_count",
                "piVar5": "item_pointer",
                "iVar6": "item_address",
                "uVar7": "result",
                "iVar8": "sub_item_count",
                "puVar9": "data_pointer"
            },
            "code": "uint process_data_000041d0(int input, undefined4 param_2, undefined4 param_3)\n{\n  code *function_pointer;\n  int current_item_index;\n  uint result = 0;\n  int *item_pointer;\n  int item_address;\n  int item_count;\n  int sub_item_count;\n  undefined *data_pointer;\n  function_pointer = DAT_000041ec;\n  if (input == 0) {\n    current_item_index = *(int *)PTR_DAT_000041e8;\n    item_pointer = (int *)(current_item_index + 0x48);\n    data_pointer = PTR_DAT_000041e8;\n    do {\n      item_address = item_pointer[1];\n      sub_item_count = item_pointer[2];\n      while (sub_item_count = sub_item_count + -1, -1 < sub_item_count) {\n        if ((1 < *(ushort *)(item_address + 0xc)) && (item_count = *(short *)(item_address + 0xe) + 1, item_count != 0)) {\n          result = (*function_pointer)(current_item_index,item_address,param_3,item_count,data_pointer) | result;\n        }\n        item_address = item_address + 0x68;\n      }\n      item_pointer = (int *)*item_pointer;\n    } while (item_pointer != (int *)0x0);\n    return result;\n  }\n  result = processData_00004158(*DAT_000041f0,input);\n  return result;\n}",
            "called": [
                "FUN_00004158"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041d0",
            "calling": [
                "FUN_00002e48"
            ],
            "imported": false,
            "current_name": "process_data_000041d0"
        },
        "FUN_0000459c": {
            "renaming": {
                "FUN_0000459c": "executeFunctionsInMemory_0000459c",
                "puVar1": "start_of_functions",
                "puVar2": "end_of_functions",
                "iVar3": "num_functions",
                "ppcVar4": "current_function"
            },
            "code": "void executeFunctionsInMemory_0000459c(void)\n{\n  undefined *start_of_functions = PTR_DAT_000045d4;\n  undefined *end_of_functions = PTR_DAT_000045d8;\n  code **current_function = (code **)start_of_functions;\n  int num_functions = (int)(end_of_functions - start_of_functions);\n  for (int i = 0; i < num_functions; i++) {\n    (**current_function)();\n    current_function++;\n  }\n  initializeMemory_00000410();\n  start_of_functions = PTR_DAT_000045dc;\n  end_of_functions = PTR_DAT_000045e0;\n  current_function = (code **)start_of_functions;\n  num_functions = (int)(end_of_functions - start_of_functions);\n  for (int i = 0; i < num_functions; i++) {\n    (**current_function)();\n    current_function++;\n  }\n  return;\n}",
            "called": [
                "FUN_00000410"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000459c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "executeFunctionsInMemory_0000459c"
        },
        "FUN_000014c4": {
            "renaming": {
                "FUN_000014c4": "set_bits_000014c4",
                "param_1": "index",
                "param_2": "value",
                "pbVar1": "data",
                "uVar2": "size",
                "uVar3": "quotient"
            },
            "code": "void set_bits_000014c4(uint32_t index, uint32_t value) {\n    byte* data = *(byte**)(PTR_DAT_000015cc + index * 0x20);\n    uint32_t size = *(uint32_t*)(PTR_DAT_000015cc + index * 0x20 + 4);\n    data[3] &= 0xf3;\n    data[2] = PTR_DAT_000015cc[index * 0x20 + 0x1d];\n    uint32_t quotient = size / (value << 4);\n    data[0] = (byte)(quotient >> 8) & 0x1f;\n    data[1] = (byte)quotient;\n    data[10] = (byte)((size << 2) / value + 1 >> 1) & 0x1f;\n    data[0x10] |= 0x88;\n    if ((data[0x10] & 0x70) == 0) {\n        data[0x13] = 0;\n    }\n    else {\n        data[0x13] = (char)(2 << (data[0x10] >> 4 & 7)) - 1;\n    }\n    data[0x15] = 1;\n    data[0x11] = 0xc0;\n    data[3] |= 0x2c;\n    set_bit_in_array_00001318((int)(char)PTR_DAT_000015cc[index * 0x20 + 0x14]);\n    return;\n}",
            "called": [
                "FUN_00001318"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000014c4",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "set_bits_000014c4"
        },
        "FUN_00004b34": {
            "renaming": {
                "FUN_00004b34": "add_pointer_to_list_00004b34",
                "param_1": "error_code",
                "param_2": "list_size",
                "param_3": "unknown_parameter",
                "param_4": "unknown_parameter",
                "puVar1": "pointer_to_list_start",
                "piVar2": "unused_pointer",
                "extraout_r1": "pointer_to_current_node",
                "ppiVar3": "pointer_to_current_node",
                "ppiVar4": "pointer_to_previous_node",
                "ppiVar5": "pointer_to_current_node",
                "ppiVar6": "pointer_to_new_node",
                "bVar7": "is_new_node_smallest"
            },
            "code": "void add_pointer_to_list_00004b34(int* new_pointer, int list_size, int error_code, int unknown_parameter)\\n\\\n{\\n\\\n  int **list_start_ptr = *(int ***)PTR_DAT_00004bcc;\\n\\\n  int **current_ptr = list_start_ptr;\\n\\\n  int **previous_ptr = NULL;\\n\\\n  bool is_new_node_smallest = false;\\n\\\n  \\n\\\n  if (list_size == 0) {\\n\\\n    return;\\n\\\n  }\\n\\\n  \\n\\\n  int **new_node_ptr = (int **)(list_size + -4);\\n\\\n  if (*(int *)(list_size + -4) < 0) {\\n\\\n    new_node_ptr = (int **)((int)new_node_ptr + *(int *)(list_size + -4));\\n\\\n  }\\n\\\n  \\n\\\n  do_nothing_with_pointer_00005790();\\n\\\n  \\n\\\n  if (list_start_ptr == NULL) {\\n\\\n    new_node_ptr[1] = NULL;\\n\\\n    *(int ***)PTR_DAT_00004bcc = new_node_ptr;\\n\\\n    current_ptr = extraout_r1;\\n\\\n    previous_ptr = PTR_DAT_00004bcc;\\n\\\n  }\\n\\\n  else if (new_node_ptr < list_start_ptr) {\\n\\\n    current_ptr = *new_node_ptr;\\n\\\n    previous_ptr = (int **)((int)new_node_ptr + (int)current_ptr);\\n\\\n    is_new_node_smallest = list_start_ptr == previous_ptr;\\n\\\n    if (is_new_node_smallest) {\\n\\\n      previous_ptr = *list_start_ptr;\\n\\\n      list_start_ptr = (int **)list_start_ptr[1];\\n\\\n    }\\n\\\n    new_node_ptr[1] = (int *)list_start_ptr;\\n\\\n    if (is_new_node_smallest) {\\n\\\n      previous_ptr = (int **)((int)previous_ptr + (int)current_ptr);\\n\\\n      *new_node_ptr = (int *)previous_ptr;\\n\\\n    }\\n\\\n    *(int ***)PTR_DAT_00004bcc = new_node_ptr;\\n\\\n  }\\n\\\n  else {\\n\\\n    while (current_ptr != NULL && current_ptr <= new_node_ptr) {\\n\\\n      previous_ptr = current_ptr;\\n\\\n      current_ptr = (int **)current_ptr[1];\\n\\\n    }\\n\\\n    int **current_node_ptr = *previous_ptr;\\n\\\n    if ((int **)((int)previous_ptr + (int)current_node_ptr) == new_node_ptr) {\\n\\\n      current_node_ptr = (int **)((int)current_node_ptr + (int)*new_node_ptr);\\n\\\n      *previous_ptr = (int *)current_node_ptr;\\n\\\n      if (current_ptr == (int **)((int)previous_ptr + (int)current_node_ptr)) {\\n\\\n        int *next_node_ptr = *current_ptr;\\n\\\n        previous_ptr[1] = current_ptr[1];\\n\\\n        current_node_ptr = (int **)((int)current_node_ptr + (int)next_node_ptr);\\n\\\n        *previous_ptr = (int *)current_node_ptr;\\n\\\n      }\\n\\\n    }\\n\\\n    else if (new_node_ptr < (int **)((int)previous_ptr + (int)current_node_ptr)) {\\n\\\n      *error_code = 0xc;\\n\\\n    }\\n\\\n    else {\\n\\\n      int **next_node_ptr = (int **)((int)new_node_ptr + (int)*new_node_ptr);\\n\\\n      is_new_node_smallest = current_ptr == next_node_ptr;\\n\\\n      if (is_new_node_smallest) {\\n\\\n        next_node_ptr = *current_ptr;\\n\\\n        current_ptr = (int **)current_ptr[1];\\n\\\n      }\\n\\\n      new_node_ptr[1] = (int *)current_ptr;\\n\\\n      if (is_new_node_smallest) {\\n\\\n        next_node_ptr = (int **)((int)next_node_ptr + (int)*new_node_ptr);\\n\\\n        *new_node_ptr = (int *)next_node_ptr;\\n\\\n      }\\n\\\n      previous_ptr[1] = (int *)new_node_ptr;\\n\\\n    }\\n\\\n  }\\n\\\n  do_nothing_with_pointer_0000579c(error_code, current_node_ptr, previous_ptr, unknown_parameter);\\n\\\n  return;\\n\\\n}",
            "called": [
                "FUN_0000579c",
                "FUN_00005790"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004b34",
            "calling": [
                "FUN_0000404c",
                "FUN_00005780",
                "FUN_000060cc",
                "FUN_000054a8",
                "FUN_00006768",
                "FUN_00006192"
            ],
            "imported": false,
            "current_name": "add_pointer_to_list_00004b34"
        },
        "FUN_000004f2": {
            "renaming": {
                "FUN_000004f2": "set_param_to_19_000004f2",
                "*param_1": "*param_ptr"
            },
            "code": "int set_param_to_19_000004f2(int *param_ptr) {\n    *param_ptr = 19;\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004f2",
            "calling": [
                "FUN_00004e26",
                "FUN_00004dee"
            ],
            "imported": false,
            "current_name": "set_param_to_19_000004f2"
        },
        "FUN_00004e66": {
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "param_1": "string1",
                "param_2": "string1_length",
                "param_3": "string2",
                "pbVar1": "current_char_string1",
                "pbVar2": "current_char_string2",
                "uVar3": "current_char_ascii_value"
            },
            "code": "int compare_strings_00004e66(byte *string1, int string1_length, byte *string2)\n{\n  byte *current_char_string1;\n  byte *current_char_string2;\n  uint current_char_ascii_value;\n  \n  if (string2 != 0) {\n    current_char_string2 = (byte *)(string1 + -1);\n    current_char_string1 = string1;\n    do {\n      current_char_ascii_value = (uint)*current_char_string1;\n      current_char_string2 = current_char_string2 + 1;\n      if ((current_char_ascii_value != *current_char_string2) || (current_char_string1 + 1 == string1 + string1_length)) break;\n      current_char_string1 = current_char_string1 + 1;\n    } while (current_char_ascii_value != 0);\n    string1_length = current_char_ascii_value - *current_char_string2;\n  }\n  return string1_length;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e66",
            "calling": [
                "FUN_00003524",
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e66"
        },
        "FUN_00005ecc": {
            "renaming": {
                "FUN_00005ecc": "find_end_of_string_00005ecc",
                "param_1": "input_string",
                "pcVar3": "current_position",
                "pcVar2": "next_position",
                "cVar1": "current_char"
            },
            "code": "char* find_end_of_string_00005ecc(char* input_string)\n{\n  char current_char;\n  char* current_position = input_string;\n  do {\n    current_position++;\n    current_char = *current_position;\n  } while (current_char != '\\0');\n  return current_position + (-1 - (int)input_string);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ecc",
            "calling": [
                "FUN_00005e68",
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "find_end_of_string_00005ecc"
        },
        "FUN_0000129c": {
            "renaming": {
                "FUN_0000129c": "update_linked_list_with_param1_0000129c",
                "param_1": "node"
            },
            "code": "void update_linked_list_with_param1_0000129c(void* node) {\n  update_linked_list(node, 1);\n  return;\n}",
            "called": [
                "FUN_00002434"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000129c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": false,
            "current_name": "update_linked_list_with_param1_0000129c"
        },
        "FUN_00001628": {
            "renaming": {
                "FUN_00001628": "check_and_call_function_00001628",
                "param_1": "index",
                "PTR_DAT_00001680": "ptr1",
                "PTR_DAT_00001684": "ptr2",
                "byte": "byte_ptr",
                "code": "func_ptr",
                "arg1": "arg1",
                "arg2": "arg2"
            },
            "code": "void check_and_call_function_00001628(int index)\n{\n    int* PTR_DAT_00001680 = PTR_DAT_00001680 + index * 0x20;\n    int* PTR_DAT_00001684 = PTR_DAT_00001684 + index * 8;\n    byte* byte_ptr = *(byte **)(PTR_DAT_00001680 + 1);\n    if ((*byte_ptr & 0x20) && (*PTR_DAT_00001684 != 0)) {\n        code* func_ptr = *(code **)PTR_DAT_00001684;\n        int arg1 = *(int *)(PTR_DAT_00001684 + 1);\n        char arg2 = *(char *)(*PTR_DAT_00001680 + 7);\n        func_ptr(arg1, arg2);\n    }\n    check_and_set_flag_00001348();\n}",
            "called": [
                "FUN_00001348"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001628",
            "calling": [
                "FUN_00001688"
            ],
            "imported": false,
            "current_name": "check_and_call_function_00001628"
        },
        "FUN_00001748": {
            "renaming": {
                "FUN_00001748": "update_byte_with_mask_00001748",
                "param_1": "new_byte",
                "*(byte *)(DAT_00001774 + 3)": "byte_ptr",
                "DAT_00001774": "byte_array",
                "current_byte": "current_byte",
                "masked_byte": "masked_byte",
                "result_byte": "result_byte"
            },
            "code": "void update_byte_with_mask_00001748(byte new_byte){\n  byte* *(byte *)(DAT_00001774 + 3) = (byte *)(DAT_00001774 + 3);\n  byte current_byte = **(byte *)(DAT_00001774 + 3);\n  byte masked_byte = current_byte & 0x1f;\n  byte result_byte = new_byte | masked_byte;\n  **(byte *)(DAT_00001774 + 3) = result_byte;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001748",
            "calling": [
                "FUN_000019c0",
                "FUN_00001bb8",
                "FUN_00001960",
                "FUN_0000191c",
                "FUN_000018bc"
            ],
            "imported": false,
            "current_name": "update_byte_with_mask_00001748"
        },
        "FUN_0000294c": {
            "renaming": {
                "FUN_0000294c": "set_flag_for_data_0000294c",
                "DAT_0000296c": "data_buffer"
            },
            "code": "void set_flag_for_data_0000294c(void)\n{\n  uint32_t *data_ptr = (uint32_t *)(DAT_0000296c + 0x14);\n  *data_ptr |= 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000294c",
            "calling": [
                "FUN_000027b0",
                "FUN_000026d8"
            ],
            "imported": false,
            "current_name": "set_flag_for_data_0000294c"
        },
        "FUN_00005790": {
            "renaming": {
                "FUN_00005790": "do_nothing_with_pointer_00005790",
                "PTR_DAT_00005798": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_00005790(void)\n{\n  do_nothing(PTR_DAT_00005798);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005790",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00005790"
        },
        "FUN_00000534": {
            "renaming": {
                "FUN_00000534": "is_valid_input_00000534",
                "param_1": "input",
                "param_2": "input_length",
                "uVar1": "is_valid",
                "*param_1": "*input"
            },
            "code": "int is_valid_input_00000534(int *input, int input_length) {\n  *input = 0;\n  if (((input_length == 0) || (input_length == 1)) || (input_length == 2)) {\n    return 1;\n  }\n  else {\n    return 0;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000534",
            "calling": [
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "is_valid_input_00000534"
        },
        "FUN_000017dc": {
            "renaming": {
                "FUN_000017dc": "set_offset_to_one_and_enable_flag_000017dc",
                "DAT_00001820": "offset_array",
                "DAT_00001824": "flag_array",
                "DAT_00001828": "data_array"
            },
            "code": "void set_offset_to_one_and_enable_flag_000017dc(void)\n{\n  set_calculated_offset_to_one(DAT_00001820,0x1d);\n  if ((*(uint *)(DAT_00001824 + 0x10) & 0x100) == 0) {\n    *(undefined4 *)(DAT_00001824 + 0x10) = 0x104;\n  }\n  *DAT_00001828 = *DAT_00001828 & 0xfff3ffff | 0x80000;\n  return;\n}",
            "called": [
                "FUN_000016c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000017dc",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "set_offset_to_one_and_enable_flag_000017dc"
        },
        "FUN_00000410": {
            "renaming": {
                "FUN_00000410": "initializeMemory_00000410",
                "PTR_00000df4": "no change",
                "DAT_00000000": "no change"
            },
            "code": "void initializeMemory_00000410(void)\n{\n  // code to initialize memory goes here\n  return;\n}",
            "called": [
                "FUN_00000df4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000410",
            "calling": [
                "FUN_0000459c"
            ],
            "imported": false,
            "current_name": "initializeMemory_00000410"
        },
        "FUN_000005ca": {
            "renaming": {
                "FUN_000005ca": "reverse_linked_list_000005ca",
                "param_1": "head_ptr",
                "puVar1": "current_node_ptr",
                "*param_1": "*head_ptr",
                "(undefined4 *)0x0": "(undefined4 *)NULL"
            },
            "code": "undefined4 *reverse_linked_list_000005ca(int *head_ptr)\n{\n  undefined4 *current_node_ptr;\n  if (*head_ptr == 0) {\n    current_node_ptr = (undefined4 *)0x0;\n  }\n  else {\n    current_node_ptr = *(undefined4 **)*head_ptr;\n    if (current_node_ptr == (undefined4 *)*head_ptr) {\n      *head_ptr = 0;\n    }\n    else {\n      *(undefined4 *)*head_ptr = *current_node_ptr;\n    }\n  }\n  return current_node_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000005ca",
            "calling": [
                "FUN_00000698"
            ],
            "imported": false,
            "current_name": "reverse_linked_list_000005ca"
        },
        "FUN_00005ff8": {
            "renaming": {
                "FUN_00005ff8": "do_nothing_with_data_00005ff8",
                "DAT_00006000": "DAT_buffer",
                "do_nothing_000045ec": "do_nothing"
            },
            "code": "void do_nothing_with_data_00005ff8(void)\n{\n  do_nothing(DAT_00006000);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ff8",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_00005ff8"
        },
        "FUN_00002714": {
            "renaming": {
                "FUN_00002714": "set_bit_in_array_00002714",
                "param_1": "bit_position",
                "DAT_00002740": "array_start_ptr",
                "uint": "uint32_t",
                "int": "int32_t",
                "char": "uint8_t",
                "*": "*",
                ">>": ">>",
                "&": "&",
                "=": "=",
                "1": "1",
                "<<": "<<",
                "return": "return"
            },
            "code": "void set_bit_in_array_00002714(uint8_t bit_position) {\n    uint32_t* array_ptr = (uint32_t*)(DAT_00002740 + (bit_position >> 5) * 4);\n    uint8_t bit_offset = bit_position & 0x1f;\n    uint32_t bit_mask = 1 << bit_offset;\n    *array_ptr = bit_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002714",
            "calling": [
                "FUN_00002894"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_00002714"
        },
        "FUN_000020e0": {
            "renaming": {
                "FUN_000020e0": "extract_bits_and_call_functions_000020e0",
                "DAT_000020f0": "data",
                "extract_bits_and_call_functions_00002028": "extract_bits_and_call_functions",
                "num_bits": "num_bits"
            },
            "code": "void extract_bits_and_call_functions_000020e0(uint8_t* DAT_000020f0, uint8_t num_bits){\n    extract_bits_and_call_functions_000020e0(DAT_000020f0, num_bits);\n    return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020e0",
            "calling": [],
            "imported": false,
            "current_name": "extract_bits_and_call_functions_000020e0"
        },
        "FUN_00005fec": {
            "renaming": {
                "FUN_00005fec": "do_nothing_with_data_00005fec",
                "DAT_00005ff4": "PTR_data"
            },
            "code": "void do_nothing_with_data_00005fec(void)\n{\n  do_nothing_with_data_00005fec(DAT_00005ff4);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fec",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_00005fec"
        },
        "FUN_00004f84": {
            "renaming": {
                "FUN_00004f84": "parseStringToUnsignedInt_00004f84",
                "param_1": "string",
                "param_2": "endPtr",
                "param_3": "base",
                "uVar1": "result",
                "uVar2": "digitChar",
                "uVar3": "charFlag",
                "uVar4": "digitValue",
                "iVar5": "digitCount",
                "uVar6": "maxIntValue",
                "uVar7": "maxDigitCount",
                "pbVar8": "previousChar",
                "pbVar9": "currentChar"
            },
            "code": "uint parseStringToUnsignedInt_00004f84(byte *string, byte **endPtr, uint base) {\n  uint digitValue;\n  uint isNegative = 0;\n  uint maxIntValue;\n  int digitCount = 0;\n  uint result = 0;\n  byte *currentChar = string;\n  while ((*currentChar >= 0x09 && *currentChar <= 0x0d) || *currentChar == 0x20) {\n    currentChar++;\n  }\n  if (*currentChar == 0x2d) {\n    isNegative = 1;\n    currentChar++;\n  }\n  else if (*currentChar == 0x2b) {\n    currentChar++;\n  }\n  if (base == 0) {\n    if (*currentChar != 0x30) {\n      base = 10;\n    }\n    else if (*(currentChar + 1) == 0x58) {\n      base = 16;\n      currentChar += 2;\n    }\n    else {\n      base = 8;\n    }\n  }\n  maxIntValue = (isNegative ? 0x80000000 : 0x7fffffff) / base;\n  while (1) {\n    if (*currentChar >= 0x30 && *currentChar <= 0x39) {\n      digitValue = *currentChar - 0x30;\n    }\n    else if (*currentChar >= 0x41 && *currentChar <= 0x5a) {\n      digitValue = *currentChar - 0x37;\n    }\n    else if (*currentChar >= 0x61 && *currentChar <= 0x7a) {\n      digitValue = *currentChar - 0x57;\n    }\n    else {\n      break;\n    }\n    if (digitValue >= base) {\n      break;\n    }\n    if (digitCount != -1) {\n      if (maxIntValue < result || (maxIntValue == result && digitValue > (isNegative ? 0x80000000 % base : 0x7fffffff % base))) {\n        digitCount = -1;\n      }\n      else {\n        result = result * base + digitValue;\n        digitCount = 1;\n      }\n    }\n    currentChar++;\n  }\n  if (digitCount == -1) {\n    *endPtr = string;\n    **(uint **)0x00004f94 = 0x22;\n    return (isNegative ? 0x80000000 : 0x7fffffff);\n  }\n  else {\n    if (isNegative) {\n      result = -result;\n    }\n    *endPtr = currentChar;\n    return result;\n  }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f84",
            "calling": [
                "FUN_0000328c",
                "FUN_00004042"
            ],
            "imported": false,
            "current_name": "parseStringToUnsignedInt_00004f84"
        },
        "FUN_000028f0": {
            "renaming": {
                "FUN_000028f0": "get_dat_value_plus_one_000028f0",
                "DAT_0000290c": "data"
            },
            "code": "int get_dat_value_plus_one_000028f0(void)\n{\n  int* DAT_0000290c_ptr = (int *)(DAT_0000290c + 8);\n  int dat_value = *DAT_0000290c_ptr;\n  int result = dat_value + 1;\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000028f0",
            "calling": [
                "FUN_00002690"
            ],
            "imported": false,
            "current_name": "get_dat_value_plus_one_000028f0"
        },
        "FUN_00004f98": {
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "param_1": "year",
                "puVar1": "data",
                "uVar2": "is_weekday",
                "uVar3": "month",
                "iVar4": "month_offset",
                "puVar5": "calendar_data",
                "iVar6": "days_since_1900",
                "uVar7": "leap_year_offset",
                "iVar8": "i",
                "iVar9": "day_of_week_offset",
                "uVar10": "leading_zeroes"
            },
            "code": "uint32_t calculate_day_of_week_00004f98(uint32_t year) {\n  uint32_t *data = (uint32_t *)get_dat_value_000056b0();\n  if (year < 0x7b2) {\n    return 0;\n  }\n  uint32_t leading_zeroes = count_leading_zeroes(year % 400);\n  uint32_t days_since_1900 = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) + (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n  data[1] = year;\n  uint32_t *calendar_data = data;\n  do {\n    uint32_t month = calendar_data[5];\n    if (*(char *)(calendar_data + 2) == 'J') {\n      if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n        if (month < 0x3c) {\n          month = 0;\n        }\n        else {\n          month = 1;\n        }\n      }\n      else {\n        month = 0;\n      }\n      month = month + days_since_1900 + calendar_data[5] + -1;\n    }\n    else if (*(char *)(calendar_data + 2) == 'D') {\n      month = days_since_1900 + calendar_data[5];\n    }\n    else {\n      uint32_t leap_year_offset = leading_zeroes >> 5;\n      if (((year & 3) == 0) && (year % 100 != 0)) {\n        leap_year_offset = 1;\n      }\n      uint32_t i = 0;\n      month = days_since_1900;\n      while ((int)calendar_data[3] > i) {\n        month = month + *(int *)(PTR_DAT_000050e4 + i * 4 + leap_year_offset * 0x30 + -4);\n        i++;\n      }\n      uint32_t day_of_week_offset = calendar_data[5] - (month + 4U) % 7;\n      if (day_of_week_offset < 0) {\n        day_of_week_offset = day_of_week_offset + 7;\n      }\n      for (day_of_week_offset = (calendar_data[4] - 1) * 7 + day_of_week_offset; *(int *)(PTR_DAT_000050e4 + i * 4 + leap_year_offset * 0x30 + -4) <= day_of_week_offset; day_of_week_offset = day_of_week_offset + -7) {\n      }\n      month = month + day_of_week_offset;\n    }\n    uint32_t day_number = calendar_data[10] + DAT_000050e0 * month + calendar_data[6];\n    calendar_data[8] = day_number;\n    calendar_data[9] = (int)day_number >> 0x1f;\n    calendar_data = calendar_data + 10;\n  } while (data + 0x14 != calendar_data);\n  uint32_t is_weekday = (uint32_t)((int)((calendar_data[9] - calendar_data[0x13]) - (uint32_t)(data[8] < data[0x12])) < 0 != (SBORROW4(calendar_data[9],calendar_data[0x13]) != SBORROW4(calendar_data[9] - calendar_data[0x13],(uint32_t)(data[8] < data[0x12]))));\n  return is_weekday;\n}",
            "called": [
                "FUN_000056b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f98",
            "calling": [
                "FUN_00005100",
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_00004f98"
        },
        "FUN_00004dee": {
            "renaming": {
                "FUN_00004dee": "copy_data_to_memory_00004dee",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "size",
                "param_4": "type",
                "uVar1": "status"
            },
            "code": "int copy_data_to_memory_00004dee(int destination, int source, int size, int type) {\n    int status;\n\n    if ((int)((uint16_t)*(uint16_t *)(source + 0xc) << 0x17) < 0) {\n        set_param_to_19(destination, (int)*(int16_t *)(source + 0xe), 0, 2);\n    }\n    *(uint16_t *)(source + 0xc) = *(uint16_t *)(source + 0xc) & 0xefff;\n    status = copy_data_to_memory_00004dee(destination, source, size, type);\n    return status;\n}",
            "called": [
                "FUN_00000e38",
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dee",
            "calling": [],
            "imported": false,
            "current_name": "copy_data_to_memory_00004dee"
        },
        "FUN_00000fec": {
            "renaming": {
                "FUN_00000fec": "initialize_memory_00000fec",
                "param_1": "memory",
                "param_2": "size",
                "PTR_s_FAILED_ASSERTION__00001030": "FAILED_ASSERTION"
            },
            "code": "void initialize_memory_00000fec(uint32_t *memory, uint32_t size) {\n    if ((size & (size - 1)) != 0) {\n        handle_interrupt_and_parse_input_loop(3, PTR_s_FAILED_ASSERTION__00001030);\n    }\n    memory[0] = 0;\n    memory[1] = 0;\n    memory[2] = size - 1;\n    return;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000fec",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "initialize_memory_00000fec"
        },
        "FUN_00000428": {
            "renaming": {
                "FUN_00000428": "check_and_update_param_00000428",
                "*param_1": "*param_ptr",
                "param_2": "new_param_value",
                "uVar1": "interrupt_enabled",
                "local_c": "rel_array_ptr"
            },
            "code": "undefined4 check_and_update_param_00000428(uint32_t *param_ptr, int new_param_value) {\n  undefined4 interrupt_enabled = check_interrupt_enabled();\n  uint32_t rel_array_ptr = *(uint32_t *)PTR_Elf32_Rel_ARRAY_00000484;\n  if ((DAT_00000488 < (uint32_t)(new_param_value + rel_array_ptr)) || ((uint32_t)(new_param_value + rel_array_ptr) < DAT_0000048c)) {\n    *param_ptr = 0xc;\n    rel_array_ptr = 0xffffffff;\n  }\n  else {\n    *(uint32_t *)PTR_Elf32_Rel_ARRAY_00000484 = new_param_value + rel_array_ptr;\n  }\n  enableIRQinterrupts_if_privileged(interrupt_enabled);\n  return rel_array_ptr;\n}",
            "called": [
                "FUN_00000d0c",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000428",
            "calling": [
                "FUN_00004bd0"
            ],
            "imported": false,
            "current_name": "check_and_update_param_00000428"
        },
        "FUN_000039e8": {
            "renaming": {
                "FUN_000039e8": "lookup_sensor_class_000039e8",
                "param_1": "sensor",
                "puVar1": "sensor_class"
            },
            "code": "#define CLASS_UNKNOWN PTR_s_CLASS_UNKNOWN_00003d20\\n#define CLASS_ANY PTR_s_CLASS_ANY_00003d1c\\n#define ACT_SERVO PTR_s_ACT_SERVO_00003ccc\\n#define ACT_MOTOR PTR_s_ACT_MOTOR_00003cd0\\n#define ACT_SWITCH PTR_s_ACT_SWITCH_00003cd4\\n#define ACT_DIMMER PTR_s_ACT_DIMMER_00003cd8\\n#define SENSE_ANY PTR_s_SENSE_ANY_00003cdc\\n#define SENSE_BTN PTR_s_SENSE_BTN_00003ce0\\n#define SENSE_TEMP PTR_s_SENSE_TEMP_00003ce4\\n#define SENSE_HUM PTR_s_SENSE_HUM_00003ce8\\n#define SENSE_LIGHT PTR_s_SENSE_LIGHT_00003cec\\n#define SENSE_ACCEL PTR_s_SENSE_ACCEL_00003cf0\\n#define SENSE_MAG PTR_s_SENSE_MAG_00003cf4\\n#define SENSE_GYRO PTR_s_SENSE_GYRO_00003cf8\\n#define SENSE_COLOR PTR_s_SENSE_COLOR_00003cfc\\n#define SENSE_PRESS PTR_s_SENSE_PRESS_00003d00\\n#define SENSE_ANALOG PTR_s_SENSE_ANALOG_00003d04\\n#define SENSE_UV PTR_s_SENSE_UV_00003d08\\n#define SENSE_OBJTEMP PTR_s_SENSE_OBJTEMP_00003d0c\\n#define SENSE_PULSE_COUNT PTR_s_SENSE_PULSE_COUNT_00003d10\\n#define SENSE_DISTANCE PTR_s_SENSE_DISTANCE_00003d14\\n#define SENSE_CO2 PTR_s_SENSE_CO2_00003d18\\n\\nundefined *lookup_sensor_class_000039e8(char sensor)\\n{\\n    undefined *sensor_class = CLASS_UNKNOWN;\\n    switch(sensor) {\\n        case \"\\0\":\\n            sensor_class = DAT_00003cc0;\\n            break;\\n        case \"@\":\\n            sensor_class = DAT_00003cc4;\\n            break;\\n        case \"B\":\\n            sensor_class = DAT_00003cc8;\\n            break;\\n        case \"C\":\\n            sensor_class = ACT_SERVO;\\n            break;\\n        case \"D\":\\n            sensor_class = ACT_MOTOR;\\n            break;\\n        case \"E\":\\n            sensor_class = ACT_SWITCH;\\n            break;\\n        case \"F\":\\n            sensor_class = ACT_DIMMER;\\n            break;\\n        case -0x80:\\n            sensor_class = SENSE_ANY;\\n            break;\\n        case -0x7f:\\n            sensor_class = SENSE_BTN;\\n            break;\\n        case -0x7e:\\n            sensor_class = SENSE_TEMP;\\n            break;\\n        case -0x7d:\\n            sensor_class = SENSE_HUM;\\n            break;\\n        case -0x7c:\\n            sensor_class = SENSE_LIGHT;\\n            break;\\n        case -0x7b:\\n            sensor_class = SENSE_ACCEL;\\n            break;\\n        case -0x7a:\\n            sensor_class = SENSE_MAG;\\n            break;\\n        case -0x79:\\n            sensor_class = SENSE_GYRO;\\n            break;\\n        case -0x78:\\n            sensor_class = SENSE_COLOR;\\n            break;\\n        case -0x77:\\n            sensor_class = SENSE_PRESS;\\n            break;\\n        case -0x76:\\n            sensor_class = SENSE_ANALOG;\\n            break;\\n        case -0x75:\\n            sensor_class = SENSE_UV;\\n            break;\\n        case -0x74:\\n            sensor_class = SENSE_OBJTEMP;\\n            break;\\n        case -0x73:\\n            sensor_class = SENSE_PULSE_COUNT;\\n            break;\\n        case -0x72:\\n            sensor_class = SENSE_DISTANCE;\\n            break;\\n        case -0x71:\\n            sensor_class = SENSE_CO2;\\n            break;\\n        case \" \": case \"!\": case \"\\\"\": case \"#\": case \"$\": case \"%\": case \"&\": case \"\\\"\": case \"(\": case \")\": case \"*\": case \"+\": case \",\": case \"-\": case \".\": case \"/\": case \"0\": case \"1\": case \"2\": case \"3\": case \"4\": case \"5\": case \"6\": case \"7\": case \"8\": case \"9\": case \":\": case \";\": case \"<\": case \"=\": case \">\": case \"?\": case \"A\": case \"G\": case \"H\": case \"I\": case \"J\": case \"K\": case \"L\": case \"M\": case \"N\": case \"O\": case \"P\": case \"Q\": case \"R\": case \"S\": case \"T\": case \"U\": case \"V\": case \"W\": case \"X\": case \"Y\": case \"Z\": case \"[\": case \"\\\": case \"]\": case \"^\": case \"_\": case \"`\": case \"a\": case \"b\": case \"c\": case \"d\": case \"e\": case \"f\": case \"g\": case \"h\": case \"i\": case \"j\": case \"k\": case \"l\": case \"m\": case \"n\": case \"o\": case \"p\": case \"q\": case \"r\": case \"s\": case \"t\": case \"u\": case \"v\": case \"w\": case \"x\": case \"y\": case \"z\": case \"{\": case \"|\": case \"}\": case \"~\": case \"\\x7f\":\\n            break;\\n        default:\\n            if (sensor == -1) {\\n                return CLASS_ANY;\\n            }\\n    }\\n    return sensor_class;\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000039e8",
            "calling": [
                "FUN_00002f74",
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "lookup_sensor_class_000039e8"
        },
        "FUN_00000e38": {
            "renaming": {
                "FUN_00000e38": "copy_data_to_memory_00000e38",
                "param_1": "destination_address",
                "param_2": "source_address",
                "copy_data_to_memory_000015d0": "memcpy",
                "return": "source_address"
            },
            "code": "int copy_data_to_memory_00000e38(int destination_address, int source_address, int data_size) {\n\tmemcpy(destination_address, source_address, data_size);\n\treturn source_address;\n}",
            "called": [
                "FUN_000015d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e38",
            "calling": [
                "FUN_00004dee"
            ],
            "imported": false,
            "current_name": "copy_data_to_memory_00000e38"
        },
        "FUN_00002294": {
            "renaming": {
                "FUN_00002294": "is_difference_equal_00002294",
                "param_1": "input_param",
                "uVar1": "is_equal",
                "iVar2": "difference",
                "bVar3": "is_equal",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "bool is_difference_equal_00002294(int input_param) {\n  int difference = *(int *)(input_param + 0xc) - *(int *)(input_param + 8);\n  int expected_difference = *(int *)(input_param + 4);\n  bool is_equal = difference == expected_difference;\n  return is_equal;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002294",
            "calling": [
                "FUN_00002364"
            ],
            "imported": false,
            "current_name": "is_difference_equal_00002294"
        },
        "FUN_00003e9e": {
            "renaming": {
                "FUN_00003e9e": "count_and_format_digits_00003e9e",
                "param_1": "num",
                "param_2": "base",
                "param_3": "format",
                "uVar1": "result",
                "count_digits_and_format_output_00003ec4": "count_digits_and_format_output"
            },
            "code": "int count_and_format_digits_00003e9e(int num, int base, int format){\n  int result = count_digits_and_format_output(num, base, format);\n  return result;\n}",
            "called": [
                "FUN_00003ec4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e9e",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "count_and_format_digits_00003e9e"
        },
        "FUN_00003378": {
            "renaming": {
                "FUN_00003378": "process_data_00003378",
                "*param_1": "*data",
                "param_1[5]": "data[5]",
                "param_1[4]": "data[4]",
                "param_1[3]": "data[3]",
                "param_1[2]": "data[2]",
                "param_1[1]": "data[1]"
            },
            "code": "int process_data_00003378(int *data)\n{\n    int value1 = data[5] + 0x76c;\n    int value2 = data[4] + 1;\n    int value3 = data[3];\n    int value4 = data[2];\n    int value5 = data[1];\n    int value6 = *data;\n    execute_function(PTR_s__04i__02i__02i__02i__02i__02i_000033bc, value1, value2, value3, value4, value5, value6);\n    return 0;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003378",
            "calling": [
                "FUN_00003444",
                "FUN_000033c0"
            ],
            "imported": false,
            "current_name": "process_data_00003378",
            "code_backup": "\nundefined4 FUN_00003378(undefined4 *param_1)\n\n{\n  FUN_00004c84(PTR_s__04i__02i__02i__02i__02i__02i_000033bc,param_1[5] + 0x76c,param_1[4] + 1,\n               param_1[3],param_1[2],param_1[1],*param_1);\n  return 0;\n}\n\n"
        },
        "FUN_00006768": {
            "renaming": {
                "FUN_00006768": "process_data_00006768",
                "param_1": "output",
                "param_2": "input",
                "param_3": "input_len",
                "param_4": "key",
                "uVar1": "flags",
                "iVar2": "result",
                "uVar3": "object_size",
                "uVar4": "data_len",
                "uVar5": "data_ptr"
            },
            "code": "int process_data_00006768(uint32_t *output, uint32_t *input, uint32_t input_len, uint32_t key) {\n  uint16_t flags;\n  int result;\n  uint32_t object_size;\n  uint32_t object_ptr;\n  uint16_t data_len;\n  uint32_t data_ptr;\n  uint32_t temp_var;\n  if (output == NULL || input == NULL || input_len == 0) {\n    return -1;\n  }\n  if (input[6] == 0) {\n    initialize_array();\n  }\n  switch ((uint32_t)input[0]) {\n    case 0:\n      if (input[4] == 0) {\n        allocate_and_initialize_object(output, input);\n      }\n      flags = *(uint16_t *)(input + 3);\n      if ((flags & 3) != 0) {\n        *(uint16_t *)(input + 3) = 1;\n        calculate_flagged_items(PTR_DAT_00006874, PTR_LAB_00006754_1_00006878);\n        *(uint16_t *)(input + 3) = flags;\n        if ((flags & 9) == 9) {\n          decode_data(output, input);\n        }\n      }\n      object_size = input[4];\n      object_ptr = input[9];\n      data_len = *(uint16_t *)(input + 3);\n      data_ptr = input[5];\n      result = (*(code *)object_ptr)(output, key, object_size, data_ptr);\n      input[1] = result;\n      if (result >= 0) {\n        flags = flags | 0x20;\n      } else {\n        flags = flags | 0x40;\n        input[1] = 0;\n      }\n      *(uint16_t *)(input + 3) = flags;\n      break;\n    case 1:\n      temp_var = input[2];\n      input[2] = input[3];\n      input[3] = input[4];\n      input[4] = temp_var;\n      result = processData(output, input, input_len, key);\n      break;\n    case 9:\n      flags = *(uint16_t *)(input + 3);\n      flags = flags | 0x40;\n      *(uint16_t *)(input + 3) = flags;\n      result = 0;\n      break;\n    default:\n      result = -1;\n  }\n  return result;\n}",
            "called": [
                "FUN_0000404c",
                "FUN_00005700",
                "FUN_000043a0",
                "FUN_00004158",
                "FUN_00004b34",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006768",
            "calling": [
                "FUN_00005e10"
            ],
            "imported": false,
            "current_name": "process_data_00006768"
        },
        "FUN_00000db0": {
            "renaming": {
                "FUN_00000db0": "initialize_data_and_clear_value_at_offset_00000db0",
                "set_data_00000dcc": "initialize_data",
                "clearValueAtOffset_00000d9c": "clear_value_at_offset"
            },
            "code": "void initialize_data_and_clear_value_at_offset_00000db0(void)\n{\n  initialize_data();\n  clear_value_at_offset();\n  return;\n}",
            "called": [
                "FUN_00000dcc",
                "FUN_00000d9c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000db0",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "initialize_data_and_clear_value_at_offset_00000db0"
        },
        "FUN_00002600": {
            "renaming": {
                "FUN_00002600": "process_and_set_flag_00002600",
                "param_1": "input",
                "uVar1": "processed_input",
                "FUN_000047e4": "process_input",
                "set_flag_and_value_0000285c": "set_flag_and_value"
            },
            "code": "int process_and_set_flag_00002600(int input){\n  int processed_input = process_input(input);\n  set_flag_and_value(processed_input);\n  return 0;\n}",
            "called": [
                "FUN_0000285c",
                "FUN_000047e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002600",
            "calling": [
                "FUN_00003478"
            ],
            "imported": false,
            "current_name": "process_and_set_flag_00002600"
        },
        "FUN_00003810": {
            "renaming": {
                "FUN_00003810": "get_label_00003810",
                "param_1": "label_num",
                "puVar1": "label",
                "PTR_LAB_00003914": "default_label",
                "PTR_LAB_000038cc": "label_2",
                "PTR_LAB_000038d0": "label_3",
                "PTR_LAB_000038d4": "label_4",
                "PTR_LAB_000038d8": "label_5",
                "PTR_LAB_000038dc": "label_6",
                "PTR_LAB_000038e0": "label_7",
                "PTR_LAB_000038e4": "label_8",
                "PTR_LAB_000038e8": "label_9",
                "PTR_LAB_000038ec": "label_10",
                "PTR_LAB_000038f0": "label_11",
                "PTR_LAB_000038f4": "label_12",
                "PTR_LAB_000038f8": "label_13",
                "PTR_LAB_000038fc": "label_14",
                "PTR_LAB_00003900": "label_15",
                "PTR_LAB_00003904": "label_16",
                "PTR_LAB_0000390c": "label_17",
                "PTR_LAB_00003910": "label_19",
                "PTR_LAB_00003908": "label_21"
            },
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* get_label_00003810(int label_num) {\n    char* label = NULL;\n    switch(label_num) {\n        case 2:\n            label = PTR_LAB_000038cc;\n            break;\n        case 3:\n            label = PTR_LAB_000038d0;\n            break;\n        case 4:\n            label = PTR_LAB_000038d4;\n            break;\n        case 5:\n            label = PTR_LAB_000038d8;\n            break;\n        case 6:\n            label = PTR_LAB_000038dc;\n            break;\n        case 7:\n            label = PTR_LAB_000038e0;\n            break;\n        case 8:\n            label = PTR_LAB_000038e4;\n            break;\n        case 9:\n            label = PTR_LAB_000038e8;\n            break;\n        case 10:\n            label = PTR_LAB_000038ec;\n            break;\n        case 11:\n            label = PTR_LAB_000038f0;\n            break;\n        case 12:\n            label = PTR_LAB_000038f4;\n            break;\n        case 13:\n            label = PTR_LAB_000038f8;\n            break;\n        case 14:\n            label = PTR_LAB_000038fc;\n            break;\n        case 15:\n            label = PTR_LAB_00003900;\n            break;\n        case 16:\n            label = PTR_LAB_00003904;\n            break;\n        case 17:\n            label = PTR_LAB_0000390c;\n            break;\n        case 19:\n            label = PTR_LAB_00003910;\n            break;\n        case 21:\n            label = PTR_LAB_00003908;\n            break;\n        default:\n            label = PTR_LAB_00003914;\n            break;\n    }\n    return label;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003810",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "get_label_00003810"
        },
        "FUN_00000ed8": {
            "renaming": {
                "FUN_00000ed8": "execute_function_with_pointer_00000ed8",
                "in_lr": "saved_register",
                "PTR_DAT_00000ef4": "PTR_FUNTION_POINTER",
                "FUN_00004c84": "execute_function_with_pointer_and_register"
            },
            "code": "void execute_function_with_pointer_00000ed8(void)\n{\n  undefined4 saved_register;\n  execute_function_with_pointer_00000ed8_and_register(PTR_DAT_00000ef4, saved_register);\n  return;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ed8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "execute_function_with_pointer_00000ed8",
            "code_backup": "\nvoid FUN_00000ed8(void)\n\n{\n  undefined4 in_lr;\n  \n  FUN_00004c84(PTR_DAT_00000ef4,in_lr);\n  return;\n}\n\n"
        },
        "FUN_000031e0": {
            "renaming": {
                "FUN_000031e0": "playAlarm_000031e0",
                "FUN_00004db8": "ringAlarm",
                "PTR_s_The_alarm_rang_000031f8": "s_The_alarm_rang"
            },
            "code": "void playAlarm_000031e0(void)\n{\n  ringAlarm(PTR_s_The_alarm_rang_000031f8);\n  return;\n}",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031e0",
            "calling": [],
            "imported": false,
            "current_name": "playAlarm_000031e0",
            "code_backup": "\nvoid FUN_000031e0(void)\n\n{\n  FUN_00004db8(PTR_s_The_alarm_rang_000031f8);\n  return;\n}\n\n"
        },
        "FUN_000020f4": {
            "renaming": {
                "FUN_000020f4": "extractBitsAndCallFunctions_000020f4",
                "DAT_00002104": "data",
                "extract_bits_and_call_functions_00002028": "extract_bits_and_call_functions",
                "PTR_": "PTR_ (no change)"
            },
            "code": "void extractBitsAndCallFunctions_000020f4(void)\n{\n  int DAT_00002104 = DAT_00002104;\n  int numBits = 3;\n  extract_bits_and_call_functions_00002028(DAT_00002104, numBits);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020f4",
            "calling": [],
            "imported": false,
            "current_name": "extractBitsAndCallFunctions_000020f4"
        },
        "FUN_0000687c": {
            "renaming": {
                "FUN_0000687c": "decode_input_0000687c",
                "param_1": "input_length",
                "param_2": "input_data",
                "pbVar1": "decoded_data",
                "uVar2": "range_start",
                "iVar3": "i",
                "uVar4": "current_byte",
                "uVar5": "next_byte",
                "uVar6": "range_end",
                "bVar7": "is_caret"
            },
            "code": "byte* decode_input_0000687c(int input_length, byte* input_data) {\n    byte* decoded_data = input_data;\n    uint current_byte = (uint)*input_data;\n    bool is_caret = current_byte == 0x5e;\n    if (is_caret) {\n        current_byte = (uint)input_data[1];\n        decoded_data += 2;\n    }\n    else {\n        decoded_data += 1;\n    }\n    int decoded_length = input_length + 0xfe;\n    for (int i = input_length - 1; i < decoded_length; i++) {\n        *(bool*)i = is_caret;\n    }\n    if (current_byte == 0) {\n        return decoded_data - 1;\n    }\n    else {\n        while (true) {\n            uint next_byte = current_byte;\n            *(bool*)(input_length + next_byte) = !is_caret;\n            decoded_data += 1;\n            while (true) {\n                current_byte = (uint)decoded_data[-1];\n                if (current_byte != 0x2d) {\n                    break;\n                }\n                uint range_end = (uint)*decoded_data;\n                if (range_end == 0x5d || range_end < next_byte) {\n                    goto LAB_000068aa;\n                }\n                for (uint j = next_byte + 1; j <= range_end; j++) {\n                    *(bool*)(input_length + j) = !is_caret;\n                }\n                int range_length = range_end - next_byte;\n                if (range_end <= next_byte) {\n                    range_length = 0;\n                }\n                next_byte = next_byte + 1 + range_length;\n                decoded_data += 2;\n            }\n            return decoded_data - 1;\n        LAB_000068aa:\n            current_byte = (uint)decoded_data[-1];\n            if (current_byte == 0x5d || current_byte == 0) {\n                return decoded_data;\n            }\n            decoded_data -= 1;\n        }\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000687c",
            "calling": [
                "FUN_0000656c",
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "decode_input_0000687c"
        },
        "FUN_00005edc": {
            "renaming": {
                "FUN_00005edc": "parse_integer_00005edc",
                "param_1": "out_result",
                "param_2": "input_str",
                "param_3": "end_ptr",
                "param_4": "base",
                "uVar1": "digit_value",
                "uVar2": "char_value",
                "bVar3": "is_hex",
                "iVar4": "parse_error",
                "uVar5": "temp_value",
                "uVar6": "max_value",
                "pbVar7": "current_char",
                "pbVar8": "next_char",
                "*param_1": "*out_result",
                "PTR_DAT_00005fd0": "DIGIT_VALUES",
                "UINT_MAX": "4294967295",
                "isspace": "isspace",
                "isdigit": "isdigit",
                "isalnum": "isalnum",
                "toupper": "toupper"
            },
            "code": "uint parse_integer_00005edc(undefined4 *out_result, byte *input_str, byte **end_ptr, uint base) {\n  uint digit_value;\n  uint result = 0;\n  int sign = 1;\n  byte *current_char = input_str;\n  uint max_value = UINT_MAX / base;\n  while (isspace(*current_char)) {\n    current_char++;\n  }\n  if (*current_char == '-') {\n    sign = -1;\n    current_char++;\n  }\n  else if (*current_char == '+') {\n    current_char++;\n  }\n  if (base == 0) {\n    if (*current_char != '0') {\n      base = 10;\n    }\n    else if (toupper(current_char[1]) == 'X') {\n      base = 16;\n      current_char += 2;\n    }\n    else {\n      base = 8;\n    }\n  }\n  while (isalnum(*current_char)) {\n    if (isdigit(*current_char)) {\n      digit_value = *current_char - '0';\n    }\n    else {\n      digit_value = toupper(*current_char) - 'A' + 10;\n    }\n    if (digit_value >= base) {\n      break;\n    }\n    if (result > max_value || (result == max_value && digit_value > UINT_MAX % base)) {\n      *out_result = 0;\n      return UINT_MAX;\n    }\n    result = result * base + digit_value;\n    current_char++;\n  }\n  *out_result = sign * result;\n  if (end_ptr != NULL) {\n    *end_ptr = current_char;\n  }\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005edc",
            "calling": [
                "FUN_00005fd8"
            ],
            "imported": false,
            "current_name": "parse_integer_00005edc"
        },
        "FUN_00001eea": {
            "renaming": {
                "FUN_00001eea": "updateMemoryAndFlags_00001eea",
                "param_1": "address",
                "param_2": "value",
                "uVar1": "lower_6_bits",
                "iVar2": "flagged_value_ptr",
                "iVar3": "memory_address_ptr",
                "extract_lower_6_bits_00001dc0": "extractLower6Bits",
                "getFlaggedValue_00001d80": "getFlaggedValuePtr",
                "getMemoryAddress_00001d5e": "getMemoryAddressPtr"
            },
            "code": "int updateMemoryAndFlags_00001eea(uint16_t address, uint8_t value) {\n  uint8_t lower_6_bits = extractLower6Bits(address);\n  uint32_t* flagged_value_ptr = getFlaggedValuePtr(address);\n  uint32_t* memory_address_ptr = getMemoryAddressPtr(address);\n  \n  if (value < 0) {\n    *flagged_value_ptr |= 1 << (lower_6_bits & 0xff);\n  } else {\n    *flagged_value_ptr &= ~(1 << (lower_6_bits & 0xff));\n  }\n  \n  *(memory_address_ptr + lower_6_bits) = value & 0x23 | 0x100;\n  return 0;\n}",
            "called": [
                "FUN_00001f80",
                "FUN_00001d80",
                "FUN_00001dc0",
                "FUN_00001d5e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001eea",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "updateMemoryAndFlags_00001eea"
        },
        "FUN_000023a4": {
            "renaming": {
                "FUN_000023a4": "handle_interrupt_and_parse_input_loop_000023a4",
                "auStack_88": "input_buffer",
                "FUN_00004db8": "initialize_memory",
                "uRam000023c4": "memory_address",
                "process_input_loop_and_parse_args_00002e6c": "process_input_loop_and_parse_args",
                "uVar1": "result",
                "software_interrupt": "generate_software_interrupt"
            },
            "code": "int handle_interrupt_and_parse_input_loop_000023a4(void)\n{\n  int result;\n  char input_buffer[128];\n  handle_interrupt(0);\n  initialize_memory(uRam000023c4);\n  result = process_input_loop_and_parse_args(0, input_buffer, 0x80);\n  generate_software_interrupt(0x3f);\n  return result;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_000023d0",
                "FUN_00002e6c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023a4",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "handle_interrupt_and_parse_input_loop_000023a4"
        },
        "FUN_0000240c": {
            "renaming": {
                "FUN_0000240c": "get_next_node_0000240c",
                "param_1": "current_node",
                "puVar1": "next_node_ptr"
            },
            "code": "undefined4 *get_next_node_0000240c(undefined4 *current_node)\n{\n  undefined4 *next_node_ptr;\n  next_node_ptr = (undefined4 *)*current_node;\n  if (next_node_ptr != (undefined4 *)0x0) {\n    *current_node = *next_node_ptr;\n  }\n  return next_node_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000240c",
            "calling": [
                "FUN_000024bc"
            ],
            "imported": false,
            "current_name": "get_next_node_0000240c"
        },
        "FUN_00004280": {
            "renaming": {
                "FUN_00004280": "do_nothing_with_pointer_00004280",
                "PTR_DAT_00004288": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_00004280(void)\n{\n  do_nothing(PTR_DAT_00004288);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004280",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00004280"
        },
        "FUN_00001448": {
            "renaming": {
                "FUN_00001448": "updateMemoryValues_00001448",
                "param_1": "index",
                "value1": "memory_value_1",
                "value2": "memory_value_2",
                "updateMemoryValueFromParam_00001f80": "updateMemoryValueFromParam",
                "PTR_DAT_000014c0": "memory_data_pointer"
            },
            "code": "void updateMemoryValues_00001448(int index)\n{\n  short value1 = *(short *)(PTR_DAT_000014c0 + index * 0x20 + 8);\n  short value2 = *(short *)(PTR_DAT_000014c0 + index * 0x20 + 10);\n  if (value1 != -1) {\n    int memoryValue1 = *(int *)(PTR_DAT_000014c0 + index * 0x20 + 0xc);\n    updateMemoryValueFromParam_00001f80(value1, memoryValue1);\n  }\n  if (value2 != -1) {\n    int memoryValue2 = *(int *)(PTR_DAT_000014c0 + index * 0x20 + 0x10);\n    updateMemoryValueFromParam_00001f80(value2, memoryValue2);\n  }\n  return;\n}",
            "called": [
                "FUN_00001f80"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001448",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "updateMemoryValues_00001448"
        },
        "FUN_00001688": {
            "renaming": {
                "FUN_00001688": "call_check_function_00001688",
                "check_and_call_function_00001628": "check_and_call_function"
            },
            "code": "void call_check_function_00001688(void)\n{\n  check_and_call_function(0);\n  return;\n}",
            "called": [
                "FUN_00001628"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001688",
            "calling": [],
            "imported": false,
            "current_name": "call_check_function_00001688"
        },
        "FUN_00004042": {
            "renaming": {
                "FUN_00004042": "parse_string_and_convert_to_unsigned_int_00004042",
                "param_1": "input_string"
            },
            "code": "void parse_string_and_convert_to_unsigned_int_00004042(const char* input_string){\n    parseStringToUnsignedInt_00004f84(input_string, 0, 10);\n    return;\n}",
            "called": [
                "FUN_00004f84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004042",
            "calling": [
                "FUN_0000305c",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "parse_string_and_convert_to_unsigned_int_00004042"
        },
        "FUN_00000cf0": {
            "renaming": {
                "FUN_00000cf0": "is_interrupt_enabled_00000cf0",
                "uVar2": "is_enabled",
                "bVar1": "is_privileged_mode"
            },
            "code": "bool is_interrupt_enabled_00000cf0(void)\n{\n  bool is_privileged_mode = isCurrentModePrivileged();\n  bool is_enabled = false;\n  if (is_privileged_mode) {\n    is_enabled = isIRQinterruptsEnabled();\n  }\n  return is_enabled;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cf0",
            "calling": [
                "FUN_00000930"
            ],
            "imported": false,
            "current_name": "is_interrupt_enabled_00000cf0"
        },
        "FUN_00000f8c": {
            "renaming": {
                "FUN_00000f8c": "handle_interrupt_and_initialize_00000f8c",
                "uVar1": "interruptEnabledFlag",
                "puVar2": "taskMemoryPointer",
                "uVar3": "taskIndex",
                "iStack_24": "stackVariable1",
                "piStack_20": "stackVariable2",
                "uStack_1c": "stackVariable3",
                "local_10": "localVariable1",
                "local_14": "localVariable2",
                "local_18": "localVariable3",
                "create_new_task_000010d4": "create_new_task",
                "run_interrupt_handler_00000930": "run_interrupt_handler",
                "handle_interrupt_and_parse_input_loop_00000f04": "handle_interrupt_and_parse_input_loop",
                "PTR_s_FAILED_ASSERTION__00001030": "FAILED_ASSERTION_STRING",
                "puRam00000fd4": "globalVariable1",
                "uRam00000fd8": "globalVariable2",
                "uRam00000fdc": "globalVariable3",
                "puRam00000fe0": "globalVariable4",
                "uRam00000fe4": "globalVariable5",
                "uRam00000fe8": "globalVariable6"
            },
            "code": "void handle_interrupt_and_initialize_00000f8c(void)\n{\n  uint interruptEnabledFlag;\n  undefined4 *taskMemoryPointer;\n  uint taskIndex;\n  int stackVariable1;\n  int *stackVariable2;\n  undefined4 stackVariable3;\n  undefined4 localVariable1;\n  undefined4 localVariable2;\n  undefined4 localVariable3;\n  check_interrupt_enabled();\n  localVariable3 = *globalVariable1;\n  localVariable2 = 0;\n  localVariable1 = globalVariable2;\n  create_new_task(globalVariable3,0x100,0xf,0xc);\n  localVariable3 = *globalVariable4;\n  localVariable2 = 0;\n  localVariable1 = globalVariable5;\n  taskIndex = 0xc;\n  create_new_task(globalVariable6,0x600,7);\n  stackVariable3 = 0xfd3;\n  interruptEnabledFlag = run_interrupt_handler();\n  interruptEnabledFlag = interruptEnabledFlag >> 0x1e;\n  taskMemoryPointer = (undefined4 *)(taskIndex * 0x100);\n  stackVariable1 = (taskIndex >> 0x1d) << 0x11;\n  stackVariable2 = &stackVariable1;\n  if ((interruptEnabledFlag & interruptEnabledFlag - 1) != 0) {\n    handle_interrupt_and_parse_input_loop(3,PTR_s_FAILED_ASSERTION__00001030);\n  }\n  *taskMemoryPointer = 0;\n  taskMemoryPointer[1] = 0;\n  taskMemoryPointer[2] = interruptEnabledFlag - 1;\n  return;\n}",
            "called": [
                "FUN_000010d4",
                "FUN_00000930",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f8c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "handle_interrupt_and_initialize_00000f8c"
        },
        "FUN_00002894": {
            "renaming": {
                "FUN_00002894": "set_memory_00002894",
                "param_1": "value_to_set",
                "param_2": "param_3",
                "param_3": "PARAM_2_ADDRESS",
                "DAT_000028e8": "DATA_SECTION_START",
                "PTR_DAT_000028ec": "PARAM_1_ADDRESS"
            },
            "code": "void set_memory_00002894(int value_to_set, int address, int param_3){\n  int data_address = DAT_000028e8;\n  int bitmask = 0xfffffffb;\n  int index = 0x2e;\n  \n  *(uint *)(data_address + 0x1c) &= bitmask;\n  *(int *)(data_address + 8) = address - 1;\n  *(int *)PTR_DAT_000028ec = value_to_set;\n  *(int *)PARAM_2_ADDRESS = param_3;\n  *(uint *)(data_address + 0x1c) |= 4;\n  \n  write_to_memory(index, 10);\n  set_bit_in_array(index);\n  return;\n}",
            "called": [
                "FUN_00002744",
                "FUN_00002714"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002894",
            "calling": [
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "set_memory_00002894"
        },
        "FUN_00004158": {
            "renaming": {
                "FUN_00004158": "processData_00004158",
                "param_1": "dataPtr",
                "param_2": "bufferPtr",
                "uVar1": "result",
                "PTR_DAT_000041c4": "originalBufferPtr1",
                "PTR_DAT_000041c8": "originalBufferPtr2",
                "PTR_DAT_000041cc": "originalBufferPtr3",
                "FUN_000042a4": "callFunctionA",
                "do_nothing_000045e8": "doNothing1",
                "do_nothing_000045ec": "doNothing2"
            },
            "code": "int processData_00004158(int dataPtr, char *bufferPtr) {\n  int result;\n  int *bufferLengthPtr = (int *)(bufferPtr + 0x10);\n  int *dataLengthPtr = (int *)(dataPtr + 0x18);\n  \n  if (*bufferLengthPtr != 0) {\n    if ((dataPtr != 0) && (*dataLengthPtr == 0)) {\n      callFunctionA();\n    }\n    \n    if (bufferPtr == PTR_DAT_000041c4) {\n      bufferPtr = *(char **)(dataPtr + 4);\n    }\n    else if (bufferPtr == PTR_DAT_000041c8) {\n      bufferPtr = *(char **)(dataPtr + 8);\n    }\n    else if (bufferPtr == PTR_DAT_000041cc) {\n      bufferPtr = *(char **)(dataPtr + 0xc);\n    }\n    \n    short *bufferLengthShortPtr = (short *)(bufferPtr + 0xc);\n    int *dataFlagPtr = (int *)(bufferPtr + 100);\n    \n    if (*bufferLengthShortPtr != 0) {\n      if ((*dataFlagPtr >= 0) && (*bufferLengthShortPtr >= 0)) {\n        doNothing1(*(int *)(bufferPtr + 0x58));\n      }\n      result = decodeData(dataPtr, bufferPtr);\n      \n      if (*dataFlagPtr < 0) {\n        return result;\n      }\n      if (*bufferLengthShortPtr < 0) {\n        return result;\n      }\n      doNothing2(*(int *)(bufferPtr + 0x58));\n      return result;\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_0000404c",
                "FUN_000045e8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004158",
            "calling": [
                "FUN_00005404",
                "FUN_00006768",
                "FUN_000041d0"
            ],
            "imported": false,
            "current_name": "processData_00004158",
            "code_backup": "\nundefined4 FUN_00004158(int param_1,undefined *param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (*(int *)(param_2 + 0x10) != 0) {\n    if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n      FUN_000042a4();\n    }\n    if (param_2 == PTR_DAT_000041c4) {\n      param_2 = *(undefined **)(param_1 + 4);\n    }\n    else if (param_2 == PTR_DAT_000041c8) {\n      param_2 = *(undefined **)(param_1 + 8);\n    }\n    else if (param_2 == PTR_DAT_000041cc) {\n      param_2 = *(undefined **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 0xc) != 0) {\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) && (-1 < (int)*(short *)(param_2 + 0xc) << 0x16)) {\n        do_nothing_000045e8(*(undefined4 *)(param_2 + 0x58));\n      }\n      uVar1 = decode_data_0000404c(param_1,param_2);\n      if (*(int *)(param_2 + 100) << 0x1f < 0) {\n        return uVar1;\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x16) < 0) {\n        return uVar1;\n      }\n      do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n"
        },
        "FUN_00002654": {
            "renaming": {
                "FUN_00002654": "execute_function_00002654",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "uVar1": "result",
                "FUN_000047e4": "get_result",
                "PTR_DAT_00002688": "PTR_EXECUTE_FUNTION",
                "set_memory_00002894": "set_memory",
                "PTR_execute_function_if_initialized_000026f0_1_0000268c": "PTR_EXECUTE_FUNTION_IF_INITIALIZED"
            },
            "code": "int execute_function_00002654(unsigned int param1, unsigned int param2, unsigned int param3) {\n    unsigned int result = get_result(param1);\n    *(unsigned int*)PTR_DAT_00002688 = param2;\n    set_memory(result, PTR_execute_function_00002654_if_initialized_000026f0_1_0000268c, param3);\n    return 0;\n}",
            "called": [
                "FUN_00002894",
                "FUN_000047e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002654",
            "calling": [
                "FUN_000033f4"
            ],
            "imported": false,
            "current_name": "execute_function_00002654"
        },
        "FUN_00002538": {
            "renaming": {
                "FUN_00002538": "set_data_00002538",
                "param_1": "address",
                "param_2": "data",
                "DAT_00002584": "data_array1",
                "DAT_00002588": "data_array2"
            },
            "code": "void set_data_00002538(byte address, uint data){\n    if (address < 0) {\n        *(char *)((address & 0xf) + DAT_00002584 + 0x14) = (char)((data & 0xff) << 4);\n    }\n    else {\n        *(char *)((char)address + DAT_00002588 + 0x300) = (char)((data & 0xff) << 4);\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002538",
            "calling": [
                "FUN_0000258c"
            ],
            "imported": false,
            "current_name": "set_data_00002538"
        },
        "FUN_00004c84": {
            "renaming": {
                "FUN_00004c84": "process_data_00004c84",
                "param_1": "data_1",
                "param_2": "data_2",
                "param_3": "data_3",
                "param_4": "data_4",
                "iVar1": "ptr_i",
                "uVar2": "arg_1",
                "uStack_c": "arg_2",
                "uStack_8": "arg_3",
                "uStack_4": "arg_4",
                "*DAT_00004cb0": "*PTR_00004cb0",
                "FUN_000042a4": "clean_data",
                "FUN_000057f8": "process_data_2"
            },
            "code": "void process_data_00004c84(undefined4 data_1, undefined4 data_2, undefined4 data_3, undefined4 data_4)\n{\n  int* ptr_i = *DAT_00004cb0;\n  undefined4 arg_1 = data_1;\n  undefined4 arg_2 = data_2;\n  undefined4 arg_3 = data_3;\n  undefined4 arg_4 = data_4;\n  if ((ptr_i != 0) && (*(int *)(ptr_i + 0x18) == 0)) {\n    clean_data(ptr_i);\n  }\n  process_data_00004c84_2(ptr_i, *(undefined4 *)(ptr_i + 8), data_1, &arg_2, arg_1, &arg_2);\n  return;\n}\n",
            "called": [
                "FUN_000057f8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004c84",
            "calling": [
                "FUN_00002b10",
                "FUN_00002a88",
                "FUN_00000f04",
                "FUN_00002ecc",
                "FUN_00002fe0",
                "FUN_0000316c",
                "FUN_00003694",
                "FUN_00003378",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00003524",
                "FUN_0000211c",
                "FUN_00000ed8"
            ],
            "imported": false,
            "current_name": "process_data_00004c84",
            "code_backup": "\nvoid FUN_00004c84(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  iVar1 = *DAT_00004cb0;\n  uVar2 = param_1;\n  uStack_c = param_2;\n  uStack_8 = param_3;\n  uStack_4 = param_4;\n  if ((iVar1 != 0) && (*(int *)(iVar1 + 0x18) == 0)) {\n    FUN_000042a4(iVar1);\n  }\n  FUN_000057f8(iVar1,*(undefined4 *)(iVar1 + 8),param_1,&uStack_c,uVar2,&uStack_c);\n  return;\n}\n\n"
        },
        "FUN_0000305c": {
            "renaming": {
                "FUN_0000305c": "write_data_to_device_0000305c",
                "param_1": "num_params",
                "param_2": "params",
                "uVar1": "data_element",
                "auStack_20": "data",
                "local_18": "num_data_params",
                "local_14": "device_index",
                "local_10": "parsed_device_id",
                "local_c": "i",
                "PTR_s_usage___s__s__device_id___value_0_00003154": "usage_error_message",
                "parse_string_and_convert_to_unsigned_int_00004042": "parse_string_to_unsigned_int",
                "find_nth_element_00003d24": "get_device_index",
                "FUN_00004db8": "output_error_message",
                "memset": "initialize_array",
                "process_data": "output_data_message",
                "display_object_data_00003694": "display_object_data",
                "execute_function_00003d94": "write_data_to_device_index",
                "PTR_s_error__undefined_device_given_00003158": "undefined_device_error_message",
                "PTR_s_Writing_to_device___i____s_0000315c": "writing_to_device_message",
                "PTR_s_error__device___i_is_not_writabl_00003160": "device_not_writable_error_message",
                "PTR_s_error__failure_to_write_to_devic_00003164": "write_failure_error_message",
                "PTR_s_data_successfully_written_to_dev_00003168": "write_success_message"
            },
            "code": "void write_data_to_device_0000305c(int num_params, undefined4 *params)\n{\n  undefined2 data[4];\n  uint num_data_params;\n  int device_id;\n  undefined4 parsed_device_id;\n  int device_index;\n  uint i;\n  uint max_data_params = 5;\n  int write_result;\n  if (num_params < 4) {\n    process_data(PTR_s_usage___s__s__device_id___value_0_00003154, *params, params[1]);\n  }\n  else {\n    parsed_device_id = parse_string_and_convert_to_unsigned_int_00004042(params[2]);\n    device_index = find_nth_element_00003d24(parsed_device_id);\n    if (device_index == 0) {\n      process_input_00004db8(PTR_s_error__undefined_device_given_00003158);\n    }\n    else {\n      memset(data, 0, sizeof(data));\n      if (num_params > max_data_params) {\n        num_data_params = max_data_params + 1;\n      }\n      else {\n        num_data_params = num_params;\n      }\n      for (i = 0; i < num_data_params - 3; i++) {\n        data[i] = parse_string_and_convert_to_unsigned_int_00004042(params[i + 3]);\n      }\n      process_data(PTR_s_Writing_to_device___i____s_0000315c, parsed_device_id, *(undefined4 *)(device_index + 8));\n      display_object_data_00003694(data, num_data_params & 0xff);\n      write_result = execute_function_00003d94(device_index, data);\n      if (write_result < 1) {\n        if (write_result == -0x86) {\n          process_data(PTR_s_error__device___i_is_not_writabl_00003160, parsed_device_id);\n        }\n        else {\n          process_data(PTR_s_error__failure_to_write_to_devic_00003164, parsed_device_id);\n        }\n      }\n      else {\n        process_data(PTR_s_data_successfully_written_to_dev_00003168, parsed_device_id);\n      }\n    }\n  }\n}\n",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00003d94",
                "FUN_00003d24",
                "FUN_00003694",
                "FUN_00004042",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000305c",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "write_data_to_device_0000305c"
        },
        "FUN_000012b4": {
            "renaming": {
                "FUN_000012b4": "checkAndUpdate_000012b4",
                "param_1": "linkedListIndex",
                "param_2": "data",
                "uVar1": "updatedValue"
            },
            "code": "int checkAndUpdate_000012b4(int linkedListIndex, undefined data){\n  int difference = linkedListIndex + 4;\n  int updatedValue = check_difference_and_update_00002364(difference, data);\n  processLinkedList_000024bc(linkedListIndex);\n  return updatedValue;\n}",
            "called": [
                "FUN_000024bc",
                "FUN_00002364"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012b4",
            "calling": [],
            "imported": false,
            "current_name": "checkAndUpdate_000012b4"
        },
        "FUN_00005b34": {
            "renaming": {
                "FUN_00005b34": "convert_and_print_data_00005b34",
                "param_1": "data_type",
                "param_2": "data",
                "param_3": "length",
                "param_4": "print_function",
                "param_5": "data_pointer",
                "bVar1": "is_greater",
                "bVar2": "data_byte",
                "puVar3": "hex_digits",
                "iVar4": "conversion_result",
                "pcVar5": "return_value",
                "iVar6": "print_result",
                "puVar7": "print_buffer",
                "uVar8": "value",
                "puVar9": "data_pointer_value",
                "uVar10": "base",
                "uVar12": "data_length",
                "puVar13": "print_buffer_current",
                "local_24": "conversion_buffer"
            },
            "code": "\ncode * convert_and_print_data_00005b34(undefined4 data_type,uint *data,undefined4 length,code *print_function,uint **data_pointer\n                   )\n\n{\n  bool is_greater;\n  byte data_byte;\n  undefined *hex_digits;\n  int conversion_result;\n  code *return_value;\n  int print_result;\n  undefined *print_buffer;\n  uint value;\n  uint *data_pointer_value;\n  uint base;\n  uint **ppuVar11;\n  uint data_length;\n  undefined *print_buffer_current;\n  code *conversion_buffer;\n  \n  hex_digits = PTR_s_0123456789ABCDEF_00005d78;\n  data_byte = *(byte *)(data + 6);\n  print_buffer = (undefined *)((int)data + 0x43);\n  conversion_buffer = print_function;\n  if (0x78 < data_byte) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)data + 0x42) = data_byte;\nLAB_00005bdc:\n    print_buffer = (undefined *)((int)data + 0x42);\n    value = 1;\nLAB_00005d28:\n    data[4] = value;\n    *(undefined *)((int)data + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (data_byte < 99) {\n    if (data_byte == 0) goto LAB_00005d06;\n    if (data_byte == 0x58) {\n      *(undefined *)((int)data + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(data_byte) {\n  case 99:\n    value = **data_pointer;\n    *data_pointer = *data_pointer + 1;\n    *(char *)((int)data + 0x42) = (char)value;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    base = *data;\n    data_pointer_value = *data_pointer;\n    if ((int)(base << 0x18) < 0) {\n      value = *data_pointer_value;\n      *data_pointer = data_pointer_value + 1;\n    }\n    else {\n      value = *data_pointer_value;\n      *data_pointer = data_pointer_value + 1;\n      if ((base & 0x40) != 0) {\n        value = (uint)(short)value;\n      }\n    }\n    if ((int)value < 0) {\n      value = -value;\n      *(undefined *)((int)data + 0x43) = 0x2d;\n    }\n    base = 10;\n    hex_digits = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*data_pointer;\n    base = *data;\n    value = data[5];\n    *data_pointer = (uint *)(ppuVar11 + 1);\n    data_pointer_value = *ppuVar11;\n    if (((int)(base << 0x18) < 0) || (-1 < (int)(base << 0x19))) {\n      *data_pointer_value = value;\n    }\n    else {\n      *(short *)data_pointer_value = (short)value;\n    }\nLAB_00005d06:\n    data[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    data_pointer_value = *data_pointer;\n    value = *data;\n    *data_pointer = data_pointer_value + 1;\n    if (((int)(value << 0x18) < 0) || (-1 < (int)(value << 0x19))) {\n      value = *data_pointer_value;\n    }\n    else {\n      value = (uint)*(ushort *)data_pointer_value;\n    }\n    hex_digits = PTR_s_0123456789ABCDEF_00005d78;\n    if (data_byte == 0x6f) {\n      base = 8;\n    }\n    else {\n      base = 10;\n    }\n    break;\n  case 0x70:\n    *data = *data | 0x20;\n  case 0x78:\n    hex_digits = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)data + 0x45) = 0x78;\nLAB_00005ca8:\n    base = *data;\n    value = **data_pointer;\n    *data_pointer = *data_pointer + 1;\n    if ((-1 < (int)(base << 0x18)) && ((int)(base << 0x19) < 0)) {\n      value = value & 0xffff;\n    }\n    if ((int)(base << 0x1f) < 0) {\n      *data = base | 0x20;\n    }\n    if (value == 0) {\n      *data = *data & 0xffffffdf;\n    }\n    base = 0x10;\n    break;\n  case 0x73:\n    data_pointer_value = *data_pointer;\n    *data_pointer = data_pointer_value + 1;\n    print_buffer = (undefined *)*data_pointer_value;\n    conversion_result = find_byte_sequence_00006010(print_buffer,0,data[1],data_pointer_value,data_type,data,length);\n    if (conversion_result != 0) {\n      data[1] = conversion_result - (int)print_buffer;\n    }\n    value = data[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)data + 0x43) = 0;\nLAB_00005c36:\n  data_length = data[1];\n  data[2] = data_length;\n  if (-1 < (int)data_length) {\n    *data = *data & 0xfffffffb;\n  }\n  print_buffer_current = print_buffer;\n  if ((value != 0) || (data_length != 0)) {\n    do {\n      print_buffer_current = print_buffer_current + -1;\n      *print_buffer_current = hex_digits[value - base * (value / base)];\n      is_greater = base <= value;\n      value = value / base;\n    } while (is_greater);\n  }\n  if (((base == 8) && ((int)(*data << 0x1f) < 0)) && ((int)data[1] <= (int)data[4])) {\n    print_buffer_current[-1] = 0x30;\n    print_buffer_current = print_buffer_current + -1;\n  }\n  data[4] = (int)print_buffer - (int)print_buffer_current;\n  print_buffer = print_buffer_current;\nLAB_00005c84:\n  conversion_result = convert_data_to_string_00005a58(data_type,data,&conversion_buffer,length,print_function);\n  if ((conversion_result == -1) || (conversion_result = (*print_function)(data_type,length,print_buffer,data[4]), conversion_result == -1)) {\nLAB_00005c98:\n    return_value = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*data << 0x1e) < 0) {\n      for (conversion_result = 0; conversion_result < (int)(data[3] - (int)conversion_buffer); conversion_result = conversion_result + 1) {\n        print_result = (*print_function)(data_type,length,(int)data + 0x19,1);\n        if (print_result == -1) goto LAB_00005c98;\n      }\n    }\n    return_value = (code *)data[3];\n    if ((int)(code *)data[3] < (int)conversion_buffer) {\n      return_value = conversion_buffer;\n    }\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_00006010",
                "FUN_00005a58"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005b34",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "convert_and_print_data_00005b34"
        },
        "FUN_0000058e": {
            "renaming": {
                "FUN_0000058e": "update_linked_list_0000058e",
                "param_1": "head_ptr",
                "param_2": "new_node_ptr",
                "*param_1": "*head_ptr",
                "*param_2": "*new_node_ptr",
                "*(undefined4 *)*param_1": "*(undefined4 *)*head_ptr",
                "*(undefined4 **)*param_1": "*(undefined4 **) *head_ptr",
                "(int)param_2": "(int)new_node_ptr"
            },
            "code": "void update_linked_list_0000058e(int *head_ptr, undefined4 *new_node_ptr)\n{\n  if (*head_ptr == 0) {\n    *new_node_ptr = new_node_ptr;\n  }\n  else {\n    *new_node_ptr = *(undefined4 *)*head_ptr;\n    *(undefined4 **) *head_ptr = new_node_ptr;\n  }\n  *head_ptr = (int)new_node_ptr;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000058e",
            "calling": [
                "FUN_00000698"
            ],
            "imported": false,
            "current_name": "update_linked_list_0000058e"
        },
        "FUN_0000656c": {
            "renaming": {
                "FUN_0000656c": "decode_and_process_input_0000656c",
                "param_1": "arg1",
                "param_2": "input_data",
                "param_3": "input_buf_ptr",
                "param_4": "output_data",
                "iVar1": "byte_seq_index",
                "uVar2": "decoded_input",
                "pcVar3": "decode_func_ptr",
                "uVar4": "input_data_flags",
                "pbVar5": "input_buf",
                "uVar6": "input_buf_len",
                "puVar7": "output_data_ptr",
                "puVar8": "output_buf_ptr",
                "puVar9": "output_buf_ptr2",
                "puVar10": "output_buf_ptr3",
                "unaff_r9": "input_buf_offset",
                "iVar11": "byte_seq_index2",
                "local_34": "byte_seq_arr"
            },
            "code": "\nundefined4 decode_and_process_input_0000656c(undefined4 arg1,uint *input_data,byte **input_buf_ptr,undefined4 *output_data)\n\n{\n  int byte_seq_index;\n  undefined4 decoded_input;\n  code *decode_func_ptr;\n  uint input_data_flags;\n  byte *input_buf;\n  uint input_buf_len;\n  undefined4 *output_data_ptr;\n  uint *output_buf_ptr;\n  uint *output_buf_ptr2;\n  uint *output_buf_ptr3;\n  int input_buf_offset;\n  int byte_seq_index2;\n  undefined4 byte_seq_arr [4];\n  \n  byte_seq_arr[0] = *(undefined4 *)PTR_PTR_DAT_00006744;\n  byte_seq_arr[1] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  byte_seq_arr[2] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  decode_func_ptr = (code *)PTR_LAB_00004f80_1_0000674c;\n  if (input_data[6] != 3) {\n    decode_func_ptr = (code *)PTR_LAB_00005fd4_1_00006748;\n  }\n  input_buf_len = input_data[2];\n  input_data_flags = input_buf_len - 1;\n  if (0x15c < input_data_flags) {\n    input_buf_offset = input_buf_len - 0x15d;\n    input_buf_len = 0x15d;\n  }\n  if (0x15c < input_data_flags) {\n    input_data[2] = input_buf_len;\n  }\n  output_buf_ptr3 = input_data + 7;\n  if (input_data_flags < 0x15d) {\n    input_buf_offset = 0;\n  }\n  *input_data = *input_data | 0xd00;\n  byte_seq_index2 = 0;\n  output_buf_ptr2 = output_buf_ptr3;\n  do {\n    byte_seq_index = find_byte_sequence_00006010(byte_seq_arr[byte_seq_index2],**input_buf_ptr,2);\n    if (byte_seq_index != 0) {\n      if (byte_seq_index2 == 1) {\n        if (input_data[1] == 0) {\n          input_data[1] = 8;\n          *input_data = *input_data | 0x200;\n        }\n        input_data_flags = *input_data & 0xfffffaff;\nLAB_000065f4:\n        *input_data = input_data_flags;\n      }\n      else if (byte_seq_index2 == 2) {\n        if ((*input_data & 0x600) != 0x200) goto LAB_00006624;\n        input_data[1] = 0x10;\n        input_data_flags = *input_data | 0x100;\n        goto LAB_000065f4;\n      }\n      input_data_flags = input_data[2];\n      input_data[2] = input_data_flags - 1;\n      if (input_data_flags != 0) {\n        input_buf = *input_buf_ptr;\n        *input_buf_ptr = input_buf + 1;\n        output_buf_ptr = (uint *)((int)output_buf_ptr2 + 1);\n        *(byte *)output_buf_ptr2 = *input_buf;\n        input_buf = input_buf_ptr[1];\n        input_buf_ptr[1] = input_buf + -1;\n        output_buf_ptr2 = output_buf_ptr;\n        if (((int)(input_buf + -1) < 1) &&\n           (byte_seq_index = (*(code *)input_data[0x60])(arg1,input_buf_ptr), byte_seq_index != 0)) {\n          byte_seq_index2 = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    byte_seq_index2 = byte_seq_index2 + 1;\n  } while (byte_seq_index2 != 3);\n  if (input_data[1] == 0) {\n    input_data[1] = 10;\n  }\n  decode_input_0000687c(input_data[5],(int)PTR_DAT_00006750 - input_data[1]);\n  byte_seq_index2 = 0;\n  while( true ) {\n    output_buf_ptr = output_buf_ptr2;\n    if (input_data[2] == 0) break;\n    input_buf = *input_buf_ptr;\n    input_data_flags = (uint)*input_buf;\n    if (*(char *)(input_data[5] + input_data_flags) == '\\0') break;\n    if ((input_data_flags == 0x30) && ((int)(*input_data << 0x14) < 0)) {\n      byte_seq_index2 = byte_seq_index2 + 1;\n      if (input_buf_offset != 0) {\n        input_buf_offset = input_buf_offset + -1;\n        input_data[2] = input_data[2] + 1;\n      }\n    }\n    else {\n      *input_data = *input_data & 0xfffff6ff;\n      output_buf_ptr = (uint *)((int)output_buf_ptr2 + 1);\n      *(byte *)output_buf_ptr2 = *input_buf;\n    }\n    input_buf = input_buf_ptr[1];\n    input_buf_ptr[1] = input_buf + -1;\n    if ((int)(input_buf + -1) < 1) {\n      byte_seq_index = (*(code *)input_data[0x60])(arg1,input_buf_ptr);\n      if (byte_seq_index != 0) break;\n    }\n    else {\n      *input_buf_ptr = *input_buf_ptr + 1;\n    }\n    input_data[2] = input_data[2] - 1;\n    output_buf_ptr2 = output_buf_ptr;\n  }\nLAB_000066ca:\n  if ((int)(*input_data << 0x17) < 0) {\n    if (output_buf_ptr3 < output_buf_ptr) {\n      (*(code *)input_data[0x5f])(arg1,*(byte *)((int)output_buf_ptr + -1),input_buf_ptr);\n      output_buf_ptr = (uint *)((int)output_buf_ptr + -1);\n    }\n    if (output_buf_ptr == output_buf_ptr3) {\n      return 1;\n    }\n  }\n  if ((*input_data & 0x10) == 0) {\n    *(byte *)output_buf_ptr = 0;\n    decoded_input = (*decode_func_ptr)(arg1,output_buf_ptr3,0,input_data[1]);\n    output_data_ptr = (undefined4 *)*output_data;\n    input_data_flags = *input_data;\n    *output_data = output_data_ptr + 1;\n    output_data_ptr = (undefined4 *)*output_data_ptr;\n    if ((input_data_flags & 0x20) == 0) {\n      if ((int)(input_data_flags << 0x1f) < 0) {\n        *(short *)output_data_ptr = (short)decoded_input;\n      }\n      else {\n        *output_data_ptr = decoded_input;\n      }\n    }\n    else {\n      *output_data_ptr = decoded_input;\n    }\n    input_data[3] = input_data[3] + 1;\n  }\n  input_data[4] = (uint)((int)output_buf_ptr + input_data[4] + (byte_seq_index2 - (int)output_buf_ptr3));\n  return 0;\n}\n\n",
            "called": [
                "FUN_0000687c",
                "FUN_00006010"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000656c",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "decode_and_process_input_0000656c"
        },
        "FUN_000025f4": {
            "renaming": {
                "FUN_000025f4": "set_data_flag_and_return_000025f4",
                "set_data_flag_000027b0": "set_data_flag"
            },
            "code": "void set_data_flag_and_return_000025f4(void)\n{\n  set_data_flag();\n  return;\n}",
            "called": [
                "FUN_000027b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000025f4",
            "calling": [
                "FUN_00002396"
            ],
            "imported": false,
            "current_name": "set_data_flag_and_return_000025f4"
        },
        "FUN_00001ddc": {
            "renaming": {
                "FUN_00001ddc": "calculate_value_from_param_00001ddc_00001ddc",
                "param_1": "param",
                "cVar1": "bits_from_right",
                "DAT_00001e08": "calculated_value"
            },
            "code": "void calculate_value_from_param_00001ddc_00001ddc(undefined2 param)\n{\n  char bits_from_right = get_bits_from_right_00001da2(param);\n  char DAT_00001e08 = bits_from_right + '\t';\n  set_DAT_00001e08_to_1_and_return_00001d3a(DAT_00001e08, DAT_00001e08);\n  return;\n}",
            "called": [
                "FUN_00001d3a",
                "FUN_00001da2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ddc",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "calculate_value_from_param_00001ddc_00001ddc"
        },
        "FUN_00002ecc": {
            "renaming": {
                "FUN_00002ecc": "read_sensor_data_and_display_00002ecc",
                "param_1": "device_id",
                "param_2": "sensor_data_ptr",
                "uVar1": "sensor_type_id",
                "uVar2": "sensor_class_id",
                "auStack_1c": "sensor_data",
                "local_14": "sensor_data_length"
            },
            "code": "void read_sensor_data_and_display_00002ecc(uint32_t device_id, int sensor_data_ptr)\n{\n    uint32_t sensor_data_length;\n    uint32_t sensor_type_id;\n    uint32_t sensor_class_id;\n    uint8_t sensor_data[8];\n    \n    sensor_data_length = execute_sensor_read_function(sensor_data_ptr, sensor_data);\n    if ((int)sensor_data_length < 1) {\n        process_error(\"failed to read from device\", device_id);\n    }\n    else {\n        sensor_type_id = *(uint32_t *)(sensor_data_ptr + 8);\n        sensor_class_id = lookup_sensor_class(*(uint8_t *)(*(int *)(sensor_data_ptr + 0xc) + 8));\n        process_data(\"Reading from sensor %i, type %s, class %s\", device_id, sensor_type_id, sensor_class_id);\n        display_object_data(sensor_data, sensor_data_length & 0xff);\n    }\n    return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00003d64",
                "FUN_000039e8",
                "FUN_00003694"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002ecc",
            "calling": [
                "FUN_00002fe0",
                "FUN_00002f30"
            ],
            "imported": false,
            "current_name": "read_sensor_data_and_display_00002ecc"
        },
        "FUN_00000d76": {
            "renaming": {
                "FUN_00000d76": "clear_value_at_offset_00000d76",
                "param_1": "base_address",
                "param_2": "offset",
                "puVar1": "value_ptr",
                "*puVar1": "*value_ptr",
                "calculate_offset_00000d44": "calculate_offset"
            },
            "code": "void clear_value_at_offset_00000d76(int base_address, int offset)\n{\n  int *value_ptr;\n  value_ptr = (int *)calculate_offset(base_address, offset);\n  *value_ptr = 0;\n  return;\n}",
            "called": [
                "FUN_00000d44"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d76",
            "calling": [
                "FUN_00000d9c"
            ],
            "imported": false,
            "current_name": "clear_value_at_offset_00000d76"
        },
        "FUN_000057a8": {
            "renaming": {
                "FUN_000057a8": "process_data_000057a8",
                "param_1": "data_length",
                "param_2": "data",
                "param_3": "data_buffer",
                "iVar1": "buffer_size",
                "puVar2": "buffer_ptr"
            },
            "code": "int process_data_000057a8(int data_length, int data, int *data_buffer){\n  int buffer_size = data_buffer[2] - 1;\n  data_buffer[2] = buffer_size;\n  if ((buffer_size < 0) && ((buffer_size < (int)data_buffer[6] || (data == 10)))) {\n    int result = process_data_000057a8_00005404();\n    return result;\n  }\n  undefined *buffer_ptr = (undefined *)*data_buffer;\n  *data_buffer = buffer_ptr + 1;\n  *buffer_ptr = (char)data;\n  return data;\n}",
            "called": [
                "FUN_00005404"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057a8",
            "calling": [
                "FUN_000057d2"
            ],
            "imported": false,
            "current_name": "process_data_000057a8"
        },
        "FUN_00001696": {
            "renaming": {
                "FUN_00001696": "calculate_offset_00001696",
                "param_1": "address",
                "param_2": "offset",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int calculate_offset_00001696(uint address, int offset) {\n    uint masked_address_high = address & 0xf0000000;\n    uint masked_address_low = address & 0xfffff;\n    int shifted_address_low = masked_address_low << 5;\n    int calculated_offset = offset * 4 + masked_address_high + shifted_address_low + 0x2000000;\n    return calculated_offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001696",
            "calling": [
                "FUN_000016ec",
                "FUN_000016c8",
                "FUN_00001710"
            ],
            "imported": false,
            "current_name": "calculate_offset_00001696"
        },
        "FUN_000008b8": {
            "renaming": {
                "FUN_000008b8": "count_relocations_in_section_000008b8",
                "local_c": "relocation_ptr",
                "PTR_DAT_000008f4": "section_start_ptr",
                "DAT_000008f8": "section_type",
                "PTR_Elf32_Rel_ARRAY_000008fc": "section_end_ptr"
            },
            "code": "int count_relocations_in_section_000008b8(void)\n{\n  int *relocation_ptr;\n  for (relocation_ptr = (int *)PTR_DAT_000008f4;\n      (*relocation_ptr == DAT_000008f8 && (relocation_ptr < PTR_Elf32_Rel_ARRAY_000008fc)); relocation_ptr = relocation_ptr + 1)\n  {\n  }\n  return ((int)PTR_Elf32_Rel_ARRAY_000008fc - (int)relocation_ptr >> 2) << 2;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000008b8",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "count_relocations_in_section_000008b8"
        },
        "FUN_000024bc": {
            "renaming": {
                "FUN_000024bc": "processLinkedList_000024bc",
                "param_1": "headNode",
                "uVar1": "privilegeMode",
                "uVar2": "isInterruptEnabled",
                "iVar3": "currentNode",
                "*param_1": "*headNode",
                "get_next_node_0000240c": "getNextNode",
                "update_linked_list_00000698": "updateLinkedList",
                "check_interrupt_enabled_00000cd0": "checkInterruptEnabled",
                "enableIRQinterrupts_if_privileged_00000d0c": "enableIRQinterruptsIfPrivileged",
                "check_privileged_mode_and_set_flag_if_not_00000738": "checkPrivilegeModeAndSetFlagIfNot"
            },
            "code": "void processLinkedList_000024bc(int *headNode) {\n  bool isInterruptEnabled;\n  int currentNode;\n  char privilegeMode;\n\n  isInterruptEnabled = checkInterruptEnabled();\n\n  if (*headNode == 0) {\n    enableIRQinterruptsIfPrivileged(isInterruptEnabled);\n  }\n  else if (*headNode == -1) {\n    *headNode = 0;\n    enableIRQinterruptsIfPrivileged(isInterruptEnabled);\n  }\n  else {\n    currentNode = getNextNode(headNode);\n    updateLinkedList(currentNode - 8, 10);\n    if (*headNode == 0) {\n      *headNode = -1;\n    }\n    privilegeMode = *(char *)(currentNode - 3);\n    enableIRQinterruptsIfPrivileged(isInterruptEnabled);\n    checkPrivilegeModeAndSetFlagIfNot(privilegeMode);\n  }\n  return;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000d0c",
                "FUN_0000240c",
                "FUN_00000cd0",
                "FUN_00000738"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000024bc",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": false,
            "current_name": "processLinkedList_000024bc"
        },
        "FUN_00000490": {
            "renaming": {
                "FUN_00000490": "find_first_non_matching_pointer_00000490",
                "param_1": "ptr1",
                "param_2": "ptr2",
                "param_3": "ptr3",
                "param_4": "ptr4",
                "uVar1": "result"
            },
            "code": "int find_first_non_matching_pointer_00000490(void* ptr1, void* ptr2) {\n  int result = 0;\n  while (*(char*)ptr1 == *(char*)ptr2) {\n    ptr1 = (char*)ptr1 + 1;\n    ptr2 = (char*)ptr2 + 1;\n  }\n  result = (int)((char*)ptr1 - (char*)param_3);\n  return result;\n}",
            "called": [
                "FUN_00000e14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000490",
            "calling": [
                "FUN_00004dc8"
            ],
            "imported": false,
            "current_name": "find_first_non_matching_pointer_00000490"
        },
        "FUN_0000091c": {
            "renaming": {
                "FUN_0000091c": "get_pointer_to_data_0000091c",
                "PTR_DAT_0000092c": "pointer_to_data"
            },
            "code": "const char* get_pointer_to_data_0000091c() {\n  return PTR_DAT_0000092c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000091c",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_pointer_to_data_0000091c"
        },
        "FUN_00001f80": {
            "renaming": {
                "FUN_00001f80": "updateMemoryValueFromParam_00001f80",
                "param_1": "paramValue",
                "param_2": "newValue",
                "iVar1": "memoryAddress",
                "iVar2": "lower6Bits",
                "uVar3": "bitsFromRight",
                "uVar4": "lower6Bits",
                "uVar5": "originalValue"
            },
            "code": "void updateMemoryValueFromParam_00001f80(uint16_t paramValue, uint32_t newValue) {\n    uint32_t* memoryAddress = getMemoryAddress(paramValue);\n    uint8_t lower6Bits = extractLower6Bits(paramValue);\n    uint32_t originalValue = *(memoryAddress + lower6Bits);\n    *(memoryAddress + lower6Bits) = newValue;\n    if ((originalValue & 0xf0000) != 0) {\n        uint32_t bitsFromRight = getBitsFromRight(paramValue);\n        uint8_t lower6Bits = extractLower6Bits(paramValue);\n        extractBitsAndSetInMemory(bitsFromRight, lower6Bits);\n    }\n}",
            "called": [
                "FUN_00001dc0",
                "FUN_00001ddc",
                "FUN_00001ec4",
                "FUN_00001d5e",
                "FUN_00001da2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001f80",
            "calling": [
                "FUN_00001448",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "updateMemoryValueFromParam_00001f80"
        },
        "FUN_00000e64": {
            "renaming": {
                "FUN_00000e64": "initializeAndSetFlags_00000e64",
                "DAT_00000ed0": "offset1",
                "DAT_00000ed4": "offset2",
                "findAndInsert_00001034": "insertPointer",
                "initialize_and_process_data_00001274": "initializeAndProcessData",
                "updateMemoryAndFlags_00001eea": "updateMemoryAndFlags",
                "set_bit_in_flagged_value_00001ff6": "setBitInFlaggedValue"
            },
            "code": "void initializeAndSetFlags_00000e64(void)\n{\n  uint* insertPointer = findAndInsert_00001034;\n  uint* dataPointer1 = insertPointer + DAT_00000ed0 + 4;\n  uint* dataPointer2 = DAT_00000ed4 + 0x48;\n\n  *dataPointer1 |= 0x200;\n  *dataPointer2 &= 0xfefff8ff;\n\n  initialize_and_process_data_00001274();\n  updateMemoryAndFlags_00001eea(0x2056,0x80);\n  updateMemoryAndFlags_00001eea(0x511a,0x80);\n  updateMemoryAndFlags_00001eea(0x2055,0x80);\n\n  set_bit_in_flagged_value_00001ff6(0x2056);\n  set_bit_in_flagged_value_00001ff6(0x511a);\n  set_bit_in_flagged_value_00001ff6(0x2055);\n  return;\n}",
            "called": [
                "FUN_00001ff6",
                "FUN_00001eea",
                "FUN_00001274"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e64",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "initializeAndSetFlags_00000e64"
        },
        "FUN_000026e4": {
            "renaming": {
                "FUN_000026e4": "clear_bit_in_uint_array_and_return_000026e4",
                "clear_bit_in_uint_array_00002970": "clear_bit_in_uint_array"
            },
            "code": "void clear_bit_in_uint_array_and_return_000026e4(void)\n{\n  clear_bit_in_uint_array();\n  return;\n}",
            "called": [
                "FUN_00002970"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026e4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "clear_bit_in_uint_array_and_return_000026e4"
        },
        "FUN_00000d44": {
            "renaming": {
                "FUN_00000d44": "calculate_offset_00000d44",
                "param_1": "address",
                "param_2": "offset"
            },
            "code": "int calculate_offset_00000d44(uint32_t address, int offset) {\n    uint32_t masked_high = address & 0xf0000000;\n    uint32_t masked_low = address & 0xfffff;\n    uint32_t shifted_low = masked_low << 5;\n    int result = (offset * 4) + masked_high + shifted_low + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d44",
            "calling": [
                "FUN_00000d76"
            ],
            "imported": false,
            "current_name": "calculate_offset_00000d44"
        },
        "FUN_00000698": {
            "renaming": {
                "FUN_00000698": "update_linked_list_00000698",
                "param_1": "node_index",
                "param_2": "new_value",
                "PTR_DAT_00000730": "linked_list_data",
                "PTR_DAT_00000734": "linked_list_flags",
                "reverse_linked_list_000005ca": "reverse_linked_list",
                "update_linked_list_0000058e": "update_linked_list_node",
                "*(byte *)(param_1 + 4)": "current_value",
                "*(byte *)(param_1 + 5)": "node_value_index",
                "*(int *)(PTR_DAT_00000730 + (uint)*(byte *)(param_1 + 5) * 4)": "node_value",
                "*(uint *)PTR_DAT_00000734": "flags_value",
                "*(sbyte *)(param_1 + 5)": "node_flag_index",
                "(char)param_2": "new_value"
            },
            "code": "void update_linked_list_00000698(int node_index, uint8_t new_value)\n{\n    if (new_value < 9)\n    {\n        uint8_t current_value = *(uint8_t *)(node_index + 4);\n        if (current_value > 8)\n        {\n            reverse_linked_list(PTR_DAT_00000730 + *(uint8_t *)(node_index + 5) * 4);\n            if (*(int *)(PTR_DAT_00000730 + *(uint8_t *)(node_index + 5) * 4) == 0)\n            {\n                *(uint32_t *)PTR_DAT_00000734 = *(uint32_t *)PTR_DAT_00000734 & ~(1 << *(int8_t *)(node_index + 5));\n            }\n        }\n    }\n    else\n    {\n        uint8_t current_value = *(uint8_t *)(node_index + 4);\n        if (current_value < 9)\n        {\n            update_linked_list_00000698_0000058e(PTR_DAT_00000730 + *(uint8_t *)(node_index + 5) * 4,node_index + 8);\n            *(uint32_t *)PTR_DAT_00000734 = *(uint32_t *)PTR_DAT_00000734 | 1 << *(int8_t *)(node_index + 5);\n        }\n    }\n    *(uint8_t *)(node_index + 4) = new_value;\n}",
            "called": [
                "FUN_000005ca",
                "FUN_0000058e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000698",
            "calling": [
                "FUN_000010d4",
                "FUN_00000794",
                "FUN_000024bc",
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "update_linked_list_00000698"
        },
        "FUN_00000cd0": {
            "renaming": {
                "FUN_00000cd0": "check_interrupt_enabled_00000cd0",
                "uVar2": "is_interrupt_enabled",
                "bVar1": "is_privileged_mode"
            },
            "code": "bool is_interrupt_enabled = false;\nbool is_privileged_mode = check_interrupt_enabled_00000cd0();\nif (is_privileged_mode) {\n    is_interrupt_enabled = isIRQinterruptsEnabled();\n}\ndisableIRQinterrupts();\nreturn is_interrupt_enabled;",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cd0",
            "calling": [
                "FUN_000010d4",
                "FUN_00000f8c",
                "FUN_00000794",
                "FUN_00000f04",
                "FUN_000024bc",
                "FUN_00002434",
                "FUN_00000e58",
                "FUN_00001c84",
                "FUN_00000428"
            ],
            "imported": false,
            "current_name": "check_interrupt_enabled_00000cd0"
        },
        "FUN_00000cc0": {
            "renaming": {
                "FUN_00000cc0": "handle_interrupts_and_input_00000cc0",
                "uVar2": "is_IRQ_interrupts_enabled",
                "bVar1": "is_privileged_mode",
                "isCurrentModePrivileged": "is_current_mode_privileged",
                "isIRQinterruptsEnabled": "is_IRQ_interrupts_enabled",
                "disableIRQinterrupts": "disable_IRQ_interrupts",
                "uRam00000ccc": "input_buffer"
            },
            "code": "bool is_IRQ_interrupts_enabled = false;\n\nhandle_interrupts_and_input_00000cc0(10, input_buffer);\n\nif (is_current_mode_privileged()) {\n  is_IRQ_interrupts_enabled = is_IRQ_interrupts_enabled();\n}\n\ndisable_IRQ_interrupts();\n\nreturn is_IRQ_interrupts_enabled;",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cc0",
            "calling": [
                "FUN_00000dc0"
            ],
            "imported": false,
            "current_name": "handle_interrupts_and_input_00000cc0"
        },
        "FUN_00002994": {
            "renaming": {
                "FUN_00002994": "check_and_call_functions_if_flags_set_00002994",
                "DAT_000029f8": "data",
                "PTR_DAT_000029fc": "ptrDatafc",
                "flag1": "flag1",
                "flag2": "flag2",
                "data14": "data14",
                "data1c": "data1c"
            },
            "code": "void check_and_call_functions_if_flags_set_00002994(void)\n{\n  int DAT_000029f8 = DAT_000029f8;\n  uint* DAT_000029f814 = (uint*)(DAT_000029f8 + 0x14);\n  uint* DAT_000029f81c = (uint*)(DAT_000029f8 + 0x1c);\n  int* PTR_DAT_000029fc = PTR_DAT_000029fc;\n  uint flag1 = 4;\n  uint flag2 = 2;\n  if ((*DAT_000029f814 & flag1) && (*PTR_DAT_000029fc != 0)) {\n    *DAT_000029f81c &= 0xfffffffb;\n    (**(code **)*PTR_DAT_000029fc)(*(undefined4 *)(PTR_DAT_000029fc + 4));\n  }\n  if ((*DAT_000029f814 & flag2) && (*(PTR_DAT_000029fc + 8) != 0)) {\n    (**(code **)(PTR_DAT_000029fc + 8))(*(undefined4 *)(PTR_DAT_000029fc + 0xc));\n  }\n  check_flag_if_set_00002798();\n  return;\n}",
            "called": [
                "FUN_00002798"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002994",
            "calling": [],
            "imported": false,
            "current_name": "check_and_call_functions_if_flags_set_00002994"
        },
        "FUN_00000d2a": {
            "renaming": {
                "FUN_00000d2a": "get_exception_number_if_privileged_mode_00000d2a",
                "bVar1": "is_privileged_mode",
                "uVar2": "exception_number"
            },
            "code": "uint get_exception_number_if_privileged_mode_00000d2a(void)\n{\n  bool is_privileged_mode;\n  uint exception_number = 0;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode)\n  {\n    exception_number = getCurrentExceptionNumber() & 0x1f;\n  }\n  return exception_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d2a",
            "calling": [
                "FUN_00000738"
            ],
            "imported": false,
            "current_name": "get_exception_number_if_privileged_mode_00000d2a"
        },
        "FUN_00001ff6": {
            "renaming": {
                "FUN_00001ff6": "set_bit_in_flagged_value_00001ff6",
                "param_1": "value",
                "uVar1": "lower_6_bits",
                "iVar2": "flagged_value_ptr",
                "getFlaggedValue_00001d80": "get_flagged_value_ptr",
                "extract_lower_6_bits_00001dc0": "extract_lower_6_bits"
            },
            "code": "void set_bit_in_flagged_value_00001ff6(uint16_t value)\n{\n  uint8_t lower_6_bits = extract_lower_6_bits(value);\n  int flagged_value_ptr = get_flagged_value_ptr(value);\n  *(int *)(flagged_value_ptr + 4) = 1 << (lower_6_bits & 0xff);\n  return;\n}",
            "called": [
                "FUN_00001d80",
                "FUN_00001dc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ff6",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "set_bit_in_flagged_value_00001ff6"
        },
        "FUN_000013b8": {
            "renaming": {
                "FUN_000013b8": "setMemoryValues_000013b8",
                "param_1": "index",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "N/A",
                "uVar1": "returnValue",
                "PTR_s_FAILED_ASSERTION__0000143c": "FAILED_ASSERTION_MSG",
                "PTR_DAT_00001440": "MEMORY_PTR",
                "updateMemoryValues_00001448": "updateMemoryValues",
                "set_value_at_calculated_address_00001392": "setValueAtCalculatedAddress",
                "PTR_DAT_00001444": "ADDRESS_PTR",
                "set_bits_000014c4": "setBits"
            },
            "code": "int setMemoryValues_000013b8(int index, int value1, int value2){\n        if (index != 0) {\n            handleInterruptAndParseInputLoop(3, PTR_s_FAILED_ASSERTION__0000143c);\n        }\n        *(int *)(PTR_DAT_00001440 + index * 8) = value1;\n        *(int *)(PTR_DAT_00001440 + index * 8 + 4) = value2;\n        updateMemoryValues(index);\n        setValueAtCalculatedAddress(*(int *)(PTR_DAT_00001444 + index * 0x20 + 0x18), PTR_DAT_00001444[index * 0x20 + 0x1c]);\n        if (PTR_DAT_00001444[index * 0x20 + 0x1e] == \"\\0\") {\n            setBits(index, value1);\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    }",
            "called": [
                "FUN_00001392",
                "FUN_00000f04",
                "FUN_000014c4",
                "FUN_00001448"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000013b8",
            "calling": [
                "FUN_00000df4"
            ],
            "imported": false,
            "current_name": "setMemoryValues_000013b8"
        },
        "FUN_00002a88": {
            "renaming": {
                "FUN_00002a88": "print_command_description_00002a88",
                "param_1": "commands",
                "local_18": "command_info",
                "local_10": "i",
                "local_c": "current_command",
                "PTR_s___20s__s_00002b04": "description_format",
                "PTR_s_Command_00002b00": "command_format",
                "PTR_s_Description_00002afc": "description_string",
                "PTR_s__________________________________00002b08": "separator_string",
                "PTR_PTR_s_reboot_00002b0c": "reboot_command"
            },
            "code": "void print_command_description_00002a88(int *commands)\n{\n  int *command_info[2];\n  uint i;\n  int *current_command;\n  print_description();\n  print_separator();\n  command_info[0] = commands;\n  command_info[1] = (int *)PTR_PTR_s_reboot_00002b0c;\n  for (i = 0; i < 2; i++) {\n    current_command = command_info[i];\n    if (current_command != (int *)0x0) {\n      for (; *current_command != 0; current_command = current_command + 3) {\n        print_command(*current_command, current_command[1]);\n      }\n    }\n  }\n}\n",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a88",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "print_command_description_00002a88",
            "code_backup": "\nvoid FUN_00002a88(int *param_1)\n\n{\n  int *local_18 [2];\n  uint local_10;\n  int *local_c;\n  \n  FUN_00004c84(PTR_s___20s__s_00002b04,PTR_s_Command_00002b00,PTR_s_Description_00002afc);\n  FUN_00004db8(PTR_s__________________________________00002b08);\n  local_18[0] = param_1;\n  local_18[1] = (int *)PTR_PTR_s_reboot_00002b0c;\n  for (local_10 = 0; local_10 < 2; local_10 = local_10 + 1) {\n    local_c = local_18[local_10];\n    if (local_c != (int *)0x0) {\n      for (; *local_c != 0; local_c = local_c + 3) {\n        FUN_00004c84(PTR_s___20s__s_00002b04,*local_c,local_c[1]);\n      }\n    }\n  }\n  return;\n}\n\n"
        },
        "FUN_00002f30": {
            "renaming": {
                "FUN_00002f30": "read_and_display_sensor_data_for_all_sensors_00002f30",
                "local_10": "sensor_index",
                "local_c": "sensor_data_ptr"
            },
            "code": "void read_and_display_sensor_data_for_all_sensors_00002f30(void)\n{\n  int sensor_index = 0;\n  undefined4 *sensor_data_ptr = *(undefined4 **)PTR_DAT_00002f6c;\n  while (sensor_data_ptr != (undefined4 *)0x0) {\n    read_sensor_data_and_display_00002ecc(sensor_index, sensor_data_ptr);\n    process_input_00004db8(PTR_DAT_00002f70);\n    sensor_index++;\n    sensor_data_ptr = (undefined4 *)*sensor_data_ptr;\n  }\n  return;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00002ecc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f30",
            "calling": [
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "read_and_display_sensor_data_for_all_sensors_00002f30"
        },
        "FUN_00001e44": {
            "renaming": {
                "FUN_00001e44": "set_bits_in_uint_at_index_00001e44",
                "param_1": "data",
                "param_2": "index",
                "param_3": "value",
                "iVar1": "word_index",
                "PTR_DAT_00001ec0": "data"
            },
            "code": "void set_bits_in_uint_at_index_00001e44(uint32_t *PTR_DAT_00001ec0, uint32_t index, uint32_t value){\n    uint32_t word_index = index >> 3;\n    uint32_t bit_index = index & 7;\n    uint32_t bit_shift = bit_index << 2;\n    uint32_t mask = 0xf << bit_shift;\n    PTR_DAT_00001ec0[word_index] &= ~mask;\n    PTR_DAT_00001ec0[word_index] |= value << bit_shift;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e44",
            "calling": [
                "FUN_00001ec4"
            ],
            "imported": false,
            "current_name": "set_bits_in_uint_at_index_00001e44"
        },
        "FUN_00001318": {
            "renaming": {
                "FUN_00001318": "set_bit_in_array_00001318",
                "param_1": "bit_position",
                "DAT_00001344": "array_base_address",
                "uint": "uint32_t",
                "int": "int32_t",
                "byte": "uint8_t",
                "*": "*",
                "<<": "<<",
                ">>": ">>",
                "&": "&",
                "|": "|"
            },
            "code": "void set_bit_in_array_00001318(uint8_t bit_position)\n{\n    uint32_t* array_ptr = (uint32_t*)(DAT_00001344 + ((uint32_t)bit_position >> 5) * 4);\n    uint32_t bit_mask = 1 << (bit_position & 0x1f);\n    *array_ptr = bit_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001318",
            "calling": [
                "FUN_000014c4"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_00001318"
        },
        "FUN_00000900": {
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "uVar1": "main_stack_pointer"
            },
            "code": "uint32_t get_main_stack_pointer_00000900(void)\n{\n  uint32_t main_stack_pointer = 0;\n  main_stack_pointer = getMainStackPointer();\n  return main_stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000900",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_main_stack_pointer_00000900"
        },
        "FUN_00004274": {
            "renaming": {
                "FUN_00004274": "do_nothing_and_return_00004274",
                "PTR_DAT_0000427c": "PTR_DATA"
            },
            "code": "void do_nothing_and_return_00004274(void)\n{\n  do_nothing(PTR_DAT_0000427c);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004274",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_and_return_00004274"
        },
        "FUN_00002fe0": {
            "renaming": {
                "FUN_00002fe0": "process_sensor_data_00002fe0",
                "param_1": "device_count",
                "param_2": "device_data",
                "iVar1": "comparison_result",
                "uVar2": "device_id",
                "process_data_00004c84": "process_data",
                "PTR_s_usage___s__s__device_id__all_00003050": "PTR_s_usage___s__s__device_id__all_00003050",
                "compare_bytes_00004e52": "compare_bytes",
                "PTR_DAT_00003054": "PTR_DAT_00003054",
                "read_and_display_sensor_data_for_all_sensors_00002f30": "read_and_display_sensor_data_for_all_sensors",
                "parse_string_and_convert_to_unsigned_int_00004042": "parse_string_and_convert_to_unsigned_int",
                "find_nth_element_00003d24": "find_nth_element",
                "FUN_00004db8": "FUN_00004db8",
                "PTR_s_error__undefined_device_id_given_00003058": "PTR_s_error__undefined_device_id_given_00003058",
                "read_sensor_data_and_display_00002ecc": "read_and_display_sensor_data"
            },
            "code": "void process_sensor_data_00002fe0(int device_count, undefined4 *device_data)\n{\n  int comparison_result;\n  undefined4 device_id;\n\n  if (device_count < 3) {\n    process_data(PTR_s_usage___s__s__device_id__all_00003050, *device_data, device_data[1]);\n  }\n  else {\n    comparison_result = compare_bytes(device_data[2], PTR_DAT_00003054);\n    if (comparison_result == 0) {\n      read_and_display_sensor_data_for_all_sensors();\n    }\n    else {\n      device_id = parse_string_and_convert_to_unsigned_int(device_data[2]);\n      comparison_result = find_nth_element(device_id);\n      if (comparison_result == 0) {\n        process_input_00004db8(PTR_s_error__undefined_device_id_given_00003058);\n      }\n      else {\n        read_and_display_sensor_data(device_id, comparison_result);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00004e52",
                "FUN_00002ecc",
                "FUN_00002f30",
                "FUN_00003d24",
                "FUN_00004042"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002fe0",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "process_sensor_data_00002fe0"
        },
        "FUN_00001dc0": {
            "renaming": {
                "FUN_00001dc0": "extract_lower_6_bits_00001dc0",
                "param_1": "input_value",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "ushort extract_lower_6_bits_00001dc0(ushort input_value) {\n    ushort lower_6_bits = input_value & 0x3f;\n    return lower_6_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001dc0",
            "calling": [
                "FUN_00001f80",
                "FUN_00001ff6",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "extract_lower_6_bits_00001dc0"
        },
        "FUN_00000df4": {
            "renaming": {
                "FUN_00000df4": "initializeMemory_00000df4",
                "PTR_checkAndUpdate_000012b4_1_00000e10": "checkAndUpdatePtr",
                "DAT_00000e0c": "data",
                "setMemoryValues_000013b8": "setMemoryValues"
            },
            "code": "void initializeMemory_00000df4(void)\n{\n    int startingAddress = 0;\n    int memorySize = 0x1c200;\n    setMemoryValues(startingAddress, memorySize, PTR_checkAndUpdate_000012b4_1_00000e10, DAT_00000e0c);\n    return;\n}",
            "called": [
                "FUN_000013b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000df4",
            "calling": [
                "FUN_00000410"
            ],
            "imported": false,
            "current_name": "initializeMemory_00000df4"
        },
        "FUN_00002400": {
            "renaming": {
                "FUN_00002400": "do_nothing_00002400"
            },
            "code": "\nvoid do_nothing_00002400(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002400",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "do_nothing_00002400"
        },
        "FUN_00002eb4": {
            "renaming": {
                "FUN_00002eb4": "process_and_return_zero_00002eb4",
                "process_data_0000211c": "process_data"
            },
            "code": "int process_and_return_zero_00002eb4(void)\n{\n  process_data();\n  return 0;\n}",
            "called": [
                "FUN_0000211c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002eb4",
            "calling": [],
            "imported": false,
            "current_name": "process_and_return_zero_00002eb4"
        },
        "FUN_0000328c": {
            "renaming": {
                "FUN_0000328c": "parse_input_and_calculate_score_0000328c",
                "param_1": "input_string",
                "param_2": "output_array",
                "local_10": "current_index",
                "local_a": "current_value",
                "calculate_score_000031fc": "calculate_score"
            },
            "code": "int parse_input_and_calculate_score_0000328c(unsigned int* input_string, int* output_array) {\n    int current_index = 0;\n    unsigned short current_value;\n\n    current_value = parseStringToUnsignedInt(input_string, &current_index, 10);\n    output_array[5] = current_value - 0x76c;\n\n    current_value = parseStringToUnsignedInt(input_string + 1, &current_index, 10);\n    output_array[2] = (int)current_value;\n\n    current_value = parseStringToUnsignedInt(input_string + 2, &current_index, 10);\n    output_array[1] = (int)current_value;\n\n    current_value = parseStringToUnsignedInt(input_string + 3, &current_index, 10);\n    *output_array = (int)current_value;\n\n    current_value = parseStringToUnsignedInt(input_string + 4, &current_index, 10);\n    output_array[4] = current_value - 1;\n\n    int calculated_score = calculate_score(output_array[5] + 0x76c, output_array[4] + 1, output_array[3]);\n    output_array[6] = calculated_score;\n    output_array[8] = -1;\n    return 0;\n}",
            "called": [
                "FUN_00004f84",
                "FUN_000031fc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000328c",
            "calling": [
                "FUN_000033f4",
                "FUN_00003478"
            ],
            "imported": false,
            "current_name": "parse_input_and_calculate_score_0000328c"
        },
        "FUN_000041f4": {
            "renaming": {
                "FUN_000041f4": "initialize_data_000041f4",
                "param_1": "data",
                "param_2": "parameter_1",
                "param_3": "parameter_2",
                "puVar1": "pointer_to_label",
                "fill_array_with_value_00004622": "fill_array_with_value",
                "PTR_FUN_00004dc8_1_0000422c": "pointer_to_function_1",
                "DAT_00004230": "data_1",
                "PTR_FUN_00004e26_1_00004234": "pointer_to_function_2",
                "PTR_LAB_00004e4a_1_00004238": "pointer_to_label"
            },
            "code": "void initialize_data_000041f4(undefined4 *data, undefined2 parameter_1, undefined2 parameter_2)\n{\n    *data = 0;\n    data[1] = 0;\n    data[2] = 0;\n    data[3] = parameter_1;\n    data[4] = 0;\n    data[5] = 0;\n    data[6] = 0;\n    data[7] = 0;\n    data[8] = data;\n    data[9] = PTR_find_first_non_matching_pointer_00004dc8_1_0000422c;\n    data[10] = DAT_00004230;\n    data[11] = PTR_set_param_to_19_00004e26_1_00004234;\n    data[12] = PTR_LAB_00004e4a_1_00004238;\n}",
            "called": [
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041f4",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "initialize_data_000041f4"
        },
        "FUN_0000316c": {
            "renaming": {
                "FUN_0000316c": "process_sensor_data_0000316c",
                "param_1": "sensor_count",
                "param_2": "sensor_data",
                "iVar1": "comparison_result",
                "print_sensor_classes_00002f74": "print_sensor_classes",
                "compare_bytes_00004e52": "compare_bytes",
                "PTR_DAT_000031d4": "PTR_DAT_sensor_data",
                "process_sensor_data_00002fe0": "process_sensor_data",
                "PTR_s_write_000031d8": "PTR_write_data",
                "write_data_to_device_0000305c": "write_data_to_device",
                "process_data_00004c84": "process_data",
                "PTR_s_usage___s_read_write_000031dc": "PTR_data_usage"
            },
            "code": "int process_sensor_data_0000316c(int sensor_count, unsigned int *sensor_data)\n{\n    int comparison_result;\n    if (sensor_count < 2) {\n        print_sensor_classes();\n    }\n    else {\n        comparison_result = compare_bytes(sensor_data[1], PTR_DAT_000031d4);\n        if (comparison_result == 0) {\n            process_sensor_data_0000316c(sensor_count, sensor_data);\n        }\n        else {\n            comparison_result = compare_bytes(sensor_data[1], PTR_s_write_000031d8);\n            if (comparison_result == 0) {\n                write_data_to_device(sensor_count, sensor_data);\n            }\n            else {\n                process_data(PTR_s_usage___s_read_write_000031dc, *sensor_data);\n            }\n        }\n    }\n    return 0;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00004e52",
                "FUN_00002fe0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000316c",
            "calling": [],
            "imported": false,
            "current_name": "process_sensor_data_0000316c"
        },
        "FUN_000026f0": {
            "renaming": {
                "FUN_000026f0": "execute_function_if_initialized_000026f0",
                "param_1": "param",
                "PTR_DAT_00002710": "initialized_pointer",
                "initialized": "initialized_value"
            },
            "code": "void execute_function_if_initialized_000026f0(undefined4 param)\n{\n  int* initialized = *(int **)PTR_DAT_00002710;\n  if (*initialized != 0) {\n    (**(code **)initialized)(param);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026f0",
            "calling": [],
            "imported": false,
            "current_name": "execute_function_if_initialized_000026f0"
        },
        "FUN_000057d2": {
            "renaming": {
                "FUN_000057d2": "process_data_and_return_last_index_000057d2",
                "param_1": "data_1",
                "param_2": "data_2",
                "param_3": "data_array",
                "param_4": "array_size",
                "puVar2": "end_of_array",
                "iVar3": "current_index",
                "iVar1": "last_index",
                "process_data_000057a8": "process_data"
            },
            "code": "int process_data_and_return_last_index_000057d2(int data_1, int data_2, char* data_array, int array_size) {\n  int last_index = -1;\n  char* current_data = data_array;\n  for(int i = 0; i < array_size; i++) {\n    last_index = process_data(data_1, *current_data, data_2, i, last_index);\n    current_data++;\n  }\n  return last_index;\n}",
            "called": [
                "FUN_000057a8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057d2",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "process_data_and_return_last_index_000057d2"
        },
        "FUN_000056b8": {
            "renaming": {
                "FUN_000056b8": "check_value_and_set_flag_000056b8",
                "param_1": "value",
                "param_2": "offset",
                "param_3": "flag",
                "param_4": "result",
                "iVar1": "set_value_result",
                "uVar2": "flag_value",
                "auStack_68": "flag_value_buffer",
                "local_64": "flag_value_mask"
            },
            "code": "int check_value_and_set_flag_000056b8(int value, int offset, int* flag, unsigned int* result) {\n  int set_value_result;\n  unsigned int flag_value;\n  if (*(short *)(offset + 0xe) < 0 || (set_value_result = set_value_to_19_00000514(value, (int)*(short *)(offset + 0xe), &flag_value)) < 0) {\n    *result = 0;\n    if ((int)((uint)*(ushort *)(offset + 0xc) << 0x18) < 0) {\n      *flag = 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    *result = (unsigned int)((flag_value & 0xf000) == 0x2000);\n  }\n  *flag = 0x400;\nLAB_000056f8:\n  return 0;\n}",
            "called": [
                "FUN_00000514"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b8",
            "calling": [
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "check_value_and_set_flag_000056b8"
        },
        "FUN_00001a18": {
            "renaming": {
                "FUN_00001a18": "set_offset_and_clear_memory_00001a18",
                "DAT_00001a34": "DAT_offset",
                "set_offset_to_one_000016ec": "set_offset_to_one",
                "clear_memory_00001734": "clear_memory",
                "*PTR_DAT_00001a38": "*PTR_counter"
            },
            "code": "void set_offset_and_clear_memory_00001a18(void)\n{\n  set_offset_to_one(DAT_00001a34,1);\n  clear_memory();\n  *PTR_DAT_00001a38 = 4;\n  return;\n}",
            "called": [
                "FUN_00001734",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a18",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_offset_and_clear_memory_00001a18"
        },
        "FUN_00000d9c": {
            "renaming": {
                "FUN_00000d9c": "clearValueAtOffset_00000d9c",
                "DAT_00000dac": "PTR_value",
                "clear_value_at_offset_00000d76": "clearValueAtOffset"
            },
            "code": "void clearValueAtOffset_00000d9c(void)\n{\n    clearValueAtOffset_00000d9c(DAT_00000dac, 0);\n    return;\n}",
            "called": [
                "FUN_00000d76"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d9c",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": false,
            "current_name": "clearValueAtOffset_00000d9c"
        },
        "FUN_00003ff4": {
            "renaming": {
                "FUN_00003ff4": "copy_and_fill_00003ff4",
                "param_1": "count_to_copy",
                "param_2": "start_index",
                "param_3": "end_index",
                "param_4": "fill_value",
                "uVar1": "end_index_copy"
            },
            "code": "uint copy_and_fill_00003ff4(uint count_to_copy, uint start_index, uint end_index, undefined fill_value){\n  uint end_index_copy = end_index;\n  if ((start_index < end_index) && (count_to_copy != 0)) {\n    reverse_copy(count_to_copy + (end_index - start_index), start_index, end_index);\n    fill_array_with_value(start_index, fill_value, end_index - start_index);\n  }\n  return end_index_copy;\n}",
            "called": [
                "FUN_000045ee",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ff4",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": false,
            "current_name": "copy_and_fill_00003ff4"
        },
        "FUN_00004634": {
            "renaming": {
                "FUN_00004634": "update_date_time_00004634",
                "param_1": "date_time",
                "param_2": "time_zone_offset",
                "param_3": "unused_param",
                "puVar1": "month_days",
                "iVar2": "days_in_month",
                "uVar3": "day_of_month",
                "uVar4": "year",
                "iVar5": "days_in_year",
                "bVar6": "negative_time_zone_offset",
                "local_20": "remainder",
                "local_1c": "hours",
                "uStack_18": "unused_stack_var"
            },
            "code": "\nvoid update_date_time_00004634(uint *date_time,uint time_zone_offset,undefined4 unused_param)\n\n{\n  undefined *month_days;\n  int days_in_month;\n  uint day_of_month;\n  uint year;\n  int days_in_year;\n  bool negative_time_zone_offset;\n  uint *remainder;\n  uint hours;\n  undefined4 unused_stack_var;\n  \n  remainder = date_time;\n  hours = time_zone_offset;\n  unused_stack_var = unused_param;\n  if (0x3b < *date_time) {\n    divide_and_remainder_00005584(&remainder,*date_time,0x3c);\n    day_of_month = date_time[1] + (int)remainder;\n    date_time[1] = day_of_month;\n    if ((int)hours < 0) {\n      day_of_month = day_of_month - 1;\n      *date_time = hours + 0x3c;\n    }\n    else {\n      *date_time = hours;\n    }\n    if ((int)hours < 0) {\n      date_time[1] = day_of_month;\n    }\n  }\n  if (0x3b < date_time[1]) {\n    divide_and_remainder_00005584(&remainder,date_time[1],0x3c);\n    negative_time_zone_offset = (int)hours < 0;\n    year = date_time[2] + (int)remainder;\n    date_time[2] = year;\n    day_of_month = hours;\n    if (negative_time_zone_offset) {\n      day_of_month = hours + 0x3c;\n      year = year - 1;\n    }\n    if (!negative_time_zone_offset) {\n      date_time[1] = day_of_month;\n    }\n    if (negative_time_zone_offset) {\n      date_time[1] = day_of_month;\n    }\n    if (negative_time_zone_offset) {\n      date_time[2] = year;\n    }\n  }\n  if (0x17 < date_time[2]) {\n    divide_and_remainder_00005584(&remainder,date_time[2],0x18);\n    negative_time_zone_offset = (int)hours < 0;\n    year = date_time[3] + (int)remainder;\n    date_time[3] = year;\n    day_of_month = hours;\n    if (negative_time_zone_offset) {\n      day_of_month = hours + 0x18;\n      year = year - 1;\n    }\n    if (!negative_time_zone_offset) {\n      date_time[2] = day_of_month;\n    }\n    if (negative_time_zone_offset) {\n      date_time[2] = day_of_month;\n    }\n    if (negative_time_zone_offset) {\n      date_time[3] = year;\n    }\n  }\n  if (0xb < date_time[4]) {\n    divide_and_remainder_00005584(&remainder,date_time[4],0xc);\n    negative_time_zone_offset = (int)hours < 0;\n    day_of_month = date_time[5] + (int)remainder;\n    date_time[5] = day_of_month;\n    if (negative_time_zone_offset) {\n      hours = hours + 0xc;\n      day_of_month = day_of_month - 1;\n    }\n    if (!negative_time_zone_offset) {\n      date_time[4] = hours;\n    }\n    if (negative_time_zone_offset) {\n      date_time[4] = hours;\n    }\n    if (negative_time_zone_offset) {\n      date_time[5] = day_of_month;\n    }\n  }\n  month_days = PTR_DAT_000047e0;\n  day_of_month = date_time[5];\n  if ((day_of_month & 3) == 0) {\n    if (day_of_month == (day_of_month / 100) * 100) {\n      if ((day_of_month + 0x76c) % 400 == 0) {\n        days_in_year = 0x1d;\n      }\n      else {\n        days_in_year = 0x1c;\n      }\n    }\n    else {\n      days_in_year = 0x1d;\n    }\n  }\n  else {\n    days_in_year = 0x1c;\n  }\n  if ((int)date_time[3] < 1) {\n    while ((int)date_time[3] < 1) {\n      day_of_month = date_time[4];\n      date_time[4] = day_of_month - 1;\n      if (day_of_month - 1 == 0xffffffff) {\n        year = date_time[5];\n        day_of_month = year - 1;\n        date_time[4] = 0xb;\n        date_time[5] = day_of_month;\n        if ((day_of_month & 3) == 0) {\n          if (day_of_month == (day_of_month / 100) * 100) {\n            if ((year + 0x76b) % 400 == 0) {\n              days_in_year = 0x1d;\n            }\n            else {\n              days_in_year = 0x1c;\n            }\n          }\n          else {\n            days_in_year = 0x1d;\n          }\n        }\n        else {\n          days_in_year = 0x1c;\n        }\n      }\n      days_in_month = days_in_year;\n      if (date_time[4] != 1) {\n        days_in_month = *(int *)(month_days + date_time[4] * 4);\n      }\n      date_time[3] = days_in_month + date_time[3];\n    }\n  }\n  else {\n    while( true ) {\n      day_of_month = date_time[4];\n      days_in_month = days_in_year;\n      if (day_of_month != 1) {\n        days_in_month = *(int *)(month_days + day_of_month * 4);\n      }\n      if ((int)date_time[3] <= days_in_month) break;\n      date_time[3] = date_time[3] - days_in_month;\n      date_time[4] = day_of_month + 1;\n      if (day_of_month + 1 == 0xc) {\n        year = date_time[5];\n        day_of_month = year + 1;\n        date_time[4] = 0;\n        date_time[5] = day_of_month;\n        if ((day_of_month & 3) == 0) {\n          if (day_of_month % 100 == 0) {\n            if ((year + 0x76d) % 400 == 0) {\n              days_in_year = 0x1d;\n            }\n            else {\n              days_in_year = 0x1c;\n            }\n          }\n          else {\n            days_in_year = 0x1d;\n          }\n        }\n        else {\n          days_in_year = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005584"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004634",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "update_date_time_00004634"
        },
        "FUN_00001d5e": {
            "renaming": {
                "FUN_00001d5e": "getMemoryAddress_00001d5e",
                "param_1": "address"
            },
            "code": "uint16_t getMemoryAddress_00001d5e(ushort address)\n{\n    uint16_t memoryAddress = address & 0x7000;\n    uint16_t baseAddress = 0x40048000;\n    return memoryAddress | baseAddress;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d5e",
            "calling": [
                "FUN_00001f80",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "getMemoryAddress_00001d5e"
        },
        "FUN_0000191c": {
            "renaming": {
                "FUN_0000191c": "set_bit_and_update_byte_0000191c",
                "set_bit_in_byte_00001778": "set_bit_in_byte",
                "update_byte_with_mask_00001748": "update_byte_with_mask",
                "*DAT_00001958": "*data_register",
                "*PTR_DAT_0000195c": "*pointer_register"
            },
            "code": "void set_bit_and_update_byte_0000191c(void)\n{\n  set_bit_in_byte();\n  update_byte_with_mask(0x40);\n  *DAT_00001958 = *DAT_00001958 & 0x3b;\n  do {\n  } while ((data_register[6] & 0xc) != 0);\n  *PTR_DAT_0000195c = 1;\n  return;\n}",
            "called": [
                "FUN_00001778",
                "FUN_00001748"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000191c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_bit_and_update_byte_0000191c"
        },
        "FUN_000050f4": {
            "renaming": {
                "FUN_000050f4": "get_pointer_to_data_000050f4",
                "PTR_DAT_000050fc": "data_pointer"
            },
            "code": "const char* get_pointer_to_data_000050f4()\n{\n    return PTR_DAT_000050fc;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050f4",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_pointer_to_data_000050f4"
        },
        "FUN_00005a58": {
            "renaming": {
                "FUN_00005a58": "convert_data_to_string_00005a58",
                "param_1": "data",
                "param_2": "output_length",
                "param_3": "output",
                "param_4": "param_4",
                "param_5": "write_function",
                "iVar1": "i",
                "uVar2": "status",
                "uVar3": "max_output_length",
                "uVar4": "padding",
                "bVar5": "is_offset_4",
                "data_offset": "data_offset",
                "output_offset": "output_offset",
                "LAB_00005afc": "error_handling_label"
            },
            "code": "undefined4 convert_data_to_string_00005a58(undefined4 data, uint *output_length, uint *output, undefined4 param_4, code *write_function)\n{\n  int i;\n  undefined4 status;\n  uint max_output_length = param_2[4];\n  if ((int)param_2[4] < (int)param_2[2]) {\n    max_output_length = param_2[2];\n  }\n  *output_length = max_output_length;\n  if (*(char *)((int)data + 0x43) != '\\0') {\n    *output_length = max_output_length + 1;\n  }\n  if ((int)(data << 0x1a) < 0) {\n    *output_length = *output_length + 2;\n  }\n  uint output_offset = 0;\n  uint data_offset = data & 6;\n  if (data_offset == 0) {\n    for (; (int)data_offset < (int)(data[3] - *output_length); data_offset++) {\n      i = (*write_function)(data, param_4, (int)output + 0x19, 1);\n      if (i == -1) goto LAB_00005afc;\n    }\n  }\n  uint padding = (uint)*(byte *)((int)data + 0x43);\n  if (padding != 0) {\n    padding = 1;\n  }\n  if ((int)(data << 0x1a) < 0) {\n    *(undefined *)((int)data + padding + 0x43) = 0x30;\n    *(undefined *)((int)data + padding + 0x44) = *(undefined *)((int)data + 0x45);\n    padding += 2;\n  }\n  i = (*write_function)(data, param_4, (int)data + 0x43, padding);\n  if (i == -1) {\n    status = 0xffffffff;\n  }\n  else {\n    uint data_length = data[3];\n    bool is_offset_4 = (data & 6) == 4;\n    if (is_offset_4) {\n      data_length = data_length - *output_length;\n    }\n    if (is_offset_4) {\n      data_length = data_length & ~((int)data_length >> 0x1f);\n    }\n    else {\n      data_length = 0;\n    }\n    if ((int)max_output_length < (int)param_2[2]) {\n      data_length = data_length + (param_2[2] - param_2[4]);\n    }\n    for (uint output_offset = 0; data_length != output_offset; output_offset++) {\n      i = (*write_function)(data, param_4, (int)output + 0x1a, 1);\n      if (i == -1) goto LAB_00005afc;\n    }\n    status = 0;\n  }\n  return status;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005a58",
            "calling": [
                "FUN_00005b34"
            ],
            "imported": false,
            "current_name": "convert_data_to_string_00005a58"
        },
        "FUN_000056b0": {
            "renaming": {
                "FUN_000056b0": "get_dat_value_000056b0",
                "DAT_000056b4": "data_value"
            },
            "code": "int get_dat_value_000056b0(void)\n{\n  return DAT_000056b4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b0",
            "calling": [
                "FUN_00005100",
                "FUN_00004f98",
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_dat_value_000056b0"
        },
        "FUN_00003d24": {
            "renaming": {
                "FUN_00003d24": "find_nth_element_00003d24",
                "param_1": "n",
                "local_10": "i",
                "local_c": "current_element"
            },
            "code": "undefined4* find_nth_element_00003d24(int n)\n{\n  undefined4 *current_element = *(undefined4 **)PTR_DAT_00003d60;\n  int i = 0;\n  \n  while (i < n && current_element != (undefined4 *)0x0)\n  {\n    current_element = (undefined4 *)*current_element;\n    i++;\n  }\n  \n  return current_element;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d24",
            "calling": [
                "FUN_0000305c",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "find_nth_element_00003d24"
        },
        "FUN_000060cc": {
            "renaming": {
                "FUN_000060cc": "allocate_and_copy_data_000060cc",
                "param_1": "address_of_list",
                "param_2": "source_address",
                "param_3": "size",
                "param_4": "data",
                "uVar1": "new_address",
                "uVar2": "new_value",
                "add_pointer_to_list_00004b34": "add_pointer_to_list",
                "calculate_new_value_00006964": "calculate_new_value",
                "allocate_memory_00004bd0": "allocate_memory",
                "copy_data_000060b0": "copy_data"
            },
            "code": "uint allocate_and_copy_data_000060cc(uint address_of_list, uint source_address, uint size, uint data){\n  uint new_address;\n  uint new_value;\n  if (source_address != 0) {\n    if (size == 0) {\n      add_pointer_to_list(address_of_list);\n      new_address = size;\n    }\n    else {\n      new_value = calculate_new_value();\n      new_address = source_address;\n      if ((new_value < size) && (new_address = allocate_memory(address_of_list, size), new_address != 0)) {\n        copy_data(new_address, source_address, size);\n        add_pointer_to_list(address_of_list, source_address);\n      }\n    }\n    return new_address;\n  }\n  new_address = allocate_memory(address_of_list, size, size, data);\n  return new_address;\n}",
            "called": [
                "FUN_000060b0",
                "FUN_00006964",
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060cc",
            "calling": [
                "FUN_000068f0"
            ],
            "imported": false,
            "current_name": "allocate_and_copy_data_000060cc"
        },
        "FUN_00003dc4": {
            "renaming": {
                "FUN_00003dc4": "get_num_of_digits_00003dc4",
                "param_1": "num",
                "param_2": "base",
                "local_20": "quotient",
                "local_14": "digit_ptr",
                "local_10": "quotient_2",
                "local_c": "num_of_digits"
            },
            "code": "int get_num_of_digits_00003dc4(int num, uint base) {\n  uint quotient;\n  char *digit_ptr;\n  uint num_of_digits;\n  num_of_digits = 1;\n  if (DAT_00003e50 < base) {\n    num_of_digits = 10;\n  }\n  else {\n    for (quotient = 10; quotient <= base; quotient = quotient * 10) {\n      num_of_digits = num_of_digits + 1;\n    }\n  }\n  if (num != 0) {\n    digit_ptr = (char *)(num_of_digits + num);\n    quotient = base;\n    do {\n      digit_ptr = digit_ptr + -1;\n      *digit_ptr = (char)quotient + (char)(uint)((ulonglong)DAT_00003e54 * (ulonglong)quotient >> 0x23) * -10 + '0';\n      quotient = (uint)((ulonglong)DAT_00003e54 * (ulonglong)quotient >> 0x23);\n    } while (quotient != 0);\n  }\n  return num_of_digits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003dc4",
            "calling": [
                "FUN_00003e58"
            ],
            "imported": false,
            "current_name": "get_num_of_digits_00003dc4"
        },
        "FUN_000022be": {
            "renaming": {
                "FUN_000022be": "increment_and_store_000022be",
                "param_1": "array",
                "param_2": "value",
                "uVar1": "index",
                "offset": "offset"
            },
            "code": "void increment_and_store_000022be(int *array, undefined value)\n{\n  uint index = array[3];\n  array[3] = index + 1;\n  uint offset = (index & array[1] - 1U) + *array;\n  *(undefined *)(offset) = value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022be",
            "calling": [
                "FUN_00002364"
            ],
            "imported": false,
            "current_name": "increment_and_store_000022be"
        },
        "FUN_00002108": {
            "renaming": {
                "FUN_00002108": "extract_and_call_functions_00002108",
                "DAT_00002118": "data",
                "extract_bits_and_call_functions_00002028": "extract_bits_and_call_functions"
            },
            "code": "void extract_and_call_functions_00002108(uint8_t* DAT_00002118, uint8_t num_bits){\n  extract_bits_and_call_functions(DAT_00002118, num_bits);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002108",
            "calling": [],
            "imported": false,
            "current_name": "extract_and_call_functions_00002108"
        },
        "FUN_00001d80": {
            "renaming": {
                "FUN_00001d80": "getFlaggedValue_00001d80",
                "param_1": "value",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "uint getFlaggedValue_00001d80(ushort value) {\n    uint maskedValue = value & 0x1c0;\n    uint flaggedValue = maskedValue | 0x400ff000;\n    return flaggedValue;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d80",
            "calling": [
                "FUN_00001ff6",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "getFlaggedValue_00001d80"
        },
        "FUN_000033c0": {
            "renaming": {
                "FUN_000033c0": "check_and_process_alarm_000033c0",
                "iVar1": "date_calculation_result",
                "auStack_2c": "alarm_data",
                "calculate_date_and_increment_value_00002690": "calculate_date_and_increment_value_00002690",
                "FUN_00004db8": "FUN_00004db8",
                "PTR_s_rtc__error_getting_alarm_000033f0": "PTR_s_rtc__error_getting_alarm_000033f0",
                "process_data_00003378": "process_alarm_data"
            },
            "code": "bool check_and_process_alarm_000033c0(void)\n{\n  int date_calculation_result;\n  undefined alarm_data[36];\n  date_calculation_result = calculate_date_and_increment_value_00002690(alarm_data);\n  if (date_calculation_result != 0) {\n    process_input_00004db8(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    process_alarm_data(alarm_data);\n  }\n  return date_calculation_result != 0;\n}",
            "called": [
                "FUN_00003378",
                "FUN_00004db8",
                "FUN_00002690"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "check_and_process_alarm_000033c0",
            "code_backup": "\nbool FUN_000033c0(void)\n\n{\n  int iVar1;\n  undefined auStack_2c [36];\n  \n  iVar1 = calculate_date_and_increment_value_00002690(auStack_2c);\n  if (iVar1 != 0) {\n    FUN_00004db8(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    process_data_00003378(auStack_2c);\n  }\n  return iVar1 != 0;\n}\n\n"
        },
        "FUN_00002b10": {
            "renaming": {
                "FUN_00002b10": "parse_command_line_args_00002b10",
                "param_1": "argc",
                "param_2": "argv",
                "local_48": "args_and_argv",
                "local_3c": "command",
                "local_38": "command_args",
                "local_34": "num_commands",
                "local_2d": "quote_type",
                "local_2c": "escape_char_ptr",
                "local_28": "char_ptr",
                "local_24": "arg_ptr",
                "local_20": "i",
                "local_1c": "num_escape_chars",
                "local_18": "num_args",
                "local_14": "curr_arg_start"
            },
            "code": "void parse_command_line_args_00002b10(uint32_t argc, char **argv)\\n{\\n    int num_args = 0;\\n    int num_escape_chars = 0;\\n    char *curr_arg_start = argv[0];\\n    while(*curr_arg_start != 0)\\n    {\\n        if(*curr_arg_start > 0x20)\\n        {\\n            if((*curr_arg_start == \"\\\"\") || (*curr_arg_start == \"\\\"\"))\\n            {\\n                char quote_type = *curr_arg_start;\\n                do\\n                {\\n                    curr_arg_start++;\\n                    if(*curr_arg_start == 0)\\n                    {\\n                        print_command_not_found();\\n                        return;\\n                    }\\n                    if(*curr_arg_start == \"\\\\\")\\n                    {\\n                        num_escape_chars++;\\n                        curr_arg_start++;\\n                        if(*curr_arg_start == 0)\\n                        {\\n                            print_command_not_found();\\n                            return;\\n                        }\\n                    }\\n                } while(quote_type != *curr_arg_start);\\n                if(*(curr_arg_start + 1) > 0x20)\\n                {\\n                    print_command_not_found();\\n                    return;\\n                }\\n            }\\n            else\\n            {\\n                do\\n                {\\n                    if(*curr_arg_start == \"\\\\\")\\n                    {\\n                        num_escape_chars++;\\n                        curr_arg_start++;\\n                        if(*curr_arg_start == 0)\\n                        {\\n                            print_command_not_found();\\n                            return;\\n                        }\\n                    }\\n                    curr_arg_start++;\\n                    if(*curr_arg_start == \"\\\"\")\\n                    {\\n                        print_command_not_found();\\n                        return;\\n                    }\\n                } while(*curr_arg_start > 0x20);\\n            }\\n            num_args++;\\n        }\\n        if(*curr_arg_start == 0)\\n        {\\n            break;\\n        }\\n        *curr_arg_start = 0;\\n        curr_arg_start++;\\n    }\\n    if(num_args > 0)\\n    {\\n        char **args = (char **)(&argv[0] - ((num_args + 1) * sizeof(char *)));\\n        args[num_args] = NULL;\\n        curr_arg_start = argv[0];\\n        for(int i = 0; i < num_args; i++)\\n        {\\n            while(*curr_arg_start == 0)\\n            {\\n                curr_arg_start++;\\n            }\\n            if((*curr_arg_start == \"\\\"\") || (*curr_arg_start == \"\\\"\"))\\n            {\\n                curr_arg_start++;\\n            }\\n            args[i] = curr_arg_start;\\n            while(*curr_arg_start != 0)\\n            {\\n                curr_arg_start++;\\n            }\\n        }\\n        for(char **arg_ptr = args; *arg_ptr != NULL; arg_ptr++)\\n        {\\n            for(char *char_ptr = *arg_ptr; num_escape_chars > 0 && *char_ptr != 0; char_ptr++)\\n            {\\n                if(*char_ptr == \"\\\\\")\\n                {\\n                    for(char *copy_ptr = char_ptr; *copy_ptr != 0; copy_ptr++)\\n                    {\\n                        *copy_ptr = *(copy_ptr + 1);\\n                    }\\n                    num_escape_chars--;\\n                    if(num_escape_chars == 0)\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        code *command = find_matching_command(argv[0], args);\\n        if(command == NULL)\\n        {\\n            if(compare_bytes(PTR_DAT_00002d8c, args) == 0)\\n            {\\n                print_command_description();\\n            }\\n            else\\n            {\\n                print_command_not_found();\\n            }\\n        }\\n        else\\n        {\\n            (*command)(num_args, args);\\n        }\\n    }\\n    return;\\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00002a88",
                "FUN_00004db8",
                "FUN_00004e52",
                "FUN_00002a18"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002b10",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "parse_command_line_args_00002b10"
        },
        "FUN_00001b10": {
            "renaming": {
                "FUN_00001b10": "process_data_00001b10",
                "param_1": "data_size",
                "uVar1": "result",
                "PTR_DAT_00001bb4": "data_table",
                "PTR_DAT_00001bb0": "data_table_size"
            },
            "code": "uint32_t process_data_00001b10(byte data_size) {\n  uint32_t result;\n  if (data_size >= 8) {\n    result = 0xffffffff;\n  }\n  else {\n    do {\n      switch(PTR_DAT_00001bb4[(uint)data_size + (uint)(byte)*PTR_DAT_00001bb0 * 8]) {\n      case 0:\n        initialize_data();\n        break;\n      case 1:\n        set_bit_and_update_byte();\n        break;\n      case 2:\n        update_memory_and_set_flag();\n        break;\n      case 3:\n        set_bit_update_clear_memory();\n        break;\n      case 4:\n        set_offset_and_clear_memory();\n        break;\n      case 5:\n        set_offset_and_clear_memory_2();\n        break;\n      case 6:\n        initialize_memory();\n        break;\n      case 7:\n        set_bitmask();\n        break;\n      default:\n        return 0xffffffff;\n      }\n    } while (data_size != *PTR_DAT_00001bb0);\n    result = 0;\n  }\n  return result;\n}",
            "called": [
                "FUN_00001a18",
                "FUN_000019c0",
                "FUN_00001960",
                "FUN_00001ad4",
                "FUN_00001a3c",
                "FUN_0000191c",
                "FUN_000018bc",
                "FUN_00001a60"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001b10",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "process_data_00001b10"
        },
        "FUN_000047e4": {
            "renaming": {
                "FUN_000047e4": "calculate_date_000047e4",
                "param_1": "date_array",
                "lVar1": "total_days",
                "lVar2": "updated_total_days",
                "piVar3": "data_array",
                "uVar4": "year",
                "iVar5": "days_since_jan1",
                "iVar6": "day_of_week",
                "iVar7": "lower_32_bits",
                "iVar11": "days_since_jan1_1900",
                "uVar8": "raw_year",
                "uVar9": "i",
                "uVar10": "last_leap_year",
                "uVar12": "raw_days_since_jan1_1900",
                "uVar13": "is_leap_year",
                "uVar14": "days_since_last_leap_year",
                "uVar15": "xor_result",
                "bVar16": "is_leap_day"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\nundefined8 calculate_date_000047e4(int *date_array)\n\n{\n  longlong total_days;\n  longlong updated_total_days;\n  int *data_array;\n  uint year;\n  int days_since_jan1;\n  int day_of_week;\n  int lower_32_bits;\n  uint raw_year;\n  uint i;\n  uint last_leap_year;\n  int days_since_jan1_1900;\n  uint raw_days_since_jan1_1900;\n  uint is_leap_year;\n  uint days_since_last_leap_year;\n  uint xor_result;\n  bool is_leap_day;\n  \n  data_array = (int *)get_dat_value_000056b0();\n  update_date_time_00004634(date_array);\n  raw_days_since_jan1_1900 = date_array[5];\n  days_since_jan1_1900 = date_array[3] + -1 + *(int *)(PTR_DAT_00004adc + date_array[4] * 4);\n  if (((1 < date_array[4]) && ((raw_days_since_jan1_1900 & 3) == 0)) &&\n     ((raw_days_since_jan1_1900 != (raw_days_since_jan1_1900 / 100) * 100 || (raw_days_since_jan1_1900 + 0x76c == ((raw_days_since_jan1_1900 + 0x76c) / 400) * 400)))) {\n    days_since_jan1_1900 = days_since_jan1_1900 + 1;\n  }\n  date_array[7] = days_since_jan1_1900;\n  if (20000 < (int)&PTR_DAT_00002710 + raw_days_since_jan1_1900) {\n    lower_32_bits = -1;\n    days_since_jan1 = -1;\n    goto LAB_00004aba;\n  }\n  if ((int)raw_days_since_jan1_1900 < 0x47) {\n    if (raw_days_since_jan1_1900 != 0x46) {\n      for (i = 0x45; (int)raw_days_since_jan1_1900 < (int)i; i = i - 1) {\n        if ((i & 3) == 0) {\n          if (i == (i / 100) * 100) {\n            if ((i + 0x76c) % 400 == 0) {\n              lower_32_bits = 0x16e;\n            }\n            else {\n              lower_32_bits = 0x16d;\n            }\n          }\n          else {\n            lower_32_bits = 0x16e;\n          }\n        }\n        else {\n          lower_32_bits = 0x16d;\n        }\n        days_since_jan1_1900 = days_since_jan1_1900 - lower_32_bits;\n      }\n      if ((i & 3) == 0) {\n        if (raw_days_since_jan1_1900 == (raw_days_since_jan1_1900 / 100) * 100) {\n          lower_32_bits = 0x16d;\n          if ((raw_days_since_jan1_1900 + 0x76c) % 400 == 0) {\n            lower_32_bits = 0x16e;\n          }\n        }\n        else {\n          lower_32_bits = 0x16e;\n        }\n      }\n      else {\n        lower_32_bits = 0x16d;\n      }\n      days_since_jan1_1900 = days_since_jan1_1900 - lower_32_bits;\n    }\n  }\n  else {\n    i = 0x46;\n    do {\n      if ((i & 3) == 0) {\n        if (i % 100 == 0) {\n          if ((i + 0x76c) % 400 == 0) {\n            lower_32_bits = 0x16e;\n          }\n          else {\n            lower_32_bits = 0x16d;\n          }\n        }\n        else {\n          lower_32_bits = 0x16e;\n        }\n      }\n      else {\n        lower_32_bits = 0x16d;\n      }\n      i = i + 1;\n      days_since_jan1_1900 = days_since_jan1_1900 + lower_32_bits;\n    } while (raw_days_since_jan1_1900 != i);\n  }\n  total_days = (longlong)DAT_00004ae0 * (longlong)days_since_jan1_1900 +\n          (longlong)(date_array[2] * 0xe10 + date_array[1] * 0x3c + *date_array);\n  xor_result = (uint)total_days;\n  lower_32_bits = (int)((ulonglong)total_days >> 0x20);\n  get_pointer_to_data_000050e8();\n  process_data_00005100();\n  i = *(uint *)PTR_DAT_00004ae4;\n  if (*(uint *)PTR_DAT_00004ae4 == 0) {\nLAB_00004934:\n    raw_days_since_jan1_1900 = data_array[10];\n    lower_32_bits = (uint)total_days + raw_days_since_jan1_1900;\n    days_since_jan1 = (int)((ulonglong)total_days >> 0x20) +\n            ((int)raw_days_since_jan1_1900 >> 0x1f) + (uint)CARRY4((uint)total_days,raw_days_since_jan1_1900);\n  }\n  else {\n    days_since_last_leap_year = date_array[8];\n    is_leap_year = days_since_last_leap_year;\n    if (0 < (int)days_since_last_leap_year) {\n      is_leap_year = 1;\n    }\n    if ((data_array[1] == date_array[5] + 0x76c) || (days_since_jan1 = calculate_day_of_week_00004f98(), days_since_jan1 != 0)) {\n      last_leap_year = data_array[0x14];\n      year = data_array[0x12];\n      raw_year = data_array[10];\n      i = year - raw_year;\n      days_since_jan1 = (data_array[0x13] - ((int)raw_year >> 0x1f)) - (uint)(year < raw_year);\n      if (((int)((lower_32_bits - days_since_jan1) - (uint)(xor_result < i)) < 0 ==\n           (SBORROW4(lower_32_bits,days_since_jan1) != SBORROW4(lower_32_bits - days_since_jan1,(uint)(xor_result < i)))) &&\n         (day_of_week = (data_array[0x13] - ((int)last_leap_year >> 0x1f)) - (uint)(year < last_leap_year),\n         is_leap_day = xor_result < year - last_leap_year,\n         (int)((lower_32_bits - day_of_week) - (uint)is_leap_day) < 0 !=\n         (SBORROW4(lower_32_bits,day_of_week) != SBORROW4(lower_32_bits - day_of_week,(uint)is_leap_day)))) goto LAB_00004a88;\n      year = data_array[8] - last_leap_year;\n      day_of_week = (data_array[9] - ((int)last_leap_year >> 0x1f)) - (uint)((uint)data_array[8] < last_leap_year);\n      if (*data_array != 0) {\n        if ((int)((lower_32_bits - day_of_week) - (uint)(xor_result < year)) < 0 ==\n            (SBORROW4(lower_32_bits,day_of_week) != SBORROW4(lower_32_bits - day_of_week,(uint)(xor_result < year))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        i = 0;\n        if ((int)days_since_last_leap_year < 0) goto LAB_00004934;\nLAB_00004a14:\n        xor_result = is_leap_year ^ i;\n        is_leap_year = i;\n        if (xor_result == 1) {\n          if (i == 0) {\n            lower_32_bits = last_leap_year - raw_year;\n          }\n          else {\n            lower_32_bits = raw_year - last_leap_year;\n          }\n          days_since_jan1 = date_array[3];\n          *date_array = *date_array + lower_32_bits;\n          updated_total_days = total_days + lower_32_bits;\n          update_date_time_00004634(date_array);\n          days_since_jan1 = date_array[3] - days_since_jan1;\n          total_days = total_days + lower_32_bits;\n          if (days_since_jan1 != 0) {\n            if (days_since_jan1 < 2) {\n              if (days_since_jan1 == -2 || days_since_jan1 + 2 < 0 != SCARRY4(days_since_jan1,2)) {\n                days_since_jan1 = 1;\n              }\n            }\n            else {\n              days_since_jan1 = -1;\n            }\n            lower_32_bits = days_since_jan1 + date_array[7];\n            days_since_jan1_1900 = days_since_jan1_1900 + days_since_jan1;\n            if (lower_32_bits < 0) {\n              i = raw_days_since_jan1_1900 - 1;\n              if ((i & 3) == 0) {\n                if (i == (i / 100) * 100) {\n                  lower_32_bits = 0x16d;\n                  if ((raw_days_since_jan1_1900 + 0x76b) % 400 != 0) {\n                    lower_32_bits = 0x16c;\n                  }\n                }\n                else {\n                  lower_32_bits = 0x16d;\n                }\n              }\n              else {\n                lower_32_bits = 0x16c;\n              }\n            }\n            else {\n              if ((raw_days_since_jan1_1900 & 3) == 0) {\n                if (raw_days_since_jan1_1900 == (raw_days_since_jan1_1900 / 100) * 100) {\n                  days_since_jan1 = 0x16d;\n                  if ((raw_days_since_jan1_1900 + 0x76c) % 400 == 0) {\n                    days_since_jan1 = 0x16e;\n                  }\n                }\n                else {\n                  days_since_jan1 = 0x16e;\n                }\n              }\n              else {\n                days_since_jan1 = 0x16d;\n              }\n              if (days_since_jan1 <= lower_32_bits) {\n                lower_32_bits = lower_32_bits - days_since_jan1;\n              }\n            }\n            date_array[7] = lower_32_bits;\n            total_days = updated_total_days;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((lower_32_bits - day_of_week) - (uint)(xor_result < year)) < 0 !=\n          (SBORROW4(lower_32_bits,day_of_week) != SBORROW4(lower_32_bits - day_of_week,(uint)(xor_result < year)))) {\nLAB_0000491e:\n        if ((int)((lower_32_bits - days_since_jan1) - (uint)(xor_result < i)) < 0 ==\n            (SBORROW4(lower_32_bits,days_since_jan1) != SBORROW4(lower_32_bits - days_since_jan1,(uint)(xor_result < i))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)days_since_last_leap_year) {\n        i = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      i = is_leap_year;\n      if (is_leap_year != 1) goto LAB_00004934;\n    }\n    raw_days_since_jan1_1900 = data_array[0x14];\n    lower_32_bits = (uint)total_days + raw_days_since_jan1_1900;\n    days_since_jan1 = (int)((ulonglong)total_days >> 0x20) +\n            ((int)raw_days_since_jan1_1900 >> 0x1f) + (uint)CARRY4((uint)total_days,raw_days_since_jan1_1900);\n    i = 1;\n  }\n  get_pointer_to_data_000050f4();\n  date_array[8] = i;\n  date_array[6] = (days_since_jan1_1900 + 4U) % 7;\nLAB_00004aba:\n  return CONCAT44(days_since_jan1,lower_32_bits);\n}\n\n",
            "called": [
                "FUN_00004634",
                "FUN_000050e8",
                "FUN_00005100",
                "FUN_00004f98",
                "FUN_000056b0",
                "FUN_000050f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000047e4",
            "calling": [
                "FUN_00002600",
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "calculate_date_000047e4"
        },
        "FUN_000023c8": {
            "renaming": {
                "FUN_000023c8": "trigger_software_interrupt_000023c8",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void trigger_software_interrupt_000023c8(void)\n{\n  software_interrupt(SOFTWARE_INTERRUPT_CODE);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023c8",
            "calling": [
                "FUN_000023d0"
            ],
            "imported": false,
            "current_name": "trigger_software_interrupt_000023c8"
        },
        "FUN_00002e48": {
            "renaming": {
                "FUN_00002e48": "process_data_and_wrap_00002e48",
                "0x3e": "data1",
                "0x20": "data2",
                "*(undefined4 *)(*DAT_00002e68 + 8)": "ptr"
            },
            "code": "void process_data_and_wrap_00002e48(void)\n{\n    int data1 = 0x3e;\n    int data2 = 0x20;\n    int* *(undefined4 *)(*DAT_00002e68 + 8) = *(int**)(DAT_00002e68 + 8);\n    process_data_wrapper_00002a00(data1);\n    process_data_wrapper_00002a00(data2);\n    process_data_000041d0(**(undefined4 *)(*DAT_00002e68 + 8));\n    return;\n}",
            "called": [
                "FUN_00002a00",
                "FUN_000041d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e48",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "process_data_and_wrap_00002e48"
        },
        "FUN_00000930": {
            "renaming": {
                "FUN_00000930": "run_interrupt_handler_00000930",
                "is_interrupt_enabled_00000cf0": "check_interrupt_status",
                "software_interrupt": "trigger_interrupt"
            },
            "code": "void run_interrupt_handler_00000930(void)\n{\n  bool is_interrupt_enabled = check_interrupt_status();\n  trigger_interrupt(1);\n  while(true) { }\n}",
            "called": [
                "FUN_00000cf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000930",
            "calling": [
                "FUN_00000f8c",
                "FUN_00000794"
            ],
            "imported": false,
            "current_name": "run_interrupt_handler_00000930"
        },
        "FUN_00001348": {
            "renaming": {
                "FUN_00001348": "check_and_set_flag_00001348",
                "PTR_DAT_0000135c": "flag_ptr",
                "set_flag_0000093c": "set_flag"
            },
            "code": "void check_and_set_flag_00001348(void)\n{\n    int* PTR_DAT_0000135c = (int*)PTR_DAT_0000135c;\n    if (*PTR_DAT_0000135c != 0)\n    {\n        set_flag_0000093c();\n    }\n    return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001348",
            "calling": [
                "FUN_00001628"
            ],
            "imported": false,
            "current_name": "check_and_set_flag_00001348"
        },
        "FUN_00001d3a": {
            "renaming": {
                "FUN_00001d3a": "set_calculated_value_to_1_and_return_00001d3a",
                "param_1": "value_ptr",
                "param_2": "param_2",
                "puVar1": "ptr_to_calculated_value",
                "calculate_value_00001d08": "calculate_value"
            },
            "code": "void set_calculated_value_to_1_and_return_00001d3a(void* value_ptr, int param_2)\n{\n  void* calculated_value_ptr = (void*)calculate_value(param_1,param_2);\n  int* ptr_to_calculated_value = (int*)calculated_value_ptr;\n  *ptr_to_calculated_value = 1;\n  return;\n}",
            "called": [
                "FUN_00001d08"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d3a",
            "calling": [
                "FUN_00001ddc"
            ],
            "imported": false,
            "current_name": "set_calculated_value_to_1_and_return_00001d3a"
        },
        "FUN_00002434": {
            "renaming": {
                "FUN_00002434": "update_linked_list_00002434",
                "param_1": "head",
                "param_2": "value",
                "uVar1": "interrupt_enabled",
                "enableIRQinterrupts_if_privileged_00000d0c": "enable_IRQ_interrupts_if_privileged",
                "PTR_DAT_000024b8": "PTR_DAT_current_head",
                "iVar2": "current_head",
                "check_interrupt_enabled_00000cd0": "check_interrupt_enabled",
                "findAndInsert_00001034": "find_and_insert",
                "*param_1": "*head",
                "set_flag_0000093c": "set_flag"
            },
            "code": "int update_linked_list_00002434(int *head, int value) {\n  int interrupt_enabled = check_interrupt_enabled();\n  if (*head == 0) {\n    *head = -1;\n    enable_IRQ_interrupts_if_privileged(interrupt_enabled);\n    return 1;\n  }\n  else if (value == 0) {\n    enable_IRQ_interrupts_if_privileged(interrupt_enabled);\n    return 0;\n  }\n  else {\n    int current_head = *(int *)PTR_DAT_000024b8;\n    update_linked_list_00002434_00000698(current_head, 2);\n    if (*head == -1) {\n      *head = current_head + 8;\n      *(int *)*head = 0;\n    }\n    else {\n      find_and_insert(head, current_head);\n    }\n    enable_IRQ_interrupts_if_privileged(interrupt_enabled);\n    set_flag();\n    return 1;\n  }\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000d0c",
                "FUN_0000093c",
                "FUN_00001034",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002434",
            "calling": [
                "FUN_0000129c"
            ],
            "imported": false,
            "current_name": "update_linked_list_00002434"
        },
        "FUN_00005700": {
            "renaming": {
                "FUN_00005700": "allocate_and_initialize_object_00005700",
                "param_1": "object_id",
                "param_2": "object_ptr",
                "uVar1": "flag_value",
                "iVar2": "allocated_memory",
                "local_18": "object_size",
                "local_14": "temp_ptr"
            },
            "code": "void allocate_and_initialize_object_00005700(int object_id, int *object_ptr)\n{\n    ushort flag_value;\n    int object_size;\n    int *temp_ptr;\n    \n    if ((uint)*(ushort *)(object_ptr + 3) << 0x1e > 0xffffffff80000000) {\n        object_size = object_id;\n        temp_ptr = object_ptr;\n        flag_value = check_value_and_set_flag(object_id, object_ptr, &object_size, &temp_ptr);\n        \n        int allocated_memory = allocate_memory(object_id, object_size);\n        if (allocated_memory != 0) {\n            *(undefined **)(object_id + 0x28) = PTR_DAT_0000577c;\n            *object_ptr = allocated_memory;\n            *(ushort *)(object_ptr + 3) = *(ushort *)(object_ptr + 3) | 0x80;\n            object_ptr[5] = object_size;\n            object_ptr[4] = allocated_memory;\n            \n            if (temp_ptr != (int *)0x0) {\n                int is_valid = is_valid_input(object_id, (int)*(short *)((int)object_ptr + 0xe));\n                if (is_valid != 0) {\n                    *(ushort *)(object_ptr + 3) = *(ushort *)(object_ptr + 3) & 0xfffc | 1;\n                }\n            }\n            \n            *(ushort *)(object_ptr + 3) = flag_value | *(ushort *)(object_ptr + 3);\n            return;\n        }\n        \n        if ((int)(short)*(ushort *)(object_ptr + 3) << 0x16 < 0) {\n            return;\n        }\n        \n        *(ushort *)(object_ptr + 3) = *(ushort *)(object_ptr + 3) & 0xfffc | 2;\n    }\n    \n    *object_ptr = (int)object_ptr + 0x47;\n    object_ptr[4] = (int)object_ptr + 0x47;\n    object_ptr[5] = 1;\n    return;\n}",
            "called": [
                "FUN_00000534",
                "FUN_00004bd0",
                "FUN_000056b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005700",
            "calling": [
                "FUN_000054a8",
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_object_00005700"
        },
        "FUN_00002798": {
            "renaming": {
                "FUN_00002798": "check_flag_if_set_00002798",
                "PTR_DAT_000027ac": "flag_ptr",
                "set_flag_0000093c": "set_flag"
            },
            "code": "void check_flag_if_set_00002798(void)\n{\n  int* PTR_DAT_000027ac = (int*)PTR_DAT_000027ac;\n  if (*PTR_DAT_000027ac != 0) {\n    set_flag_0000093c();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002798",
            "calling": [
                "FUN_00002994"
            ],
            "imported": false,
            "current_name": "check_flag_if_set_00002798"
        },
        "FUN_00003524": {
            "renaming": {
                "FUN_00003524": "process_rtc_command_00003524",
                "param_1": "num_args",
                "param_2": "command_args",
                "iVar1": "compare_result",
                "uVar2": "should_return_error",
                "initialize_rtc_commands_000034c0": "initialize_rtc_commands",
                "compare_strings_00004e66": "compare_strings",
                "PTR_s_poweron_00003638": "PTR_s_poweron",
                "initialize_data_flag_000026d8": "initialize_data_flag",
                "PTR_s_poweroff_0000363c": "PTR_s_poweroff",
                "clear_bit_in_uint_array_and_return_000026e4": "clear_bit_in_uint_array_and_return",
                "PTR_s_clearalarm_00003640": "PTR_s_clearalarm",
                "clear_flags_and_set_ptr_to_null_000026c0": "clear_flags_and_set_ptr_to_null",
                "PTR_s_getalarm_00003644": "PTR_s_getalarm",
                "check_and_process_alarm_000033c0": "check_and_process_alarm",
                "PTR_s_setalarm_00003648": "PTR_s_setalarm",
                "calculate_score_and_execute_function_000033f4": "calculate_score_and_execute_function",
                "PTR_s_gettime_0000364c": "PTR_s_gettime",
                "checkTimeValidityAndProcessData_00003444": "check_time_validity_and_process_data",
                "PTR_s_settime_00003650": "PTR_s_settime",
                "process_data_00004c84": "process_data",
                "PTR_s_unknown_command_or_missing_param_00003654": "PTR_s_unknown_command_or_missing_param",
                "calculate_score_and_parse_input_00003478": "calculate_score_and_parse_input"
            },
            "code": "int process_rtc_command_00003524(int num_args, int command_args)\n{\n    int compare_result;\n    int should_return_error = 1;\n\n    if (num_args < 2) {\n        initialize_rtc_commands();\n        should_return_error = 0;\n    }\n    else {\n        compare_result = compare_strings(command_args + 4, PTR_s_poweron_00003638_00003638, 7);\n        if (compare_result == 0) {\n            initialize_data_flag();\n            should_return_error = 0;\n        }\n        else {\n            compare_result = compare_strings(command_args + 4, PTR_s_poweroff_0000363c_0000363c, 8);\n            if (compare_result == 0) {\n                clear_bit_in_uint_array_and_return();\n                should_return_error = 0;\n            }\n            else {\n                compare_result = compare_strings(command_args + 4, PTR_s_clearalarm_00003640_00003640, 8);\n                if (compare_result == 0) {\n                    clear_flags_and_set_ptr_to_null();\n                    should_return_error = 0;\n                }\n                else {\n                    compare_result = compare_strings(command_args + 4, PTR_s_getalarm_00003644_00003644, 8);\n                    if (compare_result == 0) {\n                        check_and_process_alarm();\n                        should_return_error = 0;\n                    }\n                    else {\n                        compare_result = compare_strings(command_args + 4, PTR_s_setalarm_00003648_00003648, 8);\n                        if ((compare_result == 0) && (num_args == 4)) {\n                            calculate_score_and_execute_function(command_args + 8);\n                            should_return_error = 0;\n                        }\n                        else {\n                            compare_result = compare_strings(command_args + 4, PTR_s_gettime_0000364c_0000364c, 7);\n                            if (compare_result == 0) {\n                                check_time_validity_and_process_data();\n                                should_return_error = 0;\n                            }\n                            else {\n                                compare_result = compare_strings(command_args + 4, PTR_s_settime_00003650_00003650, 7);\n                                if ((compare_result != 0) || (num_args != 4)) {\n                                    process_data(PTR_s_unknown_command_or_missing_param_00003654_00003654, command_args + 4);\n                                    initialize_rtc_commands();\n                                }\n                                else {\n                                    calculate_score_and_parse_input(command_args + 8);\n                                    should_return_error = 0;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return should_return_error;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_000026c0",
                "FUN_00003478",
                "FUN_000033f4",
                "FUN_000026d8",
                "FUN_00003444",
                "FUN_00004e66",
                "FUN_000034c0",
                "FUN_000033c0",
                "FUN_000026e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003524",
            "calling": [],
            "imported": false,
            "current_name": "process_rtc_command_00003524"
        },
        "FUN_00001bb8": {
            "renaming": {
                "FUN_00001bb8": "clear_and_update_data_00001bb8",
                "DAT_00001c74": "control_data",
                "DAT_00001c78": "data_1",
                "DAT_00001c7c": "data_2",
                "PTR_DAT_00001c80": "data_pointer"
            },
            "code": "void clear_and_update_data_00001bb8(void)\n{\n  if ((DAT_00001c74[1] & 2) != 0) {\n    clear_memory_at_offset_00001710(DAT_00001c78,1);\n  }\n  if ((DAT_00001c74[5] & 0x40) != 0) {\n    if ((*DAT_00001c74 & 0xc0) == 0) {\n      *DAT_00001c74 = *DAT_00001c74 & 0x3f | 0x80;\n      while ((DAT_00001c74[6] & 0xc) != 8);\n    }\n    clear_memory_at_offset_00001710(DAT_00001c7c,6);\n    while ((DAT_00001c74[6] & 0x20) != 0);\n  }\n  update_byte_with_mask_00001748(0);\n  *DAT_00001c74 = *DAT_00001c74 & 0x3b | 4;\n  while ((DAT_00001c74[6] & 0x10) == 0);\n  while ((DAT_00001c74[6] & 0xc) != 0);\n  *PTR_DAT_00001c80 = 0;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001bb8",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "clear_and_update_data_00001bb8"
        },
        "FUN_0000428c": {
            "renaming": {
                "FUN_0000428c": "execute_nothingness_0000428c",
                "DAT_00004294": "DAT_nothingness",
                "do_nothing_000045e8": "do_nothing"
            },
            "code": "void execute_nothingness_0000428c(void)\n{\n  do_nothing(DAT_00004294);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000428c",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "execute_nothingness_0000428c"
        },
        "FUN_0000404c": {
            "renaming": {
                "FUN_0000404c": "decode_data_0000404c",
                "param_1": "data",
                "param_2": "params",
                "iVar1": "result",
                "piVar2": "param_ptr",
                "uVar3": "data_len",
                "uVar4": "data_flags",
                "iVar5": "data_offset",
                "pcVar6": "chunk_decoder",
                "iVar7": "data_offset_remaining",
                "uVar8": "data_offset_temp",
                "bVar9": "is_chunked",
                "chunk_result": "chunk_size"
            },
            "code": "int decode_data_0000404c(uint *data, int *params) {\n    int result = 0;\n    int *param_ptr;\n    uint data_len;\n    ushort data_flags;\n    int data_offset;\n    int data_chunk_size;\n    int chunk_result;\n    code *chunk_decoder;\n    uint data_offset_remaining;\n    bool is_chunked;\n    \n    data_flags = *(ushort *)(params + 3);\n    data_len = (uint)data_flags;\n    \n    if ((int)(data_len << 0x1c) < 0) {\n        data_chunk_size = params[4];\n        if (data_chunk_size != 0) {\n            data_offset = data_len << 0x1e;\n            is_chunked = data_offset == 0;\n            data_offset = is_chunked ? params[5] : 0;\n            *params = data_chunk_size;\n            params[2] = data_offset;\n            data_offset_remaining = *params - data_chunk_size;\n            while (data_offset_remaining > 0) {\n                chunk_decoder = (code *)params[10];\n                chunk_result = (*chunk_decoder)(data, params[8], data_chunk_size, data_offset_remaining);\n                if (chunk_result < 1) {\n                    *(ushort *)(params + 3) = *(ushort *)(params + 3) | 0x40;\n                    return -1;\n                }\n                data_chunk_size += chunk_result;\n                data_offset_remaining = *params - data_chunk_size;\n            }\n        }\n    }\n    else {\n        if ((params[1] < 1) && (params[0x10] < 1)) {\n            return 0;\n        }\n        chunk_decoder = (code *)params[0xb];\n        if (chunk_decoder == (code *)0x0) {\n            return 0;\n        }\n        data_offset = *data;\n        *data = 0;\n        if ((data_flags & 0x1000) == 0) {\n            chunk_result = (*chunk_decoder)(data, params[8], data_len & 0x1000, 1);\n            if ((chunk_result == -1) && (*data != 0)) {\n                if ((*data == 0x1d) || (*data == 0x16)) {\n                    *data = data_offset;\n                    return 0;\n                }\n                data_flags = *(ushort *)(params + 3);\n                goto LAB_00004104;\n            }\n        }\n        else {\n            chunk_result = params[0x15];\n        }\n        if (((int)((uint)*(ushort *)(params + 3) << 0x1d) < 0) && (params[0xd] != 0)) {\n            if (chunk_result == -1) {\n                chunk_result = 0;\n            }\n            chunk_result -= params[1];\n            if (params[0xd] != params + 0x11) {\n                add_pointer_to_list_00004b34(data);\n            }\n            params[0xd] = 0;\n        }\n        chunk_result = (*chunk_decoder)(data, params[8], chunk_result, 0);\n        data_flags = *(ushort *)(params + 3);\n        if ((chunk_result == -1) && ((0x1d < *data) || (-1 < (int)((data_flags >> (*data & 0xff)) << 0x1f)))) {\n            *(ushort *)(params + 3) = data_flags | 0x40;\n            return chunk_result;\n        }\n        params[1] = 0;\n        *params = params[4];\n        if (((int)((uint)data_flags << 0x13) < 0) && ((chunk_result != -1) || (*data == 0))) {\n            params[0x15] = chunk_result;\n        }\n        param_ptr = (int *)params[0xd];\n        *data = data_offset;\n        if (param_ptr != (int *)0x0) {\n            if (param_ptr != params + 0x11) {\n                add_pointer_to_list_00004b34(data);\n            }\n            params[0xd] = 0;\n            return 0;\n        }\n    }\n    return 0;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000404c",
            "calling": [
                "FUN_00004158",
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "decode_data_0000404c"
        },
        "FUN_00002f74": {
            "renaming": {
                "FUN_00002f74": "print_sensor_classes_00002f74",
                "local_14": "sensor_list",
                "local_18": "sensor_count",
                "uVar1": "sensor_class",
                "PTR_DAT_00002fd0": "sensor_list_ptr",
                "PTR_s_No_devices_found_00002fd8": "no_devices_msg",
                "PTR_s_ID_Class_Name_00002fd4": "id_class_name_msg",
                "lookup_sensor_class_000039e8": "lookup_sensor_class",
                "PTR_s___i__s__s_00002fdc": "sensor_info_msg"
            },
            "code": "void print_sensor_classes_00002f74(void)\n{\n    undefined4 *sensor_list = *(undefined4 **)PTR_DAT_00002fd0;\n    int sensor_count = 0;\n    if (sensor_list == (undefined4 *)0x0) {\n        process_input_00004db8(PTR_s_No_devices_found_00002fd8);\n    }\n    else {\n        process_input_00004db8(PTR_s_ID_Class_Name_00002fd4);\n    }\n    for (; sensor_list != (undefined4 *)0x0; sensor_list = (undefined4 *)*sensor_list) {\n        undefined4 sensor_info = sensor_list[2];\n        undefined sensor_class_id = *(undefined *)(sensor_list[3] + 8);\n        undefined4 sensor_class = lookup_sensor_class_000039e8(sensor_class_id);\n        process_data_00004c84(PTR_s___i__s__s_00002fdc, sensor_count, sensor_class, sensor_info);\n        sensor_count++;\n    }\n    return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_000039e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f74",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "print_sensor_classes_00002f74",
            "code_backup": "\nvoid FUN_00002f74(void)\n\n{\n  undefined4 uVar1;\n  int local_18;\n  undefined4 *local_14;\n  \n  local_14 = *(undefined4 **)PTR_DAT_00002fd0;\n  local_18 = 0;\n  if (local_14 == (undefined4 *)0x0) {\n    FUN_00004db8(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    FUN_00004db8(PTR_s_ID_Class_Name_00002fd4);\n  }\n  for (; local_14 != (undefined4 *)0x0; local_14 = (undefined4 *)*local_14) {\n    uVar1 = lookup_sensor_class_000039e8(*(undefined *)(local_14[3] + 8));\n    FUN_00004c84(PTR_s___i__s__s_00002fdc,local_18,uVar1,local_14[2]);\n    local_18 = local_18 + 1;\n  }\n  return;\n}\n\n"
        },
        "FUN_000010a0": {
            "renaming": {
                "FUN_000010a0": "calculate_offset_000010a0",
                "param_1": "pointer_array",
                "local_c": "current_pointer"
            },
            "code": "int calculate_offset_000010a0(int *pointer_array)\n{\n  int *current_pointer;\n  for (current_pointer = pointer_array; (int *)*current_pointer == current_pointer; current_pointer++) {\n  }\n  return (int)current_pointer - (int)pointer_array;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010a0",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "calculate_offset_000010a0"
        },
        "FUN_000012e2": {
            "renaming": {
                "FUN_000012e2": "find_first_non_matching_pointer_000012e2",
                "param_1": "starting_address",
                "param_2": "pointer_value",
                "param_3": "pointer_length",
                "iVar1": "non_matching_pointer_index",
                "find_first_non_matching_pointer_0000231c": "find_first_non_matching_pointer",
                "update_linked_list_with_param1_0000129c": "update_linked_list_with_starting_address"
            },
            "code": "int find_first_non_matching_pointer_000012e2(int starting_address, int pointer_value, int pointer_length)\n{\n  int non_matching_pointer_index;\n  while( true ) {\n    non_matching_pointer_index = find_first_non_matching_pointer_000012e2(starting_address + 4, pointer_value, pointer_length);\n    if (non_matching_pointer_index != 0) break;\n    update_linked_list_with_starting_address(starting_address);\n  }\n  return non_matching_pointer_index;\n}",
            "called": [
                "FUN_0000129c",
                "FUN_0000231c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012e2",
            "calling": [
                "FUN_00000e14"
            ],
            "imported": false,
            "current_name": "find_first_non_matching_pointer_000012e2"
        },
        "FUN_000056a0": {
            "renaming": {
                "FUN_000056a0": "find_parameter_value_and_update_stack_000056a0",
                "param_1": "function_id",
                "param_2": "initial_value",
                "param_3": "updated_value_ptr",
                "param_4": "param_4",
                "uStack_c": "previous_value",
                "uStack_8": "updated_value",
                "find_parameter_value_0000562c": "find_parameter_value"
            },
            "code": "void find_parameter_value_and_update_stack_000056a0(undefined4 param_1, undefined4 initial_value, undefined4* updated_value_ptr, undefined4 param_4, undefined4 param_5) {\n  undefined4 previous_value = initial_value;\n  undefined4 updated_value = param_4;\n  find_parameter_value(param_1, initial_value, &updated_value, param_5, param_1);\n  *updated_value_ptr = updated_value;\n}",
            "called": [
                "FUN_0000562c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056a0",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "find_parameter_value_and_update_stack_000056a0"
        },
        "FUN_0000231c": {
            "renaming": {
                "FUN_0000231c": "find_first_non_matching_pointer_0000231c",
                "param_1": "value",
                "param_2": "pointer_array",
                "param_3": "array_length",
                "uVar1": "new_value",
                "iVar2": "i",
                "local_20": "current_pointer",
                "local_14": "remaining_length"
            },
            "code": "int find_first_non_matching_pointer_0000231c(int value, undefined *pointer_array, int array_length)\n{\n  undefined new_value;\n  int i;\n  undefined *current_pointer;\n  int remaining_length;\n  \n  current_pointer = pointer_array;\n  remaining_length = array_length;\n  while ((remaining_length != 0 && (i = is_pointer_equal(value), i == 0))) {\n    new_value = increment_value(value);\n    *current_pointer = new_value;\n    remaining_length = remaining_length - 1;\n    current_pointer = current_pointer + 1;\n  }\n  return array_length - remaining_length;\n}",
            "called": [
                "FUN_000022f0",
                "FUN_00002270"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000231c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": false,
            "current_name": "find_first_non_matching_pointer_0000231c"
        },
        "FUN_000061cc": {
            "renaming": {
                "FUN_000061cc": "process_input_000061cc",
                "param_1": "input_length",
                "param_2": "input_data",
                "param_3": "current_char",
                "param_4": "output_values",
                "puVar1": "char_table",
                "puVar2": "char_table_end",
                "iVar3": "result",
                "uVar4": "char_value",
                "pbVar5": "next_char",
                "uVar6": "current_char_value",
                "local_2b0": "output_values_ptr",
                "auStack_2ac": "decode_buffer",
                "local_1ac": "flags",
                "local_1a8": "base",
                "local_1a4": "width",
                "local_1a0": "result_value",
                "local_19c": "digits_count",
                "local_198": "decode_buffer_ptr",
                "local_194": "format_type",
                "local_30": "decode_input",
                "local_2c": "process_data"
            },
            "code": "\nint process_input_000061cc(int input_length,byte **input_data,byte *current_char,int **output_values)\n\n{\n  undefined *char_table;\n  undefined *char_table_end;\n  int result;\n  uint char_value;\n  byte *next_char;\n  uint current_char_value;\n  int **output_values_ptr;\n  undefined decode_buffer [256];\n  uint flags;\n  undefined4 base;\n  uint width;\n  int result_value;\n  int digits_count;\n  undefined *decode_buffer_ptr;\n  int format_type;\n  undefined *decode_input;\n  code *process_data;\n  \n  char_table_end = PTR_DAT_000064b4;\n  char_table = PTR_DAT_000064b0;\n  result_value = 0;\n  digits_count = 0;\n  decode_input = PTR_LAB_00006118_1_000064a8;\n  process_data = DAT_000064ac;\n  output_values_ptr = output_values;\n  decode_buffer_ptr = decode_buffer;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      current_char_value = (uint)*current_char;\n      if (current_char_value == 0) {\n        return result_value;\n      }\n      char_value = (byte)char_table[current_char_value] & 8;\n      next_char = current_char + 1;\n      if ((char_table[current_char_value] & 8) == 0) break;\n      while (((current_char = next_char, 0 < (int)input_data[1] ||\n              (result = (*process_data)(input_length,input_data), result == 0)) &&\n             ((int)((uint)(byte)char_table[**input_data] << 0x1c) < 0))) {\n        digits_count = digits_count + 1;\n        input_data[1] = input_data[1] + -1;\n        *input_data = *input_data + 1;\n      }\n    }\n    if (current_char_value == 0x25) break;\nLAB_00006352:\n    if (((int)input_data[1] < 1) && (result = (*process_data)(input_length,input_data), result != 0))\n    goto LAB_00006380;\n    if (**input_data != current_char_value) {\n      return result_value;\n    }\n    *input_data = *input_data + 1;\n    digits_count = digits_count + 1;\n    input_data[1] = input_data[1] + -1;\n    current_char = next_char;\n  }\n  width = char_value;\n  flags = char_value;\n  if (current_char[1] == 0x2a) {\n    next_char = current_char + 2;\n    flags = 0x10;\n  }\n  while( true ) {\n    char_value = (uint)*next_char;\n    if (9 < char_value - 0x30) break;\n    next_char = next_char + 1;\n    width = (width * 10 + char_value) - 0x30;\n  }\n  result = find_byte_sequence_00006010(PTR_DAT_000064b4,char_value,3);\n  if (result != 0) {\n    flags = 1 << (result - (int)char_table_end & 0xffU) | flags;\n    next_char = next_char + 1;\n  }\n  current_char = next_char + 1;\n  char_value = (uint)*next_char;\n  if (char_value < 0x79) {\n    if (0x57 < char_value) {\n      switch(char_value) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        current_char = (byte *)decode_input_0000687c(decode_buffer,current_char);\n        flags = flags | 0x40;\n        format_type = 1;\n        break;\n      case 99:\n        flags = flags | 0x40;\n        format_type = 0;\n        break;\n      case 100:\n      case 0x75:\n        base = 10;\nLAB_000063a0:\n        if (char_value < 0x6f) {\n          format_type = 3;\n        }\n        else {\n          format_type = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        format_type = 5;\n        break;\n      case 0x69:\n        base = 0;\n        format_type = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(flags << 0x1b)) {\n          if ((int)(flags << 0x1f) < 0) {\n            *(short *)*output_values_ptr = (short)digits_count;\n            output_values_ptr = output_values_ptr + 1;\n          }\n          else {\n            **output_values_ptr = digits_count;\n            output_values_ptr = output_values_ptr + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        base = 8;\n        format_type = 4;\n        break;\n      case 0x70:\n        flags = flags | 0x20;\n      case 0x58:\n      case 0x78:\n        flags = flags | 0x200;\n        base = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        format_type = 2;\n      }\nLAB_000063ac:\n      if (((int)input_data[1] < 1) && (result = (*process_data)(input_length,input_data), result != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(flags << 0x19)) {\n        while ((int)((uint)(byte)char_table[**input_data] << 0x1c) < 0) {\n          digits_count = digits_count + 1;\n          next_char = input_data[1];\n          input_data[1] = next_char + -1;\n          if ((int)(next_char + -1) < 1) {\n            result = (*process_data)(input_length,input_data);\n            if (result != 0) goto LAB_00006380;\n          }\n          else {\n            *input_data = *input_data + 1;\n          }\n        }\n      }\n      if (format_type < 3) {\n        result = process_data_000064bc(input_length,&flags,input_data,&output_values_ptr);\n      }\n      else if (format_type < 5) {\n        result = decode_and_process_input_000061cc_0000656c(input_length,&flags,input_data,&output_values_ptr);\n      }\n      else {\n        result = input_length;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (result == 1) {\n        return result_value;\n      }\n      if (result == 2) {\nLAB_00006380:\n        if (result_value == 0) {\nLAB_00006388:\n          result_value = -1;\n        }\n        else if ((*(ushort *)(input_data + 3) & 0x40) != 0) {\n          result_value = -1;\n        }\n        return result_value;\n      }\n      goto LAB_000061f6;\n    }\n    next_char = current_char;\n    if (char_value == 0x25) goto LAB_00006352;\n    if (char_value < 0x26) {\n      if (char_value != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (char_value - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  format_type = 3;\n  base = 10;\n  goto LAB_000063ac;\n}\n\n",
            "called": [
                "FUN_000064bc",
                "FUN_0000687c",
                "FUN_00006010",
                "FUN_0000656c",
                "FUN_00006192"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000061cc",
            "calling": [
                "FUN_00005e68"
            ],
            "imported": false,
            "current_name": "process_input_000061cc"
        },
        "FUN_00002690": {
            "renaming": {
                "FUN_00002690": "calculate_date_and_increment_value_00002690",
                "param_1": "input_value",
                "local_10": "incremented_value",
                "uStack_c": "calculated_date",
                "get_dat_value_plus_one_000028f0": "get_dat_value_plus_one",
                "calculate_date_0000443c": "calculate_date"
            },
            "code": "int calculate_date_and_increment_value_00002690(int input_value)\n{\n    int incremented_value = get_dat_value_plus_one();\n    int calculated_date = 0;\n    calculate_date(&incremented_value, input_value, &calculated_date);\n    return 0;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_000028f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002690",
            "calling": [
                "FUN_000033c0"
            ],
            "imported": false,
            "current_name": "calculate_date_and_increment_value_00002690"
        },
        "FUN_00006010": {
            "renaming": {
                "FUN_00006010": "find_byte_sequence_00006010",
                "param_1": "data",
                "param_2": "length",
                "param_3": "value",
                "bVar1": "byte_val",
                "cVar2": "mask_1",
                "cVar3": "mask_2",
                "cVar4": "mask_3",
                "cVar5": "mask_4",
                "pbVar6": "result_ptr",
                "puVar7": "data8",
                "pbVar8": "result_ptr_2",
                "uVar9": "offset",
                "uVar10": "length8",
                "uVar11": "value_xor",
                "uVar12": "value_xor2",
                "bVar13": "mask2_1",
                "bVar14": "mask2_2",
                "bVar15": "mask2_3",
                "bVar16": "mask2_4"
            },
            "code": "byte* find_byte_sequence_00006010(uint* data, uint length, uint value) {\n  byte* result = NULL;\n  uint i = 0;\n  uint* data8 = data;\n  uint value8 = (value & 0xFF) | ((value & 0xFF) << 8) | ((value & 0xFF) << 16) | ((value & 0xFF) << 24);\n  \n  if (length < 0x10) {\n    while (i < length) {\n      if (*((byte*)data8) == (value & 0xFF)) {\n        result = (byte*)data8;\n        break;\n      }\n      data8++;\n      i++;\n    }\n  }\n  else {\n    uint offset = (uint)data & 7;\n    uint length8 = length & 0xFFFFFFF8;\n    while (offset != 0) {\n      if (*((byte*)data8) == (value & 0xFF)) {\n        result = (byte*)data8;\n        break;\n      }\n      data8++;\n      i++;\n      offset = (uint)data8 & 7;\n      if (i == length) {\n        return NULL;\n      }\n    }\n    while (length8 != 0) {\n      uint value_xor = *data8 ^ value8;\n      uint value_xor2 = *(data8 + 1) ^ value8;\n      uint mask = ((char)value_xor) | ((char)(value_xor >> 8)) | ((char)(value_xor >> 16)) | ((char)(value_xor >> 24));\n      uint mask2 = ((char)value_xor2) | ((char)(value_xor2 >> 8)) | ((char)(value_xor2 >> 16)) | ((char)(value_xor2 >> 24));\n      if (mask | mask2) {\n        if (!(mask & 1)) {\n          if (mask & 0x100) {\n            if (mask & 0x18000) {\n              data8 += 2;\n            }\n            else {\n              data8 += 1;\n            }\n          }\n          else {\n            data8 += 1;\n          }\n        }\n        else {\n          result = (byte*)data8 + 1;\n          break;\n        }\n      }\n      else {\n        data8 += 2;\n      }\n      length8 -= 8;\n    }\n    if (length & 7) {\n      while (i < length) {\n        if (*((byte*)data8) == (value & 0xFF)) {\n          result = (byte*)data8;\n          break;\n        }\n        data8++;\n        i++;\n      }\n    }\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006010",
            "calling": [
                "FUN_00005b34",
                "FUN_000057f8",
                "FUN_000061cc",
                "FUN_0000656c"
            ],
            "imported": false,
            "current_name": "find_byte_sequence_00006010"
        },
        "FUN_00001cf0": {
            "renaming": {
                "FUN_00001cf0": "check_flag_and_set_00001cf0",
                "PTR_DAT_00001d04": "flag_ptr",
                "set_flag_0000093c": "set_flag"
            },
            "code": "void check_flag_and_set_00001cf0(void)\n{\n  int* PTR_DAT_00001d04 = (int*)PTR_DAT_00001d04;\n  if (*PTR_DAT_00001d04 != 0)\n  {\n    set_flag();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001cf0",
            "calling": [
                "FUN_00002028"
            ],
            "imported": false,
            "current_name": "check_flag_and_set_00001cf0"
        },
        "FUN_00003ec4": {
            "renaming": {
                "FUN_00003ec4": "count_digits_and_format_output_00003ec4",
                "param_1": "output_string",
                "param_2": "input_number",
                "param_3": "decimal_places",
                "iVar1": "digit_count",
                "uVar2": "temp_var",
                "uVar3": "quotient",
                "local_10": "remainder",
                "local_c": "digit_count"
            },
            "code": "int count_digits_and_format_output_00003ec4(undefined *output_string, uint input_number, int decimal_places) {\n  int digit_count = 0;\n  if (decimal_places + 7 < 0 != SCARRY4(decimal_places, 7)) {\n    handle_interrupt_and_parse_input_loop_00000f04(3, PTR_s_FAILED_ASSERTION__00003fec);\n  }\n  if (decimal_places == 0) {\n    digit_count = count_digits(input_number);\n  }\n  else if (decimal_places < 1) {\n    uint divisor = *(uint *)(PTR_DAT_00003ff0 + decimal_places * -4);\n    uint quotient = input_number / divisor;\n    uint remainder = input_number % divisor;\n    if (remainder < 0) {\n      remainder = -remainder;\n    }\n    if ((quotient == 0) && ((int)input_number < 0)) {\n      if (output_string != (undefined *)0x0) {\n        *output_string = 0x2d;\n      }\n      digit_count = 1;\n    }\n    if (output_string == (undefined *)0x0) {\n      digit_count += count_digits(quotient) + 1;\n    }\n    else {\n      digit_count += count_digits(output_string + digit_count, quotient);\n      digit_count++;\n      output_string[digit_count - 1] = 0x2e;\n      digit_count += copy_and_fill(output_string + digit_count, count_digits(&output_string[digit_count], remainder), -decimal_places, 0x30);\n    }\n    digit_count = -decimal_places + digit_count;\n  }\n  else {\n    digit_count = count_digits(output_string, input_number);\n    if (output_string != (undefined *)0x0) {\n      fill_array_with_value_00004622(output_string + digit_count, 0x30, decimal_places);\n    }\n    digit_count += decimal_places;\n  }\n  return digit_count;\n}",
            "called": [
                "FUN_00000f04",
                "FUN_00003ff4",
                "FUN_00003e58",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ec4",
            "calling": [
                "FUN_00003e9e"
            ],
            "imported": false,
            "current_name": "count_digits_and_format_output_00003ec4"
        },
        "FUN_00001360": {
            "renaming": {
                "FUN_00001360": "calculate_value_00001360",
                "param_1": "input_value",
                "param_2": "multiplier"
            },
            "code": "int calculate_value_00001360(uint32_t input_value, int multiplier){\n                    uint32_t masked_value = input_value & 0xf0000000;\n                    uint32_t shifted_value = (input_value & 0xfffff) << 5;\n                    int result = multiplier * 4 + masked_value + shifted_value + 0x2000000;\n                    return result;\n                }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001360",
            "calling": [
                "FUN_00001392"
            ],
            "imported": false,
            "current_name": "calculate_value_00001360"
        },
        "FUN_00004622": {
            "renaming": {
                "FUN_00004622": "fill_array_with_value_00004622",
                "param_1": "array",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "end_of_array"
            },
            "code": "void fill_array_with_value_00004622(void *array, int value, int size) {\n  void *end_of_array = array + size;\n  for (; array != end_of_array; array = array + 1) {\n    *array = value;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004622",
            "calling": [
                "FUN_00003ec4",
                "FUN_0000305c",
                "FUN_00004248",
                "FUN_000041f4",
                "FUN_00003ff4",
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "fill_array_with_value_00004622"
        },
        "FUN_0000093c": {
            "renaming": {
                "FUN_0000093c": "set_flag_0000093c",
                "DAT_00000954": "data_ptr"
            },
            "code": "void set_flag_0000093c(void)\n{\n    uint* DAT_00000954 = (uint*)(DAT_00000954 + 4);\n    *DAT_00000954 |= 0x10000000;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000093c",
            "calling": [
                "FUN_00001cf0",
                "FUN_00002434",
                "FUN_00001348",
                "FUN_00000738",
                "FUN_00002798"
            ],
            "imported": false,
            "current_name": "set_flag_0000093c"
        },
        "FUN_00003658": {
            "renaming": {
                "FUN_00003658": "synchronize_data_00003658",
                "DAT_00003680": "data_start_address",
                "DAT_00003684": "data_value_to_or",
                "uint": "unsigned_int",
                "data_ptr": "data_pointer"
            },
            "code": "void synchronize_data_00003658(void)\n{\n    DataSynchronizationBarrier(0xf);\n    uint* data_ptr = (uint*)(DAT_00003680 + 0xc);\n    *data_ptr = DAT_00003684 | (*data_ptr & 0x700);\n    DataSynchronizationBarrier(0xf);\n    while(true)\n    {\n        // Do nothing block with infinite loop\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003658",
            "calling": [
                "FUN_00003688"
            ],
            "imported": false,
            "current_name": "synchronize_data_00003658"
        },
        "FUN_000019c0": {
            "renaming": {
                "FUN_000019c0": "set_bit_update_clear_memory_000019c0",
                "set_bit_in_byte_00001778": "set_bit",
                "update_byte_with_mask_00001748": "update_byte_with_mask",
                "clear_memory_at_offset_00001710": "clear_memory",
                "DAT_00001a0c": "DAT_main",
                "*DAT_00001a10": "*DAT_flag",
                "DAT_00001a10[6]": "DAT_flag[6]",
                "clear_memory_00001734": "clear_memory_end",
                "*PTR_DAT_00001a14": "*PTR_count"
            },
            "code": "void set_bit_update_clear_memory_000019c0(void)\n{\n  set_bit();\n  update_byte_with_mask(0x40);\n  clear_memory(DAT_00001a0c,1);\n  *DAT_00001a10 = *DAT_00001a10 & 0x3b | 0x80;\n  do {\n  } while ((DAT_00001a10[6] & 0xc) != 8);\n  clear_memory_end();\n  *PTR_DAT_00001a14 = 3;\n  return;\n}",
            "called": [
                "FUN_00001778",
                "FUN_00001748",
                "FUN_00001734",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000019c0",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_bit_update_clear_memory_000019c0"
        },
        "FUN_000060b0": {
            "renaming": {
                "FUN_000060b0": "copy_data_000060b0",
                "param_1": "destination_index",
                "param_2": "destination_array",
                "param_3": "source_length",
                "puVar1": "source_ptr",
                "puVar2": "source_array",
                "puVar3": "destination_ptr"
            },
            "code": "void copy_data_000060b0(int destination_index, undefined *destination_array, int source_length) {\n  undefined *source_array = destination_array + source_length;\n  undefined *destination_ptr = (undefined *)(destination_index - 1);\n  if (destination_array != source_array) {\n    do {\n      undefined *source_ptr = destination_array + 1;\n      destination_ptr = destination_ptr + 1;\n      *destination_ptr = *destination_array;\n      destination_array = source_ptr;\n    } while (source_ptr != source_array);\n    return;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060b0",
            "calling": [
                "FUN_000068f0",
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "copy_data_000060b0"
        },
        "FUN_00006a14": {
            "renaming": {
                "FUN_00006a14": "division_with_remainder_and_quotient_00006a14",
                "param_1": "dividend_lower",
                "param_2": "dividend_upper",
                "param_3": "divisor_lower",
                "param_4": "divisor_upper",
                "param_5": "remainder_and_quotient",
                "UNRECOVERED_JUMPTABLE": "udf_software_call",
                "uVar1": "dividend_upper_shifted",
                "puVar2": "quotient",
                "puVar3": "remainder",
                "uVar4": "leading_zeros",
                "uVar5": "dividend_partial",
                "uVar6": "quotient_partial",
                "uVar7": "divisor_lower_partial",
                "uVar8": "divisor_lower_shifted",
                "uVar9": "dividend_partial_shifted",
                "uVar10": "divisor_upper_partial",
                "bVar11": "carry_flag",
                "uVar12": "product"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong division_with_remainder_and_quotient_00006a14(uint dividend_lower,uint dividend_upper,uint divisor_lower,uint divisor_upper,uint *remainder_and_quotient)\n\n{\n  code *udf_software_call;\n  uint dividend_upper_shifted;\n  uint *quotient;\n  uint *remainder;\n  uint leading_zeros;\n  uint dividend_partial;\n  uint quotient_partial;\n  uint divisor_lower_partial;\n  uint divisor_lower_shifted;\n  uint dividend_partial_shifted;\n  uint divisor_upper_partial;\n  bool carry_flag;\n  ulonglong product;\n  \n  if (divisor_upper == 0) {\n    if (dividend_upper < divisor_lower) {\n      leading_zeros = count_leading_zeroes(divisor_lower);\n      if (leading_zeros != 0) {\n        divisor_lower = divisor_lower << (leading_zeros & 0xff);\n        dividend_upper = dividend_lower >> (0x20 - leading_zeros & 0xff) | dividend_upper << (leading_zeros & 0xff);\n        dividend_lower = dividend_lower << (leading_zeros & 0xff);\n      }\n      divisor_lower_partial = divisor_lower >> 0x10;\n      dividend_partial_shifted = dividend_upper / divisor_lower_partial;\n      dividend_partial = dividend_lower >> 0x10 | (dividend_upper - divisor_lower_partial * dividend_partial_shifted) * 0x10000;\n      dividend_upper_shifted = dividend_partial_shifted * (divisor_lower & 0xffff);\n      quotient_partial = dividend_partial_shifted;\n      if (dividend_partial <= dividend_upper_shifted && dividend_upper_shifted - dividend_partial != 0) {\n        carry_flag = CARRY4(divisor_lower,dividend_partial);\n        dividend_partial = divisor_lower + dividend_partial;\n        quotient_partial = dividend_partial_shifted - 1;\n        if ((carry_flag == false) && (dividend_partial <= dividend_upper_shifted && dividend_upper_shifted - dividend_partial != 0)) {\n          quotient_partial = dividend_partial_shifted - 2;\n          dividend_partial = dividend_partial + divisor_lower;\n        }\n      }\n      dividend_partial_shifted = (dividend_partial - dividend_upper_shifted) / divisor_lower_partial;\n      dividend_partial = dividend_lower & 0xffff | ((dividend_partial - dividend_upper_shifted) - divisor_lower_partial * dividend_partial_shifted) * 0x10000;\n      divisor_lower_partial = dividend_partial_shifted * (divisor_lower & 0xffff);\n      dividend_upper_shifted = dividend_partial_shifted;\n      if (dividend_partial <= divisor_lower_partial && divisor_lower_partial - dividend_partial != 0) {\n        carry_flag = CARRY4(divisor_lower,dividend_partial);\n        dividend_partial = divisor_lower + dividend_partial;\n        dividend_upper_shifted = dividend_partial_shifted - 1;\n        if ((carry_flag == false) && (dividend_partial <= divisor_lower_partial && divisor_lower_partial - dividend_partial != 0)) {\n          dividend_upper_shifted = dividend_partial_shifted - 2;\n          dividend_partial = dividend_partial + divisor_lower;\n        }\n      }\n      dividend_partial = dividend_partial - divisor_lower_partial;\n      quotient = (uint *)(dividend_upper_shifted | quotient_partial << 0x10);\n      remainder = (uint *)0x0;\n    }\n    else {\n      if (divisor_lower == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        udf_software_call = (code *)software_udf(0xff,0x6abc);\n        product = (*udf_software_call)();\n        return product;\n      }\n      leading_zeros = count_leading_zeroes(divisor_lower);\n      if (leading_zeros == 0) {\n        dividend_upper = dividend_upper - divisor_lower;\n        divisor_upper_partial = divisor_lower >> 0x10;\n        divisor_lower_shifted = divisor_lower & 0xffff;\n        remainder = (uint *)0x1;\n      }\n      else {\n        divisor_lower = divisor_lower << (leading_zeros & 0xff);\n        divisor_upper_partial = divisor_lower >> 0x10;\n        quotient_partial = dividend_upper >> (0x20 - leading_zeros & 0xff);\n        dividend_upper_shifted = dividend_lower >> (0x20 - leading_zeros & 0xff) | dividend_upper << (leading_zeros & 0xff);\n        dividend_partial = quotient_partial / divisor_upper_partial;\n        divisor_lower_shifted = divisor_lower & 0xffff;\n        dividend_partial_shifted = dividend_upper_shifted >> 0x10 | (quotient_partial - divisor_upper_partial * dividend_partial) * 0x10000;\n        divisor_lower_partial = dividend_partial * divisor_lower_shifted;\n        dividend_lower = dividend_lower << (leading_zeros & 0xff);\n        quotient_partial = dividend_partial;\n        if (dividend_partial_shifted <= divisor_lower_partial && divisor_lower_partial - dividend_partial_shifted != 0) {\n          carry_flag = CARRY4(divisor_lower,dividend_partial_shifted);\n          dividend_partial_shifted = divisor_lower + dividend_partial_shifted;\n          quotient_partial = dividend_partial - 1;\n          if ((carry_flag == false) && (dividend_partial_shifted <= divisor_lower_partial && divisor_lower_partial - dividend_partial_shifted != 0)) {\n            quotient_partial = dividend_partial - 2;\n            dividend_partial_shifted = dividend_partial_shifted + divisor_lower;\n          }\n        }\n        dividend_partial = (dividend_partial_shifted - divisor_lower_partial) / divisor_upper_partial;\n        dividend_upper = dividend_upper_shifted & 0xffff | ((dividend_partial_shifted - divisor_lower_partial) - divisor_upper_partial * dividend_partial) * 0x10000;\n        divisor_lower_partial = dividend_partial * divisor_lower_shifted;\n        dividend_upper_shifted = dividend_partial;\n        if (dividend_upper <= divisor_lower_partial && divisor_lower_partial - dividend_upper != 0) {\n          carry_flag = CARRY4(divisor_lower,dividend_upper);\n          dividend_upper = divisor_lower + dividend_upper;\n          dividend_upper_shifted = dividend_partial - 1;\n          if ((carry_flag == false) && (dividend_upper <= divisor_lower_partial && divisor_lower_partial - dividend_upper != 0)) {\n            dividend_upper_shifted = dividend_partial - 2;\n            dividend_upper = dividend_upper + divisor_lower;\n          }\n        }\n        dividend_upper = dividend_upper - divisor_lower_partial;\n        remainder = (uint *)(dividend_upper_shifted | quotient_partial << 0x10);\n      }\n      divisor_lower_partial = dividend_upper / divisor_upper_partial;\n      dividend_partial = dividend_lower >> 0x10 | (dividend_upper - divisor_upper_partial * divisor_lower_partial) * 0x10000;\n      dividend_upper_shifted = divisor_lower_shifted * divisor_lower_partial;\n      quotient_partial = divisor_lower_partial;\n      if (dividend_partial <= dividend_upper_shifted && dividend_upper_shifted - dividend_partial != 0) {\n        carry_flag = CARRY4(divisor_lower,dividend_partial);\n        dividend_partial = divisor_lower + dividend_partial;\n        quotient_partial = divisor_lower_partial - 1;\n        if ((carry_flag == false) && (dividend_partial <= dividend_upper_shifted && dividend_upper_shifted - dividend_partial != 0)) {\n          quotient_partial = divisor_lower_partial - 2;\n          dividend_partial = dividend_partial + divisor_lower;\n        }\n      }\n      divisor_lower_partial = (dividend_partial - dividend_upper_shifted) / divisor_upper_partial;\n      dividend_partial = dividend_lower & 0xffff | ((dividend_partial - dividend_upper_shifted) - divisor_upper_partial * divisor_lower_partial) * 0x10000;\n      divisor_lower_shifted = divisor_lower_shifted * divisor_lower_partial;\n      dividend_upper_shifted = divisor_lower_partial;\n      if (dividend_partial <= divisor_lower_shifted && divisor_lower_shifted - dividend_partial != 0) {\n        carry_flag = CARRY4(divisor_lower,dividend_partial);\n        dividend_partial = divisor_lower + dividend_partial;\n        dividend_upper_shifted = divisor_lower_partial - 1;\n        if ((carry_flag == false) && (dividend_partial <= divisor_lower_shifted && divisor_lower_shifted - dividend_partial != 0)) {\n          dividend_upper_shifted = divisor_lower_partial - 2;\n          dividend_partial = dividend_partial + divisor_lower;\n        }\n      }\n      dividend_partial = dividend_partial - divisor_lower_shifted;\n      quotient = (uint *)(dividend_upper_shifted | quotient_partial << 0x10);\n    }\n    if (remainder_and_quotient != (uint *)0x0) {\n      *remainder_and_quotient = dividend_partial >> (leading_zeros & 0xff);\n      remainder_and_quotient[1] = 0;\n    }\n  }\n  else if (dividend_upper < divisor_upper) {\n    quotient = remainder_and_quotient;\n    remainder = remainder_and_quotient;\n    if (remainder_and_quotient != (uint *)0x0) {\n      *remainder_and_quotient = dividend_lower;\n      remainder_and_quotient[1] = dividend_upper;\n      return 0;\n    }\n  }\n  else {\n    remainder = (uint *)count_leading_zeroes(divisor_upper);\n    if (remainder != (uint *)0x0) {\n      divisor_lower_shifted = 0x20 - (int)remainder;\n      dividend_partial = divisor_lower >> (divisor_lower_shifted & 0xff) | divisor_upper << ((uint)remainder & 0xff);\n      divisor_upper_partial = dividend_partial >> 0x10;\n      leading_zeros = dividend_upper >> (divisor_lower_shifted & 0xff);\n      quotient_partial = dividend_lower >> (divisor_lower_shifted & 0xff) | dividend_upper << ((uint)remainder & 0xff);\n      divisor_lower_partial = leading_zeros / divisor_upper_partial;\n      dividend_upper_shifted = quotient_partial >> 0x10 | (leading_zeros - divisor_upper_partial * divisor_lower_partial) * 0x10000;\n      dividend_partial_shifted = divisor_lower_partial * (dividend_partial & 0xffff);\n      divisor_lower = divisor_lower << ((uint)remainder & 0xff);\n      dividend_lower = dividend_lower << ((uint)remainder & 0xff);\n      leading_zeros = divisor_lower_partial;\n      if (dividend_upper_shifted <= dividend_partial_shifted && dividend_partial_shifted - dividend_upper_shifted != 0) {\n        carry_flag = CARRY4(dividend_partial,dividend_upper_shifted);\n        dividend_upper_shifted = dividend_partial + dividend_upper_shifted;\n        leading_zeros = divisor_lower_partial - 1;\n        if ((carry_flag == false) && (dividend_upper_shifted <= dividend_partial_shifted && dividend_partial_shifted - dividend_upper_shifted != 0)) {\n          leading_zeros = divisor_lower_partial - 2;\n          dividend_upper_shifted = dividend_upper_shifted + dividend_partial;\n        }\n      }\n      divisor_lower_partial = (dividend_upper_shifted - dividend_partial_shifted) / divisor_upper_partial;\n      dividend_upper_shifted = quotient_partial & 0xffff | ((dividend_upper_shifted - dividend_partial_shifted) - divisor_upper_partial * divisor_lower_partial) * 0x10000;\n      dividend_partial_shifted = divisor_lower_partial * (dividend_partial & 0xffff);\n      quotient_partial = divisor_lower_partial;\n      if (dividend_upper_shifted <= dividend_partial_shifted && dividend_partial_shifted - dividend_upper_shifted != 0) {\n        carry_flag = CARRY4(dividend_partial,dividend_upper_shifted);\n        dividend_upper_shifted = dividend_partial + dividend_upper_shifted;\n        quotient_partial = divisor_lower_partial - 1;\n        if ((carry_flag == false) && (dividend_upper_shifted <= dividend_partial_shifted && dividend_partial_shifted - dividend_upper_shifted != 0)) {\n          quotient_partial = divisor_lower_partial - 2;\n          dividend_upper_shifted = dividend_upper_shifted + dividend_partial;\n        }\n      }\n      quotient_partial = quotient_partial | leading_zeros << 0x10;\n      product = (ulonglong)quotient_partial * (ulonglong)divisor_lower;\n      if (CONCAT44(dividend_upper_shifted - dividend_partial_shifted,dividend_lower) < product) {\n        product = product - CONCAT44(dividend_partial,divisor_lower);\n        quotient_partial = quotient_partial - 1;\n      }\n      if (remainder_and_quotient != (uint *)0x0) {\n        leading_zeros = ((dividend_upper_shifted - dividend_partial_shifted) - (int)(product >> 0x20)) - (uint)(dividend_lower < (uint)product);\n        *remainder_and_quotient = leading_zeros << (divisor_lower_shifted & 0xff) | dividend_lower - (uint)product >> ((uint)remainder & 0xff);\n        remainder_and_quotient[1] = leading_zeros >> ((uint)remainder & 0xff);\n      }\n      return (ulonglong)quotient_partial;\n    }\n    if ((divisor_upper < dividend_upper) || (quotient = remainder, divisor_lower <= dividend_lower)) {\n      carry_flag = dividend_lower < divisor_lower;\n      dividend_lower = dividend_lower - divisor_lower;\n      dividend_upper = (dividend_upper - divisor_upper) - (uint)carry_flag;\n      quotient = (uint *)0x1;\n    }\n    if (remainder_and_quotient != (uint *)0x0) {\n      *remainder_and_quotient = dividend_lower;\n      remainder_and_quotient[1] = dividend_upper;\n    }\n  }\n  return CONCAT44(remainder,quotient);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006a14",
            "calling": [
                "FUN_00006974"
            ],
            "imported": false,
            "current_name": "division_with_remainder_and_quotient_00006a14"
        },
        "FUN_000023d0": {
            "renaming": {
                "FUN_000023d0": "handle_interrupt_000023d0",
                "param_1": "parameter",
                "uVar1": "return_value",
                "PTR_DAT_000023fc": "ptr_to_ptr",
                "trigger_software_interrupt_000023c8": "trigger_interrupt"
            },
            "code": "int handle_interrupt_000023d0(int interrupt_type, int parameter) {\n  int* ptr = *(int**)PTR_DAT_000023fc;\n  if (ptr == NULL) {\n    return trigger_software_interrupt_000023c8(interrupt_type, parameter, 0);\n  }\n  else {\n    return 0;\n  }\n}",
            "called": [
                "FUN_000023c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023d0",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": false,
            "current_name": "handle_interrupt_000023d0"
        },
        "FUN_00000a30": {
            "renaming": {
                "FUN_00000a30": "handle_interrupt_and_parse_input_loop_00000a30",
                "in_r3": "register3",
                "auStack_20": "stack",
                "uRam00000a3c": "ptr"
            },
            "code": "char* handle_interrupt_and_parse_input_loop_00000a30(int num, char* ptr) {\n int register3;\n char stack[24];\n handle_interrupt_and_parse_input_loop_00000a30_00000f04(num, ptr);\n return stack + (-(int)PTR_DAT_00000a60 - *(int *)(register3 + 0x4c));\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a30",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_and_parse_input_loop_00000a30"
        },
        "FUN_000034c0": {
            "renaming": {
                "FUN_000034c0": "initialize_rtc_commands_000034c0",
                "PTR_s_usage__rtc__command___arguments__00003500": "usage_rtc_command_arguments",
                "PTR_s_commands__00003504": "commands",
                "PTR_s__poweron_power_the_interface_on_00003508": "power_on_interface",
                "PTR_s__poweroff_power_the_interface_of_0000350c": "power_off_interface",
                "PTR_s__clearalarm_deactivate_the_curre_00003510": "deactivate_current_alarm",
                "PTR_s__getalarm_print_the_currently_al_00003514": "print_current_alarm",
                "PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518": "set_alarm",
                "PTR_s__gettime_print_the_current_time_0000351c": "print_current_time",
                "PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520": "set_time"
            },
            "code": "int initialize_rtc_commands_000034c0(void)\n{\n  execute_command(PTR_s_usage__rtc__command___arguments__00003500);\n  execute_command(PTR_s_commands__00003504);\n  execute_command(PTR_s__poweron_power_the_interface_on_00003508);\n  execute_command(PTR_s__poweroff_power_the_interface_of_0000350c);\n  execute_command(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  execute_command(PTR_s__getalarm_print_the_currently_al_00003514);\n  execute_command(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  execute_command(PTR_s__gettime_print_the_current_time_0000351c);\n  execute_command(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000034c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "initialize_rtc_commands_000034c0",
            "code_backup": "\nundefined4 FUN_000034c0(void)\n\n{\n  FUN_00004db8(PTR_s_usage__rtc__command___arguments__00003500);\n  FUN_00004db8(PTR_s_commands__00003504);\n  FUN_00004db8(PTR_s__poweron_power_the_interface_on_00003508);\n  FUN_00004db8(PTR_s__poweroff_power_the_interface_of_0000350c);\n  FUN_00004db8(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  FUN_00004db8(PTR_s__getalarm_print_the_currently_al_00003514);\n  FUN_00004db8(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  FUN_00004db8(PTR_s__gettime_print_the_current_time_0000351c);\n  FUN_00004db8(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}\n\n"
        },
        "FUN_000050e8": {
            "renaming": {
                "FUN_000050e8": "get_pointer_to_data_000050e8",
                "PTR_DAT_000050f0": "data_pointer"
            },
            "code": "const char* get_pointer_to_data_000050e8() {\n    return PTR_DAT_000050f0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050e8",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_pointer_to_data_000050e8"
        },
        "FUN_000042a4": {
            "renaming": {
                "FUN_000042a4": "initialize_array_000042a4",
                "param_1": "input_parameter",
                "uVar1": "initialized_value",
                "iVar2": "second_parameter",
                "bVar3": "is_same_address"
            },
            "code": "void initialize_array_000042a4(int input_parameter)\n{\n  undefined4 initialized_value;\n  int second_parameter;\n  bool is_same_address;\n  execute_nothingness();\n  if (*(int *)(input_parameter + 0x18) == 0) {\n    *(undefined4 *)(input_parameter + 0x48) = 0;\n    *(undefined4 *)(input_parameter + 0x4c) = 0;\n    *(undefined4 *)(input_parameter + 0x50) = 0;\n    second_parameter = *(int *)global_pointer;\n    *(undefined **)(input_parameter + 0x28) = global_pointer_2;\n    is_same_address = second_parameter == input_parameter;\n    if (is_same_address) {\n      second_parameter = 1;\n    }\n    if (is_same_address) {\n      *(int *)(input_parameter + 0x18) = second_parameter;\n    }\n    initialized_value = initialize_array_000042a4_helper(input_parameter);\n    *(undefined4 *)(input_parameter + 4) = initialized_value;\n    initialized_value = initialize_array_000042a4_helper(input_parameter);\n    *(undefined4 *)(input_parameter + 8) = initialized_value;\n    initialized_value = initialize_array_000042a4_helper(input_parameter);\n    *(undefined4 *)(input_parameter + 0xc) = initialized_value;\n    initialize_data(*(undefined4 *)(input_parameter + 4),4,0);\n    initialize_data(*(undefined4 *)(input_parameter + 8),9,1);\n    initialize_data(*(undefined4 *)(input_parameter + 0xc),0x12,2);\n    *(undefined4 *)(input_parameter + 0x18) = 1;\n  }\n  do_nothing(global_constant);\n  return;\n}",
            "called": [
                "FUN_0000428c",
                "FUN_000041f4",
                "FUN_000045ec",
                "FUN_00004314"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000042a4",
            "calling": [
                "FUN_00004c84",
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_00005404",
                "FUN_00005e10",
                "FUN_000054a8",
                "FUN_00004158",
                "FUN_00006768",
                "FUN_00004418",
                "FUN_00004cb4",
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "initialize_array_000042a4"
        },
        "FUN_00000514": {
            "renaming": {
                "FUN_00000514": "set_value_to_19_00000514",
                "param_1": "value_ptr",
                "*param_1": "*value_ptr",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int set_value_to_19_00000514(int *value_ptr) {\n    int value = 19;\n    *value_ptr = value;\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000514",
            "calling": [
                "FUN_000056b8"
            ],
            "imported": false,
            "current_name": "set_value_to_19_00000514"
        },
        "FUN_00002e9c": {
            "renaming": {
                "FUN_00002e9c": "synchronize_data_00002e9c",
                "undefined4": "int"
            },
            "code": "int synchronize_data_00002e9c() {\n    synchronize_data_00002e9c_00003688();\n    return 0;\n}",
            "called": [
                "FUN_00003688"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e9c",
            "calling": [],
            "imported": false,
            "current_name": "synchronize_data_00002e9c"
        },
        "FUN_00001960": {
            "renaming": {
                "FUN_00001960": "update_memory_and_set_flag_00001960",
                "DAT_000019b4": "memory_offset",
                "DAT_000019b8": "flag"
            },
            "code": "void update_memory_and_set_flag_00001960(void)\n{\n  update_byte_with_mask(0xa0);\n  clear_memory_at_offset(DAT_000019b4, 1);\n  *DAT_000019b8 = (*DAT_000019b8 & 0x3b) | 0x44;\n  while ((DAT_000019b8[6] & 0xc) != 4);\n  while ((DAT_000019b8[6] & 0x10) == 0);\n  *PTR_DAT_000019bc = 2;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001960",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "update_memory_and_set_flag_00001960"
        },
        "FUN_00000990": {
            "renaming": {
                "FUN_00000990": "do_nothing_00000990"
            },
            "code": "\nvoid do_nothing_00000990(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000990",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "do_nothing_00000990"
        },
        "FUN_00001a3c": {
            "renaming": {
                "FUN_00001a3c": "set_offset_and_clear_memory_00001a3c",
                "set_offset_to_one_000016ec": "set_offset_to_one",
                "clear_memory_00001734": "clear_memory",
                "DAT_00001a58": "DAT_offset",
                "*PTR_DAT_00001a5c": "*PTR_data"
            },
            "code": "void set_offset_and_clear_memory_00001a3c(void)\n{\n  set_offset_to_one(DAT_00001a58, 1);\n  clear_memory();\n  *PTR_DAT_00001a5c = 5;\n  return;\n}",
            "called": [
                "FUN_00001734",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a3c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_offset_and_clear_memory_00001a3c"
        },
        "FUN_000045ee": {
            "renaming": {
                "FUN_000045ee": "reverse_copy_000045ee",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "length",
                "puVar1": "start_destination",
                "puVar2": "end_source"
            },
            "code": "void reverse_copy_000045ee(char *destination, char *source, int length)\n{\n  char *start_source = source;\n  char *end_source = source + length - 1;\n  char *start_destination = destination;\n  if ((destination < source) && (source < end_source)) {\n    while (end_source != source - 1) {\n      *destination = *end_source;\n      destination++;\n      end_source--;\n    }\n  }\n  else {\n    start_destination = destination + length - 1;\n    for (; source != end_source + 1; source++) {\n      *destination = *source;\n      destination++;\n    }\n  }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ee",
            "calling": [
                "FUN_00003ff4"
            ],
            "imported": false,
            "current_name": "reverse_copy_000045ee"
        },
        "FUN_00005404": {
            "renaming": {
                "FUN_00005404": "process_data_00005404",
                "param_1": "object_id",
                "param_2": "data",
                "param_3": "data_array",
                "param_4": "param_4",
                "iVar1": "array_offset",
                "uVar2": "processed_data_uint",
                "puVar3": "current_char_ptr",
                "initialize_array_000042a4": "initialize_array",
                "PTR_DAT_0000549c": "data_array_1",
                "PTR_DAT_000054a0": "data_array_2",
                "PTR_DAT_000054a4": "data_array_3",
                "process_object_000054a8": "process_object",
                "processData_00004158": "process_data_2"
            },
            "code": "uint process_data_00005404(int object_id, uint data, int *data_array, undefined4 param_4) {\n  int array_offset, processed_data, array_size;\n  uint processed_data_uint;\n  undefined *current_char_ptr;\n  \n  if ((object_id != 0) && (*(int *)(object_id + 0x18) == 0)) {\n    initialize_array();\n  }\n  \n  if (data_array == (int *)PTR_DAT_0000549c) {\n    data_array = *(int **)(object_id + 4);\n  }\n  else if (data_array == (int *)PTR_DAT_000054a0) {\n    data_array = *(int **)(object_id + 8);\n  }\n  else if (data_array == (int *)PTR_DAT_000054a4) {\n    data_array = *(int **)(object_id + 0xc);\n  }\n  \n  data_array[2] = data_array[6];\n  processed_data_uint = (uint)*(ushort *)(data_array + 3);\n  array_offset = processed_data_uint << 0x1c;\n  \n  if (((array_offset < 0) && (processed_data_uint = data_array[4], processed_data_uint != 0)) ||\n     (array_offset = process_object(object_id, data_array, array_offset, processed_data_uint, param_4), array_offset == 0)) {\n    array_offset = *data_array - data_array[4];\n    data = data & 0xff;\n    \n    if ((array_offset < data_array[5]) || (array_offset = process_data_00005404_2(object_id, data_array), array_offset == 0)) {\n      data_array[2] = data_array[2] + -1;\n      current_char_ptr = (undefined *)*data_array;\n      *data_array = (int)(current_char_ptr + 1);\n      *current_char_ptr = (char)data;\n      \n      if (data_array[5] != array_offset + 1) {\n        if (-1 < (int)((uint)*(ushort *)(data_array + 3) << 0x1f)) {\n          return data;\n        }\n        if (data != 10) {\n          return data;\n        }\n      }\n      \n      array_offset = process_data_00005404_2(object_id, data_array);\n      if (array_offset == 0) {\n        return data;\n      }\n    }\n  }\n  \n  return 0xffffffff;\n}",
            "called": [
                "FUN_000054a8",
                "FUN_00004158",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005404",
            "calling": [
                "FUN_000057a8",
                "FUN_00004db8",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "process_data_00005404"
        },
        "FUN_00006974": {
            "renaming": {
                "FUN_00006974": "get_max_int_00006974",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "iVar1": "abs_num2",
                "uVar2": "result",
                "local_8": "NULL",
                "CONCAT44": "N/A",
                "uint": "uint8_t",
                "undefined8": "int64_t",
                "-(int)((ulonglong)uVar2 >> 0x20) - (uint)((int)uVar2 != 0)": "INT64_MIN",
                "-0x80000000": "INT32_MIN",
                "0x7fffffff": "INT32_MAX",
                "FUN_00006a14": "N/A"
            },
            "code": "int32_t get_max_int_00006974(int32_t num1, int32_t num2, int32_t num3, int32_t num4) {\n  int32_t result;\n  uint8_t is_negative_num2 = num2 < 0;\n  uint8_t is_negative_num4 = num4 < 0;\n  uint8_t is_num3_zero = num3 == 0;\n  uint8_t is_num1_zero = num1 == 0;\n  if (is_num3_zero && is_num4_zero) {\n    if (is_negative_num2) {\n      result = INT32_MIN;\n    } else if (num1 != 0 || num2 != 0) {\n      result = INT32_MAX;\n    }\n  } else {\n    int32_t abs_num2 = is_negative_num2 ? -num2 - (uint8_t)is_num1_zero : num2;\n    if (is_negative_num4) {\n      result = division_with_remainder_and_quotient_00006a14(is_num1_zero ? 0 : -num1, abs_num2, -num3, -num4 - (uint8_t)is_num3_zero, NULL);\n    } else {\n      result = division_with_remainder_and_quotient_00006a14(is_num1_zero ? 0 : -num1, abs_num2, num3, num4, NULL);\n    }\n    if (result == INT64_MIN) {\n      result = INT32_MAX;\n    }\n  }\n  return result;\n}",
            "called": [
                "FUN_00006a14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006974",
            "calling": [
                "FUN_0000443c"
            ],
            "imported": false,
            "current_name": "get_max_int_00006974"
        },
        "FUN_00004314": {
            "renaming": {
                "FUN_00004314": "initialize_array_00004314",
                "param_1": "error_code",
                "piVar1": "current_array",
                "piVar2": "next_array",
                "iVar3": "data_pointer",
                "ppiVar4": "array_ptr_ptr",
                "PTR_DAT_00004398": "DATA_POINTER",
                "FUN_000042a4": "initialize_data",
                "DAT_0000439c": "DEFAULT_VALUE",
                "do_nothing_and_return_00004274": "do_nothing_and_return",
                "do_nothing_000045e4": "do_nothing_with_pointer",
                "do_nothing_with_pointer_00004280": "do_nothing_with_pointer",
                "fill_array_with_value_00004622": "fill_array_with_value",
                "allocate_and_initialize_array_00004248": "allocate_and_initialize_array"
            },
            "code": "int *initialize_array_00004314(int *error_code)\n{\n    int *current_array;\n    int *next_array;\n    int array_length;\n    int **array_ptr_ptr;\n    do_nothing_and_return();\n    int *data_pointer = *(int *)PTR_DAT_00004398;\n    if (*(int *)(data_pointer + 0x18) == 0) {\n        initialize_data(data_pointer);\n    }\n    array_ptr_ptr = (int **)(data_pointer + 0x48);\n    do {\n        current_array = array_ptr_ptr[1];\n        next_array = array_ptr_ptr[2];\n        while (current_array = (int *)((int)current_array + -1), -1 < (int)current_array) {\n            if (*(short *)(next_array + 3) == 0) {\n                next_array[3] = DAT_0000439c;\n                next_array[0x19] = 0;\n                do_nothing_with_pointer(next_array + 0x16);\n                do_nothing_with_pointer();\n                next_array[1] = 0;\n                next_array[2] = 0;\n                next_array[4] = 0;\n                next_array[5] = 0;\n                *next_array = 0;\n                next_array[6] = 0;\n                fill_array_with_value(next_array + 0x17,0,8);\n                next_array[0xd] = 0;\n                next_array[0xe] = 0;\n                next_array[0x12] = 0;\n                next_array[0x13] = 0;\n                return next_array;\n            }\n            next_array = next_array + 0x1a;\n        }\n        if (*array_ptr_ptr == (int *)0x0) {\n            current_array = (int *)allocate_and_initialize_array_00004314(error_code,4);\n            *array_ptr_ptr = current_array;\n            if (current_array == (int *)0x0) {\n                do_nothing_with_pointer();\n                *error_code = 0xc;\n                return (int *)0x0;\n            }\n        }\n        array_ptr_ptr = (int **)*array_ptr_ptr;\n    } while( true );\n}",
            "called": [
                "FUN_000045e4",
                "FUN_00004274",
                "FUN_00004248",
                "FUN_00004280",
                "FUN_00004622",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004314",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "initialize_array_00004314",
            "code_backup": "\nint * FUN_00004314(undefined4 *param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int iVar3;\n  int **ppiVar4;\n  \n  do_nothing_and_return_00004274();\n  iVar3 = *(int *)PTR_DAT_00004398;\n  if (*(int *)(iVar3 + 0x18) == 0) {\n    FUN_000042a4(iVar3);\n  }\n  ppiVar4 = (int **)(iVar3 + 0x48);\n  do {\n    piVar1 = ppiVar4[1];\n    piVar2 = ppiVar4[2];\n    while (piVar1 = (int *)((int)piVar1 + -1), -1 < (int)piVar1) {\n      if (*(short *)(piVar2 + 3) == 0) {\n        piVar2[3] = DAT_0000439c;\n        piVar2[0x19] = 0;\n        do_nothing_000045e4(piVar2 + 0x16);\n        do_nothing_with_pointer_00004280();\n        piVar2[1] = 0;\n        piVar2[2] = 0;\n        piVar2[4] = 0;\n        piVar2[5] = 0;\n        *piVar2 = 0;\n        piVar2[6] = 0;\n        fill_array_with_value_00004622(piVar2 + 0x17,0,8);\n        piVar2[0xd] = 0;\n        piVar2[0xe] = 0;\n        piVar2[0x12] = 0;\n        piVar2[0x13] = 0;\n        return piVar2;\n      }\n      piVar2 = piVar2 + 0x1a;\n    }\n    if (*ppiVar4 == (int *)0x0) {\n      piVar1 = (int *)allocate_and_initialize_array_00004248(param_1,4);\n      *ppiVar4 = piVar1;\n      if (piVar1 == (int *)0x0) {\n        do_nothing_with_pointer_00004280();\n        *param_1 = 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar4 = (int **)*ppiVar4;\n  } while( true );\n}\n\n"
        },
        "FUN_00004dc8": {
            "renaming": {
                "FUN_00004dc8": "find_first_non_matching_pointer_00004dc8",
                "param_1": "pointer",
                "param_2": "length",
                "iVar1": "first_non_matching_index",
                "uVar2": "new_pointer",
                "bVar3": "non_matching_found"
            },
            "code": "void find_first_non_matching_pointer_00004dc8(void* pointer, int length)\n{\n  int first_non_matching_index = find_first_non_matching_pointer_00004dc8_00000490(pointer, (int)*(short *)(length + 0xe));\n  bool non_matching_found = first_non_matching_index >= 0;\n  \n  if (non_matching_found) {\n    uint new_pointer = *(int *)(length + 0x54) + first_non_matching_index;\n    *(uint *)(length + 0x54) = new_pointer;\n  }\n  else {\n    uint mask = *(ushort *)(length + 0xc) & 0xffffefff;\n    *(short *)(length + 0xc) = (short)mask;\n  }\n}",
            "called": [
                "FUN_00000490"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dc8",
            "calling": [],
            "imported": false,
            "current_name": "find_first_non_matching_pointer_00004dc8"
        },
        "FUN_00005fd8": {
            "renaming": {
                "FUN_00005fd8": "parse_integer_wrapper_00005fd8",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "parse_integer_00005edc": "parse_integer",
                "*DAT_00005fe8": "data"
            },
            "code": "void parse_integer_wrapper_00005fd8(const int* *DAT_00005fe8, int param1, int param2, int param3)\n{\n  parse_integer(*DAT_00005fe8, param1, param2, param3);\n  return;\n}",
            "called": [
                "FUN_00005edc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd8",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "parse_integer_wrapper_00005fd8"
        },
        "FUN_00005e10": {
            "renaming": {
                "FUN_00005e10": "read_byte_from_array_00005e10",
                "param_1": "array_address",
                "param_2": "array_pointer",
                "iVar1": "initialized",
                "uVar2": "byte",
                "pbVar3": "byte_pointer",
                "PTR_DAT_00005e5c": "array_pointer_1",
                "PTR_DAT_00005e60": "array_pointer_2",
                "PTR_DAT_00005e64": "array_pointer_3"
            },
            "code": "uint read_byte_from_array_00005e10(int array_address, byte **array_pointer){\n  int initialized = *(int *)(array_address + 0x18);\n  \n  if (array_address != 0 && initialized == 0) {\n    initialize_array();\n  }\n  \n  if (array_pointer == (byte **)PTR_DAT_00005e5c) {\n    array_pointer = *(byte ***)(array_address + 4);\n  }\n  else if (array_pointer == (byte **)PTR_DAT_00005e60) {\n    array_pointer = *(byte ***)(array_address + 8);\n  }\n  else if (array_pointer == (byte **)PTR_DAT_00005e64) {\n    array_pointer = *(byte ***)(array_address + 0xc);\n  }\n  \n  int result = process_data(array_address, array_pointer);\n  \n  if (result == 0) {\n    array_pointer[1] = array_pointer[1] - 1;\n    byte *byte_pointer = *array_pointer;\n    *array_pointer = byte_pointer + 1;\n    uint byte = (uint)*byte_pointer;\n    return byte;\n  }\n  else {\n    return 0xffffffff;\n  }\n}",
            "called": [
                "FUN_00006768",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e10",
            "calling": [
                "FUN_00004418"
            ],
            "imported": false,
            "current_name": "read_byte_from_array_00005e10"
        },
        "FUN_000033f4": {
            "renaming": {
                "FUN_000033f4": "calculate_score_and_execute_function_000033f4",
                "param_1": "input",
                "iVar1": "score",
                "auStack_2c": "stack",
                "parse_input_and_calculate_score_0000328c": "parse_input_and_calculate_score",
                "execute_function_00002654": "execute_function",
                "PTR_FUN_000031e0_1_0000343c": "PTR_FUNTION_POINTER",
                "FUN_00004db8": "log_error",
                "PTR_s_rtc__error_setting_alarm_00003440": "PTR_ERROR_MESSAGE",
                "uVar2": "score"
            },
            "code": "int calculate_score_and_execute_function_000033f4(undefined4 input)\n{\n  int score = 0;\n  undefined4 stack[9];\n  int parse_result = parse_input_and_calculate_score(input, stack);\n  if (parse_result == 0) {\n    int execution_result = execute_function(stack, PTR_FUN_000031e0_1_0000343c, 0);\n    if (execution_result == -1) {\n      log_error(PTR_s_rtc__error_setting_alarm_00003440);\n      score = 1;\n    }\n  }\n  else {\n    score = 1;\n  }\n  return score;\n}",
            "called": [
                "FUN_00002654",
                "FUN_00004db8",
                "FUN_0000328c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033f4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "calculate_score_and_execute_function_000033f4",
            "code_backup": "\nundefined4 FUN_000033f4(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 = parse_input_and_calculate_score_0000328c(param_1,auStack_2c);\n  if (iVar1 == 0) {\n    iVar1 = execute_function_00002654(auStack_2c,PTR_FUN_000031e0_1_0000343c,0);\n    if (iVar1 == -1) {\n      FUN_00004db8(PTR_s_rtc__error_setting_alarm_00003440);\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_0000443c": {
            "renaming": {
                "FUN_0000443c": "calculate_date_0000443c",
                "param_1": "date_array",
                "param_2": "DAT_0000458c",
                "uVar2": "year_day",
                "uVar3": "days_since_1900",
                "uVar4": "days_since_1600_jan_1_no_leap_years",
                "uVar5": "years_since_1600",
                "uVar6": "leap_years_since_1600",
                "uVar7": "days_since_1600_jan_1_leap_years",
                "uVar8": "days_since_year_start",
                "bVar9": "is_negative",
                "iVar1": "temp",
                "DAT_0000458c": "month_days",
                "DAT_00004590": "days_per_year",
                "DAT_00004594": "days_per_400_years",
                "DAT_00004598": "days_per_100_years"
            },
            "code": "uint * calculate_date_0000443c(uint *date_array, uint *DAT_0000458c, uint DAT_00004590, uint DAT_00004594, uint DAT_00004598)\n{\n  uint year = *date_array;\n  uint month = date_array[1];\n  int days_since_1900 = get_max_int(year, month, DAT_0000458c, 0);\n  bool is_negative = (int)days_since_1900 < 0;\n  if (is_negative) {\n    days_since_1900 += 0x15180;\n  }\n  uint day_of_week = (days_since_1900 + (is_negative ? 0xafa6b : 0xafa6c) + 3) % 7;\n  uint days_since_1900_jan_1 = is_negative ? days_since_1900 - 0x23ab0 : days_since_1900;\n  uint days_since_1600_jan_1 = DAT_00004594 * (days_since_1900_jan_1 / DAT_00004590) + days_since_1900_jan_1;\n  uint days_since_1600_jan_1_leap_years = days_since_1600_jan_1 / 0x8eac - days_since_1600_jan_1 / 0x5b4 + days_since_1600_jan_1 / DAT_00004598;\n  uint days_since_1600_jan_1_no_leap_years = days_since_1600_jan_1 - days_since_1600_jan_1_leap_years;\n  uint years_since_1600 = days_since_1600_jan_1_no_leap_years / 0x16d;\n  uint leap_years_since_1600 = years_since_1600 / 100 - days_since_1600_jan_1_no_leap_years / 0x5b4;\n  uint days_since_1600_jan_1_no_leap_years_no_leap_years_since_1600 = days_since_1600_jan_1_no_leap_years + leap_years_since_1600 - years_since_1600 * 0x16d;\n  uint days_since_1600_jan_1_leap_years_no_leap_years_since_1600 = days_since_1600_jan_1_leap_years + leap_years_since_1600 * 0x4 + days_since_1600_jan_1_no_leap_years_no_leap_years_since_1600 / 0x16c - days_since_1600_jan_1_no_leap_years_no_leap_years_since_1600 / DAT_00004598;\n  uint is_leap_year = leap_years_since_1600 % 4 == 0 && (leap_years_since_1600 % 100 != 0 || leap_years_since_1600 % 400 == 0);\n  uint days_since_year_start = is_leap_year ? days_since_1600_jan_1_leap_years_no_leap_years_since_1600 : days_since_1600_jan_1_no_leap_years_no_leap_years_since_1600;\n  uint month_day;\n  if (days_since_year_start < 0x132) {\n    if (((years_since_1600 & 3) == 0) && (years_since_1600 != (years_since_1600 / 100) * 100)) {\n      month_day = days_since_year_start + 0x3b + 1;\n    }\n    else {\n      month_day = days_since_year_start + 0x3b + count_leading_zeroes(years_since_1600 % 400) / 0x20;\n    }\n  }\n  else {\n    month_day = days_since_year_start - 0x132 + 1;\n  }\n  date_array[0] = days_since_year_start % 0x3c + 1;\n  date_array[1] = month_day / 0x3c + 1;\n  date_array[2] = month_day % 0x3c + 1;\n  date_array[3] = leap_years_since_1600;\n  date_array[4] = years_since_1600;\n  date_array[5] = days_since_1600_jan_1 / 0x16d - 0x76c;\n  date_array[6] = day_of_week;\n  date_array[7] = 0;\n  return date_array;\n}",
            "called": [
                "FUN_00006974"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000443c",
            "calling": [
                "FUN_00002624",
                "FUN_00002690"
            ],
            "imported": false,
            "current_name": "calculate_date_0000443c"
        },
        "FUN_000027b0": {
            "renaming": {
                "FUN_000027b0": "set_data_flag_000027b0",
                "DAT_00002814": "PTR_DATA_START",
                "DAT_00002818": "PTR_DATA_HEADER"
            },
            "code": "void set_data_flag_000027b0(void)\n{\n  uint32_t *data_ptr;\n  data_ptr = DAT_00002814;\n  data_ptr[0x40F] |= 0x20000000;\n  data_ptr[4] = 1;\n  data_ptr[4] = 0;\n  if ((data_ptr[5] & 1) != 0) {\n    *data_ptr = 0;\n  }\n  data_ptr[4] = 0x104;\n  data_ptr[2] = 0xffffff42;\n  data_ptr[7] = 0;\n  set_flag_for_data();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000027b0",
            "calling": [
                "FUN_000025f4"
            ],
            "imported": false,
            "current_name": "set_data_flag_000027b0"
        },
        "FUN_00005ebc": {
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "param_1": "destination",
                "param_2": "source",
                "cVar1": "current_char"
            },
            "code": "void copy_string_00005ebc(char *destination, char *source)\n{\n  char current_char;\n  do {\n    current_char = *source;\n    *destination = current_char;\n    source++;\n    destination++;\n  } while (current_char != '\\0');\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ebc",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "copy_string_00005ebc"
        },
        "FUN_00006192": {
            "renaming": {
                "FUN_00006192": "handle_pointer_00006192",
                "param_1": "input",
                "param_2": "ptr_list",
                "PTR_": "",
                "DAT_": "",
                "undefined4": "int",
                "ushort": "unsigned short"
            },
            "code": "int handle_pointer_00006192(int input, int *ptr_list) {\n    if ((int *)ptr_list[13] != (int *)0x0) {\n      if ((int *)ptr_list[13] != ptr_list + 0x11) {\n        add_pointer_to_list();\n      }\n      ptr_list[1] = ptr_list[16];\n      ptr_list[13] = 0;\n      if (ptr_list[16] != 0) {\n        *ptr_list = ptr_list[15];\n        return 0;\n      }\n    }\n    *ptr_list = ptr_list[4];\n    ptr_list[1] = 0;\n    *(unsigned short *)(ptr_list + 3) = *(unsigned short *)(ptr_list + 3) | 0x20;\n    return -1;\n  }",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006192",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "handle_pointer_00006192"
        },
        "FUN_00001734": {
            "renaming": {
                "FUN_00001734": "clear_memory_00001734",
                "DAT_00001744": "PTR_memory_offset"
            },
            "code": "void clear_memory_00001734(void)\n{\n    clear_memory_00001734_at_offset(DAT_00001744, 6);\n    return;\n}",
            "called": [
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001734",
            "calling": [
                "FUN_000019c0",
                "FUN_00001a18",
                "FUN_00001a3c"
            ],
            "imported": false,
            "current_name": "clear_memory_00001734"
        },
        "FUN_00000e14": {
            "renaming": {
                "FUN_00000e14": "find_first_non_matching_pointer_00000e14",
                "param_1": "ptr1",
                "param_2": "ptr2",
                "uVar1": "result",
                "DAT_00000e34": "data"
            },
            "code": "int find_first_non_matching_pointer_00000e14(uint32_t* DAT_00000e34, uint32_t* ptr1, uint32_t* ptr2) {\n  uint32_t* result = DAT_00000e34;\n  while (*ptr1 == *ptr2) {\n    ptr1++;\n    ptr2++;\n    if (*ptr1 == 0) {\n      return 0;\n    }\n  }\n  return (int)result + (int)ptr1 - (int)DAT_00000e34;\n}",
            "called": [
                "FUN_000012e2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e14",
            "calling": [
                "FUN_00000490"
            ],
            "imported": false,
            "current_name": "find_first_non_matching_pointer_00000e14"
        },
        "FUN_0000281c": {
            "renaming": {
                "FUN_0000281c": "find_first_difference_in_data_0000281c",
                "local_10": "index",
                "local_c": "data2"
            },
            "code": "int find_first_difference_in_data_0000281c(void)\n{\n  int index = 0;\n  int data1 = *DAT_00002858;\n  int data2;\n  \n  while ((index < 3 && (data2 = *DAT_00002858, data2 != data1))) {\n    index++;\n  }\n  return data2;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000281c",
            "calling": [
                "FUN_00002624"
            ],
            "imported": false,
            "current_name": "find_first_difference_in_data_0000281c"
        },
        "FUN_00002270": {
            "renaming": {
                "FUN_00002270": "is_pointer_equal_00002270",
                "param_1": "pointer_address",
                "uVar1": "is_equal",
                "iVar2": "first_pointer",
                "bVar3": "are_pointers_equal"
            },
            "code": "bool is_pointer_equal_00002270(int pointer_address) {\n  int first_pointer = *(int *)(pointer_address + 0xc);\n  bool are_pointers_equal = *(int *)(pointer_address + 8) == first_pointer;\n  if (are_pointers_equal) {\n    return true;\n  }\n  else {\n    return false;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002270",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": false,
            "current_name": "is_pointer_equal_00002270"
        },
        "FUN_00005780": {
            "renaming": {
                "FUN_00005780": "add_pointer_to_list_00005780",
                "param_1": "param",
                "*DAT_0000578c": "pointer"
            },
            "code": "void add_*add_pointer_to_list_00005780(void* *DAT_0000578c, undefined4 param){\n  add_*add_pointer_to_list_00005780_00004b34(**DAT_0000578c, param);\n  return;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005780",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "add_pointer_to_list_00005780"
        },
        "FUN_000020cc": {
            "renaming": {
                "FUN_000020cc": "extract_and_call_000020cc",
                "extract_bits_and_call_functions_00002028": "extract_bits_and_call_functions",
                "DAT_000020dc": "data_to_extract"
            },
            "code": "void extract_and_call_000020cc(uint8_t *data, int num_bits_to_extract);\n\nvoid extract_and_call_000020cc()\n{\n  uint8_t *DAT_000020dc = DAT_000020dc;\n  int num_bits_to_extract = 1;\n  extract_and_call_000020cc(DAT_000020dc, num_bits_to_extract);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020cc",
            "calling": [],
            "imported": false,
            "current_name": "extract_and_call_000020cc"
        },
        "FUN_00002396": {
            "renaming": {
                "FUN_00002396": "set_data_flag_and_return_000025f4_00002396"
            },
            "code": "void set_data_flag_and_return_000025f4_00002396(void)\n{\n  // Set data flag here\n  return;\n}",
            "called": [
                "FUN_000025f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002396",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "set_data_flag_and_return_000025f4_00002396"
        },
        "FUN_00004cb4": {
            "renaming": {
                "FUN_00004cb4": "process_data_00004cb4",
                "param_1": "data",
                "puVar1": "array_pointer",
                "uVar2": "array_length",
                "puVar3": "buffer_pointer",
                "unaff_r4": "constant1",
                "iVar4": "array_start",
                "unaff_r5": "constant2",
                "array_initialized": "array_initialized"
            },
            "code": "uint process_data_00004cb4(uint data)\n{\n  uint* array_pointer;\n  uint array_length;\n  int array_initialized;\n  uint processed_data = data & 0xff;\n  undefined* buffer_pointer;\n  uint* array_start;\n  uint* array_end;\n  undefined4 constant1;\n  undefined4 constant2;\n\n  array_start = *DAT_00004cd8;\n  array_initialized = (array_start != 0) && (*(int*)(array_start + 0x18) == 0);\n  if (array_initialized)\n  {\n    initialize_array_000042a4(array_start);\n  }\n\n  array_pointer = *(uint**)(array_start + 8);\n  array_initialized = (array_start != 0) && (*(int*)(array_start + 0x18) == 0);\n  if (array_initialized)\n  {\n    initialize_array_000042a4(array_start);\n  }\n\n  if (array_pointer == (uint*)PTR_DAT_00005e04)\n  {\n    array_pointer = *(uint**)(array_start + 4);\n  }\n  else if (array_pointer == (uint*)PTR_DAT_00005e08)\n  {\n    array_pointer = *(uint**)(array_start + 8);\n  }\n  else if (array_pointer == (uint*)PTR_DAT_00005e0c)\n  {\n    array_pointer = *(uint**)(array_start + 0xc);\n  }\n\n  if ((-1 < (int)(array_pointer[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort*)(array_pointer + 3) << 0x16)))\n  {\n    do_nothing_000045e8(array_pointer[0x16]);\n  }\n\n  array_length = array_pointer[2] - 1;\n  array_pointer[2] = array_length;\n\n  if (((int)array_length < 0) && (((int)array_length < (int)array_pointer[6]) || (processed_data == 10)))\n  {\n    processed_data = process_data_00004cb4_00005404(array_start, data, array_pointer, processed_data, constant1, constant2);\n  }\n  else\n  {\n    buffer_pointer = (undefined*)*array_pointer;\n    *array_pointer = buffer_pointer + 1;\n    *buffer_pointer = (char)data;\n  }\n\n  if ((-1 < (int)(array_pointer[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort*)(array_pointer + 3) << 0x16)))\n  {\n    do_nothing_000045ec(array_pointer[0x16]);\n  }\n  return processed_data;\n}",
            "called": [
                "FUN_00005404",
                "FUN_000045e8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cb4",
            "calling": [
                "FUN_00002a00"
            ],
            "imported": false,
            "current_name": "process_data_00004cb4"
        },
        "FUN_00003478": {
            "renaming": {
                "FUN_00003478": "calculate_score_and_parse_input_00003478",
                "param_1": "input",
                "iVar1": "parse_result",
                "uVar2": "score",
                "auStack_2c": "parsed_input",
                "process_and_set_flag_00002600": "process_and_set_flag",
                "FUN_00004db8": "log_error",
                "PTR_s_rtc__error_setting_time_000034bc": "error_message"
            },
            "code": "int calculate_score_and_parse_input_00003478(undefined4 input)\n{\n  int score = 0;\n  undefined4 parsed_input[9];\n  \n  int parse_result = parse_input_and_calculate_score_0000328c(input, parsed_input);\n  if (parse_result == 0) {\n    int flag_result = process_and_set_flag_00002600(parsed_input);\n    if (flag_result == -1) {\n      process_input_00004db8(PTR_s_rtc__error_setting_time_000034bc);\n      score = 1;\n    }\n  }\n  else {\n    score = 1;\n  }\n  return score;\n}",
            "called": [
                "FUN_0000328c",
                "FUN_00002600",
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003478",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "calculate_score_and_parse_input_00003478",
            "code_backup": "\nundefined4 FUN_00003478(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 = parse_input_and_calculate_score_0000328c(param_1,auStack_2c);\n  if (iVar1 == 0) {\n    iVar1 = process_and_set_flag_00002600(auStack_2c);\n    if (iVar1 == -1) {\n      FUN_00004db8(PTR_s_rtc__error_setting_time_000034bc);\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_00002028": {
            "renaming": {
                "FUN_00002028": "extract_bits_and_call_functions_00002028",
                "param_1": "memory_address",
                "param_2": "extract_bits_address",
                "iVar1": "function_index",
                "uVar2": "bits_to_extract",
                "local_c": "bit_index"
            },
            "code": "void extract_bits_and_call_functions_00002028(int memory_address, int extract_bits_address)\n{\n  int function_index;\n  uint bits_to_extract;\n  uint bit_index;\n  bits_to_extract = *(uint *)(memory_address + 0xa0);\n  for (bit_index = 0; (int)bit_index < 0x20; bit_index++) {\n    if (((bits_to_extract & 1 << (bit_index & 0xff)) != 0) &&\n       ((*(uint *)(memory_address + bit_index * 4) & 0xf0000) != 0)) {\n      *(int *)(memory_address + 0xa0) = 1 << (bit_index & 0xff);\n      function_index = extract_bits_from_memory(extract_bits_address, bit_index);\n      (**(code **)(PTR_DAT_000020b4 + function_index * 0xc))\n                (*(undefined4 *)(PTR_DAT_000020b4 + function_index * 0xc + 4));\n    }\n  }\n  check_flag_and_set();\n  return;\n}",
            "called": [
                "FUN_00001cf0",
                "FUN_00001e0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002028",
            "calling": [
                "FUN_000020f4",
                "FUN_000020e0",
                "FUN_000020b8",
                "FUN_000020cc",
                "FUN_00002108"
            ],
            "imported": false,
            "current_name": "extract_bits_and_call_functions_00002028"
        },
        "FUN_000016c8": {
            "renaming": {
                "FUN_000016c8": "set_calculated_offset_to_one_000016c8",
                "param_1": "base_address",
                "param_2": "offset",
                "puVar1": "offset_address",
                "*puVar1": "*offset_address",
                "calculate_offset_00001696": "calculate_offset"
            },
            "code": "void set_calculated_offset_to_one_000016c8(undefined4 base_address, undefined offset) {\n  undefined4 *offset_address;\n  offset_address = (undefined4 *)calculate_offset(base_address, offset);\n  *offset_address = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016c8",
            "calling": [
                "FUN_000017dc"
            ],
            "imported": false,
            "current_name": "set_calculated_offset_to_one_000016c8"
        },
        "FUN_00001a60": {
            "renaming": {
                "FUN_00001a60": "initialize_memory_00001a60",
                "DAT_00001ac4": "important_data",
                "*DAT_00001ac8": "*control_register",
                "DAT_00001ac8": "control_register",
                "set_offset_to_one_000016ec": "set_offset_to_one",
                "DAT_00001acc": "control_data",
                "*PTR_DAT_00001ad0": "*control_pointer"
            },
            "code": "void initialize_memory_00001a60(void)\n{\n  clear_memory_at_offset(DAT_00001ac4,1);\n  *DAT_00001ac8 = *DAT_00001ac8 & 0x3f | 0x80;\n  while ((DAT_00001ac8[6] & 0xc) != 8);\n  set_offset_to_one(DAT_00001acc,6);\n  while ((DAT_00001ac8[6] & 0x20) == 0);\n  while ((DAT_00001ac8[6] & 0x40) == 0);\n  *PTR_DAT_00001ad0 = 6;\n  return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a60",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_memory_00001a60"
        },
        "FUN_0000099c": {
            "renaming": {
                "FUN_0000099c": "initialize_and_execute_0000099c",
                "uStack_18": "stack_variable",
                "local_14": "local_array_1",
                "local_10": "original_data_array",
                "local_c": "local_array_3",
                "DAT_00000a14": "original_data_array",
                "initialize_data_and_clear_value_at_offset_00000db0": "initialize_data_and_clear_value_at_offset",
                "PTR_DAT_00000a18": "original_pointer_array",
                "PTR_Elf32_Rel_ARRAY_00000a20": "original_pointer_array_2",
                "PTR_DAT_00000a24": "original_pointer_array_2_end",
                "DAT_00000a1c": "original_value",
                "PTR_DAT_00000a28": "original_pointer_array_3",
                "DAT_00000a2c": "original_pointer_array_3_end",
                "do_nothing_00000990": "do_nothing",
                "initializeAndSetFlags_00000e64": "initialize_and_set_flags",
                "executeFunctionsInMemory_0000459c": "execute_functions_in_memory",
                "handle_interrupt_and_initialize_00000f8c": "handle_interrupt_and_initialize"
            },
            "code": "void initialize_and_execute_0000099c(void)\n{\n  undefined4 uStack_18;\n  undefined4 *local_array_1;\n  undefined4 *local_array_2;\n  undefined4 *local_array_3;\n  local_array_1 = &uStack_18;\n  local_array_2 = DAT_00000a14;\n  initialize_data_and_clear_value_at_offset();\n  local_array_3 = (undefined4 *)PTR_DAT_00000a18;\n  while (local_array_3 < &uStack_18) {\n    *local_array_3 = DAT_00000a1c;\n    local_array_3++;\n  }\n  local_array_3 = (undefined4 *)PTR_Elf32_Rel_ARRAY_00000a20;\n  while (local_array_3 < PTR_DAT_00000a24) {\n    *local_array_3 = *local_array_2;\n    local_array_2++;\n    local_array_3++;\n  }\n  local_array_3 = (undefined4 *)PTR_DAT_00000a28;\n  while( true ) {\n    if (DAT_00000a2c <= local_array_3) break;\n    *local_array_3 = 0;\n    local_array_3++;\n  }\n  do_nothing();\n  initialize_and_set_flags();\n  execute_functions_in_memory();\n  handle_interrupt_and_initialize();\n  return;\n}\n",
            "called": [
                "FUN_00000f8c",
                "FUN_00000e64",
                "FUN_00000db0",
                "FUN_0000459c",
                "FUN_00000990"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000099c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_and_execute_0000099c"
        },
        "FUN_00002d94": {
            "renaming": {
                "FUN_00002d94": "process_input_string_00002d94",
                "param_1": "input_string",
                "param_2": "string_length",
                "iVar1": "current_char",
                "bVar2": "byte_value",
                "bVar3": "is_start_of_string",
                "local_c": "current_position"
            },
            "code": "uint process_input_string_00002d94(undefined *input_string, int string_length)\n{\n    int current_char;\n    byte byte_value;\n    bool is_start_of_string;\n    undefined *current_position;\n    \n    current_position = input_string;\n    while (true)\n    {\n        if ((current_position - input_string) >= string_length - 1)\n        {\n            return 0xffffffff;\n        }\n        current_char = read_byte_from_array_00004418();\n        if (current_char < 0)\n        {\n            break;\n        }\n        if ((current_char == 0xd) || (current_char == 10))\n        {\n            *current_position = 0;\n            process_data_wrapper_00002a00(0xd);\n            process_data_wrapper_00002a00(10);\n            is_start_of_string = current_position == input_string;\n            if (is_start_of_string)\n            {\n                input_string = (undefined *)0x1;\n            }\n            byte_value = (byte)input_string;\n            if (!is_start_of_string)\n            {\n                byte_value = 0;\n            }\n            return (uint)byte_value;\n        }\n        if ((current_char == 8) || (current_char == 0x7f))\n        {\n            if (current_position != input_string)\n            {\n                current_position--;\n                *current_position = 0;\n                process_data_wrapper_00002a00(8);\n                process_data_wrapper_00002a00(0x20);\n                process_data_wrapper_00002a00(8);\n            }\n        }\n        else\n        {\n            *current_position = (char)current_char;\n            process_data_wrapper_00002a00(current_char);\n            current_position++;\n        }\n    }\n    return 1;\n}",
            "called": [
                "FUN_00002a00",
                "FUN_00004418"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002d94",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "process_input_string_00002d94"
        },
        "FUN_00003918": {
            "renaming": {
                "FUN_00003918": "get_value_00003918",
                "param_1": "param",
                "uVar1": "value",
                "undefined4": "int",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef enum {\n    PARAM_2 = 2,\n    PARAM_3 = 3,\n    PARAM_6 = 6,\n    PARAM_9 = 9,\n    PARAM_12 = 12,\n    PARAM_15 = 15,\n    PARAM_241 = 241,\n    PARAM_244 = 244,\n    PARAM_247 = 247,\n    PARAM_250 = 250,\n    PARAM_253 = 253\n} PARAM;\n\nint get_value_00003918(PARAM param) {\n    int value;\n    switch(param) {\n        case PARAM_2:\n            value = 0x68;\n            break;\n        case PARAM_3:\n            value = 0x6b;\n            break;\n        case PARAM_6:\n            value = 0x4d;\n            break;\n        case PARAM_9:\n            value = 0x47;\n            break;\n        case PARAM_12:\n            value = 0x54;\n            break;\n        case PARAM_15:\n            value = 0x50;\n            break;\n        case PARAM_241:\n            value = 0x66;\n            break;\n        case PARAM_244:\n            value = 0x70;\n            break;\n        case PARAM_247:\n            value = 0x6e;\n            break;\n        case PARAM_250:\n            value = 0x75;\n            break;\n        case PARAM_253:\n            value = 0x6d;\n            break;\n        default:\n            value = 0;\n            break;\n    }\n    return value;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003918",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "get_value_00003918"
        },
        "FUN_00003d64": {
            "renaming": {
                "FUN_00003d64": "execute_function_00003d64",
                "param_1": "function_pointer",
                "param_2": "arg1",
                "uVar1": "result"
            },
            "code": "int execute_function_00003d64(int function_pointer, int arg1)\n{\n  int result;\n  if (function_pointer == 0) {\n    result = -19;\n  }\n  else {\n    result = (***(int ***)(function_pointer + 0xc))(*(int *)(function_pointer + 4),arg1);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d64",
            "calling": [
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "execute_function_00003d64"
        },
        "FUN_00004e52": {
            "renaming": {
                "FUN_00004e52": "compare_bytes_00004e52",
                "param_1": "first_array",
                "param_2": "second_array",
                "bVar1": "current_byte_second_array",
                "uVar2": "index",
                "bVar3": "match"
            },
            "code": "int compare_bytes_00004e52(byte* first_array, byte* second_array)\n{\n    byte current_byte_first_array;\n    byte current_byte_second_array;\n    uint index = 0;\n    bool match = true;\n    do {\n        current_byte_first_array = *first_array;\n        current_byte_second_array = *second_array;\n        if (current_byte_first_array != current_byte_second_array) {\n            match = false;\n        }\n        first_array++;\n        second_array++;\n        index++;\n    } while (current_byte_first_array != 0 && match);\n    return current_byte_first_array - current_byte_second_array;\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e52",
            "calling": [
                "FUN_00002b10",
                "FUN_00004e52",
                "FUN_00005100",
                "FUN_00002fe0",
                "FUN_0000316c",
                "FUN_00002a18"
            ],
            "imported": false,
            "current_name": "compare_bytes_00004e52"
        },
        "FUN_000010d4": {
            "renaming": {
                "FUN_000010d4": "create_new_task_000010d4",
                "param_1": "alignment",
                "param_2": "priority",
                "param_3": "stack_size",
                "param_4": "flags",
                "param_5": "arg1",
                "param_6": "arg2",
                "param_7": "arg3",
                "uVar1": "interrupt_enabled",
                "uVar2": "array_initialized",
                "iVar3": "task_index",
                "uVar4": "stack_size_aligned",
                "puVar5": "task_info_ptr",
                "local_30": "stack_aligned",
                "local_2c": "task_index",
                "local_10": "i",
                "local_c": "loop_index_1",
                "local_a": "free_task_index",
                "PTR_DAT_0000126c": "task_info_list",
                "PTR_DAT_00001270": "task_info_list_count"
            },
            "code": "int create_new_task_000010d4(uint alignment, int priority, byte stack_size, uint flags, undefined4 arg1, undefined4 arg2, undefined4 arg3) {\n  uint stack_aligned;\n  int task_index;\n  uint stack_size_aligned;\n  undefined4 *task_info_ptr;\n  undefined4 task_info[12];\n  short free_task_index = 0;\n  short i;\n  \n  if (stack_size < 0x10) {\n    stack_aligned = alignment;\n    stack_size_aligned = stack_size;\n    if ((alignment & 3) != 0) {\n      stack_aligned = 4 - (alignment & 3);\n      stack_size_aligned = stack_aligned + alignment;\n      stack_aligned = priority - stack_aligned;\n    }\n    stack_size_aligned = stack_size_aligned - 0x30U & 0xfffffffc;\n    task_info_ptr = (undefined4 *)(stack_size_aligned + stack_aligned);\n    if ((flags & 8) == 0) {\n      *(uint *)stack_aligned = stack_aligned;\n    }\n    else {\n      for (i = stack_aligned; i < stack_size_aligned + stack_aligned; i = i + 4) {\n        *(uint *)i = i;\n      }\n    }\n    if (check_interrupt_enabled() == 0) {\n      return -0x8b;\n    }\n    for (i = 1; i < 0x21; i = i + 1) {\n      if (*(int *)(PTR_DAT_0000126c + i * 4) == 0) {\n        free_task_index = i;\n        break;\n      }\n    }\n    if (free_task_index == 0) {\n      enableIRQinterrupts_if_privileged();\n      return -0x8b;\n    }\n    *(undefined4 **)(PTR_DAT_0000126c + free_task_index * 4) = task_info_ptr;\n    *(short *)((int)task_info_ptr + 6) = free_task_index;\n    task_info[0] = initialize_array(arg1, arg2, stack_aligned, stack_size_aligned);\n    *task_info_ptr = task_info[0];\n    task_info_ptr[9] = stack_aligned;\n    task_info_ptr[0xb] = priority;\n    task_info_ptr[10] = arg3;\n    *(byte *)((int)task_info_ptr + 5) = stack_size;\n    *(undefined *)(task_info_ptr + 1) = 0;\n    task_info_ptr[2] = 0;\n    task_info_ptr[3] = 0;\n    task_info_ptr[4] = 0;\n    initialize_memory(task_info_ptr + 5, 0);\n    task_info_ptr[8] = 0;\n    *(int *)PTR_DAT_00001270 = *(int *)PTR_DAT_00001270 + 1;\n    if ((flags & 1) == 0) {\n      update_linked_list(task_info_ptr, 10);\n      if ((flags & 4) == 0) {\n        enableIRQinterrupts_if_privileged();\n        check_privileged_mode_and_set_flag_if_not(stack_size);\n        return (int)free_task_index;\n      }\n    }\n    else {\n      update_linked_list(task_info_ptr, 1);\n    }\n    enableIRQinterrupts_if_privileged();\n    return (int)free_task_index;\n  }\n  else {\n    return -0x16;\n  }\n}\n",
            "called": [
                "FUN_00000698",
                "FUN_00000fec",
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_00000738",
                "FUN_000007dc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010d4",
            "calling": [
                "FUN_00000f8c"
            ],
            "imported": false,
            "current_name": "create_new_task_000010d4"
        },
        "FUN_000045e4": {
            "renaming": {
                "FUN_000045e4": "do_nothing_000045e4"
            },
            "code": "\nvoid do_nothing_000045e4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e4",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e4"
        },
        "FUN_00000738": {
            "renaming": {
                "FUN_00000738": "check_privileged_mode_and_set_flag_if_not_00000738",
                "param_1": "param",
                "iVar1": "exception_number",
                "PTR_DAT_0000078c": "ptr_dat_78c",
                "*(byte *)(*(int *)PTR_DAT_0000078c + 4)": "*ptr_dat_78c_4",
                "*(byte *)(*(int *)PTR_DAT_0000078c + 5)": "*ptr_dat_78c_5",
                "get_exception_number_if_privileged_mode_00000d2a": "get_exception_number_if_privileged_mode",
                "set_flag_0000093c": "set_flag",
                "*(undefined4 *)PTR_DAT_00000790": "*(int*)PTR_DAT_00000790"
            },
            "code": "void check_privileged_mode_and_set_flag_if_not_00000738(ushort param)\n{\n  int exception_number;\n  int* PTR_DAT_0000078c = *(int**)PTR_DAT_0000078c;\n  byte* PTR_DAT_0000078c_4 = (byte*)(PTR_DAT_0000078c + 1);\n  byte* PTR_DAT_0000078c_5 = (byte*)(PTR_DAT_0000078c + 2);\n  if (*(byte *)(*(int *)PTR_DAT_0000078c + 4) < 9 || param < *(byte *)(*(int *)PTR_DAT_0000078c + 5))\n  {\n    exception_number = get_exception_number_if_privileged_mode_00000d2a();\n    if (exception_number == 0)\n    {\n      set_flag_0000093c();\n    }\n    else\n    {\n      *(undefined4 *)PTR_DAT_00000790 = 1;\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00000d2a",
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000738",
            "calling": [
                "FUN_000010d4",
                "FUN_000024bc"
            ],
            "imported": false,
            "current_name": "check_privileged_mode_and_set_flag_if_not_00000738"
        },
        "FUN_00003e58": {
            "renaming": {
                "FUN_00003e58": "count_digits_00003e58",
                "param_1": "num_array",
                "param_2": "num_length",
                "iVar1": "digit_count",
                "local_18": "count",
                "local_14": "num_ptr",
                "get_num_of_digits_00003dc4": "get_num_of_digits"
            },
            "code": "int count_digits_00003e58(int *num_array, int num_length) {\n  int count = num_length;\n  int *num_ptr = num_array;\n  if (- (num_length >> 0x1f) != 0) {\n    if (num_array != (int *)0x0) {\n      num_ptr = num_array + 1;\n      *num_array = 0x2d;\n    }\n    count = -num_length;\n  }\n  int digit_count = get_num_of_digits(num_ptr, count);\n  return - (num_length >> 0x1f) + digit_count;\n}",
            "called": [
                "FUN_00003dc4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e58",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": false,
            "current_name": "count_digits_00003e58"
        },
        "FUN_00004e26": {
            "renaming": {
                "FUN_00004e26": "set_param_to_19_00004e26",
                "param_1": "param1",
                "param_2": "param2",
                "iVar1": "result",
                "uVar2": "flag",
                "bVar3": "is_error"
            },
            "code": "void set_param_to_19_00004e26(int param1, int param2) {\n  int result = set_param_to_19_00004e26_000004f2(param1, *(short *)(param2 + 0xe));\n  bool is_error = result == -1;\n  ushort flag = *(ushort *)(param2 + 0xc);\n  if (is_error) {\n    flag &= 0xefff;\n  }\n  else {\n    *(int *)(param2 + 0x54) = result;\n    flag |= 0x1000;\n  }\n  *(ushort *)(param2 + 0xc) = flag;\n}",
            "called": [
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e26",
            "calling": [],
            "imported": false,
            "current_name": "set_param_to_19_00004e26"
        },
        "FUN_000045e8": {
            "renaming": {
                "FUN_000045e8": "do_nothing_000045e8"
            },
            "code": "\nvoid do_nothing_000045e8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e8",
            "calling": [
                "FUN_000057f8",
                "FUN_00005fec",
                "FUN_00004db8",
                "FUN_00005790",
                "FUN_00004274",
                "FUN_0000428c",
                "FUN_00004158",
                "FUN_00004418",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e8"
        },
        "FUN_000057f8": {
            "renaming": {
                "FUN_000057f8": "process_and_print_data_000057f8",
                "param_1": "obj_ptr",
                "param_2": "data_ptr",
                "param_3": "format_str",
                "param_4": "int_array",
                "puVar1": "format_str_start",
                "puVar2": "byte_seq_start",
                "iVar3": "index",
                "iVar4": "result",
                "piVar5": "int_ptr",
                "bVar6": "is_digit",
                "pbVar7": "byte_ptr",
                "unaff_r7": "temp_var",
                "pbVar8": "current_byte",
                "local_8c": "int_array_ptr",
                "local_88": "flags",
                "local_84": "precision",
                "uStack_80": "stack_var",
                "local_7c": "width",
                "local_74": "total_bytes_processed",
                "local_70": "current_char",
                "local_6f": "space_char",
                "local_6e": "plus_char",
                "local_45": "hash_char",
                "local_30": "zero_char"
            },
            "code": "\nint process_and_print_data_000057f8(int obj_ptr,undefined *data_ptr,byte *format_str,int *int_array)\n\n{\n  undefined *format_str_start;\n  undefined *byte_seq_start;\n  int index;\n  int result;\n  int *int_ptr;\n  bool is_digit;\n  byte *byte_ptr;\n  int temp_var;\n  byte *current_byte;\n  int *int_array_ptr;\n  uint flags;\n  int precision;\n  undefined4 stack_var;\n  int width;\n  int total_bytes_processed;\n  byte current_char;\n  undefined space_char;\n  undefined plus_char;\n  undefined hash_char;\n  undefined4 zero_char;\n  \n  if ((obj_ptr != 0) && (*(int *)(obj_ptr + 0x18) == 0)) {\n    initialize_array_000042a4();\n  }\n  if (data_ptr == PTR_DAT_00005a38) {\n    data_ptr = *(undefined **)(obj_ptr + 4);\n  }\n  else if (data_ptr == PTR_DAT_00005a3c) {\n    data_ptr = *(undefined **)(obj_ptr + 8);\n  }\n  else if (data_ptr == PTR_DAT_00005a40) {\n    data_ptr = *(undefined **)(obj_ptr + 0xc);\n  }\n  if ((-1 < *(int *)(data_ptr + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(data_ptr + 0xc) << 0x16))) {\n    do_nothing_000045e8(*(undefined4 *)(data_ptr + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(data_ptr + 0xc) << 0x1c)) || (*(int *)(data_ptr + 0x10) == 0)) &&\n     (index = process_object_000054a8(obj_ptr,data_ptr), index != 0)) {\n    if ((-1 < *(int *)(data_ptr + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(data_ptr + 0xc) << 0x16))) {\n      do_nothing_000045ec(*(undefined4 *)(data_ptr + 0x58));\n    }\n    return -1;\n  }\n  format_str_start = PTR_s___0__00005a44;\n  total_bytes_processed = 0;\n  space_char = 0x20;\n  plus_char = 0x30;\n  current_byte = format_str;\n  int_array_ptr = int_array;\nLAB_0000588e:\n  byte_ptr = current_byte;\n  if (*byte_ptr != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  current_byte = byte_ptr + 1;\n  if (*byte_ptr != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  index = (int)byte_ptr - (int)format_str;\n  if (index != 0) {\n    result = process_data_and_return_last_index_000057d2(obj_ptr,data_ptr,format_str,index);\n    if (result == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(data_ptr + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(data_ptr + 0xc) << 0x16))) {\n        do_nothing_000045ec(*(undefined4 *)(data_ptr + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(data_ptr + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return total_bytes_processed;\n    }\n    total_bytes_processed = total_bytes_processed + index;\n  }\n  if (*byte_ptr == 0) goto LAB_00005a06;\n  precision = -1;\n  stack_var = 0;\n  flags = 0;\n  width = 0;\n  hash_char = 0;\n  zero_char = 0;\n  current_byte = byte_ptr + 1;\n  while( true ) {\n    byte_ptr = current_byte + 1;\n    index = find_byte_sequence_00006010(PTR_s___0__00005a44,*current_byte,5);\n    byte_seq_start = PTR_DAT_00005a54;\n    if (index == 0) break;\n    flags = 1 << (index - (int)format_str_start & 0xffU) | flags;\n    current_byte = byte_ptr;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    hash_char = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    hash_char = 0x2b;\n  }\n  if (*current_byte == 0x2a) {\n    int_ptr = int_array_ptr + 1;\n    width = *int_array_ptr;\n    int_array_ptr = int_ptr;\n    if (width < 0) {\n      width = -width;\n      flags = flags | 2;\n    }\n  }\n  else {\n    is_digit = false;\n    index = width;\n    byte_ptr = current_byte;\n    while( true ) {\n      if (9 < *byte_ptr - 0x30) break;\n      index = index * 10 + (*byte_ptr - 0x30);\n      is_digit = true;\n      byte_ptr = byte_ptr + 1;\n    }\n    if (is_digit) {\n      width = index;\n    }\n  }\n  if (*byte_ptr == 0x2e) {\n    if (byte_ptr[1] == 0x2a) {\n      precision = *int_array_ptr;\n      if (precision < 0) {\n        precision = -1;\n      }\n      byte_ptr = byte_ptr + 2;\n      int_array_ptr = int_array_ptr + 1;\n    }\n    else {\n      is_digit = false;\n      precision = 0;\n      index = 0;\n      while( true ) {\n        byte_ptr = byte_ptr + 1;\n        if (9 < *byte_ptr - 0x30) break;\n        index = index * 10 + (*byte_ptr - 0x30);\n        is_digit = true;\n      }\n      if (is_digit) {\n        precision = index;\n      }\n    }\n  }\n  index = find_byte_sequence_00006010(PTR_DAT_00005a54,*byte_ptr,3);\n  if (index != 0) {\n    flags = flags | 0x40 << (index - (int)byte_seq_start & 0xffU);\n    byte_ptr = byte_ptr + 1;\n  }\n  format_str = byte_ptr + 1;\n  current_char = *byte_ptr;\n  index = find_byte_sequence_00006010(PTR_s_efgEFG_00005a48,current_char,6);\n  if (index == 0) {\n    index = convert_and_print_data_00005b34(obj_ptr,&flags,data_ptr,DAT_00005a50,&int_array_ptr);\n  }\n  else {\n    index = obj_ptr;\n    if (DAT_00005a4c == 0) {\n      int_array_ptr = (int *)(((int)int_array_ptr + 7U & 0xfffffff8) + 8);\n      index = temp_var;\n      goto LAB_000059b4;\n    }\n  }\n  if (index == -1) goto LAB_00005a06;\nLAB_000059b4:\n  total_bytes_processed = total_bytes_processed + index;\n  current_byte = format_str;\n  temp_var = index;\n  goto LAB_0000588e;\n}\n\n",
            "called": [
                "FUN_00005b34",
                "FUN_00006010",
                "FUN_000045e8",
                "FUN_000054a8",
                "FUN_000045ec",
                "FUN_000042a4",
                "FUN_000057d2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057f8",
            "calling": [
                "FUN_00004c84"
            ],
            "imported": false,
            "current_name": "process_and_print_data_000057f8"
        },
        "FUN_000018bc": {
            "renaming": {
                "FUN_000018bc": "initialize_data_000018bc",
                "DAT_00001910": "data_pointer_1",
                "DAT_00001914": "data_pointer_2",
                "PTR_DAT_00001918": "pointer_data",
                "update_byte_with_mask_00001748": "update_byte_with_mask",
                "clear_memory_at_offset_00001710": "clear_memory"
            },
            "code": "void initialize_data_000018bc(void)\n{\n  update_byte_with_mask(0xa0);\n  *DAT_00001910 = (*DAT_00001910 & 0x3b) | 4;\n  clear_memory(DAT_00001914, 1);\n  do {\n  } while ((DAT_00001910[6] & 0x10) == 0);\n  do {\n  } while ((DAT_00001910[6] & 0xc) != 0);\n  *PTR_DAT_00001918 = 0;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000018bc",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_data_000018bc"
        },
        "FUN_00000f04": {
            "renaming": {
                "FUN_00000f04": "handle_interrupt_and_parse_input_loop_00000f04",
                "param_1": "input_char",
                "param_2": "input_value",
                "*piRam00000f4c": "interrupt_enabled",
                "local_10": "last_input_value",
                "local_9": "last_input_char",
                "execute_function_with_pointer_00000ed8": "execute_function_with_pointer",
                "process_data_00004c84": "process_data",
                "uRam00000f50": "data_1",
                "uRam00000f54": "data_2",
                "uRam00000f58": "data_3",
                "check_interrupt_enabled_00000cd0": "check_interrupt_enabled",
                "do_nothing_00000ef8": "do_nothing",
                "wait_for_interrupt_00000e58": "wait_for_interrupt",
                "PTR_s_main____This_is_RIOT___Version__2_00000f7c": "main_version_string"
            },
            "code": "void handle_interrupt_and_parse_input_loop_00000f04(char input_char, unsigned int input_value) {\n  static int interrupt_enabled = 0;\n  static int initialized = 0;\n  static char last_input_char = 0;\n  static unsigned int last_input_value = 0;\n  static char *PTR_s_main____This_is_RIOT___Version__2_00000f7c = \"main: This is RIOT! (Version 2)\";\n  if (!initialized) {\n    initialized = 1;\n    if (input_char == 3) {\n      execute_function_with_pointer();\n    }\n    process_data(uRam00000f50, input_value);\n    process_data(uRam00000f54);\n    process_data(uRam00000f58);\n  }\n  check_interrupt_enabled();\n  do_nothing();\n  wait_for_interrupt();\n  process_data(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  handle_interrupt_and_parse_input_loop_00000f04();\n}\n",
            "called": [
                "FUN_00004c84",
                "FUN_0000211c",
                "FUN_00002400",
                "FUN_00000ed8",
                "FUN_00000ef8",
                "FUN_00000cd0",
                "FUN_000023a4",
                "FUN_00000e58"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f04",
            "calling": [
                "FUN_000013b8",
                "FUN_00003ec4",
                "FUN_00000cc0",
                "FUN_00000fec",
                "FUN_00001034",
                "FUN_00000a30"
            ],
            "imported": false,
            "current_name": "handle_interrupt_and_parse_input_loop_00000f04"
        },
        "FUN_00000610": {
            "renaming": {
                "FUN_00000610": "update_data_00000610",
                "iVar1": "leading_zero_bits",
                "iVar2": "current_data_ptr",
                "uVar3": "result",
                "count_leading_zero_bits_in_integer_00000566": "count_leading_zero_bits_in_integer",
                "PTR_DAT_00000684": "data_ptr_1",
                "PTR_DAT_00000688": "data_ptr_2",
                "PTR_DAT_0000068c": "input_data_ptr",
                "PTR_DAT_00000690": "data_ptr_table",
                "PTR_DAT_00000694": "short_ptr"
            },
            "code": "int update_data_00000610(int num) {\n    int count = 0;\n    while (num) {\n        num >>= 1;\n        count++;\n    }\n    return (32 - count);\n}\n\nint update_data_00000610() {\n    int current_data_ptr = *(int *)PTR_DAT_00000688;\n    int leading_zero_bits = update_data_00000610(*(int *)PTR_DAT_0000068c);\n    int new_data_ptr = **(int **)(PTR_DAT_00000690 + leading_zero_bits * 4);\n\n    if (current_data_ptr == new_data_ptr + -8) {\n        return 0;\n    }\n    else {\n        if ((current_data_ptr != 0) && (*(char *)(current_data_ptr + 4) == '\t')) {\n            *(char *)(current_data_ptr + 4) = '\\n';\n        }\n        *(char *)(new_data_ptr + -4) = '\\t';\n        *(short *)PTR_DAT_00000694 = *(short *)(new_data_ptr + -2);\n        *(int *)PTR_DAT_00000688 = new_data_ptr + -8;\n        return 1;\n    }\n}\n",
            "called": [
                "FUN_00000566"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000610",
            "calling": [],
            "imported": false,
            "current_name": "update_data_00000610"
        },
        "FUN_00003694": {
            "renaming": {
                "FUN_00003694": "display_object_data_00003694",
                "param_1": "object_address",
                "param_2": "num_elements",
                "uVar1": "label",
                "bit_value": "bit_value",
                "bit_mask": "bit_mask",
                "is_bit_set": "is_bit_set",
                "auStack_18": "value_buffer",
                "local_10": "buffer_index",
                "local_a": "value_type",
                "local_9": "element_index"
            },
            "code": "void display_object_data_00003694(int object_address, byte num_elements) {\\n    undefined4 uVar1;\\n    char bit_value;\\n    uint bit_mask;\\n    bool is_bit_set;\\n    undefined value_buffer[8];\\n    int buffer_index;\\n    char value_type;\\n    byte element_index;\\n\\n    if ((object_address == 0) || (num_elements > 3)) {\\n        process_input_00004db8(PTR_s_Unable_to_display_data_object_000037e4);\\n    }\\n    else {\\n        process_data_00004c84(PTR_s_Data__000037e8);\\n        for (element_index = 0; element_index < num_elements; element_index++) {\\n            if (*(byte *)(object_address + 6) < 0x14) {\\n                bit_mask = DAT_000037ec & 1 << (uint)*(byte *)(object_address + 6);\\n                is_bit_set = bit_mask != 0;\\n                if (is_bit_set) {\\n                    bit_mask = 1;\\n                }\\n                bit_value = (char)bit_mask;\\n                if (!is_bit_set) {\\n                    bit_value = \"\\0\";\\n                }\\n                if (bit_value == \"\\0\") {\\n                    goto LAB_000036ee;\\n                }\\n                value_type = \"\\0\";\\n            }\\n            else {\\nLAB_000036ee:\\n                value_type = get_value_type((int)*(char *)(object_address + 7));\\n            }\\n            process_data_00004c84(PTR_LAB_000037f0);\\n            if (num_elements < 2) {\\n                process_data_00004c84(PTR_s__000037f8);\\n            }\\n            else {\\n                process_data_00004c84(PTR_s___u__000037f4, element_index);\\n            }\\n            if (value_type == \"\\0\") {\\n                if (*(char *)(object_address + 7) == \"\\0\") {\\n                    process_data_00004c84(PTR_LAB_00003800, (int)*(short *)(object_address + (uint)element_index * 2));\\n                }\\n                else if ((*(char *)(object_address + 7) + 4 < 0 == SCARRY4((int)*(char *)(object_address + 7), 4)) && (*(char *)(object_address + 7) < \"\\0\")) {\\n                    buffer_index = count_and_format_digits_00003e9e(value_buffer, (int)*(short *)(object_address + (uint)element_index * 2), (int)*(char *)(object_address + 7));\\n                    value_buffer[buffer_index] = 0;\\n                    process_data_00004c84(PTR_LAB_00003804, value_buffer);\\n                }\\n                else {\\n                    process_data_00004c84(PTR_s__iE_i_00003808, (int)*(short *)(object_address + (uint)element_index * 2), (int)*(char *)(object_address + 7));\\n                }\\n            }\\n            else {\\n                process_data_00004c84(PTR_s__6d__c_000037fc, (int)*(short *)(object_address + (uint)element_index * 2), value_type);\\n            }\\n            uVar1 = get_label_00003810(*(undefined *)(object_address + 6));\\n            process_data_00004c84(PTR_LAB_0000380c, uVar1);\\n        }\\n    }\\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00003e9e",
                "FUN_00003918",
                "FUN_00003810"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003694",
            "calling": [
                "FUN_0000305c",
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "display_object_data_00003694"
        },
        "FUN_00002364": {
            "renaming": {
                "FUN_00002364": "check_difference_and_update_00002364",
                "param_1": "pointer",
                "param_2": "value",
                "iVar1": "difference",
                "uVar2": "return_value",
                "is_difference_equal_00002294": "is_difference_equal",
                "increment_and_store_000022be": "increment_and_store"
            },
            "code": "int check_difference_and_update_00002364(int difference); \\n\\n\\\n                      void increment_and_store(int* pointer, int value); \\n\\n\\\n                      \\n\\n\\\n                      int check_difference_and_update_00002364(int* pointer, int value) { \\n\\n\\\n                          int difference = check_difference_and_update_00002364(pointer); \\n\\n\\\n                          if (difference == 0) { \\n\\n\\\n                              increment_and_store(pointer, value); \\n\\n\\\n                              return 0; \\n\\n\\\n                          } \\n\\n\\\n                          else { \\n\\n\\\n                              return -1; \\n\\n\\\n                          } \\n\\n\\\n                      }",
            "called": [
                "FUN_000022be",
                "FUN_00002294"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002364",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": false,
            "current_name": "check_difference_and_update_00002364"
        },
        "FUN_00001ad4": {
            "renaming": {
                "FUN_00001ad4": "set_bitmask_00001ad4",
                "*DAT_00001b08": "data_ptr",
                "DAT_00001b08": "data_array",
                "*PTR_DAT_00001b0c": "ptr_ptr",
                "PTR_DAT_00001b0c": "ptr_array"
            },
            "code": "void set_bitmask_00001ad4(void)\n{\n  unsigned char* *DAT_00001b08 = DAT_00001b08;\n  unsigned char* *PTR_DAT_00001b0c = PTR_DAT_00001b0c;\n  **DAT_00001b08 = **DAT_00001b08 & 0x3f;\n  while ((**DAT_00001b08 & 0xc0) != 0xc0);\n  **PTR_DAT_00001b0c = 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ad4",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_bitmask_00001ad4"
        },
        "FUN_00001274": {
            "renaming": {
                "FUN_00001274": "initialize_and_process_data_00001274",
                "initialize_data_0000258c": "initialize_data",
                "DAT_00001298": "data_flag_ptr",
                "initialize_data_and_process_00001c84": "initialize_data_and_process",
                "set_data_flag_and_return_000025f4_00002396": "set_data_flag_and_return"
            },
            "code": "void initialize_and_process_data_00001274(void)\n{\n    initialize_data();\n    *DAT_00001298 |= 0x28;\n    initialize_data_and_process();\n    set_data_flag_and_return();\n    return;\n}",
            "called": [
                "FUN_0000258c",
                "FUN_00001c84",
                "FUN_00002396"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001274",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "initialize_and_process_data_00001274"
        },
        "FUN_00002e6c": {
            "renaming": {
                "FUN_00002e6c": "process_input_loop_and_parse_args_00002e6c",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "iVar1": "input_result",
                "process_data_and_wrap_00002e48": "process_data_and_wrap",
                "process_input_string_00002d94": "process_input_string",
                "parse_command_line_args_00002b10": "parse_command_line_args"
            },
            "code": "void process_input_loop_and_parse_args_00002e6c(int arg1, int arg2, int arg3)\n{\n  int input_result;\n  process_data_and_wrap();\n  do {\n    input_result = process_input_string(arg2, arg3);\n    if (input_result == 0) {\n      parse_command_line_args(arg1, arg2);\n    }\n    process_data_and_wrap();\n  } while( true );\n}",
            "called": [
                "FUN_00002d94",
                "FUN_00002b10",
                "FUN_00002e48"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e6c",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": false,
            "current_name": "process_input_loop_and_parse_args_00002e6c"
        },
        "FUN_00003444": {
            "renaming": {
                "FUN_00003444": "checkTimeValidityAndProcessData_00003444",
                "auStack_2c": "timeData",
                "iVar1": "dateAndDifference"
            },
            "code": "bool checkTimeValidityAndProcessData_00003444(void)\n{\n  int dateAndDifference;\n  undefined timeData[36];\n  \n  dateAndDifference = calculate_date_and_find_first_difference_00002624(timeData);\n  if (dateAndDifference != 0) {\n    process_input_00004db8(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    process_data_00003378(timeData);\n  }\n  return dateAndDifference != 0;\n}",
            "called": [
                "FUN_00003378",
                "FUN_00004db8",
                "FUN_00002624"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003444",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "checkTimeValidityAndProcessData_00003444",
            "code_backup": "\nbool FUN_00003444(void)\n\n{\n  int iVar1;\n  undefined auStack_2c [36];\n  \n  iVar1 = calculate_date_and_find_first_difference_00002624(auStack_2c);\n  if (iVar1 != 0) {\n    FUN_00004db8(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    process_data_00003378(auStack_2c);\n  }\n  return iVar1 != 0;\n}\n\n"
        },
        "FUN_00003688": {
            "renaming": {
                "FUN_00003688": "synchronize_data_00003688"
            },
            "code": "void synchronize_data_00003688() {\n  synchronize_data_00003688_00003658();\n  return;\n}",
            "called": [
                "FUN_00003658"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003688",
            "calling": [
                "FUN_00002e9c"
            ],
            "imported": false,
            "current_name": "synchronize_data_00003688"
        },
        "FUN_00001392": {
            "renaming": {
                "FUN_00001392": "set_value_at_calculated_address_00001392",
                "param_1": "address",
                "param_2": "value",
                "puVar1": "address_pointer",
                "*puVar1": "*address_pointer",
                "calculate_value_00001360": "calculate_address"
            },
            "code": "void set_value_at_calculated_address_00001392(int address, char value) {\n    int *address_pointer;\n    address_pointer = (int *)calculate_address(address, value);\n    *address_pointer = 1;\n    return;\n}",
            "called": [
                "FUN_00001360"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001392",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "set_value_at_calculated_address_00001392"
        },
        "FUN_00002910": {
            "renaming": {
                "FUN_00002910": "clear_flags_00002910",
                "DAT_00002944": "data_address",
                "PTR_DAT_00002948": "ptr_data_address"
            },
            "code": "void clear_flags_00002910(void)\n{\n  int DAT_00002944 = DAT_00002944;\n  *(uint *)(DAT_00002944 + 0x1c) &= 0xfffffffb;\n  *(undefined4 *)(DAT_00002944 + 8) = 0;\n  *(undefined4 *)PTR_DAT_00002948 = 0;\n  *(undefined4 *)(PTR_DAT_00002948 + 4) = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002910",
            "calling": [
                "FUN_000026c0"
            ],
            "imported": false,
            "current_name": "clear_flags_00002910"
        },
        "FUN_00004418": {
            "renaming": {
                "FUN_00004418": "read_byte_from_array_00004418",
                "uVar1": "byteValue",
                "ppbVar2": "arrayPointer",
                "pbVar3": "bytePointer",
                "iVar4": "arrayAddress",
                "initialize_array_000042a4": "initialize_array",
                "PTR_DAT_00005620": "arrayPointer1",
                "PTR_DAT_00005624": "arrayPointer2",
                "PTR_DAT_00005628": "arrayPointer3",
                "read_byte_from_array_00005e10": "read_byte_from_array_helper",
                "do_nothing_000045e8": "do_nothing",
                "do_nothing_000045ec": "do_nothing"
            },
            "code": "uint read_byte_from_array_00004418(void)\n{\n    uint byteValue;\n    byte **arrayPointer;\n    byte *bytePointer;\n    int arrayAddress = *arrayStartAddress;\n    if ((arrayAddress != 0) && (*(int *)(arrayAddress + 0x18) == 0)) {\n        initialize_array(arrayAddress);\n    }\n    arrayPointer = *(byte ***)(arrayAddress + 4);\n    if ((arrayAddress != 0) && (*(int *)(arrayAddress + 0x18) == 0)) {\n        initialize_array(arrayAddress);\n    }\n    if (arrayPointer == (byte **)PTR_DAT_00005620) {\n        arrayPointer = *(byte ***)(arrayAddress + 4);\n    }\n    else if (arrayPointer == (byte **)PTR_DAT_00005624) {\n        arrayPointer = *(byte ***)(arrayAddress + 8);\n    }\n    else if (arrayPointer == (byte **)PTR_DAT_00005628) {\n        arrayPointer = *(byte ***)(arrayAddress + 0xc);\n    }\n    if ((-1 < (int)arrayPointer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(arrayPointer + 3) << 0x16))) {\n        do_nothing(arrayPointer[0x16]);\n    }\n    bytePointer = arrayPointer[1];\n    arrayPointer[1] = bytePointer - 1;\n    if ((int)(bytePointer - 1) < 0) {\n        byteValue = read_byte_from_array_00004418_helper(arrayAddress, arrayPointer);\n    }\n    else {\n        bytePointer = *arrayPointer;\n        *arrayPointer = bytePointer + 1;\n        byteValue = (uint)*bytePointer;\n    }\n    if ((-1 < (int)arrayPointer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(arrayPointer + 3) << 0x16))) {\n        do_nothing(arrayPointer[0x16]);\n    }\n    return byteValue;\n}\n",
            "called": [
                "FUN_000045e8",
                "FUN_00005e10",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004418",
            "calling": [
                "FUN_00002d94"
            ],
            "imported": false,
            "current_name": "read_byte_from_array_00004418"
        },
        "FUN_0000258c": {
            "renaming": {
                "FUN_0000258c": "initialize_data_0000258c",
                "local_c": "counter",
                "set_data_00002538": "set_data",
                "uint": "uint32_t"
            },
            "code": "void initialize_data_0000258c(void)\n{\n  uint32_t counter;\n  *(uint32_t *)(DAT_000025ec + 8) = DAT_000025f0;\n  set_data(0xfffffffe, 1);\n  set_data(0xfffffffb, 1);\n  for (counter = 0; counter < 0x66; counter = counter + 1)\n  {\n    set_data((int)(char)counter, 1);\n  }\n  *(uint32_t *)(DAT_000025ec + 0x10) |= 0x10;\n  *(uint32_t *)(DAT_000025ec + 0x14) |= 0x200;\n  return;\n}",
            "called": [
                "FUN_00002538"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000258c",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "initialize_data_0000258c"
        },
        "FUN_00002a00": {
            "renaming": {
                "FUN_00002a00": "process_data_wrapper_00002a00",
                "param_1": "data"
            },
            "code": "void process_data_wrapper_00002a00(void* data){\n  process_data(data);\n  return;\n}",
            "called": [
                "FUN_00004cb4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a00",
            "calling": [
                "FUN_00002d94",
                "FUN_00002e48"
            ],
            "imported": false,
            "current_name": "process_data_wrapper_00002a00"
        },
        "FUN_000043a0": {
            "renaming": {
                "FUN_000043a0": "calculateFlaggedItems_000043a0",
                "param_1": "itemArray",
                "param_2": "callbackFunction",
                "piVar2": "itemPointer",
                "uVar4": "flag",
                "iVar5": "currentItem",
                "iVar3": "itemDataPointer",
                "uVar1": "result"
            },
            "code": "uint calculateFlaggedItems_000043a0(int itemArray, code *callbackFunction)\n{\n  uint flag = 0;\n  int *itemPointer;\n  int currentItem, itemDataPointer;\n  itemPointer = (int *)(itemArray + 0x48);\n  do {\n    currentItem = itemPointer[1];\n    itemDataPointer = itemPointer[2];\n    while (currentItem = currentItem + -1, -1 < currentItem) {\n      if ((1 < *(ushort *)(itemDataPointer + 0xc)) && (*(short *)(itemDataPointer + 0xe) != -1)) {\n        uint result = (*callbackFunction)(itemDataPointer);\n        flag = flag | result;\n      }\n      itemDataPointer = itemDataPointer + 0x68;\n    }\n    itemPointer = (int *)*itemPointer;\n  } while (itemPointer != (int *)0x0);\n  return flag;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043a0",
            "calling": [
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "calculateFlaggedItems_000043a0"
        },
        "FUN_0000211c": {
            "renaming": {
                "FUN_0000211c": "process_data_0000211c",
                "local_40": "section_name",
                "local_3c": "relocation_offset",
                "local_38": "stack_offset",
                "local_34": "relocation_val",
                "local_30": "relocation_type",
                "local_2c": "relocation_ptr",
                "local_28": "main_stack_pointer",
                "local_24": "data_pointer",
                "local_20": "section_offset",
                "local_1a": "section_index",
                "local_18": "total_relocation_count",
                "local_14": "total_stack_size",
                "PTR_s__pid_____21s____9sQ___pri___stac_00002250": "pid_state_pri_stack_string",
                "PTR_DAT_0000224c": "pid_data",
                "PTR_s_state_00002248": "state_string",
                "PTR_s______isr_stack______________6i___00002254": "isr_stack_string",
                "DAT_0000225c": "relocation_table",
                "PTR_s___3hi_____20s_____8s___1s____3i___00002260": "relocation_format_string",
                "calculate_offset_000010a0": "calculate_offset",
                "PTR_s___5s___21s__13s_6s__6i___5i__0000226c": "data_format_string",
                "PTR_DAT_00002264": "data_pid",
                "PTR_DAT_00002268": "data_state"
            },
            "code": "void process_data_0000211c() {\n    int relocation_count = 0;\n    int total_relocation_offset = 0;\n    int total_stack_size = 0;\n    uint32_t relocation_index;\n    uint32_t *relocation_ptr;\n    uint32_t relocation_val;\n    int relocation_offset;\n    int stack_size;\n    int stack_offset;\n    int offset;\n    uint16_t section_index;\n    uint32_t section_offset;\n    uint32_t section_size;\n    uint32_t section_relocation_count;\n    uint32_t section_relocation_offset;\n    uint32_t section_relocation_index;\n    uint32_t section_relocation_val;\n    uint8_t section_relocation_type;\n    uint32_t section_data_offset;\n    uint32_t section_data_size;\n    int i;\n\n    section_index = 1;\n    while (section_index < 0x21) {\n        section_offset = *(uint32_t *)(section_index * 4 + 0x2258);\n        if (section_offset != 0) {\n            section_size = *(uint32_t *)(section_index * 4 + 0x225c);\n            section_relocation_count = *(uint32_t *)(section_index * 4 + 0x2260);\n            section_relocation_offset = *(uint32_t *)(section_index * 4 + 0x2264);\n            section_data_offset = section_offset + section_relocation_count * 8 + 0x20;\n            section_data_size = section_size - section_relocation_count * 8 - 0x20;\n            for (section_relocation_index = 0; section_relocation_index < section_relocation_count; section_relocation_index++) {\n                relocation_ptr = (uint32_t *)(section_relocation_offset + section_relocation_index * 8);\n                relocation_type = (uint8_t)(*relocation_ptr >> 24);\n                if (relocation_type == 1) {\n                    relocation_val = *relocation_ptr & 0xFFFFFF;\n                    relocation_offset = *(uint32_t *)(section_offset + section_relocation_index * 8 + 0x20);\n                    total_relocation_offset += relocation_offset;\n                    total_stack_size += relocation_val;\n                    offset = relocation_offset - total_relocation_offset;\n                    process_data_00004c84(\"%3hi %20s %8s %1s %3i\", section_index, relocation_offset, relocation_val, relocation_type, offset);\n                }\n            }\n        }\n        section_index++;\n    }\n    process_data_00004c84(\"%5s %21s %13s %6s %6i %5i\", \"data\", \"pid\", \"state\", \"pri\", total_stack_size, total_relocation_offset);\n}\n",
            "called": [
                "FUN_00004c84",
                "FUN_000008b8",
                "FUN_00000900",
                "FUN_000010a0",
                "FUN_0000091c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000211c",
            "calling": [
                "FUN_00000f04",
                "FUN_00002eb4"
            ],
            "imported": false,
            "current_name": "process_data_0000211c",
            "code_backup": "\nvoid FUN_0000211c(void)\n\n{\n  int iVar1;\n  undefined2 local_40;\n  int local_3c;\n  int local_38;\n  undefined4 local_34;\n  uint local_30;\n  undefined4 *local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  int local_20;\n  short local_1a;\n  int local_18;\n  int local_14;\n  \n  local_40 = 0x515f;\n  local_14 = 0;\n  local_18 = 0;\n  FUN_00004c84(PTR_s__pid_____21s____9sQ___pri___stac_00002250,PTR_DAT_0000224c,PTR_s_state_00002248\n              );\n  local_20 = count_relocations_in_section_000008b8();\n  local_24 = get_pointer_to_data_0000091c();\n  local_28 = get_main_stack_pointer_00000900();\n  FUN_00004c84(PTR_s______isr_stack______________6i___00002254,0x200,local_20,local_24,local_28);\n  local_14 = local_14 + 0x200;\n  if (0 < local_20) {\n    local_18 = local_20 + local_18;\n  }\n  for (local_1a = 1; local_1a < 0x21; local_1a = local_1a + 1) {\n    local_2c = *(undefined4 **)(PTR_DAT_00002258 + local_1a * 4);\n    if (local_2c != (undefined4 *)0x0) {\n      local_30 = (uint)*(byte *)(local_2c + 1);\n      local_34 = *(undefined4 *)(DAT_0000225c + local_30 * 4);\n      local_38 = (int)&local_40 + (uint)(8 < local_30);\n      local_3c = local_2c[0xb];\n      local_14 = local_3c + local_14;\n      iVar1 = calculate_offset_000010a0(local_2c[9]);\n      local_3c = local_3c - iVar1;\n      local_18 = local_3c + local_18;\n      FUN_00004c84(PTR_s___3hi_____20s_____8s___1s____3i___00002260,\n                   (int)*(short *)((int)local_2c + 6),local_2c[10],local_34,local_38,\n                   *(undefined *)((int)local_2c + 5),local_2c[0xb],local_3c,local_2c[9],*local_2c);\n    }\n  }\n  FUN_00004c84(PTR_s___5s___21s__13s_6s__6i___5i__0000226c,PTR_DAT_00002264,PTR_DAT_00002268,\n               PTR_DAT_00002264,PTR_DAT_00002264,local_14,local_18);\n  return;\n}\n\n"
        },
        "FUN_0000562c": {
            "renaming": {
                "FUN_0000562c": "find_parameter_value_0000562c",
                "param_1": "param_index",
                "param_2": "query_string",
                "param_3": "result_index",
                "cVar1": "current_char",
                "ppiVar2": "param_list",
                "piVar3": "current_param",
                "iVar4": "comparison_result",
                "pcVar5": "query_string",
                "piVar6": "param_ptr",
                "iVar7": "query_length"
            },
            "code": "int find_parameter_value_0000562c(int param_index, char *query_string, int *result_index) {\n  char current_char;\n  int **param_list = DAT_0000569c;\n  if (*DAT_0000569c != (int *)0x0) {\n    do {\n      current_char = *query_string;\n      if (current_char == '\\0') {\n        int query_length = (int)query_string - (int)query_string;\n        int *current_param = *param_list;\n        while( true ) {\n          int *param_ptr = current_param;\n          if (*param_ptr == 0) break;\n          int comparison_result = compare_strings_00004e66(*param_ptr,query_string,query_length);\n          current_param = param_ptr + 1;\n          if ((comparison_result == 0) && (comparison_result = *param_ptr, *(char *)(comparison_result + query_length) == '=')) {\n            *result_index = (int)param_ptr - (int)*param_list >> 2;\n            do_nothing_with_data_00005ff8(param_index);\n            return comparison_result + query_length + 1;\n          }\n        }\n        break;\n      }\n      query_string = query_string + 1;\n    } while (current_char != '=');\n  }\n  do_nothing_with_data_00005ff8(param_index);\n  return 0;\n}",
            "called": [
                "FUN_00005fec",
                "FUN_00005ff8",
                "FUN_00004e66"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000562c",
            "calling": [
                "FUN_000056a0"
            ],
            "imported": false,
            "current_name": "find_parameter_value_0000562c"
        },
        "FUN_000020b8": {
            "renaming": {
                "FUN_000020b8": "extract_bits_and_call_functions_000020b8",
                "DAT_000020c8": "data",
                "PTR_": "start_bit"
            },
            "code": "void extract_bits_and_call_functions_000020b8(uint8_t *DAT_000020c8, int PTR_) {\n  extract_bits_and_call_functions_000020b8(DAT_000020c8, PTR_);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020b8",
            "calling": [],
            "imported": false,
            "current_name": "extract_bits_and_call_functions_000020b8"
        },
        "FUN_00002a18": {
            "renaming": {
                "FUN_00002a18": "find_matching_value_00002a18",
                "param_1": "search_list",
                "param_2": "search_value",
                "iVar1": "compare_result",
                "local_18": "current_list",
                "local_10": "current_index",
                "local_c": "current_item"
            },
            "code": "int find_matching_value_00002a18(int *search_list, uint32_t search_value)\n{\n  int compare_result;\n  int *current_list [2];\n  uint32_t current_index;\n  int *current_item;\n  current_list[0] = search_list;\n  current_list[1] = (int *)PTR_PTR_s_reboot_00002a84;\n  current_index = 0;\n  do {\n    if (current_index > 1) {\n      return 0;\n    }\n    current_item = current_list[current_index];\n    if (current_item != (int *)0x0) {\n      for (; *current_item != 0; current_item = current_item + 3) {\n        compare_result = compare_bytes_00004e52(*current_item,search_value);\n        if (compare_result == 0) {\n          return current_item[2];\n        }\n      }\n    }\n    current_index++;\n  } while( true );\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a18",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "find_matching_value_00002a18"
        },
        "FUN_000054a8": {
            "renaming": {
                "FUN_000054a8": "process_object_000054a8",
                "param_1": "output",
                "param_2": "input",
                "uVar1": "flags1",
                "uVar2": "flags2",
                "uVar3": "flags3",
                "uVar4": "flags4",
                "iVar5": "some_var",
                "DAT_00005574": "global_var1",
                "PTR_DAT_00005578": "global_var2",
                "PTR_DAT_0000557c": "global_var3",
                "PTR_DAT_00005580": "global_var4"
            },
            "code": "uint process_object_000054a8(undefined4 *output, undefined4 *input)\n{\n  ushort flags1;\n  ushort flags2;\n  uint flags3;\n  uint flags4;\n  int some_var;\n  some_var = *DAT_00005574;\n  if ((some_var != 0) && (*(int *)(some_var + 0x18) == 0)) {\n    cleanup(some_var);\n  }\n  if (input == (undefined4 *)PTR_DAT_00005578) {\n    input = *(undefined4 **)(some_var + 4);\n  }\n  else if (input == (undefined4 *)PTR_DAT_0000557c) {\n    input = *(undefined4 **)(some_var + 8);\n  }\n  else if (input == (undefined4 *)PTR_DAT_00005580) {\n    input = *(undefined4 **)(some_var + 0xc);\n  }\n  flags3 = (uint)*(ushort *)(input + 3);\n  flags2 = *(ushort *)(input + 3);\n  if (-1 < (int)(flags3 << 0x1c)) {\n    if (-1 < (int)(flags3 << 0x1b)) {\n      *output = 9;\n      goto LAB_000054d8;\n    }\n    if ((undefined4 *)input[0xd] != (undefined4 *)0x0) {\n      if ((undefined4 *)input[0xd] != input + 0x11) {\n        add_pointer_to_list(output);\n      }\n      input[0xd] = 0;\n    }\n    *(ushort *)(input + 3) = *(ushort *)(input + 3) & 0xffdb;\n    input[1] = 0;\n    *input = input[4];\n  }\n  *(ushort *)(input + 3) = *(ushort *)(input + 3) | 8;\n  if ((input[4] == 0) && ((*(ushort *)(input + 3) & 0x280) != 0x200)) {\n    allocate_and_initialize_object(output, input);\n  }\n  flags1 = *(ushort *)(input + 3);\n  flags3 = (uint)flags1;\n  flags2 = *(ushort *)(input + 3);\n  flags4 = flags3 & 1;\n  if ((flags1 & 1) == 0) {\n    if (-1 < (int)(flags3 << 0x1e)) {\n      flags4 = input[5];\n    }\n    input[2] = flags4;\n  }\n  else {\n    input[2] = 0;\n    input[6] = -input[5];\n  }\n  if (input[4] != 0) {\n    return 0;\n  }\n  if ((flags1 & 0x80) == 0) {\n    return flags3 & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(input + 3) = flags2 | 0x40;\n  return 0xffffffff;\n}\n",
            "called": [
                "FUN_00005700",
                "FUN_00004b34",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000054a8",
            "calling": [
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_00005404"
            ],
            "imported": false,
            "current_name": "process_object_000054a8",
            "code_backup": "\nuint FUN_000054a8(undefined4 *param_1,undefined4 *param_2)\n\n{\n  ushort uVar1;\n  ushort uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  \n  iVar5 = *DAT_00005574;\n  if ((iVar5 != 0) && (*(int *)(iVar5 + 0x18) == 0)) {\n    FUN_000042a4(iVar5);\n  }\n  if (param_2 == (undefined4 *)PTR_DAT_00005578) {\n    param_2 = *(undefined4 **)(iVar5 + 4);\n  }\n  else if (param_2 == (undefined4 *)PTR_DAT_0000557c) {\n    param_2 = *(undefined4 **)(iVar5 + 8);\n  }\n  else if (param_2 == (undefined4 *)PTR_DAT_00005580) {\n    param_2 = *(undefined4 **)(iVar5 + 0xc);\n  }\n  uVar3 = (uint)*(ushort *)(param_2 + 3);\n  uVar2 = *(ushort *)(param_2 + 3);\n  if (-1 < (int)(uVar3 << 0x1c)) {\n    if (-1 < (int)(uVar3 << 0x1b)) {\n      *param_1 = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(uVar3 << 0x1d) < 0) {\n      if ((undefined4 *)param_2[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] != param_2 + 0x11) {\n          add_pointer_to_list_00004b34(param_1);\n        }\n        param_2[0xd] = 0;\n      }\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xffdb;\n      param_2[1] = 0;\n      *param_2 = param_2[4];\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] == 0) && ((*(ushort *)(param_2 + 3) & 0x280) != 0x200)) {\n    allocate_and_initialize_object_00005700(param_1,param_2);\n  }\n  uVar1 = *(ushort *)(param_2 + 3);\n  uVar3 = (uint)uVar1;\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar4 = uVar3 & 1;\n  if ((uVar1 & 1) == 0) {\n    if (-1 < (int)(uVar3 << 0x1e)) {\n      uVar4 = param_2[5];\n    }\n    param_2[2] = uVar4;\n  }\n  else {\n    param_2[2] = 0;\n    param_2[6] = -param_2[5];\n  }\n  if (param_2[4] != 0) {\n    return 0;\n  }\n  if ((uVar1 & 0x80) == 0) {\n    return uVar3 & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(param_2 + 3) = uVar2 | 0x40;\n  return 0xffffffff;\n}\n\n"
        },
        "FUN_000007dc": {
            "renaming": {
                "FUN_000007dc": "initialize_array_000007dc",
                "param_1": "val",
                "param_2": "size",
                "param_3": "alignment",
                "param_4": "offset",
                "local_14": "i",
                "local_10": "j",
                "local_c": "array"
            },
            "code": "int* initialize_array_000007dc(int val, int size, int param_3, int param_4)\n{\n    uint aligned_size = (param_4 + param_3) & 0xfffffffc;\n    int* array = (int*)(aligned_size - sizeof(int));\n    *array = 0x77777777;\n    if(((uint)array & 7) != 0)\n    {\n        array = (int*)(aligned_size - 2 * sizeof(int));\n        *array = 0x88888888;\n    }\n    array[-1] = 0x1000000;\n    array[-2] = val;\n    array[-3] = DAT_000008b4;\n    array = array - 4;\n    *array = 0;\n    for(int i = 3; i > 0; i--)\n    {\n        array--;\n        *array = i;\n    }\n    array--;\n    *array = size;\n    for(int i = 0xb; i > 3; i--)\n    {\n        array--;\n        *array = i;\n    }\n    array[-1] = -3;\n    return (array - 1);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000007dc",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "initialize_array_000007dc"
        },
        "FUN_00001710": {
            "renaming": {
                "FUN_00001710": "clear_memory_at_offset_00001710",
                "param_1": "base_address",
                "param_2": "offset",
                "puVar1": "memory_address"
            },
            "code": "void clear_memory_at_offset_00001710(void* base_address, int offset) {\n  undefined *memory_address = (undefined *)calculate_offset(base_address, offset);\n  *memory_address = 0;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001710",
            "calling": [
                "FUN_000019c0",
                "FUN_00001bb8",
                "FUN_00001960",
                "FUN_00001778",
                "FUN_00001734",
                "FUN_0000182c",
                "FUN_000018bc",
                "FUN_00001a60"
            ],
            "imported": false,
            "current_name": "clear_memory_at_offset_00001710"
        },
        "FUN_000045ec": {
            "renaming": {
                "FUN_000045ec": "do_nothing_000045ec"
            },
            "code": "\nvoid do_nothing_000045ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ec",
            "calling": [
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_0000579c",
                "FUN_00004158",
                "FUN_00004280",
                "FUN_00005ff8",
                "FUN_00004418",
                "FUN_00004cb4",
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ec"
        },
        "FUN_00001034": {
            "renaming": {
                "FUN_00001034": "findAndInsert_00001034",
                "param_1": "list",
                "param_2": "index",
                "local_1c": "currentNode"
            },
            "code": "void findAndInsert_00001034(int **list, int index) {\n  int **currentNode;\n  int maxIndex = *(byte *)(index + 4);\n  if (maxIndex > 8) {\n    handle_interrupt_and_parse_input_loop_00000f04(3, PTR_s_FAILED_ASSERTION__0000109c);\n  }\n  for (currentNode = list; (*currentNode != (int *)0x0 && (*(byte *)((int)*currentNode + -3) <= *(byte *)(index + 5))); currentNode = (int **)*currentNode) {\n  }\n  *(int **)(index + 8) = *currentNode;\n  *currentNode = (int *)(int **)(index + 8);\n  return;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001034",
            "calling": [
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "findAndInsert_00001034"
        },
        "FUN_00006964": {
            "renaming": {
                "FUN_00006964": "calculate_new_value_00006964",
                "param_1": "starting_value",
                "param_2": "ptr_offset",
                "iVar1": "new_value"
            },
            "code": "int calculate_new_value_00006964(int starting_value, int* ptr_offset) {\n  int new_value = *(ptr_offset - 1) - 4;\n  if (*(ptr_offset - 1) < 0) {\n    new_value += *(ptr_offset + new_value / sizeof(int));\n  }\n  return new_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006964",
            "calling": [
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "calculate_new_value_00006964"
        },
        "FUN_0000182c": {
            "renaming": {
                "FUN_0000182c": "clear_memory_and_set_offset_0000182c",
                "set_offset_to_one_000016ec": "set_offset_to_one",
                "clear_memory_at_offset_00001710": "clear_memory_at_offset",
                "DAT_000018b4": "memory_address",
                "DAT_000018b8": "offset_address",
                "PTR_00001720": "offset",
                "PTR_00001724": "memory_size"
            },
            "code": "void clear_memory_and_set_offset_0000182c(void)\n{\n    byte* DAT_000018b4 = (byte*)(DAT_000018b4 + 8);\n    byte original_value = *DAT_000018b4;\n    byte new_value = original_value & 0xd0;\n    *DAT_000018b4 = new_value;\n    set_PTR_00001720_to_one(DAT_000018b8);\n    clear_memory_at_PTR_00001720(DAT_000018b4, 1);\n    clear_memory_at_PTR_00001720(DAT_000018b4, 0);\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000182c",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "clear_memory_and_set_offset_0000182c"
        },
        "FUN_00004db8": {
            "renaming": {
                "FUN_00004db8": "process_input_00004db8",
                "param_1": "input_length",
                "cVar1": "current_char",
                "iVar2": "process_object_result",
                "iVar3": "data_structure",
                "pcVar4": "current_buffer_char",
                "pcVar7": "current_input_char",
                "ppcVar5": "buffer_pointers",
                "uVar6": "return_value"
            },
            "code": "\nundefined4 process_input_00004db8(int input_length)\n\n{\n  char current_char;\n  int process_object_result;\n  int data_structure;\n  char *current_buffer_char;\n  char **buffer_pointers;\n  undefined4 return_value;\n  char *current_input_char;\n  \n  data_structure = *DAT_00004dc4;\n  if ((data_structure != 0) && (*(int *)(data_structure + 0x18) == 0)) {\n    initialize_array_000042a4();\n  }\n  buffer_pointers = *(char ***)(data_structure + 8);\n  if (*(int *)(data_structure + 0x18) == 0) {\n    initialize_array_000042a4(data_structure);\n  }\n  if (buffer_pointers == (char **)PTR_DAT_00004dac) {\n    buffer_pointers = *(char ***)(data_structure + 4);\n  }\n  else if (buffer_pointers == (char **)PTR_DAT_00004db0) {\n    buffer_pointers = *(char ***)(data_structure + 8);\n  }\n  else if (buffer_pointers == (char **)PTR_DAT_00004db4) {\n    buffer_pointers = *(char ***)(data_structure + 0xc);\n  }\n  if ((-1 < (int)buffer_pointers[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(buffer_pointers + 3) << 0x16))) {\n    do_nothing_000045e8(buffer_pointers[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(buffer_pointers + 3) << 0x1c) < 0) && (buffer_pointers[4] != (char *)0x0)) ||\n     (process_object_result = process_object_000054a8(data_structure,buffer_pointers), process_object_result == 0)) {\n    current_input_char = (char *)(input_length + -1);\n    do {\n      while( true ) {\n        current_input_char = current_input_char + 1;\n        current_char = *current_input_char;\n        current_buffer_char = buffer_pointers[2] + -1;\n        buffer_pointers[2] = current_buffer_char;\n        if (current_char == '\\0') {\n          if (-1 < (int)current_buffer_char) {\n            current_input_char = *buffer_pointers;\n            return_value = 10;\n            *buffer_pointers = current_input_char + 1;\n            *current_input_char = '\\n';\n            goto LAB_00004d64;\n          }\n          data_structure = process_data_00005404(data_structure,10,buffer_pointers);\n          if (data_structure != -1) {\n            return_value = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)current_buffer_char < 0) && (((int)current_buffer_char < (int)buffer_pointers[6] || (current_char == '\\n')))) break;\n        current_buffer_char = *buffer_pointers;\n        *buffer_pointers = current_buffer_char + 1;\n        *current_buffer_char = current_char;\n      }\n      process_object_result = process_data_00005404(data_structure,current_char,buffer_pointers);\n    } while (process_object_result != -1);\n  }\nLAB_00004d60:\n  return_value = 0xffffffff;\nLAB_00004d64:\n  if ((-1 < (int)buffer_pointers[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(buffer_pointers + 3) << 0x16))) {\n    do_nothing_000045ec(buffer_pointers[0x16]);\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_00005404",
                "FUN_000045e8",
                "FUN_000054a8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004db8",
            "calling": [
                "FUN_00002b10",
                "FUN_00002a88",
                "FUN_000031e0",
                "FUN_000033f4",
                "FUN_00002fe0",
                "FUN_00002f30",
                "FUN_00003444",
                "FUN_00003694",
                "FUN_000033c0",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00003478",
                "FUN_000023a4",
                "FUN_000034c0"
            ],
            "imported": false,
            "current_name": "process_input_00004db8"
        },
        "FUN_000022f0": {
            "renaming": {
                "FUN_000022f0": "increment_value_000022f0",
                "param_1": "arr",
                "uVar1": "index",
                "PTR_": "arr[",
                "DAT_": ""
            },
            "code": "undefined increment_value_000022f0(int *arr) {\n  uint index = PTR_2];\n  PTR_2] = index + 1;\n  uint offset = index & (PTR_1] - 1U);\n  return *(undefined *)((offset) + *(arr));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022f0",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": false,
            "current_name": "increment_value_000022f0"
        },
        "FUN_00001c84": {
            "renaming": {
                "FUN_00001c84": "initialize_data_and_process_00001c84",
                "uVar1": "interrupt_enabled",
                "check_interrupt_enabled_00000cd0": "check_interrupt_enabled",
                "clear_and_update_data_00001bb8": "clear_and_update_data",
                "DAT_00001ce8": "data_buffer",
                "DAT_00001cec": "data_buffer",
                "clear_memory_and_set_offset_0000182c": "clear_memory_and_set_offset",
                "set_offset_to_one_and_enable_flag_000017dc": "set_offset_to_one_and_enable_flag",
                "process_data_00001b10": "process_data",
                "enableIRQinterrupts_if_privileged_00000d0c": "enable_IRQ_interrupts_if_privileged"
            },
            "code": "void initialize_data_and_process_00001c84(void)\n{\n    bool interrupt_enabled = check_interrupt_enabled();\n    clear_and_update_data();\n    *(unsigned int *)(DAT_00001ce8 + 0x1044) = 0x220000;\n    DAT_00001ce8[0xc] = 0;\n    *DAT_00001ce8 = *DAT_00001ce8 & 199 | 0x38;\n    DAT_00001ce8[4] = 0x13;\n    DAT_00001ce8[5] = 0;\n    clear_memory_and_set_offset();\n    set_offset_to_one_and_enable_flag();\n    process_data(7);\n    enable_IRQ_interrupts_if_privileged(interrupt_enabled);\n}",
            "called": [
                "FUN_00001bb8",
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_000017dc",
                "FUN_0000182c",
                "FUN_00001b10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001c84",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "initialize_data_and_process_00001c84"
        },
        "FUN_000068f0": {
            "renaming": {
                "FUN_000068f0": "allocate_or_copy_memory_000068f0",
                "param_1": "size",
                "param_2": "memory",
                "iVar1": "allocated_memory",
                "iVar2": "current_size"
            },
            "code": "int allocate_or_copy_memory_000068f0(int param_1, int *memory) {\n  int allocated_memory;\n  int current_size;\n  \n  if ((int *)memory[13] == memory + 17) {\n    allocated_memory = allocate_memory(param_1, 0x400);\n    if (allocated_memory != 0) {\n      memory[14] = 0x400;\n      memory[13] = allocated_memory;\n      *(undefined *)(allocated_memory + 0x3ff) = *(undefined *)((int)memory + 0x46);\n      *(undefined *)(allocated_memory + 0x3fe) = *(undefined *)((int)memory + 0x45);\n      *(undefined *)(allocated_memory + 0x3fd) = *(undefined *)(memory + 17);\n      *memory = allocated_memory + 0x3fd;\n      return 0;\n    }\n  }\n  else {\n    current_size = memory[14];\n    allocated_memory = allocate_and_copy_data(param_1, (int *)memory[13], current_size << 1);\n    if (allocated_memory != 0) {\n      copy_data(allocated_memory + current_size, allocated_memory, current_size);\n      memory[13] = allocated_memory;\n      memory[14] = current_size << 1;\n      *memory = allocated_memory + current_size;\n      return 0;\n    }\n  }\n  return -1;\n}",
            "called": [
                "FUN_000060b0",
                "FUN_000060cc",
                "FUN_00004bd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000068f0",
            "calling": [],
            "imported": false,
            "current_name": "allocate_or_copy_memory_000068f0"
        }
    },
    "used_tokens": 205668,
    "layers": [
        [
            "FUN_000064bc",
            "FUN_00002970",
            "FUN_00000d0c",
            "FUN_00003d94",
            "FUN_0000579c",
            "FUN_000015d0",
            "FUN_00000dcc",
            "FUN_0000285c",
            "FUN_00000566",
            "FUN_00001d08",
            "FUN_000031fc",
            "FUN_00005584",
            "FUN_00001da2",
            "FUN_00002744",
            "FUN_00001e0c",
            "FUN_000004f2",
            "FUN_00004e66",
            "FUN_00005ecc",
            "FUN_00001748",
            "FUN_0000294c",
            "FUN_00005790",
            "FUN_00000534",
            "FUN_000005ca",
            "FUN_00005ff8",
            "FUN_00002714",
            "FUN_00005fec",
            "FUN_00004f84",
            "FUN_000028f0",
            "FUN_000039e8",
            "FUN_00002294",
            "FUN_00003810",
            "FUN_0000687c",
            "FUN_00005edc",
            "FUN_0000240c",
            "FUN_00004280",
            "FUN_00000cf0",
            "FUN_00002538",
            "FUN_0000058e",
            "FUN_00001696",
            "FUN_000008b8",
            "FUN_0000091c",
            "FUN_00000d44",
            "FUN_00000cd0",
            "FUN_00000d2a",
            "FUN_00001e44",
            "FUN_00001318",
            "FUN_00000900",
            "FUN_00004274",
            "FUN_00001dc0",
            "FUN_000026f0",
            "FUN_00001d5e",
            "FUN_000050f4",
            "FUN_00005a58",
            "FUN_000056b0",
            "FUN_00003d24",
            "FUN_00003dc4",
            "FUN_000022be",
            "FUN_00001d80",
            "FUN_000023c8",
            "FUN_0000428c",
            "FUN_000010a0",
            "FUN_00006010",
            "FUN_00001360",
            "FUN_00004622",
            "FUN_0000093c",
            "FUN_00003658",
            "FUN_000060b0",
            "FUN_000050e8",
            "FUN_00000514",
            "FUN_000045ee",
            "FUN_00006974",
            "FUN_00005ebc",
            "FUN_0000281c",
            "FUN_00002270",
            "FUN_00003918",
            "FUN_00003d64",
            "FUN_00004e52",
            "FUN_00001ad4",
            "FUN_00002910",
            "FUN_000043a0",
            "FUN_000007dc",
            "FUN_00006964",
            "FUN_000022f0"
        ],
        [
            "FUN_000026c0",
            "FUN_00005e68",
            "FUN_00000e58",
            "FUN_000026d8",
            "FUN_000016ec",
            "FUN_00001ec4",
            "FUN_000014c4",
            "FUN_00004b34",
            "FUN_00004f98",
            "FUN_00000428",
            "FUN_00000e38",
            "FUN_00002600",
            "FUN_00004042",
            "FUN_00002894",
            "FUN_00000d76",
            "FUN_000026e4",
            "FUN_00000698",
            "FUN_00001ff6",
            "FUN_0000328c",
            "FUN_000041f4",
            "FUN_000056b8",
            "FUN_00003ff4",
            "FUN_00000930",
            "FUN_00001348",
            "FUN_00001d3a",
            "FUN_00002798",
            "FUN_0000231c",
            "FUN_00001cf0",
            "FUN_000023d0",
            "FUN_00005fd8",
            "FUN_0000443c",
            "FUN_000027b0",
            "FUN_000016c8",
            "FUN_00000738",
            "FUN_00003e58",
            "FUN_00004e26",
            "FUN_00000610",
            "FUN_00002364",
            "FUN_00003688",
            "FUN_00001392",
            "FUN_0000258c",
            "FUN_0000562c",
            "FUN_00002a18",
            "FUN_00001710"
        ],
        [
            "FUN_00004bd0",
            "FUN_00000794",
            "FUN_00001778",
            "FUN_00002624",
            "FUN_00001628",
            "FUN_000017dc",
            "FUN_00004dee",
            "FUN_00002654",
            "FUN_000025f4",
            "FUN_00001ddc",
            "FUN_000024bc",
            "FUN_00002994",
            "FUN_00000d9c",
            "FUN_00001bb8",
            "FUN_0000404c",
            "FUN_000056a0",
            "FUN_00002690",
            "FUN_00002e9c",
            "FUN_00001960",
            "FUN_00006192",
            "FUN_00001734",
            "FUN_00005780",
            "FUN_00002028",
            "FUN_00001a60",
            "FUN_000018bc",
            "FUN_0000182c"
        ],
        [
            "FUN_00004248",
            "FUN_000020e0",
            "FUN_00000db0",
            "FUN_000020f4",
            "FUN_00001688",
            "FUN_000012b4",
            "FUN_00001f80",
            "FUN_00001a18",
            "FUN_0000191c",
            "FUN_000060cc",
            "FUN_00002108",
            "FUN_00005700",
            "FUN_000019c0",
            "FUN_00001a3c",
            "FUN_000020cc",
            "FUN_00002396",
            "FUN_000020b8"
        ],
        [
            "FUN_00001eea",
            "FUN_00001448",
            "FUN_00001b10",
            "FUN_000068f0"
        ],
        [
            "FUN_00001c84"
        ],
        [
            "FUN_00001274"
        ],
        [
            "FUN_000031e0",
            "FUN_000034c0",
            "FUN_000033f4",
            "FUN_00003478"
        ],
        [
            "FUN_00003378",
            "FUN_00000ed8",
            "FUN_0000211c"
        ],
        [
            "FUN_00002eb4"
        ],
        [
            "FUN_00002a88",
            "FUN_000033c0",
            "FUN_00002f74",
            "FUN_00003444"
        ],
        [
            "FUN_00004158",
            "FUN_00004c84",
            "FUN_00004314",
            "FUN_000054a8"
        ],
        [
            "FUN_000041d0",
            "FUN_00002b10",
            "FUN_00003524",
            "FUN_000042a4"
        ],
        [
            "FUN_00006768",
            "FUN_00005404"
        ],
        [
            "FUN_000057a8",
            "FUN_00005e10",
            "FUN_00004cb4"
        ],
        [
            "FUN_000057d2",
            "FUN_00004418",
            "FUN_00002a00"
        ],
        [
            "FUN_00002e48",
            "FUN_00002d94"
        ],
        [
            "FUN_00002e6c"
        ],
        [
            "FUN_000023a4"
        ],
        [
            "FUN_00000f04"
        ],
        [
            "FUN_00000fec",
            "FUN_00000cc0",
            "FUN_000013b8",
            "FUN_00003ec4",
            "FUN_00000a30",
            "FUN_00001034"
        ],
        [
            "FUN_00000dc0",
            "FUN_00003e9e",
            "FUN_00000e64",
            "FUN_00000df4",
            "FUN_00002434",
            "FUN_000010d4"
        ],
        [
            "FUN_0000129c",
            "FUN_00000410",
            "FUN_00000f8c",
            "FUN_00003694"
        ],
        [
            "FUN_0000459c",
            "FUN_0000305c",
            "FUN_00002ecc",
            "FUN_000012e2"
        ],
        [
            "FUN_00002f30",
            "FUN_00000e14",
            "FUN_0000099c"
        ],
        [
            "FUN_00000490",
            "FUN_00002fe0"
        ],
        [
            "FUN_0000316c",
            "FUN_00004dc8"
        ],
        [
            "FUN_00005100",
            "FUN_00005b34",
            "FUN_0000656c",
            "FUN_00004634",
            "FUN_00006a14",
            "FUN_00004db8"
        ],
        [
            "FUN_000047e4",
            "FUN_000061cc",
            "FUN_000057f8"
        ]
    ],
    "locked_functions": []
}