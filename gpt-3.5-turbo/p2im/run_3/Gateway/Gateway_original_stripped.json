{
    "functions": {
        "FUN_0800010c": {
            "entrypoint": "0x0800010c",
            "current_name": "update_completion_status_0800010c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000118) */\n\nundefined4 update_completion_status_0800010c(undefined4 status)\n\n{\n  if ((char)completion_flag == '\\0') {\n    completion_flag._0_1_ = '\\x01';\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800010c": "update_completion_status_0800010c",
                "param_1": "status",
                "completed_8667": "completion_flag"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000130": {
            "entrypoint": "0x08000130",
            "current_name": "FUNC_08000130",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000134) */\n/* WARNING: Removing unreachable block (ram,0x0800014e) */\n/* WARNING: Removing unreachable block (ram,0x08000144) */\n/* WARNING: Removing unreachable block (ram,0x08000160) */\n/* WARNING: Removing unreachable block (ram,0x08000154) */\n\nvoid FUNC_08000130(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000130": "FUNC_08000130"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000178": {
            "entrypoint": "0x08000178",
            "current_name": "calculate_string_length_08000178",
            "code": "\nsize_t calculate_string_length_08000178(char *input_string)\n\n{\n  char current_char;\n  char *next_char_pointer;\n  char *current_char_pointer;\n  \n  current_char_pointer = input_string;\n  do {\n    next_char_pointer = current_char_pointer + 1;\n    current_char = *current_char_pointer;\n    current_char_pointer = next_char_pointer;\n  } while (current_char != '\\0');\n  return (size_t)(next_char_pointer + (-1 - (int)input_string));\n}\n\n",
            "renaming": {
                "FUN_08000178": "calculate_string_length_08000178",
                "__s": "input_string",
                "pcVar3": "current_char_pointer",
                "pcVar2": "next_char_pointer",
                "cVar1": "current_char"
            },
            "calling": [
                "sendString",
                "setFirmwareNameAndVersion",
                "printNumber"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000188": {
            "entrypoint": "0x08000188",
            "current_name": "execute_interrupt_08000188",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_interrupt_08000188(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08000188": "execute_interrupt_08000188"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800018c": {
            "entrypoint": "0x0800018c",
            "current_name": "execute_afl_call_0800018c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint executeAflCall_0800018c(int numTicks)\n\n{\n  uint32_t result;\n  \n  if (hasHyperCall != 0) {\n    return 0;\n  }\n  result = aflCall(1,numTicks,0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800018c": "execute_afl_call_0800018c",
                "ticks": "numTicks",
                "noHyperCall": "hasHyperCall",
                "uVar1": "result"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080001a8": {
            "entrypoint": "0x080001a8",
            "current_name": "pin_control_080001a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pinControl_080001a8(byte pinNumber,int pinValue)\n\n{\n  bool isValidPin;\n  byte pinMode;\n  uint unsignedPin;\n  uint32_t digitalPinNumber;\n  \n  unsignedPin = (uint)pinNumber;\n  if (unsignedPin < 0x3c) {\n    if (unsignedPin < 0x3c) {\n      if ((&digitalPin)[unsignedPin] == NC) {\n        isValidPin = false;\n      }\n      else {\n        digitalPinNumber = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n        if (digitalPinNumber == 0) {\n          isValidPin = false;\n        }\n        else {\n          digitalPinNumber = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n          if (digitalPinNumber == 1) {\n            isValidPin = false;\n          }\n          else {\n            isValidPin = true;\n          }\n        }\n      }\n    }\n    else {\n      isValidPin = false;\n    }\n  }\n  else {\n    isValidPin = false;\n  }\n  if ((isValidPin) && (pinMode = firmata::FirmataClass::getPinMode(&Firmata,pinNumber), pinMode == '\\x01')) {\n    firmata::FirmataClass::setPinState(&Firmata,pinNumber,pinValue);\n    digitalWrite(unsignedPin,pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001a8": "pin_control_080001a8",
                "pin": "pinNumber",
                "value": "pinValue",
                "bVar1": "isValidPin",
                "bVar2": "pinMode",
                "ulPin": "unsignedPin",
                "uVar3": "digitalPinNumber"
            },
            "calling": [],
            "called": [
                "digitalWrite",
                "pinNametoDigitalPin",
                "getPinMode",
                "setPinState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000214": {
            "entrypoint": "0x08000214",
            "current_name": "handle_pin_mode_08000214",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handlePinMode_08000214(byte pinNumber,int pinValue)\n\n{\n  bool pinModeValid;\n  byte currentPinMode;\n  _Bool isValidPin;\n  uint unsignedPin;\n  uint32_t digitalPinIndex;\n  void *servoPtr;\n  \n  unsignedPin = (uint)pinNumber;\n  if (0x3b < unsignedPin) {\n    return;\n  }\n  currentPinMode = firmata::FirmataClass::getPinMode(&Firmata,pinNumber);\n  if (currentPinMode == '\\x03') {\n    if (unsignedPin < 0x3c) {\n      if ((&digitalPin)[unsignedPin] == NC) {\n        isValidPin = false;\n      }\n      else {\n        digitalPinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n        if (digitalPinIndex == 0) {\n          isValidPin = false;\n        }\n        else {\n          digitalPinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n          if (digitalPinIndex == 1) {\n            isValidPin = false;\n          }\n          else {\n            isValidPin = pinNumber_in_pinNumbermap((&digitalPin)[unsignedPin],(PinMap_conflict *)&PinMap_PWM);\n          }\n        }\n      }\n    }\n    else {\n      isValidPin = false;\n    }\n    if (isValidPin != false) {\n      analogWrite(unsignedPin,pinValue);\n    }\n    firmata::FirmataClass::setPinState(&Firmata,pinNumber,pinValue);\n  }\n  else if (currentPinMode == '\\x04') {\n    if (unsignedPin < 0x3c) {\n      if ((&digitalPin)[unsignedPin] == NC) {\n        pinModeValid = false;\n      }\n      else {\n        digitalPinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n        if (digitalPinIndex == 0) {\n          pinModeValid = false;\n        }\n        else {\n          digitalPinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n          if (digitalPinIndex == 1) {\n            pinModeValid = false;\n          }\n          else {\n            pinModeValid = true;\n          }\n        }\n      }\n    }\n    else {\n      pinModeValid = false;\n    }\n    if (pinModeValid) {\n      Servo::write(servos + servoPinMap[unsignedPin],pinValue,servoPtr,(size_t)servos);\n    }\n    firmata::FirmataClass::setPinState(&Firmata,pinNumber,pinValue);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000214": "handle_pin_mode_08000214",
                "pin": "pinNumber",
                "value": "pinValue",
                "bVar1": "pinModeValid",
                "bVar2": "currentPinMode",
                "_Var3": "isValidPin",
                "ulPin": "unsignedPin",
                "uVar4": "digitalPinIndex",
                "in_r2": "servoPtr"
            },
            "calling": [
                "sysexCallback"
            ],
            "called": [
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "getPinMode",
                "write",
                "setPinState",
                "analogWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002ec": {
            "entrypoint": "0x080002ec",
            "current_name": "update_digital_pins_080002ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateDigitalPins_080002ec(byte portNum,int pinValue)\n\n{\n  bool isValidPin;\n  byte pinMode;\n  uint portIdx;\n  uint32_t digitalPin;\n  int pinState;\n  byte currentPin;\n  uint32_t pinIndex;\n  uint bitMask;\n  byte lastPin;\n  uint lastBitIdx;\n  byte pin;\n  byte pin_1;\n  uint32_t firstPinInGroup;\n  uint pinMask;\n  byte pinValue;\n  \n  portIdx = (uint)portNum;\n  if (portIdx < 5) {\n    lastBitIdx = (portIdx + 1 & 0x1f) * 8;\n    if (0x3c < lastBitIdx) {\n      lastBitIdx = 0x3c;\n    }\n    pinMask = 0;\n    bitMask = 1;\n    firstPinInGroup = (portIdx & 0x1f) * 8;\n    for (pinIndex = firstPinInGroup; pinIndex < lastBitIdx; pinIndex = pinIndex + 1 & 0xff) {\n      if (pinIndex < 0x3c) {\n        if ((&digitalPin)[pinIndex] == NC) {\n          isValidPin = false;\n        }\n        else {\n          digitalPin = pinNametoDigitalPin((&digitalPin)[pinIndex]);\n          if (digitalPin == 0) {\n            isValidPin = false;\n          }\n          else {\n            digitalPin = pinNametoDigitalPin((&digitalPin)[pinIndex]);\n            if (digitalPin == 1) {\n              isValidPin = false;\n            }\n            else {\n              isValidPin = true;\n            }\n          }\n        }\n      }\n      else {\n        isValidPin = false;\n      }\n      if (isValidPin) {\n        currentPin = (byte)pinIndex;\n        pinMode = firmata::FirmataClass::getPinMode(&Firmata,currentPin);\n        if ((pinMode != '\\x01') &&\n           (pinMode = firmata::FirmataClass::getPinMode(&Firmata,currentPin), pinMode != '\\0')) {\n          isValidPin = false;\n        }\n        if (isValidPin) {\n          portIdx = (uint)((bitMask & pinValue) != 0);\n          pinMode = firmata::FirmataClass::getPinMode(&Firmata,currentPin);\n          if (pinMode == '\\x01') {\n            pinMask = bitMask | pinMask;\n          }\n          else {\n            pinMode = firmata::FirmataClass::getPinMode(&Firmata,currentPin);\n            if (pinMode == '\\0') {\n              if (portIdx == 0) {\n                isValidPin = false;\n              }\n              else {\n                pinState = firmata::FirmataClass::getPinState(&Firmata,currentPin);\n                if (pinState == 1) {\n                  isValidPin = false;\n                }\n              }\n            }\n            else {\n              isValidPin = false;\n            }\n            if (isValidPin) {\n              pinMode(pinIndex,2);\n            }\n          }\n          firmata::FirmataClass::setPinState(&Firmata,currentPin,portIdx);\n        }\n      }\n      bitMask = (bitMask & 0x7f) << 1;\n    }\n    if ((pinMask & 1) != 0) {\n      digitalWrite(firstPinInGroup,pinValue & 1);\n    }\n    if ((pinMask & 2) != 0) {\n      digitalWrite(firstPinInGroup + 1,pinValue & 2);\n    }\n    if ((pinMask & 4) != 0) {\n      digitalWrite(firstPinInGroup + 2,pinValue & 4);\n    }\n    if ((pinMask & 8) != 0) {\n      digitalWrite(firstPinInGroup + 3,pinValue & 8);\n    }\n    if ((pinMask & 0x10) != 0) {\n      digitalWrite(firstPinInGroup + 4,pinValue & 0x10);\n    }\n    if ((pinMask & 0x20) != 0) {\n      digitalWrite(firstPinInGroup + 5,pinValue & 0x20);\n    }\n    if ((pinMask & 0x40) != 0) {\n      digitalWrite(firstPinInGroup + 6,pinValue & 0x40);\n    }\n    if ((pinMask & 0x80) != 0) {\n      digitalWrite(firstPinInGroup + 7,pinValue & 0x80);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080002ec": "update_digital_pins_080002ec",
                "port": "portNum",
                "value": "pinValue",
                "bVar1": "isValidPin",
                "bVar2": "pinMode",
                "uVar3": "portIdx",
                "uVar4": "digitalPin",
                "iVar5": "pinState",
                "pin_00": "currentPin",
                "ulPin": "pinIndex",
                "uVar6": "bitMask",
                "uVar7": "lastBitIdx",
                "ulPin_00": "firstPinInGroup",
                "uVar8": "pinMask"
            },
            "calling": [],
            "called": [
                "digitalWrite",
                "getPinState",
                "pinNametoDigitalPin",
                "getPinMode",
                "setPinState",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000488": {
            "entrypoint": "0x08000488",
            "current_name": "update_analog_pin_value_08000488",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateAnalogPinValue_08000488(byte pin,int pinValue)\n\n{\n  uint convertedPin;\n  uint32_t readValue;\n  \n  convertedPin = (uint)pin;\n  if (convertedPin < 0xe) {\n    if (pinValue == 0) {\n      analogInputsToReport = analogInputsToReport & ~(1 << convertedPin);\n      return;\n    }\n    analogInputsToReport = 1 << convertedPin | analogInputsToReport;\n    if (!isResetting) {\n      readValue = analogRead(convertedPin);\n      firmata::FirmataClass::sendAnalog(&Firmata,pin,readValue);\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000488": "update_analog_pin_value_08000488",
                "analogPin": "pin",
                "value": "pinValue",
                "ulPin": "convertedPin",
                "value_00": "readValue"
            },
            "calling": [
                "setPinModeCallback"
            ],
            "called": [
                "analogRead",
                "sendAnalog"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004d4": {
            "entrypoint": "0x080004d4",
            "current_name": "initialize_servos_080004d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeServos_080004d4(int isToInitialize,int priorityLevel)\n\n{\n  int counter;\n  Servo *currentServo;\n  \n  if (isToInitialize != 1) {\n    return;\n  }\n  if (priorityLevel == 0xffff) {\n    currentServo = servos;\n    for (counter = 0xb; -1 < counter; counter = counter + -1) {\n      Servo::Servo(currentServo);\n      currentServo = currentServo + 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080004d4": "initialize_servos_080004d4",
                "__initialize_p": "isToInitialize",
                "__priority": "priorityLevel",
                "iVar1": "counter",
                "this": "currentServo"
            },
            "calling": [
                "_GLOBAL__sub_I_analogInputsToReport"
            ],
            "called": [
                "Servo"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000500": {
            "entrypoint": "0x08000500",
            "current_name": "attach_servo_08000500",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid attachServo_08000500(byte servoPin,int minimumPulse,int maximumPulse)\n\n{\n  uint convertedPin;\n  \n  convertedPin = (uint)servoPin;\n  if (0xb < attachedServoCount) {\n    sendErrorMessage(&Firmata,\"Max servoArray attached\");\n    return;\n  }\n  if (detachedServosCount == 0) {\n    pinToServoMap[convertedPin] = attachedServoCount;\n    attachedServoCount = attachedServoCount + '\\x01';\n  }\n  else {\n    pinToServoMap[convertedPin] = (&DAT_2000011f)[detachedServosCount];\n    detachedServosCount = detachedServosCount + 0xff;\n  }\n  if ((0 < minimumPulse) && (0 < maximumPulse)) {\n    attachServo_08000500(servoArray + pinToServoMap[convertedPin],convertedPin,minimumPulse,maximumPulse);\n    return;\n  }\n  attachServo_08000500(servoArray + pinToServoMap[convertedPin],convertedPin);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000500": "attach_servo_08000500",
                "pin": "servoPin",
                "minPulse": "minimumPulse",
                "maxPulse": "maximumPulse",
                "pin_00": "convertedPin",
                "servoCount": "attachedServoCount",
                "firmata::FirmataClass::sendString": "sendErrorMessage",
                "servoPinMap": "pinToServoMap",
                "servos": "servoArray",
                "detachedServoCount": "detachedServosCount",
                "Servo::attach": "attachServo"
            },
            "calling": [
                "setPinModeCallback",
                "sysexCallback"
            ],
            "called": [
                "attach",
                "attach",
                "sendString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000588": {
            "entrypoint": "0x08000588",
            "current_name": "detach_servo_08000588",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid detachServo_08000588(byte pin)\n\n{\n  Servo::detach(servoArray + pinMap[pin]);\n  if ((pinMap[pin] == count) && (count != '\\0')) {\n    count = count + 0xff;\n  }\n  else if (count != '\\0') {\n    detachedCount = detachedCount + 1;\n    (&DAT_2000011f)[detachedCount] = pinMap[pin];\n  }\n  pinMap[pin] = 0xff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000588": "detach_servo_08000588",
                "servoPinMap": "pinMap",
                "servos": "servoArray",
                "servoCount": "count",
                "detachedServoCount": "detachedCount"
            },
            "calling": [
                "setPinModeCallback",
                "sysexCallback"
            ],
            "called": [
                "detach"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005e0": {
            "entrypoint": "0x080005e0",
            "current_name": "disable_i2_c_080005e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableI2C_080005e0(void)\n\n{\n  isI2CEnabled = false;\n  queryIndex = -1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080005e0": "disable_i2_c_080005e0"
            },
            "calling": [
                "systemResetCallback",
                "setPinModeCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005f8": {
            "entrypoint": "0x080005f8",
            "current_name": "pin_mode_control_080005f8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pinModeControl_080005f8(byte pinNumber,int pinMode)\n\n{\n  byte pinModeResult;\n  PinName_conflict PVar2;\n  bool isPinValid;\n  bool isServoAttached;\n  _Bool isPinInPWM;\n  uint unsignedPin;\n  uint32_t pinIndex;\n  char cVar7;\n  uint uVar8;\n  \n  unsignedPin = (uint)pinNumber;\n  pinModeResult = firmata::FirmataClass::getPinMode(&Firmata,pinNumber);\n  if (pinModeResult != '\\x7f') {\n    pinModeResult = firmata::FirmataClass::getPinMode(&Firmata,pinNumber);\n    if (pinModeResult == '\\x06') {\n      if (isI2CEnabled == false) {\n        cVar7 = '\\0';\n      }\n      else {\n        cVar7 = isI2CEnabled;\n        if (pinMode == 6) {\n          cVar7 = '\\0';\n        }\n      }\n    }\n    else {\n      cVar7 = '\\0';\n    }\n    if (cVar7 != '\\0') {\n      disableI2CPins();\n    }\n    if (unsignedPin < 0x3c) {\n      if ((&digitalPin)[unsignedPin] == NC) {\n        isPinValid = false;\n      }\n      else {\n        pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n        if (pinIndex == 0) {\n          isPinValid = false;\n        }\n        else {\n          pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n          if (pinIndex == 1) {\n            isPinValid = false;\n          }\n          else if (pinMode == 4) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = true;\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      if (servoPinMap[unsignedPin] < 0xc) {\n        isPinValid = Servo::attached(servos + servoPinMap[unsignedPin]);\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid != false) {\n        detachServo(pinNumber);\n      }\n    }\n    uVar8 = unsignedPin - 0x2e & 0xff;\n    if (uVar8 < 0xe) {\n      if (unsignedPin < 0x3c) {\n        PVar2 = (&digitalPin)[unsignedPin];\n      }\n      else {\n        PVar2 = NC;\n      }\n      pinIndex = pinNumberNametoDigitalPin(PVar2);\n      if (pinIndex == 0) {\n        isPinValid = false;\n      }\n      else {\n        if (unsignedPin < 0x3c) {\n          PVar2 = (&digitalPin)[unsignedPin];\n        }\n        else {\n          PVar2 = NC;\n        }\n        pinIndex = pinNumberNametoDigitalPin(PVar2);\n        if (pinIndex == 1) {\n          isPinValid = false;\n        }\n        else {\n          isPinValid = true;\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      reportAnalogCallback((byte)uVar8,(uint)(pinMode == 2));\n    }\n    if (unsignedPin < 0x3c) {\n      if ((&digitalPin)[unsignedPin] == NC) {\n        isPinValid = false;\n      }\n      else {\n        pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n        if (pinIndex == 0) {\n          isPinValid = false;\n        }\n        else {\n          pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n          if (pinIndex == 1) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = true;\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      if ((pinMode == 0) || (pinMode == 0xb)) {\n        portConfigInputs[pinNumber >> 3] = portConfigInputs[pinNumber >> 3] | (byte)(1 << (unsignedPin & 7));\n      }\n      else {\n        portConfigInputs[pinNumber >> 3] = portConfigInputs[pinNumber >> 3] & ~(byte)(1 << (unsignedPin & 7));\n      }\n    }\n    firmata::FirmataClass::setPinState(&Firmata,pinNumber,0);\n    switch(pinMode) {\n    case 0:\n      if (unsignedPin < 0x3c) {\n        if ((&digitalPin)[unsignedPin] == NC) {\n          isPinValid = false;\n        }\n        else {\n          pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n          if (pinIndex == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n            if (pinIndex == 1) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        pinNumberMode(unsignedPin,0);\n        firmata::FirmataClass::setPinMode(&Firmata,pinNumber,'\\0');\n        return;\n      }\n      break;\n    case 1:\n      if (unsignedPin < 0x3c) {\n        if ((&digitalPin)[unsignedPin] == NC) {\n          isPinValid = false;\n        }\n        else {\n          pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n          if (pinIndex == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n            if (pinIndex == 1) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        pinModeResult = firmata::FirmataClass::getPinMode(&Firmata,pinNumber);\n        if (pinModeResult == '\\x03') {\n          digitalWrite(unsignedPin,0);\n        }\n        pinNumberMode(unsignedPin,1);\n        firmata::FirmataClass::setPinMode(&Firmata,pinNumber,'\\x01');\n        return;\n      }\n      break;\n    case 2:\n      if (uVar8 < 0xe) {\n        if (unsignedPin < 0x3c) {\n          PVar2 = (&digitalPin)[unsignedPin];\n        }\n        else {\n          PVar2 = NC;\n        }\n        pinIndex = pinNumberNametoDigitalPin(PVar2);\n        if (pinIndex == 0) {\n          isPinValid = false;\n        }\n        else {\n          if (unsignedPin < 0x3c) {\n            PVar2 = (&digitalPin)[unsignedPin];\n          }\n          else {\n            PVar2 = NC;\n          }\n          pinIndex = pinNumberNametoDigitalPin(PVar2);\n          if (pinIndex == 1) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = true;\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        if (unsignedPin < 0x3c) {\n          if ((&digitalPin)[unsignedPin] == NC) {\n            isPinValid = false;\n          }\n          else {\n            pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n            if (pinIndex == 0) {\n              isPinValid = false;\n            }\n            else {\n              pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n              if (pinIndex == 1) {\n                isPinValid = false;\n              }\n            }\n          }\n        }\n        else {\n          isPinValid = false;\n        }\n        if (isPinValid) {\n          pinNumberMode(unsignedPin,0);\n        }\n        firmata::FirmataClass::setPinMode(&Firmata,pinNumber,'\\x02');\n        return;\n      }\n      break;\n    case 3:\n      if (unsignedPin < 0x3c) {\n        if ((&digitalPin)[unsignedPin] == NC) {\n          isPinInPWM = false;\n        }\n        else {\n          pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n          if (pinIndex == 0) {\n            isPinInPWM = false;\n          }\n          else {\n            pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n            if (pinIndex == 1) {\n              isPinInPWM = false;\n            }\n            else {\n              isPinInPWM = pinNumber_in_pinNumbermap((&digitalPin)[unsignedPin],(PinMap_conflict *)&PinMap_PWM);\n            }\n          }\n        }\n      }\n      else {\n        isPinInPWM = false;\n      }\n      if (isPinInPWM != false) {\n        pinNumberMode(unsignedPin,1);\n        analogWrite(unsignedPin,0);\n        firmata::FirmataClass::setPinMode(&Firmata,pinNumber,'\\x03');\n        return;\n      }\n      break;\n    case 4:\n      if (unsignedPin < 0x3c) {\n        if ((&digitalPin)[unsignedPin] == NC) {\n          isPinValid = false;\n        }\n        else {\n          pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n          if (pinIndex == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n            if (pinIndex == 1) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        firmata::FirmataClass::setPinMode(&Firmata,pinNumber,'\\x04');\n        if ((servoPinMap[unsignedPin] != 0xff) &&\n           (isServoAttached = Servo::attached(servos + servoPinMap[unsignedPin]), isServoAttached)) {\n          isPinValid = false;\n        }\n        if (isPinValid) {\n          attachServo(pinNumber,-1,-1);\n          return;\n        }\n      }\n      break;\n    default:\n      firmata::FirmataClass::sendString(&Firmata,\"Unknown pinNumber pinMode\");\n      break;\n    case 6:\n      if (unsignedPin < 0x3c) {\n        if ((&digitalPin)[unsignedPin] == NC) {\n          isPinInPWM = false;\n        }\n        else {\n          pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n          if (pinIndex == 0) {\n            isPinInPWM = false;\n          }\n          else {\n            pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n            if (pinIndex == 1) {\n              isPinInPWM = false;\n            }\n            else {\n              isPinInPWM = pinNumber_in_pinNumbermap((&digitalPin)[unsignedPin],(PinMap_conflict *)&PinMap_I2C_SDA);\n              if (!isPinInPWM) {\n                isPinInPWM = pinNumber_in_pinNumbermap((&digitalPin)[unsignedPin],(PinMap_conflict *)&PinMap_I2C_SCL);\n              }\n            }\n          }\n        }\n      }\n      else {\n        isPinInPWM = false;\n      }\n      if (isPinInPWM != false) {\n        firmata::FirmataClass::setPinMode(&Firmata,pinNumber,'\\x06');\n        return;\n      }\n      break;\n    case 10:\n      break;\n    case 0xb:\n      if (unsignedPin < 0x3c) {\n        if ((&digitalPin)[unsignedPin] == NC) {\n          isPinValid = false;\n        }\n        else {\n          pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n          if (pinIndex == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinIndex = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n            if (pinIndex == 1) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        pinNumberMode(unsignedPin,2);\n        firmata::FirmataClass::setPinMode(&Firmata,pinNumber,'\\v');\n        firmata::FirmataClass::setPinState(&Firmata,pinNumber,1);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080005f8": "pin_mode_control_080005f8",
                "pin": "pinNumber",
                "mode": "pinMode",
                "bVar1": "pinModeResult",
                "bVar3": "isPinValid",
                "bVar4": "isServoAttached",
                "_Var5": "isPinInPWM",
                "ulPin": "unsignedPin",
                "uVar6": "pinIndex"
            },
            "calling": [
                "systemResetCallback",
                "enableI2CPins",
                "sysexCallback"
            ],
            "called": [
                "attached",
                "disableI2CPins",
                "setPinMode",
                "setPinState",
                "analogWrite",
                "reportAnalogCallback",
                "digitalWrite",
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "detachServo",
                "getPinMode",
                "sendString",
                "pinMode",
                "attachServo"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a64": {
            "entrypoint": "0x08000a64",
            "current_name": "initialize_i2_c_08000a64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeI2C_08000a64(void)\n\n{\n  _Bool isPinValid;\n  uint32_t digitalPinNumber;\n  uint pinIndex;\n  \n  for (pinIndex = 0; pinIndex < 0x3c; pinIndex = pinIndex + 1 & 0xff) {\n    if (pinIndex < 0x3c) {\n      if ((&digitalPin)[pinIndex] == NC) {\n        isPinValid = false;\n      }\n      else {\n        digitalPinNumber = pinNametoDigitalPin((&digitalPin)[pinIndex]);\n        if (digitalPinNumber == 0) {\n          isPinValid = false;\n        }\n        else {\n          digitalPinNumber = pinNametoDigitalPin((&digitalPin)[pinIndex]);\n          if (digitalPinNumber == 1) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = pin_in_pinmap((&digitalPin)[pinIndex],(PinMap_conflict *)&PinMap_I2C_SDA);\n            if (!isPinValid) {\n              isPinValid = pin_in_pinmap((&digitalPin)[pinIndex],(PinMap_conflict *)&PinMap_I2C_SCL);\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid != false) {\n      setPinModeCallback((byte)pinIndex,6);\n    }\n  }\n  isI2CEnabled = true;\n  TwoWire::begin(&Wire);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000a64": "initialize_i2_c_08000a64",
                "_Var1": "isPinValid",
                "uVar2": "digitalPinNumber",
                "uVar3": "pinIndex"
            },
            "calling": [
                "sysexCallback"
            ],
            "called": [
                "pin_in_pinmap",
                "begin",
                "setPinModeCallback",
                "pinNametoDigitalPin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aec": {
            "entrypoint": "0x08000aec",
            "current_name": "initialize_pins_08000aec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePins_08000aec(void)\n\n{\n  bool isSet;\n  PinName_conflict pinConfiguration;\n  uint32_t uVar3;\n  byte i;\n  uint counter;\n  byte i_1;\n  \n  resettingFlag = true;\n  if (i2cEnabledFlag) {\n    disableI2CPins();\n  }\n  for (counter = 0; counter < 5; counter = counter + 1 & 0xff) {\n    reportedPins[counter] = '\\0';\n    inputConfigPorts[counter] = '\\0';\n    previousPins[counter] = '\\0';\n  }\n  for (counter = 0; counter < 0x3c; counter = counter + 1 & 0xff) {\n    if ((counter - 0x2e & 0xff) < 0xe) {\n      if (counter < 0x3c) {\n        pinConfiguration = (&digitalPin)[counter];\n      }\n      else {\n        pinConfiguration = NC;\n      }\n      uVar3 = convertPinNameToDigital(pinConfiguration);\n      if (uVar3 == 0) {\n        isSet = false;\n      }\n      else {\n        if (counter < 0x3c) {\n          pinConfiguration = (&digitalPin)[counter];\n        }\n        else {\n          pinConfiguration = NC;\n        }\n        uVar3 = convertPinNameToDigital(pinConfiguration);\n        if (uVar3 == 1) {\n          isSet = false;\n        }\n        else {\n          isSet = true;\n        }\n      }\n    }\n    else {\n      isSet = false;\n    }\n    if (isSet) {\n      setPinMode((byte)counter,2);\n    }\n    else {\n      if ((((counter < 0x3c) && ((&digitalPin)[counter] != NC)) &&\n          (uVar3 = convertPinNameToDigital((&digitalPin)[counter]), uVar3 != 0)) &&\n         (uVar3 = convertPinNameToDigital((&digitalPin)[counter]), uVar3 != 1)) {\n        isSet = true;\n      }\n      if (isSet) {\n        setPinMode((byte)counter,1);\n      }\n    }\n    servoPinMapping[counter] = 0xff;\n  }\n  reportedAnalogInputs = 0;\n  detachedServoCount = '\\0';\n  servoCount = '\\0';\n  resettingFlag = false;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000aec": "initialize_pins_08000aec",
                "isResetting": "resettingFlag",
                "isI2CEnabled": "i2cEnabledFlag",
                "reportPINs": "reportedPins",
                "portConfigInputs": "inputConfigPorts",
                "previousPINs": "previousPins",
                "uVar4": "counter",
                "PVar2": "pinConfiguration",
                "pinNametoDigitalPin": "convertPinNameToDigital",
                "bVar1": "isSet",
                "setPinModeCallback": "setPinMode",
                "servoPinMap": "servoPinMapping",
                "analogInputsToReport": "reportedAnalogInputs"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "pinNametoDigitalPin",
                "setPinModeCallback",
                "disableI2CPins"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000be8": {
            "entrypoint": "0x08000be8",
            "current_name": "send_digital_port_if_needed_08000be8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendDigitalPortIfNeeded_08000be8(byte portNum,byte portVal,byte force)\n\n{\n  byte inputConfig;\n  \n  inputConfig = portConfigInputs[portNum] & portVal;\n  if ((force != '\\0') || ((uint)inputConfig != (uint)previousPins[portNum])) {\n    firmata::FirmataClass::sendDigitalPort(firmataInstance,portNum,(uint)inputConfig);\n    previousPins[portNum] = inputConfig;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000be8": "send_digital_port_if_needed_08000be8",
                "portNumber": "portNum",
                "portValue": "portVal",
                "forceSend": "force",
                "bVar1": "inputConfig",
                "previousPINs": "previousPins",
                "&Firmata": "firmataInstance"
            },
            "calling": [
                "checkDigitalInputs",
                "reportDigitalCallback"
            ],
            "called": [
                "sendDigitalPort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c18": {
            "entrypoint": "0x08000c18",
            "current_name": "report_port_status_08000c18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reportPortStatus_08000c18(byte portNumber,int portValue)\n\n{\n  byte inputConfig;\n  bool isPinValid;\n  uint32_t pinDigitalValue;\n  int pinReadValue;\n  uchar pinNumber;\n  uint portIndex;\n  byte finalPortValue;\n  \n  portIndex = (uint)portNumber;\n  if ((portIndex < 5) && (reportNumberPINs[portIndex] = (byte)portValue, portValue != 0)) {\n    inputConfig = portNumberConfigInputs[portIndex];\n    portIndex = (portIndex & 0x1f) * 8;\n    if (portIndex < 0x3c) {\n      if ((&digitalPin)[portIndex] == NC) {\n        finalPortValue = 0;\n      }\n      else {\n        pinDigitalValue = pinNumberNametoDigitalPin((&digitalPin)[portIndex]);\n        if (pinDigitalValue == 0) {\n          finalPortValue = 0;\n        }\n        else {\n          pinDigitalValue = pinNumberNametoDigitalPin((&digitalPin)[portIndex]);\n          if (pinDigitalValue == 1) {\n            finalPortValue = 0;\n          }\n          else if ((inputConfig & 1) == 0) {\n            finalPortValue = 0;\n          }\n          else {\n            pinReadValue = digitalRead(portIndex);\n            if (pinReadValue == 0) {\n              finalPortValue = 0;\n            }\n            else {\n              finalPortValue = 1;\n            }\n          }\n        }\n      }\n    }\n    else {\n      finalPortValue = 0;\n    }\n    if (portIndex + 1 < 0x3c) {\n      if ((&DAT_0800a909)[portIndex] == NC) {\n        isPinValid = false;\n      }\n      else {\n        pinDigitalValue = pinNumberNametoDigitalPin((&DAT_0800a909)[portIndex]);\n        if (pinDigitalValue == 0) {\n          isPinValid = false;\n        }\n        else {\n          pinDigitalValue = pinNumberNametoDigitalPin((&DAT_0800a909)[portIndex]);\n          if (pinDigitalValue == 1) {\n            isPinValid = false;\n          }\n          else if ((inputConfig & 2) == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinReadValue = digitalRead(portIndex + 1);\n            if (pinReadValue == 0) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      finalPortValue = finalPortValue | 2;\n    }\n    if (portIndex + 2 < 0x3c) {\n      if ((&DAT_0800a90a)[portIndex] == NC) {\n        isPinValid = false;\n      }\n      else {\n        pinDigitalValue = pinNumberNametoDigitalPin((&DAT_0800a90a)[portIndex]);\n        if (pinDigitalValue == 0) {\n          isPinValid = false;\n        }\n        else {\n          pinDigitalValue = pinNumberNametoDigitalPin((&DAT_0800a90a)[portIndex]);\n          if (pinDigitalValue == 1) {\n            isPinValid = false;\n          }\n          else if ((inputConfig & 4) == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinReadValue = digitalRead(portIndex + 2);\n            if (pinReadValue == 0) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      finalPortValue = finalPortValue | 4;\n    }\n    if (portIndex + 3 < 0x3c) {\n      if ((&DAT_0800a90b)[portIndex] == NC) {\n        isPinValid = false;\n      }\n      else {\n        pinDigitalValue = pinNumberNametoDigitalPin((&DAT_0800a90b)[portIndex]);\n        if (pinDigitalValue == 0) {\n          isPinValid = false;\n        }\n        else {\n          pinDigitalValue = pinNumberNametoDigitalPin((&DAT_0800a90b)[portIndex]);\n          if (pinDigitalValue == 1) {\n            isPinValid = false;\n          }\n          else if ((inputConfig & 8) == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinReadValue = digitalRead(portIndex + 3);\n            if (pinReadValue == 0) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      finalPortValue = finalPortValue | 8;\n    }\n    if (portIndex + 4 < 0x3c) {\n      if ((&DAT_0800a90c)[portIndex] == NC) {\n        isPinValid = false;\n      }\n      else {\n        pinDigitalValue = pinNumberNametoDigitalPin((&DAT_0800a90c)[portIndex]);\n        if (pinDigitalValue == 0) {\n          isPinValid = false;\n        }\n        else {\n          pinDigitalValue = pinNumberNametoDigitalPin((&DAT_0800a90c)[portIndex]);\n          if (pinDigitalValue == 1) {\n            isPinValid = false;\n          }\n          else if ((inputConfig & 0x10) == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinReadValue = digitalRead(portIndex + 4);\n            if (pinReadValue == 0) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      finalPortValue = finalPortValue | 0x10;\n    }\n    if (portIndex + 5 < 0x3c) {\n      if ((&DAT_0800a90d)[portIndex] == NC) {\n        isPinValid = false;\n      }\n      else {\n        pinDigitalValue = pinNumberNametoDigitalPin((&DAT_0800a90d)[portIndex]);\n        if (pinDigitalValue == 0) {\n          isPinValid = false;\n        }\n        else {\n          pinDigitalValue = pinNumberNametoDigitalPin((&DAT_0800a90d)[portIndex]);\n          if (pinDigitalValue == 1) {\n            isPinValid = false;\n          }\n          else if ((inputConfig & 0x20) == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinReadValue = digitalRead(portIndex + 5);\n            if (pinReadValue == 0) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      finalPortValue = finalPortValue | 0x20;\n    }\n    if (portIndex + 6 < 0x3c) {\n      if ((&DAT_0800a90e)[portIndex] == NC) {\n        isPinValid = false;\n      }\n      else {\n        pinDigitalValue = pinNumberNametoDigitalPin((&DAT_0800a90e)[portIndex]);\n        if (pinDigitalValue == 0) {\n          isPinValid = false;\n        }\n        else {\n          pinDigitalValue = pinNumberNametoDigitalPin((&DAT_0800a90e)[portIndex]);\n          if (pinDigitalValue == 1) {\n            isPinValid = false;\n          }\n          else if ((inputConfig & 0x40) == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinReadValue = digitalRead(portIndex + 6);\n            if (pinReadValue == 0) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      finalPortValue = finalPortValue | 0x40;\n    }\n    if (portIndex + 7 < 0x3c) {\n      if ((&DAT_0800a90f)[portIndex] == NC) {\n        isPinValid = false;\n      }\n      else {\n        pinDigitalValue = pinNumberNametoDigitalPin((&DAT_0800a90f)[portIndex]);\n        if (pinDigitalValue == 0) {\n          isPinValid = false;\n        }\n        else {\n          pinDigitalValue = pinNumberNametoDigitalPin((&DAT_0800a90f)[portIndex]);\n          if (pinDigitalValue == 1) {\n            isPinValid = false;\n          }\n          else if ((inputConfig & 0x80) == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinReadValue = digitalRead(portIndex + 7);\n            if (pinReadValue == 0) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      finalPortValue = finalPortValue | 0x80;\n    }\n    outputPort(portNumber,finalPortValue,'\\x01');\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c18": "report_port_status_08000c18",
                "port": "portNumber",
                "value": "portValue",
                "bVar1": "inputConfig",
                "bVar2": "isPinValid",
                "uVar3": "pinDigitalValue",
                "iVar4": "pinReadValue",
                "pin": "pinNumber",
                "uVar5": "portIndex",
                "portValue": "finalPortValue"
            },
            "calling": [],
            "called": [
                "outputPort",
                "pinNametoDigitalPin",
                "digitalRead"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ef8": {
            "entrypoint": "0x08000ef8",
            "current_name": "read_input_status_08000ef8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001ade) */\n/* WARNING: Removing unreachable block (ram,0x08001a4a) */\n/* WARNING: Removing unreachable block (ram,0x080019b6) */\n/* WARNING: Removing unreachable block (ram,0x08001912) */\n/* WARNING: Removing unreachable block (ram,0x08001866) */\n/* WARNING: Removing unreachable block (ram,0x080017d2) */\n/* WARNING: Removing unreachable block (ram,0x0800173e) */\n/* WARNING: Removing unreachable block (ram,0x0800169a) */\n/* WARNING: Removing unreachable block (ram,0x080015ee) */\n/* WARNING: Removing unreachable block (ram,0x0800155a) */\n/* WARNING: Removing unreachable block (ram,0x08001490) */\n/* WARNING: Removing unreachable block (ram,0x080014a2) */\n/* WARNING: Removing unreachable block (ram,0x080014e4) */\n/* WARNING: Removing unreachable block (ram,0x080014b0) */\n/* WARNING: Removing unreachable block (ram,0x080014ba) */\n/* WARNING: Removing unreachable block (ram,0x080014e8) */\n/* WARNING: Removing unreachable block (ram,0x080014c2) */\n/* WARNING: Removing unreachable block (ram,0x080014b6) */\n/* WARNING: Removing unreachable block (ram,0x08001496) */\n/* WARNING: Removing unreachable block (ram,0x08001430) */\n/* WARNING: Removing unreachable block (ram,0x08001376) */\n/* WARNING: Removing unreachable block (ram,0x080012e2) */\n/* WARNING: Removing unreachable block (ram,0x0800124e) */\n/* WARNING: Removing unreachable block (ram,0x080011b8) */\n/* WARNING: Removing unreachable block (ram,0x08001100) */\n/* WARNING: Removing unreachable block (ram,0x0800106c) */\n/* WARNING: Removing unreachable block (ram,0x08000fd8) */\n/* WARNING: Removing unreachable block (ram,0x08000f42) */\n/* WARNING: Removing unreachable block (ram,0x08000f8e) */\n/* WARNING: Removing unreachable block (ram,0x08001022) */\n/* WARNING: Removing unreachable block (ram,0x080010b6) */\n/* WARNING: Removing unreachable block (ram,0x0800114a) */\n/* WARNING: Removing unreachable block (ram,0x08001204) */\n/* WARNING: Removing unreachable block (ram,0x08001298) */\n/* WARNING: Removing unreachable block (ram,0x0800132c) */\n/* WARNING: Removing unreachable block (ram,0x080013c0) */\n/* WARNING: Removing unreachable block (ram,0x0800147c) */\n/* WARNING: Removing unreachable block (ram,0x08001510) */\n/* WARNING: Removing unreachable block (ram,0x080015a4) */\n/* WARNING: Removing unreachable block (ram,0x08001638) */\n/* WARNING: Removing unreachable block (ram,0x080016f4) */\n/* WARNING: Removing unreachable block (ram,0x08001788) */\n/* WARNING: Removing unreachable block (ram,0x0800181c) */\n/* WARNING: Removing unreachable block (ram,0x080018b0) */\n/* WARNING: Removing unreachable block (ram,0x0800196c) */\n/* WARNING: Removing unreachable block (ram,0x08001a00) */\n/* WARNING: Removing unreachable block (ram,0x08001a94) */\n/* WARNING: Removing unreachable block (ram,0x08001b28) */\n/* WARNING: Removing unreachable block (ram,0x080014ca) */\n/* WARNING: Unknown calling convention */\n\nvoid readInputStatus_08000ef8(void)\n\n{\n  bool isPinHigh;\n  byte portConfig;\n  uint32_t pinIndex;\n  int pinValue;\n  byte statusByte;\n  \n  portConfig = portConfigInputs[0];\n  if (reportPINs[0] != '\\0') {\n    pinIndex = pinNametoDigitalPin(PA_3);\n    if (pinIndex == 0) {\n      statusByte = 0;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PA_3);\n      if (pinIndex == 1) {\n        statusByte = 0;\n      }\n      else if ((portConfig & 1) == 0) {\n        statusByte = 0;\n      }\n      else {\n        pinValue = digitalRead(0);\n        if (pinValue == 0) {\n          statusByte = 0;\n        }\n        else {\n          statusByte = 1;\n        }\n      }\n    }\n    pinIndex = pinNametoDigitalPin(PA_2);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PA_2);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 2) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(1);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 2;\n    }\n    pinIndex = pinNametoDigitalPin(PA_10);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PA_10);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 4) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(2);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 4;\n    }\n    pinIndex = pinNametoDigitalPin(PB_3);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PB_3);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 8) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(3);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 8;\n    }\n    pinIndex = pinNametoDigitalPin(PB_5);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PB_5);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x10) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(4);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x10;\n    }\n    pinIndex = pinNametoDigitalPin(PB_4);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PB_4);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x20) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(5);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x20;\n    }\n    pinIndex = pinNametoDigitalPin(PB_10);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PB_10);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x40) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(6);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x40;\n    }\n    pinIndex = pinNametoDigitalPin(PA_8);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PA_8);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x80) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(7);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x80;\n    }\n    outputPort('\\0',statusByte,'\\0');\n  }\n  portConfig = portConfigInputs[1];\n  if (reportPINs[1] != '\\0') {\n    pinIndex = pinNametoDigitalPin(PA_9);\n    if (pinIndex == 0) {\n      statusByte = 0;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PA_9);\n      if (pinIndex == 1) {\n        statusByte = 0;\n      }\n      else if ((portConfig & 1) == 0) {\n        statusByte = 0;\n      }\n      else {\n        pinValue = digitalRead(8);\n        if (pinValue == 0) {\n          statusByte = 0;\n        }\n        else {\n          statusByte = 1;\n        }\n      }\n    }\n    pinIndex = pinNametoDigitalPin(PC_7);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PC_7);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 2) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(9);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 2;\n    }\n    pinIndex = pinNametoDigitalPin(PB_6);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PB_6);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 4) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(10);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 4;\n    }\n    pinIndex = pinNametoDigitalPin(PA_7);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PA_7);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 8) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0xb);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 8;\n    }\n    pinIndex = pinNametoDigitalPin(PA_6);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PA_6);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x10) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0xc);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x10;\n    }\n    pinIndex = pinNametoDigitalPin(PA_5);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PA_5);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x20) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0xd);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x20;\n    }\n    pinIndex = pinNametoDigitalPin(PB_9);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PB_9);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x40) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0xe);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x40;\n    }\n    pinIndex = pinNametoDigitalPin(PB_8);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PB_8);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x80) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0xf);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x80;\n    }\n    outputPort('\\x01',statusByte,'\\0');\n  }\n  portConfig = portConfigInputs[2];\n  if (reportPINs[2] != '\\0') {\n    pinIndex = pinNametoDigitalPin(PC_10);\n    if (pinIndex == 0) {\n      statusByte = 0;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PC_10);\n      if (pinIndex == 1) {\n        statusByte = 0;\n      }\n      else if ((portConfig & 1) == 0) {\n        statusByte = 0;\n      }\n      else {\n        pinValue = digitalRead(0x10);\n        if (pinValue == 0) {\n          statusByte = 0;\n        }\n        else {\n          statusByte = 1;\n        }\n      }\n    }\n    pinIndex = pinNametoDigitalPin(PC_12);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PC_12);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 2) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x11);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 2;\n    }\n    pinIndex = pinNametoDigitalPin(PA_13);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PA_13);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 8) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x13);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 8;\n    }\n    pinIndex = pinNametoDigitalPin(PA_14);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PA_14);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x10) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x14);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x10;\n    }\n    pinIndex = pinNametoDigitalPin(PA_15);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PA_15);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x20) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x15);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x20;\n    }\n    pinIndex = pinNametoDigitalPin(PB_7);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PB_7);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x40) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x16);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x40;\n    }\n    pinIndex = pinNametoDigitalPin(PC_13);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PC_13);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x80) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x17);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x80;\n    }\n    outputPort('\\x02',statusByte,'\\0');\n  }\n  portConfig = portConfigInputs[3];\n  if (reportPINs[3] != '\\0') {\n    pinIndex = pinNametoDigitalPin(PC_14);\n    if (pinIndex == 0) {\n      statusByte = 0;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PC_14);\n      if (pinIndex == 1) {\n        statusByte = 0;\n      }\n      else if ((portConfig & 1) == 0) {\n        statusByte = 0;\n      }\n      else {\n        pinValue = digitalRead(0x18);\n        if (pinValue == 0) {\n          statusByte = 0;\n        }\n        else {\n          statusByte = 1;\n        }\n      }\n    }\n    pinIndex = pinNametoDigitalPin(PC_15);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PC_15);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 2) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x19);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 2;\n    }\n    pinIndex = pinNametoDigitalPin(PD_0);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PD_0);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 4) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x1a);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 4;\n    }\n    pinIndex = pinNametoDigitalPin(PD_1);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PD_1);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 8) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x1b);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 8;\n    }\n    pinIndex = pinNametoDigitalPin(PC_2);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PC_2);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x10) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x1c);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x10;\n    }\n    pinIndex = pinNametoDigitalPin(PC_3);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PC_3);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x20) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x1d);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x20;\n    }\n    pinIndex = pinNametoDigitalPin(PC_11);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PC_11);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x40) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x1e);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x40;\n    }\n    pinIndex = pinNametoDigitalPin(PD_2);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PD_2);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x80) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x1f);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x80;\n    }\n    outputPort('\\x03',statusByte,'\\0');\n  }\n  portConfig = portConfigInputs[4];\n  if (reportPINs[4] != '\\0') {\n    pinIndex = pinNametoDigitalPin(PC_9);\n    if (pinIndex == 0) {\n      statusByte = 0;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PC_9);\n      if (pinIndex == 1) {\n        statusByte = 0;\n      }\n      else if ((portConfig & 1) == 0) {\n        statusByte = 0;\n      }\n      else {\n        pinValue = digitalRead(0x20);\n        if (pinValue == 0) {\n          statusByte = 0;\n        }\n        else {\n          statusByte = 1;\n        }\n      }\n    }\n    pinIndex = pinNametoDigitalPin(PC_8);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PC_8);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 2) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x21);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 2;\n    }\n    pinIndex = pinNametoDigitalPin(PC_6);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PC_6);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 4) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x22);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 4;\n    }\n    pinIndex = pinNametoDigitalPin(PC_5);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PC_5);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 8) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x23);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 8;\n    }\n    pinIndex = pinNametoDigitalPin(PA_12);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PA_12);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x10) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x24);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x10;\n    }\n    pinIndex = pinNametoDigitalPin(PA_11);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PA_11);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x20) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x25);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x20;\n    }\n    pinIndex = pinNametoDigitalPin(PB_12);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PB_12);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x40) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x26);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x40;\n    }\n    pinIndex = pinNametoDigitalPin(PB_11);\n    if (pinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      pinIndex = pinNametoDigitalPin(PB_11);\n      if (pinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portConfig & 0x80) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        pinValue = digitalRead(0x27);\n        if (pinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      statusByte = statusByte | 0x80;\n    }\n    outputPort('\\x04',statusByte,'\\0');\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ef8": "read_input_status_08000ef8",
                "bVar1": "isPinHigh",
                "bVar2": "portConfig",
                "bVar5": "statusByte",
                "uVar3": "pinIndex",
                "iVar4": "pinValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "outputPort",
                "pinNametoDigitalPin",
                "digitalRead"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b48": {
            "entrypoint": "0x08001b48",
            "current_name": "initialize_firmata_08001b48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeFirmata_08001b48(void)\n\n{\n  firmata::FirmataClass::setFirmwareNameAndVersion\n            (firmataInstance,\"/home/bo/p2im/p2im-real_firmware_scratch/Gateway/StandardFirmata.ino\",'\\x02',\n             '\\x05');\n  firmata::FirmataClass::attach(firmataInstance,0xe0,onAnalogWriteCallback + 1);\n  firmata::FirmataClass::attach(firmataInstance,0x90,onDigitalWriteCallback + 1);\n  firmata::FirmataClass::attach(firmataInstance,0xc0,onReportAnalogCallback + 1);\n  firmata::FirmataClass::attach(firmataInstance,0xd0,onReportDigitalCallback + 1);\n  firmata::FirmataClass::attach(firmataInstance,0xf4,onSetPinModeCallback + 1);\n  firmata::FirmataClass::attach(firmataInstance,0xf5,onSetPinValueCallback + 1);\n  firmata::FirmataClass::attach(firmataInstance,0xf0,onSysexCallback + 1);\n  firmata::FirmataClass::attach(firmataInstance,0xff,onSystemResetCallback);\n  firmata::FirmataClass::begin(firmataInstance,0xe100);\n  onSystemResetCallback();\n  startForkServer(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001b48": "initialize_firmata_08001b48",
                "&Firmata": "firmataInstance",
                "analogWriteCallback": "onAnalogWriteCallback",
                "digitalWriteCallback": "onDigitalWriteCallback",
                "reportAnalogCallback": "onReportAnalogCallback",
                "reportDigitalCallback": "onReportDigitalCallback",
                "setPinModeCallback": "onSetPinModeCallback",
                "setPinValueCallback": "onSetPinValueCallback",
                "sysexCallback": "onSysexCallback",
                "systemResetCallback": "onSystemResetCallback",
                "startForkserver": "startForkServer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "systemResetCallback",
                "begin",
                "attach",
                "attach",
                "setFirmwareNameAndVersion",
                "startForkserver",
                "attach"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001be8": {
            "entrypoint": "0x08001be8",
            "current_name": "initialize_static_data_08001be8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_08001be8(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001be8": "initialize_static_data_08001be8"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001bf8": {
            "entrypoint": "0x08001bf8",
            "current_name": "write_data_08001bf8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid writeData_08001bf8(byte inputData)\n\n{\n  void *bufferPointer;\n  size_t bufferSize;\n  \n  TwoWire::write(&Wire,(uint)inputData,bufferPointer,bufferSize);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001bf8": "write_data_08001bf8",
                "data": "inputData",
                "in_r2": "bufferPointer",
                "in_r3": "bufferSize"
            },
            "calling": [
                "readAndReportData",
                "sysexCallback"
            ],
            "called": [
                "write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c08": {
            "entrypoint": "0x08001c08",
            "current_name": "read_byte_from_wire_08001c08",
            "code": "\n/* WARNING: Unknown calling convention */\n\nbyte readByteFromWire_08001c08(void)\n\n{\n  ssize_t readResult;\n  int deviceAddress;\n  void *buffer;\n  size_t bufferSize;\n  \n  readResult = TwoWire::read(&Wire,deviceAddress,buffer,bufferSize);\n  return (byte)readResult;\n}\n\n",
            "renaming": {
                "FUN_08001c08": "read_byte_from_wire_08001c08",
                "in_r1": "deviceAddress",
                "in_r2": "buffer",
                "in_r3": "bufferSize",
                "sVar1": "readResult"
            },
            "calling": [
                "readAndReportData"
            ],
            "called": [
                "read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c18": {
            "entrypoint": "0x08001c18",
            "current_name": "process_i2_c_data_08001c18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processI2CData_08001c18(byte deviceAddress,int registerAddress,byte dataLength,byte stopTransmission)\n\n{\n  bool isDataAvailable;\n  byte receivedByte;\n  int receivedCount;\n  int availableCount;\n  uint expectedLength;\n  \n  expectedLength = (uint)dataLength;\n  if (registerAddress == -1) {\n    registerAddress = 0;\n  }\n  else {\n    TwoWire::beginTransmission(&Wire,deviceAddress);\n    wireWrite((byte)registerAddress);\n    TwoWire::endTransmission(&Wire,stopTransmission);\n  }\n  TwoWire::requestFrom(&Wire,deviceAddress,dataLength);\n  receivedCount = TwoWire::available(&Wire);\n  if ((int)expectedLength < receivedCount) {\n    firmata::FirmataClass::sendString(&Firmata,\"I2C: Too many bytes received\");\n  }\n  else {\n    receivedCount = TwoWire::available(&Wire);\n    if (receivedCount < (int)expectedLength) {\n      firmata::FirmataClass::sendString(&Firmata,\"I2C: Too few bytes received\");\n    }\n  }\n  i2cRxData[1] = (byte)registerAddress;\n  receivedCount = 0;\n  i2cRxData[0] = deviceAddress;\n  while( true ) {\n    if (receivedCount < (int)expectedLength) {\n      availableCount = TwoWire::available(&Wire);\n      if (availableCount == 0) {\n        isDataAvailable = false;\n      }\n      else {\n        isDataAvailable = true;\n      }\n    }\n    else {\n      isDataAvailable = false;\n    }\n    if (!isDataAvailable) break;\n    receivedByte = wireRead();\n    i2cRxData[receivedCount + 2] = receivedByte;\n    receivedCount = receivedCount + 1;\n  }\n  firmata::FirmataClass::sendSysex(&Firmata,'w',dataLength + '\\x02',i2cRxData);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001c18": "process_i2_c_data_08001c18",
                "address": "deviceAddress",
                "theRegister": "registerAddress",
                "numBytes": "dataLength",
                "stopTX": "stopTransmission",
                "bVar1": "isDataAvailable",
                "bVar2": "receivedByte",
                "iVar3": "receivedCount",
                "iVar4": "availableCount",
                "uVar5": "expectedLength"
            },
            "calling": [
                "loop",
                "sysexCallback"
            ],
            "called": [
                "wireRead",
                "sendSysex",
                "beginTransmission",
                "available",
                "requestFrom",
                "sendString",
                "endTransmission",
                "wireWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cd0": {
            "entrypoint": "0x08001cd0",
            "current_name": "process_command_08001cd0",
            "code": "\n/* WARNING: Unknown callloopIndexng conventloopIndexon */\n\nvoloopIndexd processCommand_08001cd0(byte cmd,byte argCount,byte *argValues)\n\n{\n  byte byteVar1;\n  uloopIndexnt8_t deviceAddress;\n  byte byteVar2;\n  byte byteVar3;\n  byte byteVar4;\n  byte slaveAddress;\n  byte data;\n  PloopIndexnName_conflloopIndexct pinNameConflict;\n  _Bool isPinInMap;\n  byte byteVar7;\n  uloopIndexnt32_t value;\n  loopIndexnt index;\n  loopIndexnt value;\n  byte pinMode;\n  byte byteVar10;\n  byte stopTransmission;\n  byte loopIndex;\n  byte loopIndex1;\n  undefloopIndexned1 *pointerVar;\n  uloopIndexnt unsignedVar;\n  uloopIndexnt delayTloopIndexme;\n  byte pin1;\n  undefloopIndexned1 *undefinedVar;\n  sloopIndexze_t sizeVar;\n  loopIndexnt maximumPulse;\n  byte ploopIndexn;\n  uloopIndexnt unsignedVar;\n  loopIndexnt minimumPulse;\n  loopIndexnt index;\n  bool boolVar;\n  \n  unsignedVar = (uloopIndexnt)argCount;\n  swloopIndextch(cmd) {\n  case 'loopIndex':\n    floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,0xf0,argValues,(sloopIndexze_t)pointerVar);\n    floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,0x6a,argValues,(sloopIndexze_t)pointerVar);\n    for (unsignedVar = 0; unsignedVar < 0x3c; unsignedVar = unsignedVar + 1 & 0xff) {\n      unsignedVar = unsignedVar - 0x2e & 0xff;\n      loopIndexf (unsignedVar < 0xe) {\n        loopIndexf (unsignedVar < 0x3c) {\n          pointerVar = &dloopIndexgloopIndextalPloopIndexn;\n          pinNameConflict = (&dloopIndexgloopIndextalPloopIndexn)[unsignedVar];\n        }\n        else {\n          pinNameConflict = NC;\n        }\n        value = ploopIndexnNametoDloopIndexgloopIndextalPloopIndexn(pinNameConflict);\n        loopIndexf (value == 0) {\n          unsignedVar = 0x7f;\n        }\n        else {\n          loopIndexf (unsignedVar < 0x3c) {\n            pointerVar = &dloopIndexgloopIndextalPloopIndexn;\n            pinNameConflict = (&dloopIndexgloopIndextalPloopIndexn)[unsignedVar];\n          }\n          else {\n            pinNameConflict = NC;\n          }\n          value = ploopIndexnNametoDloopIndexgloopIndextalPloopIndexn(pinNameConflict);\n          loopIndexf (value == 1) {\n            unsignedVar = 0x7f;\n          }\n        }\n      }\n      else {\n        unsignedVar = 0x7f;\n      }\n      floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,unsignedVar,argValues,(sloopIndexze_t)pointerVar);\n    }\n    floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,0xf7,argValues,(sloopIndexze_t)pointerVar);\n    break;\n  case 'k':\n    floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,0xf0,argValues,(sloopIndexze_t)pointerVar);\n    floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,0x6c,argValues,(sloopIndexze_t)pointerVar);\n    for (unsignedVar = 0; unsignedVar < 0x3c; unsignedVar = unsignedVar + 1 & 0xff) {\n      loopIndexf (unsignedVar < 0x3c) {\n        loopIndexf ((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar] == NC) {\n          sizeVar = 0;\n        }\n        else {\n          value = ploopIndexnNametoDloopIndexgloopIndextalPloopIndexn((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar]);\n          loopIndexf (value == 0) {\n            sizeVar = 0;\n          }\n          else {\n            value = ploopIndexnNametoDloopIndexgloopIndextalPloopIndexn((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar]);\n            loopIndexf (value == 1) {\n              sizeVar = 0;\n            }\n            else {\n              sizeVar = 1;\n            }\n          }\n        }\n      }\n      else {\n        sizeVar = 0;\n      }\n      loopIndexf (sizeVar != 0) {\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,0,argValues,sizeVar);\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,1,argValues,sizeVar);\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,0xb,argValues,sizeVar);\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,1,argValues,sizeVar);\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,1,argValues,sizeVar);\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,1,argValues,sizeVar);\n      }\n      loopIndexf ((unsignedVar - 0x2e & 0xff) < 0xe) {\n        loopIndexf (unsignedVar < 0x3c) {\n          pinNameConflict = (&dloopIndexgloopIndextalPloopIndexn)[unsignedVar];\n        }\n        else {\n          pinNameConflict = NC;\n        }\n        value = ploopIndexnNametoDloopIndexgloopIndextalPloopIndexn(pinNameConflict);\n        loopIndexf (value == 0) {\n          undefinedVar = (undefloopIndexned1 *)0x0;\n        }\n        else {\n          loopIndexf (unsignedVar < 0x3c) {\n            pinNameConflict = (&dloopIndexgloopIndextalPloopIndexn)[unsignedVar];\n          }\n          else {\n            pinNameConflict = NC;\n          }\n          value = ploopIndexnNametoDloopIndexgloopIndextalPloopIndexn(pinNameConflict);\n          loopIndexf (value == 1) {\n            undefinedVar = (undefloopIndexned1 *)0x0;\n          }\n          else {\n            undefinedVar = (undefloopIndexned1 *)0x1;\n          }\n        }\n      }\n      else {\n        undefinedVar = (undefloopIndexned1 *)0x0;\n      }\n      loopIndexf (undefinedVar != (undefloopIndexned1 *)0x0) {\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,2,argValues,(sloopIndexze_t)undefinedVar);\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,10,argValues,(sloopIndexze_t)undefinedVar);\n      }\n      loopIndexf (unsignedVar < 0x3c) {\n        undefinedVar = &dloopIndexgloopIndextalPloopIndexn;\n        loopIndexf ((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar] == NC) {\n          isPinInMap = false;\n        }\n        else {\n          value = ploopIndexnNametoDloopIndexgloopIndextalPloopIndexn((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar]);\n          loopIndexf (value == 0) {\n            isPinInMap = false;\n          }\n          else {\n            undefinedVar = &dloopIndexgloopIndextalPloopIndexn;\n            value = ploopIndexnNametoDloopIndexgloopIndextalPloopIndexn((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar]);\n            loopIndexf (value == 1) {\n              isPinInMap = false;\n            }\n            else {\n              undefinedVar = &dloopIndexgloopIndextalPloopIndexn;\n              isPinInMap = ploopIndexn_loopIndexn_ploopIndexnmap((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar],(PloopIndexnMap_conflloopIndexct *)&PloopIndexnMap_PWM);\n            }\n          }\n        }\n      }\n      else {\n        isPinInMap = false;\n      }\n      loopIndexf (isPinInMap != false) {\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,3,argValues,(sloopIndexze_t)undefinedVar);\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,8,argValues,(sloopIndexze_t)undefinedVar);\n      }\n      loopIndexf (unsignedVar < 0x3c) {\n        loopIndexf ((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar] == NC) {\n          sizeVar = 0;\n        }\n        else {\n          value = ploopIndexnNametoDloopIndexgloopIndextalPloopIndexn((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar]);\n          loopIndexf (value == 0) {\n            sizeVar = 0;\n          }\n          else {\n            value = ploopIndexnNametoDloopIndexgloopIndextalPloopIndexn((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar]);\n            loopIndexf (value == 1) {\n              sizeVar = 0;\n            }\n            else {\n              sizeVar = 1;\n            }\n          }\n        }\n      }\n      else {\n        sizeVar = 0;\n      }\n      loopIndexf (sizeVar != 0) {\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,4,argValues,sizeVar);\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,0xe,argValues,sizeVar);\n      }\n      loopIndexf (unsignedVar < 0x3c) {\n        loopIndexf ((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar] == NC) {\n          pointerVar = (undefloopIndexned1 *)0x0;\n        }\n        else {\n          value = ploopIndexnNametoDloopIndexgloopIndextalPloopIndexn((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar]);\n          loopIndexf (value == 0) {\n            pointerVar = (undefloopIndexned1 *)0x0;\n          }\n          else {\n            value = ploopIndexnNametoDloopIndexgloopIndextalPloopIndexn((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar]);\n            loopIndexf (value == 1) {\n              pointerVar = (undefloopIndexned1 *)0x0;\n            }\n            else {\n              isPinInMap = ploopIndexn_loopIndexn_ploopIndexnmap((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar],(PloopIndexnMap_conflloopIndexct *)&PloopIndexnMap_I2C_SDA);\n              pointerVar = (undefloopIndexned1 *)(uloopIndexnt)isPinInMap;\n              loopIndexf (pointerVar == (undefloopIndexned1 *)0x0) {\n                isPinInMap = ploopIndexn_loopIndexn_ploopIndexnmap((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar],(PloopIndexnMap_conflloopIndexct *)&PloopIndexnMap_I2C_SCL);\n                pointerVar = (undefloopIndexned1 *)(uloopIndexnt)isPinInMap;\n              }\n            }\n          }\n        }\n      }\n      else {\n        pointerVar = (undefloopIndexned1 *)0x0;\n      }\n      loopIndexf (pointerVar != (undefloopIndexned1 *)0x0) {\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,6,argValues,(sloopIndexze_t)pointerVar);\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,1,argValues,(sloopIndexze_t)pointerVar);\n      }\n      floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,0x7f,argValues,(sloopIndexze_t)pointerVar);\n    }\n    floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,0xf7,argValues,(sloopIndexze_t)pointerVar);\n    return;\n  case 'm':\n    loopIndexf (unsignedVar != 0) {\n      byteVar1 = *argValues;\n      floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,0xf0,argValues,(sloopIndexze_t)pointerVar);\n      floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,0x6e,argValues,(sloopIndexze_t)pointerVar);\n      floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,(uloopIndexnt)byteVar1,argValues,(sloopIndexze_t)pointerVar);\n      loopIndexf (byteVar1 < 0x3c) {\n        byteVar7 = floopIndexrmata::FloopIndexrmataClass::getPloopIndexnMode(&FloopIndexrmata,byteVar1);\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,(uloopIndexnt)byteVar7,argValues,(sloopIndexze_t)pointerVar);\n        unsignedVar = floopIndexrmata::FloopIndexrmataClass::getPloopIndexnState(&FloopIndexrmata,byteVar1);\n        floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,unsignedVar & 0x7f,argValues,(sloopIndexze_t)pointerVar);\n        unsignedVar = floopIndexrmata::FloopIndexrmataClass::getPloopIndexnState(&FloopIndexrmata,byteVar1);\n        pointerVar = (undefloopIndexned1 *)0xff80;\n        loopIndexf ((unsignedVar & 0xff80) != 0) {\n          index = floopIndexrmata::FloopIndexrmataClass::getPloopIndexnState(&FloopIndexrmata,byteVar1);\n          floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,(uloopIndexnt)(index << 0x12) >> 0x19,argValues,(sloopIndexze_t)pointerVar);\n        }\n        unsignedVar = floopIndexrmata::FloopIndexrmataClass::getPloopIndexnState(&FloopIndexrmata,byteVar1);\n        loopIndexf ((unsignedVar & 0xc000) != 0) {\n          index = floopIndexrmata::FloopIndexrmataClass::getPloopIndexnState(&FloopIndexrmata,byteVar1);\n          floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,(uloopIndexnt)(index << 0xb) >> 0x19,argValues,(sloopIndexze_t)pointerVar);\n        }\n      }\n      floopIndexrmata::FloopIndexrmataClass::wrloopIndexte(&FloopIndexrmata,0xf7,argValues,(sloopIndexze_t)pointerVar);\n      return;\n    }\n    break;\n  case 'o':\n    loopIndexf (1 < unsignedVar) {\n      unsignedVar = (uloopIndexnt)argValues[1];\n      loopIndexf (2 < unsignedVar) {\n        unsignedVar = unsignedVar | (uloopIndexnt)argValues[2] << 7;\n      }\n      loopIndexf (3 < unsignedVar) {\n        unsignedVar = unsignedVar | (uloopIndexnt)argValues[3] << 0xe;\n      }\n      analogWrloopIndexteCallback(*argValues,unsignedVar);\n      return;\n    }\n    break;\n  case 'p':\n    loopIndexf (4 < unsignedVar) {\n      byteVar1 = *argValues;\n      unsignedVar = (uloopIndexnt)byteVar1;\n      byteVar7 = argValues[1];\n      byteVar2 = argValues[2];\n      byteVar3 = argValues[3];\n      byteVar4 = argValues[4];\n      loopIndexf (unsignedVar < 0x3c) {\n        loopIndexf ((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar] == NC) {\n          boolVar = false;\n        }\n        else {\n          value = ploopIndexnNametoDloopIndexgloopIndextalPloopIndexn((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar]);\n          loopIndexf (value == 0) {\n            boolVar = false;\n          }\n          else {\n            value = ploopIndexnNametoDloopIndexgloopIndextalPloopIndexn((&dloopIndexgloopIndextalPloopIndexn)[unsignedVar]);\n            loopIndexf (value == 1) {\n              boolVar = false;\n            }\n            else {\n              boolVar = true;\n            }\n          }\n        }\n      }\n      else {\n        boolVar = false;\n      }\n      loopIndexf (boolVar) {\n        loopIndexf (servoPloopIndexnMap[unsignedVar] < 0xc) {\n          boolVar = Servo::attached(servos + servoPloopIndexnMap[unsignedVar]);\n        }\n        else {\n          boolVar = false;\n        }\n        loopIndexf (boolVar != false) {\n          detachServo(byteVar1);\n        }\n        attachServo(byteVar1,(uloopIndexnt)byteVar7 + (uloopIndexnt)byteVar2 * 0x80,(uloopIndexnt)byteVar3 + (uloopIndexnt)byteVar4 * 0x80);\n        setPloopIndexnModeCallback(byteVar1,4);\n        return;\n      }\n    }\n    break;\n  case 'v':\n    byteVar1 = argValues[1];\n    loopIndexf ((byteVar1 & 0x20) != 0) {\n      floopIndexrmata::FloopIndexrmataClass::sendStrloopIndexng(&FloopIndexrmata,\"10-bloopIndext deviceAddressloopIndexng not supported\");\n      return;\n    }\n    deviceAddress = *argValues;\n    boolVar = (byteVar1 & 0x40) == 0;\n    loopIndexf ((byteVar1 & 0x18) < 0x19) {\n      swloopIndextch(byteVar1 & 0x18) {\n      case 0:\n        TwoWloopIndexre::begloopIndexnTransmloopIndexssloopIndexon(&WloopIndexre,deviceAddress);\n        for (unsignedVar = 2; unsignedVar < unsignedVar; unsignedVar = unsignedVar + 2 & 0xff) {\n          wloopIndexreWrloopIndexte(argValues[unsignedVar + 1] * -0x80 + argValues[unsignedVar]);\n        }\n        TwoWloopIndexre::endTransmloopIndexssloopIndexon(&WloopIndexre);\n        return;\n      case 8:\n        loopIndexf (unsignedVar == 6) {\n          index = (uloopIndexnt)argValues[2] + (uloopIndexnt)argValues[3] * 0x80;\n          byteVar10 = argValues[4] + argValues[5] * -0x80;\n        }\n        else {\n          byteVar10 = argValues[2] + argValues[3] * -0x80;\n          index = -1;\n        }\n        readAndReportData(deviceAddress,index,byteVar10,boolVar);\n        return;\n      case 0x10:\n        loopIndexf (queryIndex + 1 < 8) {\n          loopIndexf (unsignedVar == 6) {\n            index = (uloopIndexnt)argValues[2] + (uloopIndexnt)argValues[3] * 0x80;\n            byteVar10 = argValues[4] + argValues[5] * -0x80;\n          }\n          else {\n            byteVar10 = argValues[2] + argValues[3] * -0x80;\n            index = -1;\n          }\n          queryIndex = queryIndex + '\\x01';\n          index = (loopIndexnt)queryIndex;\n          query[index].addr = deviceAddress;\n          query[index].reg = index;\n          query[index].bytes = byteVar10;\n          *(bool *)(index * 0xc + 0x20000191) = boolVar;\n          return;\n        }\n        floopIndexrmata::FloopIndexrmataClass::sendStrloopIndexng(&FloopIndexrmata,\"too many querloopIndexes\");\n        return;\n      case 0x18:\n        loopIndexf (queryIndex < 1) {\n          queryIndex = -1;\n          return;\n        }\n      }\n      for (unsignedVar = 0; index = queryIndex + 1, (loopIndexnt)unsignedVar < index; unsignedVar = unsignedVar + 1 & 0xff) {\n        loopIndexf (deviceAddress == query[unsignedVar].addr) goto LAB_08001e66;\n      }\n      unsignedVar = 0;\nLAB_08001e66:\n      for (; (loopIndexnt)unsignedVar < index; unsignedVar = unsignedVar + 1 & 0xff) {\n        loopIndexf (unsignedVar < 8) {\n          index = unsignedVar + 1;\n          query[unsignedVar].addr = query[index].addr;\n          query[unsignedVar].reg = query[index].reg;\n          query[unsignedVar].bytes = query[index].bytes;\n          query[unsignedVar].stopTransmission = query[index].stopTransmission;\n        }\n      }\n      queryIndex = queryIndex + -1;\n      return;\n    }\n    break;\n  case 'x':\n    unsignedVar = (uloopIndexnt)*argValues + (uloopIndexnt)argValues[1] * 0x80;\n    loopIndexf ((1 < unsignedVar) && (unsignedVar != 0)) {\n      loopIndex2cReadDelayTloopIndexme = unsignedVar;\n    }\n    loopIndexf (!loopIndexsI2CEnabled) {\n      enableI2CPloopIndexns();\n      return;\n    }\n    break;\n  case 'z':\n    loopIndexf ((1 < unsignedVar) &&\n       (samplloopIndexngIntervalue = (uloopIndexnt)*argValues + (uloopIndexnt)argValues[1] * 0x80, samplloopIndexngIntervalue == 0)) {\n      samplloopIndexngIntervalue = 1;\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cd0": "process_command_08001cd0",
                "command": "cmd",
                "argc": "argCount",
                "argv": "argValues",
                "bVar1": "byteVar1",
                "address": "deviceAddress",
                "bVar2": "byteVar2",
                "bVar3": "byteVar3",
                "bVar4": "byteVar4",
                "PVar5": "pinNameConflict",
                "_Var6": "isPinInMap",
                "bVar7": "byteVar7",
                "uVar8": "value",
                "iVar9": "index",
                "val": "value",
                "mode": "pinMode",
                "bVar10": "byteVar10",
                "stopTX": "stopTransmission",
                "i": "loopIndex",
                "i_1": "loopIndex1",
                "in_r3": "pointerVar",
                "uVar11": "unsignedVar",
                "pin_1": "pin1",
                "__n": "undefinedVar",
                "sVar12": "sizeVar",
                "maxPulse": "maximumPulse",
                "uVar13": "unsignedVar",
                "minPulse": "minimumPulse",
                "iVar14": "index",
                "bVar15": "boolVar"
            },
            "calling": [],
            "called": [
                "attached",
                "analogWriteCallback",
                "beginTransmission",
                "readAndReportData",
                "write",
                "getPinState",
                "endTransmission",
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "setPinModeCallback",
                "detachServo",
                "getPinMode",
                "sendString",
                "attachServo",
                "wireWrite",
                "enableI2CPins"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080022f8": {
            "entrypoint": "0x080022f8",
            "current_name": "process_digital_inputs_080022f8",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd processDigitalInputs_080022f8(voindexd)\n\n{\n  bool isPinDigital;\n  PindexnName_conflindexct pinName;\n  byte pinMode;\n  indexnt availableCount;\n  uindexnt32_t digitalPin;\n  byte index;\n  uindexnt loopIndex;\n  byte analogPindexn;\n  uindexnt digitalPinIndex;\n  \n  checkDindexgindextalInputs();\n  whindexle (availableCount = findexrmata::FindexrmataClass::avaindexlable(&Findexrmata), availableCount != 0) {\n    findexrmata::FindexrmataClass::processInput(&Findexrmata);\n  }\n  currentMindexllindexs = mindexllindexs();\n  indexf (samplindexngInterval < currentMindexllindexs - previndexousMindexllindexs) {\n    previndexousMindexllindexs = previndexousMindexllindexs + samplindexngInterval;\n    for (loopIndex = 0; loopIndex < 0x3c; loopIndex = loopIndex + 1 & 0xff) {\n      digitalPinIndex = loopIndex - 0x2e & 0xff;\n      indexf (digitalPinIndex < 0xe) {\n        indexf (loopIndex < 0x3c) {\n          pinName = (&dindexgindextalPindexn)[loopIndex];\n        }\n        else {\n          pinName = NC;\n        }\n        digitalPin = pindexnNametoDindexgindextalPindexn(pinName);\n        indexf (digitalPin == 0) {\n          isPinDigital = false;\n        }\n        else {\n          indexf (loopIndex < 0x3c) {\n            pinName = (&dindexgindextalPindexn)[loopIndex];\n          }\n          else {\n            pinName = NC;\n          }\n          digitalPin = pindexnNametoDindexgindextalPindexn(pinName);\n          indexf (digitalPin == 1) {\n            isPinDigital = false;\n          }\n          else {\n            pinMode = findexrmata::FindexrmataClass::getPindexnMode(&Findexrmata,(byte)loopIndex);\n            indexf (pinMode == '\\x02') {\n              isPinDigital = true;\n            }\n            else {\n              isPinDigital = false;\n            }\n          }\n        }\n      }\n      else {\n        isPinDigital = false;\n      }\n      indexf ((isPinDigital) && ((analogInputsToReport >> digitalPinIndex & 1U) != 0)) {\n        digitalPin = analogRead(digitalPinIndex);\n        findexrmata::FindexrmataClass::sendAnalog(&Findexrmata,(byte)digitalPinIndex,digitalPin);\n      }\n    }\n    indexf (-1 < queryIndex) {\n      for (loopIndex = 0; (indexnt)loopIndex < queryIndex + 1; loopIndex = loopIndex + 1 & 0xff) {\n        readAndReportData(query[loopIndex].addr,query[loopIndex].reg,query[loopIndex].bytes,query[loopIndex].stopTX)\n        ;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080022f8": "process_digital_inputs_080022f8",
                "bVar1": "isPinDigital",
                "PVar2": "pinName",
                "bVar3": "pinMode",
                "iVar4": "availableCount",
                "uVar5": "digitalPin",
                "i": "index",
                "uVar6": "loopIndex",
                "ulPin": "digitalPinIndex"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available",
                "analogRead",
                "millis",
                "pinNametoDigitalPin",
                "sendAnalog",
                "checkDigitalInputs",
                "getPinMode",
                "readAndReportData",
                "processInput"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002400": {
            "entrypoint": "0x08002400",
            "current_name": "check_servo_pin_status_08002400",
            "code": "\n/* WARNING: Unknown calling convention */\n\nboolean checkServoPinStatus_08002400(timer16_Sequence_t timer)\n\n{\n  uint index;\n  \n  index = 0;\n  while( true ) {\n    if (0xb < index) {\n      return false;\n    }\n    if (((byte)servos[(uint)timer * 0xc + index].Pin & 0x40) != 0) break;\n    index = index + 1 & 0xff;\n  }\n  return true;\n}\n\n",
            "renaming": {
                "FUN_08002400": "check_servo_pin_status_08002400",
                "uVar1": "index"
            },
            "calling": [
                "attach",
                "detach"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800242c": {
            "entrypoint": "0x0800242c",
            "current_name": "initialize_pulse_timer_0800242c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePulseTimer_0800242c(stimer_t *pulseTimer)\n\n{\n  initializeTimerPulse((timerConfig *)pulseTimer,60000,0x5dc,irqHandler + 1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800242c": "initialize_pulse_timer_0800242c",
                "obj": "pulseTimer",
                "TimerPulseInit": "initializeTimerPulse",
                "stimer_t_conflict": "timerConfig",
                "ServoIrqHandle": "irqHandler"
            },
            "calling": [
                "attach"
            ],
            "called": [
                "TimerPulseInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002444": {
            "entrypoint": "0x08002444",
            "current_name": "update_servo_position_08002444",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateServoPosition_08002444(stimer_t *servo,uint32_t servoChannel)\n\n{\n  bool isPinSet;\n  uint32_t counterValue;\n  int offset;\n  uint index;\n  \n  index = (uint)servo->idx;\n  if ((timerChannel[index] & 0x80U) == 0) {\n    offset = index * 0xc;\n    if (timerChannel[index] + offset < (int)(uint)ServoCount) {\n      if (((byte)servos[timerChannel[index] + offset].Pin & 0x40) == 0) {\n        isPinSet = false;\n      }\n      else {\n        isPinSet = true;\n      }\n    }\n    else {\n      isPinSet = false;\n    }\n    if (isPinSet) {\n      digitalWrite((byte)servos[offset + timerChannel[index]].Pin & 0x3f,0);\n    }\n  }\n  else {\n    setTimerCounter((stimer_t_conflict *)servo,0);\n  }\n  timerChannel[index] = timerChannel[index] + '\\x01';\n  offset = index * 0xc;\n  if (timerChannel[index] + offset < (int)(uint)ServoCount) {\n    if (timerChannel[index] < '\\f') {\n      isPinSet = true;\n    }\n    else {\n      isPinSet = false;\n    }\n  }\n  else {\n    isPinSet = false;\n  }\n  if (isPinSet) {\n    if (((byte)servos[timerChannel[index] + offset].Pin & 0x40) != 0) {\n      digitalWrite((byte)servos[timerChannel[index] + offset].Pin & 0x3f,1);\n    }\n    counterValue = getTimerCounter((stimer_t_conflict *)servo);\n    setCCRRegister((stimer_t_conflict *)servo,servoChannel,\n                   servos[offset + timerChannel[index]].ticks + counterValue);\n    return;\n  }\n  counterValue = getTimerCounter((stimer_t_conflict *)servo);\n  if (counterValue + 4 < 20000) {\n    setCCRRegister((stimer_t_conflict *)servo,servoChannel,20000);\n  }\n  else {\n    counterValue = getTimerCounter((stimer_t_conflict *)servo);\n    setCCRRegister((stimer_t_conflict *)servo,servoChannel,counterValue + 4);\n  }\n  timerChannel[index] = -1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002444": "update_servo_position_08002444",
                "obj": "servo",
                "channel": "servoChannel",
                "bVar1": "isPinSet",
                "uVar2": "counterValue",
                "iVar3": "offset",
                "uVar4": "index"
            },
            "calling": [],
            "called": [
                "digitalWrite",
                "setCCRRegister",
                "setTimerCounter",
                "getTimerCounter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002578": {
            "entrypoint": "0x08002578",
            "current_name": "deinit_timer_pulse_08002578",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid deinitTimerPulse_08002578(stimer_t *timerObject)\n\n{\n  TimerPulseDeinit((stimer_t_conflict *)timerObject);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002578": "deinit_timer_pulse_08002578",
                "obj": "timerObject"
            },
            "calling": [
                "detach"
            ],
            "called": [
                "TimerPulseDeinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002580": {
            "entrypoint": "0x08002580",
            "current_name": "initialize_servo_08002580",
            "code": "\n/* DWARF original prototype: Servo *  Servo(Servo * servo) */\n\nServo * __servocall Servo::initializeServo_08002580(Servo *servo)\n\n{\n  uint8_t newServoCount;\n  uint oldServoCount;\n  \n  oldServoCount = (uint)ServoCount;\n  if (0xb < oldServoCount) {\n    servo->servoIndex = 0xff;\n    return servo;\n  }\n  newServoCount = ServoCount + '\\x01';\n  servo->servoIndex = ServoCount;\n  ServoCount = newServoCount;\n  servos[oldServoCount].ticks = 0x5dc;\n  return servo;\n}\n\n",
            "renaming": {
                "this": "servo",
                "uVar1": "newServoCount",
                "uVar2": "oldServoCount",
                "FUN_08002580": "initialize_servo_08002580"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025ac": {
            "entrypoint": "0x080025ac",
            "current_name": "attach_080025ac",
            "code": "\n/* DWARF original prototype: uint8_t  attach_080025ac(Servo * servo, int servoPin, int minValue, int maxValue) */\n\nuint8_t __servocall Servo::attach_080025ac(Servo *servo,int servoPin,int minValue,int maxValue)\n\n{\n  timerSequence timerIndex;\n  boolean isTimerActive;\n  timerSequence timer;\n  int adjustedValue;\n  \n  if (servo->servoIndex < 0xc) {\n    servoPinMode(servoPin,1);\n    servos[servo->servoIndex].Pin =\n         (ServoPin_t)((byte)servos[servo->servoIndex].Pin & 0xc0 | (byte)servoPin & 0x3f);\n    adjustedValue = -minValue + 0x220;\n    if (adjustedValue < 0) {\n      adjustedValue = -minValue + 0x223;\n    }\n    servo->minValue = (int8_t)((uint)(adjustedValue << 0x16) >> 0x18);\n    adjustedValue = -maxValue + 0x960;\n    if (adjustedValue < 0) {\n      adjustedValue = -maxValue + 0x963;\n    }\n    servo->maxValue = (int8_t)((uint)(adjustedValue << 0x16) >> 0x18);\n    timerIndex = servo->servoIndex / 0xc;\n    isTimerActive = isTimerActive(timerIndex);\n    if (!isTimerActive) {\n      _timer.idx = timerIndex;\n      initISR(&_timer);\n    }\n    servos[servo->servoIndex].Pin = (ServoPin_t)((byte)servos[servo->servoIndex].Pin | 0x40);\n  }\n  return servo->servoIndex;\n}\n\n",
            "renaming": {
                "FUN_080025ac": "attach_080025ac",
                "this": "servo",
                "pin": "servoPin",
                "min": "minValue",
                "max": "maxValue",
                "timer16_Sequence_t": "timerSequence",
                "bVar1": "isTimerActive",
                "iVar2": "adjustedValue",
                "timer_00": "timerIndex"
            },
            "calling": [
                "attach",
                "attachServo"
            ],
            "called": [
                "isTimerActive",
                "initISR",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002634": {
            "entrypoint": "0x08002634",
            "current_name": "attach_servo_08002634",
            "code": "\n/* DWARF original prototype: uint8_t  attach(Servo * servoInstance, int servoPin) */\n\nuint8_t __servoInstancecall Servo::attachServo_08002634(Servo *servoInstance,int servoPin)\n\n{\n  uint8_t result;\n  \n  result = attach(servoInstance,servoPin,0x220,0x960);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002634": "attach_servo_08002634",
                "this": "servoInstance",
                "pin": "servoPin",
                "uVar1": "result"
            },
            "calling": [
                "attachServo"
            ],
            "called": [
                "attach"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002644": {
            "entrypoint": "0x08002644",
            "current_name": "detach_servo_08002644",
            "code": "\n/* DWARF original prototype: void  detach(Servo * servo) */\n\nvoid __servocall Servo::detachServo_08002644(Servo *servo)\n\n{\n  byte servoIndex;\n  boolean isTimerActive;\n  \n  servoIndex = servo->servoIndex;\n  servoPin = (ServoPin_t)((byte)servoPin & 0xbf);\n  isTimerActive = checkTimerActive(servoIndex / 0xc);\n  if (!isTimerActive) {\n    finISR(&timer);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "servo",
                "bVar1": "servoIndex",
                "bVar2": "isTimerActive",
                "servos": "allServos",
                "servos[bVar1].Pin": "servoPin",
                "isTimerActive": "checkTimerActive",
                "_timer": "timer",
                "FUN_08002644": "detach_servo_08002644"
            },
            "calling": [
                "detachServo"
            ],
            "called": [
                "isTimerActive",
                "finISR"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800267c": {
            "entrypoint": "0x0800267c",
            "current_name": "set_servo_microseconds_0800267c",
            "code": "\n/* DWARF original prototype: void  writeMicroseconds(Servo * servo, int microseconds) */\n\nvoid __servocall Servo::setServoMicroseconds_0800267c(Servo *servo,int microseconds)\n\n{\n  uint minTicks;\n  int maxTicks;\n  \n  if (servo->servoIndex < 0xc) {\n    minTicks = (0x88 - servo->min) * 4;\n    if ((minTicks - microseconds == 0 || (int)minTicks < microseconds) &&\n       (maxTicks = 600 - servo->max, minTicks = maxTicks * 4,\n       microseconds == minTicks || microseconds + maxTicks * -4 < 0 != SBORROW4(microseconds,minTicks))) {\n      minTicks = microseconds;\n    }\n    servos[servo->servoIndex].ticks = minTicks;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800267c": "set_servo_microseconds_0800267c",
                "this": "servo",
                "value": "microseconds",
                "uVar1": "minTicks",
                "iVar2": "maxTicks"
            },
            "calling": [
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080026b0": {
            "entrypoint": "0x080026b0",
            "current_name": "map_and_write_servo_080026b0",
            "code": "\n/* DWARF original prototype: void  write(Servo * servo, int value) */\n\nssize_t __servocall Servo::mapAndWriteServo_080026b0(Servo *servo,int fileDescriptor,void *buffer,size_t size)\n\n{\n  if (fileDescriptor < 0x220) {\n    if (fileDescriptor < 0) {\n      fileDescriptor = 0;\n    }\n    else if (0xb4 < fileDescriptor) {\n      fileDescriptor = 0xb4;\n    }\n    fileDescriptor = mapRange(fileDescriptor,0,0xb4,(0x88 - servo->servoMin) * 4,(600 - servo->servoMax) * 4);\n  }\n  writeToMicroseconds(servo,fileDescriptor);\n  return result;\n}\n\n",
            "renaming": {
                "this": "servo",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "size",
                "map": "mapRange",
                "min": "servoMin",
                "max": "servoMax",
                "writeMicroseconds": "writeToMicroseconds",
                "(ssize_t)this": "result",
                "FUN_080026b0": "map_and_write_servo_080026b0"
            },
            "calling": [
                "analogWriteCallback"
            ],
            "called": [
                "writeMicroseconds",
                "map"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080026f8": {
            "entrypoint": "0x080026f8",
            "current_name": "is_servo_attached_080026f8",
            "code": "\n/* DWARF original prototype: bool  attached(Servo * servo) */\n\nbool __servocall Servo::isServoAttached_080026f8(Servo *servo)\n\n{\n  return SUB41(((uint)(byte)servoList[servo->index].Pin << 0x19) >> 0x1f,0);\n}\n\n",
            "renaming": {
                "FUN_080026f8": "is_servo_attached_080026f8",
                "this": "servo",
                "servos": "servoList",
                "servoIndex": "index"
            },
            "calling": [
                "setPinModeCallback",
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800270c": {
            "entrypoint": "0x0800270c",
            "current_name": "calculate_available_0800270c",
            "code": "\n/* DWARF original prototype: int  available(TwoWire * wire) */\n\nint __wirecall TwoWire::calculateAvailable_0800270c(TwoWire *wire)\n\n{\n  return (uint)bufferLength - (uint)bufferIndex;\n}\n\n",
            "renaming": {
                "FUN_0800270c": "calculate_available_0800270c",
                "this": "wire",
                "rxBufferLength": "bufferLength",
                "rxBufferIndex": "bufferIndex"
            },
            "calling": [
                "readAndReportData"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002720": {
            "entrypoint": "0x08002720",
            "current_name": "read_from_rx_buffer_08002720",
            "code": "\n/* DWARF original prototype: int  read(TwoWire * this) */\n\nssize_t classMember TwoWire::readFromRxBuffer_08002720(TwoWire *this,int fileDescriptor,void *buffer,size_t numberOfBytes)\n\n{\n  uint currentIndex;\n  \n  currentIndex = (uint)currentIndex;\n  if (currentIndex < bufferLength) {\n    currentIndex = currentIndex + '\\x01';\n    return (uint)buffer[currentIndex];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08002720": "read_from_rx_buffer_08002720",
                "__thiscall": "classMember",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numberOfBytes",
                "uVar1": "currentIndex",
                "rxBufferIndex": "currentIndex",
                "rxBufferLength": "bufferLength",
                "rxBuffer": "buffer"
            },
            "calling": [
                "wireRead"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800274c": {
            "entrypoint": "0x0800274c",
            "current_name": "peek_data_0800274c",
            "code": "\n/* DWARF original prototype: int  peek(TwoWire * wireInstance) */\n\nint __wireInstancecall TwoWire::peekData_0800274c(TwoWire *wireInstance)\n\n{\n  if ((uint)bufferIndex < (uint)bufferLength) {\n    return (uint)buffer[bufferIndex];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_0800274c": "peek_data_0800274c",
                "this": "wireInstance",
                "rxBufferIndex": "bufferIndex",
                "rxBufferLength": "bufferLength",
                "rxBuffer": "buffer"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002774": {
            "entrypoint": "0x08002774",
            "current_name": "handle_on_request_08002774",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TwoWire::handleOnRequest_08002774(void)\n\n{\n  if (requestHandler != (_func_void *)0x0) {\n    bufferIndex = '\\0';\n    bufferLength = '\\0';\n    (*requestHandler)();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002774": "handle_on_request_08002774",
                "user_onRequest": "requestHandler",
                "txBufferIndex": "bufferIndex",
                "txBufferLength": "bufferLength"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002798": {
            "entrypoint": "0x08002798",
            "current_name": "clear_buffer_08002798",
            "code": "\n/* DWARF original prototype: void  flush(TwoWire * this) */\n\nvoid __thiscall TwoWire::clearBuffer_08002798(TwoWire *this)\n\n{\n  bufferIndex = '\\0';\n  bufferLength = '\\0';\n  if (receiveBuffer != (uint8_t *)0x0) {\n    memset(receiveBuffer,0,(uint)receiveBufferAllocated);\n  }\n  transmitBufferIndex = '\\0';\n  transmitBufferLength = '\\0';\n  if (transmitBuffer != (uint8_t *)0x0) {\n    memset(transmitBuffer,0,(uint)transmitBufferAllocated);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002798": "clear_buffer_08002798",
                "rxBufferIndex": "bufferIndex",
                "rxBufferLength": "bufferLength",
                "rxBuffer": "receiveBuffer",
                "rxBufferAllocated": "receiveBufferAllocated",
                "txBufferIndex": "transmitBufferIndex",
                "txBufferLength": "transmitBufferLength",
                "txBuffer": "transmitBuffer"
            },
            "calling": [],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f0": {
            "entrypoint": "0x080027f0",
            "current_name": "write_data_080027f0",
            "code": "\n/* DWARF original prototype: size_t  write(TwoWire * wire, uint8_t * data, size_t quantity) */\n\nssize_t __wirecall TwoWire::write_data_080027f0(TwoWire *wire,int file_descriptor,void *buffer,size_t quantity)\n\n{\n  i2c_status_e_conflict status;\n  size_t new_size;\n  \n  if (is_transmitting == '\\0') {\n    status = i2c_write((i2c_t_conflict *)&wire->_i2c,(uint8_t *)file_descriptor,(uint16_t)buffer);\n    if (status == I2C_SUCCESS) {\n      return (ssize_t)buffer;\n    }\n    return 0;\n  }\n  new_size = (uint)buffer_length + (int)buffer;\n  if (allocated_buffer_size < new_size) {\n    if (new_size < 0x20) {\n      new_size = 0x20;\n    }\n    transmit_buffer = (uint8_t *)realloc(transmit_buffer,new_size);\n    if (transmit_buffer == (uint8_t *)0x0) {\n      allocated_buffer_size = '\\0';\n    }\n    else {\n      allocated_buffer_size = (uint8_t)new_size;\n    }\n  }\n  if (transmit_buffer == (uint8_t *)0x0) {\n    (wire->super_Stream).super_Print.write_error = 1;\n    return 0;\n  }\n  memcpy(transmit_buffer + buffer_index,(void *)file_descriptor,(size_t)buffer);\n  buffer_index = buffer_index + (char)buffer;\n  buffer_length = buffer_index;\n  return (ssize_t)buffer;\n}\n\n",
            "renaming": {
                "FUN_080027f0": "write_data_080027f0",
                "this": "wire",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "quantity",
                "iVar1": "status",
                "__size": "new_size",
                "transmitting": "is_transmitting",
                "i2c_slave_write_IT": "i2c_write",
                "I2C_OK": "I2C_SUCCESS",
                "txBufferLength": "buffer_length",
                "txBufferAllocated": "allocated_buffer_size",
                "txBuffer": "transmit_buffer",
                "txBufferIndex": "buffer_index"
            },
            "calling": [],
            "called": [
                "i2c_slave_write_IT",
                "realloc",
                "memcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800288c": {
            "entrypoint": "0x0800288c",
            "current_name": "write_data_0800288c",
            "code": "\n/* DWARF original prototype: unsignedSize  write(TwoWire * wireInstance, uint8_t data) */\n\nsignedSize __wireInstancecall TwoWire::writeData_0800288c(TwoWire *wireInstance,int fileDescriptor,void *buffer,unsignedSize bufferSize)\n\n{\n  i2cStatus iVar1;\n  signedSize sVar2;\n  unsignedSize __size;\n  uint8_t data;\n  \n  data = (uint8_t)fileDescriptor;\n  if (isTransmitting == '\\0') {\n    iVar1 = i2cSlaveWrite((i2c_t_conflict *)&wireInstance->_i2c,&data,1);\n    if (iVar1 == i2cOk) {\n      sVar2 = 1;\n    }\n    else {\n      sVar2 = 0;\n    }\n  }\n  else {\n    __size = transmitBufferLength + 1;\n    if (transmitBufferAllocated < __size) {\n      if (__size < 0x20) {\n        __size = 0x20;\n      }\n      transmitBuffer = (uint8_t *)realloc(transmitBuffer,__size);\n      if (transmitBuffer == (uint8_t *)0x0) {\n        transmitBufferAllocated = '\\0';\n      }\n      else {\n        transmitBufferAllocated = (uint8_t)__size;\n      }\n    }\n    if (transmitBuffer == (uint8_t *)0x0) {\n      (wireInstance->super_Stream).super_Print.write_error = 1;\n      sVar2 = 0;\n    }\n    else {\n      transmitBuffer[transmitBufferIndex] = data;\n      transmitBufferIndex = transmitBufferIndex + '\\x01';\n      sVar2 = 1;\n      transmitBufferLength = transmitBufferIndex;\n    }\n  }\n  return sVar2;\n}\n\n",
            "renaming": {
                "this": "wireInstance",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "bufferSize",
                "i2c_status_e_conflict": "i2cStatus",
                "ssize_t": "signedSize",
                "size_t": "unsignedSize",
                "local_11": "data",
                "transmitting": "isTransmitting",
                "i2c_slave_write_IT": "i2cSlaveWrite",
                "I2C_OK": "i2cOk",
                "txBufferLength": "transmitBufferLength",
                "txBufferAllocated": "transmitBufferAllocated",
                "txBuffer": "transmitBuffer",
                "txBufferIndex": "transmitBufferIndex",
                "FUN_0800288c": "write_data_0800288c"
            },
            "calling": [
                "wireWrite"
            ],
            "called": [
                "i2c_slave_write_IT",
                "realloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800291c": {
            "entrypoint": "0x0800291c",
            "current_name": "initialize_wire_0800291c",
            "code": "\n/* DWARF original prototype: TwoWire *  TwoWire(TwoWire * wireInstance) */\n\nTwoWire * __wireInstancecall TwoWire::initializeWire_0800291c(TwoWire *wireInstance)\n\n{\n  (wireInstance->super_Stream).super_Print.write_error = 0;\n  (wireInstance->super_Stream)._timeout = 1000;\n  (wireInstance->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&PTR_write_1_0800a5a0;\n  (wireInstance->_i2c).sda = PB_9;\n  (wireInstance->_i2c).scl = PB_8;\n  return wireInstance;\n}\n\n",
            "renaming": {
                "this": "wireInstance",
                "FUN_0800291c": "initialize_wire_0800291c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002948": {
            "entrypoint": "0x08002948",
            "current_name": "initialize_wire_08002948",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeWire_08002948(int isInitialize,int priority)\n\n{\n  if (isInitialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    WireLibrary::WireLibrary(&wireInstance);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002948": "initialize_wire_08002948",
                "__initialize_p": "isInitialize",
                "__priority": "priority",
                "TwoWire": "WireLibrary",
                "Wire": "wireInstance"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN7TwoWire8rxBufferE"
            ],
            "called": [
                "TwoWire"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002968": {
            "entrypoint": "0x08002968",
            "current_name": "initialize_wire_08002968",
            "code": "\n/* DWARF original prototype: void  begin(TwoWire * wire, uint8_t deviceAddress) */\n\nvoid __wirecall TwoWire::initializeWire_08002968(TwoWire *wire,uint8_t deviceAddress)\n\n{\n  uint32_t generatedOwnAddress;\n  i2cHandler *i2cConfig;\n  \n  receiveBufferIndex = '\\0';\n  receiveBufferLength = '\\0';\n  if (receiveBuffer != (uint8_t *)0x0) {\n    memset(receiveBuffer,0,(uint)receiveBufferAllocated);\n  }\n  transmitBufferIndex = '\\0';\n  transmitBufferLength = '\\0';\n  if (transmitBuffer != (uint8_t *)0x0) {\n    memset(transmitBuffer,0,(uint)transmitBufferAllocated);\n  }\n  isTransmitting = '\\0';\n  generatedOwnAddress = (deviceAddress & 0x7f) << 1;\n  wire->generatedOwnAddress = (uint8_t)generatedOwnAddress;\n  if (deviceAddress == 0x33) {\n    wire->master = true;\n  }\n  else {\n    wire->master = false;\n  }\n  i2cConfig = &wire->i2cInstance;\n  initializeI2C((i2cHandler_conflict *)i2cConfig,I2C_100KHz,0x4000,generatedOwnAddress,wire->master);\n  if (wire->master == false) {\n    attachSlaveTransmitEvent((i2cHandler_conflict *)i2cConfig,onRequestHandler + 1);\n    attachSlaveReceiveEvent((i2cHandler_conflict *)i2cConfig,onReceiveHandler + 1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "wire",
                "address": "deviceAddress",
                "ownAddress": "generatedOwnAddress",
                "i2c_t": "i2cHandler",
                "obj": "i2cConfig",
                "rxBufferIndex": "receiveBufferIndex",
                "rxBufferLength": "receiveBufferLength",
                "rxBuffer": "receiveBuffer",
                "rxBufferAllocated": "receiveBufferAllocated",
                "txBufferIndex": "transmitBufferIndex",
                "txBufferLength": "transmitBufferLength",
                "txBuffer": "transmitBuffer",
                "transmitting": "isTransmitting",
                "_i2c": "i2cInstance",
                "i2c_custom_init": "initializeI2C",
                "i2c_attachSlaveTxEvent": "attachSlaveTransmitEvent",
                "i2c_attachSlaveRxEvent": "attachSlaveReceiveEvent",
                "onRequestService": "onRequestHandler",
                "onReceiveService": "onReceiveHandler",
                "FUN_08002968": "initialize_wire_08002968"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "memset",
                "i2c_attachSlaveTxEvent",
                "i2c_attachSlaveRxEvent",
                "i2c_custom_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002a1c": {
            "entrypoint": "0x08002a1c",
            "current_name": "initialize_wire_communication_08002a1c",
            "code": "\n/* DWARF original prototype: void  begin(TwoWire * wireInstance, int deviceAddress) */\n\nvoid __wireInstancecall TwoWire::initializeWireCommunication_08002a1c(TwoWire *wireInstance,int deviceAddress)\n\n{\n  begin(wireInstance,(uint8_t)deviceAddress);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002a1c": "initialize_wire_communication_08002a1c",
                "this": "wireInstance",
                "address": "deviceAddress"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002a26": {
            "entrypoint": "0x08002a26",
            "current_name": "initialize_wire_communication_08002a26",
            "code": "\n/* DWARF original prototype: void  begin(TwoWire * wireObject) */\n\nvoid __wireObjectcall TwoWire::initializeWireCommunication_08002a26(TwoWire *wireObject)\n\n{\n  begin(wireObject,0x33);\n  return;\n}\n\n",
            "renaming": {
                "this": "wireObject",
                "FUN_08002a26": "initialize_wire_communication_08002a26"
            },
            "calling": [
                "enableI2CPins"
            ],
            "called": [
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002a30": {
            "entrypoint": "0x08002a30",
            "current_name": "initialize_transmission_08002a30",
            "code": "\n/* DWARF original prototype: void  beginTransmission(TwoWire * wire, uint8_t deviceAddress) */\n\nvoid __wirecall TwoWire::initializeTransmission_08002a30(TwoWire *wire,uint8_t deviceAddress)\n\n{\n  isTransmitting = '\\x01';\n  transmitAddress = deviceAddress << 1;\n  transmitBufferIndex = '\\0';\n  transmitBufferLength = '\\0';\n  return;\n}\n\n",
            "renaming": {
                "this": "wire",
                "address": "deviceAddress",
                "transmitting": "isTransmitting",
                "txAddress": "transmitAddress",
                "txBufferIndex": "transmitBufferIndex",
                "txBufferLength": "transmitBufferLength",
                "FUN_08002a30": "initialize_transmission_08002a30"
            },
            "calling": [
                "readAndReportData",
                "requestFrom",
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002a58": {
            "entrypoint": "0x08002a58",
            "current_name": "end_transmission_08002a58",
            "code": "\n/* DWARF original prototype: uint8_t  endTransmission_08002a58(TwoWire * wire, uint8_t shouldSendStop) */\n\nuint8_t __wirecall TwoWire::endTransmission_08002a58(TwoWire *wire,uint8_t shouldSendStop)\n\n{\n  i2c_status_e_conflict status;\n  uint8_t result;\n  \n  if (wire->isMaster == false) {\n    result = '\\x04';\n  }\n  else {\n    status = i2c_isMaster_write((i2cType *)&wire->i2cInstance,transmitAddress,transmitBuffer,(ushort)transmitBufferLength\n                            );\n    if (status == I2CStatusOK) {\n      result = '\\0';\n    }\n    else if (status == I2CStatusTimeout) {\n      result = '\\x01';\n    }\n    else {\n      result = '\\x04';\n    }\n    if (transmitBuffer != (uint8_t *)0x0) {\n      memset(transmitBuffer,0,(uint)transmitBufferAllocated);\n    }\n    transmitBufferIndex = '\\0';\n    transmitBufferLength = '\\0';\n    isTransmitting = '\\0';\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002a58": "end_transmission_08002a58",
                "this": "wire",
                "sendStop": "shouldSendStop",
                "iVar1": "status",
                "uVar2": "result",
                "master": "isMaster",
                "i2c_t_conflict": "i2cType",
                "_i2c": "i2cInstance",
                "txAddress": "transmitAddress",
                "txBuffer": "transmitBuffer",
                "txBufferLength": "transmitBufferLength",
                "I2C_OK": "I2CStatusOK",
                "I2C_TIMEOUT": "I2CStatusTimeout",
                "txBufferAllocated": "transmitBufferAllocated",
                "txBufferIndex": "transmitBufferIndex",
                "transmitting": "isTransmitting"
            },
            "calling": [
                "endTransmission",
                "readAndReportData",
                "requestFrom"
            ],
            "called": [
                "memset",
                "i2c_master_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ac0": {
            "entrypoint": "0x08002ac0",
            "current_name": "transmit_data_08002ac0",
            "code": "\n/* DWARF original prototype: uint8_t  endTransmission(TwoWire * wireInstance) */\n\nuint8_t __wireInstancecall TwoWire::transmitData_08002ac0(TwoWire *wireInstance)\n\n{\n  uint8_t transmissionStatus;\n  \n  transmissionStatus = endTransmission(wireInstance,'\\x01');\n  return transmissionStatus;\n}\n\n",
            "renaming": {
                "this": "wireInstance",
                "uVar1": "transmissionStatus",
                "FUN_08002ac0": "transmit_data_08002ac0"
            },
            "calling": [
                "sysexCallback"
            ],
            "called": [
                "endTransmission"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002acc": {
            "entrypoint": "0x08002acc",
            "current_name": "reallocate_rx_buffer_08002acc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TwoWire::reallocateRxBuffer_08002acc(size_t newLength)\n\n{\n  if (bufferSize < newLength) {\n    if (newLength < 0x20) {\n      newLength = 0x20;\n    }\n    buffer = (uint8_t *)realloc(buffer,newLength);\n    if (buffer == (uint8_t *)0x0) {\n      bufferSize = '\\0';\n    }\n    else {\n      bufferSize = (uint8_t)newLength;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002acc": "reallocate_rx_buffer_08002acc",
                "length": "newLength",
                "rxBufferAllocated": "bufferSize",
                "rxBuffer": "buffer"
            },
            "calling": [
                "onReceiveService",
                "requestFrom"
            ],
            "called": [
                "realloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b00": {
            "entrypoint": "0x08002b00",
            "current_name": "handle_received_data_08002b00",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TwoWire::handleReceivedData_08002b00(uint8_t *receivedData,int dataLength)\n\n{\n  if ((onReceiveCallback != (_func_void_int *)0x0) && (bufferLength <= bufferIndex)) {\n    allocateBuffer(dataLength);\n    if (buffer == (uint8_t *)0x0) {\n      handleError(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/libraries/Wire/src/Wire.cpp\"\n                     ,0x183);\n    }\n    memcpy(buffer,receivedData,dataLength);\n    bufferIndex = '\\0';\n    bufferLength = (uint8_t)dataLength;\n    (*onReceiveCallback)(dataLength);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002b00": "handle_received_data_08002b00",
                "inBytes": "receivedData",
                "numBytes": "dataLength",
                "user_onReceive": "onReceiveCallback",
                "rxBufferLength": "bufferLength",
                "rxBufferIndex": "bufferIndex",
                "allocateRxBuffer": "allocateBuffer",
                "rxBuffer": "buffer",
                "_Error_Handler": "handleError"
            },
            "calling": [],
            "called": [
                "_Error_Handler",
                "allocateRxBuffer",
                "memcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b68": {
            "entrypoint": "0x08002b68",
            "current_name": "request_from_08002b68",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08002bb2 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: uint8_t  requestFrom_08002b68(TwoWire * wire, uint8_t deviceAddress, uint8_t dataSize,\n   uint32_t internalAddress, uint8_t addressSize, uint8_t stopBit) */\n\nuint8_t __wirecall\nTwoWire::requestFrom_08002b68(TwoWire *wire,uint8_t deviceAddress,uint8_t dataSize,uint32_t internalAddress,uint8_t addressSize,\n          uint8_t stopBit)\n\n{\n  conflictStatus status;\n  uint size;\n  \n  size = (uint)addressSize;\n  if (wire->master == false) {\n    return '\\0';\n  }\n  allocateReceiveBuffer((uint)dataSize);\n  if (receiveBuffer != (uint8_t *)0x0) {\n    if (size != 0) {\n      startTransmission(wire,deviceAddress);\n      if (3 < size) {\n        size = 3;\n      }\n      while( true ) {\n        if (size == 0) break;\n        (**(wire->super_Stream).super_Print._vptr_Print)\n                  (wire,internalAddress >> ((size - 1 & 0x1f) << 3) & 0xff);\n        size = size - 1 & 0xff;\n      }\n      finishTransmission(wire,'\\0');\n    }\n    status = i2c_master_read((conflictT *)&wire->_i2c,deviceAddress << 1,receiveBuffer,(ushort)dataSize);\n    if (status != I2C_OK) {\n      dataSize = '\\0';\n    }\n    receiveBufferIndex = '\\0';\n    receiveBufferLength = dataSize;\n    return dataSize;\n  }\n  (wire->super_Stream).super_Print.write_error = 1;\n  return '\\0';\n}\n\n",
            "renaming": {
                "FUN_08002b68": "request_from_08002b68",
                "this": "wire",
                "address": "deviceAddress",
                "quantity": "dataSize",
                "iaddress": "internalAddress",
                "isize": "addressSize",
                "sendStop": "stopBit",
                "iVar1": "status",
                "uVar2": "size",
                "rxBuffer": "receiveBuffer",
                "rxBufferIndex": "receiveBufferIndex",
                "rxBufferLength": "receiveBufferLength",
                "allocateRxBuffer": "allocateReceiveBuffer",
                "beginTransmission": "startTransmission",
                "endTransmission": "finishTransmission",
                "i2c_status_e_conflict": "conflictStatus",
                "i2c_t_conflict": "conflictT"
            },
            "calling": [
                "requestFrom"
            ],
            "called": [
                "beginTransmission",
                "i2c_master_read",
                "allocateRxBuffer",
                "endTransmission"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c00": {
            "entrypoint": "0x08002c00",
            "current_name": "request_from_08002c00",
            "code": "\n/* DWARF original prototype: uint8_t  requestFrom_08002c00(TwoWire * wire, uint8_t deviceAddress, uint8_t dataCount,\n   uint8_t sendStop) */\n\nuint8_t __wirecall\nTwoWire::requestFrom_08002c00(TwoWire *wire,uint8_t deviceAddress,uint8_t dataCount,uint8_t sendStop)\n\n{\n  uint8_t result;\n  \n  result = requestFrom_08002c00(wire,deviceAddress,dataCount,0,'\\0',sendStop);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002c00": "request_from_08002c00",
                "this": "wire",
                "address": "deviceAddress",
                "quantity": "dataCount",
                "uVar1": "result"
            },
            "calling": [
                "requestFrom"
            ],
            "called": [
                "requestFrom"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c14": {
            "entrypoint": "0x08002c14",
            "current_name": "read_data_from_slave_08002c14",
            "code": "\n/* DWARF original prototype: uint8_t  requestFrom(TwoWire * wire, uint8_t slaveAddress, uint8_t dataQuantity)\n    */\n\nuint8_t __wirecall TwoWire::readDataFromSlave_08002c14(TwoWire *wire,uint8_t slaveAddress,uint8_t dataQuantity)\n\n{\n  uint8_t result;\n  \n  result = requestFrom(wire,slaveAddress,dataQuantity,'\\x01');\n  return result;\n}\n\n",
            "renaming": {
                "this": "wire",
                "address": "slaveAddress",
                "quantity": "dataQuantity",
                "uVar1": "result",
                "FUN_08002c14": "read_data_from_slave_08002c14"
            },
            "calling": [
                "readAndReportData"
            ],
            "called": [
                "requestFrom"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c1e": {
            "entrypoint": "0x08002c1e",
            "current_name": "initialize_static_data_08002c1e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_08002c1e(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c1e": "initialize_static_data_08002c1e"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2c": {
            "entrypoint": "0x08002c2c",
            "current_name": "handle_analog_command_08002c2c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::handleAnalogCommand_08002c2c(void *data,uint8_t command,uint16_t analogValue)\n\n{\n  if (currentAnalogCallback != (callbackFunction)0x0) {\n    (*currentAnalogCallback)(command,(int)analogValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "param_1": "data",
                "value": "analogValue",
                "FUN_08002c2c": "handle_analog_command_08002c2c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c40": {
            "entrypoint": "0x08002c40",
            "current_name": "handle_firmata_command_08002c40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::handleFirmataCommand_08002c40(void *data,uint8_t commandByte,uint16_t commandValue)\n\n{\n  if (callbackFunctionPointer != (callbackFunction)0x0) {\n    (*callbackFunctionPointer)(commandByte,(int)commandValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "param_1": "data",
                "command": "commandByte",
                "value": "commandValue",
                "currentDigitalCallback": "callbackFunctionPointer",
                "FUN_08002c40": "handle_firmata_command_08002c40"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c54": {
            "entrypoint": "0x08002c54",
            "current_name": "process_firmata_command_08002c54",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::processFirmataCommand_08002c54(void *data,uint8_t pinCommand,uint16_t pinValue)\n\n{\n  if (callback != (callbackFunction)0x0) {\n    (*callback)(pinCommand,(int)pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "param_1": "data",
                "command": "pinCommand",
                "value": "pinValue",
                "currentPinModeCallback": "callback",
                "FUN_08002c54": "process_firmata_command_08002c54"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c68": {
            "entrypoint": "0x08002c68",
            "current_name": "process_pin_value_08002c68",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::processPinValue_08002c68(void *data,uint8_t pinCommand,uint16_t pinValue)\n\n{\n  if (pinValueCallback != (callbackFunction)0x0) {\n    (*pinValueCallback)(pinCommand,(int)pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "param_1": "data",
                "command": "pinCommand",
                "value": "pinValue",
                "currentPinValueCallback": "pinValueCallback",
                "FUN_08002c68": "process_pin_value_08002c68"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c7c": {
            "entrypoint": "0x08002c7c",
            "current_name": "handle_analog_command_08002c7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::handleAnalogCommand_08002c7c(void *data,uint8_t analogCommand,uint16_t analogValue)\n\n{\n  if (reportAnalogCallback != (callbackFunction)0x0) {\n    (*reportAnalogCallback)(analogCommand,(int)analogValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c7c": "handle_analog_command_08002c7c",
                "param_1": "data",
                "command": "analogCommand",
                "value": "analogValue",
                "currentReportAnalogCallback": "reportAnalogCallback"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c90": {
            "entrypoint": "0x08002c90",
            "current_name": "handle_digital_command_08002c90",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::handleDigitalCommand_08002c90(void *dataBuffer,uint8_t digitalCommand,uint16_t digitalValue)\n\n{\n  if (currentReportDigitalCallback != (callbackFunction)0x0) {\n    (*currentReportDigitalCallback)(digitalCommand,(int)digitalValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c90": "handle_digital_command_08002c90",
                "param_1": "dataBuffer",
                "command": "digitalCommand",
                "value": "digitalValue"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca4": {
            "entrypoint": "0x08002ca4",
            "current_name": "process_string_callback_08002ca4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::processStringCallback_08002ca4(void *data,char *string)\n\n{\n  if (currentStringCallback != (stringCallbackFunction)0x0) {\n    (*currentStringCallback)(string);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ca4": "process_string_callback_08002ca4",
                "param_1": "data",
                "c_str": "string"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cb8": {
            "entrypoint": "0x08002cb8",
            "current_name": "handle_sysex_command_08002cb8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::handleSysexCommand_08002cb8(void *data_ptr,uint8_t sysex_command,size_t arg_count,uint8_t *arg_values)\n\n{\n  if (currentSysexCallback != (sysexCallbackFunction)0x0) {\n    (*currentSysexCallback)(sysex_command,(uint8_t)arg_count,arg_values);\n  }\n  return;\n}\n\n",
            "renaming": {
                "param_1": "data_ptr",
                "command": "sysex_command",
                "argc": "arg_count",
                "argv": "arg_values",
                "FUN_08002cb8": "handle_sysex_command_08002cb8"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cd0": {
            "entrypoint": "0x08002cd0",
            "current_name": "handle_system_reset_08002cd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::handleSystemReset_08002cd0(void *callbackFunction)\n\n{\n  if (currentResetCallback != (systemCallbackFunction)0x0) {\n    (*currentResetCallback)();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002cd0": "handle_system_reset_08002cd0",
                "param_1": "callbackFunction",
                "currentSystemResetCallback": "currentResetCallback"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ce0": {
            "entrypoint": "0x08002ce0",
            "current_name": "initialize_firmata_class_08002ce0",
            "code": "\n/* DWARF original prototype: FirmataClass *  FirmataClass(FirmataClass * firmataInstance) */\n\nFirmataClass * __firmataInstancecall firmata::FirmataClass::initializeFirmataClass_08002ce0(FirmataClass *firmataInstance)\n\n{\n  FirmataParserConstructor *parserInstance;\n  \n  FirmataMarshallerConstructor::FirmataMarshallerConstructor(&firmataInstance->marshaller);\n  parserInstance = &firmataInstance->parser;\n  FirmataParserConstructor::FirmataParserConstructor(parserInstance,firmataInstance->parserBuffer,0x40);\n  firmataInstance->versionCount = '\\0';\n  firmataInstance->versionVector = (byte *)0x0;\n  firmataInstance->isBlinkVersionDisabled = false;\n  FirmataParserConstructor::attach(parserInstance,0xe0,analogCallback + 1,(void *)0x0);\n  FirmataParserConstructor::attach(parserInstance,0x90,digitalCallback + 1,(void *)0x0);\n  FirmataParserConstructor::attach(parserInstance,0xc0,reportAnalogCallback + 1,(void *)0x0);\n  FirmataParserConstructor::attach(parserInstance,0xd0,reportDigitalCallback + 1,(void *)0x0);\n  FirmataParserConstructor::attach(parserInstance,0xf4,pinModeCallback + 1,(void *)0x0);\n  FirmataParserConstructor::attach(parserInstance,0xf5,pinValueCallback + 1,(void *)0x0);\n  FirmataParserConstructor::attach(parserInstance,'q',stringCallback + 1,(void *)0x0);\n  FirmataParserConstructor::attach(parserInstance,0xf0,sysexCallback + 1,(void *)0x0);\n  FirmataParserConstructor::attach(parserInstance,'y',reportFirmwareCallback + 1,firmataInstance);\n  FirmataParserConstructor::attach(parserInstance,0xf9,reportVersionCallback + 1,firmataInstance);\n  FirmataParserConstructor::attach(parserInstance,0xff,systemResetCallback + 1,(void *)0x0);\n  return firmataInstance;\n}\n\n",
            "renaming": {
                "FUN_08002ce0": "initialize_firmata_class_08002ce0",
                "this": "firmataInstance",
                "this_00": "parserInstance",
                "FirmataMarshaller": "FirmataMarshallerConstructor",
                "firmwareVersionCount": "versionCount",
                "firmwareVersionVector": "versionVector",
                "blinkVersionDisabled": "isBlinkVersionDisabled",
                "FirmataParser": "FirmataParserConstructor",
                "staticAnalogCallback": "analogCallback",
                "staticDigitalCallback": "digitalCallback",
                "staticReportAnalogCallback": "reportAnalogCallback",
                "staticReportDigitalCallback": "reportDigitalCallback",
                "staticPinModeCallback": "pinModeCallback",
                "staticPinValueCallback": "pinValueCallback",
                "staticStringCallback": "stringCallback",
                "staticSysexCallback": "sysexCallback",
                "staticReportFirmwareCallback": "reportFirmwareCallback",
                "staticReportVersionCallback": "reportVersionCallback",
                "staticSystemResetCallback": "systemResetCallback"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "attach",
                "attach",
                "attach",
                "FirmataParser",
                "FirmataMarshaller",
                "attach",
                "attach"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002dbc": {
            "entrypoint": "0x08002dbc",
            "current_name": "initialize_firmata_08002dbc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeFirmata_08002dbc(int initializeFlag,int priority)\n\n{\n  if (initializeFlag != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    firmata::firmataObjectClass::firmataObjectClass(&firmataObject);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002dbc": "initialize_firmata_08002dbc",
                "__initialize_p": "initializeFlag",
                "__priority": "priority",
                "Firmata": "firmataObject"
            },
            "calling": [
                "_GLOBAL__sub_I_Firmata"
            ],
            "called": [
                "FirmataClass"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ddc": {
            "entrypoint": "0x08002ddc",
            "current_name": "send_firmata_version_08002ddc",
            "code": "\n/* DWARF original prototype: void  printVersion(FirmataClass * firmataInstance) */\n\nvoid __firmataInstancecall firmata::FirmataClass::sendFirmataVersion_08002ddc(FirmataClass *firmataInstance)\n\n{\n  FirmataMarshaller::sendVersion(&firmataInstance->marshaller,'\\x02','\\x05');\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ddc": "send_firmata_version_08002ddc",
                "this": "firmataInstance"
            },
            "calling": [
                "begin",
                "staticReportVersionCallback"
            ],
            "called": [
                "sendVersion"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002dea": {
            "entrypoint": "0x08002dea",
            "current_name": "print_version_if_context_not_null_08002dea",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::printVersionIfContextNotNull_08002dea(void *ctx)\n\n{\n  if (ctx != (void *)0x0) {\n    printVersion((FirmataClass *)ctx);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002dea": "print_version_if_context_not_null_08002dea",
                "context": "ctx"
            },
            "calling": [],
            "called": [
                "printVersion"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002df6": {
            "entrypoint": "0x08002df6",
            "current_name": "send_firmware_version_if_present_08002df6",
            "code": "\n/* DWARF original prototype: void  printFirmwareVersion(FirmataClass * firmataInstance) */\n\nvoid __firmataInstancecall firmata::FirmataClass::sendFirmwareVersionIfPresent_08002df6(FirmataClass *firmataInstance)\n\n{\n  uint8_t *firmwareVersionPtr;\n  \n  if (firmataInstance->firmwareVersionLength == 0) {\n    return;\n  }\n  firmwareVersionPtr = firmataInstance->firmwareVersionVector;\n  FirmataMarshaller::sendFirmwareVersion\n            (&firmataInstance->marshaller,*firmwareVersionPtr,firmwareVersionPtr[1],firmataInstance->firmwareVersionLength - 2,firmwareVersionPtr + 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002df6": "send_firmware_version_if_present_08002df6",
                "this": "firmataInstance",
                "puVar1": "firmwareVersionPtr",
                "firmwareVersionCount": "firmwareVersionLength"
            },
            "calling": [
                "begin",
                "staticReportFirmwareCallback"
            ],
            "called": [
                "sendFirmwareVersion"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002e1a": {
            "entrypoint": "0x08002e1a",
            "current_name": "print_firmware_version_or_default_08002e1a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::printFirmwareVersionOrDefault_08002e1a(void *firmataInstance,size_t size1,size_t size2,char *message)\n\n{\n  if (firmataInstance != (void *)0x0) {\n    printFirmwareVersion((FirmataClass *)firmataInstance);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002e1a": "print_firmware_version_or_default_08002e1a",
                "context": "firmataInstance",
                "param_2": "size1",
                "param_3": "size2",
                "param_4": "message"
            },
            "calling": [],
            "called": [
                "printFirmwareVersion"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002e26": {
            "entrypoint": "0x08002e26",
            "current_name": "initialize_firmata_08002e26",
            "code": "\n/* DWARF original prototype: void  begin(firmataObject * firmataObject, inputStream * inputStream) */\n\nvoid __firmataObjectcall firmata::firmataObject::initializeFirmata_08002e26(firmataObject *firmataObject,inputStream *inputStream)\n\n{\n  firmataObject->inputStream = inputStream;\n  marshallerObject::begin(&firmataObject->marinputStreamhaller,inputStream);\n  printLibraryVersion(firmataObject);\n  printFirmwareLibraryVersion(firmataObject);\n  return;\n}\n\n",
            "renaming": {
                "FirmataClass": "firmataObject",
                "FUN_08002e26": "initialize_firmata_08002e26",
                "Stream": "inputStream",
                "this": "firmataObject",
                "s": "inputStream",
                "FirmataStream": "inputStream",
                "FirmataMarshaller": "marshallerObject",
                "printVersion": "printLibraryVersion",
                "printFirmwareVersion": "printFirmwareLibraryVersion"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "printFirmwareVersion",
                "printVersion",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002e44": {
            "entrypoint": "0x08002e44",
            "current_name": "set_firmware_name_and_version_08002e44",
            "code": "\n/* DWARF original prototype: void  setFirmwareNameAndVersion_08002e44(FirmataClass * firmataObj, char * fileName, byte\n   majorVersion, byte minorVersion) */\n\nvoid __firmataObjcall\nfirmata::FirmataClass::setFirmwareNameAndVersion_08002e44(FirmataClass *firmataObj,char *fileName,byte majorVersion,byte minorVersion)\n\n{\n  byte count;\n  char *cppExtension;\n  char *backslashOrForwardslash;\n  char *lastSlash;\n  char *baseName;\n  byte *versionVector;\n  size_t nameLength;\n  \n  cppExtension = strstr(fileName,\".cpp\");\n  lastSlash = strrchr(fileName,0x2f);\n  if (lastSlash == (char *)0x0) {\n    lastSlash = strrchr(fileName,0x5c);\n  }\n  if (lastSlash != (char *)0x0) {\n    fileName = lastSlash + 1;\n  }\n  if (cppExtension == (char *)0x0) {\n    nameLength = strlen(fileName);\n    firmataObj->firmwareVersionCount = (char)nameLength + '\\x02';\n  }\n  else {\n    firmataObj->firmwareVersionCount = ((char)cppExtension - (char)fileName) + '\\x02';\n  }\n  free(firmataObj->firmwareVersionVector);\n  count = firmataObj->firmwareVersionCount;\n  versionVector = (byte *)malloc(count + 1);\n  firmataObj->firmwareVersionVector = versionVector;\n  versionVector[count] = '\\0';\n  *versionVector = majorVersion;\n  versionVector[1] = minorVersion;\n  strncpy((char *)(versionVector + 2),fileName,firmataObj->firmwareVersionCount - 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002e44": "set_firmware_name_and_version_08002e44",
                "this": "firmataObj",
                "name": "fileName",
                "major": "majorVersion",
                "minor": "minorVersion",
                "bVar1": "count",
                "pcVar2": "cppExtension",
                "pcVar3": "lastSlash",
                "extension": "backslashOrForwardslash",
                "firmwareName": "baseName",
                "pbVar4": "versionVector",
                "sVar5": "nameLength"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "free",
                "strrchr",
                "strncpy",
                "strstr",
                "strlen",
                "malloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ec4": {
            "entrypoint": "0x08002ec4",
            "current_name": "print_available_08002ec4",
            "code": "\n/* DWARF original prototype: int  available(FirmataClass * obj) */\n\nint __objcall firmata::FirmataClass::printAvailable_08002ec4(FirmataClass *obj)\n\n{\n  int result;\n  \n  result = (*(obj->FirmataStream->super_Print)._vptr_Print[2])();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002ec4": "print_available_08002ec4",
                "this": "obj",
                "iVar1": "result"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ed2": {
            "entrypoint": "0x08002ed2",
            "current_name": "process_input_08002ed2",
            "code": "\n/* DWARF original prototype: void  processInput_08002ed2(FirmataClass * firmataInstance) */\n\nvoid __firmataInstancecall firmata::FirmataClass::processInput_08002ed2(FirmataClass *firmataInstance)\n\n{\n  int result;\n  int input;\n  \n  result = (*(firmataInstance->FirmataStream->super_Print)._vptr_Print[3])();\n  if (result != -1) {\n    FirmataParser::parse(&firmataInstance->parser,(uint8_t)result);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "firmataInstance",
                "iVar1": "result",
                "inputData": "input",
                "FUN_08002ed2": "process_input_08002ed2"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "parse"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ef2": {
            "entrypoint": "0x08002ef2",
            "current_name": "send_analog_value_08002ef2",
            "code": "\n/* DWARF original prototype: void  sendAnalog(FirmataClass * firmataInstance, byte analogPin, int analogValue) */\n\nvoid __firmataInstancecall firmata::FirmataClass::sendAnalogValue_08002ef2(FirmataClass *firmataInstance,byte analogPin,int analogValue)\n\n{\n  sendAnalogToMarshaller(&firmataInstance->marshaller,analogPin,(uint16_t)analogValue);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ef2": "send_analog_value_08002ef2",
                "this": "firmataInstance",
                "pin": "analogPin",
                "value": "analogValue",
                "FirmataMarshaller::sendAnalog": "sendAnalogToMarshaller"
            },
            "calling": [
                "loop",
                "reportAnalogCallback"
            ],
            "called": [
                "sendAnalog"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efe": {
            "entrypoint": "0x08002efe",
            "current_name": "send_digital_port_08002efe",
            "code": "\n/* DWARF original prototype: void  sendDigitalPort_08002efe(FirmataClass * firmataObject, byte digitalPortNumber, int\n   digitalPortData) */\n\nvoid __firmataObjectcall firmata::FirmataClass::sendDigitalPort_08002efe(FirmataClass *firmataObject,byte digitalPortNumber,int digitalPortData)\n\n{\n  FirmataMarshaller::sendDigitalPort_08002efe(&firmataObject->marshaller,digitalPortNumber,(uint16_t)digitalPortData);\n  return;\n}\n\n",
            "renaming": {
                "this": "firmataObject",
                "portNumber": "digitalPortNumber",
                "portData": "digitalPortData",
                "FUN_08002efe": "send_digital_port_08002efe"
            },
            "calling": [
                "outputPort"
            ],
            "called": [
                "sendDigitalPort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f0a": {
            "entrypoint": "0x08002f0a",
            "current_name": "send_sysex_command_08002f0a",
            "code": "\n/* DWARF original prototype: void  sendSysex(FirmataClass * firmataInstance, byte sysexCommand, byte numBytes, byte *\n   byteValues) */\n\nvoid __firmataInstancecall\nfirmata::FirmataClass::sendSysexCommand_08002f0a(FirmataClass *firmataInstance,byte sysexCommand,byte numBytes,byte *byteValues)\n\n{\n  sendSysexToMarshaller(&firmataInstance->marshaller,sysexCommand,(uint)numBytes,byteValues);\n  return;\n}\n\n",
            "renaming": {
                "this": "firmataInstance",
                "command": "sysexCommand",
                "bytec": "numBytes",
                "bytev": "byteValues",
                "FirmataMarshaller::sendSysex": "sendSysexToMarshaller",
                "FUN_08002f0a": "send_sysex_command_08002f0a"
            },
            "calling": [
                "readAndReportData"
            ],
            "called": [
                "sendSysex"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f14": {
            "entrypoint": "0x08002f14",
            "current_name": "send_string_08002f14",
            "code": "\n/* DWARF original prototype: void  sendString_08002f14(FirmataClass * firmataObject, char * inputString) */\n\nvoid __firmataObjectcall firmata::FirmataClass::sendString_08002f14(FirmataClass *firmataObject,char *inputString)\n\n{\n  FirmataMarshaller::sendString_08002f14(&firmataObject->marshaller,inputString);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f14": "send_string_08002f14",
                "this": "firmataObject",
                "string": "inputString"
            },
            "calling": [
                "setPinModeCallback",
                "readAndReportData",
                "attachServo",
                "sysexCallback"
            ],
            "called": [
                "sendString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f1e": {
            "entrypoint": "0x08002f1e",
            "current_name": "write_to_firmata_stream_08002f1e",
            "code": "\n/* DWARF original prototype: void  write(FirmataClass * firmataObject, byte c) */\n\nssize_t __firmataObjectcall\nfirmata::FirmataClass::writeToFirmataStream_08002f1e(FirmataClass *firmataObject,int fileDescriptor,void *buffer,size_t size)\n\n{\n  int returnValue;\n  \n  returnValue = (**(firmataObject->FirmataStream->super_Print)._vptr_Print)();\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08002f1e": "write_to_firmata_stream_08002f1e",
                "this": "firmataObject",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "size",
                "iVar1": "returnValue"
            },
            "calling": [
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f2c": {
            "entrypoint": "0x08002f2c",
            "current_name": "handle_command_08002f2c",
            "code": "\n/* DWARF original prototype: void  attach(FirmataClass * firmataInstance, uint8_t receivedCommand, callbackFunction\n   callbackFunction) */\n\nvoid __firmataInstancecall\nfirmata::FirmataClass::handleCommand_08002f2c(FirmataClass *firmataInstance,uint8_t receivedCommand,callbackFunction callbackFunction)\n\n{\n  callbackFunction previousCallback;\n  \n  if (receivedCommand == 0xd0) {\n    currentReportDigitalCallback = callbackFunction;\n    return;\n  }\n  if (0xd0 < receivedCommand) {\n    if (receivedCommand == 0xf4) {\n      currentPinModeCallback = callbackFunction;\n      return;\n    }\n    previousCallback = callbackFunction;\n    if ((receivedCommand != 0xf5) && (previousCallback = currentPinValueCallback, receivedCommand == 0xe0)) {\n      currentAnalogCallback = callbackFunction;\n      return;\n    }\n    currentPinValueCallback = previousCallback;\n    return;\n  }\n  if (receivedCommand == 0x90) {\n    currentDigitalCallback = callbackFunction;\n    return;\n  }\n  if (receivedCommand != 0xc0) {\n    return;\n  }\n  currentReportAnalogCallback = callbackFunction;\n  return;\n}\n\n",
            "renaming": {
                "this": "firmataInstance",
                "command": "receivedCommand",
                "newFunction": "callbackFunction",
                "p_Var1": "previousCallback",
                "FUN_08002f2c": "handle_command_08002f2c"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f84": {
            "entrypoint": "0x08002f84",
            "current_name": "attach_system_callback_08002f84",
            "code": "\n/* DWARF original prototype: void  attach(FirmataClass * firmataInstance, uint8_t callbackCommand,\n   systemCallbackFunction callbackFunction) */\n\nvoid __firmataInstancecall\nfirmata::FirmataClass::attachSystemCallback_08002f84(FirmataClass *firmataInstance,uint8_t callbackCommand,systemCallbackFunction callbackFunction)\n\n{\n  if (callbackCommand == 0xff) {\n    currentSystemResetCallback = callbackFunction;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f84": "attach_system_callback_08002f84",
                "this": "firmataInstance",
                "command": "callbackCommand",
                "newFunction": "callbackFunction"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f94": {
            "entrypoint": "0x08002f94",
            "current_name": "set_sysex_callback_08002f94",
            "code": "\n/* DWARF original prototype: void  attach(FirmataClass * firmataObject, uint8_t commandCode,\n   sysexCallbackFunction callbackFunction) */\n\nvoid __firmataObjectcall\nfirmata::FirmataClass::setSysexCallback_08002f94(FirmataClass *firmataObject,uint8_t commandCode,sysexCallbackFunction callbackFunction)\n\n{\n  sysexCallback = callbackFunction;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f94": "set_sysex_callback_08002f94",
                "this": "firmataObject",
                "command": "commandCode",
                "newFunction": "callbackFunction",
                "currentSysexCallback": "sysexCallback"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fa0": {
            "entrypoint": "0x08002fa0",
            "current_name": "get_pin_mode_08002fa0",
            "code": "\n/* DWARF original prototype: byte  getPinMode_08002fa0(FirmataClass * firmataObj, byte pinNumber) */\n\nbyte __firmataObjcall firmata::FirmataClass::getPinMode_08002fa0(FirmataClass *firmataObj,byte pinNumber)\n\n{\n  return firmataObj->pinModeConfig[pinNumber];\n}\n\n",
            "renaming": {
                "FUN_08002fa0": "get_pin_mode_08002fa0",
                "this": "firmataObj",
                "pin": "pinNumber",
                "pinConfig": "pinModeConfig"
            },
            "calling": [
                "digitalWriteCallback",
                "setPinValueCallback",
                "analogWriteCallback",
                "setPinModeCallback",
                "loop",
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fa8": {
            "entrypoint": "0x08002fa8",
            "current_name": "update_pin_config_08002fa8",
            "code": "\n/* DWARF original prototype: void  setPinMode(FirmataClass * firmataInstance, byte pinNumber, byte pinConfiguration) */\n\nvoid __firmataInstancecall firmata::FirmataClass::updatePinConfig_08002fa8(FirmataClass *firmataInstance,byte pinNumber,byte pinConfiguration)\n\n{\n  if (firmataInstance->pinNumberConfig[pinNumber] != '\\x7f') {\n    firmataInstance->pinNumberConfig[pinNumber] = pinConfiguration;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002fa8": "update_pin_config_08002fa8",
                "this": "firmataInstance",
                "pin": "pinNumber",
                "config": "pinConfiguration"
            },
            "calling": [
                "setPinModeCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fba": {
            "entrypoint": "0x08002fba",
            "current_name": "get_pin_state_08002fba",
            "code": "\n/* DWARF original prototype: int  getPinState_08002fba(FirmataClass * firmataInstance, byte pinNumber) */\n\nint __firmataInstancecall firmata::FirmataClass::getPinState_08002fba(FirmataClass *firmataInstance,byte pinNumber)\n\n{\n  return firmataInstance->pinStates[pinNumber];\n}\n\n",
            "renaming": {
                "FUN_08002fba": "get_pin_state_08002fba",
                "this": "firmataInstance",
                "pin": "pinNumber",
                "pinState": "pinStates"
            },
            "calling": [
                "digitalWriteCallback",
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fc2": {
            "entrypoint": "0x08002fc2",
            "current_name": "set_pin_state_08002fc2",
            "code": "\n/* DWARF original prototype: void  setPinState_08002fc2(FirmataClass * firmataObj, byte pinNumber, int newState) */\n\nvoid __firmataObjcall firmata::FirmataClass::setPinState_08002fc2(FirmataClass *firmataObj,byte pinNumber,int newState)\n\n{\n  firmataObj->pinNumberState[pinNumber] = newState;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002fc2": "set_pin_state_08002fc2",
                "this": "firmataObj",
                "pin": "pinNumber",
                "state": "newState"
            },
            "calling": [
                "digitalWriteCallback",
                "setPinValueCallback",
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fca": {
            "entrypoint": "0x08002fca",
            "current_name": "strobe_blink_pin_08002fca",
            "code": "\n/* DWARF original prototype: void  strobeBlinkPin_08002fca(FirmataClass * obj, byte targetPin, int blinkCount, int\n   blinkOnInterval, int blinkOffInterval) */\n\nvoid __objcall\nfirmata::FirmataClass::strobeBlinkPin_08002fca(FirmataClass *obj,byte targetPin,int blinkCount,int blinkOnInterval,int blinkOffInterval)\n\n{\n  uint iteration;\n  \n  for (iteration = 0; (int)iteration < blinkCount; iteration = iteration + 1 & 0xff) {\n    delay(blinkOffInterval);\n    digitalWrite((uint)targetPin,1);\n    delay(blinkOnInterval);\n    digitalWrite((uint)targetPin,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002fca": "strobe_blink_pin_08002fca",
                "this": "obj",
                "pin": "targetPin",
                "count": "blinkCount",
                "onInterval": "blinkOnInterval",
                "offInterval": "blinkOffInterval",
                "uVar1": "iteration"
            },
            "calling": [
                "blinkVersion"
            ],
            "called": [
                "digitalWrite",
                "delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003002": {
            "entrypoint": "0x08003002",
            "current_name": "blink_version_08003002",
            "code": "\n/* DWARF original prototype: void  blinkVersion_08003002(Firmata * firmata) */\n\nvoid __firmatacall firmata::Firmata::blinkVersion_08003002(Firmata *firmata)\n\n{\n  if (firmata->isDisabled != false) {\n    return;\n  }\n  setPinMode(0xd,1);\n  strobePin(firmata,'\\r',2,0x28,0xd2);\n  pause(0xfa);\n  strobePin(firmata,'\\r',5,0x28,0xd2);\n  pause(0x7d);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003002": "blink_version_08003002",
                "FirmataClass": "Firmata",
                "this": "firmata",
                "blinkVersionDisabled": "isDisabled",
                "pinMode": "setPinMode",
                "strobeBlinkPin": "strobePin",
                "delay": "pause"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "strobeBlinkPin",
                "delay",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003048": {
            "entrypoint": "0x08003048",
            "current_name": "initialize_firmata_08003048",
            "code": "\n/* DWARF original prototype: void  begin(FirmataClass * firmataInstance, long baudRate) */\n\nvoid __firmataInstancecall firmata::FirmataClass::initializeFirmata_08003048(FirmataClass *firmataInstance,long baudRate)\n\n{\n  HardwareSerial::begin(&Serial2,baudRate,'\\x06');\n  blinkVersion(firmataInstance);\n  begin(firmataInstance,&Serial2.super_Stream);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003048": "initialize_firmata_08003048",
                "this": "firmataInstance",
                "speed": "baudRate"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "begin",
                "blinkVersion",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800306c": {
            "entrypoint": "0x0800306c",
            "current_name": "initialize_static_data_0800306c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_0800306c(void)\n\n{\n  initialize_and_destroy_static_data(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800306c": "initialize_static_data_0800306c",
                "__static_initialization_and_destruction_0": "initialize_and_destroy_static_data"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800307a": {
            "entrypoint": "0x0800307a",
            "current_name": "encode_byte_stream_0800307a",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003102 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  encodeByteStream_0800307a(FirmataMarshaller * marshaller, size_t numBytes, uint8_t\n   * byteArray, size_t maxBytes) */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::encodeByteStream_0800307a(FirmataMarshaller *marshaller,size_t numBytes,uint8_t *byteArray,size_t maxBytes)\n\n{\n  uint8_t transmitByte;\n  uint8_t bitCache;\n  uint currentByte;\n  uint bitOffset;\n  uint byteCount;\n  uint byteIndex;\n  \n  currentByte = (uint)*byteArray;\n  if (maxBytes == 0) {\n    maxBytes = 0xffffffff;\n  }\n  byteIndex = 0;\n  bitOffset = 0;\n  byteCount = 0;\n  while ((byteIndex < numBytes && (byteCount < maxBytes))) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)\n              (marshaller->FirmataStream,((uint)byteArray[byteIndex] << (bitOffset & 0xff) | currentByte) & 0x7f);\n    currentByte = (int)(uint)byteArray[byteIndex] >> (7 - bitOffset & 0xff) & 0xff;\n    bitOffset = bitOffset + 1;\n    while ((byteCount = byteCount + 1, 6 < bitOffset && (byteCount < maxBytes))) {\n      (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,currentByte & 0x7f);\n      currentByte = currentByte >> 7;\n      bitOffset = bitOffset - 7;\n    }\n    byteIndex = byteIndex + 1;\n  }\n  if ((bitOffset != 0) && (byteCount < maxBytes)) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)\n              (marshaller->FirmataStream,(1 << (bitOffset & 0xff)) - 1U & currentByte);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800307a": "encode_byte_stream_0800307a",
                "this": "marshaller",
                "bytec": "numBytes",
                "bytev": "byteArray",
                "max_bytes": "maxBytes",
                "transmit_byte": "transmitByte",
                "outstanding_bit_cache": "bitCache",
                "uVar1": "currentByte",
                "uVar2": "bitOffset",
                "uVar3": "byteCount",
                "uVar4": "byteIndex"
            },
            "calling": [
                "sendFirmwareVersion",
                "sendSysex",
                "sendAnalog",
                "sendExtendedAnalog",
                "sendDigitalPort"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003106": {
            "entrypoint": "0x08003106",
            "current_name": "send_extended_analog_08003106",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x0800311e */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendExtendedAnalog_08003106(FirmataMarshaller * marshaller, uint8_t pinNumber, size_t\n   byteCount, uint8_t * byteValues) */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendExtendedAnalog_08003106(FirmataMarshaller *marshaller,uint8_t pinNumber,size_t byteCount,uint8_t *byteValues)\n\n{\n  if (marshaller->firmataStream != (Stream *)0x0) {\n    (**(marshaller->firmataStream->superPrint)._vptr_Print)(marshaller,0xf0);\n    (**(marshaller->firmataStream->superPrint)._vptr_Print)(marshaller->firmataStream,0x6f);\n    (**(marshaller->firmataStream->superPrint)._vptr_Print)(marshaller->firmataStream,(uint)pinNumber);\n    encodeByteStream(marshaller,byteCount,byteValues,byteCount);\n    (**(marshaller->firmataStream->superPrint)._vptr_Print)(marshaller->firmataStream,0xf7);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003106": "send_extended_analog_08003106",
                "this": "marshaller",
                "pin": "pinNumber",
                "bytec": "byteCount",
                "bytev": "byteValues",
                "FirmataStream": "firmataStream",
                "super_Print": "superPrint"
            },
            "calling": [
                "sendAnalog"
            ],
            "called": [
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800314e": {
            "entrypoint": "0x0800314e",
            "current_name": "initialize_firmata_marshaller_0800314e",
            "code": "\n/* DWARF original prototype: Marshaller *  Marshaller(Marshaller * marshaller) */\n\nMarshaller * __marshallercall firmata::Marshaller::initializeFirmataMarshaller_0800314e(Marshaller *marshaller)\n\n{\n  marshaller->FirmataStream = (Stream *)0x0;\n  return marshaller;\n}\n\n",
            "renaming": {
                "FirmataMarshaller": "Marshaller",
                "this": "marshaller",
                "FUN_0800314e": "initialize_firmata_marshaller_0800314e"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003154": {
            "entrypoint": "0x08003154",
            "current_name": "initialize_firmata_stream_08003154",
            "code": "\n/* DWARF original prototype: void  begin(FirmataMarstreamhaller * marshaller, Stream * stream) */\n\nvoid __marshallercall firmata::FirmataMarstreamhaller::initializeFirmataStream_08003154(FirmataMarstreamhaller *marshaller,Stream *stream)\n\n{\n  marshaller->FirmataStream = stream;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003154": "initialize_firmata_stream_08003154",
                "this": "marshaller",
                "s": "stream"
            },
            "calling": [
                "begin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003158": {
            "entrypoint": "0x08003158",
            "current_name": "send_analog_data_08003158",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x0800318c */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendAnalog(FirmataMarshaller * marshaller, uint8_t analogPin, uint16_t analogValue)\n    */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendAnalogData_08003158(FirmataMarshaller *marshaller,uint8_t analogPin,uint16_t analogValue)\n\n{\n  uint16_t encodedValue;\n  \n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    encodedValue = analogValue;\n    if ((analogPin < 0x10) && (analogValue < 0x4000)) {\n      (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller,analogPin | 0xe0);\n      encodeByteStream(marshaller,2,(uint8_t *)&encodedValue,2);\n    }\n    else {\n      sendExtendedAnalog(marshaller,analogPin,2,(uint8_t *)&encodedValue);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003158": "send_analog_data_08003158",
                "this": "marshaller",
                "pin": "analogPin",
                "value": "analogValue",
                "local_a": "encodedValue"
            },
            "calling": [
                "sendAnalog"
            ],
            "called": [
                "sendExtendedAnalog",
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800319e": {
            "entrypoint": "0x0800319e",
            "current_name": "send_digital_port_0800319e",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080031ba */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendDigitalPort_0800319e(FirmataMarshaller * marshaller, uint8_t portNum,\n   uint16_t data) */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendDigitalPort_0800319e(FirmataMarshaller *marshaller,uint8_t portNum,uint16_t data)\n\n{\n  uint16_t encodedData;\n  \n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    encodedData = data;\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller,portNum & 0xf | 0x90);\n    encodeByteStream(marshaller,2,(uint8_t *)&encodedData,2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "marshaller",
                "portNumber": "portNum",
                "portData": "data",
                "local_a": "encodedData",
                "FUN_0800319e": "send_digital_port_0800319e"
            },
            "calling": [
                "sendDigitalPort"
            ],
            "called": [
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080031ce": {
            "entrypoint": "0x080031ce",
            "current_name": "send_firmware_version_080031ce",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080031e8 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendFirmwareVersion_080031ce(FirmataMarshaller * marshaller, uint8_t majorVersion,\n   uint8_t minorVersion, size_t byteCount, uint8_t * byteArray) */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendFirmwareVersion_080031ce(FirmataMarshaller *marshaller,uint8_t majorVersion,uint8_t minorVersion,size_t byteCount,uint8_t *byteArray)\n\n{\n  _func_int_varargs *printFunction;\n  uint index;\n  \n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    printFunction = *(marshaller->FirmataStream->super_Print)._vptr_Print;\n    (*printFunction)(marshaller,0xf0,(uint)minorVersion,printFunction,byteCount);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,0x79);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,(uint)majorVersion);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,(uint)minorVersion);\n    for (index = 0; index < byteCount; index = index + 1) {\n      encodeByteStream(marshaller,1,byteArray + index,0);\n    }\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,0xf7);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080031ce": "send_firmware_version_080031ce",
                "this": "marshaller",
                "major": "majorVersion",
                "minor": "minorVersion",
                "bytec": "byteCount",
                "bytev": "byteArray",
                "p_Var1": "printFunction",
                "uVar2": "index"
            },
            "calling": [
                "printFirmwareVersion"
            ],
            "called": [
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800322c": {
            "entrypoint": "0x0800322c",
            "current_name": "send_version_0800322c",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003240 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendVersion_0800322c(FirmataMarshaller * marshaller, uint8_t majorVersion, uint8_t\n   minorVersion) */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendVersion_0800322c(FirmataMarshaller *marshaller,uint8_t majorVersion,uint8_t minorVersion)\n\n{\n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller,0xf9);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,(uint)majorVersion);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,(uint)minorVersion);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "marshaller",
                "major": "majorVersion",
                "minor": "minorVersion",
                "FUN_0800322c": "send_version_0800322c"
            },
            "calling": [
                "printVersion"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800325a": {
            "entrypoint": "0x0800325a",
            "current_name": "send_sysex_0800325a",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003272 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendSysex_0800325a(FirmataMarshaller * marshaller, uint8_t sysexCommand, size_t\n   byteCount, uint8_t * byteArray) */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendSysex_0800325a(FirmataMarshaller *marshaller,uint8_t sysexCommand,size_t byteCount,uint8_t *byteArray)\n\n{\n  uint index;\n  \n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller,0xf0);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,(uint)sysexCommand);\n    for (index = 0; index < byteCount; index = index + 1) {\n      encodeByteStream(marshaller,1,byteArray + index,0);\n    }\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,0xf7);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "marshaller",
                "command": "sysexCommand",
                "bytec": "byteCount",
                "bytev": "byteArray",
                "uVar1": "index",
                "FUN_0800325a": "send_sysex_0800325a"
            },
            "calling": [
                "sendSysex",
                "sendString"
            ],
            "called": [
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080032a2": {
            "entrypoint": "0x080032a2",
            "current_name": "send_string_080032a2",
            "code": "\n/* DWARF original prototype: void  sendString_080032a2(FirmataMarshaller * marshaller, char * inputString) */\n\nvoid __marshallercall firmata::FirmataMarshaller::sendString_080032a2(FirmataMarshaller *marshaller,char *inputString)\n\n{\n  size_t stringLength;\n  \n  stringLength = strlen(inputString);\n  sendSysex(marshaller,'q',stringLength,(uint8_t *)inputString);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080032a2": "send_string_080032a2",
                "this": "marshaller",
                "string": "inputString",
                "bytec": "stringLength"
            },
            "calling": [
                "sendString"
            ],
            "called": [
                "sendSysex",
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080032bc": {
            "entrypoint": "0x080032bc",
            "current_name": "initialize_firmata_parser_080032bc",
            "code": "\n/* DWARF original prototype: FirmataParser *  FirmataParser(FirmataParser * parser, uint8_t *\n   buffer, size_t bufferSize) */\n\nFirmataParser * __parsercall\nfirmata::FirmataParser::initializeFirmataParser_080032bc(FirmataParser *parser,uint8_t *buffer,size_t bufferSize)\n\n{\n  parser->buffer = buffer;\n  parser->bufferSize = bufferSize;\n  parser->multiByteCommand = '\\0';\n  parser->multiByteChannel = '\\0';\n  parser->waitData = 0;\n  parser->isParsingSysex = false;\n  parser->sysexBytesRead = 0;\n  parser->analogCallbackContext = (void *)0x0;\n  parser->digitalCallbackContext = (void *)0x0;\n  parser->reportAnalogCallbackContext = (void *)0x0;\n  parser->reportDigitalCallbackContext = (void *)0x0;\n  parser->pinModeCallbackContext = (void *)0x0;\n  parser->pinValueCallbackContext = (void *)0x0;\n  parser->reportFirmwareCallbackContext = (void *)0x0;\n  parser->reportVersionCallbackContext = (void *)0x0;\n  parser->dataBufferOverflowCallbackContext = (void *)0x0;\n  parser->stringCallbackContext = (void *)0x0;\n  parser->sysexCallbackContext = (void *)0x0;\n  parser->systemResetCallbackContext = (void *)0x0;\n  parser->analogCallback = (callbackFunction)0x0;\n  parser->digitalCallback = (callbackFunction)0x0;\n  parser->reportAnalogCallback = (callbackFunction)0x0;\n  parser->reportDigitalCallback = (callbackFunction)0x0;\n  parser->pinModeCallback = (callbackFunction)0x0;\n  parser->pinValueCallback = (callbackFunction)0x0;\n  parser->dataBufferOverflowCallback = (bufferOverflowCallbackFunction)0x0;\n  parser->stringCallback = (stringCallbackFunction)0x0;\n  parser->sysexCallback = (sysexCallbackFunction)0x0;\n  parser->reportFirmwareCallback = (versionCallbackFunction)0x0;\n  parser->reportVersionCallback = (systemCallbackFunction)0x0;\n  parser->systemResetCallback = (systemCallbackFunction)0x0;\n  parser->isAllowBufferUpdate = buffer == (uint8_t *)0x0;\n  return parser;\n}\n\n",
            "renaming": {
                "this": "parser",
                "dataBuffer": "buffer",
                "dataBufferSize": "bufferSize",
                "executeMultiByteCommand": "multiByteCommand",
                "waitForData": "waitData",
                "parsingSysex": "isParsingSysex",
                "currentAnalogCallbackContext": "analogCallbackContext",
                "currentDigitalCallbackContext": "digitalCallbackContext",
                "currentReportAnalogCallbackContext": "reportAnalogCallbackContext",
                "currentReportDigitalCallbackContext": "reportDigitalCallbackContext",
                "currentPinModeCallbackContext": "pinModeCallbackContext",
                "currentPinValueCallbackContext": "pinValueCallbackContext",
                "currentReportFirmwareCallbackContext": "reportFirmwareCallbackContext",
                "currentReportVersionCallbackContext": "reportVersionCallbackContext",
                "currentDataBufferOverflowCallbackContext": "dataBufferOverflowCallbackContext",
                "currentStringCallbackContext": "stringCallbackContext",
                "currentSysexCallbackContext": "sysexCallbackContext",
                "currentSystemResetCallbackContext": "systemResetCallbackContext",
                "currentAnalogCallback": "analogCallback",
                "currentDigitalCallback": "digitalCallback",
                "currentReportAnalogCallback": "reportAnalogCallback",
                "currentReportDigitalCallback": "reportDigitalCallback",
                "currentPinModeCallback": "pinModeCallback",
                "currentPinValueCallback": "pinValueCallback",
                "currentDataBufferOverflowCallback": "dataBufferOverflowCallback",
                "currentStringCallback": "stringCallback",
                "currentSysexCallback": "sysexCallback",
                "currentReportFirmwareCallback": "reportFirmwareCallback",
                "currentReportVersionCallback": "reportVersionCallback",
                "currentSystemResetCallback": "systemResetCallback",
                "allowBufferUpdate": "isAllowBufferUpdate",
                "FUN_080032bc": "initialize_firmata_parser_080032bc"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003306": {
            "entrypoint": "0x08003306",
            "current_name": "attach_08003306",
            "code": "\n/* DWARF original prototype: void  attach_08003306(FirmataParser * parser, uint8_t opcode, callbackFunction\n   callback, void * callbackContext) */\n\nvoid __parsercall\nfirmata::FirmataParser::attach_08003306(FirmataParser *parser,uint8_t opcode,callbackFunction callback,void *callbackContext)\n\n{\n  if (opcode == 0xd0) {\n    parser->currentReportDigitalCallback = callback;\n    parser->currentReportDigitalCallbackContext = callbackContext;\n    return;\n  }\n  if (0xd0 < opcode) {\n    if (opcode == 0xf4) {\n      parser->currentPinModeCallback = callback;\n      parser->currentPinModeCallbackContext = callbackContext;\n      return;\n    }\n    if (opcode == 0xf5) {\n      parser->currentPinValueCallback = callback;\n      parser->currentPinValueCallbackContext = callbackContext;\n    }\n    else if (opcode == 0xe0) {\n      parser->currentAnalogCallback = callback;\n      parser->currentAnalogCallbackContext = callbackContext;\n      return;\n    }\n    return;\n  }\n  if (opcode == 0x90) {\n    parser->currentDigitalCallback = callback;\n    parser->currentDigitalCallbackContext = callbackContext;\n    return;\n  }\n  if (opcode == 0xc0) {\n    parser->currentReportAnalogCallback = callback;\n    parser->currentReportAnalogCallbackContext = callbackContext;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003306": "attach_08003306",
                "this": "parser",
                "command": "opcode",
                "newFunction": "callback",
                "context": "callbackContext"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003346": {
            "entrypoint": "0x08003346",
            "current_name": "attach_firmware_callback_08003346",
            "code": "\n/* DWARF original prototype: void  attach(FirmataParser * parser, uint8_t cmd,\n   versionCallbackFunction callback, void * callbackContext) */\n\nvoid __parsercall\nfirmata::FirmataParser::attachFirmwareCallback_08003346(FirmataParser *parser,uint8_t cmd,versionCallbackFunction callback,void *callbackContext)\n\n{\n  if (cmd == 'y') {\n    parser->currentReportFirmwareCallback = callback;\n    parser->currentReportFirmwareCallbackContext = callbackContext;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003346": "attach_firmware_callback_08003346",
                "this": "parser",
                "command": "cmd",
                "newFunction": "callback",
                "context": "callbackContext"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003350": {
            "entrypoint": "0x08003350",
            "current_name": "handle_command_08003350",
            "code": "\n/* DWARF original prototype: void  attach(FirmataParser * parser, uint8_t cmd,\n   systemCallbackFunction callback, void * callbackContext) */\n\nvoid __parsercall\nfirmata::FirmataParser::handleCommand_08003350(FirmataParser *parser,uint8_t cmd,systemCallbackFunction callback,void *callbackContext)\n\n{\n  if (cmd == 0xf9) {\n    parser->reportVerCallback = callback;\n    parser->reportVerCallbackContext = callbackContext;\n    return;\n  }\n  if (cmd != 0xff) {\n    return;\n  }\n  parser->systemResetCallback = callback;\n  parser->systemResetCallbackContext = callbackContext;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003350": "handle_command_08003350",
                "this": "parser",
                "command": "cmd",
                "newFunction": "callback",
                "context": "callbackContext",
                "currentReportVersionCallback": "reportVerCallback",
                "currentReportVersionCallbackContext": "reportVerCallbackContext",
                "currentSystemResetCallback": "systemResetCallback",
                "currentSystemResetCallbackContext": "systemResetCallbackContext"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003366": {
            "entrypoint": "0x08003366",
            "current_name": "attach_string_callback_08003366",
            "code": "\n/* DWARF original prototype: void  attach(FirmataParser * parser, uint8_t cmd,\n   stringCallbackFunction callback, void * ctx) */\n\nvoid __parsercall\nfirmata::FirmataParser::attachStringCallback_08003366(FirmataParser *parser,uint8_t cmd,stringCallbackFunction callback,void *ctx)\n\n{\n  if (cmd == 'q') {\n    parser->currentStringCallback = callback;\n    parser->currentStringCallbackContext = ctx;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003366": "attach_string_callback_08003366",
                "this": "parser",
                "command": "cmd",
                "newFunction": "callback",
                "context": "ctx"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003370": {
            "entrypoint": "0x08003370",
            "current_name": "attach_08003370",
            "code": "\n/* DWARF original prototype: void  attach_08003370(FirmataParser * parser, uint8_t cmd,\n   callbackFn newCallbackFn, void * callbackContext) */\n\nvoid __parsercall\nfirmata::FirmataParser::attach_08003370(FirmataParser *parser,uint8_t cmd,callbackFn newCallbackFn,void *callbackContext)\n\n{\n  parser->currentSysexCallback = newCallbackFn;\n  parser->currentSysexCallbackContext = callbackContext;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003370": "attach_08003370",
                "this": "parser",
                "command": "cmd",
                "sysexCallbackFunction": "callbackFn",
                "newFunction": "newCallbackFn",
                "context": "callbackContext"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003376": {
            "entrypoint": "0x08003376",
            "current_name": "buffer_data_at_position_08003376",
            "code": "\n/* DWARF original prototype: bool  bufferDataAtPosition_08003376(FirmataParser * parser, uint8_t bufferData, size_t\n   position) */\n\nbool __parsercall firmata::FirmataParser::bufferDataAtPosition_08003376(FirmataParser *parser,uint8_t bufferData,size_t position)\n\n{\n  bool isDataOverflow;\n  bool isBufferOverflow;\n  \n  if (position < parser->bufferSize) {\n    isDataOverflow = false;\n  }\n  else {\n    isDataOverflow = true;\n    if (parser->dataBufferOverflowCallback != (bufferOverflowCallbackFunction)0x0) {\n      parser->updateBufferAllowed = true;\n      (*parser->dataBufferOverflowCallback)(parser->dataBufferOverflowCallbackContext);\n      if (position < parser->bufferSize) {\n        isDataOverflow = false;\n      }\n      else {\n        isDataOverflow = true;\n      }\n    }\n  }\n  if (!isDataOverflow) {\n    parser->buffer[position] = bufferData;\n  }\n  return isDataOverflow;\n}\n\n",
            "renaming": {
                "FUN_08003376": "buffer_data_at_position_08003376",
                "this": "parser",
                "data": "bufferData",
                "pos": "position",
                "bVar1": "isDataOverflow",
                "bufferOverflow": "isBufferOverflow",
                "currentDataBufferOverflowCallback": "dataBufferOverflowCallback",
                "allowBufferUpdate": "updateBufferAllowed",
                "currentDataBufferOverflowCallbackContext": "dataBufferOverflowCallbackContext",
                "dataBuffer": "buffer",
                "dataBufferSize": "bufferSize"
            },
            "calling": [
                "processSysexMessage",
                "parse"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033a8": {
            "entrypoint": "0x080033a8",
            "current_name": "decode_byte_stream_080033a8",
            "code": "\n/* DWARF original prototype: size_t  decodeByteStream_080033a8(FirmataParser * parser, size_t byteCount, uint8_t *\n   byteVector) */\n\nsize_t decodeByteStream_080033a8\nfirmata::FirmataParser::decodeByteStream_080033a8(FirmataParser *parser,size_t byteCount,uint8_t *byteVector)\n\n{\n  byte currentValue;\n  size_t newByteIndex;\n  uint currentByte;\n  \n  newByteIndex = 0;\n  for (currentByte = 0; currentByte < byteCount; currentByte = currentByte + 2) {\n    currentValue = byteVector[currentByte];\n    byteVector[newByteIndex] = currentValue;\n    byteVector[newByteIndex] = byteVector[currentByte + 1] << 7 | currentValue;\n    newByteIndex = newByteIndex + 1;\n  }\n  return newByteIndex;\n}\n\n",
            "renaming": {
                "FUN_080033a8": "decode_byte_stream_080033a8",
                "__thiscall": "decodeByteStream",
                "this": "parser",
                "bytec": "byteCount",
                "bytev": "byteVector",
                "sVar2": "newByteIndex",
                "uVar3": "currentByte",
                "bVar1": "currentValue"
            },
            "calling": [
                "processSysexMessage"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033cc": {
            "entrypoint": "0x080033cc",
            "current_name": "process_sysex_message_080033cc",
            "code": "\n/* DWARF original prototype: void  processSysexMessage_080033cc(FirmataParser * parser) */\n\nvoid __parsercall firmata::FirmataParser::processSysexMessage_080033cc(FirmataParser *parser)\n\n{\n  uint8_t firstByte;\n  size_t decodedLength;\n  uint8_t *dataPointer;\n  \n  dataPointer = parser->dataBuffer;\n  firstByte = *dataPointer;\n  if (firstByte == 'q') {\n    if (parser->currentStringCallback != (stringCallbackFunction)0x0) {\n      decodedLength = decodeByteStream(parser,parser->sysexBytesRead - 1,dataPointer + 1);\n      bufferDataAtPosition(parser,'\\0',decodedLength + 1);\n      (*parser->currentStringCallback)\n                (parser->currentStringCallbackContext,(char *)(parser->dataBuffer + 1));\n      return;\n    }\n  }\n  else if (firstByte == 'y') {\n    if (parser->currentReportFirmwareCallback != (versionCallbackFunction)0x0) {\n      if (parser->sysexBytesRead < 3) {\n        (*parser->currentReportFirmwareCallback)\n                  (parser->currentReportFirmwareCallbackContext,0,0,(char *)0x0);\n        return;\n      }\n      decodedLength = decodeByteStream(parser,parser->sysexBytesRead - 3,dataPointer + 3);\n      bufferDataAtPosition(parser,'\\0',decodedLength + 3);\n      dataPointer = parser->dataBuffer;\n      (*parser->currentReportFirmwareCallback)\n                (parser->currentReportFirmwareCallbackContext,(uint)dataPointer[1],(uint)dataPointer[2],\n                 (char *)(dataPointer + 3));\n      return;\n    }\n  }\n  else if (parser->currentSysexCallback != (sysexCallbackFunction)0x0) {\n    (*parser->currentSysexCallback)\n              (parser->currentSysexCallbackContext,firstByte,parser->sysexBytesRead - 1,dataPointer + 1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "parser",
                "uVar1": "firstByte",
                "sVar2": "decodedLength",
                "puVar3": "dataPointer",
                "FUN_080033cc": "process_sysex_message_080033cc"
            },
            "calling": [
                "parse"
            ],
            "called": [
                "decodeByteStream",
                "bufferDataAtPosition"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800344a": {
            "entrypoint": "0x0800344a",
            "current_name": "reset_firmata_parser_0800344a",
            "code": "\n/* DWARF orindexgindexnal prototype: voindexd  systemReset(FindexrmataParser * parser) */\n\nvoindexd __parsercall findexrmata::FindexrmataParser::resetFirmataParser_0800344a(FindexrmataParser *parser)\n\n{\n  sindexze_t index;\n  \n  parser->dataWaiting = 0;\n  parser->currentCommand = '\\0';\n  parser->currentChannel = '\\0';\n  for (index = 0; index < parser->bufferSize; index = index + 1) {\n    parser->buffer[index] = '\\0';\n  }\n  parser->sysexParsing = false;\n  parser->sysexBytesCount = 0;\n  indexf (parser->resetCallback != (callbackFunction)0x0) {\n    (*parser->resetCallback)(parser->callbackContext);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "parser",
                "i": "index",
                "waitForData": "dataWaiting",
                "executeMultiByteCommand": "currentCommand",
                "multiByteChannel": "currentChannel",
                "dataBufferSize": "bufferSize",
                "dataBuffer": "buffer",
                "parsingSysex": "sysexParsing",
                "sysexBytesRead": "sysexBytesCount",
                "currentSystemResetCallback": "resetCallback",
                "systemCallbackFunction": "callbackFunction",
                "currentSystemResetCallbackContext": "callbackContext",
                "FUN_0800344a": "reset_firmata_parser_0800344a"
            },
            "calling": [
                "parse"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003474": {
            "entrypoint": "0x08003474",
            "current_name": "parse_08003474",
            "code": "\n/* DWARF original prototype: void  parse_08003474(FirmataParser * parse_08003474r, uint8_t inputData) */\n\nvoid __parse_08003474rcall firmata::FirmataParser::parse_08003474(FirmataParser *parse_08003474r,uint8_t inputData)\n\n{\n  byte byteValue;\n  uint intValue;\n  size_t position;\n  \n  intValue = (uint)inputData;\n  if (parse_08003474r->isParsingSysex != false) {\n    if (intValue != 0xf7) {\n      bufferDataAtPosition(parse_08003474r,inputData,parse_08003474r->sysexBytesRead);\n      parse_08003474r->sysexBytesRead = parse_08003474r->sysexBytesRead + 1;\n      return;\n    }\n    parse_08003474r->isParsingSysex = false;\n    processSysexMessage(parse_08003474r);\n    return;\n  }\n  if ((parse_08003474r->waitForData == 0) || (0x7f < intValue)) {\n    if (intValue < 0xf0) {\n      parse_08003474r->multiByteChannel = inputData & 0xf;\n      intValue = intValue & 0xf0;\n    }\n    if (intValue == 0xf0) {\n      parse_08003474r->isParsingSysex = true;\n      parse_08003474r->sysexBytesRead = 0;\n      return;\n    }\n    if (intValue < 0xf1) {\n      if (intValue != 0xc0) {\n        if (intValue < 0xc1) {\n          if (intValue != 0x90) {\n            return;\n          }\n        }\n        else {\n          if (intValue == 0xd0) goto LAB_0800359c;\n          if (intValue != 0xe0) {\n            return;\n          }\n        }\nLAB_08003586:\n        parse_08003474r->waitForData = 2;\n        parse_08003474r->executeMultiByteCommand = (uint8_t)intValue;\n        return;\n      }\nLAB_0800359c:\n      parse_08003474r->waitForData = 1;\n      parse_08003474r->executeMultiByteCommand = (uint8_t)intValue;\n      return;\n    }\n    if (intValue != 0xf9) {\n      if (0xf9 < intValue) {\n        if (intValue == 0xff) {\n          systemReset(parse_08003474r);\n          return;\n        }\n        return;\n      }\n      if (1 < intValue - 0xf4) {\n        return;\n      }\n      goto LAB_08003586;\n    }\n    if (parse_08003474r->currentReportVersionCallback != (systemCallbackFunction)0x0) {\n      (*parse_08003474r->currentReportVersionCallback)(parse_08003474r->currentReportVersionCallbackContext);\n    }\n  }\n  else {\n    position = parse_08003474r->waitForData - 1;\n    parse_08003474r->waitForData = position;\n    bufferDataAtPosition(parse_08003474r,inputData,position);\n    if ((parse_08003474r->waitForData == 0) && (byteValue = parse_08003474r->executeMultiByteCommand, byteValue != 0)) {\n      if (byteValue == 0xd0) {\n        if (parse_08003474r->currentReportDigitalCallback != (callbackFunction)0x0) {\n          (*parse_08003474r->currentReportDigitalCallback)\n                    (parse_08003474r->currentReportDigitalCallbackContext,parse_08003474r->multiByteChannel,\n                     (uint16_t)*parse_08003474r->dataBuffer);\n        }\n      }\n      else if (byteValue < 0xd1) {\n        if (byteValue == 0x90) {\n          if (parse_08003474r->currentDigitalCallback != (callbackFunction)0x0) {\n            (*parse_08003474r->currentDigitalCallback)\n                      (parse_08003474r->currentDigitalCallbackContext,parse_08003474r->multiByteChannel,\n                       (ushort)parse_08003474r->dataBuffer[1] + (ushort)*parse_08003474r->dataBuffer * 0x80);\n          }\n        }\n        else if ((byteValue == 0xc0) && (parse_08003474r->currentReportAnalogCallback != (callbackFunction)0x0)) {\n          (*parse_08003474r->currentReportAnalogCallback)\n                    (parse_08003474r->currentReportAnalogCallbackContext,parse_08003474r->multiByteChannel,\n                     (uint16_t)*parse_08003474r->dataBuffer);\n        }\n      }\n      else if (byteValue == 0xf4) {\n        if (parse_08003474r->currentPinModeCallback != (callbackFunction)0x0) {\n          (*parse_08003474r->currentPinModeCallback)\n                    (parse_08003474r->currentPinModeCallbackContext,parse_08003474r->dataBuffer[1],\n                     (uint16_t)*parse_08003474r->dataBuffer);\n        }\n      }\n      else if (byteValue == 0xf5) {\n        if (parse_08003474r->currentPinValueCallback != (callbackFunction)0x0) {\n          (*parse_08003474r->currentPinValueCallback)\n                    (parse_08003474r->currentPinValueCallbackContext,parse_08003474r->dataBuffer[1],\n                     (uint16_t)*parse_08003474r->dataBuffer);\n        }\n      }\n      else if ((byteValue == 0xe0) && (parse_08003474r->currentAnalogCallback != (callbackFunction)0x0)) {\n        (*parse_08003474r->currentAnalogCallback)\n                  (parse_08003474r->currentAnalogCallbackContext,parse_08003474r->multiByteChannel,\n                   (ushort)parse_08003474r->dataBuffer[1] + (ushort)*parse_08003474r->dataBuffer * 0x80);\n      }\n      parse_08003474r->executeMultiByteCommand = '\\0';\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "bVar1": "byteValue",
                "uVar2": "intValue",
                "pos": "position",
                "this": "parser",
                "parsingSysex": "isParsingSysex",
                "FUN_08003474": "parse_08003474"
            },
            "calling": [
                "processInput"
            ],
            "called": [
                "processSysexMessage",
                "systemReset",
                "bufferDataAtPosition"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035b8": {
            "entrypoint": "0x080035b8",
            "current_name": "initialize_system_080035b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_080035b8(void)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t hclkFreq;\n  PeriphClkInit PeriphClkInit;\n  ClkInitStruct RCC_ClkInitStruct;\n  OscInitStruct RCC_OscInitStruct;\n  \n  OscillatorType = 2;\n  HSIState = 1;\n  HSICalibrationValue = 0x10;\n  PLLState = 2;\n  PLLSource = 0;\n  PLLMUL = 0x380000;\n  status = HAL_RCC_OscConfig((OscInitStruct_conflict *)&RCC_OscInitStruct);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x88);\n  }\n  ClockType = 0xf;\n  SYSCLKSource = 2;\n  AHBCLKDivider = 0;\n  APB1CLKDivider = 0x400;\n  APB2CLKDivider = 0;\n  status = HAL_RCC_ClockConfig((ClkInitStruct_conflict *)&RCC_ClkInitStruct,2);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x95);\n  }\n  PeriphClockSelection = 2;\n  AdcClockSelection = 0x8000;\n  status = HAL_RCCEx_PeriphCLKConfig((PeriphClkInit_conflict *)&PeriphClkInit);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x9c);\n  }\n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035b8": "initialize_system_080035b8",
                "HVar1": "status",
                "uVar2": "hclkFreq",
                "RCC_PeriphCLKInitTypeDef": "PeriphClkInit",
                "RCC_ClkInitTypeDef": "ClkInitStruct",
                "RCC_OscInitTypeDef": "OscInitStruct",
                "RCC_OscInitStruct.OscillatorType": "OscillatorType",
                "RCC_OscInitStruct.HSIState": "HSIState",
                "RCC_OscInitStruct.HSICalibrationValue": "HSICalibrationValue",
                "RCC_OscInitStruct.PLL.PLLState": "PLLState",
                "RCC_OscInitStruct.PLL.PLLSource": "PLLSource",
                "RCC_OscInitStruct.PLL.PLLMUL": "PLLMUL",
                "RCC_ClkInitStruct.ClockType": "ClockType",
                "RCC_ClkInitStruct.SYSCLKSource": "SYSCLKSource",
                "RCC_ClkInitStruct.AHBCLKDivider": "AHBCLKDivider",
                "RCC_ClkInitStruct.APB1CLKDivider": "APB1CLKDivider",
                "RCC_ClkInitStruct.APB2CLKDivider": "APB2CLKDivider",
                "PeriphClkInit.PeriphClockSelection": "PeriphClockSelection",
                "PeriphClkInit.AdcClockSelection": "AdcClockSelection"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_OscConfig",
                "HAL_RCC_GetHCLKFreq",
                "HAL_RCCEx_PeriphCLKConfig",
                "_Error_Handler",
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config",
                "HAL_RCC_ClockConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003658": {
            "entrypoint": "0x08003658",
            "current_name": "initialize_system_08003658",
            "code": "\nvoid initializeSystem_08003658(void)\n\n{\n  int index;\n  undefined4 *pointer;\n  code *jumpTable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8667; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (pointer = &completed_8667; pointer < &_ebss; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x800368a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x0800368a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003658": "initialize_system_08003658",
                "iVar1": "index",
                "puVar2": "pointer",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "main",
                "SystemInit",
                "__libc_init_array"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036a0": {
            "entrypoint": "0x080036a0",
            "current_name": "run_infinite_loop_080036a0",
            "code": "\nvoid runInfiniteLoop_080036a0(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080036a0": "run_infinite_loop_080036a0"
            },
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036a2": {
            "entrypoint": "0x080036a2",
            "current_name": "initialize_hardware_configuration_080036a2",
            "code": "\nint initializeHardwareConfiguration_080036a2(EVP_PKEY_CTX *context)\n\n{\n  hw_config_init();\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_080036a2": "initialize_hardware_configuration_080036a2",
                "ctx": "context"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036ac": {
            "entrypoint": "0x080036ac",
            "current_name": "find_matching_pin_080036ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t find_matching_pin_080036ac(pin p)\n\n{\n  uint32_t matching_pin_index;\n  \n  if ((uint)((int)p << 0x18) >> 0x1c < 5) {\n    for (matching_pin_index = 0; (matching_pin_index < 0x3c && ((int)p != (int)(char)(&digitalPin)[matching_pin_index])); matching_pin_index = matching_pin_index + 1\n        ) {\n    }\n  }\n  else {\n    matching_pin_index = 0xffffffff;\n  }\n  return matching_pin_index;\n}\n\n",
            "renaming": {
                "FUN_080036ac": "find_matching_pin_080036ac",
                "PinName_conflict": "pin",
                "uVar1": "matching_pin_index"
            },
            "calling": [
                "digitalWriteCallback",
                "setPinValueCallback",
                "analogWriteCallback",
                "systemResetCallback",
                "setPinModeCallback",
                "checkDigitalInputs",
                "loop",
                "reportDigitalCallback",
                "enableI2CPins",
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036d4": {
            "entrypoint": "0x080036d4",
            "current_name": "FUNC_080036d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080036d4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036d4": "FUNC_080036d4"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080036d8": {
            "entrypoint": "0x080036d8",
            "current_name": "configure_sys_tick_080036d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureSysTick_080036d8(uint32_t tickPriority)\n\n{\n  uint32_t configStatus;\n  \n  configStatus = HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (configStatus != 0) {\n    return HAL_ERROR;\n  }\n  if (0xf < tickPriority) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,tickPriority,0);\n  uwTickPrio = tickPriority;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080036d8": "configure_sys_tick_080036d8",
                "TickPriority": "tickPriority",
                "uVar1": "configStatus"
            },
            "calling": [
                "HAL_Init",
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003724": {
            "entrypoint": "0x08003724",
            "current_name": "initialize_hal_08003724",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_Status initialize_HAL_08003724(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  set_priority_grouping(3);\n  init_tick(0xf);\n  initialize_Msp();\n  return HAL_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_08003724": "initialize_hal_08003724",
                "HAL_StatusTypeDef_conflict": "HAL_Status",
                "HAL_NVIC_SetPriorityGrouping": "set_priority_grouping",
                "HAL_InitTick": "init_tick",
                "HAL_MspInit": "initialize_Msp",
                "HAL_OK": "HAL_SUCCESS"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003748": {
            "entrypoint": "0x08003748",
            "current_name": "update_tick_value_08003748",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTickValue_08003748(void)\n\n{\n  updatedTickValue = tickFrequency + updatedTickValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003748": "update_tick_value_08003748",
                "uwTick": "updatedTickValue",
                "uwTickFreq": "tickFrequency"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003760": {
            "entrypoint": "0x08003760",
            "current_name": "get_system_tick_count_08003760",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTickCount_08003760(void)\n\n{\n  return systemTickCount;\n}\n\n",
            "renaming": {
                "FUN_08003760": "get_system_tick_count_08003760",
                "uwTick": "systemTickCount"
            },
            "calling": [
                "HAL_UART_Transmit",
                "uart_debug_write",
                "HAL_RCC_OscConfig",
                "HAL_ADCEx_Calibration_Start",
                "ADC_Enable",
                "UART_WaitOnFlagUntilTimeout",
                "HAL_RCCEx_PeriphCLKConfig",
                "GetCurrentMilli",
                "i2c_master_read",
                "i2c_master_write",
                "HAL_RCC_ClockConfig",
                "HAL_ADC_PollForConversion",
                "ADC_ConversionStop_Disable"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800376c": {
            "entrypoint": "0x0800376c",
            "current_name": "perform_adc_conversion_0800376c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict performADCConversion_0800376c(ADC_HandleTypeDef *adcHandle,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTick;\n  uint32_t clockFreq;\n  int samplingTime;\n  uint32_t currentTick;\n  ADC_TypeDef *adcInstance;\n  uint cpuCycles;\n  uint32_t conversionTimeoutCycles;\n  \n  conversionTimeoutCycles = 0;\n  startTick = HAL_GetTick();\n  currentTick = SystemCoreClock;\n  adcInstance = adcHandle->Instance;\n  if ((adcInstance->CR2 & 0x100) == 0) {\n    if (((adcInstance->CR1 & 0x100) == 0) && ((adcInstance->SQR1 & 0xf00000) == 0)) {\n      do {\n        if ((adcHandle->Instance->SR & 2) != 0) goto LAB_0800387e;\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n      adcHandle->State = adcHandle->State | 4;\n      adcHandle->Lock = HAL_UNLOCKED;\n      status = HAL_TIMEOUT;\n    }\n    else {\n      clockFreq = HAL_RCCEx_GetPeriphCLKFreq(2);\n      adcInstance = adcHandle->Instance;\n      if (((adcInstance->SMPR2 & 0x24924924) == 0) && ((adcInstance->SMPR1 & 0x924924) == 0)) {\n        if ((adcInstance->SMPR2 & 0x12492492) == 0) {\n          if ((adcInstance->SMPR1 & 0x492492) == 0) {\n            samplingTime = 0x14;\n          }\n          else {\n            samplingTime = 0x29;\n          }\n        }\n        else {\n          samplingTime = 0x29;\n        }\n      }\n      else if (((adcInstance->SMPR2 & 0x12492492) == 0) && ((adcInstance->SMPR1 & 0x492492) == 0)) {\n        samplingTime = 0x54;\n      }\n      else if ((adcInstance->SMPR2 & 0x249249) == 0) {\n        if ((adcInstance->SMPR1 & 0x249249) == 0) {\n          samplingTime = 0x54;\n        }\n        else {\n          samplingTime = 0xfc;\n        }\n      }\n      else {\n        samplingTime = 0xfc;\n      }\n      cpuCycles = (currentTick / clockFreq) * samplingTime;\n      for (; conversionTimeoutCycles <= cpuCycles && cpuCycles - conversionTimeoutCycles != 0;\n          conversionTimeoutCycles = conversionTimeoutCycles + 1) {\n        if ((timeout != 0xffffffff) &&\n           ((timeout == 0 || (currentTick = HAL_GetTick(), timeout < currentTick - startTick)))) {\n          adcHandle->State = adcHandle->State | 4;\n          adcHandle->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nLAB_0800387e:\n      adcHandle->Instance->SR = 0xffffffed;\n      adcHandle->State = adcHandle->State | 0x200;\n      if ((adcHandle->Instance->CR2 & 0xe0000) == 0xe0000) {\n        if ((adcHandle->Init).ContinuousConvMode == 0) {\n          adcHandle->State = adcHandle->State & 0xfffffeff;\n          if ((adcHandle->State & 0x1000) == 0) {\n            adcHandle->State = adcHandle->State | 1;\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        status = HAL_OK;\n      }\n    }\n  }\n  else {\n    adcHandle->State = adcHandle->State | 0x20;\n    adcHandle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800376c": "perform_adc_conversion_0800376c",
                "hadc": "adcHandle",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTick",
                "uVar3": "clockFreq",
                "iVar4": "samplingTime",
                "uVar5": "currentTick",
                "pAVar6": "adcInstance",
                "uVar7": "cpuCycles",
                "Conversion_Timeout_CPU_cycles": "conversionTimeoutCycles"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080038dc": {
            "entrypoint": "0x080038dc",
            "current_name": "read_adc_data_080038dc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t read_ADC_Data_080038dc(ADC_HandleTypeDef *adc_handle)\n\n{\n  return adc_handle->Instance->DR;\n}\n\n",
            "renaming": {
                "FUN_080038dc": "read_adc_data_080038dc",
                "hadc": "adc_handle"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080038e4": {
            "entrypoint": "0x080038e4",
            "current_name": "configure_adc_channel_080038e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureADCChannel_080038e4(ADC_HandleTypeDef *adcHandle,ADC_ChannelConfTypeDef *channelConfig)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint channelIndex;\n  uint32_t loopIndex;\n  \n  if (adcHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    adcHandle->Lock = HAL_LOCKED;\n    channelIndex = channelConfig->Rank;\n    if (channelIndex < 7) {\n      channelIndex = channelIndex * 5 - 5;\n      adcHandle->Instance->SQR3 =\n           channelConfig->Channel << (channelIndex & 0xff) | adcHandle->Instance->SQR3 & ~(0x1f << (channelIndex & 0xff));\n    }\n    else if (channelIndex < 0xd) {\n      channelIndex = channelIndex * 5 - 0x23;\n      adcHandle->Instance->SQR2 =\n           channelConfig->Channel << (channelIndex & 0xff) | adcHandle->Instance->SQR2 & ~(0x1f << (channelIndex & 0xff));\n    }\n    else {\n      channelIndex = channelIndex * 5 - 0x41;\n      adcHandle->Instance->SQR1 =\n           channelConfig->Channel << (channelIndex & 0xff) | adcHandle->Instance->SQR1 & ~(0x1f << (channelIndex & 0xff));\n    }\n    channelIndex = channelConfig->Channel;\n    if (channelIndex < 10) {\n      adcHandle->Instance->SMPR2 =\n           channelConfig->SamplingTime << (channelIndex * 3 & 0xff) |\n           adcHandle->Instance->SMPR2 & ~(7 << (channelIndex * 3 & 0xff));\n    }\n    else {\n      channelIndex = channelIndex * 3 - 0x1e;\n      adcHandle->Instance->SMPR1 =\n           channelConfig->SamplingTime << (channelIndex & 0xff) | adcHandle->Instance->SMPR1 & ~(7 << (channelIndex & 0xff));\n    }\n    if (channelConfig->Channel - 0x10 < 2) {\n      if (adcHandle->Instance == (ADC_TypeDef *)0x40012400) {\n        if ((uRam40012408 & 0x800000) == 0) {\n          uRam40012408 = uRam40012408 | 0x800000;\n          if (channelConfig->Channel == 0x10) {\n            for (loopIndex = (SystemCoreClock / 1000000) * 10; loopIndex != 0;\n                loopIndex = loopIndex - 1) {\n            }\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        adcHandle->State = adcHandle->State | 0x20;\n        status = HAL_ERROR;\n      }\n    }\n    else {\n      status = HAL_OK;\n    }\n    adcHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080038e4": "configure_adc_channel_080038e4",
                "hadc": "adcHandle",
                "sConfig": "channelConfig",
                "HVar1": "status",
                "uVar2": "channelIndex",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a1c": {
            "entrypoint": "0x08003a1c",
            "current_name": "get_state_08003a1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getState_08003a1c(ADC_HandleTypeDef *hadc)\n\n{\n  return hadc->adcState;\n}\n\n",
            "renaming": {
                "FUN_08003a1c": "get_state_08003a1c",
                "State": "adcState"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a20": {
            "entrypoint": "0x08003a20",
            "current_name": "initialize_adc_08003a20",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeADC_08003a20(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef HVar1;\n  uint32_t startTick;\n  uint32_t currentTick;\n  ADC_TypeDef *adcInstance;\n  uint32_t loopIndex;\n  \n  adcInstance = hadc->Instance;\n  if ((adcInstance->CR2 & 1) == 0) {\n    adcInstance->CR2 = adcInstance->CR2 | 1;\n    for (loopIndex = systemClock / 1000000; loopIndex != 0;\n        loopIndex = loopIndex - 1) {\n    }\n    startTick = getCurrentTick();\n    do {\n      if ((hadc->Instance->CR2 & 1) != 0) {\n        return HAL_OK;\n      }\n      currentTick = getCurrentTick();\n    } while (currentTick - startTick < 3);\n    hadc->State = hadc->State | 0x10;\n    hadc->ErrorCode = hadc->ErrorCode | 1;\n    hadc->Lock = HAL_UNLOCKED;\n    HVar1 = HAL_ERROR;\n  }\n  else {\n    HVar1 = HAL_OK;\n  }\n  return HVar1;\n}\n\n",
            "renaming": {
                "FUN_08003a20": "initialize_adc_08003a20",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "uVar2": "startTick",
                "uVar3": "currentTick",
                "pAVar4": "adcInstance",
                "wait_loop_index": "loopIndex",
                "SystemCoreClock": "systemClock",
                "HAL_GetTick": "getCurrentTick"
            },
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003aa0": {
            "entrypoint": "0x08003aa0",
            "current_name": "enable_adc_08003aa0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict enableADC_08003aa0(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  ADC_TypeDef *pAVar2;\n  \n  if (hadc->isLocked != locked) {\n    hadc->isLocked = locked;\n    HVar1 = enableADC_08003aa0(hadc);\n    if (HVar1 == ok) {\n      hadc->State = hadc->State & 0xfffffcfe | 0x100;\n      pAVar2 = hadc->Instance;\n      if ((pAVar2 == (ADC_TypeDef *)0x40012800) && ((_DAT_40012404 & 0xf0000) != 0)) {\n        hadc->State = hadc->State | 0x100000;\n        if ((_DAT_40012404 & 0x400) != 0) {\n          hadc->State = hadc->State & 0xffffcfff | 0x1000;\n        }\n      }\n      else {\n        hadc->State = hadc->State & 0xffefffff;\n        if ((pAVar2->CR1 & 0x400) != 0) {\n          hadc->State = hadc->State & 0xffffcfff | 0x1000;\n        }\n      }\n      if ((hadc->State & 0x1000) == 0) {\n        hadc->ErrorCode = 0;\n      }\n      else {\n        hadc->ErrorCode = hadc->ErrorCode & 0xfffffff9;\n      }\n      hadc->isLocked = HAL_UNLOCKED;\n      pAVar2->SR = 0xfffffffd;\n      pAVar2 = hadc->Instance;\n      if (((pAVar2->CR2 & 0xe0000) == 0xe0000) &&\n         ((pAVar2 != (ADC_TypeDef *)0x40012800 || ((_DAT_40012404 & 0xf0000) == 0)))) {\n        pAVar2->CR2 = pAVar2->CR2 | 0x500000;\n      }\n      else {\n        pAVar2->CR2 = pAVar2->CR2 | 0x100000;\n      }\n    }\n    else {\n      hadc->isLocked = HAL_UNLOCKED;\n    }\n    return HVar1;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08003aa0": "enable_adc_08003aa0",
                "HAL_LOCKED": "locked",
                "HAL_OK": "ok",
                "Lock": "isLocked",
                "ADC_Enable": "enableADC"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_Enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003b8c": {
            "entrypoint": "0x08003b8c",
            "current_name": "check_adc_conversion_status_08003b8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict checkADCConversionStatus_08003b8c(ADC_HandleTypeDef *adcHandle)\n\n{\n  uint32_t startTick;\n  uint32_t currentTick;\n  ADC_TypeDef *adcInstance;\n  \n  adcInstance = adcHandle->Instance;\n  if ((adcInstance->CR2 & 1) == 0) {\n    return HAL_OK;\n  }\n  adcInstance->CR2 = adcInstance->CR2 & 0xfffffffe;\n  startTick = HAL_GetTick();\n  do {\n    if ((adcHandle->Instance->CR2 & 1) == 0) {\n      return HAL_OK;\n    }\n    currentTick = HAL_GetTick();\n  } while (currentTick - startTick < 3);\n  adcHandle->State = adcHandle->State | 0x10;\n  adcHandle->ErrorCode = adcHandle->ErrorCode | 1;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08003b8c": "check_adc_conversion_status_08003b8c",
                "hadc": "adcHandle",
                "pAVar3": "adcInstance",
                "uVar1": "startTick",
                "uVar2": "currentTick"
            },
            "calling": [
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Stop",
                "HAL_ADC_DeInit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003bd8": {
            "entrypoint": "0x08003bd8",
            "current_name": "initialize_adc_08003bd8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeADC_08003bd8(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t value1;\n  uint value2;\n  uint value3;\n  uint32_t value4;\n  \n  if (adcHandle == (ADC_HandleTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (adcHandle->State == 0) {\n    adcHandle->ErrorCode = 0;\n    adcHandle->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(adcHandle);\n  }\n  status = ADC_ConversionStop_Disable(adcHandle);\n  if (((adcHandle->State & 0x10) == 0) && (status == HAL_OK)) {\n    adcHandle->State = adcHandle->State & 0xffffeefd | 2;\n    value4 = (adcHandle->Init).ContinuousConvMode;\n    value2 = (adcHandle->Init).DataAlign | (adcHandle->Init).ExternalTrigConv | value4 << 1;\n    value1 = (adcHandle->Init).ScanConvMode;\n    if (value1 == 0x100) {\n      value3 = 0x100;\n    }\n    else {\n      value3 = 0;\n      if (value1 == 1) {\n        value3 = 0x100;\n      }\n    }\n    if ((adcHandle->Init).DiscontinuousConvMode == 1) {\n      if (value4 == 0) {\n        value3 = value3 | ((adcHandle->Init).NbrOfDiscConversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        adcHandle->State = adcHandle->State | 0x20;\n        adcHandle->ErrorCode = adcHandle->ErrorCode | 1;\n      }\n    }\n    adcHandle->Instance->CR1 = value3 | adcHandle->Instance->CR1 & 0xffff16ff;\n    adcHandle->Instance->CR2 = adcHandle->Instance->CR2 & 0xffe1f7fd | value2;\n    value1 = (adcHandle->Init).ScanConvMode;\n    if ((value1 == 0x100) || (value1 == 1)) {\n      value3 = ((adcHandle->Init).NbrOfConversion - 1) * 0x100000;\n    }\n    else {\n      value3 = 0;\n    }\n    adcHandle->Instance->SQR1 = value3 | adcHandle->Instance->SQR1 & 0xff0fffff;\n    if (value2 != (adcHandle->Instance->CR2 & 0xff1f0efe)) {\n      adcHandle->State = adcHandle->State & 0xffffffed | 0x10;\n      adcHandle->ErrorCode = adcHandle->ErrorCode | 1;\n      return HAL_ERROR;\n    }\n    adcHandle->ErrorCode = 0;\n    adcHandle->State = adcHandle->State & 0xfffffffc | 1;\n    return HAL_OK;\n  }\n  adcHandle->State = adcHandle->State | 0x10;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08003bd8": "initialize_adc_08003bd8",
                "hadc": "adcHandle",
                "HVar1": "status",
                "uVar2": "value1",
                "uVar3": "value2",
                "uVar4": "value3",
                "uVar5": "value4"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_ADC_MspInit",
                "ADC_ConversionStop_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ce8": {
            "entrypoint": "0x08003ce8",
            "current_name": "disable_adc_conversion_08003ce8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict disableADCConversion_08003ce8(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  \n  if (adcHandle == (ADC_HandleTypeDef *)0x0) {\n    status = ERROR;\n  }\n  else {\n    adcHandle->State = adcHandle->State | 2;\n    status = ADC_ConversionStop_Disable(adcHandle);\n    if (status == OK) {\n      adcHandle->Instance->SR = 0xffffffe0;\n      adcHandle->Instance->CR1 = adcHandle->Instance->CR1 & 0xff3f0000;\n      adcHandle->Instance->CR2 = adcHandle->Instance->CR2 & 0xff0106f0;\n      adcHandle->Instance->SMPR1 = adcHandle->Instance->SMPR1 & 0xff000000;\n      adcHandle->Instance->SMPR2 = adcHandle->Instance->SMPR2 & 0xc0000000;\n      adcHandle->Instance->JOFR1 = adcHandle->Instance->JOFR1 & 0xfffff000;\n      adcHandle->Instance->JOFR2 = adcHandle->Instance->JOFR2 & 0xfffff000;\n      adcHandle->Instance->JOFR3 = adcHandle->Instance->JOFR3 & 0xfffff000;\n      adcHandle->Instance->JOFR4 = adcHandle->Instance->JOFR4 & 0xfffff000;\n      adcHandle->Instance->HTR = adcHandle->Instance->HTR & 0xfffff000;\n      adcHandle->Instance->LTR = adcHandle->Instance->LTR & 0xfffff000;\n      adcHandle->Instance->SQR1 = adcHandle->Instance->SQR1 & 0xff000000;\n      adcHandle->Instance->SQR1 = adcHandle->Instance->SQR1 & 0xff000000;\n      adcHandle->Instance->SQR2 = adcHandle->Instance->SQR2 & 0xc0000000;\n      adcHandle->Instance->SQR3 = adcHandle->Instance->SQR3 & 0xc0000000;\n      adcHandle->Instance->JSQR = adcHandle->Instance->JSQR & 0xffc00000;\n      adcHandle->Instance->JSQR = adcHandle->Instance->JSQR & 0xffc00000;\n      HAL_ADC_MspDeInit(adcHandle);\n      adcHandle->ErrorCode = 0;\n      adcHandle->State = 0;\n    }\n    adcHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003ce8": "disable_adc_conversion_08003ce8",
                "hadc": "adcHandle",
                "HVar1": "status",
                "HAL_ERROR": "ERROR",
                "HAL_OK": "OK"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003de4": {
            "entrypoint": "0x08003de4",
            "current_name": "stop_adc_conversion_08003de4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict stopADCConversion_08003de4(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  \n  if (adcHandle->Lock == locked) {\n    return busy;\n  }\n  adcHandle->Lock = locked;\n  status = disableADCConversionStop(adcHandle);\n  if (status == HAL_OK) {\n    adcHandle->state = adcHandle->state & 0xffffeefe | 1;\n  }\n  adcHandle->Lock = unlocked;\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003de4": "stop_adc_conversion_08003de4",
                "hadc": "adcHandle",
                "HVar1": "status",
                "HAL_LOCKED": "locked",
                "HAL_BUSY": "busy",
                "HAL_UNLOCKED": "unlocked",
                "ADC_ConversionStop_Disable": "disableADCConversionStop",
                "State": "state"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e20": {
            "entrypoint": "0x08003e20",
            "current_name": "perform_adc_conversion_08003e20",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict performADCConversion_08003e20(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t clockFreq;\n  uint32_t coreClock;\n  ADC_TypeDef *adcInstance;\n  uint32_t startTick;\n  uint32_t loopIndex;\n  \n  if (adcHandle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  adcHandle->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(adcHandle);\n  if (status == HAL_OK) {\n    adcHandle->State = adcHandle->State & 0xffffeefd | 2;\n    coreClock = SystemCoreClock;\n    clockFreq = HAL_RCCEx_GetPeriphCLKFreq(2);\n    for (loopIndex = coreClock / clockFreq << 1; loopIndex != 0;\n        loopIndex = loopIndex - 1) {\n    }\n    ADC_Enable(adcHandle);\n    adcHandle->Instance->CR2 = adcHandle->Instance->CR2 | 8;\n    coreClock = HAL_GetTick();\n    while (adcInstance = adcHandle->Instance, (adcInstance->CR2 & 8) != 0) {\n      clockFreq = HAL_GetTick();\n      if (10 < clockFreq - coreClock) {\n        adcHandle->State = adcHandle->State & 0xffffffed | 0x10;\n        adcHandle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adcInstance->CR2 = adcInstance->CR2 | 4;\n    coreClock = HAL_GetTick();\n    while ((adcHandle->Instance->CR2 & 4) != 0) {\n      clockFreq = HAL_GetTick();\n      if (10 < clockFreq - coreClock) {\n        adcHandle->State = adcHandle->State & 0xffffffed | 0x10;\n        adcHandle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adcHandle->State = adcHandle->State & 0xfffffffc | 1;\n  }\n  adcHandle->Lock = HAL_UNLOCKED;\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003e20": "perform_adc_conversion_08003e20",
                "hadc": "adcHandle",
                "HVar1": "status",
                "uVar2": "clockFreq",
                "uVar3": "coreClock",
                "pAVar4": "adcInstance",
                "tickstart": "startTick",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_Enable",
                "ADC_ConversionStop_Disable",
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f0c": {
            "entrypoint": "0x08003f0c",
            "current_name": "set_priority_group_08003f0c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setPriorityGroup_08003f0c(uint32_t priority)\n\n{\n  uint32_t registerValue;\n  \n  _DAT_e000ed0c = (priority & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f0c": "set_priority_group_08003f0c",
                "PriorityGroup": "priority",
                "reg_value": "registerValue"
            },
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f30": {
            "entrypoint": "0x08003f30",
            "current_name": "set_interrupt_priority_08003f30",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptPriority_08003f30(interrupt_type IRQn,uint32_t preempt_priority,uint32_t sub_priority)\n\n{\n  uint interrupt_number;\n  uint priority_mask;\n  uint32_t priority_group_temp;\n  uint32_t sub_priority_bits;\n  uint32_t preempt_priority_bits;\n  \n  interrupt_number = (uint)IRQn;\n  priority_mask = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preempt_priority_bits = 7 - priority_mask;\n  if (3 < preempt_priority_bits) {\n    preempt_priority_bits = 4;\n  }\n  if (priority_mask + 4 < 7) {\n    sub_priority_bits = 0;\n  }\n  else {\n    sub_priority_bits = priority_mask - 3;\n  }\n  priority_mask = (preempt_priority & (1 << (preempt_priority_bits & 0xff)) - 1U) << (sub_priority_bits & 0xff) |\n          (1 << (sub_priority_bits & 0xff)) - 1U & sub_priority;\n  if ((int)interrupt_number < 0) {\n    *(char *)((interrupt_number & 0xf) + 0xe000ed14) = (char)(priority_mask << 4);\n  }\n  else {\n    *(char *)(interrupt_number + 0xe000e400) = (char)(priority_mask << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f30": "set_interrupt_priority_08003f30",
                "IRQn_Type_conflict": "interrupt_type",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "PriorityGroupTmp": "priority_group_temp",
                "SubPriorityBits": "sub_priority_bits",
                "PreemptPriorityBits": "preempt_priority_bits",
                "uVar1": "interrupt_number",
                "uVar2": "priority_mask"
            },
            "calling": [
                "SystemClock_Config",
                "TimerPulseInit",
                "uart_attach_rx_callback",
                "uart_attach_tx_callback",
                "i2c_custom_init",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f94": {
            "entrypoint": "0x08003f94",
            "current_name": "set_interrupt_flag_08003f94",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptFlag_08003f94(interruptNumber IRQn)\n\n{\n  uint convertedInterruptNumber;\n  \n  convertedInterruptNumber = (uint)IRQn;\n  if (-1 < (int)convertedInterruptNumber) {\n    *(int *)((convertedInterruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << (convertedInterruptNumber & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f94": "set_interrupt_flag_08003f94",
                "IRQn_Type_conflict": "interruptNumber",
                "uVar1": "convertedInterruptNumber"
            },
            "calling": [
                "TimerPulseInit",
                "uart_attach_rx_callback",
                "uart_attach_tx_callback",
                "i2c_custom_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fb0": {
            "entrypoint": "0x08003fb0",
            "current_name": "initialize_interrupt_08003fb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeInterrupt_08003fb0(interruptType IRQn)\n\n{\n  uint interruptIndex;\n  \n  interruptIndex = (uint)IRQn;\n  if (-1 < (int)interruptIndex) {\n    *(int *)(((interruptIndex >> 5) + 0x20) * 4 + -0x1fff1f00) = 1 << (interruptIndex & 0x1f);\n    DataSynchronizationBarrier(0xf);\n    InstructionSynchronizationBarrier(0xf);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fb0": "initialize_interrupt_08003fb0",
                "IRQn_Type_conflict": "interruptType",
                "uVar1": "interruptIndex"
            },
            "calling": [
                "TimerPulseDeinit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fd8": {
            "entrypoint": "0x08003fd8",
            "current_name": "initialize_timer_08003fd8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t initializeTimer_08003fd8(uint32_t ticksNumber)\n\n{\n  if (ticksNumber - 1 < 0x1000000) {\n    _DAT_e000e014 = ticksNumber - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08003fd8": "initialize_timer_08003fd8",
                "TicksNumb": "ticksNumber"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004004": {
            "entrypoint": "0x08004004",
            "current_name": "set_irq_enabled_08004004",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setIRQEnabled_08004004(interruptNumber_Type_conflict interruptNumber)\n\n{\n  uint convertedNumber;\n  \n  convertedNumber = (uint)interruptNumber;\n  if (-1 < (int)convertedNumber) {\n    *(int *)(((convertedNumber >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (convertedNumber & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004004": "set_irq_enabled_08004004",
                "IRQn": "interruptNumber",
                "uVar1": "convertedNumber"
            },
            "calling": [
                "USART1_IRQHandler",
                "USART3_IRQHandler",
                "USART2_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004024": {
            "entrypoint": "0x08004024",
            "current_name": "set_clock_source_08004024",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setClockSource_08004024(uint32_t source)\n\n{\n  if (source != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004024": "set_clock_source_08004024",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004044": {
            "entrypoint": "0x08004044",
            "current_name": "FUNC_08004044",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004044(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004044": "FUNC_08004044"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004046": {
            "entrypoint": "0x08004046",
            "current_name": "execute_hal_systick_callback_08004046",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid execute_HAL_SYSTICK_Callback_08004046(void)\n\n{\n  perform_SYSTICK_Callback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004046": "execute_hal_systick_callback_08004046",
                "HAL_SYSTICK_Callback": "perform_SYSTICK_Callback"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004050": {
            "entrypoint": "0x08004050",
            "current_name": "configure_dma_channel_08004050",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_Status configureDMAChannel_08004050(DMA_HandleTypeDef_conflict *dmaHandle)\n\n{\n  DMA_Channel_TypeDef_conflict *currentChannel;\n  \n  if (dmaHandle->State != DMA_STATE_BUSY) {\n    dmaHandle->ErrorCode = 4;\n    return ERROR;\n  }\n  dmaHandle->Instance->CCR = dmaHandle->Instance->CCR & 0xfffffff1;\n  dmaHandle->Instance->CCR = dmaHandle->Instance->CCR & 0xfffffffe;\n  currentChannel = dmaHandle->Instance;\n  if (currentChannel == (DMA_Channel_TypeDef_conflict *)0x40020008) {\n    _DAT_40020004 = 1;\n  }\n  else if (currentChannel == (DMA_Channel_TypeDef_conflict *)0x4002001c) {\n    _DAT_40020004 = 0x10;\n  }\n  else if (currentChannel == (DMA_Channel_TypeDef_conflict *)0x40020030) {\n    _DAT_40020004 = 0x100;\n  }\n  else if (currentChannel == (DMA_Channel_TypeDef_conflict *)0x40020044) {\n    _DAT_40020004 = 0x1000;\n  }\n  else if (currentChannel == (DMA_Channel_TypeDef_conflict *)0x40020058) {\n    _DAT_40020004 = 0x10000;\n  }\n  else if (currentChannel == (DMA_Channel_TypeDef_conflict *)0x4002006c) {\n    _DAT_40020004 = 0x100000;\n  }\n  else {\n    _DAT_40020004 = 0x1000000;\n  }\n  dmaHandle->State = DMA_STATE_READY;\n  dmaHandle->Lock = UNLOCKED;\n  if (dmaHandle->XferAbortCallback != (XferAbortCallback *)0x0) {\n    (*dmaHandle->XferAbortCallback)(dmaHandle);\n    return OK;\n  }\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08004050": "configure_dma_channel_08004050",
                "hdma": "dmaHandle",
                "pDVar1": "currentChannel",
                "HAL_StatusTypeDef_conflict": "HAL_Status",
                "HAL_DMA_STATE_BUSY": "DMA_STATE_BUSY",
                "HAL_DMA_STATE_READY": "DMA_STATE_READY",
                "HAL_ERROR": "ERROR",
                "HAL_OK": "OK",
                "HAL_UNLOCKED": "UNLOCKED",
                "_func_void___DMA_HandleTypeDef_ptr_conflict": "XferAbortCallback"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "configure_gpio_080040e8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_080040e8(GPIO_TypeDef *gpioPort,gpioInitTypeDef *gpioInit)\n\n{\n  GPIO_TypeDef *gpioPortVar;\n  uint bitMask;\n  uint pinValue;\n  uint bitIndex;\n  uint gpioMode;\n  uint32_t gpioSpeed;\n  int tempVar1;\n  uint32_t *configRegister;\n  int tempVar2;\n  uint32_t temporaryRegister;\n  \n  gpioSpeed = 0;\n  bitIndex = 0;\n  do {\n    if (0xf < bitIndex) {\n      return;\n    }\n    bitMask = 1 << (bitIndex & 0xff);\n    pinValue = gpioInit->Pin & bitMask;\n    if (bitMask == pinValue) {\n      gpioMode = gpioInit->Mode;\n      if (gpioMode == 0x12) {\n        gpioSpeed = gpioInit->Speed + 0xc;\n      }\n      else if (gpioMode < 0x13) {\n        if (gpioMode == 2) {\n          gpioSpeed = gpioInit->Speed + 8;\n        }\n        else if (gpioMode < 3) {\n          if (gpioMode == 0) goto LAB_0800423a;\n          if (gpioMode == 1) {\n            gpioSpeed = gpioInit->Speed;\n          }\n        }\n        else if (gpioMode == 3) {\n          gpioSpeed = 0;\n        }\n        else if (gpioMode == 0x11) {\n          gpioSpeed = gpioInit->Speed + 4;\n        }\n      }\n      else if (gpioMode == 0x10210000) {\nLAB_0800423a:\n        if (gpioInit->Pull == 0) {\n          gpioSpeed = 4;\n        }\n        else if (gpioInit->Pull == 1) {\n          gpioPort->BSRR = bitMask;\n          gpioSpeed = 8;\n        }\n        else {\n          gpioPort->BRR = bitMask;\n          gpioSpeed = 8;\n        }\n      }\n      else if (gpioMode < 0x10210001) {\n        if ((gpioMode == 0x10110000) || (gpioMode == 0x10120000)) goto LAB_0800423a;\n      }\n      else if ((gpioMode == 0x10310000) || ((gpioMode == 0x10320000 || (gpioMode == 0x10220000))))\n      goto LAB_0800423a;\n      bitMask = bitIndex;\n      gpioPortVar = gpioPort;\n      if (0xff < pinValue) {\n        bitMask = bitIndex - 8;\n        gpioPortVar = (GPIO_TypeDef *)&gpioPort->CRH;\n      }\n      gpioPortVar->CRL = gpioPortVar->CRL & ~(0xf << (bitMask << 2 & 0xff)) | gpioSpeed << (bitMask << 2 & 0xff);\n      if ((gpioInit->Mode & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        tempVar1 = (bitIndex & 3) << 2;\n        if (gpioPort == (GPIO_TypeDef *)0x40010800) {\n          tempVar2 = 0;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40010c00) {\n          tempVar2 = 1;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011000) {\n          tempVar2 = 2;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011400) {\n          tempVar2 = 3;\n        }\n        else {\n          tempVar2 = 4;\n        }\n        *(uint *)(((bitIndex >> 2) + 2) * 4 + 0x40010000) =\n             *(uint *)(((bitIndex >> 2) + 2) * 4 + 0x40010000) & ~(0xf << tempVar1) | tempVar2 << tempVar1;\n        if ((gpioInit->Mode & 0x10000) == 0) {\n          _DAT_40010400 = _DAT_40010400 & ~pinValue;\n        }\n        else {\n          _DAT_40010400 = _DAT_40010400 | pinValue;\n        }\n        if ((gpioInit->Mode & 0x20000) == 0) {\n          _DAT_40010404 = _DAT_40010404 & ~pinValue;\n        }\n        else {\n          _DAT_40010404 = _DAT_40010404 | pinValue;\n        }\n        if ((gpioInit->Mode & 0x100000) == 0) {\n          _DAT_40010408 = _DAT_40010408 & ~pinValue;\n        }\n        else {\n          _DAT_40010408 = _DAT_40010408 | pinValue;\n        }\n        if ((gpioInit->Mode & 0x200000) == 0) {\n          _DAT_4001040c = _DAT_4001040c & ~pinValue;\n        }\n        else {\n          _DAT_4001040c = pinValue | _DAT_4001040c;\n        }\n      }\n    }\n    bitIndex = bitIndex + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080040e8": "configure_gpio_080040e8",
                "GPIOx": "gpioPort",
                "GPIO_Init": "gpioInit",
                "pGVar1": "gpioPortVar",
                "uVar2": "bitMask",
                "uVar3": "pinValue",
                "uVar4": "bitIndex",
                "uVar5": "gpioMode",
                "uVar6": "gpioSpeed",
                "configregister": "configRegister",
                "iVar7": "tempVar1",
                "iVar8": "tempVar2",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "uart_init",
                "HAL_TIM_PWM_MspInit",
                "HAL_ADC_MspInit",
                "digital_io_init",
                "i2c_custom_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042d4": {
            "entrypoint": "0x080042d4",
            "current_name": "check_pin_state_080042d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\npinState checkPinState_080042d4(GPIO_TypeDef *port,uint16_t pin)\n\n{\n  pinState state;\n  \n  if (((uint)pin & port->IDR) == 0) {\n    state = GPIO_PIN_RESET;\n    return state;\n  }\n  return GPIO_PIN_SET;\n}\n\n",
            "renaming": {
                "FUN_080042d4": "check_pin_state_080042d4",
                "GPIOx": "port",
                "GPIO_Pin": "pin",
                "bitstatus": "state"
            },
            "calling": [
                "digital_io_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042e2": {
            "entrypoint": "0x080042e2",
            "current_name": "set_gpio_pin_state_080042e2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_GPIO_PinState_080042e2(GPIO_TypeDef *GPIO_port,uint16_t pin,pinState state)\n\n{\n  if (state == GPIO_PIN_RESET) {\n    GPIO_port->BSRR = (uint)pin << 0x10;\n    return;\n  }\n  GPIO_port->BSRR = (uint)pin;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080042e2": "set_gpio_pin_state_080042e2",
                "GPIOx": "GPIO_port",
                "GPIO_Pin": "pin",
                "PinState": "state"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042f0": {
            "entrypoint": "0x080042f0",
            "current_name": "handle_gpio_pin_080042f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_Pin_080042f0(uint16_t pin_number)\n\n{\n  if ((_DAT_40010414 & pin_number) != 0) {\n    _DAT_40010414 = (uint)pin_number;\n    handle_external_interrupt(pin_number);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080042f0": "handle_gpio_pin_080042f0",
                "GPIO_Pin": "pin_number",
                "HAL_GPIO_EXTI_Callback": "handle_external_interrupt"
            },
            "calling": [
                "EXTI15_10_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI4_IRQHandler",
                "EXTI1_IRQHandler",
                "EXTI0_IRQHandler"
            ],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800430c": {
            "entrypoint": "0x0800430c",
            "current_name": "set_i2_c_device_address_0800430c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict setI2CDeviceAddress_0800430c(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  if (i2cHandle->i2cMode == HAL_I2C_MODE_MEMORY) {\n    if (i2cHandle->eventCount == 0) {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xfe;\n    }\n    else {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xff | 1;\n    }\n  }\n  else if ((i2cHandle->i2cInit).addressingMode == 0x4000) {\n    if (i2cHandle->i2cState == HAL_I2C_STATE_BUSY_TRANSMIT) {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xfe;\n    }\n    else {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xff | 1;\n    }\n  }\n  else if (i2cHandle->eventCount == 0) {\n    i2cHandle->i2cInstance->dataRegister = (i2cHandle->deviceAddress << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (i2cHandle->eventCount == 1) {\n    i2cHandle->i2cInstance->dataRegister = (i2cHandle->deviceAddress << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800430c": "set_i2_c_device_address_0800430c",
                "hi2c": "i2cHandle",
                "Mode": "i2cMode",
                "EventCount": "eventCount",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "Devaddress": "deviceAddress",
                "Init": "i2cInit",
                "AddressingMode": "addressingMode",
                "State": "i2cState",
                "HAL_I2C_MODE_MEM": "HAL_I2C_MODE_MEMORY",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TRANSMIT"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004396": {
            "entrypoint": "0x08004396",
            "current_name": "set_device_address_08004396",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus setDeviceAddress_08004396(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xff;\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08004396": "set_device_address_08004396",
                "hi2c": "i2cHandle",
                "HAL_StatusTypeDef_conflict": "Status",
                "HAL_OK": "OK"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043a2": {
            "entrypoint": "0x080043a2",
            "current_name": "handle_i2_crx_event_080043a2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CRXEvent_080043a2(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t tempVar1;\n  I2C_TypeDef_conflict *i2cInstance;\n  uint32_t previousState;\n  uint32_t tempRegister;\n  uint32_t tempRegister1;\n  uint32_t tempRegister2;\n  uint32_t tempRegister3;\n  uint32_t tempRegister4;\n  uint32_t tempRegister5;\n  uint32_t tempRegister6;\n  uint32_t tempRegister7;\n  uint32_t tempRegister8;\n  uint32_t tempRegister9;\n  uint32_t tempRegister10;\n  \n  tempVar1 = i2cHandle->XferOptions;\n  if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((i2cHandle->EventCount != 0 || (i2cHandle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((i2cHandle->EventCount == 0) && ((i2cHandle->Init).AddressingMode == 0xc000)) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      i2cHandle->EventCount = i2cHandle->EventCount + 1;\n    }\n    else {\n      if (i2cHandle->XferCount == 0) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      else if (i2cHandle->XferCount == 1) {\n        if (tempVar1 == 0xffff0000) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cInstance = i2cHandle->Instance;\n          if ((i2cInstance->CR2 & 0x800) == 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n          }\n          else {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((tempVar1 == 4) || (tempVar1 == 8)) || (i2cHandle->PreviousState == 0x12)) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (i2cHandle->XferCount == 2) {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      else {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      i2cHandle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080043a2": "handle_i2_crx_event_080043a2",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar1": "tempVar1",
                "pIVar2": "i2cInstance",
                "Prev_State": "previousState",
                "tmpreg": "tempRegister",
                "tmpreg_1": "tempRegister1",
                "tmpreg_2": "tempRegister2",
                "tmpreg_3": "tempRegister3",
                "tmpreg_4": "tempRegister4",
                "tmpreg_5": "tempRegister5",
                "tmpreg_6": "tempRegister6",
                "tmpreg_7": "tempRegister7",
                "tmpreg_8": "tempRegister8",
                "tmpreg_9": "tempRegister9",
                "tmpreg_10": "tempRegister10"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800457c": {
            "entrypoint": "0x0800457c",
            "current_name": "send_byte_0800457c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict sendByte_0800457c(I2C_HandleTypeDef_conflict *i2cHandler)\n\n{\n  byte *pbVar1;\n  \n  if (i2cHandler->transferCount != 0) {\n    pbVar1 = i2cHandler->bufferPointer;\n    i2cHandler->bufferPointer = pbVar1 + 1;\n    i2cHandler->i2cInstance->dataRegister = (uint)*pbVar1;\n    i2cHandler->transferCount = i2cHandler->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800457c": "send_byte_0800457c",
                "hi2c": "i2cHandler",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800459c": {
            "entrypoint": "0x0800459c",
            "current_name": "read_data_from_i2_c_0800459c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict readDataFromI2C_0800459c(I2C_HandleTypeDef_conflict *I2C_Handle)\n\n{\n  uint8_t *puVar1;\n  \n  if (I2C_Handle->transferCount != 0) {\n    puVar1 = I2C_Handle->bufferPointer;\n    I2C_Handle->bufferPointer = puVar1 + 1;\n    *puVar1 = (uint8_t)I2C_Handle->DENKQFXXdataRegister->dataRegister;\n    I2C_Handle->transferCount = I2C_Handle->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800459c": "read_data_from_i2_c_0800459c",
                "hi2c": "I2C_Handle",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045bc": {
            "entrypoint": "0x080045bc",
            "current_name": "FUNC_080045bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080045bc(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080045bc": "FUNC_080045bc"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080045c0": {
            "entrypoint": "0x080045c0",
            "current_name": "initialize_i2_c_080045c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_Status initializeI2C_080045c0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  bool isClockSpeedValid;\n  uint32_t pclk1Freq;\n  uint prescaler;\n  uint riseTime;\n  uint32_t dutyCycle;\n  \n  if (i2cHandle == (I2C_HandleTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (i2cHandle->State == HAL_I2C_STATE_RESET) {\n    i2cHandle->Lock = HAL_UNLOCKED;\n    HAL_I2C_MspInit(i2cHandle);\n  }\n  i2cHandle->State = HAL_I2C_STATE_BUSY;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n  pclk1Freq = HAL_RCC_GetPCLK1Freq();\n  if ((i2cHandle->Init).ClockSpeed < 0x186a1) {\n    if (pclk1Freq < 2000000) {\n      isClockSpeedValid = true;\n    }\n    else {\n      isClockSpeedValid = false;\n    }\n  }\n  else {\n    isClockSpeedValid = pclk1Freq < 4000000;\n  }\n  if (isClockSpeedValid) {\n    return HAL_ERROR;\n  }\n  prescaler = pclk1Freq / 1000000;\n  i2cHandle->Instance->CR2 = prescaler;\n  if (100000 < (i2cHandle->Init).ClockSpeed) {\n    prescaler = (prescaler * 300) / 1000;\n  }\n  i2cHandle->Instance->TRISE = prescaler + 1;\n  prescaler = (i2cHandle->Init).ClockSpeed;\n  if (prescaler < 0x186a1) {\n    pclk1Freq = (pclk1Freq - 1) / (prescaler << 1) + 1 & 0xfff;\n    if (pclk1Freq < 4) {\n      pclk1Freq = 4;\n    }\n  }\n  else {\n    dutyCycle = (i2cHandle->Init).DutyCycle;\n    if (dutyCycle == 0) {\n      riseTime = (pclk1Freq - 1) / (prescaler * 3);\n    }\n    else {\n      riseTime = (pclk1Freq - 1) / (prescaler * 0x19);\n    }\n    if ((riseTime + 1 & 0xfff) == 0) {\n      pclk1Freq = 1;\n    }\n    else if (dutyCycle == 0) {\n      pclk1Freq = (pclk1Freq - 1) / (prescaler * 3) + 1 & 0xfff | 0x8000;\n    }\n    else {\n      pclk1Freq = (pclk1Freq - 1) / (prescaler * 0x19) + 1 & 0xfff | 0xc000;\n    }\n  }\n  i2cHandle->Instance->CCR = pclk1Freq;\n  i2cHandle->Instance->CR1 = (i2cHandle->Init).GeneralCallMode | (i2cHandle->Init).NoStretchMode;\n  i2cHandle->Instance->OAR1 = (i2cHandle->Init).AddressingMode | (i2cHandle->Init).OwnAddress1;\n  i2cHandle->Instance->OAR2 = (i2cHandle->Init).DualAddressMode | (i2cHandle->Init).OwnAddress2;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n  i2cHandle->ErrorCode = 0;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->PreviousState = 0;\n  i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080045c0": "initialize_i2_c_080045c0",
                "hi2c": "i2cHandle",
                "bVar1": "isClockSpeedValid",
                "uVar2": "pclk1Freq",
                "uVar3": "prescaler",
                "uVar4": "riseTime",
                "uVar5": "dutyCycle",
                "HAL_StatusTypeDef_conflict": "HAL_Status",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef"
            },
            "calling": [
                "i2c_custom_init"
            ],
            "called": [
                "HAL_I2C_MspInit",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004728": {
            "entrypoint": "0x08004728",
            "current_name": "send_data_over_i2_c_08004728",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nsendDataOverI2C_08004728(I2C_HandleTypeDef_conflict *i2cHandle,uint16_t deviceAddress,uint8_t *data,uint16_t size)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2cInstance;\n  uint32_t timeoutCount;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_READY) {\n    timeoutCount = (SystemCoreClock / 25000) * 0x19;\n    do {\n      if (timeoutCount == 0) {\n        i2cHandle->PreviousState = 0;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        i2cHandle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      i2cInstance = i2cHandle->Instance;\n      timeoutCount = timeoutCount - 1;\n    } while ((i2cInstance->SR2 & 2) != 0);\n    if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_TX;\n      i2cHandle->Mode = HAL_I2C_MODE_MASTER;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = data;\n      i2cHandle->XferCount = size;\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->Xfersize = i2cHandle->XferCount;\n      i2cHandle->Devaddress = (uint)deviceAddress;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08004728": "send_data_over_i2_c_08004728",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "pData": "data",
                "Size": "size",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "count": "timeoutCount"
            },
            "calling": [
                "i2c_master_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047f4": {
            "entrypoint": "0x080047f4",
            "current_name": "check_i2_c_device_status_080047f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\ncheckI2CDeviceStatus_080047f4(I2C_HandleTypeDef_conflict *I2CHandle,uint16_t DeviceAddress,uint8_t *Data,uint16_t DataSize)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *I2CInstance;\n  uint32_t timeoutCount;\n  \n  if (I2CHandle->State == HAL_I2C_STATE_READY) {\n    timeoutCount = (SystemCoreClock / 25000) * 0x19;\n    do {\n      if (timeoutCount == 0) {\n        I2CHandle->PreviousState = 0;\n        I2CHandle->State = HAL_I2C_STATE_READY;\n        I2CHandle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      I2CInstance = I2CHandle->Instance;\n      timeoutCount = timeoutCount - 1;\n    } while ((I2CInstance->SR2 & 2) != 0);\n    if (I2CHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      I2CHandle->Lock = HAL_LOCKED;\n      if ((I2CInstance->CR1 & 1) == 0) {\n        I2CInstance->CR1 = I2CInstance->CR1 | 1;\n      }\n      I2CHandle->Instance->CR1 = I2CHandle->Instance->CR1 & 0xfffff7ff;\n      I2CHandle->State = HAL_I2C_STATE_BUSY_RX;\n      I2CHandle->Mode = HAL_I2C_MODE_MASTER;\n      status = HAL_OK;\n      I2CHandle->ErrorCode = 0;\n      I2CHandle->pBuffPtr = Data;\n      I2CHandle->XferCount = DataSize;\n      I2CHandle->XferOptions = 0xffff0000;\n      I2CHandle->XferDataSize = I2CHandle->XferCount;\n      I2CHandle->Devaddress = (uint)DeviceAddress;\n      I2CHandle->Instance->CR1 = I2CHandle->Instance->CR1 | 0x400;\n      I2CHandle->Instance->CR1 = I2CHandle->Instance->CR1 | 0x100;\n      I2CHandle->Lock = HAL_UNLOCKED;\n      I2CHandle->Instance->CR2 = I2CHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080047f4": "check_i2_c_device_status_080047f4",
                "hi2c": "I2CHandle",
                "DevAddress": "DeviceAddress",
                "pData": "Data",
                "Size": "DataSize",
                "HVar1": "status",
                "pIVar2": "I2CInstance",
                "count": "timeoutCount"
            },
            "calling": [
                "i2c_master_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048c8": {
            "entrypoint": "0x080048c8",
            "current_name": "configure_i2_c_080048c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureI2C_080048c8(I2C_HandleTypeDef_conflict *i2cHandle,uint8_t *dataBuffer,uint16_t dataSize,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (dataBuffer == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (dataSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = dataBuffer;\n      i2cHandle->XferCount = dataSize;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->XferdataSize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080048c8": "configure_i2_c_080048c8",
                "hi2c": "i2cHandle",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004954": {
            "entrypoint": "0x08004954",
            "current_name": "configure_i2_c_listen_mode_08004954",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nconfigureI2CListenMode_08004954(I2C_HandleTypeDef *i2cHandle,uint8_t *dataBuffer,uint16_t bufferSize,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (dataBuffer == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (bufferSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = dataBuffer;\n      i2cHandle->XferCount = bufferSize;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->XferbufferSize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08004954": "configure_i2_c_listen_mode_08004954",
                "hi2c": "i2cHandle",
                "pData": "dataBuffer",
                "Size": "bufferSize",
                "XferOptions": "transferOptions",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "I2C_TypeDef_conflict": "I2C_TypeDef",
                "tmpreg": "temporaryRegister",
                "HVar1": "status",
                "pIVar2": "i2cInstance"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049e0": {
            "entrypoint": "0x080049e0",
            "current_name": "initialize_i2_c_080049e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeI2C_080049e0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  \n  if (i2cHandle->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  i2cHandle->State = HAL_I2C_STATE_LISTEN;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR1 & 1) == 0) {\n    i2cInstance->CR1 = i2cInstance->CR1 | 1;\n  }\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x300;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080049e0": "initialize_i2_c_080049e0",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "I2C_TypeDef_conflict": "I2C_TypeDef"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "i2c_attachSlaveTxEvent",
                "i2c_attachSlaveRxEvent",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a1e": {
            "entrypoint": "0x08004a1e",
            "current_name": "FUNC_08004a1e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004a1e(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a1e": "FUNC_08004a1e"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004a20": {
            "entrypoint": "0x08004a20",
            "current_name": "FUNC_08004a20",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004a20(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a20": "FUNC_08004a20"
            },
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004a22": {
            "entrypoint": "0x08004a22",
            "current_name": "FUNC_08004a22",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004a22(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a22": "FUNC_08004a22"
            },
            "calling": [
                "I2C_Slave_AF",
                "I2C_SlaveTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004a24": {
            "entrypoint": "0x08004a24",
            "current_name": "transfer_byte_over_i2_c_08004a24",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef transferByteOverI2C_08004a24(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  byte *bufferPtr;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->XferCount != 0) {\n    bufferPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPtr + 1;\n    i2cHandle->Instance->DR = (uint)*bufferPtr;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    if ((i2cHandle->XferCount == 0) && (currentState == HAL_I2C_STATE_BUSY_TRANSMIT)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      i2cHandle->PreviousState = 0x21;\n      i2cHandle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n    }\n    return HAL_SUCCESS;\n  }\n  return HAL_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_08004a24": "transfer_byte_over_i2_c_08004a24",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pbVar2": "bufferPtr",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "HAL_I2C_StateTypeDef_conflict": "HAL_I2C_StateTypeDef",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "HAL_I2C_STATE_BUSY_TRANSMIT",
                "HAL_OK": "HAL_SUCCESS"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a74": {
            "entrypoint": "0x08004a74",
            "current_name": "FUNC_08004a74",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004a74(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a74": "FUNC_08004a74"
            },
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004a76": {
            "entrypoint": "0x08004a76",
            "current_name": "read_from_i2_c_08004a76",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict readFromI2C_08004a76(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef_conflict currentState;\n  uint8_t *bufferPtr;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->transferCount != 0) {\n    bufferPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    if ((i2cHandle->transferCount == 0) && (currentState == I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffbff;\n      i2cHandle->previousState = 0x22;\n      i2cHandle->State = I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004a76": "read_from_i2_c_08004a76",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "puVar2": "bufferPtr",
                "XferCount": "transferCount",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "CR2": "controlRegister2",
                "PreviousState": "previousState",
                "HAL_I2C_STATE_BUSY_RX_LISTEN": "I2C_STATE_BUSY_RX_LISTEN",
                "HAL_I2C_STATE_LISTEN": "I2C_STATE_LISTEN"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ac2": {
            "entrypoint": "0x08004ac2",
            "current_name": "handle_i2_c_address_match_08004ac2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CAddressMatch_08004ac2(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  uint16_t addressMatchCode;\n  \n  if ((i2cHandle->Instance->SR2 & 0x80) == 0) {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress1;\n  }\n  else {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2cHandle,(i2cHandle->Instance->SR2 & 4) == 0,addressMatchCode);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004ac2": "handle_i2_c_address_match_08004ac2",
                "hi2c": "i2cHandle",
                "AddrMatchCode": "addressMatchCode"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004aec": {
            "entrypoint": "0x08004aec",
            "current_name": "handle_i2_c_state_08004aec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CState_08004aec(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t currentState;\n  \n  if (((i2cHandle->XferOptions == 4) || (i2cHandle->XferOptions == 8)) &&\n     (i2cHandle->State == HAL_I2C_STATE_LISTEN)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  else if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0x21;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n  }\n  else {\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004aec": "handle_i2_c_state_08004aec",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "CurrentState": "currentState"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b80": {
            "entrypoint": "0x08004b80",
            "current_name": "FUNC_08004b80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004b80(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b80": "FUNC_08004b80"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004b82": {
            "entrypoint": "0x08004b82",
            "current_name": "handle_i2_c_state_08004b82",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CState_08004b82(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef_conflict currentState;\n  uint32_t currentState;\n  byte *dataPtr;\n  uint32_t currentTransferOptions;\n  uint32_t currentTransferOptions;\n  \n  currentState = i2cHandle->State;\n  currentTransferOptions = i2cHandle->XferOptions;\n  if ((i2cHandle->XferSize == 0) && (currentState == HAL_I2C_STATE_BUSY_TX)) {\n    if ((currentTransferOptions == 4) || ((currentTransferOptions == 8 || (currentTransferOptions == 0xffff0000)))) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(i2cHandle);\n      }\n      else {\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->PreviousState = 0x11;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(i2cHandle);\n    }\n  }\n  else if ((currentState == HAL_I2C_STATE_BUSY_TX) ||\n          ((i2cHandle->Mode == HAL_I2C_MODE_MEM && (currentState == HAL_I2C_STATE_BUSY_RX)))) {\n    if (i2cHandle->XferCount == 0) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n    }\n    else if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n      if (i2cHandle->EventCount == 0) {\n        if (i2cHandle->MemaddSize == 1) {\n          i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n          i2cHandle->EventCount = i2cHandle->EventCount + 2;\n        }\n        else {\n          i2cHandle->Instance->DR = (i2cHandle->Memaddress << 0x10) >> 0x18;\n          i2cHandle->EventCount = i2cHandle->EventCount + 1;\n        }\n      }\n      else if (i2cHandle->EventCount == 1) {\n        i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n        i2cHandle->EventCount = i2cHandle->EventCount + 1;\n      }\n      else if (i2cHandle->EventCount == 2) {\n        if (i2cHandle->State == HAL_I2C_STATE_BUSY_RX) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n        }\n        else if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n          dataPtr = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = dataPtr + 1;\n          i2cHandle->Instance->DR = (uint)*dataPtr;\n          i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        }\n      }\n    }\n    else {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      i2cHandle->Instance->DR = (uint)*dataPtr;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004b82": "handle_i2_c_state_08004b82",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "CurrentState": "currentState",
                "pbVar2": "dataPtr",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar3": "currentTransferOptions"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ccc": {
            "entrypoint": "0x08004ccc",
            "current_name": "handle_i2_c_transfer_08004ccc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CTransfer_08004ccc(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  byte *bufferPointer;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (i2cHandle->XferCount == 0) {\n      if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        i2cHandle->PreviousState = 0;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(i2cHandle);\n        }\n      }\n      else {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->PreviousState = 0x11;\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      bufferPointer = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPointer + 1;\n      i2cHandle->Instance->DR = (uint)*bufferPointer;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004ccc": "handle_i2_c_transfer_08004ccc",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "pbVar2": "bufferPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d6a": {
            "entrypoint": "0x08004d6a",
            "current_name": "FUNC_08004d6a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004d6a(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d6a": "FUNC_08004d6a"
            },
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004d6c": {
            "entrypoint": "0x08004d6c",
            "current_name": "handle_i2_c_rx_08004d6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CRx_08004d6c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint8_t *bufferPointer;\n  \n  if (i2cHandle->i2cState == HAL_I2C_STATE_RECEIVING) {\n    if (i2cHandle->transferCount < 4) {\n      if (i2cHandle->transferCount - 2 < 2) {\n        if (i2cHandle->transferOptions == 2) {\n          i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 | 0x400;\n        }\n        else {\n          i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 & 0xfffffbff;\n          i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 | 0x800;\n        }\n        i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffbff;\n      }\n      else {\n        if (i2cHandle->transferOptions == 2) {\n          i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 | 0x400;\n        }\n        else {\n          i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 & 0xfffffbff;\n        }\n        i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffff8ff;\n        bufferPointer = i2cHandle->bufferPointer;\n        i2cHandle->bufferPointer = bufferPointer + 1;\n        *bufferPointer = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n        i2cHandle->transferCount = i2cHandle->transferCount - 1;\n        i2cHandle->i2cState = HAL_I2C_STATE_IDLE;\n        i2cHandle->previousState = 0;\n        if (i2cHandle->i2cMode == HAL_I2C_MODE_MEMORY) {\n          i2cHandle->i2cMode = HAL_I2C_MODE_NO_OPERATION;\n          handleMemoryReceiveComplete(i2cHandle);\n        }\n        else {\n          i2cHandle->i2cMode = HAL_I2C_MODE_NO_OPERATION;\n          handleMasterReceiveComplete(i2cHandle);\n        }\n      }\n    }\n    else {\n      bufferPointer = i2cHandle->bufferPointer;\n      i2cHandle->bufferPointer = bufferPointer + 1;\n      *bufferPointer = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n      i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    }\n  }\n  return PdataRegisterNIDMYIO;\n}\n\n",
            "renaming": {
                "FUN_08004d6c": "handle_i2_c_rx_08004d6c",
                "hi2c": "i2cHandle",
                "puVar1": "bufferPointer",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "HAL_I2C_STATE_BUSY_RX": "HAL_I2C_STATE_RECEIVING",
                "HAL_I2C_MODE_MEM": "HAL_I2C_MODE_MEMORY",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NO_OPERATION",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_IDLE",
                "HAL_OK": "HAL_SUCCESS",
                "XferCount": "transferCount",
                "XferOptions": "transferOptions",
                "Instance": "i2cInstance",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "pBuffPtr": "bufferPointer",
                "Mode": "i2cMode",
                "State": "i2cState",
                "PreviousState": "previousState",
                "HAL_I2C_MemRxCpltCallback": "handleMemoryReceiveComplete",
                "HAL_I2C_MasterRxCpltCallback": "handleMasterReceiveComplete",
                "DR": "dataRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e3c": {
            "entrypoint": "0x08004e3c",
            "current_name": "process_i2_c_data_08004e3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processI2CData_08004e3c(I2C_HandleTypeDef_conflict *i2cHandler)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  uint8_t *bufferPointer;\n  \n  transferOptions = i2cHandler->XferOptions;\n  if (i2cHandler->transferCount == 3) {\n    if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n      i2cHandler->i2cInstance->controlRegister1 = i2cHandler->i2cInstance->controlRegister1 & 0xfffffbff;\n    }\n    bufferPointer = i2cHandler->dataBufferPointer;\n    i2cHandler->dataBufferPointer = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandler->i2cInstance->dataRegister;\n    i2cHandler->transferCount = i2cHandler->transferCount - 1;\n  }\n  else if (i2cHandler->transferCount == 2) {\n    if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n      i2cHandler->i2cInstance->controlRegister2 = i2cHandler->i2cInstance->controlRegister2 & 0xfffffcff;\n      i2cHandler->i2cInstance->controlRegister1 = i2cHandler->i2cInstance->controlRegister1 | 0x200;\n    }\n    else {\n      if (transferOptions == 2) {\n        i2cHandler->i2cInstance->controlRegister1 = i2cHandler->i2cInstance->controlRegister1 | 0x400;\n      }\n      else {\n        i2cHandler->i2cInstance->controlRegister1 = i2cHandler->i2cInstance->controlRegister1 & 0xfffffbff;\n      }\n      i2cHandler->i2cInstance->controlRegister2 = i2cHandler->i2cInstance->controlRegister2 & 0xfffffcff;\n    }\n    bufferPointer = i2cHandler->dataBufferPointer;\n    i2cHandler->dataBufferPointer = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandler->i2cInstance->dataRegister;\n    i2cHandler->transferCount = i2cHandler->transferCount - 1;\n    bufferPointer = i2cHandler->dataBufferPointer;\n    i2cHandler->dataBufferPointer = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandler->i2cInstance->dataRegister;\n    i2cHandler->transferCount = i2cHandler->transferCount - 1;\n    i2cHandler->currentState = STATE_READY;\n    i2cHandler->previousState = 0;\n    if (i2cHandler->operationMode == MODE_MEM) {\n      i2cHandler->operationMode = MODE_NONE;\n      memReceiveCompleteCallback(i2cHandler);\n    }\n    else {\n      i2cHandler->operationMode = MODE_NONE;\n      masterReceiveCompleteCallback(i2cHandler);\n    }\n  }\n  else {\n    bufferPointer = i2cHandler->dataBufferPointer;\n    i2cHandler->dataBufferPointer = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandler->i2cInstance->dataRegister;\n    i2cHandler->transferCount = i2cHandler->transferCount - 1;\n  }\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08004e3c": "process_i2_c_data_08004e3c",
                "hi2c": "i2cHandler",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "puVar2": "bufferPointer",
                "Instance": "i2cInstance",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "XferCount": "transferCount",
                "pBuffPtr": "dataBufferPointer",
                "DR": "dataRegister",
                "State": "currentState",
                "PreviousState": "previousState",
                "Mode": "operationMode",
                "HAL_I2C_STATE_READY": "STATE_READY",
                "HAL_I2C_MODE_MEM": "MODE_MEM",
                "HAL_I2C_MODE_NONE": "MODE_NONE",
                "HAL_I2C_MemRxCpltCallback": "memReceiveCompleteCallback",
                "HAL_I2C_MasterRxCpltCallback": "masterReceiveCompleteCallback",
                "HAL_OK": "OK"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3a": {
            "entrypoint": "0x08004f3a",
            "current_name": "FUNC_08004f3a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004f3a(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3a": "FUNC_08004f3a"
            },
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "handle_i2_c_state_08004f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CState_08004f3c(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint8_t *bufferPtr;\n  I2C_TypeDef_conflict *i2cInstance;\n  \n  if (i2cHandle->State - 0x29 < 2) {\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((i2cHandle->State != HAL_I2C_STATE_ABORT) && ((i2cHandle->Instance->CR2 & 0x800) == 0)) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n    }\n    i2cHandle->PreviousState = 0;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  }\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) == 0) {\n    if (i2cHandle->State == HAL_I2C_STATE_ABORT) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->ErrorCode = 0;\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        bufferPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = bufferPtr + 1;\n        *bufferPtr = (uint8_t)i2cInstance->DR;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(i2cHandle);\n    }\n    else {\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        bufferPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = bufferPtr + 1;\n        *bufferPtr = (uint8_t)i2cInstance->DR;\n      }\n      HAL_I2C_ErrorCallback(i2cHandle);\n    }\n  }\n  else {\n    i2cInstance->CR2 = i2cInstance->CR2 & 0xfffff7ff;\n    if (i2cHandle->hdmatx->State == HAL_DMA_STATE_READY) {\n      i2cHandle->hdmarx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmarx);\n      if (status != HAL_OK) {\n        if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n          bufferPtr = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = bufferPtr + 1;\n          *bufferPtr = (uint8_t)i2cHandle->Instance->DR;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmarx->XferAbortCallback)(i2cHandle->hdmarx);\n      }\n    }\n    else {\n      i2cHandle->hdmatx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmatx);\n      if (status != HAL_OK) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmatx->XferAbortCallback)(i2cHandle->hdmatx);\n      }\n    }\n  }\n  if ((i2cHandle->State == HAL_I2C_STATE_LISTEN) && ((i2cHandle->ErrorCode & 4) != 0)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "handle_i2_c_state_08004f3c",
                "hi2c": "i2cHandle",
                "HVar1": "status",
                "puVar2": "bufferPtr",
                "pIVar3": "i2cInstance"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_DMA_Abort_IT",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005084": {
            "entrypoint": "0x08005084",
            "current_name": "process_i2_c_transfer_08005084",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processI2CTransfer_08005084(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef_conflict currentState;\n  I2C_TypeDef_conflict *i2cInstance;\n  uint8_t *bufferPtr;\n  uint32_t currentState;\n  uint32_t tempRegister;\n  \n  currentState = i2cHandle->State;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) != 0) {\n    if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) || (i2cHandle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmarx->Instance->CNDTR;\n    }\n    else {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmatx->Instance->CNDTR;\n    }\n  }\n  if (i2cHandle->XferCount != 0) {\n    if ((i2cInstance->SR1 & 4) != 0) {\n      bufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPtr + 1;\n      *bufferPtr = (uint8_t)i2cInstance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n      bufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPtr + 1;\n      *bufferPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n  }\n  if (i2cHandle->ErrorCode == 0) {\n    if (((currentState == HAL_I2C_STATE_LISTEN) || (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (currentState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2cHandle);\n    }\n    else if ((i2cHandle->PreviousState == 0x22) || (currentState == HAL_I2C_STATE_BUSY_RX)) {\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    I2C_ITError(i2cHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08005084": "process_i2_c_transfer_08005084",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pIVar2": "i2cInstance",
                "puVar3": "bufferPtr",
                "CurrentState": "currentState",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005188": {
            "entrypoint": "0x08005188",
            "current_name": "handle_i2_c_interrupt_08005188",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CInterrupt_08005188(I2CHandleConflict *i2cHandle)\n\n{\n  I2CTypedefConflict *i2cInstance;\n  uint32_t currentMode;\n  uint statusRegister1;\n  uint32_t sr1ITFlags;\n  uint controlRegister2;\n  uint32_t itsources;\n  uint statusRegister2;\n  uint32_t sr2itflags;\n  \n  i2cInstance = i2cHandle->Instance;\n  statusRegister2 = i2cInstance->SR2;\n  statusRegister1 = i2cInstance->SR1;\n  controlRegister2 = i2cInstance->CR2;\n  if ((i2cHandle->Mode == HAL_I2C_MODE_MASTER) || (i2cHandle->Mode == HAL_I2C_MODE_MEM)) {\n    if (((statusRegister1 & 0x10001) == 0) || ((controlRegister2 & 0x200) == 0)) {\n      if (((statusRegister1 & 0x10008) == 0) || ((controlRegister2 & 0x200) == 0)) {\n        if (((statusRegister1 & 0x10002) != 0) && ((controlRegister2 & 0x200) != 0)) {\n          I2C_Master_ADDR(i2cHandle);\n        }\n      }\n      else {\n        I2C_Master_ADD10(i2cHandle);\n      }\n    }\n    else {\n      I2C_Master_SB(i2cHandle);\n    }\n    if ((statusRegister2 & 0x100004) == 0) {\n      if ((((statusRegister1 & 0x10040) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_MasterReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(i2cHandle);\n        return;\n      }\n    }\n    else {\n      if ((((statusRegister1 & 0x10080) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_MasterTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  else {\n    if (((statusRegister1 & 0x10002) != 0) && ((controlRegister2 & 0x200) != 0)) {\n      I2C_Slave_ADDR(i2cHandle);\n      return;\n    }\n    if (((statusRegister1 & 0x10010) != 0) && ((controlRegister2 & 0x200) != 0)) {\n      I2C_Slave_STOPF(i2cHandle);\n      return;\n    }\n    if ((statusRegister2 & 0x100004) == 0) {\n      if ((((statusRegister1 & 0x10040) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_SlaveReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(i2cHandle);\n      }\n    }\n    else {\n      if ((((statusRegister1 & 0x10080) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_SlaveTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005188": "handle_i2_c_interrupt_08005188",
                "hi2c": "i2cHandle",
                "I2C_HandleTypeDef_conflict": "I2CHandleConflict",
                "I2C_TypeDef_conflict": "I2CTypedefConflict",
                "pIVar1": "i2cInstance",
                "CurrentMode": "currentMode",
                "uVar2": "statusRegister1",
                "sr1itflags": "sr1ITFlags",
                "uVar3": "controlRegister2",
                "uVar4": "statusRegister2"
            },
            "calling": [
                "I2C2_EV_IRQHandler",
                "I2C1_EV_IRQHandler"
            ],
            "called": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF",
                "I2C_SlaveReceive_RXNE",
                "I2C_MasterTransmit_TXE",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_TXE",
                "I2C_Master_SB",
                "I2C_Master_ADD10",
                "I2C_MasterTransmit_BTF",
                "I2C_SlaveReceive_BTF",
                "I2C_Slave_STOPF",
                "I2C_Master_ADDR",
                "I2C_SlaveTransmit_BTF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052f0": {
            "entrypoint": "0x080052f0",
            "current_name": "handle_i2_c_errors_080052f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_I2C_errors_080052f0(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  HAL_I2C_StateTypeDef_conflict i2c_state;\n  I2C_TypeDef_conflict *i2c_instance;\n  uint32_t i2c_sr1_itflags;\n  uint sr1_value;\n  uint32_t itsources;\n  uint cr2_value;\n  \n  i2c_instance = i2c_handle->Instance;\n  sr1_value = i2c_instance->SR1;\n  cr2_value = i2c_instance->CR2;\n  if (((sr1_value & 0x10100) != 0) && ((cr2_value & 0x100) != 0)) {\n    i2c_handle->ErrorCode = i2c_handle->ErrorCode | 1;\n    i2c_instance->SR1 = 0xfffffeff;\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x8000;\n  }\n  if (((sr1_value & 0x10200) != 0) && ((cr2_value & 0x100) != 0)) {\n    i2c_handle->ErrorCode = i2c_handle->ErrorCode | 2;\n    i2c_handle->Instance->SR1 = 0xfffffdff;\n  }\n  if (((sr1_value & 0x10400) != 0) && ((cr2_value & 0x100) != 0)) {\n    i2c_state = i2c_handle->State;\n    if (((i2c_handle->Mode == HAL_I2C_MODE_SLAVE) && (i2c_handle->XferCount == 0)) &&\n       (((i2c_state == HAL_I2C_STATE_BUSY_TX || (i2c_state == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((i2c_state == HAL_I2C_STATE_LISTEN && (i2c_handle->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(i2c_handle);\n    }\n    else {\n      i2c_handle->ErrorCode = i2c_handle->ErrorCode | 4;\n      if (i2c_handle->Mode == HAL_I2C_MODE_MASTER) {\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n      }\n      i2c_handle->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((sr1_value & 0x10800) != 0) && ((cr2_value & 0x100) != 0)) {\n    i2c_handle->ErrorCode = i2c_handle->ErrorCode | 8;\n    i2c_handle->Instance->SR1 = 0xfffff7ff;\n  }\n  if (i2c_handle->ErrorCode != 0) {\n    I2C_ITError(i2c_handle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052f0": "handle_i2_c_errors_080052f0",
                "hi2c": "i2c_handle",
                "HVar1": "i2c_state",
                "pIVar2": "i2c_instance",
                "sr1itflags": "i2c_sr1_itflags",
                "uVar3": "sr1_value",
                "uVar4": "cr2_value"
            },
            "calling": [
                "I2C2_ER_IRQHandler",
                "I2C1_ER_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053cc": {
            "entrypoint": "0x080053cc",
            "current_name": "reset_i2_c_080053cc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetI2C_080053cc(DMA_HandleTypeDef_conflict *dma)\n\n{\n  I2C_HandleTypeDef_conflict *currentI2C;\n  I2C_HandleTypeDef_conflict *nextI2C;\n  \n  currentI2C = (I2C_HandleTypeDef_conflict *)dma->Parent;\n  currentI2C->Instance->CR1 = currentI2C->Instance->CR1 & 0xfffffbff;\n  currentI2C->XferCount = 0;\n  currentI2C->dmatx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0;\n  currentI2C->dmarx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0;\n  if (currentI2C->State != HAL_I2C_STATE_ABORT) {\n    currentI2C->State = HAL_I2C_STATE_READY;\n    currentI2C->Mode = HAL_I2C_MODE_NONE;\n    currentI2C->Instance->CR1 = currentI2C->Instance->CR1 & 0xfffffffe;\n    HAL_I2C_ErrorCallback(currentI2C);\n    return;\n  }\n  currentI2C->State = HAL_I2C_STATE_READY;\n  currentI2C->Mode = HAL_I2C_MODE_NONE;\n  currentI2C->ErrorCode = 0;\n  currentI2C->Instance->CR1 = currentI2C->Instance->CR1 & 0xfffffffe;\n  HAL_I2C_AbortCpltCallback(currentI2C);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053cc": "reset_i2_c_080053cc",
                "hdma": "dma",
                "hi2c_00": "currentI2C",
                "hi2c": "nextI2C"
            },
            "calling": [],
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800542a": {
            "entrypoint": "0x0800542a",
            "current_name": "get_i2_c_state_0800542a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_I2C_StateTypeDef_conflict getI2CState_0800542a(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  return i2cHandle->State;\n}\n\n",
            "renaming": {
                "FUN_0800542a": "get_i2_c_state_0800542a",
                "hi2c": "i2cHandle"
            },
            "calling": [
                "i2c_master_read",
                "i2c_master_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005430": {
            "entrypoint": "0x08005430",
            "current_name": "get_error_08005430",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getError_08005430(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  return i2cHandle->ErrorCode;\n}\n\n",
            "renaming": {
                "FUN_08005430": "get_error_08005430",
                "hi2c": "i2cHandle"
            },
            "calling": [
                "i2c_master_read",
                "i2c_master_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005434": {
            "entrypoint": "0x08005434",
            "current_name": "delay_function_08005434",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid delayFunction_08005434(uint32_t milliseconds)\n\n{\n  bool isDelayZero;\n  uint32_t delayCount;\n  \n  delayCount = milliseconds * (SystemCoreClock / 8000);\n  do {\n    isDelayZero = delayCount != 0;\n    delayCount = delayCount - 1;\n  } while (isDelayZero);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005434": "delay_function_08005434",
                "mdelay": "milliseconds",
                "Delay": "delayCount",
                "bVar1": "isDelayZero"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005460": {
            "entrypoint": "0x08005460",
            "current_name": "initialize_rcc_oscillators_08005460",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeRCCOscillators_08005460(RCC_OscInitTypeDef_conflict *oscillatorConfig)\n\n{\n  HAL_StatusTypeDef HVar1;\n  uint32_t currentTicks;\n  uint32_t startTicks;\n  bool flag;\n  uint32_t temporaryRegister;\n  \n  if ((oscillatorConfig->OscillatorType & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) != 0)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (oscillatorConfig->HSEState == 0)) {\n        return STATUS_ERROR;\n      }\n    }\n    else {\n      startTicks = oscillatorConfig->HSEState;\n      if (startTicks == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (startTicks == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (startTicks == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (oscillatorConfig->HSEState == 0) {\n        startTicks = getElapsedTicks();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTicks = getElapsedTicks();\n          if (100 < currentTicks - startTicks) {\n            return STATUS_TIMEOUT;\n          }\n        }\n      }\n      else {\n        startTicks = getElapsedTicks();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTicks = getElapsedTicks();\n          if (100 < currentTicks - startTicks) {\n            return STATUS_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (oscillatorConfig->HSIState != 1)) {\n        return STATUS_ERROR;\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | oscillatorConfig->HSICalibrationValue << 3;\n    }\n    else if (oscillatorConfig->HSIState == 0) {\n      _DAT_42420000 = 0;\n      startTicks = getElapsedTicks();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTicks = getElapsedTicks();\n        if (2 < currentTicks - startTicks) {\n          return STATUS_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTicks = getElapsedTicks();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTicks = getElapsedTicks();\n        if (2 < currentTicks - startTicks) {\n          return STATUS_TIMEOUT;\n        }\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | oscillatorConfig->HSICalibrationValue << 3;\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 8) != 0) {\n    if (oscillatorConfig->LSIState == 0) {\n      _DAT_42420480 = 0;\n      startTicks = getElapsedTicks();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTicks = getElapsedTicks();\n        if (2 < currentTicks - startTicks) {\n          return STATUS_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTicks = getElapsedTicks();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTicks = getElapsedTicks();\n        if (2 < currentTicks - startTicks) {\n          return STATUS_TIMEOUT;\n        }\n      }\n      delay(1);\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 4) != 0) {\n    flag = (_DAT_4002101c & 0x10000000) == 0;\n    if (flag) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTicks = getElapsedTicks();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTicks = getElapsedTicks();\n        if (100 < currentTicks - startTicks) {\n          return STATUS_TIMEOUT;\n        }\n      }\n    }\n    startTicks = oscillatorConfig->LSEState;\n    if (startTicks == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (startTicks == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (startTicks == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (oscillatorConfig->LSEState == 0) {\n      startTicks = getElapsedTicks();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTicks = getElapsedTicks();\n        if (5000 < currentTicks - startTicks) {\n          return STATUS_TIMEOUT;\n        }\n      }\n    }\n    else {\n      startTicks = getElapsedTicks();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTicks = getElapsedTicks();\n        if (5000 < currentTicks - startTicks) {\n          return STATUS_TIMEOUT;\n        }\n      }\n    }\n    if (flag) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  startTicks = (oscillatorConfig->PLL).PLLState;\n  if (startTicks == 0) {\n    HVar1 = STATUS_OK;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    HVar1 = STATUS_ERROR;\n  }\n  else if (startTicks == 2) {\n    _DAT_42420060 = 0;\n    startTicks = getElapsedTicks();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if ((oscillatorConfig->PLL).PLLSource == 0x10000) {\n          _DAT_40021004 = _DAT_40021004 & 0xfffdffff | oscillatorConfig->HSEPredivValue;\n        }\n        _DAT_40021004 =\n             _DAT_40021004 & 0xffc2ffff |\n             (oscillatorConfig->PLL).PLLSource | (oscillatorConfig->PLL).PLLMUL;\n        _DAT_42420060 = 1;\n        startTicks = getElapsedTicks();\n        do {\n          if ((_DAT_40021000 & 0x2000000) != 0) {\n            return STATUS_OK;\n          }\n          currentTicks = getElapsedTicks();\n        } while (currentTicks - startTicks < 3);\n        return STATUS_TIMEOUT;\n      }\n      currentTicks = getElapsedTicks();\n    } while (currentTicks - startTicks < 3);\n    HVar1 = STATUS_TIMEOUT;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTicks = getElapsedTicks();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        return STATUS_OK;\n      }\n      currentTicks = getElapsedTicks();\n    } while (currentTicks - startTicks < 3);\n    HVar1 = STATUS_TIMEOUT;\n  }\n  return HVar1;\n}\n\n",
            "renaming": {
                "FUN_08005460": "initialize_rcc_oscillators_08005460",
                "RCC_OscInitStruct": "oscillatorConfig",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_GetTick": "getElapsedTicks",
                "RCC_Delay": "delay",
                "HAL_OK": "STATUS_OK",
                "HAL_ERROR": "STATUS_ERROR",
                "HAL_TIMEOUT": "STATUS_TIMEOUT",
                "uVar2": "currentTicks",
                "uVar3": "startTicks",
                "tmpreg": "temporaryRegister",
                "bVar4": "flag"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "RCC_Delay",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005840": {
            "entrypoint": "0x08005840",
            "current_name": "calculate_frequency_08005840",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateFrequency_08005840(void)\n\n{\n  uint32_t frequency;\n  uint8_t predivFactorTable [2];\n  uint8_t pllmulFactorTable [16];\n  \n  pllmulFactorTable[12] = '\\x0e';\n  pllmulFactorTable[13] = '\\x0f';\n  pllmulFactorTable[14] = '\\x10';\n  pllmulFactorTable[15] = '\\x10';\n  pllmulFactorTable[8] = '\\n';\n  pllmulFactorTable[9] = '\\v';\n  pllmulFactorTable[10] = '\\f';\n  pllmulFactorTable[11] = '\\r';\n  pllmulFactorTable[4] = '\\x06';\n  pllmulFactorTable[5] = '\\a';\n  pllmulFactorTable[6] = '\\b';\n  pllmulFactorTable[7] = '\\t';\n  pllmulFactorTable[0] = '\\x02';\n  pllmulFactorTable[1] = '\\x03';\n  pllmulFactorTable[2] = '\\x04';\n  pllmulFactorTable[3] = '\\x05';\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 8) {\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      frequency = (uint)pllmulFactorTable[(_DAT_40021004 << 10) >> 0x1c] * 4000000;\n    }\n    else {\n      frequency = ((uint)pllmulFactorTable[(_DAT_40021004 << 10) >> 0x1c] * 8000000) /\n              (uint)predivFactorTable[-((int)(_DAT_40021004 << 0xe) >> 0x1f)];\n    }\n  }\n  else {\n    frequency = 8000000;\n  }\n  return frequency;\n}\n\n",
            "renaming": {
                "FUN_08005840": "calculate_frequency_08005840",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllmulFactorTable",
                "uVar1": "frequency"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058ac": {
            "entrypoint": "0x080058ac",
            "current_name": "configure_clocks_080058ac",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureClocks_080058ac(clockConfig *RCC_ClkInitStruct,uint32_t flashLatency)\n\n{\n  uint32_t tempVar1;\n  uint32_t tempVar2;\n  uint tempVar3;\n  \n  if ((_DAT_40022000 & 7) < flashLatency) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency;\n    if (flashLatency != (flashLatency & 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((RCC_ClkInitStruct->ClockType & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffff0f | RCC_ClkInitStruct->AHBCLKDivider;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 1) != 0) {\n    tempVar3 = RCC_ClkInitStruct->SYSCLKSource;\n    if (tempVar3 == 1) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((tempVar3 != 2) && ((_DAT_40021000 & 2) == 0)) {\n      return HAL_ERROR;\n    }\n    _DAT_40021004 = tempVar3 | _DAT_40021004 & 0xfffffffc;\n    tempVar1 = HAL_GetTick();\n    if (RCC_ClkInitStruct->SYSCLKSource == 1) {\n      while ((_DAT_40021004 & 0xc) != 4) {\n        tempVar2 = HAL_GetTick();\n        if (5000 < tempVar2 - tempVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else if (RCC_ClkInitStruct->SYSCLKSource == 2) {\n      while ((_DAT_40021004 & 0xc) != 8) {\n        tempVar2 = HAL_GetTick();\n        if (5000 < tempVar2 - tempVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      while ((_DAT_40021004 & 0xc) != 0) {\n        tempVar2 = HAL_GetTick();\n        if (5000 < tempVar2 - tempVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if (flashLatency < (_DAT_40022000 & 7)) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency;\n    if (flashLatency != (flashLatency & 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((RCC_ClkInitStruct->ClockType & 4) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | RCC_ClkInitStruct->APB1CLKDivider;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 8) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | RCC_ClkInitStruct->APB2CLKDivider << 3;\n  }\n  tempVar1 = HAL_RCC_GetSysClockFreq();\n  SystemCoreClock = tempVar1 >> \"\"[(_DAT_40021004 << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080058ac": "configure_clocks_080058ac",
                "RCC_ClkInitTypeDef_conflict": "clockConfig",
                "FLatency": "flashLatency",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a1c": {
            "entrypoint": "0x08005a1c",
            "current_name": "get_system_core_clock_08005a1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08005a1c(void)\n\n{\n  return systemCoreClock;\n}\n\n",
            "renaming": {
                "FUN_08005a1c": "get_system_core_clock_08005a1c",
                "SystemCoreClock": "systemCoreClock"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a28": {
            "entrypoint": "0x08005a28",
            "current_name": "get_hclk_frequency_08005a28",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getHCLKFrequency_08005a28(void)\n\n{\n  uint32_t hclkFrequency;\n  \n  hclkFrequency = HAL_RCC_GetHCLKFreq();\n  return hclkFrequency >> \"\"[(uint)(_DAT_40021004 << 0x15) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08005a28": "get_hclk_frequency_08005a28",
                "uVar1": "hclkFrequency"
            },
            "calling": [
                "getTimerClkFreq",
                "UART_SetConfig",
                "HAL_I2C_Init"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a48": {
            "entrypoint": "0x08005a48",
            "current_name": "get_adjusted_hclk_freq_08005a48",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedHCLKFreq_08005a48(void)\n\n{\n  uint32_t adjustedHCLKFreq;\n  \n  adjustedHCLKFreq = getCurrentHCLKFreq();\n  return adjustedHCLKFreq >> \"\"[(uint)(_DAT_40021004 << 0x12) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08005a48": "get_adjusted_hclk_freq_08005a48",
                "uVar1": "adjustedHCLKFreq",
                "HAL_RCC_GetHCLKFreq": "getCurrentHCLKFreq"
            },
            "calling": [
                "getTimerClkFreq",
                "HAL_RCCEx_GetPeriphCLKFreq",
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a68": {
            "entrypoint": "0x08005a68",
            "current_name": "initialize_clock_configuration_08005a68",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeClockConfiguration_08005a68(RCC_ClkInitTypeDef_conflict *clkInitStruct,uint32_t *pFlashLatency)\n\n{\n  clkInitStruct->ClockType = 0xf;\n  clkInitStruct->SYSCLKSource = _DAT_40021004 & 3;\n  clkInitStruct->AHBCLKDivider = _DAT_40021004 & 0xf0;\n  clkInitStruct->APB1CLKDivider = _DAT_40021004 & 0x700;\n  clkInitStruct->APB2CLKDivider = _DAT_40021004 >> 3 & 0x700;\n  *pFlashLatency = _DAT_40022000 & 7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a68": "initialize_clock_configuration_08005a68",
                "RCC_ClkInitStruct": "clkInitStruct",
                "pFLatency": "pFlashLatency"
            },
            "calling": [
                "getTimerClkFreq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005aa4": {
            "entrypoint": "0x08005aa4",
            "current_name": "configure_periph_clock_08005aa4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configurePeriphClock_08005aa4(RCC_PeriphCLKInitTypeDef_conflict *clockInit)\n\n{\n  uint tempVar1;\n  uint tempVar2;\n  uint32_t tempVar3;\n  uint32_t tempVar4;\n  bool clockEnabled;\n  uint32_t tempRegister;\n  \n  if ((clockInit->PeriphClockSelection & 1) != 0) {\n    clockEnabled = (_DAT_4002101c & 0x10000000) == 0;\n    if (clockEnabled) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      tempVar3 = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        tempVar4 = HAL_GetTick();\n        if (100 < tempVar4 - tempVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (((_DAT_40021020 & 0x300) != 0) &&\n       ((_DAT_40021020 & 0x300) != (clockInit->RTCClockSelection & 0x300))) {\n      tempVar2 = _DAT_40021020 & 0xfffffcff;\n      _DAT_42420440 = 0;\n      tempVar1 = _DAT_40021020 & 1;\n      _DAT_40021020 = tempVar2;\n      if (tempVar1 != 0) {\n        tempVar3 = HAL_GetTick();\n        while ((_DAT_40021020 & 2) == 0) {\n          tempVar4 = HAL_GetTick();\n          if (5000 < tempVar4 - tempVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    _DAT_40021020 = _DAT_40021020 & 0xfffffcff | clockInit->RTCClockSelection;\n    if (clockEnabled) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if ((clockInit->PeriphClockSelection & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffff3fff | clockInit->AdcClockSelection;\n  }\n  if ((clockInit->PeriphClockSelection & 0x10) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffbfffff | clockInit->UsbClockSelection;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08005aa4": "configure_periph_clock_08005aa4",
                "PeriphClkInit": "clockInit",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "bVar5": "clockEnabled",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bb8": {
            "entrypoint": "0x08005bb8",
            "current_name": "calculate_clock_frequency_08005bb8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateClockFrequency_08005bb8(uint32_t clockType)\n\n{\n  uint32_t frequency;\n  uint divider;\n  uint8_t predivFactorTable [2];\n  uint8_t pllMulFactorTable [16];\n  \n  pllMulFactorTable[12] = '\\x0e';\n  pllMulFactorTable[13] = '\\x0f';\n  pllMulFactorTable[14] = '\\x10';\n  pllMulFactorTable[15] = '\\x10';\n  pllMulFactorTable[8] = '\\n';\n  pllMulFactorTable[9] = '\\v';\n  pllMulFactorTable[10] = '\\f';\n  pllMulFactorTable[11] = '\\r';\n  pllMulFactorTable[4] = '\\x06';\n  pllMulFactorTable[5] = '\\a';\n  pllMulFactorTable[6] = '\\b';\n  pllMulFactorTable[7] = '\\t';\n  pllMulFactorTable[0] = '\\x02';\n  pllMulFactorTable[1] = '\\x03';\n  pllMulFactorTable[2] = '\\x04';\n  pllMulFactorTable[3] = '\\x05';\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if (clockType == 2) {\n    frequency = HAL_RCC_GetPCLK2Freq();\n    frequency = frequency / ((((_DAT_40021004 << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (clockType == 0x10) {\n    if ((_DAT_40021000 & 0x1000000) == 0) {\n      frequency = 0;\n    }\n    else {\n      if ((_DAT_40021004 & 0x10000) == 0) {\n        divider = 4000000;\n      }\n      else {\n        divider = 8000000 / predivFactorTable[-((int)(_DAT_40021004 << 0xe) >> 0x1f)];\n      }\n      frequency = divider * pllMulFactorTable[(_DAT_40021004 << 10) >> 0x1c];\n      if ((_DAT_40021004 & 0x400000) == 0) {\n        frequency = (frequency * 2) / 3;\n      }\n    }\n  }\n  else if (clockType == 1) {\n    if ((_DAT_40021020 & 0x302) == 0x102) {\n      frequency = 0x8000;\n    }\n    else if (((_DAT_40021020 & 0x300) == 0x200) && ((_DAT_40021024 & 2) != 0)) {\n      frequency = 32000;\n    }\n    else if ((_DAT_40021020 & 0x300) == 0x300) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        frequency = 0;\n      }\n      else {\n        frequency = 0xf424;\n      }\n    }\n    else {\n      frequency = 0;\n    }\n  }\n  else {\n    frequency = 0;\n  }\n  return frequency;\n}\n\n",
            "renaming": {
                "FUN_08005bb8": "calculate_clock_frequency_08005bb8",
                "PeriphClk": "clockType",
                "uVar1": "frequency",
                "uVar2": "divider",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable"
            },
            "calling": [
                "HAL_ADC_PollForConversion",
                "HAL_ADCEx_Calibration_Start"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cb4": {
            "entrypoint": "0x08005cb4",
            "current_name": "handle_alarm_event_08005cb4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handleAlarmEvent_08005cb4(RTC_HandleTypeDef *rtcHandle)\n\n{\n  if (((rtcHandle->rtcInstance->controlHighRegister & 2) != 0) && ((rtcHandle->rtcInstance->controlLowRegister & 2) != 0)) {\n    handleAlarmAEventCallback(rtcHandle);\n    rtcHandle->rtcInstance->controlLowRegister = 0xfffffffd;\n  }\n  _DAT_40010414 = 0x20000;\n  rtcHandle->rtcState = HAL_RTC_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005cb4": "handle_alarm_event_08005cb4",
                "hrtc": "rtcHandle",
                "Instance": "rtcInstance",
                "CRH": "controlHighRegister",
                "CRL": "controlLowRegister",
                "HAL_RTC_AlarmAEventCallback": "handleAlarmAEventCallback",
                "State": "rtcState"
            },
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cec": {
            "entrypoint": "0x08005cec",
            "current_name": "configure_timer_output_08005cec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerOutput_08005cec(TIM_TypeDef_conflict *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint32_t ccerMask;\n  uint32_t cr2Value;\n  uint ocMode;\n  \n  timer->CCER = timer->CCER & 0xfffffffe;\n  cr2Value = timer->CR2;\n  ocMode = outputConfig->OCMode;\n  ccerMask = timer->CCER & 0xfffffffd | outputConfig->OCPolarity;\n  if (timer == (TIM_TypeDef_conflict *)0x40012c00) {\n    ccerMask = (ccerMask & 0xfffffff7 | outputConfig->OCNPolarity) & 0xfffffffb;\n    cr2Value = cr2Value & 0xfffffcff | outputConfig->OCIdleState | outputConfig->OCNIdleState;\n  }\n  timer->CR2 = cr2Value;\n  timer->CCMR1 = timer->CCMR1 & 0xffffff8c | ocMode;\n  timer->CCR1 = outputConfig->Pulse;\n  timer->CCER = ccerMask;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005cec": "configure_timer_output_08005cec",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "uVar1": "ccerMask",
                "uVar2": "cr2Value",
                "uVar3": "ocMode"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d48": {
            "entrypoint": "0x08005d48",
            "current_name": "configure_timer_oc_08005d48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerOC_08005d48(TIM_TypeDef_conflict *timer,TIM_OC_InitTypeDef *ocConfig)\n\n{\n  uint32_t ccerValue;\n  uint32_t cr2Value;\n  uint ocModeValue;\n  \n  timer->CCER = timer->CCER & 0xfffffeff;\n  cr2Value = timer->CR2;\n  ocModeValue = ocConfig->OCMode;\n  ccerValue = timer->CCER & 0xfffffdff | ocConfig->OCPolarity << 8;\n  if (timer == (TIM_TypeDef_conflict *)0x40012c00) {\n    ccerValue = (ccerValue & 0xfffff7ff | ocConfig->OCNPolarity << 8) & 0xfffffbff;\n    cr2Value = cr2Value & 0xffffcfff | ocConfig->OCIdleState << 4 | ocConfig->OCNIdleState << 4;\n  }\n  timer->CR2 = cr2Value;\n  timer->CCMR2 = timer->CCMR2 & 0xffffff8c | ocModeValue;\n  timer->CCR3 = ocConfig->Pulse;\n  timer->CCER = ccerValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d48": "configure_timer_oc_08005d48",
                "TIMx": "timer",
                "OC_Config": "ocConfig",
                "uVar1": "ccerValue",
                "uVar2": "cr2Value",
                "uVar3": "ocModeValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dac": {
            "entrypoint": "0x08005dac",
            "current_name": "configure_tim_oc_08005dac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configure_TIM_OC_08005dac(TIM_TypeDef_conflict *tim_instance,TIM_OC_InitTypeDef *oc_config)\n\n{\n  uint32_t cr2_value;\n  uint32_t oc_mode;\n  uint32_t oc_polarity;\n  \n  tim_instance->CCER = tim_instance->CCER & 0xffffefff;\n  cr2_value = tim_instance->CR2;\n  oc_mode = oc_config->OCMode;\n  oc_polarity = oc_config->OCPolarity;\n  if (tim_instance == (TIM_TypeDef_conflict *)0x40012c00) {\n    cr2_value = cr2_value & 0xffffbfff | oc_config->OCIdleState << 6;\n  }\n  tim_instance->CR2 = cr2_value;\n  tim_instance->CCMR2 = tim_instance->CCMR2 & 0xffff8cff | oc_mode << 8;\n  tim_instance->CCR4 = oc_config->Pulse;\n  tim_instance->CCER = tim_instance->CCER & 0xffffdfff | oc_polarity << 0xc;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005dac": "configure_tim_oc_08005dac",
                "TIMx": "tim_instance",
                "OC_Config": "oc_config",
                "uVar1": "cr2_value",
                "uVar2": "oc_mode",
                "uVar3": "oc_polarity"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005df4": {
            "entrypoint": "0x08005df4",
            "current_name": "reset_timer_08005df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict resetTimer_08005df4(TIM_HandleTypeDef_conflict *timer)\n\n{\n  Timer *timerInstance;\n  \n  timer->State = TIMER_STATE_BUSY;\n  timerInstance = timer->Instance;\n  if (((timerInstance->captureCompareEnableRegister & 0x1111) == 0) && ((timerInstance->captureCompareEnableRegister & 0x444) == 0)) {\n    timerInstance->controlRegister1 = timerInstance->controlRegister1 & 0xfffffffe;\n  }\n  deinitializeTimerOutputCompare(timer);\n  timer->State = TIMER_STATE_RESET;\n  timer->Lock = TIMER_UNLOCKED;\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08005df4": "reset_timer_08005df4",
                "htim": "timer",
                "HAL_TIM_STATE_BUSY": "TIMER_STATE_BUSY",
                "TIM_TypeDef_conflict": "Timer",
                "pTVar1": "timerInstance",
                "CCER": "captureCompareEnableRegister",
                "CR1": "controlRegister1",
                "HAL_TIM_OC_MspDeInit": "deinitializeTimerOutputCompare",
                "HAL_TIM_STATE_RESET": "TIMER_STATE_RESET",
                "HAL_UNLOCKED": "TIMER_UNLOCKED",
                "HAL_OK": "OK"
            },
            "calling": [
                "TimerPulseDeinit"
            ],
            "called": [
                "HAL_TIM_OC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e2e": {
            "entrypoint": "0x08005e2e",
            "current_name": "disable_timer_pwm_08005e2e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus disableTimerPWM_08005e2e(TimerHandle *timer)\n\n{\n  TimerTypeDef *timerInstance;\n  \n  timer->State = HAL_TIM_STATE_BUSY;\n  timerInstance = timer->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(timer);\n  timer->State = HAL_TIM_STATE_RESET;\n  timer->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08005e2e": "disable_timer_pwm_08005e2e",
                "htim": "timer",
                "TIM_HandleTypeDef_conflict": "TimerHandle",
                "HAL_StatusTypeDef_conflict": "Status",
                "TIM_TypeDef_conflict": "TimerTypeDef",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e68": {
            "entrypoint": "0x08005e68",
            "current_name": "FUNC_08005e68",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005e68(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005e68": "FUNC_08005e68"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005e6a": {
            "entrypoint": "0x08005e6a",
            "current_name": "FUNC_08005e6a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005e6a(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005e6a": "FUNC_08005e6a"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005e6c": {
            "entrypoint": "0x08005e6c",
            "current_name": "FUNC_08005e6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005e6c(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005e6c": "FUNC_08005e6c"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005e6e": {
            "entrypoint": "0x08005e6e",
            "current_name": "handle_tim_interrupts_08005e6e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimInterrupts_08005e6e(TIM_HandleTypeDef_conflict *timHandle)\n\n{\n  TIM_TypeDef_conflict *timInstance;\n  \n  timInstance = timHandle->Instance;\n  if (((timInstance->statusRegister & 2) != 0) && ((timInstance->interruptEnableRegister & 2) != 0)) {\n    timInstance->statusRegister = 0xfffffffd;\n    timHandle->activeChannel = ACTIVE_CHANNEL_1;\n    if ((timHandle->Instance->CCMR1 & 3) == 0) {\n      handleOutputCompareDelayElapsed(timHandle);\n      handlePwmPulseFinished(timHandle);\n    }\n    else {\n      handleInputCapture(timHandle);\n    }\n    timHandle->activeChannel = ACTIVE_CHANNEL_CLEARED;\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->statusRegister & 4) != 0) && ((timInstance->interruptEnableRegister & 4) != 0)) {\n    timInstance->statusRegister = 0xfffffffb;\n    timHandle->activeChannel = ACTIVE_CHANNEL_2;\n    if ((timHandle->Instance->CCMR1 & 0x300) == 0) {\n      handleOutputCompareDelayElapsed(timHandle);\n      handlePwmPulseFinished(timHandle);\n    }\n    else {\n      handleInputCapture(timHandle);\n    }\n    timHandle->activeChannel = ACTIVE_CHANNEL_CLEARED;\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->statusRegister & 8) != 0) && ((timInstance->interruptEnableRegister & 8) != 0)) {\n    timInstance->statusRegister = 0xfffffff7;\n    timHandle->activeChannel = ACTIVE_CHANNEL_3;\n    if ((timHandle->Instance->CCMR2 & 3) == 0) {\n      handleOutputCompareDelayElapsed(timHandle);\n      handlePwmPulseFinished(timHandle);\n    }\n    else {\n      handleInputCapture(timHandle);\n    }\n    timHandle->activeChannel = ACTIVE_CHANNEL_CLEARED;\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->statusRegister & 0x10) != 0) && ((timInstance->interruptEnableRegister & 0x10) != 0)) {\n    timInstance->statusRegister = 0xffffffef;\n    timHandle->activeChannel = ACTIVE_CHANNEL_4;\n    if ((timHandle->Instance->CCMR2 & 0x300) == 0) {\n      handleOutputCompareDelayElapsed(timHandle);\n      handlePwmPulseFinished(timHandle);\n    }\n    else {\n      handleInputCapture(timHandle);\n    }\n    timHandle->activeChannel = ACTIVE_CHANNEL_CLEARED;\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->statusRegister & 1) != 0) && ((timInstance->interruptEnableRegister & 1) != 0)) {\n    timInstance->statusRegister = 0xfffffffe;\n    handlePeriodElapsed(timHandle);\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->statusRegister & 0x80) != 0) && ((timInstance->interruptEnableRegister & 0x80) != 0)) {\n    timInstance->statusRegister = 0xffffff7f;\n    VXBPNQNstatusRegisterP(timHandle);\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->statusRegister & 0x40) != 0) && ((timInstance->interruptEnableRegister & 0x40) != 0)) {\n    timInstance->statusRegister = 0xffffffbf;\n    handleTrigger(timHandle);\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->statusRegister & 0x20) != 0) && ((timInstance->interruptEnableRegister & 0x20) != 0)) {\n    timInstance->statusRegister = 0xffffffdf;\n    handleCommutation(timHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005e6e": "handle_tim_interrupts_08005e6e",
                "htim": "timHandle",
                "pTVar1": "timInstance",
                "SR": "statusRegister",
                "DIER": "interruptEnableRegister",
                "Channel": "activeChannel",
                "HAL_TIM_ACTIVE_CHANNEL_1": "ACTIVE_CHANNEL_1",
                "HAL_TIM_ACTIVE_CHANNEL_2": "ACTIVE_CHANNEL_2",
                "HAL_TIM_ACTIVE_CHANNEL_3": "ACTIVE_CHANNEL_3",
                "HAL_TIM_ACTIVE_CHANNEL_4": "ACTIVE_CHANNEL_4",
                "HAL_TIM_ACTIVE_CHANNEL_CLEARED": "ACTIVE_CHANNEL_CLEARED",
                "HAL_TIM_OC_DelayElapsedCallback": "handleOutputCompareDelayElapsed",
                "HAL_TIM_PWM_PulseFinishedCallback": "handlePwmPulseFinished",
                "HAL_TIM_IC_CaptureCallback": "handleInputCapture",
                "HAL_TIM_PeriodElapsedCallback": "handlePeriodElapsed",
                "HAL_TIMEx_BreakCallback": "handleBreak",
                "HAL_TIM_TriggerCallback": "handleTrigger",
                "HAL_TIMEx_CommutationCallback": "handleCommutation"
            },
            "calling": [
                "TIM4_IRQHandler",
                "TIM2_IRQHandler",
                "TIM3_IRQHandler",
                "TIM1_UP_IRQHandler"
            ],
            "called": [
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005fe8": {
            "entrypoint": "0x08005fe8",
            "current_name": "configure_timer_08005fe8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimer_08005fe8(TIM_TypeDef_conflict *timer,timerInitStructure *Structure)\n\n{\n  uint tempVar;\n  \n  tempVar = timer->CR1;\n  if ((((timer == (TIM_TypeDef_conflict *)0x40012c00) || (timer == (TIM_TypeDef_conflict *)0x40000000)\n       ) || (timer == (TIM_TypeDef_conflict *)0x40000400)) ||\n     (timer == (TIM_TypeDef_conflict *)0x40000800)) {\n    tempVar = tempVar & 0xffffff8f | Structure->counterMode;\n  }\n  if (((timer == (TIM_TypeDef_conflict *)0x40012c00) || (timer == (TIM_TypeDef_conflict *)0x40000000))\n     || ((timer == (TIM_TypeDef_conflict *)0x40000400 || (timer == (TIM_TypeDef_conflict *)0x40000800)\n         ))) {\n    tempVar = tempVar & 0xfffffcff | Structure->clockDivision;\n  }\n  timer->CR1 = tempVar & 0xffffff7f | Structure->autoReloadPreload;\n  timer->period = Structure->Period;\n  timer->prescaler = Structure->Prescaler;\n  if (timer == (TIM_TypeDef_conflict *)0x40012c00) {\n    uRam40012c30 = Structure->repetitionCounter;\n  }\n  timer->EGR = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005fe8": "configure_timer_08005fe8",
                "TIMx": "timer",
                "TIM_Base_InitTypeDef_conflict": "timerInitStructure",
                "uVar1": "tempVar",
                "CounterMode": "counterMode",
                "ClockDivision": "clockDivision",
                "AutoReloadPreload": "autoReloadPreload",
                "ARR": "period",
                "PSC": "prescaler",
                "RepetitionCounter": "repetitionCounter"
            },
            "calling": [
                "HAL_TIM_OC_Init",
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006060": {
            "entrypoint": "0x08006060",
            "current_name": "configure_timer_08006060",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureTimer_08006060(TIM_HandleTypeDef_conflict *timer)\n\n{\n  if (timer != (TIM_HandleTypeDef_conflict *)0x0) {\n    if (timer->State == stateReset) {\n      timer->Lock = unlocked;\n      initializeTimerOC(timer);\n    }\n    timer->State = stateBusy;\n    setTimerConfiguration(timer->Instance,&timer->Init);\n    timer->State = stateReady;\n    return success;\n  }\n  return error;\n}\n\n",
            "renaming": {
                "FUN_08006060": "configure_timer_08006060",
                "htim": "timer",
                "HAL_TIM_STATE_RESET": "stateReset",
                "HAL_UNLOCKED": "unlocked",
                "HAL_TIM_OC_MspInit": "initializeTimerOC",
                "HAL_TIM_STATE_BUSY": "stateBusy",
                "HAL_TIM_STATE_READY": "stateReady",
                "HAL_OK": "success",
                "HAL_ERROR": "error",
                "TIM_Base_SetConfig": "setTimerConfiguration"
            },
            "calling": [
                "TimerPulseInit"
            ],
            "called": [
                "HAL_TIM_OC_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006092": {
            "entrypoint": "0x08006092",
            "current_name": "configure_timer_08006092",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureTimer_08006092(TIM_HandleTypeDef_conflict *timerHandle)\n\n{\n  if (timerHandle != (TIM_HandleTypeDef_conflict *)0x0) {\n    if (timerHandle->State == HAL_TIM_STATE_RESET) {\n      timerHandle->Lock = unlocked;\n      initializePWM(timerHandle);\n    }\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(timerHandle->Instance,&timerHandle->Init);\n    timerHandle->State = HAL_TIM_STATE_READY;\n    return OK;\n  }\n  return ERROR;\n}\n\n",
            "renaming": {
                "FUN_08006092": "configure_timer_08006092",
                "htim": "timerHandle",
                "HAL_TIM_PWM_MspInit": "initializePWM",
                "HAL_UNLOCKED": "unlocked",
                "HAL_OK": "OK",
                "HAL_ERROR": "ERROR"
            },
            "calling": [
                "pwm_start"
            ],
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060c4": {
            "entrypoint": "0x080060c4",
            "current_name": "configure_timer_080060c4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimer_080060c4(TIM_TypeDef_conflict *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint32_t ccer1;\n  uint32_t cr2;\n  uint32_t ocMode;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  cr2 = timer->CR2;\n  ocMode = outputConfig->OCMode;\n  ccer1 = timer->CCER & 0xffffffdf | outputConfig->OCPolarity << 4;\n  if (timer == (TIM_TypeDef_conflict *)0x40012c00) {\n    ccer1 = (ccer1 & 0xffffff7f | outputConfig->OCNPolarity << 4) & 0xffffffbf;\n    cr2 = cr2 & 0xfffff3ff | outputConfig->OCIdleState << 2 | outputConfig->OCNIdleState << 2;\n  }\n  timer->CR2 = cr2;\n  timer->CCMR1 = timer->CCMR1 & 0xffff8cff | ocMode << 8;\n  timer->CCR2 = outputConfig->Pulse;\n  timer->CCER = ccer1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060c4": "configure_timer_080060c4",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "uVar1": "ccer1",
                "uVar2": "cr2",
                "uVar3": "ocMode"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006128": {
            "entrypoint": "0x08006128",
            "current_name": "initialize_timer_channel_08006128",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus\ninitializeTimerChannel_08006128(TIM_HandleTypeDef_conflict *timerHandler,TIM_OC_InitTypeDef *channelConfig,uint32_t channel)\n\n{\n  if (timerHandler->Lock != LOCKED) {\n    timerHandler->Lock = LOCKED;\n    timerHandler->State = BUSY;\n    switch(channel) {\n    case 0:\n      configureOC1(timerHandler->Instance,channelConfig);\n      break;\n    case 4:\n      configureOC2(timerHandler->Instance,channelConfig);\n      break;\n    case 8:\n      configureOC3(timerHandler->Instance,channelConfig);\n      break;\n    case 0xc:\n      configureOC4(timerHandler->Instance,channelConfig);\n    }\n    timerHandler->State = READY;\n    timerHandler->Lock = UNLOCKED;\n    return OK;\n  }\n  return BUSY;\n}\n\n",
            "renaming": {
                "FUN_08006128": "initialize_timer_channel_08006128",
                "htim": "timerHandler",
                "sConfig": "channelConfig",
                "Channel": "channel",
                "HAL_StatusTypeDef_conflict": "Status",
                "HAL_LOCKED": "LOCKED",
                "HAL_TIM_STATE_BUSY": "BUSY",
                "HAL_TIM_STATE_READY": "READY",
                "HAL_UNLOCKED": "UNLOCKED",
                "TIM_OC1_SetConfig": "configureOC1",
                "TIM_OC2_SetConfig": "configureOC2",
                "TIM_OC3_SetConfig": "configureOC3",
                "TIM_OC4_SetConfig": "configureOC4",
                "HAL_OK": "OK",
                "HAL_BUSY": "BUSY"
            },
            "calling": [
                "TimerPulseInit"
            ],
            "called": [
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC3_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006186": {
            "entrypoint": "0x08006186",
            "current_name": "initialize_tim_oc_08006186",
            "code": "\n/* WARNING: Unknown calling convention */\n\nstatus\ninitialize_TIM_OC_08006186(TIM_HandleTypeDef_conflict *tim_handler,TIM_OC_InitTypeDef *oc_init_config,uint32_t channel)\n\n{\n  if (tim_handler->Lock != LOCKED) {\n    tim_handler->Lock = LOCKED;\n    tim_handler->State = STATE_BUSY;\n    switch(channel) {\n    case 0:\n      configure_TIM_OC1(tim_handler->instance,oc_init_config);\n      tim_handler->instance->ccmr1 = tim_handler->instance->ccmr1 | 8;\n      tim_handler->instance->ccmr1 = tim_handler->instance->ccmr1 & 0xfffffffb;\n      tim_handler->instance->ccmr1 = tim_handler->instance->ccmr1 | oc_init_config->oc_fast_mode;\n      break;\n    case 4:\n      configure_TIM_OC2(tim_handler->instance,oc_init_config);\n      tim_handler->instance->ccmr1 = tim_handler->instance->ccmr1 | 0x800;\n      tim_handler->instance->ccmr1 = tim_handler->instance->ccmr1 & 0xfffffbff;\n      tim_handler->instance->ccmr1 = tim_handler->instance->ccmr1 | oc_init_config->oc_fast_mode << 8;\n      break;\n    case 8:\n      configure_TIM_OC3(tim_handler->instance,oc_init_config);\n      tim_handler->instance->ccmr2 = tim_handler->instance->ccmr2 | 8;\n      tim_handler->instance->ccmr2 = tim_handler->instance->ccmr2 & 0xfffffffb;\n      tim_handler->instance->ccmr2 = tim_handler->instance->ccmr2 | oc_init_config->oc_fast_mode;\n      break;\n    case 0xc:\n      configure_TIM_OC4(tim_handler->instance,oc_init_config);\n      tim_handler->instance->ccmr2 = tim_handler->instance->ccmr2 | 0x800;\n      tim_handler->instance->ccmr2 = tim_handler->instance->ccmr2 & 0xfffffbff;\n      tim_handler->instance->ccmr2 = tim_handler->instance->ccmr2 | oc_init_config->oc_fast_mode << 8;\n    }\n    tim_handler->State = STATE_READY;\n    tim_handler->Lock = UNLOCKED;\n    return OK;\n  }\n  return BUSY;\n}\n\n",
            "renaming": {
                "FUN_08006186": "initialize_tim_oc_08006186",
                "htim": "tim_handler",
                "sConfig": "oc_init_config",
                "Channel": "channel",
                "HAL_StatusTypeDef_conflict": "status",
                "HAL_LOCKED": "LOCKED",
                "HAL_TIM_STATE_BUSY": "STATE_BUSY",
                "HAL_TIM_STATE_READY": "STATE_READY",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_OK": "OK",
                "HAL_BUSY": "BUSY",
                "TIM_OC1_SetConfig": "configure_TIM_OC1",
                "TIM_OC2_SetConfig": "configure_TIM_OC2",
                "TIM_OC3_SetConfig": "configure_TIM_OC3",
                "TIM_OC4_SetConfig": "configure_TIM_OC4",
                "Instance": "instance",
                "CCMR1": "ccmr1",
                "CCMR2": "ccmr2",
                "OCFastMode": "oc_fast_mode"
            },
            "calling": [
                "pwm_start"
            ],
            "called": [
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC3_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006262": {
            "entrypoint": "0x08006262",
            "current_name": "configure_timer_channel_08006262",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerChannel_08006262(TIM_TypeDef_conflict *timer,uint32_t channel,uint32_t channelState)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channel & 0xff));\n  timer->CCER = timer->CCER | channelState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006262": "configure_timer_channel_08006262",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "channelState"
            },
            "calling": [
                "HAL_TIM_OC_Start_IT",
                "HAL_TIM_OC_Stop_IT",
                "HAL_TIM_PWM_Stop",
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006280": {
            "entrypoint": "0x08006280",
            "current_name": "configure_timer_interrupt_08006280",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureTimerInterrupt_08006280(TIM_HandleTypeDef_conflict *timerHandle,uint32_t channel)\n\n{\n  switch(channel) {\n  case 0:\n    timerHandle->timerInstance->DMAInterruptEnableReg = timerHandle->timerInstance->DMAInterruptEnableReg | 2;\n    break;\n  case 4:\n    timerHandle->timerInstance->DMAInterruptEnableReg = timerHandle->timerInstance->DMAInterruptEnableReg | 4;\n    break;\n  case 8:\n    timerHandle->timerInstance->DMAInterruptEnableReg = timerHandle->timerInstance->DMAInterruptEnableReg | 8;\n    break;\n  case 0xc:\n    timerHandle->timerInstance->DMAInterruptEnableReg = timerHandle->timerInstance->DMAInterruptEnableReg | 0x10;\n  }\n  configureChannelCommand(timerHandle->timerInstance,channel,1);\n  if (timerHandle->timerInstance == (TIM_TypeDef_conflict *)0x40012c00) {\n    memoryAddress = memoryAddress | 0x8000;\n  }\n  timerHandle->timerInstance->controlReg1 = timerHandle->timerInstance->controlReg1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08006280": "configure_timer_interrupt_08006280",
                "htim": "timerHandle",
                "Channel": "channel",
                "Instance": "timerInstance",
                "DIER": "DMAInterruptEnableReg",
                "TIM_CCxChannelCmd": "configureChannelCommand",
                "uRam40012c44": "memoryAddress",
                "CR1": "controlReg1"
            },
            "calling": [
                "TimerPulseInit"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080062f4": {
            "entrypoint": "0x080062f4",
            "current_name": "disable_timer_interrupt_080062f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict disableTimerInterrupt_080062f4(TIM_HandleTypeDef_conflict *timerHandle,uint32_t channel)\n\n{\n  Timer *timerInstance;\n  \n  switch(channel) {\n  case 0:\n    timerHandle->Instance->DIER = timerHandle->Instance->DIER & 0xfffffffd;\n    break;\n  case 4:\n    timerHandle->Instance->DIER = timerHandle->Instance->DIER & 0xfffffffb;\n    break;\n  case 8:\n    timerHandle->Instance->DIER = timerHandle->Instance->DIER & 0xfffffff7;\n    break;\n  case 0xc:\n    timerHandle->Instance->DIER = timerHandle->Instance->DIER & 0xffffffef;\n  }\n  TIM_CCxchannelCmd(timerHandle->Instance,channel,0);\n  if (((timerHandle->Instance == (Timer *)0x40012c00) && ((uRam40012c20 & 0x1111) == 0)) &&\n     ((uRam40012c20 & 0x444) == 0)) {\n    uRam40012c44 = uRam40012c44 & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080062f4": "disable_timer_interrupt_080062f4",
                "htim": "timerHandle",
                "Channel": "channel",
                "TIM_TypeDef_conflict": "Timer",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "TimerPulseDeinit"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006390": {
            "entrypoint": "0x08006390",
            "current_name": "configure_tim_channel_08006390",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configure_TIM_Channel_08006390(TIM_HandleTypeDef_conflict *tim_handler,uint32_t channel)\n\n{\n  configureChannel(tim_handler->Instance,channel,1);\n  if (tim_handler->Instance == (TIM_TypeDef *)0x40012c00) {\n    statusFlag = statusFlag | 0x8000;\n  }\n  tim_handler->Instance->CR1 = tim_handler->Instance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08006390": "configure_tim_channel_08006390",
                "htim": "tim_handler",
                "Channel": "channel",
                "TIM_CCxChannelCmd": "configureChannel",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "uRam40012c44": "statusFlag",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "calling": [
                "pwm_start"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080063c0": {
            "entrypoint": "0x080063c0",
            "current_name": "disable_tim_channel_080063c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict disableTimChannel_080063c0(TIM_HandleTypeDef_conflict *timHandle,uint32_t channel)\n\n{\n  TIM_TypeDef_conflict *timInstance;\n  \n  TIM_CCxchannelCmd(timHandle->Instance,channel,0);\n  if (((timHandle->Instance == (TIM_TypeDef_conflict *)0x40012c00) && ((ramValue1 & 0x1111) == 0)) &&\n     ((ramValue1 & 0x444) == 0)) {\n    ramValue2 = ramValue2 & 0xffff7fff;\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->CCER & 0x1111) == 0) && ((timInstance->CCER & 0x444) == 0)) {\n    timInstance->CR1 = timInstance->CR1 & 0xfffffffe;\n  }\n  timHandle->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080063c0": "disable_tim_channel_080063c0",
                "htim": "timHandle",
                "Channel": "channel",
                "pTVar1": "timInstance",
                "uRam40012c20": "ramValue1",
                "uRam40012c44": "ramValue2"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006420": {
            "entrypoint": "0x08006420",
            "current_name": "set_channel_state_08006420",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setChannelState_08006420(TIM_TypeDef_conflict *timer,uint32_t channel,uint32_t newState)\n\n{\n  timer->CCER = timer->CCER & ~(4 << (channel & 0xff));\n  timer->CCER = timer->CCER | newState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006420": "set_channel_state_08006420",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "newState"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Start",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800643c": {
            "entrypoint": "0x0800643c",
            "current_name": "initialize_timer_channel_0800643c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeTimerChannel_0800643c(TIM_HandleTypeDef_conflict *timerHandle,uint32_t channelNumber)\n\n{\n  TIM_CCxNchannelNumberCmd(timerHandle->Instance,channelNumber,4);\n  timerHandle->Instance->BDTR = timerHandle->Instance->BDTR | 0x8000;\n  timerHandle->Instance->CR1 = timerHandle->Instance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800643c": "initialize_timer_channel_0800643c",
                "htim": "timerHandle",
                "Channel": "channelNumber"
            },
            "calling": [
                "pwm_start"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006460": {
            "entrypoint": "0x08006460",
            "current_name": "disable_channel_08006460",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict disableChannel_08006460(TIM_HandleTypeDef_conflict *timer,uint32_t channel)\n\n{\n  TimerTypeDef *timerInstance;\n  \n  TIM_CCxNchannelCmd(timer->Instance,channel,0);\n  timerInstance = timer->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08006460": "disable_channel_08006460",
                "htim": "timer",
                "Channel": "channel",
                "TIM_TypeDef_conflict": "TimerTypeDef",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080064ac": {
            "entrypoint": "0x080064ac",
            "current_name": "FUNC_080064ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080064ac(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080064ac": "FUNC_080064ac"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080064ae": {
            "entrypoint": "0x080064ae",
            "current_name": "FUNC_080064ae",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080064ae(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080064ae": "FUNC_080064ae"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080064b0": {
            "entrypoint": "0x080064b0",
            "current_name": "reset_uart_state_080064b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetUARTState_080064b0(UART_HandleTypeDef *uartHandle)\n\n{\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffedf;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n  uartHandle->RxState = HAL_UART_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080064b0": "reset_uart_state_080064b0",
                "huart": "uartHandle"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080064cc": {
            "entrypoint": "0x080064cc",
            "current_name": "uart_transmit_080064cc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict UART_Transmit_080064cc(UART_HandleTypeDef *uart_handle)\n\n{\n  uint16_t remaining_bytes;\n  byte *buffer_ptr;\n  uint16_t *tmp_ptr;\n  \n  if (uart_handle->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((uart_handle->Init).WordLength == 0x1000) {\n    uart_handle->Instance->DR = *(ushort *)uart_handle->pTxBuffPtr & 0x1ff;\n    if ((uart_handle->Init).Parity == 0) {\n      uart_handle->pTxBuffPtr = uart_handle->pTxBuffPtr + 2;\n    }\n    else {\n      uart_handle->pTxBuffPtr = uart_handle->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    buffer_ptr = uart_handle->pTxBuffPtr;\n    uart_handle->pTxBuffPtr = buffer_ptr + 1;\n    uart_handle->Instance->DR = (uint)*buffer_ptr;\n  }\n  remaining_bytes = uart_handle->TxXferCount - 1;\n  uart_handle->TxXferCount = remaining_bytes;\n  if (remaining_bytes == 0) {\n    uart_handle->Instance->CR1 = uart_handle->Instance->CR1 & 0xffffff7f;\n    uart_handle->Instance->CR1 = uart_handle->Instance->CR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080064cc": "uart_transmit_080064cc",
                "huart": "uart_handle",
                "uVar1": "remaining_bytes",
                "pbVar2": "buffer_ptr",
                "tmp": "tmp_ptr"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006538": {
            "entrypoint": "0x08006538",
            "current_name": "configure_uart_08006538",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureUART_08006538(uartHandler *huart)\n\n{\n  uint32_t pclkFreq1;\n  uint32_t pclkFreq2;\n  uint32_t pclkFreq3;\n  uint32_t pclkFreq4;\n  uint32_t pclkFreq5;\n  uint32_t baudRate1;\n  uint32_t baudRate2;\n  uint32_t baudRate3;\n  uint32_t baudRate4;\n  uartTypeDef *uartInstance;\n  \n  huart->Instance->CR2 = huart->Instance->CR2 & 0xffffcfff | (huart->Init).StopBits;\n  huart->Instance->CR1 =\n       (huart->Init).WordLength | (huart->Init).Parity | (huart->Init).Mode |\n       huart->Instance->CR1 & 0xffffe9f3;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffcff | (huart->Init).HwFlowCtl;\n  uartInstance = huart->Instance;\n  if (uartInstance != (uartTypeDef *)0x40013800) {\n    pclkFreq1 = HAL_RCC_GetPCLK1Freq();\n    baudRate1 = (huart->Init).BaudRate;\n    pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n    baudRate2 = (huart->Init).BaudRate;\n    pclkFreq3 = HAL_RCC_GetPCLK1Freq();\n    baudRate3 = (huart->Init).BaudRate;\n    pclkFreq4 = HAL_RCC_GetPCLK1Freq();\n    baudRate4 = (huart->Init).BaudRate;\n    pclkFreq5 = HAL_RCC_GetPCLK1Freq();\n    uartInstance->BRR = ((uint)((int)((ulonglong)\n                                 (((pclkFreq4 * 0x19) / (baudRate4 << 2) +\n                                  (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                        (ulonglong)((huart->Init).BaudRate << 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                   ((((pclkFreq2 * 0x19) / (baudRate2 << 2) +\n                     (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 & 0xf0) +\n                   (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(baudRate1 << 2)) / 100) * 0x10;\n    return;\n  }\n  pclkFreq1 = HAL_RCC_GetPCLK2Freq();\n  baudRate1 = (huart->Init).BaudRate;\n  pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n  baudRate2 = (huart->Init).BaudRate;\n  pclkFreq3 = HAL_RCC_GetPCLK2Freq();\n  baudRate3 = (huart->Init).BaudRate;\n  pclkFreq4 = HAL_RCC_GetPCLK2Freq();\n  baudRate4 = (huart->Init).BaudRate;\n  pclkFreq5 = HAL_RCC_GetPCLK2Freq();\n  iRam40013808 = ((uint)((int)((ulonglong)\n                               (((pclkFreq4 * 0x19) / (baudRate4 << 2) +\n                                (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                      (ulonglong)((huart->Init).BaudRate << 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                 ((((pclkFreq2 * 0x19) / (baudRate2 << 2) +\n                   (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 & 0xf0) +\n                 (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(baudRate1 << 2)) / 100) * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006538": "configure_uart_08006538",
                "UART_HandleTypeDef": "uartHandler",
                "USART_TypeDef": "uartTypeDef",
                "pUVar10": "uartInstance",
                "uVar1": "pclkFreq1",
                "uVar2": "pclkFreq2",
                "uVar3": "pclkFreq3",
                "uVar4": "pclkFreq4",
                "uVar5": "pclkFreq5",
                "uVar6": "baudRate1",
                "uVar7": "baudRate2",
                "uVar8": "baudRate3",
                "uVar9": "baudRate4"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080066e8": {
            "entrypoint": "0x080066e8",
            "current_name": "check_flag_status_080066e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_desiredStatusTypeDef_conflict\ncheckFlagStatus_080066e8(UART_HandleTypeDef *UART_Handle,uint32_t flagMask,flagMaskdesiredStatus desiredStatus,uint32_t startTick,\n            uint32_t timeout)\n\n{\n  uint32_t currentTick;\n  \n  do {\n    if (((flagMask & ~UART_Handle->Instance->SR) == 0) != (bool)desiredStatus) {\n      return HAL_OK;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n  UART_Handle->Instance->CR1 = UART_Handle->Instance->CR1 & 0xfffffe5f;\n  UART_Handle->Instance->CR3 = UART_Handle->Instance->CR3 & 0xfffffffe;\n  UART_Handle->gState = HAL_UART_STATE_READY;\n  UART_Handle->RxState = HAL_UART_STATE_READY;\n  UART_Handle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_080066e8": "check_flag_status_080066e8",
                "huart": "UART_Handle",
                "Flag": "flagMask",
                "Status": "desiredStatus",
                "Tickstart": "startTick",
                "Timeout": "timeout",
                "uVar1": "currentTick"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800674c": {
            "entrypoint": "0x0800674c",
            "current_name": "FUNC_0800674c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800674c(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800674c": "FUNC_0800674c"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800674e": {
            "entrypoint": "0x0800674e",
            "current_name": "initialize_uart_0800674e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_Status initializeUART_0800674e(UART_HandleTypeDef *huart)\n\n{\n  if (huart != (UART_HandleTypeDef *)0x0) {\n    if (huart->globalState == HAL_UART_STATE_RESET) {\n      huart->lockStatus = HAL_UNLOCKED;\n      HAL_UART_MspInit(huart);\n    }\n    huart->globalState = HAL_UART_STATE_BUSY;\n    huart->uartInstance->controlRegister1 = huart->uartInstance->controlRegister1 & 0xffffdfff;\n    UART_SetConfig(huart);\n    huart->uartInstance->controlRegister2 = huart->uartInstance->controlRegister2 & 0xffffb7ff;\n    huart->uartInstance->controlRegister3 = huart->uartInstance->controlRegister3 & 0xffffffd5;\n    huart->uartInstance->controlRegister1 = huart->uartInstance->controlRegister1 | 0x2000;\n    huart->error = 0;\n    huart->globalState = HAL_UART_STATE_READY;\n    huart->receiveState = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800674e": "initialize_uart_0800674e",
                "HAL_StatusTypeDef_conflict": "HAL_Status",
                "gState": "globalState",
                "Lock": "lockStatus",
                "Instance": "uartInstance",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "CR3": "controlRegister3",
                "ErrorCode": "error",
                "RxState": "receiveState"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080067ac": {
            "entrypoint": "0x080067ac",
            "current_name": "transmit_data_080067ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\ntransmitData_080067ac(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTicks;\n  uint16_t *temp;\n  \n  if (uartHandle->gState == HAL_UART_STATE_READY) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (uartHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n      startTicks = HAL_GetTick();\n      uartHandle->TxXfersize = size;\n      uartHandle->TxXferCount = size;\n      while (uartHandle->TxXferCount != 0) {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,startTicks,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = *(ushort *)data & 0x1ff;\n          if ((uartHandle->Init).Parity == 0) {\n            data = (uint8_t *)((int)data + 2);\n          }\n          else {\n            data = (uint8_t *)((int)data + 1);\n          }\n        }\n        else {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,startTicks,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = (uint)*data;\n          data = (uint8_t *)((int)data + 1);\n        }\n      }\n      status = UART_WaitOnFlagUntiltimeout(uartHandle,0x40,RESET,startTicks,timeout);\n      if (status == HAL_OK) {\n        uartHandle->gState = HAL_UART_STATE_READY;\n        uartHandle->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080067ac": "transmit_data_080067ac",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "startTicks",
                "tmp": "temp"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "UART_WaitOnFlagUntilTimeout",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800688e": {
            "entrypoint": "0x0800688e",
            "current_name": "configure_uart_0800688e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configure_UART_0800688e(UART_HandleTypeDef *UART_handler,uint8_t *data,uint16_t size)\n\n{\n  if (UART_handler->gState != UART_STATE_READY) {\n    return BUSY;\n  }\n  if (data == (uint8_t *)0x0) {\n    return ERROR;\n  }\n  if (size == 0) {\n    return ERROR;\n  }\n  if (UART_handler->Lock != LOCKED) {\n    UART_handler->transmit_buffer_pointer = data;\n    UART_handler->transmit_transfer_size = size;\n    UART_handler->transmit_transfer_count = size;\n    UART_handler->error_code = 0;\n    UART_handler->gState = UART_STATE_BUSY_TX;\n    UART_handler->Lock = UNLOCKED;\n    UART_handler->UART_instance->control_register_1 = UART_handler->UART_instance->control_register_1 | 0x80;\n    return OK;\n  }\n  return BUSY;\n}\n\n",
            "renaming": {
                "FUN_0800688e": "configure_uart_0800688e",
                "huart": "UART_handler",
                "pData": "data",
                "Size": "size",
                "HAL_UART_STATE_READY": "UART_STATE_READY",
                "HAL_BUSY": "BUSY",
                "HAL_ERROR": "ERROR",
                "HAL_LOCKED": "LOCKED",
                "pTxBuffPtr": "transmit_buffer_pointer",
                "TxXferSize": "transmit_transfer_size",
                "TxXferCount": "transmit_transfer_count",
                "ErrorCode": "error_code",
                "HAL_UART_STATE_BUSY_TX": "UART_STATE_BUSY_TX",
                "HAL_UNLOCKED": "UNLOCKED",
                "Instance": "UART_instance",
                "CR1": "control_register_1",
                "HAL_OK": "OK"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080068d6": {
            "entrypoint": "0x080068d6",
            "current_name": "initialize_uart_receive_080068d6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initialize_UART_receive_080068d6(UART_HandleTypeDef *UART_handle,uint8_t *data_buffer,uint16_t buffer_size)\n\n{\n  if (UART_handle->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data_buffer == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (buffer_size == 0) {\n    return HAL_ERROR;\n  }\n  if (UART_handle->Lock != HAL_LOCKED) {\n    UART_handle->pRxBuffPtr = data_buffer;\n    UART_handle->RxXferbuffer_size = buffer_size;\n    UART_handle->RxXferCount = buffer_size;\n    UART_handle->ErrorCode = 0;\n    UART_handle->RxState = HAL_UART_STATE_BUSY_RX;\n    UART_handle->Lock = HAL_UNLOCKED;\n    UART_handle->Instance->CR1 = UART_handle->Instance->CR1 | 0x100;\n    UART_handle->Instance->CR3 = UART_handle->Instance->CR3 | 1;\n    UART_handle->Instance->CR1 = UART_handle->Instance->CR1 | 0x20;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_080068d6": "initialize_uart_receive_080068d6",
                "huart": "UART_handle",
                "pData": "data_buffer",
                "Size": "buffer_size"
            },
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006932": {
            "entrypoint": "0x08006932",
            "current_name": "reset_uart_08006932",
            "code": "\n/* WARNING: Unknown calling convention */\n\nstatus_conflict reset_uart_08006932(UART_HandleTypeDef *uart_handle)\n\n{\n  uart_handle->uart_instance->control_register1 = uart_handle->uart_instance->control_register1 & 0xffffffbf;\n  uart_handle->uart_state = HAL_UART_STATE_READY;\n  handle_tx_complete_callback(uart_handle);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08006932": "reset_uart_08006932",
                "huart": "uart_handle",
                "Instance": "uart_instance",
                "CR1": "control_register1",
                "gState": "uart_state",
                "HAL_UART_TxCpltCallback": "handle_tx_complete_callback",
                "HAL_StatusTypeDef": "status"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800694c": {
            "entrypoint": "0x0800694c",
            "current_name": "receive_data_0800694c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict receiveData_0800694c(UART_HandleTypeDef *uartHandle)\n\n{\n  uint16_t *wordPointer;\n  byte *bytePointer;\n  uint16_t remainingBytes;\n  uint8_t *bytePointer2;\n  \n  if (uartHandle->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((uartHandle->Init).WordLength == 0x1000) {\n    if ((uartHandle->Init).Parity == 0) {\n      *(ushort *)uartHandle->pRxBuffPtr = (ushort)((uartHandle->Instance->DR << 0x17) >> 0x17);\n      uartHandle->pRxBuffPtr = uartHandle->pRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)uartHandle->pRxBuffPtr = (ushort)uartHandle->Instance->DR & 0xff;\n      uartHandle->pRxBuffPtr = uartHandle->pRxBuffPtr + 1;\n    }\n  }\n  else if ((uartHandle->Init).Parity == 0) {\n    bytePointer2 = uartHandle->pRxBuffPtr;\n    uartHandle->pRxBuffPtr = bytePointer2 + 1;\n    *bytePointer2 = (uint8_t)uartHandle->Instance->DR;\n  }\n  else {\n    bytePointer = uartHandle->pRxBuffPtr;\n    uartHandle->pRxBuffPtr = bytePointer + 1;\n    *bytePointer = (byte)uartHandle->Instance->DR & 0x7f;\n  }\n  remainingBytes = uartHandle->RxXferCount - 1;\n  uartHandle->RxXferCount = remainingBytes;\n  if (remainingBytes != 0) {\n    return HAL_OK;\n  }\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffffdf;\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffeff;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n  uartHandle->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uartHandle);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800694c": "receive_data_0800694c",
                "huart": "uartHandle",
                "tmp": "wordPointer",
                "pbVar1": "bytePointer",
                "uVar2": "remainingBytes",
                "puVar3": "bytePointer2"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080069ec": {
            "entrypoint": "0x080069ec",
            "current_name": "handle_uart_interrupt_080069ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_080069ec(UART_HandleTypeDef *UART_handle)\n\n{\n  HAL_StatusTypeDef_conflict HAL_status;\n  uint control_register_1;\n  uint32_t cr1_interrupts;\n  USART_TypeDef *UART_instance;\n  uint32_t cr3_interrupts;\n  uint cr3_bit;\n  uint status_register;\n  uint32_t interrupt_flags;\n  \n  UART_instance = UART_handle->Instance;\n  status_register = UART_instance->SR;\n  control_register_1 = UART_instance->CR1;\n  if ((((status_register & 0xf) == 0) && ((status_register & 0x20) != 0)) && ((control_register_1 & 0x20) != 0)) {\n    UART_Receive_IT(UART_handle);\n    return;\n  }\n  if (((status_register & 0xf) == 0) || ((cr3_bit = UART_instance->CR3 & 1, cr3_bit == 0 && ((control_register_1 & 0x120) == 0)))) {\n    if (((status_register & 0x80) != 0) && ((control_register_1 & 0x80) != 0)) {\n      UART_Transmit_IT(UART_handle);\n      return;\n    }\n    if (((status_register & 0x40) != 0) && ((control_register_1 & 0x40) != 0)) {\n      UART_EndTransmit_IT(UART_handle);\n    }\n  }\n  else {\n    if (((status_register & 1) != 0) && ((control_register_1 & 0x100) != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 1;\n    }\n    if (((status_register & 4) != 0) && (cr3_bit != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 2;\n    }\n    if (((status_register & 2) != 0) && (cr3_bit != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 4;\n    }\n    if (((status_register & 8) != 0) && (cr3_bit != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 8;\n    }\n    if (UART_handle->ErrorCode != 0) {\n      if (((status_register & 0x20) != 0) && ((control_register_1 & 0x20) != 0)) {\n        UART_Receive_IT(UART_handle);\n      }\n      if (((UART_handle->ErrorCode & 8) == 0) && ((UART_handle->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(UART_handle);\n        UART_handle->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(UART_handle);\n      UART_instance = UART_handle->Instance;\n      if ((UART_instance->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(UART_handle);\n        return;\n      }\n      UART_instance->CR3 = UART_instance->CR3 & 0xffffffbf;\n      if (UART_handle->hdmarx == (DMA_HandleTypeDef_conflict *)0x0) {\n        HAL_UART_ErrorCallback(UART_handle);\n        return;\n      }\n      UART_handle->hdmarx->XferAbortCallback = UART_DMAAbortOnError + 1;\n      HAL_status = HAL_DMA_Abort_IT(UART_handle->hdmarx);\n      if (HAL_status != HAL_OK) {\n        (*UART_handle->hdmarx->XferAbortCallback)(UART_handle->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080069ec": "handle_uart_interrupt_080069ec",
                "huart": "UART_handle",
                "HVar1": "HAL_status",
                "uVar2": "control_register_1",
                "uVar4": "cr3_bit",
                "uVar5": "status_register",
                "isrflags": "interrupt_flags",
                "pUVar3": "UART_instance",
                "cr1its": "cr1_interrupts",
                "cr3its": "cr3_interrupts"
            },
            "calling": [
                "USART1_IRQHandler",
                "USART3_IRQHandler",
                "USART2_IRQHandler"
            ],
            "called": [
                "UART_EndTransmit_IT",
                "UART_Receive_IT",
                "UART_Transmit_IT",
                "HAL_DMA_Abort_IT",
                "HAL_UART_ErrorCallback",
                "UART_EndRxTransfer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b0c": {
            "entrypoint": "0x08006b0c",
            "current_name": "handle_dma_error_08006b0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleDmaError_08006b0c(DMA_HandleTypeDef_conflict *dmaHandle)\n\n{\n  UART_HandleTypeDef *uartHandle;\n  UART_HandleTypeDef *uart;\n  \n  uartHandle = (UART_HandleTypeDef *)dmaHandle->Parent;\n  uartHandle->receiveTransferCount = 0;\n  uartHandle->transmitTransferCount = 0;\n  reportUartError(uartHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006b0c": "handle_dma_error_08006b0c",
                "hdma": "dmaHandle",
                "huart_00": "uartHandle",
                "huart": "uart",
                "RxXferCount": "receiveTransferCount",
                "TxXferCount": "transmitTransferCount",
                "HAL_UART_ErrorCallback": "reportUartError"
            },
            "calling": [],
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b1c": {
            "entrypoint": "0x08006b1c",
            "current_name": "get_combined_state_08006b1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef get_combined_state_08006b1c(UART_HandleTypeDef *uart_handler)\n\n{\n  return uart_handler->receive_state | uart_handler->global_state;\n}\n\n",
            "renaming": {
                "FUN_08006b1c": "get_combined_state_08006b1c",
                "huart": "uart_handler",
                "RxState": "receive_state",
                "gState": "global_state"
            },
            "calling": [
                "serial_rx_active",
                "serial_tx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b28": {
            "entrypoint": "0x08006b28",
            "current_name": "check_pin_functionality_08006b28",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool checkPinFunctionality_08006b28(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint32_t pinIndex;\n  \n  pinIndex = pinMap[(uint)((int)pinName << 0x18) >> 0x1c];\n  return (_Bool)((byte)(pinIndex >> ((int)pinName & 0xfU)) & 1);\n}\n\n",
            "renaming": {
                "FUN_08006b28": "check_pin_functionality_08006b28",
                "pin": "pinName",
                "map": "pinMap",
                "index": "pinIndex"
            },
            "calling": [
                "digitalWrite",
                "digitalRead",
                "analogWrite",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b3e": {
            "entrypoint": "0x08006b3e",
            "current_name": "set_pin_map_value_08006b3e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinMapValue_08006b3e(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint shiftedIndex;\n  uint32_t index;\n  \n  shiftedIndex = (uint)((int)pinName << 0x18) >> 0x1c;\n  pinMap[shiftedIndex] = pinMap[shiftedIndex] | 1 << ((int)pinName & 0xfU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006b3e": "set_pin_map_value_08006b3e",
                "pin": "pinName",
                "map": "pinMap",
                "uVar1": "shiftedIndex"
            },
            "calling": [
                "analogWrite",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b5c": {
            "entrypoint": "0x08006b5c",
            "current_name": "update_pin_map_08006b5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updatePinMap_08006b5c(PinName_conflict inputPin,uint32_t *pinMap)\n\n{\n  uint pinIndex;\n  uint32_t index;\n  \n  pinIndex = (uint)((int)inputPin << 0x18) >> 0x1c;\n  pinMap[pinIndex] = pinMap[pinIndex] & ~(1 << ((int)inputPin & 0xfU));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006b5c": "update_pin_map_08006b5c",
                "pin": "inputPin",
                "map": "pinMap",
                "uVar1": "pinIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b7c": {
            "entrypoint": "0x08006b7c",
            "current_name": "get_gpio_type_def_08006b7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * getGPIOTypeDef_08006b7c(uint32_t portIndex)\n\n{\n  switch(portIndex) {\n  case 0:\n    return (GPIO_TypeDef *)0x40010800;\n  case 1:\n    return (GPIO_TypeDef *)0x40010c00;\n  case 2:\n    return (GPIO_TypeDef *)0x40011000;\n  case 3:\n    return (GPIO_TypeDef *)0x40011400;\n  case 4:\n    return (GPIO_TypeDef *)0x40011800;\n  default:\n    return (GPIO_TypeDef *)0x0;\n  }\n}\n\n",
            "renaming": {
                "FUN_08006b7c": "get_gpio_type_def_08006b7c",
                "port_idx": "portIndex"
            },
            "calling": [
                "digitalWrite",
                "digitalRead"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006bb8": {
            "entrypoint": "0x08006bb8",
            "current_name": "get_gpio_from_port_index_08006bb8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * getGPIOFromPortIndex_08006bb8(uint32_t portIndex)\n\n{\n  GPIO_TypeDef *GPIOVariable;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister1;\n  uint32_t temporaryRegister2;\n  uint32_t temporaryRegister3;\n  uint32_t temporaryRegister4;\n  \n  switch(portIndex) {\n  case 0:\n    _DAT_40021018 = _DAT_40021018 | 4;\n    GPIOVariable = (GPIO_TypeDef *)0x40010800;\n    break;\n  case 1:\n    _DAT_40021018 = _DAT_40021018 | 8;\n    GPIOVariable = (GPIO_TypeDef *)0x40010c00;\n    break;\n  case 2:\n    _DAT_40021018 = _DAT_40021018 | 0x10;\n    GPIOVariable = (GPIO_TypeDef *)0x40011000;\n    break;\n  case 3:\n    _DAT_40021018 = _DAT_40021018 | 0x20;\n    GPIOVariable = (GPIO_TypeDef *)0x40011400;\n    break;\n  case 4:\n    _DAT_40021018 = _DAT_40021018 | 0x40;\n    GPIOVariable = (GPIO_TypeDef *)0x40011800;\n    break;\n  default:\n    GPIOVariable = (GPIO_TypeDef *)0x0;\n  }\n  return GPIOVariable;\n}\n\n",
            "renaming": {
                "FUN_08006bb8": "get_gpio_from_port_index_08006bb8",
                "port_idx": "portIndex",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister1",
                "tmpreg_2": "temporaryRegister2",
                "tmpreg_3": "temporaryRegister3",
                "tmpreg_4": "temporaryRegister4",
                "pGVar1": "GPIOVariable"
            },
            "calling": [
                "uart_init",
                "HAL_TIM_PWM_MspInit",
                "HAL_ADC_MspInit",
                "digital_io_init",
                "i2c_custom_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c60": {
            "entrypoint": "0x08006c60",
            "current_name": "get_adc_function_08006c60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getADCFunction_08006c60(pin pin)\n\n{\n  uint32_t pinFunction;\n  uint32_t shiftedFunction;\n  \n  pinFunction = pinmap_shiftedFunction(pin,(PinMap_conflict *)&PinMap_ADC);\n  shiftedFunction = pinFunction << 0xc;\n  shiftedFunction = shiftedFunction >> 0x1b;\n  if (0x10 < shiftedFunction - 1) {\n    shiftedFunction = 0;\n  }\n  return shiftedFunction;\n}\n\n",
            "renaming": {
                "FUN_08006c60": "get_adc_function_08006c60",
                "PinName_conflict": "pin",
                "uVar1": "pinFunction",
                "function": "shiftedFunction"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c7c": {
            "entrypoint": "0x08006c7c",
            "current_name": "get_pin_function_08006c7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getPinFunction_08006c7c(PinName_conflict inputPin)\n\n{\n  uint32_t functionIndex;\n  uint32_t functionCode;\n  \n  functionIndex = inputPinmap_functionCode(inputPin,(PinMap_conflict *)&PinMap_PWM);\n  functionCode = functionIndex << 0xc;\n  functionCode = functionCode >> 0x1b;\n  if (functionCode == 3) {\n    return 8;\n  }\n  if (functionCode != 4) {\n    if (functionCode != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_08006c7c": "get_pin_function_08006c7c",
                "pin": "inputPin",
                "uVar1": "functionIndex",
                "function": "functionCode"
            },
            "calling": [
                "pwm_stop",
                "pwm_start"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ca8": {
            "entrypoint": "0x08006ca8",
            "current_name": "initialize_adc_gpio_08006ca8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeADC_GPIO_08006ca8(ADC_HandleTypeDef *adcHandle)\n\n{\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *gpioPort;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister_1;\n  GPIO_InitTypeDef gpioInitStructure;\n  \n  if (adcHandle->Instance == (ADC_TypeDef *)0x40012400) {\n    _DAT_40021018 = _DAT_40021018 | 0x200;\n  }\n  else if (adcHandle->Instance == (ADC_TypeDef *)0x40012800) {\n    _DAT_40021018 = _DAT_40021018 | 0x400;\n  }\n  gpioPort = set_GPIO_Port_Clock((uint)((int)g_current_pin << 0x18) >> 0x1c);\n  gpioInitStructure.Pin = 1 << (g_current_pin & 0xfU) & 0xffff;\n  gpioInitStructure.Mode = 3;\n  gpioInitStructure.Pull = 0;\n  HAL_GPIO_Init(gpioPort,&gpioInitStructure);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006ca8": "initialize_adc_gpio_08006ca8",
                "hadc": "adcHandle",
                "GPIOx": "gpioPort",
                "port": "gpioPort",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister_1",
                "GPIO_InitStruct": "gpioInitStructure"
            },
            "calling": [
                "HAL_ADC_Init"
            ],
            "called": [
                "set_GPIO_Port_Clock",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d24": {
            "entrypoint": "0x08006d24",
            "current_name": "update_adc_registers_08006d24",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid update_ADC_registers_08006d24(ADC_HandleTypeDef *ADC_handle)\n\n{\n  if (ADC_handle->ADC_instance != (ADC_TypeDef *)0x40012400) {\n    if (ADC_handle->ADC_instance == (ADC_TypeDef *)0x40012800) {\n      _DAT_4002100c = _DAT_4002100c & 0xfffffbff;\n      _DAT_40021018 = _DAT_40021018 & 0xfffffbff;\n    }\n    return;\n  }\n  _DAT_4002100c = _DAT_4002100c & 0xfffffdff;\n  _DAT_40021018 = _DAT_40021018 & 0xfffffdff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006d24": "update_adc_registers_08006d24",
                "hadc": "ADC_handle",
                "Instance": "ADC_instance"
            },
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d80": {
            "entrypoint": "0x08006d80",
            "current_name": "read_adc_value_08006d80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint16_t readADCValue_08006d80(pin pin)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t adcValue;\n  uint16_t convertedValue;\n  ADC_ChannelConfTypeDef channelConfig;\n  ADC_HandleTypeDef adcHandle;\n  \n  memset(&adcHandle,0,0x30);\n  channelConfig.Channel = 0;\n  channelConfig.Rank = 0;\n  channelConfig.SamplingTime = 0;\n  convertedValue = 0;\n  adcHandle.Instance = (ADC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_ADC);\n  if (adcHandle.Instance == (ADC_TypeDef *)0x0) {\n    convertedValue = 0;\n  }\n  else {\n    adcHandle.Init.DataAlign = 0;\n    adcHandle.Init.ScanConvMode = 0;\n    adcHandle.Init.ContinuousConvMode = 0;\n    adcHandle.Init.DiscontinuousConvMode = 0;\n    adcHandle.Init.ExternalTrigConv = 0xe0000;\n    adcHandle.State = 0;\n    adcHandle.Init.NbrOfConversion = 1;\n    adcHandle.Init.NbrOfDiscConversion = 0;\n    g_current_pin = pin;\n    status = HAL_ADC_Init(&adcHandle);\n    if (status == HAL_OK) {\n      channelConfig.Channel = get_adc_channel(pin);\n      if (channelConfig.Channel < 0x12) {\n        channelConfig.Rank = 1;\n        channelConfig.SamplingTime = 2;\n        status = HAL_ADC_ConfigChannel(&adcHandle,&channelConfig);\n        if (status == HAL_OK) {\n          status = HAL_ADCEx_Calibration_Start(&adcHandle);\n          if (status == HAL_OK) {\n            status = HAL_ADC_Start(&adcHandle);\n            if (status == HAL_OK) {\n              status = HAL_ADC_PollForConversion(&adcHandle,10);\n              if (status == HAL_OK) {\n                adcValue = HAL_ADC_GetState(&adcHandle);\n                if ((adcValue & 0x200) != 0) {\n                  adcValue = HAL_ADC_GetValue(&adcHandle);\n                  convertedValue = (uint16_t)adcValue;\n                }\n                status = HAL_ADC_Stop(&adcHandle);\n                if (status == HAL_OK) {\n                  status = HAL_ADC_DeInit(&adcHandle);\n                  if (status != HAL_OK) {\n                    convertedValue = 0;\n                  }\n                }\n                else {\n                  convertedValue = 0;\n                }\n              }\n              else {\n                convertedValue = 0;\n              }\n            }\n            else {\n              convertedValue = 0;\n            }\n          }\n          else {\n            convertedValue = 0;\n          }\n        }\n        else {\n          convertedValue = 0;\n        }\n      }\n      else {\n        convertedValue = 0;\n      }\n    }\n    else {\n      convertedValue = 0;\n    }\n  }\n  return convertedValue;\n}\n\n",
            "renaming": {
                "FUN_08006d80": "read_adc_value_08006d80",
                "PinName_conflict": "pin",
                "HVar1": "status",
                "uVar2": "adcValue",
                "uhADCxConvertedValue": "convertedValue",
                "AdcChannelConf": "channelConfig",
                "AdcHandle": "adcHandle"
            },
            "calling": [
                "analogRead"
            ],
            "called": [
                "memset",
                "HAL_ADC_ConfigChannel",
                "HAL_ADC_PollForConversion",
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_GetValue",
                "get_adc_channel",
                "pinmap_peripheral",
                "HAL_ADC_GetState",
                "HAL_ADC_Start",
                "HAL_ADC_Stop",
                "HAL_ADC_DeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e68": {
            "entrypoint": "0x08006e68",
            "current_name": "initialize_pwm_gpio_08006e68",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_PWM_GPIO_08006e68(TIM_HandleTypeDef_conflict *timer_handle)\n\n{\n  uint32_t pin_function;\n  uint32_t tmpreg_10;\n  GPIO_TypeDef *gpio_port;\n  GPIO_TypeDef *tmpreg_13;\n  uint32_t tmpreg_13;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t pin_config;\n  uint32_t tmpreg_11;\n  uint32_t tmpreg_12;\n  uint32_t tmpreg;\n  GPIO_InitTypeDef gpio_init;\n  \n  pin_function = pinmap_tmpreg_10(g_current_pin,(PinMap_conflict *)&PinMap_PWM);\n  timer_enable_clock(timer_handle);\n  gpio_port = set_GPIO_Port_Clock((uint)((int)g_current_pin << 0x18) >> 0x1c);\n  gpio_init.Mode = 2;\n  gpio_init.Pull = 0;\n  gpio_init.Speed = 3;\n  _DAT_40021018 = _DAT_40021018 | 1;\n  switch((pin_function << 0x11) >> 0x19) {\n  case 1:\n    pin_config = pin_config | 0x7000001;\n    break;\n  case 2:\n    pin_config = pin_config & 0xfffffffe | 0x7000000;\n    break;\n  case 3:\n    pin_config = pin_config | 0x7000002;\n    break;\n  case 4:\n    pin_config = pin_config & 0xfffffffd | 0x7000000;\n    break;\n  case 5:\n    pin_config = pin_config | 0x7000004;\n    break;\n  case 6:\n    pin_config = pin_config & 0xfffffffb | 0x7000000;\n    break;\n  case 7:\n    pin_config = pin_config | 0x7000008;\n    break;\n  case 8:\n    pin_config = pin_config & 0xfffffff7 | 0x7000000;\n    break;\n  case 9:\n    pin_config = pin_config | 0x7000030;\n    break;\n  case 10:\n    tmpreg_1 = pin_config & 0xffffffcf;\n    pin_config = tmpreg_1 | 0x7000010;\n    break;\n  case 0xb:\n    tmpreg_2 = pin_config & 0xffffffcf;\n    pin_config = tmpreg_2 | 0x7000000;\n    break;\n  case 0xc:\n    pin_config = pin_config | 0x70000c0;\n    break;\n  case 0xd:\n    tmpreg_3 = pin_config & 0xffffff3f;\n    pin_config = tmpreg_3 | 0x7000040;\n    break;\n  case 0xe:\n    tmpreg_4 = pin_config & 0xffffff3f;\n    pin_config = tmpreg_4 | 0x7000000;\n    break;\n  case 0xf:\n    pin_config = pin_config | 0x7000300;\n    break;\n  case 0x10:\n    tmpreg_5 = pin_config & 0xfffffcff;\n    pin_config = tmpreg_5 | 0x7000200;\n    break;\n  case 0x11:\n    tmpreg_6 = pin_config & 0xfffffcff;\n    pin_config = tmpreg_6 | 0x7000100;\n    break;\n  case 0x12:\n    tmpreg_7 = pin_config & 0xfffffcff;\n    pin_config = tmpreg_7 | 0x7000000;\n    break;\n  case 0x13:\n    pin_config = pin_config | 0x7000c00;\n    break;\n  case 0x14:\n    tmpreg_8 = pin_config & 0xfffff3ff;\n    pin_config = tmpreg_8 | 0x7000800;\n    break;\n  case 0x15:\n    tmpreg_9 = pin_config & 0xfffff3ff;\n    pin_config = tmpreg_9 | 0x7000000;\n    break;\n  case 0x16:\n    pin_config = pin_config | 0x7001000;\n    break;\n  case 0x17:\n    pin_config = pin_config & 0xffffefff | 0x7000000;\n    break;\n  case 0x1b:\n    pin_config = pin_config | 0x7008000;\n    break;\n  case 0x1c:\n    pin_config = pin_config & 0xffff7fff | 0x7000000;\n    break;\n  case 0x21:\n    pin_config = pin_config & 0xf8ffffff;\n    break;\n  case 0x22:\n    tmpreg_11 = pin_config & 0xf8ffffff;\n    pin_config = tmpreg_11 | 0x1000000;\n    break;\n  case 0x23:\n    tmpreg_12 = pin_config & 0xf8ffffff;\n    pin_config = tmpreg_12 | 0x2000000;\n    break;\n  case 0x24:\n    pin_config = pin_config & 0xf8ffffff | 0x4000000;\n  }\n  gpio_init.Pin = 1 << (g_current_pin & 0xfU) & 0xffff;\n  HAL_GPIO_Init(gpio_port,&gpio_init);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e68": "initialize_pwm_gpio_08006e68",
                "htim": "timer_handle",
                "uVar1": "pin_function",
                "function": "tmpreg_10",
                "GPIOx": "gpio_port",
                "port": "tmpreg_13",
                "tmpreg_10": "pin_config",
                "GPIO_InitStruct": "gpio_init"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [
                "pinmap_function",
                "set_GPIO_Port_Clock",
                "timer_enable_clock",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007110": {
            "entrypoint": "0x08007110",
            "current_name": "disable_timer_clock_08007110",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_timer_clock_08007110(TIM_HandleTypeDef_conflict *timer_handle)\n\n{\n  disable_timer_clock_08007110(timer_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007110": "disable_timer_clock_08007110",
                "htim": "timer_handle",
                "timer_disable_clock": "disable_timer_clock"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007118": {
            "entrypoint": "0x08007118",
            "current_name": "initialize_pwm_08007118",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_PWM_08007118(pin pin,uint32_t clock_frequency,uint32_t pulse_period,uint32_t pulse_value,\n                 uint8_t initialize)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t timer_clk_freq;\n  uint32_t timer_channel;\n  uint32_t pwm_channel;\n  TIM_OC_InitTypeDef pwm_config;\n  TIM_HandleTypeDef_conflict timer_handle;\n  \n  memset(&timer_handle,0,0x40);\n  pwm_config.OCMode = 0;\n  pwm_config.Pulse = 0;\n  pwm_config.OCPolarity = 0;\n  pwm_config.OCNPolarity = 0;\n  pwm_config.OCFastMode = 0;\n  pwm_config.OCIdleState = 0;\n  pwm_config.OCNIdleState = 0;\n  timer_handle.Instance = (TIM_TypeDef_conflict *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_PWM)\n  ;\n  if (timer_handle.Instance != (TIM_TypeDef_conflict *)0x0) {\n    timer_clk_freq = getTimerClkFreq(timer_handle.Instance);\n    timer_handle.Init.Prescaler = timer_clk_freq / clock_frequency - 1;\n    timer_handle.Init.Period = pulse_period - 1;\n    timer_handle.Init.ClockDivision = 0;\n    timer_handle.Init.CounterMode = 0;\n    timer_handle.Init.RepetitionCounter = 0;\n    timer_handle.State = HAL_TIM_STATE_RESET;\n    if (((initialize != '\\x01') ||\n        (g_current_pin = pin, status = HAL_TIM_PWM_Init(&timer_handle), status == HAL_OK)) &&\n       (((timer_clk_freq = get_pwm_channel(pin), timer_clk_freq == 0 ||\n         (((timer_clk_freq == 4 || (timer_clk_freq == 8)) || (timer_clk_freq == 0xc)))) || (timer_clk_freq == 0x18)))) {\n      pwm_config.OCMode = 0x60;\n      pwm_config.OCPolarity = 0;\n      pwm_config.OCFastMode = 0;\n      pwm_config.OCNPolarity = 0;\n      pwm_config.OCNIdleState = 0;\n      pwm_config.OCIdleState = 0;\n      pwm_config.Pulse = pulse_value;\n      status = HAL_TIM_PWM_ConfigChannel(&timer_handle,&pwm_config,timer_clk_freq);\n      if (status == HAL_OK) {\n        pwm_channel = pinmap_function(pin,(PinMap_conflict *)&PinMap_PWM);\n        if ((pwm_channel & 0x100000) == 0) {\n          HAL_TIM_PWM_Start(&timer_handle,timer_clk_freq);\n        }\n        else {\n          HAL_TIMEx_PWMN_Start(&timer_handle,timer_clk_freq);\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007118": "initialize_pwm_08007118",
                "PinName_conflict": "pin",
                "clock_freq": "clock_frequency",
                "period": "pulse_period",
                "value": "pulse_value",
                "do_init": "initialize",
                "HVar1": "status",
                "uVar2": "timer_clk_freq",
                "timChannel": "timer_channel",
                "uVar3": "pwm_channel",
                "timConfig": "pwm_config",
                "timHandle": "timer_handle"
            },
            "calling": [
                "analogWrite"
            ],
            "called": [
                "memset",
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIMEx_PWMN_Start",
                "pinmap_function",
                "get_pwm_channel",
                "HAL_TIM_PWM_Start",
                "pinmap_peripheral",
                "getTimerClkFreq",
                "HAL_TIM_PWM_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080071e4": {
            "entrypoint": "0x080071e4",
            "current_name": "stop_and_de_initialize_pwm_080071e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopAndDeInitializePwm_080071e4(pin pin)\n\n{\n  uint32_t channel;\n  uint32_t timchannel;\n  uint32_t functionResult;\n  TIM_HandleTypeDef_conflict timHandle;\n  \n  timHandle.Instance = (TIM_TypeDef_conflict *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_PWM)\n  ;\n  if ((timHandle.Instance != (TIM_TypeDef_conflict *)0x0) &&\n     ((((channel = get_pwm_channel(pin), channel == 0 || (channel == 4)) || (channel == 8)) ||\n      ((channel == 0xc || (channel == 0x18)))))) {\n    functionResult = pinmap_function(pin,(PinMap_conflict *)&PinMap_PWM);\n    if ((functionResult & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timHandle,channel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timHandle,channel);\n    }\n    HAL_TIM_PWM_DeInit(&timHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080071e4": "stop_and_de_initialize_pwm_080071e4",
                "PinName_conflict": "pin",
                "Channel": "channel",
                "uVar1": "functionResult"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_TIM_PWM_DeInit",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "pinmap_function",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800723c": {
            "entrypoint": "0x0800723c",
            "current_name": "get_system_ticks_0800723c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTicks_0800723c(void)\n\n{\n  uint32_t systemTicks;\n  \n  systemTicks = HAL_GetTick();\n  return systemTicks;\n}\n\n",
            "renaming": {
                "FUN_0800723c": "get_system_ticks_0800723c",
                "uVar1": "systemTicks"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007244": {
            "entrypoint": "0x08007244",
            "current_name": "FUNC_08007244",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08007244(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007244": "FUNC_08007244"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08007246": {
            "entrypoint": "0x08007246",
            "current_name": "handle_sys_tick_interrupt_08007246",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickInterrupt_08007246(void)\n\n{\n  incrementSystemTick();\n  handleSysTick();\n  handleNoOsSysTick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007246": "handle_sys_tick_interrupt_08007246",
                "HAL_IncTick": "incrementSystemTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTick",
                "noOsSystickHandler": "handleNoOsSysTick"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "HAL_IncTick",
                "noOsSystickHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007258": {
            "entrypoint": "0x08007258",
            "current_name": "initialize_pin_08007258",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializePin_08007258(pinName pin,uint32_t pinMode,uint32_t pinPull)\n\n{\n  uint pinValue;\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *gpioPort;\n  uint32_t registerValue2;\n  uint32_t registerValue1;\n  uint32_t registerValue;\n  GPIO_InitTypeDef gpioInitStructure;\n  \n  pinValue = (uint)pin;\n  gpioPort = set_GPIO_Port_Clock((pinValue << 0x18) >> 0x1c);\n  gpioInitStructure.Pin = 1 << (pinValue & 0xf) & 0xffff;\n  gpioInitStructure.Speed = 3;\n  _DAT_40021018 = _DAT_40021018 | 1;\n  if ((pinValue - 0xd & 0xff) < 2) {\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x4000000;\n  }\n  if (((pinValue == 0xf) || (pinValue == 0x13)) || (pinValue == 0x14)) {\n    registerValue1 = _DAT_40010004 & 0xf8ffffff;\n    _DAT_40010004 = registerValue1 | 0x2000000;\n  }\n  gpioInitStructure.Mode = pinMode;\n  gpioInitStructure.Pull = pinPull;\n  HAL_GPIO_Init(gpioPort,&gpioInitStructure);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007258": "initialize_pin_08007258",
                "PinName_conflict": "pinName",
                "mode": "pinMode",
                "pull": "pinPull",
                "uVar1": "pinValue",
                "GPIOx": "gpioPort",
                "port": "gpioPort",
                "tmpreg_2": "registerValue2",
                "tmpreg_1": "registerValue1",
                "tmpreg": "registerValue",
                "GPIO_InitStructure": "gpioInitStructure"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "set_GPIO_Port_Clock",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072d8": {
            "entrypoint": "0x080072d8",
            "current_name": "set_pin_value_080072d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinValue_080072d8(GPIO_TypeDef *gpioPort,uint32_t gpioPin,uint32_t pinValue)\n\n{\n  if (pinValue == 0) {\n    HAL_GPIO_WritePin(gpioPort,(uint16_t)gpioPin,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpioPort,(uint16_t)gpioPin,GPIO_PIN_SET);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072d8": "set_pin_value_080072d8",
                "port": "gpioPort",
                "pin": "gpioPin",
                "val": "pinValue"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072f0": {
            "entrypoint": "0x080072f0",
            "current_name": "read_pin_state_080072f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t readPinState_080072f0(GPIO_TypeDef *gpioPort,uint32_t gpioPin)\n\n{\n  GPIO_PinState pinState;\n  \n  pinState = HAL_GPIO_ReadPin(gpioPort,(uint16_t)gpioPin);\n  return (uint)pinState;\n}\n\n",
            "renaming": {
                "FUN_080072f0": "read_pin_state_080072f0",
                "port": "gpioPort",
                "pin": "gpioPin",
                "GVar1": "pinState"
            },
            "calling": [
                "digitalRead"
            ],
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072fa": {
            "entrypoint": "0x080072fa",
            "current_name": "initialize_system_080072fa",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_080072fa(void)\n\n{\n  initializeHardwareAbstractionLayer();\n  configureSystemClock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072fa": "initialize_system_080072fa",
                "HAL_Init": "initializeHardwareAbstractionLayer",
                "SystemClock_Config": "configureSystemClock"
            },
            "calling": [
                "init"
            ],
            "called": [
                "SystemClock_Config",
                "HAL_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007306": {
            "entrypoint": "0x08007306",
            "current_name": "find_peripheral_by_pin_08007306",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * findPeripheralByPin_08007306(PinName_conflict targetPin,PinMap_conflict *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPin == NoConnection) {\n      return (void *)0x0;\n    }\n    if (pinMap->targetPin == targetPin) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->peripheral;\n}\n\n",
            "renaming": {
                "FUN_08007306": "find_peripheral_by_pin_08007306",
                "pin": "targetPin",
                "map": "pinMap",
                "NC": "NoConnection"
            },
            "calling": [
                "pinmap_peripheral",
                "pinmap_find_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007320": {
            "entrypoint": "0x08007320",
            "current_name": "find_peripheral_by_pin_08007320",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * find_peripheral_by_pin_08007320(pin pin,map *map)\n\n{\n  void *peripheral_found;\n  \n  if (pin != NC) {\n    peripheral_found = pinmap_find_peripheral(pin,map);\n    return peripheral_found;\n  }\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08007320": "find_peripheral_by_pin_08007320",
                "PinName_conflict": "pin",
                "PinMap_conflict": "map",
                "pvVar1": "peripheral_found"
            },
            "calling": [
                "uart_debug_write",
                "uart_init",
                "adc_read_value",
                "uart_debug_init",
                "pwm_stop",
                "pwm_start",
                "i2c_custom_init"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007332": {
            "entrypoint": "0x08007332",
            "current_name": "find_pin_by_peripheral_08007332",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName findPinByPeripheral_08007332(void *targetPeripheral,PinMap *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPeripheral == (void *)0x0) {\n      return NotConnected;\n    }\n    if (pinMap->targetPeripheral == targetPeripheral) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->pin;\n}\n\n",
            "renaming": {
                "FUN_08007332": "find_pin_by_peripheral_08007332",
                "peripheral": "targetPeripheral",
                "map": "pinMap",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap",
                "NC": "NotConnected"
            },
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800734a": {
            "entrypoint": "0x0800734a",
            "current_name": "find_pin_0800734a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict findPin_0800734a(void *peripheral,PinMap_conflict *pinMap)\n\n{\n  PinName_conflict pinName;\n  \n  if (peripheral != (void *)0x0) {\n    pinName = pinpinMap_find_pin(peripheral,pinMap);\n    return pinName;\n  }\n  return NC;\n}\n\n",
            "renaming": {
                "FUN_0800734a": "find_pin_0800734a",
                "map": "pinMap",
                "PVar1": "pinName"
            },
            "calling": [
                "uart_debug_init",
                "HardwareSerial"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800735a": {
            "entrypoint": "0x0800735a",
            "current_name": "find_pin_function_0800735a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t findPinFunction_0800735a(PinName_conflict targetPin,PinMap_conflict *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPin == NotConnected) {\n      return 0xffffffff;\n    }\n    if (pinMap->targetPin == targetPin) exitLoop;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->pinFunction;\n}\n\n",
            "renaming": {
                "FUN_0800735a": "find_pin_function_0800735a",
                "pin": "targetPin",
                "map": "pinMap",
                "NC": "NotConnected",
                "break": "exitLoop",
                "function": "pinFunction"
            },
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007376": {
            "entrypoint": "0x08007376",
            "current_name": "find_pin_function_08007376",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t find_pin_function_08007376(PinName_conflict pin_name,PinMap_conflict *pin_map)\n\n{\n  uint32_t result;\n  \n  if (pin_name == NC) {\n    return 0xffffffff;\n  }\n  result = pin_namepin_map_find_function(pin_name,pin_map);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08007376": "find_pin_function_08007376",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "result"
            },
            "calling": [
                "uart_init",
                "HAL_TIM_PWM_MspInit",
                "get_pwm_channel",
                "pwm_stop",
                "get_adc_channel",
                "pwm_start",
                "i2c_custom_init"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800738a": {
            "entrypoint": "0x0800738a",
            "current_name": "check_pin_map_0800738a",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool checkPinMap_0800738a(PinName currentPin,PinMap *pinMap)\n\n{\n  if (currentPin == NoConnection) {\n    return false;\n  }\n  while( true ) {\n    if (pinMap->currentPin == NoConnection) {\n      return false;\n    }\n    if (currentPin == pinMap->currentPin) break;\n    pinMap = pinMap + 1;\n  }\n  return true;\n}\n\n",
            "renaming": {
                "FUN_0800738a": "check_pin_map_0800738a",
                "pin": "currentPin",
                "map": "pinMap",
                "NC": "NoConnection",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap"
            },
            "calling": [
                "analogWriteCallback",
                "setPinModeCallback",
                "analogWrite",
                "pinMode",
                "enableI2CPins",
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073ae": {
            "entrypoint": "0x080073ae",
            "current_name": "find_non_null_pointer_080073ae",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * find_non_null_pointer_080073ae(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n",
            "renaming": {
                "FUN_080073ae": "find_non_null_pointer_080073ae"
            },
            "calling": [
                "uart_init",
                "i2c_custom_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073c0": {
            "entrypoint": "0x080073c0",
            "current_name": "perform_user_callback_080073c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid performUserCallback_080073c0(RTC_HandleTypeDef *rtcHandle)\n\n{\n  if (userCallback != (voidCallbackPtr)0x0) {\n    (*userCallback)(userData);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080073c0": "perform_user_callback_080073c0",
                "hrtc": "rtcHandle",
                "RTCUserCallback": "userCallback",
                "callbackUserData": "userData"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073d8": {
            "entrypoint": "0x080073d8",
            "current_name": "handle_alarm_irq_080073d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleAlarmIRQ_080073d8(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(&rtcHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080073d8": "handle_alarm_irq_080073d8",
                "&RtcHandle": "&rtcHandle"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073e8": {
            "entrypoint": "0x080073e8",
            "current_name": "infinite_loop_080073e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_080073e8(char *message,int value)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080073e8": "infinite_loop_080073e8",
                "msg": "message",
                "val": "value"
            },
            "calling": [
                "SystemClock_Config",
                "_Error_Handler",
                "onReceiveService"
            ],
            "called": [
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073ec": {
            "entrypoint": "0x080073ec",
            "current_name": "initialize_registers_080073ec",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeRegisters_080073ec(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080073ec": "initialize_registers_080073ec"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007438": {
            "entrypoint": "0x08007438",
            "current_name": "configure_timer_08007438",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nvoid configureTimer_08007438(TIM_HandleTypeDef_conflict *timerHandle)\n\n{\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister1;\n  uint32_t temporaryRegister2;\n  uint32_t temporaryRegister3;\n  \n  if (timerHandle->Instance == (TIM_TypeDef_conflict *)0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 | 0x800;\n    timer_handles[0] = timerHandle;\n  }\n  if (timerHandle->Instance == (TIM_TypeDef_conflict *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c | 1;\n    timer_handles[1] = timerHandle;\n  }\n  if (timerHandle->Instance == (TIM_TypeDef_conflict *)0x40000400) {\n    _DAT_4002101c = _DAT_4002101c | 2;\n    timer_handles[2] = timerHandle;\n  }\n  if (timerHandle->Instance == (TIM_TypeDef_conflict *)0x40000800) {\n    _DAT_4002101c = _DAT_4002101c | 4;\n    timer_handles[3] = timerHandle;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007438": "configure_timer_08007438",
                "htim": "timerHandle",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister1",
                "tmpreg_2": "temporaryRegister2",
                "tmpreg_3": "temporaryRegister3"
            },
            "calling": [
                "HAL_TIM_PWM_MspInit",
                "HAL_TIM_OC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080074e0": {
            "entrypoint": "0x080074e0",
            "current_name": "configure_timer_080074e0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureTimer_080074e0(TIM_HandleTypeDef_conflict *timer)\n\n{\n  if (timer->Instance == (TimerType *)0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 & 0xfffff7ff;\n  }\n  if (timer->Instance == (TimerType *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffe;\n  }\n  if (timer->Instance == (TimerType *)0x40000400) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffd;\n  }\n  if (timer->Instance == (TimerType *)0x40000800) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080074e0": "configure_timer_080074e0",
                "htim": "timer",
                "TIM_TypeDef_conflict": "TimerType"
            },
            "calling": [
                "HAL_TIM_OC_MspDeInit",
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007544": {
            "entrypoint": "0x08007544",
            "current_name": "get_timer_ir_qn_08007544",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTimerIRQn_08007544(TIM_TypeDef *timer)\n\n{\n  if (timer == (TIM_TypeDef *)0xffffffff) {\n    return 0;\n  }\n  if (timer == (TIM_TypeDef *)0x40000400) {\n    return 0x1d;\n  }\n  if (timer < (TIM_TypeDef *)0x40000401) {\n    if (timer == (TIM_TypeDef *)0x40000000) {\n      return 0x1c;\n    }\n  }\n  else {\n    if (timer == (TIM_TypeDef *)0x40000800) {\n      return 0x1e;\n    }\n    if (timer == (TIM_TypeDef *)0x40012c00) {\n      return 0x19;\n    }\n  }\n  printErrorMessage(\"TIM: Unknown timerer IRQn\");\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08007544": "get_timer_ir_qn_08007544",
                "tim": "timer",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "iprintf": "printErrorMessage"
            },
            "calling": [
                "TimerPulseInit",
                "TimerPulseDeinit"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007594": {
            "entrypoint": "0x08007594",
            "current_name": "get_timer_instance_type_08007594",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t getTimerInstanceType_08007594(TimerInstanceType *timerInstance)\n\n{\n  if (timerInstance == (TimerInstanceType *)0xffffffff) {\n    return '\\0';\n  }\n  if (timerInstance == (TimerInstanceType *)0x40000400) {\n    return '\\x01';\n  }\n  if (timerInstance < (TimerInstanceType *)0x40000401) {\n    if (timerInstance == (TimerInstanceType *)0x40000000) {\n      return '\\x01';\n    }\n  }\n  else {\n    if (timerInstance == (TimerInstanceType *)0x40000800) {\n      return '\\x01';\n    }\n    if (timerInstance == (TimerInstanceType *)0x40012c00) {\n      return '\\x02';\n    }\n  }\n  iprintf(\"TIM: Unknown timerInstanceer instance\");\n  return '\\0';\n}\n\n",
            "renaming": {
                "FUN_08007594": "get_timer_instance_type_08007594",
                "tim": "timerInstance",
                "TIM_TypeDef_conflict": "TimerInstanceType"
            },
            "calling": [
                "getTimerClkFreq"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080075dc": {
            "entrypoint": "0x080075dc",
            "current_name": "get_timer_frequency_080075dc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTimerFrequency_080075dc(TIM_TypeDef_conflict *timer)\n\n{\n  uint32_t apb2ClockDivider;\n  uint8_t timerClkSrc;\n  uint32_t timerFrequency;\n  uint32_t apb1ClockDivider;\n  uint32_t flashLatency;\n  RCC_ClkInitTypeDef_conflict clockConfiguration;\n  \n  clockConfiguration.ClockType = 0;\n  clockConfiguration.SYSCLKSource = 0;\n  clockConfiguration.AHBCLKDivider = 0;\n  clockConfiguration.APB1CLKDivider = 0;\n  clockConfiguration.APB2CLKDivider = 0;\n  flashLatency = 0;\n  HAL_RCC_GetClockConfig(&clockConfiguration,&flashLatency);\n  timerClkSrc = getTimerClkSrc(timer);\n  apb2ClockDivider = clockConfiguration.APB2CLKDivider;\n  apb1ClockDivider = clockConfiguration.APB1CLKDivider;\n  if (timerClkSrc == '\\x01') {\n    timerFrequency = HAL_RCC_GetPCLK1Freq();\n  }\n  else if (timerClkSrc == '\\x02') {\n    timerFrequency = HAL_RCC_GetPCLK2Freq();\n    apb1ClockDivider = apb2ClockDivider;\n  }\n  else {\n    iprintf(\"TIM: Unknown clock source\");\n    timerFrequency = 0;\n    apb1ClockDivider = 0;\n  }\n  if (apb1ClockDivider != 0x500) {\n    if (apb1ClockDivider < 0x501) {\n      if (apb1ClockDivider != 0x400) {\n        return timerFrequency;\n      }\n    }\n    else if ((apb1ClockDivider != 0x600) && (apb1ClockDivider != 0x700)) {\n      return timerFrequency;\n    }\n  }\n  return timerFrequency << 1;\n}\n\n",
            "renaming": {
                "FUN_080075dc": "get_timer_frequency_080075dc",
                "tim": "timer",
                "uVar1": "apb2ClockDivider",
                "uVar2": "timerClkSrc",
                "uVar3": "timerFrequency",
                "uVar4": "apb1ClockDivider",
                "pFLatency": "flashLatency",
                "clkconfig": "clockConfiguration"
            },
            "calling": [
                "TimerPulseInit",
                "pwm_start"
            ],
            "called": [
                "getTimerClkSrc",
                "HAL_RCC_GetClockConfig",
                "HAL_RCC_GetPCLK2Freq",
                "iprintf",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007648": {
            "entrypoint": "0x08007648",
            "current_name": "initialize_timer_08007648",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_08007648(stimer_t_conflict *timerConfig,uint16_t timerPeriod,uint16_t timerPulseWidth,\n                 _func_void_stimer_t_ptr_uint32_t_conflict *interruptHandler)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t timerClkFreq;\n  TIM_HandleTypeDef_conflict *timerHandle;\n  TIM_HandleTypeDef_conflict *timerHandleConflicted;\n  TIM_OC_InitTypeDef outputConfig;\n  \n  outputConfig.OCMode = 0;\n  outputConfig.Pulse = 0;\n  outputConfig.OCPolarity = 0;\n  outputConfig.OCNPolarity = 0;\n  outputConfig.OCFastMode = 0;\n  outputConfig.OCIdleState = 0;\n  outputConfig.OCNIdleState = 0;\n  timerHandleConflicted = &timerConfig->timerHandle;\n  timerConfig->timer = (TIM_TypeDef_conflict *)0x40000000;\n  (timerConfig->timerHandle).Instance = (TIM_TypeDef_conflict *)0x40000000;\n  (timerConfig->timerHandle).Init.Period = (uint)timerPeriod;\n  timerClkFreq = getTimerClkFreq((TIM_TypeDef_conflict *)0x40000000);\n  (timerConfig->timerHandle).Init.Prescaler = timerClkFreq / 1000000 - 1;\n  (timerConfig->timerHandle).Init.ClockDivision = 0;\n  (timerConfig->timerHandle).Init.CounterMode = 0;\n  (timerConfig->timerHandle).Init.RepetitionCounter = 0;\n  timerConfig->interruptHandlerOC = interruptHandler;\n  outputConfig.OCMode = 0;\n  outputConfig.OCPolarity = 0;\n  outputConfig.OCFastMode = 0;\n  outputConfig.OCNPolarity = 0;\n  outputConfig.OCIdleState = 0;\n  outputConfig.OCNIdleState = 0;\n  outputConfig.Pulse = (uint)timerPulseWidth;\n  timerClkFreq = getTimerIrq(timerConfig->timer);\n  HAL_NVIC_SetPriority((IRQn_Type_conflict)timerClkFreq,0xe,0);\n  timerClkFreq = getTimerIrq(timerConfig->timer);\n  HAL_NVIC_EnableIRQ((IRQn_Type_conflict)timerClkFreq);\n  status = HAL_TIM_OC_Init(timerHandleConflicted);\n  if ((status == HAL_OK) && (status = HAL_TIM_OC_ConfigChannel(timerHandleConflicted,&outputConfig,0), status == HAL_OK)) {\n    HAL_TIM_OC_Start_IT(timerHandleConflicted,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007648": "initialize_timer_08007648",
                "obj": "timerConfig",
                "period": "timerPeriod",
                "pulseWidth": "timerPulseWidth",
                "irqHandle": "interruptHandler",
                "HVar1": "status",
                "uVar2": "timerClkFreq",
                "handle": "timerHandle",
                "htim": "timerHandleConflicted",
                "sConfig": "outputConfig"
            },
            "calling": [
                "initISR"
            ],
            "called": [
                "HAL_TIM_OC_Start_IT",
                "getTimerIrq",
                "HAL_TIM_OC_ConfigChannel",
                "HAL_TIM_OC_Init",
                "getTimerClkFreq",
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080076e0": {
            "entrypoint": "0x080076e0",
            "current_name": "disable_timer_interrupts_080076e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableTimerInterrupts_080076e0(stimer_t_conflict *obj)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t timerIrq;\n  TIM_HandleTypeDef_conflict *handle;\n  \n  obj->irqHandleOC = (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0;\n  timerIrq = getTimerIrq(obj->timer);\n  HAL_NVIC_DisableIRQ((IRQn_Type_conflict)timerIrq);\n  status = HAL_TIM_OC_DeInit(&obj->handle);\n  if (status == HAL_OK) {\n    HAL_TIM_OC_Stop_IT(&obj->handle,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080076e0": "disable_timer_interrupts_080076e0",
                "HVar1": "status",
                "uVar2": "timerIrq"
            },
            "calling": [
                "finISR"
            ],
            "called": [
                "HAL_TIM_OC_Stop_IT",
                "getTimerIrq",
                "HAL_TIM_OC_DeInit",
                "HAL_NVIC_DisableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007708": {
            "entrypoint": "0x08007708",
            "current_name": "enable_timer_clock_08007708",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enable_timer_clock_08007708(TIM_HandleTypeDef_conflict *timer_handler)\n\n{\n  timer_enable_clock(timer_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007708": "enable_timer_clock_08007708",
                "htim": "timer_handler"
            },
            "calling": [
                "HAL_TIM_OC_Init"
            ],
            "called": [
                "timer_enable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007710": {
            "entrypoint": "0x08007710",
            "current_name": "disable_timer_clock_08007710",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableTimerClock_08007710(TIM_HandleTypeDef_conflict *timerHandle)\n\n{\n  timer_disable_clock(timerHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007710": "disable_timer_clock_08007710",
                "htim": "timerHandle"
            },
            "calling": [
                "HAL_TIM_OC_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007718": {
            "entrypoint": "0x08007718",
            "current_name": "get_conflict_timer_config_08007718",
            "code": "\n/* WARNING: Unknown calling convention */\n\nConflictTimerStruct * getConflictTimerConfig_08007718(TIM_HandleTypeDef_conflict *timerHandle)\n\n{\n  return (ConflictTimerStruct *)&timerHandle[-1].timerLock;\n}\n\n",
            "renaming": {
                "FUN_08007718": "get_conflict_timer_config_08007718",
                "htim": "timerHandle",
                "stimer_t_conflict": "ConflictTimerStruct",
                "Lock": "timerLock"
            },
            "calling": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800771c": {
            "entrypoint": "0x0800771c",
            "current_name": "handle_timer_interrupt_0800771c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_0800771c(TIM_HandleTypeDef_conflict *timerHandle)\n\n{\n  stimer_t_conflict *timerObject;\n  stimer_t_conflict *tempObject;\n  \n  timerObject = get_timer_tempObject(timerHandle);\n  if ((timerObject->irqHandleOC != (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0) &&\n     (timerHandle->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timerObject->irqHandleOC)(timerObject,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800771c": "handle_timer_interrupt_0800771c",
                "htim": "timerHandle",
                "psVar1": "timerObject",
                "obj": "tempObject"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007736": {
            "entrypoint": "0x08007736",
            "current_name": "handle_timer_irq_08007736",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_irq_08007736(TIM_HandleTypeDef_conflict *timer_handle)\n\n{\n  stimer_t_conflict *timer_obj;\n  stimer_t_conflict *timer_object;\n  \n  timer_obj = get_timer_timer_object(timer_handle);\n  if (timer_obj->irqHandle != (_func_void_stimer_t_ptr_conflict *)0x0) {\n    (*timer_obj->irqHandle)(timer_obj);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007736": "handle_timer_irq_08007736",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "obj": "timer_object"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007744": {
            "entrypoint": "0x08007744",
            "current_name": "get_timer_count_08007744",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_timer_count_08007744(stimer_t_conflict *timer_object)\n\n{\n  return ((timer_object->timer_handle).timer_instance)->counter;\n}\n\n",
            "renaming": {
                "FUN_08007744": "get_timer_count_08007744",
                "obj": "timer_object",
                "handle": "timer_handle",
                "Instance": "timer_instance",
                "CNT": "counter"
            },
            "calling": [
                "ServoIrqHandle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800774a": {
            "entrypoint": "0x0800774a",
            "current_name": "set_timer_value_0800774a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setTimerValue_0800774a(stimer_t_conflict *timerObject,uint32_t newValue)\n\n{\n  ((timerObject->handle).Instance)->CNT = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800774a": "set_timer_value_0800774a",
                "obj": "timerObject",
                "value": "newValue"
            },
            "calling": [
                "ServoIrqHandle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007750": {
            "entrypoint": "0x08007750",
            "current_name": "set_timer_channel_value_08007750",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setTimerChannelValue_08007750(stimer_t_conflict *timerObject,uint32_t channelIndex,uint32_t channelValue)\n\n{\n  (&((timerObject->handle).Instance)->CCR1)[channelIndex] = channelValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007750": "set_timer_channel_value_08007750",
                "obj": "timerObject",
                "channel": "channelIndex",
                "value": "channelValue"
            },
            "calling": [
                "ServoIrqHandle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007760": {
            "entrypoint": "0x08007760",
            "current_name": "handle_first_timer_08007760",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleFirstTimer_08007760(void)\n\n{\n  if (timerHandles[0] != (TimerHandleConflict *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[0]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007760": "handle_first_timer_08007760",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef_conflict": "TimerHandleConflict"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007774": {
            "entrypoint": "0x08007774",
            "current_name": "handle_timer_interrupt_08007774",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08007774(void)\n\n{\n  if (timerHandles[1] != (TimerHandleConflict *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[1]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007774": "handle_timer_interrupt_08007774",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef_conflict": "TimerHandleConflict"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007788": {
            "entrypoint": "0x08007788",
            "current_name": "handle_timer_irq_08007788",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerIRQ_08007788(void)\n\n{\n  if (timerHandlers[2] != (TIM_HandleTypeDef_conflict *)0x0) {\n    HAL_TIM_IRQHandler(timerHandlers[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007788": "handle_timer_irq_08007788",
                "timer_handles": "timerHandlers"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800779c": {
            "entrypoint": "0x0800779c",
            "current_name": "handle_timer_interrupt_0800779c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_0800779c(void)\n\n{\n  if (timerHandle3 != (TIM_HandleTypeDef_conflict *)0x0) {\n    HAL_TIM_IRQHandler(timerHandle3);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800779c": "handle_timer_interrupt_0800779c",
                "timer_handles[3]": "timerHandle3"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080077b0": {
            "entrypoint": "0x080077b0",
            "current_name": "initialize_i2_c_080077b0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeI2C_080077b0(i2c_t_conflict *i2cObject,i2c_timing_e_conflict timing,uint32_t addressingMode,\n                 uint32_t ownAddress,uint8_t isMaster)\n\n{\n  void *a;\n  I2C_TypeDef_conflict *i2cSDA;\n  void *b;\n  I2C_TypeDef_conflict *i2cSCL;\n  I2C_TypeDef_conflict *i2cTypeConflict;\n  GPIO_TypeDef *gpioType;\n  GPIO_TypeDef *gpioPort;\n  uint32_t variable3;\n  uint32_t variable4;\n  uint32_t temporaryRegister3;\n  uint32_t temporaryRegister4;\n  uint32_t temporaryRegister5;\n  uint32_t temporaryRegister6;\n  uint32_t temporaryRegister7;\n  uint32_t temporaryRegister8;\n  uint32_t temporaryRegister9;\n  uint32_t temporaryRegister10;\n  uint32_t temporaryRegister11;\n  uint32_t temporaryRegister12;\n  uint32_t temporaryRegister13;\n  uint32_t temporaryRegister14;\n  uint32_t temporaryRegister15;\n  uint32_t temporaryRegister17;\n  uint32_t temporaryRegister18;\n  uint32_t temporaryRegister19;\n  uint32_t temporaryRegister20;\n  uint32_t temporaryRegister21;\n  uint32_t temporaryRegister22;\n  uint32_t temporaryRegister23;\n  uint32_t temporaryRegister24;\n  uint32_t temporaryRegister25;\n  uint32_t temporaryRegister26;\n  uint32_t temporaryRegister27;\n  uint32_t temporaryRegister28;\n  uint32_t temporaryRegister29;\n  I2C_HandleTypeDef_conflict *i2cHandleConflict;\n  I2C_HandleTypeDef_conflict *i2cHandleConflict;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister1;\n  uint32_t temporaryRegister16;\n  uint32_t temporaryRegister2;\n  GPIO_InitTypeDef gpioInitStructure;\n  \n  if (i2cObject != (i2c_t_conflict *)0x0) {\n    i2cHandleConflict = &i2cObject->i2cHandleConflict;\n    a = pinmap_peripheral(i2cObject->sda,(PinMap_conflict *)&PinMap_I2C_SDA);\n    b = pinmap_peripheral(i2cObject->scl,(PinMap_conflict *)&PinMap_I2C_SCL);\n    if ((a == (void *)0x0) || (b == (void *)0x0)) {\n      iprintf(\"ERROR: at least one I2C pin has no peripheral\\n\");\n    }\n    else {\n      i2cTypeConflict = (I2C_TypeDef_conflict *)pinmap_merge_peripheral(a,b);\n      i2cObject->i2c = i2cTypeConflict;\n      if (i2cTypeConflict == (I2C_TypeDef_conflict *)0x0) {\n        iprintf(\"ERROR: I2C pins mismatch\\n\");\n      }\n      else {\n        if (i2cTypeConflict == (I2C_TypeDef_conflict *)0x40005400) {\n          _DAT_4002101c = _DAT_4002101c | 0x200000;\n          _DAT_40021010 = _DAT_40021010 & 0xffdfffff;\n          i2cObject->irq = I2C1_EV_IRQn;\n          i2cObject->irqER = I2C1_ER_IRQn;\n          i2c_i2cHandleConflicts = i2cHandleConflict;\n        }\n        if (i2cObject->i2c == (I2C_TypeDef_conflict *)0x40005800) {\n          _DAT_4002101c = _DAT_4002101c | 0x400000;\n          _DAT_40021010 = _DAT_40021010 & 0xffbfffff;\n          i2cObject->irq = I2C2_EV_IRQn;\n          i2cObject->irqER = I2C2_ER_IRQn;\n          I2C2_ER_IRQHandler::i2cHandleConflict = i2cHandleConflict;\n        }\n        gpioType = set_GPIO_Port_Clock((uint)((int)i2cObject->scl << 0x18) >> 0x1c);\n        gpioPort = (GPIO_TypeDef *)(int)i2cObject->scl;\n        gpioInitStructure.Pin = 1 << ((uint)gpioPort & 0xf) & 0xffff;\n        variable3 = pinmap_function(i2cObject->scl,(PinMap_conflict *)&PinMap_I2C_SCL);\n        variable4 = pinmap_function(i2cObject->scl,(PinMap_conflict *)&PinMap_I2C_SCL);\n        gpioInitStructure.Mode = (variable3 >> 3 & 1) << 4 | variable4 & 7;\n        gpioInitStructure.Speed = 3;\n        variable3 = pinmap_function(i2cObject->scl,(PinMap_conflict *)&PinMap_I2C_SCL);\n        gpioInitStructure.Pull = (variable3 << 0x1a) >> 0x1e;\n        variable3 = pinmap_function(i2cObject->scl,(PinMap_conflict *)&PinMap_I2C_SCL);\n        _DAT_40021018 = _DAT_40021018 | 1;\n        switch((variable3 << 0x11) >> 0x19) {\n        case 1:\n          temporaryRegister26 = temporaryRegister26 | 0x7000001;\n          break;\n        case 2:\n          temporaryRegister26 = temporaryRegister26 & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          temporaryRegister26 = temporaryRegister26 | 0x7000002;\n          break;\n        case 4:\n          temporaryRegister26 = temporaryRegister26 & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          temporaryRegister26 = temporaryRegister26 | 0x7000004;\n          break;\n        case 6:\n          temporaryRegister26 = temporaryRegister26 & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          temporaryRegister26 = temporaryRegister26 | 0x7000008;\n          break;\n        case 8:\n          temporaryRegister26 = temporaryRegister26 & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          temporaryRegister26 = temporaryRegister26 | 0x7000030;\n          break;\n        case 10:\n          temporaryRegister3 = temporaryRegister26 & 0xffffffcf;\n          temporaryRegister26 = temporaryRegister3 | 0x7000010;\n          break;\n        case 0xb:\n          temporaryRegister4 = temporaryRegister26 & 0xffffffcf;\n          temporaryRegister26 = temporaryRegister4 | 0x7000000;\n          break;\n        case 0xc:\n          temporaryRegister26 = temporaryRegister26 | 0x70000c0;\n          break;\n        case 0xd:\n          temporaryRegister5 = temporaryRegister26 & 0xffffff3f;\n          temporaryRegister26 = temporaryRegister5 | 0x7000040;\n          break;\n        case 0xe:\n          temporaryRegister6 = temporaryRegister26 & 0xffffff3f;\n          temporaryRegister26 = temporaryRegister6 | 0x7000000;\n          break;\n        case 0xf:\n          temporaryRegister26 = temporaryRegister26 | 0x7000300;\n          break;\n        case 0x10:\n          temporaryRegister7 = temporaryRegister26 & 0xfffffcff;\n          temporaryRegister26 = temporaryRegister7 | 0x7000200;\n          break;\n        case 0x11:\n          temporaryRegister8 = temporaryRegister26 & 0xfffffcff;\n          temporaryRegister26 = temporaryRegister8 | 0x7000100;\n          break;\n        case 0x12:\n          temporaryRegister9 = temporaryRegister26 & 0xfffffcff;\n          temporaryRegister26 = temporaryRegister9 | 0x7000000;\n          break;\n        case 0x13:\n          temporaryRegister26 = temporaryRegister26 | 0x7000c00;\n          break;\n        case 0x14:\n          temporaryRegister10 = temporaryRegister26 & 0xfffff3ff;\n          temporaryRegister26 = temporaryRegister10 | 0x7000800;\n          break;\n        case 0x15:\n          temporaryRegister11 = temporaryRegister26 & 0xfffff3ff;\n          temporaryRegister26 = temporaryRegister11 | 0x7000000;\n          break;\n        case 0x16:\n          temporaryRegister26 = temporaryRegister26 | 0x7001000;\n          break;\n        case 0x17:\n          temporaryRegister26 = temporaryRegister26 & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          temporaryRegister26 = temporaryRegister26 | 0x7008000;\n          break;\n        case 0x1c:\n          temporaryRegister26 = temporaryRegister26 & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          temporaryRegister12 = temporaryRegister26 & 0xf8ffffff;\n          temporaryRegister26 = temporaryRegister12;\n          break;\n        case 0x22:\n          temporaryRegister13 = temporaryRegister26 & 0xf8ffffff;\n          temporaryRegister26 = temporaryRegister13 | 0x1000000;\n          break;\n        case 0x23:\n          temporaryRegister14 = temporaryRegister26 & 0xf8ffffff;\n          temporaryRegister26 = temporaryRegister14 | 0x2000000;\n          break;\n        case 0x24:\n          temporaryRegister15 = temporaryRegister26 & 0xf8ffffff;\n          temporaryRegister26 = temporaryRegister15 | 0x4000000;\n        }\n        HAL_GPIO_Init(gpioType,&gpioInitStructure);\n        gpioType = set_GPIO_Port_Clock((uint)((int)i2cObject->sda << 0x18) >> 0x1c);\n        gpioInitStructure.Pin = 1 << ((int)i2cObject->sda & 0xfU) & 0xffff;\n        variable3 = pinmap_function(i2cObject->sda,(PinMap_conflict *)&PinMap_I2C_SDA);\n        variable4 = pinmap_function(i2cObject->sda,(PinMap_conflict *)&PinMap_I2C_SDA);\n        gpioInitStructure.Mode = (variable3 >> 3 & 1) << 4 | variable4 & 7;\n        gpioInitStructure.Speed = 3;\n        variable3 = pinmap_function(i2cObject->sda,(PinMap_conflict *)&PinMap_I2C_SDA);\n        gpioInitStructure.Pull = (variable3 << 0x1a) >> 0x1e;\n        variable3 = pinmap_function(i2cObject->sda,(PinMap_conflict *)&PinMap_I2C_SDA);\n        _DAT_40021018 = _DAT_40021018 | 1;\n        switch((variable3 << 0x11) >> 0x19) {\n        case 1:\n          temporaryRegister26 = temporaryRegister26 | 0x7000001;\n          break;\n        case 2:\n          temporaryRegister26 = temporaryRegister26 & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          temporaryRegister26 = temporaryRegister26 | 0x7000002;\n          break;\n        case 4:\n          temporaryRegister26 = temporaryRegister26 & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          temporaryRegister26 = temporaryRegister26 | 0x7000004;\n          break;\n        case 6:\n          temporaryRegister26 = temporaryRegister26 & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          temporaryRegister26 = temporaryRegister26 | 0x7000008;\n          break;\n        case 8:\n          temporaryRegister26 = temporaryRegister26 & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          temporaryRegister26 = temporaryRegister26 | 0x7000030;\n          break;\n        case 10:\n          temporaryRegister17 = temporaryRegister26 & 0xffffffcf;\n          temporaryRegister26 = temporaryRegister17 | 0x7000010;\n          break;\n        case 0xb:\n          temporaryRegister18 = temporaryRegister26 & 0xffffffcf;\n          temporaryRegister26 = temporaryRegister18 | 0x7000000;\n          break;\n        case 0xc:\n          temporaryRegister26 = temporaryRegister26 | 0x70000c0;\n          break;\n        case 0xd:\n          temporaryRegister19 = temporaryRegister26 & 0xffffff3f;\n          temporaryRegister26 = temporaryRegister19 | 0x7000040;\n          break;\n        case 0xe:\n          temporaryRegister20 = temporaryRegister26 & 0xffffff3f;\n          temporaryRegister26 = temporaryRegister20 | 0x7000000;\n          break;\n        case 0xf:\n          temporaryRegister26 = temporaryRegister26 | 0x7000300;\n          break;\n        case 0x10:\n          temporaryRegister21 = temporaryRegister26 & 0xfffffcff;\n          temporaryRegister26 = temporaryRegister21 | 0x7000200;\n          break;\n        case 0x11:\n          temporaryRegister22 = temporaryRegister26 & 0xfffffcff;\n          temporaryRegister26 = temporaryRegister22 | 0x7000100;\n          break;\n        case 0x12:\n          temporaryRegister23 = temporaryRegister26 & 0xfffffcff;\n          temporaryRegister26 = temporaryRegister23 | 0x7000000;\n          break;\n        case 0x13:\n          temporaryRegister26 = temporaryRegister26 | 0x7000c00;\n          break;\n        case 0x14:\n          temporaryRegister24 = temporaryRegister26 & 0xfffff3ff;\n          temporaryRegister26 = temporaryRegister24 | 0x7000800;\n          break;\n        case 0x15:\n          temporaryRegister25 = temporaryRegister26 & 0xfffff3ff;\n          temporaryRegister26 = temporaryRegister25 | 0x7000000;\n          break;\n        case 0x16:\n          temporaryRegister26 = temporaryRegister26 | 0x7001000;\n          break;\n        case 0x17:\n          temporaryRegister26 = temporaryRegister26 & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          temporaryRegister26 = temporaryRegister26 | 0x7008000;\n          break;\n        case 0x1c:\n          temporaryRegister26 = temporaryRegister26 & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          temporaryRegister26 = temporaryRegister26 & 0xf8ffffff;\n          break;\n        case 0x22:\n          temporaryRegister27 = temporaryRegister26 & 0xf8ffffff;\n          temporaryRegister26 = temporaryRegister27 | 0x1000000;\n          break;\n        case 0x23:\n          temporaryRegister28 = temporaryRegister26 & 0xf8ffffff;\n          temporaryRegister26 = temporaryRegister28 | 0x2000000;\n          break;\n        case 0x24:\n          temporaryRegister29 = temporaryRegister26 & 0xf8ffffff;\n          temporaryRegister26 = temporaryRegister29 | 0x4000000;\n        }\n        HAL_GPIO_Init(gpioType,&gpioInitStructure);\n        (i2cObject->i2cHandleConflict).Instance = i2cObject->i2c;\n        (i2cObject->i2cHandleConflict).Init.ClockSpeed = timing;\n        (i2cObject->i2cHandleConflict).Init.DutyCycle = 0;\n        (i2cObject->i2cHandleConflict).Init.OwnAddress1 = ownAddress;\n        (i2cObject->i2cHandleConflict).Init.OwnAddress2 = 0xff;\n        (i2cObject->i2cHandleConflict).Init.AddressingMode = addressingMode;\n        (i2cObject->i2cHandleConflict).Init.DualAddressMode = 0;\n        (i2cObject->i2cHandleConflict).Init.GeneralCallMode = 0;\n        (i2cObject->i2cHandleConflict).Init.NoStretchMode = 0;\n        (i2cObject->i2cHandleConflict).State = HAL_I2C_STATE_RESET;\n        HAL_NVIC_SetPriority(i2cObject->irq,0,1);\n        HAL_NVIC_EnableIRQ(i2cObject->irq);\n        HAL_NVIC_SetPriority(i2cObject->irqER,0,1);\n        HAL_NVIC_EnableIRQ(i2cObject->irqER);\n        HAL_I2C_Init(i2cHandleConflict);\n        i2cObject->isMaster = isMaster;\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080077b0": "initialize_i2_c_080077b0",
                "obj": "i2cObject",
                "master": "isMaster",
                "i2c_sda": "i2cSDA",
                "i2c_scl": "i2cSCL",
                "pIVar1": "i2cTypeConflict",
                "pGVar2": "gpioType",
                "port": "gpioPort",
                "uVar3": "variable3",
                "uVar4": "variable4",
                "tmpreg_3": "temporaryRegister3",
                "tmpreg_4": "temporaryRegister4",
                "tmpreg_5": "temporaryRegister5",
                "tmpreg_6": "temporaryRegister6",
                "tmpreg_7": "temporaryRegister7",
                "tmpreg_8": "temporaryRegister8",
                "tmpreg_9": "temporaryRegister9",
                "tmpreg_10": "temporaryRegister10",
                "tmpreg_11": "temporaryRegister11",
                "tmpreg_12": "temporaryRegister12",
                "tmpreg_13": "temporaryRegister13",
                "tmpreg_14": "temporaryRegister14",
                "tmpreg_15": "temporaryRegister15",
                "tmpreg_16": "temporaryRegister16",
                "tmpreg_17": "temporaryRegister17",
                "tmpreg_18": "temporaryRegister18",
                "tmpreg_19": "temporaryRegister19",
                "tmpreg_20": "temporaryRegister20",
                "tmpreg_21": "temporaryRegister21",
                "tmpreg_22": "temporaryRegister22",
                "tmpreg_23": "temporaryRegister23",
                "tmpreg_24": "temporaryRegister24",
                "tmpreg_25": "temporaryRegister25",
                "tmpreg_26": "temporaryRegister26",
                "tmpreg_27": "temporaryRegister27",
                "tmpreg_28": "temporaryRegister28",
                "tmpreg_29": "temporaryRegister29",
                "hi2c": "i2cHandleConflict",
                "handle": "i2cHandleConflict",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister1",
                "tmpreg_2": "temporaryRegister2",
                "GPIO_InitStruct": "gpioInitStructure"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "set_GPIO_Port_Clock",
                "pinmap_function",
                "pinmap_peripheral",
                "pinmap_merge_peripheral",
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority",
                "HAL_GPIO_Init",
                "iprintf",
                "HAL_I2C_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007e74": {
            "entrypoint": "0x08007e74",
            "current_name": "transmit_data_to_i2_c_device_08007e74",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_status_e_conflict\ntransmitDataToI2CDevice_08007e74(i2c_t_conflict *i2cObject,uint8_t deviceAddress,uint8_t *dataArray,uint16_t dataSize)\n\n{\n  HAL_I2C_StateTypeDef_conflict i2cState;\n  HAL_StatusTypeDef_conflict halStatus;\n  uint32_t currentTick;\n  uint32_t startTick;\n  uint32_t elapsedTick;\n  uint elapsedTime;\n  i2c_status_e_conflict transmissionStatus;\n  I2C_HandleTypeDef_conflict *i2cHandle;\n  \n  currentTick = HAL_GetTick();\n  elapsedTime = 0;\n  transmissionStatus = I2C_ERROR;\n  do {\n    i2cHandle = &i2cObject->handle;\n    halStatus = HAL_I2C_Master_Transmit_IT(i2cHandle,(ushort)deviceAddress,dataArray,dataSize);\n    if (halStatus == HAL_OK) {\n      transmissionStatus = I2C_OK;\n      while ((i2cState = HAL_I2C_GetState(i2cHandle), i2cState != HAL_I2C_STATE_READY && (transmissionStatus == I2C_OK))) {\n        elapsedTick = HAL_GetTick();\n        elapsedTime = elapsedTick - currentTick;\n        if (elapsedTime < 0x65) {\n          elapsedTick = HAL_I2C_GetError(i2cHandle);\n          if (elapsedTick != 0) {\n            transmissionStatus = I2C_ERROR;\n          }\n        }\n        else {\n          transmissionStatus = I2C_TIMEOUT;\n        }\n      }\n    }\n    elapsedTick = HAL_I2C_GetError(i2cHandle);\n  } while ((elapsedTick == 4) && (elapsedTime < 100));\n  return transmissionStatus;\n}\n\n",
            "renaming": {
                "FUN_08007e74": "transmit_data_to_i2_c_device_08007e74",
                "obj": "i2cObject",
                "dev_address": "deviceAddress",
                "data": "dataArray",
                "size": "dataSize",
                "HVar1": "i2cState",
                "HVar2": "halStatus",
                "uVar3": "currentTick",
                "tickstart": "startTick",
                "uVar4": "elapsedTick",
                "uVar5": "elapsedTime",
                "iVar6": "transmissionStatus",
                "hi2c": "i2cHandle"
            },
            "calling": [
                "endTransmission"
            ],
            "called": [
                "HAL_I2C_GetError",
                "HAL_I2C_GetState",
                "HAL_I2C_Master_Transmit_IT",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007ede": {
            "entrypoint": "0x08007ede",
            "current_name": "copy_data_to_i2c_buffer_08007ede",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_status_e_conflict copy_data_to_i2c_buffer_08007ede(i2c_t_conflict *i2c_object,uint8_t *source_data,uint16_t data_size)\n\n{\n  uint index;\n  \n  if (0x20 < data_size) {\n    return I2C_ERROR;\n  }\n  for (index = 0; index < data_size; index = index + 1 & 0xff) {\n    i2c_object->i2cTxRxBuffer[index] = source_data[index];\n    i2c_object->i2cTxRxBufferSize = i2c_object->i2cTxRxBufferSize + '\\x01';\n  }\n  return I2C_OK;\n}\n\n",
            "renaming": {
                "FUN_08007ede": "copy_data_to_i2c_buffer_08007ede",
                "obj": "i2c_object",
                "data": "source_data",
                "size": "data_size",
                "uVar1": "index"
            },
            "calling": [
                "write",
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007f0e": {
            "entrypoint": "0x08007f0e",
            "current_name": "receive_i2_c_data_08007f0e",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_status_e_conflict\nreceiveI2CData_08007f0e(i2c_t_conflict *i2cObject,uint8_t deviceAddress,uint8_t *dataBuffer,uint16_t dataSize)\n\n{\n  HAL_I2C_StateTypeDef_conflict i2cState;\n  HAL_StatusTypeDef_conflict halStatus;\n  uint32_t startTicks;\n  uint32_t currentTicks;\n  uint32_t elapsedTicks;\n  uint timeoutTicks;\n  i2c_status_e_conflict i2cStatus;\n  I2C_HandleTypeDef_conflict *i2cHandle;\n  \n  startTicks = HAL_GetTick();\n  timeoutTicks = 0;\n  i2cStatus = I2C_ERROR;\n  do {\n    i2cHandle = &i2cObject->handle;\n    halStatus = HAL_I2C_Master_Receive_IT(i2cHandle,(ushort)deviceAddress,dataBuffer,dataSize);\n    if (halStatus == HAL_OK) {\n      i2cStatus = I2C_OK;\n      while ((i2cState = HAL_I2C_GetState(i2cHandle), i2cState != HAL_I2C_STATE_READY && (i2cStatus == I2C_OK))) {\n        elapsedTicks = HAL_GetTick();\n        timeoutTicks = elapsedTicks - startTicks;\n        if (timeoutTicks < 0x65) {\n          elapsedTicks = HAL_I2C_GetError(i2cHandle);\n          if (elapsedTicks != 0) {\n            i2cStatus = I2C_ERROR;\n          }\n        }\n        else {\n          i2cStatus = I2C_TIMEOUT;\n        }\n      }\n    }\n    elapsedTicks = HAL_I2C_GetError(i2cHandle);\n  } while ((elapsedTicks == 4) && (timeoutTicks < 100));\n  return i2cStatus;\n}\n\n",
            "renaming": {
                "FUN_08007f0e": "receive_i2_c_data_08007f0e",
                "obj": "i2cObject",
                "dev_address": "deviceAddress",
                "data": "dataBuffer",
                "size": "dataSize",
                "HVar1": "i2cState",
                "HVar2": "halStatus",
                "uVar3": "startTicks",
                "tickstart": "currentTicks",
                "uVar4": "elapsedTicks",
                "uVar5": "timeoutTicks",
                "iVar6": "i2cStatus",
                "hi2c": "i2cHandle"
            },
            "calling": [
                "requestFrom"
            ],
            "called": [
                "HAL_I2C_GetError",
                "HAL_I2C_GetState",
                "HAL_GetTick",
                "HAL_I2C_Master_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007f78": {
            "entrypoint": "0x08007f78",
            "current_name": "get_i2c_t_conflict_pointer_08007f78",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_t * get_i2c_t_conflict_pointer_08007f78(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  return (i2c_t *)&i2c_handle[-1].event_count;\n}\n\n",
            "renaming": {
                "FUN_08007f78": "get_i2c_t_conflict_pointer_08007f78",
                "hi2c": "i2c_handle",
                "i2c_t_conflict": "i2c_t",
                "EventCount": "event_count"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007f7c": {
            "entrypoint": "0x08007f7c",
            "current_name": "set_slave_receive_function_08007f7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setSlaveReceiveFunction_08007f7c(i2c_t_conflict *i2cObject,_func_void_uint8_t_ptr_int *receiveFunction)\n\n{\n  if (i2cObject != (i2c_t_conflict *)0x0) {\n    if (receiveFunction != (_func_void_uint8_t_ptr_int *)0x0) {\n      i2cObject->slaveReceiveCallback = receiveFunction;\n      enableListenInterrupt(&i2cObject->handle);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007f7c": "set_slave_receive_function_08007f7c",
                "obj": "i2cObject",
                "function": "receiveFunction",
                "i2c_onSlaveReceive": "slaveReceiveCallback",
                "HAL_I2C_EnableListen_IT": "enableListenInterrupt"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007f8e": {
            "entrypoint": "0x08007f8e",
            "current_name": "set_i2_c_on_slave_transmit_handler_08007f8e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setI2COnSlaveTransmitHandler_08007f8e(i2c_t_conflict *i2cObject,_func_void *onSlaveTransmitHandler)\n\n{\n  if (i2cObject != (i2c_t_conflict *)0x0) {\n    if (onSlaveTransmitHandler != (_func_void *)0x0) {\n      i2cObject->setOnSlaveTransmit = onSlaveTransmitHandler;\n      enableI2CListenInterrupt(&i2cObject->handle);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007f8e": "set_i2_c_on_slave_transmit_handler_08007f8e",
                "obj": "i2cObject",
                "function": "onSlaveTransmitHandler",
                "i2c_onSlaveTransmit": "setOnSlaveTransmit",
                "HAL_I2C_EnableListen_IT": "enableI2CListenInterrupt"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007fa0": {
            "entrypoint": "0x08007fa0",
            "current_name": "handle_transfer_08007fa0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTransfer_08007fa0(I2C_HandleTypeDef_conflict *i2cHandle,uint8_t direction,uint16_t addressCode)\n\n{\n  i2c_t_conflict *i2cObj;\n  i2c_t_conflict *i2cObj2;\n  \n  i2cObj = get_i2c_i2cObj2(i2cHandle);\n  if ((uint)addressCode == (i2cHandle->Init).OwnAddress1) {\n    if (direction == '\\0') {\n      i2cObj->i2cTxRxBufferSize = '\\0';\n      i2cObj->slaveMode = '\\0';\n      if (i2cObj->i2c_onSlaveTransmit != (_func_void *)0x0) {\n        (*i2cObj->i2c_onSlaveTransmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT\n                (i2cHandle,i2cObj->i2cTxRxBuffer,(ushort)i2cObj->i2cTxRxBufferSize,8);\n      return;\n    }\n    i2cObj->slaveMode = '\\x01';\n    HAL_I2C_Slave_Sequential_Receive_IT(i2cHandle,i2cObj->i2cTxRxBuffer,0x20,8);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007fa0": "handle_transfer_08007fa0",
                "hi2c": "i2cHandle",
                "TransferDirection": "direction",
                "AddrMatchCode": "addressCode",
                "piVar1": "i2cObj",
                "obj": "i2cObj2"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "HAL_I2C_Slave_Sequential_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007ff0": {
            "entrypoint": "0x08007ff0",
            "current_name": "enable_listen_mode_08007ff0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableListenMode_08007ff0(I2CHandle *i2cHandle)\n\n{\n  I2CT *i2cObj;\n  I2CT *i2cObj2;\n  uint bufferLength;\n  \n  i2cObj = get_i2c_i2cObj2(i2cHandle);\n  if (((i2cObj->i2c_onSlaveReceive != (_func_void_uint8_t_ptr_int *)0x0) &&\n      (i2cObj->slaveMode == '\\x01')) &&\n     (bufferLength = 0x20 - *(byte *)&(i2cObj->handle).XferSize & 0xff, bufferLength != 0)) {\n    (*i2cObj->i2c_onSlaveReceive)(i2cObj->i2cTxRxBuffer,bufferLength);\n  }\n  HAL_I2C_EnableListen_IT(i2cHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007ff0": "enable_listen_mode_08007ff0",
                "hi2c": "i2cHandle",
                "I2C_HandleTypeDef_conflict": "I2CHandle",
                "i2c_t_conflict": "I2CT",
                "piVar1": "i2cObj",
                "obj": "i2cObj2",
                "uVar2": "bufferLength"
            },
            "calling": [
                "I2C_ITError",
                "I2C_Slave_AF",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008020": {
            "entrypoint": "0x08008020",
            "current_name": "enable_i2_c_listen_it_08008020",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableI2CListenIT_08008020(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  i2c_t_conflict *i2cObj;\n  i2c_t_conflict *i2cObj;\n  \n  i2cObj = get_i2c_i2cObj(i2cHandle);\n  if (i2cObj->isMaster == '\\0') {\n    enableI2CListen(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008020": "enable_i2_c_listen_it_08008020",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObj",
                "obj": "i2cObj",
                "HAL_I2C_EnableListen_IT": "enableI2CListen"
            },
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008038": {
            "entrypoint": "0x08008038",
            "current_name": "handle_i2c_event_interrupt_08008038",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2cEventInterrupt_08008038(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c_handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008038": "handle_i2c_event_interrupt_08008038"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008048": {
            "entrypoint": "0x08008048",
            "current_name": "handle_i2_c_error_interrupt_08008048",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CErrorInterrupt_08008048(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c_handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008048": "handle_i2_c_error_interrupt_08008048"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008058": {
            "entrypoint": "0x08008058",
            "current_name": "handle_i2_c2_events_08008058",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2C2Events_08008058(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c2EventHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008058": "handle_i2_c2_events_08008058",
                "I2C2_ER_IRQHandler::handle": "i2c2EventHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008068": {
            "entrypoint": "0x08008068",
            "current_name": "handle_i2_c_er_08008068",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_I2C_ER_08008068(void)\n\n{\n  HAL_I2C_ER_IRQHandler(I2C_ErrorHandler::handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008068": "handle_i2_c_er_08008068",
                "I2C2_ER_IRQHandler": "I2C_ErrorHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008078": {
            "entrypoint": "0x08008078",
            "current_name": "initialize_uart_08008078",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeUART_08008078(serial_t *serialObject)\n\n{\n  void *a;\n  USART_TypeDef *uartTX;\n  void *b;\n  USART_TypeDef *uartRX;\n  USART_TypeDef *mergedPeripheral;\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *gpioPort;\n  uint32_t pinFunction;\n  uint32_t tmpreg4;\n  uint32_t tmpreg5;\n  uint32_t tmpreg6;\n  uint32_t tmpreg7;\n  uint32_t tmpreg8;\n  uint32_t tmpreg9;\n  uint32_t tmpreg10;\n  uint32_t tmpreg11;\n  uint32_t tmpreg12;\n  uint32_t tmpreg13;\n  uint32_t tmpreg14;\n  uint32_t tmpreg15;\n  uint32_t tmpreg16;\n  UART_HandleTypeDef *uartHandle;\n  uint32_t tmpreg;\n  uint32_t tmpreg1;\n  uint32_t tmpreg2;\n  uint32_t tmpreg3;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  if (serialObject != (serial_t *)0x0) {\n    a = pinmap_peripheral(serialObject->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n    b = pinmap_peripheral(serialObject->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      mergedPeripheral = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      serialObject->uart = mergedPeripheral;\n      if (mergedPeripheral == (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (mergedPeripheral == (USART_TypeDef *)0x40013800) {\n          _DAT_4002100c = _DAT_4002100c & 0xffffbfff;\n          _DAT_40021018 = _DAT_40021018 | 0x4000;\n          serialObject->index = '\\0';\n          serialObject->irq = USART1_IRQn;\n        }\n        else if (mergedPeripheral == (USART_TypeDef *)0x40004400) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffdffff;\n          _DAT_4002101c = _DAT_4002101c | 0x20000;\n          serialObject->index = '\\x01';\n          serialObject->irq = USART2_IRQn;\n        }\n        else if (mergedPeripheral == (USART_TypeDef *)0x40004800) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffbffff;\n          _DAT_4002101c = _DAT_4002101c | 0x40000;\n          serialObject->index = '\\x02';\n          serialObject->irq = USART3_IRQn;\n        }\n        gpioPort = set_GPIO_Port_Clock((uint)((int)serialObject->pin_rx << 0x18) >> 0x1c);\n        pinFunction = pinmap_function(serialObject->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n        gpioInitStruct.Pin = 1 << (serialObject->pin_rx & 0xfU) & 0xffff;\n        gpioInitStruct.Mode = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioInitStruct.Pull = (pinFunction << 0x1a) >> 0x1e;\n        _DAT_40021018 = _DAT_40021018 | 1;\n        switch((pinFunction << 0x11) >> 0x19) {\n        case 1:\n          tmpreg13 = tmpreg13 | 0x7000001;\n          break;\n        case 2:\n          tmpreg13 = tmpreg13 & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          tmpreg13 = tmpreg13 | 0x7000002;\n          break;\n        case 4:\n          tmpreg13 = tmpreg13 & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          tmpreg13 = tmpreg13 | 0x7000004;\n          break;\n        case 6:\n          tmpreg13 = tmpreg13 & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          tmpreg13 = tmpreg13 | 0x7000008;\n          break;\n        case 8:\n          tmpreg13 = tmpreg13 & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          tmpreg13 = tmpreg13 | 0x7000030;\n          break;\n        case 10:\n          tmpreg4 = tmpreg13 & 0xffffffcf;\n          tmpreg13 = tmpreg4 | 0x7000010;\n          break;\n        case 0xb:\n          tmpreg5 = tmpreg13 & 0xffffffcf;\n          tmpreg13 = tmpreg5 | 0x7000000;\n          break;\n        case 0xc:\n          tmpreg13 = tmpreg13 | 0x70000c0;\n          break;\n        case 0xd:\n          tmpreg6 = tmpreg13 & 0xffffff3f;\n          tmpreg13 = tmpreg6 | 0x7000040;\n          break;\n        case 0xe:\n          tmpreg7 = tmpreg13 & 0xffffff3f;\n          tmpreg13 = tmpreg7 | 0x7000000;\n          break;\n        case 0xf:\n          tmpreg13 = tmpreg13 | 0x7000300;\n          break;\n        case 0x10:\n          tmpreg8 = tmpreg13 & 0xfffffcff;\n          tmpreg13 = tmpreg8 | 0x7000200;\n          break;\n        case 0x11:\n          tmpreg9 = tmpreg13 & 0xfffffcff;\n          tmpreg13 = tmpreg9 | 0x7000100;\n          break;\n        case 0x12:\n          tmpreg10 = tmpreg13 & 0xfffffcff;\n          tmpreg13 = tmpreg10 | 0x7000000;\n          break;\n        case 0x13:\n          tmpreg13 = tmpreg13 | 0x7000c00;\n          break;\n        case 0x14:\n          tmpreg11 = tmpreg13 & 0xfffff3ff;\n          tmpreg13 = tmpreg11 | 0x7000800;\n          break;\n        case 0x15:\n          tmpreg12 = tmpreg13 & 0xfffff3ff;\n          tmpreg13 = tmpreg12 | 0x7000000;\n          break;\n        case 0x16:\n          tmpreg13 = tmpreg13 | 0x7001000;\n          break;\n        case 0x17:\n          tmpreg13 = tmpreg13 & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          tmpreg13 = tmpreg13 | 0x7008000;\n          break;\n        case 0x1c:\n          tmpreg13 = tmpreg13 & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          tmpreg13 = tmpreg13 & 0xf8ffffff;\n          break;\n        case 0x22:\n          tmpreg14 = tmpreg13 & 0xf8ffffff;\n          tmpreg13 = tmpreg14 | 0x1000000;\n          break;\n        case 0x23:\n          tmpreg15 = tmpreg13 & 0xf8ffffff;\n          tmpreg13 = tmpreg15 | 0x2000000;\n          break;\n        case 0x24:\n          tmpreg16 = tmpreg13 & 0xf8ffffff;\n          tmpreg13 = tmpreg16 | 0x4000000;\n        }\n        gpioInitStruct.Speed = 3;\n        HAL_GPIO_Init(gpioPort,&gpioInitStruct);\n        gpioPort = set_GPIO_Port_Clock((uint)((int)serialObject->pin_tx << 0x18) >> 0x1c);\n        pinFunction = pinmap_function(serialObject->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n        gpioInitStruct.Pin = 1 << (serialObject->pin_tx & 0xfU) & 0xffff;\n        gpioInitStruct.Mode = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioInitStruct.Pull = (pinFunction << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(gpioPort,&gpioInitStruct);\n        uart_handlers[serialObject->index] = &serialObject->handle;\n        (serialObject->handle).Instance = serialObject->uart;\n        (serialObject->handle).Init.BaudRate = serialObject->baudrate;\n        (serialObject->handle).Init.WordLength = serialObject->databits;\n        (serialObject->handle).Init.StopBits = serialObject->stopbits;\n        (serialObject->handle).Init.Parity = serialObject->parity;\n        (serialObject->handle).Init.Mode = 0xc;\n        (serialObject->handle).Init.HwFlowCtl = 0;\n        (serialObject->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&serialObject->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008078": "initialize_uart_08008078",
                "obj": "serialObject",
                "uart_tx": "uartTX",
                "uart_rx": "uartRX",
                "pUVar1": "mergedPeripheral",
                "pGVar2": "gpioPort",
                "port": "gpioPort",
                "uVar3": "pinFunction",
                "tmpreg_4": "tmpreg4",
                "tmpreg_5": "tmpreg5",
                "tmpreg_6": "tmpreg6",
                "tmpreg_7": "tmpreg7",
                "tmpreg_8": "tmpreg8",
                "tmpreg_9": "tmpreg9",
                "tmpreg_10": "tmpreg10",
                "tmpreg_11": "tmpreg11",
                "tmpreg_12": "tmpreg12",
                "tmpreg_13": "tmpreg13",
                "tmpreg_14": "tmpreg14",
                "tmpreg_15": "tmpreg15",
                "tmpreg_16": "tmpreg16",
                "huart": "uartHandle",
                "tmpreg_1": "tmpreg1",
                "tmpreg_2": "tmpreg2",
                "tmpreg_3": "tmpreg3",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "uart_debug_init",
                "begin"
            ],
            "called": [
                "set_GPIO_Port_Clock",
                "pinmap_function",
                "HAL_UART_Init",
                "pinmap_peripheral",
                "pinmap_merge_peripheral",
                "HAL_GPIO_Init",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080084b0": {
            "entrypoint": "0x080084b0",
            "current_name": "initialize_debug_serial_080084b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeDebugSerial_080084b0(void)\n\n{\n  void *peripheral;\n  \n  peripheral = pinmap_peripheral(PA_2,(ConflictPinMap *)&PinMap_UART_TX);\n  if (peripheral != (void *)0x0) {\n    peripheral = pinmap_peripheral(PA_2,(ConflictPinMap *)&PinMap_UART_TX);\n    debugSerial.rxPin = pinmap_pin(peripheral,(ConflictPinMap *)&PinMap_UART_RX);\n    debugSerial.txPin = PA_2;\n    debugSerial.baudRate = 0x2580;\n    debugSerial.parity = 0;\n    debugSerial.dataBits = 0;\n    debugSerial.stopBits = 0;\n    initializeUART(&debugSerial);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080084b0": "initialize_debug_serial_080084b0",
                "pvVar1": "peripheral",
                "PinMap_conflict": "ConflictPinMap",
                "serial_debug": "debugSerial",
                "pin_rx": "rxPin",
                "pin_tx": "txPin",
                "baudrate": "baudRate",
                "databits": "dataBits",
                "stopbits": "stopBits",
                "uart_init": "initializeUART"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "uart_init",
                "pinmap_pin",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008500": {
            "entrypoint": "0x08008500",
            "current_name": "transmit_data_08008500",
            "code": "\n/* WARNING: Unknown calling convention */\n\ndataSize_t transmitData_08008500(uint8_t *dataBuffer,uint32_t dataSize)\n\n{\n  HAL_StatusTypeDef_conflict transmitStatus;\n  uint32_t startTime;\n  uint32_t tickstart;\n  void *peripheral;\n  USART_TypeDef *peripheralInstance;\n  uint32_t currentTime;\n  uint handlerIndex;\n  \n  startTime = HAL_GetTick();\n  peripheral = pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX);\n  if (peripheral == (void *)0x0) {\n    return 0;\n  }\n  handlerIndex = 0;\n  while ((handlerIndex < 5 &&\n         ((uart_handlers[handlerIndex] == (UART_HandleTypeDef *)0x0 ||\n          (peripheralInstance = (USART_TypeDef *)pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX),\n          uart_handlers[handlerIndex]->Instance != peripheralInstance))))) {\n    handlerIndex = handlerIndex + 1 & 0xff;\n  }\n  if (4 < handlerIndex) {\n    if ((4 < serial_debug.index) && (uart_debug_init(), 4 < serial_debug.index)) {\n      return 0;\n    }\n    handlerIndex = (uint)serial_debug.index;\n  }\n  do {\n    transmitStatus = HAL_UART_Transmit(uart_handlers[handlerIndex],dataBuffer,(uint16_t)dataSize,1000);\n    if (transmitStatus == HAL_OK) {\n      return dataSize;\n    }\n    currentTime = HAL_GetTick();\n  } while (currentTime - startTime < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008500": "transmit_data_08008500",
                "data": "dataBuffer",
                "size": "dataSize",
                "HVar1": "transmitStatus",
                "uVar2": "startTime",
                "pvVar3": "peripheral",
                "pUVar4": "peripheralInstance",
                "uVar5": "currentTime",
                "uVar6": "handlerIndex"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "HAL_UART_Transmit",
                "uart_debug_init",
                "pinmap_peripheral",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080085b8": {
            "entrypoint": "0x080085b8",
            "current_name": "check_uart_state_080085b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_080085b8(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(handlers[serial_object->index]);\n  return (uart_state & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_080085b8": "check_uart_state_080085b8",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "uart_handlers": "handlers"
            },
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080085dc": {
            "entrypoint": "0x080085dc",
            "current_name": "check_uart_state_080085dc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_080085dc(serial_t *object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(handlers[object->index]);\n  return (uart_state & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_080085dc": "check_uart_state_080085dc",
                "obj": "object",
                "HVar1": "uart_state",
                "uart_handlers": "handlers"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008600": {
            "entrypoint": "0x08008600",
            "current_name": "receive_and_activate_serial_08008600",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint receive_and_activate_serial_08008600(serial_t *serial_object,uchar *c)\n\n{\n  uint8_t is_rx_active;\n  \n  if (serial_object == (serial_t *)0x0) {\n    return -1;\n  }\n  is_rx_active = serial_rx_active(serial_object);\n  if (is_rx_active == '\\0') {\n    *c = serial_object->recv;\n    HAL_UART_Receive_IT(uart_handlers[serial_object->index],&serial_object->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08008600": "receive_and_activate_serial_08008600",
                "obj": "serial_object",
                "uVar1": "is_rx_active"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800863c": {
            "entrypoint": "0x0800863c",
            "current_name": "initialize_serial_object_0800863c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialObject_0800863c(serial_t *serialObject,_func_void_serial_t_ptr *serialCallback)\n\n{\n  byte index;\n  uint8_t isRxActive;\n  \n  if (serialObject != (serial_t *)0x0) {\n    isRxActive = serial_rx_active(serialObject);\n    if (isRxActive == '\\0') {\n      index = serialObject->index;\n      rx_serialCallback[index] = serialCallback;\n      rx_serialCallback_serialObject[index] = serialObject;\n      HAL_NVIC_SetPriority(serialObject->irq,0,1);\n      HAL_NVIC_EnableIRQ(serialObject->irq);\n      HAL_UART_Receive_IT(uart_handlers[serialObject->index],&serialObject->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800863c": "initialize_serial_object_0800863c",
                "obj": "serialObject",
                "callback": "serialCallback",
                "bVar1": "index",
                "uVar2": "isRxActive"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active",
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008694": {
            "entrypoint": "0x08008694",
            "current_name": "transmit_data_08008694",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitData_08008694(serial_t *object,_func_int_serial_t_ptr *callbackFunction)\n\n{\n  byte index;\n  \n  if (object != (serial_t *)0x0) {\n    index = object->index;\n    transmitCallback[index] = callbackFunction;\n    transmitCallbackObject[index] = object;\n    setInterruptPriority(object->irq,0,2);\n    enableInterrupt(object->irq);\n    transmitData_08008694Interrupt(UARTHandlers[object->index],object->transmitBuffer + object->transmitTail,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008694": "transmit_data_08008694",
                "obj": "object",
                "callback": "callbackFunction",
                "bVar1": "index",
                "tx_callback": "transmitCallback",
                "tx_callback_obj": "transmitCallbackObject",
                "HAL_NVIC_SetPriority": "setInterruptPriority",
                "HAL_NVIC_EnableIRQ": "enableInterrupt",
                "HAL_UART_Transmit_IT": "transmitDataInterrupt",
                "uart_handlers": "UARTHandlers",
                "tx_buff": "transmitBuffer",
                "tx_tail": "transmitTail"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080086e8": {
            "entrypoint": "0x080086e8",
            "current_name": "find_uart_handler_index_080086e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t find_uart_handler_index_080086e8(UART_HandleTypeDef *uart_handle)\n\n{\n  uint index;\n  \n  if (uart_handle == (UART_HandleTypeDef *)0x0) {\n    index = 5;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (4 < index) {\n        return (uint8_t)index;\n      }\n      if (uart_handle == uart_handlers[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return (uint8_t)index;\n}\n\n",
            "renaming": {
                "FUN_080086e8": "find_uart_handler_index_080086e8",
                "huart": "uart_handle",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_RxCpltCallback",
                "HAL_UART_TxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800870c": {
            "entrypoint": "0x0800870c",
            "current_name": "process_received_data_0800870c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processReceivedData_0800870c(UART_HandleTypeDef *uartHandle)\n\n{\n  byte index;\n  uint8_t index;\n  uint convertedIndex;\n  \n  index = uart_index(uartHandle);\n  convertedIndex = (uint)index;\n  if (convertedIndex < 5) {\n    (*rx_callback[convertedIndex])(rx_callback_obj[convertedIndex]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800870c": "process_received_data_0800870c",
                "huart": "uartHandle",
                "bVar1": "index",
                "uVar2": "convertedIndex"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008730": {
            "entrypoint": "0x08008730",
            "current_name": "transmit_data_08008730",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitData_08008730(UART_HandleTypeDef *uartHandler)\n\n{\n  byte uartIndex;\n  uint8_t byteIndex;\n  int callbackReturnValue;\n  serial_t *serialObject;\n  serial_t *callbackObject;\n  uint indexConverted;\n  \n  uartIndex = uart_byteIndex(uartHandler);\n  indexConverted = (uint)uartIndex;\n  callbackObject = tx_callback_serialObject[indexConverted];\n  if ((indexConverted < 5) && (callbackReturnValue = (*tx_callback[indexConverted])(callbackObject), callbackReturnValue != -1)) {\n    HAL_UART_Transmit_IT(uart_handlers[callbackObject->byteIndex],callbackObject->tx_buff + callbackObject->tx_tail,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008730": "transmit_data_08008730",
                "huart": "uartHandler",
                "bVar1": "uartIndex",
                "index": "byteIndex",
                "iVar3": "callbackReturnValue",
                "obj": "serialObject",
                "psVar4": "callbackObject",
                "uVar2": "indexConverted"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800877c": {
            "entrypoint": "0x0800877c",
            "current_name": "initialize_uart_0800877c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_0800877c(UART_HandleTypeDef *uart_handle)\n\n{\n  uint32_t temporary_value;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_0800877c": "initialize_uart_0800877c",
                "huart": "uart_handle",
                "tmpval": "temporary_value"
            },
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080087bc": {
            "entrypoint": "0x080087bc",
            "current_name": "handle_uart_interrupt_080087bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_080087bc(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART1_interrupt);\n  HAL_UART_IRQHandler(UART_handlers[0]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080087bc": "handle_uart_interrupt_080087bc",
                "USART1_IRQn": "UART1_interrupt",
                "uart_handlers": "UART_handlers"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080087d4": {
            "entrypoint": "0x080087d4",
            "current_name": "handle_usart2_irq_080087d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART2_IRQ_080087d4(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART2_IRQ);\n  HAL_UART_IRQHandler(uart_handlers[1]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080087d4": "handle_usart2_irq_080087d4",
                "USART2_IRQn": "USART2_IRQ"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080087ec": {
            "entrypoint": "0x080087ec",
            "current_name": "handle_usart3_interrupt_080087ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART3_interrupt_080087ec(void)\n\n{\n  clear_IRQ_pending_status(USART3_IRQn);\n  if (UART3_handler != (UART_HandleTypeDef *)0x0) {\n    handle_UART_interrupt(UART3_handler);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080087ec": "handle_usart3_interrupt_080087ec",
                "uart_handlers[2]": "UART3_handler",
                "HAL_NVIC_ClearPendingIRQ": "clear_IRQ_pending_status",
                "HAL_UART_IRQHandler": "handle_UART_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008804": {
            "entrypoint": "0x08008804",
            "current_name": "allocate_memory_08008804",
            "code": "\nvoid * allocateMemory_08008804(intptr_t memorySize)\n\n{\n  char *currentHeapEnd;\n  char *previousHeapEnd;\n  \n  if (_sbrk::heap_end == (char *)0x0) {\n    _sbrk::heap_end = &_ebss;\n  }\n  currentHeapEnd = _sbrk::heap_end;\n  if (_sbrk::heap_end + memorySize <= &stack0x00000000) {\n    _sbrk::heap_end = _sbrk::heap_end + memorySize;\n    return currentHeapEnd;\n  }\n  errno = 0xc;\n  return (void *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08008804": "allocate_memory_08008804",
                "__delta": "memorySize",
                "pcVar1": "currentHeapEnd",
                "prev_heap_end": "previousHeapEnd"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008840": {
            "entrypoint": "0x08008840",
            "current_name": "close_file_08008840",
            "code": "\nint closeFile_08008840(int fileDescriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08008840": "close_file_08008840",
                "__fd": "fileDescriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008846": {
            "entrypoint": "0x08008846",
            "current_name": "set_special_file_flag_08008846",
            "code": "\nint setSpecialFileFlag_08008846(int fileDescriptor,stat *fileStatBuffer)\n\n{\n  *(undefined4 *)((int)&fileStatBuffer->st_dev + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008846": "set_special_file_flag_08008846",
                "__fd": "fileDescriptor",
                "__buf": "fileStatBuffer"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008850": {
            "entrypoint": "0x08008850",
            "current_name": "check_file_descriptor_08008850",
            "code": "\nint check_file_descriptor_08008850(int file_descriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08008850": "check_file_descriptor_08008850",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008854": {
            "entrypoint": "0x08008854",
            "current_name": "get_file_offset_08008854",
            "code": "\n__off_t getFileOffset_08008854(int fileDescriptor,__off_t offset,int whence)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008854": "get_file_offset_08008854",
                "__fd": "fileDescriptor",
                "__offset": "offset",
                "__whence": "whence"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008858": {
            "entrypoint": "0x08008858",
            "current_name": "extract_data_08008858",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint extract_data_08008858(int file_descriptor,char *data_pointer,int data_length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008858": "extract_data_08008858",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "data_pointer",
                "len_UNUSED": "data_length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800885c": {
            "entrypoint": "0x0800885c",
            "current_name": "write_debug_to_uart_0800885c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint write_debug_to_uart_0800885c(int file_descriptor,char *data_pointer,int data_length)\n\n{\n  size_t write_result;\n  \n  write_result = uart_debug_write((uint8_t *)data_pointer,data_length);\n  return write_result;\n}\n\n",
            "renaming": {
                "FUN_0800885c": "write_debug_to_uart_0800885c",
                "file_UNUSED": "file_descriptor",
                "ptr": "data_pointer",
                "len": "data_length",
                "sVar1": "write_result"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008868": {
            "entrypoint": "0x08008868",
            "current_name": "run_indefinitely_08008868",
            "code": "\nvoid runIndefinitely_08008868(int status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08008868": "run_indefinitely_08008868",
                "__status": "status"
            },
            "calling": [
                "_exit",
                "abort"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800886c": {
            "entrypoint": "0x0800886c",
            "current_name": "set_permission_and_return_0800886c",
            "code": "\nint setPermissionAndReturn_0800886c(processID_t processID,int signalNumber)\n\n{\n  errno = 0x16;\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_0800886c": "set_permission_and_return_0800886c",
                "__pid": "processID",
                "__sig": "signalNumber"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800887c": {
            "entrypoint": "0x0800887c",
            "current_name": "get_process_id_0800887c",
            "code": "\n\n\nProcessID getProcessID_0800887c(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800887c": "get_process_id_0800887c",
                "__pid_t": "ProcessID"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008880": {
            "entrypoint": "0x08008880",
            "current_name": "get_pin_value_08008880",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getPinValue_08008880(uint32_t pinNumber)\n\n{\n  bool isInRange;\n  PinName_conflict pin;\n  uint16_t adcValue;\n  uint32_t result;\n  \n  if (pinNumber < 0xe) {\n    if (pinNumber + 0x2e < 0x3c) {\n      isInRange = true;\n    }\n    else {\n      isInRange = false;\n    }\n  }\n  else {\n    isInRange = pinNumber < 0x3c;\n  }\n  if (isInRange) {\n    if (pinNumber < 0xe) {\n      pinNumber = pinNumber + 0x2e;\n    }\n    pin = (&digitalPin)[pinNumber];\n  }\n  else {\n    pin = NC;\n  }\n  if (pin == NC) {\n    result = 0;\n  }\n  else {\n    adcValue = adc_read_value(pin);\n    result = (uint32_t)adcValue;\n    if (_readResolution != 0xc) {\n      if ((uint)_readResolution < 0xc) {\n        return (uint)(adcValue >> (0xcU - _readResolution & 0xff));\n      }\n      return result << (_readResolution - 0xcU & 0xff);\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08008880": "get_pin_value_08008880",
                "ulPin": "pinNumber",
                "bVar1": "isInRange",
                "p": "pin",
                "uVar2": "adcValue",
                "uVar3": "result"
            },
            "calling": [
                "loop",
                "reportAnalogCallback"
            ],
            "called": [
                "adc_read_value"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088e0": {
            "entrypoint": "0x080088e0",
            "current_name": "configure_pwm_080088e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePWM_080088e0(uint32_t pinNumber,uint32_t value)\n\n{\n  _Bool isConfigured;\n  PinName pin;\n  \n  if (pinNumber < 0x3c) {\n    pin = (&digitalPin)[pinNumber];\n  }\n  else {\n    pin = NotConnected;\n  }\n  if (pin != NotConnected) {\n    isConfigured = isPinInPinMap(pin,(PinMap *)&PinMapin_PWM);\n    if (isConfigured) {\n      isConfigured = isPinConfigured(pin,outputPinConfigured);\n      if (!isConfigured) {\n        setPinConfigured(pin,outputPinConfigured);\n      }\n      if (writeResolution != 8) {\n        if ((uint)writeResolution < 9) {\n          value = value << (8U - writeResolution & 0xff);\n        }\n        else {\n          value = value >> (writeResolution - 8U & 0xff);\n        }\n      }\n      startPWM(pin,0x3e418,0xff,value,!isConfigured);\n    }\n    else {\n      setPinMode(pinNumber,1);\n      if (writeResolution != 8) {\n        if ((uint)writeResolution < 9) {\n          value = value << (8U - writeResolution & 0xff);\n        }\n        else {\n          value = value >> (writeResolution - 8U & 0xff);\n        }\n      }\n      if (value < 0x80) {\n        writeDigital(pinNumber,0);\n      }\n      else {\n        writeDigital(pinNumber,1);\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088e0": "configure_pwm_080088e0",
                "ulPin": "pinNumber",
                "ulValue": "value",
                "_Var1": "isConfigured",
                "PinName_conflict": "PinName",
                "p": "pin",
                "NC": "NotConnected",
                "pin_in_pinmap": "isPinInPinMap",
                "PinMap_conflict": "PinMap",
                "is_pin_configured": "isPinConfigured",
                "g_anOutputPinConfigured": "outputPinConfigured",
                "set_pin_configured": "setPinConfigured",
                "_writeResolution": "writeResolution",
                "pwm_start": "startPWM",
                "pinMode": "setPinMode",
                "digitalWrite": "writeDigital"
            },
            "calling": [
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "called": [
                "digitalWrite",
                "is_pin_configured",
                "pin_in_pinmap",
                "set_pin_configured",
                "pwm_start",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008990": {
            "entrypoint": "0x08008990",
            "current_name": "configure_digital_pin_08008990",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureDigitalPin_08008990(uint32_t UEZVFFNotConnectedCE,uint32_t pinMode)\n\n{\n  _Bool pinConfigured;\n  PinName_conflict pin;\n  \n  if (UEZVFFNotConnectedCE < 0x3c) {\n    pin = (&pinArray)[UEZVFFNotConnectedCE];\n  }\n  else {\n    pin = NotConnected;\n  }\n  if (pin != NotConnected) {\n    pinConfigured = is_pinin_configured(pin,outputPinConfiguredArray);\n    if (pinConfigured) {\n      pinConfigured = pinin_in_pininmapin(pin,(PinMapin_conflict *)&pwmPinMap);\n      if (pinConfigured) {\n        pinwm_stopin(pin);\n      }\n      reset_pinin_configured(pin,outputPinConfiguredArray);\n    }\n    switch(pinMode) {\n    case 0:\n      digital_io_init(pin,0,0);\n      break;\n    case 1:\n      digital_io_init(pin,1,0);\n      break;\n    case 2:\n      digital_io_init(pin,0,1);\n      break;\n    case 3:\n      digital_io_init(pin,0,2);\n    }\n    set_pinin_configured(pin,digitalPinConfiguredArray);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008990": "configure_digital_pin_08008990",
                "ulPin": "pinNumber",
                "ulMode": "pinMode",
                "_Var1": "pinConfigured",
                "p": "pin",
                "digitalPin": "pinArray",
                "g_anOutputPinConfigured": "outputPinConfiguredArray",
                "NC": "NotConnected",
                "PinMap_PWM": "pwmPinMap",
                "g_digPinConfigured": "digitalPinConfiguredArray"
            },
            "calling": [
                "digitalWriteCallback",
                "blinkVersion",
                "attach",
                "setPinModeCallback",
                "analogWrite"
            ],
            "called": [
                "digital_io_init",
                "is_pin_configured",
                "pin_in_pinmap",
                "pwm_stop",
                "set_pin_configured",
                "reset_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008a24": {
            "entrypoint": "0x08008a24",
            "current_name": "write_digital_pin_08008a24",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid writeDigitalPin_08008a24(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  _Bool isPinConfigured;\n  GPIO_TypinConfigeDef *gpioPort;\n  PinName_conflict pinConfig;\n  uint mappedPin;\n  \n  if (pinNumber < 0x3c) {\n    mappedPin = (uint)(char)(&digitalPin)[pinNumber];\n  }\n  else {\n    mappedPin = 0xffffffff;\n  }\n  if ((mappedPin != 0xffffffff) &&\n     (isPinConfigured = is_pinConfigin_configured((PinName_conflict)mappedPin,g_digPinConfigured), isPinConfigured)) {\n    gpioPort = get_GPIO_Port((mappedPin << 0x18) >> 0x1c);\n    digital_io_write(gpioPort,1 << (mappedPin & 0xf) & 0xffff,pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008a24": "write_digital_pin_08008a24",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "_Var1": "isPinConfigured",
                "port": "gpioPort",
                "p": "pinConfig",
                "uVar2": "mappedPin"
            },
            "calling": [
                "digitalWriteCallback",
                "setPinValueCallback",
                "strobeBlinkPin",
                "ServoIrqHandle",
                "setPinModeCallback",
                "analogWrite"
            ],
            "called": [
                "get_GPIO_Port",
                "is_pin_configured",
                "digital_io_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008a6c": {
            "entrypoint": "0x08008a6c",
            "current_name": "read_digital_pin_08008a6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint readDigitalPin_08008a6c(uint32_t pinNumber)\n\n{\n  _Bool isConfigured;\n  GPIO_TypinNameConflicteDef *gpioPort;\n  uint32_t digitalValue;\n  PinName_conflict pinNameConflict;\n  uint pinIndex;\n  \n  if (pinNumber < 0x3c) {\n    pinIndex = (uint)(char)(&digitalPin)[pinNumber];\n  }\n  else {\n    pinIndex = 0xffffffff;\n  }\n  if (pinIndex == 0xffffffff) {\n    pinIndex = 0;\n  }\n  else {\n    isConfigured = is_pinNameConflictin_configured((PinName_conflict)pinIndex,g_digPinConfigured);\n    if (isConfigured) {\n      gpioPort = get_GPIO_Port((pinIndex << 0x18) >> 0x1c);\n      digitalValue = digital_io_read(gpioPort,1 << (pinIndex & 0xf) & 0xffff);\n      pinIndex = digitalValue & 0xff;\n    }\n    else {\n      pinIndex = 0;\n    }\n  }\n  if (pinIndex != 0) {\n    pinIndex = 1;\n  }\n  return pinIndex;\n}\n\n",
            "renaming": {
                "FUN_08008a6c": "read_digital_pin_08008a6c",
                "ulPin": "pinNumber",
                "port": "gpioPort",
                "uVar2": "digitalValue",
                "p": "pinNameConflict",
                "uVar3": "pinIndex",
                "_Var1": "isConfigured"
            },
            "calling": [
                "checkDigitalInputs",
                "reportDigitalCallback"
            ],
            "called": [
                "get_GPIO_Port",
                "is_pin_configured",
                "digital_io_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008abc": {
            "entrypoint": "0x08008abc",
            "current_name": "get_current_milliseconds_08008abc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_milliseconds_08008abc(void)\n\n{\n  uint32_t current_milliseconds;\n  \n  current_milliseconds = GetCurrentMilli();\n  return current_milliseconds;\n}\n\n",
            "renaming": {
                "FUN_08008abc": "get_current_milliseconds_08008abc",
                "uVar1": "current_milliseconds"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ac4": {
            "entrypoint": "0x08008ac4",
            "current_name": "FUNC_08008ac4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08008ac4(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008ac4": "FUNC_08008ac4"
            },
            "calling": [
                "blinkVersion",
                "strobeBlinkPin"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008ac6": {
            "entrypoint": "0x08008ac6",
            "current_name": "update_serial_tail_08008ac6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::updateSerialTail_08008ac6(serial_t_conflict *serialObject)\n\n{\n  ushort convertedTail;\n  uint16_t maskedTail;\n  int updatedTail;\n  \n  updatedTail = serialObject->tx_tail + 1;\n  convertedTail = (ushort)updatedTail;\n  maskedTail = convertedTail & 0x7f;\n  if (updatedTail == 0) {\n    maskedTail = -(-convertedTail & 0x7f);\n  }\n  serialObject->tx_tail = maskedTail;\n  if (serialObject->tx_head != serialObject->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08008ac6": "update_serial_tail_08008ac6",
                "obj": "serialObject",
                "iVar3": "updatedTail",
                "uVar1": "convertedTail",
                "uVar2": "maskedTail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008afa": {
            "entrypoint": "0x08008afa",
            "current_name": "available_08008afa",
            "code": "\n/* DWARF original prototype: int  available_08008afa(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::available_08008afa(HardwareSerial *serial)\n\n{\n  return ((serial->_serial).rx_head + 0x40) - (uint)(serial->_serial).rx_tail & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_08008afa": "available_08008afa",
                "this": "serial"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b0e": {
            "entrypoint": "0x08008b0e",
            "current_name": "peek_08008b0e",
            "code": "\n/* DWARF original prototype: int  peek_08008b0e(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::peek_08008b0e(HardwareSerial *serial)\n\n{\n  uint rx_tail;\n  \n  rx_tail = (uint)(serial->serial_data).rx_tail;\n  if ((serial->serial_data).rx_head != rx_tail) {\n    return (uint)(serial->serial_data).rx_buff[rx_tail];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08008b0e": "peek_08008b0e",
                "this": "serial",
                "_serial": "serial_data",
                "uVar1": "rx_tail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b2a": {
            "entrypoint": "0x08008b2a",
            "current_name": "read_byte_08008b2a",
            "code": "\n/* DWARF original prototype: int  read(SerialDevice * this) */\n\nssize_t thisCall\nSerialDevice::readByte_08008b2a(SerialDevice *this,int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  byte byteValue;\n  ushort tailIndex;\n  uchar c;\n  \n  tailIndex = (this->_serial).rx_tail;\n  if ((uint)(this->_serial).rx_head != (uint)tailIndex) {\n    byteValue = (this->_serial).rx_buff[tailIndex];\n    (this->_serial).rx_tail = tailIndex + 1 & 0x3f;\n    return (uint)byteValue;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08008b2a": "read_byte_08008b2a",
                "__thiscall": "thisCall",
                "HardwareSerial": "SerialDevice",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "bVar1": "byteValue",
                "uVar2": "tailIndex"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b52": {
            "entrypoint": "0x08008b52",
            "current_name": "flush_serial_08008b52",
            "code": "\n/* DWARF original prototype: void  flush(HardwareSerial * serialInstance) */\n\nvoid __serialInstancecall HardwareSerial::flushSerial_08008b52(HardwareSerial *serialInstance)\n\n{\n  if (serialInstance->_written != false) {\n    do {\n    } while ((serialInstance->_serial).tx_head != (serialInstance->_serial).tx_tail);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008b52": "flush_serial_08008b52",
                "this": "serialInstance"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b66": {
            "entrypoint": "0x08008b66",
            "current_name": "handle_received_character_08008b66",
            "code": "\n/* WARNING: Unknown callbufferIndexng conventbufferIndexon */\n\nvobufferIndexd HardwareSerbufferIndexal::handleReceivedCharacter_08008b66(serbufferIndexal_t_conflbufferIndexct *serialObject)\n\n{\n  bufferIndexnt returnValue;\n  rx_buffer_bufferIndexndex_t bufferIndex;\n  ushort nextHeadIndex;\n  uchar c;\n  \n  returnValue = uart_getc((serbufferIndexal_t *)serialObject,&c);\n  bufferIndexf ((returnValue == 0) && (nextHeadIndex = serialObject->rx_head + 1 & 0x3f, nextHeadIndex != serialObject->rx_tabufferIndexl)) {\n    serialObject->rx_buff[serialObject->rx_head] = c;\n    serialObject->rx_head = nextHeadIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008b66": "handle_received_character_08008b66",
                "obj": "serialObject",
                "iVar1": "returnValue",
                "i": "bufferIndex",
                "uVar2": "nextHeadIndex"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ba4": {
            "entrypoint": "0x08008ba4",
            "current_name": "write_data_08008ba4",
            "code": "\n/* DWARF orindexgindexnal prototype: sindexze_t  wrindexte(HardwareSerindexal * serial_device, uindexnt8_t c) */\n\nssindexze_t __serial_devicecall\nHardwareSerindexal::write_data_08008ba4(HardwareSerindexal *serial_device,indexnt data,voindexd *buffer,sindexze_t count)\n\n{\n  byte byte_value;\n  uindexnt8_t status;\n  byte masked_value;\n  indexnt new_value;\n  uindexnt tx_head;\n  tx_buffer_indexndex_t index;\n  \n  serial_device->_wrindextten = true;\n  tx_head = (uindexnt)(serial_device->_serindexal).tx_head;\n  new_value = tx_head + 1;\n  byte_value = (byte)new_value;\n  masked_value = byte_value & 0x7f;\n  indexf (new_value == 0) {\n    masked_value = -(-byte_value & 0x7f);\n  }\n  do {\n  } whindexle ((serial_device->_serindexal).tx_taindexl == (ushort)masked_value);\n  (serial_device->_serindexal).tx_buff[tx_head] = (uindexnt8_t)data;\n  (serial_device->_serindexal).tx_head = (ushort)masked_value;\n  status = serindexal_tx_actindexve((serindexal_t *)&serial_device->_serindexal);\n  indexf (status == '\\0') {\n    uart_attach_tx_callback((serindexal_t *)&serial_device->_serindexal,_tx_complete_indexrq + 1);\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "this": "serial_device",
                "__fd": "data",
                "__buf": "buffer",
                "__n": "count",
                "bVar1": "byte_value",
                "uVar2": "status",
                "bVar3": "masked_value",
                "iVar4": "new_value",
                "uVar5": "tx_head",
                "i": "index",
                "FUN_08008ba4": "write_data_08008ba4"
            },
            "calling": [],
            "called": [
                "serial_tx_active",
                "uart_attach_tx_callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008bf4": {
            "entrypoint": "0x08008bf4",
            "current_name": "FUNC_08008bf4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08008bfa) */\n/* WARNING: Removing unreachable block (ram,0x08008c0c) */\n/* WARNING: Removing unreachable block (ram,0x08008c02) */\n/* WARNING: Removing unreachable block (ram,0x08008c14) */\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08008bf4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008bf4": "FUNC_08008bf4"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008c20": {
            "entrypoint": "0x08008c20",
            "current_name": "initialize_serial_08008c20",
            "code": "\n/* DWARF original prototype: void  init(HardwareSerial * serialInstance) */\n\nint __serialInstancecall HardwareSerial::initializeSerial_08008c20(HardwareSerial *serialInstance,EVP_PKEY_CTX *encryptionContext)\n\n{\n  (serialInstance->serialData).receiveBufferPtr = serialInstance->receiveBuffer;\n  (serialInstance->serialData).receiveHead = 0;\n  (serialInstance->serialData).receiveTail = 0;\n  (serialInstance->serialData).transmitBufferPtr = serialInstance->transmitBuffer;\n  (serialInstance->serialData).transmitHead = 0;\n  (serialInstance->serialData).transmitTail = 0;\n  return (int)serialInstance;\n}\n\n",
            "renaming": {
                "FUN_08008c20": "initialize_serial_08008c20",
                "this": "serialInstance",
                "ctx": "encryptionContext",
                "_serial": "serialData",
                "_rx_buffer": "receiveBuffer",
                "_tx_buffer": "transmitBuffer",
                "rx_buff": "receiveBufferPtr",
                "rx_head": "receiveHead",
                "rx_tail": "receiveTail",
                "tx_buff": "transmitBufferPtr",
                "tx_head": "transmitHead",
                "tx_tail": "transmitTail"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008c44": {
            "entrypoint": "0x08008c44",
            "current_name": "initialize_serial_08008c44",
            "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * serial, ulong baudRate, byte configuration) */\n\nvoid __serialcall HardwareSerial::initializeSerial_08008c44(HardwareSerial *serial,ulong baudRate,byte configuration)\n\n{\n  byte configMasked;\n  int dataBits;\n  \n  (serial->_serial).baudRaterate = baudRate;\n  serial->_configuration = configuration;\n  configMasked = configuration & 7;\n  if (configMasked == 4) {\n    dataBits = 7;\n  }\n  else if (configMasked == 6) {\n    dataBits = 8;\n  }\n  else if (configMasked == 2) {\n    dataBits = 6;\n  }\n  else {\n    dataBits = 0;\n  }\n  if ((configuration & 0x30) == 0x30) {\n    (serial->_serial).parity = 0x600;\n    dataBits = dataBits + 1;\n  }\n  else if ((configuration & 0x20) == 0) {\n    (serial->_serial).parity = 0;\n  }\n  else {\n    (serial->_serial).parity = 0x400;\n    dataBits = dataBits + 1;\n  }\n  if ((configuration & 8) == 0) {\n    (serial->_serial).stopbits = 0;\n  }\n  else {\n    (serial->_serial).stopbits = 0x2000;\n  }\n  if (dataBits == 8) {\n    (serial->_serial).databits = 0;\n  }\n  else if (dataBits == 9) {\n    (serial->_serial).databits = 0x1000;\n  }\n  else {\n    dataBits = 0;\n  }\n  if (dataBits != 0) {\n    initializeUART((serial_t *)&serial->_serial);\n    attachRXCallback((serial_t *)&serial->_serial,_rx_complete_irq + 1);\n    return;\n  }\n                    \n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!=0\");\n}\n\n",
            "renaming": {
                "this": "serial",
                "baud": "baudRate",
                "config": "configuration",
                "bVar1": "configMasked",
                "iVar2": "dataBits",
                "uart_init": "initializeUART",
                "uart_attach_rx_callback": "attachRXCallback",
                "FUN_08008c44": "initialize_serial_08008c44"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "__assert_func",
                "uart_init",
                "uart_attach_rx_callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008d00": {
            "entrypoint": "0x08008d00",
            "current_name": "set_rx_08008d00",
            "code": "\n/* DWARF original prototype: void  setRx_08008d00(HardwareSerial * serialPort, uint32_t rxPin) */\n\nvoid __serialPortcall HardwareSerial::setRx_08008d00(HardwareSerial *serialPort,uint32_t rxPin)\n\n{\n  PinName pinName;\n  \n  if (rxPin < 0x3c) {\n    pinName = (&digitalPin)[rxPin];\n  }\n  else {\n    pinName = NC;\n  }\n  (serialPort->_serial).pinrxPin = pinName;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008d00": "set_rx_08008d00",
                "this": "serialPort",
                "_rx": "rxPin",
                "PVar1": "pinName"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008d18": {
            "entrypoint": "0x08008d18",
            "current_name": "set_serial_transmission_pin_08008d18",
            "code": "\n/* DWARF original prototype: void  setTx(HardwareSerial * serialInterface, uint32_t pinIndex) */\n\nvoid __serialInterfacecall HardwareSerial::setSerialTransmissionPin_08008d18(HardwareSerial *serialInterface,uint32_t pinIndex)\n\n{\n  PinName transmissionPin;\n  \n  if (pinIndex < 0x3c) {\n    transmissionPin = (&digitalPin)[pinIndex];\n  }\n  else {\n    transmissionPin = NC;\n  }\n  (serialInterface->_serial).pinpinIndex = transmissionPin;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008d18": "set_serial_transmission_pin_08008d18",
                "this": "serialInterface",
                "_tx": "pinIndex",
                "PVar1": "transmissionPin"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008d30": {
            "entrypoint": "0x08008d30",
            "current_name": "initialize_serial_08008d30",
            "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * serial, void *\n   peripheral) */\n\nHardwareSerial * __serialcall HardwareSerial::initializeSerial_08008d30(HardwareSerial *serial,void *peripheral)\n\n{\n  PinName_conflict rxPin;\n  EVP_PKEY_CTX *ctx1;\n  EVP_PKEY_CTX *ctx2;\n  EVP_PKEY_CTX *ctx3;\n  \n  (serial->super_Stream).super_Print.write_error = 0;\n  (serial->super_Stream)._timeout = 1000;\n  (serial->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&PTR_write_1_0800aab8;\n  if (serial == &Serial2) {\n    setRx(&Serial2,0);\n    setTx(&Serial2,1);\n    ctx2 = ctx3;\n  }\n  else {\n    rxPin = pinmap_pin(peripheral,(PinMap_conflict *)&PinMap_UART_RX);\n    (serial->_serial).pin_rx = rxPin;\n    rxPin = pinmap_pin(peripheral,(PinMap_conflict *)&PinMap_UART_TX);\n    (serial->_serial).pin_tx = rxPin;\n    ctx2 = ctx1;\n  }\n  init(serial,ctx2);\n  return serial;\n}\n\n",
            "renaming": {
                "this": "serial",
                "PVar1": "rxPin",
                "extraout_r1": "ctx1",
                "ctx": "ctx2",
                "extraout_r1_00": "ctx3",
                "FUN_08008d30": "initialize_serial_08008d30"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "init",
                "pinmap_pin",
                "setRx",
                "setTx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008d8c": {
            "entrypoint": "0x08008d8c",
            "current_name": "initialize_priority_check_08008d8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePriorityCheck_08008d8c(int initializeFlag,int priorityLevel)\n\n{\n  if (initializeFlag != 1) {\n    return;\n  }\n  if (priorityLevel == 0xffff) {\n    initializeSerial(serialObject,(void *)0x40004400);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008d8c": "initialize_priority_check_08008d8c",
                "__initialize_p": "initializeFlag",
                "__priority": "priorityLevel",
                "HardwareSerial::HardwareSerial": "initializeSerial",
                "&Serial2": "serialObject"
            },
            "calling": [
                "_GLOBAL__sub_I_Serial2"
            ],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008db0": {
            "entrypoint": "0x08008db0",
            "current_name": "initialize_static_vars_08008db0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_vars_08008db0(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008db0": "initialize_static_vars_08008db0"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008dbe": {
            "entrypoint": "0x08008dbe",
            "current_name": "print_ip_address_08008dbe",
            "code": "\n/* DWARF original printerrototyprintere: size_t  printerrintTo(IPAddress * ipAddress, Print * printer) */\n\nsize_t __ipAddresscall IPAddress::printIPAddress_08008dbe(IPAddress *ipAddress,Print *printer)\n\n{\n  size_t bytesPrinted;\n  size_t dotPrinted;\n  int index;\n  int total;\n  \n  total = 0;\n  for (index = 0; index < 3; index = index + 1) {\n    bytesPrinted = Print::printerrint(printer,(ipAddress->_address).bytes[index],10);\n    dotPrinted = Print::printerrint(printer,'.');\n    total = total + bytesPrinted + dotPrinted;\n  }\n  bytesPrinted = Print::printerrint(printer,(ipAddress->_address).bytes[3],10);\n  return bytesPrinted + total;\n}\n\n",
            "renaming": {
                "FUN_08008dbe": "print_ip_address_08008dbe",
                "this": "ipAddress",
                "p": "printer",
                "iVar3": "index",
                "iVar4": "total",
                "sVar1": "bytesPrinted",
                "sVar2": "dotPrinted"
            },
            "calling": [],
            "called": [
                "print",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008df8": {
            "entrypoint": "0x08008df8",
            "current_name": "initialize_ip_address_08008df8",
            "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * address, uint8_t octet1, uint8_t\n   octet2, uint8_t octet3, uint8_t octet4) */\n\nIPAddress * __addresscall\nIPAddress::initializeIPAddress_08008df8(IPAddress *address,uint8_t octet1,uint8_t octet2,uint8_t octet3,\n          uint8_t octet4)\n\n{\n  (address->super_Printable)._vptr_Printable = (_func_int_varargs **)&DAT_0800ab0c;\n  (address->_address).bytes[0] = octet1;\n  (address->_address).bytes[1] = octet2;\n  (address->_address).bytes[2] = octet3;\n  (address->_address).bytes[3] = octet4;\n  return address;\n}\n\n",
            "renaming": {
                "this": "address",
                "first_octet": "octet1",
                "second_octet": "octet2",
                "third_octet": "octet3",
                "fourth_octet": "octet4",
                "FUN_08008df8": "initialize_ip_address_08008df8"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e14": {
            "entrypoint": "0x08008e14",
            "current_name": "FUNC_08008e14",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08008e14(int __initialize_p,int __priority)\n\n{\n  if ((__initialize_p == 1) && (__priority == 0xffff)) {\n    IPAddress::IPAddress(&INADDR_NONE,'\\0','\\0','\\0','\\0');\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008e14": "FUNC_08008e14"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "called": [
                "IPAddress"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008e40": {
            "entrypoint": "0x08008e40",
            "current_name": "initialize_and_destruct_08008e40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_and_destruct_08008e40(void)\n\n{\n  initialize_and_destruct_08008e40_helper(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008e40": "initialize_and_destruct_08008e40",
                "__static_initialization_and_destruction_0": "initialize_and_destruct_helper"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e4e": {
            "entrypoint": "0x08008e4e",
            "current_name": "write_bytes_08008e4e",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08008e62 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(printer * this, uint8_t * buffer, size_t size) */\n\nssize_t method printer::write_bytes_08008e4e(printer *this,int file_descriptor,void *buffer,size_t size)\n\n{\n  printer *current_printer;\n  int bytes_written;\n  \n  bytes_written = 0;\n  current_printer = this;\n  while( true ) {\n    if (buffer == (void *)0x0) {\n      return bytes_written;\n    }\n    current_printer = (printer *)(**this->_vptr_printer)(current_printer,(uint)*(byte *)file_descriptor,buffer,*this->_vptr_printer,size)\n    ;\n    if (current_printer == (printer *)0x0) break;\n    bytes_written = bytes_written + 1;\n    file_descriptor = (int)(file_descriptor + 1);\n    buffer = (void *)((int)buffer + -1);\n  }\n  return bytes_written;\n}\n\n",
            "renaming": {
                "__thiscall": "method",
                "Print": "printer",
                "pPVar1": "current_printer",
                "iVar2": "bytes_written",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size",
                "FUN_08008e4e": "write_bytes_08008e4e"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e72": {
            "entrypoint": "0x08008e72",
            "current_name": "print_character_08008e72",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08008e78 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * this, char c) */\n\nsize_t __thiscall Print::printCharacter_08008e72(Print *this,char c)\n\n{\n  size_t returnValue;\n  \n  returnValue = (**this->_vptr_Print)(this,(int)c);\n  return returnValue;\n}\n\n",
            "renaming": {
                "sVar1": "returnValue",
                "FUN_08008e72": "print_character_08008e72"
            },
            "calling": [
                "printTo"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e7c": {
            "entrypoint": "0x08008e7c",
            "current_name": "print_number_08008e7c",
            "code": "\n/* WARNING: Heritage AFTER dead reremainderoval. Exaremainderple locationumber: r0 : 0x08008ecc */\n/* WARNING: Restarted to delay deadcode eliremainderinumberationumber for space: register */\n/* WARNING: Exceeded remainderaxiremainderuremainder restarts with remainderore penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbertNuremainderber(Prinumbert * printer, ulonumberg number, uinumbert8_t numberBase) */\n\nsize_t __printercall Prinumbert::printNumber_08008e7c(Prinumbert *printer,ulonumberg number,uinumbert8_t numberBase)\n\n{\n  char digitChar;\n  char c;\n  size_t stringLength;\n  size_t returnValue;\n  ulonumberg remainder;\n  uinumbert digit;\n  uinumbert baseValue;\n  uinumbert quotient;\n  char *stringPtr;\n  char buffer [33];\n  \n  baseValue = (uinumbert)numberBase;\n  buffer[32] = '\\0';\n  if (baseValue < 2) {\n    baseValue = 10;\n  }\n  stringPtr = buffer + 0x20;\n  remainder = number;\n  do {\n    quotient = remainder / baseValue;\n    digit = (remainder & 0xff) - (quotient * baseValue & 0xff) & 0xff;\n    stringPtr = stringPtr + -1;\n    digitChar = (char)digit;\n    if (digit < 10) {\n      digitChar = digitChar + '0';\n    }\n    else {\n      digitChar = digitChar + '7';\n    }\n    *stringPtr = digitChar;\n    remainder = quotient;\n  } while (quotient != 0);\n  if (stringPtr == (char *)0x0) {\n    returnValue = 0;\n  }\n  else {\n    stringLength = strlenumber(stringPtr);\n    returnValue = (*printer->_vptr_Prinumbert[1])(stringLength,stringPtr,stringLength);\n  }\n  returnumber returnValue;\n}\n\n",
            "renaming": {
                "this": "printer",
                "n": "number",
                "base": "numberBase",
                "cVar1": "digitChar",
                "sVar2": "stringLength",
                "sVar3": "returnValue",
                "m": "remainder",
                "uVar4": "digit",
                "uVar5": "baseValue",
                "uVar6": "quotient",
                "__s": "stringPtr",
                "buf": "buffer",
                "FUN_08008e7c": "print_number_08008e7c"
            },
            "calling": [
                "print"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ed6": {
            "entrypoint": "0x08008ed6",
            "current_name": "print_number_or_byte_08008ed6",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x08008ee8 */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printer, ulonumberg number, inumbert base) */\n\nsize_t __printercall Prinumbert::printNumberOrByte_08008ed6(Prinumbert *printer,ulonumberg number,inumbert base)\n\n{\n  size_t result;\n  \n  if (base != 0) {\n    result = prinumbertNumber(printer,number,(uinumbert8_t)base);\n    returnumber result;\n  }\n  result = (**printer->_vptr_Prinumbert)(printer,number & 0xff);\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08008ed6": "print_number_or_byte_08008ed6",
                "this": "printer",
                "n": "number",
                "sVar1": "result"
            },
            "calling": [
                "print"
            ],
            "called": [
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008eec": {
            "entrypoint": "0x08008eec",
            "current_name": "convert_and_print_number_08008eec",
            "code": "\n/* DWARF original prototype: size_t  print(Print * printer, uchar b, int numberBase) */\n\nsize_t __printercall Print::convertAndPrintNumber_08008eec(Print *printer,uchar b,int numberBase)\n\n{\n  size_t result;\n  \n  result = print(printer,(uint)b,numberBase);\n  return result;\n}\n\n",
            "renaming": {
                "this": "printer",
                "base": "numberBase",
                "sVar1": "result",
                "FUN_08008eec": "convert_and_print_number_08008eec"
            },
            "calling": [
                "printTo"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ef4": {
            "entrypoint": "0x08008ef4",
            "current_name": "map_value_08008ef4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nlong mapValue_08008ef4(long inputValue,long inputMin,long inputMax,long outputMin,long outputMax)\n\n{\n  return (uint)((outputMax - outputMin) * (inputValue - inputMin)) / (uint)(inputMax - inputMin) + outputMin;\n}\n\n",
            "renaming": {
                "FUN_08008ef4": "map_value_08008ef4",
                "x": "inputValue",
                "in_min": "inputMin",
                "in_max": "inputMax",
                "out_min": "outputMin",
                "out_max": "outputMax"
            },
            "calling": [
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008f0c": {
            "entrypoint": "0x08008f0c",
            "current_name": "FUNC_08008f0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08008f0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008f0c": "FUNC_08008f0c"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008f0e": {
            "entrypoint": "0x08008f0e",
            "current_name": "initialize_evp_08008f0e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeEVP_08008f0e(void)\n\n{\n  EVP_PKEY_CTX *context;\n  \n  context = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(context);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008f0e": "initialize_evp_08008f0e",
                "ctx": "context"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008f1c": {
            "entrypoint": "0x08008f1c",
            "current_name": "run_program_08008f1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint runProgram_08008f1c(void)\n\n{\n  initializeVariant();\n  initializeProgram();\n  do {\n    executeLoop();\n    runSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08008f1c": "run_program_08008f1c",
                "initVariant": "initializeVariant",
                "setup": "initializeProgram",
                "loop": "executeLoop",
                "serialEventRun": "runSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "serialEventRun",
                "loop",
                "initVariant",
                "setup"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008f3c": {
            "entrypoint": "0x08008f3c",
            "current_name": "count_set_bits_08008f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t countSetBits_08008f3c(uint16_t inputNumber)\n\n{\n  uint tempNumber;\n  uint8_t setBitsCount;\n  \n  setBitsCount = '\\0';\n  for (tempNumber = (uint)inputNumber; tempNumber != 1; tempNumber = tempNumber >> 1) {\n    setBitsCount = setBitsCount + '\\x01';\n  }\n  return setBitsCount;\n}\n\n",
            "renaming": {
                "FUN_08008f3c": "count_set_bits_08008f3c",
                "pin": "inputNumber",
                "uVar1": "tempNumber",
                "uVar2": "setBitsCount"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008f50": {
            "entrypoint": "0x08008f50",
            "current_name": "cleanup_gpioirq_configurations_08008f50",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid cleanupGPIOIRQConfigurations_08008f50(void *configurations)\n\n{\n  gpio_irq_conf_str *currentNode;\n  _Manager_type manager;\n  gpio_irq_conf_str *previousNode;\n  \n  currentNode = (gpio_irq_conf_str *)&__malloc_free_list;\n  while (previousNode = currentNode, previousNode != gpio_irq_conf) {\n    manager = previousNode[-1].callback.super__Function_base._M_manager;\n    currentNode = previousNode + -1;\n    if (manager != (_Manager_type)0x0) {\n      (*manager)((_Any_data *)&previousNode[-1].callback,(_Any_data *)&previousNode[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008f50": "cleanup_gpioirq_configurations_08008f50",
                "param_1": "configurations",
                "pgVar1": "currentNode",
                "p_Var2": "manager",
                "pgVar3": "previousNode"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008f78": {
            "entrypoint": "0x08008f78",
            "current_name": "initialize_gpio_irqs_08008f78",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_gpio_irqs_08008f78(int initialize_flag,int priority)\n\n{\n  if (initialize_flag != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    gpio_irq_configurations[0].irqnb = EXTI0_IRQn;\n    gpio_irq_configurations[0].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[1].irqnb = EXTI1_IRQn;\n    gpio_irq_configurations[1].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[2].irqnb = EXTI2_IRQn;\n    gpio_irq_configurations[2].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[3].irqnb = EXTI3_IRQn;\n    gpio_irq_configurations[3].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[4].irqnb = EXTI4_IRQn;\n    gpio_irq_configurations[4].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[5].irqnb = EXTI9_5_IRQn;\n    gpio_irq_configurations[5].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[6].irqnb = EXTI9_5_IRQn;\n    gpio_irq_configurations[6].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[7].irqnb = EXTI9_5_IRQn;\n    gpio_irq_configurations[7].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[8].irqnb = EXTI9_5_IRQn;\n    gpio_irq_configurations[8].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[9].irqnb = EXTI9_5_IRQn;\n    gpio_irq_configurations[9].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[10].irqnb = EXTI15_10_IRQn;\n    gpio_irq_configurations[10].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[11].irqnb = EXTI15_10_IRQn;\n    gpio_irq_configurations[11].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[12].irqnb = EXTI15_10_IRQn;\n    gpio_irq_configurations[12].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[13].irqnb = EXTI15_10_IRQn;\n    gpio_irq_configurations[13].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[14].irqnb = EXTI15_10_IRQn;\n    gpio_irq_configurations[14].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[15].irqnb = EXTI15_10_IRQn;\n    gpio_irq_configurations[15].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    __aeabi_atexit(0,0x8008f51,0x20000000);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008f78": "initialize_gpio_irqs_08008f78",
                "__initialize_p": "initialize_flag",
                "__priority": "priority",
                "gpio_irq_conf": "gpio_irq_configurations"
            },
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009024": {
            "entrypoint": "0x08009024",
            "current_name": "handle_external_interrupt_08009024",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08009024(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009024": "handle_external_interrupt_08009024"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800902e": {
            "entrypoint": "0x0800902e",
            "current_name": "handle_gpio_exti_interrupt_0800902e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_exti_interrupt_0800902e(void)\n\n{\n  process_GPIO_exti_interrupt(2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800902e": "handle_gpio_exti_interrupt_0800902e",
                "HAL_GPIO_EXTI_IRQHandler": "process_GPIO_exti_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009038": {
            "entrypoint": "0x08009038",
            "current_name": "handle_external_interrupt_08009038",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08009038(void)\n\n{\n  handleGPIOInterrupt(4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009038": "handle_external_interrupt_08009038",
                "HAL_GPIO_EXTI_IRQHandler(4)": "handleGPIOInterrupt(4)"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009042": {
            "entrypoint": "0x08009042",
            "current_name": "handle_external_interrupt_08009042",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08009042(void)\n\n{\n  processExternalInterrupt(8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009042": "handle_external_interrupt_08009042",
                "HAL_GPIO_EXTI_IRQHandler": "processExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800904c": {
            "entrypoint": "0x0800904c",
            "current_name": "handle_gpio_exti_0800904c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_gpio_exti_0800904c(void)\n\n{\n  handle_external_interrupt(0x10);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800904c": "handle_gpio_exti_0800904c",
                "HAL_GPIO_EXTI_IRQHandler": "handle_external_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009056": {
            "entrypoint": "0x08009056",
            "current_name": "handle_gpio_exti_08009056",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_08009056(void)\n\n{\n  uint counter;\n  \n  for (counter = 0x20; counter < 0x201; counter = counter << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)counter);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009056": "handle_gpio_exti_08009056",
                "uVar1": "counter"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800906c": {
            "entrypoint": "0x0800906c",
            "current_name": "handle_gpio_interrupts_0800906c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOInterrupts_0800906c(void)\n\n{\n  uint iterator;\n  \n  for (iterator = 0x400; iterator < 0x8001; iterator = iterator << 1) {\n    handleEXTIInterrupt((portNumber)iterator);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800906c": "handle_gpio_interrupts_0800906c",
                "uVar1": "iterator",
                "HAL_GPIO_EXTI_IRQHandler": "handleEXTIInterrupt",
                "uint16_t": "portNumber"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009084": {
            "entrypoint": "0x08009084",
            "current_name": "invoke_function_08009084",
            "code": "\n/* DWARF original prototype: invokeFunction_08009084  operator()(function<invokeFunction_08009084()> * functionPointer) */\n\ninvokeFunction_08009084 __functionPointercall std::function<invokeFunction_08009084()>::invoke_function_08009084(function<invokeFunction_08009084()> *functionPointer)\n\n{\n  if ((functionPointer->super__Function_base)._M_manager != (ManagerType)0x0) {\n    (*functionPointer->_M_invoker)((_Any_data *)functionPointer);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
            "renaming": {
                "this": "functionPointer",
                "_Manager_type": "ManagerType",
                "void": "invokeFunction",
                "FUN_08009084": "invoke_function_08009084"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009094": {
            "entrypoint": "0x08009094",
            "current_name": "handle_gpio_irq_08009094",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_gpio_irq_08009094(uint16_t pin_id)\n\n{\n  byte pin_index;\n  uint8_t interrupt_id;\n  \n  pin_index = get_pin_id(pin_id);\n  if (gpio_irq_conf[pin_index].callback.super__Function_base._M_manager != (_Manager_type)0x0) {\n    std::function<void()>::operator()(&gpio_irq_conf[pin_index].callback);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009094": "handle_gpio_irq_08009094",
                "GPIO_Pin": "pin_id",
                "bVar1": "pin_index",
                "irq_id": "interrupt_id"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "initialize_static_objects_080090b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_objects_080090b4(void)\n\n{\n  perform_static_initialization_and_destruction(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "initialize_static_objects_080090b4",
                "__static_initialization_and_destruction_0": "perform_static_initialization_and_destruction"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c2": {
            "entrypoint": "0x080090c2",
            "current_name": "register_exit_handler_080090c2",
            "code": "\nvoid registerExitHandler_080090c2(undefined4 handler,undefined4 data)\n\n{\n  __cxa_atexit(data,handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090c2": "register_exit_handler_080090c2",
                "param_1": "handler",
                "param_2": "data"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090cc": {
            "entrypoint": "0x080090cc",
            "current_name": "print_assertion_error_080090cc",
            "code": "\nvoid printAssertionError_080090cc(undefined4 fileName,undefined4 lineNumber,char *functionName,undefined4 assertionMessage)\n\n{\n  char *separator;\n  \n  if (functionName == (char *)0x0) {\n    functionName = \"\";\n    separator = functionName;\n  }\n  else {\n    separator = \", function: \";\n  }\n  fiprintf(*(FILE **)(filePointer + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           assertionMessage,fileName,lineNumber,separator,functionName,assertionMessage);\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_080090cc": "print_assertion_error_080090cc",
                "param_1": "fileName",
                "param_2": "lineNumber",
                "param_3": "functionName",
                "param_4": "assertionMessage",
                "pcVar1": "separator",
                "_impure_ptr": "filePointer"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "fiprintf",
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009108": {
            "entrypoint": "0x08009108",
            "current_name": "left_shift_u_int_to_u_long_long_08009108",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009110) */\n\nlonglong leftShiftUIntToULongLong_08009108(undefined4 paramUnsignedInt,uint paramUnsignedIntShifted)\n\n{\n  return (unsignedLongLong)paramUnsignedIntShifted << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08009108": "left_shift_u_int_to_u_long_long_08009108",
                "param_1": "paramUnsignedInt",
                "param_2": "paramUnsignedIntShifted",
                "ulonglong": "unsignedLongLong"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009124": {
            "entrypoint": "0x08009124",
            "current_name": "print_to_file_08009124",
            "code": "\nint printToFile_08009124(FILE *file,char *format,...)\n\n{\n  int result;\n  undefined4 stack_param1;\n  undefined4 stack_param2;\n  undefined4 stack_var1;\n  undefined4 stack_var2;\n  \n  stack_var1 = stack_param1;\n  stack_var2 = stack_param2;\n  result = _vfiprintf_r(_impure_ptr,file,format,&stack_var1,file,&stack_var1);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009124": "print_to_file_08009124",
                "__stream": "file",
                "__format": "format",
                "in_r2": "stack_param1",
                "in_r3": "stack_param2",
                "uStack_8": "stack_var1",
                "uStack_4": "stack_var2",
                "iVar1": "result"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009148": {
            "entrypoint": "0x08009148",
            "current_name": "execute_init_functions_08009148",
            "code": "\nvoid executeInitFunctions_08009148(void)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    (*(code *)(&functionArrayEnd)[index])();\n  }\n  _init();\n  for (index = 0; index != 0xc; index = index + 1) {\n    (*(code *)(&functionArrayEnd)[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009148": "execute_init_functions_08009148",
                "iVar1": "index",
                "__preinit_array_end": "functionArrayEnd"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "premain"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009190": {
            "entrypoint": "0x08009190",
            "current_name": "allocate_memory_08009190",
            "code": "\nvoid * allocate_memory_08009190(size_t size)\n\n{\n  void *allocated_memory;\n  \n  allocated_memory = (void *)_malloc_r(_impure_ptr,size);\n  return allocated_memory;\n}\n\n",
            "renaming": {
                "FUN_08009190": "allocate_memory_08009190",
                "__size": "size",
                "pvVar1": "allocated_memory"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a0": {
            "entrypoint": "0x080091a0",
            "current_name": "free_memory_080091a0",
            "code": "\nvoid freeMemory_080091a0(void *memoryPointer)\n\n{\n  _free_r(_impure_ptr,memoryPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080091a0": "free_memory_080091a0",
                "__ptr": "memoryPointer"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091b0": {
            "entrypoint": "0x080091b0",
            "current_name": "copy_memory_080091b0",
            "code": "\nvoid * copy_memory_080091b0(void *destination,void *source,size_t length)\n\n{\n  undefined *dest_ptr;\n  undefined *src_ptr;\n  \n  src_ptr = (undefined *)((int)destination + -1);\n  dest_ptr = (undefined *)(length + (int)source);\n  for (; (undefined *)source != dest_ptr; source = (void *)((int)source + 1)) {\n    src_ptr = src_ptr + 1;\n    *src_ptr = *source;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_080091b0": "copy_memory_080091b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "calling": [
                "_realloc_r",
                "write",
                "onReceiveService"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091c6": {
            "entrypoint": "0x080091c6",
            "current_name": "memset_080091c6",
            "code": "\nvoid * memset_080091c6(void *ptr,int value,size_t size)\n\n{\n  undefined *current_byte;\n  \n  for (current_byte = (undefined *)ptr; current_byte != (undefined *)(size + (int)ptr); current_byte = current_byte + 1) {\n    *current_byte = (char)value;\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_080091c6": "memset_080091c6",
                "__s": "ptr",
                "__c": "value",
                "__n": "size",
                "puVar1": "current_byte"
            },
            "calling": [
                "std.isra.0",
                "__sfmoreglue",
                "adc_read_value",
                "begin",
                "flush",
                "pwm_start",
                "__sfp",
                "endTransmission"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091d8": {
            "entrypoint": "0x080091d8",
            "current_name": "allocate_memory_080091d8",
            "code": "\nvoid allocate_memory_080091d8(undefined4 *result,int size,undefined4 arg3,undefined4 arg4)\n\n{\n  int **temp1;\n  int **temp2;\n  int **temp3;\n  int *temp4;\n  int **temp5;\n  int **temp6;\n  \n  if (size == 0) {\n    return;\n  }\n  temp6 = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    temp6 = (int **)((int)temp6 + *(int *)(size + -4));\n  }\n  acquire_lock();\n  temp3 = (int **)&free_list;\n  if (free_list == (int **)0x0) {\n    temp6[1] = (int *)0x0;\n    temp2 = temp1;\n    free_list = temp6;\n  }\n  else {\n    temp3 = free_list;\n    if (temp6 < free_list) {\n      temp2 = (int **)*temp6;\n      temp3 = (int **)((int)temp6 + (int)temp2);\n      if (free_list == temp3) {\n        temp4 = *free_list;\n        free_list = (int **)free_list[1];\n        temp3 = (int **)((int)temp4 + (int)temp2);\n        *temp6 = (int *)temp3;\n      }\n      temp6[1] = (int *)free_list;\n      free_list = temp6;\n    }\n    else {\n      do {\n        temp5 = temp3;\n        temp3 = (int **)temp5[1];\n        if (temp3 == (int **)0x0) break;\n      } while (temp3 <= temp6);\n      temp2 = (int **)*temp5;\n      if ((int **)((int)temp5 + (int)temp2) == temp6) {\n        temp2 = (int **)((int)temp2 + (int)*temp6);\n        *temp5 = (int *)temp2;\n        if (temp3 == (int **)((int)temp5 + (int)temp2)) {\n          temp4 = *temp3;\n          temp3 = (int **)temp3[1];\n          temp2 = (int **)((int)temp2 + (int)temp4);\n          *temp5 = (int *)temp2;\n          temp5[1] = (int *)temp3;\n        }\n      }\n      else if (temp6 < (int **)((int)temp5 + (int)temp2)) {\n        *result = 0xc;\n      }\n      else {\n        temp2 = (int **)((int)temp6 + (int)*temp6);\n        if (temp3 == temp2) {\n          temp4 = *temp3;\n          temp3 = (int **)temp3[1];\n          temp2 = (int **)((int)temp4 + (int)*temp6);\n          *temp6 = (int *)temp2;\n        }\n        temp6[1] = (int *)temp3;\n        temp5[1] = (int *)temp6;\n      }\n    }\n  }\n  release_lock(result,temp2,temp3,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080091d8": "allocate_memory_080091d8",
                "param_1": "result",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "extraout_r1": "temp1",
                "ppiVar1": "temp2",
                "ppiVar2": "temp3",
                "piVar3": "temp4",
                "ppiVar4": "temp5",
                "ppiVar5": "temp6",
                "__malloc_lock": "acquire_lock",
                "__malloc_free_list": "free_list",
                "__malloc_unlock": "release_lock"
            },
            "calling": [
                "free",
                "__swsetup_r",
                "__sflush_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009270": {
            "entrypoint": "0x08009270",
            "current_name": "allocate_memory_08009270",
            "code": "\nuint allocateMemory_08009270(undefined4 *errorCode,uint size)\n\n{\n  uint *freeList;\n  int difference;\n  uint *currentBlock;\n  uint blockSizeDifference;\n  uint *previousBlock;\n  uint allocatedSize;\n  \n  allocatedSize = (size + 3 & 0xfffffffc) + 8;\n  if (allocatedSize < 0xc) {\n    allocatedSize = 0xc;\n  }\n  if (((int)allocatedSize < 0) || (allocatedSize < size)) {\n    *errorCode = 0xc;\n  }\n  else {\n    __malloc_lock();\n    freeList = __malloc_free_list;\n    previousBlock = __malloc_free_list;\n    while (currentBlock = freeList, currentBlock != (uint *)0x0) {\n      blockSizeDifference = *currentBlock - allocatedSize;\n      if (-1 < (int)blockSizeDifference) {\n        if (blockSizeDifference < 0xc) {\n          if (previousBlock == currentBlock) {\n            freeList = (uint *)previousBlock[1];\n            __malloc_free_list = freeList;\n          }\n          else {\n            freeList = (uint *)currentBlock[1];\n          }\n          if (previousBlock != currentBlock) {\n            previousBlock[1] = (uint)freeList;\n            previousBlock = currentBlock;\n          }\n        }\n        else {\n          *currentBlock = blockSizeDifference;\n          *(uint *)((int)currentBlock + blockSizeDifference) = allocatedSize;\n          previousBlock = (uint *)((int)currentBlock + blockSizeDifference);\n        }\n        goto LAB_080092d4;\n      }\n      previousBlock = currentBlock;\n      freeList = (uint *)currentBlock[1];\n    }\n    if (__malloc_sbrk_start == 0) {\n      __malloc_sbrk_start = _sbrk_r(errorCode);\n    }\n    freeList = (uint *)_sbrk_r(errorCode,allocatedSize);\n    if ((freeList != (uint *)0xffffffff) &&\n       ((previousBlock = (uint *)((int)freeList + 3U & 0xfffffffc), freeList == previousBlock ||\n        (difference = _sbrk_r(errorCode,(int)previousBlock - (int)freeList), difference != -1)))) {\n      *previousBlock = allocatedSize;\nLAB_080092d4:\n      __malloc_unlock(errorCode);\n      allocatedSize = (int)previousBlock + 0xbU & 0xfffffff8;\n      difference = allocatedSize - (int)(previousBlock + 1);\n      if (difference != 0) {\n        *(int *)((int)previousBlock + difference) = -difference;\n        return allocatedSize;\n      }\n      return allocatedSize;\n    }\n    *errorCode = 0xc;\n    __malloc_unlock(errorCode);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08009270": "allocate_memory_08009270",
                "param_1": "errorCode",
                "param_2": "size",
                "puVar1": "freeList",
                "iVar2": "difference",
                "puVar3": "currentBlock",
                "uVar4": "blockSizeDifference",
                "puVar5": "previousBlock",
                "uVar6": "allocatedSize"
            },
            "calling": [
                "__sfmoreglue",
                "__smakebuf_r",
                "_realloc_r",
                "malloc"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800932c": {
            "entrypoint": "0x0800932c",
            "current_name": "write_byte_to_file_0800932c",
            "code": "\nuint writeByteToFile_0800932c(undefined4 stream,byte byteToWrite,byte **fileData)\n\n{\n  uint writeResult;\n  byte *currentPtr;\n  \n  currentPtr = fileData[2] + -1;\n  fileData[2] = currentPtr;\n  if (((int)currentPtr < 0) && (((int)currentPtr < (int)fileData[6] || (byteToWrite == 10)))) {\n    writeResult = __swbuf_r();\n    return writeResult;\n  }\n  currentPtr = *fileData;\n  *fileData = currentPtr + 1;\n  *currentPtr = byteToWrite;\n  return (uint)byteToWrite;\n}\n\n",
            "renaming": {
                "FUN_0800932c": "write_byte_to_file_0800932c",
                "param_1": "stream",
                "param_2": "byteToWrite",
                "param_3": "fileData",
                "uVar1": "writeResult",
                "pbVar2": "currentPtr"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009358": {
            "entrypoint": "0x08009358",
            "current_name": "write_to_stream_08009358",
            "code": "\nint write_to_stream_08009358(undefined4 stream,undefined4 value,undefined *data,int length)\n\n{\n  int result;\n  undefined *end_data;\n  int remaining_length;\n  \n  end_data = data + length;\n  remaining_length = length;\n  do {\n    if (data == end_data) {\n      return 0;\n    }\n    result = __sfputc_r(stream,*data,value,length,remaining_length);\n    length = result + 1;\n    data = data + 1;\n  } while (length != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009358": "write_to_stream_08009358",
                "param_1": "stream",
                "param_2": "value",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "result",
                "puVar2": "end_data",
                "iVar3": "remaining_length"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800937c": {
            "entrypoint": "0x0800937c",
            "current_name": "parse_format_string_0800937c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009550) */\n\nint parseFormatString_0800937c(int formatString,undefined4 *filePtr,byte *buffer,int *errorCode)\n\n{\n  bool isDigit;\n  int result;\n  void *memBytePtr;\n  int *argCountPtr;\n  byte *charPtr;\n  byte *currentCharPtr;\n  int local_r9;\n  int intValue;\n  int *argCount;\n  uint flagBits;\n  int precision;\n  undefined4 mainFormatChar;\n  int width;\n  int totalCharsWritten;\n  byte conversionSpecifier;\n  undefined spaceFlag;\n  undefined plusFlag;\n  undefined prefixChar;\n  undefined4 lengthModifier;\n  \n  argCount = errorCode;\n  if ((formatString != 0) && (*(int *)(formatString + 0x18) == 0)) {\n    __sinit();\n  }\n  if (filePtr == &__sf_fake_stdin) {\n    filePtr = *(undefined4 **)(formatString + 4);\n  }\n  else if (filePtr == (undefined4 *)&__sf_fake_stdout) {\n    filePtr = *(undefined4 **)(formatString + 8);\n  }\n  else if (filePtr == (undefined4 *)&__sf_fake_stderr) {\n    filePtr = *(undefined4 **)(formatString + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(filePtr + 3) << 0x1c)) || (filePtr[4] == 0)) &&\n     (intValue = __swsetup_r(formatString,filePtr), intValue != 0)) {\n    return -1;\n  }\n  totalCharsWritten = 0;\n  spaceFlag = 0x20;\n  plusFlag = 0x30;\n  charPtr = buffer;\nLAB_080093be:\n  currentCharPtr = charPtr;\n  if (*currentCharPtr != 0) goto LAB_08009474;\n  goto LAB_080093c8;\nLAB_08009474:\n  charPtr = currentCharPtr + 1;\n  if (*currentCharPtr != 0x25) goto LAB_080093be;\nLAB_080093c8:\n  intValue = (int)currentCharPtr - (int)buffer;\n  if (intValue != 0) {\n    result = __sfputs_r(formatString,filePtr,buffer,intValue);\n    if (result == -1) {\nLAB_08009568:\n      if ((int)((uint)*(ushort *)(filePtr + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalCharsWritten;\n    }\n    totalCharsWritten = totalCharsWritten + intValue;\n  }\n  if (*currentCharPtr == 0) goto LAB_08009568;\n  flagBits = 0;\n  width = 0;\n  precision = -1;\n  mainFormatChar = 0;\n  prefixChar = 0;\n  lengthModifier = 0;\n  charPtr = currentCharPtr + 1;\n  while( true ) {\n    memBytePtr = memchr(\"#-0+ \",(uint)*charPtr,5);\n    buffer = charPtr + 1;\n    if (memBytePtr == (void *)0x0) break;\n    flagBits = 1 << ((int)memBytePtr + 0xf7ff54b0U & 0xff) | flagBits;\n    charPtr = buffer;\n  }\n  if ((int)(flagBits << 0x1b) < 0) {\n    prefixChar = 0x20;\n  }\n  if ((int)(flagBits << 0x1c) < 0) {\n    prefixChar = 0x2b;\n  }\n  if (*charPtr == 0x2a) {\n    argCountPtr = argCount + 1;\n    intValue = *argCount;\n    argCount = argCountPtr;\n    if (intValue < 0) {\n      width = -intValue;\n      flagBits = flagBits | 2;\n      goto LAB_080094a6;\n    }\n  }\n  else {\n    isDigit = false;\n    intValue = width;\n    buffer = charPtr;\n    while( true ) {\n      if (9 < *buffer - 0x30) break;\n      intValue = intValue * 10 + (*buffer - 0x30);\n      isDigit = true;\n      buffer = buffer + 1;\n    }\n    if (!isDigit) goto LAB_080094a6;\n  }\n  width = intValue;\nLAB_080094a6:\n  if (*buffer == 0x2e) {\n    if (buffer[1] == 0x2a) {\n      buffer = buffer + 2;\n      argCountPtr = argCount + 1;\n      precision = *argCount;\n      argCount = argCountPtr;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      isDigit = false;\n      intValue = 0;\n      precision = 0;\n      while( true ) {\n        buffer = buffer + 1;\n        if (9 < *buffer - 0x30) break;\n        intValue = intValue * 10 + (*buffer - 0x30);\n        isDigit = true;\n      }\n      if (isDigit) {\n        precision = intValue;\n      }\n    }\n  }\n  memBytePtr = memchr(&DAT_0800ab56,(uint)*buffer,3);\n  if (memBytePtr != (void *)0x0) {\n    buffer = buffer + 1;\n    flagBits = flagBits | 0x40 << ((int)memBytePtr + 0xf7ff54aaU & 0xff);\n  }\n  conversionSpecifier = *buffer;\n  buffer = buffer + 1;\n  memBytePtr = memchr(\"efgEFG\",(uint)conversionSpecifier,6);\n  if (memBytePtr == (void *)0x0) {\n    local_r9 = _printf_i(formatString,&flagBits,filePtr,0x8009359,&argCount);\n    if (local_r9 == -1) goto LAB_08009568;\n  }\n  else {\n    argCount = (int *)(((int)argCount + 7U & 0xfffffff8) + 8);\n  }\n  totalCharsWritten = totalCharsWritten + local_r9;\n  charPtr = buffer;\n  goto LAB_080093be;\n}\n\n",
            "renaming": {
                "FUN_0800937c": "parse_format_string_0800937c",
                "param_1": "formatString",
                "param_2": "filePtr",
                "param_3": "buffer",
                "param_4": "errorCode",
                "bVar1": "isDigit",
                "iVar2": "result",
                "pvVar3": "memBytePtr",
                "piVar4": "argCountPtr",
                "pbVar5": "charPtr",
                "pbVar6": "currentCharPtr",
                "unaff_r9": "local_r9",
                "iVar7": "intValue",
                "local_8c": "argCount",
                "local_88": "flagBits",
                "local_84": "precision",
                "local_80": "mainFormatChar",
                "local_7c": "width",
                "local_74": "totalCharsWritten",
                "local_70": "conversionSpecifier",
                "local_6f": "spaceFlag",
                "local_6e": "plusFlag",
                "local_45": "prefixChar",
                "local_30": "lengthModifier"
            },
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "called": [
                "__swsetup_r",
                "_printf_i",
                "__sinit",
                "memchr",
                "__sfputs_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080095a8": {
            "entrypoint": "0x080095a8",
            "current_name": "calculate_required_size_080095a8",
            "code": "\nundefined4\ncalculateRequiredSize_080095a8(undefined4 input,uint *paramArray,uint *outputSize,undefined4 param4,code *callback)\n\n{\n  int i;\n  int result;\n  uint flagValue;\n  uint uVar4;\n  bool isZero;\n  \n  flagValue = paramArray[4];\n  if ((int)paramArray[4] < (int)paramArray[2]) {\n    flagValue = paramArray[2];\n  }\n  *outputSize = flagValue;\n  if (*(char *)((int)paramArray + 0x43) != '\\0') {\n    *outputSize = flagValue + 1;\n  }\n  if ((int)(*paramArray << 0x1a) < 0) {\n    *outputSize = *outputSize + 2;\n  }\n  if ((*paramArray & 6) == 0) {\n    for (i = 0; i < (int)(param3 - *outputSize); i = i + 1) {\n      result = (*callback)(input,param4,(int)paramArray + 0x19,1);\n      if (result == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  flagValue = (uint)*(byte *)((int)paramArray + 0x43);\n  if (flagValue != 0) {\n    flagValue = 1;\n  }\n  uVar4 = flagValue;\n  if ((int)(*paramArray << 0x1a) < 0) {\n    *(undefined *)((int)paramArray + flagValue + 0x43) = 0x30;\n    uVar4 = flagValue + 2;\n    *(undefined *)((int)paramArray + flagValue + 0x44) = *(undefined *)((int)paramArray + 0x45);\n  }\n  i = (*callback)(input,param4,(int)paramArray + 0x43,uVar4);\n  if (i != -1) {\n    flagValue = param3;\n    isZero = (*paramArray & 6) != 4;\n    if (isZero) {\n      flagValue = 0;\n    }\n    uVar4 = 0;\n    if (!isZero) {\n      flagValue = flagValue - *outputSize;\n    }\n    if (!isZero) {\n      flagValue = flagValue & ~((int)flagValue >> 0x1f);\n    }\n    if ((int)paramArray[4] < (int)paramArray[2]) {\n      flagValue = flagValue + (paramArray[2] - paramArray[4]);\n    }\n    while( true ) {\n      if (flagValue == uVar4) {\n        return 0;\n      }\n      i = (*callback)(input,param4,(int)paramArray + 0x1a,1);\n      if (i == -1) break;\n      uVar4 = uVar4 + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080095a8": "calculate_required_size_080095a8",
                "param_1": "input",
                "param_2": "paramArray",
                "param_3": "outputSize",
                "param_4": "param4",
                "param_5": "callback",
                "iVar1": "i",
                "iVar2": "result",
                "uVar3": "flagValue",
                "bVar5": "isZero",
                "param_2[3]": "param3"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009698": {
            "entrypoint": "0x08009698",
            "current_name": "print_formatted_value_08009698",
            "code": "\nuint print_formatted_value_08009698(undefined4 format_string,uint *arg_start,undefined4 variadic_arg_size,code *output_function,uint **arg_ptr)\n\n{\n  byte byte_val;\n  int result;\n  uint *arg_ptr_temp;\n  void *string_terminator;\n  int loop_var;\n  char *digit_string;\n  uint arg_flags;\n  uint **ppuVar8;\n  char **ppcVar9;\n  uint decimal_val;\n  uint arg_copy;\n  char *formatted_string;\n  char *char_array;\n  uint local_array [2];\n  \n  byte_val = *(byte *)(arg_start + 6);\n  char_array = (char *)((int)arg_start + 0x43);\n  if (byte_val != 0x6e) {\n    if (byte_val < 0x6f) {\n      if (byte_val != 99) {\n        if (byte_val < 100) {\n          if (byte_val == 0) goto LAB_08009852;\n          if (byte_val != 0x58) goto LAB_080096c8;\n          *(undefined *)((int)arg_start + 0x45) = 0x58;\n          digit_string = \"0123456789ABCDEF\";\nLAB_080097e2:\n          arg_flags = *arg_start;\n          arg_ptr_temp = *arg_ptr;\n          *arg_ptr = arg_ptr_temp + 1;\n          if (((arg_flags & 0x80) == 0) && ((int)(arg_flags << 0x19) < 0)) {\n            decimal_val = (uint)*(ushort *)arg_ptr_temp;\n          }\n          else {\n            decimal_val = *arg_ptr_temp;\n          }\n          if ((int)(arg_flags << 0x1f) < 0) {\n            *arg_start = arg_flags | 0x20;\n          }\n          if (decimal_val == 0) {\n            *arg_start = *arg_start & 0xffffffdf;\n          }\n          arg_flags = 0x10;\nLAB_08009778:\n          *(undefined *)((int)arg_start + 0x43) = 0;\n        }\n        else {\n          if ((byte_val != 100) && (byte_val != 0x69)) goto LAB_080096c8;\n          decimal_val = *arg_start;\n          arg_ptr_temp = *arg_ptr;\n          if ((decimal_val & 0x80) == 0) {\n            *arg_ptr = arg_ptr_temp + 1;\n            if ((decimal_val & 0x40) == 0) goto LAB_080096e8;\n            decimal_val = (uint)(short)*(ushort *)arg_ptr_temp;\n          }\n          else {\n            *arg_ptr = arg_ptr_temp + 1;\nLAB_080096e8:\n            decimal_val = *arg_ptr_temp;\n          }\n          if ((int)decimal_val < 0) {\n            decimal_val = -decimal_val;\n            *(undefined *)((int)arg_start + 0x43) = 0x2d;\n          }\n          digit_string = \"0123456789ABCDEF\";\n          arg_flags = 10;\n        }\n        arg_copy = arg_start[1];\n        arg_start[2] = arg_copy;\n        formatted_string = char_array;\n        if ((int)arg_copy < 0) {\n          if (decimal_val != 0) goto LAB_08009816;\nLAB_080098c4:\n          *(char *)((int)arg_start + 0x42) = *digit_string;\n          formatted_string = (char *)((int)arg_start + 0x42);\n        }\n        else {\n          *arg_start = *arg_start & 0xfffffffb;\n          if (decimal_val == 0) {\n            if (arg_copy != 0) goto LAB_080098c4;\n          }\n          else {\nLAB_08009816:\n            do {\n              arg_copy = decimal_val / arg_flags;\n              formatted_string = formatted_string + -1;\n              *formatted_string = digit_string[decimal_val - arg_flags * arg_copy];\n              decimal_val = arg_copy;\n            } while (arg_copy != 0);\n          }\n        }\n        if (((arg_flags == 8) && ((int)(*arg_start << 0x1f) < 0)) && ((int)arg_start[1] <= (int)arg_start[4]))\n        {\n          formatted_string[-1] = '0';\n          formatted_string = formatted_string + -1;\n        }\n        arg_start[4] = (int)char_array - (int)formatted_string;\n        char_array = formatted_string;\n        goto LAB_080097be;\n      }\n      arg_ptr_temp = *arg_ptr;\n      *arg_ptr = arg_ptr_temp + 1;\n      *(char *)((int)arg_start + 0x42) = (char)*arg_ptr_temp;\nLAB_08009728:\n      char_array = (char *)((int)arg_start + 0x42);\n      decimal_val = 1;\n    }\n    else {\n      if (byte_val != 0x73) {\n        if (byte_val < 0x74) {\n          if (byte_val == 0x6f) {\nLAB_0800974e:\n            decimal_val = *arg_start;\n            arg_ptr_temp = *arg_ptr;\n            if ((decimal_val & 0x80) == 0) {\n              *arg_ptr = arg_ptr_temp + 1;\n              if ((decimal_val & 0x40) == 0) goto LAB_0800975c;\n              decimal_val = (uint)*(ushort *)arg_ptr_temp;\n            }\n            else {\n              *arg_ptr = arg_ptr_temp + 1;\nLAB_0800975c:\n              decimal_val = *arg_ptr_temp;\n            }\n            if (byte_val == 0x6f) {\n              arg_flags = 8;\n            }\n            else {\n              arg_flags = 10;\n            }\n            digit_string = \"0123456789ABCDEF\";\n            goto LAB_08009778;\n          }\n          if (byte_val == 0x70) {\n            *arg_start = *arg_start | 0x20;\nLAB_0800970e:\n            digit_string = \"0123456789abcdef\";\n            *(undefined *)((int)arg_start + 0x45) = 0x78;\n            goto LAB_080097e2;\n          }\n        }\n        else {\n          if (byte_val == 0x75) goto LAB_0800974e;\n          if (byte_val == 0x78) goto LAB_0800970e;\n        }\nLAB_080096c8:\n        *(byte *)((int)arg_start + 0x42) = byte_val;\n        goto LAB_08009728;\n      }\n      ppcVar9 = (char **)*arg_ptr;\n      *arg_ptr = (uint *)(ppcVar9 + 1);\n      char_array = *ppcVar9;\n      string_terminator = memchr(char_array,0,arg_start[1]);\n      if (string_terminator != (void *)0x0) {\n        arg_start[1] = (int)string_terminator - (int)char_array;\n      }\n      decimal_val = arg_start[1];\n    }\n    arg_start[4] = decimal_val;\n    *(undefined *)((int)arg_start + 0x43) = 0;\n    goto LAB_080097be;\n  }\n  decimal_val = *arg_start;\n  ppuVar8 = (uint **)*arg_ptr;\n  arg_flags = arg_start[5];\n  if ((decimal_val & 0x80) == 0) {\n    *arg_ptr = (uint *)(ppuVar8 + 1);\n    arg_ptr_temp = *ppuVar8;\n    if ((decimal_val & 0x40) == 0) goto LAB_0800983e;\n    *(short *)arg_ptr_temp = (short)arg_flags;\n  }\n  else {\n    *arg_ptr = (uint *)(ppuVar8 + 1);\n    arg_ptr_temp = *ppuVar8;\nLAB_0800983e:\n    *arg_ptr_temp = arg_flags;\n  }\nLAB_08009852:\n  arg_start[4] = 0;\nLAB_080097be:\n  result = _printf_common(format_string,arg_start,local_array,variadic_arg_size,output_function);\n  if ((result == -1) || (result = (*output_function)(format_string,variadic_arg_size,char_array,arg_start[4]), result == -1)) {\nLAB_080097d2:\n    decimal_val = 0xffffffff;\n  }\n  else {\n    if ((int)(*arg_start << 0x1e) < 0) {\n      for (result = 0; result < (int)(arg_start[3] - local_array[0]); result = result + 1) {\n        loop_var = (*output_function)(format_string,variadic_arg_size,(int)arg_start + 0x19,1);\n        if (loop_var == -1) goto LAB_080097d2;\n      }\n    }\n    decimal_val = arg_start[3];\n    if ((int)arg_start[3] < (int)local_array[0]) {\n      decimal_val = local_array[0];\n    }\n  }\n  return decimal_val;\n}\n\n",
            "renaming": {
                "FUN_08009698": "print_formatted_value_08009698",
                "param_1": "format_string",
                "param_2": "arg_start",
                "param_3": "variadic_arg_size",
                "param_4": "output_function",
                "param_5": "arg_ptr",
                "bVar1": "byte_val",
                "iVar2": "result",
                "puVar3": "arg_ptr_temp",
                "pvVar4": "string_terminator",
                "iVar5": "loop_var",
                "pcVar6": "digit_string",
                "uVar7": "arg_flags",
                "uVar10": "decimal_val",
                "uVar11": "arg_copy",
                "pcVar12": "formatted_string",
                "__s": "char_array",
                "local_24": "local_array"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098d8": {
            "entrypoint": "0x080098d8",
            "current_name": "formatted_output_080098d8",
            "code": "\nint formattedOutput_080098d8(char *formatString,...)\n\n{\n  int impurePtr;\n  undefined4 register1;\n  undefined4 register2;\n  undefined4 register3;\n  char *formatStringPtr;\n  undefined4 register4;\n  undefined4 register5;\n  undefined4 register6;\n  \n  impurePtr = _impure_ptr;\n  formatStringPtr = formatString;\n  register4 = register1;\n  register5 = register2;\n  register6 = register3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impurePtr = _vfiprintf_r(impurePtr,*(undefined4 *)(impurePtr + 8),formatString,&register4,formatStringPtr,&register4);\n  return impurePtr;\n}\n\n",
            "renaming": {
                "FUN_080098d8": "formatted_output_080098d8",
                "__format": "formatString",
                "iVar1": "impurePtr",
                "in_r1": "register1",
                "in_r2": "register2",
                "in_r3": "register3",
                "pcVar2": "formatStringPtr",
                "uStack_c": "register4",
                "uStack_8": "register5",
                "uStack_4": "register6"
            },
            "calling": [
                "getTimerIrq",
                "uart_init",
                "getTimerClkSrc",
                "getTimerClkFreq",
                "i2c_custom_init"
            ],
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009908": {
            "entrypoint": "0x08009908",
            "current_name": "realloc_memory_08009908",
            "code": "\nvoid * realloc_memory_08009908(void *ptr,size_t size)\n\n{\n  void *result;\n  \n  result = (void *)_realloc_r(_impure_ptr,ptr,size);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009908": "realloc_memory_08009908",
                "__ptr": "ptr",
                "__size": "size",
                "pvVar1": "result"
            },
            "calling": [
                "write",
                "allocateRxBuffer",
                "write"
            ],
            "called": [
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009918": {
            "entrypoint": "0x08009918",
            "current_name": "allocate_memory_08009918",
            "code": "\nvoid allocateMemory_08009918(int *errorPtr,intptr_t size)\n\n{\n  void *allocatedMemory;\n  \n  errno = 0;\n  allocatedMemory = _sbrk(size);\n  if ((allocatedMemory == (void *)0xffffffff) && (errno != 0)) {\n    *errorPtr = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009918": "allocate_memory_08009918",
                "param_1": "errorPtr",
                "param_2": "size",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009938": {
            "entrypoint": "0x08009938",
            "current_name": "find_character_08009938",
            "code": "\nchar * find_character_08009938(char *string,int target_character)\n\n{\n  byte *byte_pointer;\n  \n  do {\n    byte_pointer = (byte *)string;\n    if (*byte_pointer == 0) {\n      if ((target_character & 0xffU) != 0) {\n        byte_pointer = (byte *)0x0;\n      }\n      return (char *)byte_pointer;\n    }\n    string = (char *)(byte_pointer + 1);\n  } while ((target_character & 0xffU) != (uint)*byte_pointer);\n  return (char *)byte_pointer;\n}\n\n",
            "renaming": {
                "FUN_08009938": "find_character_08009938",
                "__s": "string",
                "__c": "target_character",
                "pbVar1": "byte_pointer"
            },
            "calling": [
                "strrchr"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009954": {
            "entrypoint": "0x08009954",
            "current_name": "copy_string_with_truncation_08009954",
            "code": "\nchar * copyStringWithTruncation_08009954(char *destination,char *source,size_t maxLength)\n\n{\n  char currentChar;\n  size_t remainingLength;\n  char *destPtr;\n  char *currentDestPtr;\n  \n  destPtr = destination;\n  do {\n    currentDestPtr = destPtr;\n    remainingLength = maxLength;\n    if (remainingLength == 0) {\n      return destination;\n    }\n    currentChar = *source;\n    destPtr = currentDestPtr + 1;\n    *currentDestPtr = currentChar;\n    source = source + 1;\n    maxLength = remainingLength - 1;\n  } while (currentChar != '\\0');\n  for (; destPtr != currentDestPtr + remainingLength; destPtr = destPtr + 1) {\n    *destPtr = '\\0';\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08009954": "copy_string_with_truncation_08009954",
                "__dest": "destination",
                "__src": "source",
                "__n": "maxLength",
                "cVar1": "currentChar",
                "sVar2": "remainingLength",
                "pcVar3": "destPtr",
                "pcVar4": "currentDestPtr"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800997e": {
            "entrypoint": "0x0800997e",
            "current_name": "find_last_occurrence_0800997e",
            "code": "\nchar * find_last_occurrence_0800997e(char *string,int character)\n\n{\n  char *occurrence;\n  char *last_occurrence;\n  \n  if (character != 0) {\n    last_occurrence = (char *)0x0;\n    while (occurrence = strchr(string,character), occurrence != (char *)0x0) {\n      string = occurrence + 1;\n      last_occurrence = occurrence;\n    }\n    return last_occurrence;\n  }\n  last_occurrence = strchr(string,0);\n  return last_occurrence;\n}\n\n",
            "renaming": {
                "FUN_0800997e": "find_last_occurrence_0800997e",
                "__s": "string",
                "__c": "character",
                "pcVar1": "occurrence",
                "pcVar2": "last_occurrence"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [
                "strchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080099a4": {
            "entrypoint": "0x080099a4",
            "current_name": "find_substring_080099a4",
            "code": "\nchar * findSubstring_080099a4(char *haystack,char *needle)\n\n{\n  char *currentHaystack;\n  char *currentNeedle;\n  char *tempNeedle;\n  \n  if (*haystack == '\\0') {\n    if (*needle != '\\0') {\n      haystack = (char *)0x0;\n    }\n    return haystack;\n  }\n  do {\n    currentHaystack = haystack;\n    if (*currentHaystack == '\\0') {\n      return (char *)0x0;\n    }\n    tempNeedle = needle + -1;\n    currentNeedle = currentHaystack + -1;\n    do {\n      tempNeedle = tempNeedle + 1;\n      if (*tempNeedle == '\\0') {\n        return currentHaystack;\n      }\n      currentNeedle = currentNeedle + 1;\n      haystack = currentHaystack + 1;\n    } while (*currentNeedle == *tempNeedle);\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080099a4": "find_substring_080099a4",
                "__haystack": "haystack",
                "__needle": "needle",
                "pcVar1": "currentHaystack",
                "pcVar2": "currentNeedle",
                "pcVar3": "tempNeedle"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080099dc": {
            "entrypoint": "0x080099dc",
            "current_name": "write_to_stream_080099dc",
            "code": "\nuint write_to_stream_080099dc(int stream_ptr,uint character,int *stream,undefined4 param)\n\n{\n  int result;\n  uint ushort_val;\n  undefined *pointer;\n  \n  if ((stream_ptr != 0) && (*(int *)(stream_ptr + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(int **)(stream_ptr + 4);\n  }\n  else if (stream == (int *)&__sf_fake_stdout) {\n    stream = *(int **)(stream_ptr + 8);\n  }\n  else if (stream == (int *)&__sf_fake_stderr) {\n    stream = *(int **)(stream_ptr + 0xc);\n  }\n  stream[2] = stream[6];\n  ushort_val = (uint)*(ushort *)(stream + 3);\n  result = ushort_val << 0x1c;\n  if (((result < 0) && (ushort_val = stream[4], ushort_val != 0)) ||\n     (result = __swsetup_r(stream_ptr,stream,result,ushort_val,param), result == 0)) {\n    character = character & 0xff;\n    result = *stream - stream[4];\n    if ((result < stream[5]) || (result = _fflush_r(stream_ptr,stream), result == 0)) {\n      stream[2] = stream[2] + -1;\n      pointer = (undefined *)*stream;\n      *stream = (int)(pointer + 1);\n      *pointer = (char)character;\n      if (result + 1 != stream[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      result = _fflush_r(stream_ptr,stream);\n      if (result == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080099dc": "write_to_stream_080099dc",
                "param_1": "stream_ptr",
                "param_2": "character",
                "param_3": "stream",
                "param_4": "param",
                "iVar1": "result",
                "uVar2": "ushort_val",
                "puVar3": "pointer"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "__swsetup_r",
                "_fflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a80": {
            "entrypoint": "0x08009a80",
            "current_name": "sanitize_and_validate_stream_08009a80",
            "code": "\nuint sanitizeAndValidateStream_08009a80(undefined4 *streamPointerPtr,undefined4 *streamPtrPtr)\n\n{\n  int impurePtr;\n  uint returnValue;\n  ushort uVar3;\n  \n  impurePtr = impurePtr;\n  if ((impurePtr != 0) && (*(int *)(impurePtr + 0x18) == 0)) {\n    initializeStream(impurePtr);\n  }\n  if (streamPtrPtr == fakeStdinPtr) {\n    streamPtrPtr = *(undefined4 **)(impurePtr + 4);\n  }\n  else if (streamPtrPtr == (undefined4 *)fakeStdoutPtr) {\n    streamPtrPtr = *(undefined4 **)(impurePtr + 8);\n  }\n  else if (streamPtrPtr == (undefined4 *)fakeStderrPtr) {\n    streamPtrPtr = *(undefined4 **)(impurePtr + 0xc);\n  }\n  uVar3 = *(ushort *)(streamPtrPtr + 3);\n  returnValue = (uint)uVar3;\n  if (-1 < (int)(returnValue << 0x1c)) {\n    if (-1 < (int)(returnValue << 0x1b)) {\n      *streamPointerPtr = 9;\n      goto LAB_08009ab0;\n    }\n    if ((int)(returnValue << 0x1d) < 0) {\n      if ((undefined4 *)streamPtrPtr[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)streamPtrPtr[0xd] != streamPtrPtr + 0x11) {\n          freeStreamBuffer(streamPointerPtr);\n        }\n        streamPtrPtr[0xd] = 0;\n      }\n      *(ushort *)(streamPtrPtr + 3) = *(ushort *)(streamPtrPtr + 3) & 0xffdb;\n      streamBufferEnd = 0;\n      *streamPtrPtr = characterBuffer;\n    }\n    *(ushort *)(streamPtrPtr + 3) = *(ushort *)(streamPtrPtr + 3) | 8;\n  }\n  if ((characterBuffer == 0) && ((*(ushort *)(streamPtrPtr + 3) & 0x280) != 0x200)) {\n    createBufferedStream(streamPointerPtr,streamPtrPtr);\n  }\n  uVar3 = *(ushort *)(streamPtrPtr + 3);\n  returnValue = uVar3 & 1;\n  if ((uVar3 & 1) == 0) {\n    if (-1 < (int)((uint)uVar3 << 0x1e)) {\n      returnValue = bufferSize;\n    }\n    currentBufferSize = returnValue;\n  }\n  else {\n    currentBufferSize = 0;\n    negativeBufferSize = -bufferSize;\n  }\n  if (characterBuffer == 0) {\n    uVar3 = *(ushort *)(streamPtrPtr + 3);\n    returnValue = (int)(short)uVar3 & 0x80;\n    if (returnValue != 0) {\nLAB_08009ab0:\n      *(ushort *)(streamPtrPtr + 3) = uVar3 | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08009a80": "sanitize_and_validate_stream_08009a80",
                "param_1": "streamPointerPtr",
                "param_2": "streamPtrPtr",
                "iVar1": "impurePtr",
                "_impure_ptr": "impurePtr",
                "__sinit": "initializeStream",
                "&__sf_fake_stdin": "fakeStdinPtr",
                "_free_r": "freeStreamBuffer",
                "__smakebuf_r": "createBufferedStream",
                "&__sf_fake_stdout": "fakeStdoutPtr",
                "&__sf_fake_stderr": "fakeStderrPtr",
                "param_2[1]": "streamBufferEnd",
                "param_2[4]": "characterBuffer",
                "param_2[5]": "bufferSize",
                "param_2[2]": "currentBufferSize",
                "param_2[6]": "negativeBufferSize",
                "uVar2": "returnValue"
            },
            "calling": [
                "_vfiprintf_r",
                "__swbuf_r"
            ],
            "called": [
                "_free_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009b5c": {
            "entrypoint": "0x08009b5c",
            "current_name": "terminate_program_08009b5c",
            "code": "\n\n\nvoid terminate_program_08009b5c(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
            "renaming": {
                "FUN_08009b5c": "terminate_program_08009b5c"
            },
            "calling": [
                "__assert_func",
                "__throw_bad_function_call"
            ],
            "called": [
                "_exit",
                "raise"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009b6c": {
            "entrypoint": "0x08009b6c",
            "current_name": "process_data_08009b6c",
            "code": "\nundefined4 processData_08009b6c(uint *data,int *settings)\n\n{\n  int tempVar1;\n  int *tempVar2;\n  uint ushortValue;\n  ushort ushortFlag;\n  int tempVar3;\n  code *callbackFunc;\n  int loopVar;\n  uint tempVar4;\n  bool flag;\n  \n  ushortFlag = *(ushort *)(settings + 3);\n  ushortValue = (uint)ushortFlag;\n  if ((int)(ushortValue << 0x1c) < 0) {\n    tempVar1 = settings[4];\n    if (tempVar1 != 0) {\n      tempVar3 = ushortValue << 0x1e;\n      flag = tempVar3 != 0;\n      if (flag) {\n        tempVar3 = 0;\n      }\n      loopVar = *settings;\n      if (!flag) {\n        tempVar3 = settings[5];\n      }\n      *settings = tempVar1;\n      settings[2] = tempVar3;\n      for (loopVar = loopVar - tempVar1; 0 < loopVar; loopVar = loopVar - tempVar3) {\n        tempVar3 = (*(code *)settings[10])(data,settings[8],tempVar1,loopVar);\n        if (tempVar3 < 1) {\n          ushortFlag = *(ushort *)(settings + 3);\n          goto LAB_08009c62;\n        }\n        tempVar1 = tempVar1 + tempVar3;\n      }\n    }\n  }\n  else if (((0 < settings[1]) || (0 < settings[0x10])) &&\n          (callbackFunc = (code *)settings[0xb], callbackFunc != (code *)0x0)) {\n    tempVar4 = *data;\n    *data = 0;\n    if ((ushortFlag & 0x1000) == 0) {\n      tempVar1 = (*callbackFunc)(data,settings[8],ushortValue & 0x1000,1);\n      if ((tempVar1 == -1) && (ushortValue = *data, ushortValue != 0)) {\n        if ((ushortValue != 0x1d) && (ushortValue != 0x16)) {\n          *(ushort *)(settings + 3) = *(ushort *)(settings + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *data = tempVar4;\n        return 0;\n      }\n    }\n    else {\n      tempVar1 = settings[0x15];\n    }\n    if (((int)((uint)*(ushort *)(settings + 3) << 0x1d) < 0) &&\n       (tempVar1 = tempVar1 - settings[1], settings[0xd] != 0)) {\n      tempVar1 = tempVar1 - settings[0x10];\n    }\n    tempVar1 = (*(code *)settings[0xb])(data,settings[8],tempVar1,0);\n    ushortFlag = *(ushort *)(settings + 3);\n    if ((tempVar1 == -1) &&\n       ((0x1d < *data || (-1 < (int)((0x20400001U >> (*data & 0xff)) << 0x1f))))) {\nLAB_08009c62:\n      *(ushort *)(settings + 3) = ushortFlag | 0x40;\n      return 0xffffffff;\n    }\n    settings[1] = 0;\n    *settings = settings[4];\n    if (((int)((uint)ushortFlag << 0x13) < 0) && ((tempVar1 != -1 || (*data == 0)))) {\n      settings[0x15] = tempVar1;\n    }\n    tempVar2 = (int *)settings[0xd];\n    *data = tempVar4;\n    if (tempVar2 != (int *)0x0) {\n      if (tempVar2 != settings + 0x11) {\n        _free_r(data);\n      }\n      settings[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08009b6c": "process_data_08009b6c",
                "param_1": "data",
                "param_2": "settings",
                "iVar1": "tempVar1",
                "piVar2": "tempVar2",
                "uVar3": "ushortValue",
                "uVar4": "ushortFlag",
                "iVar5": "tempVar3",
                "pcVar6": "callbackFunc",
                "iVar7": "loopVar",
                "uVar8": "tempVar4",
                "bVar9": "flag"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009c7c": {
            "entrypoint": "0x08009c7c",
            "current_name": "check_and_flush_08009c7c",
            "code": "\nundefined4 check_and_flush_08009c7c(int stream,undefined4 *file,undefined4 buffer,undefined4 size)\n\n{\n  undefined4 result;\n  \n  if (file[4] != 0) {\n    if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n      __sinit();\n    }\n    if (file == &__sf_fake_stdin) {\n      file = *(undefined4 **)(stream + 4);\n    }\n    else if (file == (undefined4 *)&__sf_fake_stdout) {\n      file = *(undefined4 **)(stream + 8);\n    }\n    else if (file == (undefined4 *)&__sf_fake_stderr) {\n      file = *(undefined4 **)(stream + 0xc);\n    }\n    if (*(short *)(file + 3) != 0) {\n      result = __sflush_r(stream,file,buffer,size);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08009c7c": "check_and_flush_08009c7c",
                "param_1": "stream",
                "param_2": "file",
                "param_3": "buffer",
                "param_4": "size",
                "uVar1": "result"
            },
            "calling": [
                "__swbuf_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009cd0": {
            "entrypoint": "0x08009cd0",
            "current_name": "walk_function_reent_08009cd0",
            "code": "\nvoid walk_function_reent_08009cd0(undefined4 reent_structure)\n\n{\n  recursive_walk_reent(reent_structure,0x8009c7d);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009cd0": "walk_function_reent_08009cd0",
                "param_1": "reent_structure",
                "_fwalk_reent": "recursive_walk_reent"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009cdc": {
            "entrypoint": "0x08009cdc",
            "current_name": "initialize_data_struct_08009cdc",
            "code": "\nvoid initializeDataStruct_08009cdc(undefined4 *dataStruct,undefined2 value1,undefined2 value2)\n\n{\n  *dataStruct = 0;\n  dataStruct[1] = 0;\n  dataStruct[2] = 0;\n  *(undefined2 *)(dataStruct + 3) = value1;\n  dataStruct[0x19] = 0;\n  *(undefined2 *)((int)dataStruct + 0xe) = value2;\n  dataStruct[4] = 0;\n  dataStruct[5] = 0;\n  dataStruct[6] = 0;\n  memset(dataStruct + 0x17,0,8);\n  dataStruct[8] = dataStruct;\n  dataStruct[9] = 0x800a021;\n  dataStruct[10] = 0x800a043;\n  dataStruct[0xb] = 0x800a07b;\n  dataStruct[0xc] = 0x800a09f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009cdc": "initialize_data_struct_08009cdc",
                "param_1": "dataStruct",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009d24": {
            "entrypoint": "0x08009d24",
            "current_name": "allocate_memory_and_initialize_08009d24",
            "code": "\nundefined4 * allocateMemoryAndInitialize_08009d24(undefined4 size,int count)\n\n{\n  undefined4 *memoryPtr;\n  int totalSize;\n  \n  totalSize = (count + -1) * 0x68;\n  memoryPtr = (undefined4 *)_malloc_r(size,totalSize + 0x74);\n  if (memoryPtr != (undefined4 *)0x0) {\n    *memoryPtr = 0;\n    memoryPtr[1] = count;\n    memoryPtr[2] = memoryPtr + 3;\n    memset(memoryPtr + 3,0,totalSize + 0x68);\n  }\n  return memoryPtr;\n}\n\n",
            "renaming": {
                "FUN_08009d24": "allocate_memory_and_initialize_08009d24",
                "param_1": "size",
                "param_2": "count",
                "puVar1": "memoryPtr",
                "iVar2": "totalSize"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "memset",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009d50": {
            "entrypoint": "0x08009d50",
            "current_name": "initialize_data_08009d50",
            "code": "\nvoid initializeData_08009d50(undefined1 *dataPtr)\n\n{\n  undefined4 result;\n  undefined1 *impureDataPtr;\n  \n  if (*(int *)(dataPtr + 0x18) == 0) {\n    *(undefined4 *)(dataPtr + 0x48) = 0;\n    *(undefined4 *)(dataPtr + 0x4c) = 0;\n    *(undefined4 *)(dataPtr + 0x50) = 0;\n    impureDataPtr = &impure_data;\n    *(undefined4 *)(dataPtr + 0x28) = 0x8009cd1;\n    if (dataPtr == &impure_data) {\n      impureDataPtr = (undefined1 *)0x1;\n    }\n    if (dataPtr == &impure_data) {\n      *(undefined1 **)(dataPtr + 0x18) = impureDataPtr;\n    }\n    result = __sfp();\n    *(undefined4 *)(dataPtr + 4) = result;\n    result = __sfp(dataPtr);\n    *(undefined4 *)(dataPtr + 8) = result;\n    result = __sfp(dataPtr);\n    *(undefined4 *)(dataPtr + 0xc) = result;\n    std_isra_0(*(undefined4 *)(dataPtr + 4),4,0);\n    std_isra_0(*(undefined4 *)(dataPtr + 8),9,1);\n    std_isra_0(*(undefined4 *)(dataPtr + 0xc),0x12,2);\n    *(undefined4 *)(dataPtr + 0x18) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009d50": "initialize_data_08009d50",
                "param_1": "dataPtr",
                "uVar1": "result",
                "puVar2": "impureDataPtr"
            },
            "calling": [
                "__swsetup_r",
                "_fflush_r",
                "_vfiprintf_r",
                "__swbuf_r",
                "iprintf",
                "__sfp"
            ],
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009db0": {
            "entrypoint": "0x08009db0",
            "current_name": "initialize_data_structure_08009db0",
            "code": "\nint * initializeDataStructure_08009db0(undefined4 *errorFlag)\n\n{\n  int *currentPtr;\n  int *rowPtr;\n  int **dataStructure;\n  \n  if (DAT_200000ac == 0) {\n    __sinit(impureData);\n  }\n  dataStructure = (int **)&DAT_200000dc;\n  do {\n    rowPtr = dataStructure[2];\n    currentPtr = dataStructure[1];\n    while (currentPtr = (int *)((int)currentPtr + -1), -1 < (int)currentPtr) {\n      if (*(short *)(rowPtr + 3) == 0) {\n        *(undefined2 *)((int)rowPtr + 0xe) = 0xffff;\n        rowPtr[0x19] = 0;\n        *(undefined2 *)(rowPtr + 3) = 1;\n        *rowPtr = 0;\n        rowPtr[2] = 0;\n        rowPtr[1] = 0;\n        rowPtr[4] = 0;\n        rowPtr[5] = 0;\n        rowPtr[6] = 0;\n        memset(rowPtr + 0x17,0,8);\n        rowPtr[0xd] = 0;\n        rowPtr[0xe] = 0;\n        rowPtr[0x12] = 0;\n        rowPtr[0x13] = 0;\n        return rowPtr;\n      }\n      rowPtr = rowPtr + 0x1a;\n    }\n    if (*dataStructure == (int *)0x0) {\n      currentPtr = (int *)__sfmoreglue(errorFlag,4);\n      *dataStructure = currentPtr;\n      if (currentPtr == (int *)0x0) {\n        *errorFlag = 0xc;\n        return (int *)0x0;\n      }\n    }\n    dataStructure = (int **)*dataStructure;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08009db0": "initialize_data_structure_08009db0",
                "param_1": "errorFlag",
                "piVar1": "currentPtr",
                "piVar2": "rowPtr",
                "ppiVar3": "dataStructure",
                "&impure_data": "impureData"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__sfmoreglue",
                "memset",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e28": {
            "entrypoint": "0x08009e28",
            "current_name": "process_elements_08009e28",
            "code": "\nuint processElements_08009e28(int input,code *callback,undefined4 param1,undefined4 param2)\n\n{\n  uint result;\n  int count;\n  int *elementPtr;\n  int elementAddress;\n  uint aggregateResult;\n  int elementCount;\n  \n  aggregateResult = 0;\n  for (elementPtr = (int *)(input + 0x48); elementPtr != (int *)0x0; elementPtr = (int *)*elementPtr) {\n    elementAddress = elementPtr[2];\n    elementCount = elementPtr[1];\n    while (elementCount = elementCount + -1, -1 < elementCount) {\n      if ((1 < *(ushort *)(elementAddress + 0xc)) && (count = *(short *)(elementAddress + 0xe) + 1, count != 0)) {\n        result = (*callback)(input,elementAddress,param1,count,param2);\n        aggregateResult = aggregateResult | result;\n      }\n      elementAddress = elementAddress + 0x68;\n    }\n  }\n  return aggregateResult;\n}\n\n",
            "renaming": {
                "FUN_08009e28": "process_elements_08009e28",
                "param_1": "input",
                "param_2": "callback",
                "param_3": "param1",
                "param_4": "param2",
                "uVar1": "result",
                "iVar2": "count",
                "piVar3": "elementPtr",
                "iVar4": "elementAddress",
                "uVar5": "aggregateResult",
                "iVar6": "elementCount"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e64": {
            "entrypoint": "0x08009e64",
            "current_name": "check_file_status_08009e64",
            "code": "\nundefined4 checkFileStatus_08009e64(undefined4 fileDescriptor,int buffer,undefined4 *result,uint *isExecutable)\n\n{\n  int status;\n  undefined4 accessFlags;\n  undefined statusBuffer [4];\n  uint fileMode;\n  \n  if ((*(short *)(buffer + 0xe) < 0) ||\n     (status = _fstat_r(fileDescriptor,(int)*(short *)(buffer + 0xe),statusBuffer), status < 0)) {\n    *isExecutable = 0;\n    if ((int)((uint)*(ushort *)(buffer + 0xc) << 0x18) < 0) {\n      accessFlags = 0x40;\n      goto LAB_08009ea4;\n    }\n  }\n  else {\n    *isExecutable = (uint)((fileMode & 0xf000) == 0x2000);\n  }\n  accessFlags = 0x400;\nLAB_08009ea4:\n  *result = accessFlags;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08009e64": "check_file_status_08009e64",
                "param_1": "fileDescriptor",
                "param_2": "buffer",
                "param_3": "result",
                "param_4": "isExecutable",
                "iVar1": "status",
                "uVar2": "accessFlags",
                "auStack_4c": "statusBuffer",
                "local_48": "fileMode"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009eac": {
            "entrypoint": "0x08009eac",
            "current_name": "decode_and_update_08009eac",
            "code": "\nvoid decode_and_update_08009eac(int input_buffer,int *output_buffer)\n\n{\n  ushort updated_value;\n  int allocated_buffer;\n  int input_length;\n  int *local_variables;\n  \n  if (-1 < (int)((uint)*(ushort *)(output_buffer + 3) << 0x1e)) {\n    input_length = input_buffer;\n    local_variables = output_buffer;\n    updated_value = __swhatbuf_r(input_buffer,output_buffer,&input_length,&local_variables);\n    allocated_buffer = _malloc_r(input_buffer,input_length);\n    if (allocated_buffer != 0) {\n      *(undefined4 *)(input_buffer + 0x28) = 0x8009cd1;\n      *output_buffer = allocated_buffer;\n      *(ushort *)(output_buffer + 3) = *(ushort *)(output_buffer + 3) | 0x80;\n      output_buffer[4] = allocated_buffer;\n      output_buffer[5] = input_length;\n      if ((local_variables != (int *)0x0) &&\n         (allocated_buffer = _isatty_r(input_buffer,(int)*(short *)((int)output_buffer + 0xe)), allocated_buffer != 0)) {\n        *(ushort *)(output_buffer + 3) = *(ushort *)(output_buffer + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(output_buffer + 3) = updated_value | *(ushort *)(output_buffer + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(output_buffer + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(output_buffer + 3) = *(ushort *)(output_buffer + 3) & 0xfffc | 2;\n  }\n  *output_buffer = (int)output_buffer + 0x47;\n  output_buffer[4] = (int)output_buffer + 0x47;\n  output_buffer[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009eac": "decode_and_update_08009eac",
                "param_1": "input_buffer",
                "param_2": "output_buffer",
                "uVar1": "updated_value",
                "iVar2": "allocated_buffer",
                "local_18": "input_length",
                "local_14": "local_variables"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "__swhatbuf_r",
                "_isatty_r",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009f2c": {
            "entrypoint": "0x08009f2c",
            "current_name": "find_first_byte_in_memory_08009f2c",
            "code": "\nvoid * findFirstByteInMemory_08009f2c(void *memory,int byteToFind,size_t memorySize)\n\n{\n  byte *bytePointer;\n  byte *currentBytePointer;\n  \n  bytePointer = (byte *)memory;\n  do {\n    currentBytePointer = bytePointer;\n    if (currentBytePointer == (byte *)(memorySize + (int)memory)) {\n      return (void *)0x0;\n    }\n    bytePointer = currentBytePointer + 1;\n  } while ((uint)*currentBytePointer != (byteToFind & 0xffU));\n  return currentBytePointer;\n}\n\n",
            "renaming": {
                "FUN_08009f2c": "find_first_byte_in_memory_08009f2c",
                "__s": "memory",
                "__c": "byteToFind",
                "__n": "memorySize",
                "pbVar1": "bytePointer",
                "pbVar2": "currentBytePointer"
            },
            "calling": [
                "_printf_i",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009f48": {
            "entrypoint": "0x08009f48",
            "current_name": "FUNC_08009f48",
            "code": "\nvoid FUNC_08009f48(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009f48": "FUNC_08009f48"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009f4a": {
            "entrypoint": "0x08009f4a",
            "current_name": "FUNC_08009f4a",
            "code": "\nvoid FUNC_08009f4a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009f4a": "FUNC_08009f4a"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009f4c": {
            "entrypoint": "0x08009f4c",
            "current_name": "resize_and_copy_memory_08009f4c",
            "code": "\nvoid * resizeAndCopyMemory_08009f4c(undefined4 mem_ptr,void *old_ptr,uint old_size,undefined4 new_size)\n\n{\n  void *new_ptr;\n  uint usable_size;\n  \n  if (old_ptr != (void *)0x0) {\n    if (old_size == 0) {\n      _free_r();\n      new_ptr = (void *)0x0;\n    }\n    else {\n      usable_size = _malloc_usable_size_r();\n      new_ptr = old_ptr;\n      if ((usable_size < old_size) && (new_ptr = (void *)_malloc_r(mem_ptr,old_size), new_ptr != (void *)0x0))\n      {\n        memcpy(new_ptr,old_ptr,old_size);\n        _free_r(mem_ptr,old_ptr);\n      }\n    }\n    return new_ptr;\n  }\n  new_ptr = (void *)_malloc_r(mem_ptr,old_size,old_size,new_size);\n  return new_ptr;\n}\n\n",
            "renaming": {
                "FUN_08009f4c": "resize_and_copy_memory_08009f4c",
                "param_1": "mem_ptr",
                "param_2": "old_ptr",
                "param_3": "old_size",
                "param_4": "new_size",
                "pvVar1": "new_ptr",
                "uVar2": "usable_size"
            },
            "calling": [
                "realloc"
            ],
            "called": [
                "_free_r",
                "_malloc_usable_size_r",
                "_malloc_r",
                "memcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009f98": {
            "entrypoint": "0x08009f98",
            "current_name": "execute_command_08009f98",
            "code": "\nundefined4 execute_command_08009f98(undefined4 *status,uint command_id,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t pid;\n  undefined4 result;\n  int command_table;\n  code *command;\n  \n  if (0x1f < command_id) {\n    *status = 0x16;\n    return 0xffffffff;\n  }\n  command_table = status[0x11];\n  if ((command_table != 0) && (command = *(code **)(command_table + command_id * 4), command != (code *)0x0)) {\n    if (command != (code *)0x1) {\n      if (command == (code *)0xffffffff) {\n        *status = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(command_table + command_id * 4) = 0;\n      (*command)(command_id);\n    }\n    return 0;\n  }\n  pid = _getpid_r();\n  result = _kill_r(status,pid,command_id,param_4);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009f98": "execute_command_08009f98",
                "param_1": "status",
                "param_2": "command_id",
                "_Var1": "pid",
                "uVar2": "result",
                "iVar3": "command_table",
                "pcVar4": "command"
            },
            "calling": [
                "raise"
            ],
            "called": [
                "_kill_r",
                "_getpid_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009fe8": {
            "entrypoint": "0x08009fe8",
            "current_name": "handle_signal_08009fe8",
            "code": "\nint handle_signal_08009fe8(int signal_code)\n\n{\n  int result;\n  \n  result = _raise_r(_impure_ptr,signal_code);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009fe8": "handle_signal_08009fe8",
                "__sig": "signal_code",
                "iVar1": "result"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_raise_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009ff8": {
            "entrypoint": "0x08009ff8",
            "current_name": "kill_process_08009ff8",
            "code": "\nvoid kill_process_08009ff8(int *error_code,__pid_t process_id,int signal_number)\n\n{\n  int kill_result;\n  \n  errno = 0;\n  kill_result = _kill(process_id,signal_number);\n  if ((kill_result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009ff8": "kill_process_08009ff8",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal_number",
                "iVar1": "kill_result"
            },
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a01c": {
            "entrypoint": "0x0800a01c",
            "current_name": "FUN_0800a01c",
            "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a020": {
            "entrypoint": "0x0800a020",
            "current_name": "update_read_value_0800a020",
            "code": "\nvoid updateReadValue_0800a020(undefined4 buffer,int data)\n\n{\n  int readResult;\n  uint updatedValue;\n  bool isReadSuccessful;\n  \n  readResult = _read_r(buffer,(int)*(short *)(data + 0xe));\n  isReadSuccessful = -1 < readResult;\n  if (isReadSuccessful) {\n    updatedValue = *(int *)(data + 0x54) + readResult;\n  }\n  else {\n    updatedValue = *(ushort *)(data + 0xc) & 0xffffefff;\n  }\n  if (isReadSuccessful) {\n    *(uint *)(data + 0x54) = updatedValue;\n  }\n  if (!isReadSuccessful) {\n    *(short *)(data + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a020": "update_read_value_0800a020",
                "param_1": "buffer",
                "param_2": "data",
                "iVar1": "readResult",
                "uVar2": "updatedValue",
                "bVar3": "isReadSuccessful"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a042": {
            "entrypoint": "0x0800a042",
            "current_name": "update_file_if_negative_value_0800a042",
            "code": "\nvoid updateFileIfNegativeValue_0800a042(unknown4 fileDescriptor,integer bufferAddress,unknown4 dataAddress,unknown4 dataSize)\n\n{\n  if ((integer)((uinteger)*(unsignedShort *)(bufferAddress + 0xc) << 0x17) < 0) {\n    repositionFilePointer(fileDescriptor,(integer)*(short *)(bufferAddress + 0xe),0,2);\n  }\n  *(unsignedShort *)(bufferAddress + 0xc) = *(unsignedShort *)(bufferAddress + 0xc) & 0xefff;\n  writeToFile(fileDescriptor,(integer)*(short *)(bufferAddress + 0xe),dataAddress,dataSize);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a042": "update_file_if_negative_value_0800a042",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress",
                "param_3": "dataAddress",
                "param_4": "dataSize",
                "ushort": "unsignedShort",
                "int": "integer",
                "undefined4": "unknown4",
                "_lseek_r": "repositionFilePointer",
                "_write_r": "writeToFile"
            },
            "calling": [],
            "called": [
                "_lseek_r",
                "_write_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a07a": {
            "entrypoint": "0x0800a07a",
            "current_name": "seek_and_set_flag_0800a07a",
            "code": "\nvoid seekAndSetFlag_0800a07a(undefined4 fileDescriptor,int structPtr)\n\n{\n  int seekResult;\n  ushort flag;\n  bool isSeekError;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(structPtr + 0xe));\n  isSeekError = seekResult == -1;\n  if (isSeekError) {\n    flag = *(ushort *)(structPtr + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(structPtr + 0x54) = seekResult;\n    flag = *(ushort *)(structPtr + 0xc) | 0x1000;\n  }\n  if (isSeekError) {\n    *(ushort *)(structPtr + 0xc) = flag;\n  }\n  if (!isSeekError) {\n    *(ushort *)(structPtr + 0xc) = flag;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a07a": "seek_and_set_flag_0800a07a",
                "param_1": "fileDescriptor",
                "param_2": "structPtr",
                "iVar1": "seekResult",
                "uVar2": "flag",
                "bVar3": "isSeekError"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a09e": {
            "entrypoint": "0x0800a09e",
            "current_name": "close_file_descriptor_0800a09e",
            "code": "\nvoid closeFileDescriptor_0800a09e(undefined4 fileDescriptor,int bufferAddress)\n\n{\n  _close_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a09e": "close_file_descriptor_0800a09e",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a0a8": {
            "entrypoint": "0x0800a0a8",
            "current_name": "write_to_stream_0800a0a8",
            "code": "\nvoid writeToStream_0800a0a8(int *errorFlag,int streamFileDescriptor,char *dataBuffer,int dataLength)\n\n{\n  int writeResult;\n  \n  errno = 0;\n  writeResult = _write(streamFileDescriptor,dataBuffer,dataLength);\n  if ((writeResult == -1) && (errno != 0)) {\n    *errorFlag = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a0a8": "write_to_stream_0800a0a8",
                "param_1": "errorFlag",
                "param_2": "streamFileDescriptor",
                "param_3": "dataBuffer",
                "param_4": "dataLength",
                "iVar1": "writeResult"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a0cc": {
            "entrypoint": "0x0800a0cc",
            "current_name": "close_file_0800a0cc",
            "code": "\nvoid closeFile_0800a0cc(int *errorPointer,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errno = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errno != 0)) {\n    *errorPointer = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a0cc": "close_file_0800a0cc",
                "param_1": "errorPointer",
                "param_2": "fileDescriptor",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a0ec": {
            "entrypoint": "0x0800a0ec",
            "current_name": "get_file_status_0800a0ec",
            "code": "\nvoid get_file_status_0800a0ec(int *error_code_ptr,int file_descriptor,stat *stat_buffer)\n\n{\n  int status;\n  \n  err_num = 0;\n  status = _fstat(file_descriptor,stat_buffer);\n  if ((status == -1) && (err_num != 0)) {\n    *error_code_ptr = err_num;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a0ec": "get_file_status_0800a0ec",
                "param_1": "error_code_ptr",
                "param_2": "file_descriptor",
                "param_3": "stat_buffer",
                "iVar1": "status",
                "errno": "err_num"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a110": {
            "entrypoint": "0x0800a110",
            "current_name": "check_is_terminal_0800a110",
            "code": "\nvoid checkIsTerminal_0800a110(int *error,int fileDescriptor)\n\n{\n  int isTerminal;\n  \n  lastError = 0;\n  isTerminal = _isatty(fileDescriptor);\n  if ((isTerminal == -1) && (lastError != 0)) {\n    *error = lastError;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a110": "check_is_terminal_0800a110",
                "param_1": "error",
                "param_2": "fileDescriptor",
                "iVar1": "isTerminal",
                "errno": "lastError"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a130": {
            "entrypoint": "0x0800a130",
            "current_name": "set_error_code_if_seek_fails_0800a130",
            "code": "\nvoid setErrorCodeIfSeekFails_0800a130(int *errorPtr,int fileDescriptor,__off_t offset,int whence)\n\n{\n  __off_t seekResult;\n  \n  errno = 0;\n  seekResult = _lseek(fileDescriptor,offset,whence);\n  if ((seekResult == -1) && (errno != 0)) {\n    *errorPtr = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a130": "set_error_code_if_seek_fails_0800a130",
                "param_1": "errorPtr",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "seekResult"
            },
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a154": {
            "entrypoint": "0x0800a154",
            "current_name": "calculate_value_0800a154",
            "code": "\nint calculateValue_0800a154(undefined4 value1,int value2)\n\n{\n  int result;\n  \n  result = *(int *)(value2 + -4) + -4;\n  if (*(int *)(value2 + -4) < 0) {\n    result = result + *(int *)(value2 + result);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800a154": "calculate_value_0800a154",
                "param_1": "value1",
                "param_2": "value2",
                "iVar1": "result"
            },
            "calling": [
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a168": {
            "entrypoint": "0x0800a168",
            "current_name": "read_from_file_0800a168",
            "code": "\nvoid read_from_file_0800a168(int *error_code,int file_descriptor,char *buffer,int num_bytes)\n\n{\n  int bytes_read;\n  \n  errno = 0;\n  bytes_read = _read(file_descriptor,buffer,num_bytes);\n  if ((bytes_read == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a168": "read_from_file_0800a168",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "num_bytes",
                "iVar1": "bytes_read"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a18c": {
            "entrypoint": "0x0800a18c",
            "current_name": "terminate_program_0800a18c",
            "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::terminate_program_0800a18c(void)\n\n{\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_0800a18c": "terminate_program_0800a18c"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a194": {
            "entrypoint": "0x0800a194",
            "current_name": "initialize_locale_data_0800a194",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeLocaleData_0800a194(void)\n\n{\n  if (-1 < moneypunct<char,false>::id << 0x1f) {\n    moneypunct<char,false>::id = 1;\n  }\n  if (-1 < moneypunct<char,true>::id << 0x1f) {\n    moneypunct<char,true>::id = 1;\n  }\n  if (-1 < money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < numpunct<char>::id << 0x1f) {\n    numpunct<char>::id = 1;\n  }\n  if (-1 < num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __timepunct<char>::id << 0x1f) {\n    __timepunct<char>::id = 1;\n  }\n  if (-1 < time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < messages<char>::id << 0x1f) {\n    messages<char>::id = 1;\n  }\n  if (-1 < collate<char>::id << 0x1f) {\n    collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a194": "initialize_locale_data_0800a194"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a258": {
            "entrypoint": "0x0800a258",
            "current_name": "initialize_ctype_by_name_0800a258",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeCtypeByName_0800a258(void)\n\n{\n  if (-1 < moneypunct<wchar_t,false>::id << 0x1f) {\n    moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < moneypunct<wchar_t,true>::id << 0x1f) {\n    moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < numpunct<wchar_t>::id << 0x1f) {\n    numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __timepunct<wchar_t>::id << 0x1f) {\n    __timepunct<wchar_t>::id = 1;\n  }\n  if (-1 < time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < messages<wchar_t>::id << 0x1f) {\n    messages<wchar_t>::id = 1;\n  }\n  if (-1 < collate<wchar_t>::id << 0x1f) {\n    collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a258": "initialize_ctype_by_name_0800a258"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a31c": {
            "entrypoint": "0x0800a31c",
            "current_name": "initialize_c_type_by_name_0800a31c",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeCTypeByName_0800a31c(void)\n\n{\n  if (-1 < __cxx11::moneypunct<wchar_t,false>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<wchar_t,true>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<wchar_t>::id << 0x1f) {\n    __cxx11::numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<wchar_t>::id << 0x1f) {\n    __cxx11::messages<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::collate<wchar_t>::id << 0x1f) {\n    __cxx11::collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a31c": "initialize_c_type_by_name_0800a31c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a3a0": {
            "entrypoint": "0x0800a3a0",
            "current_name": "initialize_standard_locales_0800a3a0",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeStandardLocales_0800a3a0(void)\n\n{\n  if (-1 < __cxx11::moneypunct<char,false>::id << 0x1f) {\n    __cxx11::moneypunct<char,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<char,true>::id << 0x1f) {\n    __cxx11::moneypunct<char,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<char>::id << 0x1f) {\n    __cxx11::numpunct<char>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f\n     ) {\n    __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<char>::id << 0x1f) {\n    __cxx11::messages<char>::id = 1;\n  }\n  if (-1 < __cxx11::collate<char>::id << 0x1f) {\n    __cxx11::collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a3a0": "initialize_standard_locales_0800a3a0"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a424": {
            "entrypoint": "0x0800a424",
            "current_name": "FUNC_0800a424",
            "code": "\nvoid FUNC_0800a424(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a424": "FUNC_0800a424"
            },
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800a430": {
            "entrypoint": "0x0800a430",
            "current_name": "FUNC_0800a430",
            "code": "\nvoid FUNC_0800a430(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a430": "FUNC_0800a430"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 237129,
    "layers": [
        [
            "FUN_0800010c",
            "FUN_08000178",
            "FUN_08000188",
            "FUN_0800018c",
            "FUN_080001a8",
            "FUN_08000214",
            "FUN_080002ec",
            "FUN_08000488",
            "FUN_080004d4",
            "FUN_08000500",
            "FUN_08000588",
            "FUN_080005e0",
            "FUN_080005f8",
            "FUN_08000a64",
            "FUN_08000aec",
            "FUN_08000be8",
            "FUN_08000c18",
            "FUN_08000ef8",
            "FUN_08001b48",
            "FUN_08001be8",
            "FUN_08001bf8",
            "FUN_08001c08",
            "FUN_08001c18",
            "FUN_08001cd0",
            "FUN_080022f8",
            "FUN_08002400",
            "FUN_0800242c",
            "FUN_08002444",
            "FUN_08002578",
            "FUN_08002580",
            "FUN_080025ac",
            "FUN_08002634",
            "FUN_08002644",
            "FUN_0800267c",
            "FUN_080026b0",
            "FUN_080026f8",
            "FUN_0800270c",
            "FUN_08002720",
            "FUN_0800274c",
            "FUN_08002774",
            "FUN_08002798",
            "FUN_080027f0",
            "FUN_0800288c",
            "FUN_0800291c",
            "FUN_08002948",
            "FUN_08002968",
            "FUN_08002a1c",
            "FUN_08002a26",
            "FUN_08002a30",
            "FUN_08002a58",
            "FUN_08002ac0",
            "FUN_08002acc",
            "FUN_08002b00",
            "FUN_08002b68",
            "FUN_08002c00",
            "FUN_08002c14",
            "FUN_08002c1e",
            "FUN_08002c2c",
            "FUN_08002c40",
            "FUN_08002c54",
            "FUN_08002c68",
            "FUN_08002c7c",
            "FUN_08002c90",
            "FUN_08002ca4",
            "FUN_08002cb8",
            "FUN_08002cd0",
            "FUN_08002ce0",
            "FUN_08002dbc",
            "FUN_08002ddc",
            "FUN_08002dea",
            "FUN_08002df6",
            "FUN_08002e1a",
            "FUN_08002e26",
            "FUN_08002e44",
            "FUN_08002ec4",
            "FUN_08002ed2",
            "FUN_08002ef2",
            "FUN_08002efe",
            "FUN_08002f0a",
            "FUN_08002f14",
            "FUN_08002f1e",
            "FUN_08002f2c",
            "FUN_08002f84",
            "FUN_08002f94",
            "FUN_08002fa0",
            "FUN_08002fa8",
            "FUN_08002fba",
            "FUN_08002fc2",
            "FUN_08002fca",
            "FUN_08003002",
            "FUN_08003048",
            "FUN_0800306c",
            "FUN_0800307a",
            "FUN_08003106",
            "FUN_0800314e",
            "FUN_08003154",
            "FUN_08003158",
            "FUN_0800319e",
            "FUN_080031ce",
            "FUN_0800322c",
            "FUN_0800325a",
            "FUN_080032a2",
            "FUN_080032bc",
            "FUN_08003306",
            "FUN_08003346",
            "FUN_08003350",
            "FUN_08003366",
            "FUN_08003370",
            "FUN_08003376",
            "FUN_080033a8",
            "FUN_080033cc",
            "FUN_0800344a",
            "FUN_08003474",
            "FUN_080035b8",
            "FUN_08003658",
            "FUN_080036a0",
            "FUN_080036a2",
            "FUN_080036ac",
            "FUN_080036d8",
            "FUN_08003724",
            "FUN_08003748",
            "FUN_08003760",
            "FUN_0800376c",
            "FUN_080038dc",
            "FUN_080038e4",
            "FUN_08003a1c",
            "FUN_08003a20",
            "FUN_08003aa0",
            "FUN_08003b8c",
            "FUN_08003bd8",
            "FUN_08003ce8",
            "FUN_08003de4",
            "FUN_08003e20",
            "FUN_08003f0c",
            "FUN_08003f30",
            "FUN_08003f94",
            "FUN_08003fb0",
            "FUN_08003fd8",
            "FUN_08004004",
            "FUN_08004024",
            "FUN_08004046",
            "FUN_08004050",
            "FUN_080040e8",
            "FUN_080042d4",
            "FUN_080042e2",
            "FUN_080042f0",
            "FUN_0800430c",
            "FUN_08004396",
            "FUN_080043a2",
            "FUN_0800457c",
            "FUN_0800459c",
            "FUN_080045c0",
            "FUN_08004728",
            "FUN_080047f4",
            "FUN_080048c8",
            "FUN_08004954",
            "FUN_080049e0",
            "FUN_08004a24",
            "FUN_08004a76",
            "FUN_08004ac2",
            "FUN_08004aec",
            "FUN_08004b82",
            "FUN_08004ccc",
            "FUN_08004d6c",
            "FUN_08004e3c",
            "FUN_08004f3c",
            "FUN_08005084",
            "FUN_08005188",
            "FUN_080052f0",
            "FUN_080053cc",
            "FUN_0800542a",
            "FUN_08005430",
            "FUN_08005434",
            "FUN_08005460",
            "FUN_08005840",
            "FUN_080058ac",
            "FUN_08005a1c",
            "FUN_08005a28",
            "FUN_08005a48",
            "FUN_08005a68",
            "FUN_08005aa4",
            "FUN_08005bb8",
            "FUN_08005cb4",
            "FUN_08005cec",
            "FUN_08005d48",
            "FUN_08005dac",
            "FUN_08005df4",
            "FUN_08005e2e",
            "FUN_08005e6e",
            "FUN_08005fe8",
            "FUN_08006060",
            "FUN_08006092",
            "FUN_080060c4",
            "FUN_08006128",
            "FUN_08006186",
            "FUN_08006262",
            "FUN_08006280",
            "FUN_080062f4",
            "FUN_08006390",
            "FUN_080063c0",
            "FUN_08006420",
            "FUN_0800643c",
            "FUN_08006460",
            "FUN_080064b0",
            "FUN_080064cc",
            "FUN_08006538",
            "FUN_080066e8",
            "FUN_0800674e",
            "FUN_080067ac",
            "FUN_0800688e",
            "FUN_080068d6",
            "FUN_08006932",
            "FUN_0800694c",
            "FUN_080069ec",
            "FUN_08006b0c",
            "FUN_08006b1c",
            "FUN_08006b28",
            "FUN_08006b3e",
            "FUN_08006b5c",
            "FUN_08006b7c",
            "FUN_08006bb8",
            "FUN_08006c60",
            "FUN_08006c7c",
            "FUN_08006ca8",
            "FUN_08006d24",
            "FUN_08006d80",
            "FUN_08006e68",
            "FUN_08007110",
            "FUN_08007118",
            "FUN_080071e4",
            "FUN_0800723c",
            "FUN_08007246",
            "FUN_08007258",
            "FUN_080072d8",
            "FUN_080072f0",
            "FUN_080072fa",
            "FUN_08007306",
            "FUN_08007320",
            "FUN_08007332",
            "FUN_0800734a",
            "FUN_0800735a",
            "FUN_08007376",
            "FUN_0800738a",
            "FUN_080073ae",
            "FUN_080073c0",
            "FUN_080073d8",
            "FUN_080073e8",
            "FUN_080073ec",
            "FUN_08007438",
            "FUN_080074e0",
            "FUN_08007544",
            "FUN_08007594",
            "FUN_080075dc",
            "FUN_08007648",
            "FUN_080076e0",
            "FUN_08007708",
            "FUN_08007710",
            "FUN_08007718",
            "FUN_0800771c",
            "FUN_08007736",
            "FUN_08007744",
            "FUN_0800774a",
            "FUN_08007750",
            "FUN_08007760",
            "FUN_08007774",
            "FUN_08007788",
            "FUN_0800779c",
            "FUN_080077b0",
            "FUN_08007e74",
            "FUN_08007ede",
            "FUN_08007f0e",
            "FUN_08007f78",
            "FUN_08007f7c",
            "FUN_08007f8e",
            "FUN_08007fa0",
            "FUN_08007ff0",
            "FUN_08008020",
            "FUN_08008038",
            "FUN_08008048",
            "FUN_08008058",
            "FUN_08008068",
            "FUN_08008078",
            "FUN_080084b0",
            "FUN_08008500",
            "FUN_080085b8",
            "FUN_080085dc",
            "FUN_08008600",
            "FUN_0800863c",
            "FUN_08008694",
            "FUN_080086e8",
            "FUN_0800870c",
            "FUN_08008730",
            "FUN_0800877c",
            "FUN_080087bc",
            "FUN_080087d4",
            "FUN_080087ec",
            "FUN_08008804",
            "FUN_08008840",
            "FUN_08008846",
            "FUN_08008850",
            "FUN_08008854",
            "FUN_08008858",
            "FUN_0800885c",
            "FUN_08008868",
            "FUN_0800886c",
            "FUN_0800887c",
            "FUN_08008880",
            "FUN_080088e0",
            "FUN_08008990",
            "FUN_08008a24",
            "FUN_08008a6c",
            "FUN_08008abc",
            "FUN_08008ac6",
            "FUN_08008afa",
            "FUN_08008b0e",
            "FUN_08008b2a",
            "FUN_08008b52",
            "FUN_08008b66",
            "FUN_08008ba4",
            "FUN_08008c20",
            "FUN_08008c44",
            "FUN_08008d00",
            "FUN_08008d18",
            "FUN_08008d30",
            "FUN_08008d8c",
            "FUN_08008db0",
            "FUN_08008dbe",
            "FUN_08008df8",
            "FUN_08008e14",
            "FUN_08008e40",
            "FUN_08008e4e",
            "FUN_08008e72",
            "FUN_08008e7c",
            "FUN_08008ed6",
            "FUN_08008eec",
            "FUN_08008ef4",
            "FUN_08008f0e",
            "FUN_08008f1c",
            "FUN_08008f3c",
            "FUN_08008f50",
            "FUN_08008f78",
            "FUN_08009024",
            "FUN_0800902e",
            "FUN_08009038",
            "FUN_08009042",
            "FUN_0800904c",
            "FUN_08009056",
            "FUN_0800906c",
            "FUN_08009084",
            "FUN_08009094",
            "FUN_080090b4",
            "FUN_080090c2",
            "FUN_080090cc",
            "FUN_08009108",
            "FUN_08009124",
            "FUN_08009148",
            "FUN_08009190",
            "FUN_080091a0",
            "FUN_080091b0",
            "FUN_080091c6",
            "FUN_080091d8",
            "FUN_08009270",
            "FUN_0800932c",
            "FUN_08009358",
            "FUN_0800937c",
            "FUN_080095a8",
            "FUN_08009698",
            "FUN_080098d8",
            "FUN_08009908",
            "FUN_08009918",
            "FUN_08009938",
            "FUN_08009954",
            "FUN_0800997e",
            "FUN_080099a4",
            "FUN_080099dc",
            "FUN_08009a80",
            "FUN_08009b5c",
            "FUN_08009b6c",
            "FUN_08009c7c",
            "FUN_08009cd0",
            "FUN_08009cdc",
            "FUN_08009d24",
            "FUN_08009d50",
            "FUN_08009db0",
            "FUN_08009e28",
            "FUN_08009e64",
            "FUN_08009eac",
            "FUN_08009f2c",
            "FUN_08009f4c",
            "FUN_08009f98",
            "FUN_08009fe8",
            "FUN_08009ff8",
            "FUN_0800a020",
            "FUN_0800a042",
            "FUN_0800a07a",
            "FUN_0800a09e",
            "FUN_0800a0a8",
            "FUN_0800a0cc",
            "FUN_0800a0ec",
            "FUN_0800a110",
            "FUN_0800a130",
            "FUN_0800a154",
            "FUN_0800a168",
            "FUN_0800a18c",
            "FUN_0800a194",
            "FUN_0800a258",
            "FUN_0800a31c",
            "FUN_0800a3a0"
        ]
    ],
    "locked_functions": []
}