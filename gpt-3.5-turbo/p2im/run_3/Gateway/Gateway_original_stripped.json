{
    "functions": {
        "FUN_08007246": {
            "renaming": {
                "FUN_08007246": "increment_system_tick_08007246"
            },
            "code": "void increment_system_tick_08007246(void)\n{\n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  noOsSystickHandler();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007246",
            "calling": [],
            "imported": false,
            "current_name": "increment_system_tick_08007246"
        },
        "FUN_0800a042": {
            "renaming": {
                "FUN_0800a042": "write_data_to_file_0800a042",
                "param_1": "file",
                "param_2": "data_pointer",
                "param_3": "data",
                "param_4": "size",
                "*PTR_0000000c": "data_size",
                "*PTR_0000000e": "data_offset"
            },
            "code": "void write_data_to_file_0800a042(FILE* file, int data_pointer, void* data, size_t size) {\n  unsigned short* *PTR_0000000c = (unsigned short*)(data_pointer + 0xc);\n  if((int)((uint)(**PTR_0000000c) << 0x17) < 0) {\n    _lseek_r(file, (int)*(short*)(data_pointer + 0xe), 0, 2);\n  }\n  **PTR_0000000c = **PTR_0000000c & 0xefff;\n  _write_r(file, (int)*(short*)(data_pointer + 0xe), data, size);\n  return;\n}",
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a042",
            "calling": [],
            "imported": false,
            "current_name": "write_data_to_file_0800a042"
        },
        "FUN_08008e4e": {
            "renaming": {
                "FUN_08008e4e": "print_buffer_08008e4e",
                "this": "print_obj",
                "buffer": "buffer",
                "size": "buffer_size",
                "pPVar1": "print_ptr",
                "sVar2": "bytes_printed"
            },
            "code": "size_t __thiscall print_buffer_08008e4e(Print *print_obj, uint8_t *buffer, size_t buffer_size) {\n  Print *print_ptr;\n  size_t bytes_printed = 0;\n  print_ptr = print_obj;\n  while(buffer_size > 0) {\n    if (print_ptr->_vptr_Print == 0) {\n      return bytes_printed;\n    }\n    print_ptr = (Print *)(*print_ptr->_vptr_Print)(print_ptr, (uint)*buffer);\n    if (print_ptr == 0) {\n      break;\n    }\n    bytes_printed++;\n    buffer++;\n    buffer_size--;\n  }\n  return bytes_printed;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e4e",
            "calling": [],
            "imported": false,
            "current_name": "print_buffer_08008e4e"
        },
        "FUN_08008694": {
            "renaming": {
                "FUN_08008694": "setup_serial_08008694",
                "obj": "serial_obj",
                "callback": "callback_fn",
                "bVar1": "index",
                "PTR_tx_callback_080086dc": "tx_callback_ptr",
                "PTR_tx_callback_obj_080086e0": "tx_callback_obj_ptr",
                "PTR_uart_handlers_080086e4": "uart_handler_ptr",
                "irq": "serial_obj->irq",
                "tx_buff": "serial_obj->tx_buff",
                "tx_tail": "serial_obj->tx_tail"
            },
            "code": "void setup_serial_08008694(serial_t *serial_obj, _func_int_serial_t_ptr *callback_fn){\n  if (serial_obj != NULL){\n    byte index = serial_obj->index;\n    _func_int_serial_t_ptr **PTR_tx_callback_080086dc = PTR_tx_callback_080086dc + (uint)index * 4;\n    *PTR_tx_callback_080086dc = callback_fn;\n    serial_t **PTR_tx_callback_obj_080086e0 = PTR_tx_callback_obj_080086e0 + (uint)index * 4;\n    *PTR_tx_callback_obj_080086e0 = serial_obj;\n    HAL_NVIC_SetPriority(serial_obj->irq, 0, 2);\n    HAL_NVIC_EnableIRQ(serial_obj->irq);\n    UART_HandleTypeDef **PTR_uart_handlers_080086e4 = PTR_uart_handlers_080086e4 + (uint)serial_obj->index * 4;\n    HAL_UART_Transmit_IT(*PTR_uart_handlers_080086e4, serial_obj->tx_buff + serial_obj->tx_tail, 1);\n  }\n}",
            "called": [
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_SetPriority",
                "HAL_NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008694",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "setup_serial_08008694"
        },
        "FUN_08002ce0": {
            "renaming": {
                "FUN_08002ce0": "initialize_parser_08002ce0",
                "this": "firmata_instance",
                "this_00": "parser",
                "marshaller": "firmata_marshaller",
                "parserBuffer": "parser_buffer",
                "firmwareVersionCount": "firmware_version_count",
                "firmwareVersionVector": "firmware_version_vector",
                "blinkVersionDisabled": "blink_version_disabled",
                "DAT_08002d90": "SYSEX_REPORT_FIRMWARE",
                "DAT_08002d94": "ANALOG_MESSAGE",
                "DAT_08002d98": "REPORT_ANALOG_PIN",
                "DAT_08002d9c": "REPORT_DIGITAL_PORTS",
                "DAT_08002da0": "START_SYSEX",
                "DAT_08002da4": "SET_PIN_MODE",
                "DAT_08002da8": "SYSEX_STRING",
                "DAT_08002dac": "SYSTEM_RESET",
                "DAT_08002db0": "PROTOCOL_VERSION",
                "DAT_08002db4": "REPORT_FIRMWARE",
                "DAT_08002db8": "END_SYSEX"
            },
            "code": "initialize_parser_08002ce0 * __thiscall firmata::initialize_parser_08002ce0::initialize_parser_08002ce0(initialize_parser_08002ce0 *firmata_instance)\\n\\\n{\\n\\\n  FirmataParser *parser = &firmata_instance->parser;\\n\\\n  FirmataMarshaller::FirmataMarshaller(&firmata_instance->marshaller);\\n\\\n  FirmataParser::FirmataParser(parser,firmata_instance->parserBuffer,0x40);\\n\\\n  firmata_instance->firmwareVersionCount = \"\\0\";\\n\\\n  firmata_instance->firmwareVersionVector = (byte *)0x0;\\n\\\n  firmata_instance->blinkVersionDisabled = false;\\n\\\n  FirmataParser::attach(parser,0xe0,DAT_08002d90,(void *)0x0);\\n\\\n  FirmataParser::attach(parser,0x90,DAT_08002d94,(void *)0x0);\\n\\\n  FirmataParser::attach(parser,0xc0,DAT_08002d98,(void *)0x0);\\n\\\n  FirmataParser::attach(parser,0xd0,DAT_08002d9c,(void *)0x0);\\n\\\n  FirmataParser::attach(parser,0xf4,DAT_08002da0,(void *)0x0);\\n\\\n  FirmataParser::attach(parser,0xf5,DAT_08002da4,(void *)0x0);\\n\\\n  FirmataParser::attach(parser,DAT_08002da8,(void *)0x0,(void *)0x0);\\n\\\n  FirmataParser::attach(parser,0xf0,DAT_08002dac,(void *)0x0);\\n\\\n  FirmataParser::attach(parser,DAT_08002db0,(void *)0x0,firmata_instance);\\n\\\n  FirmataParser::attach(parser,DAT_08002db4,(void *)0x0,firmata_instance);\\n\\\n  FirmataParser::attach(parser,DAT_08002db8,(void *)0x0,(void *)0x0);\\n\\\n  return firmata_instance;\\n\\\n}",
            "called": [
                "attach",
                "attach",
                "FirmataMarshaller",
                "attach",
                "FirmataParser",
                "attach",
                "attach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ce0",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_parser_08002ce0"
        },
        "FUN_08005188": {
            "renaming": {
                "FUN_08005188": "i2c_handler_08005188",
                "hi2c": "handler",
                "pIVar1": "instance",
                "uVar2": "sr1",
                "uVar3": "cr2",
                "uVar4": "sr2"
            },
            "code": "void i2c_handler_08005188(I2C_HandleTypeDef_conflict *handler)\n{\n  I2C_TypeDef_conflict *instance;\n  uint sr2;\n  uint sr1;\n  uint cr2;\n\n  instance = handler->Instance;\n  sr2 = instance->SR2;\n  sr1 = instance->SR1;\n  cr2 = instance->CR2;\n\n  if ((handler->Mode == HAL_I2C_MODE_MASTER) || (handler->Mode == HAL_I2C_MODE_MEM)) {\n    if (((sr1 & 0x10001) == 0) || ((cr2 & 0x200) == 0)) {\n      if (((sr1 & 0x8) == 0) || ((cr2 & 0x200) == 0)) {\n        if (((sr1 & 0x2) != 0) && ((cr2 & 0x200) != 0)) {\n          I2C_Master_ADDR(handler);\n        }\n      }\n      else {\n        I2C_Master_ADD10(handler);\n      }\n    }\n    else {\n      I2C_Master_SB(handler);\n    }\n    if ((sr2 & 0x2) == 0) {\n      if ((((sr1 & 0x40) != 0) && ((cr2 & 0x400) != 0)) && ((sr1 & 0x4) == 0)) {\n        I2C_MasterReceive_RXNE(handler);\n        return;\n      }\n      if (((sr1 & 0x4) != 0) && ((cr2 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(handler);\n        return;\n      }\n    }\n    else {\n      if ((((sr1 & 0x40) != 0) && ((cr2 & 0x400) != 0)) && ((sr1 & 0x4) == 0)) {\n        I2C_MasterTransmit_TXE(handler);\n        return;\n      }\n      if (((sr1 & 0x4) != 0) && ((cr2 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(handler);\n        return;\n      }\n    }\n  }\n  else {\n    if (((sr1 & 0x2) != 0) && ((cr2 & 0x200) != 0)) {\n      I2C_Slave_ADDR(handler);\n      return;\n    }\n    if (((sr1 & 0x10) != 0) && ((cr2 & 0x200) != 0)) {\n      I2C_Slave_STOPF(handler);\n      return;\n    }\n    if ((sr2 & 0x2) == 0) {\n      if ((((sr1 & 0x40) != 0) && ((cr2 & 0x400) != 0)) && ((sr1 & 0x4) == 0)) {\n        I2C_SlaveReceive_RXNE(handler);\n        return;\n      }\n      if (((sr1 & 0x4) != 0) && ((cr2 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(handler);\n      }\n    }\n    else {\n      if ((((sr1 & 0x40) != 0) && ((cr2 & 0x400) != 0)) && ((sr1 & 0x4) == 0)) {\n        I2C_SlaveTransmit_TXE(handler);\n        return;\n      }\n      if (((sr1 & 0x4) != 0) && ((cr2 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(handler);\n        return;\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "I2C_MasterTransmit_BTF",
                "I2C_Master_ADD10",
                "I2C_Master_ADDR",
                "I2C_MasterTransmit_TXE",
                "I2C_SlaveReceive_RXNE",
                "I2C_Master_SB",
                "I2C_SlaveReceive_BTF",
                "I2C_MasterReceive_BTF",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_TXE",
                "I2C_SlaveTransmit_BTF",
                "I2C_Slave_STOPF",
                "I2C_MasterReceive_RXNE"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005188",
            "calling": [
                "I2C1_EV_IRQHandler",
                "I2C2_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handler_08005188"
        },
        "FUN_08007244": {
            "renaming": {
                "FUN_08007244": "do_nothing_08007244"
            },
            "code": "\nvoid do_nothing_08007244(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007244",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "do_nothing_08007244"
        },
        "FUN_08001bf8": {
            "renaming": {
                "FUN_08001bf8": "write_to_wire_08001bf8",
                "data": "byte_data"
            },
            "code": "void write_to_wire_08001bf8(byte data)\n{\n  TwoWire::write((TwoWire *)PTR_Wire_08001c04,data);\n  return;\n}",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001bf8",
            "calling": [
                "sysexCallback",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "write_to_wire_08001bf8"
        },
        "FUN_080069ec": {
            "renaming": {
                "FUN_080069ec": "handle_uart_interrupt_080069ec",
                "huart": "uart_handle",
                "HVar1": "status",
                "uVar2": "cr1_reg",
                "pUVar3": "instance",
                "uVar4": "cr3_flag",
                "uVar5": "sr_reg",
                "PTR_DAT_08006b08": "uart_dma_rx_abort_callback",
                "hdmarx": "hdma_rx",
                "UART_Receive_IT": "uart_receive_it",
                "UART_Transmit_IT": "uart_transmit_it",
                "UART_EndTransmit_IT": "uart_end_transmit_it",
                "HAL_UART_ErrorCallback": "hal_uart_error_callback",
                "HAL_DMA_Abort_IT": "hal_dma_abort_it",
                "HAL_UART_ERROR_PE": "UART_ERROR_PE",
                "HAL_UART_ERROR_FE": "UART_ERROR_FE",
                "HAL_UART_ERROR_NE": "UART_ERROR_NE",
                "HAL_UART_ERROR_ORE": "UART_ERROR_ORE",
                "USART_SR_RXNE": "USART_SR_RXNE",
                "USART_SR_IDLE": "USART_SR_IDLE",
                "USART_CR1_IDLEIE": "USART_CR1_IDLEIE",
                "USART_SR_TC": "USART_SR_TC",
                "USART_CR1_TCIE": "USART_CR1_TCIE",
                "USART_SR_TXE": "USART_SR_TXE",
                "USART_CR1_TXEIE": "USART_CR1_TXEIE",
                "USART_SR_PE": "USART_SR_PE",
                "USART_CR1_PEIE": "USART_CR1_PEIE",
                "USART_SR_FE": "USART_SR_FE",
                "USART_CR3_EIE": "USART_CR3_EIE",
                "USART_SR_NE": "USART_SR_NE",
                "USART_SR_ORE": "USART_SR_ORE",
                "USART_CR3_HDSEL": "USART_CR3_HDSEL",
                "USART_CR3_CTSE": "USART_CR3_CTSE",
                "HAL_UART_ERROR_NONE": "UART_ERROR_NONE"
            },
            "code": "void handle_uart_interrupt_080069ec(UART_HandleTypeDef *huart) {\n  HAL_StatusTypeDef_conflict status;\n  uint32_t sr_reg;\n  USART_TypeDef *instance;\n  uint32_t cr1_reg;\n  uint32_t cr3_reg;\n  uint32_t error_code;\n  DMA_HandleTypeDef_conflict *hdmarx;\n  instance = huart->Instance;\n  sr_reg = instance->SR;\n  cr1_reg = instance->CR1;\n  cr3_reg = instance->CR3;\n  if (((sr_reg & USART_SR_RXNE) == RESET) && ((sr_reg & USART_SR_IDLE) != RESET) && ((cr1_reg & USART_CR1_IDLEIE) != RESET)) {\n    UART_Receive_IT(huart);\n    return;\n  }\n  if (((sr_reg & USART_SR_RXNE) == RESET) || ((cr3_reg & USART_CR3_EIE) == RESET && ((cr1_reg & (USART_CR1_RXNEIE | USART_CR1_PEIE)) == RESET))) {\n    if (((sr_reg & USART_SR_TC) != RESET) && ((cr1_reg & USART_CR1_TCIE) != RESET)) {\n      UART_Transmit_IT(huart);\n      return;\n    }\n    if (((sr_reg & USART_SR_TXE) != RESET) && ((cr1_reg & USART_CR1_TXEIE) != RESET))) {\n      UART_EndTransmit_IT(huart);\n    }\n  }\n  else {\n    error_code = 0;\n    if (((sr_reg & USART_SR_PE) != RESET) && ((cr1_reg & USART_CR1_PEIE) != RESET)) {\n      error_code |= HAL_UART_ERROR_PE;\n    }\n    if (((sr_reg & USART_SR_FE) != RESET) && ((cr3_reg & USART_CR3_EIE) != RESET)) {\n      error_code |= HAL_UART_ERROR_FE;\n    }\n    if (((sr_reg & USART_SR_NE) != RESET) && ((cr3_reg & USART_CR3_EIE) != RESET)) {\n      error_code |= HAL_UART_ERROR_NE;\n    }\n    if (((sr_reg & USART_SR_ORE) != RESET) && ((cr3_reg & USART_CR3_EIE) != RESET)) {\n      error_code |= HAL_UART_ERROR_ORE;\n    }\n    if (error_code != 0) {\n      if (((sr_reg & USART_SR_IDLE) != RESET) && ((cr1_reg & USART_CR1_IDLEIE) != RESET)) {\n        UART_Receive_IT(huart);\n      }\n      if (((error_code & HAL_UART_ERROR_ORE) == RESET) && ((cr3_reg & USART_CR3_HDSEL) == RESET)) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      UART_EndRxTransfer(huart);\n      if ((cr3_reg & USART_CR3_HDSEL) == RESET) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      instance->CR3 = cr3_reg & ~USART_CR3_CTSE;\n      hdmarx = huart->hdmarx;\n      if (hdmarx == NULL) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      hdmarx->XferAbortCallback = PTR_DAT_08006b08;\n      status = HAL_DMA_Abort_IT(hdmarx);\n      if (status != HAL_OK) {\n        hdmarx->XferAbortCallback(hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "UART_EndTransmit_IT",
                "HAL_DMA_Abort_IT",
                "UART_EndRxTransfer",
                "UART_Receive_IT",
                "UART_Transmit_IT",
                "HAL_UART_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080069ec",
            "calling": [
                "USART2_IRQHandler",
                "USART1_IRQHandler",
                "USART3_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_uart_interrupt_080069ec"
        },
        "FUN_0800a168": {
            "renaming": {
                "FUN_0800a168": "read_and_set_errno_0800a168",
                "param_1": "result",
                "param_2": "fd",
                "param_3": "buffer",
                "param_4": "size",
                "puVar1": "errno_ptr",
                "iVar2": "read_result"
            },
            "code": "void read_and_set_errno_0800a168(int *result, int fd, char *buffer, int size) {\n    int read_result = 0;\n    int *errno_ptr = PTR_errno_0800a188;\n    *(undefined4 *)PTR_errno_0800a188 = 0;\n    read_result = _read(fd, buffer, size);\n    if ((read_result == -1) && (*(int *)errno_ptr != 0)) {\n        *result = *(int *)errno_ptr;\n    }\n    return;\n}",
            "called": [
                "_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a168",
            "calling": [
                "__sread"
            ],
            "imported": false,
            "current_name": "read_and_set_errno_0800a168"
        },
        "FUN_080067ac": {
            "renaming": {
                "FUN_080067ac": "UART_Transmit_080067ac",
                "huart": "handle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickstart"
            },
            "code": "HAL_StatusTypeDef UART_Transmit_080067ac(UART_HandleTypeDef *huart, uint8_t *data, uint16_t size, uint32_t timeout)\n{\n  HAL_StatusTypeDef status;\n  uint32_t tickstart;\n  if (huart->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == NULL || size == 0 || huart->Lock == HAL_LOCKED) {\n    return HAL_ERROR;\n  }\n  huart->Lock = HAL_LOCKED;\n  huart->ErrorCode = 0;\n  huart->gState = HAL_UART_STATE_BUSY_TX;\n  tickstart = HAL_GetTick();\n  huart->TxXferSize = size;\n  huart->TxXferCount = size;\n  while (huart->TxXferCount--) {\n    if (huart->Init.WordLength == UART_WORDLENGTH_9B) {\n      status = UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, timeout);\n      if (status != HAL_OK) {\n        return HAL_TIMEOUT;\n      }\n      huart->Instance->DR = *(uint16_t*)data & 0x1FF;\n      data += 2 - (huart->Init.Parity == UART_PARITY_NONE);\n    }\n    else {\n      status = UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, timeout);\n      if (status != HAL_OK) {\n        return HAL_TIMEOUT;\n      }\n      huart->Instance->DR = *data++;\n    }\n  }\n  status = UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, timeout);\n  huart->gState = HAL_UART_STATE_READY;\n  huart->Lock = HAL_UNLOCKED;\n  return (status == HAL_OK) ? HAL_OK : HAL_TIMEOUT;\n}",
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080067ac",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "UART_Transmit_080067ac"
        },
        "FUN_0800735a": {
            "renaming": {
                "FUN_0800735a": "find_pin_function_0800735a",
                "pin": "target_pin",
                "map": "pin_map",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap",
                "NC": "no_connection"
            },
            "code": "uint32_t find_pin_function_0800735a(PinName_conflict pin, PinMap_conflict *pin_map) {\n    while (true) {\n        if (pin_map->pin == NC) {\n            return 0xffffffff;\n        }\n        if (pin_map->pin == pin) {\n            break;\n        }\n        pin_map++;\n    }\n    return pin_map->function;\n}",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800735a",
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "imported": false,
            "current_name": "find_pin_function_0800735a"
        },
        "FUN_08008c20": {
            "renaming": {
                "FUN_08008c20": "initializeSerialBuffers_08008c20",
                "*this": "serial",
                "ctx": "context",
                "(this->_serial).rx_buff": "serial->rx_buffer",
                "this->_rx_buffer": "serial->_rx_buffer",
                "(this->_serial).rx_head": "serial->rx_head",
                "(this->_serial).rx_tail": "serial->rx_tail",
                "(this->_serial).tx_buff": "serial->tx_buffer",
                "this->_tx_buffer": "serial->_tx_buffer",
                "(this->_serial).tx_head": "serial->tx_head",
                "(this->_serial).tx_tail": "serial->tx_tail"
            },
            "code": "int __thiscall initializeSerialBuffers_08008c20(HardwareSerial *serial, EVP_PKEY_CTX *context)\n{\n  serial->rx_buffer = serial->_rx_buffer;\n  serial->rx_head = 0;\n  serial->rx_tail = 0;\n  serial->tx_buffer = serial->_tx_buffer;\n  serial->tx_head = 0;\n  serial->tx_tail = 0;\n  return (int)serial;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008c20",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "initializeSerialBuffers_08008c20"
        },
        "FUN_0800723c": {
            "renaming": {
                "FUN_0800723c": "get_current_tick_0800723c",
                "uVar1": "current_tick"
            },
            "code": "uint32_t get_current_tick_0800723c(void)\n{\n  uint32_t current_tick = HAL_GetTick();\n  return current_tick;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800723c",
            "calling": [
                "millis"
            ],
            "imported": false,
            "current_name": "get_current_tick_0800723c"
        },
        "FUN_080043a2": {
            "renaming": {
                "FUN_080043a2": "handle_i2c_events_080043a2",
                "*hi2c": "*i2c_handle",
                "uVar1": "transfer_options",
                "pIVar2": "i2c_instance",
                "tmpreg": "cr1_reg",
                "tmpreg_1": "cr2_reg",
                "tmpreg_2": "event_count",
                "tmpreg_3": "transfer_count",
                "tmpreg_4": "previous_state",
                "tmpreg_5": "addressing_mode",
                "tmpreg_6": "mode",
                "tmpreg_7": "state"
            },
            "code": "HAL_StatusTypeDef_conflict handle_i2c_events_080043a2(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  uint32_t transfer_options = i2c_handle->XferOptions;\n  I2C_TypeDef_conflict *i2c_instance = i2c_handle->Instance;\n  uint32_t cr1_reg = i2c_instance->CR1;\n  uint32_t cr2_reg = i2c_instance->CR2;\n  uint32_t event_count = i2c_handle->EventCount;\n  uint32_t transfer_count = i2c_handle->XferCount;\n  uint32_t previous_state = i2c_handle->PreviousState;\n  uint32_t addressing_mode = (i2c_handle->Init).AddressingMode;\n  uint32_t mode = i2c_handle->Mode;\n  uint32_t state = i2c_handle->State;\n  \n  if (state == HAL_I2C_STATE_BUSY_RX && (event_count != 0 || mode != HAL_I2C_MODE_MEM)) {\n    if (event_count == 0 && addressing_mode == 0xc000) {\n      cr1_reg |= 0x100;\n      i2c_handle->EventCount++;\n    }\n    else {\n      if (transfer_count == 0) {\n        cr1_reg |= 0x200;\n      }\n      else if (transfer_count == 1) {\n        if (transfer_options == 0xffff0000) {\n          cr1_reg &= 0xfffffbff;\n          if ((cr2_reg & 0x800) == 0) {\n            cr1_reg |= 0x200;\n          }\n          else {\n            cr1_reg &= 0xfffffbff;\n          }\n        }\n        else if ((transfer_options == 4 || transfer_options == 8) || previous_state == 0x12) {\n          cr1_reg &= 0xfffffbff;\n          cr1_reg |= 0x200;\n        }\n        else if (transfer_options == 2) {\n          cr1_reg |= 0x400;\n        }\n        else {\n          cr1_reg &= 0xfffffbff;\n        }\n      }\n      else if (transfer_count == 2) {\n        if (transfer_options == 2) {\n          cr1_reg |= 0x400;\n        }\n        else {\n          cr1_reg |= 0x800;\n          cr1_reg &= 0xfffffbff;\n        }\n        if ((cr2_reg & 0x800) != 0) {\n          cr2_reg |= 0x1000;\n        }\n      }\n      else {\n        cr1_reg |= 0x400;\n        if ((cr2_reg & 0x800) != 0) {\n          cr2_reg |= 0x1000;\n        }\n      }\n      i2c_handle->EventCount = 0;\n    }\n  }\n  i2c_instance->CR1 = cr1_reg;\n  i2c_instance->CR2 = cr2_reg;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080043a2",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_events_080043a2"
        },
        "FUN_08006280": {
            "renaming": {
                "FUN_08006280": "configure_timer_08006280",
                "htim": "timer_handle",
                "Channel": "channel",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "pTVar1": "timer_instance",
                "DAT_080062f0": "PTR_TIM1_BASE"
            },
            "code": "HAL_StatusTypeDef configure_timer_08006280(TIM_HandleTypeDef *timer_handle, uint32_t channel) {\n    TIM_TypeDef *timer_instance = timer_handle->Instance;\n    switch(channel) {\n        case 0:\n            timer_instance->DIER |= 2;\n            break;\n        case 4:\n            timer_instance->DIER |= 4;\n            break;\n        case 8:\n            timer_instance->DIER |= 8;\n            break;\n        case 0xc:\n            timer_instance->DIER |= 0x10;\n            break;\n    }\n    TIM_CCxChannelCmd(timer_instance, channel, 1);\n    if (timer_instance == DAT_080062f0) {\n        timer_instance->BDTR |= 0x8000;\n    }\n    timer_instance->CR1 |= 1;\n    return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006280",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "configure_timer_08006280"
        },
        "FUN_08007258": {
            "renaming": {
                "FUN_08007258": "init_GPIO_pin_08007258",
                "pin": "pin_name",
                "mode": "pin_mode",
                "pull": "pin_pull",
                "uVar1": "pin_num",
                "GPIOx": "gpio_port",
                "tmpreg": "temporary_register",
                "GPIO_InitStructure": "GPIO_InitStruct",
                "DAT_080072d0": "data_address_1",
                "DAT_080072d4": "data_address_2"
            },
            "code": "void init_GPIO_pin_08007258(PinName_conflict pin, uint32_t mode, uint32_t pull) {\n  uint32_t pin_num = (uint32_t)pin;\n  GPIO_TypeDef *GPIOx = set_GPIO_Port_Clock((pin_num << 24) >> 28);\n  uint32_t pin_mask = 1 << (pin_num & 0xf) & 0xffff;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  GPIO_InitStruct.Pin = pin_mask;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;\n  *(uint32_t *)(DAT_080072d0 + 0x18) |= 1;\n  if ((pin_num - 0xd & 0xff) < 2) {\n    *(uint32_t *)(DAT_080072d4 + 4) = *(uint32_t *)(DAT_080072d4 + 4) & 0xf8ffffff | 0x4000000;\n  }\n  if (((pin_num == 0xf) || (pin_num == 0x13)) || (pin_num == 0x14)) {\n    *(uint32_t *)(DAT_080072d4 + 4) = *(uint32_t *)(DAT_080072d4 + 4) & 0xf8ffffff | 0x2000000;\n  }\n  GPIO_InitStruct.Mode = mode;\n  GPIO_InitStruct.Pull = pull;\n  HAL_GPIO_Init(GPIOx, &GPIO_InitStruct);\n}\n",
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007258",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "init_GPIO_pin_08007258"
        },
        "FUN_08009f4c": {
            "renaming": {
                "FUN_08009f4c": "allocate_memory_08009f4c",
                "param_1": "size",
                "param_2": "ptr1",
                "param_3": "ptr2",
                "param_4": "size2",
                "pvVar1": "new_ptr",
                "pvVar2": "usable_size"
            },
            "code": "void * allocate_memory_08009f4c(size_t size, void *ptr1, void *ptr2, size_t size2)\n{\n  void *new_ptr;\n  void *usable_size;\n  \n  if (ptr1 != NULL) {\n    if (ptr2 == NULL) {\n      free(ptr2);\n      new_ptr = ptr2;\n    }\n    else {\n      usable_size = (void *)malloc_usable_size(ptr1);\n      new_ptr = ptr1;\n      if ((usable_size < ptr2) && (new_ptr = (void *)malloc(size2), new_ptr != NULL)\n         ) {\n        memcpy(new_ptr, ptr1, (size_t)ptr2);\n        free(ptr1);\n      }\n    }\n    return new_ptr;\n  }\n  new_ptr = (void *)malloc(size2);\n  return new_ptr;\n}",
            "called": [
                "_free_r",
                "memcpy",
                "_malloc_usable_size_r",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f4c",
            "calling": [
                "realloc"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009f4c"
        },
        "FUN_08009f4a": {
            "renaming": {
                "FUN_08009f4a": "do_nothing_08009f4a"
            },
            "code": "\nvoid do_nothing_08009f4a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f4a",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_08009f4a"
        },
        "FUN_08006c7c": {
            "renaming": {
                "FUN_08006c7c": "map_pwm_function_08006c7c",
                "pin": "pin",
                "uVar1": "function_index",
                "uVar2": "shifted_index",
                "PTR_PinMap_PWM_08006ca4": "PTR_PinMap_PWM_08006ca4"
            },
            "code": "uint32_t map_pwm_function_08006c7c(PinName_conflict pin)\n{\n  uint32_t function_index = pinmap_function(pin, (PinMap_conflict *)PTR_PinMap_PWM_08006ca4);\n  uint32_t shift_amount = 0xc;\n  uint32_t mask = 0x1b;\n  uint32_t shifted_index = (function_index << shift_amount) >> mask;\n  if (shifted_index == 3) {\n    return 8;\n  }\n  if (shifted_index == 4) {\n    return 0xc;\n  }\n  if (shifted_index == 2) {\n    return 4;\n  }\n  return 0;\n}",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c7c",
            "calling": [
                "pwm_stop",
                "pwm_start"
            ],
            "imported": false,
            "current_name": "map_pwm_function_08006c7c"
        },
        "FUN_08006b5c": {
            "renaming": {
                "FUN_08006b5c": "clear_pin_from_map_08006b5c",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "pin_index",
                "mask": "mask"
            },
            "code": "void clear_pin_from_map_08006b5c(PinName_conflict pin, uint32_t *pin_map) {\n    uint8_t pin_index = (uint8_t)(((uint32_t)pin) >> 2);\n    uint32_t mask = ~(1 << ((uint32_t)pin & 0x0F));\n    pin_map[pin_index] &= mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b5c",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "clear_pin_from_map_08006b5c"
        },
        "FUN_08007376": {
            "renaming": {
                "FUN_08007376": "find_pin_function_08007376",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "function_index"
            },
            "code": "uint32_t find_pin_function_08007376(PinName_conflict pin, PinMap_conflict *pin_map)\n{\n  uint32_t function_index;\n  if (pin == NC) {\n    return 0xffffffff;\n  }\n  function_index = pinmap_find_function(pin, pin_map);\n  return function_index;\n}",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007376",
            "calling": [
                "pwm_stop",
                "get_adc_channel",
                "get_pwm_channel",
                "HAL_TIM_PWM_MspInit",
                "pwm_start",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "find_pin_function_08007376"
        },
        "FUN_080033cc": {
            "renaming": {
                "FUN_080033cc": "parseFirmataMessage_080033cc",
                "this": "parser",
                "uVar1": "message_type",
                "sVar2": "message_length",
                "puVar3": "messageBuffer",
                "bufferDataAtPosition": "bufferDataAtPosition",
                "decodeByteStream": "decodeByteStream",
                "currentStringCallback": "currentStringCallback",
                "stringCallbackFunction": "stringCallbackFunction",
                "currentStringCallbackContext": "currentStringCallbackContext",
                "currentReportFirmwareCallback": "currentReportFirmwareCallback",
                "versionCallbackFunction": "versionCallbackFunction",
                "currentReportFirmwareCallbackContext": "currentReportFirmwareCallbackContext",
                "currentSysexCallback": "currentSysexCallback",
                "sysexCallbackFunction": "sysexCallbackFunction",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void __thiscall firmata::FirmataParser::parseFirmataMessage_080033cc(FirmataParser *parser)\n{\n  uint8_t message_type = *(parser->messageBuffer);\n  if (message_type == 'q') {\n    if (parser->currentStringCallback != (stringCallbackFunction)0x0) {\n      size_t message_length = decodeByteStream(parser, parser->sysexBytesRead - 1, parser->messageBuffer + 1);\n      bufferDataAtPosition(parser, '\\0', message_length + 1);\n      (*parser->currentStringCallback)(parser->currentStringCallbackContext, (char *)(parser->messageBuffer + 1));\n      return;\n    }\n  }\n  else if (message_type == 'y') {\n    if (parser->currentReportFirmwareCallback != (versionCallbackFunction)0x0) {\n      if (parser->sysexBytesRead < 3) {\n        (*parser->currentReportFirmwareCallback)(parser->currentReportFirmwareCallbackContext, 0, 0, (char *)0x0);\n        return;\n      }\n      size_t message_length = decodeByteStream(parser, parser->sysexBytesRead - 3, parser->messageBuffer + 3);\n      bufferDataAtPosition(parser, '\\0', message_length + 3);\n      uint8_t *firmware_version = parser->messageBuffer;\n      (*parser->currentReportFirmwareCallback)(parser->currentReportFirmwareCallbackContext, (uint)firmware_version[1], (uint)firmware_version[2], (char *)(firmware_version + 3));\n      return;\n    }\n  }\n  else if (parser->currentSysexCallback != (sysexCallbackFunction)0x0) {\n    (*parser->currentSysexCallback)(parser->currentSysexCallbackContext, message_type, parser->sysexBytesRead - 1, parser->messageBuffer + 1);\n  }\n  return;\n}\n",
            "called": [
                "bufferDataAtPosition",
                "decodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033cc",
            "calling": [
                "parse"
            ],
            "imported": false,
            "current_name": "parseFirmataMessage_080033cc"
        },
        "FUN_08003de4": {
            "renaming": {
                "FUN_08003de4": "stop_conversion_08003de4",
                "*hadc": "hadc",
                "HVar1": "status",
                "HAL_LOCKED": "HAL_BUSY",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "ADC_ConversionStop_Disable": "ADC_conversion_stop_disable",
                "State": "state"
            },
            "code": "HAL_StatusTypeDef_conflict stop_conversion_08003de4(ADC_HandleTypeDef *hadc)\n{\n  HAL_StatusTypeDef_conflict status;\n  if (hadc->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  hadc->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(hadc);\n  if (status == HAL_OK) {\n    hadc->State &= 0xFFFFEEFE | 1;\n  }\n  hadc->Lock = HAL_UNLOCKED;\n  return status;\n}",
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003de4",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "stop_conversion_08003de4"
        },
        "FUN_08000500": {
            "renaming": {
                "FUN_08000500": "attachServoToPin_08000500",
                "pin": "pin",
                "minPulse": "minPulseWidth",
                "maxPulse": "maxPulseWidth",
                "bVar1": "servoCount",
                "bVar2": "detachedServoCount",
                "pin_00": "pinAsUInt",
                "*PTR_servoCount_0800056c": "servoCountPtr",
                "firmata::FirmataClass::sendString": "sendString",
                "(FirmataClass *)PTR_Firmata_08000584": "firmataPtr",
                "PTR_s_Max_servos_attached_08000580": "maxServoErrMsg",
                "*PTR_detachedServoCount_08000570": "detachedServoCountPtr",
                "PTR_servoPinMap_08000578": "servoPinMap",
                "PTR_detachedServos_08000574": "detachedServos",
                "Servo::attach": "Servo::attach",
                "*PTR_servos_0800057c": "servosPtr"
            },
            "code": "void attachServoToPin_08000500(byte pin, int minPulseWidth, int maxPulseWidth) {\n  byte servoCount = **PTR_servoCount_0800056c;\n  if (servoCount > 11) {\n    firmata::FirmataClass::sendString((FirmataClass *)(FirmataClass *)PTR_Firmata_08000584, PTR_s_Max_servos_attached_08000580);\n    return;\n  }\n  byte detachedServoCount = **PTR_detachedServoCount_08000570;\n  if (detachedServoCount == 0) {\n    PTR_servoPinMap_08000578[pin] = servoCount;\n    **PTR_servoCount_0800056c = servoCount + 1;\n  }\n  else {\n    PTR_servoPinMap_08000578[pin] = PTR_detachedServos_08000574[detachedServoCount - 1];\n    **PTR_detachedServoCount_08000570 = detachedServoCount - 1;\n  }\n  if (minPulseWidth > 0 && maxPulseWidth > 0) {\n    Servo::attach((Servo *)(*PTR_servos_0800057c + (uint)(byte)PTR_servoPinMap_08000578[pin] * 3), pin, minPulseWidth, maxPulseWidth);\n    return;\n  }\n  Servo::attach((Servo *)(*PTR_servos_0800057c + (uint)(byte)PTR_servoPinMap_08000578[pin] * 3), pin);\n}",
            "called": [
                "attach",
                "attach",
                "sendString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000500",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "attachServoToPin_08000500"
        },
        "FUN_08009d24": {
            "renaming": {
                "FUN_08009d24": "malloc_and_initialize_array_08009d24",
                "param_1": "size",
                "param_2": "num_elements",
                "puVar1": "array",
                "iVar2": "total_size"
            },
            "code": "_malloc_r malloc_and_initialize_array_08009d24(int size, int num_elements)\n{\n  int total_size = (num_elements - 1) * 0x68;\n  undefined4 *array = (undefined4 *)_malloc_r(size, total_size + 0x74);\n  if (array != (undefined4 *)0x0) {\n    *array = 0;\n    array[1] = num_elements;\n    array[2] = array + 3;\n    memset(array + 3, 0, total_size + 0x68);\n  }\n  return array;\n}",
            "called": [
                "memset",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009d24",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "malloc_and_initialize_array_08009d24"
        },
        "FUN_08008e72": {
            "renaming": {
                "__thiscall Print::FUN_08008e72": "print_character",
                "this": "print_object",
                "c": "character",
                "sVar1": "size_of_print",
                "FUN_08008e72": "print_character_08008e72"
            },
            "code": "size_t __thiscall print_character_08008e72(Print *print_object, char character) {\n    size_t size_of_print;\n    size_of_print = (**print_object->_vptr_Print)(print_object, (int)character);\n    return size_of_print;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e72",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "print_character_08008e72"
        },
        "FUN_080022f8": {
            "renaming": {
                "FUN_080022f8": "readInputsAndSendToSerial_080022f8",
                "bVar1": "isDigitalPin",
                "PVar2": "pinName",
                "bVar3": "pinMode",
                "iVar4": "availableBytes",
                "uVar5": "currentMillis",
                "uVar6": "digitalPinNumber",
                "ulPin": "analogPinNumber",
                "PTR_currentMillis_080023e4": "currentMillisPtr",
                "PTR_samplingInterval_080023ec": "samplingIntervalPtr",
                "PTR_previousMillis_080023e8": "previousMillisPtr",
                "PTR_digitalPin_080023f4": "digitalPinPtr",
                "PTR_analogInputsToReport_080023f0": "analogInputsToReportPtr",
                "PTR_queryIndex_080023f8": "queryIndexPtr",
                "PTR_query_080023fc": "queryPtr",
                "checkDigitalInputs": "checkDigitalInputs",
                "firmata::FirmataClass::available": "firmataAvailable",
                "firmata::FirmataClass::processInput": "firmataProcessInput",
                "millis": "getMillis",
                "pinNametoDigitalPin": "getDigitalPinNumber",
                "analogRead": "readAnalogPin",
                "firmata::FirmataClass::sendAnalog": "sendAnalogToSerial",
                "readAndReportData": "readAndReportData"
            },
            "code": "void readInputsAndSendToSerial_080022f8() {\n  bool isDigitalPin;\n  PinName_conflict pinName;\n  byte pinMode;\n  int availableBytes;\n  uint32_t currentMillis;\n  uint analogPinNumber;\n  uint digitalPinNumber;\n  uint samplingInterval = *(uint *)PTR_samplingInterval_080023ec;\n  uint previousMillis = *(int *)PTR_previousMillis_080023e8;\n  uint8_t analogInputsToReport = *(int *)PTR_analogInputsToReport_080023f0;\n  int queryIndex = (char)*PTR_queryIndex_080023f8;\n\n  checkDigitalInputs();\n  while ((availableBytes = firmata::FirmataClass::available((FirmataClass *)PTR_Firmata_080023e0)) != 0) {\n    firmata::FirmataClass::processInput((FirmataClass *)PTR_Firmata_080023e0);\n  }\n\n  currentMillis = millis();\n  *(uint32_t *)PTR_currentMillis_080023e4 = currentMillis;\n\n  if (samplingInterval < currentMillis - previousMillis) {\n    *(uint *)PTR_previousMillis_080023e8 = previousMillis + samplingInterval;\n    for (int i = 0; i < 60; i++) {\n      digitalPinNumber = i - 46;\n      if (digitalPinNumber < 14) {\n        if (i < 60) {\n          pinName = PTR_digitalPin_080023f4[i];\n        }\n        else {\n          pinName = NC;\n        }\n        digitalPinNumber = pinNametoDigitalPin(pinName);\n        if (digitalPinNumber == 0) {\n          isDigitalPin = false;\n        }\n        else if (digitalPinNumber == 1) {\n          isDigitalPin = false;\n        }\n        else {\n          pinMode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_080023e0, (byte)i);\n          isDigitalPin = (pinMode == 2);\n        }\n      }\n      else {\n        isDigitalPin = false;\n      }\n      if (isDigitalPin && ((analogInputsToReport >> digitalPinNumber & 1U) != 0)) {\n        analogPinNumber = digitalPinNumber - 14;\n        uint analogValue = analogRead(analogPinNumber);\n        firmata::FirmataClass::sendAnalog((FirmataClass *)PTR_Firmata_080023e0, (byte)analogPinNumber, analogValue);\n      }\n    }\n    if (queryIndex >= 0) {\n      for (int i = 0; i < queryIndex + 1; i++) {\n        int queryOffset = i * 12;\n        readAndReportData(PTR_query_080023fc[queryOffset], *(int *)(PTR_query_080023fc + queryOffset + 4), PTR_query_080023fc[queryOffset + 8], PTR_query_080023fc[queryOffset + 9]);\n      }\n    }\n  }\n}",
            "called": [
                "processInput",
                "checkDigitalInputs",
                "millis",
                "pinNametoDigitalPin",
                "sendAnalog",
                "analogRead",
                "readAndReportData",
                "getPinMode",
                "available"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080022f8",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "readInputsAndSendToSerial_080022f8"
        },
        "FUN_08005084": {
            "renaming": {
                "FUN_08005084": "handle_i2c_transfer_08005084",
                "hi2c": "i2c_handle",
                "HVar1": "state",
                "pIVar2": "i2c_instance",
                "puVar3": "buffer_ptr",
                "tmpreg": "cr2_reg",
                "hi2c->Instance->CR2": "i2c_instance->CR2",
                "hi2c->Instance->CR1": "i2c_instance->CR1",
                "hi2c->hdmarx->Instance->CNDTR": "i2c_handle->hdmarx->Instance->CNDTR",
                "hi2c->hdmatx->Instance->CNDTR": "i2c_handle->hdmatx->Instance->CNDTR",
                "hi2c->XferCount": "i2c_handle->XferCount",
                "hi2c->pBuffPtr": "i2c_handle->pBuffPtr",
                "pIVar2->CR2": "i2c_instance->CR2",
                "i2c_instance->SR1": "sr1_reg",
                "i2c_instance->DR": "i2c_instance->DR",
                "hi2c->ErrorCode": "i2c_handle->ErrorCode",
                "hi2c->PreviousState": "i2c_handle->PreviousState",
                "hi2c->XferOptions": "i2c_handle->XferOptions",
                "hi2c->State": "i2c_handle->State",
                "hi2c->Mode": "i2c_handle->Mode",
                "HAL_I2C_ListenCpltCallback": "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveRxCpltCallback": "HAL_I2C_SlaveRxCpltCallback",
                "HAL_I2C_STATE_BUSY_RX": "HAL_I2C_STATE_BUSY_RX",
                "HAL_I2C_STATE_BUSY_RX_LISTEN": "HAL_I2C_STATE_BUSY_RX_LISTEN",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "HAL_I2C_STATE_BUSY_TX_LISTEN",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef_conflict handle_i2c_transfer_08005084(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  HAL_I2C_StateTypeDef_conflict state = i2c_handle->State;\n  I2C_TypeDef_conflict *i2c_instance = i2c_handle->Instance;\n  uint8_t *buffer_ptr;\n  uint32_t cr2_reg;\n  uint32_t sr1_reg;\n\n  cr2_reg = i2c_instance->CR2 & 0xfffff8ff;\n  i2c_instance->CR2 = cr2_reg;\n  i2c_instance->CR1 |= 1;\n  i2c_instance->CR1 &= 0xfffffbff;\n\n  if ((i2c_instance->CR2 & 0x800) != 0) {\n    if ((state == HAL_I2C_STATE_BUSY_RX) || (state == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2c_handle->XferCount = (uint16_t)i2c_handle->hdmarx->Instance->CNDTR;\n    }\n    else {\n      i2c_handle->XferCount = (uint16_t)i2c_handle->hdmatx->Instance->CNDTR;\n    }\n  }\n\n  if (i2c_handle->XferCount != 0) {\n    sr1_reg = i2c_instance->SR1;\n    if ((sr1_reg & 4) != 0) {\n      buffer_ptr = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = buffer_ptr + 1;\n      *buffer_ptr = (uint8_t)i2c_instance->DR;\n      i2c_handle->XferCount--;\n    }\n    if ((sr1_reg & 0x40) != 0) {\n      buffer_ptr = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = buffer_ptr + 1;\n      *buffer_ptr = (uint8_t)i2c_instance->DR;\n      i2c_handle->XferCount--;\n    }\n    i2c_handle->ErrorCode |= 4;\n  }\n\n  if (i2c_handle->ErrorCode == 0) {\n    if (((state == HAL_I2C_STATE_LISTEN) || (state == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (state == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2c_handle->XferOptions = DAT_08005184;\n      i2c_handle->PreviousState = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2c_handle);\n    }\n    else if ((i2c_handle->PreviousState == 0x22) || (state == HAL_I2C_STATE_BUSY_RX)) {\n      i2c_handle->PreviousState = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2c_handle);\n    }\n  }\n  else {\n    I2C_ITError(i2c_handle);\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005084",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_transfer_08005084"
        },
        "FUN_08008b0e": {
            "renaming": {
                "FUN_08008b0e": "readNextCharFromSerialBuffer_08008b0e",
                "this": "serialObject",
                "_serial": "serialData",
                "rx_tail": "rxTail",
                "rx_head": "rxHead",
                "rx_buff": "rxBuffer"
            },
            "code": "int __thiscall readNextCharFromSerialBuffer_08008b0e(HardwareSerial *serialObject) {\n  uint rxTail = (uint)(serialObject->_serial).rx_tail;\n  if ((serialObject->_serial).rx_head != rxTail) {\n    return (uint)(serialObject->_serial).rx_buff[rxTail];\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b0e",
            "calling": [],
            "imported": false,
            "current_name": "readNextCharFromSerialBuffer_08008b0e"
        },
        "FUN_0800291c": {
            "renaming": {
                "FUN_0800291c::FUN_0800291c": "initialize_i2c",
                "this": "i2c_instance",
                "puVar1": "digital_pins",
                "FUN_0800291c": "initialize_i2c_0800291c"
            },
            "code": "initialize_i2c_0800291c* initialize_i2c_0800291c(initialize_i2c_0800291c *this)\n{\n  undefined *digital_pins;\n  digital_pins = PTR_digitalPin_08002944;\n  (this->super_Stream).super_Print.write_error = 0;\n  (this->super_Stream)._timeout = 1000;\n  (this->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)PTR_PTR_write_1_08002940;\n  (this->_i2c).sda = digital_pins[0xe];\n  (this->_i2c).scl = digital_pins[0xf];\n  return this;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800291c",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_i2c_0800291c"
        },
        "FUN_08002ac0": {
            "renaming": {
                "FUN_08002ac0": "sendStart_08002ac0",
                "this": "wire_object",
                "uVar1": "status"
            },
            "code": "uint8_t __thiscall TwoWire::sendStart_08002ac0(TwoWire *wire_object)\n{\n  uint8_t status;\n  status = sendStart_08002ac0(wire_object, '\\x01');\n  return status;\n}",
            "called": [
                "endTransmission"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ac0",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "sendStart_08002ac0"
        },
        "FUN_080032bc": {
            "renaming": {
                "FUN_080032bc::FUN_080032bc": "firmata::setup",
                "this": "self",
                "dataBuffer": "data_buffer",
                "dataBufferSize": "data_buffer_size",
                "executeMultiByteCommand": "execute_multi_byte_command",
                "multiByteChannel": "multi_byte_channel",
                "waitForData": "wait_for_data",
                "parsingSysex": "parsing_sysex",
                "sysexBytesRead": "sysex_bytes_read",
                "currentAnalogCallbackContext": "current_analog_callback_context",
                "currentDigitalCallbackContext": "current_digital_callback_context",
                "currentReportAnalogCallbackContext": "current_report_analog_callback_context",
                "currentReportDigitalCallbackContext": "current_report_digital_callback_context",
                "currentPinModeCallbackContext": "current_pin_mode_callback_context",
                "currentPinValueCallbackContext": "current_pin_value_callback_context",
                "currentReportFirmwareCallbackContext": "current_report_firmware_callback_context",
                "currentReportVersionCallbackContext": "current_report_version_callback_context",
                "currentDataBufferOverflowCallbackContext": "current_data_buffer_overflow_callback_context",
                "currentStringCallbackContext": "current_string_callback_context",
                "currentSysexCallbackContext": "current_sysex_callback_context",
                "currentSystemResetCallbackContext": "current_system_reset_callback_context",
                "currentAnalogCallback": "current_analog_callback",
                "currentDigitalCallback": "current_digital_callback",
                "currentReportAnalogCallback": "current_report_analog_callback",
                "currentReportDigitalCallback": "current_report_digital_callback",
                "currentPinModeCallback": "current_pin_mode_callback",
                "currentPinValueCallback": "current_pin_value_callback",
                "currentDataBufferOverflowCallback": "current_data_buffer_overflow_callback",
                "currentStringCallback": "current_string_callback",
                "currentSysexCallback": "current_sysex_callback",
                "currentReportFirmwareCallback": "current_report_firmware_callback",
                "currentReportVersionCallback": "current_report_version_callback",
                "currentSystemResetCallback": "current_system_reset_callback",
                "count_leading_zeroes": "count_leading_zeroes",
                "FUN_080032bc": "setup_080032bc"
            },
            "code": "setup_080032bc * __thiscall firmata::setup_080032bc(setup_080032bc *this,uint8_t *data_buffer,size_t data_buffer_size)\n{\n    uint leading_zeroes_count = count_leading_zeroes(data_buffer);\n    bool allow_buffer_update = (leading_zeroes_count >> 5) & 1;\n    this->data_buffer = data_buffer;\n    this->data_buffer_size = data_buffer_size;\n    this->execute_multi_byte_command = false;\n    this->multi_byte_channel = false;\n    this->wait_for_data = false;\n    this->parsing_sysex = false;\n    this->sysex_bytes_read = 0;\n    this->current_analog_callback_context = nullptr;\n    this->current_digital_callback_context = nullptr;\n    this->current_report_analog_callback_context = nullptr;\n    this->current_report_digital_callback_context = nullptr;\n    this->current_pin_mode_callback_context = nullptr;\n    this->current_pin_value_callback_context = nullptr;\n    this->current_report_firmware_callback_context = nullptr;\n    this->current_report_version_callback_context = nullptr;\n    this->current_data_buffer_overflow_callback_context = nullptr;\n    this->current_string_callback_context = nullptr;\n    this->current_sysex_callback_context = nullptr;\n    this->current_system_reset_callback_context = nullptr;\n    this->current_analog_callback = nullptr;\n    this->current_digital_callback = nullptr;\n    this->current_report_analog_callback = nullptr;\n    this->current_report_digital_callback = nullptr;\n    this->current_pin_mode_callback = nullptr;\n    this->current_pin_value_callback = nullptr;\n    this->current_data_buffer_overflow_callback = nullptr;\n    this->current_string_callback = nullptr;\n    this->current_sysex_callback = nullptr;\n    this->current_report_firmware_callback = nullptr;\n    this->current_report_version_callback = nullptr;\n    this->current_system_reset_callback = nullptr;\n    return this;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080032bc",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "setup_080032bc"
        },
        "FUN_080077b0": {
            "renaming": {
                "FUN_080077b0": "FUNC_080077b0"
            },
            "code": "\nvoid FUNC_080077b0(i2c_t_conflict *obj,i2c_timing_e_conflict timing,uint32_t addressingMode,\n                    uint32_t ownAddress,uint8_t master)\n\n{\n  undefined *puVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  void *a;\n  void *b;\n  I2C_TypeDef_conflict *pIVar3;\n  GPIO_TypeDef *pGVar4;\n  uint32_t uVar5;\n  uint32_t uVar6;\n  I2C_HandleTypeDef_conflict *hi2c;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_2;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj != (i2c_t_conflict *)0x0) {\n    hi2c = &obj->handle;\n    a = pinmap_peripheral(obj->sda,(PinMap_conflict *)PTR_PinMap_I2C_SDA_08007a74);\n    b = pinmap_peripheral(obj->scl,(PinMap_conflict *)PTR_PinMap_I2C_SCL_08007a78);\n    if ((a == (void *)0x0) || (b == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_I2C_pin_has_n_08007a88);\n    }\n    else {\n      pIVar3 = (I2C_TypeDef_conflict *)pinmap_merge_peripheral(a,b);\n      obj->i2c = pIVar3;\n      pIVar2 = DAT_08007a7c;\n      if (pIVar3 == (I2C_TypeDef_conflict *)0x0) {\n        iprintf(PTR_s_ERROR__I2C_pins_mismatch_08007a8c);\n      }\n      else {\n        if (pIVar3 == DAT_08007a7c) {\n          DAT_08007a7c[0xc56].CR2 = DAT_08007a7c[0xc56].CR2 | 0x200000;\n          pIVar2[0xc55].CCR = pIVar2[0xc55].CCR | 0x200000;\n          pIVar2[0xc55].CCR = pIVar2[0xc55].CCR & 0xffdfffff;\n          obj->irq = I2C1_EV_IRQn;\n          obj->irqER = I2C1_ER_IRQn;\n          *(I2C_HandleTypeDef_conflict **)PTR_i2c_handles_08007a90 = hi2c;\n        }\n        pIVar2 = DAT_08007a80;\n        if (obj->i2c == DAT_08007a80) {\n          DAT_08007a80[0xc39].SR2 = DAT_08007a80[0xc39].SR2 | 0x400000;\n          pIVar2[0xc39].OAR2 = pIVar2[0xc39].OAR2 | 0x400000;\n          pIVar2[0xc39].OAR2 = pIVar2[0xc39].OAR2 & 0xffbfffff;\n          obj->irq = I2C2_EV_IRQn;\n          obj->irqER = I2C2_ER_IRQn;\n          *(I2C_HandleTypeDef_conflict **)(PTR_i2c_handles_08007a90 + 4) = hi2c;\n        }\n        pGVar4 = set_GPIO_Port_Clock((uint)((int)obj->scl << 0x18) >> 0x1c);\n        puVar1 = PTR_PinMap_I2C_SCL_08007a78;\n        GPIO_InitStruct.Pin = 1 << ((int)obj->scl & 0xfU) & 0xffff;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)PTR_PinMap_I2C_SCL_08007a78);\n        uVar6 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Mode = (uVar5 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Speed = 3;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Pull = (uVar5 << 0x1a) >> 0x1e;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        *(uint *)(DAT_08007a84 + 0x18) = *(uint *)(DAT_08007a84 + 0x18) | 1;\n        switch((uVar5 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x4000000;\n        }\n        HAL_GPIO_Init(pGVar4,&GPIO_InitStruct);\n        pGVar4 = set_GPIO_Port_Clock((uint)((int)obj->sda << 0x18) >> 0x1c);\n        puVar1 = PTR_PinMap_I2C_SDA_08007a74;\n        GPIO_InitStruct.Pin = 1 << ((int)obj->sda & 0xfU) & 0xffff;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)PTR_PinMap_I2C_SDA_08007a74);\n        uVar6 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Mode = (uVar5 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Speed = 3;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Pull = (uVar5 << 0x1a) >> 0x1e;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        *(uint *)(DAT_08007a84 + 0x18) = *(uint *)(DAT_08007a84 + 0x18) | 1;\n        switch((uVar5 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x4000000;\n        }\n        HAL_GPIO_Init(pGVar4,&GPIO_InitStruct);\n        (obj->handle).Instance = obj->i2c;\n        (obj->handle).Init.ClockSpeed = timing;\n        (obj->handle).Init.DutyCycle = 0;\n        (obj->handle).Init.OwnAddress1 = ownAddress;\n        (obj->handle).Init.OwnAddress2 = 0xff;\n        (obj->handle).Init.AddressingMode = addressingMode;\n        (obj->handle).Init.DualAddressMode = 0;\n        (obj->handle).Init.GeneralCallMode = 0;\n        (obj->handle).Init.NoStretchMode = 0;\n        (obj->handle).State = HAL_I2C_STATE_RESET;\n        HAL_NVIC_SetPriority(obj->irq,0,1);\n        HAL_NVIC_EnableIRQ(obj->irq);\n        HAL_NVIC_SetPriority(obj->irqER,0,1);\n        HAL_NVIC_EnableIRQ(obj->irqER);\n        HAL_I2C_Init(hi2c);\n        obj->isMaster = master;\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "pinmap_function",
                "HAL_GPIO_Init",
                "pinmap_merge_peripheral",
                "pinmap_peripheral",
                "set_GPIO_Port_Clock",
                "HAL_NVIC_SetPriority",
                "HAL_I2C_Init",
                "HAL_NVIC_EnableIRQ",
                "iprintf"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080077b0",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "FUNC_080077b0"
        },
        "FUN_08008c44": {
            "renaming": {
                "__thiscall HardwareSerial::FUN_08008c44": "setSerialConfiguration",
                "this": "serial",
                "baud": "baudrate",
                "config": "config",
                "bVar1": "configMask",
                "iVar2": "bits",
                "PTR_s__home_bo__arduino15_packages_STM_08008cfc": "assertMessage",
                "PTR___PRETTY_FUNCTION___08008cf8": "assertFunction",
                "PTR_s_databits__0_08008cf4": "assertDetail",
                "FUN_08008c44": "setSerialConfiguration_08008c44"
            },
            "code": "void setSerialConfiguration_08008c44(HardwareSerial *serial, ulong baudrate, byte config) {\n  byte parity = 0;\n  byte stopbits = 0;\n  byte databits = 0;\n  int bits = 0;\n  serial->baudrate = baudrate;\n  serial->_config = config;\n  byte configMask = config & 7;\n  if (configMask == 4) {\n    bits = 7;\n  }\n  else if (configMask == 6) {\n    bits = 8;\n  }\n  else if (configMask == 2) {\n    bits = 6;\n  }\n  if ((config & 0x30) == 0x30) {\n    parity = 0x600;\n    bits++;\n  }\n  else if ((config & 0x20) == 0) {\n    parity = 0;\n  }\n  else {\n    parity = 0x400;\n    bits++;\n  }\n  if ((config & 8) == 0) {\n    stopbits = 0;\n  }\n  else {\n    stopbits = 0x2000;\n  }\n  if (bits == 8) {\n    databits = 0;\n  }\n  else if (bits == 9) {\n    databits = 0x1000;\n  }\n  if (bits != 0) {\n    uart_init((serial_t *)&serial->_serial);\n    uart_attach_rx_callback((serial_t *)&serial->_serial, receiveSerialData);\n    return;\n  }\n  __assert_func(PTR_s__home_bo__arduino15_packages_STM_08008cfc,299,PTR___PRETTY_FUNCTION___08008cf8, PTR_s_databits__0_08008cf4);\n}\n",
            "called": [
                "uart_attach_rx_callback",
                "__assert_func",
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008c44",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "setSerialConfiguration_08008c44"
        },
        "FUN_08006060": {
            "renaming": {
                "FUN_08006060": "configure_timer_08006060",
                "htim": "timer",
                "htim->State": "timer->state",
                "HAL_TIM_STATE_RESET": "HAL_TIM_STATE_RESET",
                "htim->Lock": "timer->lock",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIM_OC_MspInit": "HAL_TIM_OC_MspInit",
                "htim->Instance": "timer->instance",
                "&htim->Init": "&(timer->init)",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_OK": "HAL_OK",
                "HAL_ERROR": "HAL_ERROR"
            },
            "code": "HAL_StatusTypeDef_conflict configure_timer_08006060(TIM_HandleTypeDef_conflict *timer)\n{\n  if (timer != NULL) {\n    if (timer->State == HAL_TIM_STATE_RESET) {\n      timer->Lock = HAL_UNLOCKED;\n      HAL_TIM_OC_MspInit(timer);\n    }\n    timer->State = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(timer->Instance, &(timer->Init));\n    timer->State = HAL_TIM_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "TIM_Base_SetConfig",
                "HAL_TIM_OC_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006060",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "configure_timer_08006060"
        },
        "FUN_08009698": {
            "renaming": {
                "FUN_08009698": "FUNC_08009698"
            },
            "code": "\nuint FUNC_08009698(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint *puVar3;\n  void *pvVar4;\n  int iVar5;\n  undefined *puVar6;\n  uint uVar7;\n  uint **ppuVar8;\n  uint uVar9;\n  uint uVar10;\n  undefined *puVar11;\n  undefined *__s;\n  uint local_24 [2];\n  \n  bVar1 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  if (bVar1 != 0x6e) {\n    if (bVar1 < 0x6f) {\n      if (bVar1 != 99) {\n        if (bVar1 < 100) {\n          if (bVar1 == 0) goto LAB_08009852;\n          if (bVar1 != 0x58) goto LAB_080096c8;\n          *(undefined *)((int)param_2 + 0x45) = 0x58;\n          puVar6 = PTR_s_0123456789ABCDEF_080098d4;\nLAB_080097e2:\n          uVar7 = *param_2;\n          puVar3 = *param_5;\n          *param_5 = puVar3 + 1;\n          if (((uVar7 & 0x80) == 0) && ((int)(uVar7 << 0x19) < 0)) {\n            uVar9 = (uint)*(ushort *)puVar3;\n          }\n          else {\n            uVar9 = *puVar3;\n          }\n          if ((int)(uVar7 << 0x1f) < 0) {\n            *param_2 = uVar7 | 0x20;\n          }\n          if (uVar9 == 0) {\n            *param_2 = *param_2 & 0xffffffdf;\n          }\n          uVar7 = 0x10;\nLAB_08009778:\n          *(undefined *)((int)param_2 + 0x43) = 0;\n        }\n        else {\n          if ((bVar1 != 100) && (bVar1 != 0x69)) goto LAB_080096c8;\n          uVar9 = *param_2;\n          puVar3 = *param_5;\n          if ((uVar9 & 0x80) == 0) {\n            *param_5 = puVar3 + 1;\n            if ((uVar9 & 0x40) == 0) goto LAB_080096e8;\n            uVar9 = (uint)(short)*(ushort *)puVar3;\n          }\n          else {\n            *param_5 = puVar3 + 1;\nLAB_080096e8:\n            uVar9 = *puVar3;\n          }\n          if ((int)uVar9 < 0) {\n            uVar9 = -uVar9;\n            *(undefined *)((int)param_2 + 0x43) = 0x2d;\n          }\n          uVar7 = 10;\n          puVar6 = PTR_s_0123456789ABCDEF_080098d4;\n        }\n        uVar10 = param_2[1];\n        param_2[2] = uVar10;\n        puVar11 = __s;\n        if ((int)uVar10 < 0) {\n          if (uVar9 != 0) goto LAB_08009816;\nLAB_080098c4:\n          *(undefined *)((int)param_2 + 0x42) = *puVar6;\n          puVar11 = (undefined *)((int)param_2 + 0x42);\n        }\n        else {\n          *param_2 = *param_2 & 0xfffffffb;\n          if (uVar9 == 0) {\n            if (uVar10 != 0) goto LAB_080098c4;\n          }\n          else {\nLAB_08009816:\n            do {\n              uVar10 = uVar9 / uVar7;\n              puVar11 = puVar11 + -1;\n              *puVar11 = puVar6[uVar9 - uVar7 * uVar10];\n              uVar9 = uVar10;\n            } while (uVar10 != 0);\n          }\n        }\n        if (((uVar7 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4]))\n        {\n          puVar11[-1] = 0x30;\n          puVar11 = puVar11 + -1;\n        }\n        param_2[4] = (int)__s - (int)puVar11;\n        __s = puVar11;\n        goto LAB_080097be;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      *(char *)((int)param_2 + 0x42) = (char)*puVar3;\nLAB_08009728:\n      __s = (undefined *)((int)param_2 + 0x42);\n      uVar9 = 1;\n    }\n    else {\n      if (bVar1 != 0x73) {\n        if (bVar1 < 0x74) {\n          if (bVar1 == 0x6f) {\nLAB_0800974e:\n            uVar9 = *param_2;\n            puVar3 = *param_5;\n            if ((uVar9 & 0x80) == 0) {\n              *param_5 = puVar3 + 1;\n              if ((uVar9 & 0x40) == 0) goto LAB_0800975c;\n              uVar9 = (uint)*(ushort *)puVar3;\n            }\n            else {\n              *param_5 = puVar3 + 1;\nLAB_0800975c:\n              uVar9 = *puVar3;\n            }\n            puVar6 = PTR_s_0123456789ABCDEF_080098d4;\n            if (bVar1 == 0x6f) {\n              uVar7 = 8;\n            }\n            else {\n              uVar7 = 10;\n            }\n            goto LAB_08009778;\n          }\n          if (bVar1 == 0x70) {\n            *param_2 = *param_2 | 0x20;\nLAB_0800970e:\n            puVar6 = PTR_s_0123456789abcdef_080098d0;\n            *(undefined *)((int)param_2 + 0x45) = 0x78;\n            goto LAB_080097e2;\n          }\n        }\n        else {\n          if (bVar1 == 0x75) goto LAB_0800974e;\n          if (bVar1 == 0x78) goto LAB_0800970e;\n        }\nLAB_080096c8:\n        *(byte *)((int)param_2 + 0x42) = bVar1;\n        goto LAB_08009728;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      __s = (undefined *)*puVar3;\n      pvVar4 = memchr(__s,0,param_2[1]);\n      if (pvVar4 != (void *)0x0) {\n        param_2[1] = (int)pvVar4 - (int)__s;\n      }\n      uVar9 = param_2[1];\n    }\n    param_2[4] = uVar9;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_080097be;\n  }\n  uVar9 = *param_2;\n  ppuVar8 = (uint **)*param_5;\n  uVar7 = param_2[5];\n  if ((uVar9 & 0x80) == 0) {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\n    if ((uVar9 & 0x40) == 0) goto LAB_0800983e;\n    *(short *)puVar3 = (short)uVar7;\n  }\n  else {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\nLAB_0800983e:\n    *puVar3 = uVar7;\n  }\nLAB_08009852:\n  param_2[4] = 0;\nLAB_080097be:\n  iVar2 = _printf_common(param_1,param_2,local_24,param_3,param_4);\n  if ((iVar2 == -1) || (iVar2 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar2 == -1)) {\nLAB_080097d2:\n    uVar9 = 0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar2 = 0; iVar2 < (int)(param_2[3] - local_24[0]); iVar2 = iVar2 + 1) {\n        iVar5 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar5 == -1) goto LAB_080097d2;\n      }\n    }\n    uVar9 = param_2[3];\n    if ((int)param_2[3] < (int)local_24[0]) {\n      uVar9 = local_24[0];\n    }\n  }\n  return uVar9;\n}\n\n",
            "called": [
                "_printf_common",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08009698",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "FUNC_08009698"
        },
        "FUN_08006186": {
            "renaming": {
                "FUN_08006186": "configureTimer_08006186",
                "htim": "timerHandle",
                "sConfig": "config",
                "Channel": "channel",
                "Lock": "isLocked",
                "State": "state",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "TIM_OC1_SetConfig": "TIM_OC1_SetConfig",
                "TIM_OC2_SetConfig": "TIM_OC2_SetConfig",
                "TIM_OC3_SetConfig": "TIM_OC3_SetConfig",
                "TIM_OC4_SetConfig": "TIM_OC4_SetConfig",
                "Instance": "instance",
                "CCMR1": "CCMR1",
                "CCMR2": "CCMR2",
                "OCFastMode": "OCFastMode"
            },
            "code": "HAL_StatusTypeDef configureTimer_08006186(TIM_HandleTypeDef *timerHandle, TIM_OC_InitTypeDef *config, uint32_t channel) {\n  if (timerHandle->isLocked != HAL_LOCKED) {\n    timerHandle->isLocked = HAL_LOCKED;\n    timerHandle->state = HAL_TIM_STATE_BUSY;\n    switch(channel) {\n    case 0:\n      TIM_OC1_SetConfig(timerHandle->instance, config);\n      timerHandle->instance->CCMR1 |= 8;\n      timerHandle->instance->CCMR1 &= 0xfffffffb;\n      timerHandle->instance->CCMR1 |= config->OCFastMode;\n      break;\n    case 4:\n      TIM_OC2_SetConfig(timerHandle->instance, config);\n      timerHandle->instance->CCMR1 |= 0x800;\n      timerHandle->instance->CCMR1 &= 0xfffffbff;\n      timerHandle->instance->CCMR1 |= config->OCFastMode << 8;\n      break;\n    case 8:\n      TIM_OC3_SetConfig(timerHandle->instance, config);\n      timerHandle->instance->CCMR2 |= 8;\n      timerHandle->instance->CCMR2 &= 0xfffffffb;\n      timerHandle->instance->CCMR2 |= config->OCFastMode;\n      break;\n    case 0xc:\n      TIM_OC4_SetConfig(timerHandle->instance, config);\n      timerHandle->instance->CCMR2 |= 0x800;\n      timerHandle->instance->CCMR2 &= 0xfffffbff;\n      timerHandle->instance->CCMR2 |= config->OCFastMode << 8;\n    }\n    timerHandle->state = HAL_TIM_STATE_READY;\n    timerHandle->isLocked = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}",
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006186",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configureTimer_08006186"
        },
        "FUN_08006b7c": {
            "renaming": {
                "FUN_08006b7c": "get_gpio_for_port_08006b7c",
                "port_idx": "port_index",
                "DAT_08006ba4": "GPIO_PORTA",
                "DAT_08006ba8": "GPIO_PORTC",
                "DAT_08006bac": "GPIO_PORTD",
                "DAT_08006bb0": "GPIO_PORTE",
                "DAT_08006bb4": "GPIO_PORTB"
            },
            "code": "GPIO_TypeDef* get_gpio_for_port_08006b7c(uint32_t port_index) {\n  switch(port_index) {\n    case 0:\n      return DAT_08006ba4;\n    case 1:\n      return DAT_08006bb4;\n    case 2:\n      return DAT_08006ba8;\n    case 3:\n      return DAT_08006bac;\n    case 4:\n      return DAT_08006bb0;\n    default:\n      return (GPIO_TypeDef*)0x0;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b7c",
            "calling": [
                "digitalRead",
                "digitalWrite"
            ],
            "imported": false,
            "current_name": "get_gpio_for_port_08006b7c"
        },
        "FUN_08008e7c": {
            "renaming": {
                "__thiscall Print::FUN_08008e7c": "printNumber",
                "this": "this",
                "n": "number",
                "base": "base",
                "cVar1": "digit",
                "sVar2": "length",
                "sVar3": "bytes_written",
                "uVar4": "remainder",
                "uVar5": "base_uint",
                "uVar6": "quotient",
                "__s": "end_of_buffer",
                "buf": "buffer",
                "FUN_08008e7c": "printNumber_08008e7c"
            },
            "code": "size_t __thiscall Print::printNumber_08008e7c(Print *this, ulong number, uint8_t base) {\n  char digit;\n  size_t length;\n  size_t bytes_written;\n  uint base_uint = (uint)base;\n  char buffer[33];\n  buffer[32] = '\\0';\n  if (base_uint < 2) {\n    base_uint = 10;\n  }\n  char *end_of_buffer = buffer + 0x20;\n  do {\n    uint quotient = number / base_uint;\n    uint remainder = (number & 0xff) - (quotient * base_uint & 0xff) & 0xff;\n    end_of_buffer--;\n    digit = (char)remainder;\n    if (remainder < 10) {\n      digit += '0';\n    }\n    else {\n      digit += '7';\n    }\n    *end_of_buffer = digit;\n    number = quotient;\n  } while (number != 0);\n  if (end_of_buffer == (char *)0x0) {\n    length = 0;\n  }\n  else {\n    length = strlen(end_of_buffer);\n    bytes_written = (*this->_vptr_Print[1])(length,end_of_buffer,length);\n  }\n  return bytes_written;\n}",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e7c",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "printNumber_08008e7c"
        },
        "FUN_0800a194": {
            "renaming": {
                "std::ctype_byname<char>::FUN_0800a194": "set_pointers_to_one",
                "PTR_id_0800a228": "int_pointer_1",
                "PTR_id_0800a22c": "int_pointer_2",
                "PTR_id_0800a230": "int_pointer_3",
                "PTR_id_0800a234": "int_pointer_4",
                "PTR_id_0800a238": "int_pointer_5",
                "PTR_id_0800a23c": "int_pointer_6",
                "PTR_id_0800a240": "int_pointer_7",
                "PTR_id_0800a244": "int_pointer_8",
                "PTR_id_0800a248": "int_pointer_9",
                "PTR_id_0800a24c": "int_pointer_10",
                "PTR_id_0800a250": "int_pointer_11",
                "PTR_id_0800a254": "int_pointer_12",
                "undefined4": "undefined",
                "std::basic_string<char, std::char_traits<char>, std::allocator<char> >": "string",
                "FUN_0800a194": "set_pointers_to_one_0800a194"
            },
            "code": "void set_pointers_to_one_0800a194(void)\n{\n    if (*PTR_id_0800a228 << 0x1f) {\n        *undefined_pointer_1 = 1;\n    }\n    if (*PTR_id_0800a22c << 0x1f) {\n        *undefined_pointer_2 = 1;\n    }\n    if (*PTR_id_0800a230 << 0x1f) {\n        *undefined_pointer_3 = 1;\n    }\n    if (*PTR_id_0800a234 << 0x1f) {\n        *undefined_pointer_4 = 1;\n    }\n    if (*PTR_id_0800a238 << 0x1f) {\n        *undefined_pointer_5 = 1;\n    }\n    if (*PTR_id_0800a23c << 0x1f) {\n        *undefined_pointer_6 = 1;\n    }\n    if (*PTR_id_0800a240 << 0x1f) {\n        *undefined_pointer_7 = 1;\n    }\n    if (*PTR_id_0800a244 << 0x1f) {\n        *undefined_pointer_8 = 1;\n    }\n    if (*PTR_id_0800a248 << 0x1f) {\n        *undefined_pointer_9 = 1;\n    }\n    if (*PTR_id_0800a24c << 0x1f) {\n        *undefined_pointer_10 = 1;\n    }\n    if (*PTR_id_0800a250 << 0x1f) {\n        *undefined_pointer_11 = 1;\n    }\n    if (*PTR_id_0800a254 << 0x1f) {\n        *undefined_pointer_12 = 1;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a194",
            "calling": [],
            "imported": false,
            "current_name": "set_pointers_to_one_0800a194"
        },
        "FUN_08003aa0": {
            "renaming": {
                "FUN_08003aa0": "enable_ADC_08003aa0",
                "*hadc": "*ADC_handle",
                "HVar1": "status",
                "*pAVar2": "*ADC_instance",
                "DAT_08003b84": "PTR_DAT_08003b84",
                "JOFR1": "JOFR1",
                "ADC_Enable": "ADC_Enable",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef_conflict",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_OK": "HAL_OK",
                "State": "State",
                "ErrorCode": "ErrorCode",
                "Lock": "Lock",
                "SR": "SR",
                "CR1": "CR1",
                "CR2": "CR2"
            },
            "code": "HAL_StatusTypeDef_conflict enable_ADC_08003aa0(ADC_HandleTypeDef *ADC_handle)\n{\n  HAL_StatusTypeDef_conflict status;\n  ADC_TypeDef *ADC_instance;\n\n  if (ADC_handle->Lock != HAL_LOCKED) {\n    ADC_handle->Lock = HAL_LOCKED;\n    status = ADC_Enable(ADC_handle);\n    if (status == HAL_OK) {\n      ADC_handle->State = (ADC_handle->State & 0xfffffcfe) | 0x100;\n      ADC_instance = ADC_handle->Instance;\n      if ((ADC_instance == DAT_08003b84) && ((DAT_08003b84[-0xd].JOFR1 & 0xf0000) != 0)) {\n        ADC_handle->State |= 0x100000;\n        if ((*(uint *)(PTR_DAT_08003b88 + 4) & 0x400) != 0) {\n          ADC_handle->State = (ADC_handle->State & 0xffffcfff) | 0x1000;\n        }\n      }\n      else {\n        ADC_handle->State &= 0xffefffff;\n        if ((ADC_instance->CR1 & 0x400) != 0) {\n          ADC_handle->State = (ADC_handle->State & 0xffffcfff) | 0x1000;\n        }\n      }\n      if ((ADC_handle->State & 0x1000) == 0) {\n        ADC_handle->ErrorCode = 0;\n      }\n      else {\n        ADC_handle->ErrorCode &= 0xfffffff9;\n      }\n      ADC_handle->Lock = HAL_UNLOCKED;\n      ADC_instance->SR = 0xfffffffd;\n      ADC_instance = ADC_handle->Instance;\n      if (((ADC_instance->CR2 & 0xe0000) == 0xe0000) && ((ADC_instance != DAT_08003b84) || ((DAT_08003b84[-0xd].JOFR1 & 0xf0000) == 0))) {\n        ADC_instance->CR2 |= 0x500000;\n      }\n      else {\n        ADC_instance->CR2 |= 0x100000;\n      }\n    }\n    else {\n      ADC_handle->Lock = HAL_UNLOCKED;\n    }\n    return status;\n  }\n  return HAL_BUSY;\n}",
            "called": [
                "ADC_Enable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003aa0",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "enable_ADC_08003aa0"
        },
        "FUN_08005fe8": {
            "renaming": {
                "FUN_08005fe8": "initialize_timer_08005fe8",
                "TIMx": "timer",
                "Structure": "init_structure",
                "uVar1": "cr1_value",
                "DAT_0800605c": "timer1"
            },
            "code": "void initialize_timer_08005fe8(TIM_TypeDef_conflict *timer,TIM_Base_InitTypeDef_conflict *init_structure)\n{\n    uint32_t cr1_value = timer->CR1;\n    if ((((timer == DAT_0800605c) || (timer == timer2)) || (timer == &DAT_0800605c->DMAR)) || (timer == &DAT_0800605c->SMCR)) {\n        cr1_value = cr1_value & 0xffffff8f | init_structure->CounterMode;\n    }\n    if (((timer == DAT_0800605c) || (timer == timer2)) || ((timer == &DAT_0800605c->DMAR || (timer == &DAT_0800605c->SMCR)))) {\n        cr1_value = cr1_value & 0xfffffcff | init_structure->ClockDivision;\n    }\n    timer->CR1 = cr1_value & 0xffffff7f | init_structure->AutoReloadPreload;\n    timer->ARR = init_structure->Period;\n    timer->PSC = init_structure->Prescaler;\n    if (timer == DAT_0800605c) {\n        timer->RCR = init_structure->RepetitionCounter;\n    }\n    timer->EGR = 1;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005fe8",
            "calling": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_OC_Init"
            ],
            "imported": false,
            "current_name": "initialize_timer_08005fe8"
        },
        "FUN_08003ce8": {
            "renaming": {
                "FUN_08003ce8": "stop_ADC_conversion_08003ce8",
                "*hadc": "*adc_handle",
                "HVar1": "status"
            },
            "code": "HAL_StatusTypeDef_conflict stop_ADC_conversion_08003ce8(ADC_HandleTypeDef *adc_handle) {\n    HAL_StatusTypeDef_conflict status;\n    if (adc_handle == NULL) {\n        status = HAL_ERROR;\n    }\n    else {\n        adc_handle->State |= 2; // Set state to conversion stopped\n        status = ADC_ConversionStop_Disable(adc_handle);\n        if (status == HAL_OK) {\n            // Reset ADC registers to default values\n            adc_handle->Instance->SR = 0xffffffe0;\n            adc_handle->Instance->CR1 &= DAT_08003ddc;\n            adc_handle->Instance->CR2 &= DAT_08003de0;\n            adc_handle->Instance->SMPR1 &= 0xff000000;\n            adc_handle->Instance->SMPR2 &= 0xc0000000;\n            adc_handle->Instance->JOFR1 &= 0xfffff000;\n            adc_handle->Instance->JOFR2 &= 0xfffff000;\n            adc_handle->Instance->JOFR3 &= 0xfffff000;\n            adc_handle->Instance->JOFR4 &= 0xfffff000;\n            adc_handle->Instance->HTR &= 0xfffff000;\n            adc_handle->Instance->LTR &= 0xfffff000;\n            adc_handle->Instance->SQR1 &= 0xff000000;\n            adc_handle->Instance->SQR2 &= 0xc0000000;\n            adc_handle->Instance->SQR3 &= 0xc0000000;\n            adc_handle->Instance->JSQR &= 0xffc00000;\n            HAL_ADC_MspDeInit(adc_handle);\n            adc_handle->ErrorCode = 0;\n            adc_handle->State = 0; // Set state to ready\n        }\n        adc_handle->Lock = HAL_UNLOCKED;\n    }\n    return status;\n}",
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ce8",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "stop_ADC_conversion_08003ce8"
        },
        "FUN_0800738a": {
            "renaming": {
                "FUN_0800738a": "is_valid_pin_0800738a",
                "pin": "pin_name",
                "map": "pin_map"
            },
            "code": "_Bool is_valid_pin_0800738a(PinName_conflict pin, PinMap_conflict *pin_map) {\n        if (pin == NC) {\n            return false;\n        }\n        while (true) {\n            if (pin_map->pin == NC) {\n                return false;\n            }\n            if (pin == pin_map->pin) {\n                break;\n            }\n            pin_map++;\n        }\n        return true;\n    }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800738a",
            "calling": [
                "enableI2CPins",
                "analogWrite",
                "pinMode",
                "sysexCallback",
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "is_valid_pin_0800738a"
        },
        "FUN_08002948": {
            "renaming": {
                "FUN_08002948": "initializeWireIfNecessary_08002948",
                "__initialize_p": "shouldInitialize",
                "__priority": "priority"
            },
            "code": "void initializeWireIfNecessary_08002948(int shouldInitialize, int priority) {\n  if (shouldInitialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    TwoWire::TwoWire((TwoWire *)PTR_Wire_08002964);\n  }\n  return;\n}",
            "called": [
                "TwoWire"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002948",
            "calling": [
                "_GLOBAL__sub_I__ZN7TwoWire8rxBufferE"
            ],
            "imported": false,
            "current_name": "initializeWireIfNecessary_08002948"
        },
        "FUN_08009e64": {
            "renaming": {
                "FUN_08009e64": "check_file_permissions_08009e64",
                "param_1": "file_descriptor",
                "param_2": "file_info_offset",
                "param_3": "result_code",
                "param_4": "file_permissions",
                "iVar1": "file_status",
                "uVar2": "permissions",
                "auStack_4c": "stack",
                "local_48": "file_status_mask"
            },
            "code": "int check_file_permissions_08009e64(int file_descriptor, int file_info_offset, int* result_code, unsigned int* file_permissions) {\n    int file_status;\n    unsigned int permissions = 0;\n    if (*(short *)(file_info_offset + 0xe) < 0 || (_fstat_r(file_descriptor, (int)*(short *)(file_info_offset + 0xe), &file_status) < 0)) {\n        *result_code = 0;\n        if ((int)((uint)*(ushort *)(file_info_offset + 0xc) << 0x18) < 0) {\n            permissions = 0x40;\n        }\n    }\n    else {\n        permissions = (unsigned int)((file_status & 0xf000) == 0x2000);\n        *result_code = 0;\n    }\n    *file_permissions = permissions | 0x400;\n    return 0;\n}",
            "called": [
                "_fstat_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009e64",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_file_permissions_08009e64"
        },
        "FUN_08002acc": {
            "renaming": {
                "TwoWire::FUN_08002acc": "resize_rx_buffer",
                "length": "new_length",
                "puVar1": "rx_buffer_ptr",
                "pvVar2": "new_buffer_ptr",
                "uVar3": "new_buffer_length",
                "FUN_08002acc": "resize_rx_buffer_08002acc"
            },
            "code": "void resize_rx_buffer_08002acc(size_t new_length) {\n  undefined *rx_buffer_ptr;\n  void *new_buffer_ptr;\n  undefined new_buffer_length;\n  rx_buffer_ptr = rx_buffer;\n  if ((byte)*rx_buffer_allocated < new_length) {\n    if (new_length < 0x20) {\n      new_length = 0x20;\n    }\n    new_buffer_ptr = realloc(*(void **)rx_buffer,new_length);\n    *(void **)rx_buffer_ptr = new_buffer_ptr;\n    if (new_buffer_ptr == (void *)0x0) {\n      new_buffer_length = 0;\n    }\n    else {\n      new_buffer_length = (undefined)new_length;\n    }\n    *rx_buffer_allocated = new_buffer_length;\n  }\n  return;\n}",
            "called": [
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002acc",
            "calling": [
                "requestFrom",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "resize_rx_buffer_08002acc"
        },
        "FUN_0800932c": {
            "renaming": {
                "FUN_0800932c": "write_byte_to_buffer_0800932c",
                "param_1": "buffer_size",
                "param_2": "byte_to_write",
                "param_3": "buffer_ptr",
                "pbVar2": "last_position_in_buffer",
                "uVar1": "result",
                "*pbVar2": "*last_position_in_buffer",
                "*param_3": "*buffer_ptr",
                "pbVar2 + 1": "current_position_in_buffer + 1",
                "*pbVar2 = param_2": "*current_position_in_buffer = byte_to_write",
                "uint": "unsigned int",
                "byte": "char",
                "&&": "and",
                "||": "or"
            },
            "code": "unsigned int write_byte_to_buffer_0800932c(unsigned int buffer_size, char byte_to_write, char **buffer_ptr) {\n  unsigned int result;\n  char *current_position_in_buffer = *buffer_ptr;\n  char *last_position_in_buffer = (*buffer_ptr + buffer_size) - 1;\n  if (((int)last_position_in_buffer < 0) && (((int)last_position_in_buffer < (int)(*buffer_ptr + 6) || (byte_to_write == 10)))) {\n    result = __swbuf_r();\n    return result;\n  }\n  *current_position_in_buffer = byte_to_write;\n  *buffer_ptr = current_position_in_buffer + 1;\n  return (unsigned int)byte_to_write;\n}",
            "called": [
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800932c",
            "calling": [
                "__sfputs_r"
            ],
            "imported": false,
            "current_name": "write_byte_to_buffer_0800932c"
        },
        "FUN_080099a4": {
            "renaming": {
                "FUN_080099a4": "find_substring_080099a4",
                "__haystack": "string",
                "__needle": "substring",
                "pcVar1": "potential_match",
                "pcVar2": "current_char",
                "pcVar3": "current_substring_char"
            },
            "code": "char *find_substring_080099a4(char *string, char *substring) {\\n    char *current_char;\\n    char *current_substring_char;\\n    char *potential_match;\\n    \\n    if (*string == \"\\0\") {\\n        if (*substring != \"\\0\") {\\n            string = NULL;\\n        }\\n        return string;\\n    }\\n    \\n    do {\\n        potential_match = string;\\n        if (*potential_match == \"\\0\") {\\n            return NULL;\\n        }\\n        current_substring_char = substring + -1;\\n        current_char = potential_match + -1;\\n        do {\\n            current_substring_char = current_substring_char + 1;\\n            if (*current_substring_char == \"\\0\") {\\n                return potential_match;\\n            }\\n            current_char = current_char + 1;\\n            string = potential_match + 1;\\n        } while (*current_char == *current_substring_char);\\n    } while( true );\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080099a4",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "find_substring_080099a4"
        },
        "FUN_08005a1c": {
            "renaming": {
                "FUN_08005a1c": "get_SystemCoreClock_08005a1c",
                "PTR_SystemCoreClock_08005a24": "system_core_clock_ptr"
            },
            "code": "uint32_t get_SystemCoreClock_08005a1c(void)\n{\n  uint32_t* PTR_SystemCoreClock_08005a24 = (uint32_t*)PTR_SystemCoreClock_08005a24;\n  return *PTR_SystemCoreClock_08005a24;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a1c",
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "SystemClock_Config",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "imported": false,
            "current_name": "get_SystemCoreClock_08005a1c"
        },
        "FUN_08006b0c": {
            "renaming": {
                "FUN_08006b0c": "reset_uart_transfer_counts_08006b0c",
                "hdma": "dma_handle",
                "huart": "uart_handle",
                "RxXferCount": "rx_transfer_count",
                "TxXferCount": "tx_transfer_count",
                "HAL_UART_ErrorCallback": "handle_uart_error"
            },
            "code": "void reset_uart_transfer_counts_08006b0c(DMA_HandleTypeDef_conflict *dma_handle)\n{\n  UART_HandleTypeDef *uart_handle;\n  uart_handle = (UART_HandleTypeDef *)dma_handle->Parent;\n  uart_handle->RxXferCount = 0;\n  uart_handle->TxXferCount = 0;\n  HAL_UART_ErrorCallback(uart_handle);\n  return;\n}",
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b0c",
            "calling": [],
            "imported": false,
            "current_name": "reset_uart_transfer_counts_08006b0c"
        },
        "FUN_08001cd0": {
            "renaming": {
                "FUN_08001cd0": "FUNC_08001cd0"
            },
            "code": "\nvoid FUNC_08001cd0(byte command,byte argc,byte *argv)\n\n{\n  byte bVar1;\n  uint8_t address;\n  byte bVar2;\n  byte bVar3;\n  byte bVar4;\n  byte bVar5;\n  char cVar6;\n  undefined *puVar7;\n  undefined *this;\n  PinName_conflict PVar8;\n  _Bool _Var9;\n  byte bVar10;\n  uint32_t uVar11;\n  uint uVar12;\n  int iVar13;\n  int iVar14;\n  char cVar15;\n  uint uVar16;\n  int iVar17;\n  bool bVar18;\n  \n  this = PTR_Firmata_080022e8;\n  puVar7 = PTR_Firmata_08002044;\n  uVar16 = (uint)argc;\n  switch(command) {\n  case 'i':\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf0);\n    firmata::FirmataClass::write((FirmataClass *)this,'j');\n    for (uVar16 = 0; uVar16 < 0x3c; uVar16 = uVar16 + 1 & 0xff) {\n      uVar12 = uVar16 - 0x2e & 0xff;\n      bVar10 = (byte)uVar12;\n      if (uVar12 < 0xe) {\n        if (uVar16 < 0x3c) {\n          PVar8 = PTR_digitalPin_080022e4[uVar16];\n        }\n        else {\n          PVar8 = NC;\n        }\n        uVar11 = pinNametoDigitalPin(PVar8);\n        if (uVar11 == 0) {\n          bVar10 = '\\x7f';\n        }\n        else {\n          if (uVar16 < 0x3c) {\n            PVar8 = PTR_digitalPin_080022e4[uVar16];\n          }\n          else {\n            PVar8 = NC;\n          }\n          uVar11 = pinNametoDigitalPin(PVar8);\n          if (uVar11 == 1) {\n            bVar10 = '\\x7f';\n          }\n        }\n      }\n      else {\n        bVar10 = '\\x7f';\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,bVar10);\n    }\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n    break;\n  case 'k':\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_08002044,0xf0);\n    firmata::FirmataClass::write((FirmataClass *)puVar7,'l');\n    for (uVar16 = 0; uVar16 < 0x3c; uVar16 = uVar16 + 1 & 0xff) {\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_08002044;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_08002044,'\\0');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\v');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n      }\n      if ((uVar16 - 0x2e & 0xff) < 0xe) {\n        if (uVar16 < 0x3c) {\n          PVar8 = PTR_digitalPin_08002060[uVar16];\n        }\n        else {\n          PVar8 = NC;\n        }\n        uVar11 = pinNametoDigitalPin(PVar8);\n        if (uVar11 == 0) {\n          bVar18 = false;\n        }\n        else {\n          if (uVar16 < 0x3c) {\n            PVar8 = PTR_digitalPin_08002060[uVar16];\n          }\n          else {\n            PVar8 = NC;\n          }\n          uVar11 = pinNametoDigitalPin(PVar8);\n          if (uVar11 == 1) {\n            bVar18 = false;\n          }\n          else {\n            bVar18 = true;\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x02');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\n');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          _Var9 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            _Var9 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              _Var9 = false;\n            }\n            else {\n              _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                    (PinMap_conflict *)PTR_PinMap_PWM_080022ec);\n            }\n          }\n        }\n      }\n      else {\n        _Var9 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (_Var9 != false) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x03');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\b');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x04');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x0e');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          _Var9 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            _Var9 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              _Var9 = false;\n            }\n            else {\n              _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                    (PinMap_conflict *)PTR_PinMap_I2C_SDA_080022f0);\n              if (!_Var9) {\n                _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                      (PinMap_conflict *)PTR_PinMap_I2C_SCL_080022f4);\n              }\n            }\n          }\n        }\n      }\n      else {\n        _Var9 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (_Var9 != false) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x06');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x7f');\n    }\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n    return;\n  case 'm':\n    if (uVar16 != 0) {\n      bVar1 = *argv;\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf0);\n      firmata::FirmataClass::write((FirmataClass *)this,'n');\n      firmata::FirmataClass::write((FirmataClass *)this,bVar1);\n      if (bVar1 < 0x3c) {\n        bVar10 = firmata::FirmataClass::getPinMode((FirmataClass *)this,bVar1);\n        firmata::FirmataClass::write((FirmataClass *)this,bVar10);\n        iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n        firmata::FirmataClass::write((FirmataClass *)this,(byte)iVar13 & 0x7f);\n        uVar16 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n        if ((uVar16 & 0xff80) != 0) {\n          iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n          firmata::FirmataClass::write((FirmataClass *)this,(byte)((uint)(iVar13 << 0x12) >> 0x19));\n        }\n        uVar16 = firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_080022e8,bVar1);\n        puVar7 = PTR_Firmata_080022e8;\n        if ((uVar16 & 0xc000) != 0) {\n          iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_080022e8,bVar1);\n          firmata::FirmataClass::write((FirmataClass *)puVar7,(byte)((uint)(iVar13 << 0xb) >> 0x19))\n          ;\n        }\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n      return;\n    }\n    break;\n  case 'o':\n    if (1 < uVar16) {\n      uVar12 = (uint)argv[1];\n      if (2 < uVar16) {\n        uVar12 = uVar12 | (uint)argv[2] << 7;\n      }\n      if (3 < uVar16) {\n        uVar12 = uVar12 | (uint)argv[3] << 0xe;\n      }\n      analogWriteCallback(*argv,uVar12);\n      return;\n    }\n    break;\n  case 'p':\n    if (4 < uVar16) {\n      bVar1 = *argv;\n      uVar16 = (uint)bVar1;\n      bVar2 = argv[1];\n      bVar3 = argv[2];\n      bVar4 = argv[3];\n      bVar5 = argv[4];\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_08002060[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      if (bVar18) {\n        if ((byte)PTR_servoPinMap_08002064[uVar16] < 0xc) {\n          bVar18 = Servo::attached((Servo *)(PTR_servos_08002068 +\n                                            (uint)(byte)PTR_servoPinMap_08002064[uVar16] * 3));\n        }\n        else {\n          bVar18 = false;\n        }\n        if (bVar18 != false) {\n          detachServo(bVar1);\n        }\n        attachServo(bVar1,(uint)bVar2 + (uint)bVar3 * 0x80,(uint)bVar4 + (uint)bVar5 * 0x80);\n        setPinModeCallback(bVar1,4);\n        return;\n      }\n    }\n    break;\n  case 'v':\n    bVar1 = argv[1];\n    if ((bVar1 & 0x20) != 0) {\n      firmata::FirmataClass::sendString\n                ((FirmataClass *)PTR_Firmata_08002044,PTR_s_10_bit_addressing_not_supported_08002040\n                );\n      return;\n    }\n    address = *argv;\n    bVar18 = (bVar1 & 0x40) == 0;\n    if ((bVar1 & 0x18) < 0x19) {\n      switch(bVar1 & 0x18) {\n      case 0:\n        TwoWire::beginTransmission((TwoWire *)PTR_Wire_08002048,address);\n        for (uVar12 = 2; uVar12 < uVar16; uVar12 = uVar12 + 2 & 0xff) {\n          wireWrite(argv[uVar12 + 1] * -0x80 + argv[uVar12]);\n        }\n        TwoWire::endTransmission((TwoWire *)PTR_Wire_08002048);\n        return;\n      case 8:\n        if (uVar16 == 6) {\n          iVar13 = (uint)argv[2] + (uint)argv[3] * 0x80;\n          bVar10 = argv[4] + argv[5] * -0x80;\n        }\n        else {\n          bVar10 = argv[2] + argv[3] * -0x80;\n          iVar13 = -1;\n        }\n        readAndReportData(address,iVar13,bVar10,bVar18);\n        return;\n      case 0x10:\n        if ((char)*PTR_queryIndex_0800204c + 1 < 8) {\n          if (uVar16 == 6) {\n            iVar13 = (uint)argv[2] + (uint)argv[3] * 0x80;\n            cVar15 = argv[4] + argv[5] * -0x80;\n          }\n          else {\n            cVar15 = argv[2] + argv[3] * -0x80;\n            iVar13 = -1;\n          }\n          cVar6 = *PTR_queryIndex_0800204c + '\\x01';\n          *PTR_queryIndex_0800204c = cVar6;\n          puVar7 = PTR_query_08002050;\n          iVar14 = cVar6 * 0xc;\n          PTR_query_08002050[iVar14] = address;\n          *(int *)(puVar7 + iVar14 + 4) = iVar13;\n          puVar7[iVar14 + 8] = cVar15;\n          puVar7[iVar14 + 9] = bVar18;\n          return;\n        }\n        firmata::FirmataClass::sendString\n                  ((FirmataClass *)PTR_Firmata_08002044,PTR_s_too_many_queries_08002054);\n        return;\n      case 0x18:\n        cVar15 = *PTR_queryIndex_0800204c;\n        if (cVar15 < 1) {\n          *PTR_queryIndex_0800204c = 0xff;\n          return;\n        }\n      }\n      for (uVar16 = 0; iVar13 = cVar15 + 1, (int)uVar16 < iVar13; uVar16 = uVar16 + 1 & 0xff) {\n        if (address == PTR_query_08002050[uVar16 * 0xc]) goto LAB_08001e66;\n      }\n      uVar16 = 0;\nLAB_08001e66:\n      for (; puVar7 = PTR_query_08002050, (int)uVar16 < iVar13; uVar16 = uVar16 + 1 & 0xff) {\n        if (uVar16 < 8) {\n          iVar14 = (uVar16 + 1) * 0xc;\n          iVar17 = uVar16 * 0xc;\n          PTR_query_08002050[iVar17] = PTR_query_08002050[iVar14];\n          *(undefined4 *)(puVar7 + iVar17 + 4) = *(undefined4 *)(puVar7 + iVar14 + 4);\n          puVar7[iVar17 + 8] = puVar7[iVar14 + 8];\n          puVar7[iVar17 + 9] = puVar7[iVar14 + 9];\n        }\n      }\n      *PTR_queryIndex_0800204c = cVar15 + -1;\n      return;\n    }\n    break;\n  case 'x':\n    iVar13 = (uint)*argv + (uint)argv[1] * 0x80;\n    if ((1 < uVar16) && (iVar13 != 0)) {\n      *(int *)PTR_i2cReadDelayTime_08002058 = iVar13;\n    }\n    if (*PTR_isI2CEnabled_0800205c == '\\0') {\n      enableI2CPins();\n      return;\n    }\n    break;\n  case 'z':\n    if ((1 < uVar16) &&\n       (iVar13 = (uint)*argv + (uint)argv[1] * 0x80, *(int *)PTR_samplingInterval_0800206c = iVar13,\n       iVar13 == 0)) {\n      *(undefined4 *)PTR_samplingInterval_0800206c = 1;\n      return;\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "enableI2CPins",
                "attached",
                "pin_in_pinmap",
                "beginTransmission",
                "pinNametoDigitalPin",
                "wireWrite",
                "sendString",
                "write",
                "endTransmission",
                "attachServo",
                "getPinState",
                "detachServo",
                "getPinMode",
                "readAndReportData",
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08001cd0",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_08001cd0"
        },
        "FUN_08007320": {
            "renaming": {
                "FUN_08007320": "find_peripheral_by_pin_08007320",
                "pin": "pin_name",
                "map": "pin_map",
                "pvVar1": "peripheral"
            },
            "code": "void * find_peripheral_by_pin_08007320(PinName_conflict pin, PinMap_conflict *pin_map) {\n  void *peripheral = NULL;\n  if (pin != NC) {\n    peripheral = pinmap_find_peripheral(pin, pin_map);\n  }\n  return peripheral;\n}",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007320",
            "calling": [
                "pwm_stop",
                "uart_debug_init",
                "pwm_start",
                "uart_init",
                "adc_read_value",
                "i2c_custom_init",
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "find_peripheral_by_pin_08007320"
        },
        "FUN_080002ec": {
            "renaming": {
                "FUN_080002ec": "setDigitalPorts_080002ec",
                "port": "portIndex",
                "value": "portValue",
                "bVar1": "isPinValid",
                "bVar2": "pinModeValue",
                "uVar3": "portIndex",
                "uVar4": "pin",
                "iVar5": "pinState",
                "pin": "pinIndex",
                "ulPin": "pinIndex",
                "ulPin_00": "startPinIndex",
                "uVar6": "mask",
                "uVar7": "endPinIndex",
                "uVar8": "pinMask"
            },
            "code": "void setDigitalPorts_080002ec(byte port, int value) {\n  bool isPinValid;\n  byte pinIndex;\n  byte pinValue;\n  uint32_t pinMask = 0;\n  uint portIndex = (uint)port;\n  if (portIndex < 5) {\n    uint32_t startPinIndex = (portIndex & 0x1f) * 8;\n    uint32_t endPinIndex = startPinIndex + 8;\n    if (endPinIndex > 60) {\n      endPinIndex = 60;\n    }\n    uint32_t mask = 1;\n    for (uint32_t pinIndex = startPinIndex; pinIndex < endPinIndex; pinIndex++) {\n      if (pinIndex < 60) {\n        if (digitalPinMapping[pinIndex] == NC) {\n          isPinValid = false;\n        }\n        else {\n          uint32_t pin = pinNametoDigitalPin(digitalPinMapping[pinIndex]);\n          if (pin == 0 || pin == 1) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = true;\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        pinValue = (byte)((mask & value) != 0);\n        byte pinModeValue = Firmata.getPinMode(pinIndex);\n        if (pinModeValue == INPUT || pinModeValue == OUTPUT) {\n          if (pinModeValue == INPUT) {\n            pinMask = mask | pinMask;\n          }\n          else {\n            if (pinValue == 0) {\n              isPinValid = false;\n            }\n            else {\n              int pinState = Firmata.getPinState(pinIndex);\n              if (pinState == 1) {\n                isPinValid = false;\n              }\n            }\n            if (isPinValid) {\n              pinMode(pinIndex, OUTPUT);\n            }\n          }\n          Firmata.setPinState(pinIndex, pinValue);\n        }\n      }\n      mask = mask << 1;\n    }\n    for (uint32_t i = 0; i < 8; i++) {\n      if ((pinMask & (1 << i)) != 0) {\n        digitalWrite(startPinIndex + i, (value & (1 << i)) != 0);\n      }\n    }\n  }\n}",
            "called": [
                "digitalWrite",
                "pinNametoDigitalPin",
                "setPinState",
                "pinMode",
                "getPinState",
                "getPinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002ec",
            "calling": [],
            "imported": false,
            "current_name": "setDigitalPorts_080002ec"
        },
        "FUN_08000be8": {
            "renaming": {
                "FUN_08000be8": "send_digital_port_if_changed_08000be8",
                "portNumber": "port_number",
                "portValue": "port_value",
                "forceSend": "force_send",
                "PTR_portConfigInputs_08000c0c": "port_config_inputs",
                "PTR_previousPINs_08000c10": "previous_pins",
                "firmata::FirmataClass::sendDigitalPort": "firmata_instance->sendDigitalPort",
                "PTR_Firmata_08000c14": "firmata_instance"
            },
            "code": "void send_digital_port_if_changed_08000be8(byte port_number, byte port_value, byte force_send) {\n  byte port_config = PTR_portConfigInputs_08000c0c[port_number] & port_value;\n  if (force_send || (port_config != PTR_previousPINs_08000c10[port_number])) {\n    firmata::FirmataClass::sendDigitalPort(PTR_Firmata_08000c14, port_number, port_config);\n    PTR_previousPINs_08000c10[port_number] = port_config;\n  }\n  return;\n}",
            "called": [
                "sendDigitalPort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000be8",
            "calling": [
                "checkDigitalInputs",
                "reportDigitalCallback"
            ],
            "imported": false,
            "current_name": "send_digital_port_if_changed_08000be8"
        },
        "FUN_08003fd8": {
            "renaming": {
                "FUN_08003fd8": "calculate_ticks_08003fd8",
                "TicksNumb": "ticks_number",
                "puVar1": "ticks_array"
            },
            "code": "uint32_t calculate_ticks_08003fd8(uint32_t ticks_number) {\n  undefined4 *ticks_array;\n  ticks_array = DAT_08003ffc;\n  if (ticks_number - 1 < 0x1000000) {\n    DAT_08003ffc[1] = ticks_number - 1;\n    *(undefined *)(DAT_08004000 + 0x23) = 0xf0;\n    ticks_array[2] = 0;\n    *ticks_array = 7;\n    return 0;\n  }\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fd8",
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "calculate_ticks_08003fd8"
        },
        "FUN_0800307a": {
            "renaming": {
                "FUN_0800307a": "encode_0800307a",
                "this": "marshaller",
                "bytec": "num_bytes",
                "bytev": "byte_array",
                "max_bytes": "max_bytes",
                "uVar1": "current_byte",
                "uVar2": "bit_index",
                "uVar3": "output_index",
                "uVar4": "unused_variable",
                "FirmataStream": "firmata_stream",
                "_vptr_Print": "virtual_function_pointer"
            },
            "code": "void __thiscall FirmataMarshaller::encode_0800307a(FirmataMarshaller *marshaller, size_t num_bytes, uint8_t *byte_array, size_t max_bytes)\n{\n  uint current_byte = (uint)*byte_array;\n  if (max_bytes == 0) {\n    max_bytes = 0xffffffff;\n  }\n  uint bit_index = 0;\n  uint encode_0800307ad_byte = 0;\n  uint output_index = 0;\n  while ((output_index < num_bytes) && (output_index < max_bytes)) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream, ((uint)byte_array[output_index] << (bit_index & 0xff) | current_byte) & 0x7f);\n    current_byte = (int)(uint)byte_array[output_index] >> (7 - bit_index & 0xff) & 0xff;\n    bit_index++;\n    while ((bit_index > 6) && (output_index < max_bytes)) {\n      (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream, current_byte & 0x7f);\n      current_byte = current_byte >> 7;\n      bit_index -= 7;\n    }\n    output_index++;\n  }\n  if ((bit_index != 0) && (output_index < max_bytes)) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream, (1 << (bit_index & 0xff)) - 1U & current_byte);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800307a",
            "calling": [
                "sendExtendedAnalog",
                "sendSysex",
                "sendFirmwareVersion",
                "sendDigitalPort",
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "encode_0800307a"
        },
        "FUN_08004b80": {
            "renaming": {
                "FUN_08004b80": "do_nothing_08004b80"
            },
            "code": "\nvoid do_nothing_08004b80(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b80",
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004b80"
        },
        "FUN_08002ca4": {
            "renaming": {
                "FUN_08002ca4": "callCurrentStringCallback_08002ca4",
                "param_1": "callback",
                "c_str": "stringParam",
                "PTR_currentStringCallback_08002cb4": "currentStringCallbackPtr"
            },
            "code": "void firmata::FirmataClass::callCurrentStringCallback_08002ca4(void *callback, char *stringParam) {\n  if (*(code **)PTR_currentStringCallback_08002cb4 != (code *)0x0) {\n    (**(code **)PTR_currentStringCallback_08002cb4)(stringParam);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ca4",
            "calling": [],
            "imported": false,
            "current_name": "callCurrentStringCallback_08002ca4"
        },
        "FUN_0800319e": {
            "renaming": {
                "FUN_0800319e": "sendPortData_0800319e",
                "portNumber": "port_number",
                "portData": "port_data",
                "local_a": "local_port_data",
                "FirmataStream": "FirmataStream"
            },
            "code": "void __thiscall FirmataMarshaller::sendPortData_0800319e(FirmataMarshaller *this, uint8_t port_number, uint16_t port_data) {\n  uint16_t local_port_data;\n  \n  if (this->FirmataStream != (Stream *)0x0) {\n    local_port_data = port_data;\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this, port_number & 0xf | 0x90);\n    encodeByteStream(this, 2, (uint8_t *)&local_port_data, 2);\n  }\n  return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800319e",
            "calling": [
                "sendDigitalPort"
            ],
            "imported": false,
            "current_name": "sendPortData_0800319e"
        },
        "FUN_08008d00": {
            "renaming": {
                "FUN_08008d00": "setRxPin_08008d00",
                "_rx": "rxPinIndex",
                "PVar1": "rxPin",
                "PTR_digitalPin_08008d14": "digitalPin",
                "NC": "NC"
            },
            "code": "void __thiscall HardwareSerial::setRxPin_08008d00(HardwareSerial *this, uint32_t rxPinIndex)\n{\n\tPinName rxPin;\n\tif (rxPinIndex < 0x3c) {\n\t\trxPin = PTR_digitalPin_08008d14[rxPinIndex];\n\t}\n\telse {\n\t\trxPin = NC;\n\t}\n\t(this->_serial).pin_rx = rxPin;\n\treturn;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d00",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "setRxPin_08008d00"
        },
        "FUN_08004b82": {
            "renaming": {
                "FUN_08004b82": "i2c_transfer_08004b82",
                "*hi2c": "*i2c_handle",
                "HVar1": "state",
                "pbVar2": "buffer",
                "uVar3": "transfer_options"
            },
            "code": "HAL_StatusTypeDef_conflict i2c_transfer_08004b82(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  HAL_I2C_StateTypeDef_conflict state = i2c_handle->State;\n  uint32_t transfer_options = i2c_handle->XferOptions;\n  if ((i2c_handle->XferSize == 0) && (state == HAL_I2C_STATE_BUSY_TX)) {\n    if ((transfer_options == 4) || ((transfer_options == 8 || (transfer_options == 0xffff0000)))) {\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n      i2c_handle->PreviousState = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n        i2c_handle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(i2c_handle);\n      }\n      else {\n        i2c_handle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(i2c_handle);\n      }\n    }\n    else {\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n      i2c_handle->PreviousState = 0x11;\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(i2c_handle);\n    }\n  }\n  else if ((state == HAL_I2C_STATE_BUSY_TX) || ((i2c_handle->Mode == HAL_I2C_MODE_MEM && (state == HAL_I2C_STATE_BUSY_RX)))) {\n    if (i2c_handle->XferCount == 0) {\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffffbff;\n    }\n    else if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n      if (i2c_handle->EventCount == 0) {\n        if (i2c_handle->MemaddSize == 1) {\n          i2c_handle->Instance->DR = i2c_handle->Memaddress & 0xff;\n          i2c_handle->EventCount = i2c_handle->EventCount + 2;\n        }\n        else {\n          i2c_handle->Instance->DR = (i2c_handle->Memaddress << 0x10) >> 0x18;\n          i2c_handle->EventCount = i2c_handle->EventCount + 1;\n        }\n      }\n      else if (i2c_handle->EventCount == 1) {\n        i2c_handle->Instance->DR = i2c_handle->Memaddress & 0xff;\n        i2c_handle->EventCount = i2c_handle->EventCount + 1;\n      }\n      else if (i2c_handle->EventCount == 2) {\n        if (state == HAL_I2C_STATE_BUSY_RX) {\n          i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x100;\n        }\n        else if (state == HAL_I2C_STATE_BUSY_TX) {\n          uint8_t *buffer = i2c_handle->pBuffPtr;\n          i2c_handle->pBuffPtr = buffer + 1;\n          i2c_handle->Instance->DR = (uint)*buffer;\n          i2c_handle->XferCount = i2c_handle->XferCount - 1;\n        }\n      }\n    }\n    else {\n      uint8_t *buffer = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = buffer + 1;\n      i2c_handle->Instance->DR = (uint)*buffer;\n      i2c_handle->XferCount = i2c_handle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b82",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08004b82"
        },
        "FUN_0800997e": {
            "renaming": {
                "FUN_0800997e": "find_last_occurrence_of_character_0800997e",
                "__s": "string",
                "__c": "character",
                "pcVar1": "occurrence",
                "pcVar2": "last_occurrence"
            },
            "code": "char* find_last_occurrence_of_character_0800997e(char* string, int character) {\n    char* last_occurrence = NULL;\n    if (character != 0) {\n        while (char* occurrence = strchr(string, character)) {\n            last_occurrence = occurrence;\n            string = occurrence + 1;\n        }\n        return last_occurrence;\n    }\n    return strchr(string, 0);\n}",
            "called": [
                "strchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800997e",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "find_last_occurrence_of_character_0800997e"
        },
        "FUN_0800779c": {
            "renaming": {
                "FUN_0800779c": "handle_timer_interrupt_0800779c",
                "PTR_timer_handles_080077ac": "PTR_timer_handles",
                "TIM_HandleTypeDef_conflict": "Timer_HandleTypeDef",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt_request",
                "timer_handle": "current_timer_handle"
            },
            "code": "void handle_timer_interrupt_0800779c(void)\n{\n  TIM_HandleTypeDef_conflict *timer_handle = *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_080077ac_080077ac + 0xc);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800779c",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_0800779c"
        },
        "FUN_08002dbc": {
            "renaming": {
                "FUN_08002dbc": "initializeFirmata_08002dbc",
                "__initialize_p": "shouldInitialize",
                "__priority": "priorityLevel",
                "FirmataClass::FirmataClass": "FirmataClass",
                "PTR_Firmata_08002dd8": "PTR_Firmata_08002dd8",
                "firmataInstance": "firmataInstance"
            },
            "code": "void initializeFirmata_08002dbc(int shouldInitialize, int priorityLevel) {\n  if (shouldInitialize != 1) {\n    return;\n  }\n  if (priorityLevel == 0xffff) {\n    FirmataClass firmataInstance(PTR_Firmata_08002dd8);\n  }\n  return;\n}",
            "called": [
                "FirmataClass"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002dbc",
            "calling": [
                "_GLOBAL__sub_I_Firmata"
            ],
            "imported": false,
            "current_name": "initializeFirmata_08002dbc"
        },
        "FUN_08007f78": {
            "renaming": {
                "FUN_08007f78": "get_i2c_t_from_i2c_handle_08007f78",
                "hi2c": "i2c_handle"
            },
            "code": "i2c_t_conflict * get_i2c_t_from_i2c_handle_08007f78(I2C_HandleTypeDef_conflict *i2c_handle) {\n    return (i2c_t_conflict *)&i2c_handle[-1].EventCount;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f78",
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "imported": false,
            "current_name": "get_i2c_t_from_i2c_handle_08007f78"
        },
        "FUN_08006b28": {
            "renaming": {
                "FUN_08006b28": "is_pin_high_08006b28",
                "PinName_conflict": "PinName",
                "map": "map_ptr",
                "pin": "pin_name",
                "pin_index": "pin_index",
                "pin_mask": "pin_mask",
                "pin_value": "pin_value"
            },
            "code": "_Bool is_pin_high_08006b28(PinName_conflict pin, uint32_t *map) {\n    uint32_t pin_index = ((int)pin << 0x18) >> 0x1c;\n    uint32_t pin_mask = (1U << ((int)pin & 0xfU));\n    uint32_t pin_value = map[pin_index] & pin_mask;\n    return (_Bool)(pin_value != 0);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b28",
            "calling": [
                "digitalRead",
                "digitalWrite",
                "analogWrite",
                "pinMode"
            ],
            "imported": false,
            "current_name": "is_pin_high_08006b28"
        },
        "FUN_08006b1c": {
            "renaming": {
                "FUN_08006b1c": "get_uart_rx_and_global_state_08006b1c",
                "huart": "uart_handle",
                "RxState": "rx_state",
                "gState": "global_state"
            },
            "code": "HAL_UART_StateTypeDef get_uart_rx_and_global_state_08006b1c(UART_HandleTypeDef *huart) {\n  HAL_UART_StateTypeDef rx_state = huart->RxState;\n  HAL_UART_StateTypeDef global_state = huart->gState;\n  return rx_state | global_state;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b1c",
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "imported": false,
            "current_name": "get_uart_rx_and_global_state_08006b1c"
        },
        "FUN_0800a130": {
            "renaming": {
                "FUN_0800a130": "seek_file_0800a130",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "puVar1": "errno_ptr",
                "iVar2": "seek_result"
            },
            "code": "void seek_file_0800a130(int *error_code, int file_descriptor, int offset, int whence) {\n\tint seek_result;\n\tint *errno_ptr = PTR_errno_0800a150;\n\t*(int *)PTR_errno_0800a150 = 0;\n\n\tseek_result = _lseek(file_descriptor, offset, whence);\n\tif ((seek_result == -1) && (*errno_ptr != 0)) {\n\t\t*error_code = *errno_ptr;\n\t}\n\treturn;\n}",
            "called": [
                "_lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a130",
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "imported": false,
            "current_name": "seek_file_0800a130"
        },
        "FUN_08008f3c": {
            "renaming": {
                "FUN_08008f3c": "count_bits_set_in_binary_representation_08008f3c",
                "pin": "input_pin",
                "uVar1": "pin",
                "uVar2": "count"
            },
            "code": "uint8_t count_bits_set_in_binary_representation_08008f3c(uint16_t input_pin) {\n  uint16_t pin = input_pin;\n  uint8_t count = 0;\n  while (pin) {\n    count += pin & 1;\n    pin >>= 1;\n  }\n  return count;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f3c",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "count_bits_set_in_binary_representation_08008f3c"
        },
        "FUN_08002ef2": {
            "renaming": {
                "FUN_08002ef2": "sendPinValueToMarshaller_08002ef2",
                "this": "FirmataClass",
                "pin": "pin",
                "value": "value",
                "FirmataMarshaller::FUN_08002ef2": "sendPinValue",
                "&this->marshaller": "&marshaller",
                "(uint16_t)value": "(uint16_t)value"
            },
            "code": "void __thiscall FirmataClass::sendPinValueToMarshaller_08002ef2(byte pin, int value) {\n  FirmataMarshaller::sendPinValue(&marshaller, pin, (uint16_t)value);\n  return;\n}",
            "called": [
                "sendAnalog"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ef2",
            "calling": [
                "reportAnalogCallback",
                "loop"
            ],
            "imported": false,
            "current_name": "sendPinValueToMarshaller_08002ef2"
        },
        "FUN_08007332": {
            "renaming": {
                "FUN_08007332": "find_pin_name_08007332",
                "PinName_conflict": "PinName_conflict",
                "void *peripheral": "void *peripheral",
                "PinMap_conflict *map": "PinMap_conflict *map",
                "NC": "NC",
                "map": "map",
                "peripheral": "peripheral"
            },
            "code": "PinName_conflict find_pin_name_08007332(void *peripheral, PinMap_conflict *map) {\n    while (true) {\n        if (map->peripheral == NULL) {\n            return NC;\n        }\n        if (map->peripheral == peripheral) {\n            break;\n        }\n        map++;\n    }\n    return map->pin;\n}",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007332",
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "imported": false,
            "current_name": "find_pin_name_08007332"
        },
        "FUN_08006128": {
            "renaming": {
                "FUN_08006128": "set_timer_channel_config_08006128",
                "htim": "timer_handle",
                "sConfig": "output_compare_config",
                "Channel": "channel",
                "Lock": "lock_status",
                "State": "state",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "TIM_OC1_SetConfig": "TIM_OC1_SetConfig",
                "TIM_OC2_SetConfig": "TIM_OC2_SetConfig",
                "TIM_OC3_SetConfig": "TIM_OC3_SetConfig",
                "TIM_OC4_SetConfig": "TIM_OC4_SetConfig"
            },
            "code": "HAL_StatusTypeDef set_timer_channel_config_08006128(TIM_HandleTypeDef *timer_handle, TIM_OC_InitTypeDef *output_compare_config, uint32_t channel) {\n  if (timer_handle->lock_status != HAL_LOCKED) {\n    timer_handle->lock_status = HAL_LOCKED;\n    timer_handle->state = HAL_TIM_STATE_BUSY;\n    switch(channel) {\n    case 0:\n      TIM_OC1_SetConfig(timer_handle->Instance, output_compare_config);\n      break;\n    case 4:\n      TIM_OC2_SetConfig(timer_handle->Instance, output_compare_config);\n      break;\n    case 8:\n      TIM_OC3_SetConfig(timer_handle->Instance, output_compare_config);\n      break;\n    case 0xc:\n      TIM_OC4_SetConfig(timer_handle->Instance, output_compare_config);\n    }\n    timer_handle->state = HAL_TIM_STATE_READY;\n    timer_handle->lock_status = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}",
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006128",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "set_timer_channel_config_08006128"
        },
        "FUN_0800a258": {
            "renaming": {
                "std::ctype_byname<wchar_t>::FUN_0800a258": "set_flags_of_pointers",
                "FUN_0800a258": "set_flags_of_pointers_0800a258"
            },
            "code": "void set_flags_of_pointers_0800a258(void)\n{\n    if (-1 < *(int *)PTR_id_0800a2ec << 0x1f) {\n        *(undefined4 *)PTR_id_0800a2ec = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a2f0 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a2f0 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a2f4 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a2f4 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a2f8 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a2f8 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a2fc << 0x1f) {\n        *(undefined4 *)PTR_id_0800a2fc = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a300 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a300 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a304 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a304 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a308 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a308 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a30c << 0x1f) {\n        *(undefined4 *)PTR_id_0800a30c = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a310 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a310 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a314 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a314 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a318 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a318 = 1;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a258",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_of_pointers_0800a258"
        },
        "FUN_08002cb8": {
            "renaming": {
                "FUN_08002cb8": "handleSysexMessage_08002cb8",
                "param_1": "callbackFunction",
                "command": "command",
                "argc": "argc",
                "argv": "data"
            },
            "code": "void firmata::FirmataClass::handleSysexMessage_08002cb8(void *callbackFunction, uint8_t command, size_t argc, uint8_t *data) {\n  if (*(code **)callbackFunction != (code *)0x0) {\n    (**(code **)callbackFunction)(command, argc & 0xff, data, data, data);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002cb8",
            "calling": [],
            "imported": false,
            "current_name": "handleSysexMessage_08002cb8"
        },
        "FUN_08004a74": {
            "renaming": {
                "FUN_08004a74": "do_nothing_08004a74"
            },
            "code": "\nvoid do_nothing_08004a74(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a74",
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a74"
        },
        "FUN_08008f50": {
            "renaming": {
                "FUN_08008f50": "free_gpio_irq_configurations_08008f50",
                "param_1": "list_start",
                "puVar1": "current_node",
                "puVar2": "previous_node"
            },
            "code": "void free_gpio_irq_configurations_08008f50(void *list_start){\n  undefined *current_node;\n  undefined *previous_node;\n  current_node = PTR___malloc_free_list_08008f70;\n  while (previous_node = current_node, previous_node != PTR_gpio_irq_conf_08008f74) {\n    current_node = previous_node + -0x14;\n    if (*(code **)(previous_node + -8) != (code *)0x0) {\n      (**(code **)(previous_node + -8))(previous_node + -0x10,previous_node + -0x10,3);\n    }\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f50",
            "calling": [],
            "imported": false,
            "current_name": "free_gpio_irq_configurations_08008f50"
        },
        "FUN_08004a76": {
            "renaming": {
                "FUN_08004a76": "read_i2c_08004a76",
                "hi2c": "i2c_handle",
                "HVar1": "i2c_state",
                "puVar2": "buffer_ptr",
                "XferCount": "TransferCount",
                "pBuffPtr": "BufferPtr",
                "Instance": "DataRegister",
                "CR2": "ControlRegister2",
                "PreviousState": "PreviousState",
                "HAL_I2C_STATE_BUSY_RX_LISTEN": "HAL_I2C_STATE_BUSY_RX_LISTEN",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "HAL_I2C_SlaveRxCpltCallback": "HAL_I2C_SlaveRxCpltCallback",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef_conflict read_i2c_08004a76(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  HAL_I2C_StateTypeDef_conflict i2c_state;\n  uint8_t *buffer_ptr;\n  i2c_state = i2c_handle->State;\n  if (i2c_handle->TransferCount != 0) {\n    buffer_ptr = i2c_handle->BufferPtr;\n    i2c_handle->BufferPtr = buffer_ptr + 1;\n    *buffer_ptr = (uint8_t)i2c_handle->Instance->DataRegister;\n    i2c_handle->TransferCount = i2c_handle->TransferCount - 1;\n    if ((i2c_handle->TransferCount == 0) && (i2c_state == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2c_handle->Instance->ControlRegister2 = i2c_handle->Instance->ControlRegister2 & 0xfffffbff;\n      i2c_handle->PreviousState = 0x22;\n      i2c_handle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(i2c_handle);\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a76",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "read_i2c_08004a76"
        },
        "FUN_0800877c": {
            "renaming": {
                "FUN_0800877c": "initialize_uart_0800877c",
                "huart": "uart_handle",
                "tmpval": "tmp_value"
            },
            "code": "void initialize_uart_0800877c(UART_HandleTypeDef *uart_handle)\n{\n  uint32_t tmp_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800877c",
            "calling": [
                "HAL_UART_IRQHandler",
                "UART_DMAAbortOnError"
            ],
            "imported": false,
            "current_name": "initialize_uart_0800877c"
        },
        "FUN_080047f4": {
            "renaming": {
                "FUN_080047f4": "I2C_read_080047f4",
                "hi2c": "handle",
                "DevAddress": "address",
                "pData": "data",
                "Size": "size",
                "HVar1": "status",
                "pIVar2": "instance",
                "count": "count",
                "DAT_080048c0": "count_constant",
                "PTR_SystemCoreClock_080048bc": "clock_constant",
                "DAT_080048c4": "option_constant"
            },
            "code": "HAL_StatusTypeDef_conflict I2C_read_080047f4(I2C_HandleTypeDef_conflict *handle, uint16_t address, uint8_t *data, uint16_t size)\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *instance;\n  uint32_t count;\n  \n  if (handle->State == HAL_I2C_STATE_READY) {\n    count = (uint)((uint64_t)DAT_080048c0 * (uint64_t)(*(uint *)PTR_SystemCoreClock_080048bc >> 3) >> 0x28) * 0x19;\n    do {\n      if (count == 0) {\n        handle->PreviousState = 0;\n        handle->State = HAL_I2C_STATE_READY;\n        handle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      instance = handle->Instance;\n      count = count - 1;\n    } while ((instance->SR2 & 2) != 0);\n    if (handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      handle->Lock = HAL_LOCKED;\n      if ((instance->CR1 & 1) == 0) {\n        instance->CR1 = instance->CR1 | 1;\n      }\n      handle->Instance->CR1 = handle->Instance->CR1 & 0xfffff7ff;\n      handle->State = HAL_I2C_STATE_BUSY_RX;\n      handle->Mode = HAL_I2C_MODE_MASTER;\n      status = HAL_OK;\n      handle->ErrorCode = 0;\n      handle->pBuffPtr = data;\n      handle->XferCount = size;\n      handle->XferOptions = DAT_080048c4;\n      handle->XferSize = handle->XferCount;\n      handle->Devaddress = (uint)address;\n      handle->Instance->CR1 = handle->Instance->CR1 | 0x400;\n      handle->Instance->CR1 = handle->Instance->CR1 | 0x100;\n      handle->Lock = HAL_UNLOCKED;\n      handle->Instance->CR2 = handle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047f4",
            "calling": [
                "i2c_master_read"
            ],
            "imported": false,
            "current_name": "I2C_read_080047f4"
        },
        "FUN_08005a48": {
            "renaming": {
                "FUN_08005a48": "get_HCLK_frequency_divided_by_APB_08005a48",
                "uVar1": "HCLK_frequency_divided_by_APB",
                "PTR_APBPrescTable_08005a64": "APB_prescaler_table",
                "DAT_08005a60": "APB_prescaler_index_ptr",
                "APB_prescaler_index": "APB_prescaler_index",
                "APB_prescaler": "APB_prescaler"
            },
            "code": "uint32_t get_HCLK_frequency_divided_by_APB_08005a48(void)\n{\n    uint32_t HCLK_frequency = HAL_RCC_GetHCLKFreq();\n    uint32_t APB_prescaler_index = (uint)(*(int *)(DAT_08005a60 + 4) << 0x12) >> 0x1d;\n    uint32_t APB_prescaler = PTR_APBPrescTable_08005a64[APB_prescaler_index];\n    uint32_t HCLK_frequency_divided_by_APB = HCLK_frequency / APB_prescaler;\n    return HCLK_frequency_divided_by_APB;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a48",
            "calling": [
                "HAL_RCCEx_GetPeriphCLKFreq",
                "getTimerClkFreq",
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "get_HCLK_frequency_divided_by_APB_08005a48"
        },
        "FUN_080033a8": {
            "renaming": {
                "FUN_080033a8": "parseBytes_080033a8",
                "this": "parser",
                "bytec": "numBytes",
                "bytev": "byteArray",
                "sVar2": "currentIndex",
                "uVar3": "i",
                "bVar1": "currentByte"
            },
            "code": "size_t __thiscall firmata::FirmataParser::parseBytes_080033a8(FirmataParser *parser,size_t numBytes,uint8_t *byteArray) {\n    byte currentByte;\n    size_t currentIndex = 0;\n    for (uint i = 0; i < numBytes; i += 2) {\n        currentByte = byteArray[i];\n        byteArray[currentIndex] = currentByte;\n        byteArray[currentIndex] = (byteArray[i + 1] << 7) | currentByte;\n        currentIndex++;\n    }\n    return currentIndex;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033a8",
            "calling": [
                "processSysexMessage"
            ],
            "imported": false,
            "current_name": "parseBytes_080033a8"
        },
        "FUN_08008d18": {
            "renaming": {
                "FUN_08008d18": "set_tx_pin_08008d18",
                "_tx": "tx_pin_index",
                "PVar1": "tx_pin",
                "PTR_digitalPin_08008d2c": "digitalPin"
            },
            "code": "void __thiscall HardwareSerial::set_tx_pin_08008d18(HardwareSerial *this, uint32_t tx_pin_index) {\n  PinName tx_pin;\n  if (tx_pin_index < 0x3c) {\n    tx_pin = PTR_digitalPin_08008d2c[tx_pin_index];\n  }\n  else {\n    tx_pin = NC;\n  }\n  (this->_serial).pin_tx = tx_pin;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d18",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "set_tx_pin_08008d18"
        },
        "FUN_0800a020": {
            "renaming": {
                "FUN_0800a020": "read_data_from_file_and_update_position_0800a020",
                "param_1": "file_descriptor",
                "param_2": "position_ptr",
                "iVar1": "bytes_read",
                "uVar2": "updated_position",
                "bVar3": "read_successful"
            },
            "code": "void read_data_from_file_and_update_position_0800a020(int file_descriptor, int position_ptr) {\n    int bytes_read = _read_r(file_descriptor, (int)*(short *)(position_ptr + 0xe));\n    bool read_successful = bytes_read >= 0;\n    uint updated_position;\n    if (read_successful) {\n        updated_position = *(int *)(position_ptr + 0x54) + bytes_read;\n    }\n    else {\n        updated_position = *(ushort *)(position_ptr + 0xc) & 0xffffefff;\n    }\n    if (read_successful) {\n        *(uint *)(position_ptr + 0x54) = updated_position;\n    }\n    if (!read_successful) {\n        *(short *)(position_ptr + 0xc) = (short)updated_position;\n    }\n}",
            "called": [
                "_read_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a020",
            "calling": [],
            "imported": false,
            "current_name": "read_data_from_file_and_update_position_0800a020"
        },
        "FUN_08007f7c": {
            "renaming": {
                "FUN_08007f7c": "set_slave_receive_callback_08007f7c",
                "obj": "i2c_conflict_obj",
                "function": "callback_func",
                "i2c_onSlaveReceive": "callback_func_on_slave_receive",
                "HAL_I2C_EnableListen_IT": "enable_listen_interrupt_for_i2c"
            },
            "code": "void set_slave_receive_callback_08007f7c(i2c_t_conflict *i2c_conflict_obj, _func_void_uint8_t_ptr_int *callback_func) {\n  if (i2c_conflict_obj != NULL) {\n    if (callback_func != NULL) {\n      i2c_conflict_obj->i2c_onSlaveReceive = callback_func;\n      HAL_I2C_EnableListen_IT(&i2c_conflict_obj->handle);\n    }\n  }\n}",
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f7c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "set_slave_receive_callback_08007f7c"
        },
        "FUN_08006d80": {
            "renaming": {
                "FUN_08006d80": "read_analog_pin_08006d80",
                "pin": "pin",
                "HVar1": "status",
                "uVar2": "value",
                "uhADCxConvertedValue": "converted_value",
                "AdcChannelConf": "channel_config",
                "AdcHandle": "adc_handle",
                "PTR_PinMap_ADC_08006e60": "PTR_PinMap_ADC",
                "ADC_TypeDef": "ADC",
                "ADC_DATAALIGN_RIGHT": "ADC_DATAALIGN",
                "DISABLE": "ADC_DISABLE",
                "ADC_SOFTWARE_START": "ADC_START",
                "HAL_ADC_STATE_RESET": "ADC_STATE_RESET",
                "ADC_SAMPLETIME_2CYCLES_5": "ADC_SAMPLE_TIME",
                "get_adc_channel": "get_adc_channel",
                "PTR_g_current_pin_08006e64": "PTR_g_current_pin"
            },
            "code": "uint16_t read_analog_pin_08006d80(PinName_conflict pin)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t value;\n  uint16_t converted_value;\n  ADC_ChannelConfTypeDef channel_config;\n  ADC_HandleTypeDef adc_handle;\n  memset(&adc_handle, 0, sizeof(adc_handle));\n  channel_config.Channel = 0;\n  channel_config.Rank = 0;\n  channel_config.SamplingTime = 0;\n  converted_value = 0;\n  adc_handle.Instance = (ADC_TypeDef *)pinmap_peripheral(pin, (PinMap_conflict *)PTR_PinMap_ADC_08006e60_08006e60);\n  if (adc_handle.Instance == (ADC_TypeDef *)0x0) {\n    converted_value = 0;\n  }\n  else {\n    adc_handle.Init.DataAlign = ADC_DATAALIGN_RIGHT_RIGHT;\n    adc_handle.Init.ScanConvMode = DISABLE;\n    adc_handle.Init.ContinuousConvMode = DISABLE;\n    adc_handle.Init.DiscontinuousConvMode = DISABLE;\n    adc_handle.Init.ExternalTrigConv = ADC_SOFTWARE_START;\n    adc_handle.State = HAL_ADC_STATE_RESET;\n    adc_handle.Init.NbrOfConversion = 1;\n    adc_handle.Init.NbrOfDiscConversion = 0;\n    *PTR_g_current_pin_08006e64_08006e64 = pin;\n    status = HAL_ADC_Init(&adc_handle);\n    if (status == HAL_OK) {\n      channel_config.Channel = get_adc_channel(pin);\n      if (channel_config.Channel < 0x12) {\n        channel_config.Rank = 1;\n        channel_config.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;\n        status = HAL_ADC_ConfigChannel(&adc_handle, &channel_config);\n        if (status == HAL_OK) {\n          status = HAL_ADCEx_Calibration_Start(&adc_handle);\n          if (status == HAL_OK) {\n            status = HAL_ADC_Start(&adc_handle);\n            if (status == HAL_OK) {\n              status = HAL_ADC_PollForConversion(&adc_handle, 10);\n              if (status == HAL_OK) {\n                value = HAL_ADC_GetValue(&adc_handle);\n                converted_value = (uint16_t)value;\n              }\n              status = HAL_ADC_Stop(&adc_handle);\n              if (status != HAL_OK) {\n                converted_value = 0;\n              }\n            }\n            else {\n              converted_value = 0;\n            }\n          }\n          else {\n            converted_value = 0;\n          }\n        }\n        else {\n          converted_value = 0;\n        }\n      }\n      else {\n        converted_value = 0;\n      }\n      status = HAL_ADC_DeInit(&adc_handle);\n      if (status != HAL_OK) {\n        converted_value = 0;\n      }\n    }\n    else {\n      converted_value = 0;\n    }\n  }\n  return converted_value;\n}",
            "called": [
                "get_adc_channel",
                "memset",
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_PollForConversion",
                "HAL_ADC_Stop",
                "HAL_ADC_GetState",
                "pinmap_peripheral",
                "HAL_ADC_DeInit",
                "HAL_ADC_ConfigChannel",
                "HAL_ADC_GetValue",
                "HAL_ADC_Start"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d80",
            "calling": [
                "analogRead"
            ],
            "imported": false,
            "current_name": "read_analog_pin_08006d80"
        },
        "FUN_08006c60": {
            "renaming": {
                "FUN_08006c60": "get_adc_channel_08006c60",
                "pin": "pin_name",
                "uVar1": "adc_channel_id"
            },
            "code": "uint32_t get_adc_channel_08006c60(PinName_conflict pin)\n{\n  uint32_t adc_channel_id;\n  adc_channel_id = pinmap_function(pin, (PinMap_conflict *)PTR_PinMap_ADC_08006c78);\n  adc_channel_id = (adc_channel_id << 12) >> 27;\n  if (adc_channel_id > 15) {\n    adc_channel_id = 0;\n  }\n  return adc_channel_id;\n}",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c60",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_adc_channel_08006c60"
        },
        "FUN_08008e40": {
            "renaming": {
                "FUN_08008e40": "initialize_static_data_08008e40"
            },
            "code": "void initialize_static_data_08008e40(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e40",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_08008e40"
        },
        "FUN_080045c0": {
            "renaming": {
                "FUN_080045c0": "configureI2C_080045c0",
                "*hi2c": "*i2c",
                "bVar1": "clockSpeedValid",
                "uVar2": "pclk1Freq",
                "uVar3": "ccr",
                "uVar4": "trise",
                "uVar5": "dutyCycle",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "HAL_I2C_StateTypeDef": "HAL_I2C_StateTypeDef",
                "HAL_I2C_InitTypeDef": "HAL_I2C_InitTypeDef",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_I2C_MspInit": "HAL_I2C_MspInit",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_I2C_STATE_RESET": "HAL_I2C_STATE_RESET",
                "HAL_I2C_STATE_BUSY": "HAL_I2C_STATE_BUSY",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "HAL_I2C_ERROR_NONE": "HAL_I2C_ERROR_NONE",
                "HAL_I2C_ERROR_BERR": "HAL_I2C_ERROR_BERR",
                "HAL_I2C_ERROR_ARLO": "HAL_I2C_ERROR_ARLO",
                "HAL_I2C_ERROR_AF": "HAL_I2C_ERROR_AF",
                "HAL_I2C_ERROR_OVR": "HAL_I2C_ERROR_OVR",
                "HAL_I2C_ERROR_DMA": "HAL_I2C_ERROR_DMA",
                "HAL_I2C_ERROR_TIMEOUT": "HAL_I2C_ERROR_TIMEOUT",
                "HAL_I2C_ERROR_SIZE": "HAL_I2C_ERROR_SIZE",
                "HAL_I2C_ERROR_DMA_PARAM": "HAL_I2C_ERROR_DMA_PARAM",
                "HAL_I2C_ERROR_INVALID_CALLBACK": "HAL_I2C_ERROR_INVALID_CALLBACK",
                "HAL_I2C_ERROR_INVALID_HANDLE": "HAL_I2C_ERROR_INVALID_HANDLE"
            },
            "code": "HAL_StatusTypeDef configureI2C_080045c0(I2C_HandleTypeDef *i2c)\n{\n  bool clockSpeedValid;\n  uint32_t pclk1Freq, ccr, trise;\n  uint32_t clockSpeed = i2c->Init.ClockSpeed;\n  uint32_t dutyCycle = i2c->Init.DutyCycle;\n\n  if (i2c == NULL) {\n    return HAL_ERROR;\n  }\n\n  if (i2c->State == HAL_I2C_STATE_RESET) {\n    i2c->Lock = HAL_UNLOCKED;\n    HAL_I2C_MspInit(i2c);\n  }\n\n  i2c->State = HAL_I2C_STATE_BUSY;\n  i2c->Instance->CR1 &= ~(1);\n\n  pclk1Freq = HAL_RCC_GetPCLK1Freq();\n  if (DAT_08004714 < clockSpeed) {\n    clockSpeedValid = pclk1Freq <= DAT_08004720;\n  }\n  else if (DAT_08004718 < pclk1Freq) {\n    clockSpeedValid = false;\n  }\n  else {\n    clockSpeedValid = true;\n  }\n\n  if (clockSpeedValid) {\n    return HAL_ERROR;\n  }\n\n  ccr = (uint32_t)(((uint64_t)DAT_0800471c * pclk1Freq) >> 0x32);\n  i2c->Instance->CR2 = ccr;\n\n  if (DAT_08004714 < clockSpeed) {\n    trise = (uint32_t)(((uint64_t)DAT_08004724 * (uint64_t)(ccr * 300)) >> 0x26);\n  }\n  else {\n    trise = (uint32_t)(((dutyCycle == 0) ? ((pclk1Freq - 1) / (clockSpeed * 3)) : ((pclk1Freq - 1) / (clockSpeed * 0x19))) + 1) & 0xfff;\n  }\n\n  if (clockSpeed < DAT_08004714) {\n    ccr = (uint32_t)(((pclk1Freq - 1) / (clockSpeed << 1)) + 1) & 0xfff;\n    if (ccr < 4) {\n      ccr = 4;\n    }\n  }\n  else {\n    ccr |= ((dutyCycle == 0) ? 0x8000 : 0xc000);\n  }\n\n  i2c->Instance->CCR = ccr;\n  i2c->Instance->CR1 = i2c->Init.GeneralCallMode | i2c->Init.NoStretchMode | 1;\n  i2c->Instance->OAR1 = i2c->Init.AddressingMode | i2c->Init.OwnAddress1;\n  i2c->Instance->OAR2 = i2c->Init.DualAddressMode | i2c->Init.OwnAddress2;\n\n  i2c->ErrorCode = 0;\n  i2c->State = HAL_I2C_STATE_READY;\n  i2c->PreviousState = 0;\n  i2c->Mode = HAL_I2C_MODE_NONE;\n\n  return HAL_OK;\n}",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_I2C_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045c0",
            "calling": [
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "configureI2C_080045c0"
        },
        "FUN_08007e74": {
            "renaming": {
                "FUN_08007e74": "check_i2c_status_08007e74",
                "*obj": "*handle",
                "dev_address": "device_address",
                "*data": "data",
                "size": "size",
                "HVar1": "status",
                "HVar2": "status",
                "uVar3": "start_time",
                "uVar4": "error_code",
                "uVar5": "elapsed_time",
                "iVar6": "result",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "HAL_I2C_StateTypeDef_conflict": "HAL_I2C_StateTypeDef",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "hi2c": "handle"
            },
            "code": "i2c_status_e check_i2c_status_08007e74(I2C_HandleTypeDef *handle, uint8_t device_address, uint8_t *data, uint16_t size) {\n  HAL_StatusTypeDef status;\n  uint32_t start_time = HAL_GetTick();\n  uint32_t elapsed_time = 0;\n  i2c_status_e result = I2C_ERROR;\n  do {\n    status = HAL_I2C_Master_Transmit_IT(handle, device_address, data, size);\n    if (status == HAL_OK) {\n      result = I2C_OK;\n      while (HAL_I2C_GetState(handle) != HAL_I2C_STATE_READY && result == I2C_OK) {\n        elapsed_time = HAL_GetTick() - start_time;\n        if (elapsed_time >= 0x65) {\n          result = I2C_TIMEOUT;\n        }\n        else if (HAL_I2C_GetError(handle) != 0) {\n          result = I2C_ERROR;\n        }\n      }\n    }\n  } while (HAL_I2C_GetError(handle) == 4 && elapsed_time < 100);\n  return result;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_I2C_Master_Transmit_IT",
                "HAL_I2C_GetState",
                "HAL_I2C_GetError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e74",
            "calling": [
                "endTransmission"
            ],
            "imported": false,
            "current_name": "check_i2c_status_08007e74"
        },
        "FUN_08002efe": {
            "renaming": {
                "FUN_08002efe": "writePortData_08002efe",
                "portNumber": "portNumber",
                "portData": "portData"
            },
            "code": "void __thiscall firmata::FirmataClass::writePortData_08002efe(FirmataClass *this, byte portNumber, int portData)\n{\n    FirmataMarshaller::writePortData_08002efe(&this->marshaller, portNumber, (uint16_t)portData);\n    return;\n}",
            "called": [
                "sendDigitalPort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002efe",
            "calling": [
                "outputPort"
            ],
            "imported": false,
            "current_name": "writePortData_08002efe"
        },
        "FUN_08002ddc": {
            "renaming": {
                "FUN_08002ddc": "sendFirmwareVersion_08002ddc",
                "FirmataMarshaller::sendVersion": "FirmataMarshaller::sendVersion",
                "&this->marshaller": "&this->marshaller",
                "'\\x02'": "2",
                "'\\x05'": "5"
            },
            "code": "void __thiscall firmata::FirmataClass::sendFirmwareVersion_08002ddc(FirmataClass *this)\n{\n  FirmataMarshaller::sendVersion(&this->marshaller, 2, 5);\n  return;\n}",
            "called": [
                "sendVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ddc",
            "calling": [
                "staticReportVersionCallback",
                "begin"
            ],
            "imported": false,
            "current_name": "sendFirmwareVersion_08002ddc"
        },
        "FUN_08009f2c": {
            "renaming": {
                "FUN_08009f2c": "find_byte_in_memory_08009f2c",
                "__s": "memory",
                "__c": "byte_to_find",
                "__n": "memory_size",
                "pbVar1": "memory_ptr",
                "pbVar2": "current_memory_ptr"
            },
            "code": "void* find_byte_in_memory_08009f2c(void* memory, int byte_to_find, size_t memory_size) {\n    unsigned char* memory_ptr = (unsigned char*)memory;\n    while(memory_ptr != (unsigned char*)(memory_size + (int)memory)) {\n        if((uint)*memory_ptr == (byte_to_find & 0xffU)) {\n            return memory_ptr;\n        }\n        memory_ptr++;\n    }\n    return (void*)0x0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f2c",
            "calling": [
                "_vfiprintf_r",
                "_printf_i"
            ],
            "imported": false,
            "current_name": "find_byte_in_memory_08009f2c"
        },
        "FUN_0800a154": {
            "renaming": {
                "FUN_0800a154": "calculate_value_0800a154",
                "param_1": "starting_value",
                "param_2": "array",
                "iVar1": "index"
            },
            "code": "int calculate_value_0800a154(int starting_value, int *array) {\n  int index = starting_value - 4;\n  if (starting_value < 0) {\n    index += array[index];\n  }\n  return index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a154",
            "calling": [
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "calculate_value_0800a154"
        },
        "FUN_08007f8e": {
            "renaming": {
                "FUN_08007f8e": "set_i2c_slave_transmit_callback_08007f8e",
                "obj": "i2c_conflict_obj",
                "function": "callback_function",
                "i2c_onSlaveTransmit": "callback_function",
                "HAL_I2C_EnableListen_IT": "HAL_I2C_EnableListen_IT",
                "handle": "handle"
            },
            "code": "void set_i2c_slave_transmit_callback_08007f8e(i2c_t_conflict *i2c_conflict_obj, _func_void *callback_function) {\n  if (i2c_conflict_obj != NULL) {\n    if (callback_function != NULL) {\n      i2c_conflict_obj->i2c_onSlaveTransmit = callback_function;\n      HAL_I2C_EnableListen_IT(&i2c_conflict_obj->handle);\n    }\n  }\n}",
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f8e",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "set_i2c_slave_transmit_callback_08007f8e"
        },
        "FUN_08006b3e": {
            "renaming": {
                "FUN_08006b3e": "set_pin_high_08006b3e",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "pin_index"
            },
            "code": "void set_pin_high_08006b3e(PinName_conflict pin, uint32_t *pin_map) {\n  uint32_t pin_index = (uint32_t)pin >> 28;\n  uint32_t pin_mask = 1 << ((uint32_t)pin & 0x0F);\n  pin_map[pin_index] |= pin_mask;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b3e",
            "calling": [
                "analogWrite",
                "pinMode"
            ],
            "imported": false,
            "current_name": "set_pin_high_08006b3e"
        },
        "FUN_08006262": {
            "renaming": {
                "FUN_08006262": "update_channel_state_08006262",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "state",
                "CCER": "channel_control_register",
                "PTR_": "PTR_ (no change)",
                "DAT_": "DAT_ (no change)"
            },
            "code": "void update_channel_state_08006262(TIM_TypeDef_conflict *timer, uint32_t channel, uint32_t state) {\n  uint32_t mask = ~(1 << (channel & 0xff));\n  timer->CCER = (timer->CCER & mask) | (state << (channel & 0xff));\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006262",
            "calling": [
                "HAL_TIM_PWM_Stop",
                "HAL_TIM_OC_Stop_IT",
                "HAL_TIM_OC_Start_IT",
                "HAL_TIM_PWM_Start"
            ],
            "imported": false,
            "current_name": "update_channel_state_08006262"
        },
        "FUN_08007110": {
            "renaming": {
                "FUN_08007110": "disable_timer_clock_08007110",
                "htim": "timer_handle"
            },
            "code": "void disable_timer_clock_08007110(TIM_HandleTypeDef_conflict *timer_handle)\n{\n  timer_disable_clock(timer_handle);\n  return;\n}",
            "called": [
                "timer_disable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007110",
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "imported": false,
            "current_name": "disable_timer_clock_08007110"
        },
        "FUN_08007594": {
            "renaming": {
                "FUN_08007594": "check_timer_instance_08007594",
                "tim": "timer",
                "DAT_080075d0": "timer1",
                "DAT_080075d4": "timer2",
                "PTR_s_TIM__Unknown_timer_instance_080075d8": "Unknown_timer_instance"
            },
            "code": "uint8_t check_timer_instance_08007594(TIM_TypeDef_conflict *timer) {\n  if (timer == (TIM_TypeDef_conflict *)0xffffffff) {\n    return 0;\n  }\n  if (timer == DAT_080075d0) {\n    return 1;\n  }\n  if (DAT_080075d0 < timer) {\n    if (timer == DAT_080075d4) {\n      return 1;\n    }\n    if (timer == (TIM_TypeDef_conflict *)&DAT_080075d4[0x379].DMAR) {\n      return 2;\n    }\n  }\n  else if (timer == (TIM_TypeDef_conflict *)0x40000000) {\n    return 1;\n  }\n  iprintf(PTR_s_TIM__Unknown_timer_instance_080075d8);\n  return 0;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007594",
            "calling": [
                "getTimerClkFreq"
            ],
            "imported": false,
            "current_name": "check_timer_instance_08007594"
        },
        "FUN_08002cd0": {
            "renaming": {
                "FUN_08002cd0": "resetSystemCallback_08002cd0",
                "param_1": "callbackFunctionPtr",
                "PTR_currentSystemResetCallback_08002cdc": "currentSystemResetCallback"
            },
            "code": "void firmata::FirmataClass::resetSystemCallback_08002cd0(void *callbackFunctionPtr) {\n  if (*(code **)PTR_currentSystemResetCallback_08002cdc != (code *)0x0) {\n    (**(code **)PTR_currentSystemResetCallback_08002cdc)();\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002cd0",
            "calling": [],
            "imported": false,
            "current_name": "resetSystemCallback_08002cd0"
        },
        "FUN_08002df6": {
            "renaming": {
                "FUN_08002df6": "sendFirmwareVersionIfAvailable_08002df6",
                "this": "firmataInstance",
                "puVar1": "firmwareVersionVector",
                "firmwareVersionCount": "firmwareVersionCount",
                "firmwareVersionVector": "firmwareVersionVector",
                "FirmataMarshaller::sendFirmwareVersion": "FirmataMarshaller::sendFirmwareVersion",
                "&this->marshaller": "&firmataInstance->marshaller"
            },
            "code": "void __thiscall firmata::FirmataClass::sendFirmwareVersionIfAvailable_08002df6(FirmataClass *firmataInstance)\n{\n  uint8_t *firmwareVersionVector;\n  int firmwareVersionCount;\n  firmwareVersionCount = firmataInstance->firmwareVersionCount;\n  if (firmwareVersionCount == 0) {\n    return;\n  }\n  firmwareVersionVector = firmataInstance->firmwareVersionVector;\n  FirmataMarshaller::sendFirmwareVersion(&firmataInstance->marshaller, firmwareVersionVector[0], firmwareVersionVector[1], firmwareVersionCount - 2, firmwareVersionVector + 2);\n  return;\n}",
            "called": [
                "sendFirmwareVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002df6",
            "calling": [
                "begin",
                "staticReportFirmwareCallback"
            ],
            "imported": false,
            "current_name": "sendFirmwareVersionIfAvailable_08002df6"
        },
        "FUN_080045bc": {
            "renaming": {
                "FUN_080045bc": "do_nothing_080045bc"
            },
            "code": "\nvoid do_nothing_080045bc(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045bc",
            "calling": [
                "HAL_I2C_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_080045bc"
        },
        "FUN_08007118": {
            "renaming": {
                "FUN_08007118": "set_pwm_08007118",
                "PinName_conflict": "PinName",
                "clock_freq": "clock_frequency",
                "period": "period",
                "value": "duty_cycle",
                "do_init": "initialize",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HVar1": "status",
                "uVar2": "timer_clk_freq",
                "uVar3": "function",
                "timConfig": "timer_config",
                "timHandle": "timer_handle",
                "TIM_OC_InitTypeDef": "TIM_OC_InitTypeDef",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "getTimerClkFreq": "getTimerClkFreq",
                "pinmap_peripheral": "pinmap_peripheral",
                "PinMap_conflict": "PinMap",
                "get_pwm_channel": "get_pwm_channel",
                "HAL_TIM_PWM_Init": "HAL_TIM_PWM_Init",
                "PTR_g_current_pin_080071e0": "g_current_pin",
                "HAL_TIM_PWM_ConfigChannel": "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_PWM_Start": "HAL_TIM_PWM_Start",
                "HAL_TIMEx_PWMN_Start": "HAL_TIMEx_PWMN_Start",
                "TIM_OCMODE_PWM1": "TIM_OCMODE_PWM1",
                "TIM_OCPOLARITY_HIGH": "TIM_OCPOLARITY_HIGH",
                "TIM_OCNPOLARITY_HIGH": "TIM_OCNPOLARITY_HIGH",
                "TIM_OCFAST_DISABLE": "TIM_OCFAST_DISABLE",
                "TIM_OCIDLESTATE_RESET": "TIM_OCIDLESTATE_RESET",
                "TIM_OCNIDLESTATE_RESET": "TIM_OCNIDLESTATE_RESET",
                "TIM_COUNTERMODE_UP": "TIM_COUNTERMODE_UP",
                "PTR_PinMap_PWM_080071dc": "PinMap_PWM"
            },
            "code": "void set_pwm_08007118(PinName pin, uint32_t clock_frequency, uint32_t period, uint32_t duty_cycle, uint8_t initialize)\n{\n  HAL_StatusTypeDef status;\n  uint32_t timer_clk_freq;\n  uint32_t pwm_channel;\n  TIM_OC_InitTypeDef timer_config;\n  TIM_HandleTypeDef timer_handle;\n  memset(&timer_handle, 0, sizeof(TIM_HandleTypeDef));\n  timer_config.OCMode = TIM_OCMODE_PWM1;\n  timer_config.Pulse = 0;\n  timer_config.OCPolarity = TIM_OCPOLARITY_HIGH;\n  timer_config.OCNPolarity = TIM_OCNPOLARITY_HIGH;\n  timer_config.OCFastMode = TIM_OCFAST_DISABLE;\n  timer_config.OCIdleState = TIM_OCIDLESTATE_RESET;\n  timer_config.OCNIdleState = TIM_OCNIDLESTATE_RESET;\n  timer_handle.Instance = (TIM_TypeDef *)pinmap_peripheral(pin, (PinMap *)PTR_PinMap_PWM_080071dc);\n  if (timer_handle.Instance != NULL)\n  {\n    timer_clk_freq = getTimerClkFreq(timer_handle.Instance);\n    timer_handle.Init.Prescaler = timer_clk_freq / clock_frequency - 1;\n    timer_handle.Init.Period = period - 1;\n    timer_handle.Init.ClockDivision = 0;\n    timer_handle.Init.CounterMode = TIM_COUNTERMODE_UP;\n    timer_handle.Init.RepetitionCounter = 0;\n    timer_handle.State = HAL_TIM_STATE_RESET;\n    if (initialize == 1)\n    {\n      PTR_g_current_pin_080071e0 = pin;\n      status = HAL_TIM_PWM_Init(&timer_handle);\n      if (status != HAL_OK)\n      {\n        return;\n      }\n    }\n    pwm_channel = get_pwm_channel(pin);\n    if ((pwm_channel == 0) || (pwm_channel == 4) || (pwm_channel == 8) || (pwm_channel == 12) || (pwm_channel == 24))\n    {\n      timer_config.Pulse = duty_cycle;\n      status = HAL_TIM_PWM_ConfigChannel(&timer_handle, &timer_config, pwm_channel);\n      if (status == HAL_OK)\n      {\n        uint32_t function = pinmap_function(pin, (PinMap *)PTR_PinMap_PWM_080071dc);\n        if ((function & 0x100000) == 0)\n        {\n          HAL_TIM_PWM_Start(&timer_handle, pwm_channel);\n        }\n        else\n        {\n          HAL_TIMEx_PWMN_Start(&timer_handle, pwm_channel);\n        }\n      }\n    }\n  }\n}",
            "called": [
                "pinmap_function",
                "memset",
                "get_pwm_channel",
                "HAL_TIM_PWM_Init",
                "getTimerClkFreq",
                "HAL_TIMEx_PWMN_Start",
                "pinmap_peripheral",
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_PWM_Start"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007118",
            "calling": [
                "analogWrite"
            ],
            "imported": false,
            "current_name": "set_pwm_08007118"
        },
        "FUN_08001be8": {
            "renaming": {
                "FUN_08001be8": "initialize_static_variables_08001be8"
            },
            "code": "void initialize_static_variables_08001be8(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001be8",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_08001be8"
        },
        "FUN_08005a68": {
            "renaming": {
                "FUN_08005a68": "set_clk_init_struct_08005a68",
                "RCC_ClkInitStruct_conflict": "clk_init_struct",
                "pFLatency": "flash_latency",
                "iVar1": "temp_var",
                "ClockType": "RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2",
                "SYSCLKSource": "RCC_SYSCLKSOURCE_STATUS_PLLCLK",
                "AHBCLKDivider": "RCC_CFGR_HPRE_DIV15",
                "APB1CLKDivider": "RCC_CFGR_PPRE1_DIV7",
                "APB2CLKDivider": "RCC_CFGR_PPRE2_DIV7",
                "DAT_08005a9c": "PTR_DAT_08005a9c",
                "DAT_08005aa0": "PTR_DAT_08005aa0",
                "*pFLatency": "*flash_latency",
                "*(uint *)(DAT_08005a9c + 4) & 3": "*(uint *)(temp_var + 4) & RCC_SYSCLKSOURCE_STATUS_PLLCLK",
                "*(uint *)(iVar1 + 4) & 0xf0": "*(uint *)(temp_var + 4) & RCC_CFGR_HPRE_DIV15",
                "*(uint *)(iVar1 + 4) & 0x700": "*(uint *)(temp_var + 4) & RCC_CFGR_PPRE1_DIV7",
                "*(uint *)(iVar1 + 4) >> 3 & 0x700": "*(uint *)(temp_var + 4) >> 3 & RCC_CFGR_PPRE2_DIV7",
                "*DAT_08005aa0 & 7": "*PTR_DAT_08005aa0 & FLASH_LATENCY_MASK"
            },
            "code": "void set_clk_init_struct_08005a68(RCC_ClkInitTypeDef_conflict *clk_init_struct, uint32_t *flash_latency) {\n  int temp_var;\n  clk_init_struct->ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  temp_var = DAT_08005a9c;\n  clk_init_struct->SYSCLKSource = *(uint *)(DAT_08005a9c + 4) & 3;\n  clk_init_struct->AHBCLKDivider = *(uint *)(temp_var + 4) & RCC_CFGR_HPRE_DIV15;\n  clk_init_struct->APB1CLKDivider = *(uint *)(temp_var + 4) & RCC_CFGR_PPRE1_DIV7;\n  clk_init_struct->APB2CLKDivider = *(uint *)(temp_var + 4) >> 3 & RCC_CFGR_PPRE2_DIV7;\n  *flash_latency = *DAT_08005aa0 & 7;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a68",
            "calling": [
                "getTimerClkFreq"
            ],
            "imported": false,
            "current_name": "set_clk_init_struct_08005a68"
        },
        "FUN_08008f78": {
            "renaming": {
                "FUN_08008f78": "configure_gpio_irq_08008f78",
                "__initialize_p": "should_initialize",
                "__priority": "priority",
                "puVar1": "gpio_irq_conf_ptr"
            },
            "code": "void configure_gpio_irq_08008f78(int should_initialize, int priority) {\n  undefined *gpio_irq_conf_ptr;\n  gpio_irq_conf_ptr = PTR_gpio_irq_conf_08009018;\n  if (should_initialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    gpio_irq_conf_ptr[0x0] = 6;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0xc) = 0;\n    gpio_irq_conf_ptr[0x14] = 7;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x20) = 0;\n    gpio_irq_conf_ptr[0x28] = 8;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x34) = 0;\n    gpio_irq_conf_ptr[0x3c] = 9;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x48) = 0;\n    gpio_irq_conf_ptr[0x50] = 10;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x5c) = 0;\n    gpio_irq_conf_ptr[0x64] = 0x17;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x70) = 0;\n    gpio_irq_conf_ptr[0x78] = 0x17;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x84) = 0;\n    gpio_irq_conf_ptr[0x8c] = 0x17;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x98) = 0;\n    gpio_irq_conf_ptr[0xa0] = 0x17;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0xac) = 0;\n    gpio_irq_conf_ptr[0xb4] = 0x17;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0xc0) = 0;\n    gpio_irq_conf_ptr[0xc8] = 0x28;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0xd4) = 0;\n    gpio_irq_conf_ptr[0xdc] = 0x28;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0xe8) = 0;\n    gpio_irq_conf_ptr[0xf0] = 0x28;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0xfc) = 0;\n    gpio_irq_conf_ptr[0x104] = 0x28;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x110) = 0;\n    gpio_irq_conf_ptr[0x118] = 0x28;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x124) = 0;\n    gpio_irq_conf_ptr[0x12c] = 0x28;\n    *(undefined4 *)(gpio_irq_conf_ptr + 0x138) = 0;\n    __aeabi_atexit(0,DAT_08009020,PTR___dso_handle_0800901c);\n  }\n  return;\n}",
            "called": [
                "__aeabi_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f78",
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "imported": false,
            "current_name": "configure_gpio_irq_08008f78"
        },
        "FUN_08002dea": {
            "renaming": {
                "FUN_08002dea": "printFirmataVersion_08002dea",
                "context": "firmataContext",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "void firmata::FirmataClass::printFirmataVersion_08002dea(void *firmataContext) {\n  if (firmataContext != nullptr) {\n    printVersion((FirmataClass *)firmataContext);\n    return;\n  }\n  return;\n}",
            "called": [
                "printVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002dea",
            "calling": [],
            "imported": false,
            "current_name": "printFirmataVersion_08002dea"
        },
        "FUN_08008d30": {
            "renaming": {
                "FUN_08008d30::FUN_08008d30": "initializeSerialCommunication",
                "this": "obj",
                "peripheral": "peripheral",
                "PVar1": "pin_rx",
                "extraout_r1": "ctx2",
                "extraout_r1_00": "ctx1",
                "ctx": "ctx2",
                "FUN_08008d30": "initializeSerialCommunication_08008d30"
            },
            "code": "initializeSerialCommunication_08008d30* __thiscall initializeSerialCommunication_08008d30(initializeSerialCommunication_08008d30* obj, void* peripheral) {\n  PinName_conflict pin_rx;\n  EVP_PKEY_CTX *ctx1;\n  EVP_PKEY_CTX *ctx2;\n  \n  (obj->super_Stream).super_Print.write_error = 0;\n  (obj->super_Stream)._timeout = 1000;\n  (obj->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)PTR_PTR_write_1_08008d7c;\n  if (obj == (initializeSerialCommunication_08008d30 *)PTR_Serial2_08008d80) {\n    setRx(obj, 0);\n    setTx(obj, 1);\n    ctx1 = extraout_r1_00;\n  }\n  else {\n    pin_rx = pinmap_pin(peripheral, (PinMap_conflict *)PTR_PinMap_UART_RX_08008d84);\n    (obj->_serial).pin_rx = pin_rx;\n    pin_tx = pinmap_pin(peripheral, (PinMap_conflict *)PTR_PinMap_UART_TX_08008d88);\n    (obj->_serial).pin_tx = pin_tx;\n    ctx2 = extraout_r1;\n  }\n  init(obj, ctx1);\n  return obj;\n}",
            "called": [
                "init",
                "pinmap_pin",
                "setTx",
                "setRx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d30",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initializeSerialCommunication_08008d30"
        },
        "FUN_0800734a": {
            "renaming": {
                "FUN_0800734a": "find_pin_for_peripheral_0800734a",
                "*peripheral": "peripheral",
                "*map": "map",
                "PVar1": "pin_name"
            },
            "code": "PinName_conflict find_pin_for_peripheral_0800734a(void *peripheral, PinMap_conflict *map) {\n  PinName_conflict pin_name;\n  if (peripheral != NULL) {\n    pin_name = pinmap_find_pin(peripheral, map);\n    return pin_name;\n  }\n  return NC;\n}",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800734a",
            "calling": [
                "uart_debug_init",
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "find_pin_for_peripheral_0800734a"
        },
        "FUN_08000aec": {
            "renaming": {
                "FUN_08000aec": "resetAllPins_08000aec",
                "PTR_isResetting_08000bc0": "isResettingPtr",
                "PTR_isI2CEnabled_08000bc4": "isI2CEnabledPtr",
                "disableI2CPins": "disableI2CPins",
                "PTR_reportPINs_08000bc8": "reportPINsPtr",
                "PTR_portConfigInputs_08000bcc": "portConfigInputsPtr",
                "PTR_previousPINs_08000bd0": "previousPINsPtr",
                "PTR_digitalPin_08000bd4": "digitalPinPtr",
                "pinNametoDigitalPin": "pinNametoDigitalPin",
                "setPinModeCallback": "setPinModeCallback",
                "PTR_servoPinMap_08000bd8": "servoPinMapPtr",
                "PTR_analogInputsToReport_08000bdc": "analogInputsToReportPtr",
                "PTR_detachedServoCount_08000be0": "detachedServoCountPtr",
                "PTR_servoCount_08000be4": "servoCountPtr"
            },
            "code": "void resetAllPins_08000aec()\n{\n  bool isI2CEnabled = *PTR_isI2CEnabled_08000bc4;\n  *PTR_isResetting_08000bc0 = true;\n  if (isI2CEnabled) {\n    disableI2CPins();\n  }\n  for (uint i = 0; i < 5; i++) {\n    PTR_reportPINs_08000bc8[i] = 0;\n    PTR_portConfigInputs_08000bcc[i] = 0;\n    PTR_previousPINs_08000bd0[i] = 0;\n  }\n  for (uint i = 0; i < 0x3c; i++) {\n    bool isPinServo = false;\n    if (i >= 0x2e && i < 0x3c) {\n      PinName_conflict pinName = PTR_digitalPin_08000bd4[i];\n      uint digitalPin = pinNametoDigitalPin(pinName);\n      if (digitalPin == 2) {\n        isPinServo = true;\n      }\n      else if (digitalPin != 1 && digitalPin != 0) {\n        isPinServo = true;\n      }\n    }\n    if (isPinServo) {\n      setPinModeCallback((byte)i, 2);\n    }\n    else {\n      if (i < 0x3c && PTR_digitalPin_08000bd4[i] != NC) {\n        PinName_conflict pinName = PTR_digitalPin_08000bd4[i];\n        uint digitalPin = pinNametoDigitalPin(pinName);\n        if (digitalPin != 1 && digitalPin != 0) {\n          setPinModeCallback((byte)i, 1);\n        }\n      }\n    }\n    PTR_servoPinMap_08000bd8[i] = 0xff;\n  }\n  *PTR_analogInputsToReport_08000bdc = 0;\n  *PTR_detachedServoCount_08000be0 = 0;\n  *PTR_servoCount_08000be4 = 0;\n  *PTR_isResetting_08000bc0 = false;\n}",
            "called": [
                "disableI2CPins",
                "pinNametoDigitalPin",
                "setPinModeCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000aec",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "resetAllPins_08000aec"
        },
        "FUN_080068d6": {
            "renaming": {
                "FUN_080068d6": "receive_uart_data_080068d6",
                "*huart": "*uart_handle",
                "*pData": "*data_buffer",
                "Size": "data_size",
                "HAL_BUSY": "HAL_BUSY",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_UART_STATE_BUSY_RX": "HAL_UART_STATE_BUSY_RX",
                "huart->pRxBuffPtr": "uart_handle->pRxBuffPtr",
                "huart->RxXferSize": "uart_handle->RxXferSize",
                "huart->RxXferCount": "uart_handle->RxXferCount",
                "huart->ErrorCode": "uart_handle->ErrorCode",
                "huart->RxState": "uart_handle->RxState",
                "huart->Lock": "uart_handle->Lock",
                "huart->Instance->CR1": "uart_handle->Instance->CR1",
                "huart->Instance->CR3": "uart_handle->Instance->CR3",
                "| 0x100": "| USART_CR1_RXNEIE",
                "| 1": "| USART_CR3_EIE",
                "| 0x20": "| USART_CR1_RE",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef receive_uart_data_080068d6(UART_HandleTypeDef *uart_handle, uint8_t *data_buffer, uint16_t data_size)\n{\n    if (uart_handle->RxState != HAL_UART_STATE_READY) {\n        return HAL_BUSY;\n    }\n    if (data_buffer == NULL) {\n        return HAL_ERROR;\n    }\n    if (data_size == 0) {\n        return HAL_ERROR;\n    }\n    if (uart_handle->Lock != HAL_LOCKED) {\n        uart_handle->pRxBuffPtr = data_buffer;\n        uart_handle->RxXferSize = data_size;\n        uart_handle->RxXferCount = data_size;\n        uart_handle->ErrorCode = 0;\n        uart_handle->RxState = HAL_UART_STATE_BUSY_RX;\n        uart_handle->Lock = HAL_UNLOCKED;\n        uart_handle->Instance->CR1 |= USART_CR1_RXNEIE;\n        uart_handle->Instance->CR3 |= USART_CR3_EIE;\n        uart_handle->Instance->CR1 |= USART_CR1_RE;\n        return HAL_OK;\n    }\n    return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080068d6",
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "imported": false,
            "current_name": "receive_uart_data_080068d6"
        },
        "FUN_080032a2": {
            "renaming": {
                "FUN_080032a2": "sendSysexMessage_080032a2",
                "this": "marshaller",
                "string": "message",
                "bytec": "message_length",
                "sendSysex": "sendSysex"
            },
            "code": "void __thiscall firmata::FirmataMarshaller::sendSysexMessage_080032a2(FirmataMarshaller *marshaller, char *message) {\n  size_t message_length;\n  message_length = strlen(message);\n  sendSysex(marshaller, 'q', message_length, (uint8_t *)message);\n  return;\n}",
            "called": [
                "sendSysex",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080032a2",
            "calling": [
                "sendString"
            ],
            "imported": false,
            "current_name": "sendSysexMessage_080032a2"
        },
        "FUN_08009e28": {
            "renaming": {
                "FUN_08009e28": "process_data_08009e28",
                "param_1": "data_count",
                "param_2": "process_func",
                "param_3": "arg1",
                "param_4": "arg2",
                "piVar3": "data_ptr",
                "iVar4": "data_item",
                "iVar6": "data_item_count",
                "uVar1": "process_result",
                "uVar5": "result"
            },
            "code": "uint process_data_08009e28(int data_count, code* process_func, undefined4 arg1, undefined4 arg2) {\n  uint result = 0;\n  for (int* data_ptr = (int*)(data_count + 0x48); data_ptr != (int*)0x0; data_ptr = (int*)*data_ptr) {\n    int data_item = data_ptr[2];\n    int data_item_count = data_ptr[1];\n    while (data_item_count = data_item_count - 1, -1 < data_item_count) {\n      if ((1 < *(ushort*)(data_item + 0xc)) && (*(short*)(data_item + 0xe) + 1 != 0)) {\n        uint process_result = (*process_func)(data_count, data_item, arg1, *(short*)(data_item + 0xe) + 1, arg2);\n        result |= process_result;\n      }\n      data_item += 0x68;\n    }\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009e28",
            "calling": [
                "_cleanup_r"
            ],
            "imported": false,
            "current_name": "process_data_08009e28"
        },
        "FUN_0800a01c": {
            "renaming": {
                "FUN_0800a01c": "get_process_id_0800a01c"
            },
            "code": "__pid_t get_process_id_0800a01c(void)\n{\n  return 1;\n}",
            "called": [
                "_getpid"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a01c",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "get_process_id_0800a01c"
        },
        "FUN_08006390": {
            "renaming": {
                "FUN_08006390": "configureTimer_08006390",
                "htim": "timerHandle",
                "Channel": "channel",
                "pTVar1": "timerInstance",
                "DAT_080063bc": "timerInstancePtr"
            },
            "code": "HAL_StatusTypeDef_conflict configureTimer_08006390(TIM_HandleTypeDef_conflict *timerHandle, uint32_t channel) {\n  TIM_TypeDef_conflict *timerInstance;\n  TIM_CCxChannelCmd(timerHandle->Instance, channel, 1);\n  timerInstance = timerHandle->Instance;\n  if (timerInstance == DAT_080063bc) {\n    timerInstance->BDTR |= 0x8000;\n  }\n  timerHandle->Instance->CR1 |= TIM_CR1_CEN;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006390",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configureTimer_08006390"
        },
        "FUN_08009f48": {
            "renaming": {
                "FUN_08009f48": "do_nothing_08009f48"
            },
            "code": "\nvoid do_nothing_08009f48(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f48",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_08009f48"
        },
        "FUN_08004d6a": {
            "renaming": {
                "FUN_08004d6a": "do_nothing_08004d6a"
            },
            "code": "\nvoid do_nothing_08004d6a(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d6a",
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004d6a"
        },
        "FUN_08008730": {
            "renaming": {
                "FUN_08008730": "transmit_data_08008730",
                "*huart": "*uart_handler",
                "bVar1": "uart_index",
                "iVar3": "callback_func",
                "iVar4": "callback_obj",
                "uVar2": "index"
            },
            "code": "void transmit_data_08008730(UART_HandleTypeDef *uart_handler) \\n\\\n    {\\\n        byte uart_index;\\\n        int callback_obj;\\\n        int callback_func;\\\n        uint index;\\\n        \\n\\\n        uart_index = get_uart_index(uart_handler);\\\n        index = (uint)uart_index;\\\n        callback_obj = *(int *)(PTR_tx_callback_obj_08008770 + index * 4);\\\n        if ((index < 5) && (callback_func = (**(code **)(PTR_tx_callback_08008774 + index * 4))(callback_obj), callback_func != -1)) {\\\n            HAL_UART_Transmit_IT(\\\n                *(UART_HandleTypeDef **)(PTR_uart_handlers_08008778 + (uint)*(byte *)(callback_obj + 0x44) * 4),\\\n                (uint8_t *)(*(int *)(callback_obj + 100) + (uint)*(ushort *)(callback_obj + 0x6a)),\\\n                1);\\\n        }\\\n    }",
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008730",
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "imported": false,
            "current_name": "transmit_data_08008730"
        },
        "FUN_08005460": {
            "renaming": {
                "FUN_08005460": "FUNC_08005460"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nHAL_StatusTypeDef_conflict FUNC_08005460(RCC_OscInitTypeDef_conflict *RCC_OscInitStruct)\n\n{\n  uint *puVar1;\n  uint *puVar2;\n  HAL_StatusTypeDef_conflict HVar3;\n  uint32_t uVar4;\n  uint32_t uVar5;\n  bool bVar6;\n  uint32_t tmpreg;\n  \n  puVar1 = DAT_08005720;\n  if ((RCC_OscInitStruct->OscillatorType & 1) != 0) {\n    if (((DAT_08005720[1] & 0xc) == 4) ||\n       (((DAT_08005720[1] & 0xc) == 8 && ((DAT_08005720[1] & 0x10000) != 0)))) {\n      if (((*DAT_08005720 & 0x20000) != 0) && (RCC_OscInitStruct->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      uVar5 = RCC_OscInitStruct->HSEState;\n      if (uVar5 == 0x10000) {\n        *DAT_08005720 = *DAT_08005720 | 0x10000;\n      }\n      else if (uVar5 == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (uVar5 == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        *DAT_08005720 = *DAT_08005720 & 0xfffeffff;\n        *puVar1 = *puVar1 & 0xfffbffff;\n      }\n      if (RCC_OscInitStruct->HSEState == 0) {\n        uVar5 = HAL_GetTick();\n        while ((*DAT_08005720 & 0x20000) != 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar5) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        uVar5 = HAL_GetTick();\n        while ((*DAT_08005720 & 0x20000) == 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar5) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 2) != 0) {\n    if (((DAT_08005720[1] & 0xc) == 0) ||\n       (((DAT_08005720[1] & 0xc) == 8 && ((DAT_08005720[1] & 0x10000) == 0)))) {\n      if (((*DAT_08005720 & 2) != 0) && (RCC_OscInitStruct->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      *DAT_08005720 = *DAT_08005720 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n    else if (RCC_OscInitStruct->HSIState == 0) {\n      *DAT_08005724 = 0;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_08005720 & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005724 = 1;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_08005720 & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_08005720 = *DAT_08005720 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 8) != 0) {\n    if (RCC_OscInitStruct->LSIState == 0) {\n      *DAT_08005728 = 0;\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[9] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005728 = 1;\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[9] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 4) != 0) {\n    bVar6 = (DAT_08005720[7] & 0x10000000) == 0;\n    if (bVar6) {\n      DAT_08005720[7] = DAT_08005720[7] | 0x10000000;\n    }\n    if ((*DAT_0800572c & 0x100) == 0) {\n      *DAT_0800572c = *DAT_0800572c | 0x100;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_0800572c & 0x100) == 0) {\n        uVar4 = HAL_GetTick();\n        if (100 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    puVar2 = DAT_08005838;\n    puVar1 = DAT_08005720;\n    uVar5 = RCC_OscInitStruct->LSEState;\n    if (uVar5 == 1) {\n      DAT_08005720[8] = DAT_08005720[8] | 1;\n    }\n    else if (uVar5 == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (uVar5 == 5) {\n      DAT_08005838[8] = DAT_08005838[8] | 4;\n      puVar2[8] = puVar2[8] | 1;\n    }\n    else {\n      DAT_08005720[8] = DAT_08005720[8] & 0xfffffffe;\n      puVar1[8] = puVar1[8] & 0xfffffffb;\n    }\n    if (RCC_OscInitStruct->LSEState == 0) {\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005838[8] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[8] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (bVar6) {\n      DAT_08005838[7] = DAT_08005838[7] & 0xefffffff;\n    }\n  }\n  uVar5 = (RCC_OscInitStruct->PLL).PLLState;\n  if (uVar5 == 0) {\n    HVar3 = HAL_OK;\n  }\n  else if ((DAT_08005838[1] & 0xc) == 8) {\n    HVar3 = HAL_ERROR;\n  }\n  else if (uVar5 == 2) {\n    *DAT_0800583c = 0;\n    uVar5 = HAL_GetTick();\n    do {\n      if ((*DAT_08005838 & 0x2000000) == 0) {\n        if ((RCC_OscInitStruct->PLL).PLLSource == 0x10000) {\n          DAT_08005838[1] = DAT_08005838[1] & 0xfffdffff | RCC_OscInitStruct->HSEPredivValue;\n        }\n        DAT_08005838[1] =\n             DAT_08005838[1] & 0xffc2ffff |\n             (RCC_OscInitStruct->PLL).PLLSource | (RCC_OscInitStruct->PLL).PLLMUL;\n        *DAT_0800583c = 1;\n        uVar5 = HAL_GetTick();\n        do {\n          if ((*DAT_08005838 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          uVar4 = HAL_GetTick();\n        } while (uVar4 - uVar5 < 3);\n        return HAL_TIMEOUT;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar5 < 3);\n    HVar3 = HAL_TIMEOUT;\n  }\n  else {\n    *DAT_0800583c = 0;\n    uVar5 = HAL_GetTick();\n    do {\n      if ((*DAT_08005838 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar5 < 3);\n    HVar3 = HAL_TIMEOUT;\n  }\n  return HVar3;\n}\n\n",
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08005460",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "FUNC_08005460"
        },
        "FUN_08008854": {
            "renaming": {
                "FUN_08008854": "count_unused_files_08008854",
                "file_UNUSED": "num_files",
                "ptr_UNUSED": "unused_ptr",
                "dir_UNUSED": "unused_dir"
            },
            "code": "int count_unused_files_08008854(int num_files, int unused_ptr, int unused_dir) {\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008854",
            "calling": [
                "_lseek_r"
            ],
            "imported": false,
            "current_name": "count_unused_files_08008854"
        },
        "FUN_08004d6c": {
            "renaming": {
                "FUN_08004d6c": "handle_i2c_rx_interrupt_08004d6c",
                "hi2c": "handle_i2c",
                "State": "state",
                "XferCount": "xfer_count",
                "XferOptions": "xfer_options",
                "Instance": "instance",
                "CR1": "cr1",
                "CR2": "cr2",
                "pBuffPtr": "rx_buffer_ptr",
                "DR": "dr",
                "PreviousState": "previous_state",
                "Mode": "mode",
                "HAL_I2C_STATE_BUSY_RX": "HAL_I2C_STATE_BUSY_RX",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_I2C_MODE_MEM": "HAL_I2C_MODE_MEM",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "HAL_I2C_MemRxCpltCallback": "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback": "HAL_I2C_MasterRxCpltCallback"
            },
            "code": "HAL_StatusTypeDef_conflict handle_i2c_rx_interrupt_08004d6c(I2C_HandleTypeDef_conflict *hi2c) {\n  uint8_t *rx_buffer_ptr;\n  \n  if (hi2c->state == HAL_I2C_STATE_BUSY_RX) {\n    if (hi2c->xfer_count < 4) {\n      if (hi2c->xfer_count - 2 < 2) {\n        if (hi2c->xfer_options == 2) {\n          hi2c->instance->CR1 = hi2c->instance->CR1 | 0x400;\n        }\n        else {\n          hi2c->instance->CR1 = hi2c->instance->CR1 & 0xfffffbff;\n          hi2c->instance->CR1 = hi2c->instance->CR1 | 0x800;\n        }\n        hi2c->instance->CR2 = hi2c->instance->CR2 & 0xfffffbff;\n      }\n      else {\n        if (hi2c->xfer_options == 2) {\n          hi2c->instance->CR1 = hi2c->instance->CR1 | 0x400;\n        }\n        else {\n          hi2c->instance->CR1 = hi2c->instance->CR1 & 0xfffffbff;\n        }\n        hi2c->instance->CR2 = hi2c->instance->CR2 & 0xfffff8ff;\n        rx_buffer_ptr = hi2c->rx_buffer_ptr;\n        hi2c->rx_buffer_ptr = rx_buffer_ptr + 1;\n        *rx_buffer_ptr = (uint8_t)hi2c->instance->DR;\n        hi2c->xfer_count = hi2c->xfer_count - 1;\n        hi2c->state = HAL_I2C_STATE_READY;\n        hi2c->previous_state = 0;\n        if (hi2c->mode == HAL_I2C_MODE_MEM) {\n          hi2c->mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(hi2c);\n        }\n        else {\n          hi2c->mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(hi2c);\n        }\n      }\n    }\n    else {\n      rx_buffer_ptr = hi2c->rx_buffer_ptr;\n      hi2c->rx_buffer_ptr = rx_buffer_ptr + 1;\n      *rx_buffer_ptr = (uint8_t)hi2c->instance->DR;\n      hi2c->xfer_count = hi2c->xfer_count - 1;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d6c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_rx_interrupt_08004d6c"
        },
        "FUN_08007760": {
            "renaming": {
                "FUN_08007760": "handle_timer_interrupt_08007760",
                "PTR_timer_handles_08007770": "timer_handles"
            },
            "code": "void handle_timer_interrupt_08007760(void)\n{\n    TIM_HandleTypeDef_conflict **PTR_timer_handles_08007770 = PTR_PTR_timer_handles_08007770_08007770;\n    if (*PTR_timer_handles_08007770 != NULL) {\n        HAL_TIM_IRQHandler(*PTR_timer_handles_08007770);\n    }\n    return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007760",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007760"
        },
        "FUN_08008850": {
            "renaming": {
                "FUN_08008850": "return_one_08008850",
                "file_UNUSED": "file_unused"
            },
            "code": "int return_one_08008850(int file_unused) {\n    return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008850",
            "calling": [
                "_isatty_r"
            ],
            "imported": false,
            "current_name": "return_one_08008850"
        },
        "FUN_08002fc2": {
            "renaming": {
                "FUN_08002fc2": "setPinState_08002fc2",
                "pin": "pinNumber",
                "state": "newState",
                "pinState": "pinStates",
                "this": "firmataInstance"
            },
            "code": "void __thiscall firmata::FirmataClass::setPinState_08002fc2(FirmataClass *this, byte pin, int state)\n{\n  this->pinState[pin] = state;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fc2",
            "calling": [
                "digitalWriteCallback",
                "analogWriteCallback",
                "setPinValueCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "setPinState_08002fc2"
        },
        "FUN_08008afa": {
            "renaming": {
                "__thiscall HardwareSerial::FUN_08008afa": "calculateSerialBufferLength",
                "this": "serial",
                "_serial": "serialData",
                "rx_head": "head",
                "rx_tail": "tail",
                "FUN_08008afa": "calculateSerialBufferLength_08008afa"
            },
            "code": "int calculateSerialBufferLength_08008afa(HardwareSerial *serial) {\n                        int head = (serial->_serial).rx_head;\n                        int tail = (serial->_serial).rx_tail;\n                        int bufferLength = (head + 64 - tail) & 0x3f;\n                        return bufferLength;\n                    }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008afa",
            "calling": [
                "serialEventRun"
            ],
            "imported": false,
            "current_name": "calculateSerialBufferLength_08008afa"
        },
        "FUN_08003048": {
            "renaming": {
                "FUN_08003048": "sendSerialData_08003048",
                "speed": "baud_rate",
                "s": "serial_ptr"
            },
            "code": "void __thiscall firmata::FirmataClass::sendSerialData_08003048(FirmataClass *this,long speed)\n{\n  undefined *serial_ptr;\n  serial_ptr = PTR_Serial2_08003068;\n  HardwareSerial::begin((HardwareSerial *)PTR_Serial2_08003068,speed,'\\x06');\n  blinkVersion(this);\n  sendSerialData_08003048(this,(Stream *)serial_ptr);\n  return;\n}",
            "called": [
                "begin",
                "blinkVersion",
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003048",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "sendSerialData_08003048"
        },
        "FUN_080038dc": {
            "renaming": {
                "FUN_080038dc": "get_ADC_data_080038dc",
                "hadc": "adc_handle"
            },
            "code": "uint32_t get_ADC_data_080038dc(ADC_HandleTypeDef *adc_handle)\n{\n  return adc_handle->Instance->DR;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080038dc",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_ADC_data_080038dc"
        },
        "FUN_080025ac": {
            "renaming": {
                "FUN_080025ac": "attach_080025ac",
                "pin": "servo_pin",
                "min": "min_pulse_width",
                "max": "max_pulse_width",
                "obj": "timer_object",
                "bVar1": "is_timer_active",
                "iVar2": "pulse_duration",
                "timer": "timer_sequence",
                "PTR_servos_08002628": "servo_pointer_array",
                "DAT_0800262c": "timer_frequency",
                "PTR__timer_08002630": "timer_pointer_array",
                "this->servoIndex": "servo_index",
                "this->min": "min_pulse_width",
                "this->max": "max_pulse_width"
            },
            "code": "uint8_t __thiscall Servo::attach_080025ac(Servo *this, int pin, int min_pulse_width, int max_pulse_width)\n{\n    if (this->servoIndex >= 0xc) {\n        return this->servoIndex;\n    }\n    pinMode(pin, OUTPUT);\n    int8_t min_pulse = (int8_t)(-min_pulse_width + 0x220);\n    if (min_pulse < 0) {\n        min_pulse = (int8_t)(-min_pulse_width + 0x223);\n    }\n    this->min_pulse_width = min_pulse;\n    int8_t max_pulse = (int8_t)(-max_pulse_width + 0x960);\n    if (max_pulse < 0) {\n        max_pulse = (int8_t)(-max_pulse_width + 0x963);\n    }\n    this->max_pulse_width = max_pulse;\n    timer16_Sequence_t timer = (timer16_Sequence_t)((uint32_t)PTR_servos_08002628[(uint32_t)this->servoIndex * 8] * (uint32_t)DAT_0800262c >> 0x23);\n    if (!isTimerActive(timer)) {\n        PTR__timer_08002630[0x44] = timer;\n        initISR((stimer_t *)PTR__timer_08002630);\n    }\n    PTR_servos_08002628[(uint32_t)this->servoIndex * 8] = PTR_servos_08002628[(uint32_t)this->servoIndex * 8] | 0x40;\n    return this->servoIndex;\n}",
            "called": [
                "initISR",
                "isTimerActive",
                "pinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025ac",
            "calling": [
                "attachServo",
                "attach"
            ],
            "imported": false,
            "current_name": "attach_080025ac"
        },
        "FUN_08007648": {
            "renaming": {
                "FUN_08007648": "initialize_stimer_08007648",
                "obj": "timer_obj",
                "period": "period",
                "pulseWidth": "pulse_width",
                "irqHandle": "irq_handler",
                "HVar1": "hal_status",
                "uVar2": "timer_clk_freq",
                "htim": "timer_handle",
                "sConfig": "oc_config",
                "Instance": "Instance",
                "Prescaler": "Prescaler",
                "ClockDivision": "ClockDivision",
                "CounterMode": "CounterMode",
                "RepetitionCounter": "RepetitionCounter",
                "irqHandleOC": "irq_handler_OC",
                "OCMode": "OCMode",
                "Pulse": "Pulse",
                "OCPolarity": "OCPolarity",
                "OCNPolarity": "OCNPolarity",
                "OCFastMode": "OCFastMode",
                "OCIdleState": "OCIdleState",
                "OCNIdleState": "OCNIdleState"
            },
            "code": "void initialize_stimer_08007648(stimer_t_conflict *timer_obj, uint16_t period, uint16_t pulse_width, _func_void_stimer_t_ptr_uint32_t_conflict *irq_handler) {\n  HAL_StatusTypeDef_conflict hal_status;\n  uint32_t timer_clk_freq;\n  TIM_HandleTypeDef_conflict *timer_handle;\n  TIM_OC_InitTypeDef oc_config;\n  oc_config.OCMode = 0;\n  oc_config.Pulse = 0;\n  oc_config.OCPolarity = 0;\n  oc_config.OCNPolarity = 0;\n  oc_config.OCFastMode = 0;\n  oc_config.OCIdleState = 0;\n  oc_config.OCNIdleState = 0;\n  timer_handle = &timer_obj->handle;\n  timer_obj->timer = (TIM_TypeDef_conflict *)0x40000000;\n  timer_handle->Instance = (TIM_TypeDef_conflict *)0x40000000;\n  timer_handle->Init.Period = (uint32_t)period;\n  timer_clk_freq = get_timer_clk_freq((TIM_TypeDef_conflict *)0x40000000);\n  timer_handle->Init.Prescaler = (uint32_t)(((uint64_t)DAT_080076dc * (uint64_t)timer_clk_freq) >> 0x32) - 1;\n  timer_handle->Init.ClockDivision = 0;\n  timer_handle->Init.CounterMode = 0;\n  timer_handle->Init.RepetitionCounter = 0;\n  timer_obj->irq_handler_OC = irq_handler;\n  oc_config.OCMode = 0;\n  oc_config.OCPolarity = 0;\n  oc_config.OCFastMode = 0;\n  oc_config.OCNPolarity = 0;\n  oc_config.OCIdleState = 0;\n  oc_config.OCNIdleState = 0;\n  oc_config.Pulse = (uint32_t)pulse_width;\n  timer_obj->irq_number = get_timer_irq(timer_obj->timer);\n  HAL_NVIC_SetPriority((IRQn_Type_conflict)timer_obj->irq_number, 0xE, 0);\n  HAL_NVIC_EnableIRQ((IRQn_Type_conflict)timer_obj->irq_number);\n  hal_status = HAL_TIM_OC_Init(timer_handle);\n  if ((hal_status == HAL_OK) && (hal_status = HAL_TIM_OC_ConfigChannel(timer_handle, &oc_config, 0), hal_status == HAL_OK)) {\n    HAL_TIM_OC_Start_IT(timer_handle, 0);\n  }\n}\n",
            "called": [
                "HAL_TIM_OC_Init",
                "getTimerClkFreq",
                "getTimerIrq",
                "HAL_NVIC_SetPriority",
                "HAL_TIM_OC_ConfigChannel",
                "HAL_TIM_OC_Start_IT",
                "HAL_NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007648",
            "calling": [
                "initISR"
            ],
            "imported": false,
            "current_name": "initialize_stimer_08007648"
        },
        "FUN_08008858": {
            "renaming": {
                "FUN_08008858": "return_zero_08008858",
                "file_UNUSED": "file_unused",
                "ptr_UNUSED": "ptr_unused",
                "len_UNUSED": "len_unused"
            },
            "code": "int return_zero_08008858(int file_unused, char *ptr_unused, int len_unused)\n{\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008858",
            "calling": [
                "_read_r"
            ],
            "imported": false,
            "current_name": "return_zero_08008858"
        },
        "FUN_08004a20": {
            "renaming": {
                "FUN_08004a20": "do_nothing_08004a20"
            },
            "code": "\nvoid do_nothing_08004a20(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a20",
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a20"
        },
        "FUN_08004a24": {
            "renaming": {
                "FUN_08004a24": "send_i2c_data_08004a24",
                "hi2c": "handle",
                "HVar1": "state",
                "pbVar2": "data_ptr"
            },
            "code": "HAL_StatusTypeDef_conflict send_i2c_data_08004a24(I2C_HandleTypeDef_conflict *handle)\n{\n  HAL_I2C_StateTypeDef_conflict state = handle->State;\n  if (handle->XferCount != 0) {\n    byte *data_ptr = handle->pBuffPtr;\n    handle->pBuffPtr = data_ptr + 1;\n    handle->Instance->DR = (uint)*data_ptr;\n    handle->XferCount--;\n    if ((handle->XferCount == 0) && (state == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      handle->Instance->CR2 &= 0xfffffbff;\n      handle->PreviousState = 0x21;\n      handle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(handle);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a24",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "send_i2c_data_08004a24"
        },
        "FUN_08004a22": {
            "renaming": {
                "FUN_08004a22": "do_nothing_08004a22"
            },
            "code": "\nvoid do_nothing_08004a22(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a22",
            "calling": [
                "I2C_Slave_AF",
                "I2C_SlaveTransmit_TXE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a22"
        },
        "FUN_08002fba": {
            "renaming": {
                "FUN_08002fba": "getPinState_08002fba",
                "pin": "pin",
                "this": "this",
                "pinState": "pinState"
            },
            "code": "int __thiscall firmata::FirmataClass::getPinState_08002fba(FirmataClass *this, byte pin) {\n  return this->pinState[pin];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fba",
            "calling": [
                "digitalWriteCallback",
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "getPinState_08002fba"
        },
        "FUN_080090cc": {
            "renaming": {
                "FUN_080090cc": "print_assertion_failed_080090cc",
                "param_1": "file",
                "param_2": "message",
                "param_3": "file_name",
                "param_4": "line_number",
                "puVar1": "expression",
                "puVar2": "value",
                "PTR_s__08009104": "default_expression",
                "PTR_s___function__080090fc": "default_value",
                "PTR_s_assertion___s__failed__file___s__08009100": "assertion_failed_message",
                "PTR__impure_ptr_080090f8": "impure_ptr"
            },
            "code": "void print_assertion_failed_080090cc(FILE *file, const char *message, const char *file_name, int line_number, const char *function_name, const char *expression, const char *value)\n{\n    const char *PTR_s__08009104 = \"\";\n    const char *PTR_s___function__080090fc = \"\";\n    if (expression == NULL)\n        expression = PTR_s__08009104;\n    if (value == NULL)\n        value = PTR_s___function__080090fc;\n    fprintf(file, \"%s:%d: %s: Assertion '%s' failed. Value was '%s'.\\n\", file_name, line_number, function_name, expression, value);\n    abort();\n}",
            "called": [
                "fiprintf",
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090cc",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "print_assertion_failed_080090cc"
        },
        "FUN_080049e0": {
            "renaming": {
                "FUN_080049e0": "listen_for_i2c_events_080049e0",
                "hi2c": "handle",
                "pIVar1": "i2c_instance",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "HAL_StatusTypeDef listen_for_i2c_events_080049e0(I2C_HandleTypeDef *handle)\n{\n  I2C_TypeDef *i2c_instance;\n  \n  if (handle->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  handle->State = HAL_I2C_STATE_LISTEN;\n  i2c_instance = handle->Instance;\n  if ((i2c_instance->CR1 & 1) == 0) {\n    i2c_instance->CR1 |= 1;\n  }\n  i2c_instance->CR1 |= 0x400;\n  i2c_instance->CR2 |= 0x300;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080049e0",
            "calling": [
                "i2c_attachSlaveRxEvent",
                "i2c_attachSlaveTxEvent",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "imported": false,
            "current_name": "listen_for_i2c_events_080049e0"
        },
        "FUN_08006d24": {
            "renaming": {
                "FUN_08006d24": "update_ADC_status_08006d24",
                "*hadc": "*adc_handle",
                "iVar1": "current_adc_status",
                "DAT_08006d7c": "ADC_STATUS_PTR",
                "DAT_08006d74": "ADC_INSTANCE_A",
                "DAT_08006d78": "ADC_INSTANCE_B"
            },
            "code": "void update_ADC_status_08006d24(ADC_HandleTypeDef *adc_handle)\n{\n  int current_adc_status = DAT_08006d7c;\n  if (adc_handle->Instance != DAT_08006d74)\n  {\n    if (adc_handle->Instance == DAT_08006d78)\n    {\n      *(uint *)(DAT_08006d7c + 0xc) |= 0x400;\n      *(uint *)(current_adc_status + 0xc) &= 0xfffffbff;\n      *(uint *)(current_adc_status + 0x18) &= 0xfffffbff;\n      *(uint *)(current_adc_status + 0x18) &= 0xfffffbff;\n    }\n    return;\n  }\n  *(uint *)(DAT_08006d7c + 0xc) |= 0x200;\n  *(uint *)(current_adc_status + 0xc) &= 0xfffffdff;\n  *(uint *)(current_adc_status + 0x18) &= 0xfffffdff;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d24",
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "imported": false,
            "current_name": "update_ADC_status_08006d24"
        },
        "FUN_08008500": {
            "renaming": {
                "FUN_08008500": "transmit_data_08008500",
                "*data": "data",
                "size": "size",
                "PinName_conflict": "PinName",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "uVar2": "start_time",
                "PTR_digitalPin_080085a8": "digitalPin",
                "pvVar3": "peripheral",
                "PinMap_conflict": "PinMap",
                "PTR_PinMap_UART_TX_080085ac": "PinMap_UART_TX",
                "uVar5": "index",
                "PTR_uart_handlers_080085b0": "uart_handlers",
                "PTR_serial_debug_080085b4": "serial_debug",
                "HVar1": "status",
                "uVar4": "current_time"
            },
            "code": "size_t transmit_data_08008500(uint8_t *data, uint32_t size)\n{\n  PinName pin_name;\n  HAL_StatusTypeDef status;\n  uint32_t start_time;\n  void *peripheral;\n  uint32_t index;\n\n  start_time = HAL_GetTick();\n  pin_name = PTR_digitalPin_080085a8[1];\n  peripheral = pinmap_peripheral(pin_name, (PinMap *)PTR_PinMap_UART_TX_080085ac);\n  if (peripheral == NULL) {\n    return 0;\n  }\n  index = 0;\n  while ((index < 5 && ((PTR_uart_handlers_080085b0[index] == 0 || (peripheral = pinmap_peripheral(pin_name, (PinMap *)PTR_PinMap_UART_TX_080085ac), *(void **)PTR_uart_handlers_080085b0[index] != peripheral))))) {\n    index++;\n  }\n  if (4 < index) {\n    if ((4 < PTR_serial_debug_080085b4[0x44]) && (uart_debug_init(), 4 < PTR_serial_debug_080085b4[0x44])) {\n      return 0;\n    }\n    index = (uint)PTR_serial_debug_080085b4[0x44];\n  }\n  do {\n    status = HAL_UART_Transmit(*(UART_HandleTypeDef **)PTR_uart_handlers_080085b0[index], data, (uint16_t)size, 1000);\n    if (status == HAL_OK) {\n      return size;\n    }\n  } while (HAL_GetTick() - start_time < 1000);\n  return 0;\n}",
            "called": [
                "HAL_GetTick",
                "uart_debug_init",
                "pinmap_peripheral",
                "HAL_UART_Transmit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008500",
            "calling": [
                "_write"
            ],
            "imported": false,
            "current_name": "transmit_data_08008500"
        },
        "FUN_08007774": {
            "renaming": {
                "FUN_08007774": "handle_timer_interrupt_08007774",
                "PTR_timer_handles_08007784": "PTR_timer_handles",
                "TIM_HandleTypeDef_conflict": "TimerHandle",
                "HAL_TIM_IRQHandler": "HandleTimerIRQ",
                "timer_handle": "current_timer_handle"
            },
            "code": "void handle_timer_interrupt_08007774(void)\n{\n    TIM_HandleTypeDef_conflict* timer_handle = *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_08007784_08007784 + 4);\n    if (timer_handle != NULL) {\n        HAL_TIM_IRQHandler(timer_handle);\n    }\n    return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007774",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007774"
        },
        "FUN_08005e6c": {
            "renaming": {
                "FUN_08005e6c": "do_nothing_08005e6c"
            },
            "code": "\nvoid do_nothing_08005e6c(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6c",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e6c"
        },
        "FUN_080001a8": {
            "renaming": {
                "FUN_080001a8": "checkAndSetPinState_080001a8",
                "pin": "pinNumber",
                "value": "pinValue",
                "bVar1": "isPinValid",
                "bVar2": "pinModeValue",
                "ulPin": "digitalPinNumber",
                "uVar3": "pinToDigitalPinNumber"
            },
            "code": "void checkAndSetPinState_080001a8(byte pin, int value) {\n  bool isPinValid;\n  byte pinModeValue;\n  uint digitalPinNumber;\n  uint32_t pinToDigitalPinNumber;\n  \n  digitalPinNumber = (uint)pin;\n  if (digitalPinNumber < 0x3c) {\n    if (PTR_digitalPin_0800020c[digitalPinNumber] == NC) {\n      isPinValid = false;\n    }\n    else {\n      pinToDigitalPinNumber = pinNametoDigitalPin(PTR_digitalPin_0800020c[digitalPinNumber]);\n      if (pinToDigitalPinNumber == 0) {\n        isPinValid = false;\n      }\n      else if (pinToDigitalPinNumber == 1) {\n        isPinValid = false;\n      }\n      else {\n        isPinValid = true;\n      }\n    }\n  }\n  else {\n    isPinValid = false;\n  }\n  pinModeValue = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000210,pin);\n  if ((isPinValid) && (pinModeValue == OUTPUT)) {\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000210,pin,value);\n    digitalWrite(digitalPinNumber,value);\n  }\n  return;\n}",
            "called": [
                "digitalWrite",
                "pinNametoDigitalPin",
                "setPinState",
                "getPinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001a8",
            "calling": [],
            "imported": false,
            "current_name": "checkAndSetPinState_080001a8"
        },
        "FUN_080048c8": {
            "renaming": {
                "FUN_080048c8": "configureI2C_080048c8",
                "hi2c": "i2cHandle",
                "pData": "data",
                "Size": "dataSize",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance"
            },
            "code": "HAL_StatusTypeDef_conflict configureI2C_080048c8(I2C_HandleTypeDef_conflict *i2cHandle, uint8_t *data, uint16_t dataSize, uint32_t transferOptions)\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2cInstance;\n  uint32_t tmpreg;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == NULL) {\n      status = HAL_ERROR;\n    }\n    else if (dataSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = data;\n      i2cHandle->XferCount = dataSize;\n      i2cHandle->XferOptions = transferOptions;\n      i2cHandle->XferSize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080048c8",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "configureI2C_080048c8"
        },
        "FUN_08009954": {
            "renaming": {
                "FUN_08009954": "copy_string_08009954",
                "__dest": "destination",
                "__src": "source",
                "__n": "max_length",
                "cVar1": "current_char",
                "sVar2": "chars_copied",
                "pcVar3": "dest_ptr",
                "pcVar4": "dest_ptr"
            },
            "code": "char* copy_string_08009954(char* destination, char* source, size_t max_length) {\n    char current_char;\n    size_t chars_copied;\n    char* dest_ptr = destination;\n    while (1) {\n        current_char = *source;\n        if (current_char == '\\0' || chars_copied == max_length - 1) {\n            break;\n        }\n        *dest_ptr = current_char;\n        dest_ptr++;\n        source++;\n        chars_copied++;\n    }\n    while (chars_copied < max_length) {\n        *dest_ptr = '\\0';\n        dest_ptr++;\n        chars_copied++;\n    }\n    return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009954",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "copy_string_08009954"
        },
        "FUN_08005e6e": {
            "renaming": {
                "FUN_08005e6e": "handle_TIM_interrupts_08005e6e",
                "htim": "timer_handle",
                "pTVar1": "timer_instance"
            },
            "code": "void handle_TIM_interrupts_08005e6e(TIM_HandleTypeDef_conflict *htim)\n{\n    TIM_TypeDef_conflict *timer_instance = htim->Instance;\n    \n    if (((timer_instance->SR & TIM_SR_CC1IF) != 0) && ((timer_instance->DIER & TIM_DIER_CC1IE) != 0)) {\n        timer_instance->SR = ~(TIM_SR_CC1IF);\n        \n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n        if ((timer_instance->CCMR1 & TIM_CCMR1_CC1S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(htim);\n            HAL_TIM_PWM_PulseFinishedCallback(htim);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(htim);\n        }\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n    \n    if (((timer_instance->SR & TIM_SR_CC2IF) != 0) && ((timer_instance->DIER & TIM_DIER_CC2IE) != 0)) {\n        timer_instance->SR = ~(TIM_SR_CC2IF);\n        \n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n        if ((timer_instance->CCMR1 & TIM_CCMR1_CC2S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(htim);\n            HAL_TIM_PWM_PulseFinishedCallback(htim);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(htim);\n        }\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n    \n    if (((timer_instance->SR & TIM_SR_CC3IF) != 0) && ((timer_instance->DIER & TIM_DIER_CC3IE) != 0)) {\n        timer_instance->SR = ~(TIM_SR_CC3IF);\n        \n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n        if ((timer_instance->CCMR2 & TIM_CCMR2_CC3S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(htim);\n            HAL_TIM_PWM_PulseFinishedCallback(htim);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(htim);\n        }\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n    \n    if (((timer_instance->SR & TIM_SR_CC4IF) != 0) && ((timer_instance->DIER & TIM_DIER_CC4IE) != 0)) {\n        timer_instance->SR = ~(TIM_SR_CC4IF);\n        \n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n        if ((timer_instance->CCMR2 & TIM_CCMR2_CC4S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(htim);\n            HAL_TIM_PWM_PulseFinishedCallback(htim);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(htim);\n        }\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n    \n    if (((timer_instance->SR & TIM_SR_UIF) != 0) && ((timer_instance->DIER & TIM_DIER_UIE) != 0)) {\n        timer_instance->SR = ~(TIM_SR_UIF);\n        HAL_TIM_PeriodElapsedCallback(htim);\n    }\n    \n    if (((timer_instance->SR & TIM_SR_BIF) != 0) && ((timer_instance->DIER & TIM_DIER_BIE) != 0)) {\n        timer_instance->SR = ~(TIM_SR_BIF);\n        HAL_TIMEx_BreakCallback(htim);\n    }\n    \n    if (((timer_instance->SR & TIM_SR_TIF) != 0) && ((timer_instance->DIER & TIM_DIER_TIE) != 0)) {\n        timer_instance->SR = ~(TIM_SR_TIF);\n        HAL_TIM_TriggerCallback(htim);\n    }\n    \n    if (((timer_instance->SR & TIM_SR_COMIF) != 0) && ((timer_instance->DIER & TIM_DIER_COMIE) != 0)) {\n        timer_instance->SR = ~(TIM_SR_COMIF);\n        HAL_TIMEx_CommutationCallback(htim);\n    }\n}\n",
            "called": [
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIMEx_BreakCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6e",
            "calling": [
                "TIM2_IRQHandler",
                "TIM4_IRQHandler",
                "TIM1_UP_IRQHandler",
                "TIM3_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_TIM_interrupts_08005e6e"
        },
        "FUN_08004024": {
            "renaming": {
                "FUN_08004024": "set_clock_source_08004024",
                "CLKSource": "source",
                "*DAT_08004040": "clock_register"
            },
            "code": "void set_clock_source_08004024(uint32_t source) {\n  if (source != 4) {\n    *DAT_08004040 = *DAT_08004040 & 0xfffffffb;\n    return;\n  }\n  *DAT_08004040 = *DAT_08004040 | 4;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004024",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_clock_source_08004024"
        },
        "FUN_08005e6a": {
            "renaming": {
                "FUN_08005e6a": "do_nothing_08005e6a"
            },
            "code": "\nvoid do_nothing_08005e6a(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6a",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e6a"
        },
        "FUN_08004a1e": {
            "renaming": {
                "FUN_08004a1e": "do_nothing_08004a1e"
            },
            "code": "\nvoid do_nothing_08004a1e(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a1e",
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a1e"
        },
        "FUN_08008868": {
            "renaming": {
                "FUN_08008868": "infinite_loop_08008868",
                "status_UNUSED": "unused_status"
            },
            "code": "void infinite_loop_08008868(int unused_status)\n{\n  while(true)\n  {\n    // Do nothing\n  }\n}",
            "called": [
                "_exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008868",
            "calling": [
                "abort",
                "_exit"
            ],
            "imported": false,
            "current_name": "infinite_loop_08008868"
        },
        "FUN_080036ac": {
            "renaming": {
                "FUN_080036ac": "find_pin_index_080036ac",
                "p": "pin_conflict",
                "uVar1": "index"
            },
            "code": "uint32_t find_pin_index_080036ac(PinName_conflict pin_conflict)\n{\n  uint32_t index = 0xffffffff;\n  uint32_t max_pins = 5;\n  if ((uint)((int)pin_conflict << 0x18) >> 0x1c < max_pins) {\n    for (uint32_t i = 0; i < 0x3c && ((int)pin_conflict != (int)(char)PTR_digitalPin_080036d0[i]); i++) {\n      index = i;\n    }\n  }\n  return index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036ac",
            "calling": [
                "enableI2CPins",
                "checkDigitalInputs",
                "loop",
                "digitalWriteCallback",
                "sysexCallback",
                "systemResetCallback",
                "analogWriteCallback",
                "setPinValueCallback",
                "setPinModeCallback",
                "reportDigitalCallback"
            ],
            "imported": false,
            "current_name": "find_pin_index_080036ac"
        },
        "FUN_0800885c": {
            "renaming": {
                "FUN_0800885c": "send_debug_message_0800885c",
                "file_UNUSED": "file_unused",
                "ptr": "message",
                "len": "length",
                "sVar1": "message_length",
                "uart_debugFUN_0800885c": "send_uart_debug_message"
            },
            "code": "int send_debug_message_0800885c(int file_unused, char *message, int length) {\n  size_t message_length;\n  message_length = send_uart_debug_message((uint8_t *)message, length);\n  return message_length;\n}",
            "called": [
                "uart_debug_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800885c",
            "calling": [
                "_write_r"
            ],
            "imported": false,
            "current_name": "send_debug_message_0800885c"
        },
        "FUN_0800643c": {
            "renaming": {
                "FUN_0800643c": "configureTimer_0800643c",
                "htim": "timerHandle",
                "Channel": "channel",
                "BDTR": "TIM_BDTR_MOE",
                "CR1": "TIM_CR1_CEN",
                "Instance": "timerHandle->Instance",
                "TIM_CCxNChannelCmd": "TIM_CCxNChannelCmd",
                "4": "TIM_OCMODE_PWM1",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef configureTimer_0800643c(TIM_HandleTypeDef *timerHandle, uint32_t channel)\n{\n  TIM_CCxNChannelCmd(timerHandle->Instance, channel, TIM_OCMODE_PWM1);\n  timerHandle->Instance->BDTR |= TIM_BDTR_MOE;\n  timerHandle->Instance->CR1 |= TIM_CR1_CEN;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800643c",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configureTimer_0800643c"
        },
        "FUN_08002fca": {
            "renaming": {
                "FUN_08002fca": "blinkPin_08002fca",
                "pin": "ledPin",
                "count": "blinkCount",
                "onInterval": "onTime",
                "offInterval": "offTime",
                "uVar1": "i"
            },
            "code": "void __thiscall firmata::FirmataClass::blinkPin_08002fca(FirmataClass *this, byte pin, int blinkCount, int onTime, int offTime){\n  for (int i = 0; i < blinkCount; i++) {\n    delay(offTime);\n    digitalWrite((uint)pin, HIGH);\n    delay(onTime);\n    digitalWrite((uint)pin, LOW);\n  }\n  return;\n}",
            "called": [
                "delay",
                "digitalWrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fca",
            "calling": [
                "blinkVersion"
            ],
            "imported": false,
            "current_name": "blinkPin_08002fca"
        },
        "FUN_0800a31c": {
            "renaming": {
                "std::ctype_byname<wchar_t>::FUN_0800a31c": "set_flags_of_pointers",
                "FUN_0800a31c": "set_flags_of_pointers_0800a31c"
            },
            "code": "void set_flags_of_pointers_0800a31c(void)\n{\n    if (*(int *)PTR_id_0800a380 < 0)\n    {\n        *(undefined4 *)PTR_id_0800a380 = 1;\n    }\n    if (*(int *)PTR_id_0800a384 < 0)\n    {\n        *(undefined4 *)PTR_id_0800a384 = 1;\n    }\n    if (*(int *)PTR_id_0800a388 < 0)\n    {\n        *(undefined4 *)PTR_id_0800a388 = 1;\n    }\n    if (*(int *)PTR_id_0800a38c < 0)\n    {\n        *(undefined4 *)PTR_id_0800a38c = 1;\n    }\n    if (*(int *)PTR_id_0800a390 < 0)\n    {\n        *(undefined4 *)PTR_id_0800a390 = 1;\n    }\n    if (*(int *)PTR_id_0800a394 < 0)\n    {\n        *(undefined4 *)PTR_id_0800a394 = 1;\n    }\n    if (*(int *)PTR_id_0800a398 < 0)\n    {\n        *(undefined4 *)PTR_id_0800a398 = 1;\n    }\n    if (*(int *)PTR_id_0800a39c < 0)\n    {\n        *(undefined4 *)PTR_id_0800a39c = 1;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a31c",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_of_pointers_0800a31c"
        },
        "FUN_080026f8": {
            "renaming": {
                "FUN_080026f8": "isServoEnabled_080026f8",
                "this": "servo",
                "PTR_servos_08002708": "servoPtr",
                "servoIndex": "servoIndex",
                "uint": "uint32_t",
                "SUB41": "maskedValue",
                "byte": "uint8_t"
            },
            "code": "bool isServoEnabled_080026f8(Servo *servo) {\n  uint32_t servoIndex = (uint32_t)servo->servoIndex;\n  uint32_t PTR_servos_08002708 = (uint32_t)&PTR_servos_08002708[servoIndex * 8];\n  uint32_t shiftedValue = ((uint32_t)*(uint8_t*)PTR_servos_08002708) << 0x19;\n  uint32_t maskedValue = shiftedValue >> 0x1f;\n  return maskedValue != 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026f8",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "isServoEnabled_080026f8"
        },
        "FUN_08007544": {
            "renaming": {
                "FUN_08007544": "get_timer_value_08007544",
                "*tim": "timer",
                "DAT_08007588": "unknown_timer",
                "DAT_0800758c": "known_timer",
                "PTR_s_TIM__Unknown_timer_IRQn_08007590": "unknown_timer_irq"
            },
            "code": "uint32_t get_timer_value_08007544(TIM_TypeDef_conflict *timer)\n{\n    if (timer == (TIM_TypeDef_conflict *)0xffffffff) {\n        return 0;\n    }\n    if (timer == DAT_08007588) {\n        return 0x1d;\n    }\n    if (DAT_08007588 < timer) {\n        if (timer == DAT_0800758c) {\n            return 0x1e;\n        }\n        if (timer == (TIM_TypeDef_conflict *)&DAT_0800758c[0x379].DMAR) {\n            return 0x19;\n        }\n    }\n    else if (timer == (TIM_TypeDef_conflict *)0x40000000) {\n        return 0x1c;\n    }\n    iprintf(PTR_s_TIM__UnDAT_0800758c_IRQn_08007590);\n    return 0;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007544",
            "calling": [
                "TimerPulseDeinit",
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "get_timer_value_08007544"
        },
        "FUN_08008990": {
            "renaming": {
                "FUN_08008990": "configure_pin_08008990",
                "ulPin": "pin_number",
                "ulMode": "mode",
                "_Var1": "is_configured",
                "pin": "pin_name",
                "PTR_digitalPin_08008a14": "digital_pin_array",
                "NC": "NC",
                "is_pin_configured": "is_pin_configured",
                "PTR_g_anOutputPinConfigured_08008a18": "output_pin_config_array",
                "pin_in_pinmap": "pin_in_pinmap",
                "PinMap_PWM_08008a1c": "PWM_pin_map_array",
                "pwm_stop": "pwm_stop",
                "reset_pin_configured": "reset_pin_configured",
                "digital_io_init": "digital_io_init",
                "set_pin_configured": "set_pin_configured",
                "PTR_g_digPinConfigured_08008a20": "digital_pin_config_array"
            },
            "code": "void configure_pin_08008990(uint32_t pin_number, uint32_t mode) {\n    PinName_conflict pin_name;\n    if (pin_number < 0x3c) {\n        pin_name = PTR_digitalPin_08008a14[pin_number];\n    }\n    else {\n        pin_name = NC;\n    }\n    if (pin_name != NC) {\n        bool is_configured = is_pin_configured(pin_name, (uint32_t *)PTR_g_anOutputPinConfigured_08008a18);\n        if (is_configured) {\n            bool is_pwm_pin = pin_in_pinmap(pin_name, (PinMap_conflict *)PWM_pin_map_array);\n            if (is_pwm_pin) {\n                pwm_stop(pin_name);\n            }\n            reset_pin_configured(pin_name, (uint32_t *)PTR_g_anOutputPinConfigured_08008a18);\n        }\n        switch (mode) {\n            case 0:\n                digital_io_init(pin_name, 0, 0);\n                break;\n            case 1:\n                digital_io_init(pin_name, 1, 0);\n                break;\n            case 2:\n                digital_io_init(pin_name, 0, 1);\n                break;\n            case 3:\n                digital_io_init(pin_name, 0, 2);\n        }\n        set_pin_configured(pin_name, (uint32_t *)PTR_g_digPinConfigured_08008a20);\n    }\n}",
            "called": [
                "pwm_stop",
                "pin_in_pinmap",
                "digital_io_init",
                "set_pin_configured",
                "reset_pin_configured",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008990",
            "calling": [
                "attach",
                "analogWrite",
                "digitalWriteCallback",
                "blinkVersion",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "configure_pin_08008990"
        },
        "FUN_08004396": {
            "renaming": {
                "FUN_08004396": "send_i2c_data_08004396",
                "hi2c": "i2c_handle",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "Devaddress": "device_address",
                "HAL_StatusTypeDef_conflict": "HAL_status"
            },
            "code": "HAL_StatusTypeDef_conflict send_i2c_data_08004396(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  uint8_t device_address = i2c_handle->Devaddress & 0xff;\n  i2c_handle->Instance->DR = device_address;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004396",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "send_i2c_data_08004396"
        },
        "FUN_08003fb0": {
            "renaming": {
                "FUN_08003fb0": "set_interrupt_enable_flag_08003fb0",
                "IRQn": "interrupt_number",
                "uVar1": "interrupt_bit_position",
                "DAT_08003fd4": "interrupt_enable_register",
                "DataSynchronizationBarrier": "DataSynchronizationBarrier",
                "InstructionSynchronizationBarrier": "InstructionSynchronizationBarrier"
            },
            "code": "void set_interrupt_enable_flag_08003fb0(IRQn_Type_conflict interrupt_number)\n{\n  uint32_t interrupt_bit_position = (uint32_t)interrupt_number;\n  if (interrupt_bit_position >= 0) {\n    uint32_t* DAT_08003fd4 = (uint32_t*)(DAT_08003fd4 + ((interrupt_bit_position >> 5) + 0x20) * 4);\n    uint32_t interrupt_enable_mask = 1 << (interrupt_bit_position & 0x1f);\n    *DAT_08003fd4 = interrupt_enable_mask;\n    DataSynchronizationBarrier(0xf);\n    InstructionSynchronizationBarrier(0xf);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fb0",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "set_interrupt_enable_flag_08003fb0"
        },
        "FUN_08007788": {
            "renaming": {
                "FUN_08007788": "handle_timer_interrupt_08007788",
                "PTR_timer_handles_08007798": "PTR_timer_handles",
                "TIM_HandleTypeDef_conflict": "TimerHandleTypeDef"
            },
            "code": "void handle_timer_interrupt_08007788(void)\n{\n    TIM_HandleTypeDef_conflict* timer_handle = *(TIM_HandleTypeDef_conflict**)(PTR_timer_handles_08007798_08007798 + 8);\n    if (timer_handle != NULL) {\n        HAL_TIM_IRQHandler(timer_handle);\n    }\n    return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007788",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007788"
        },
        "FUN_08008f0c": {
            "renaming": {
                "FUN_08008f0c": "do_nothing_08008f0c"
            },
            "code": "\nvoid do_nothing_08008f0c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f0c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "do_nothing_08008f0c"
        },
        "FUN_08002ec4": {
            "renaming": {
                "FUN_08002ec4": "print_08002ec4",
                "this": "firmata_instance",
                "iVar1": "print_result"
            },
            "code": "int __thiscall firmata::FirmataClass::print_08002ec4(FirmataClass *firmata_instance) {\n  int print_08002ec4_result = (*(firmata_instance->FirmataStream->super_Print)._vptr_Print[2])();\n  return print_08002ec4_result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ec4",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "print_08002ec4"
        },
        "FUN_08007306": {
            "renaming": {
                "FUN_08007306": "find_peripheral_by_pin_08007306",
                "pin": "target_pin",
                "map": "pin_map",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap",
                "NC": "NoConnection",
                "peripheral": "peripheral_device"
            },
            "code": "void * find_peripheral_by_pin_08007306(PinName_conflict pin, PinMap_conflict *pin_map) {\n  while( true ) {\n    if (pin_map->pin == NC) {\n      return (void *)0x0;\n    }\n    if (pin_map->pin == pin) break;\n    pin_map++;\n  }\n  return pin_map->peripheral;\n}",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007306",
            "calling": [
                "pinmap_peripheral",
                "pinmap_find_peripheral"
            ],
            "imported": false,
            "current_name": "find_peripheral_by_pin_08007306"
        },
        "FUN_08008f0e": {
            "renaming": {
                "FUN_08008f0e": "initialize_EVP_PKEY_CTX_08008f0e",
                "ctx": "context",
                "HAL_NVIC_SetPriorityGrouping(3)": "HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4)"
            },
            "code": "void initialize_EVP_PKEY_CTX_08008f0e(void)\n{\n  EVP_PKEY_CTX *context;\n  context = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\n  init(context);\n  return;\n}",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f0e",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_08008f0e"
        },
        "FUN_0800886c": {
            "renaming": {
                "FUN_0800886c": "set_errno_to_22_0800886c",
                "pid_UNUSED": "pid",
                "sig_UNUSED": "sig",
                "PTR_errno_08008878": "PTR_errno"
            },
            "code": "int set_errno_to_22_0800886c(int pid, int sig) {\n    *(undefined4 *)PTR_errno_08008878_08008878 = 0x16;\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800886c",
            "calling": [
                "_kill_r"
            ],
            "imported": false,
            "current_name": "set_errno_to_22_0800886c"
        },
        "FUN_080036d4": {
            "renaming": {
                "FUN_080036d4": "do_nothing_080036d4"
            },
            "code": "\nvoid do_nothing_080036d4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036d4",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_080036d4"
        },
        "FUN_08006e68": {
            "renaming": {
                "FUN_08006e68": "FUNC_08006e68"
            },
            "code": "\nvoid FUNC_08006e68(TIM_HandleTypeDef_conflict *htim)\n\n{\n  undefined *puVar1;\n  uint32_t uVar2;\n  GPIO_TypeDef *GPIOx;\n  uint32_t tmpreg;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  puVar1 = PTR_g_current_pin_08007100;\n  uVar2 = pinmap_function(*PTR_g_current_pin_08007100,(PinMap_conflict *)PTR_PinMap_PWM_08007104);\n  timer_enable_clock(htim);\n  GPIOx = set_GPIO_Port_Clock((uint)((int)(char)*puVar1 << 0x18) >> 0x1c);\n  GPIO_InitStruct.Mode = 2;\n  GPIO_InitStruct.Pull = 0;\n  GPIO_InitStruct.Speed = 3;\n  *(uint *)(DAT_08007108 + 0x18) = *(uint *)(DAT_08007108 + 0x18) | 1;\n  switch((uVar2 << 0x11) >> 0x19) {\n  case 1:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000001;\n    break;\n  case 2:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffe | 0x7000000;\n    break;\n  case 3:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000002;\n    break;\n  case 4:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffd | 0x7000000;\n    break;\n  case 5:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000004;\n    break;\n  case 6:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffb | 0x7000000;\n    break;\n  case 7:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000008;\n    break;\n  case 8:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffff7 | 0x7000000;\n    break;\n  case 9:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000030;\n    break;\n  case 10:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffffcf | 0x7000010;\n    break;\n  case 0xb:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffffcf | 0x7000000;\n    break;\n  case 0xc:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x70000c0;\n    break;\n  case 0xd:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffff3f | 0x7000040;\n    break;\n  case 0xe:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffff3f | 0x7000000;\n    break;\n  case 0xf:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000300;\n    break;\n  case 0x10:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000200;\n    break;\n  case 0x11:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000100;\n    break;\n  case 0x12:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000000;\n    break;\n  case 0x13:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000c00;\n    break;\n  case 0x14:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffff3ff | 0x7000800;\n    break;\n  case 0x15:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffff3ff | 0x7000000;\n    break;\n  case 0x16:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7001000;\n    break;\n  case 0x17:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffefff | 0x7000000;\n    break;\n  case 0x1b:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7008000;\n    break;\n  case 0x1c:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffff7fff | 0x7000000;\n    break;\n  case 0x21:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff;\n    break;\n  case 0x22:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x1000000;\n    break;\n  case 0x23:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x2000000;\n    break;\n  case 0x24:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x4000000;\n  }\n  GPIO_InitStruct.Pin = 1 << (*PTR_g_current_pin_08007100 & 0xf) & 0xffff;\n  HAL_GPIO_Init(GPIOx,&GPIO_InitStruct);\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init",
                "pinmap_function",
                "timer_enable_clock",
                "set_GPIO_Port_Clock"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08006e68",
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "imported": false,
            "current_name": "FUNC_08006e68"
        },
        "FUN_080036d8": {
            "renaming": {
                "FUN_080036d8": "configureSysTick_080036d8",
                "TickPriority": "tickPriority",
                "uVar1": "systickConfigResult",
                "PTR_SystemCoreClock_0800371c": "clockSpeed",
                "PTR_uwTickFreq_08003718": "tickFreq"
            },
            "code": "HAL_StatusTypeDef configureSysTick_080036d8(uint32_t tickPriority){\n  uint32_t PTR_SystemCoreClock_0800371c = *(uint *)PTR_SystemCoreClock_0800371c;\n  uint32_t PTR_uwTickFreq_08003718 = (1000 / (ulonglong)(byte)*PTR_uwTickFreq_08003718);\n  uint32_t systickConfigResult = HAL_SYSTICK_Config(PTR_SystemCoreClock_0800371c / PTR_uwTickFreq_08003718);\n  if (systickConfigResult != 0) {\n    return HAL_ERROR;\n  }\n  if (tickPriority > 0xf) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,tickPriority,0);\n  *(uint32_t *)PTR_uwTickPrio_08003720 = tickPriority;\n  return HAL_OK;\n}",
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036d8",
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "configureSysTick_080036d8"
        },
        "FUN_0800a110": {
            "renaming": {
                "FUN_0800a110": "check_terminal_0800a110",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "puVar1": "error_flag_ptr",
                "iVar2": "is_terminal"
            },
            "code": "void check_terminal_0800a110(int *error_code, int file_descriptor) {\n  undefined *error_flag_ptr;\n  int is_terminal;\n  error_flag_ptr = PTR_errno_0800a12c;\n  *(undefined4 *)PTR_errno_0800a12c = 0;\n  is_terminal = _isatty(file_descriptor);\n  if ((is_terminal == -1) && (*(int *)error_flag_ptr != 0)) {\n    *error_code = *(int *)error_flag_ptr;\n  }\n  return;\n}",
            "called": [
                "_isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a110",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_terminal_0800a110"
        },
        "FUN_08003b8c": {
            "renaming": {
                "FUN_08003b8c": "check_ADC_status_08003b8c",
                "*hadc": "*adc_handle",
                "uVar1": "start_time",
                "uVar2": "current_time",
                "*pAVar3": "*adc_instance"
            },
            "code": "HAL_StatusTypeDef check_ADC_status_08003b8c(ADC_HandleTypeDef *adc_handle)\n{\n  uint32_t start_time = HAL_GetTick();\n  ADC_TypeDef *adc_instance = adc_handle->Instance;\n  if ((adc_instance->CR2 & 1) == 0) {\n    return HAL_OK;\n  }\n  adc_instance->CR2 = adc_instance->CR2 & 0xfffffffe;\n  while ((adc_handle->Instance->CR2 & 1) != 0 && HAL_GetTick() - start_time < 3);\n  if ((adc_handle->Instance->CR2 & 1) != 0) {\n    adc_handle->State |= 0x10;\n    adc_handle->ErrorCode |= 1;\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003b8c",
            "calling": [
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_DeInit",
                "HAL_ADC_Stop"
            ],
            "imported": false,
            "current_name": "check_ADC_status_08003b8c"
        },
        "FUN_080035b8": {
            "renaming": {
                "FUN_080035b8": "initialize_clock_080035b8",
                "HVar1": "hal_status",
                "uVar2": "hclk_freq",
                "PeriphClkInit": "periph_clk_init",
                "RCC_ClkInitStruct": "rcc_clk_init_struct",
                "RCC_OscInitStruct": "rcc_osc_init_struct",
                "OscillatorType": "RCC_OSCILLATORTYPE_HSI",
                "HSIState": "RCC_HSI_ON",
                "HSICalibrationValue": "0x10",
                "PLLState": "RCC_PLL_ON",
                "PLLSource": "RCC_PLLSOURCE_HSI",
                "PLLMUL": "RCC_PLL_MUL16",
                "ClockType": "RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2",
                "SYSCLKSource": "RCC_SYSCLKSOURCE_PLLCLK",
                "AHBCLKDivider": "RCC_SYSCLK_DIV1",
                "APB1CLKDivider": "RCC_HCLK_DIV2",
                "APB2CLKDivider": "RCC_HCLK_DIV1",
                "PeriphClockSelection": "RCC_PERIPHCLK_ADC",
                "AdcClockSelection": "RCC_ADCPCLK2_DIV8"
            },
            "code": "void initialize_clock_080035b8(void)\n{\n  HAL_StatusTypeDef_conflict hal_status;\n  uint32_t hclk_freq;\n  RCC_PeriphCLKInitTypeDef periph_clk_init;\n  RCC_ClkInitTypeDef rcc_clk_init_struct;\n  RCC_OscInitTypeDef rcc_osc_init_struct;\n  \n  rcc_osc_init_struct.OscillatorType = RCC_OSCILLATORTYPE_HSI;\n  rcc_osc_init_struct.HSIState = RCC_HSI_ON;\n  rcc_osc_init_struct.HSICalibrationValue = 0x10;\n  rcc_osc_init_struct.PLL.PLLState = RCC_PLL_ON;\n  rcc_osc_init_struct.PLL.PLLSource = RCC_PLLSOURCE_HSI;\n  rcc_osc_init_struct.PLL.PLLMUL = RCC_PLL_MUL16;\n  hal_status = HAL_RCC_OscConfig(&rcc_osc_init_struct);\n  if (hal_status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x88);\n  }\n  \n  rcc_clk_init_struct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  rcc_clk_init_struct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  rcc_clk_init_struct.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  rcc_clk_init_struct.APB1CLKDivider = RCC_HCLK_DIV2;\n  rcc_clk_init_struct.APB2CLKDivider = RCC_HCLK_DIV1;\n  hal_status = HAL_RCC_ClockConfig(&rcc_clk_init_struct, FLASH_LATENCY_2);\n  if (hal_status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x95);\n  }\n  \n  periph_clk_init.PeriphClockSelection = RCC_PERIPHCLK_ADC;\n  periph_clk_init.AdcClockSelection = RCC_ADCPCLK2_DIV8;\n  hal_status = HAL_RCCEx_PeriphCLKConfig(&periph_clk_init);\n  if (hal_status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x9c);\n  }\n  \n  hclk_freq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(SYSTICK_RELOAD_VALUE * hclk_freq);\n  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);\n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n}\n",
            "called": [
                "_Error_Handler",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_OscConfig",
                "HAL_SYSTICK_Config",
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035b8",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "initialize_clock_080035b8"
        },
        "FUN_08006460": {
            "renaming": {
                "FUN_08006460": "checkCCERandBDTR_08006460",
                "htim": "timerHandle",
                "Channel": "channel",
                "pTVar1": "timerInstance"
            },
            "code": "HAL_StatusTypeDef_conflict checkCCERandBDTR_08006460(TIM_HandleTypeDef_conflict *timerHandle,uint32_t channel)\n{\n  TIM_TypeDef_conflict *timerInstance;\n  TIM_CCxNChannelCmd(timerHandle->Instance,channel,0);\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006460",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "checkCCERandBDTR_08006460"
        },
        "FUN_08004046": {
            "renaming": {
                "FUN_08004046": "call_HAL_SYSTICK_Callback_08004046"
            },
            "code": "void call_HAL_SYSTICK_Callback_08004046(void)\n{\n  HAL_SYSTICK_Callback();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004046",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "call_HAL_SYSTICK_Callback_08004046"
        },
        "FUN_08008880": {
            "renaming": {
                "FUN_08008880": "read_analog_pin_08008880",
                "ulPin": "pin_number",
                "bVar1": "is_valid_pin",
                "pin": "pin",
                "uVar2": "adc_value",
                "uVar3": "result",
                "uVar4": "resolution",
                "PTR_digitalPin_080088d8": "digitalPin",
                "NC": "NC",
                "PTR__readResolution_080088dc": "readResolution_ptr"
            },
            "code": "uint32_t read_analog_pin_08008880(uint32_t pin_number)\n{\n  bool is_valid_pin;\n  PinName_conflict pin;\n  uint16_t adc_value;\n  uint32_t result;\n  uint resolution;\n  if (pin_number < 14) {\n    is_valid_pin = pin_number + 46 < 60;\n  }\n  else {\n    is_valid_pin = pin_number < 60;\n  }\n  if (is_valid_pin) {\n    if (pin_number < 14) {\n      pin_number += 46;\n    }\n    pin = PTR_digitalPin_080088d8[pin_number];\n  }\n  else {\n    pin = NC;\n  }\n  if (pin == NC) {\n    result = 0;\n  }\n  else {\n    adc_value = adc_read_value(pin);\n    result = (uint32_t)adc_value;\n    resolution = *(uint *)PTR__readResolution_080088dc;\n    if (resolution != 12) {\n      if (resolution < 12) {\n        return (uint)(adc_value >> (12 - resolution & 0xff));\n      }\n      return result << (resolution - 12 & 0xff);\n    }\n  }\n  return result;\n}\n",
            "called": [
                "adc_read_value"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008880",
            "calling": [
                "reportAnalogCallback",
                "loop"
            ],
            "imported": false,
            "current_name": "read_analog_pin_08008880"
        },
        "FUN_08004044": {
            "renaming": {
                "FUN_08004044": "do_nothing_08004044"
            },
            "code": "\nvoid do_nothing_08004044(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004044",
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08004044"
        },
        "FUN_08002ed2": {
            "renaming": {
                "FUN_08002ed2": "parseIncomingByte_08002ed2",
                "this": "firmataInstance",
                "iVar1": "incomingByte",
                "FirmataStream": "firmataStream",
                "_vptr_Print": "virtualFunctionTable",
                "FirmataParser": "firmataParser",
                "parse": "parseIncomingByte"
            },
            "code": "void __thiscall firmata::FirmataClass::parseIncomingByte_08002ed2(FirmataClass *firmataInstance)\n{\n  int incomingByte = (*(firmataInstance->FirmataStream->super_Print)._vptr_Print[3])();\n  if (incomingByte != -1) {\n    FirmataParser::parse(&firmataInstance->parser, (uint8_t)incomingByte);\n  }\n  return;\n}",
            "called": [
                "parse"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ed2",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "parseIncomingByte_08002ed2"
        },
        "FUN_08008f1c": {
            "renaming": {
                "FUN_08008f1c": "main_loop_08008f1c",
                "DAT_08008f38": "data"
            },
            "code": "int main_loop_08008f1c(void)\n{\n  initVariant();\n  setup();\n  do {\n    do {\n      loop();\n    } while (DAT_08008f38 == 0);\n    serialEventRun();\n  } while( true );\n}",
            "called": [
                "loop",
                "initVariant",
                "serialEventRun",
                "setup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f1c",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "main_loop_08008f1c"
        },
        "FUN_080058ac": {
            "renaming": {
                "FUN_080058ac": "set_clock_config_080058ac",
                "RCC_ClkInitStruct_conflict": "RCC_ClkInitTypeDef",
                "FLatency": "flash_latency",
                "puVar1": "rcc_cfgr",
                "uVar2": "tickstart",
                "uVar3": "tickcount",
                "uVar4": "sysclk_source",
                "DAT_08005a0c": "rcc_cfgr",
                "DAT_08005a10": "rcc_cfgr2",
                "PTR_SystemCoreClock_08005a18": "SystemCoreClock",
                "PTR_AHBPrescTable_08005a14": "AHBPrescTable",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_OK": "HAL_OK",
                "HAL_TIMEOUT": "HAL_TIMEOUT",
                "HSE_VALUE": "HSE_VALUE",
                "HSI_VALUE": "HSI_VALUE",
                "HSI14_VALUE": "HSI14_VALUE",
                "AHBPrescTable": "AHBPrescTable",
                "APBPrescTable": "APBPrescTable"
            },
            "code": "HAL_StatusTypeDef set_clock_config_080058ac(RCC_ClkInitTypeDef *clk_init, uint32_t flash_latency)\n{\n  uint32_t *DAT_08005a0c = (uint32_t *)0x40021000;\n  uint32_t *DAT_08005a10 = (uint32_t *)0x40021004;\n  uint32_t *DAT_08005a0c3 = (uint32_t *)0x40021008;\n  uint32_t *rcc_cr = (uint32_t *)0x40021000;\n  uint32_t tickstart;\n  uint32_t hclk_frequency;\n  uint32_t sysclk_source;\n  uint32_t sysclk_frequency;\n  uint32_t hpre_divider;\n  uint32_t ppre1_divider;\n  uint32_t ppre2_divider;\n  uint32_t flitf_latency;\n  uint32_t sw;\n\n  if ((DAT_08005a0c[0] & 0x3) != 0)\n  {\n    rcc_cr[0] |= 0x10000;\n    while ((rcc_cr[0] & 0x20000) == 0)\n    {\n    }\n  }\n\n  hclk_frequency = HAL_RCC_GetHCLKFreq();\n  sysclk_source = (DAT_08005a0c[0] & 0xc) >> 2;\n  if (sysclk_source == 0)\n  {\n    sysclk_frequency = HAL_RCC_GetSysClockFreq();\n  }\n  else if (sysclk_source == 1)\n  {\n    sysclk_frequency = HSE_VALUE;\n  }\n  else if (sysclk_source == 2)\n  {\n    sysclk_frequency = HSI_VALUE;\n  }\n  else\n  {\n    sysclk_frequency = HSI14_VALUE;\n  }\n\n  hpre_divider = (DAT_08005a0c[0] & 0xf0) >> 4;\n  if (hpre_divider != 0)\n  {\n    hclk_frequency >>= PTR_AHBPrescTable_08005a14[hpre_divider];\n  }\n\n  flitf_latency = flash_latency;\n  if ((DAT_08005a0c3[0] & 0x1) != 0)\n  {\n    flitf_latency |= 0x1;\n  }\n\n  if (flitf_latency != (DAT_08005a0c[0] & 0x7))\n  {\n    DAT_08005a0c[0] &= 0xfffffff8;\n    DAT_08005a0c[0] |= flitf_latency;\n    if (flitf_latency != (DAT_08005a0c[0] & 0x7))\n    {\n      return HAL_ERROR;\n    }\n  }\n\n  ppre1_divider = (DAT_08005a0c[0] & 0x100) >> 8;\n  if (ppre1_divider != 0)\n  {\n    hclk_frequency >>= APBPrescTable[ppre1_divider];\n  }\n\n  ppre2_divider = (DAT_08005a0c[0] & 0x800) >> 11;\n  if (ppre2_divider != 0)\n  {\n    hclk_frequency >>= APBPrescTable[ppre2_divider];\n  }\n\n  if (clk_init->SYSCLKSource != 0)\n  {\n    DAT_08005a0c[0] &= 0xfffffffc;\n    DAT_08005a0c[0] |= clk_init->SYSCLKSource;\n    sysclk_source = (DAT_08005a0c[0] & 0xc) >> 2;\n    if (sysclk_source == 0)\n    {\n      sysclk_frequency = HAL_RCC_GetSysClockFreq();\n    }\n    else if (sysclk_source == 1)\n    {\n      sysclk_frequency = HSE_VALUE;\n    }\n    else if (sysclk_source == 2)\n    {\n      sysclk_frequency = HSI_VALUE;\n    }\n    else\n    {\n      sysclk_frequency = HSI14_VALUE;\n    }\n  }\n\n  if (clk_init->AHBCLKDivider != 0)\n  {\n    DAT_08005a0c[0] &= 0xff0fffff;\n    DAT_08005a0c[0] |= clk_init->AHBCLKDivider << 4;\n  }\n\n  if (clk_init->APB1CLKDivider != 0)\n  {\n    DAT_08005a0c[0] &= 0xffff8fff;\n    DAT_08005a0c[0] |= clk_init->APB1CLKDivider << 10;\n  }\n\n  if (clk_init->APB2CLKDivider != 0)\n  {\n    DAT_08005a0c[0] &= 0xffc7ffff;\n    DAT_08005a0c[0] |= clk_init->APB2CLKDivider << 13;\n  }\n\n  sw = clk_init->SYSCLKSource;\n  if (sw != (DAT_08005a0c[0] & 0x3))\n  {\n    DAT_08005a0c[0] &= 0xfffffffc;\n    DAT_08005a0c[0] |= sw;\n    if (sw != (DAT_08005a0c[0] & 0x3))\n    {\n      return HAL_ERROR;\n    }\n  }\n\n  tickstart = HAL_GetTick();\n  if (sw == 0)\n  {\n    while ((DAT_08005a0c[0] & 0xc) != 0)\n    {\n      if ((HAL_GetTick() - tickstart) > 5000)\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  else if (sw == 1)\n  {\n    while ((DAT_08005a0c[0] & 0xc) != 4)\n    {\n      if ((HAL_GetTick() - tickstart) > 5000)\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  else if (sw == 2)\n  {\n    while ((DAT_08005a0c[0] & 0xc) != 8)\n    {\n      if ((HAL_GetTick() - tickstart) > 5000)\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  else\n  {\n    while ((DAT_08005a0c[0] & 0xc) != 12)\n    {\n      if ((HAL_GetTick() - tickstart) > 5000)\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n\n  return HAL_OK;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_InitTick",
                "HAL_RCC_GetSysClockFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058ac",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_clock_config_080058ac"
        },
        "FUN_08007438": {
            "renaming": {
                "FUN_08007438": "configure_timer_08007438",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "htim": "timer",
                "DAT_080074d0": "timer1",
                "_DAT_4002101c": "RCC->APB1ENR",
                "PTR_timer_handles_080074dc": "timer_handles",
                "DAT_080074d4": "timer3",
                "DAT_080074d8": "timer4"
            },
            "code": "void configure_timer_08007438(TIM_HandleTypeDef_conflict *timer)\n{\n  uint32_t dier_reg;\n  uint32_t smcr_reg;\n  uint32_t ccmr1_reg;\n\n  if (timer->Instance == DAT_080074d0) {\n    dier_reg = DAT_080074d0->DIER | 0x800;\n    PTR_timer_handles_080074dc[0] = timer;\n  }\n  if (timer->Instance == timer2) {\n    _DAT_4002101c |= RCC_APB1ENR_TIM2EN;\n    PTR_timer_handles_080074dc[1] = timer;\n  }\n  if (timer->Instance == DAT_080074d4) {\n    ccmr1_reg = DAT_080074d4->CCMR1 | 2;\n    PTR_timer_handles_080074dc[2] = timer;\n  }\n  if (timer->Instance == DAT_080074d8) {\n    smcr_reg = DAT_080074d8->SMCR | 4;\n    PTR_timer_handles_080074dc[3] = timer;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007438",
            "calling": [
                "HAL_TIM_PWM_MspInit",
                "HAL_TIM_OC_MspInit"
            ],
            "imported": false,
            "current_name": "configure_timer_08007438"
        },
        "FUN_0800306c": {
            "renaming": {
                "FUN_0800306c": "initialize_static_vars_0800306c"
            },
            "code": "void initialize_static_vars_0800306c(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800306c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_vars_0800306c"
        },
        "FUN_0800887c": {
            "renaming": {
                "FUN_0800887c": "get_process_id_0800887c"
            },
            "code": "__pid_t get_process_id_0800887c(void)\n{\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800887c",
            "calling": [
                "_getpid_r"
            ],
            "imported": false,
            "current_name": "get_process_id_0800887c"
        },
        "FUN_0800863c": {
            "renaming": {
                "FUN_0800863c": "receive_data_0800863c",
                "obj": "serial_obj",
                "callback": "rx_callback",
                "bVar1": "index",
                "uVar2": "is_rx_active"
            },
            "code": "void receive_data_0800863c(serial_t *serial_obj, _func_void_serial_t_ptr *rx_callback) {\n  if (serial_obj != NULL) {\n    uint8_t is_rx_active = serial_rx_active(serial_obj);\n    if (is_rx_active == 0) {\n      byte index = serial_obj->index;\n      *(_func_void_serial_t_ptr **)(PTR_rx_callback_08008688 + (uint)index * 4) = rx_callback;\n      *(serial_t **)(PTR_rx_callback_obj_0800868c + (uint)index * 4) = serial_obj;\n      HAL_NVIC_SetPriority(serial_obj->irq, 0, 1);\n      HAL_NVIC_EnableIRQ(serial_obj->irq);\n      HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08008690 + (uint)serial_obj->index * 4),&serial_obj->recv,1);\n    }\n  }\n}",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "HAL_NVIC_EnableIRQ",
                "serial_rx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800863c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "receive_data_0800863c"
        },
        "FUN_08004050": {
            "renaming": {
                "FUN_08004050": "update_DMA_settings_08004050",
                "hdma": "dma_handle",
                "uVar1": "channel_bitmask",
                "pDVar2": "dma_channel",
                "DAT_080040e0": "PTR_080040e0",
                "hdma->State": "dma_handle->State",
                "HAL_DMA_STATE_BUSY": "HAL_DMA_STATE_BUSY",
                "hdma->ErrorCode": "dma_handle->ErrorCode",
                "HAL_ERROR": "HAL_ERROR",
                "hdma->Instance->CCR": "dma_handle->Instance->CCR",
                "DMA_Channel_TypeDef_conflict": "DMA_Channel_TypeDef_conflict",
                "PTR_080040e0": "PTR_080040e0",
                "channel_id": "channel_id",
                "PTR_080040e0[1].CNDTR": "(DMA_Channel_TypeDef_conflict *)&PTR_080040e0[1].CNDTR",
                "PTR_080040e0[2].CPAR": "(DMA_Channel_TypeDef_conflict *)&PTR_080040e0[2].CPAR",
                "PTR_080040e0[3].CMAR": "(DMA_Channel_TypeDef_conflict *)&PTR_080040e0[3].CMAR",
                "PTR_080040e0 + 5": "PTR_080040e0 + 5",
                "(DMA_Channel_TypeDef_conflict *)&PTR_080040e0[6].CNDTR": "(DMA_Channel_TypeDef_conflict *)&PTR_080040e0[6].CNDTR",
                "PTR_080040e4": "PTR_080040e4",
                "dma_handle->Lock": "dma_handle->Lock",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "dma_handle->XferAbortCallback": "dma_handle->XferAbortCallback",
                "_func_void___DMA_HandleTypeDef_ptr_conflict": "_func_void___DMA_HandleTypeDef_ptr_conflict",
                "0x0": "0x0",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef_conflict update_DMA_settings_08004050(DMA_HandleTypeDef_conflict *dma_handle)\n{\n  \n  if (dma_handle->State != HAL_DMA_STATE_BUSY) {\n    dma_handle->ErrorCode = 4;\n    return HAL_ERROR;\n  }\n  dma_handle->Instance->CCR &= ~(1 << 0);\n  dma_handle->Instance->CCR &= ~(1 << 1);\n  DMA_Channel_TypeDef_conflict *dma_channel = dma_handle->Instance;\n  int channel_id = -1;\n  if (dma_channel == DAT_080040e0) {\n    channel_id = 0;\n  }\n  else if (dma_channel == DAT_080040e0[1].CNDTR) {\n    channel_id = 1;\n  }\n  else if (dma_channel == DAT_080040e0[2].CPAR) {\n    channel_id = 2;\n  }\n  else if (dma_channel == DAT_080040e0[3].CMAR) {\n    channel_id = 3;\n  }\n  else if (dma_channel == DAT_080040e0 + 5) {\n    channel_id = 4;\n  }\n  else if (dma_channel == (DMA_Channel_TypeDef_conflict *)&DAT_080040e0[6].CNDTR) {\n    channel_id = 5;\n  }\n  else {\n    channel_id = 6;\n  }\n  PTR_080040e4[1] = 1 << (channel_id * 4);\n  dma_handle->State = HAL_DMA_STATE_READY;\n  dma_handle->Lock = HAL_UNLOCKED;\n  if (dma_handle->XferAbortCallback != (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0) {\n    (*dma_handle->XferAbortCallback)(dma_handle);\n    return HAL_OK;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004050",
            "calling": [
                "HAL_UART_IRQHandler",
                "I2C_ITError"
            ],
            "imported": false,
            "current_name": "update_DMA_settings_08004050"
        },
        "FUN_08008e14": {
            "renaming": {
                "FUN_08008e14": "initializeIPAddress_08008e14",
                "__initialize_p": "shouldInitialize",
                "__priority": "priorityLevel"
            },
            "code": "void initializeIPAddress_08008e14(int shouldInitialize, int priorityLevel) {\n  if (shouldInitialize == 1 && priorityLevel == 0xffff) {\n    IPAddress::IPAddress((IPAddress *)PTR_INADDR_NONE_08008e3c, '\\0', '\\0', '\\0', '\\0');\n    return;\n  }\n  return;\n}",
            "called": [
                "IPAddress"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e14",
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "imported": false,
            "current_name": "initializeIPAddress_08008e14"
        },
        "FUN_08005a28": {
            "renaming": {
                "FUN_08005a28": "get_HCLK_frequency_divider_08005a28",
                "DAT_08005a40": "data_08005a40",
                "PTR_APBPrescTable_08005a44": "apb_prescaler_table_08005a44"
            },
            "code": "uint32_t get_HCLK_frequency_divider_08005a28(void)\n{\n  uint32_t HCLK_freq = HAL_RCC_GetHCLKFreq();\n  uint32_t apb_presc_index = (uint)(*(int *)(DAT_08005a40 + 4) << 0x15) >> 0x1d;\n  uint32_t HCLK_divider = PTR_APBPrescTable_08005a44[apb_presc_index];\n  return HCLK_freq >> HCLK_divider;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a28",
            "calling": [
                "getTimerClkFreq",
                "HAL_I2C_Init",
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "get_HCLK_frequency_divider_08005a28"
        },
        "FUN_08008ac6": {
            "renaming": {
                "FUN_08008ac6": "calculateNextTailPosition_08008ac6",
                "*obj": "*serialObject",
                "uVar1": "nextTailPositionAsUshort",
                "uVar2": "maskedNextTailPosition",
                "iVar3": "nextTailPosition"
            },
            "code": "int calculateNextTailPosition_08008ac6(serial_t_conflict *serialObject) {\n\tint nextTailPosition = serialObject->tx_tail + 1;\n\tushort nextTailPositionAsUshort = (ushort)nextTailPosition;\n\tuint16_t maskedNextTailPosition = nextTailPositionAsUshort & 0x7f;\n\tif (nextTailPosition == 0) {\n\t\tmaskedNextTailPosition = -(-nextTailPositionAsUshort & 0x7f);\n\t}\n\tserialObject->tx_tail = maskedNextTailPosition;\n\tif (serialObject->tx_head != serialObject->tx_tail) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ac6",
            "calling": [],
            "imported": false,
            "current_name": "calculateNextTailPosition_08008ac6"
        },
        "FUN_08003002": {
            "renaming": {
                "FUN_08003002": "initializeBoard_08003002",
                "this->FUN_08003002Disabled": "this->isDisabled",
                "0xd": "13",
                "'\\r'": "'\\r'",
                "2": "2",
                "0x28": "40",
                "0xd2": "210",
                "0xfa": "250",
                "5": "5",
                "0x7d": "125"
            },
            "code": "void __thiscall firmata::FirmataClass::initializeBoard_08003002(FirmataClass *this)\n{\n  if (this->isDisabled != false) {\n    return;\n  }\n  pinMode(13, OUTPUT);\n  strobeBlinkPin(this, '\\r', 2, 40, 210);\n  delay(250);\n  strobeBlinkPin(this, '\\r', 5, 40, 210);\n  delay(125);\n  return;\n}",
            "called": [
                "delay",
                "strobeBlinkPin",
                "pinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003002",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initializeBoard_08003002"
        },
        "FUN_08008ac4": {
            "renaming": {
                "FUN_08008ac4": "do_nothing_08008ac4"
            },
            "code": "\nvoid do_nothing_08008ac4(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ac4",
            "calling": [
                "strobeBlinkPin",
                "blinkVersion"
            ],
            "imported": false,
            "current_name": "do_nothing_08008ac4"
        },
        "FUN_08003366": {
            "renaming": {
                "FUN_08003366": "setStringCallback_08003366",
                "command": "commandByte",
                "newFunction": "callbackFunction",
                "context": "callbackContext",
                "currentStringCallback": "stringCallback",
                "currentStringCallbackContext": "stringCallbackContext"
            },
            "code": "void __thiscall firmata::FirmataParser::setStringCallback_08003366(FirmataParser *this, uint8_t command, stringCallbackFunction newFunction, void *context)\n{\n    if (command == 'q') {\n        this->currentStringCallback = newFunction;\n        this->currentStringCallbackContext = context;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003366",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "setStringCallback_08003366"
        },
        "FUN_080091b0": {
            "renaming": {
                "FUN_080091b0": "copy_memory_080091b0",
                "__dest": "dest",
                "__src": "src",
                "__n": "n",
                "puVar1": "destination",
                "puVar2": "source"
            },
            "code": "void * copy_memory_080091b0(void *dest, const void *src, size_t n) {\n  unsigned char *destination = (unsigned char *)dest;\n  const unsigned char *source = (const unsigned char *)src;\n  for (size_t i = 0; i < n; i++) {\n    destination[i] = source[i];\n  }\n  return dest;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091b0",
            "calling": [
                "write",
                "_realloc_r",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "copy_memory_080091b0"
        },
        "FUN_08009908": {
            "renaming": {
                "FUN_08009908": "allocate_memory_08009908",
                "__ptr": "impure_ptr",
                "__size": "size",
                "pvVar1": "allocated_memory"
            },
            "code": "void * allocate_memory_08009908(void *impure_ptr, size_t size) {\n  void *allocated_memory;\n  allocated_memory = (void *)_allocate_memory_08009908_r(*(undefined4 *)PTR__impure_ptr_08009914, impure_ptr, size);\n  return allocated_memory;\n}",
            "called": [
                "_realloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009908",
            "calling": [
                "write",
                "write",
                "allocateRxBuffer"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009908"
        },
        "FUN_08008abc": {
            "renaming": {
                "FUN_08008abc": "get_current_milliseconds_08008abc",
                "uVar1": "current_milliseconds"
            },
            "code": "uint32_t get_current_milliseconds_08008abc(void)\n{\n  uint32_t current_milliseconds;\n  current_milliseconds = GetCurrentMilli();\n  return current_milliseconds;\n}",
            "called": [
                "GetCurrentMilli"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008abc",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "get_current_milliseconds_08008abc"
        },
        "FUN_08002b68": {
            "renaming": {
                "TwoWire::FUN_08002b68": "readFromAddress",
                "this": "wire",
                "address": "address",
                "quantity": "quantity",
                "iaddress": "internalAddress",
                "isize": "internalAddressSize",
                "sendStop": "sendStop",
                "iVar1": "i2cStatus",
                "uVar2": "bufferSize",
                "PTR_rxBuffer_08002bf4": "rxBuffer",
                "PTR_rxBufferIndex_08002bf8": "rxBufferIndex",
                "PTR_rxBufferLength_08002bfc": "rxBufferLength",
                "i2c_t_conflict": "i2cStatusType",
                "i2c_master_read": "readI2C",
                "FUN_08002b68": "readFromAddress_08002b68"
            },
            "code": "uint8_t __thiscall readFromAddress_08002b68(TwoWire *wire, uint8_t address, uint8_t quantity, uint32_t internalAddress, uint8_t internalAddressSize, uint8_t sendStop) {\n  i2c_status_e_conflict i2cStatus;\n  uint8_t bufferSize;\n  \n  if (!wire->master) {\n    return 0;\n  }\n  \n  allocateRxBuffer(quantity);\n  \n  if (*PTR_rxBuffer_08002bf4 != 0 && internalAddressSize > 0) {\n    beginTransmission(wire, address);\n    internalAddressSize = min(internalAddressSize, 3);\n    while(internalAddressSize > 0) {\n      uint8_t shiftAmount = (internalAddressSize - 1) & 0x1f;\n      uint8_t shiftedAddress = (internalAddress >> (shiftAmount << 3)) & 0xff;\n      (**wire->super_Stream->super_Print._vptr_Print)(wire, shiftedAddress);\n      internalAddressSize--;\n    }\n    endTransmission(wire, sendStop);\n  }\n  \n  i2cStatus = i2c_master_read((i2c_t_conflict *)&wire->_i2c, address << 1, (uint8_t *)PTR_rxBuffer_08002bf4, (ushort)quantity);\n  if (i2cStatus != I2C_OK) {\n    bufferSize = 0;\n  }\n  \n  *PTR_PTR_rxBuffer_08002bf4Index_08002bf8 = 0;\n  *PTR_PTR_rxBuffer_08002bf4Length_08002bfc = bufferSize;\n  return bufferSize;\n}",
            "called": [
                "beginTransmission",
                "endTransmission",
                "i2c_master_read",
                "allocateRxBuffer"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002b68",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "readFromAddress_08002b68"
        },
        "FUN_080005e0": {
            "renaming": {
                "FUN_080005e0": "disableI2C_080005e0",
                "PTR_isI2CEnabled_080005f0": "is_I2C_Enabled",
                "PTR_queryIndex_080005f4": "query_Index"
            },
            "code": "void disableI2C_080005e0(void)\n{\n    *PTR_isI2CEnabled_080005f0 = 0;\n    *PTR_queryIndex_080005f4 = 0xFF;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080005e0",
            "calling": [
                "systemResetCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "disableI2C_080005e0"
        },
        "FUN_0800674c": {
            "renaming": {
                "FUN_0800674c": "do_nothing_0800674c"
            },
            "code": "\nvoid do_nothing_0800674c(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800674c",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_0800674c"
        },
        "FUN_0800674e": {
            "renaming": {
                "FUN_0800674e": "configure_UART_0800674e",
                "huart": "UART_handle",
                "HAL_UART_STATE_RESET": "HAL_UART_STATE_RESET",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_UART_MspInit": "HAL_UART_MspInit",
                "HAL_UART_STATE_BUSY": "HAL_UART_STATE_BUSY",
                "UART_SetConfig": "UART_SetConfig",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_OK": "HAL_OK",
                "HAL_ERROR": "HAL_ERROR",
                "CR1": "CR1",
                "CR2": "CR2",
                "CR3": "CR3",
                "ErrorCode": "ErrorCode",
                "Instance": "Instance",
                "gState": "gState",
                "RxState": "RxState"
            },
            "code": "HAL_StatusTypeDef configure_UART_0800674e(UART_HandleTypeDef *UART_handle)\n{\n  if (UART_handle != NULL) {\n    if (UART_handle->gState == HAL_UART_STATE_RESET) {\n      UART_handle->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(UART_handle);\n    }\n    UART_handle->gState = HAL_UART_STATE_BUSY;\n    UART_handle->Instance->CR1 &= ~(1 << 13);\n    UART_SetConfig(UART_handle);\n    UART_handle->Instance->CR2 &= ~(1 << 11);\n    UART_handle->Instance->CR3 &= ~(1 << 2);\n    UART_handle->Instance->CR1 |= (1 << 13);\n    UART_handle->ErrorCode = 0;\n    UART_handle->gState = HAL_UART_STATE_READY;\n    UART_handle->RxState = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800674e",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "configure_UART_0800674e"
        },
        "FUN_0800771c": {
            "renaming": {
                "FUN_0800771c": "handle_timer_interrupt_0800771c",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "get_timer_obj": "get_timer_object",
                "irqHandleOC": "on_compare_interrupt"
            },
            "code": "void handle_timer_interrupt_0800771c(TIM_HandleTypeDef* timer_handle){\n  stimer_t* timer_obj = get_timer_object(timer_handle);\n  if ((timer_obj->on_compare_interrupt != NULL) && (timer_handle->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timer_obj->on_compare_interrupt)(timer_obj, 0);\n  }\n  return;\n}",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800771c",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_0800771c"
        },
        "FUN_08003370": {
            "renaming": {
                "FUN_08003370": "setSysexCallback_08003370",
                "this": "parser",
                "command": "command",
                "newFunction": "sysexCallbackFunction",
                "context": "context",
                "currentSysexCallback": "currentSysexCallback",
                "currentSysexCallbackContext": "currentSysexCallbackContext"
            },
            "code": "void __thiscall firmata::FirmataParser::setSysexCallback_08003370(FirmataParser *parser, uint8_t command, sysexCallbackFunction newFunction, void *context)\n{\n  parser->currentSysexCallback = newFunction;\n  parser->currentSysexCallbackContext = context;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003370",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "setSysexCallback_08003370"
        },
        "FUN_08003376": {
            "renaming": {
                "__thiscall firmata::FirmataParser::FUN_08003376": "isDataBufferOverflow",
                "*this": "parser",
                "data": "inputData",
                "pos": "position",
                "bVar1": "isOverflow",
                "currentDataBufferOverflowCallback": "dataBufferOverflowCallback",
                "allowBufferUpdate": "updateBuffer",
                "currentDataBufferOverflowCallbackContext": "callbackContext",
                "FUN_08003376": "isDataBufferOverflow_08003376"
            },
            "code": "bool isDataBufferOverflow_08003376(FirmataParser *parser, uint8_t data, size_t position) {\n  bool isOverflow = false;\n  if (position >= parser->dataBufferSize) {\n    isOverflow = true;\n    if (parser->currentDataBufferOverflowCallback != (dataBufferOverflowCallbackFunction)0x0) {\n      parser->allowBufferUpdate = true;\n      (*parser->currentDataBufferOverflowCallback)(parser->currentDataBufferOverflowCallbackContext);\n      if (position >= parser->dataBufferSize) {\n        isOverflow = true;\n      }\n      else {\n        isOverflow = false;\n      }\n    }\n  }\n  if (!isOverflow) {\n    parser->dataBuffer[position] = data;\n  }\n  return isOverflow;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003376",
            "calling": [
                "parse",
                "processSysexMessage"
            ],
            "imported": false,
            "current_name": "isDataBufferOverflow_08003376"
        },
        "FUN_08008bf4": {
            "renaming": {
                "FUN_08008bf4": "checkSerial2Availability_08008bf4",
                "DAT_08008c18": "serial2Enabled",
                "PTR_Serial2_08008c1c": "serial2Ptr"
            },
            "code": "void checkSerial2Availability_08008bf4(void)\n{\n  if (DAT_08008c18)\n  {\n    HardwareSerial::available(PTR_Serial2_08008c1c);\n  }\n  return;\n}",
            "called": [
                "available"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008bf4",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "checkSerial2Availability_08008bf4"
        },
        "FUN_08002c7c": {
            "renaming": {
                "FUN_08002c7c": "reportAnalogCallback_08002c7c",
                "param_1": "analogCallback",
                "command": "command",
                "value": "value",
                "PTR_currentReportAnalogCallback_08002c8c": "currentReportAnalogCallback"
            },
            "code": "void firmata::FirmataClass::reportAnalogCallback_08002c7c(void *analogCallback, uint8_t command, uint16_t value) {\n  if (*(code **)PTR_currentReportAnalogCallback_08002c8c != (code *)0x0) {\n    (**(code **)PTR_currentReportAnalogCallback_08002c8c)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c7c",
            "calling": [],
            "imported": false,
            "current_name": "reportAnalogCallback_08002c7c"
        },
        "FUN_08005430": {
            "renaming": {
                "FUN_08005430": "get_i2c_error_code_08005430",
                "hi2c": "i2c_handle",
                "ErrorCode": "error_code"
            },
            "code": "uint32_t get_i2c_error_code_08005430(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  return i2c_handle->ErrorCode;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005430",
            "calling": [
                "i2c_master_read",
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "get_i2c_error_code_08005430"
        },
        "FUN_08009918": {
            "renaming": {
                "FUN_08009918": "allocate_memory_08009918",
                "param_1": "allocated_memory",
                "param_2": "size",
                "puVar1": "errno_pointer",
                "pcVar2": "sbrk_result"
            },
            "code": "void allocate_memory_08009918(int *allocated_memory, int size) {\n  undefined *errno_pointer;\n  caddr_t sbrk_result;\n  \n  errno_pointer = PTR_errno_08009934;\n  *(undefined4 *)PTR_errno_08009934 = 0;\n  sbrk_result = _sbrk(size);\n  if ((sbrk_result == (caddr_t)0xffffffff) && (*(int *)errno_pointer != 0)) {\n    *allocated_memory = *(int *)errno_pointer;\n  }\n  return;\n}",
            "called": [
                "_sbrk"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009918",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009918"
        },
        "FUN_08005434": {
            "renaming": {
                "FUN_08005434": "delay_in_milliseconds_08005434",
                "mdelay": "milliseconds",
                "Delay": "delay_cycles",
                "bVar1": "delay_complete"
            },
            "code": "void delay_in_milliseconds_08005434(uint32_t milliseconds)\n{\n  bool delay_complete;\n  uint32_t delay_cycles = milliseconds * (uint)((ulonglong)DAT_0800545c * (ulonglong)*(uint *)PTR_SystemCoreClock_08005458 >> 0x29);\n  do {\n    delay_complete = delay_cycles != 0;\n    delay_cycles = delay_cycles - 1;\n  } while (delay_complete);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005434",
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "imported": false,
            "current_name": "delay_in_milliseconds_08005434"
        },
        "FUN_08005e2e": {
            "renaming": {
                "FUN_08005e2e": "reset_timer_08005e2e",
                "htim": "timer",
                "HAL_TIM_STATE_BUSY": "TIMER_STATE_BUSY",
                "TIM_TypeDef_conflict": "TimerInstance",
                "pTVar1": "timer_instance",
                "CCER": "CaptureCompareEnableRegister",
                "CR1": "ControlRegister1",
                "HAL_TIM_PWM_MspDeInit": "DeinitializePWM",
                "HAL_TIM_STATE_RESET": "TIMER_STATE_RESET",
                "HAL_UNLOCKED": "TIMER_UNLOCKED"
            },
            "code": "HAL_StatusTypeDef_conflict reset_timer_08005e2e(TIM_HandleTypeDef_conflict *timer)\n{\n  TIM_TypeDef_conflict *timer_instance;\n  timer->State = HAL_TIM_STATE_BUSY;\n  timer_instance = timer->Instance;\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 = timer_instance->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(timer);\n  timer->State = HAL_TIM_STATE_RESET;\n  timer->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}",
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e2e",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "reset_timer_08005e2e"
        },
        "FUN_08007736": {
            "renaming": {
                "FUN_08007736": "handle_timer_interrupt_08007736",
                "htim": "timer_handle",
                "psVar1": "timer_object",
                "get_timer_obj": "get_timer_object",
                "irqHandle": "irq_handler"
            },
            "code": "void handle_timer_interrupt_08007736(TIM_HandleTypeDef_conflict *timer_handle)\n{\n  stimer_t_conflict *timer_object;\n  timer_object = get_timer_object(timer_handle);\n  if (timer_object->irq_handler != (_func_void_stimer_t_ptr_conflict *)0x0) {\n    (*timer_object->irq_handler)(timer_object);\n  }\n  return;\n}",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007736",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007736"
        },
        "FUN_08002c90": {
            "renaming": {
                "FUN_08002c90": "report_digital_state_08002c90",
                "param_1": "callback",
                "command": "command",
                "value": "value",
                "PTR_currentReportDigitalCallback_08002ca0": "current_report_digital_callback"
            },
            "code": "void firmata::FirmataClass::report_digital_state_08002c90(void *callback, uint8_t command, uint16_t value)\n{\n  if (*(code **)PTR_currentReportDigitalCallback_08002ca0 != (code *)0x0) {\n    (**(code **)PTR_currentReportDigitalCallback_08002ca0)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c90",
            "calling": [],
            "imported": false,
            "current_name": "report_digital_state_08002c90"
        },
        "FUN_0800542a": {
            "renaming": {
                "FUN_0800542a": "get_i2c_state_0800542a",
                "hi2c": "i2c_handle",
                "HAL_I2C_StateTypeDef_conflict": "HAL_I2C_StateTypeDef"
            },
            "code": "HAL_I2C_StateTypeDef get_i2c_state_0800542a(I2C_HandleTypeDef *i2c_handle)\n{\n  return i2c_handle->State;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800542a",
            "calling": [
                "i2c_master_read",
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "get_i2c_state_0800542a"
        },
        "FUN_0800457c": {
            "renaming": {
                "FUN_0800457c": "sendByte_0800457c",
                "hi2c": "i2cHandle",
                "hi2c->XferCount": "i2cHandle->transferCount",
                "pbVar1": "currentByte",
                "hi2c->pBuffPtr": "i2cHandle->bufferPointer",
                "hi2c->Instance->DR": "i2cHandle->Instance->DataRegister",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "byte": "uint8_t"
            },
            "code": "HAL_StatusTypeDef_conflict sendByte_0800457c(I2C_HandleTypeDef_conflict *hi2c)\n{\n  byte *currentByte;\n  if (hi2c->XferCount != 0) {\n    currentByte = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = currentByte + 1;\n    hi2c->Instance->DR = (uint)*currentByte;\n    hi2c->XferCount--;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800457c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "sendByte_0800457c"
        },
        "FUN_080091c6": {
            "renaming": {
                "FUN_080091c6": "fill_memory_with_value_080091c6",
                "__s": "memory_start",
                "__c": "value_to_fill",
                "__n": "memory_size",
                "puVar1": "current_address"
            },
            "code": "void* fill_memory_with_value_080091c6(void* memory_start, int value_to_fill, size_t memory_size) {\n  unsigned char* current_address = (unsigned char*) memory_start;\n  unsigned char* end_address = current_address + memory_size;\n  while (current_address < end_address) {\n    *current_address = (unsigned char) value_to_fill;\n    current_address++;\n  }\n  return memory_start;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091c6",
            "calling": [
                "begin",
                "std.isra.0",
                "endTransmission",
                "pwm_start",
                "__sfp",
                "adc_read_value",
                "flush",
                "__sfmoreglue"
            ],
            "imported": false,
            "current_name": "fill_memory_with_value_080091c6"
        },
        "FUN_08003a20": {
            "renaming": {
                "FUN_08003a20": "initialize_ADC_08003a20",
                "*hadc": "*hadc",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "current_time",
                "*pAVar4": "*adc_instance",
                "wait_loop_index": "wait_time"
            },
            "code": "HAL_StatusTypeDef_conflict initialize_ADC_08003a20(ADC_HandleTypeDef* hadc) {\n    HAL_StatusTypeDef_conflict status;\n    uint32_t wait_time;\n    uint32_t start_time;\n    uint32_t current_time;\n    ADC_TypeDef* adc_instance;\n\n    adc_instance = hadc->Instance;\n\n    if ((adc_instance->CR2 & 1) == 0) {\n        adc_instance->CR2 |= 1;\n\n        wait_time = (uint32_t)((uint64_t)DAT_08003a9c * (uint64_t)*(uint *)PTR_SystemCoreClock_08003a98 >> 0x32);\n        for (uint32_t i = 0; i < wait_time; i++) {\n        }\n\n        start_time = HAL_GetTick();\n        do {\n            if ((hadc->Instance->CR2 & 1) != 0) {\n                return HAL_OK;\n            }\n            current_time = HAL_GetTick();\n        } while (current_time - start_time < 3);\n\n        hadc->State |= 0x10;\n        hadc->ErrorCode |= 1;\n        hadc->Lock = HAL_UNLOCKED;\n        status = HAL_ERROR;\n    }\n    else {\n        status = HAL_OK;\n    }\n    return status;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a20",
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start"
            ],
            "imported": false,
            "current_name": "initialize_ADC_08003a20"
        },
        "FUN_08009cdc": {
            "renaming": {
                "std_isra_0": "initialize_parameters",
                "param_1": "params",
                "param_2": "param_2",
                "param_3": "param_3",
                "DAT_08009d14": "uVar1",
                "DAT_08009d18": "DAT_08009d18",
                "DAT_08009d1c": "DAT_08009d1c",
                "DAT_08009d20": "DAT_08009d20",
                "FUN_08009cdc": "initialize_parameters_08009cdc"
            },
            "code": "void initialize_parameters_08009cdc(undefined4 *params, undefined2 param_2, undefined2 param_3) {\n    undefined4 DAT_08009d14;\n    params[0] = 0;\n    params[1] = 0;\n    params[2] = 0;\n    *(undefined2 *)(params + 3) = param_2;\n    params[25] = 0;\n    *(undefined2 *)((int)params + 0xe) = param_3;\n    params[4] = 0;\n    params[5] = 0;\n    params[6] = 0;\n    memset(params + 23, 0, 8);\n    DAT_08009d14 = DAT_08009d14;\n    params[8] = params;\n    params[9] = DAT_08009d14;\n    params[10] = DAT_08009d18;\n    params[11] = DAT_08009d1c;\n    params[12] = DAT_08009d20;\n    return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009cdc",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_parameters_08009cdc"
        },
        "FUN_080026b0": {
            "renaming": {
                "FUN_080026b0": "mapValueToMicroseconds_080026b0",
                "this": "servo",
                "value": "inputValue",
                "PTR_min": "minPulse",
                "PTR_max": "maxPulse"
            },
            "code": "void __thiscall Servo::mapValueToMicroseconds_080026b0(Servo *servo,int value)\n{\n  int PTR_minWidth = (0x88 - servo->min) * 4;\n  int PTR_maxWidth = (600 - servo->max) * 4;\n  if (value < 0x220) {\n    if (value < 0) {\n      value = 0;\n    }\n    else if (0xb4 < value) {\n      value = 0xb4;\n    }\n    value = map(value, 0, 0xb4, PTR_minWidth, PTR_maxWidth);\n  }\n  mapValueToMicroseconds_080026b0Microseconds(servo, value);\n  return;\n}",
            "called": [
                "map",
                "writeMicroseconds"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026b0",
            "calling": [
                "analogWriteCallback"
            ],
            "imported": false,
            "current_name": "mapValueToMicroseconds_080026b0"
        },
        "FUN_08002a58": {
            "renaming": {
                "FUN_08002a58": "transmitData_08002a58",
                "this": "wire",
                "sendStop": "sendStop",
                "iVar1": "status",
                "uVar2": "result",
                "PTR_txAddress_08002ab0": "txAddress",
                "PTR_txBuffer_08002aac": "txBuffer",
                "PTR_txBufferLength_08002aa8": "txBufferLength",
                "PTR_txBufferAllocated_08002ab4": "txBufferAllocated",
                "PTR_txBufferIndex_08002ab8": "txBufferIndex",
                "PTR_transmitting_08002abc": "transmitting"
            },
            "code": "uint8_t __thiscall transmitData_08002a58(TwoWire *wire, uint8_t sendStop)\n{\n  i2c_status_e_conflict status;\n  uint8_t result;\n  if (wire->master == false) {\n    result = 4;\n  }\n  else {\n    status = i2c_master_write((i2c_t_conflict *)&wire->_i2c, *PTR_txAddress_08002ab0, *(uint8_t **)PTR_txBuffer_08002aac, (ushort)(byte)*PTR_PTR_txBuffer_08002aacLength_08002aa8);\n    if (status == I2C_OK) {\n      result = 0;\n    }\n    else if (status == I2C_TIMEOUT) {\n      result = 1;\n    }\n    else {\n      result = 4;\n    }\n    if (*(void **)PTR_txBuffer_08002aac != (void *)0x0) {\n      memset(*(void **)PTR_txBuffer_08002aac, 0, (uint)(byte)*PTR_PTR_txBuffer_08002aacAllocated_08002ab4);\n    }\n    *PTR_PTR_txBuffer_08002aacIndex_08002ab8 = 0;\n    *PTR_PTR_txBuffer_08002aacLength_08002aa8 = 0;\n    *PTR_transmitting_08002abc = 0;\n  }\n  return result;\n}",
            "called": [
                "memset",
                "i2c_master_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a58",
            "calling": [
                "requestFrom",
                "endTransmission",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "transmitData_08002a58"
        },
        "FUN_080004d4": {
            "renaming": {
                "FUN_080004d4": "initialize_servos_080004d4",
                "__initialize_p": "should_initialize",
                "__priority": "priority",
                "iVar1": "servo_index",
                "this": "servo_ptr"
            },
            "code": "void initialize_servos_080004d4(int should_initialize, int priority) {\n  int servo_index;\n  Servo *servo_ptr;\n  if (should_initialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    servo_ptr = (Servo *)PTR_servos_080004fc;\n    for (servo_index = 0xb; servo_index >= 0; servo_index--) {\n      Servo::Servo(servo_ptr);\n      servo_ptr++;\n    }\n  }\n  return;\n}",
            "called": [
                "Servo"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004d4",
            "calling": [
                "_GLOBAL__sub_I_analogInputsToReport"
            ],
            "imported": false,
            "current_name": "initialize_servos_080004d4"
        },
        "FUN_080005f8": {
            "renaming": {
                "FUN_080005f8": "FUNC_080005f8"
            },
            "code": "\nvoid FUNC_080005f8(byte pin,int mode)\n\n{\n  undefined *this;\n  byte bVar1;\n  PinName_conflict PVar2;\n  bool bVar3;\n  bool bVar4;\n  _Bool _Var5;\n  uint ulPin;\n  uint32_t uVar6;\n  char cVar7;\n  uint uVar8;\n  \n  ulPin = (uint)pin;\n  bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000874,pin);\n  if (bVar1 != '\\x7f') {\n    bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000874,pin);\n    if (bVar1 == '\\x06') {\n      cVar7 = *PTR_isI2CEnabled_0800087c;\n      if (cVar7 == '\\0') {\n        cVar7 = '\\0';\n      }\n      else if (mode == 6) {\n        cVar7 = '\\0';\n      }\n    }\n    else {\n      cVar7 = '\\0';\n    }\n    if (cVar7 != '\\0') {\n      disableI2CPins();\n    }\n    if (ulPin < 0x3c) {\n      if (PTR_digitalPin_08000878[ulPin] == NC) {\n        bVar3 = false;\n      }\n      else {\n        uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else if (mode == 4) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      if ((byte)PTR_servoPinMap_08000880[ulPin] < 0xc) {\n        bVar3 = Servo::attached((Servo *)(PTR_servos_08000884 +\n                                         (uint)(byte)PTR_servoPinMap_08000880[ulPin] * 3));\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3 != false) {\n        detachServo(pin);\n      }\n    }\n    uVar8 = ulPin - 0x2e & 0xff;\n    if (uVar8 < 0xe) {\n      if (ulPin < 0x3c) {\n        PVar2 = PTR_digitalPin_08000878[ulPin];\n      }\n      else {\n        PVar2 = NC;\n      }\n      uVar6 = pinNametoDigitalPin(PVar2);\n      if (uVar6 == 0) {\n        bVar3 = false;\n      }\n      else {\n        if (ulPin < 0x3c) {\n          PVar2 = PTR_digitalPin_08000878[ulPin];\n        }\n        else {\n          PVar2 = NC;\n        }\n        uVar6 = pinNametoDigitalPin(PVar2);\n        if (uVar6 == 1) {\n          bVar3 = false;\n        }\n        else {\n          bVar3 = true;\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      reportAnalogCallback((byte)uVar8,(uint)(mode == 2));\n    }\n    if (ulPin < 0x3c) {\n      if (PTR_digitalPin_08000878[ulPin] == NC) {\n        bVar3 = false;\n      }\n      else {\n        uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      if ((mode == 0) || (mode == 0xb)) {\n        PTR_portConfigInputs_08000888[pin >> 3] =\n             PTR_portConfigInputs_08000888[pin >> 3] | (byte)(1 << (ulPin & 7));\n      }\n      else {\n        PTR_portConfigInputs_08000888[pin >> 3] =\n             PTR_portConfigInputs_08000888[pin >> 3] & ~(byte)(1 << (ulPin & 7));\n      }\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000874,pin,0);\n    switch(mode) {\n    case 0:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000878[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        pinMode(ulPin,0);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000874,pin,'\\0');\n        return;\n      }\n      break;\n    case 1:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000a44,pin);\n        if (bVar1 == '\\x03') {\n          digitalWrite(ulPin,0);\n        }\n        pinMode(ulPin,1);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x01');\n        return;\n      }\n      break;\n    case 2:\n      if (uVar8 < 0xe) {\n        if (ulPin < 0x3c) {\n          PVar2 = PTR_digitalPin_08000878[ulPin];\n        }\n        else {\n          PVar2 = NC;\n        }\n        uVar6 = pinNametoDigitalPin(PVar2);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          if (ulPin < 0x3c) {\n            PVar2 = PTR_digitalPin_08000878[ulPin];\n          }\n          else {\n            PVar2 = NC;\n          }\n          uVar6 = pinNametoDigitalPin(PVar2);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        if (ulPin < 0x3c) {\n          if (PTR_digitalPin_08000878[ulPin] == NC) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 0) {\n              bVar3 = false;\n            }\n            else {\n              uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n              if (uVar6 == 1) {\n                bVar3 = false;\n              }\n            }\n          }\n        }\n        else {\n          bVar3 = false;\n        }\n        if (bVar3) {\n          pinMode(ulPin,0);\n        }\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000874,pin,'\\x02');\n        return;\n      }\n      break;\n    case 3:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          _Var5 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            _Var5 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              _Var5 = false;\n            }\n            else {\n              _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                    (PinMap_conflict *)PTR_PinMap_PWM_08000a4c);\n            }\n          }\n        }\n      }\n      else {\n        _Var5 = false;\n      }\n      if (_Var5 != false) {\n        pinMode(ulPin,1);\n        analogWrite(ulPin,0);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x03');\n        return;\n      }\n      break;\n    case 4:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x04');\n        if (((byte)PTR_servoPinMap_08000a50[ulPin] != 0xff) &&\n           (bVar4 = Servo::attached((Servo *)(PTR_servos_08000a54 +\n                                             (uint)(byte)PTR_servoPinMap_08000a50[ulPin] * 3)),\n           bVar4)) {\n          bVar3 = false;\n        }\n        if (bVar3) {\n          attachServo(pin,-1,-1);\n          return;\n        }\n      }\n      break;\n    default:\n      firmata::FirmataClass::sendString\n                ((FirmataClass *)PTR_Firmata_08000a44,PTR_s_Unknown_pin_mode_08000a60);\n      break;\n    case 6:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          _Var5 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            _Var5 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              _Var5 = false;\n            }\n            else {\n              _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                    (PinMap_conflict *)PTR_PinMap_I2C_SDA_08000a58);\n              if (!_Var5) {\n                _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                      (PinMap_conflict *)PTR_PinMap_I2C_SCL_08000a5c);\n              }\n            }\n          }\n        }\n      }\n      else {\n        _Var5 = false;\n      }\n      if (_Var5 != false) {\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x06');\n        return;\n      }\n      break;\n    case 10:\n      break;\n    case 0xb:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000878[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        pinMode(ulPin,2);\n        this = PTR_Firmata_08000a44;\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\v');\n        firmata::FirmataClass::setPinState((FirmataClass *)this,pin,1);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "attached",
                "pin_in_pinmap",
                "disableI2CPins",
                "digitalWrite",
                "pinNametoDigitalPin",
                "analogWrite",
                "pinMode",
                "sendString",
                "reportAnalogCallback",
                "setPinState",
                "attachServo",
                "detachServo",
                "getPinMode",
                "setPinMode"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080005f8",
            "calling": [
                "enableI2CPins",
                "sysexCallback",
                "systemResetCallback"
            ],
            "imported": false,
            "current_name": "FUNC_080005f8"
        },
        "FUN_08002fa0": {
            "renaming": {
                "FUN_08002fa0": "getPinConfiguration_08002fa0",
                "this": "firmataInstance",
                "pin": "pinNumber",
                "pinConfig": "pinConfiguration"
            },
            "code": "byte __thiscall firmata::FirmataClass::getPinConfiguration_08002fa0(FirmataClass *this, byte pin) {\n    return this->pinConfig[pin];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fa0",
            "calling": [
                "loop",
                "digitalWriteCallback",
                "sysexCallback",
                "analogWriteCallback",
                "setPinValueCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "getPinConfiguration_08002fa0"
        },
        "FUN_0800a424": {
            "renaming": {
                "FUN_0800a424": "do_nothing_0800a424"
            },
            "code": "\nvoid do_nothing_0800a424(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a424",
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "do_nothing_0800a424"
        },
        "FUN_08003a1c": {
            "renaming": {
                "FUN_08003a1c": "get_ADC_state_08003a1c",
                "hadc": "adc_handle"
            },
            "code": "uint32_t get_ADC_state_08003a1c(ADC_HandleTypeDef *adc_handle)\n{\n  return adc_handle->State;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a1c",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_ADC_state_08003a1c"
        },
        "FUN_08007744": {
            "renaming": {
                "FUN_08007744": "get_timer_count_08007744",
                "obj": "timer_obj",
                "(obj->handle).Instance": "timer_handle->Instance",
                "((obj->handle).Instance)->CNT": "timer_handle->Instance->CNT"
            },
            "code": "uint32_t get_timer_count_08007744(stimer_t_conflict *timer_obj)\n{\n  TIM_HandleTypeDef *timer_handle = &(timer_obj->handle);\n  return timer_handle->Instance->CNT;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007744",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "get_timer_count_08007744"
        },
        "FUN_08006538": {
            "renaming": {
                "FUN_08006538": "set_uart_config_08006538",
                "*huart": "huart",
                "USART_TypeDef *pUVar12": "USART_TypeDef *usart_instance",
                "uVar1": "brr_value",
                "uVar2": "baud_rate",
                "uVar3": "pclk_freq",
                "uVar4": "pclk_freq",
                "uVar5": "pclk_freq",
                "uVar6": "pclk_freq",
                "uVar7": "pclk_freq",
                "uVar8": "baud_rate",
                "uVar9": "baud_rate",
                "uVar10": "baud_rate",
                "uVar11": "baud_rate",
                "pUVar12": "usart_instance",
                "CR1": "usart_cr1",
                "CR2": "usart_cr2",
                "CR3": "usart_cr3",
                "BRR": "brr_value",
                "DAT_080066e0": "DAT_080066e0"
            },
            "code": "void set_uart_config_08006538(UART_HandleTypeDef *huart)\n{\n    uint32_t pclk_freq = 0;\n    uint32_t baud_rate = 0;\n    uint32_t usart_cr1 = 0;\n    uint32_t usart_cr2 = 0;\n    uint32_t usart_cr3 = 0;\n    uint32_t brr_value = 0;\n    USART_TypeDef *usart_instance = huart->Instance;\n    \n    // Set stop bits\n    usart_cr2 = usart_instance->CR2 & 0xffffcfff;\n    usart_cr2 |= huart->Init.StopBits;\n    usart_instance->CR2 = usart_cr2;\n    \n    // Set word length, parity, and mode\n    usart_cr1 = usart_instance->CR1 & 0xffffe9f3;\n    usart_cr1 |= huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;\n    usart_instance->CR1 = usart_cr1;\n    \n    // Set hardware flow control\n    usart_cr3 = usart_instance->CR3 & 0xfffffcff;\n    usart_cr3 |= huart->Init.HwFlowCtl;\n    usart_instance->CR3 = usart_cr3;\n    \n    // Calculate baud rate\n    baud_rate = huart->Init.BaudRate;\n    pclk_freq = (usart_instance == DAT_080066e0) ? HAL_RCC_GetPCLK2Freq() : HAL_RCC_GetPCLK1Freq();\n    brr_value = (uint32_t)(((uint64_t)pclk_freq * 2) / baud_rate);\n    usart_instance->BRR = brr_value;\n}\n",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006538",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "set_uart_config_08006538"
        },
        "FUN_08002fa8": {
            "renaming": {
                "FUN_08002fa8": "set_pin_config_08002fa8",
                "this": "firmata",
                "pin": "pin",
                "config": "config",
                "pinConfig": "pin_configurations"
            },
            "code": "void set_pin_config_08002fa8(FirmataClass *firmata, byte pin, byte config)\n{\n  if (firmata->pin_configurations[pin] != '\\x7f') {\n    firmata->pin_configurations[pin] = config;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fa8",
            "calling": [
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "set_pin_config_08002fa8"
        },
        "FUN_0800325a": {
            "renaming": {
                "FUN_0800325a": "sendCommand_0800325a",
                "this": "marshaller",
                "command": "command",
                "bytec": "byteCount",
                "bytev": "byteValue",
                "uVar1": "byteIndex",
                "FirmataStream": "firmataStream",
                "Stream": "Stream",
                "super_Print": "super_Print",
                "_vptr_Print": "_vptr_Print",
                "encodeByteStream": "encodeByteStream"
            },
            "code": "void __thiscall FirmataMarshaller::sendCommand_0800325a(FirmataMarshaller *marshaller, uint8_t command, size_t byteCount, uint8_t *byteValue)\n{\n  uint byteIndex;\n  if (marshaller->firmataStream != (Stream *)0x0) {\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller,0xf0);\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream,(uint)command);\n    for (byteIndex = 0; byteIndex < byteCount; byteIndex = byteIndex + 1) {\n      encodeByteStream(marshaller,1,byteValue + byteIndex,0);\n    }\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream,0xf7);\n  }\n  return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800325a",
            "calling": [
                "sendString",
                "sendSysex"
            ],
            "imported": false,
            "current_name": "sendCommand_0800325a"
        },
        "FUN_080091d8": {
            "renaming": {
                "FUN_080091d8": "allocate_memory_080091d8",
                "param_1": "error_code",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "puVar1": "previous_block",
                "extraout_r1": "next_block",
                "ppiVar2": "previous_block",
                "ppiVar3": "next_block",
                "piVar4": "block_size",
                "ppiVar5": "current_block",
                "ppiVar6": "previous_block",
                "ppiVar7": "block_to_allocate"
            },
            "code": "void allocate_memory_080091d8(int* error_code, int size, int arg3, int arg4)\n{\n    int** previous_block = NULL;\n    int** current_block = *(int***)PTR___malloc_free_list_0800926c;\n    int** block_to_allocate = (int**)(size + -4);\n    if (size == 0)\n        return;\n    if (*block_to_allocate < 0)\n        block_to_allocate = (int**)((int)block_to_allocate + **(int***)block_to_allocate);\n    __malloc_lock();\n    if (current_block == NULL)\n    {\n        block_to_allocate[1] = NULL;\n        *(int***)PTR___malloc_free_list_0800926c = block_to_allocate;\n        previous_block = NULL;\n    }\n    else if (block_to_allocate < current_block)\n    {\n        previous_block = (int**)*block_to_allocate;\n        int** next_block = (int**)((int)block_to_allocate + (int)previous_block);\n        if (current_block == next_block)\n        {\n            int* block_size = *current_block;\n            current_block = (int**)current_block[1];\n            next_block = (int**)((int)block_size + (int)previous_block);\n            *block_to_allocate = (int*)next_block;\n        }\n        block_to_allocate[1] = (int*)current_block;\n        *(int***)PTR___malloc_free_list_0800926c = block_to_allocate;\n    }\n    else\n    {\n        while (current_block != NULL && current_block <= block_to_allocate)\n        {\n            previous_block = current_block;\n            current_block = (int**)current_block[1];\n        }\n        int** next_block = (int**)((int)previous_block + (int)*previous_block);\n        if (block_to_allocate == next_block)\n        {\n            int* block_size = *next_block;\n            next_block = (int**)((int)block_size + (int)*previous_block);\n            *previous_block = (int*)next_block;\n            if (current_block == next_block)\n            {\n                int* current_block_size = *current_block;\n                current_block = (int**)current_block[1];\n                next_block = (int**)((int)current_block_size + (int)block_size);\n                *previous_block = (int*)next_block;\n                previous_block[1] = (int*)current_block;\n            }\n        }\n        else if (block_to_allocate < next_block)\n        {\n            *error_code = 0xc;\n        }\n        else\n        {\n            next_block = (int**)((int)block_to_allocate + (int)*block_to_allocate);\n            if (current_block == next_block)\n            {\n                int* current_block_size = *current_block;\n                current_block = (int**)current_block[1];\n                next_block = (int**)((int)current_block_size + (int)*block_to_allocate);\n                *block_to_allocate = (int*)next_block;\n            }\n            block_to_allocate[1] = (int*)current_block;\n            previous_block[1] = (int*)block_to_allocate;\n        }\n    }\n    __malloc_unlock(error_code, previous_block, current_block, arg4);\n}\n",
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091d8",
            "calling": [
                "free",
                "__swsetup_r",
                "_realloc_r",
                "__sflush_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_080091d8"
        },
        "FUN_0800688e": {
            "renaming": {
                "FUN_0800688e": "check_uart_state_ready_0800688e",
                "huart": "uart_handle",
                "pData": "data",
                "Size": "size",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_BUSY": "HAL_BUSY",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_LOCKED": "HAL_LOCKED",
                "pTxBuffPtr": "tx_buffer_pointer",
                "TxXferSize": "tx_transfer_size",
                "TxXferCount": "tx_transfer_count",
                "ErrorCode": "error_code",
                "gState": "global_state",
                "Instance": "instance",
                "CR1": "control_register_1"
            },
            "code": "HAL_StatusTypeDef check_uart_state_ready_0800688e(UART_HandleTypeDef *huart, uint8_t *data, uint16_t size) {\n\tHAL_StatusTypeDef status = HAL_OK;\n\tif (huart->gState != HAL_UART_STATE_READY) {\n\t\tstatus = HAL_BUSY;\n\t} else if (data == NULL || size == 0) {\n\t\tstatus = HAL_ERROR;\n\t} else if (huart->Lock == HAL_LOCKED) {\n\t\tstatus = HAL_BUSY;\n\t} else {\n\t\thuart->pTxBuffPtr = data;\n\t\thuart->TxXferSize = size;\n\t\thuart->TxXferCount = size;\n\t\thuart->ErrorCode = 0;\n\t\thuart->gState = HAL_UART_STATE_BUSY_TX;\n\t\thuart->Lock = HAL_UNLOCKED;\n\t\thuart->Instance->CR1 |= 0x80;\n\t}\n\treturn status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800688e",
            "calling": [
                "uart_attach_tx_callback",
                "HAL_UART_TxCpltCallback"
            ],
            "imported": false,
            "current_name": "check_uart_state_ready_0800688e"
        },
        "FUN_080090b4": {
            "renaming": {
                "FUN_080090b4": "initialize_static_variables_080090b4"
            },
            "code": "void initialize_static_variables_080090b4(void)\n{\n    __static_initialization_and_destruction_0(1, 0xffff);\n    return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090b4",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_080090b4"
        },
        "FUN_0800870c": {
            "renaming": {
                "FUN_0800870c": "handle_uart_data_0800870c",
                "*huart": "*uart_handle",
                "bVar1": "index",
                "uVar2": "callback_ptr",
                "PTR_rx_callback_08008728": "callback_ptr",
                "PTR_rx_callback_obj_0800872c": "callback_obj",
                "**(code **)(PTR_rx_callback_08008728 + uVar2 * 4)": "*(code **)callback_ptr",
                "*(undefined4 *)(PTR_rx_callback_obj_0800872c + uVar2 * 4)": "*(undefined4 *)callback_obj",
                "(*(undefined4 *)(PTR_rx_callback_obj_0800872c + uVar2 * 4))": "*(undefined4 *)callback_obj",
                "(*(code **)(PTR_rx_callback_08008728 + uVar2 * 4))": "*(code **)callback_ptr"
            },
            "code": "void handle_uart_data_0800870c(UART_HandleTypeDef *uart_handle) {\n  uint8_t index = uart_index(uart_handle);\n  uint32_t PTR_rx_callback_08008728 = PTR_rx_callback_08008728 + (index * 4);\n  uint32_t PTR_rx_callback_obj_0800872c = PTR_rx_PTR_rx_callback_obj_0800872c_0800872c + (index * 4);\n  if (index < 5) {\n    code *callback = **(code **)(PTR_rx_callback_08008728 + uVar2 * 4);\n    undefined4 obj = *(undefined4 *)(PTR_rx_PTR_rx_callback_obj_0800872c_0800872c + uVar2 * 4);\n    callback(obj);\n  }\n  return;\n}",
            "called": [
                "uart_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800870c",
            "calling": [
                "UART_Receive_IT"
            ],
            "imported": false,
            "current_name": "handle_uart_data_0800870c"
        },
        "FUN_08008840": {
            "renaming": {
                "FUN_08008840": "return_error_08008840",
                "file_UNUSED": "file_unused"
            },
            "code": "int return_error_08008840(int file_unused) {\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008840",
            "calling": [
                "_close_r"
            ],
            "imported": false,
            "current_name": "return_error_08008840"
        },
        "FUN_08008600": {
            "renaming": {
                "FUN_08008600": "receive_data_from_serial_port_08008600",
                "obj": "serial_object",
                "c": "received_data",
                "uVar1": "is_rx_active",
                "PTR_uart_handlers_08008638": "PTR_uart_handlers_08008638",
                "DAT_08008634": "DAT_08008634"
            },
            "code": "int receive_data_from_serial_port_08008600(serial_t *serial_object, uchar *received_data) {\n  uint8_t is_rx_active;\n  if (serial_object == NULL) {\n    return -1;\n  }\n  is_rx_active = serial_rx_active(serial_object);\n  if (is_rx_active == 0) {\n    *received_data = serial_object->recv;\n    HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08008638 + (uint)serial_object->index * 4), &serial_object->recv, 1);\n    return 0;\n  }\n  return -1;\n}",
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008600",
            "calling": [
                "_rx_complete_irq"
            ],
            "imported": false,
            "current_name": "receive_data_from_serial_port_08008600"
        },
        "FUN_08003154": {
            "renaming": {
                "FUN_08003154": "setFirmataStream_08003154",
                "s": "stream",
                "FirmataStream": "FirmataStream"
            },
            "code": "void __thiscall firmata::FirmataMarshaller::setFirmataStream_08003154(Stream *stream) {\n  this->FirmataStream = stream;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003154",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "setFirmataStream_08003154"
        },
        "FUN_08006420": {
            "renaming": {
                "FUN_08006420": "set_channel_state_08006420",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "channel_state",
                "CCER": "cc_register_value",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "void set_channel_state_08006420(TIM_TypeDef_conflict *timer, uint32_t channel, uint32_t channel_state) {\n    uint32_t channel_mask = 4 << (channel & 0xff);\n    uint32_t cc_register_value = timer->CCER & ~channel_mask;\n    timer->CCER = cc_register_value | (channel_state << (channel & 0xff));\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006420",
            "calling": [
                "HAL_TIMEx_PWMN_Start",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "imported": false,
            "current_name": "set_channel_state_08006420"
        },
        "FUN_08007750": {
            "renaming": {
                "FUN_08007750": "set_timer_channel_08007750",
                "obj": "timer",
                "channel": "channel_number",
                "value": "value",
                "&((obj->handle).Instance)->CCR1": "channel_register"
            },
            "code": "void set_timer_channel_08007750(stimer_t_conflict *timer, uint32_t channel_number, uint32_t value) {\n    uint32_t *channel_register = &((timer->handle).Instance)->CCR1;\n    channel_register[channel_number] = value;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007750",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "set_timer_channel_08007750"
        },
        "FUN_08009938": {
            "renaming": {
                "FUN_08009938": "find_char_in_string_08009938",
                "__s": "str",
                "__c": "ch",
                "pbVar1": "byte_ptr"
            },
            "code": "char* find_char_in_string_08009938(char* str, int ch) {\n  byte* byte_ptr;\n  do {\n    byte_ptr = (byte*)str;\n    if (*byte_ptr == 0) {\n      if ((ch & 0xffU) != 0) {\n        byte_ptr = (byte*)0x0;\n      }\n      return (char*)byte_ptr;\n    }\n    str = (char*)(byte_ptr + 1);\n  } while ((ch & 0xffU) != (uint)*byte_ptr);\n  return (char*)byte_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009938",
            "calling": [
                "strrchr"
            ],
            "imported": false,
            "current_name": "find_char_in_string_08009938"
        },
        "FUN_08007f0e": {
            "renaming": {
                "FUN_08007f0e": "receive_i2c_data_08007f0e",
                "*obj": "i2c_handle",
                "dev_address": "device_address",
                "*data": "data_buffer",
                "size": "data_size",
                "HVar1": "i2c_state",
                "HVar2": "i2c_status",
                "uVar3": "start_time",
                "uVar4": "i2c_error_code",
                "uVar5": "elapsed_time",
                "iVar6": "return_status",
                "hi2c": "i2c_handle",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "i2c_t_conflict": "i2c_data"
            },
            "code": "i2c_status_e_conflict receive_i2c_data_08007f0e(I2C_HandleTypeDef_conflict *i2c_handle, uint8_t device_address, uint8_t *data_buffer, uint16_t data_size)\n{\n  HAL_I2C_StateTypeDef_conflict i2c_state;\n  HAL_StatusTypeDef_conflict i2c_status;\n  uint32_t start_time;\n  uint32_t elapsed_time;\n  uint32_t i2c_error_code;\n  uint8_t retry_count = 0;\n  i2c_status_e_conflict return_status = I2C_ERROR;\n  start_time = HAL_GetTick();\n  do {\n    i2c_status = HAL_I2C_Master_Receive_IT(i2c_handle, (uint16_t)device_address, data_buffer, data_size);\n    if (i2c_status == HAL_OK) {\n      return_status = I2C_OK;\n      while ((i2c_state = HAL_I2C_GetState(i2c_handle), i2c_state != HAL_I2C_STATE_READY && (return_status == I2C_OK))) {\n        elapsed_time = HAL_GetTick() - start_time;\n        if (elapsed_time < 0x65) {\n          i2c_error_code = HAL_I2C_GetError(i2c_handle);\n          if (i2c_error_code != 0) {\n            return_status = I2C_ERROR;\n          }\n        }\n        else {\n          return_status = I2C_TIMEOUT;\n        }\n      }\n    }\n    i2c_error_code = HAL_I2C_GetError(i2c_handle);\n    retry_count++;\n  } while ((i2c_error_code == 4) && (elapsed_time < 100));\n  return return_status;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_I2C_Master_Receive_IT",
                "HAL_I2C_GetState",
                "HAL_I2C_GetError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f0e",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "receive_i2c_data_08007f0e"
        },
        "FUN_08004004": {
            "renaming": {
                "FUN_08004004": "set_IRQn_bitmask_08004004",
                "IRQn": "IRQn",
                "uVar1": "IRQn_bit",
                "DAT_08004020": "NVIC_ISER_base",
                "bit_pos": "bit_position"
            },
            "code": "void set_IRQn_bitmask_08004004(IRQn_Type_conflict IRQn)\n{\n  uint32_t IRQn_bit = (uint32_t)IRQn;\n  if (IRQn_bit != -1) {\n    uint32_t* NVIC_ISER = (uint32_t*)(DAT_08004020 + ((IRQn_bit >> 5) + 0x60) * 4);\n    uint32_t bit_pos = IRQn_bit & 0x1f;\n    *NVIC_ISER = 1 << bit_pos;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004004",
            "calling": [
                "USART2_IRQHandler",
                "USART1_IRQHandler",
                "USART3_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_IRQn_bitmask_08004004"
        },
        "FUN_08003158": {
            "renaming": {
                "FUN_08003158": "sendPinValue_08003158",
                "this": "marshaller",
                "pin": "pin",
                "value": "value",
                "local_a": "encoded_value",
                "FirmataStream": "FirmataStream",
                "Stream": "Stream",
                "_vptr_Print": "_vptr_Print",
                "encodeByteStream": "encodeByteStream",
                "sendExtendedAnalog": "sendExtendedAnalog"
            },
            "code": "void __thiscall FirmataMarshaller::sendPinValue_08003158(FirmataMarshaller *marshaller, uint8_t pin, uint16_t value) {\n  uint16_t encoded_value;\n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    encoded_value = value;\n    if ((pin < 0x10) && (value < 0x4000)) {\n      (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller,pin | 0xe0);\n      encodeByteStream(marshaller,2,(uint8_t *)&encoded_value,2);\n    }\n    else {\n      sendExtendedAnalog(marshaller,pin,2,(uint8_t *)&encoded_value);\n    }\n  }\n  return;\n}",
            "called": [
                "encodeByteStream",
                "sendExtendedAnalog"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003158",
            "calling": [
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "sendPinValue_08003158"
        },
        "FUN_080090c2": {
            "renaming": {
                "FUN_080090c2": "register_exit_function_080090c2",
                "param_1": "func",
                "param_2": "arg"
            },
            "code": "void register_exit_function_080090c2(void (*func)(void), void *arg)\n{\n  __cxa_atexit(arg, func);\n  return;\n}",
            "called": [
                "__cxa_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090c2",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "register_exit_function_080090c2"
        },
        "FUN_08000ef8": {
            "renaming": {
                "FUN_08000ef8": "FUNC_08000ef8"
            },
            "code": "\nvoid FUNC_08000ef8(void)\n\n{\n  byte bVar1;\n  bool bVar2;\n  uint32_t uVar3;\n  int iVar4;\n  byte bVar5;\n  \n  if (*PTR_reportPINs_08001188 != '\\0') {\n    bVar1 = *PTR_portConfigInputs_0800118c;\n    if (*PTR_digitalPin_08001190 == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(*PTR_digitalPin_08001190);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(*PTR_digitalPin_08001190);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001190[1] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[1]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[1]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(1);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001190[2] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[2]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[2]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(2);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001190[3] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[3]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[3]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(3);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001190[4] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[4]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[4]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(4);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001190[5] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[5]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[5]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(5);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001190[6] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[6]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[6]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(6);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001190[7] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[7]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[7]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(7);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\0',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001188[1] != '\\0') {\n    bVar1 = PTR_portConfigInputs_0800118c[1];\n    if (PTR_digitalPin_08001190[8] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[8]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[8]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(8);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001424[9] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[9]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[9]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(9);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001424[10] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[10]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[10]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(10);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001424[0xb] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xb]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xb]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xb);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001424[0xc] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xc]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xc]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xc);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001424[0xd] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xd]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xd]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xd);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001424[0xe] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xe]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xe]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xe);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001424[0xf] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xf]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xf]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xf);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x01',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001428[2] != '\\0') {\n    bVar1 = PTR_portConfigInputs_0800142c[2];\n    if (PTR_digitalPin_08001424[0x10] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0x10]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0x10]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x10);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_080016c4[0x11] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x11]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x11]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x11);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_080016c4[0x12] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x12]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x12]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x12);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_080016c4[0x13] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x13]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x13]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x13);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_080016c4[0x14] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x14]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x14]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x14);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_080016c4[0x15] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x15]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x15]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x15);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_080016c4[0x16] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x16]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x16]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x16);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_080016c4[0x17] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x17]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x17]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x17);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x02',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_080016c8[3] != '\\0') {\n    bVar1 = PTR_portConfigInputs_080016cc[3];\n    if (PTR_digitalPin_080016c4[0x18] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x18]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x18]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x18);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_080016c4[0x19] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x19]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x19]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x19);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001960[0x1a] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1a]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1a]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1a);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001960[0x1b] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1b]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1b]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1b);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001960[0x1c] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1c]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1c]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1c);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001960[0x1d] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1d]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1d]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1d);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001960[0x1e] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1e]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1e]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1e);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001960[0x1f] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1f]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1f]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1f);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x03',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001964[4] != '\\0') {\n    bVar1 = PTR_portConfigInputs_08001968[4];\n    if (PTR_digitalPin_08001960[0x20] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x20]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x20]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x20);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001960[0x21] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x21]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x21]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x21);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001b44[0x22] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x22]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x22]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x22);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001b44[0x23] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x23]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x23]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x23);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001b44[0x24] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x24]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x24]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x24);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001b44[0x25] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x25]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x25]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x25);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001b44[0x26] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x26]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x26]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x26);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001b44[0x27] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x27]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x27]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x27);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x04',bVar5,'\\0');\n  }\n  return;\n}\n\n",
            "called": [
                "digitalRead",
                "pinNametoDigitalPin",
                "outputPort"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000ef8",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "FUNC_08000ef8"
        },
        "FUN_08008846": {
            "renaming": {
                "FUN_08008846": "set_file_mode_to_directory_08008846",
                "file_UNUSED": "",
                "st": "file_stat"
            },
            "code": "int set_file_mode_to_directory_08008846(stat *file_stat) {\n  file_stat->st_mode = 0x2000;\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008846",
            "calling": [
                "_fstat_r"
            ],
            "imported": false,
            "current_name": "set_file_mode_to_directory_08008846"
        },
        "FUN_0800a430": {
            "renaming": {
                "FUN_0800a430": "do_nothing_0800a430"
            },
            "code": "\nvoid do_nothing_0800a430(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a430",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800a430"
        },
        "FUN_0800459c": {
            "renaming": {
                "FUN_0800459c": "read_byte_from_i2c_0800459c",
                "hi2c": "i2c_handle",
                "puVar1": "buffer_pointer",
                "hi2c->XferCount": "i2c_handle->XferCount",
                "hi2c->pBuffPtr": "i2c_handle->pBuffPtr",
                "hi2c->Instance->DR": "i2c_handle->Instance->DR",
                "*puVar1": "*buffer_pointer"
            },
            "code": "HAL_StatusTypeDef read_byte_from_i2c_0800459c(I2C_HandleTypeDef *i2c_handle)\n{\n  uint8_t *buffer_pointer;\n  if (i2c_handle->XferCount != 0) {\n    buffer_pointer = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = buffer_pointer + 1;\n    *buffer_pointer = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->XferCount = i2c_handle->XferCount - 1;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800459c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "read_byte_from_i2c_0800459c"
        },
        "FUN_0800774a": {
            "renaming": {
                "FUN_0800774a": "set_timer_0800774a",
                "obj": "timer_object",
                "value": "timer_value",
                "(obj->handle).Instance": "timer_instance",
                "CNT": "timer_value"
            },
            "code": "void set_timer_0800774a(stimer_t_conflict *timer_object, uint32_t timer_value)\n{\n  TIM_TypeDef *timer_instance = (timer_object->handle).Instance;\n  timer_instance->CNT = timer_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800774a",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "set_timer_0800774a"
        },
        "FUN_080027f0": {
            "renaming": {
                "__thiscall TwoWire::FUN_080027f0": "transmitData",
                "this": "wire",
                "data": "data",
                "quantity": "quantity",
                "cVar1": "currentByte",
                "puVar2": "txBufferPtr",
                "iVar3": "i2cStatus",
                "pvVar4": "reallocPtr",
                "uVar5": "allocatedSize",
                "__size": "allocatedSize",
                "*PTR_txBuffer_08002884": "txBufferPtr",
                "*PTR_transmitting_08002878": "transmittingFlag",
                "i2c_slave_FUN_080027f0_IT": "i2cSlaveTransmit",
                "i2c_t_conflict": "i2cConflictType",
                "I2C_OK": "i2cSuccess",
                "*PTR_txBufferLength_0800287c": "txBufferLength",
                "*PTR_txBufferAllocated_08002880": "txBufferAllocatedSize",
                "realloc": "reallocateMemory",
                "memcpy": "copyMemory",
                "*PTR_txBufferIndex_08002888": "txBufferIndex",
                "wire->_i2c": "wireI2c",
                "(wire->super_Stream).super_Print.FUN_080027f0_error": "wirePrintError",
                "FUN_080027f0": "transmitData_080027f0"
            },
            "code": "size_t __thiscall TwoWire::transmitData_080027f0(TwoWire *wire, uint8_t *data, size_t quantity)\\n{\\n  char currentByte;\\n  undefined **PTR_txBuffer_08002884;\\n  i2c_status_e_conflict i2cStatus;\\n  void *reallocPtr;\\n  undefined allocatedSize;\\n  \\n  *PTR_txBuffer_08002884 = PTR_txBuffer_08002884;\\n  if (*PTR_transmitting_08002878 == \"\\0\") {\\n    i2cStatus = i2cSlaveTransmit((i2c_t_conflict *)&wire->_i2c, data, (uint16_t)quantity);\\n    if (i2cStatus != I2C_OK) {\\n      return 0;\\n    }\\n    return quantity;\\n  }\\n  allocatedSize = (byte)*PTR_*PTR_txBufferLength_0800287c_0800287c + quantity;\\n  if ((byte)*PTR_txBufferAllocated_08002880 < allocatedSize) {\\n    if (allocatedSize < 0x20) {\\n      allocatedSize = 0x20;\\n    }\\n    reallocPtr = realloc(*(void **)PTR_txBuffer_08002884, allocatedSize);\\n    *(void **)*PTR_txBuffer_08002884 = reallocPtr;\\n    if (reallocPtr == (void *)0x0) {\\n      allocatedSize = 0;\\n    }\\n    else {\\n      allocatedSize = (undefined)allocatedSize;\\n    }\\n    *PTR_txBufferAllocated_08002880 = allocatedSize;\\n  }\\n  *PTR_txBuffer_08002884 = PTR_*PTR_txBufferIndex_08002888_08002888;\\n  if (*(int *)PTR_txBuffer_08002884 != 0) {\\n    memcpy((void *)((uint)(byte)*PTR_*PTR_txBufferIndex_08002888_08002888 + *(int *)PTR_txBuffer_08002884), data, quantity);\\n    currentByte = **PTR_txBuffer_08002884 + (char)quantity;\\n    **PTR_txBuffer_08002884 = currentByte;\\n    *PTR_*PTR_txBufferLength_0800287c_0800287c = currentByte;\\n    return quantity;\\n  }\\n  (wire->super_Stream).super_Print.transmitData_080027f0_error = 1;\\n  return 0;\\n}",
            "called": [
                "memcpy",
                "i2c_slave_write_IT",
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080027f0",
            "calling": [],
            "imported": false,
            "current_name": "transmitData_080027f0"
        },
        "FUN_0800314e": {
            "renaming": {
                "FUN_0800314e::FUN_0800314e": "initialize_firmata_stream",
                "this": "firmata_instance",
                "FirmataStream": "firmata_stream",
                "FUN_0800314e": "initialize_firmata_stream_0800314e"
            },
            "code": "initialize_firmata_stream_0800314e * __thiscall initialize_firmata_stream_0800314e(initialize_firmata_stream_0800314e *firmata_instance)\n{\n  firmata_instance->FirmataStream = (Stream *)0x0;\n  return firmata_instance;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800314e",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "initialize_firmata_stream_0800314e"
        },
        "FUN_080036a0": {
            "renaming": {
                "FUN_080036a0": "infiniteLoop_080036a0"
            },
            "code": "void infiniteLoop_080036a0(void)\n{\n  while(true){\n    // Do nothing\n  }\n}",
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036a0",
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "imported": false,
            "current_name": "infiniteLoop_080036a0"
        },
        "FUN_080036a2": {
            "renaming": {
                "FUN_080036a2": "initialize_pkey_context_080036a2",
                "ctx": "pkey_ctx",
                "hw_config_FUN_080036a2": "configure_hardware"
            },
            "code": "int initialize_pkey_context_080036a2(EVP_PKEY_CTX *pkey_ctx) {\n  configure_hardware();\n  return (int)pkey_ctx;\n}",
            "called": [
                "hw_config_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036a2",
            "calling": [
                "premain"
            ],
            "imported": false,
            "current_name": "initialize_pkey_context_080036a2"
        },
        "FUN_080038e4": {
            "renaming": {
                "FUN_080038e4": "set_adc_channel_080038e4",
                "*hadc": "hadc",
                "*sConfig": "config",
                "HVar1": "status",
                "uVar2": "rank",
                "pAVar3": "adc",
                "wait_loop_index": "wait_loop_index",
                "PTR_SystemCoreClock_08003a14": "PTR_SystemCoreClock_08003a14",
                "DAT_08003a10": "DAT_08003a10",
                "DAT_08003a18": "DAT_08003a18"
            },
            "code": "HAL_StatusTypeDef set_adc_channel_080038e4(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *config)\n{\n  HAL_StatusTypeDef status;\n  uint32_t rank = config->Rank;\n  uint32_t channel = config->Channel;\n  uint32_t sampling_time = config->SamplingTime;\n  ADC_TypeDef *adc = hadc->Instance;\n\n  if (hadc->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    hadc->Lock = HAL_LOCKED;\n    if (rank < 7) {\n      uint32_t offset = rank * 5 - 5;\n      adc->SQR3 = (channel << offset) | (adc->SQR3 & ~(0x1f << offset));\n    }\n    else if (rank < 0xd) {\n      uint32_t offset = rank * 5 - 0x23;\n      adc->SQR2 = (channel << offset) | (adc->SQR2 & ~(0x1f << offset));\n    }\n    else {\n      uint32_t offset = rank * 5 - 0x41;\n      adc->SQR1 = (channel << offset) | (adc->SQR1 & ~(0x1f << offset));\n    }\n    if (channel < 10) {\n      adc->SMPR2 = (sampling_time << (channel * 3)) | (adc->SMPR2 & ~(7 << (channel * 3)));\n    }\n    else {\n      uint32_t offset = channel * 3 - 0x1e;\n      adc->SMPR1 = (sampling_time << offset) | (adc->SMPR1 & ~(7 << offset));\n    }\n    if (channel >= 0x10 && channel <= 0x12 && adc == DAT_08003a10) {\n      if ((adc->CR2 & 0x800000) == 0) {\n        adc->CR2 |= 0x800000;\n        if (channel == 0x10) {\n          uint32_t wait_loop_index = (uint32_t)(((uint64_t)DAT_08003a18 * (uint64_t)*(uint32_t *)PTR_SystemCoreClock_08003a14) >> 0x32) * 10;\n          while (wait_loop_index--);\n          status = HAL_OK;\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        status = HAL_OK;\n      }\n    }\n    else {\n      hadc->State |= 0x20;\n      status = HAL_ERROR;\n    }\n    hadc->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080038e4",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "set_adc_channel_080038e4"
        },
        "FUN_08005e68": {
            "renaming": {
                "FUN_08005e68": "do_nothing_08005e68"
            },
            "code": "\nvoid do_nothing_08005e68(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e68",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e68"
        },
        "FUN_08005d48": {
            "renaming": {
                "FUN_08005d48": "configure_timer_08005d48",
                "TIMx": "timer",
                "OC_Config": "oc_config",
                "uVar1": "cc_enable_value",
                "uVar2": "cr2_value",
                "uVar3": "oc_mode_value",
                "CCER": "cc_enable_mask",
                "DAT_08005da8": "PTR_08005da8"
            },
            "code": "void configure_timer_08005d48(TIM_TypeDef_conflict *timer, TIM_OC_InitTypeDef *oc_config)\n{\n  uint32_t cc_enable_mask = 0xfffffeff;\n  uint32_t cr2_value = timer->CR2;\n  uint oc_mode_value = oc_config->OCMode;\n  uint32_t cc_enable_value = (timer->CCER & 0xfffffdff) | (oc_config->OCPolarity << 8);\n  if (timer == DAT_08005da8) {\n    cc_enable_value = (cc_enable_value & 0xfffff7ff) | (oc_config->OCNPolarity << 8);\n    cr2_value = (cr2_value & 0xffffcfff) | (oc_config->OCIdleState << 4) | (oc_config->OCNIdleState << 4);\n  }\n  timer->CR2 = cr2_value;\n  timer->CCMR2 = (timer->CCMR2 & 0xffffff8c) | oc_mode_value;\n  timer->CCR3 = oc_config->Pulse;\n  timer->CCER = cc_enable_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d48",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08005d48"
        },
        "FUN_08008ba4": {
            "renaming": {
                "__thiscall HardwareSerial::FUN_08008ba4": "write_byte",
                "this": "serial_obj",
                "c": "byte_to_write",
                "_written": "is_written",
                "_serial": "serial_obj->_serial",
                "tx_head": "tx_head",
                "uVar2": "is_tx_active",
                "serial_tx_active": "serial_tx_active",
                "uart_attach_tx_callback": "uart_attach_tx_callback",
                "iVar4": "new_head",
                "bVar1": "new_head_byte",
                "bVar3": "new_head_byte",
                "uVar5": "tx_head",
                "FUN_08008ba4": "write_byte_08008ba4"
            },
            "code": "size_t __thiscall HardwareSerial::write_byte_08008ba4(HardwareSerial *serial_obj, uint8_t byte_to_write) {\\n  bool is_written = true;\\n  uint tx_head = (uint)(serial_obj->_serial).tx_head;\\n  int new_head = tx_head + 1;\\n  byte new_head_byte = (byte)new_head & 0x7f;\\n  if (new_head == 0) {\\n    new_head_byte = -(-new_head_byte & 0x7f);\\n  }\\n  while ((serial_obj->_serial).tx_tail == (ushort)new_head_byte) {};\\n  (serial_obj->_serial).tx_buff[tx_head] = byte_to_write;\\n  (serial_obj->_serial).tx_head = (ushort)new_head_byte;\\n  uint8_t is_tx_active = serial_tx_active((serial_t *)&serial_obj->_serial);\\n  if (is_tx_active == \"\\0\") {\\n    uart_attach_tx_callback((serial_t *)&serial_obj->_serial,DAT_08008bf0);\\n  }\\n  return 1;\\n}",
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ba4",
            "calling": [],
            "imported": false,
            "current_name": "write_byte_08008ba4"
        },
        "FUN_08009ff8": {
            "renaming": {
                "FUN_08009ff8": "kill_process_if_possible_08009ff8",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal_number",
                "puVar1": "error_ptr",
                "iVar2": "kill_result"
            },
            "code": "void kill_process_if_possible_08009ff8(int *error_code, int process_id, int signal_number) {\n  undefined *error_ptr = PTR_errno_0800a018;\n  *(undefined4 *)PTR_errno_0800a018 = 0;\n  int kill_result = _kill(process_id, signal_number);\n  if ((kill_result == -1) && (*(int *)error_ptr != 0)) {\n    *error_code = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_kill"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009ff8",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "kill_process_if_possible_08009ff8"
        },
        "FUN_08009db0": {
            "renaming": {
                "FUN_08009db0": "reset_if_zero_08009db0",
                "param_1": "param_ptr",
                "piVar1": "current_ptr",
                "piVar2": "next_ptr",
                "iVar3": "global_impure_ptr",
                "ppiVar4": "ptr_to_current_ptr"
            },
            "code": "int* reset_if_zero_08009db0(int* param_1)\n{\n  int* current_ptr;\n  int* next_ptr;\n  int global_impure_ptr = *(int*)PTR__global_impure_ptr_08009e24;\n  if (*(int*)(global_impure_ptr + 0x18) == 0) {\n    __sinit(global_impure_ptr);\n  }\n  int** ptr_to_current_ptr = (int**)(global_impure_ptr + 0x48);\n  do {\n    next_ptr = ptr_to_current_ptr[2];\n    current_ptr = ptr_to_current_ptr[1];\n    while (current_ptr = (int*)((int)current_ptr - 1), -1 < (int)current_ptr) {\n      if (*(short*)(next_ptr + 3) == 0) {\n        *(undefined2*)((int)next_ptr + 0xe) = 0xffff;\n        next_ptr[0x19] = 0;\n        *(undefined2*)(next_ptr + 3) = 1;\n        *next_ptr = 0;\n        next_ptr[2] = 0;\n        next_ptr[1] = 0;\n        next_ptr[4] = 0;\n        next_ptr[5] = 0;\n        next_ptr[6] = 0;\n        memset(next_ptr + 0x17, 0, 8);\n        next_ptr[0xd] = 0;\n        next_ptr[0xe] = 0;\n        next_ptr[0x12] = 0;\n        next_ptr[0x13] = 0;\n        return next_ptr;\n      }\n      next_ptr = next_ptr + 0x1a;\n    }\n    if (*ptr_to_current_ptr == (int*)0x0) {\n      current_ptr = (int*)__sfmoreglue(param_1, 4);\n      *ptr_to_current_ptr = current_ptr;\n      if (current_ptr == (int*)0x0) {\n        *param_1 = 0xc;\n        return (int*)0x0;\n      }\n    }\n    ptr_to_current_ptr = (int**)*ptr_to_current_ptr;\n  } while (true);\n}",
            "called": [
                "memset",
                "__sinit",
                "__sfmoreglue"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009db0",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "reset_if_zero_08009db0"
        },
        "FUN_08002c2c": {
            "renaming": {
                "FUN_08002c2c": "handleAnalogCallback_08002c2c",
                "param_1": "callbackFunction",
                "command": "command",
                "value": "value",
                "PTR_currentAnalogCallback_08002c3c": "currentAnalogCallback"
            },
            "code": "void firmata::FirmataClass::handleAnalogCallback_08002c2c(void *callbackFunction, uint8_t command, uint16_t value)\n{\n  if (*(code **)PTR_currentAnalogCallback_08002c3c != (code *)0x0) {\n    (**(code **)PTR_currentAnalogCallback_08002c3c)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c2c",
            "calling": [],
            "imported": false,
            "current_name": "handleAnalogCallback_08002c2c"
        },
        "FUN_080072f0": {
            "renaming": {
                "FUN_080072f0": "read_gpio_pin_state_080072f0",
                "port": "gpio_port",
                "pin": "pin_number",
                "GVar1": "pin_state"
            },
            "code": "uint32_t read_gpio_pin_state_080072f0(GPIO_TypeDef *gpio_port, uint32_t pin_number)\n{\n  GPIO_PinState pin_state;\n  pin_state = HAL_GPIO_ReadPin(gpio_port, (uint16_t)pin_number);\n  return (uint32_t)pin_state;\n}",
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072f0",
            "calling": [
                "digitalRead"
            ],
            "imported": false,
            "current_name": "read_gpio_pin_state_080072f0"
        },
        "FUN_08000178": {
            "renaming": {
                "FUN_08000178": "get_string_length_08000178",
                "__s": "str",
                "pcVar3": "current_ptr",
                "pcVar2": "next_ptr",
                "cVar1": "current_char"
            },
            "code": "size_t get_string_length_08000178(char* str) {\n  char current_char;\n  char* current_ptr = str;\n  while (current_char = *current_ptr++) {\n  }\n  return (size_t)(current_ptr - 1 - (int)str);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000178",
            "calling": [
                "sendString",
                "setFirmwareNameAndVersion",
                "printNumber"
            ],
            "imported": false,
            "current_name": "get_string_length_08000178"
        },
        "FUN_08000a64": {
            "renaming": {
                "FUN_08000a64": "checkAndEnableI2C_08000a64",
                "_Var1": "isPinValid",
                "uVar2": "digitalPin",
                "uVar3": "pinIndex"
            },
            "code": "void checkAndEnableI2C_08000a64() {\n  bool isI2CEnabled = true;\n  for (uint8_t pinIndex = 0; pinIndex < 60; pinIndex++) {\n    if (PTR_digitalPin_08000ad8[pinIndex] != NC) {\n      uint32_t digitalPin = pinNametoDigitalPin(PTR_digitalPin_08000ad8[pinIndex]);\n      if (digitalPin != 0 && digitalPin != 1) {\n        if (!pin_in_pinmap(PTR_digitalPin_08000ad8[pinIndex], (PinMap_conflict *)PTR_PinMap_I2C_SDA_08000adc)) {\n          if (!pin_in_pinmap(PTR_digitalPin_08000ad8[pinIndex], (PinMap_conflict *)PTR_PinMap_I2C_SCL_08000ae0)) {\n            continue;\n          }\n        }\n        setPinModeCallback(pinIndex, 6);\n        isI2CEnabled = true;\n      }\n    }\n  }\n  if (isI2CEnabled) {\n    *PTR_isI2CEnabled_08000ae4 = 1;\n    TwoWire::begin((TwoWire *)PTR_Wire_08000ae8);\n  }\n}\n",
            "called": [
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "begin",
                "setPinModeCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a64",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "checkAndEnableI2C_08000a64"
        },
        "FUN_08002c40": {
            "renaming": {
                "FUN_08002c40": "digitalCallback_08002c40",
                "param_1": "digitalPin",
                "command": "command",
                "value": "value",
                "PTR_currentDigitalCallback_08002c50": "currentDigitalCallback"
            },
            "code": "void firmata::FirmataClass::digitalCallback_08002c40(void* digitalPin, uint8_t command, uint16_t value) {\n  if (*(code **)PTR_currentDigitalCallback_08002c50 != (code *)0x0) {\n    (**(code **)PTR_currentDigitalCallback_08002c50)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c40",
            "calling": [],
            "imported": false,
            "current_name": "digitalCallback_08002c40"
        },
        "FUN_0800694c": {
            "renaming": {
                "FUN_0800694c": "receive_data_0800694c",
                "*huart": "*uart",
                "HAL_UART_STATE_BUSY_RX": "HAL_UART_STATE_RECEIVING",
                "huart->RxState": "uart->RxState",
                "HAL_BUSY": "HAL_ERROR_BUSY",
                "(huart->Init).WordLength": "uart->WordLength",
                "UART_WORDLENGTH_9B": "UART_WORDLENGTH_9_BITS",
                "(huart->Init).Parity": "uart->Parity",
                "UART_PARITY_NONE": "UART_PARITY_NO",
                "*(ushort *)huart->pRxBuffPtr": "*(uint16_t *)uart->pRxBuffPtr",
                "huart->pRxBuffPtr": "uart->pRxBuffPtr",
                "huart->Instance->DR": "uart->DR",
                "uint16_t": "uint16_t",
                "uint8_t *puVar3": "uint8_t *data_ptr",
                "puVar3": "data_ptr",
                "puVar3 + 1": "data_ptr + 1",
                "uint8_t": "uint8_t",
                "byte *pbVar1": "uint8_t *buffer_ptr",
                "pbVar1": "buffer_ptr",
                "huart->pRxBuffPtr + 2": "uart->pRxBuffPtr + 2",
                "huart->pRxBuffPtr + 1": "uart->pRxBuffPtr + 1",
                "(byte)huart->Instance->DR": "(uint8_t)uart->DR",
                "(byte)huart->Instance->DR & 0x7f": "(uint8_t)uart->DR & 0x7f",
                "huart->RxXferCount": "uart->remaining_data",
                "uVar2": "remaining_data",
                "HAL_OK": "HAL_OK",
                "uart->Instance->CR1": "uart->CR1",
                "uart->Instance->CR3": "uart->CR3",
                "uart->RxState": "uart->state",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_UART_RxCpltCallback": "HAL_UART_RxCpltCallback"
            },
            "code": "HAL_StatusTypeDef receive_data_0800694c(UART_HandleTypeDef *uart)\n{\n  uint8_t *buffer_ptr;\n  uint16_t remaining_data;\n  uint8_t *data_ptr;\n  if (uart->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((uart->Init).WordLength == UART_WORDLENGTH_9B) {\n    if ((uart->Init).Parity == UART_PARITY_NONE) {\n      *(uint16_t *)uart->pRxBuffPtr = (uint16_t)((uart->Instance->DR << 0x17) >> 0x17);\n      uart->pRxBuffPtr += 2;\n    }\n    else {\n      *(uint16_t *)uart->pRxBuffPtr = (uint16_t)uart->Instance->DR & 0xff;\n      uart->pRxBuffPtr++;\n    }\n  }\n  else if ((uart->Init).Parity == UART_PARITY_NONE) {\n    data_ptr = uart->pRxBuffPtr;\n    uart->pRxBuffPtr = data_ptr + 1;\n    *data_ptr = (uint8_t)uart->Instance->DR;\n  }\n  else {\n    buffer_ptr = uart->pRxBuffPtr;\n    uart->pRxBuffPtr = buffer_ptr + 1;\n    *buffer_ptr = (uint8_t)uart->Instance->DR & 0x7f;\n  }\n  remaining_data = uart->RxXferCount - 1;\n  uart->RxXferCount = remaining_data;\n  if (remaining_data != 0) {\n    return HAL_OK;\n  }\n  uart->Instance->CR1 &= 0xffffffdf;\n  uart->Instance->CR1 &= 0xfffffeff;\n  uart->Instance->CR3 &= 0xfffffffe;\n  uart->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uart);\n  return HAL_OK;\n}",
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800694c",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_data_0800694c"
        },
        "FUN_0800a0ec": {
            "renaming": {
                "FUN_0800a0ec": "get_file_status_0800a0ec",
                "param_1": "status",
                "param_2": "file_descriptor",
                "param_3": "file_stat",
                "puVar1": "error_ptr",
                "iVar2": "file_status"
            },
            "code": "void get_file_status_0800a0ec(int *status, int file_descriptor, struct stat *file_stat) {\n  int error_code = 0;\n  error_code = errno;\n  *(int *)PTR_errno_0800a10c = 0;\n  int file_status = _fstat(file_descriptor, file_stat);\n  if ((file_status == -1) && (*(int *)PTR_errno_0800a10c != 0)) {\n    *status = *(int *)PTR_errno_0800a10c;\n  }\n  errno = error_code;\n  return;\n}",
            "called": [
                "_fstat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0ec",
            "calling": [
                "__swhatbuf_r"
            ],
            "imported": false,
            "current_name": "get_file_status_0800a0ec"
        },
        "FUN_08008df8": {
            "renaming": {
                "FUN_08008df8::FUN_08008df8": "initializeAddress",
                "this": "this",
                "first_octet": "firstOctet",
                "second_octet": "secondOctet",
                "third_octet": "thirdOctet",
                "fourth_octet": "fourthOctet",
                "(this->super_Printable)._vptr_Printable": "(this->superPrintable)._vptrPrintable",
                "PTR_DAT_08008e10": "PTR_DAT_08008e10",
                "(this->_address).bytes[0]": "(this->address).bytes[0]",
                "(this->_address).bytes[1]": "(this->address).bytes[1]",
                "(this->_address).bytes[2]": "(this->address).bytes[2]",
                "(this->_address).bytes[3]": "(this->address).bytes[3]",
                "FUN_08008df8": "initializeAddress_08008df8"
            },
            "code": "initializeAddress_08008df8 * __thiscall initializeAddress_08008df8(initializeAddress_08008df8 *this, uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet) {\n  (this->superPrintable)._vptrPrintable = (_func_int_varargs **)PTR_DAT_08008e10;\n  (this->address).bytes[0] = first_octet;\n  (this->address).bytes[1] = second_octet;\n  (this->address).bytes[2] = third_octet;\n  (this->address).bytes[3] = fourth_octet;\n  return this;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008df8",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initializeAddress_08008df8"
        },
        "FUN_08000188": {
            "renaming": {
                "FUN_08000188": "read_hardware_08000188",
                "a0": "address",
                "a1": "data",
                "a2": "timeout"
            },
            "code": "uint32_t read_hardware_08000188(uint32_t address, uint32_t data, int32_t timeout)\n{\n  software_interrupt(0x3f);\n  return address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000188",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "read_hardware_08000188"
        },
        "FUN_08004f3c": {
            "renaming": {
                "FUN_08004f3c": "handle_I2C_events_08004f3c",
                "hi2c": "hi2c_handle",
                "HVar1": "status",
                "puVar2": "buffer_ptr",
                "pIVar3": "instance_var"
            },
            "code": "void handle_I2C_events_08004f3c(I2C_HandleTypeDef_conflict *hi2c) {\n  HAL_StatusTypeDef_conflict status;\n  uint8_t *buffer_ptr;\n  I2C_TypeDef_conflict *instance_var;\n  \n  if ((byte)hi2c->State - 0x29 < 2) {\n    hi2c->PreviousState = 0;\n    hi2c->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((hi2c->State != HAL_I2C_STATE_ABORT) && ((hi2c->Instance->CR2 & 0x800) == 0)) {\n      hi2c->State = HAL_I2C_STATE_READY;\n    }\n    hi2c->PreviousState = 0;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n  }\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffff7ff;\n  instance_var = hi2c->Instance;\n  if ((instance_var->CR2 & 0x800) == 0) {\n    if (hi2c->State == HAL_I2C_STATE_ABORT) {\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->ErrorCode = 0;\n      if ((instance_var->SR1 & 0x40) != 0) {\n        buffer_ptr = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = buffer_ptr + 1;\n        *buffer_ptr = (uint8_t)instance_var->DR;\n      }\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(hi2c);\n    }\n    else {\n      if ((instance_var->SR1 & 0x40) != 0) {\n        buffer_ptr = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = buffer_ptr + 1;\n        *buffer_ptr = (uint8_t)instance_var->DR;\n      }\n      HAL_I2C_ErrorCallback(hi2c);\n    }\n  }\n  else {\n    instance_var->CR2 = instance_var->CR2 & 0xfffff7ff;\n    if (hi2c->hdmatx->State == HAL_DMA_STATE_READY) {\n      hi2c->hdmarx->XferAbortCallback = handle_I2C_abort;\n      status = HAL_DMA_Abort_IT(hi2c->hdmarx);\n      if (status != HAL_OK) {\n        if ((hi2c->Instance->SR1 & 0x40) != 0) {\n          buffer_ptr = hi2c->pBuffPtr;\n          hi2c->pBuffPtr = buffer_ptr + 1;\n          *buffer_ptr = (uint8_t)hi2c->Instance->DR;\n        }\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n        hi2c->State = HAL_I2C_STATE_READY;\n        (*hi2c->hdmarx->XferAbortCallback)(hi2c->hdmarx);\n      }\n    }\n    else {\n      hi2c->hdmatx->XferAbortCallback = handle_I2C_abort;\n      status = HAL_DMA_Abort_IT(hi2c->hdmatx);\n      if (status != HAL_OK) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n        hi2c->State = HAL_I2C_STATE_READY;\n        (*hi2c->hdmatx->XferAbortCallback)(hi2c->hdmatx);\n      }\n    }\n  }\n  if ((hi2c->State == HAL_I2C_STATE_LISTEN) && ((hi2c->ErrorCode & 4) != 0)) {\n    hi2c->XferOptions = HAL_I2C_FIRST_AND_LAST_FRAME;\n    hi2c->PreviousState = 0;\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(hi2c);\n  }\n  return;\n}",
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f3c",
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "handle_I2C_events_08004f3c"
        },
        "FUN_08004f3a": {
            "renaming": {
                "FUN_08004f3a": "do_nothing_08004f3a"
            },
            "code": "\nvoid do_nothing_08004f3a(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f3a",
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "imported": false,
            "current_name": "do_nothing_08004f3a"
        },
        "FUN_0800344a": {
            "renaming": {
                "FUN_0800344a": "reset_parser_state_0800344a",
                "this": "parser",
                "uVar1": "buffer_index",
                "waitForData": "wait_for_data",
                "executeMultiByteCommand": "execute_multibyte_command",
                "multiByteChannel": "multibyte_channel",
                "dataBufferSize": "buffer_size",
                "dataBuffer": "buffer",
                "parsingSysex": "parsing_sysex",
                "sysexBytesRead": "sysex_bytes_read",
                "currentSystemResetCallback": "system_reset_callback",
                "systemCallbackFunction": "system_callback_function",
                "currentSystemResetCallbackContext": "system_reset_callback_context"
            },
            "code": "void __thiscall firmata::FirmataParser::reset_parser_state_0800344a(FirmataParser *parser) {\n  uint buffer_index;\n  parser->waitForData = false;\n  parser->executeMultiByteCommand = 0;\n  parser->multiByteChannel = 0;\n  for (buffer_index = 0; buffer_index < parser->dataBufferSize; buffer_index++) {\n    parser->dataBuffer[buffer_index] = 0;\n  }\n  parser->parsingSysex = false;\n  parser->sysexBytesRead = 0;\n  if (parser->currentSystemResetCallback != (systemCallbackFunction)0x0) {\n    (*parser->currentSystemResetCallback)(parser->currentSystemResetCallbackContext);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800344a",
            "calling": [
                "parse"
            ],
            "imported": false,
            "current_name": "reset_parser_state_0800344a"
        },
        "FUN_080071e4": {
            "renaming": {
                "FUN_080071e4": "stop_pwm_signal_080071e4",
                "pin": "pin_name",
                "Channel": "channel",
                "uVar1": "function",
                "timHandle": "tim_handle",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "get_pwm_channel": "get_channel",
                "PinMap_conflict": "PinMap",
                "pinmap_peripheral": "map_peripheral",
                "pinmap_function": "map_function",
                "HAL_TIM_PWM_Stop": "stop_pwm",
                "HAL_TIMEx_PWMN_Stop": "stop_pwm_ex",
                "HAL_TIM_PWM_DeInit": "deinit_pwm"
            },
            "code": "void stop_pwm_signal_080071e4(PinName_conflict pin)\n{\n  uint32_t channel;\n  uint32_t function;\n  TIM_HandleTypeDef_conflict tim_handle;\n  \n  tim_handle.Instance = (TIM_TypeDef_conflict *)pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_PWM_08007238);\n  if ((tim_handle.Instance != (TIM_TypeDef_conflict *)0x0) && (channel = get_pwm_channel(pin), (channel == 0 || channel == 4 || channel == 8 || channel == 0xc || channel == 0x18)))\n  {\n    function = pinmap_function(pin,(PinMap_conflict *)PTR_PinMap_PWM_08007238);\n    if ((function & 0x100000) == 0)\n    {\n      HAL_TIM_PWM_Stop(&tim_handle,channel);\n    }\n    else\n    {\n      HAL_TIMEx_PWMN_Stop(&tim_handle,channel);\n    }\n    HAL_TIM_PWM_DeInit(&tim_handle);\n  }\n  return;\n}",
            "called": [
                "pinmap_function",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "pinmap_peripheral",
                "HAL_TIM_PWM_DeInit",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080071e4",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "stop_pwm_signal_080071e4"
        },
        "FUN_08002c54": {
            "renaming": {
                "FUN_08002c54": "handlePinModeCallback_08002c54",
                "param_1": "callbackFunction",
                "command": "command",
                "value": "value",
                "PTR_currentPinModeCallback_08002c64": "currentPinModeCallback"
            },
            "code": "void firmata::FirmataClass::handlePinModeCallback_08002c54(void *callbackFunction, uint8_t command, uint16_t value)\n{\n  if (*(code **)PTR_currentPinModeCallback_08002c64 != (code *)0x0) {\n    (**(code **)PTR_currentPinModeCallback_08002c64)(command,value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c54",
            "calling": [],
            "imported": false,
            "current_name": "handlePinModeCallback_08002c54"
        },
        "FUN_080072fa": {
            "renaming": {
                "FUN_080072fa": "initialize_system_080072fa",
                "HAL_Init": "initialize_hal",
                "SystemClock_Config": "configure_system_clock"
            },
            "code": "void initialize_system_080072fa(void)\n{\n  initialize_hal();\n  configure_system_clock();\n  return;\n}",
            "called": [
                "HAL_Init",
                "SystemClock_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072fa",
            "calling": [
                "init"
            ],
            "imported": false,
            "current_name": "initialize_system_080072fa"
        },
        "FUN_08003346": {
            "renaming": {
                "FUN_08003346": "reportFirmwareCallback_08003346",
                "this": "parser",
                "command": "firmwareCommand",
                "newFunction": "callback",
                "context": "callbackContext",
                "currentReportFirmwareCallback": "reportFirmwareCallback",
                "currentReportFirmwareCallbackContext": "reportFirmwareCallbackContext"
            },
            "code": "void __thiscall firmata::FirmataParser::reportFirmwareCallback_08003346(FirmataParser *this, uint8_t command, versionCallbackFunction newCallback, void *context) {\n    if (command == 'y') {\n        this->currentReportFirmwareCallback = newCallback;\n        this->currentReportFirmwareCallbackContext = context;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003346",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "reportFirmwareCallback_08003346"
        },
        "FUN_08003106": {
            "renaming": {
                "FUN_08003106": "sendPinState_08003106",
                "this": "marshaller",
                "pin": "pin",
                "bytec": "byteCount",
                "bytev": "byteValues",
                "FirmataStream": "firmataStream",
                "Stream": "Stream",
                "_vptr_Print": "_vptr_Print",
                "encodeByteStream": "encodeByteStream"
            },
            "code": "void __thiscall FirmataMarshaller::sendPinState_08003106(FirmataMarshaller *marshaller, uint8_t pin, size_t byteCount, uint8_t *byteValues) {\n  if (marshaller->firmataStream != nullptr) {\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller, 0xf0);\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream, 0x6f);\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream, static_cast<uint>(pin));\n    encodeByteStream(marshaller, byteCount, byteValues, byteCount);\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream, 0xf7);\n  }\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003106",
            "calling": [
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "sendPinState_08003106"
        },
        "FUN_08007708": {
            "renaming": {
                "FUN_08007708": "enable_timer_clock_08007708",
                "htim": "timer_handle"
            },
            "code": "void enable_timer_clock_08007708(TIM_HandleTypeDef_conflict *timer_handle)\n{\n  timer_enable_clock(timer_handle);\n  return;\n}",
            "called": [
                "timer_enable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007708",
            "calling": [
                "HAL_TIM_OC_Init"
            ],
            "imported": false,
            "current_name": "enable_timer_clock_08007708"
        },
        "FUN_0800018c": {
            "renaming": {
                "FUN_0800018c": "execute_afl_call_0800018c",
                "ticks": "num_ticks",
                "uVar1": "result"
            },
            "code": "uint32_t execute_afl_call_0800018c(int ticks) {\n    uint32_t result;\n    if (*(int *)PTR_noHyperCall_080001a4 != 0) {\n        return 0;\n    }\n    result = aflCall(1, ticks, 0);\n    return result;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800018c",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "execute_afl_call_0800018c"
        },
        "FUN_08003f94": {
            "renaming": {
                "FUN_08003f94": "set_irq_handler_08003f94",
                "IRQn": "irq",
                "uVar1": "irq_num",
                "PTR_DAT_08003fac": "irq_reg",
                "DAT_08003fac": "DAT_08003fac"
            },
            "code": "void set_irq_handler_08003f94(IRQn_Type_conflict irq) {\n  uint irq_num = (uint)irq;\n  if (irq_num >= 0) {\n    int* PTR_DAT_08003fac = (int*)(DAT_08003fac + (irq_num >> 5) * 4);\n    int irq_bit = 1 << (irq_num & 0x1f);\n    *PTR_DAT_08003fac = irq_bit;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f94",
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "TimerPulseInit",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "set_irq_handler_08003f94"
        },
        "FUN_08002c68": {
            "renaming": {
                "FUN_08002c68": "handlePinValueChange_08002c68",
                "param_1": "callbackFunction",
                "command": "command",
                "value": "value",
                "PTR_currentPinValueCallback_08002c78": "currentPinValueCallback"
            },
            "code": "void firmata::FirmataClass::handlePinValueChange_08002c68(void *callbackFunction, uint8_t command, uint16_t value)\n{\n  if (*(code **)PTR_currentPinValueCallback_08002c78 != (code *)0x0) {\n    (**(code **)PTR_currentPinValueCallback_08002c78)(command,value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c68",
            "calling": [],
            "imported": false,
            "current_name": "handlePinValueChange_08002c68"
        },
        "FUN_08002a26": {
            "renaming": {
                "FUN_08002a26": "sendStartCondition_08002a26",
                "this": "wireInstance"
            },
            "code": "void __thiscall TwoWire::sendStartCondition_08002a26(TwoWire *wireInstance)\n{\n  sendStartCondition_08002a26(wireInstance, 0x33);\n  return;\n}",
            "called": [
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a26",
            "calling": [
                "enableI2CPins"
            ],
            "imported": false,
            "current_name": "sendStartCondition_08002a26"
        },
        "FUN_0800430c": {
            "renaming": {
                "FUN_0800430c": "configure_I2C_0800430c",
                "hi2c": "i2c_handle",
                "Mode": "mode",
                "EventCount": "event_count",
                "Instance": "instance",
                "DR": "data_register",
                "Devaddress": "device_address",
                "Init": "init_params",
                "AddressingMode": "addressing_mode",
                "State": "state"
            },
            "code": "HAL_StatusTypeDef_conflict configure_I2C_0800430c(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n    if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n        if (i2c_handle->EventCount == 0) {\n            i2c_handle->Instance->DR = i2c_handle->Devaddress & 0xfe;\n        }\n        else {\n            i2c_handle->Instance->DR = i2c_handle->Devaddress & 0xff | 1;\n        }\n    }\n    else if ((i2c_handle->Init).AddressingMode == 0x4000) {\n        if (i2c_handle->State == HAL_I2C_STATE_BUSY_TX) {\n            i2c_handle->Instance->DR = i2c_handle->Devaddress & 0xfe;\n        }\n        else {\n            i2c_handle->Instance->DR = i2c_handle->Devaddress & 0xff | 1;\n        }\n    }\n    else if (i2c_handle->EventCount == 0) {\n        i2c_handle->Instance->DR = (i2c_handle->Devaddress << 0x10) >> 0x17 & 6 | 0xf0;\n    }\n    else if (i2c_handle->EventCount == 1) {\n        i2c_handle->Instance->DR = (i2c_handle->Devaddress << 0x10) >> 0x17 & 6 | 0xf1;\n    }\n    return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800430c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "configure_I2C_0800430c"
        },
        "FUN_08003350": {
            "renaming": {
                "FUN_08003350": "parseCommand_08003350",
                "command": "command",
                "newFunction": "callbackFunction",
                "context": "callbackContext",
                "0xf9": "REPORT_VERSION",
                "0xff": "SYSTEM_RESET",
                "this->currentReportVersionCallback": "currentReportVersionCallback",
                "this->currentReportVersionCallbackContext": "currentReportVersionCallbackContext",
                "this->currentSystemResetCallback": "currentSystemResetCallback",
                "this->currentSystemResetCallbackContext": "currentSystemResetCallbackContext"
            },
            "code": "void __thiscall firmata::FirmataParser::parseCommand_08003350(FirmataParser *this, uint8_t command, systemCallbackFunction newFunction, void *context) {\n  if (command == REPORT_VERSION) {\n    this->currentReportVersionCallback = newFunction;\n    this->currentReportVersionCallbackContext = context;\n    return;\n  }\n  if (command != SYSTEM_RESET) {\n    return;\n  }\n  this->currentSystemResetCallback = newFunction;\n  this->currentSystemResetCallbackContext = context;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003350",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "parseCommand_08003350"
        },
        "FUN_08007710": {
            "renaming": {
                "FUN_08007710": "disable_timer_clock_08007710",
                "htim": "timer_handle",
                "timer_disable_clock": "timer_disable_clock"
            },
            "code": "void disable_timer_clock_08007710(TIM_HandleTypeDef_conflict *timer_handle)\n{\n    timer_disable_clock(timer_handle);\n    return;\n}",
            "called": [
                "timer_disable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007710",
            "calling": [
                "HAL_TIM_OC_DeInit"
            ],
            "imported": false,
            "current_name": "disable_timer_clock_08007710"
        },
        "FUN_08003474": {
            "renaming": {
                "__thiscall firmata::FirmataParser::FUNC_08003474": "parseFirmataMessage",
                "inputData": "inputByte",
                "byte bVar1": "byte currentByte",
                "uint uVar2": "uint inputByte",
                "size_t pos": "size_t pos",
                "this->parsingSysex": "this->parsingSysex",
                "this->sysexBytesRead": "this->sysexBytesRead",
                "bufferDataAtPosition": "bufferDataAtPosition",
                "processSysexMessage": "processSysexMessage",
                "this->waitForData": "this->waitForData",
                "this->multiByteChannel": "this->multiByteChannel",
                "this->executeMultiByteCommand": "this->executeMultiByteCommand",
                "systemReset": "systemReset",
                "this->currentReportVersionCallback": "this->currentReportVersionCallback",
                "systemCallbackFunction": "systemCallbackFunction",
                "this->currentReportVersionCallbackContext": "this->currentReportVersionCallbackContext",
                "callbackFunction": "callbackFunction",
                "this->currentReportDigitalCallback": "this->currentReportDigitalCallback",
                "this->currentReportDigitalCallbackContext": "this->currentReportDigitalCallbackContext",
                "this->dataBuffer": "this->dataBuffer",
                "this->currentDigitalCallback": "this->currentDigitalCallback",
                "this->currentDigitalCallbackContext": "this->currentDigitalCallbackContext",
                "this->currentReportAnalogCallback": "this->currentReportAnalogCallback",
                "this->currentReportAnalogCallbackContext": "this->currentReportAnalogCallbackContext",
                "this->currentPinModeCallback": "this->currentPinModeCallback",
                "this->currentPinModeCallbackContext": "this->currentPinModeCallbackContext",
                "this->currentPinValueCallback": "this->currentPinValueCallback",
                "this->currentPinValueCallbackContext": "this->currentPinValueCallbackContext",
                "this->currentAnalogCallback": "this->currentAnalogCallback",
                "this->currentAnalogCallbackContext": "this->currentAnalogCallbackContext",
                "FUN_08003474": "parseFirmataMessage_08003474"
            },
            "code": "void __thiscall firmata::FirmataParser::parseFirmataMessage_08003474(FirmataParser *this, uint8_t inputData)\\n{\\n    byte currentByte;\\n    uint inputByte = (uint)inputData;\\n    size_t pos;\\n    \\n    if (this->parsingSysex)\\n    {\\n        if (inputByte != 0xf7)\\n        {\\n            bufferDataAtPosition(this, inputData, this->sysexBytesRead);\\n            this->sysexBytesRead++;\\n            return;\\n        }\\n        this->parsingSysex = false;\\n        processSysexMessage(this);\\n        return;\\n    }\\n    \\n    if ((this->waitForData == 0) || (0x7f < inputByte))\\n    {\\n        if (inputByte < 0xf0)\\n        {\\n            this->multiByteChannel = inputData & 0xf;\\n            inputByte &= 0xf0;\\n        }\\n        if (inputByte == 0xf0)\\n        {\\n            this->parsingSysex = true;\\n            this->sysexBytesRead = 0;\\n            return;\\n        }\\n        if (inputByte < 0xf1)\\n        {\\n            if (inputByte != 0xc0)\\n            {\\n                if (inputByte < 0xc1)\\n                {\\n                    if (inputByte != 0x90)\\n                    {\\n                        return;\\n                    }\\n                }\\n                else\\n                {\\n                    if (inputByte == 0xd0) goto LAB_0800359c;\\n                    if (inputByte != 0xe0) return;\\n                }\\n                this->waitForData = 2;\\n                this->executeMultiByteCommand = (uint8_t)inputByte;\\n                return;\\n            }\\n        LAB_0800359c:\\n            this->waitForData = 1;\\n            this->executeMultiByteCommand = (uint8_t)inputByte;\\n            return;\\n        }\\n        if (inputByte != 0xf9)\\n        {\\n            if (0xf9 < inputByte)\\n            {\\n                if (inputByte == 0xff)\\n                {\\n                    systemReset(this);\\n                    return;\\n                }\\n                return;\\n            }\\n            if (inputByte < 0xf5) goto LAB_08003586;\\n        }\\n        else if (this->currentReportVersionCallback != (systemCallbackFunction)0x0)\\n        {\\n            (*this->currentReportVersionCallback)(this->currentReportVersionCallbackContext);\\n        }\\n    }\\n    else\\n    {\\n        pos = this->waitForData - 1;\\n        this->waitForData = pos;\\n        bufferDataAtPosition(this, inputData, pos);\\n        if ((this->waitForData == 0) && (currentByte = this->executeMultiByteCommand, currentByte != 0))\\n        {\\n            if (currentByte == 0xd0)\\n            {\\n                if (this->currentReportDigitalCallback != (callbackFunction)0x0)\\n                {\\n                    (*this->currentReportDigitalCallback)(this->currentReportDigitalCallbackContext, this->multiByteChannel, (uint16_t)*this->dataBuffer);\\n                }\\n            }\\n            else if (currentByte < 0xd1)\\n            {\\n                if (currentByte == 0x90)\\n                {\\n                    if (this->currentDigitalCallback != (callbackFunction)0x0)\\n                    {\\n                        (*this->currentDigitalCallback)(this->currentDigitalCallbackContext, this->multiByteChannel, (uint16_t)this->dataBuffer[1] + (ushort)*this->dataBuffer * 0x80);\\n                    }\\n                }\\n                else if ((currentByte == 0xc0) && (this->currentReportAnalogCallback != (callbackFunction)0x0))\\n                {\\n                    (*this->currentReportAnalogCallback)(this->currentReportAnalogCallbackContext, this->multiByteChannel, (uint16_t)*this->dataBuffer);\\n                }\\n            }\\n            else if (currentByte == 0xf4)\\n            {\\n                if (this->currentPinModeCallback != (callbackFunction)0x0)\\n                {\\n                    (*this->currentPinModeCallback)(this->currentPinModeCallbackContext, this->dataBuffer[1], (uint16_t)*this->dataBuffer);\\n                }\\n            }\\n            else if (currentByte == 0xf5)\\n            {\\n                if (this->currentPinValueCallback != (callbackFunction)0x0)\\n                {\\n                    (*this->currentPinValueCallback)(this->currentPinValueCallbackContext, this->dataBuffer[1], (uint16_t)*this->dataBuffer);\\n                }\\n            }\\n            else if ((currentByte == 0xe0) && (this->currentAnalogCallback != (callbackFunction)0x0))\\n            {\\n                (*this->currentAnalogCallback)(this->currentAnalogCallbackContext, this->multiByteChannel, (ushort)this->dataBuffer[1] + (ushort)*this->dataBuffer * 0x80);\\n            }\\n            this->executeMultiByteCommand = \"\\0\";\\n            return;\\n        }\\n    }\\n    return;\\n}",
            "called": [
                "systemReset",
                "bufferDataAtPosition",
                "processSysexMessage"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003474",
            "calling": [
                "processInput"
            ],
            "imported": false,
            "current_name": "parseFirmataMessage_08003474"
        },
        "FUN_08008804": {
            "renaming": {
                "FUN_08008804": "allocate_memory_08008804",
                "incr": "size",
                "pcVar1": "current_address",
                "pcVar2": "new_address"
            },
            "code": "caddr_t allocate_memory_08008804(int size)\n{\n  caddr_t current_address;\n  caddr_t new_address;\n  \n  if (*(int *)PTR_heap_end_08008834 == 0) {\n    *(undefined **)PTR_heap_end_08008834 = PTR__ebss_08008838;\n  }\n  current_address = *(caddr_t *)PTR_heap_end_08008834;\n  new_address = current_address + size;\n  if (new_address <= &stack0x00000000) {\n    *(caddr_t *)PTR_heap_end_08008834 = new_address;\n    return current_address;\n  }\n  *(undefined4 *)PTR_errno_0800883c = 0xc;\n  return (caddr_t)0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008804",
            "calling": [
                "_sbrk_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08008804"
        },
        "FUN_08004e3c": {
            "renaming": {
                "FUN_08004e3c": "handle_i2c_transfer_08004e3c",
                "*hi2c": "*i2c_handle",
                "uVar1": "transfer_options",
                "puVar2": "buffer_ptr"
            },
            "code": "HAL_StatusTypeDef_conflict handle_i2c_transfer_08004e3c(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  uint32_t transfer_options = i2c_handle->XferOptions;\n  uint8_t *buffer_ptr;\n  \n  if (i2c_handle->XferCount == 3) {\n    if (((transfer_options == 4) || (transfer_options == 8)) || (transfer_options == 0xffff0000)) {\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffbff;\n    }\n    buffer_ptr = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = buffer_ptr + 1;\n    *buffer_ptr = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->XferCount = i2c_handle->XferCount - 1;\n  }\n  else if (i2c_handle->XferCount == 2) {\n    if (((transfer_options == 4) || (transfer_options == 8)) || (transfer_options == 0xffff0000)) {\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffffcff;\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n    }\n    else {\n      if (transfer_options == 2) {\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x400;\n      }\n      else {\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffbff;\n      }\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffffcff;\n    }\n    buffer_ptr = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = buffer_ptr + 1;\n    *buffer_ptr = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->XferCount = i2c_handle->XferCount - 1;\n    buffer_ptr = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = buffer_ptr + 1;\n    *buffer_ptr = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->XferCount = i2c_handle->XferCount - 1;\n    i2c_handle->State = HAL_I2C_STATE_READY;\n    i2c_handle->PreviousState = 0;\n    if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(i2c_handle);\n    }\n    else {\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(i2c_handle);\n    }\n  }\n  else {\n    buffer_ptr = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = buffer_ptr + 1;\n    *buffer_ptr = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->XferCount = i2c_handle->XferCount - 1;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e3c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_transfer_08004e3c"
        },
        "FUN_080091a0": {
            "renaming": {
                "FUN_080091a0": "reversePointer_080091a0",
                "__ptr": "pointer",
                "PTR__impure_ptr_080091ac": "impurePtr",
                "_FUN_080091a0_r": "reverseFunction"
            },
            "code": "void reversePointer_080091a0(void* __ptr)\n{\n  int* PTR__impure_ptr_080091ac = *(int*)PTR__impure_ptr_080091ac;\n  _reversePointer_080091a0_r(PTR__impure_ptr_080091ac, __ptr);\n  return;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091a0",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "reversePointer_080091a0"
        },
        "FUN_08002a1c": {
            "renaming": {
                "FUN_08002a1c": "sendByteToWire_08002a1c",
                "this": "wire",
                "address": "address"
            },
            "code": "void __thiscall sendByteToWire_08002a1c(TwoWire *wire, int address)\n{\n  sendByteToWire_08002a1c(wire, (uint8_t)address);\n  return;\n}",
            "called": [
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a1c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "sendByteToWire_08002a1c"
        },
        "FUN_08007718": {
            "renaming": {
                "FUN_08007718": "get_stimer_from_htim_08007718",
                "htim": "TIM_HandleTypeDef_conflict",
                "stimer_t_conflict": "stimer_t",
                "&htim[-1].Lock": "stimer_t address"
            },
            "code": "stimer_t_conflict* get_stimer_from_htim_08007718(TIM_HandleTypeDef_conflict* htim)\n{\n    return (stimer_t_conflict*) &htim[-1].Lock;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007718",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "imported": false,
            "current_name": "get_stimer_from_htim_08007718"
        },
        "FUN_08002a30": {
            "renaming": {
                "FUN_08002a30": "initializeTransmission_08002a30",
                "*this": "wire",
                "address": "address",
                "*PTR_transmitting_08002a48": "transmitting",
                "*PTR_txAddress_08002a4c": "txAddress",
                "*PTR_txBufferIndex_08002a50": "txBufferIndex",
                "*PTR_txBufferLength_08002a54": "txBufferLength"
            },
            "code": "void __thiscall initializeTransmission_08002a30(TwoWire *wire, uint8_t address) {\n    bool *PTR_transmitting_08002a48 = true;\n    uint8_t *PTR_txAddress_08002a4c = address << 1;\n    uint8_t *PTR_txBufferIndex_08002a50 = 0;\n    uint8_t *PTR_txBufferLength_08002a54 = 0;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a30",
            "calling": [
                "requestFrom",
                "sysexCallback",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "initializeTransmission_08002a30"
        },
        "FUN_08009cd0": {
            "renaming": {
                "FUN_08009cd0": "walk_reentrancy_guarded_heap_08009cd0",
                "param_1": "reentrancy_guard",
                "DAT_08009cd8": "guarded_heap"
            },
            "code": "void walk_reentrancy_guarded_heap_08009cd0(void* reentrancy_guard)\n{\n    _fwalk_reent(reentrancy_guard, DAT_08009cd8);\n    return;\n}",
            "called": [
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009cd0",
            "calling": [],
            "imported": false,
            "current_name": "walk_reentrancy_guarded_heap_08009cd0"
        },
        "FUN_0800322c": {
            "renaming": {
                "FUN_0800322c": "sendVersion_0800322c",
                "this": "marshaller",
                "major": "majorVersion",
                "minor": "minorVersion",
                "FirmataStream": "stream"
            },
            "code": "void __thiscall FirmataMarshaller::sendVersion_0800322c(FirmataMarshaller *marshaller,uint8_t major,uint8_t minor)\n{\n  if (marshaller->stream != nullptr) {\n    (**(marshaller->stream->super_Print)._vptr_Print)(marshaller,0xf9);\n    (**(marshaller->stream->super_Print)._vptr_Print)(marshaller->stream,(uint)major);\n    (**(marshaller->stream->super_Print)._vptr_Print)(marshaller->stream,(uint)minor);\n    return;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800322c",
            "calling": [
                "printVersion"
            ],
            "imported": false,
            "current_name": "sendVersion_0800322c"
        },
        "FUN_08003760": {
            "renaming": {
                "FUN_08003760": "get_uwTick_value_08003760",
                "PTR_uwTick_08003768": "uwTick_ptr"
            },
            "code": "uint32_t get_uwTick_value_08003760(void)\n{\n  uint32_t *PTR_uwTick_08003768 = (uint32_t *)PTR_uwTick_08003768;\n  return *PTR_uwTick_08003768;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003760",
            "calling": [
                "ADC_ConversionStop_Disable",
                "ADC_Enable",
                "HAL_ADCEx_Calibration_Start",
                "UART_WaitOnFlagUntilTimeout",
                "HAL_RCC_OscConfig",
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_ADC_PollForConversion",
                "i2c_master_write",
                "uart_debug_write",
                "HAL_RCC_ClockConfig",
                "GetCurrentMilli",
                "i2c_master_read",
                "HAL_UART_Transmit"
            ],
            "imported": false,
            "current_name": "get_uwTick_value_08003760"
        },
        "FUN_08000130": {
            "renaming": {
                "FUN_08000130": "process_completed_items_if_needed_08000130",
                "DAT_08000164": "is_processing_disabled",
                "PTR_completed_8667_08000170": "completed_items_ptr",
                "DAT_08000174": "process_completed_item",
                "PTR_object_8672_0800016c": "object_ptr"
            },
            "code": "void process_completed_items_if_needed_08000130(void)\n{\n  if (DAT_08000164 == 0) {\n    if ((*(int *)PTR_completed_8667_08000170 != 0) && (DAT_08000174 != (code *)0x0)) {\n      DAT_08000174();\n    }\n  }\n  else {\n    if ((*(int *)PTR_completed_8667_08000170 != 0) && (DAT_08000174 != (code *)0x0)) {\n      DAT_08000174(PTR_completed_8667_08000170, PTR_object_8672_0800016c);\n    }\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000130",
            "calling": [],
            "imported": false,
            "current_name": "process_completed_items_if_needed_08000130"
        },
        "FUN_08002798": {
            "renaming": {
                "FUN_08002798": "initializeWireBuffer_08002798",
                "this": "wire",
                "PTR_rxBufferIndex_080027d0": "wire->rxBufferIndex",
                "PTR_rxBufferLength_080027d4": "wire->rxBufferLength",
                "PTR_rxBuffer_080027d8": "wire->rxBuffer",
                "PTR_rxBufferAllocated_080027dc": "wire->rxBufferAllocated",
                "PTR_txBufferIndex_080027e0": "wire->txBufferIndex",
                "PTR_txBufferLength_080027e4": "wire->txBufferLength",
                "PTR_txBuffer_080027e8": "wire->txBuffer",
                "PTR_txBufferAllocated_080027ec": "wire->txBufferAllocated"
            },
            "code": "void __thiscall initializeWireBuffer_08002798(TwoWire *wire) {\n    PTR_rxBufferIndex_080027d0 = 0;\n    PTR_rxBufferLength_080027d4 = 0;\n    if (*(void **)PTR_rxBuffer_080027d8 != (void *)0x0) {\n        memset(*(void **)PTR_rxBuffer_080027d8, 0, (uint)(byte)*PTR_rxBufferAllocated_080027dc);\n    }\n    PTR_txBufferIndex_080027e0 = 0;\n    PTR_txBufferLength_080027e4 = 0;\n    if (*(void **)PTR_txBuffer_080027e8 != (void *)0x0) {\n        memset(*(void **)PTR_txBuffer_080027e8, 0, (uint)(byte)*PTR_txBufferAllocated_080027ec);\n    }\n    return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002798",
            "calling": [],
            "imported": false,
            "current_name": "initializeWireBuffer_08002798"
        },
        "FUN_08009190": {
            "renaming": {
                "FUN_08009190": "allocate_memory_08009190",
                "__size": "size",
                "pvVar1": "allocated_memory",
                "_FUN_08009190_r": "_allocate_memory_r"
            },
            "code": "void * allocate_memory_08009190(size_t size)\n{\n  void *allocated_memory;\n  allocated_memory = (void *)_allocate_memory_08009190_r(*(undefined4 *)PTR__impure_ptr_0800919c,size);\n  return allocated_memory;\n}",
            "called": [
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009190",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009190"
        },
        "FUN_0800242c": {
            "renaming": {
                "FUN_0800242c": "initialize_timer_0800242c",
                "obj": "timer_object",
                "60000": "timer_pulse_init",
                "0x5dc": "pulse_value"
            },
            "code": "void initialize_timer_0800242c(stimer_t *timer_object)\n{\n  int timer_pulse_init = 60000;\n  int pulse_value = 0x5dc;\n  TimerPulseInit((stimer_t_conflict *)timer_object, timer_pulse_init, pulse_value, DAT_08002440);\n  return;\n}",
            "called": [
                "TimerPulseInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800242c",
            "calling": [
                "attach"
            ],
            "imported": false,
            "current_name": "initialize_timer_0800242c"
        },
        "FUN_08002e44": {
            "renaming": {
                "FUN_08002e44": "updateFirmwareVersion_08002e44",
                "this": "firmataInstance",
                "name": "firmwareName",
                "major": "majorVersion",
                "minor": "minorVersion",
                "bVar1": "firmwareVersionLength",
                "pcVar2": "cppPrefix",
                "pcVar3": "lastSlash",
                "pbVar4": "firmwareVersionVector",
                "sVar5": "nameLength"
            },
            "code": "void __thiscall firmata::FirmataClass::updateFirmwareVersion_08002e44(FirmataClass *firmataInstance, char *firmwareName, byte majorVersion, byte minorVersion) {\n  byte firmwareVersionLength;\n  char *cppPrefix = strstr(firmwareName, cppPrefix);\n  char *lastSlash = strrchr(firmwareName, 0x2f);\n  if (lastSlash == NULL) {\n    lastSlash = strrchr(firmwareName, 0x5c);\n  }\n  if (lastSlash != NULL) {\n    firmwareName = lastSlash + 1;\n  }\n  if (cppPrefix == NULL) {\n    firmwareVersionLength = (byte)strlen(firmwareName) + 2;\n  }\n  else {\n    firmwareVersionLength = ((byte)cppPrefix - (byte)firmwareName) + 2;\n  }\n  free(firmataInstance->firmwareVersionVector);\n  byte *firmwareVersionVector = (byte *)malloc(firmwareVersionLength + 1);\n  firmataInstance->firmwareVersionVector = firmwareVersionVector;\n  firmwareVersionVector[firmwareVersionLength] = 0;\n  *firmwareVersionVector = majorVersion;\n  firmwareVersionVector[1] = minorVersion;\n  strncpy((char *)(firmwareVersionVector + 2), firmwareName, firmwareVersionLength - 2);\n  return;\n}",
            "called": [
                "free",
                "strncpy",
                "strstr",
                "strrchr",
                "malloc",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e44",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "updateFirmwareVersion_08002e44"
        },
        "FUN_0800a0a8": {
            "renaming": {
                "<original_function_name>": "FUN_0800a0a8 -> write_to_file",
                "<param_1>": "error_code",
                "<param_2>": "file_descriptor",
                "<param_3>": "buffer",
                "<param_4>": "buffer_size",
                "puVar1": "error_ptr",
                "iVar2": "write_result",
                "FUN_0800a0a8": "write_to_file_0800a0a8"
            },
            "code": "void write_to_file_0800a0a8(int *error_code, int file_descriptor, char *buffer, int buffer_size) {\n                      undefined *error_ptr = PTR_errno_0800a0c8;\n                      *(undefined4 *)PTR_errno_0800a0c8 = 0;\n                      int write_result = _write(file_descriptor, buffer, buffer_size);\n                      if ((write_result == -1) && (*(int *)error_ptr != 0)) {\n                        *error_code = *(int *)error_ptr;\n                      }\n                    }",
            "called": [
                "_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0a8",
            "calling": [
                "__swrite"
            ],
            "imported": false,
            "current_name": "write_to_file_0800a0a8"
        },
        "FUN_08002c00": {
            "renaming": {
                "FUN_08002c00": "readFromSlave_08002c00",
                "this": "wire",
                "address": "address",
                "quantity": "quantity",
                "sendStop": "sendStop",
                "uVar1": "result"
            },
            "code": "uint8_t __thiscall readFromSlave_08002c00(TwoWire *wire, uint8_t address, uint8_t quantity, uint8_t sendStop)\\n{\\n  uint8_t result;\\n  result = readFromSlave_08002c00(wire, address, quantity, 0, \"\\0\", sendStop);\\n  return result;\\n}",
            "called": [
                "requestFrom"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c00",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "readFromSlave_08002c00"
        },
        "FUN_08003f30": {
            "renaming": {
                "FUN_08003f30": "set_interrupt_priority_08003f30",
                "IRQn": "irq",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "uVar1": "irq_bits",
                "uVar2": "priority_group_bits",
                "uVar3": "sub_priority_bits",
                "DAT_08003f8c": "priority_group_address",
                "DAT_08003f90": "interrupt_priority_address"
            },
            "code": "void set_interrupt_priority_08003f30(IRQn_Type_conflict irq, uint32_t preempt_priority, uint32_t sub_priority)\n{\n  uint8_t priority_group_bits = (*((int *)(DAT_08003f8c + 0xc))) << 0x15;\n  uint8_t priority_group = priority_group_bits >> 0x1d;\n  uint8_t sub_priority_bits = 7 - priority_group;\n  if (sub_priority_bits > 3) {\n    sub_priority_bits = 4;\n  }\n  uint8_t preempt_priority_bits = preempt_priority & ((1 << (sub_priority_bits & 0xff)) - 1U);\n  uint8_t sub_priority_mask = (1 << (priority_group & 0xff)) - 1U & sub_priority;\n  uint8_t priority_shift = priority_group < 4 ? 0 : priority_group - 3;\n  uint32_t priority = (preempt_priority_bits << priority_shift) | sub_priority_mask;\n  if ((int)irq < 0) {\n    *(char *)(DAT_08003f90 + (irq & 0xf)) = (char)(priority << 4);\n  }\n  else {\n    *(char *)(irq + 0xe000e400) = (char)(priority << 4);\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f30",
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "HAL_InitTick",
                "TimerPulseInit",
                "SystemClock_Config",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_08003f30"
        },
        "FUN_080073d8": {
            "renaming": {
                "FUN_080073d8": "handle_rtc_alarm_interrupt_080073d8",
                "PTR_RtcHandle_080073e4": "rtc_handle"
            },
            "code": "void handle_rtc_alarm_interrupt_080073d8(void)\n{\n  RTC_HandleTypeDef* PTR_RtcHandle_080073e4 = (RTC_HandleTypeDef*)PTR_RtcHandle_080073e4;\n  HAL_RTC_AlarmIRQHandler(PTR_RtcHandle_080073e4);\n  return;\n}",
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073d8",
            "calling": [],
            "imported": false,
            "current_name": "handle_rtc_alarm_interrupt_080073d8"
        },
        "FUN_080085dc": {
            "renaming": {
                "FUN_080085dc": "is_uart_transmit_complete_080085dc",
                "obj": "serial",
                "HVar1": "uart_state",
                "PTR_uart_handlers_080085fc": "uart_handlers"
            },
            "code": "bool is_uart_transmit_complete_080085dc(serial_t *serial) {\n  UART_HandleTypeDef *uart_handler = *(UART_HandleTypeDef **)(PTR_PTR_uart_handlers_080085fc_080085fc + (uint)serial->index * 4);\n  HAL_UART_StateTypeDef uart_state = HAL_UART_GetState(uart_handler);\n  return (uart_state & (HAL_UART_STATE_BUSY_TX | HAL_UART_STATE_BUSY_TX_RX)) == (HAL_UART_STATE_BUSY_TX | HAL_UART_STATE_BUSY_TX_RX);\n}",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085dc",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "is_uart_transmit_complete_080085dc"
        },
        "FUN_08008ed6": {
            "renaming": {
                "__thiscall Print::FUN_08008ed6": "print_number",
                "this": "printer",
                "n": "number",
                "base": "base",
                "sVar1": "size",
                "FUN_08008ed6Number": "print_number_base",
                "FUN_08008ed6": "print_number_08008ed6"
            },
            "code": "size_t __thiscall print_number_08008ed6(Print *printer, ulong number, int base) {\n  size_t sVar1;\n  if (base != 0) {\n    sVar1 = print_number_08008ed6_base(printer, number, (uint8_t)base);\n    return sVar1;\n  }\n  sVar1 = (**printer->_vptr_Print)(printer, number & 0xff);\n  return sVar1;\n}",
            "called": [
                "printNumber"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ed6",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "print_number_08008ed6"
        },
        "FUN_08008db0": {
            "renaming": {
                "FUN_08008db0": "initialize_static_variables_08008db0"
            },
            "code": "void initialize_static_variables_08008db0(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008db0",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_08008db0"
        },
        "FUN_08002444": {
            "renaming": {
                "FUN_08002444": "updateServo_08002444",
                "obj": "servo_timer",
                "channel": "channel",
                "bVar1": "is_servo_enabled",
                "puVar2": "timer_channel_ptr",
                "uVar3": "timer_counter",
                "iVar4": "servo_offset",
                "uVar5": "servo_index"
            },
            "code": "void updateServo_08002444(stimer_t *servo_timer, uint32_t channel) {\n    bool is_servo_enabled;\n    undefined *timer_channel_ptr;\n    uint servo_index = (uint)servo_timer->idx;\n    timer_channel_ptr = PTR_timerChannel_0800256c;\n    if ((timer_channel_ptr[servo_index] & 0x80) == 0) {\n        int servo_offset = servo_index * 0xc;\n        int servo_position = (char)timer_channel_ptr[servo_index] + servo_offset;\n        if (servo_position < (int)(uint)(byte)*PTR_ServoCount_08002570) {\n            if ((PTR_servos_08002574[servo_position * 8] & 0x40) == 0) {\n                is_servo_enabled = false;\n            }\n            else {\n                is_servo_enabled = true;\n            }\n        }\n        else {\n            is_servo_enabled = false;\n        }\n        if (is_servo_enabled) {\n            digitalWrite((byte)PTR_servos_08002574[servo_position * 8] & 0x3f, 0);\n        }\n    }\n    else {\n        setTimerCounter((stimer_t_conflict *)servo_timer, 0);\n    }\n    timer_channel_ptr[servo_index]++;\n    int servo_offset = servo_index * 0xc;\n    int servo_position = (char)timer_channel_ptr[servo_index] + servo_offset;\n    if (servo_position < (int)(uint)(byte)*PTR_ServoCount_08002570) {\n        if ((char)timer_channel_ptr[servo_index] < '\f') {\n            is_servo_enabled = true;\n        }\n        else {\n            is_servo_enabled = false;\n        }\n    }\n    else {\n        is_servo_enabled = false;\n    }\n    if (is_servo_enabled) {\n        if ((PTR_servos_08002574[servo_position * 8] & 0x40) != 0) {\n            digitalWrite((byte)PTR_servos_08002574[servo_position * 8] & 0x3f, 1);\n        }\n        uint timer_counter = getTimerCounter((stimer_t_conflict *)servo_timer);\n        int servo_offset = servo_index * 0xc;\n        int servo_timing_offset = servo_offset + (char)timer_channel_ptr[servo_index];\n        int servo_timing_data = *(int *)(PTR_servos_08002574 + servo_timing_offset * 8 + 4);\n        setCCRRegister((stimer_t_conflict *)servo_timer, channel, servo_timing_data + timer_counter);\n        return;\n    }\n    uint timer_counter = getTimerCounter((stimer_t_conflict *)servo_timer);\n    if (timer_counter + 4 < 20000) {\n        setCCRRegister((stimer_t_conflict *)servo_timer, channel, 20000);\n    }\n    else {\n        setCCRRegister((stimer_t_conflict *)servo_timer, channel, timer_counter + 4);\n    }\n    timer_channel_ptr[servo_index] = 0xff;\n}",
            "called": [
                "digitalWrite",
                "getTimerCounter",
                "setCCRRegister",
                "setTimerCounter"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002444",
            "calling": [],
            "imported": false,
            "current_name": "updateServo_08002444"
        },
        "FUN_0800906c": {
            "renaming": {
                "FUN_0800906c": "handle_gpio_exti_irq_for_range_of_pins_0800906c",
                "uVar1": "pin_number"
            },
            "code": "void handle_gpio_exti_irq_for_range_of_pins_0800906c(void)\n{\n  uint16_t pin_number;\n  for (pin_number = 0x400; pin_number < 0x8001; pin_number = pin_number << 1) {\n    HAL_GPIO_EXTI_IRQHandler(pin_number);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800906c",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_irq_for_range_of_pins_0800906c"
        },
        "FUN_08003658": {
            "renaming": {
                "FUN_08003658": "initialize_system_08003658",
                "iVar1": "i",
                "puVar2": "completed",
                "UNRECOVERED_JUMPTABLE": "jumptable"
            },
            "code": "void initialize_system_08003658(void)\n{\n  int i = 0;\n  undefined4 *completed = (undefined4 *)PTR_completed_8667_08003698;\n  undefined4 *dso_handle = (undefined4 *)PTR___dso_handle_08003690;\n  code *jumptable = (code *)0x800368a;\n  for (i = 0; dso_handle + i < (undefined4 *)PTR_completed_8667_08003694; i += 4) {\n    *(undefined4 *)(dso_handle + i) = *(undefined4 *)(PTR__sidata_0800368c + i);\n  }\n  for (; completed < (undefined4 *)PTR__ebss_0800369c; completed++) {\n    *completed = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  (*jumptable)();\n  return;\n}",
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003658",
            "calling": [],
            "imported": false,
            "current_name": "initialize_system_08003658"
        },
        "FUN_08009a80": {
            "renaming": {
                "FUN_08009a80": "stream_status_08009a80",
                "param_1": "status",
                "param_2": "stream",
                "iVar3": "impure_ptr",
                "uVar1": "stream_status",
                "uVar2": "stream_flags"
            },
            "code": "uint stream_status_08009a80(uint *status, uint *stream)\n{\n  uint impure_ptr = *(uint *)PTR__impure_ptr_08009b4c;\n  if ((impure_ptr != 0) && (*(uint *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  if (stream == (uint *)PTR___sf_fake_stdin_08009b50) {\n    stream = *(uint **)(impure_ptr + 4);\n  }\n  else if (stream == (uint *)PTR___sf_fake_stdout_08009b54) {\n    stream = *(uint **)(impure_ptr + 8);\n  }\n  else if (stream == (uint *)PTR___sf_fake_stderr_08009b58) {\n    stream = *(uint **)(impure_ptr + 0xc);\n  }\n  ushort stream_flags = *(ushort *)(stream + 3);\n  uint stream_status_08009a80 = (uint)stream_flags;\n  if (-1 < (int)(stream_status_08009a80 << 0x1c)) {\n    if (-1 < (int)(stream_status_08009a80 << 0x1b)) {\n      *status = 9;\n      goto LAB_08009ab0;\n    }\n    if ((uint *)stream[0xd] != (uint *)0x0) {\n      if ((uint *)stream[0xd] != stream + 0x11) {\n        _free_r(status);\n      }\n      stream[0xd] = 0;\n    }\n    *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xffdb;\n    stream[1] = 0;\n    *stream = stream[4];\n  }\n  if ((stream[4] == 0) && ((*(ushort *)(stream + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(status,stream);\n  }\n  stream_flags = *(ushort *)(stream + 3);\n  stream_status_08009a80 = stream_flags & 1;\n  if ((stream_flags & 1) == 0) {\n    if (-1 < (int)((uint)stream_flags << 0x1e)) {\n      stream_status_08009a80 = stream[5];\n    }\n    stream[2] = stream_status_08009a80;\n  }\n  else {\n    stream[2] = 0;\n    stream[6] = -stream[5];\n  }\n  if (stream[4] == 0) {\n    stream_flags = *(ushort *)(stream + 3);\n    stream_status_08009a80 = (int)(short)stream_flags & 0x80;\n    if (stream_status_08009a80 != 0) {\n      *(ushort *)(stream + 3) = stream_flags | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    stream_status_08009a80 = 0;\n  }\n  return stream_status_08009a80;\n}",
            "called": [
                "_free_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009a80",
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "stream_status_08009a80"
        },
        "FUN_080062f4": {
            "renaming": {
                "FUN_080062f4": "disable_TIM_Channel_080062f4",
                "htim": "tim_handle",
                "Channel": "channel",
                "pTVar1": "tim_instance"
            },
            "code": "HAL_StatusTypeDef_conflict disable_TIM_Channel_080062f4(TIM_HandleTypeDef_conflict *htim,uint32_t channel)\n{\n  TIM_TypeDef_conflict *tim_instance;\n  switch(channel) {\n    case 0:\n      htim->Instance->DIER &= 0xfffffffd;\n      break;\n    case 4:\n      htim->Instance->DIER &= 0xfffffffb;\n      break;\n    case 8:\n      htim->Instance->DIER &= 0xfffffff7;\n      break;\n    case 0xc:\n      htim->Instance->DIER &= 0xffffffef;\n  }\n  TIM_CCxChannelCmd(htim->Instance, channel, 0);\n  tim_instance = htim->Instance;\n  if (((tim_instance == TIM1) && ((tim_instance->CCER & 0x1111) == 0)) && ((tim_instance->CCER & 0x444) == 0))\n  {\n    tim_instance->BDTR &= 0xffff7fff;\n  }\n  tim_instance = htim->Instance;\n  if (((tim_instance->CCER & 0x1111) == 0) && ((tim_instance->CCER & 0x444) == 0)) {\n    tim_instance->CR1 &= 0xfffffffe;\n  }\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080062f4",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "disable_TIM_Channel_080062f4"
        },
        "FUN_080073e8": {
            "renaming": {
                "FUN_080073e8": "infiniteLoop_080073e8",
                "msg": "message",
                "val": "value"
            },
            "code": "void infiniteLoop_080073e8(char *message, int value)\n{\n    while (true) {\n        // do nothing\n    }\n}",
            "called": [
                "_Error_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073e8",
            "calling": [
                "_Error_Handler",
                "SystemClock_Config",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "infiniteLoop_080073e8"
        },
        "FUN_0800267c": {
            "renaming": {
                "FUN_0800267c": "update_servo_position_0800267c",
                "this": "servo",
                "value": "position",
                "iVar1": "min_diff",
                "iVar2": "max_diff",
                "PTR_servos_080026ac": "servo_pointer"
            },
            "code": "void __thiscall update_servo_position_0800267c(Servo *servo, int value) {\n  int min_value = servo->min;\n  int max_value = servo->max;\n  int servo_index = servo->servoIndex;\n  if (servo_index < 0xc) {\n    int min_diff = (0x88 - min_value) * 4;\n    int max_diff = (max_value - 600) * 4;\n    if ((min_diff - value == 0 || min_diff < value) &&\n       (max_diff == value || value - max_diff * -1 < 0 != SBORROW4(value,max_diff))) {\n      *(int *)(PTR_servos_080026ac + (uint)servo_index * 8 + 4) = value;\n    }\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800267c",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "update_servo_position_0800267c"
        },
        "FUN_0800376c": {
            "renaming": {
                "FUN_0800376c": "perform_ADC_conversion_0800376c",
                "hadc": "ADC_handle",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_time",
                "pAVar5": "adc_instance",
                "Conversion_Timeout_CPU_cycles": "conversion_timeout_cpu_cycles",
                "PTR_SystemCoreClock_080038c8": "system_core_clock",
                "uVar3": "peripheral_clk_freq",
                "iVar4": "conversion_timeout_cpu_cycles",
                "uVar6": "conversion_timeout_cpu_cycles"
            },
            "code": "HAL_StatusTypeDef_conflict perform_ADC_conversion_0800376c(ADC_HandleTypeDef *hadc, uint32_t timeout)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t start_time = HAL_GetTick();\n  ADC_TypeDef *adc_instance = hadc->Instance;\n  uint32_t conversion_timeout_cpu_cycles = 0;\n  \n  if ((adc_instance->CR2 & ADC_CR2_ADON) == 0) {\n    if (((adc_instance->CR1 & ADC_CR1_EOCIE) == 0) && ((adc_instance->SQR1 & ADC_SQR1_L) == 0)) {\n      do {\n        if ((hadc->Instance->SR & ADC_SR_EOC) != 0) goto conversion_complete;\n      } while ((timeout == 0xffffffff) || ((timeout != 0 && (HAL_GetTick() - start_time <= timeout))));\n      hadc->State = hadc->State | ADC_STATE_TIMEOUT;\n      hadc->Lock = HAL_UNLOCKED;\n      status = HAL_TIMEOUT;\n    }\n    else {\n      uint32_t PTR_SystemCoreClock_080038c8 = *(uint *)PTR_SystemCoreClock_080038c8;\n      uint32_t peripheral_clk_freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);\n      if (((adc_instance->SMPR2 & DAT_080038cc) == 0) &&\n         ((adc_instance->SMPR1 & (DAT_080038cc + 0xdc000000)) == 0)) {\n        if ((adc_instance->SMPR2 & DAT_080038d0) == 0) {\n          if ((adc_instance->SMPR1 & DAT_080038d4) == 0) {\n            conversion_timeout_cpu_cycles = 20;\n          }\n          else {\n            conversion_timeout_cpu_cycles = 41;\n          }\n        }\n        else {\n          conversion_timeout_cpu_cycles = 41;\n        }\n      }\n      else if (((adc_instance->SMPR2 & DAT_080038d0) == 0) &&\n              ((adc_instance->SMPR1 & (DAT_080038d0 + 0xee000000)) == 0)) {\n        conversion_timeout_cpu_cycles = 84;\n      }\n      else if ((DAT_080038d8 & adc_instance->SMPR2) == 0) {\n        if ((DAT_080038d8 & adc_instance->SMPR1) == 0) {\n          conversion_timeout_cpu_cycles = 84;\n        }\n        else {\n          conversion_timeout_cpu_cycles = 252;\n        }\n      }\n      else {\n        conversion_timeout_cpu_cycles = 252;\n      }\n      conversion_timeout_cpu_cycles = (PTR_SystemCoreClock_080038c8 / peripheral_clk_freq) * conversion_timeout_cpu_cycles;\n      for (; conversion_timeout_cpu_cycles <= conversion_timeout_cpu_cycles && conversion_timeout_cpu_cycles - conversion_timeout_cpu_cycles != 0;\n          conversion_timeout_cpu_cycles = conversion_timeout_cpu_cycles + 1) {\n        if ((timeout != 0xffffffff) &&\n           ((timeout == 0 || (HAL_GetTick() - start_time > timeout)))) {\n          hadc->State = hadc->State | ADC_STATE_TIMEOUT;\n          hadc->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nconversion_complete:\n      adc_instance->SR = 0xffffffed;\n      hadc->State = hadc->State | ADC_STATE_READY;\n      if ((adc_instance->CR2 & ADC_CR2_CONT) == ADC_CR2_CONT) {\n        if ((hadc->Init).ContinuousConvMode == 0) {\n          hadc->State = hadc->State & ~ADC_STATE_REG_EOC;\n          if ((hadc->State & ADC_STATE_INJ_EOC) == 0) {\n            hadc->State = hadc->State | ADC_STATE_REG_EOC;\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        status = HAL_OK;\n      }\n    }\n  }\n  else {\n    hadc->State = hadc->State | ADC_STATE_ERROR_INTERNAL;\n    hadc->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800376c",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "perform_ADC_conversion_0800376c"
        },
        "FUN_08003e20": {
            "renaming": {
                "FUN_08003e20": "perform_ADC_conversion_08003e20",
                "hadc": "adc_handle",
                "HVar1": "status",
                "uVar2": "clock_freq_divisor",
                "uVar3": "current_time",
                "pAVar4": "adc_instance",
                "uVar5": "wait_loop_index"
            },
            "code": "HAL_StatusTypeDef_conflict perform_ADC_conversion_08003e20(ADC_HandleTypeDef *adc_handle)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t clock_freq_divisor;\n  ADC_TypeDef *adc_instance;\n  uint32_t wait_loop_index;\n  \n  if (adc_handle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  adc_handle->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(adc_handle);\n  if (status == HAL_OK) {\n    adc_handle->State = adc_handle->State & 0xffffeefd | 2;\n    clock_freq_divisor = *(uint *)PTR_SystemCoreClock_08003f08 / HAL_RCCEx_GetPeriphCLKFreq(2) << 1;\n    for (wait_loop_index = clock_freq_divisor; wait_loop_index != 0; wait_loop_index--) {\n    }\n    ADC_Enable(adc_handle);\n    adc_instance = adc_handle->Instance;\n    adc_instance->CR2 = adc_instance->CR2 | 8;\n    uint32_t start_time = HAL_GetTick();\n    while ((adc_instance->CR2 & 8) != 0) {\n      uint32_t current_time = HAL_GetTick();\n      if (current_time - start_time > 10) {\n        adc_handle->State = adc_handle->State & 0xffffffed | 0x10;\n        adc_handle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adc_instance->CR2 = adc_instance->CR2 | 4;\n    start_time = HAL_GetTick();\n    while ((adc_handle->Instance->CR2 & 4) != 0) {\n      uint32_t current_time = HAL_GetTick();\n      if (current_time - start_time > 10) {\n        adc_handle->State = adc_handle->State & 0xffffffed | 0x10;\n        adc_handle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adc_handle->State = adc_handle->State & 0xfffffffc | 1;\n  }\n  adc_handle->Lock = HAL_UNLOCKED;\n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "ADC_ConversionStop_Disable",
                "ADC_Enable",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003e20",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "perform_ADC_conversion_08003e20"
        },
        "FUN_08002c14": {
            "renaming": {
                "FUN_08002c14": "readFrom_08002c14",
                "this": "self",
                "address": "deviceAddress",
                "quantity": "quantity",
                "uVar1": "success"
            },
            "code": "uint8_t __thiscall TwoWire::readFrom_08002c14(uint8_t deviceAddress, uint8_t quantity)\n{\n  uint8_t success;\n  success = readFrom_08002c14(deviceAddress, quantity, '\\x01');\n  return success;\n}",
            "called": [
                "requestFrom"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c14",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "readFrom_08002c14"
        },
        "FUN_08009084": {
            "renaming": {
                "__thiscall std::function<void()>::operator__": "executeFunction",
                "this": "thisPtr",
                "function_void___ *this": "functionPtr",
                "super__Function_base": "functionBase",
                "_M_manager": "manager",
                "_M_invoker": "invoker",
                "_Any_data": "data",
                "__throw_bad_function_call": "throwBadFunctionCall",
                "FUN_08009084": "executeFunction_08009084"
            },
            "code": "void __thiscall executeFunction_08009084(void)::operator()(function_void___ *functionPtr) {\n  if ((functionPtr->functionBase)._M_manager != (_Manager_type)0x0) {\n    (*functionPtr->invoker)((_Any_data *)functionPtr);\n    return;\n  }\n  __throw_bad_function_call();\n}",
            "called": [
                "__throw_bad_function_call"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009084",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "executeFunction_08009084"
        },
        "FUN_08005840": {
            "renaming": {
                "FUN_08005840": "calculate_result_08005840",
                "uVar1": "result",
                "uVar2": "data6",
                "local_1c": "data4",
                "abStack_18": "data5",
                "uStack_14": "data3",
                "uStack_10": "data2",
                "uStack_c": "data1"
            },
            "code": "uint calculate_result_08005840(void)\n{\n  uint result = 0;\n  uint data1 = *(uint *)(PTR__etext_0800589c + 8);\n  uint data2 = *(uint *)(PTR__etext_0800589c + 4);\n  uint data3 = *(uint *)PTR__etext_0800589c;\n  uint data4 = *(uint *)(PTR__etext_0800589c + 0x10);\n  byte data5[4];\n  data5[0] = *(byte *)(data2 << 10 >> 0x1c);\n  uint data6 = *(uint *)(DAT_080058a0 + 4);\n  uint data7 = DAT_080058a8;\n  if ((data6 & 0xc) == 8) {\n    if ((data6 & 0x10000) == 0) {\n      result = DAT_080058a4 * (uint)data5[0];\n    }\n    else {\n      result = (DAT_080058a8 * data5[0]) / (uint)*(byte *)((int)&data4 - ((*(int *)(DAT_080058a0 + 4) << 0xe) >> 0x1f));\n    }\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005840",
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "calculate_result_08005840"
        },
        "FUN_08003306": {
            "renaming": {
                "FUN_08003306": "parseCommand_08003306",
                "command": "commandByte",
                "newFunction": "callback",
                "context": "callbackContext",
                "currentReportDigitalCallback": "digitalReportCallback",
                "currentReportDigitalCallbackContext": "digitalReportCallbackContext",
                "PIN_MODE_RESPONSE_COMMAND": "pinModeResponseCommand",
                "currentPinModeCallback": "pinModeCallback",
                "currentPinModeCallbackContext": "pinModeCallbackContext",
                "PIN_VALUE_RESPONSE_COMMAND": "pinValueResponseCommand",
                "currentPinValueCallback": "pinValueCallback",
                "currentPinValueCallbackContext": "pinValueCallbackContext",
                "ANALOG_REPORT_COMMAND": "analogReportCommand",
                "currentAnalogCallback": "analogCallback",
                "currentAnalogCallbackContext": "analogCallbackContext",
                "DIGITAL_MESSAGE_COMMAND": "digitalMessageCommand",
                "currentDigitalCallback": "digitalCallback",
                "currentDigitalCallbackContext": "digitalCallbackContext",
                "ANALOG_REPORT_ENABLE_COMMAND": "analogReportEnableCommand",
                "currentReportAnalogCallback": "analogReportCallback",
                "currentReportAnalogCallbackContext": "analogReportCallbackContext"
            },
            "code": "void __thiscall firmata::FirmataParser::parseCommand_08003306(FirmataParser *this, uint8_t command, callbackFunction newFunction, void *context) {\n  if (command == DIGITAL_REPORT_COMMAND) {\n    this->currentReportDigitalCallback = newFunction;\n    this->currentReportDigitalCallbackContext = context;\n    return;\n  }\n  if (command > DIGITAL_REPORT_COMMAND) {\n    if (command == PIN_MODE_RESPONSE_COMMAND) {\n      this->currentPinModeCallback = newFunction;\n      this->currentPinModeCallbackContext = context;\n      return;\n    }\n    if (command == PIN_VALUE_RESPONSE_COMMAND) {\n      this->currentPinValueCallback = newFunction;\n      this->currentPinValueCallbackContext = context;\n    }\n    else if (command == ANALOG_REPORT_COMMAND) {\n      this->currentAnalogCallback = newFunction;\n      this->currentAnalogCallbackContext = context;\n      return;\n    }\n    return;\n  }\n  if (command == DIGITAL_MESSAGE_COMMAND) {\n    this->currentDigitalCallback = newFunction;\n    this->currentDigitalCallbackContext = context;\n    return;\n  }\n  if (command == ANALOG_REPORT_ENABLE_COMMAND) {\n    this->currentReportAnalogCallback = newFunction;\n    this->currentReportAnalogCallbackContext = context;\n    return;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003306",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "parseCommand_08003306"
        },
        "FUN_08002578": {
            "renaming": {
                "FUN_08002578": "deinitialize_timer_08002578",
                "obj": "timer_object"
            },
            "code": "void deinitialize_timer_08002578(stimer_t *timer_object) {\n  TimerPulseDeinit((stimer_t_conflict *)timer_object);\n  return;\n}",
            "called": [
                "TimerPulseDeinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002578",
            "calling": [
                "detach"
            ],
            "imported": false,
            "current_name": "deinitialize_timer_08002578"
        },
        "FUN_08006932": {
            "renaming": {
                "FUN_08006932": "set_uart_to_ready_state_08006932",
                "*huart": "*uart_handle",
                "Instance": "uart_handle->Instance",
                "CR1": "uart_handle->Instance->CR1",
                "gState": "uart_handle->gState",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_UART_TxCpltCallback": "HAL_UART_TxCpltCallback",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef set_uart_to_ready_state_08006932(UART_HandleTypeDef *uart_handle)\n{\n  uart_handle->Instance->CR1 &= ~(1 << 6);\n  uart_handle->gState = HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(uart_handle);\n  return HAL_OK;\n}",
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006932",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_uart_to_ready_state_08006932"
        },
        "FUN_080060c4": {
            "renaming": {
                "FUN_080060c4": "configure_timer_080060c4",
                "TIMx": "timer",
                "OC_Config": "oc_config",
                "uVar1": "cc_enable_value",
                "uVar2": "cr2_register_value",
                "uVar3": "oc_mode_value",
                "cc_enable_mask": "cc_enable_mask",
                "DAT_08006124": "PTR_08006124"
            },
            "code": "void configure_timer_080060c4(TIM_TypeDef_conflict *timer, TIM_OC_InitTypeDef *oc_config)\n{\n  uint32_t cc_enable_mask = 0xffffffef;\n  uint32_t cr2_register_value = timer->CR2;\n  uint32_t oc_mode_value = oc_config->OCMode;\n  uint32_t cc_enable_value = (timer->CCER & 0xffffffdf) | (oc_config->OCPolarity << 4);\n  if (timer == DAT_08006124) {\n    cc_enable_value = (cc_enable_value & 0xffffff7f) | (oc_config->OCNPolarity << 4);\n    cr2_register_value = (cr2_register_value & 0xfffff3ff) | (oc_config->OCIdleState << 2) | (oc_config->OCNIdleState << 2);\n  }\n  timer->CR2 = cr2_register_value;\n  timer->CCMR1 = (timer->CCMR1 & 0xffff8cff) | (oc_mode_value << 8);\n  timer->CCR2 = oc_config->Pulse;\n  timer->CCER = cc_enable_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080060c4",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_080060c4"
        },
        "FUN_08009eac": {
            "renaming": {
                "FUN_08009eac": "process_data_08009eac",
                "param_1": "data_length",
                "param_2": "data_array",
                "local_18": "processed_length",
                "local_14": "processed_data_array",
                "uVar1": "flags",
                "iVar2": "allocated_data",
                "DAT_08009f28": "DATA_FLAG"
            },
            "code": "void process_data_08009eac(int data_length, int *data_array)\n{\n  ushort flags;\n  int processed_length;\n  int *processed_data_array;\n  \n  if (-1 < (int)((uint)*(ushort *)(data_array + 3) << 0x1e))) {\n    processed_length = data_length;\n    processed_data_array = data_array;\n    flags = __process_data_08009eac_buffer(processed_length, processed_data_array, &processed_length, &processed_data_array);\n    int *allocated_data = _malloc_r(data_length, processed_length);\n    if (allocated_data != 0) {\n      *(undefined4 *)(data_length + 0x28) = DAT_08009f28;\n      *data_array = allocated_data;\n      *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) | 0x80;\n      data_array[4] = allocated_data;\n      data_array[5] = processed_length;\n      if ((processed_data_array != (int *)0x0) && (_is_terminal_r(data_length, (int)*(short *)((int)data_array + 0xe)) != 0)) {\n        *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(data_array + 3) = flags | *(ushort *)(data_array + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(data_array + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) & 0xfffc | 2;\n  }\n  *data_array = (int)data_array + 0x47;\n  data_array[4] = (int)data_array + 0x47;\n  data_array[5] = 1;\n  return;\n}",
            "called": [
                "_isatty_r",
                "__swhatbuf_r",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009eac",
            "calling": [
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "process_data_08009eac"
        },
        "FUN_08008dbe": {
            "renaming": {
                "FUN_08008dbe": "printAddress_08008dbe",
                "this": "ipAddress",
                "p": "printer",
                "iVar3": "i",
                "iVar4": "totalPrinted",
                "sVar1": "printed",
                "sVar2": "dotPrinted"
            },
            "code": "size_t __thiscall IPAddress::printAddress_08008dbe(Print *printer)\n{\n  size_t totalPrinted = 0;\n  for (int i = 0; i < 3; i++) {\n    size_t printed = Print::print(printer, (this->_address).bytes[i], 10);\n    totalPrinted += printed + Print::print(printer, '.', 10);\n  }\n  totalPrinted += Print::print(printer, (this->_address).bytes[3], 10);\n  return totalPrinted;\n}",
            "called": [
                "print",
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008dbe",
            "calling": [],
            "imported": false,
            "current_name": "printAddress_08008dbe"
        },
        "FUN_080072d8": {
            "renaming": {
                "FUN_080072d8": "set_gpio_pin_state_080072d8",
                "port": "gpio_port",
                "pin": "gpio_pin",
                "val": "gpio_pin_state"
            },
            "code": "void set_gpio_pin_state_080072d8(GPIO_TypeDef *gpio_port, uint32_t gpio_pin, uint32_t gpio_pin_state) {\n  if (gpio_pin_state == 0) {\n    HAL_GPIO_WritePin(gpio_port, (uint16_t)gpio_pin, GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpio_port, (uint16_t)gpio_pin, GPIO_PIN_SET);\n  return;\n}",
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072d8",
            "calling": [
                "digitalWrite"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_080072d8"
        },
        "FUN_08002b00": {
            "renaming": {
                "TwoWire::FUN_08002b00": "receiveData",
                "*inBytes": "data",
                "numBytes": "numBytes",
                "PTR_user_onReceive_08002b54": "userOnReceive",
                "PTR_rxBufferLength_08002b5c": "rxBufferLength",
                "PTR_rxBufferIndex_08002b58": "rxBufferIndex",
                "allocateRxBuffer": "allocateRxBuffer",
                "PTR_rxBuffer_08002b60": "rxBuffer",
                "_Error_Handler": "_Error_Handler",
                "FUN_08002b00": "receiveData_08002b00"
            },
            "code": "void receiveData_08002b00(uint8_t *data, int numBytes) {\n  int *PTR_user_onReceive_08002b54 = (int *)PTR_user_onReceive_08002b54;\n  char *PTR_PTR_rxBuffer_08002b60Length_08002b5c = (char *)PTR_PTR_PTR_rxBuffer_08002b60Length_08002b5c_08002b5c;\n  char *PTR_PTR_rxBuffer_08002b60Index_08002b58 = (char *)PTR_PTR_PTR_rxBuffer_08002b60Index_08002b58_08002b58;\n  void **PTR_rxBuffer_08002b60 = (void **)PTR_PTR_rxBuffer_08002b60_08002b60;\n\n  if (*PTR_user_onReceive_08002b54 != 0 && *PTR_PTR_rxBuffer_08002b60Length_08002b5c <= *PTR_PTR_rxBuffer_08002b60Index_08002b58) {\n    allocateRxBuffer(numBytes);\n    if (*PTR_rxBuffer_08002b60 == 0) {\n      _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08002b64, 0x183);\n    }\n    memcpy(*PTR_rxBuffer_08002b60, data, numBytes);\n    *PTR_PTR_rxBuffer_08002b60Index_08002b58 = 0;\n    *PTR_PTR_rxBuffer_08002b60Length_08002b5c = (char)numBytes;\n    (*(void (*)(int))(*PTR_user_onReceive_08002b54))(numBytes);\n  }\n}\n",
            "called": [
                "_Error_Handler",
                "memcpy",
                "allocateRxBuffer"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002b00",
            "calling": [],
            "imported": false,
            "current_name": "receiveData_08002b00"
        },
        "FUN_08002f84": {
            "renaming": {
                "FUN_08002f84": "setSystemResetCallback_08002f84",
                "PTR_currentSystemResetCallback_08002f90": "currentSystemResetCallback",
                "command": "command",
                "newFunction": "newFunction"
            },
            "code": "void __thiscall firmata::FirmataClass::setSystemResetCallback_08002f84(FirmataClass *this,uint8_t command,systemCallbackFunction newFunction)\n{\n  if (command == 0xff) {\n    *(systemCallbackFunction *)PTR_currentSystemResetCallback_08002f90 = newFunction;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f84",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "setSystemResetCallback_08002f84"
        },
        "FUN_08009094": {
            "renaming": {
                "FUN_08009094": "handle_gpio_interrupt_08009094",
                "GPIO_Pin": "pin",
                "bVar1": "pin_id",
                "PTR_gpio_irq_conf_080090b0": "gpio_irq_conf"
            },
            "code": "void handle_gpio_interrupt_08009094(uint16_t pin)\n{\n  uint8_t pin_id = get_pin_id(pin);\n  if (*(int *)(PTR_gpio_irq_conf_080090b0 + (uint)pin_id * 0x14 + 0xc) != 0) {\n    std::function<void()>::operator__\n              ((function_void___ *)(PTR_gpio_irq_conf_080090b0 + (uint)pin_id * 0x14 + 4));\n  }\n  return;\n}",
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009094",
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_gpio_interrupt_08009094"
        },
        "FUN_0800a0cc": {
            "renaming": {
                "FUN_0800a0cc": "close_file_and_handle_error_0800a0cc",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "puVar1": "error_ptr",
                "iVar2": "close_result"
            },
            "code": "void close_file_and_handle_error_0800a0cc(int *error_code, int file_descriptor) \\n\\\n    {\\n\\\n        undefined *error_ptr = PTR_errno_0800a0e8;\\n\\\n        *(undefined4 *)PTR_errno_0800a0e8 = 0;\\n\\\n        int close_result = _close(file_descriptor);\\n\\\n        if ((close_result == -1) && (*(int *)error_ptr != 0))\\n\\\n        {\\n\\\n            *error_code = *(int *)error_ptr;\\n\\\n        }\\n\\\n        return;\\n\\\n    }",
            "called": [
                "_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0cc",
            "calling": [
                "__sclose"
            ],
            "imported": false,
            "current_name": "close_file_and_handle_error_0800a0cc"
        },
        "FUN_08002580": {
            "renaming": {
                "FUN_08002580::FUN_08002580": "initializeServo",
                "this": "servo",
                "bVar1": "servo_count",
                "FUN_08002580": "initializeServo_08002580"
            },
            "code": "initializeServo_08002580* __thiscall initializeServo_08002580(initializeServo_08002580* servo) {\n  byte servo_count = *PTR_initializeServo_08002580Count_080025a4;\n  if (servo_count > 11) {\n    servo->servoIndex = 0xff;\n    return servo;\n  }\n  *PTR_initializeServo_08002580Count_080025a4 = servo_count + 1;\n  servo->servoIndex = servo_count;\n  *(undefined4 *)(PTR_servos_080025a8 + (uint)servo_count * 8 + 4) = 0x5dc;\n  return servo;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002580",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initializeServo_08002580"
        },
        "FUN_080073ec": {
            "renaming": {
                "FUN_080073ec": "set_bit_and_mask_080073ec",
                "DAT_0800742c": "data",
                "DAT_08007430": "mask"
            },
            "code": "void set_bit_and_mask_080073ec(uint* DAT_0800742c)\n{\n  uint* ptr_DAT_0800742c = DAT_0800742c;\n  *ptr_DAT_0800742c |= 0x1;\n  ptr_DAT_0800742c[1] &= 0xffffff00;\n  *ptr_DAT_0800742c &= 0xfef6ffff;\n  *ptr_DAT_0800742c &= 0xfffbffff;\n  ptr_DAT_0800742c[1] &= 0xff80ffff;\n  ptr_DAT_0800742c[2] = 0x9f0000;\n  *(uint*)(DAT_0800742c + 0x8) = 0x8000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073ec",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "set_bit_and_mask_080073ec"
        },
        "FUN_08008ef4": {
            "renaming": {
                "FUN_08008ef4": "map_value_08008ef4",
                "x": "input_value",
                "in_min": "input_min",
                "in_max": "input_max",
                "out_min": "output_min",
                "out_max": "output_max",
                "(uint)": "(uint32_t)",
                "(uint32_t)": "(uint32_t)"
            },
            "code": "uint32_t map_value_08008ef4(uint32_t input_value, uint32_t input_min, uint32_t input_max, uint32_t output_min, uint32_t output_max) {\n    uint32_t input_range = input_max - input_min;\n    uint32_t output_range = output_max - output_min;\n    uint32_t scaled_value = (input_value - input_min) * output_range;\n    uint32_t mapped_value = (scaled_value + output_min * input_range) / input_range;\n    return mapped_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ef4",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "map_value_08008ef4"
        },
        "FUN_08009fe8": {
            "renaming": {
                "FUN_08009fe8": "signal_handler_08009fe8",
                "__sig": "signal_number",
                "iVar1": "return_value",
                "_FUN_08009fe8_r": "_signal_handler_r"
            },
            "code": "int signal_handler_08009fe8(int signal_number) {\n  int return_value;\n  return_value = _signal_handler_08009fe8_r(*(undefined4 *)PTR__impure_ptr_08009ff4, signal_number);\n  return return_value;\n}",
            "called": [
                "_raise_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009fe8",
            "calling": [
                "abort"
            ],
            "imported": false,
            "current_name": "signal_handler_08009fe8"
        },
        "FUN_08002c1e": {
            "renaming": {
                "FUN_08002c1e": "initialize_static_variables_08002c1e"
            },
            "code": "void initialize_static_variables_08002c1e(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c1e",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_08002c1e"
        },
        "FUN_08002f94": {
            "renaming": {
                "FUN_08002f94": "set_sysex_callback_08002f94",
                "this": "firmata_instance",
                "command": "command",
                "newFunction": "new_callback",
                "PTR_currentSysexCallback_08002f9c": "current_sysex_callback"
            },
            "code": "void set_sysex_callback_08002f94(FirmataClass *firmata_instance, uint8_t command, sysexCallbackFunction new_callback) {\n  *(sysexCallbackFunction *)PTR_currentSysexCallback_08002f9c = new_callback;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f94",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "set_sysex_callback_08002f94"
        },
        "FUN_08008eec": {
            "renaming": {
                "FUN_08008eec": "printChar_08008eec",
                "this": "printObj",
                "b": "character",
                "base": "base",
                "sVar1": "size"
            },
            "code": "size_t __thiscall Print::printChar_08008eec(Print *printObj, uchar character, int base) {\n  size_t size;\n  size = printChar_08008eec(printObj, (uint)character, base);\n  return size;\n}",
            "called": [
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008eec",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "printChar_08008eec"
        },
        "FUN_08001b48": {
            "renaming": {
                "FUN_08001b48": "initializeFirmata_08001b48",
                "this": "firmata"
            },
            "code": "void initializeFirmata_08001b48(void)\n{\n  FirmataClass *firmata = (FirmataClass *)PTR_Firmata_08001bc0;\n  firmata->setFirmwareNameAndVersion(PTR_Firmata_08001bc0, PTR_s__home_bo_p2im_p2im_real_firmware_08001bc4, 2, 5);\n  firmata->attach(firmata, 0xe0, DAT_08001bc8);\n  firmata->attach(firmata, 0x90, DAT_08001bcc);\n  firmata->attach(firmata, 0xc0, DAT_08001bd0);\n  firmata->attach(firmata, 0xd0, DAT_08001bd4);\n  firmata->attach(firmata, 0xf4, DAT_08001bd8);\n  firmata->attach(firmata, 0xf5, DAT_08001bdc);\n  firmata->attach(firmata, 0xf0, DAT_08001be0);\n  firmata->attach(firmata, 0xff, DAT_08001be4);\n  firmata->begin(0xe100);\n  systemResetCallback();\n  startForkserver(0);\n  return;\n}",
            "called": [
                "begin",
                "startForkserver",
                "attach",
                "attach",
                "setFirmwareNameAndVersion",
                "attach",
                "systemResetCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001b48",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initializeFirmata_08001b48"
        },
        "FUN_08005df4": {
            "renaming": {
                "FUN_08005df4": "reset_tim_08005df4",
                "htim": "tim_handle",
                "TIM_HandleTypeDef_conflict": "TIM_handle_conflict",
                "TIM_TypeDef_conflict": "TIM_type_def_conflict",
                "pTVar1": "tim_instance",
                "HAL_TIM_STATE_BUSY": "TIM_state_busy",
                "CCER": "capture_compare_enable_register",
                "CR1": "control_register_1",
                "HAL_TIM_STATE_RESET": "TIM_state_reset",
                "HAL_UNLOCKED": "TIM_lock_unlocked",
                "HAL_TIM_OC_MspDeInit": "TIM_OC_MspDeInit",
                "HAL_StatusTypeDef_conflict": "HAL_status_type_def_conflict",
                "HAL_OK": "HAL_ok"
            },
            "code": "HAL_StatusTypeDef_conflict reset_tim_08005df4(TIM_HandleTypeDef_conflict *htim)\n{\n  TIM_TypeDef_conflict *tim_instance;\n  htim->State = HAL_TIM_STATE_BUSY;\n  tim_instance = htim->Instance;\n  if (((tim_instance->CCER & 0x1111) == 0) && ((tim_instance->CCER & 0x444) == 0)) {\n    tim_instance->CR1 = tim_instance->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_OC_MspDeInit(htim);\n  htim->State = HAL_TIM_STATE_RESET;\n  htim->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}",
            "called": [
                "HAL_TIM_OC_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005df4",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "reset_tim_08005df4"
        },
        "FUN_08009148": {
            "renaming": {
                "FUN_08009148": "execute_functions_and_initializers_08009148",
                "puVar1": "preinit_array_end",
                "iVar2": "preinit_array_size",
                "iVar3": "i",
                "dtors_array_end": "dtors_array_end",
                "dtors_array_size": "dtors_array_size"
            },
            "code": "void execute_functions_and_initializers_08009148(void)\n{\n  undefined *preinit_array_end = PTR___preinit_array_end_08009180;\n  int preinit_array_size = (int)PTR___preinit_array_end_08009184 - (int)PTR___preinit_array_end_08009180;\n  for (int i = 0; i < preinit_array_size / 4; i++) {\n    (**(code **)(preinit_array_end + i * 4))();\n  }\n  _init();\n  undefined *dtors_array_end = PTR___preinit_array_end_08009188;\n  int dtors_array_size = (int)PTR___do_global_dtors_aux_fini_array_entry_0800918c - (int)PTR___preinit_array_end_08009188;\n  for (int i = 0; i < dtors_array_size / 4; i++) {\n    (**(code **)(dtors_array_end + i * 4))();\n  }\n  return;\n}",
            "called": [
                "premain",
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009148",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "execute_functions_and_initializers_08009148"
        },
        "FUN_080099dc": {
            "renaming": {
                "FUN_080099dc": "encode_string_080099dc",
                "param_1": "input_length",
                "param_2": "input_char",
                "param_3": "stream",
                "param_4": "param_4",
                "iVar1": "initial_stream_pos",
                "uVar2": "char_code",
                "puVar3": "current_pos"
            },
            "code": "uint encode_string_080099dc(int input_length, uint input_char, int *stream, undefined4 param_4)\n{\n  int initial_stream_pos;\n  uint char_code;\n  undefined *current_pos;\n  \n  if ((input_length != 0) && (*(int *)(input_length + 0x18) == 0)) {\n    initialize_stream();\n  }\n  \n  if (stream == (int *)PTR___sf_fake_stdin_08009a74) {\n    stream = *(int **)(input_length + 4);\n  }\n  else if (stream == (int *)PTR___sf_fake_stdout_08009a78) {\n    stream = *(int **)(input_length + 8);\n  }\n  else if (stream == (int *)PTR___sf_fake_stderr_08009a7c) {\n    stream = *(int **)(input_length + 0xc);\n  }\n  \n  stream[2] = stream[6];\n  char_code = (uint)*(ushort *)(stream + 3);\n  initial_stream_pos = char_code << 0x1c;\n  \n  if (((initial_stream_pos < 0) && (char_code = stream[4], char_code != 0)) ||\n     (initial_stream_pos = __swsetup_r(input_length,stream,initial_stream_pos,char_code,param_4), initial_stream_pos == 0)) {\n    input_char = input_char & 0xff;\n    initial_stream_pos = *stream - stream[4];\n    if ((initial_stream_pos < stream[5]) || (initial_stream_pos = _fflush_r(input_length,stream), initial_stream_pos == 0)) {\n      stream[2] = stream[2] + -1;\n      current_pos = (undefined *)*stream;\n      *stream = (int)(current_pos + 1);\n      *current_pos = (char)input_char;\n      if (initial_stream_pos + 1 != stream[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return input_char;\n        }\n        if (input_char != 10) {\n          return input_char;\n        }\n      }\n      initial_stream_pos = _fflush_r(input_length,stream);\n      if (initial_stream_pos == 0) {\n        return input_char;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080099dc",
            "calling": [
                "__sfputc_r"
            ],
            "imported": false,
            "current_name": "encode_string_080099dc"
        },
        "FUN_08000c18": {
            "renaming": {
                "FUN_08000c18": "FUNC_08000c18"
            },
            "code": "\nvoid FUNC_08000c18(byte port,int value)\n\n{\n  byte bVar1;\n  bool bVar2;\n  uint32_t uVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte portValue;\n  \n  uVar6 = (uint)port;\n  if ((uVar6 < 5) && (PTR_reportPINs_08000ebc[uVar6] = (char)value, value != 0)) {\n    bVar1 = PTR_portConfigInputs_08000ec0[uVar6];\n    uVar6 = (uVar6 & 0x1f) * 8;\n    if (uVar6 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar6] == NC) {\n        portValue = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n        if (uVar3 == 0) {\n          portValue = 0;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n          if (uVar3 == 1) {\n            portValue = 0;\n          }\n          else if ((bVar1 & 1) == 0) {\n            portValue = 0;\n          }\n          else {\n            iVar4 = digitalRead(uVar6);\n            if (iVar4 == 0) {\n              portValue = 0;\n            }\n            else {\n              portValue = 1;\n            }\n          }\n        }\n      }\n    }\n    else {\n      portValue = 0;\n    }\n    uVar5 = uVar6 + 1;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 2) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 2;\n    }\n    uVar5 = uVar6 + 2;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 4) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 4;\n    }\n    uVar5 = uVar6 + 3;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 8) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 8;\n    }\n    uVar5 = uVar6 + 4;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x10) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x10;\n    }\n    uVar5 = uVar6 + 5;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x20) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x20;\n    }\n    uVar5 = uVar6 + 6;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x40) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x40;\n    }\n    uVar6 = uVar6 + 7;\n    if (uVar6 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar6] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x80) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar6);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x80;\n    }\n    outputPort(port,portValue,'\\x01');\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "digitalRead",
                "pinNametoDigitalPin",
                "outputPort"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000c18",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_08000c18"
        },
        "FUN_08009024": {
            "renaming": {
                "FUN_08009024": "handle_gpio_interrupt_08009024",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void handle_gpio_interrupt_08009024(void)\n{\n  const int gpio_pin = 1;\n  HAL_GPIO_EXTI_IRQHandler(gpio_pin);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009024",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_interrupt_08009024"
        },
        "FUN_080064cc": {
            "renaming": {
                "FUN_080064cc": "send_data_080064cc",
                "huart": "uart",
                "uVar1": "data_length",
                "pbVar2": "buffer_pointer"
            },
            "code": "HAL_StatusTypeDef send_data_080064cc(UART_HandleTypeDef *uart)\n{\n  uint16_t data_length;\n  byte *buffer_pointer;\n  \n  if (uart->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  \n  data_length = (uart->Init).WordLength;\n  if (data_length == 0x1000) {\n    uint16_t *data_pointer = (uint16_t *)uart->pTxBuffPtr;\n    uint16_t data = *data_pointer & 0x1ff;\n    if ((uart->Init).Parity == 0) {\n      uart->pTxBuffPtr = (byte *)data_pointer + 2;\n    }\n    else {\n      uart->pTxBuffPtr = (byte *)data_pointer + 1;\n    }\n    uart->Instance->DR = data;\n  }\n  else {\n    buffer_pointer = uart->pTxBuffPtr;\n    uart->pTxBuffPtr = buffer_pointer + 1;\n    uart->Instance->DR = (uint)*buffer_pointer;\n  }\n  \n  data_length = uart->TxXferCount - 1;\n  uart->TxXferCount = data_length;\n  if (data_length == 0) {\n    uart->Instance->CR1 &= 0xffffff7f;\n    uart->Instance->CR1 |= 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064cc",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "send_data_080064cc"
        },
        "FUN_08008058": {
            "renaming": {
                "FUN_08008058": "handle_I2C_event_08008058",
                "PTR_i2c_handles_08008064": "i2c_handles",
                "I2C_HandleTypeDef_conflict": "I2C_Handle",
                "current_handle": "current_I2C_Handle"
            },
            "code": "void handle_I2C_event_08008058(void)\n{\n  I2C_HandleTypeDef_conflict **PTR_i2c_handles_08008064 = PTR_PTR_i2c_handles_08008064_08008064;\n  I2C_HandleTypeDef_conflict *current_handle = *(PTR_i2c_handles_08008064 + 4);\n  HAL_I2C_EV_IRQHandler(current_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008058",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_event_08008058"
        },
        "FUN_08004ac2": {
            "renaming": {
                "FUN_08004ac2": "check_address_match_08004ac2",
                "hi2c": "i2c_handle",
                "AddrMatchCode": "address_code",
                "OwnAddress1": "own_address_1",
                "OwnAddress2": "own_address_2"
            },
            "code": "HAL_StatusTypeDef_conflict check_address_match_08004ac2(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  uint16_t address_code;\n  if ((i2c_handle->Instance->SR2 & 0x80) == 0) {\n    address_code = *(uint16_t *)&(i2c_handle->Init).OwnAddress1;\n  }\n  else {\n    address_code = *(uint16_t *)&(i2c_handle->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2c_handle, (i2c_handle->Instance->SR2 & 4) == 0, address_code);\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ac2",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "check_address_match_08004ac2"
        },
        "FUN_08006ca8": {
            "renaming": {
                "FUN_08006ca8": "initialize_ADC_GPIO_pins_08006ca8",
                "*hadc": "*ADC_HandleTypeDef",
                "GPIOx": "GPIOx",
                "puVar1": "*undefined",
                "tmpreg": "tmpreg",
                "tmpreg_1": "tmpreg_1",
                "GPIO_InitStruct": "*GPIO_InitTypeDef",
                "Instance": "Instance",
                "DAT_08006d14": "ADC1",
                "DAT_08006d18": "ADC2",
                "DAT_08006d20": "GPIOC_BASE",
                "PTR_g_current_pin_08006d1c": "*g_current_pin",
                "current_pin": "current_pin"
            },
            "code": "void initialize_ADC_GPIO_pins_08006ca8(ADC_HandleTypeDef *hadc)\n{\n    uint32_t tmpreg;\n    uint32_t tmpreg_1;\n    GPIO_InitTypeDef GPIO_InitStruct;\n    if (hadc->Instance == DAT_08006d14) {\n        *(uint *)(DAT_08006d20 + 0x18) = *(uint *)(DAT_08006d20 + 0x18) | GPIO_PIN_9;\n    }\n    else if (hadc->Instance == DAT_08006d18) {\n        *(uint *)(DAT_08006d20 + 0x18) = *(uint *)(DAT_08006d20 + 0x18) | GPIO_PIN_10;\n    }\n    uint8_t *current_pin = g_current_pin;\n    GPIO_TypeDef *GPIOx = set_GPIO_Port_Clock((uint)((int)(char)*current_pin << 0x18) >> 0x1c);\n    GPIO_InitStruct.Pin = 1 << (*current_pin & 0xf) & 0xffff;\n    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\n    HAL_GPIO_Init(GPIOx, &GPIO_InitStruct);\n    return;\n}",
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ca8",
            "calling": [
                "HAL_ADC_Init"
            ],
            "imported": false,
            "current_name": "initialize_ADC_GPIO_pins_08006ca8"
        },
        "FUN_0800937c": {
            "renaming": {
                "FUN_0800937c": "FUNC_0800937c"
            },
            "code": "\nint FUNC_0800937c(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  int iVar3;\n  void *pvVar4;\n  int *piVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  int unaff_r9;\n  int iVar8;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 local_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  local_8c = param_4;\n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == PTR___sf_fake_stdin_08009588) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR___sf_fake_stdout_08009590) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR___sf_fake_stderr_08009594) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar8 = __swsetup_r(param_1,param_2), iVar8 != 0)) {\n    return -1;\n  }\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar6 = param_3;\nLAB_080093be:\n  pbVar7 = pbVar6;\n  if (*pbVar7 != 0) goto LAB_08009474;\n  goto LAB_080093c8;\nLAB_08009474:\n  pbVar6 = pbVar7 + 1;\n  if (*pbVar7 != 0x25) goto LAB_080093be;\nLAB_080093c8:\n  iVar8 = (int)pbVar7 - (int)param_3;\n  if (iVar8 != 0) {\n    iVar3 = __sfputs_r(param_1,param_2,param_3,iVar8);\n    if (iVar3 == -1) {\nLAB_08009568:\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar8;\n  }\n  if (*pbVar7 == 0) goto LAB_08009568;\n  local_88 = 0;\n  local_7c = 0;\n  local_84 = -1;\n  local_80 = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar6 = pbVar7 + 1;\n  while( true ) {\n    pvVar4 = memchr(PTR_s___0__0800958c,(uint)*pbVar6,5);\n    puVar2 = PTR_DAT_08009598;\n    param_3 = pbVar6 + 1;\n    if (pvVar4 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar4 - (int)PTR_s___0__0800958c & 0xffU) | local_88;\n    pbVar6 = param_3;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar6 == 0x2a) {\n    piVar5 = local_8c + 1;\n    iVar8 = *local_8c;\n    local_8c = piVar5;\n    if (-1 < iVar8) goto LAB_08009498;\n    local_7c = -iVar8;\n    local_88 = local_88 | 2;\n  }\n  else {\n    bVar1 = false;\n    iVar8 = local_7c;\n    param_3 = pbVar6;\n    while( true ) {\n      if (9 < *param_3 - 0x30) break;\n      iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n      bVar1 = true;\n      param_3 = param_3 + 1;\n    }\n    if (bVar1) {\nLAB_08009498:\n      local_7c = iVar8;\n    }\n  }\n  if (*param_3 == 0x2e) {\n    if (param_3[1] == 0x2a) {\n      param_3 = param_3 + 2;\n      piVar5 = local_8c + 1;\n      local_84 = *local_8c;\n      local_8c = piVar5;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n    }\n    else {\n      bVar1 = false;\n      iVar8 = 0;\n      local_84 = 0;\n      while( true ) {\n        param_3 = param_3 + 1;\n        if (9 < *param_3 - 0x30) break;\n        iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar8;\n      }\n    }\n  }\n  pvVar4 = memchr(PTR_DAT_08009598,(uint)*param_3,3);\n  if (pvVar4 != (void *)0x0) {\n    param_3 = param_3 + 1;\n    local_88 = local_88 | 0x40 << ((int)pvVar4 - (int)puVar2 & 0xffU);\n  }\n  local_70 = *param_3;\n  param_3 = param_3 + 1;\n  pvVar4 = memchr(PTR_s_efgEFG_0800959c,(uint)local_70,6);\n  if (pvVar4 == (void *)0x0) {\n    iVar8 = _printf_i(param_1,&local_88,param_2,DAT_080095a4,&local_8c);\n  }\n  else {\n    iVar8 = param_1;\n    if (DAT_080095a0 == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar8 = unaff_r9;\n      goto LAB_0800951a;\n    }\n  }\n  if (iVar8 == -1) goto LAB_08009568;\nLAB_0800951a:\n  local_74 = local_74 + iVar8;\n  pbVar6 = param_3;\n  unaff_r9 = iVar8;\n  goto LAB_080093be;\n}\n\n",
            "called": [
                "memchr",
                "__sfputs_r",
                "__swsetup_r",
                "_printf_i",
                "__sinit"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0800937c",
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "imported": false,
            "current_name": "FUNC_0800937c"
        },
        "FUN_08000214": {
            "renaming": {
                "FUN_08000214": "write_to_pin_08000214",
                "pin": "pin_number",
                "value": "pin_value",
                "bVar1": "is_valid_servo_pin",
                "bVar2": "pin_mode",
                "_Var3": "is_valid_digital_pin",
                "ulPin": "pin_number",
                "uVar4": "digital_pin",
                "PTR_Firmata_080002d8": "firmata_instance",
                "PTR_digitalPin_080002dc": "digital_pin_map",
                "NC": "NO_CONNECTION",
                "pinNametoDigitalPin": "get_digital_pin_number_from_pin_name",
                "pin_in_pinmap": "is_pin_in_pwm_pinmap",
                "PTR_PinMap_PWM_080002e8": "pwm_pinmap",
                "PTR_servos_080002e4": "servo_instance_map",
                "PTR_servoPinMap_080002e0": "servo_pin_map"
            },
            "code": "void write_to_pin_08000214(byte pin, int value) {\n  bool is_valid_pin = false;\n  byte pin_mode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_080002d8, pin);\n  uint pin_number = (uint)pin;\n  if (pin_number <= 0x3b) {\n    if (pin_mode == '\\x03') {\n      if (pin_number < 0x3c) {\n        if (PTR_digitalPin_080002dc[pin_number] != NC) {\n          uint32_t digital_pin = pinNametoDigitalPin(PTR_digitalPin_080002dc[pin_number]);\n          if (digital_pin > 1 && pin_in_pinmap(PTR_digitalPin_080002dc[pin_number], (PinMap_conflict *)PTR_PinMap_PWM_080002e8)) {\n            is_valid_pin = true;\n            analogWrite(pin_number, value);\n          }\n        }\n      }\n    }\n    else if (pin_mode == '\\x04') {\n      if (pin_number < 0x3c) {\n        if (PTR_digitalPin_080002dc[pin_number] != NC && PTR_servoPinMap_080002e0[pin_number] != NC) {\n          is_valid_pin = true;\n          Servo *servo = (Servo *)(PTR_servos_080002e4 + (uint)(byte)PTR_servoPinMap_080002e0[pin_number] * 3);\n          servo->write(value);\n        }\n      }\n    }\n  }\n  if (is_valid_pin) {\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_080002d8, pin, value);\n  }\n}\n",
            "called": [
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "setPinState",
                "analogWrite",
                "getPinMode",
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000214",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "write_to_pin_08000214"
        },
        "FUN_08003724": {
            "renaming": {
                "FUN_08003724": "set_priority_and_init_08003724",
                "FUN_08003724Tick": "set_tick",
                "*DAT_08003744": "data_register"
            },
            "code": "HAL_StatusTypeDef_conflict set_priority_and_init_08003724(void)\n{\n  **DAT_08003744 = **DAT_08003744 | 0x10;\n  HAL_NVIC_SetPriorityGrouping(3);\n  set_tick(0xf);\n  HAL_MspInit();\n  return HAL_OK;\n}",
            "called": [
                "HAL_InitTick",
                "HAL_MspInit",
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003724",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "set_priority_and_init_08003724"
        },
        "FUN_08005bb8": {
            "renaming": {
                "FUN_08005bb8": "calculatePeripheralClock_08005bb8",
                "PeriphClk": "periphClock",
                "uVar1": "result",
                "uVar2": "temp",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable",
                "PTR_DAT_08005ca0": "PLLMUL_FACTOR_TABLE_PTR",
                "DAT_08005ca4": "PLLCFGR",
                "DAT_08005ca8": "VCO_INPUT_FREQUENCY",
                "DAT_08005cac": "VCO_OUTPUT_FREQUENCY",
                "HAL_RCC_GetPCLK2Freq": "HAL_RCC_GetPCLK2Frequency",
                "PTR_DAT_08005ca0 + 0x10": "PREDIV_FACTOR_TABLE_PTR",
                "uint8_t aPredivFactorTable [2]": "uint8_t predivFactorTable[2]",
                "uint8_t aPLLMULFactorTable [16]": "uint8_t pllMulFactorTable[16]"
            },
            "code": "uint32_t calculatePeripheralClock_08005bb8(uint32_t periphClock)\n{\n    uint32_t result = 0;\n    uint8_t predivFactorTable[2];\n    uint8_t pllMulFactorTable[16];\n\n    pllMulFactorTable[0] = *(uint32_t *)(PTR_DAT_08005ca0 + 0);\n    pllMulFactorTable[1] = *(uint32_t *)(PTR_DAT_08005ca0 + 4);\n    pllMulFactorTable[2] = *(uint32_t *)(PTR_DAT_08005ca0 + 8);\n    predivFactorTable[0] = *(uint8_t *)(PTR_DAT_08005ca0 + 0x10 + 0);\n    predivFactorTable[1] = *(uint8_t *)(PTR_DAT_08005ca0 + 0x10 + 1);\n\n    if (periphClock == 2)\n    {\n        uint32_t pclk2Freq = HAL_RCC_GetPCLK2Freq();\n        result = pclk2Freq / ((((DAT_08005ca4 >> 27) & 0x0F) + 1) * 2);\n    }\n    else if (periphClock == 16)\n    {\n        if ((DAT_08005ca4 & 0x1000000) == 0)\n        {\n            result = 0;\n        }\n        else\n        {\n            uint32_t vcoInputFrequency = DAT_08005ca8;\n            if ((DAT_08005ca4 & 0x20000) != 0)\n            {\n                vcoInputFrequency /= predivFactorTable[-((int)(DAT_08005ca4 << 14) >> 31)];\n            }\n            uint32_t vcoOutputFrequency = vcoInputFrequency * pllMulFactorTable[(DAT_08005ca4 >> 18) & 0x0F];\n            if ((DAT_08005ca4 & 0x400000) == 0)\n            {\n                vcoOutputFrequency /= 2;\n            }\n            result = vcoOutputFrequency / ((DAT_08005ca4 & 0x3F) + 1);\n        }\n    }\n    else if (periphClock == 1)\n    {\n        if ((RCC_CFGR & 0x302) == 0x102)\n        {\n            result = 8000;\n        }\n        else\n        {\n            uint32_t apb1Prescaler = RCC_CFGR & 0x300;\n            if ((apb1Prescaler == 0x200) && ((RCC_CFGR & 0x2) != 0))\n            {\n                result = 32000;\n            }\n            else if (apb1Prescaler == 0x300)\n            {\n                result = 8000000;\n            }\n            else\n            {\n                result = 0;\n            }\n        }\n    }\n    else\n    {\n        result = 0;\n    }\n    return result;\n}",
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bb8",
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_PollForConversion"
            ],
            "imported": false,
            "current_name": "calculatePeripheralClock_08005bb8"
        },
        "FUN_08002f0a": {
            "renaming": {
                "FUN_08002f0a": "sendCommandToMarshaller_08002f0a",
                "bytec": "numBytes",
                "bytev": "data",
                "command": "command"
            },
            "code": "void __thiscall firmata::FirmataClass::sendCommandToMarshaller_08002f0a(byte command, byte numBytes, byte *data){FirmataMarshaller::sendCommand(&this->marshaller, command, (uint)numBytes, data); return;}",
            "called": [
                "sendSysex"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f0a",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "sendCommandToMarshaller_08002f0a"
        },
        "FUN_08002634": {
            "renaming": {
                "FUN_08002634": "setPin_08002634",
                "this": "servo",
                "pin": "pin",
                "uVar1": "result"
            },
            "code": "uint8_t __thiscall Servo::setPin_08002634(Servo *servo, int pin)\n{\n  uint8_t result = setPin_08002634(servo, pin, 0x220, 0x960);\n  return result;\n}",
            "called": [
                "attach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002634",
            "calling": [
                "attachServo"
            ],
            "imported": false,
            "current_name": "setPin_08002634"
        },
        "FUN_080063c0": {
            "renaming": {
                "FUN_080063c0": "disable_timer_channel_080063c0",
                "htim": "timer_handle",
                "Channel": "channel",
                "pTVar1": "timer_instance",
                "DAT_0800641c": "PTR_DAT_0800641c"
            },
            "code": "HAL_StatusTypeDef_conflict disable_timer_channel_080063c0(TIM_HandleTypeDef_conflict *timer_handle, uint32_t channel)\n{\n    TIM_TypeDef_conflict *timer_instance = timer_handle->Instance;\n    TIM_CCxChannelCmd(timer_instance, channel, 0);\n    if (((timer_instance == DAT_0800641c) && ((timer_instance->CCER & 0x1111) == 0)) && ((timer_instance->CCER & 0x444) == 0))\n    {\n        timer_instance->BDTR &= 0xffff7fff;\n    }\n    if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n        timer_instance->CR1 &= 0xfffffffe;\n    }\n    timer_handle->State = HAL_TIM_STATE_READY;\n    return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080063c0",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "disable_timer_channel_080063c0"
        },
        "FUN_0800274c": {
            "renaming": {
                "FUN_0800274c": "readByteFromRxBuffer_0800274c",
                "this": "wire",
                "*PTR_rxBufferIndex_08002768": "*(wire->rxBufferIndex)",
                "*PTR_rxBufferLength_0800276c": "*(wire->rxBufferLength)",
                "*PTR_rxBuffer_08002770": "*(wire->rxBuffer)"
            },
            "code": "int __thiscall readByteFromRxBuffer_0800274c(TwoWire *wire) {\n  uint8_t rxBufferIndex = *PTR_rxBufferIndex_08002768;\n  uint8_t rxBufferLength = *PTR_rxBufferLength_0800276c;\n  uint8_t *rxBuffer = *PTR_rxBuffer_08002770;\n  if (rxBufferIndex < rxBufferLength) {\n    return *(rxBuffer + rxBufferIndex);\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800274c",
            "calling": [],
            "imported": false,
            "current_name": "readByteFromRxBuffer_0800274c"
        },
        "FUN_080098d8": {
            "renaming": {
                "FUN_080098d8": "format_print_080098d8",
                "__format": "format",
                "iVar1": "impure_ptr",
                "pcVar2": "format_string",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3"
            },
            "code": "int format_print_080098d8(char* format, ...)\n{\n  int impure_ptr = *(int*)PTR__impure_ptr_08009904;\n  char* format_string = format;\n  undefined4 arg1 = 0;\n  undefined4 arg2 = 0;\n  undefined4 arg3 = 0;\n  if ((impure_ptr != 0) && (*(int*)(impure_ptr + 0x18) == 0))\n  {\n    __sinit(impure_ptr);\n  }\n  int result = _vfformat_print_080098d8_r(impure_ptr, *(undefined4*)(impure_ptr + 8), format_string, &arg1, &arg2, &arg3);\n  return result;\n}",
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080098d8",
            "calling": [
                "getTimerClkFreq",
                "getTimerIrq",
                "getTimerClkSrc",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "format_print_080098d8"
        },
        "FUN_08009270": {
            "renaming": {
                "FUN_08009270": "allocate_memory_block_08009270",
                "*param_1": "*alloc_result",
                "param_2": "requested_size",
                "puVar1": "current_sbrk",
                "uVar2": "allocation_result",
                "puVar3": "free_list",
                "iVar4": "sbrk_result",
                "puVar5": "current_block",
                "uVar6": "remaining_space",
                "puVar7": "previous_block",
                "uVar8": "aligned_size"
            },
            "code": "uint allocate_memory_block_08009270(undefined4 *alloc_result, uint requested_size)\n{\n  uint aligned_size = (requested_size + 3 & 0xfffffffc) + 8;\n  if (aligned_size < 0xc) {\n    aligned_size = 0xc;\n  }\n  if (((int)aligned_size < 0) || (aligned_size < requested_size)) {\n    *alloc_result = 0xc;\n  }\n  else {\n    __malloc_lock();\n    void *current_sbrk = PTR___malloc_sbrk_start_08009328;\n    uint *free_list = *(uint **)PTR___malloc_free_list_08009324;\n    uint *previous_free_list = *(uint **)PTR___malloc_free_list_08009324;\n    while (free_list != (uint *)0x0) {\n      uint remaining_space = *free_list - aligned_size;\n      if (-1 < (int)remaining_space) {\n        if (remaining_space < 0xc) {\n          if (previous_free_list == free_list) {\n            uint next_block = previous_free_list[1];\n            *(uint *)PTR___malloc_free_list_08009324 = next_block;\n          }\n          else {\n            uint next_block = free_list[1];\n          }\n          if (previous_free_list != free_list) {\n            previous_free_list[1] = next_block;\n            previous_free_list = free_list;\n          }\n        }\n        else {\n          *free_list = remaining_space;\n          *(uint *)((int)free_list + remaining_space) = aligned_size;\n          previous_free_list = (uint *)((int)free_list + remaining_space);\n        }\n        goto end_of_allocation;\n      }\n      previous_free_list = free_list;\n      free_list = (uint *)free_list[1];\n    }\n    if (*(int *)PTR___malloc_sbrk_start_08009328 == 0) {\n      uVar2 = _sbrk_r(alloc_result);\n      *(undefined4 *)current_sbrk = uVar2;\n    }\n    free_list = (uint *)_sbrk_r(alloc_result, aligned_size);\n    if ((free_list != (uint *)0xffffffff) && ((previous_free_list = (uint *)((int)free_list + 3U & 0xfffffffc), free_list == previous_free_list || (_sbrk_r(alloc_result,(int)previous_free_list - (int)free_list) != -1)))) {\n      *previous_free_list = aligned_size;\nend_of_allocation:\n      __malloc_unlock(alloc_result);\n      uint allocated_block_end = (int)previous_free_list + 0xbU & 0xfffffff8;\n      int padding_size = allocated_block_end - (int)(previous_free_list + 1);\n      if (padding_size != 0) {\n        *(int *)((int)previous_free_list + padding_size) = -padding_size;\n        return allocated_block_end;\n      }\n      return allocated_block_end;\n    }\n    *alloc_result = 0xc;\n    __malloc_unlock(alloc_result);\n  }\n  return 0;\n}",
            "called": [
                "__malloc_lock",
                "_sbrk_r",
                "__malloc_unlock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009270",
            "calling": [
                "__smakebuf_r",
                "malloc",
                "_realloc_r",
                "__sfmoreglue"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_08009270"
        },
        "FUN_08009038": {
            "renaming": {
                "FUN_08009038": "handle_GPIO_EXTI_interrupt_08009038",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "void handle_GPIO_EXTI_interrupt_08009038(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(gpio_pin_4);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009038",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_EXTI_interrupt_08009038"
        },
        "FUN_08005aa4": {
            "renaming": {
                "FUN_08005aa4": "configurePeriphClocks_08005aa4",
                "PeriphClkInitTypeDef_conflict": "RCC_PeriphCLKInitTypeDef",
                "iVar1": "counter",
                "puVar2": "regPtr",
                "uVar3": "currentTime",
                "uVar4": "startTime",
                "uVar5": "clockSelection",
                "bVar6": "setBit",
                "tmpreg": "tempReg",
                "DAT_08005bac": "RCC_BASE",
                "DAT_08005bb0": "RCC_BDCR_OFFSET",
                "DAT_08005bb4": "RCC_BDCR_RTCSEL",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_TIMEOUT": "HAL_TIMEOUT",
                "uint32_t": "uint",
                "undefined4": "undefined4",
                "bool": "bool"
            },
            "code": "HAL_StatusTypeDef configurePeriphClocks_08005aa4(RCC_PeriphCLKInitTypeDef *PeriphClkInit)\n{\n  int counter;\n  uint32_t *regPtr;\n  uint32_t currentTime;\n  uint32_t startTime;\n  bool setBit;\n  uint clockSelection;\n  \n  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) != 0) {\n    setBit = (*(uint *)(DAT_08005bac + DAT_08005bb0) & RCC_BDCR_RTCEN) == 0;\n    if (setBit) {\n      *(uint *)(DAT_08005bac + DAT_08005bb0) |= RCC_BDCR_RTCEN;\n    }\n    if ((*(uint *)(DAT_08005bac + DAT_08005bb0) & RCC_BDCR_RTCEN) == 0) {\n      startTime = HAL_GetTick();\n      while ((*(uint *)(DAT_08005bac + DAT_08005bb0) & RCC_BDCR_RTCEN) == 0) {\n        currentTime = HAL_GetTick();\n        if (100 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    regPtr = (uint32_t *)(DAT_08005bac + DAT_08005bb0);\n    counter = DAT_08005bb0;\n    clockSelection = *(uint *)(DAT_08005bac + DAT_08005bb0) & DAT_08005bb4;\n    if ((clockSelection != 0) && (clockSelection != (PeriphClkInit->RTCClockSelection & DAT_08005bb4))) {\n      clockSelection = *(uint *)(DAT_08005bac + DAT_08005bb0);\n      *regPtr = DAT_08005bb4_0;\n      *regPtr = 0;\n      *(uint *)(counter + DAT_08005bb0) = clockSelection & ~DAT_08005bb4;\n      if ((clockSelection & DAT_08005bb4_0) != 0) {\n        startTime = HAL_GetTick();\n        while ((*(uint *)(DAT_08005bac + DAT_08005bb0) & DAT_08005bb4_1) == 0) {\n          currentTime = HAL_GetTick();\n          if (5000 < currentTime - startTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    counter = DAT_08005bb0;\n    *(uint *)(DAT_08005bac + DAT_08005bb0) = *(uint *)(DAT_08005bac + DAT_08005bb0) & ~DAT_08005bb4 | PeriphClkInit->RTCClockSelection;\n    if (setBit) {\n      *(uint *)(counter + DAT_08005bb0) = *(uint *)(counter + DAT_08005bb0) & ~RCC_BDCR_RTCEN;\n    }\n  }\n  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) != 0) {\n    *(uint *)(DAT_08005bac + RCC_CFGR_OFFSET) = *(uint *)(DAT_08005bac + RCC_CFGR_OFFSET) & ~RCC_CFGR_ADCPRE | PeriphClkInit->AdcClockSelection;\n  }\n  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USB) != 0) {\n    *(uint *)(DAT_08005bac + RCC_CFGR_OFFSET) = *(uint *)(DAT_08005bac + RCC_CFGR_OFFSET) & ~RCC_CFGR_USBPRE | PeriphClkInit->UsbClockSelection;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005aa4",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configurePeriphClocks_08005aa4"
        },
        "FUN_08008068": {
            "renaming": {
                "FUN_08008068": "handle_I2C_errors_08008068",
                "*PTR_i2c_handles_08008074": "i2c_handles",
                "I2C_HandleTypeDef_conflict": "i2c_handle",
                "*i2c_handle": "i2c_error_handler"
            },
            "code": "void handle_I2C_errors_08008068(void)\n{\n  I2C_HandleTypeDef_conflict* i2c_handle = *(I2C_HandleTypeDef_conflict**)(PTR_*PTR_i2c_handles_08008074_08008074 + 4);\n  HAL_I2C_ER_IRQHandler(i2c_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008068",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_errors_08008068"
        },
        "FUN_08002400": {
            "renaming": {
                "FUN_08002400": "has_timer16_Sequence_exceeded_max_08002400",
                "timer": "timer16_Sequence_t",
                "uVar1": "i"
            },
            "code": "bool has_timer16_Sequence_exceeded_max_08002400(timer16_Sequence_t timer)\n{\n  uint8_t i = 0;\n  while(i <= 11) {\n    if ((PTR_servos_08002428[((uint)timer * 0xc + i) * 8] & 0x40) != 0) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002400",
            "calling": [
                "attach",
                "detach"
            ],
            "imported": false,
            "current_name": "has_timer16_Sequence_exceeded_max_08002400"
        },
        "FUN_08000588": {
            "renaming": {
                "FUN_08000588": "detachServo_08000588",
                "pin": "servoPin",
                "cVar1": "servoCount",
                "cVar2": "servoPinIndex",
                "puVar3": "servoPinMapPointer"
            },
            "code": "void detachServo_08000588(byte servoPin)\\n{\\n  char servoPinIndex;\\n  char servoCount;\\n  undefined *servoPinMapPointer;\\n  servoPinMapPointer = PTR_servoPinMap_080005cc;\\n  Servo::detach((Servo *)(PTR_servos_080005d0 + (uint)(byte)PTR_servoPinMap_080005cc[servoPin] * 3));\\n  servoPinIndex = servoPinMapPointer[servoPin];\\n  servoCount = *PTR_servoCount_080005d4;\\n  if ((servoPinIndex == servoCount) && (servoCount != \"\\0\")) {\\n    *PTR_servoCount_080005d4 = servoCount + -1;\\n  }\\n  else if (servoCount != \"\\0\") {\\n    char detachedServoCount = *PTR_detachedServoCount_080005d8;\\n    *PTR_detachedServoCount_080005d8 = detachedServoCount + 1U;\\n    PTR_detachedServos_080005dc[(byte)(detachedServoCount + 1U) - 1] = servoPinIndex;\\n  }\\n  servoPinMapPointer[servoPin] = 0xff;\\n  return;\\n}",
            "called": [
                "detach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000588",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "detachServo_08000588"
        },
        "FUN_08002644": {
            "renaming": {
                "FUN_08002644": "updateServo_08002644",
                "this": "servo",
                "bVar1": "isTimerActive",
                "uVar2": "servoIndex"
            },
            "code": "void __thiscall updateServo_08002644(Servo *servo) {\n  boolean isTimerActive;\n  uint servoIndex = (uint)servo->servoIndex;\n  PTR_servos_08002670[servoIndex * 8] = PTR_servos_08002670[servoIndex * 8] & 0xbf;\n  isTimerActive = isTimerActive((timer16_Sequence_t)((ulonglong)DAT_08002674 * (ulonglong)servoIndex >> 0x23));\n  if (!isTimerActive) {\n    finISR((stimer_t *)PTR__timer_08002678);\n  }\n  return;\n}",
            "called": [
                "isTimerActive",
                "finISR"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002644",
            "calling": [
                "detachServo"
            ],
            "imported": false,
            "current_name": "updateServo_08002644"
        },
        "FUN_08002f1e": {
            "renaming": {
                "FUN_08002f1e": "printByte_08002f1e",
                "this": "firmata_instance",
                "c": "byte_to_print",
                "FirmataStream": "firmata_stream"
            },
            "code": "void __thiscall firmata::FirmataClass::printByte_08002f1e(FirmataClass *firmata_instance, byte byte_to_print)\n{\n  (**(firmata_instance->FirmataStream->super_Print)._vptr_Print)(firmata_instance->FirmataStream,(uint)byte_to_print);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f1e",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "printByte_08002f1e"
        },
        "FUN_0800902e": {
            "renaming": {
                "FUN_0800902e": "handle_GPIO_interrupt_0800902e",
                "PTR_": "",
                "DAT_": "",
                "2": "GPIO_PIN_2"
            },
            "code": "void handle_GPIO_interrupt_0800902e(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800902e",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_interrupt_0800902e"
        },
        "FUN_08009042": {
            "renaming": {
                "FUN_08009042": "handle_GPIO_interrupt_08009042",
                "PTR_": "PTR_ (unchanged)",
                "DAT_": "DAT_ (unchanged)"
            },
            "code": "void handle_GPIO_interrupt_08009042(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_8);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009042",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_interrupt_08009042"
        },
        "FUN_08009c7c": {
            "renaming": {
                "FUN_08009c7c": "flush_if_buffer_non_empty_08009c7c",
                "param_1": "file_descriptor",
                "param_2": "stream",
                "param_3": "mode",
                "param_4": "flags",
                "uVar1": "result",
                "stream_buffer_ptr": "stream_buffer_ptr",
                "stream_mode_ptr": "stream_mode_ptr"
            },
            "code": "int flush_if_buffer_non_empty_08009c7c(int file_descriptor, char* stream, int mode, int flags) {\n    int result = 0;\n    int* stream_buffer_ptr = (int*)(stream + 0x10);\n    if (*stream_buffer_ptr != 0) {\n        if ((file_descriptor != 0) && (*(int*)(file_descriptor + 0x18) == 0)) {\n            __sinit();\n        }\n        if (stream == PTR___sf_fake_stdin_08009cc4) {\n            stream = *(char**)(file_descriptor + 4);\n        }\n        else if (stream == PTR___sf_fake_stdout_08009cc8) {\n            stream = *(char**)(file_descriptor + 8);\n        }\n        else if (stream == PTR___sf_fake_stderr_08009ccc) {\n            stream = *(char**)(file_descriptor + 0xc);\n        }\n        short* stream_mode_ptr = (short*)(stream + 0xc);\n        if (*stream_mode_ptr != 0) {\n            result = __sflush_r(file_descriptor, stream, mode, flags);\n        }\n    }\n    return result;\n}",
            "called": [
                "__sinit",
                "__sflush_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009c7c",
            "calling": [
                "__swbuf_r"
            ],
            "imported": false,
            "current_name": "flush_if_buffer_non_empty_08009c7c"
        },
        "FUN_08009b5c": {
            "renaming": {
                "FUN_08009b5c": "handle_sigabrt_08009b5c",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "void handle_sigabrt_08009b5c() {\n  raise(SIGABRT);\n  exit(1);\n}",
            "called": [
                "_exit",
                "raise"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009b5c",
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "imported": false,
            "current_name": "handle_sigabrt_08009b5c"
        },
        "FUN_08008a6c": {
            "renaming": {
                "FUN_08008a6c": "read_digital_pin_08008a6c",
                "ulPin": "pin_number",
                "_Var1": "is_pin_configured",
                "port": "gpio_port",
                "uVar2": "digital_io_value",
                "uVar3": "digital_pin_number"
            },
            "code": "int read_digital_pin_08008a6c(uint32_t pin_number) {\n    bool is_pin_configured;\n    GPIO_TypeDef *gpio_port;\n    uint32_t digital_io_value;\n    uint32_t digital_pin_number;\n\n    if (pin_number < 0x3c) {\n        digital_pin_number = (uint32_t)(char)PTR_digitalPin_08008ab4[pin_number];\n    }\n    else {\n        digital_pin_number = 0xffffffff;\n    }\n\n    if (digital_pin_number == 0xffffffff) {\n        digital_pin_number = 0;\n    }\n    else {\n        is_pin_configured = is_pin_configured((PinName_conflict)digital_pin_number, (uint32_t *)PTR_g_digPinConfigured_08008ab8);\n\n        if (is_pin_configured) {\n            gpio_port = get_GPIO_Port((digital_pin_number << 0x18) >> 0x1c);\n            digital_io_value = digital_io_read(gpio_port, 1 << (digital_pin_number & 0xf) & 0xffff);\n            digital_pin_number = digital_io_value & 0xff;\n        }\n        else {\n            digital_pin_number = 0;\n        }\n    }\n\n    if (digital_pin_number != 0) {\n        digital_pin_number = 1;\n    }\n\n    return digital_pin_number;\n}",
            "called": [
                "digital_io_read",
                "get_GPIO_Port",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a6c",
            "calling": [
                "checkDigitalInputs",
                "reportDigitalCallback"
            ],
            "imported": false,
            "current_name": "read_digital_pin_08008a6c"
        },
        "FUN_080085b8": {
            "renaming": {
                "FUN_080085b8": "is_uart_transmit_complete_080085b8",
                "obj": "serial",
                "HVar1": "uart_state",
                "PTR_uart_handlers_080085d8": "uart_handlers",
                "uint": "unsigned int",
                "return": "return",
                "HAL_UART_StateTypeDef": "HAL_UART_StateTypeDef",
                "HAL_UART_GetState": "HAL_UART_GetState",
                "UART_HandleTypeDef": "UART_HandleTypeDef"
            },
            "code": "bool is_uart_transmit_complete_080085b8(serial_t* serial) {\n    UART_HandleTypeDef* uart_handle = *(UART_HandleTypeDef**)(PTR_PTR_uart_handlers_080085d8_080085d8 + (uint)serial->index * 4);\n    HAL_UART_StateTypeDef uart_state = HAL_UART_GetState(uart_handle);\n    return (uart_state & 0x22U) == 0x22;\n}",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085b8",
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "imported": false,
            "current_name": "is_uart_transmit_complete_080085b8"
        },
        "FUN_08001c08": {
            "renaming": {
                "FUN_08001c08": "readTwoWire_08001c08",
                "in_r1": "readAddress",
                "in_r2": "readBuffer",
                "in_r3": "readLength",
                "sVar1": "readResult"
            },
            "code": "byte readTwoWire_08001c08(void)\n{\n  ssize_t readResult;\n  int readAddress;\n  void *readBuffer;\n  size_t readLength;\n  \n  readResult = TwoWire::read((TwoWire *)PTR_Wire_08001c14, readAddress, readBuffer, readLength);\n  return (byte)readResult;\n}",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c08",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "readTwoWire_08001c08"
        },
        "FUN_080075dc": {
            "renaming": {
                "FUN_080075dc": "calculate_timer_frequency_080075dc",
                "tim": "timer",
                "uVar1": "frequency",
                "uVar2": "timer_clk_src",
                "uVar3": "apb_clk_frequency",
                "uVar4": "apb_clk_divider",
                "pFLatency": "flash_latency",
                "clkconfig": "clk_config",
                "ClockType": "RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2",
                "SYSCLKSource": "RCC_SYSCLKSOURCE_HSE",
                "AHBCLKDivider": "RCC_SYSCLK_DIV1",
                "APB1CLKDivider": "RCC_HCLK_DIV1",
                "APB2CLKDivider": "RCC_HCLK_DIV1",
                "PTR_s_TIM__Unknown_clock_source_08007644": "Unknown clock source"
            },
            "code": "uint32_t calculate_timer_frequency_080075dc(TIM_TypeDef_conflict *timer) {\n  uint32_t frequency;\n  uint8_t timer_clk_src;\n  uint32_t apb2_clk_divider;\n  uint32_t apb1_clk_divider;\n  uint32_t flash_latency;\n  RCC_ClkInitTypeDef_conflict clk_config;\n  clk_config.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;\n  HAL_RCC_GetClockConfig(&clk_config, &flash_latency);\n  timer_clk_src = get_timer_clk_src(timer);\n  apb2_clk_divider = clk_config.APB2CLKDivider;\n  apb1_clk_divider = clk_config.APB1CLKDivider;\n  if (timer_clk_src == TIMER_CLK_SRC_APB1) {\n    frequency = HAL_RCC_GetPCLK1Freq();\n  }\n  else if (timer_clk_src == TIMER_CLK_SRC_APB2) {\n    frequency = HAL_RCC_GetPCLK2Freq();\n    apb1_clk_divider = apb2_clk_divider;\n  }\n  else {\n    iprintf(PTR_s_TIM__Unknown_clock_source_08007644);\n    frequency = 0;\n    apb1_clk_divider = 0;\n  }\n  if (apb1_clk_divider != 0x500) {\n    if (apb1_clk_divider < 0x501) {\n      if (apb1_clk_divider != 0x400) {\n        return frequency;\n      }\n    }\n    else if ((apb1_clk_divider != 0x600) && (apb1_clk_divider != 0x700)) {\n      return frequency;\n    }\n  }\n  return frequency << 1;\n}",
            "called": [
                "HAL_RCC_GetClockConfig",
                "HAL_RCC_GetPCLK1Freq",
                "getTimerClkSrc",
                "iprintf",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080075dc",
            "calling": [
                "pwm_start",
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "calculate_timer_frequency_080075dc"
        },
        "FUN_080087ec": {
            "renaming": {
                "FUN_080087ec": "handle_UART_interrupt_080087ec",
                "USART3_IRQn": "USART3_Interrupt",
                "PTR_uart_handlers_08008800": "ptr_uart_handlers",
                "UART_HandleTypeDef": "UART_handler"
            },
            "code": "void handle_UART_interrupt_080087ec(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART3_IRQn);\n  UART_HandleTypeDef *uart_handler = *(UART_HandleTypeDef **)(PTR_uart_handlers_08008800 + 8);\n  if (uart_handler != NULL) {\n    HAL_UART_IRQHandler(uart_handler);\n  }\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087ec",
            "calling": [],
            "imported": false,
            "current_name": "handle_UART_interrupt_080087ec"
        },
        "FUN_08007ff0": {
            "renaming": {
                "FUN_08007ff0": "handle_i2c_slave_receive_08007ff0",
                "hi2c": "i2c_handle",
                "piVar1": "i2c_obj",
                "uVar2": "remaining_bytes",
                "i2c_onSlaveReceive": "i2c_on_slave_receive",
                "slaveMode": "slave_mode",
                "handle": "i2c_handle",
                "XferSize": "xfer_size",
                "i2cTxRxBuffer": "i2c_tx_rx_buffer",
                "HAL_I2C_EnableListen_IT": "enable_i2c_listen_interrupt"
            },
            "code": "void handle_i2c_slave_receive_08007ff0(I2C_HandleTypeDef_conflict *i2c_handle) {\n  i2c_t_conflict *i2c_obj = get_i2c_object(i2c_handle);\n  if (i2c_obj->i2c_on_slave_receive != (_func_void_uint8_t_ptr_int *)0x0 && i2c_obj->slave_mode == '\\x01') {\n    uint8_t remaining_bytes = 0x20 - *(uint8_t *)&(i2c_obj->handle).XferSize & 0xff;\n    if (remaining_bytes != 0) {\n      (*i2c_obj->i2c_on_slave_receive)(i2c_obj->i2c_tx_rx_buffer, remaining_bytes);\n    }\n  }\n  HAL_I2C_EnableListen_IT(i2c_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ff0",
            "calling": [
                "I2C_Slave_AF",
                "I2C_ITError",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "handle_i2c_slave_receive_08007ff0"
        },
        "FUN_08008078": {
            "renaming": {
                "FUN_08008078": "FUNC_08008078"
            },
            "code": "\nvoid FUNC_08008078(serial_t *obj)\n\n{\n  USART_TypeDef *pUVar1;\n  USART_TypeDef *pUVar2;\n  USART_TypeDef *pUVar3;\n  void *a;\n  void *b;\n  USART_TypeDef *pUVar4;\n  GPIO_TypeDef *pGVar5;\n  uint32_t uVar6;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj != (serial_t *)0x0) {\n    a = pinmap_peripheral(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08008330);\n    b = pinmap_peripheral(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08008334);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_UART_pin_has_08008348);\n    }\n    else {\n      pUVar4 = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      obj->uart = pUVar4;\n      pUVar3 = DAT_08008340;\n      pUVar2 = DAT_0800833c;\n      pUVar1 = DAT_08008338;\n      if (pUVar4 == (USART_TypeDef *)0x0) {\n        iprintf(PTR_s_ERROR__U_S_ART_pins_mismatch_0800834c);\n      }\n      else {\n        if (pUVar4 == DAT_08008338) {\n          DAT_08008338[0x7b7].BRR = DAT_08008338[0x7b7].BRR | 0x4000;\n          pUVar1[0x7b7].BRR = pUVar1[0x7b7].BRR & 0xffffbfff;\n          pUVar1[0x7b7].CR3 = pUVar1[0x7b7].CR3 | 0x4000;\n          obj->index = '\\0';\n          obj->irq = USART1_IRQn;\n        }\n        else if (pUVar4 == DAT_0800833c) {\n          DAT_0800833c[0x106e].BRR = DAT_0800833c[0x106e].BRR | 0x20000;\n          pUVar2[0x106e].BRR = pUVar2[0x106e].BRR & 0xfffdffff;\n          pUVar2[0x106e].CR3 = pUVar2[0x106e].CR3 | 0x20000;\n          obj->index = '\\x01';\n          obj->irq = USART2_IRQn;\n        }\n        else if (pUVar4 == DAT_08008340) {\n          DAT_08008340[0x1049].CR3 = DAT_08008340[0x1049].CR3 | 0x40000;\n          pUVar3[0x1049].CR3 = pUVar3[0x1049].CR3 & 0xfffbffff;\n          pUVar3[0x104a].DR = pUVar3[0x104a].DR | 0x40000;\n          obj->index = '\\x02';\n          obj->irq = USART3_IRQn;\n        }\n        pGVar5 = set_GPIO_Port_Clock((uint)((int)obj->pin_rx << 0x18) >> 0x1c);\n        uVar6 = pinmap_function(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08008334);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_rx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar6 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Pull = (uVar6 << 0x1a) >> 0x1e;\n        *(uint *)(DAT_08008344 + 0x18) = *(uint *)(DAT_08008344 + 0x18) | 1;\n        switch((uVar6 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x4000000;\n        }\n        GPIO_InitStruct.Speed = 3;\n        HAL_GPIO_Init(pGVar5,&GPIO_InitStruct);\n        pGVar5 = set_GPIO_Port_Clock((uint)((int)obj->pin_tx << 0x18) >> 0x1c);\n        uVar6 = pinmap_function(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08008330);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_tx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar6 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Pull = (uVar6 << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(pGVar5,&GPIO_InitStruct);\n        *(UART_HandleTypeDef **)(PTR_uart_handlers_08008354 + (uint)obj->index * 4) = &obj->handle;\n        (obj->handle).Instance = obj->uart;\n        (obj->handle).Init.BaudRate = obj->baudrate;\n        (obj->handle).Init.WordLength = obj->databits;\n        (obj->handle).Init.StopBits = obj->stopbits;\n        (obj->handle).Init.Parity = obj->parity;\n        (obj->handle).Init.Mode = 0xc;\n        (obj->handle).Init.HwFlowCtl = 0;\n        (obj->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&obj->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init",
                "pinmap_function",
                "pinmap_merge_peripheral",
                "pinmap_peripheral",
                "HAL_UART_Init",
                "set_GPIO_Port_Clock",
                "iprintf"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008078",
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "imported": false,
            "current_name": "FUNC_08008078"
        },
        "FUN_08002774": {
            "renaming": {
                "TwoWire::FUN_08002774": "executeUserRequestCallback",
                "pcVar1": "userCallback",
                "PTR_user_onRequest_0800278c": "user_onRequest",
                "PTR_txBufferIndex_08002790": "txBufferIndex",
                "PTR_txBufferLength_08002794": "txBufferLength",
                "FUN_08002774": "executeUserRequestCallback_08002774"
            },
            "code": "void executeUserRequestCallback_08002774(void)\n{\n  void (*userCallback)(void) = *(void (**))(PTR_user_onRequest_0800278c);\n  if (userCallback != NULL)\n  {\n    *PTR_txBufferIndex_08002790 = 0;\n    *PTR_txBufferLength_08002794 = 0;\n    userCallback();\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002774",
            "calling": [],
            "imported": false,
            "current_name": "executeUserRequestCallback_08002774"
        },
        "FUN_080052f0": {
            "renaming": {
                "FUN_080052f0": "checkI2CStatus_080052f0",
                "*hi2c": "*i2cHandler",
                "HVar1": "i2cState",
                "*pIVar2": "*i2cInstance",
                "uVar3": "sr1Reg",
                "uVar4": "cr2Reg",
                "DAT_080053c8": "I2C_SR1_TIMEOUT",
                "0x100": "I2C_CR2_START",
                "1": "I2C_ERROR_TIMEOUT",
                "2": "I2C_ERROR_ADDR",
                "4": "I2C_ERROR_BTF",
                "8": "I2C_ERROR_ARLO",
                "HAL_I2C_MODE_SLAVE": "I2C_MODE_SLAVE",
                "HAL_I2C_MODE_MASTER": "I2C_MODE_MASTER",
                "HAL_I2C_STATE_BUSY_TX": "I2C_STATE_BUSY_TX",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "I2C_STATE_BUSY_TX_LISTEN",
                "HAL_I2C_STATE_LISTEN": "I2C_STATE_LISTEN",
                "0x21": "I2C_STATE_ADDR",
                "I2C_Slave_AF": "I2C_Slave_AF",
                "I2C_ITError": "I2C_ITError"
            },
            "code": "void checkI2CStatus_080052f0(I2C_HandleTypeDef_conflict *i2cHandler){\n  HAL_I2C_StateTypeDef_conflict i2cState;\n  I2C_TypeDef_conflict *i2cInstance;\n  uint16_t sr1Reg;\n  uint16_t cr2Reg;\n  \n  i2cInstance = i2cHandler->Instance;\n  sr1Reg = i2cInstance->SR1;\n  cr2Reg = i2cInstance->CR2;\n  \n  if(((sr1Reg & DAT_080053c8) != 0) && ((cr2Reg & 0x100) != 0)){\n    i2cHandler->ErrorCode |= I2C_ERROR_TIMEOUT;\n    i2cInstance->SR1 = 0xfffffeff;\n    i2cInstance->CR1 |= 0x8000;\n  }\n  if(((sr1Reg & I2C_SR1_ADDR) != 0) && ((cr2Reg & 0x100) != 0)){\n    i2cHandler->ErrorCode |= I2C_ERROR_ADDR;\n    i2cInstance->SR1 = 0xfffffdff;\n  }\n  if(((sr1Reg & I2C_SR1_BTF) != 0) && ((cr2Reg & 0x100) != 0)){\n    i2cState = i2cHandler->State;\n    if(((i2cHandler->Mode == HAL_I2C_MODE_SLAVE) && (i2cHandler->XferCount == 0)) && (((i2cState == HAL_I2C_STATE_BUSY_TX) || (i2cState == HAL_I2C_STATE_BUSY_TX_LISTEN)) || ((i2cState == HAL_I2C_STATE_LISTEN) && (i2cHandler->PreviousState == I2C_STATE_ADDR)))){\n      I2C_Slave_AF(i2cHandler);\n    }\n    else{\n      i2cHandler->ErrorCode |= I2C_ERROR_BTF;\n      if(i2cHandler->Mode == HAL_I2C_MODE_MASTER){\n        i2cInstance->CR1 |= 0x200;\n      }\n      i2cInstance->SR1 = 0xfffffbff;\n    }\n  }\n  if(((sr1Reg & I2C_SR1_ARLO) != 0) && ((cr2Reg & 0x100) != 0)){\n    i2cHandler->ErrorCode |= I2C_ERROR_ARLO;\n    i2cInstance->SR1 = 0xfffff7ff;\n  }\n  if(i2cHandler->ErrorCode != 0){\n    I2C_ITError(i2cHandler);\n  }\n  return;\n}",
            "called": [
                "I2C_Slave_AF",
                "I2C_ITError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052f0",
            "calling": [
                "I2C1_ER_IRQHandler",
                "I2C2_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "checkI2CStatus_080052f0"
        },
        "FUN_08002f2c": {
            "renaming": {
                "FUN_08002f2c": "setCallback_08002f2c",
                "this": "firmataObject",
                "command": "commandByte",
                "newFunction": "callbackFunctionPointer",
                "PTR_currentReportDigitalCallback_08002f78": "currentReportDigitalCallback",
                "PTR_currentPinModeCallback_08002f7c": "currentPinModeCallback",
                "PTR_currentPinValueCallback_08002f80": "currentPinValueCallback",
                "PTR_currentAnalogCallback_08002f6c": "currentAnalogCallback",
                "PTR_currentDigitalCallback_08002f74": "currentDigitalCallback",
                "PTR_currentReportAnalogCallback_08002f70": "currentReportAnalogCallback"
            },
            "code": "void __thiscall firmata::FirmataClass::setCallback_08002f2c(FirmataClass *this, uint8_t command, callbackFunction newFunction) {\n  if (command == 0xd0) {\n    *(callbackFunction *)PTR_currentReportDigitalCallback_08002f78 = newFunction;\n    return;\n  }\n  if (command > 0xd0) {\n    if (command == 0xf4) {\n      *(callbackFunction *)PTR_currentPinModeCallback_08002f7c = newFunction;\n      return;\n    }\n    if (command == 0xf5) {\n      *(callbackFunction *)PTR_currentPinValueCallback_08002f80 = newFunction;\n    }\n    else if (command == 0xe0) {\n      *(callbackFunction *)PTR_currentAnalogCallback_08002f6c = newFunction;\n      return;\n    }\n    return;\n  }\n  if (command == 0x90) {\n    *(callbackFunction *)PTR_currentDigitalCallback_08002f74 = newFunction;\n    return;\n  }\n  if (command == 0xc0) {\n    *(callbackFunction *)PTR_currentReportAnalogCallback_08002f70 = newFunction;\n    return;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f2c",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "setCallback_08002f2c"
        },
        "FUN_08004954": {
            "renaming": {
                "FUN_08004954": "i2c_listen_08004954",
                "hi2c": "handle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "xfer_options",
                "HVar1": "status",
                "pIVar2": "instance",
                "tmpreg": "tmp_reg"
            },
            "code": "HAL_StatusTypeDef_conflict i2c_listen_08004954(I2C_HandleTypeDef_conflict *handle, uint8_t *data, uint16_t size, uint32_t xfer_options) {\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *instance;\n  uint32_t tmp_reg;\n  \n  if (handle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == NULL || size == 0 || handle->Lock == HAL_LOCKED) {\n      status = HAL_ERROR;\n    }\n    else {\n      handle->Lock = HAL_LOCKED;\n      instance = handle->Instance;\n      if ((instance->CR1 & 1) == 0) {\n        instance->CR1 |= 1;\n      }\n      handle->Instance->CR1 &= 0xfffff7ff;\n      handle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      handle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      handle->ErrorCode = 0;\n      handle->pBuffPtr = data;\n      handle->XferCount = size;\n      handle->XferOptions = xfer_options;\n      handle->XferSize = handle->XferCount;\n      handle->Lock = HAL_UNLOCKED;\n      handle->Instance->CR2 |= 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004954",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "i2c_listen_08004954"
        },
        "FUN_08005cec": {
            "renaming": {
                "FUN_08005cec": "configureTimer_08005cec",
                "TIMx": "timer",
                "OC_Config": "config",
                "uVar1": "ccEnableValue",
                "uVar2": "cr2Value",
                "uVar3": "ocMode",
                "CCER": "ccEnableMask",
                "DAT_08005d44": "PTR_08005d44"
            },
            "code": "void configureTimer_08005cec(TIM_TypeDef_conflict *timer, TIM_OC_InitTypeDef *config) {\n\tuint32_t ccEnableMask = 0xfffffffe;\n\tuint32_t cr2Value = timer->CR2;\n\tuint8_t ocMode = config->OCMode;\n\tuint32_t ccEnableValue = (timer->CCER & 0xfffffffd) | config->OCPolarity;\n\tif (timer == DAT_08005d44) {\n\t\tccEnableValue &= 0xfffffff7 | config->OCNPolarity;\n\t\tcr2Value = (cr2Value & 0xfffffcff) | config->OCIdleState | config->OCNIdleState;\n\t}\n\ttimer->CR2 = cr2Value;\n\ttimer->CCMR1 = (timer->CCMR1 & 0xffffff8c) | ocMode;\n\ttimer->CCR1 = config->Pulse;\n\ttimer->CCER = ccEnableValue;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cec",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configureTimer_08005cec"
        },
        "FUN_08003748": {
            "renaming": {
                "FUN_08003748": "update_tick_08003748",
                "*PTR_uwTick_08003758": "tick_ptr_ptr",
                "(uint)(byte)*PTR_uwTickFreq_0800375c": "tick_freq_ptr",
                "*(uint *)PTR_uwTick_08003758": "*tick_ptr",
                "uint": "uint32_t",
                "byte": "uint8_t",
                "int": "int32_t"
            },
            "code": "void update_tick_08003748(void)\n{\n    uint8_t tick_freq = *(uint)(byte)*PTR_uwTickFreq_0800375c;\n    uint32_t* tick_ptr = (uint32_t*)*PTR_uwTick_08003758;\n    *(uint *)PTR_uwTick_08003758 = *(uint *)PTR_uwTick_08003758 + tick_freq;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003748",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "update_tick_08003748"
        },
        "FUN_080040e8": {
            "renaming": {
                "FUN_080040e8": "configure_GPIO_080040e8",
                "GPIOx": "GPIO",
                "GPIO_Init": "config",
                "uVar2": "value2",
                "uVar3": "pin_mask",
                "uVar4": "result",
                "uVar5": "pin",
                "uVar6": "mode_bits",
                "uVar7": "speed_bits",
                "iVar8": "shift",
                "iVar10": "index",
                "tmpreg": "reg_value",
                "uVar9": "value9",
                "DAT_080042c8": "mode1",
                "DAT_080042cc": "mode2",
                "GPIO_TypeDef": "GPIO_TypeDef",
                "pGVar1": "gpio_reg",
                "reg_offset": "reg_offset",
                "reg_index": "reg_index",
                "pull_bits": "pull_bits",
                "LAB_0800423a": "skip_pull",
                "GPIO_InitTypeDef": "GPIO_InitTypeDef"
            },
            "code": "void configure_GPIO_080040e8(GPIO_TypeDef *GPIO, GPIO_InitTypeDef *config) {\n    uint32_t pin_mask;\n    uint32_t speed_bits;\n    uint32_t mode_bits;\n    GPIO_TypeDef *gpio_reg;\n    uint32_t reg_value;\n    uint32_t reg_offset;\n    uint32_t reg_index;\n    uint32_t pull_bits;\n    for (uint32_t pin = 0; pin <= 15; pin++) {\n        pin_mask = 1 << pin;\n        if ((config->Pin & pin_mask) == pin_mask) {\n            mode_bits = config->Mode & 0x0F;\n            if (mode_bits == GPIO_MODE_OUTPUT_PP) {\n                speed_bits = config->Speed & 0x03;\n                gpio_reg = GPIO;\n                reg_offset = (pin < 8) ? (pin * 4) : ((pin - 8) * 4);\n                gpio_reg->CRL = (gpio_reg->CRL & ~(0x0F << reg_offset)) | (speed_bits << reg_offset);\n            }\n            else if (mode_bits == GPIO_MODE_OUTPUT_OD) {\n                speed_bits = config->Speed & 0x03;\n                gpio_reg = GPIO;\n                reg_offset = (pin < 8) ? (pin * 4) : ((pin - 8) * 4);\n                gpio_reg->CRL = (gpio_reg->CRL & ~(0x0F << reg_offset)) | (speed_bits << reg_offset);\n                gpio_reg->BRR = pin_mask;\n            }\n            else if (mode_bits == GPIO_MODE_INPUT) {\n                pull_bits = config->Pull & 0x03;\n                gpio_reg = GPIO;\n                reg_offset = (pin < 8) ? (pin * 4) : ((pin - 8) * 4);\n                gpio_reg->CRL = (gpio_reg->CRL & ~(0x0F << reg_offset)) | (pull_bits << reg_offset);\n            }\n            else if (mode_bits == GPIO_MODE_IT_RISING) {\n                reg_index = pin / 4;\n                reg_offset = (pin % 4) * 4;\n                reg_value = (1 << reg_offset);\n                *(uint32_t *)(0x40021000 + 0x18) |= 1;\n                *(uint32_t *)(0x40021000 + ((reg_index + 2) * 4)) = (*(uint32_t *)(0x40021000 + ((reg_index + 2) * 4)) & ~(0x0F << reg_offset)) | (0 << reg_offset);\n                if ((config->Mode & GPIO_MODE_IT_PULL) == 0) {\n                    *(uint32_t *)(0x40021000 + 0x08) &= ~pin_mask;\n                }\n                else {\n                    *(uint32_t *)(0x40021000 + 0x08) |= pin_mask;\n                }\n                if ((config->Mode & GPIO_MODE_IT_FALLING) == 0) {\n                    *(uint32_t *)(0x40021000 + 0x0C) &= ~pin_mask;\n                }\n                else {\n                    *(uint32_t *)(0x40021000 + 0x0C) |= pin_mask;\n                }\n            }\n            else if (mode_bits == GPIO_MODE_IT_FALLING) {\n                reg_index = pin / 4;\n                reg_offset = (pin % 4) * 4;\n                reg_value = (1 << reg_offset);\n                *(uint32_t *)(0x40021000 + 0x18) |= 1;\n                *(uint32_t *)(0x40021000 + ((reg_index + 2) * 4)) = (*(uint32_t *)(0x40021000 + ((reg_index + 2) * 4)) & ~(0x0F << reg_offset)) | (0 << reg_offset);\n                if ((config->Mode & GPIO_MODE_IT_PULL) == 0) {\n                    *(uint32_t *)(0x40021000 + 0x08) &= ~pin_mask;\n                }\n                else {\n                    *(uint32_t *)(0x40021000 + 0x08) |= pin_mask;\n                }\n                if ((config->Mode & GPIO_MODE_IT_RISING) == 0) {\n                    *(uint32_t *)(0x40021000 + 0x10) &= ~pin_mask;\n                }\n                else {\n                    *(uint32_t *)(0x40021000 + 0x10) |= pin_mask;\n                }\n            }\n        }\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040e8",
            "calling": [
                "HAL_ADC_MspInit",
                "digital_io_init",
                "HAL_TIM_PWM_MspInit",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "configure_GPIO_080040e8"
        },
        "FUN_08009b6c": {
            "renaming": {
                "FUN_08009b6c": "process_data_08009b6c",
                "param_1": "data",
                "param_2": "params",
                "iVar1": "start_index",
                "piVar2": "step_ptr",
                "uVar3": "size",
                "uVar4": "flags",
                "iVar5": "step",
                "pcVar6": "func",
                "iVar7": "end_index",
                "uVar8": "old_data",
                "bVar9": "is_step_zero"
            },
            "code": "uint32_t process_data_08009b6c(uint32_t *data, int *params) {\n  int start_index = params[4];\n  uint16_t flags = *(uint16_t *)(params + 3);\n  uint32_t size = (uint32_t)flags;\n  if ((int)(size << 0x1c) < 0) {\n    if (start_index != 0) {\n      int step = size << 0x1e;\n      bool is_step_zero = step == 0;\n      if (is_step_zero) {\n        step = 0;\n      }\n      int end_index = *params;\n      if (!is_step_zero) {\n        step = params[5];\n      }\n      *params = start_index;\n      params[2] = step;\n      for (int i = end_index - start_index; i > 0; i -= step) {\n        int result = (*(code *)params[10])(data, params[8], start_index, i);\n        if (result < 1) {\n          flags |= 0x40;\n          *(uint16_t *)(params + 3) = flags;\n          return 0xffffffff;\n        }\n        start_index += result;\n      }\n    }\n  } else if (((params[1] > 0) || (params[0x10] > 0)) && (params[0xb] != 0)) {\n    code *func = (code *)params[0xb];\n    uint32_t old_data = *data;\n    *data = 0;\n    if ((flags & 0x1000) == 0) {\n      int result = (*func)(data, params[8], size & 0x1000, 1);\n      if ((result == -1) && (*data != 0)) {\n        if ((*data != 0x1d) && (*data != 0x16)) {\n          flags |= 0x40;\n          *(uint16_t *)(params + 3) = flags;\n          return 0xffffffff;\n        }\n        *data = old_data;\n        return 0;\n      }\n    } else {\n      int result = params[0x15];\n    }\n    if (((int)((uint)flags << 0x1d) < 0) && (params[0xd] != 0)) {\n      int step = params[0x10];\n      if (params[0xd] != params + 0x11) {\n        _free_r(data);\n      }\n      params[0xd] = 0;\n    }\n    int result = (*(code *)params[0xb])(data, params[8], start_index - params[4], 0);\n    flags = *(uint16_t *)(params + 3);\n    if ((result == -1) && ((0x1d < *data) || (-1 < (int)((DAT_08009c78 >> (*data & 0xff)) << 0x1f))))) {\n      flags |= 0x40;\n      *(uint16_t *)(params + 3) = flags;\n      return 0xffffffff;\n    }\n    params[1] = 0;\n    *params = start_index;\n    if (((int)((uint)flags << 0x13) < 0) && ((result != -1) || (*data == 0))) {\n      params[0x15] = result;\n    }\n    if (params[0xd] != 0) {\n      params[0xd] = 0;\n    }\n  }\n  return 0;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009b6c",
            "calling": [
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "process_data_08009b6c"
        },
        "FUN_0800288c": {
            "renaming": {
                "__thiscall TwoWire::FUN_0800288c": "transmitData",
                "this": "wire",
                "data": "data",
                "puVar1": "txBuffer",
                "iVar2": "status",
                "pvVar3": "bufferPtr",
                "sVar4": "returnVal",
                "cVar5": "bufferIndex",
                "uVar6": "allocatedSize",
                "__size": "dataSize",
                "local_11": "localData",
                "FUN_0800288c": "transmitData_0800288c"
            },
            "code": "size_t __thiscall transmitData_0800288c(TwoWire *wire, uint8_t data)\\n{\\n    undefined *txBuffer;\\n    uint8_t localData = data;\\n    i2c_status_e_conflict status;\\n    void *bufferPtr;\\n    size_t dataSize;\\n    char bufferIndex;\\n    undefined allocatedSize;\\n    size_t returnVal;\\n\\n    txBuffer = PTR_txBuffer_08002914;\\n\\n    if (*PTR_transmitting_08002908 == \"\\0\") {\\n        status = i2c_slave_transmitData_0800288c_IT((i2c_t_conflict *)&wire->_i2c, &localData, 1);\\n        returnVal = (status == I2C_OK) ? 1 : 0;\\n    }\\n    else {\\n        dataSize = (byte)*PTR_txBufferLength_0800290c + 1;\\n        if ((byte)*PTR_txBufferAllocated_08002910 < dataSize) {\\n            if (dataSize < 0x20) {\\n                dataSize = 0x20;\\n            }\\n            bufferPtr = realloc(*(void **)PTR_txBuffer_08002914, dataSize);\\n            *(void **)txBuffer = bufferPtr;\\n            allocatedSize = (bufferPtr == (void *)0x0) ? 0 : (undefined)dataSize;\\n            *PTR_txBufferAllocated_08002910 = allocatedSize;\\n        }\\n        bufferIndex = *PTR_txBufferIndex_08002918;\\n        if (*(int *)PTR_txBuffer_08002914 == 0) {\\n            (wire->super_Stream).super_Print.transmitData_0800288c_error = 1;\\n            returnVal = 0;\\n        }\\n        else {\\n            *(uint8_t *)(*(int *)PTR_txBuffer_08002914 + (uint)(byte)bufferIndex) = localData;\\n            bufferIndex++;\\n            *PTR_txBufferIndex_08002918 = bufferIndex;\\n            *PTR_txBufferLength_0800290c = bufferIndex;\\n            returnVal = 1;\\n        }\\n    }\\n    return returnVal;\\n}",
            "called": [
                "i2c_slave_write_IT",
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800288c",
            "calling": [
                "wireWrite"
            ],
            "imported": false,
            "current_name": "transmitData_0800288c"
        },
        "FUN_08002e26": {
            "renaming": {
                "FUN_08002e26": "initializeFirmata_08002e26",
                "s": "stream",
                "printVersion": "printVersionInfo",
                "this->FirmataStream": "this->stream",
                "this->marshaller": "this->marshaller"
            },
            "code": "void __thiscall firmata::FirmataClass::initializeFirmata_08002e26(Stream *stream){\n  this->FirmataStream = stream;\n  FirmataMarshaller::initializeMarshaller(&this->marshaller, stream);\n  printVersionInfo(this);\n  printFirmwareVersion(this);\n  return;\n}",
            "called": [
                "printVersion",
                "begin",
                "printFirmwareVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e26",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initializeFirmata_08002e26"
        },
        "FUN_0800010c": {
            "renaming": {
                "FUN_0800010c": "check_if_initialized_0800010c",
                "param_1": "input_str",
                "*PTR_completed_8667_08000124": "*PTR_completed",
                "DAT_08000128": "DAT_init_flag",
                "PTR__init_0800012c": "PTR_init_string"
            },
            "code": "char* check_if_initialized_0800010c(char* input_str) {\\n  if (*PTR_completed_8667_08000124 == \"\\0\") {\\n    if (DAT_08000128 != 0) {\\n      input_str = PTR__init_0800012c;\\n    }\\n    *PTR_completed_8667_08000124 = 1;\\n  }\\n  return input_str;\\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800010c",
            "calling": [],
            "imported": false,
            "current_name": "check_if_initialized_0800010c"
        },
        "FUN_080086e8": {
            "renaming": {
                "FUN_080086e8": "get_uart_handler_index_080086e8",
                "*huart": "*uart_handler",
                "uVar1": "index"
            },
            "code": "uint8_t get_uart_handler_index_080086e8(UART_HandleTypeDef *uart_handler) {\n    uint8_t index;\n    if (uart_handler == NULL) {\n        index = 5;\n    }\n    else {\n        index = 0;\n        while (index < 5) {\n            if (uart_handler == *(UART_HandleTypeDef **)(PTR_uart_handlers_08008708 + index * 4)) break;\n            index++;\n        }\n    }\n    return index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080086e8",
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "imported": false,
            "current_name": "get_uart_handler_index_080086e8"
        },
        "FUN_08001c18": {
            "renaming": {
                "FUN_08001c18": "readI2CData_08001c18",
                "address": "deviceAddress",
                "theRegister": "registerAddress",
                "numBytes": "numBytesToRead",
                "stopTX": "stopTX",
                "bVar1": "dataAvailable",
                "puVar2": "wirePtr",
                "bVar3": "dataByte",
                "iVar4": "bytesAvailable",
                "iVar5": "byteCount",
                "uVar6": "numBytes"
            },
            "code": "void readI2CData_08001c18(byte deviceAddress, int registerAddress, byte numBytesToRead, byte stopTX)\n{\n  bool dataAvailable;\n  undefined *wirePtr;\n  byte dataByte;\n  int bytesAvailable;\n  uint numBytes = (uint)numBytesToRead;\n  wirePtr = PTR_Wire_08001cbc;\n  if (registerAddress == -1)\n  {\n    registerAddress = 0;\n  }\n  else\n  {\n    TwoWire::beginTransmission((TwoWire *)PTR_Wire_08001cbc, deviceAddress);\n    wireWrite((byte)registerAddress);\n    TwoWire::endTransmission((TwoWire *)wirePtr, stopTX);\n  }\n  wirePtr = PTR_Wire_08001cbc;\n  TwoWire::requestFrom((TwoWire *)PTR_Wire_08001cbc, deviceAddress, numBytesToRead);\n  bytesAvailable = TwoWire::available((TwoWire *)wirePtr);\n  if ((int)numBytes < bytesAvailable)\n  {\n    firmata::FirmataClass::sendString((FirmataClass *)PTR_Firmata_08001cc4, PTR_s_I2C__Too_many_bytes_received_08001cc0);\n  }\n  else\n  {\n    bytesAvailable = TwoWire::available((TwoWire *)PTR_Wire_08001cbc);\n    if (bytesAvailable < (int)numBytes)\n    {\n      firmata::FirmataClass::sendString((FirmataClass *)PTR_Firmata_08001cc4, PTR_s_I2C__Too_few_bytes_received_08001ccc);\n    }\n  }\n  wirePtr = PTR_i2cRxData_08001cc8;\n  *PTR_i2cRxData_08001cc8 = deviceAddress;\n  wirePtr[1] = (char)registerAddress;\n  int byteCount = 0;\n  while(true)\n  {\n    if (byteCount < (int)numBytes)\n    {\n      bytesAvailable = TwoWire::available((TwoWire *)PTR_Wire_08001cbc);\n      if (bytesAvailable == 0)\n      {\n        dataAvailable = false;\n      }\n      else\n      {\n        dataAvailable = true;\n      }\n    }\n    else\n    {\n      dataAvailable = false;\n    }\n    if (!dataAvailable)\n    {\n      break;\n    }\n    dataByte = wireRead();\n    PTR_i2cRxData_08001cc8[byteCount + 2] = dataByte;\n    byteCount++;\n  }\n  firmata::FirmataClass::sendSysex((FirmataClass *)PTR_Firmata_08001cc4, 'w', numBytesToRead + '\\x02', PTR_i2cRxData_08001cc8);\n  return;\n}",
            "called": [
                "beginTransmission",
                "endTransmission",
                "available",
                "wireWrite",
                "wireRead",
                "sendString",
                "sendSysex",
                "requestFrom"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c18",
            "calling": [
                "loop",
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "readI2CData_08001c18"
        },
        "FUN_08009056": {
            "renaming": {
                "FUN_08009056": "handle_GPIO_EXTI_IRQs_08009056",
                "uVar1": "pin_num"
            },
            "code": "void handle_GPIO_EXTI_IRQs_08009056(void)\n{\n  uint16_t pin_num;\n  for (pin_num = 0x20; pin_num < 0x201; pin_num = pin_num << 1) {\n    HAL_GPIO_EXTI_IRQHandler(pin_num);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009056",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_EXTI_IRQs_08009056"
        },
        "FUN_08002e1a": {
            "renaming": {
                "FUN_08002e1a": "printFirmwareVersionIfContextNotNull_08002e1a",
                "param_2": "paramSize1",
                "param_3": "paramSize2",
                "param_4": "paramCharPtr",
                "context": "context"
            },
            "code": "void firmata::FirmataClass::printFirmwareVersionIfContextNotNull_08002e1a(void *context,size_t paramSize1,size_t paramSize2,char *paramCharPtr) {\n  if (context != nullptr) {\n    printFirmwareVersion(static_cast<FirmataClass *>(context));\n    return;\n  }\n  return;\n}",
            "called": [
                "printFirmwareVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e1a",
            "calling": [],
            "imported": false,
            "current_name": "printFirmwareVersionIfContextNotNull_08002e1a"
        },
        "FUN_0800904c": {
            "renaming": {
                "FUN_0800904c": "handle_GPIO_EXTI_interrupt_0800904c",
                "DAT_0800c000": "GPIO_PIN_4"
            },
            "code": "void handle_GPIO_EXTI_interrupt_0800904c(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(DAT_0800c000);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800904c",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_EXTI_interrupt_0800904c"
        },
        "FUN_080073ae": {
            "renaming": {
                "FUN_080073ae": "get_non_null_pointer_080073ae",
                "a": "ptr1",
                "b": "ptr2"
            },
            "code": "void * get_non_null_pointer_080073ae(void *ptr1, void *ptr2) {\n  if (ptr1 != ptr2) {\n    if (ptr1 == NULL) {\n      return ptr2;\n    }\n    if (ptr2 == NULL) {\n      return ptr1;\n    }\n    ptr1 = NULL;\n  }\n  return ptr1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073ae",
            "calling": [
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "get_non_null_pointer_080073ae"
        },
        "FUN_08003f0c": {
            "renaming": {
                "FUN_08003f0c": "set_priority_group_08003f0c",
                "PriorityGroup": "priority_group",
                "DAT_08003f2c": "priority_register",
                "PTR_": "ptr_"
            },
            "code": "void set_priority_group_08003f0c(uint32_t priority_group) {\n    uint32_t* priority_reg = (uint32_t*)(DAT_08003f2c + 0xc);\n    uint32_t priority_masked = *(uint32_t*)priority_reg & 0xf8ff;\n    uint32_t new_priority = (priority_group & 0x7) << 8 | priority_masked | 0x5fa0000;\n    *priority_reg = new_priority;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f0c",
            "calling": [
                "HAL_Init",
                "premain"
            ],
            "imported": false,
            "current_name": "set_priority_group_08003f0c"
        },
        "FUN_08000488": {
            "renaming": {
                "FUN_08000488": "report_analog_input_08000488",
                "analogPin": "analog_input_pin",
                "value": "input_value",
                "ulPin": "pin",
                "value_00": "input_reading",
                "PTR_analogInputsToReport_080004c8": "analog_inputs_to_report",
                "PTR_isResetting_080004cc": "is_resetting",
                "PTR_Firmata_080004d0": "firmata_instance"
            },
            "code": "void report_analog_input_08000488(byte analog_input_pin, int input_value) {\\n    uint32_t pin = (uint32_t)analog_input_pin;\\n    if (pin < 0xe) {\\n        if (input_value == 0) {\\n            *(uint32_t*)PTR_analogInputsToReport_080004c8 =\\n                *(uint32_t*)PTR_analogInputsToReport_080004c8 & ~(1 << pin);\\n            return;\\n        }\\n        *(uint32_t*)PTR_analogInputsToReport_080004c8 =\\n            1 << pin | *(uint32_t*)PTR_analogInputsToReport_080004c8;\\n        if (*PTR_isResetting_080004cc == \"\\0\") {\\n            uint32_t input_reading = analogRead(pin);\\n            firmata::FirmataClass::sendAnalog((FirmataClass*)PTR_Firmata_080004d0, analog_input_pin, input_reading);\\n            return;\\n        }\\n    }\\n    return;\\n}",
            "called": [
                "sendAnalog",
                "analogRead"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000488",
            "calling": [
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "report_analog_input_08000488"
        },
        "FUN_08006bb8": {
            "renaming": {
                "FUN_08006bb8": "get_GPIO_08006bb8",
                "port_idx": "port_index",
                "pGVar1": "gpio",
                "tmpreg": "temporary_register",
                "tmpreg_1": "temporary_register_1",
                "tmpreg_2": "temporary_register_2",
                "tmpreg_3": "temporary_register_3",
                "tmpreg_4": "temporary_register_4"
            },
            "code": "GPIO_TypeDef * get_GPIO_08006bb8(uint32_t port_index) {\n    GPIO_TypeDef *gpio;\n    uint32_t tmpreg;\n    uint32_t tmpreg_1;\n    uint32_t tmpreg_2;\n    uint32_t tmpreg_3;\n    uint32_t tmpreg_4;\n\n    switch(port_index) {\n        case 0:\n            *(uint *)(DAT_08006c48 + 0x18) |= 4;\n            gpio = DAT_08006c4c;\n            break;\n        case 1:\n            *(uint *)(DAT_08006c48 + 0x18) |= 8;\n            gpio = DAT_08006c50;\n            break;\n        case 2:\n            *(uint *)(DAT_08006c48 + 0x18) |= 0x10;\n            gpio = DAT_08006c54;\n            break;\n        case 3:\n            *(uint *)(DAT_08006c48 + 0x18) |= 0x20;\n            gpio = DAT_08006c58;\n            break;\n        case 4:\n            *(uint *)(DAT_08006c48 + 0x18) |= 0x40;\n            gpio = DAT_08006c5c;\n            break;\n        default:\n            gpio = (GPIO_TypeDef *)0x0;\n    }\n    return gpio;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006bb8",
            "calling": [
                "HAL_ADC_MspInit",
                "digital_io_init",
                "HAL_TIM_PWM_MspInit",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "get_GPIO_08006bb8"
        },
        "FUN_08004aec": {
            "renaming": {
                "FUN_08004aec": "handleI2CEvents_08004aec",
                "*hi2c": "*i2cHandle",
                "XferOptions": "transferOptions",
                "State": "state",
                "PreviousState": "previousState",
                "Mode": "mode",
                "Instance": "instance",
                "CR1": "cr1",
                "CR2": "cr2",
                "SR1": "sr1",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "HAL_I2C_ListenCpltCallback": "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveTxCpltCallback": "HAL_I2C_SlaveTxCpltCallback"
            },
            "code": "HAL_StatusTypeDef_conflict handleI2CEvents_08004aec(I2C_HandleTypeDef_conflict *i2cHandle) {\n    if (((i2cHandle->transferOptions == 4) || (i2cHandle->transferOptions == 8)) && (i2cHandle->state == HAL_I2C_STATE_LISTEN)) {\n        i2cHandle->transferOptions = DAT_08004b7c;\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->Instance->SR1 = 0xfffffbff;\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        i2cHandle->previousState = 0;\n        i2cHandle->state = HAL_I2C_STATE_READY;\n        i2cHandle->mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_ListenCpltCallback(i2cHandle);\n    }\n    else if (i2cHandle->state == HAL_I2C_STATE_BUSY_TX) {\n        i2cHandle->transferOptions = DAT_08004b7c;\n        i2cHandle->previousState = 0x21;\n        i2cHandle->state = HAL_I2C_STATE_READY;\n        i2cHandle->mode = HAL_I2C_MODE_NONE;\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->Instance->SR1 = 0xfffffbff;\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n    }\n    else {\n        i2cHandle->Instance->SR1 = 0xfffffbff;\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004aec",
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "handleI2CEvents_08004aec"
        },
        "FUN_08007ede": {
            "renaming": {
                "FUN_08007ede": "transferData_08007ede",
                "obj": "conflictObj",
                "data": "data",
                "size": "dataSize",
                "uVar1": "index",
                "i2cTxRxBuffer": "i2cTxRxBuffer",
                "i2cTxRxBufferSize": "i2cTxRxBufferSize",
                "I2C_ERROR": "I2C_ERROR",
                "I2C_OK": "I2C_OK"
            },
            "code": "i2c_status_e transferData_08007ede(i2c_t_conflict *conflictObj, uint8_t *data, uint16_t dataSize) {\n  uint8_t index = 0;\n\n  if (dataSize > 0x20) {\n    return I2C_ERROR;\n  }\n\n  for (index = 0; index < dataSize; index++) {\n    conflictObj->i2cTxRxBuffer[index] = data[index];\n    conflictObj->i2cTxRxBufferSize++;\n  }\n\n  return I2C_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ede",
            "calling": [
                "write",
                "write"
            ],
            "imported": false,
            "current_name": "transferData_08007ede"
        },
        "FUN_08004728": {
            "renaming": {
                "FUN_08004728": "send_i2c_data_08004728",
                "hi2c": "handle",
                "DevAddress": "address",
                "pData": "data",
                "Size": "size",
                "HVar1": "status",
                "pIVar2": "i2c_instance",
                "count": "count",
                "DAT_080047ec": "count_constant",
                "PTR_SystemCoreClock_080047e8": "system_core_clock_ptr",
                "hi2c->State": "handle->State",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "handle->PreviousState": "handle->PreviousState",
                "handle->State": "handle->State",
                "handle->Lock": "handle->Lock",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIMEOUT": "HAL_TIMEOUT",
                "i2c_instance->SR2": "i2c_instance->SR2",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_BUSY": "HAL_BUSY",
                "i2c_instance->CR1": "i2c_instance->CR1",
                "handle->Instance->CR1": "handle->Instance->CR1",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "HAL_I2C_MODE_MASTER": "HAL_I2C_MODE_MASTER",
                "HAL_OK": "HAL_OK",
                "handle->ErrorCode": "handle->ErrorCode",
                "handle->pBuffPtr": "handle->pBuffPtr",
                "handle->XferCount": "handle->XferCount",
                "xfer_options_constant": "handle->XferOptions",
                "handle->XferSize": "handle->XferSize",
                "handle->Devaddress": "handle->Devaddress",
                "handle->Instance->CR2": "handle->Instance->CR2"
            },
            "code": "HAL_StatusTypeDef_conflict send_i2c_data_08004728(I2C_HandleTypeDef_conflict *handle, uint16_t address, uint8_t *data, uint16_t size)\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2c_instance;\n  uint32_t count;\n  \n  if (handle->State == HAL_I2C_STATE_READY) {\n    count = (uint)((ulonglong)DAT_080047ec * (ulonglong)(*(uint *)PTR_SystemCoreClock_080047e8 >> 3) >> 0x28) * 0x19;\n    do {\n      if (count == 0) {\n        handle->PreviousState = 0;\n        handle->State = HAL_I2C_STATE_READY;\n        handle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      i2c_instance = handle->Instance;\n      count = count - 1;\n    } while ((i2c_instance->SR2 & 2) != 0);\n    if (handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      handle->Lock = HAL_LOCKED;\n      if ((i2c_instance->CR1 & 1) == 0) {\n        i2c_instance->CR1 = i2c_instance->CR1 | 1;\n      }\n      handle->Instance->CR1 = handle->Instance->CR1 & 0xfffff7ff;\n      handle->State = HAL_I2C_STATE_BUSY_TX;\n      handle->Mode = HAL_I2C_MODE_MASTER;\n      status = HAL_OK;\n      handle->ErrorCode = 0;\n      handle->pBuffPtr = data;\n      handle->XferCount = size;\n      handle->XferOptions = xfer_options_constant;\n      handle->XferSize = handle->XferCount;\n      handle->Devaddress = (uint)address;\n      handle->Instance->CR1 = handle->Instance->CR1 | 0x100;\n      handle->Lock = HAL_UNLOCKED;\n      handle->Instance->CR2 = handle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004728",
            "calling": [
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "send_i2c_data_08004728"
        },
        "FUN_080074e0": {
            "renaming": {
                "FUN_080074e0": "clear_timer_interrupt_flags_080074e0",
                "htim": "timer",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "Instance": "timer_instance",
                "DAT_08007534": "TIM2",
                "DAT_08007538": "TIM4",
                "DAT_0800753c": "TIM5",
                "DAT_08007540": "TIMER_BASE_ADDRESS"
            },
            "code": "void clear_timer_interrupt_flags_080074e0(TIM_HandleTypeDef_conflict *timer)\n{\n    if (timer->Instance == DAT_08007534) {\n        uint32_t *interrupt_flags_register = (uint32_t *)(DAT_08007540 + 0x18);\n        *interrupt_flags_register &= ~(1 << 11);\n    }\n    if (timer->Instance == TIM3) {\n        uint32_t *interrupt_flags_register = (uint32_t *)(DAT_08007540 + 0x1C);\n        *interrupt_flags_register &= ~(1 << 0);\n    }\n    if (timer->Instance == DAT_08007538) {\n        uint32_t *interrupt_flags_register = (uint32_t *)(DAT_08007540 + 0x1C);\n        *interrupt_flags_register &= ~(1 << 1);\n    }\n    if (timer->Instance == DAT_0800753c) {\n        uint32_t *interrupt_flags_register = (uint32_t *)(DAT_08007540 + 0x1C);\n        *interrupt_flags_register &= ~(1 << 2);\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080074e0",
            "calling": [
                "HAL_TIM_PWM_MspDeInit",
                "HAL_TIM_OC_MspDeInit"
            ],
            "imported": false,
            "current_name": "clear_timer_interrupt_flags_080074e0"
        },
        "FUN_080073c0": {
            "renaming": {
                "FUN_080073c0": "execute_RTC_user_callback_080073c0",
                "hrtc": "rtc_handle",
                "PTR_RTCUserCallback_080073d0": "user_callback_ptr",
                "code": "function_pointer",
                "PTR_callbackUserData_080073d4": "user_callback_data_ptr",
                "undefined4": "uint32_t"
            },
            "code": "void execute_RTC_user_callback_080073c0(RTC_HandleTypeDef *rtc_handle)\n{\n  if (*PTR_RTCUserCallback_080073d0 != NULL) {\n    (**PTR_RTCUserCallback_080073d0)(*(uint32_t *)PTR_callbackUserData_080073d4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073c0",
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "imported": false,
            "current_name": "execute_RTC_user_callback_080073c0"
        },
        "FUN_080084b0": {
            "renaming": {
                "FUN_080084b0": "initialize_uart_080084b0",
                "PinName_conflict pin": "PinName_conflict uart_tx_pin",
                "undefined *obj": "void *serial_debug_obj",
                "PinName_conflict PVar1": "PinName_conflict uart_rx_pin",
                "void *pvVar2": "void *peripheral",
                "PTR_digitalPin_080084f0": "digitalPin",
                "PTR_PinMap_UART_TX_080084f4": "PinMap_UART_TX",
                "PTR_PinMap_UART_RX_080084f8": "PinMap_UART_RX",
                "PTR_serial_debug_080084fc": "serial_debug"
            },
            "code": "void initialize_uart_080084b0(void)\n{\n  PinName_conflict uart_tx_pin = PTR_digitalPin_080084f0[1];\n  void *peripheral = pinmap_peripheral(uart_tx_pin, (PinMap_conflict *)PTR_PinMap_UART_TX_080084f4);\n  if (peripheral != NULL)\n  {\n    PinName_conflict uart_rx_pin = pinmap_pin(peripheral, (PinMap_conflict *)PTR_PinMap_UART_RX_080084f8);\n    void *PTR_serial_debug_080084fc_obj = PTR_serial_debug_080084fc;\n    PTR_serial_debug_080084fc[0x59] = uart_rx_pin;\n    PTR_serial_debug_080084fc[0x58] = uart_tx_pin;\n    *(undefined4 *)(PTR_serial_debug_080084fc + 0x48) = 9600;\n    *(undefined4 *)(PTR_serial_debug_080084fc + 0x54) = 0;\n    *(undefined4 *)(PTR_serial_debug_080084fc + 0x4c) = 0;\n    *(undefined4 *)(PTR_serial_debug_080084fc + 0x50) = 0;\n    uart_init((serial_t *)PTR_serial_debug_080084fc_obj);\n  }\n  return;\n}",
            "called": [
                "pinmap_pin",
                "pinmap_peripheral",
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080084b0",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "initialize_uart_080084b0"
        },
        "FUN_080095a8": {
            "renaming": {
                "FUN_080095a8": "calculate_output_value_080095a8",
                "param_1": "input_value",
                "param_2": "min_max_values",
                "param_3": "output_value",
                "param_4": "unused_value",
                "param_5": "function_pointer",
                "uVar2": "bit_mask",
                "uVar3": "byte_index",
                "bVar4": "bit_mask_condition",
                "iVar1": "function_return_value"
            },
            "code": "int calculate_output_value_080095a8(uint32_t input_value, uint32_t *min_max_values, uint32_t *output_value, uint32_t unused_value, code *function_pointer)\n{\n  int function_return_value;\n  uint32_t max_value = min_max_values[4];\n  if ((int)min_max_values[4] < (int)min_max_values[2]) {\n    max_value = min_max_values[2];\n  }\n  *output_value = max_value;\n  if (*(char *)((int)min_max_values + 0x43) != \"\\0\") {\n    *output_value = max_value + 1;\n  }\n  if ((int)(*min_max_values << 0x1a) < 0) {\n    *output_value = *output_value + 2;\n  }\n  uint32_t bit_mask = *min_max_values & 6;\n  if (bit_mask == 0) {\n    for (; (int)bit_mask < (int)(min_max_values[3] - *output_value); bit_mask++) {\n      function_return_value = (*function_pointer)(input_value, unused_value, (int)min_max_values + 0x19, 1);\n      if (function_return_value == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  uint32_t byte_value = (uint32_t)*(byte *)((int)min_max_values + 0x43);\n  if (byte_value != 0) {\n    byte_value = 1;\n  }\n  uint32_t byte_index = byte_value;\n  if ((int)(*min_max_values << 0x1a) < 0) {\n    *(undefined *)((int)min_max_values + byte_value + 0x43) = 0x30;\n    byte_index = byte_value + 2;\n    *(undefined *)((int)min_max_values + byte_value + 0x44) = *(undefined *)((int)min_max_values + 0x45);\n  }\n  function_return_value = (*function_pointer)(input_value, unused_value, (int)min_max_values + 0x43, byte_index);\n  if (function_return_value != -1) {\n    uint32_t output_length = min_max_values[3];\n    bool bit_mask_condition = (*min_max_values & 6) != 4;\n    if (bit_mask_condition) {\n      output_length = 0;\n    }\n    uint32_t output_index = 0;\n    if (!bit_mask_condition) {\n      output_length = output_length - *output_value;\n    }\n    if (!bit_mask_condition) {\n      output_length = output_length & ~((int)output_length >> 0x1f);\n    }\n    if ((int)min_max_values[4] < (int)min_max_values[2]) {\n      output_length = output_length + (min_max_values[2] - min_max_values[4]);\n    }\n    while( true ) {\n      if (output_length == output_index) {\n        return 0;\n      }\n      function_return_value = (*function_pointer)(input_value, unused_value, (int)min_max_values + 0x1a, 1);\n      if (function_return_value == -1) break;\n      output_index++;\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080095a8",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "calculate_output_value_080095a8"
        },
        "FUN_08008b2a": {
            "renaming": {
                "FUN_08008b2a": "readByte_08008b2a",
                "__thiscall HardwareSerial": "HardwareSerial",
                "this": "serial",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "bVar1": "receivedByte",
                "uVar2": "tailIndex",
                "_serial": "serialData",
                "rx_tail": "tailIndex",
                "rx_head": "headIndex",
                "rx_buff": "receiveBuffer"
            },
            "code": "ssize_t __thiscall HardwareSerial::readByte_08008b2a(HardwareSerial *serial,int fileDescriptor,void *buffer,size_t numBytes) {\n  byte receivedByte;\n  ushort tailIndex;\n  \n  tailIndex = (serial->_serial).rx_tail;\n  if ((uint)(serial->_serial).rx_head != (uint)tailIndex) {\n    receivedByte = (serial->_serial).rx_buff[tailIndex];\n    (serial->_serial).rx_tail = (tailIndex + 1) & 0x3f;\n    return (uint)receivedByte;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b2a",
            "calling": [],
            "imported": false,
            "current_name": "readByte_08008b2a"
        },
        "FUN_08003bd8": {
            "renaming": {
                "FUN_08003bd8": "configureADC_08003bd8",
                "*hadc": "*adc",
                "HVar1": "status",
                "uVar2": "unusedVar2",
                "uVar3": "dataAlignExternalTrigConvContinuousConvMode",
                "uVar4": "scanConvModeNbrOfDiscConversion",
                "uVar5": "continuousConvMode",
                "DAT_08003ce0": "unusedVar3",
                "DAT_08003ce4": "unusedVar4"
            },
            "code": "HAL_StatusTypeDef_conflict configureADC_08003bd8(ADC_HandleTypeDef *adc) {\n  HAL_StatusTypeDef_conflict status;\n  uint32_t state;\n  uint32_t cr1;\n  uint32_t cr2;\n  uint32_t sqr1;\n  uint32_t uVar5;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  if (adc == NULL) {\n    return HAL_ERROR;\n  }\n  if (adc->State == 0) {\n    adc->ErrorCode = 0;\n    adc->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(adc);\n  }\n  status = ADC_ConversionStop_Disable(adc);\n  state = adc->State & 0x10;\n  if ((state == 0) && (status == HAL_OK)) {\n    adc->State = adc->State & 0xffffeefd | 2;\n    uVar5 = adc->Init.ContinuousConvMode;\n    uVar3 = adc->Init.DataAlign | adc->Init.ExternalTrigConv | uVar5 << 1;\n    uVar4 = adc->Init.ScanConvMode;\n    if (uVar4 == 0x100 || uVar4 == 1) {\n      uVar4 = 0x100;\n    }\n    if (adc->Init.DiscontinuousConvMode == 1) {\n      if (uVar5 == 0) {\n        uVar4 |= (adc->Init.NbrOfDiscConversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        adc->State |= 0x20;\n        adc->ErrorCode |= 1;\n      }\n    }\n    cr1 = adc->Instance->CR1;\n    cr1 &= 0xffff16ff;\n    cr1 |= uVar4;\n    adc->Instance->CR1 = cr1;\n    cr2 = adc->Instance->CR2;\n    cr2 &= 0x0000FFFF;\n    cr2 |= uVar3;\n    adc->Instance->CR2 = cr2;\n    uVar4 = adc->Init.ScanConvMode;\n    if (uVar4 == 0x100 || uVar4 == 1) {\n      uVar4 = (adc->Init.NbrOfConversion - 1) * 0x100000;\n    }\n    else {\n      uVar4 = 0;\n    }\n    sqr1 = adc->Instance->SQR1;\n    sqr1 &= 0xff0fffff;\n    sqr1 |= uVar4;\n    adc->Instance->SQR1 = sqr1;\n    if (uVar3 != (0x00000FFF & adc->Instance->CR2)) {\n      adc->State = adc->State & 0xffffffed | 0x10;\n      adc->ErrorCode |= 1;\n      return HAL_ERROR;\n    }\n    adc->ErrorCode = 0;\n    adc->State = adc->State & 0xfffffffc | 1;\n    return HAL_OK;\n  }\n  adc->State |= 0x10;\n  return HAL_ERROR;\n}",
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003bd8",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "configureADC_08003bd8"
        },
        "FUN_08009d50": {
            "renaming": {
                "FUN_08009d50": "initialize_struct_08009d50",
                "param_1": "struct_ptr",
                "PTR__global_impure_ptr_08009da8": "global_impure_ptr",
                "DAT_08009dac": "default_value",
                "uVar1": "float_value",
                "iVar2": "is_global_ptr",
                "bVar3": "is_current_ptr_global"
            },
            "code": "void initialize_struct_08009d50(int struct_ptr)\n{\n  if (*(int *)(struct_ptr + 0x18) == 0) {\n    int is_global_ptr = *(int *)PTR__global_impure_ptr_08009da8;\n    *(int *)(struct_ptr + 0x48) = 0;\n    *(int *)(struct_ptr + 0x4c) = 0;\n    *(int *)(struct_ptr + 0x50) = 0;\n    *(int *)(struct_ptr + 0x28) = DAT_08009dac;\n    bool is_current_ptr_global = struct_ptr == is_global_ptr;\n    if (is_current_ptr_global) {\n      is_global_ptr = 1;\n    }\n    if (is_current_ptr_global) {\n      *(int *)(struct_ptr + 0x18) = is_global_ptr;\n    }\n    float first_value = get_float_value();\n    float second_value = get_float_value(struct_ptr);\n    float third_value = get_float_value(struct_ptr);\n    std_isra_0(first_value, 4, 0);\n    std_isra_0(second_value, 9, 1);\n    std_isra_0(third_value, 0x12, 2);\n    *(int *)(struct_ptr + 0x18) = 1;\n  }\n  return;\n}",
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009d50",
            "calling": [
                "_fflush_r",
                "__swbuf_r",
                "_vfiprintf_r",
                "__swsetup_r",
                "__sfp",
                "iprintf"
            ],
            "imported": false,
            "current_name": "initialize_struct_08009d50"
        },
        "FUN_08009108": {
            "renaming": {
                "FUN_08009108": "calculate_result_08009108",
                "param_1": "flag",
                "param_2": "input_value"
            },
            "code": "longlong calculate_result_08009108(undefined4 flag, uint input_value) {\n  if (DAT_08009120 != 0) {\n    return CONCAT44(flag, 2);\n  }\n  return (ulonglong)input_value << 0x20;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009108",
            "calling": [
                "__aeabi_atexit"
            ],
            "imported": false,
            "current_name": "calculate_result_08009108"
        },
        "FUN_08009f98": {
            "renaming": {
                "FUN_08009f98": "execute_function_08009f98",
                "param_1": "result",
                "param_2": "function_index",
                "param_3": "arg1",
                "param_4": "arg2",
                "_Var1": "process_id",
                "uVar2": "result",
                "iVar3": "function_pointer",
                "pcVar4": "function"
            },
            "code": "int execute_function_08009f98(int* result, uint function_index, int arg1, int arg2) {\n  int process_id;\n  int function_pointer;\n  code* function;\n\n  if (function_index > 31) {\n    *result = 22;\n    return -1;\n  }\n  function_pointer = result[17];\n  if (function_pointer != 0 && (function = *(code **)(function_pointer + function_index * 4), function != (code *)0x0)) {\n    if (function != (code *)0x1) {\n      if (function == (code *)0xffffffff) {\n        *result = 22;\n        return 1;\n      }\n      *(int *)(function_pointer + function_index * 4) = 0;\n      (*function)(arg1);\n    }\n    return 0;\n  }\n  process_id = _getpid_r();\n  result = _kill_r(result, process_id, function_index, arg2);\n  return result;\n}",
            "called": [
                "_getpid_r",
                "_kill_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f98",
            "calling": [
                "raise"
            ],
            "imported": false,
            "current_name": "execute_function_08009f98"
        },
        "FUN_0800a18c": {
            "renaming": {
                "std::FUN_0800a18c": "abort_program",
                "FUN_0800a18c": "abort_program_0800a18c"
            },
            "code": "void abort_program_0800a18c(void)\n{\n    /* WARNING: Subroutine does not return */\n    abort();\n}\n",
            "called": [
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a18c",
            "calling": [
                "operator()"
            ],
            "imported": false,
            "current_name": "abort_program_0800a18c"
        },
        "FUN_08008a24": {
            "renaming": {
                "FUN_08008a24": "configure_and_write_digital_pin_08008a24",
                "ulPin": "pin_number",
                "ulVal": "pin_value",
                "_Var1": "is_pin_configured",
                "port": "gpio_port",
                "uVar2": "pin_config_index"
            },
            "code": "void configure_and_write_digital_pin_08008a24(uint32_t pin_number, uint32_t pin_value)\n{\n    bool is_pin_configured = false;\n    GPIO_TypeDef *gpio_port;\n    uint32_t pin_config_index;\n    \n    if (pin_number < 0x3c) {\n        pin_config_index = (uint32_t)(char)PTR_digitalPin_08008a64[pin_number];\n    }\n    else {\n        pin_config_index = 0xffffffff;\n    }\n    \n    if (pin_config_index != 0xffffffff && is_pin_configured((PinName_conflict)pin_config_index, (uint32_t *)PTR_g_digPinConfigured_08008a68)) {\n        gpio_port = get_GPIO_Port((pin_config_index << 0x18) >> 0x1c);\n        digital_io_write(gpio_port, 1 << (pin_config_index & 0xf) & 0xffff, pin_value);\n    }\n    return;\n}",
            "called": [
                "digital_io_write",
                "get_GPIO_Port",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a24",
            "calling": [
                "strobeBlinkPin",
                "analogWrite",
                "digitalWriteCallback",
                "ServoIrqHandle",
                "setPinValueCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "configure_and_write_digital_pin_08008a24"
        },
        "FUN_08008020": {
            "renaming": {
                "FUN_08008020": "enable_i2c_listen_interrupt_08008020",
                "hi2c": "i2c_handle",
                "piVar1": "i2c_obj",
                "isMaster": "is_master",
                "get_i2c_obj": "get_i2c_object"
            },
            "code": "void enable_i2c_listen_interrupt_08008020(I2C_HandleTypeDef_conflict *i2c_handle) {\\n  i2c_t_conflict *i2c_obj = get_i2c_object(i2c_handle);\\n  if (i2c_obj->is_master == \"\\0\") {\\n    HAL_I2C_EnableListen_IT(i2c_handle);\\n  }\\n  return;\\n}",
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008020",
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "imported": false,
            "current_name": "enable_i2c_listen_interrupt_08008020"
        },
        "FUN_08005dac": {
            "renaming": {
                "FUN_08005dac": "configure_timer_08005dac",
                "TIMx": "timer",
                "OC_Config": "output_channel_config",
                "uVar1": "cr2_value",
                "uVar2": "output_mode_value",
                "uVar3": "output_polarity_value"
            },
            "code": "void configure_timer_08005dac(TIM_TypeDef_conflict *timer, TIM_OC_InitTypeDef *output_channel_config)\n{\n  uint32_t cr2_value;\n  uint32_t output_mode_value;\n  uint32_t output_polarity_value;\n  \n  timer->CCER = timer->CCER & 0xffffefff;\n  cr2_value = timer->CR2;\n  output_mode_value = output_channel_config->OCMode;\n  output_polarity_value = output_channel_config->OCPolarity;\n  if (timer == PTR_08005df0) {\n    cr2_value = cr2_value & 0xffffbfff | output_channel_config->OCIdleState << 6;\n  }\n  timer->CR2 = cr2_value;\n  timer->CCMR2 = timer->CCMR2 & 0xffff8cff | output_mode_value << 8;\n  timer->CCR4 = output_channel_config->Pulse;\n  timer->CCER = timer->CCER & 0xffffdfff | output_polarity_value << 0xc;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005dac",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08005dac"
        },
        "FUN_080066e8": {
            "renaming": {
                "FUN_080066e8": "check_uart_flag_080066e8",
                "huart": "uart_handle",
                "Flag": "flag",
                "Status": "status",
                "Tickstart": "start_time",
                "Timeout": "timeout",
                "uVar1": "current_time"
            },
            "code": "HAL_StatusTypeDef check_uart_flag_080066e8(UART_HandleTypeDef *uart_handle, uint32_t flag, FlagStatus status, uint32_t start_time, uint32_t timeout)\n{\n  uint32_t current_time;\n  do {\n    bool flag_status = ((flag & ~uart_handle->Instance->SR) == 0);\n    if (flag_status != (bool)status) {\n      return HAL_OK;\n    }\n  } while ((timeout == 0xffffffff) || ((timeout != 0 && (current_time = HAL_GetTick(), current_time - start_time <= timeout))));\n  uart_handle->Instance->CR1 &= 0xfffffe5f;\n  uart_handle->Instance->CR3 &= 0xfffffffe;\n  uart_handle->gState = HAL_UART_STATE_READY;\n  uart_handle->RxState = HAL_UART_STATE_READY;\n  uart_handle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080066e8",
            "calling": [
                "HAL_UART_Transmit"
            ],
            "imported": false,
            "current_name": "check_uart_flag_080066e8"
        },
        "FUN_08009358": {
            "renaming": {
                "FUN_08009358": "write_to_file_08009358",
                "param_1": "file_descriptor",
                "param_2": "buffer",
                "param_3": "size",
                "param_4": "bytes_written",
                "puVar2": "end_of_buffer",
                "iVar1": "bytes_written",
                "iVar3": "bytes_written"
            },
            "code": "int write_to_file_08009358(int file_descriptor, const void* buffer, size_t size)\n{\n  int bytes_written = 0;\n  const void* end_of_buffer = buffer + size;\n  while (buffer != end_of_buffer) {\n    if (bytes_written = write(file_descriptor, buffer, 1) == -1) {\n      return -1;\n    }\n    buffer = (char*)buffer + 1;\n    bytes_written++;\n  }\n  return bytes_written;\n}",
            "called": [
                "__sfputc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009358",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "write_to_file_08009358"
        },
        "FUN_0800270c": {
            "renaming": {
                "FUN_0800270c": "calculateReceivedDataLength_0800270c",
                "this": "wire",
                "*PTR_rxBufferLength_08002718": "receivedBufferLength",
                "*PTR_rxBufferIndex_0800271c": "receivedBufferIndex"
            },
            "code": "int __thiscall calculateReceivedDataLength_0800270c(TwoWire *wire) {\n    int *PTR_rxBufferLength_08002718 = (int)(byte)*PTR_rxBufferLength_08002718;\n    int *PTR_rxBufferIndex_0800271c = (int)(byte)*PTR_rxBufferIndex_0800271c;\n    return *PTR_rxBufferLength_08002718 - *PTR_rxBufferIndex_0800271c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800270c",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "calculateReceivedDataLength_0800270c"
        },
        "FUN_08007fa0": {
            "renaming": {
                "FUN_08007fa0": "i2c_handle_slave_transmission_08007fa0",
                "hi2c": "i2c_handle",
                "TransferDirection": "transfer_direction",
                "AddrMatchCode": "address_match_code",
                "piVar1": "i2c_obj",
                "get_i2c_obj": "get_i2c_object",
                "i2cTxRxBufferSize": "tx_rx_buffer_size",
                "slaveMode": "slave_mode",
                "i2c_onSlaveTransmit": "on_slave_transmit",
                "i2cTxRxBuffer": "tx_rx_buffer",
                "HAL_I2C_Slave_Sequential_Transmit_IT": "HAL_I2C_Slave_Sequential_Transmit_IT",
                "(ushort)": "(ushort)",
                "HAL_I2C_Slave_Sequential_Receive_IT": "HAL_I2C_Slave_Sequential_Receive_IT"
            },
            "code": "void i2c_handle_slave_transmission_08007fa0(I2C_HandleTypeDef_conflict *i2c_handle,uint8_t transfer_direction,uint16_t address_match_code)\\n{\\n  i2c_t_conflict *i2c_obj;\\n  i2c_obj = get_i2c_object(i2c_handle);\\n  if ((uint)address_match_code == (i2c_handle->Init).OwnAddress1) {\\n    if (transfer_direction == \"\\0\") {\\n      i2c_obj->tx_rx_buffer_size = \"\\0\";\\n      i2c_obj->slave_mode = \"\\0\";\\n      if (i2c_obj->on_slave_transmit != (_func_void *)0x0) {\\n        (*i2c_obj->on_slave_transmit)();\\n      }\\n      HAL_I2C_Slave_Sequential_Transmit_IT\\n                (i2c_handle,i2c_obj->tx_rx_buffer,(ushort)i2c_obj->tx_rx_buffer_size,8);\\n      return;\\n    }\\n    i2c_obj->slave_mode = \"\\x01\";\\n    HAL_I2C_Slave_Sequential_Receive_IT(i2c_handle,i2c_obj->tx_rx_buffer,0x20,8);\\n  }\\n  return;\\n}",
            "called": [
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007fa0",
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "imported": false,
            "current_name": "i2c_handle_slave_transmission_08007fa0"
        },
        "FUN_08002720": {
            "renaming": {
                "FUN_08002720": "readByte_08002720",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__nbytes": "num_bytes",
                "bVar1": "buffer_index",
                "bVar2": "data",
                "*PTR_rxBufferIndex_08002740": "*rx_buffer_index",
                "*PTR_rxBufferLength_08002744": "*rx_buffer_length",
                "*(byte *)(*(int *)PTR_rxBuffer_08002748 + (uint)bVar1)": "*(byte *)(*(int *)rx_buffer + (uint)buffer_index)"
            },
            "code": "ssize_t __thiscall TwoWire::readByte_08002720(TwoWire *wire,int file_descriptor,void *buffer,size_t num_bytes) {\n    byte buffer_index = *PTR_rxBufferIndex_08002740;\n    if ((uint)buffer_index < (uint)(byte)*PTR_rxBufferLength_08002744) {\n        byte data = *(byte *)(*(int *)PTR_rxBuffer_08002748 + (uint)bVar1);\n        *PTR_rxBufferIndex_08002740 = buffer_index + 1;\n        return (uint)data;\n    }\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002720",
            "calling": [
                "wireRead"
            ],
            "imported": false,
            "current_name": "readByte_08002720"
        },
        "FUN_080031ce": {
            "renaming": {
                "FUN_080031ce": "sendData_080031ce",
                "this": "marshaller",
                "major": "majorVersion",
                "minor": "minorVersion",
                "bytec": "numBytes",
                "bytev": "byteArray",
                "p_Var1": "printFuncPtr",
                "uVar2": "index"
            },
            "code": "void __thiscall FirmataMarshaller::sendData_080031ce(FirmataMarshaller *marshaller, uint8_t majorVersion, uint8_t minorVersion, size_t numBytes, uint8_t *byteArray) {\n  _func_int_varargs *printFuncPtr;\n  uint index;\n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    printFuncPtr = *(marshaller->FirmataStream->super_Print)._vptr_Print;\n    (*printFuncPtr)(marshaller, 0xf0, (uint)minorVersion, printFuncPtr, numBytes);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream, 0x79);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream, (uint)majorVersion);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream, (uint)minorVersion);\n    for (index = 0; index < numBytes; index++) {\n      encodeByteStream(marshaller, 1, byteArray + index, 0);\n    }\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream, 0xf7);\n  }\n  return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080031ce",
            "calling": [
                "printFirmwareVersion"
            ],
            "imported": false,
            "current_name": "sendData_080031ce"
        },
        "FUN_08008b52": {
            "renaming": {
                "FUN_08008b52": "waitForTransmissionCompletion_08008b52",
                "this": "serial",
                "_written": "hasDataToTransmit"
            },
            "code": "void __thiscall HardwareSerial::waitForTransmissionCompletion_08008b52(HardwareSerial *serial)\n{\n    if (serial->hasDataToTransmit) \n    {\n        while ((serial->_serial).tx_head != (serial->_serial).tx_tail);\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b52",
            "calling": [],
            "imported": false,
            "current_name": "waitForTransmissionCompletion_08008b52"
        },
        "FUN_08002968": {
            "renaming": {
                "FUN_08002968": "initializeI2C_08002968",
                "this": "wire",
                "address": "address",
                "ownAddress": "ownAddress",
                "obj": "i2c"
            },
            "code": "void __thiscall initializeI2C_08002968(TwoWire *wire, uint8_t address) {\n  uint32_t ownAddress;\n  i2c_t *i2c;\n  wire->rxBufferIndex = 0;\n  wire->rxBufferLength = 0;\n  if (*(void **)wire->rxBuffer != (void *)0x0) {\n    memset(*(void **)wire->rxBuffer, 0, (uint)(byte)*wire->rxBufferAllocated);\n  }\n  wire->txBufferIndex = 0;\n  wire->txBufferLength = 0;\n  if (*(void **)wire->txBuffer != (void *)0x0) {\n    memset(*(void **)wire->txBuffer, 0, (uint)(byte)*wire->txBufferAllocated);\n  }\n  wire->transmitting = 0;\n  ownAddress = (address & 0x7f) << 1;\n  wire->ownAddress = (uint8_t)ownAddress;\n  if (address == 0x33) {\n    wire->master = true;\n  }\n  else {\n    wire->master = false;\n  }\n  i2c = &wire->_i2c;\n  i2c_custom_init((i2c_t_conflict *)i2c, wire->rxBuffer, wire->txBufferAllocated, ownAddress, wire->master);\n  if (wire->master == false) {\n    i2c_attachSlaveTxEvent((i2c_t_conflict *)i2c, wire->txBuffer);\n    i2c_attachSlaveRxEvent((i2c_t_conflict *)i2c, wire->rxBuffer);\n  }\n  return;\n}",
            "called": [
                "i2c_attachSlaveRxEvent",
                "i2c_attachSlaveTxEvent",
                "memset",
                "i2c_custom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002968",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initializeI2C_08002968"
        },
        "FUN_08004ccc": {
            "renaming": {
                "FUN_08004ccc": "handle_i2c_transfer_08004ccc",
                "hi2c": "i2c_handle",
                "uVar1": "transfer_options",
                "pbVar2": "buffer_ptr"
            },
            "code": "HAL_StatusTypeDef handle_i2c_transfer_08004ccc(I2C_HandleTypeDef *i2c_handle)\n{\n  uint32_t transfer_options = i2c_handle->XferOptions;\n  if (i2c_handle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (i2c_handle->XferCount == 0) {\n      if (((transfer_options == 4) || (transfer_options == 8)) || (transfer_options == 0xffff0000)) {\n        i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n        i2c_handle->PreviousState = 0;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n          i2c_handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(i2c_handle);\n        }\n        else {\n          i2c_handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(i2c_handle);\n        }\n      }\n      else {\n        i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n        i2c_handle->PreviousState = 0x11;\n        i2c_handle->Mode = HAL_I2C_MODE_NONE;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(i2c_handle);\n      }\n    }\n    else {\n      uint8_t *buffer_ptr = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = buffer_ptr + 1;\n      i2c_handle->Instance->DR = (uint)*buffer_ptr;\n      i2c_handle->XferCount = i2c_handle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ccc",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_transfer_08004ccc"
        },
        "FUN_080042d4": {
            "renaming": {
                "FUN_080042d4": "check_GPIO_Pin_080042d4",
                "GPIOx": "GPIO",
                "GPIO_Pin": "Pin",
                "GPIO_PIN_RESET": "GPIO_OFF",
                "GPIO_PIN_SET": "GPIO_ON"
            },
            "code": "GPIO_PinState check_GPIO_Pin_080042d4(GPIO_TypeDef *GPIO, uint16_t Pin) {\n  if (((uint)Pin & GPIO->IDR) == 0) {\n    return GPIO_PIN_RESET;\n  }\n  return GPIO_PIN_SET;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042d4",
            "calling": [
                "digital_io_read"
            ],
            "imported": false,
            "current_name": "check_GPIO_Pin_080042d4"
        },
        "FUN_0800a07a": {
            "renaming": {
                "FUN_0800a07a": "seek_and_update_file_pointer_0800a07a",
                "param_1": "file_descriptor",
                "param_2": "file_info_address",
                "iVar1": "seek_result",
                "uVar2": "updated_flags",
                "bVar3": "seek_failed"
            },
            "code": "void seek_and_update_file_pointer_0800a07a(int file_descriptor, int file_info_address)\n{\n    int seek_result;\n    ushort updated_flags;\n    bool seek_failed;\n    seek_result = _lseek_r(file_descriptor, (int)*(short *)(file_info_address + 0xe));\n    seek_failed = seek_result == -1;\n    if (seek_failed) {\n        updated_flags = *(ushort *)(file_info_address + 0xc) & 0xefff;\n    }\n    else {\n        *(int *)(file_info_address + 0x54) = seek_result;\n        updated_flags = *(ushort *)(file_info_address + 0xc) | 0x1000;\n    }\n    if (seek_failed) {\n        *(ushort *)(file_info_address + 0xc) = updated_flags;\n    }\n    if (!seek_failed) {\n        *(ushort *)(file_info_address + 0xc) = updated_flags;\n    }\n    return;\n}\n",
            "called": [
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a07a",
            "calling": [],
            "imported": false,
            "current_name": "seek_and_update_file_pointer_0800a07a"
        },
        "FUN_080064b0": {
            "renaming": {
                "FUN_080064b0": "reset_uart_080064b0",
                "huart": "uart_handle"
            },
            "code": "void reset_uart_080064b0(UART_HandleTypeDef *uart_handle)\n{\n  uart_handle->Instance->CR1 &= ~(1 << 13);\n  uart_handle->Instance->CR3 &= ~(1);\n  uart_handle->RxState = HAL_UART_STATE_READY;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064b0",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "reset_uart_080064b0"
        },
        "FUN_08006092": {
            "renaming": {
                "FUN_08006092": "configure_timer_08006092",
                "htim": "timer",
                "State": "state",
                "Lock": "lock",
                "HAL_TIM_STATE_RESET": "HAL_TIM_STATE_RESET",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIM_PWM_MspInit": "HAL_TIM_PWM_MspInit",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "TIM_Base_SetConfig": "TIM_Base_SetConfig",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_OK": "HAL_OK",
                "HAL_ERROR": "HAL_ERROR"
            },
            "code": "HAL_StatusTypeDef_conflict configure_timer_08006092(TIM_HandleTypeDef_conflict *timer)\n{\n  if (timer != NULL) {\n    if (timer->state == HAL_TIM_STATE_RESET) {\n      timer->lock = HAL_UNLOCKED;\n      HAL_TIM_PWM_MspInit(timer);\n    }\n    timer->state = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(timer->Instance,&timer->Init);\n    timer->state = HAL_TIM_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006092",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configure_timer_08006092"
        },
        "FUN_08008d8c": {
            "renaming": {
                "FUN_08008d8c": "initializeSerial_08008d8c",
                "__initialize_p": "shouldInitialize",
                "__priority": "priority",
                "PTR_Serial2_08008dac": "serialPtr",
                "DAT_08008da8": "data"
            },
            "code": "void initializeSerial_08008d8c(int shouldInitialize, int priority) {\n  if (shouldInitialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    HardwareSerial::HardwareSerial((HardwareSerial *)PTR_Serial2_08008dac, DAT_08008da8);\n  }\n  return;\n}",
            "called": [
                "HardwareSerial"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d8c",
            "calling": [
                "_GLOBAL__sub_I_Serial2"
            ],
            "imported": false,
            "current_name": "initializeSerial_08008d8c"
        },
        "FUN_08008038": {
            "renaming": {
                "FUN_08008038": "handle_I2C_event_interrupt_08008038",
                "PTR_i2c_handles_08008044": "i2c_handle_ptr",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "*(I2C_HandleTypeDef_conflict **)PTR_i2c_handles_08008044": "*(I2C_HandleTypeDef**)i2c_handle_ptr",
                "HAL_I2C_EV_IRQHandler": "HAL_I2C_EV_IRQHandler",
                "I2C_HandleTypeDef": "I2C_HandleTypeDef",
                "i2c_handle": "i2c_handle"
            },
            "code": "void handle_I2C_event_interrupt_08008038(void)\n{\n  I2C_HandleTypeDef* i2c_handle = *(I2C_HandleTypeDef_conflict **)PTR_i2c_handles_08008044;\n  HAL_I2C_EV_IRQHandler(i2c_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008038",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_event_interrupt_08008038"
        },
        "FUN_08009124": {
            "renaming": {
                "FUN_08009124": "print_formatted_output_08009124",
                "__stream": "output_stream",
                "__format": "format_string",
                "iVar1": "return_value",
                "in_r2": "",
                "in_r3": "",
                "uStack_8": "",
                "uStack_4": "",
                "PTR__impure_ptr_08009144": "",
                "_vFUN_08009124_r": "vfprintf",
                "&uStack_8": "arguments"
            },
            "code": "int print_formatted_output_08009124(FILE *output_stream, char *format_string, ...) {\n    int return_value;\n    va_list arguments;\n    va_start(arguments, format_string);\n    return_value = vfprintf(output_stream, format_string, arguments);\n    va_end(arguments);\n    return return_value;\n}",
            "called": [
                "_vfiprintf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009124",
            "calling": [
                "__assert_func"
            ],
            "imported": false,
            "current_name": "print_formatted_output_08009124"
        },
        "FUN_080064ae": {
            "renaming": {
                "FUN_080064ae": "do_nothing_080064ae"
            },
            "code": "\nvoid do_nothing_080064ae(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064ae",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080064ae"
        },
        "FUN_080064ac": {
            "renaming": {
                "FUN_080064ac": "do_nothing_080064ac"
            },
            "code": "\nvoid do_nothing_080064ac(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064ac",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080064ac"
        },
        "FUN_08005cb4": {
            "renaming": {
                "FUN_08005cb4": "handle_rtc_alarm_08005cb4",
                "hrtc": "rtc_handle",
                "DAT_08005ce8": "rtc_data",
                "CRH": "crh_value",
                "CRL": "crl_value"
            },
            "code": "void handle_rtc_alarm_08005cb4(RTC_HandleTypeDef *rtc_handle) {\n  uint32_t crh_value = rtc_handle->Instance->CRH;\n  uint32_t crl_value = rtc_handle->Instance->CRL;\n  if ((crh_value & 2) && (crl_value & 2)) {\n    HAL_RTC_AlarmAEventCallback(rtc_handle);\n    rtc_handle->Instance->CRL = 0xfffffffd;\n  }\n  *(uint32_t *)(DAT_08005ce8 + 0x14) = 0x20000;\n  rtc_handle->State = HAL_RTC_STATE_READY;\n  return;\n}",
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cb4",
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_rtc_alarm_08005cb4"
        },
        "FUN_080042e2": {
            "renaming": {
                "FUN_080042e2": "set_GPIO_pin_state_080042e2",
                "GPIOx": "GPIO_port",
                "GPIO_Pin": "pin_num",
                "PinState": "pin_state",
                "BSRR": "bit_set_reset_register",
                "GPIO_PIN_RESET": "GPIO_pin_reset_state"
            },
            "code": "void set_GPIO_pin_state_080042e2(GPIO_TypeDef *GPIO_port, uint16_t pin_num, GPIO_PinState pin_state) {\n  if (pin_state == GPIO_PIN_RESET) {\n    GPIO_port->BSRR = (uint32_t)pin_num << 16;\n    return;\n  }\n  GPIO_port->BSRR = (uint32_t)pin_num;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042e2",
            "calling": [
                "digital_io_write"
            ],
            "imported": false,
            "current_name": "set_GPIO_pin_state_080042e2"
        },
        "FUN_080088e0": {
            "renaming": {
                "FUN_080088e0": "configure_pin_080088e0",
                "ulPin": "pin_number",
                "ulValue": "value",
                "_Var1": "is_pin_pwm",
                "uVar2": "write_resolution",
                "pin": "pin",
                "PTR_digitalPin_0800897c": "digital_pin_array",
                "NC": "NC",
                "pin_in_pinmap": "is_pin_in_pinmap",
                "PinMap_conflict": "PinMap_conflict",
                "PTR_PinMap_PWM_08008980": "pin_map_pwm",
                "is_pin_configured": "is_pin_configured",
                "PTR_g_anOutputPinConfigured_08008984": "output_pin_config_array",
                "set_pin_configured": "set_pin_configured",
                "PTR__writeResolution_08008988": "write_resolution_pointer",
                "pwm_start": "pwm_start",
                "DAT_0800898c": "DAT_0800898c",
                "pinMode": "pinMode",
                "digitalWrite": "digitalWrite"
            },
            "code": "void configure_pin_080088e0(uint32_t pin_number, uint32_t value)\n{\n  _Bool is_pin_pwm = false;\n  uint write_resolution = *(uint*)PTR__writeResolution_08008988;\n  PinName_conflict pin = pin_number < 0x3c ? PTR_digitalPin_0800897c[pin_number] : NC;\n  \n  if (pin != NC) {\n    is_pin_pwm = pin_in_pinmap(pin, (PinMap_conflict*)PTR_PinMap_PWM_08008980);\n    if (is_pin_pwm && !is_pin_configured(pin, (uint32_t*)PTR_g_anOutputPinConfigured_08008984)) {\n      set_pin_configured(pin, (uint32_t*)PTR_g_anOutputPinConfigured_08008984);\n    }\n    if (write_resolution != 8) {\n      if (write_resolution < 9) {\n        value = value << (8 - write_resolution & 0xff);\n      }\n      else {\n        value = value >> (write_resolution - 8 & 0xff);\n      }\n    }\n    if (is_pin_pwm) {\n      pwm_start(pin, DAT_0800898c, 0xff, value, !is_pin_configured(pin, (uint32_t*)PTR_g_anOutputPinConfigured_08008984));\n    }\n    else {\n      pinMode(pin_number, 1);\n      digitalWrite(pin_number, value >= 0x80);\n    }\n  }\n}\n",
            "called": [
                "pin_in_pinmap",
                "set_pin_configured",
                "digitalWrite",
                "pinMode",
                "pwm_start",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080088e0",
            "calling": [
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "configure_pin_080088e0"
        },
        "FUN_08008b66": {
            "renaming": {
                "FUN_08008b66": "read_serial_data_08008b66",
                "obj": "serial_object",
                "iVar1": "read_result",
                "uVar2": "next_head",
                "c": "received_char"
            },
            "code": "void read_serial_data_08008b66(serial_t_conflict *serial_object){\n  int read_result;\n  ushort next_head;\n  uchar received_char;\n  \n  read_result = uart_getc((serial_t *)serial_object, &received_char);\n  if ((read_result == 0) && (next_head = serial_object->rx_head + 1 & 0x3f, next_head != serial_object->rx_tail)) {\n    serial_object->rx_buff[serial_object->rx_head] = received_char;\n    serial_object->rx_head = next_head;\n  }\n  return;\n}",
            "called": [
                "uart_getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b66",
            "calling": [],
            "imported": false,
            "current_name": "read_serial_data_08008b66"
        },
        "FUN_0800a3a0": {
            "renaming": {
                "std::ctype_byname<char>::FUN_0800a3a0": "set_flags",
                "FUN_0800a3a0": "set_flags_0800a3a0"
            },
            "code": "void set_flags_0800a3a0(void)\n{\n    if (*(int *)PTR_id_0800a404 < 0)\n    {\n        *(undefined4 *)PTR_id_0800a404 = 1;\n    }\n    if (*(int *)PTR_id_0800a408 < 0)\n    {\n        *(undefined4 *)PTR_id_0800a408 = 1;\n    }\n    if (*(int *)PTR_id_0800a40c < 0)\n    {\n        *(undefined4 *)PTR_id_0800a40c = 1;\n    }\n    if (*(int *)PTR_id_0800a410 < 0)\n    {\n        *(undefined4 *)PTR_id_0800a410 = 1;\n    }\n    if (*(int *)PTR_id_0800a414 < 0)\n    {\n        *(undefined4 *)PTR_id_0800a414 = 1;\n    }\n    if (*(int *)PTR_id_0800a418 < 0)\n    {\n        *(undefined4 *)PTR_id_0800a418 = 1;\n    }\n    if (*(int *)PTR_id_0800a41c < 0)\n    {\n        *(undefined4 *)PTR_id_0800a41c = 1;\n    }\n    if (*(int *)PTR_id_0800a420 < 0)\n    {\n        *(undefined4 *)PTR_id_0800a420 = 1;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a3a0",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_0800a3a0"
        },
        "FUN_08008048": {
            "renaming": {
                "FUN_08008048": "handle_i2c_errors_08008048",
                "PTR_i2c_handles_08008054": "i2c_handle_ptr",
                "**": "*",
                "*": "",
                "HAL_I2C_ER_IRQHandler": "HAL_I2C_ER_IRQHandler",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "i2c_handle": "i2c_handle"
            },
            "code": "void handle_i2c_errors_08008048(void)\n{\n  I2C_HandleTypeDef* i2c_handle = *(I2C_HandleTypeDef**)PTR_i2c_handles_08008054;\n  HAL_I2C_ER_IRQHandler(i2c_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008048",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_errors_08008048"
        },
        "FUN_080053cc": {
            "renaming": {
                "FUN_080053cc": "reset_I2C_transfer_080053cc",
                "hdma": "i2c_handle",
                "hi2c": "hi2c",
                "Parent": "Instance",
                "XferCount": "xfer_count",
                "hdmatx": "dma_tx_handle",
                "XferAbortCallback": "xfer_abort_callback",
                "hdmarx": "dma_rx_handle",
                "State": "state",
                "HAL_I2C_STATE_ABORT": "HAL_I2C_STATE_ABORT",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "Mode": "mode",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "ErrorCode": "error_code",
                "Instance": "Instance",
                "CR1": "CR1",
                "HAL_I2C_ErrorCallback": "error_callback",
                "HAL_I2C_AbortCpltCallback": "abort_callback"
            },
            "code": "void reset_I2C_transfer_080053cc(I2C_HandleTypeDef* i2c_handle)\n{\n  I2C_HandleTypeDef* hi2c = i2c_handle;\n  hi2c->Instance->CR1 &= ~(1 << 10);\n  hi2c->XferCount = 0;\n  hi2c->hdmatx->XferAbortCallback = NULL;\n  hi2c->hdmarx->XferAbortCallback = NULL;\n  if (hi2c->State != HAL_I2C_STATE_ABORT) {\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n    hi2c->Instance->CR1 &= ~1;\n    HAL_I2C_ErrorCallback(hi2c);\n    return;\n  }\n  hi2c->State = HAL_I2C_STATE_READY;\n  hi2c->Mode = HAL_I2C_MODE_NONE;\n  hi2c->ErrorCode = 0;\n  hi2c->Instance->CR1 &= ~1;\n  HAL_I2C_AbortCpltCallback(hi2c);\n  return;\n}",
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053cc",
            "calling": [],
            "imported": false,
            "current_name": "reset_I2C_transfer_080053cc"
        },
        "FUN_080087bc": {
            "renaming": {
                "FUN_080087bc": "handle_USART1_interrupt_080087bc",
                "*PTR_uart_handlers_080087d0": "uart_handlers"
            },
            "code": "void handle_USART1_interrupt_080087bc(void)\n{\n    HAL_NVIC_ClearPendingIRQ(USART1_IRQn);\n    UART_HandleTypeDef* *PTR_uart_handlers_080087d0 = *(UART_HandleTypeDef**)PTR_*PTR_uart_handlers_080087d0_080087d0;\n    HAL_UART_IRQHandler(*PTR_uart_handlers_080087d0);\n    return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087bc",
            "calling": [],
            "imported": false,
            "current_name": "handle_USART1_interrupt_080087bc"
        },
        "FUN_080042f0": {
            "renaming": {
                "FUN_080042f0": "update_gpio_pin_080042f0",
                "GPIO_Pin": "pin",
                "DAT_08004308": "gpio_data",
                "PTR_uint": "uint32_t",
                "PTR_uint_001": "uint16_t"
            },
            "code": "void update_gpio_pin_080042f0(PTR_uint_001 pin) {\n  PTR_uint *DAT_08004308 = (PTR_uint *)(DAT_08004308 + 0x14);\n  if ((*DAT_08004308 & (PTR_uint)pin) != 0) {\n    *DAT_08004308 = (PTR_uint)pin;\n    HAL_GPIO_EXTI_Callback(pin);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042f0",
            "calling": [
                "EXTI2_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI1_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI15_10_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI4_IRQHandler"
            ],
            "imported": false,
            "current_name": "update_gpio_pin_080042f0"
        },
        "FUN_080087d4": {
            "renaming": {
                "FUN_080087d4": "handle_USART2_interrupt_080087d4",
                "USART2_IRQn": "USART2_interrupt",
                "PTR_uart_handlers_080087e8": "uart_handlers_ptr"
            },
            "code": "void handle_USART2_interrupt_080087d4(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART2_IRQn);\n  UART_HandleTypeDef* uart_handler_ptr = *(UART_HandleTypeDef **)(PTR_uart_handlers_080087e8 + 4);\n  HAL_UART_IRQHandler(uart_handler_ptr);\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087d4",
            "calling": [],
            "imported": false,
            "current_name": "handle_USART2_interrupt_080087d4"
        },
        "FUN_0800a09e": {
            "renaming": {
                "FUN_0800a09e": "close_file_descriptor_0800a09e",
                "param_1": "file_descriptor",
                "param_2": "file_descriptor_offset"
            },
            "code": "void close_file_descriptor_0800a09e(void* file_descriptor, int file_descriptor_offset) {\n    _close_r(file_descriptor, (int)*(short*)(file_descriptor_offset + 0xe));\n    return;\n}",
            "called": [
                "_close_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a09e",
            "calling": [],
            "imported": false,
            "current_name": "close_file_descriptor_0800a09e"
        },
        "FUN_080076e0": {
            "renaming": {
                "FUN_080076e0": "disableTimerInterrupt_080076e0",
                "obj": "timer_object",
                "HVar1": "hal_status",
                "uVar2": "timer_irq_number"
            },
            "code": "void disableTimerInterrupt_080076e0(stimer_t_conflict *timer_object)\n{\n  HAL_StatusTypeDef_conflict hal_status;\n  uint32_t timer_irq_number;\n  timer_object->irqHandleOC = (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0;\n  timer_irq_number = getTimerIrq(timer_object->timer);\n  HAL_NVIC_DisableIRQ((IRQn_Type_conflict)timer_irq_number);\n  hal_status = HAL_TIM_OC_DeInit(&timer_object->handle);\n  if (hal_status == HAL_OK) {\n    HAL_TIM_OC_Stop_IT(&timer_object->handle,0);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_OC_DeInit",
                "getTimerIrq",
                "HAL_TIM_OC_Stop_IT",
                "HAL_NVIC_DisableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080076e0",
            "calling": [
                "finISR"
            ],
            "imported": false,
            "current_name": "disableTimerInterrupt_080076e0"
        },
        "FUN_08002f14": {
            "renaming": {
                "FUN_08002f14": "sendStringToMarshaller_08002f14",
                "FirmataMarshaller::FUN_08002f14": "sendStringToMarshaller",
                "this": "firmataClassInstance",
                "string": "message",
                "&this->marshaller": "firmataMarshallerInstance"
            },
            "code": "void __thiscall firmata::FirmataClass::sendStringToMarshaller_08002f14(FirmataClass *this,char *string)\n{\n  FirmataMarshaller::sendStringToMarshaller_08002f14(&this->marshaller,string);\n  return;\n}",
            "called": [
                "sendString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f14",
            "calling": [
                "attachServo",
                "sysexCallback",
                "readAndReportData",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "sendStringToMarshaller_08002f14"
        }
    },
    "used_tokens": 325571,
    "layers": [
        [
            "FUN_08007246",
            "FUN_0800a042",
            "FUN_08008e4e",
            "FUN_08008694",
            "FUN_08005188",
            "FUN_08001bf8",
            "FUN_080069ec",
            "FUN_0800a168",
            "FUN_080067ac",
            "FUN_0800735a",
            "FUN_08008c20",
            "FUN_0800723c",
            "FUN_080043a2",
            "FUN_08006280",
            "FUN_08007258",
            "FUN_08009f4c",
            "FUN_08006c7c",
            "FUN_08006b5c",
            "FUN_08007376",
            "FUN_080033cc",
            "FUN_08003de4",
            "FUN_08000500",
            "FUN_08009d24",
            "FUN_08008e72",
            "FUN_080022f8",
            "FUN_08005084",
            "FUN_08008b0e",
            "FUN_0800291c",
            "FUN_080032bc",
            "FUN_08008c44",
            "FUN_08006060",
            "FUN_08006186",
            "FUN_08006b7c",
            "FUN_08008e7c",
            "FUN_0800a194",
            "FUN_08003aa0",
            "FUN_08005fe8",
            "FUN_08003ce8",
            "FUN_0800738a",
            "FUN_08002948",
            "FUN_08009e64",
            "FUN_08002acc",
            "FUN_0800932c",
            "FUN_080099a4",
            "FUN_08005a1c",
            "FUN_08006b0c",
            "FUN_08007320",
            "FUN_080002ec",
            "FUN_08000be8",
            "FUN_08003fd8",
            "FUN_0800307a",
            "FUN_08002ca4",
            "FUN_0800319e",
            "FUN_08008d00",
            "FUN_08004b82",
            "FUN_0800997e",
            "FUN_0800779c",
            "FUN_08002dbc",
            "FUN_08007f78",
            "FUN_08006b28",
            "FUN_08006b1c",
            "FUN_0800a130",
            "FUN_08008f3c",
            "FUN_08007332",
            "FUN_08006128",
            "FUN_0800a258",
            "FUN_08002cb8",
            "FUN_08008f50",
            "FUN_08004a76",
            "FUN_0800877c",
            "FUN_080047f4",
            "FUN_08005a48",
            "FUN_080033a8",
            "FUN_08008d18",
            "FUN_0800a020",
            "FUN_08007f7c",
            "FUN_08006d80",
            "FUN_08006c60",
            "FUN_08008e40",
            "FUN_080045c0",
            "FUN_08007e74",
            "FUN_08002ddc",
            "FUN_08009f2c",
            "FUN_0800a154",
            "FUN_08007f8e",
            "FUN_08006b3e",
            "FUN_08006262",
            "FUN_08007110",
            "FUN_08007594",
            "FUN_08002cd0",
            "FUN_08002df6",
            "FUN_08007118",
            "FUN_08001be8",
            "FUN_08005a68",
            "FUN_08008f78",
            "FUN_08002dea",
            "FUN_0800734a",
            "FUN_08000aec",
            "FUN_080068d6",
            "FUN_080032a2",
            "FUN_08009e28",
            "FUN_0800a01c",
            "FUN_08006390",
            "FUN_08008730",
            "FUN_08008854",
            "FUN_08004d6c",
            "FUN_08007760",
            "FUN_08008850",
            "FUN_08002fc2",
            "FUN_08008afa",
            "FUN_080038dc",
            "FUN_080025ac",
            "FUN_08007648",
            "FUN_08008858",
            "FUN_08004a24",
            "FUN_08002fba",
            "FUN_080090cc",
            "FUN_080049e0",
            "FUN_08006d24",
            "FUN_08008500",
            "FUN_08007774",
            "FUN_080001a8",
            "FUN_080048c8",
            "FUN_08009954",
            "FUN_08005e6e",
            "FUN_08004024",
            "FUN_08008868",
            "FUN_080036ac",
            "FUN_0800643c",
            "FUN_08002fca",
            "FUN_0800a31c",
            "FUN_080026f8",
            "FUN_08007544",
            "FUN_08008990",
            "FUN_08004396",
            "FUN_08003fb0",
            "FUN_08007788",
            "FUN_08002ec4",
            "FUN_08007306",
            "FUN_08008f0e",
            "FUN_0800886c",
            "FUN_080036d8",
            "FUN_0800a110",
            "FUN_08003b8c",
            "FUN_080035b8",
            "FUN_08006460",
            "FUN_08004046",
            "FUN_08008880",
            "FUN_08002ed2",
            "FUN_08008f1c",
            "FUN_080058ac",
            "FUN_08007438",
            "FUN_0800306c",
            "FUN_0800887c",
            "FUN_0800863c",
            "FUN_08004050",
            "FUN_08008e14",
            "FUN_08005a28",
            "FUN_08008ac6",
            "FUN_08003366",
            "FUN_080091b0",
            "FUN_08008abc",
            "FUN_08002b68",
            "FUN_080005e0",
            "FUN_0800674e",
            "FUN_0800771c",
            "FUN_08003370",
            "FUN_08003376",
            "FUN_08008bf4",
            "FUN_08002c7c",
            "FUN_08005430",
            "FUN_08009918",
            "FUN_08005434",
            "FUN_08005e2e",
            "FUN_08007736",
            "FUN_08002c90",
            "FUN_0800542a",
            "FUN_0800457c",
            "FUN_080091c6",
            "FUN_08003a20",
            "FUN_08002a58",
            "FUN_080004d4",
            "FUN_08002fa0",
            "FUN_08003a1c",
            "FUN_08007744",
            "FUN_08006538",
            "FUN_08002fa8",
            "FUN_0800325a",
            "FUN_080091d8",
            "FUN_0800688e",
            "FUN_080090b4",
            "FUN_0800870c",
            "FUN_08008840",
            "FUN_08008600",
            "FUN_08003154",
            "FUN_08006420",
            "FUN_08007750",
            "FUN_08009938",
            "FUN_08007f0e",
            "FUN_08004004",
            "FUN_08003158",
            "FUN_080090c2",
            "FUN_08008846",
            "FUN_0800459c",
            "FUN_0800774a",
            "FUN_0800314e",
            "FUN_080036a0",
            "FUN_080038e4",
            "FUN_08005d48",
            "FUN_08008ba4",
            "FUN_08009ff8",
            "FUN_08009db0",
            "FUN_08002c2c",
            "FUN_080072f0",
            "FUN_08000178",
            "FUN_08000a64",
            "FUN_08002c40",
            "FUN_0800694c",
            "FUN_0800a0ec",
            "FUN_08008df8",
            "FUN_08000188",
            "FUN_08004f3c",
            "FUN_0800344a",
            "FUN_080071e4",
            "FUN_08002c54",
            "FUN_080072fa",
            "FUN_08003346",
            "FUN_08003106",
            "FUN_08007708",
            "FUN_0800018c",
            "FUN_08003f94",
            "FUN_08002c68",
            "FUN_0800430c",
            "FUN_08003350",
            "FUN_08007710",
            "FUN_08003474",
            "FUN_08008804",
            "FUN_08004e3c",
            "FUN_08007718",
            "FUN_08002a30",
            "FUN_08009cd0",
            "FUN_0800322c",
            "FUN_08003760",
            "FUN_08000130",
            "FUN_08002798",
            "FUN_0800242c",
            "FUN_08002e44",
            "FUN_0800a0a8",
            "FUN_08003f30",
            "FUN_080073d8",
            "FUN_080085dc",
            "FUN_08008db0",
            "FUN_08002444",
            "FUN_0800906c",
            "FUN_08003658",
            "FUN_08009a80",
            "FUN_080062f4",
            "FUN_080073e8",
            "FUN_0800267c",
            "FUN_0800376c",
            "FUN_08003e20",
            "FUN_08005840",
            "FUN_08003306",
            "FUN_08002578",
            "FUN_08006932",
            "FUN_080060c4",
            "FUN_08009eac",
            "FUN_08008dbe",
            "FUN_080072d8",
            "FUN_08002b00",
            "FUN_08002f84",
            "FUN_08009094",
            "FUN_0800a0cc",
            "FUN_08002580",
            "FUN_080073ec",
            "FUN_08008ef4",
            "FUN_08002c1e",
            "FUN_08002f94",
            "FUN_08001b48",
            "FUN_08005df4",
            "FUN_08009148",
            "FUN_080099dc",
            "FUN_08009024",
            "FUN_080064cc",
            "FUN_08008058",
            "FUN_08004ac2",
            "FUN_08006ca8",
            "FUN_08000214",
            "FUN_08005bb8",
            "FUN_080063c0",
            "FUN_0800274c",
            "FUN_08009270",
            "FUN_08009038",
            "FUN_08005aa4",
            "FUN_08008068",
            "FUN_08002400",
            "FUN_08000588",
            "FUN_08002644",
            "FUN_08002f1e",
            "FUN_0800902e",
            "FUN_08009042",
            "FUN_08009c7c",
            "FUN_08009b5c",
            "FUN_08008a6c",
            "FUN_080085b8",
            "FUN_08001c08",
            "FUN_080075dc",
            "FUN_080087ec",
            "FUN_08007ff0",
            "FUN_08002774",
            "FUN_080052f0",
            "FUN_08002f2c",
            "FUN_08004954",
            "FUN_08005cec",
            "FUN_08003748",
            "FUN_080040e8",
            "FUN_08009b6c",
            "FUN_0800010c",
            "FUN_080086e8",
            "FUN_08001c18",
            "FUN_08009056",
            "FUN_08002e1a",
            "FUN_0800904c",
            "FUN_080073ae",
            "FUN_08003f0c",
            "FUN_08000488",
            "FUN_08006bb8",
            "FUN_08004aec",
            "FUN_08007ede",
            "FUN_08004728",
            "FUN_080074e0",
            "FUN_080073c0",
            "FUN_080084b0",
            "FUN_080095a8",
            "FUN_08008b2a",
            "FUN_08003bd8",
            "FUN_08009d50",
            "FUN_08009108",
            "FUN_08009f98",
            "FUN_08008a24",
            "FUN_08008020",
            "FUN_08005dac",
            "FUN_080066e8",
            "FUN_08009358",
            "FUN_0800270c",
            "FUN_08007fa0",
            "FUN_08002720",
            "FUN_080031ce",
            "FUN_08008b52",
            "FUN_08002968",
            "FUN_08004ccc",
            "FUN_080042d4",
            "FUN_0800a07a",
            "FUN_080064b0",
            "FUN_08006092",
            "FUN_08008d8c",
            "FUN_08008038",
            "FUN_08005cb4",
            "FUN_080042e2",
            "FUN_080088e0",
            "FUN_08008b66",
            "FUN_0800a3a0",
            "FUN_08008048",
            "FUN_080053cc",
            "FUN_080087bc",
            "FUN_080042f0",
            "FUN_080087d4",
            "FUN_0800a09e",
            "FUN_080076e0"
        ],
        [
            "FUN_08002ce0",
            "FUN_08002ac0",
            "FUN_08002ef2",
            "FUN_08002efe",
            "FUN_08008d30",
            "FUN_08003048",
            "FUN_0800885c",
            "FUN_08003002",
            "FUN_08009908",
            "FUN_08009cdc",
            "FUN_080026b0",
            "FUN_080027f0",
            "FUN_080036a2",
            "FUN_08002a26",
            "FUN_080091a0",
            "FUN_08002a1c",
            "FUN_08009190",
            "FUN_08002c00",
            "FUN_08008ed6",
            "FUN_08002c14",
            "FUN_08009084",
            "FUN_08009fe8",
            "FUN_08008eec",
            "FUN_08003724",
            "FUN_08002f0a",
            "FUN_08002634",
            "FUN_080098d8",
            "FUN_0800288c",
            "FUN_08002e26",
            "FUN_0800a18c",
            "FUN_08009124",
            "FUN_08002f14"
        ],
        [
            "FUN_08003474"
        ]
    ],
    "locked_functions": []
}