{
    "functions": {
        "FUN_0800010c": {
            "entrypoint": "0x0800010c",
            "current_name": "update_completed_flag_0800010c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000118) */\n\nundefined4 updateCompletedFlag_0800010c(undefined4 inputValue)\n\n{\n  if ((char)isCompleted == '\\0') {\n    isCompleted._0_1_ = '\\x01';\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_0800010c": "update_completed_flag_0800010c",
                "param_1": "inputValue",
                "completed_8667": "isCompleted"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000130": {
            "entrypoint": "0x08000130",
            "current_name": "FUNC_08000130",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000134) */\n/* WARNING: Removing unreachable block (ram,0x0800014e) */\n/* WARNING: Removing unreachable block (ram,0x08000144) */\n/* WARNING: Removing unreachable block (ram,0x08000160) */\n/* WARNING: Removing unreachable block (ram,0x08000154) */\n\n\nvoid FUNC_08000130(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000130": "FUNC_08000130"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000178": {
            "entrypoint": "0x08000178",
            "current_name": "calculate_string_length_08000178",
            "code": "\nsize_t calculateStringLength_08000178(char *string)\n\n{\n  char currentChar;\n  char *nextCharPointer;\n  char *currentCharPointer;\n  \n  currentCharPointer = string;\n  do {\n    nextCharPointer = currentCharPointer + 1;\n    currentChar = *currentCharPointer;\n    currentCharPointer = nextCharPointer;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPointer + (-1 - (int)string));\n}\n\n",
            "renaming": {
                "FUN_08000178": "calculate_string_length_08000178",
                "__s": "string",
                "cVar1": "currentChar",
                "pcVar2": "nextCharPointer",
                "pcVar3": "currentCharPointer"
            },
            "calling": [
                "print",
                "printNumber"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000188": {
            "entrypoint": "0x08000188",
            "current_name": "add_offset_to_param_08000188",
            "code": "\nvoid addOffsetToParam_08000188(undefined4 result,uint offset)\n\n{\n  __aeabi_dadd(result,offset ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000188": "add_offset_to_param_08000188",
                "param_1": "result",
                "param_2": "offset"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000190": {
            "entrypoint": "0x08000190",
            "current_name": "calculate_arithmetic_result_08000190",
            "code": "\nulonglong calculate_arithmetic_result_08000190(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int left_shift_amount;\n  byte carry_flag;\n  uint var3;\n  uint var4;\n  uint var5;\n  uint temp1;\n  uint temp2;\n  int right_shift_amount;\n  uint result1;\n  uint result2;\n  uint result3;\n  uint result4;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  temp1 = input4 ^ 0x80000000;\n  result1 = input2 << 1;\n  input4 = input4 << 1;\n  flag1 = ((input2 ^ temp1) & 0x7fffffff) == 0;\n  flag2 = flag1 && input1 == input3;\n  if (!flag1 || input1 != input3) {\n    flag2 = (result1 | input1) == 0;\n  }\n  if (!flag2) {\n    flag2 = (input4 | input3) == 0;\n  }\n  right_shift_amount = (int)result1 >> 0x15;\n  if (!flag2) {\n    flag2 = right_shift_amount == -1;\n  }\n  left_shift_amount = (int)input4 >> 0x15;\n  if (!flag2) {\n    flag2 = left_shift_amount == -1;\n  }\n  if (flag2) {\n    if (right_shift_amount == -1 || left_shift_amount == -1) {\n      result1 = temp1;\n      result3 = input3;\n      if (right_shift_amount == -1) {\n        result1 = input2;\n        result3 = input1;\n      }\n      if (right_shift_amount != -1 || left_shift_amount != -1) {\n        input3 = result3;\n        temp1 = result1;\n      }\n      flag2 = (result3 | result1 << 0xc) == 0;\n      if (flag2) {\n        flag2 = (input3 | temp1 << 0xc) == 0;\n      }\n      if (flag2) {\n        flag2 = result1 == temp1;\n      }\n      if (!flag2) {\n        result1 = result1 | 0x80000;\n      }\n      return CONCAT44(result1,result3);\n    }\n    if (((input2 ^ temp1) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((result1 | input1) == 0) {\n        input1 = input3;\n        input2 = temp1;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != temp1) {\n      return 0;\n    }\n    if (result1 >> 0x15 == 0) {\n      flag2 = (input1 & 0x80000000) != 0;\n      temp1 = input2 * 2 + (uint)flag2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)flag2)) {\n        temp1 = temp1 | 0x80000000;\n      }\n      return CONCAT44(temp1,input1 << 1);\n    }\n    if (result1 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  result1 = result1 >> 0x15;\n  input4 = input4 >> 0x15;\n  result3 = input4 - result1;\n  flag2 = result3 != 0;\n  if (input4 < result1) {\n    result3 = -result3;\n  }\n  result2 = input1;\n  temp2 = input2;\n  if (flag2 && result1 <= input4) {\n    result1 = result1 + result3;\n    result2 = input3;\n    temp2 = temp1;\n    input3 = input1;\n    temp1 = input2;\n  }\n  if (0x36 < result3) {\n    return CONCAT44(temp2,result2);\n  }\n  var4 = temp2 & 0xfffff | 0x100000;\n  if ((temp2 & 0x80000000) != 0) {\n    flag2 = result2 != 0;\n    result2 = -result2;\n    var4 = -var4 - (uint)flag2;\n  }\n  temp2 = temp1 & 0xfffff | 0x100000;\n  if ((temp1 & 0x80000000) != 0) {\n    flag2 = input3 != 0;\n    input3 = -input3;\n    temp2 = -temp2 - (uint)flag2;\n  }\n  if (result1 == result3) {\n    temp2 = temp2 ^ 0x100000;\n    if (result1 == 0) {\n      var4 = var4 ^ 0x100000;\n      result1 = 1;\n    }\n    else {\n      result3 = result3 - 1;\n    }\n  }\n  temp1 = -result3 + 0x20;\n  if ((int)result3 < 0x21) {\n    result4 = input3 << (temp1 & 0xff);\n    input3 = input3 >> (result3 & 0xff);\n    var3 = result2 + input3;\n    var5 = temp2 << (temp1 & 0xff);\n    temp1 = var3 + var5;\n    var4 = var4 + CARRY4(result2,input3) + ((int)temp2 >> (result3 & 0xff)) +\n            (uint)CARRY4(var3,var5);\n  }\n  else {\n    result4 = temp2 << (-result3 + 0x40 & 0xff);\n    if (input3 != 0) {\n      result4 = result4 | 2;\n    }\n    temp2 = (int)temp2 >> (result3 - 0x20 & 0xff);\n    temp1 = result2 + temp2;\n    var4 = var4 + ((int)temp2 >> 0x1f) + (uint)CARRY4(result2,temp2);\n  }\n  input2 = var4 & 0x80000000;\n  result3 = var4;\n  if ((int)var4 < 0) {\n    flag2 = result4 == 0;\n    result4 = -result4;\n    result3 = -temp1;\n    temp1 = -(uint)!flag2 - temp1;\n    result3 = -(uint)(flag2 <= result3) - var4;\n  }\n  if (0xfffff < result3) {\n    result2 = result1 - 1;\n    if (0x1fffff < result3) {\n      result2 = result3 & 1;\n      result3 = result3 >> 1;\n      carry_flag = (byte)temp1;\n      temp1 = (uint)(result2 != 0) << 0x1f | temp1 >> 1;\n      result4 = (uint)(carry_flag & 1) << 0x1f | result4 >> 1;\n      result2 = result1;\n      if (0xffbfffff < result1 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    flag2 = 0x7fffffff < result4;\n    if (result4 == 0x80000000) {\n      flag2 = (temp1 & 1) != 0;\n    }\n    return CONCAT44(result3 + result2 * 0x100000 + (uint)CARRY4(temp1,(uint)flag2) | input2,\n                    temp1 + flag2);\n  }\n  flag1 = (result4 & 0x80000000) != 0;\n  result4 = result4 << 1;\n  result2 = temp1 * 2;\n  flag2 = CARRY4(temp1,temp1);\n  temp1 = temp1 * 2 + (uint)flag1;\n  result3 = result3 * 2 + (uint)(flag2 || CARRY4(result2,(uint)flag1));\n  result2 = result1 - 2;\n  if ((result3 & 0x100000) != 0) goto LAB_080002a0;\n  temp2 = temp1;\n  result1 = result3;\n  if (result3 == 0) {\n    temp2 = 0;\n    result1 = temp1;\n  }\n  right_shift_amount = LZCOUNT(result1);\n  if (result3 == 0) {\n    right_shift_amount = right_shift_amount + 0x20;\n  }\n  result3 = right_shift_amount - 0xb;\n  flag3 = SBORROW4(result3,0x20);\n  temp1 = right_shift_amount - 0x2b;\n  flag2 = (int)temp1 < 0;\n  flag1 = temp1 == 0;\n  if ((int)result3 < 0x20) {\n    flag3 = SCARRY4(temp1,0xc);\n    right_shift_amount = right_shift_amount + -0x1f;\n    flag2 = right_shift_amount < 0;\n    flag1 = right_shift_amount == 0;\n    temp1 = result3;\n    if (!flag1 && flag2 == flag3) {\n      temp2 = result1 << (result3 & 0xff);\n      result1 = result1 >> (0xcU - right_shift_amount & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (flag1 || flag2 != flag3) {\n    result4 = 0x20 - temp1;\n  }\n  result1 = result1 << (temp1 & 0xff);\n  if (flag1 || flag2 != flag3) {\n    result1 = result1 | temp2 >> (result4 & 0xff);\n  }\n  if (flag1 || flag2 != flag3) {\n    temp2 = temp2 << (temp1 & 0xff);\n  }\nLAB_08000318:\n  if ((int)result3 <= (int)result2) {\n    return CONCAT44(result1 + (result2 - result3) * 0x100000 | input2,temp2);\n  }\n  temp1 = ~(result2 - result3);\n  if ((int)temp1 < 0x1f) {\n    right_shift_amount = temp1 - 0x13;\n    if (right_shift_amount != 0 && right_shift_amount < 0 == SCARRY4(temp1 - 0x1f,0xc)) {\n      return CONCAT44(var4,temp2 >> (0x20 - (0xcU - right_shift_amount) & 0xff) | result1 << (0xcU - right_shift_amount & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp1 = temp1 + 1;\n    return CONCAT44(input2 | result1 >> (temp1 & 0xff),\n                    temp2 >> (temp1 & 0xff) | result1 << (0x20 - temp1 & 0xff));\n  }\n  return CONCAT44(var4,result1 >> (temp1 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000190": "calculate_arithmetic_result_08000190",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "left_shift_amount",
                "bVar2": "carry_flag",
                "uVar3": "var3",
                "uVar4": "var4",
                "uVar5": "var5",
                "uVar6": "temp1",
                "uVar7": "temp2",
                "iVar8": "right_shift_amount",
                "uVar9": "result1",
                "uVar10": "result2",
                "uVar11": "result3",
                "uVar12": "result4",
                "bVar13": "flag1",
                "bVar14": "flag2",
                "bVar15": "flag3"
            },
            "calling": [
                "SetTunings",
                "Compute",
                "SetControllerDirection",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000194": {
            "entrypoint": "0x08000194",
            "current_name": "calculate_sum_08000194",
            "code": "\nulonglong calculate_sum_08000194(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  int shift_count_1;\n  byte carry;\n  uint temp_1;\n  uint temp_2;\n  uint temp_3;\n  int shift_count_2;\n  uint temp_4;\n  uint temp_5;\n  uint result_1;\n  uint result_2;\n  uint bit_shift;\n  uint result_3;\n  bool is_negative;\n  bool check_flag;\n  bool overflow_flag;\n  \n  temp_4 = input_2 << 1;\n  result_1 = input_4 << 1;\n  is_negative = ((input_2 ^ input_4) & 0x7fffffff) == 0;\n  check_flag = is_negative && input_1 == input_3;\n  if (!is_negative || input_1 != input_3) {\n    check_flag = (temp_4 | input_1) == 0;\n  }\n  if (!check_flag) {\n    check_flag = (result_1 | input_3) == 0;\n  }\n  shift_count_2 = (int)temp_4 >> 0x15;\n  if (!check_flag) {\n    check_flag = shift_count_2 == -1;\n  }\n  shift_count_1 = (int)result_1 >> 0x15;\n  if (!check_flag) {\n    check_flag = shift_count_1 == -1;\n  }\n  if (check_flag) {\n    if (shift_count_2 == -1 || shift_count_1 == -1) {\n      result_1 = input_4;\n      temp_4 = input_3;\n      if (shift_count_2 == -1) {\n        result_1 = input_2;\n        temp_4 = input_1;\n      }\n      if (shift_count_2 != -1 || shift_count_1 != -1) {\n        input_3 = temp_4;\n        input_4 = result_1;\n      }\n      check_flag = (temp_4 | result_1 << 0xc) == 0;\n      if (check_flag) {\n        check_flag = (input_3 | input_4 << 0xc) == 0;\n      }\n      if (check_flag) {\n        check_flag = result_1 == input_4;\n      }\n      if (!check_flag) {\n        result_1 = result_1 | 0x80000;\n      }\n      return CONCAT44(result_1,temp_4);\n    }\n    if (((input_2 ^ input_4) & 0x7fffffff) != 0 || input_1 != input_3) {\n      if ((temp_4 | input_1) == 0) {\n        input_1 = input_3;\n        input_2 = input_4;\n      }\n      return CONCAT44(input_2,input_1);\n    }\n    if (input_2 != input_4) {\n      return 0;\n    }\n    if (temp_4 >> 0x15 == 0) {\n      check_flag = (input_1 & 0x80000000) != 0;\n      result_1 = input_2 * 2 + (uint)check_flag;\n      if (CARRY4(input_2,input_2) || CARRY4(input_2 * 2,(uint)check_flag)) {\n        result_1 = result_1 | 0x80000000;\n      }\n      return CONCAT44(result_1,input_1 << 1);\n    }\n    if (temp_4 < 0xffc00000) {\n      return CONCAT44(input_2 + 0x100000,input_1);\n    }\n    input_2 = input_2 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(input_2 | 0x7ff00000) << 0x20;\n  }\n  temp_4 = temp_4 >> 0x15;\n  result_1 = result_1 >> 0x15;\n  result_2 = result_1 - temp_4;\n  check_flag = result_2 != 0;\n  if (result_1 < temp_4) {\n    result_2 = -result_2;\n  }\n  temp_5 = input_1;\n  temp_3 = input_2;\n  if (check_flag && temp_4 <= result_1) {\n    temp_4 = temp_4 + result_2;\n    temp_5 = input_3;\n    temp_3 = input_4;\n    input_3 = input_1;\n    input_4 = input_2;\n  }\n  if (0x36 < result_2) {\n    return CONCAT44(temp_3,temp_5);\n  }\n  result_1 = temp_3 & 0xfffff | 0x100000;\n  if ((temp_3 & 0x80000000) != 0) {\n    check_flag = temp_5 != 0;\n    temp_5 = -temp_5;\n    result_1 = -result_1 - (uint)check_flag;\n  }\n  temp_3 = input_4 & 0xfffff | 0x100000;\n  if ((input_4 & 0x80000000) != 0) {\n    check_flag = input_3 != 0;\n    input_3 = -input_3;\n    temp_3 = -temp_3 - (uint)check_flag;\n  }\n  if (temp_4 == result_2) {\n    temp_3 = temp_3 ^ 0x100000;\n    if (temp_4 == 0) {\n      result_1 = result_1 ^ 0x100000;\n      temp_4 = 1;\n    }\n    else {\n      result_2 = result_2 - 1;\n    }\n  }\n  result_3 = -result_2 + 0x20;\n  if ((int)result_2 < 0x21) {\n    bit_shift = input_3 << (result_3 & 0xff);\n    input_3 = input_3 >> (result_2 & 0xff);\n    temp_1 = temp_5 + input_3;\n    temp_2 = temp_3 << (result_3 & 0xff);\n    result_3 = temp_1 + temp_2;\n    result_1 = result_1 + CARRY4(temp_5,input_3) + ((int)temp_3 >> (result_2 & 0xff)) +\n            (uint)CARRY4(temp_1,temp_2);\n  }\n  else {\n    bit_shift = temp_3 << (-result_2 + 0x40 & 0xff);\n    if (input_3 != 0) {\n      bit_shift = bit_shift | 2;\n    }\n    temp_3 = (int)temp_3 >> (result_2 - 0x20 & 0xff);\n    result_3 = temp_5 + temp_3;\n    result_1 = result_1 + ((int)temp_3 >> 0x1f) + (uint)CARRY4(temp_5,temp_3);\n  }\n  input_2 = result_1 & 0x80000000;\n  result_2 = result_1;\n  if ((int)result_1 < 0) {\n    check_flag = bit_shift == 0;\n    bit_shift = -bit_shift;\n    result_2 = -result_3;\n    result_3 = -(uint)!check_flag - result_3;\n    result_2 = -(uint)(check_flag <= result_2) - result_1;\n  }\n  if (0xfffff < result_2) {\n    temp_5 = temp_4 - 1;\n    if (0x1fffff < result_2) {\n      result_1 = result_2 & 1;\n      result_2 = result_2 >> 1;\n      carry = (byte)result_3;\n      result_3 = (uint)(result_1 != 0) << 0x1f | result_3 >> 1;\n      bit_shift = (uint)(carry & 1) << 0x1f | bit_shift >> 1;\n      temp_5 = temp_4;\n      if (0xffbfffff < temp_4 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    check_flag = 0x7fffffff < bit_shift;\n    if (bit_shift == 0x80000000) {\n      check_flag = (result_3 & 1) != 0;\n    }\n    return CONCAT44(result_2 + temp_5 * 0x100000 + (uint)CARRY4(result_3,(uint)check_flag) | input_2,\n                    result_3 + check_flag);\n  }\n  is_negative = (bit_shift & 0x80000000) != 0;\n  bit_shift = bit_shift << 1;\n  temp_5 = result_3 * 2;\n  check_flag = CARRY4(result_3,result_3);\n  result_3 = result_3 * 2 + (uint)is_negative;\n  result_2 = result_2 * 2 + (uint)(check_flag || CARRY4(temp_5,(uint)is_negative));\n  temp_5 = temp_4 - 2;\n  if ((result_2 & 0x100000) != 0) goto LAB_080002a0;\n  temp_3 = result_3;\n  temp_4 = result_2;\n  if (result_2 == 0) {\n    temp_3 = 0;\n    temp_4 = result_3;\n  }\n  shift_count_2 = LZCOUNT(temp_4);\n  if (result_2 == 0) {\n    shift_count_2 = shift_count_2 + 0x20;\n  }\n  result_3 = shift_count_2 - 0xb;\n  overflow_flag = SBORROW4(result_3,0x20);\n  result_2 = shift_count_2 - 0x2b;\n  check_flag = (int)result_2 < 0;\n  is_negative = result_2 == 0;\n  if ((int)result_3 < 0x20) {\n    overflow_flag = SCARRY4(result_2,0xc);\n    shift_count_2 = shift_count_2 + -0x1f;\n    check_flag = shift_count_2 < 0;\n    is_negative = shift_count_2 == 0;\n    result_2 = result_3;\n    if (!is_negative && check_flag == overflow_flag) {\n      temp_3 = temp_4 << (result_3 & 0xff);\n      temp_4 = temp_4 >> (0xcU - shift_count_2 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (is_negative || check_flag != overflow_flag) {\n    bit_shift = 0x20 - result_2;\n  }\n  temp_4 = temp_4 << (result_2 & 0xff);\n  if (is_negative || check_flag != overflow_flag) {\n    temp_4 = temp_4 | temp_3 >> (bit_shift & 0xff);\n  }\n  if (is_negative || check_flag != overflow_flag) {\n    temp_3 = temp_3 << (result_2 & 0xff);\n  }\nLAB_08000318:\n  if ((int)result_3 <= (int)temp_5) {\n    return CONCAT44(temp_4 + (temp_5 - result_3) * 0x100000 | input_2,temp_3);\n  }\n  result_2 = ~(temp_5 - result_3);\n  if ((int)result_2 < 0x1f) {\n    shift_count_2 = result_2 - 0x13;\n    if (shift_count_2 != 0 && shift_count_2 < 0 == SCARRY4(result_2 - 0x1f,0xc)) {\n      return CONCAT44(result_1,temp_3 >> (0x20 - (0xcU - shift_count_2) & 0xff) | temp_4 << (0xcU - shift_count_2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    result_2 = result_2 + 1;\n    return CONCAT44(input_2 | temp_4 >> (result_2 & 0xff),\n                    temp_3 >> (result_2 & 0xff) | temp_4 << (0x20 - result_2 & 0xff));\n  }\n  return CONCAT44(result_1,temp_4 >> (result_2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000194": "calculate_sum_08000194",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "shift_count_1",
                "bVar2": "carry",
                "uVar3": "temp_1",
                "uVar4": "temp_2",
                "uVar5": "temp_3",
                "iVar6": "shift_count_2",
                "uVar7": "temp_4",
                "uVar8": "temp_5",
                "uVar9": "result_1",
                "uVar10": "result_2",
                "uVar11": "bit_shift",
                "uVar12": "result_3",
                "bVar13": "is_negative",
                "bVar14": "check_flag",
                "bVar15": "overflow_flag"
            },
            "calling": [
                "loop",
                "Compute",
                "__aeabi_drsub",
                "readThermocouple",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800040c": {
            "entrypoint": "0x0800040c",
            "current_name": "reverse_bits_0800040c",
            "code": "\nulonglong reverseBits_0800040c(uint input)\n\n{\n  uint result1;\n  uint result2;\n  int bitCount;\n  uint shiftAmount;\n  uint remainingBits;\n  bool isNegative;\n  bool isZero;\n  bool isCarry;\n  \n  if (input == 0) {\n    return 0;\n  }\n  result1 = 0;\n  bitCount = LZCOUNT(input);\n  shiftAmount = bitCount + 0x15;\n  isCarry = SBORROW4(shiftAmount,0x20);\n  result2 = bitCount - 0xb;\n  isNegative = (int)result2 < 0;\n  isZero = result2 == 0;\n  if (shiftAmount < 0x20) {\n    isCarry = SCARRY4(result2,0xc);\n    isNegative = false;\n    isZero = bitCount + 1 == 0;\n    result2 = shiftAmount;\n    if (!isZero && isCarry == false) {\n      result1 = input << shiftAmount;\n      input = input >> (0xcU - (bitCount + 1) & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (isZero || isNegative != isCarry) {\n    remainingBits = 0x20 - result2;\n  }\n  input = input << (result2 & 0xff);\n  if (isZero || isNegative != isCarry) {\n    input = input | 0U >> (remainingBits & 0xff);\n  }\n  if (isZero || isNegative != isCarry) {\n    result1 = 0 << (result2 & 0xff);\n  }\nLAB_08000318:\n  if (shiftAmount < 0x433) {\n    return CONCAT44(input + (0x432 - shiftAmount) * 0x100000,result1);\n  }\n  result2 = ~(0x432 - shiftAmount);\n  if (0x1e < (int)result2) {\n    return (ulonglong)(input >> (result2 - 0x1f & 0xff));\n  }\n  bitCount = result2 - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(result2 - 0x1f,0xc)) {\n    result2 = result2 + 1;\n    return CONCAT44(input >> (result2 & 0xff),\n                    result1 >> (result2 & 0xff) | input << (0x20 - result2 & 0xff));\n  }\n  return (ulonglong)(result1 >> (0x20 - (0xcU - bitCount) & 0xff) | input << (0xcU - bitCount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800040c": "reverse_bits_0800040c",
                "param_1": "input",
                "uVar1": "result1",
                "uVar2": "result2",
                "iVar3": "bitCount",
                "uVar4": "shiftAmount",
                "in_r12": "remainingBits",
                "bVar5": "isNegative",
                "bVar6": "isZero",
                "bVar7": "isCarry"
            },
            "calling": [
                "loop",
                "SetTunings",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800042c": {
            "entrypoint": "0x0800042c",
            "current_name": "count_leading_zeros_0800042c",
            "code": "\nulonglong countLeadingZeros_0800042c(uint input)\n\n{\n  uint leadingZeros;\n  uint absInput;\n  uint shiftAmount;\n  int leadingOnes;\n  uint finalShift;\n  uint signBit;\n  uint remainingShift;\n  bool isZeroOrNegative;\n  bool isZero;\n  bool isShiftOutOfRange;\n  \n  if (input == 0) {\n    return 0;\n  }\n  signBit = input & 0x80000000;\n  absInput = input;\n  if ((int)signBit < 0) {\n    absInput = -input;\n  }\n  leadingZeros = 0;\n  leadingOnes = LZCOUNT(absInput);\n  finalShift = leadingOnes + 0x15;\n  isShiftOutOfRange = SBORROW4(finalShift,0x20);\n  shiftAmount = leadingOnes - 0xb;\n  isZeroOrNegative = (int)shiftAmount < 0;\n  isZero = shiftAmount == 0;\n  if (finalShift < 0x20) {\n    isShiftOutOfRange = SCARRY4(shiftAmount,0xc);\n    isZeroOrNegative = false;\n    isZero = leadingOnes + 1 == 0;\n    shiftAmount = finalShift;\n    if (!isZero && isShiftOutOfRange == false) {\n      leadingZeros = absInput << finalShift;\n      absInput = absInput >> (0xcU - (leadingOnes + 1) & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (isZero || isZeroOrNegative != isShiftOutOfRange) {\n    remainingShift = 0x20 - shiftAmount;\n  }\n  absInput = absInput << (shiftAmount & 0xff);\n  if (isZero || isZeroOrNegative != isShiftOutOfRange) {\n    absInput = absInput | 0U >> (remainingShift & 0xff);\n  }\n  if (isZero || isZeroOrNegative != isShiftOutOfRange) {\n    leadingZeros = 0 << (shiftAmount & 0xff);\n  }\nLAB_08000318:\n  if (finalShift < 0x433) {\n    return CONCAT44(absInput + (0x432 - finalShift) * 0x100000 | signBit,leadingZeros);\n  }\n  shiftAmount = ~(0x432 - finalShift);\n  if (0x1e < (int)shiftAmount) {\n    return CONCAT44(input,absInput >> (shiftAmount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leadingOnes = shiftAmount - 0x13;\n  if (leadingOnes == 0 || leadingOnes < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(signBit | absInput >> (shiftAmount & 0xff),\n                    leadingZeros >> (shiftAmount & 0xff) | absInput << (0x20 - shiftAmount & 0xff));\n  }\n  return CONCAT44(input,leadingZeros >> (0x20 - (0xcU - leadingOnes) & 0xff) | absInput << (0xcU - leadingOnes & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800042c": "count_leading_zeros_0800042c",
                "param_1": "input",
                "uVar1": "leadingZeros",
                "uVar2": "absInput",
                "uVar3": "shiftAmount",
                "iVar4": "leadingOnes",
                "uVar5": "finalShift",
                "uVar6": "signBit",
                "in_r12": "remainingShift",
                "bVar7": "isZeroOrNegative",
                "bVar8": "isZero",
                "bVar9": "isShiftOutOfRange"
            },
            "calling": [
                "loop",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000450": {
            "entrypoint": "0x08000450",
            "current_name": "decode_and_shift_bits_08000450",
            "code": "\nulonglong decodeAndShiftBits_08000450(uint inputValue,undefined4 param2,undefined4 param3,uint param4)\n\n{\n  uint bit31AsUInt;\n  uint shiftedValue;\n  uint bit31AndShiftedValue;\n  uint shiftAmount;\n  uint shiftedValueTimes2;\n  int bitLeadingZeros;\n  uint valueMinus11Shifted;\n  uint remainder;\n  bool isLessThanZero;\n  bool isZero;\n  bool isCarry;\n  \n  shiftedValueTimes2 = inputValue << 1;\n  isZero = shiftedValueTimes2 == 0;\n  bit31AsUInt = (uint)((inputValue & 0x80000000) != 0) << 0x1f;\n  shiftAmount = (uint)((int)shiftedValueTimes2 >> 3) >> 1;\n  bit31AndShiftedValue = bit31AsUInt | shiftAmount;\n  inputValue = inputValue << 0x1d;\n  if (!isZero) {\n    param4 = shiftedValueTimes2 & 0xff000000;\n    isZero = param4 == 0;\n  }\n  if (!isZero) {\n    isZero = param4 == 0xff000000;\n  }\n  if (!isZero) {\n    return concatenateUInt64(bit31AndShiftedValue,inputValue) ^ 0x3800000000000000;\n  }\n  if (shiftedValueTimes2 == 0 || param4 == 0xff000000) {\n    return concatenateUInt64(bit31AndShiftedValue,inputValue);\n  }\n  shiftedValue = inputValue;\n  shiftedValueTimes2 = shiftAmount;\n  if (shiftAmount == 0) {\n    shiftedValue = 0;\n    shiftedValueTimes2 = inputValue;\n  }\n  bitLeadingZeros = countLeadingZeros(shiftedValueTimes2);\n  if (shiftAmount == 0) {\n    bitLeadingZeros = bitLeadingZeros + 0x20;\n  }\n  valueMinus11Shifted = bitLeadingZeros - 0xb;\n  isCarry = subtractionOverflow(valueMinus11Shifted,0x20);\n  shiftAmount = bitLeadingZeros - 0x2b;\n  isZero = (int)shiftAmount < 0;\n  isLessThanZero = shiftAmount == 0;\n  if ((int)valueMinus11Shifted < 0x20) {\n    isCarry = additionOverflow(shiftAmount,0xc);\n    bitLeadingZeros = bitLeadingZeros + -0x1f;\n    isZero = bitLeadingZeros < 0;\n    isLessThanZero = bitLeadingZeros == 0;\n    shiftAmount = valueMinus11Shifted;\n    if (!isLessThanZero && isZero == isCarry) {\n      shiftedValue = shiftedValueTimes2 << (valueMinus11Shifted & 0xff);\n      shiftedValueTimes2 = shiftedValueTimes2 >> (0xcU - bitLeadingZeros & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (isLessThanZero || isZero != isCarry) {\n    remainder = 0x20 - shiftAmount;\n  }\n  shiftedValueTimes2 = shiftedValueTimes2 << (shiftAmount & 0xff);\n  if (isLessThanZero || isZero != isCarry) {\n    shiftedValueTimes2 = shiftedValueTimes2 | shiftedValue >> (remainder & 0xff);\n  }\n  if (isLessThanZero || isZero != isCarry) {\n    shiftedValue = shiftedValue << (shiftAmount & 0xff);\n  }\nLAB_08000318:\n  if ((int)valueMinus11Shifted < 0x381) {\n    return concatenateUInt64(shiftedValueTimes2 + (0x380 - valueMinus11Shifted) * 0x100000 | bit31AsUInt,shiftedValue);\n  }\n  shiftAmount = ~(0x380 - valueMinus11Shifted);\n  if ((int)shiftAmount < 0x1f) {\n    bitLeadingZeros = shiftAmount - 0x13;\n    if (bitLeadingZeros != 0 && bitLeadingZeros < 0 == additionOverflow(shiftAmount - 0x1f,0xc)) {\n      return concatenateUInt64(bit31AndShiftedValue,shiftedValue >> (0x20 - (0xcU - bitLeadingZeros) & 0xff) | shiftedValueTimes2 << (0xcU - bitLeadingZeros & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shiftAmount = shiftAmount + 1;\n    return concatenateUInt64(bit31AsUInt | shiftedValueTimes2 >> (shiftAmount & 0xff),\n                    shiftedValue >> (shiftAmount & 0xff) | shiftedValueTimes2 << (0x20 - shiftAmount & 0xff));\n  }\n  return concatenateUInt64(bit31AndShiftedValue,shiftedValueTimes2 >> (shiftAmount - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000450": "decode_and_shift_bits_08000450",
                "param_1": "inputValue",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "bit31AsUInt",
                "uVar2": "shiftedValue",
                "uVar3": "bit31AndShiftedValue",
                "uVar4": "shiftAmount",
                "uVar5": "shiftedValueTimes2",
                "uVar7": "valueMinus11Shifted",
                "in_r12": "remainder",
                "bVar8": "isLessThanZero",
                "bVar9": "isZero",
                "bVar10": "isCarry",
                "iVar6": "bitLeadingZeros",
                "LZCOUNT": "countLeadingZeros",
                "CONCAT44": "concatenateUInt64",
                "SBORROW4": "subtractionOverflow",
                "SCARRY4": "additionOverflow"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800048c": {
            "entrypoint": "0x0800048c",
            "current_name": "convert_to_unsigned_long_long_0800048c",
            "code": "\nulonglong convertToUnsignedLongLong_0800048c(uint num1,uint num2)\n\n{\n  byte byte1;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int temp4;\n  uint temp5;\n  int temp6;\n  uint temp7;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  if ((num1 | num2) == 0) {\n    return CONCAT44(num2,num1);\n  }\n  temp6 = 0x432;\n  temp7 = num2 >> 0x16;\n  if (temp7 != 0) {\n    temp6 = 3;\n    if (num2 >> 0x19 != 0) {\n      temp6 = 6;\n    }\n    if (num2 >> 0x1c != 0) {\n      temp6 = temp6 + 3;\n    }\n    temp3 = temp6 - ((int)num2 >> 0x1f);\n    temp7 = num1 << (0x20 - temp3 & 0xff);\n    num1 = num1 >> (temp3 & 0xff) | num2 << (0x20 - temp3 & 0xff);\n    num2 = num2 >> (temp3 & 0xff);\n    temp6 = temp3 + 0x432;\n  }\n  if (0xfffff < num2) {\n    if (0x1fffff < num2) {\n      temp3 = num2 & 1;\n      num2 = num2 >> 1;\n      byte1 = (byte)num1;\n      num1 = (uint)(temp3 != 0) << 0x1f | num1 >> 1;\n      temp7 = (uint)(byte1 & 1) << 0x1f | temp7 >> 1;\n      temp6 = temp6 + 1;\n      if (0xffbfffff < (uint)(temp6 * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_080002a0:\n    flag2 = 0x7fffffff < temp7;\n    if (temp7 == 0x80000000) {\n      flag2 = (num1 & 1) != 0;\n    }\n    return CONCAT44(num2 + temp6 * 0x100000 + (uint)CARRY4(num1,(uint)flag2),num1 + flag2\n                   );\n  }\n  flag1 = (temp7 & 0x80000000) != 0;\n  temp7 = temp7 << 1;\n  temp3 = num1 * 2;\n  flag2 = CARRY4(num1,num1);\n  num1 = num1 * 2 + (uint)flag1;\n  num2 = num2 * 2 + (uint)(flag2 || CARRY4(temp3,(uint)flag1));\n  temp6 = temp6 + -1;\n  if ((num2 & 0x100000) != 0) goto LAB_080002a0;\n  temp1 = num1;\n  temp3 = num2;\n  if (num2 == 0) {\n    temp1 = 0;\n    temp3 = num1;\n  }\n  temp4 = LZCOUNT(temp3);\n  if (num2 == 0) {\n    temp4 = temp4 + 0x20;\n  }\n  temp5 = temp4 - 0xb;\n  flag3 = SBORROW4(temp5,0x20);\n  temp2 = temp4 - 0x2b;\n  flag2 = (int)temp2 < 0;\n  flag1 = temp2 == 0;\n  if ((int)temp5 < 0x20) {\n    flag3 = SCARRY4(temp2,0xc);\n    temp4 = temp4 + -0x1f;\n    flag2 = temp4 < 0;\n    flag1 = temp4 == 0;\n    temp2 = temp5;\n    if (!flag1 && flag2 == flag3) {\n      temp1 = temp3 << (temp5 & 0xff);\n      temp3 = temp3 >> (0xcU - temp4 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (flag1 || flag2 != flag3) {\n    temp7 = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (flag1 || flag2 != flag3) {\n    temp3 = temp3 | temp1 >> (temp7 & 0xff);\n  }\n  if (flag1 || flag2 != flag3) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_08000318:\n  if ((int)temp5 <= temp6) {\n    return CONCAT44(temp3 + (temp6 - temp5) * 0x100000,temp1);\n  }\n  temp7 = ~(temp6 - temp5);\n  if (0x1e < (int)temp7) {\n    return (ulonglong)(temp3 >> (temp7 - 0x1f & 0xff));\n  }\n  temp6 = temp7 - 0x13;\n  if (temp6 == 0 || temp6 < 0 != SCARRY4(temp7 - 0x1f,0xc)) {\n    temp7 = temp7 + 1;\n    return CONCAT44(temp3 >> (temp7 & 0xff),temp1 >> (temp7 & 0xff) | temp3 << (0x20 - temp7 & 0xff)\n                   );\n  }\n  return (ulonglong)(temp1 >> (0x20 - (0xcU - temp6) & 0xff) | temp3 << (0xcU - temp6 & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800048c": "convert_to_unsigned_long_long_0800048c",
                "param_1": "num1",
                "param_2": "num2",
                "bVar1": "byte1",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "temp4",
                "uVar6": "temp5",
                "iVar7": "temp6",
                "uVar8": "temp7",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800049c": {
            "entrypoint": "0x0800049c",
            "current_name": "calculate_floating_point_0800049c",
            "code": "\nulonglong calculateFloatingPoint_0800049c(uint input1,uint input2)\n\n{\n  byte bit1;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int var1;\n  uint temp4;\n  int var2;\n  uint temp5;\n  uint temp6;\n  bool carry1;\n  bool carry2;\n  bool carry3;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  temp5 = input2 & 0x80000000;\n  temp2 = input2;\n  if ((int)temp5 < 0) {\n    carry2 = input1 != 0;\n    input1 = -input1;\n    temp2 = -input2 - (uint)carry2;\n  }\n  var2 = 0x432;\n  temp6 = temp2 >> 0x16;\n  if (temp6 != 0) {\n    var2 = 3;\n    if (temp2 >> 0x19 != 0) {\n      var2 = 6;\n    }\n    if (temp2 >> 0x1c != 0) {\n      var2 = var2 + 3;\n    }\n    temp3 = var2 - ((int)temp2 >> 0x1f);\n    temp6 = input1 << (0x20 - temp3 & 0xff);\n    input1 = input1 >> (temp3 & 0xff) | temp2 << (0x20 - temp3 & 0xff);\n    temp2 = temp2 >> (temp3 & 0xff);\n    var2 = temp3 + 0x432;\n  }\n  if (0xfffff < temp2) {\n    if (0x1fffff < temp2) {\n      temp3 = temp2 & 1;\n      temp2 = temp2 >> 1;\n      bit1 = (byte)input1;\n      input1 = (uint)(temp3 != 0) << 0x1f | input1 >> 1;\n      temp6 = (uint)(bit1 & 1) << 0x1f | temp6 >> 1;\n      var2 = var2 + 1;\n      if (0xffbfffff < (uint)(var2 * 0x200000)) {\n        return (ulonglong)(temp5 | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_080002a0:\n    carry2 = 0x7fffffff < temp6;\n    if (temp6 == 0x80000000) {\n      carry2 = (input1 & 1) != 0;\n    }\n    return CONCAT44(temp2 + var2 * 0x100000 + (uint)CARRY4(input1,(uint)carry2) | temp5,\n                    input1 + carry2);\n  }\n  carry1 = (temp6 & 0x80000000) != 0;\n  temp6 = temp6 << 1;\n  temp3 = input1 * 2;\n  carry2 = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)carry1;\n  temp2 = temp2 * 2 + (uint)(carry2 || CARRY4(temp3,(uint)carry1));\n  var2 = var2 + -1;\n  if ((temp2 & 0x100000) != 0) goto LAB_080002a0;\n  temp1 = input1;\n  temp3 = temp2;\n  if (temp2 == 0) {\n    temp1 = 0;\n    temp3 = input1;\n  }\n  var1 = LZCOUNT(temp3);\n  if (temp2 == 0) {\n    var1 = var1 + 0x20;\n  }\n  temp4 = var1 - 0xb;\n  carry3 = SBORROW4(temp4,0x20);\n  temp2 = var1 - 0x2b;\n  carry2 = (int)temp2 < 0;\n  carry1 = temp2 == 0;\n  if ((int)temp4 < 0x20) {\n    carry3 = SCARRY4(temp2,0xc);\n    var1 = var1 + -0x1f;\n    carry2 = var1 < 0;\n    carry1 = var1 == 0;\n    temp2 = temp4;\n    if (!carry1 && carry2 == carry3) {\n      temp1 = temp3 << (temp4 & 0xff);\n      temp3 = temp3 >> (0xcU - var1 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (carry1 || carry2 != carry3) {\n    temp6 = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (carry1 || carry2 != carry3) {\n    temp3 = temp3 | temp1 >> (temp6 & 0xff);\n  }\n  if (carry1 || carry2 != carry3) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_08000318:\n  if ((int)temp4 <= var2) {\n    return CONCAT44(temp3 + (var2 - temp4) * 0x100000 | temp5,temp1);\n  }\n  temp2 = ~(var2 - temp4);\n  if (0x1e < (int)temp2) {\n    return CONCAT44(input2,temp3 >> (temp2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  var2 = temp2 - 0x13;\n  if (var2 == 0 || var2 < 0 != SCARRY4(temp2 - 0x1f,0xc)) {\n    temp2 = temp2 + 1;\n    return CONCAT44(temp5 | temp3 >> (temp2 & 0xff),\n                    temp1 >> (temp2 & 0xff) | temp3 << (0x20 - temp2 & 0xff));\n  }\n  return CONCAT44(input2,temp1 >> (0x20 - (0xcU - var2) & 0xff) | temp3 << (0xcU - var2 & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800049c": "calculate_floating_point_0800049c",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "bit1",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "var1",
                "uVar6": "temp4",
                "iVar7": "var2",
                "uVar8": "temp5",
                "uVar9": "temp6",
                "bVar10": "carry1",
                "bVar11": "carry2",
                "bVar12": "carry3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004f8": {
            "entrypoint": "0x080004f8",
            "current_name": "calculate_double_precision_080004f8",
            "code": "\nulonglong calculate_double_precision_080004f8(undefined4 input1,uint input2,uint operand1,uint operand2)\n\n{\n  ulonglong result_upper;\n  longlong temp;\n  uint operand1_lower;\n  uint operand2_lower;\n  int sum_of_exponents;\n  uint temp_lower;\n  uint operand2_exponent;\n  uint temp_upper;\n  uint result_lower;\n  bool is_zero;\n  bool is_overflow;\n  bool is_negative;\n  ulonglong input1_concat_input2;\n  \n  input1_concat_input2 = CONCAT44(input2,input1);\n  temp_upper = 0x7ff;\n  operand2_lower = input2 >> 0x14 & 0x7ff;\n  is_zero = operand2_lower == 0;\n  if (!is_zero) {\n    operand2_exponent = operand2 >> 0x14 & 0x7ff;\n    is_zero = operand2_exponent == 0;\n  }\n  if (!is_zero) {\n    is_zero = operand2_lower == 0x7ff;\n  }\n  if (!is_zero) {\n    is_zero = operand2_exponent == 0x7ff;\n  }\n  if (is_zero) {\n    input1_concat_input2 = reverse_and_mask_bits_080006d4();\n  }\n  operand1_lower = (uint)(input1_concat_input2 >> 0x20);\n  sum_of_exponents = operand2_lower + operand2_exponent;\n  operand2_lower = operand1_lower ^ operand2;\n  operand1_lower = operand1_lower & ~(temp_upper << 0x15);\n  operand2 = operand2 & ~(temp_upper << 0x15);\n  is_zero = ((uint)input1_concat_input2 | operand1_lower << 0xc) == 0;\n  if (!is_zero) {\n    is_zero = (operand1 | operand2 << 0xc) == 0;\n  }\n  operand1_lower = operand1_lower | 0x100000;\n  operand2 = operand2 | 0x100000;\n  if (is_zero) {\n    operand1 = (uint)input1_concat_input2 | operand1;\n    operand2 = (operand2_lower & 0x80000000 | operand1_lower) ^ operand2;\n    operand2_lower = temp_upper >> 1;\n    is_negative = SBORROW4(sum_of_exponents,operand2_lower);\n    temp_lower = sum_of_exponents - operand2_lower;\n    is_zero = temp_lower == 0;\n    operand1_lower = temp_lower;\n    if (!is_zero && (int)operand2_lower <= sum_of_exponents) {\n      is_negative = SBORROW4(temp_upper,temp_lower);\n      operand1_lower = temp_upper - temp_lower;\n      is_zero = temp_upper == temp_lower;\n    }\n    if (!is_zero && (int)operand1_lower < 0 == is_negative) {\n      operand2 = operand2 | temp_lower * 0x100000;\n    }\n    if (!is_zero && (int)operand1_lower < 0 == is_negative) {\n      return CONCAT44(operand2,operand1);\n    }\n    operand2 = operand2 | 0x100000;\n    temp_upper = 0;\n    is_negative = SBORROW4(temp_lower,1);\n    temp_lower = temp_lower - 1;\n    is_zero = temp_lower == 0;\n    operand2_lower = temp_lower;\n  }\n  else {\n    result_upper = (input1_concat_input2 & 0xffffffff) * (ulonglong)operand1;\n    input1_concat_input2 = (input1_concat_input2 & 0xffffffff) * (ulonglong)operand2 +\n             (ulonglong)operand1_lower * (ulonglong)operand1 + (result_upper >> 0x20);\n    result_lower = (uint)input1_concat_input2;\n    temp = (ulonglong)operand1_lower * (ulonglong)operand2 + (input1_concat_input2 >> 0x20);\n    temp_upper = (uint)temp;\n    operand1_lower = (uint)((ulonglong)temp >> 0x20);\n    if ((int)result_upper != 0) {\n      result_lower = result_lower | 1;\n    }\n    temp_lower = (sum_of_exponents + -0x3ff) - (uint)(operand1_lower < 0x200);\n    if (operand1_lower < 0x200) {\n      is_zero = (result_lower & 0x80000000) != 0;\n      result_lower = result_lower << 1;\n      temp = CONCAT44(operand1_lower * 2 + (uint)(CARRY4(temp_upper,temp_upper) || CARRY4(temp_upper * 2,(uint)is_zero)),\n                       temp_upper * 2 + (uint)is_zero);\n    }\n    operand2 = operand2_lower & 0x80000000 | (int)((ulonglong)temp >> 0x20) << 0xb | (uint)temp >> 0x15;\n    operand1 = (uint)temp << 0xb | result_lower >> 0x15;\n    temp_upper = result_lower * 0x800;\n    is_overflow = 0xfc < temp_lower;\n    is_negative = SBORROW4(temp_lower,0xfd);\n    operand1_lower = temp_lower - 0xfd;\n    is_zero = operand1_lower == 0;\n    operand2_lower = operand1_lower;\n    if (is_overflow && !is_zero) {\n      is_overflow = 0x6ff < operand1_lower;\n      is_negative = SBORROW4(operand1_lower,0x700);\n      operand2_lower = temp_lower - 0x7fd;\n      is_zero = operand1_lower == 0x700;\n    }\n    if (!is_overflow || is_zero) {\n      is_zero = 0x7fffffff < temp_upper;\n      if (temp_upper == 0x80000000) {\n        is_zero = (result_lower >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(operand2 + temp_lower * 0x100000 + (uint)CARRY4(operand1,(uint)is_zero),operand1 + is_zero\n                     );\n    }\n  }\n  if (!is_zero && (int)operand2_lower < 0 == is_negative) {\n    return (ulonglong)(operand2 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  is_overflow = SCARRY4(temp_lower,0x36);\n  is_zero = (int)(temp_lower + 0x36) < 0;\n  is_negative = temp_lower == 0xffffffca;\n  if (is_negative || is_zero != is_overflow) {\n    operand1 = 0;\n  }\n  if (is_negative || is_zero != is_overflow) {\n    operand2 = operand2 & 0x80000000;\n  }\n  if (is_negative || is_zero != is_overflow) {\n    return CONCAT44(operand2,operand1);\n  }\n  operand2_lower = -temp_lower;\n  operand1_lower = operand2_lower - 0x20;\n  if (0x1f < (int)operand2_lower) {\n    temp_lower = operand1 >> (operand1_lower & 0xff) | operand2 << (0x20 - operand1_lower & 0xff);\n    operand2_lower = (operand2 >> (operand1_lower & 0xff) & ~((operand2 & 0x80000000) >> (operand1_lower & 0xff))) -\n            ((int)temp_lower >> 0x1f);\n    if ((temp_upper | operand1 << (0x20 - operand1_lower & 0xff) | temp_lower << 1) == 0) {\n      operand2_lower = operand2_lower & ~(temp_lower >> 0x1f);\n    }\n    return CONCAT44(operand2,operand2_lower) & 0x80000000ffffffff;\n  }\n  sum_of_exponents = operand2_lower - 0x14;\n  if (sum_of_exponents == 0 || sum_of_exponents < 0 != SCARRY4(operand1_lower,0xc)) {\n    result_lower = operand1 << (temp_lower + 0x20 & 0xff);\n    operand1_lower = operand1 >> (operand2_lower & 0xff) | operand2 << (temp_lower + 0x20 & 0xff);\n    temp_lower = operand1_lower + -((int)result_lower >> 0x1f);\n    if ((temp_upper | result_lower << 1) == 0) {\n      temp_lower = temp_lower & ~(result_lower >> 0x1f);\n    }\n    return CONCAT44((operand2 & 0x80000000) +\n                    ((operand2 & 0x7fffffff) >> (operand2_lower & 0xff)) +\n                    (uint)CARRY4(operand1_lower,-((int)result_lower >> 0x1f)),temp_lower);\n  }\n  operand2_lower = 0xc - sum_of_exponents;\n  temp_lower = operand1 << (operand2_lower & 0xff);\n  operand2_lower = operand1 >> (0x20 - operand2_lower & 0xff) | operand2 << (operand2_lower & 0xff);\n  operand1_lower = operand2_lower + -((int)temp_lower >> 0x1f);\n  if ((temp_upper | temp_lower << 1) == 0) {\n    operand1_lower = operand1_lower & ~(temp_lower >> 0x1f);\n  }\n  return CONCAT44((operand2 & 0x80000000) + (uint)CARRY4(operand2_lower,-((int)temp_lower >> 0x1f)),operand1_lower);\n}\n\n",
            "renaming": {
                "FUN_080004f8": "calculate_double_precision_080004f8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "operand1",
                "param_4": "operand2",
                "uVar1": "result_upper",
                "lVar2": "temp",
                "uVar3": "operand1_lower",
                "uVar4": "operand2_lower",
                "iVar5": "sum_of_exponents",
                "uVar6": "temp_lower",
                "unaff_r5": "operand2_exponent",
                "uVar7": "temp_upper",
                "uVar8": "result_lower",
                "bVar9": "is_zero",
                "bVar10": "is_overflow",
                "bVar11": "is_negative",
                "uVar12": "input1_concat_input2"
            },
            "calling": [
                "SetTunings",
                "Compute",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [
                "FUN_080006d4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006d4": {
            "entrypoint": "0x080006d4",
            "current_name": "reverse_and_mask_bits_080006d4",
            "code": "\nulonglong reverseAndMaskBits_080006d4(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint mask;\n  bool isZero;\n  \n  temp3 = mask & input4 >> 0x14;\n  if (temp2 != mask && temp3 != mask) {\n    isZero = (input1 | input2 << 1) == 0;\n    if (!isZero) {\n      isZero = (input3 | input4 << 1) == 0;\n    }\n    if (isZero) {\n      result (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n    }\n    if (temp2 == 0) {\n      temp4 = input2 & 0x80000000;\n      do {\n        temp1 = input1 & 0x80000000;\n        input1 = input1 << 1;\n        input2 = input2 * 2 + (uint)(temp1 != 0);\n      } while ((input2 & 0x100000) == 0);\n      input2 = input2 | temp4;\n      if (temp3 != 0) {\n        result CONCAT44(input2,input1);\n      }\n    }\n    do {\n      temp3 = input3 & 0x80000000;\n      input3 = input3 << 1;\n      input4 = input4 * 2 + (uint)(temp3 != 0);\n    } while ((input4 & 0x100000) == 0);\n    result CONCAT44(input2,input1);\n  }\n  isZero = (input1 | input2 << 1) == 0;\n  if (isZero) {\n    input2 = input4;\n    input1 = input3;\n  }\n  if (!isZero) {\n    isZero = (input3 | input4 << 1) == 0;\n  }\n  temp4 = input2;\n  if (((!isZero) && ((temp2 != mask || ((input1 | input2 << 0xc) == 0)))) &&\n     ((temp3 != mask || (input1 = input3, temp4 = input4, (input3 | input4 << 0xc) == 0)))) {\n    result (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  result CONCAT44(temp4,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006d4": "reverse_and_mask_bits_080006d4",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "temp1",
                "unaff_r4": "temp2",
                "uVar2": "temp3",
                "uVar3": "temp4",
                "in_r12": "mask",
                "bVar4": "isZero",
                "return": "result"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800074c": {
            "entrypoint": "0x0800074c",
            "current_name": "calculate_floating_point_0800074c",
            "code": "\nulonglong calculate_floating_point_0800074c(undefined4 input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint temp_1;\n  uint temp_2;\n  uint temp_3;\n  uint temp_4;\n  uint temp_5;\n  uint temp_6;\n  uint temp_7;\n  int temp_8;\n  uint temp_9;\n  uint temp_10;\n  uint temp_11;\n  uint temp_12;\n  uint temp_13;\n  uint temp_14;\n  bool flag_1;\n  bool flag_2;\n  bool flag_3;\n  undefined8 result;\n  \n  result = CONCAT44(input_2,input_1);\n  temp_14 = 0x7ff;\n  temp_7 = input_2 >> 0x14 & 0x7ff;\n  flag_1 = temp_7 == 0;\n  if (!flag_1) {\n    temp_10 = input_4 >> 0x14 & 0x7ff;\n    flag_1 = temp_10 == 0;\n  }\n  if (!flag_1) {\n    flag_1 = temp_7 == 0x7ff;\n  }\n  if (!flag_1) {\n    flag_1 = temp_10 == 0x7ff;\n  }\n  if (flag_1) {\n    result = calculate_floating_point_0800074c_number_080008ba();\n  }\n  temp_9 = (uint)((ulonglong)result >> 0x20);\n  temp_12 = (uint)result;\n  temp_8 = temp_7 - temp_10;\n  if ((input_3 | input_4 << 0xc) == 0) {\n    temp_7 = (temp_9 ^ input_4) & 0x80000000 | temp_9 & 0xfffff;\n    flag_3 = SCARRY4(temp_8,temp_14 >> 1);\n    temp_9 = temp_8 + (temp_14 >> 1);\n    flag_1 = (int)temp_9 < 0;\n    flag_2 = temp_9 == 0;\n    if (!flag_2 && flag_1 == flag_3) {\n      flag_3 = SBORROW4(temp_14,temp_9);\n      flag_1 = (int)(temp_14 - temp_9) < 0;\n      flag_2 = temp_14 == temp_9;\n    }\n    if (!flag_2 && flag_1 == flag_3) {\n      temp_7 = temp_7 | temp_9 * 0x100000;\n    }\n    if (!flag_2 && flag_1 == flag_3) {\n      return CONCAT44(temp_7,temp_12);\n    }\n    temp_7 = temp_7 | 0x100000;\n    temp_14 = 0;\n    flag_2 = SBORROW4(temp_9,1);\n    temp_9 = temp_9 - 1;\n    flag_1 = temp_9 == 0;\n    temp_3 = temp_9;\n  }\n  else {\n    temp_3 = (input_4 << 0xc) >> 4 | 0x10000000 | input_3 >> 0x18;\n    temp_14 = input_3 << 8;\n    temp_11 = (temp_9 << 0xc) >> 4 | 0x10000000 | temp_12 >> 0x18;\n    temp_12 = temp_12 * 0x100;\n    temp_7 = (temp_9 ^ input_4) & 0x80000000;\n    flag_1 = temp_3 <= temp_11;\n    if (temp_11 == temp_3) {\n      flag_1 = temp_14 <= temp_12;\n    }\n    temp_8 = temp_8 + (uint)flag_1;\n    temp_9 = temp_8 + 0x3fd;\n    if (flag_1 == false) {\n      temp_3 = temp_3 >> 1;\n      temp_14 = (uint)((input_3 >> 0x18 & 1) != 0) << 0x1f | temp_14 >> 1;\n    }\n    temp_13 = temp_12 - temp_14;\n    temp_11 = (temp_11 - temp_3) - (uint)(temp_12 < temp_14);\n    temp_4 = temp_3 >> 1;\n    temp_1 = (uint)((temp_3 & 1) != 0) << 0x1f | temp_14 >> 1;\n    temp_12 = 0x100000;\n    temp_3 = 0x80000;\n    while( true ) {\n      flag_1 = temp_1 <= temp_13;\n      if (temp_4 < temp_11 || temp_11 - temp_4 < (uint)flag_1) {\n        temp_13 = temp_13 - temp_1;\n        temp_12 = temp_12 | temp_3;\n        temp_11 = (temp_11 - temp_4) - (uint)!flag_1;\n      }\n      temp_5 = temp_4 >> 1;\n      temp_1 = (uint)((temp_4 & 1) != 0) << 0x1f | temp_1 >> 1;\n      flag_2 = temp_1 <= temp_13;\n      flag_1 = temp_11 - temp_5 < (uint)flag_2;\n      temp_14 = temp_11;\n      if (temp_5 < temp_11 || flag_1) {\n        temp_13 = temp_13 - temp_1;\n        temp_14 = (temp_11 - temp_5) - (uint)!flag_2;\n      }\n      if (temp_5 < temp_11 || flag_1) {\n        temp_12 = temp_12 | temp_3 >> 1;\n      }\n      temp_11 = temp_4 >> 2;\n      temp_2 = (uint)((temp_5 & 1) != 0) << 0x1f | temp_1 >> 1;\n      flag_2 = temp_2 <= temp_13;\n      flag_1 = temp_14 - temp_11 < (uint)flag_2;\n      temp_5 = temp_14;\n      if (temp_11 < temp_14 || flag_1) {\n        temp_13 = temp_13 - temp_2;\n        temp_5 = (temp_14 - temp_11) - (uint)!flag_2;\n      }\n      if (temp_11 < temp_14 || flag_1) {\n        temp_12 = temp_12 | temp_3 >> 2;\n      }\n      temp_6 = temp_4 >> 3;\n      temp_1 = (uint)((temp_11 & 1) != 0) << 0x1f | temp_2 >> 1;\n      flag_2 = temp_1 <= temp_13;\n      flag_1 = temp_5 - temp_6 < (uint)flag_2;\n      temp_11 = temp_5;\n      if (temp_6 < temp_5 || flag_1) {\n        temp_13 = temp_13 - temp_1;\n        temp_11 = (temp_5 - temp_6) - (uint)!flag_2;\n      }\n      if (temp_6 < temp_5 || flag_1) {\n        temp_12 = temp_12 | temp_3 >> 3;\n      }\n      temp_14 = temp_11 | temp_13;\n      if (temp_14 == 0) break;\n      temp_11 = temp_11 << 4 | temp_13 >> 0x1c;\n      temp_13 = temp_13 << 4;\n      temp_4 = temp_4 & 0xfffffff8 | temp_1 >> 0x1d;\n      temp_1 = (temp_2 >> 1) << 3;\n      temp_3 = temp_3 >> 4;\n      if (temp_3 == 0) {\n        temp_6 = temp_4;\n        if ((temp_7 & 0x100000) != 0) goto LAB_0800086a;\n        temp_7 = temp_7 | temp_12;\n        temp_12 = 0;\n        temp_3 = 0x80000000;\n      }\n    }\n    if ((temp_7 & 0x100000) == 0) {\n      temp_7 = temp_7 | temp_12;\n      temp_12 = 0;\n    }\nLAB_0800086a:\n    flag_3 = 0xfc < temp_9;\n    flag_2 = SBORROW4(temp_9,0xfd);\n    temp_4 = temp_8 + 0x300;\n    flag_1 = temp_4 == 0;\n    temp_3 = temp_4;\n    if (flag_3 && !flag_1) {\n      flag_3 = 0x6ff < temp_4;\n      flag_2 = SBORROW4(temp_4,0x700);\n      temp_3 = temp_8 - 0x400;\n      flag_1 = temp_4 == 0x700;\n    }\n    if (!flag_3 || flag_1) {\n      flag_1 = temp_6 <= temp_11;\n      if (temp_11 == temp_6) {\n        flag_1 = temp_1 <= temp_13;\n      }\n      if (temp_11 == temp_6 && temp_13 == temp_1) {\n        flag_1 = (temp_12 & 1) != 0;\n      }\n      return CONCAT44(temp_7 + temp_9 * 0x100000 + (uint)CARRY4(temp_12,(uint)flag_1),temp_12 + flag_1);\n    }\n  }\n  if (!flag_1 && (int)temp_3 < 0 == flag_2) {\n    return (ulonglong)(temp_7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag_3 = SCARRY4(temp_9,0x36);\n  flag_1 = (int)(temp_9 + 0x36) < 0;\n  flag_2 = temp_9 == 0xffffffca;\n  if (flag_2 || flag_1 != flag_3) {\n    temp_12 = 0;\n  }\n  if (flag_2 || flag_1 != flag_3) {\n    temp_7 = temp_7 & 0x80000000;\n  }\n  if (flag_2 || flag_1 != flag_3) {\n    return CONCAT44(temp_7,temp_12);\n  }\n  temp_3 = -temp_9;\n  temp_11 = temp_3 - 0x20;\n  if (0x1f < (int)temp_3) {\n    temp_3 = temp_12 >> (temp_11 & 0xff) | temp_7 << (0x20 - temp_11 & 0xff);\n    temp_9 = (temp_7 >> (temp_11 & 0xff) & ~((temp_7 & 0x80000000) >> (temp_11 & 0xff))) -\n            ((int)temp_3 >> 0x1f);\n    if ((temp_14 | temp_12 << (0x20 - temp_11 & 0xff) | temp_3 << 1) == 0) {\n      temp_9 = temp_9 & ~(temp_3 >> 0x1f);\n    }\n    return CONCAT44(temp_7,temp_9) & 0x80000000ffffffff;\n  }\n  temp_8 = temp_3 - 0x14;\n  if (temp_8 != 0 && temp_8 < 0 == SCARRY4(temp_11,0xc)) {\n    temp_9 = 0xc - temp_8;\n    temp_3 = temp_12 << (temp_9 & 0xff);\n    temp_12 = temp_12 >> (0x20 - temp_9 & 0xff) | temp_7 << (temp_9 & 0xff);\n    temp_9 = temp_12 + -((int)temp_3 >> 0x1f);\n    if ((temp_14 | temp_3 << 1) == 0) {\n      temp_9 = temp_9 & ~(temp_3 >> 0x1f);\n    }\n    return CONCAT44((temp_7 & 0x80000000) + (uint)CARRY4(temp_12,-((int)temp_3 >> 0x1f)),temp_9);\n  }\n  temp_11 = temp_12 << (temp_9 + 0x20 & 0xff);\n  temp_12 = temp_12 >> (temp_3 & 0xff) | temp_7 << (temp_9 + 0x20 & 0xff);\n  temp_9 = temp_12 + -((int)temp_11 >> 0x1f);\n  if ((temp_14 | temp_11 << 1) == 0) {\n    temp_9 = temp_9 & ~(temp_11 >> 0x1f);\n  }\n  return CONCAT44((temp_7 & 0x80000000) +\n                  ((temp_7 & 0x7fffffff) >> (temp_3 & 0xff)) +\n                  (uint)CARRY4(temp_12,-((int)temp_11 >> 0x1f)),temp_9);\n}\n\n",
            "renaming": {
                "FUN_0800074c": "calculate_floating_point_0800074c",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "temp_1",
                "uVar2": "temp_2",
                "uVar3": "temp_3",
                "uVar4": "temp_4",
                "uVar5": "temp_5",
                "uVar6": "temp_6",
                "uVar7": "temp_7",
                "iVar8": "temp_8",
                "uVar9": "temp_9",
                "unaff_r5": "temp_10",
                "uVar10": "temp_11",
                "uVar11": "temp_12",
                "uVar12": "temp_13",
                "uVar13": "temp_14",
                "bVar14": "flag_1",
                "bVar15": "flag_2",
                "bVar16": "flag_3",
                "uVar17": "result"
            },
            "calling": [
                "SetTunings",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [
                "FUN_080008ba"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008ba": {
            "entrypoint": "0x080008ba",
            "current_name": "calculate_floating_point_number_080008ba",
            "code": "\nulonglong calculateFloatingPointNumber_080008ba(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint bit1;\n  uint constant1;\n  uint bit2;\n  uint bit3;\n  uint constant2;\n  bool checkResult;\n  \n  bit2 = constant2 & input4 >> 0x14;\n  bit3 = input2;\n  if (constant1 != constant2 || bit2 != constant2) {\n    if (constant1 == constant2) {\n      if (((input1 | input2 << 0xc) == 0) && (input1 = input3, bit3 = input4, bit2 != constant2)\n         ) {\nLAB_0800072c:\n        return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bit2 == constant2) {\n      input1 = input3;\n      bit3 = input4;\n      if ((input3 | input4 << 0xc) == 0) {\nLAB_080006f0:\n        return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      checkResult = (input1 | input2 << 1) == 0;\n      if (!checkResult) {\n        checkResult = (input3 | input4 << 1) == 0;\n      }\n      if (!checkResult) {\n        if (constant1 == 0) {\n          bit3 = input2 & 0x80000000;\n          do {\n            bit1 = input1 & 0x80000000;\n            input1 = input1 << 1;\n            input2 = input2 * 2 + (uint)(bit1 != 0);\n          } while ((input2 & 0x100000) == 0);\n          input2 = input2 | bit3;\n          if (bit2 != 0) {\n            return CONCAT44(input2,input1);\n          }\n        }\n        do {\n          bit3 = input3 & 0x80000000;\n          input3 = input3 << 1;\n          input4 = input4 * 2 + (uint)(bit3 != 0);\n        } while ((input4 & 0x100000) == 0);\n        return CONCAT44(input2,input1);\n      }\n      if ((input1 | input2 << 1) != 0) goto LAB_0800072c;\n      if ((input3 | input4 << 1) != 0) goto LAB_080006f0;\n    }\n  }\n  return CONCAT44(bit3,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080008ba": "calculate_floating_point_number_080008ba",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bit1",
                "unaff_r4": "constant1",
                "uVar2": "bit2",
                "uVar3": "bit3",
                "in_r12": "constant2",
                "bVar4": "checkResult"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800091c": {
            "entrypoint": "0x0800091c",
            "current_name": "check_parameter_equality_0800091c",
            "code": "\nuint check_parameter_equality_0800091c(uint first_param,uint second_param,uint third_param,uint fourth_param)\n\n{\n  uint param_xor_result;\n  bool is_zero;\n  bool is_less_or_equal;\n  \n  if (((int)(second_param << 1) >> 0x15 == -1 || (int)(fourth_param << 1) >> 0x15 == -1) &&\n     ((((int)(second_param << 1) >> 0x15 == -1 && ((first_param | second_param << 0xc) != 0)) ||\n      (((int)(fourth_param << 1) >> 0x15 == -1 && ((third_param | fourth_param << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  is_zero = (first_param | second_param << 1) == 0;\n  if (is_zero) {\n    is_zero = (third_param | fourth_param << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = second_param == fourth_param;\n  }\n  if (is_zero) {\n    is_zero = first_param == third_param;\n  }\n  if (!is_zero) {\n    param_xor_result = second_param ^ fourth_param;\n    is_zero = param_xor_result == 0;\n    if (-1 < (int)param_xor_result) {\n      is_zero = second_param == fourth_param;\n    }\n    is_less_or_equal = -1 < (int)param_xor_result && fourth_param <= second_param;\n    if (is_zero) {\n      is_less_or_equal = third_param <= first_param;\n    }\n    fourth_param = (int)fourth_param >> 0x1f;\n    if (!is_less_or_equal) {\n      fourth_param = ~fourth_param;\n    }\n    return fourth_param | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800091c": "check_parameter_equality_0800091c",
                "param_1": "first_param",
                "param_2": "second_param",
                "param_3": "third_param",
                "param_4": "fourth_param",
                "uVar1": "param_xor_result",
                "bVar2": "is_zero",
                "bVar3": "is_less_or_equal"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000924": {
            "entrypoint": "0x08000924",
            "current_name": "check_equality_08000924",
            "code": "\nuint checkEquality_08000924(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint xorResult;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(input2 << 1) >> 0x15 == -1 || (int)(input4 << 1) >> 0x15 == -1) &&\n     ((((int)(input2 << 1) >> 0x15 == -1 && ((input1 | input2 << 0xc) != 0)) ||\n      (((int)(input4 << 1) >> 0x15 == -1 && ((input3 | input4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (input1 | input2 << 1) == 0;\n  if (isZero) {\n    isZero = (input3 | input4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = input2 == input4;\n  }\n  if (isZero) {\n    isZero = input1 == input3;\n  }\n  if (!isZero) {\n    xorResult = input2 ^ input4;\n    isZero = xorResult == 0;\n    if (-1 < (int)xorResult) {\n      isZero = input2 == input4;\n    }\n    isNegative = -1 < (int)xorResult && input4 <= input2;\n    if (isZero) {\n      isNegative = input3 <= input1;\n    }\n    input4 = (int)input4 >> 0x1f;\n    if (!isNegative) {\n      input4 = ~input4;\n    }\n    return input4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000924": "check_equality_08000924",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "xorResult",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800092c": {
            "entrypoint": "0x0800092c",
            "current_name": "check_parameters_0800092c",
            "code": "\nuint check_parameters_0800092c(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint xor_result;\n  bool is_zero;\n  bool is_negative;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  is_zero = (value1 | value2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (value3 | value4 << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = value2 == value4;\n  }\n  if (is_zero) {\n    is_zero = value1 == value3;\n  }\n  if (!is_zero) {\n    xor_result = value2 ^ value4;\n    is_zero = xor_result == 0;\n    if (-1 < (int)xor_result) {\n      is_zero = value2 == value4;\n    }\n    is_negative = -1 < (int)xor_result && value4 <= value2;\n    if (is_zero) {\n      is_negative = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!is_negative) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800092c": "check_parameters_0800092c",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "xor_result",
                "bVar2": "is_zero",
                "bVar3": "is_negative"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009a8": {
            "entrypoint": "0x080009a8",
            "current_name": "compare_floats_080009a8",
            "code": "\nvoid compareFloats_080009a8(undefined4 result,undefined4 t,undefined4 param_3,undefined4 param_4)\n\n{\n  __aeabi_cdcmpeq(param_3,param_4,result,t);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080009a8": "compare_floats_080009a8",
                "param_1": "result",
                "param_2": "t"
            },
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009b8": {
            "entrypoint": "0x080009b8",
            "current_name": "calculate_080009b8",
            "code": "\nundefined4 calculate_080009b8(undefined4 input_value)\n\n{\n  __eqdf2();\n  return input_value;\n}\n\n",
            "renaming": {
                "FUN_080009b8": "calculate_080009b8",
                "param_1": "input_value"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_cdrcmple",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "called": [
                "__eqdf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c8": {
            "entrypoint": "0x080009c8",
            "current_name": "check_cdcmp_result_080009c8",
            "code": "\nbool check_cdcmp_result_080009c8(void)\n\n{\n  char is_not_zero;\n  \n  compare_floats();\n  return is_not_zero != '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009c8": "check_cdcmp_result_080009c8",
                "in_ZR": "is_not_zero",
                "__aeabi_cdcmpeq": "compare_floats"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009dc": {
            "entrypoint": "0x080009dc",
            "current_name": "check_carry_flag_080009dc",
            "code": "\nbool check_carry_flag_080009dc(void)\n\n{\n  char carry_flag;\n  \n  __aeabi_cdcmpeq();\n  return carry_flag == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009dc": "check_carry_flag_080009dc",
                "in_CY": "carry_flag"
            },
            "calling": [
                "SetOutputLimits",
                "Initialize",
                "loop",
                "SetTunings",
                "Compute",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009f0": {
            "entrypoint": "0x080009f0",
            "current_name": "check_comparison_result_080009f0",
            "code": "\nbool check_comparison_result_080009f0(void)\n\n{\n  undefined zero_result_flag;\n  undefined carry_flag;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)carry_flag || (bool)zero_result_flag;\n}\n\n",
            "renaming": {
                "FUN_080009f0": "check_comparison_result_080009f0",
                "in_ZR": "zero_result_flag",
                "in_CY": "carry_flag"
            },
            "calling": [
                "loop",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a04": {
            "entrypoint": "0x08000a04",
            "current_name": "check_zero_or_negative_08000a04",
            "code": "\nbool check_zero_or_negative_08000a04(void)\n\n{\n  undefined is_zero_flag;\n  undefined is_negative_flag;\n  \n  __aeabi_cdrcmple();\n  return !(bool)is_negative_flag || (bool)is_zero_flag;\n}\n\n",
            "renaming": {
                "FUN_08000a04": "check_zero_or_negative_08000a04",
                "in_ZR": "is_zero_flag",
                "in_CY": "is_negative_flag"
            },
            "calling": [
                "SetOutputLimits",
                "loop"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a18": {
            "entrypoint": "0x08000a18",
            "current_name": "is_null_terminated_08000a18",
            "code": "\nbool is_null_terminated_08000a18(void)\n\n{\n  char input_char;\n  \n  check_less_or_equal();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000a18": "is_null_terminated_08000a18",
                "in_CY": "input_char",
                "__aeabi_cdrcmple": "check_less_or_equal"
            },
            "calling": [
                "SetOutputLimits",
                "Initialize",
                "loop",
                "Compute",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a2c": {
            "entrypoint": "0x08000a2c",
            "current_name": "check_conditions_08000a2c",
            "code": "\nundefined4 check_conditions_08000a2c(uint input_1,int input_2,uint input_3,int input_4)\n\n{\n  if ((((input_2 << 1) >> 0x15 != -1) || ((input_1 | input_2 << 0xc) == 0)) &&\n     (((input_4 << 1) >> 0x15 != -1 || ((input_3 | input_4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000a2c": "check_conditions_08000a2c",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a58": {
            "entrypoint": "0x08000a58",
            "current_name": "scale_and_clamp_08000a58",
            "code": "\nuint scale_and_clamp_08000a58(uint scaled_value,uint scale_factor)\n\n{\n  uint result;\n  int scaled_offset;\n  uint mask;\n  \n  scaled_offset = scale_factor * 2 + 0x200000;\n  if (scale_factor * 2 < 0xffe00000) {\n    if (-1 < scaled_offset) {\n      return 0;\n    }\n    result = scaled_offset >> 0x15;\n    mask = -result - 0x3e1;\n    if (result < 0xfffffc20 && mask != 0) {\n      result = (scale_factor << 0xb | 0x80000000 | scaled_value >> 0x15) >> (mask & 0xff);\n      if ((scale_factor & 0x80000000) != 0) {\n        result = -result;\n      }\n      return result;\n    }\n  }\n  else if ((scaled_value | scale_factor << 0xc) != 0) {\n    return 0;\n  }\n  scale_factor = scale_factor & 0x80000000;\n  if (scale_factor == 0) {\n    scale_factor = 0x7fffffff;\n  }\n  return scale_factor;\n}\n\n",
            "renaming": {
                "FUN_08000a58": "scale_and_clamp_08000a58",
                "param_1": "scaled_value",
                "param_2": "scale_factor",
                "uVar1": "result",
                "iVar2": "scaled_offset",
                "uVar3": "mask"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "validate_input_08000aa8",
            "code": "\nuint validate_input_08000aa8(uint input_1,uint input_2)\n\n{\n  int result;\n  uint shift_amount;\n  \n  if ((input_2 & 0x80000000) != 0) {\n    return 0;\n  }\n  result = input_2 * 2 + 0x200000;\n  if (input_2 * 2 < 0xffe00000) {\n    if (-1 < result) {\n      return 0;\n    }\n    shift_amount = -(result >> 0x15) - 0x3e1;\n    if (-1 < (int)shift_amount) {\n      return (input_2 << 0xb | 0x80000000 | input_1 >> 0x15) >> (shift_amount & 0xff);\n    }\n  }\n  else if ((input_1 | input_2 << 0xc) != 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "validate_input_08000aa8",
                "param_1": "input_1",
                "param_2": "input_2",
                "iVar1": "result",
                "uVar2": "shift_amount"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ae8": {
            "entrypoint": "0x08000ae8",
            "current_name": "execute_system_interrupt_08000ae8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_system_interrupt_08000ae8(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08000ae8": "execute_system_interrupt_08000ae8"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aec": {
            "entrypoint": "0x08000aec",
            "current_name": "execute_afl_call_08000aec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint executeAflCall_08000aec(int inputTicks)\n\n{\n  uint32_t aflReturnValue;\n  \n  if (noHyperCall != 0) {\n    return 0;\n  }\n  aflReturnValue = aflCall(1,inputTicks,0);\n  return aflReturnValue;\n}\n\n",
            "renaming": {
                "FUN_08000aec": "execute_afl_call_08000aec",
                "ticks": "inputTicks",
                "uVar1": "aflReturnValue"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b08": {
            "entrypoint": "0x08000b08",
            "current_name": "initialize_components_08000b08",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeComponents_08000b08(int isInitializing,int priority)\n\n{\n  if ((isInitializing == 1) && (priority == 0xffff)) {\n    PID::PID(&ovenPID,&inputTemp,&outputTemp,&desiredTemp,(double)concat44(kp_4_4,kp_0_4),\n             (double)concat44(ki_4_4,ki_0_4),(double)concat44(kd_4_4,kd_0_4),0);\n    lcdInit::lcdInit\n              (&lcdObj,(uint8_t)lcdRs,(uint8_t)lcdE,(uint8_t)lcdD4,(uint8_t)lcdD5,\n               (uint8_t)lcdD6,(uint8_t)lcdD7);\n    thermocoupleInit::thermocoupleInit(&thermocoupleObj,(uchar)thermoSOPin,(uchar)thermoCSPin,\n                       (uchar)thermoCLKPin);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000b08": "initialize_components_08000b08",
                "__initialize_p": "isInitializing",
                "__priority": "priority",
                "reflowOvenPID": "ovenPID",
                "input": "inputTemp",
                "output": "outputTemp",
                "setpoint": "desiredTemp",
                "CONCAT44": "concat44",
                "kp._4_4_": "kp_4_4",
                "kp._0_4_": "kp_0_4",
                "ki._4_4_": "ki_4_4",
                "ki._0_4_": "ki_0_4",
                "kd._4_4_": "kd_4_4",
                "kd._0_4_": "kd_0_4",
                "LiquidCrystal": "lcdInit",
                "lcd": "lcdObj",
                "lcdRsPin": "lcdRs",
                "lcdEPin": "lcdE",
                "lcdD4Pin": "lcdD4",
                "lcdD5Pin": "lcdD5",
                "lcdD6Pin": "lcdD6",
                "lcdD7Pin": "lcdD7",
                "MAX31855": "thermocoupleInit",
                "thermocouple": "thermocoupleObj",
                "thermocoupleSOPin": "thermoSOPin",
                "thermocoupleCSPin": "thermoCSPin",
                "thermocoupleCLKPin": "thermoCLKPin"
            },
            "calling": [
                "_GLOBAL__sub_I_lcdMessagesReflowStatus"
            ],
            "called": [
                "MAX31855",
                "LiquidCrystal",
                "PID"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000bcc": {
            "entrypoint": "0x08000bcc",
            "current_name": "initialize_oven_08000bcc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeOven_08000bcc(void)\n\n{\n  digitalWrite(ovenRelayPin,0);\n  pinMode(ovenRelayPin,1);\n  digitalWrite(buzzerPin,0);\n  pinMode(buzzerPin,1);\n  digitalWrite(statusLedPin,0);\n  pinMode(statusLedPin,1);\n  digitalWrite(buzzerPin,1);\n  LiquidCrystal::begin(&liquidCrystalDisplay,'\\b','\\x02','\\0');\n  LiquidCrystal::createChar(&liquidCrystalDisplay,'\\0',degreeSymbol);\n  LiquidCrystal::clear(&liquidCrystalDisplay);\n  Print::print(&liquidCrystalDisplay.super_Print,\"Reflow\");\n  LiquidCrystal::setCursor(&liquidCrystalDisplay,'\\0','\\x01');\n  Print::print(&liquidCrystalDisplay.super_Print,\"Oven 1.2\");\n  digitalWrite(buzzerPin,0);\n  delay(0x9c4);\n  LiquidCrystal::clear(&liquidCrystalDisplay);\n  HardwareSerial::begin(&Serial2,0xe100,'\\x06');\n  digitalWrite(statusLedPin,1);\n  windowSize = 2000;\n  nextCheckTime = millis();\n  nextReadTime = millis();\n  startForkServer(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000bcc": "initialize_oven_08000bcc",
                "ssrPin": "ovenRelayPin",
                "ledRedPin": "statusLedPin",
                "lcd": "liquidCrystalDisplay",
                "degree": "degreeSymbol",
                "nextCheck": "nextCheckTime",
                "nextRead": "nextReadTime",
                "startForkserver": "startForkServer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "begin",
                "digitalWrite",
                "startForkserver",
                "delay",
                "setCursor",
                "print",
                "begin",
                "millis",
                "createChar",
                "pinMode",
                "clear"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cbc": {
            "entrypoint": "0x08000cbc",
            "current_name": "initialize_static_variables_08000cbc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_variables_08000cbc(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000cbc": "initialize_static_variables_08000cbc"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cd0": {
            "entrypoint": "0x08000cd0",
            "current_name": "reflow_controller_08000cd0",
            "code": "\n/* WARNING: UnkcurrentMillisn calling convention */\n\nvoid reflowController_08000cd0(void)\n\n{\n  double dVar1;\n  uint32_t currentTime;\n  MAX31855 *thermocouplePtr;\n  int redLedState;\n  ulong currentMillis;\n  int comparisonResult;\n  size_t extraReturnValue;\n  int digits1;\n  int digits2;\n  int digits3;\n  size_t stringLength;\n  undefined4 tempValue1;\n  undefined4 tempValue2;\n  undefined8 elapsedTime;\n  undefined4 tempVar1;\n  undefined4 tempVar2;\n  undefined4 tempVar3;\n  \n  currentTime = millis();\n  if (nextRead < currentTime) {\n    nextRead = nextRead + 1000;\n    thermocouplePtr = &thermocouple;\n    MAX31855::readThermocouple(&thermocouple,CELSIUS);\n    input._0_4_ = thermocouplePtr;\n    input._4_4_ = extraReturnValue;\n    comparisonResult = __aeabi_dcmpeq();\n    if (((comparisonResult != 0) || (comparisonResult = __aeabi_dcmpeq(thermocouplePtr,extraReturnValue,0,0x40c38880), comparisonResult != 0)) ||\n       (comparisonResult = __aeabi_dcmpeq(thermocouplePtr,extraReturnValue,0,0x40c38900), comparisonResult != 0)) {\n      reflowState = REFLOW_STATE_ERROR;\n      reflowStatus = REFLOW_STATUS_OFF;\n    }\n  }\n  currentTime = millis();\n  comparisonResult = ledRedPin;\n  if (nextCheck < currentTime) {\n    nextCheck = nextCheck + 1000;\n    if (reflowStatus == REFLOW_STATUS_ON) {\n      redLedState = digitalRead(ledRedPin);\n      digitalWrite(comparisonResult,(uint)(redLedState == 0));\n      timerSeconds = timerSeconds + 1;\n      Print::print((Print *)&Serial2,timerSeconds,10);\n      Print::print((Print *)&Serial2,\" \");\n      Print::print((Print *)&Serial2,(double)CONCAT44(tempVar1,2),digits1);\n      Print::print((Print *)&Serial2,\" \");\n      Print::print((Print *)&Serial2,(double)CONCAT44(tempVar1,2),digits2);\n      Print::print((Print *)&Serial2,\" \");\n      Print::println((Print *)&Serial2,(double)CONCAT44(tempVar1,2),digits3);\n    }\n    else {\n      digitalWrite(ledRedPin,1);\n    }\n    LiquidCrystal::clear(&lcd);\n    Print::print(&lcd.super_Print,lcdMessagesReflowStatus[reflowState]);\n    LiquidCrystal::setCursor(&lcd,'\\0','\\x01');\n    if (reflowState == REFLOW_STATE_ERROR) {\n      Print::print(&lcd.super_Print,\"TC Error!\");\n    }\n    else {\n      thermocouplePtr = input._0_4_;\n      stringLength = input._4_4_;\n      Print::print(&lcd.super_Print,(double)CONCAT44(tempVar1,2),2);\n      LiquidCrystal::write(&lcd,0,thermocouplePtr,stringLength);\n      Print::print(&lcd.super_Print,\"C \");\n    }\n  }\n  stringLength = input._4_4_;\n  thermocouplePtr = input._0_4_;\n  setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n  switch(reflowState) {\n  case REFLOW_STATE_IDLE:\n    comparisonResult = __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x40490000);\n    if (comparisonResult == 0) {\n      if (switchStatus == SWITCH_1) {\n        Print::println((Print *)&Serial2,\"Time Setpoint Input Output\");\n        timerSeconds = 0;\n        windowStartTime = millis();\n        setpoint._0_4_ = 0;\n        setpoint._4_4_ = 0x4062c000;\n        dVar1 = (double)__floatsidf(windowSize);\n        PID::SetOutputLimits\n                  (&reflowOvenPID,dVar1,(double)CONCAT44(tempVar3,tempVar2));\n        PID::SetSampleTime(&reflowOvenPID,1000);\n        PID::SetMode(&reflowOvenPID,1);\n        reflowState = REFLOW_STATE_PREHEAT;\n      }\n    }\n    else {\n      reflowState = REFLOW_STATE_TOO_HOT;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_PREHEAT:\n    reflowStatus = REFLOW_STATUS_ON;\n    comparisonResult = __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x4062c000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      currentTime = millis();\n      timerSoak = currentTime + 9000;\n      PID::SetTunings(&reflowOvenPID,0.05,250.0,(double)CONCAT44(tempValue2,tempValue1));\n      reflowState = REFLOW_STATE_SOAK;\n      setpoint = 155.0;\n    }\n    break;\n  case REFLOW_STATE_SOAK:\n    currentTime = millis();\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (timerSoak < currentTime) {\n      currentTime = millis();\n      timerSoak = currentTime + 9000;\n      setpoint = (double)__aeabi_dadd(setpoint._0_4_,setpoint._4_4_,0,0x40140000);\n      comparisonResult = __aeabi_dcmpgt(SUB84(setpoint,0),(int)((ulonglong)setpoint >> 0x20),0,0x40690000);\n      if (comparisonResult != 0) {\n        PID::SetTunings(&reflowOvenPID,0.05,350.0,(double)CONCAT44(tempValue2,tempValue1));\n        reflowState = REFLOW_STATE_REFLOW;\n        setpoint = 250.0;\n      }\n    }\n    break;\n  case REFLOW_STATE_REFLOW:\n    comparisonResult = __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x406ea000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      PID::SetTunings(&reflowOvenPID,0.05,350.0,(double)CONCAT44(tempValue2,tempValue1));\n      reflowState = REFLOW_STATE_COOL;\n      setpoint = 100.0;\n    }\n    break;\n  case REFLOW_STATE_COOL:\n    comparisonResult = __aeabi_dcmple(input._0_4_,input._4_4_,0,0x40590000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      currentTime = millis();\n      buzzerPeriod = currentTime + 1000;\n      digitalWrite(buzzerPin,1);\n      reflowStatus = REFLOW_STATUS_OFF;\n      reflowState = REFLOW_STATE_COMPLETE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_COMPLETE:\n    currentTime = millis();\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (buzzerPeriod < currentTime) {\n      digitalWrite(buzzerPin,0);\n      reflowState = REFLOW_STATE_IDLE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_TOO_HOT:\n    comparisonResult = __aeabi_dcmplt(input._0_4_,input._4_4_,0,0x40490000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      reflowState = REFLOW_STATE_IDLE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_ERROR:\n    comparisonResult = __aeabi_dcmpeq(input._0_4_,input._4_4_,0,0x40c38800);\n    if ((comparisonResult == 0) && (comparisonResult = __aeabi_dcmpeq(thermocouplePtr,stringLength,0,0x40c38880), comparisonResult == 0)) {\n      comparisonResult = __aeabi_dcmpeq(thermocouplePtr,stringLength,0,0x40c38900);\n      if (comparisonResult == 0) {\n        reflowState = REFLOW_STATE_IDLE;\n        setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n        break;\n      }\n    }\n    reflowState = REFLOW_STATE_ERROR;\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n  }\n  if ((switchStatus == SWITCH_1) && (reflowStatus == REFLOW_STATUS_ON)) {\n    reflowStatus = REFLOW_STATUS_OFF;\n    reflowState = REFLOW_STATE_IDLE;\n  }\n  if (debounceState == DEBOUNCE_STATE_CHECK) {\n    currentTime = analogRead(switchPin);\n    if (currentTime == 0) {\n      currentTime = millis();\n      if (0x32 < currentTime - lastDebounceTime) {\n        debounceState = DEBOUNCE_STATE_RELEASE;\n      }\n    }\n    else {\n      debounceState = DEBOUNCE_STATE_IDLE;\n    }\n  }\n  else if (debounceState == DEBOUNCE_STATE_IDLE) {\n    switchStatus = SWITCH_NONE;\n    currentTime = analogRead(switchPin);\n    if (currentTime == 0) {\n      lastDebounceTime = millis();\n      debounceState = DEBOUNCE_STATE_CHECK;\n    }\n  }\n  else if (debounceState == DEBOUNCE_STATE_RELEASE) {\n    currentTime = analogRead(switchPin);\n    if (currentTime != 0) {\n      switchStatus = SWITCH_1;\n      debounceState = DEBOUNCE_STATE_IDLE;\n    }\n  }\n  if (reflowStatus == REFLOW_STATUS_ON) {\n    currentTime = millis();\n    PID::Compute(&reflowOvenPID);\n    if ((uint)windowSize < currentTime - windowStartTime) {\n      windowStartTime = windowStartTime + windowSize;\n    }\n    elapsedTime = __floatunsidf(currentTime - windowStartTime);\n    comparisonResult = __aeabi_dcmplt((int)elapsedTime,(int)((ulonglong)elapsedTime >> 0x20),output._0_4_,output._4_4_);\n    if (comparisonResult == 0) {\n      digitalWrite(ssrPin,0);\n      dVar1 = setpoint;\n    }\n    else {\n      digitalWrite(ssrPin,1);\n      dVar1 = setpoint;\n    }\n  }\n  else {\n    digitalWrite(ssrPin,0);\n    dVar1 = setpoint;\n  }\n  setpoint._4_4_ = (undefined4)((ulonglong)dVar1 >> 0x20);\n  setpoint._0_4_ = SUB84(dVar1,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000cd0": "reflow_controller_08000cd0",
                "uVar2": "currentTime",
                "pMVar3": "thermocouplePtr",
                "iVar4": "redLedState",
                "now": "currentMillis",
                "iVar5": "comparisonResult",
                "extraout_r1": "extraReturnValue",
                "digits": "digits1",
                "digits_00": "digits2",
                "digits_01": "digits3",
                "sVar6": "stringLength",
                "unaff_r4": "tempValue1",
                "unaff_r5": "tempValue2",
                "uVar7": "elapsedTime",
                "in_stack_ffffffe4": "tempVar1",
                "in_stack_ffffffe8": "tempVar2",
                "in_stack_ffffffec": "tempVar3"
            },
            "calling": [
                "main"
            ],
            "called": [
                "SetOutputLimits",
                "write",
                "print",
                "setCursor",
                "analogRead",
                "millis",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "print",
                "__aeabi_dcmpeq",
                "println",
                "digitalRead",
                "__aeabi_dcmpge",
                "clear",
                "__aeabi_dcmple",
                "readThermocouple",
                "digitalWrite",
                "__floatsidf",
                "print",
                "Compute",
                "SetTunings",
                "SetSampleTime",
                "SetMode",
                "__floatunsidf",
                "__aeabi_dcmplt",
                "println"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001294": {
            "entrypoint": "0x08001294",
            "current_name": "set_row_offsets_08001294",
            "code": "\n/* DWARF original prototype: void  setRowOffsets_08001294(LiquidCrystal * lcd, int offset0, int offset1, int offset2,\n   int offset3) */\n\nvoid __lcdcall LiquidCrystal::setRowOffsets_08001294(LiquidCrystal *lcd,int offset0,int offset1,int offset2,int offset3)\n\n{\n  lcd->rowOffset0 = (uint8_t)offset0;\n  lcd->rowOffset1 = (uint8_t)offset1;\n  lcd->rowOffset2 = (uint8_t)offset2;\n  lcd->rowOffset3 = (uint8_t)offset3;\n  return;\n}\n\n",
            "renaming": {
                "this": "lcd",
                "row0": "offset0",
                "row1": "offset1",
                "row2": "offset2",
                "row3": "offset3",
                "_row_offsets[0]": "rowOffset0",
                "_row_offsets[1]": "rowOffset1",
                "_row_offsets[2]": "rowOffset2",
                "_row_offsets[3]": "rowOffset3",
                "FUN_08001294": "set_row_offsets_08001294"
            },
            "calling": [
                "begin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012a2": {
            "entrypoint": "0x080012a2",
            "current_name": "pulse_enable_080012a2",
            "code": "\n/* DWARF original prototype: void  pulseEnable_080012a2(LiquidCrystal * lcd) */\n\nvoid __lcdcall LiquidCrystal::pulseEnable_080012a2(LiquidCrystal *lcd)\n\n{\n  digitalWrite((uint)lcd->pin,0);\n  digitalWrite((uint)lcd->pin,1);\n  digitalWrite((uint)lcd->pin,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080012a2": "pulse_enable_080012a2",
                "this": "lcd",
                "_enable_pin": "pin"
            },
            "calling": [
                "write4bits",
                "write8bits"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012c0": {
            "entrypoint": "0x080012c0",
            "current_name": "write4bits_080012c0",
            "code": "\n/* DWARF original prototype: void  write4bits_080012c0(LiquidCrystal * lcd, uint8_t bits) */\n\nvoid __lcdcall LiquidCrystal::write4bits_080012c0(LiquidCrystal *lcd,uint8_t bits)\n\n{\n  uint bitIndex;\n  \n  for (bitIndex = 0; (int)bitIndex < 4; bitIndex = bitIndex + 1) {\n    digitalWrite((uint)lcd->_data_pins[bitIndex],(int)(uint)bits >> (bitIndex & 0xff) & 1);\n  }\n  pulseEnable(lcd);\n  return;\n}\n\n",
            "renaming": {
                "this": "lcd",
                "value": "bits",
                "uVar1": "bitIndex",
                "FUN_080012c0": "write4bits_080012c0"
            },
            "calling": [
                "send",
                "begin"
            ],
            "called": [
                "digitalWrite",
                "pulseEnable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012e8": {
            "entrypoint": "0x080012e8",
            "current_name": "write8bits_080012e8",
            "code": "\n/* DWARF original prototype: void  write8bits_080012e8(LiquidCrystal * lcd, uint8_t data) */\n\nvoid __lcdcall LiquidCrystal::write8bits_080012e8(LiquidCrystal *lcd,uint8_t data)\n\n{\n  uint bitIndex;\n  \n  for (bitIndex = 0; (int)bitIndex < 8; bitIndex = bitIndex + 1) {\n    digitalWrite((uint)lcd->_data_pins[bitIndex],(int)(uint)data >> (bitIndex & 0xff) & 1);\n  }\n  pulseEnable(lcd);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080012e8": "write8bits_080012e8",
                "this": "lcd",
                "value": "data",
                "uVar1": "bitIndex"
            },
            "calling": [
                "send"
            ],
            "called": [
                "digitalWrite",
                "pulseEnable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001310": {
            "entrypoint": "0x08001310",
            "current_name": "send_lcd_data_08001310",
            "code": "\n/* DWARF original prototype: void  send(LiquidCrystal * lcd, uint8_t value, uint8_t mode) */\n\nssize_t __lcdcall\nLiquidCrystal::sendLCDData_08001310(LiquidCrystal *lcd,int value,void *mode,size_t length,int flags)\n\n{\n  digitalWrite((uint)lcd->_rs_pin,(uint32_t)mode);\n  if (lcd->_rw_pin != 0xff) {\n    digitalWrite((uint)lcd->_rw_pin,0);\n  }\n  if ((lcd->_displayfunction & 0x10) == 0) {\n    write4bits(lcd,(uint8_t)((uint)value >> 4));\n    write4bits(lcd,(uint8_t)value);\n    return (ssize_t)lcd;\n  }\n  write8bits(lcd,(uint8_t)value);\n  return (ssize_t)lcd;\n}\n\n",
            "renaming": {
                "FUN_08001310": "send_lcd_data_08001310",
                "this": "lcd",
                "__fd": "value",
                "__buf": "mode",
                "__n": "length",
                "__flags": "flags"
            },
            "calling": [
                "write",
                "setCursor",
                "begin",
                "display",
                "createChar",
                "clear"
            ],
            "called": [
                "digitalWrite",
                "write4bits",
                "write8bits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800134e": {
            "entrypoint": "0x0800134e",
            "current_name": "write_lcd_data_0800134e",
            "code": "\n/* DWARF original prototype: size_t  write(LiquidCrystal * this, uint8_t value) */\n\nssize_t liquid_crystal_instance LiquidCrystal::write_lcd_data_0800134e(LiquidCrystal *this,int file_descriptor,void *buffer,size_t data_length)\n\n{\n  send_data(this,file_descriptor,(void *)0x1,data_length,data_length);\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800134e": "write_lcd_data_0800134e",
                "__thiscall": "liquid_crystal_instance",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "data_length",
                "send": "send_data"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800135a": {
            "entrypoint": "0x0800135a",
            "current_name": "clear_lcd_screen_0800135a",
            "code": "\n/* DWARF original prototype: void  clear(LCD * this) */\n\nvoid __thiscall LCD::clear_lcd_screen_0800135a(LCD *this)\n\n{\n  size_t data_size;\n  \n  send(this,1,(void *)0x0,data_size,data_size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800135a": "clear_lcd_screen_0800135a",
                "LiquidCrystal": "LCD",
                "in_r3": "data_size"
            },
            "calling": [
                "setup",
                "begin",
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001366": {
            "entrypoint": "0x08001366",
            "current_name": "update_cursor_position_08001366",
            "code": "\n/* DWARF original prototype: void  setCursor(LiquidCrystal * lcdInstance, uint8_t column, uint8_t row) */\n\nvoid __lcdInstancecall LiquidCrystal::updateCursorPosition_08001366(LiquidCrystal *lcdInstance,uint8_t column,uint8_t row)\n\n{\n  uint clampedRow;\n  int unknownValue;\n  \n  clampedRow = (uint)row;\n  if (3 < clampedRow) {\n    clampedRow = 3;\n  }\n  if (lcdInstance->_numlines <= clampedRow) {\n    clampedRow = lcdInstance->_numlines - 1 & 0xff;\n  }\n  send(lcdInstance,(uint)(byte)(column + lcdInstance->_row_offsets[clampedRow] | 0x80),(void *)0x0,\n       (uint)lcdInstance->_row_offsets[clampedRow],unknownValue);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001366": "update_cursor_position_08001366",
                "this": "lcdInstance",
                "col": "column",
                "uVar1": "clampedRow",
                "in_r3": "unknownValue"
            },
            "calling": [
                "setup",
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800138e": {
            "entrypoint": "0x0800138e",
            "current_name": "update_display_control_0800138e",
            "code": "\n/* DWARF original prototype: void  display(LiquidCrystal * lcd) */\n\nvoid __lcdcall LiquidCrystal::updateDisplayControl_0800138e(LiquidCrystal *lcd)\n\n{\n  byte displayControl;\n  size_t size;\n  \n  displayControl = lcd->previousDisplayControl;\n  lcd->previousDisplayControl = displayControl | 4;\n  sendMessage(lcd,displayControl | 0xc,(void *)0x0,size,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800138e": "update_display_control_0800138e",
                "this": "lcd",
                "bVar1": "displayControl",
                "in_r3": "size",
                "_displaycontrol": "previousDisplayControl",
                "send": "sendMessage"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080013a4": {
            "entrypoint": "0x080013a4",
            "current_name": "initialize_lcd_080013a4",
            "code": "\n/* DWARF original prototype: void  begin(LiquidCrystal * this, uint8_t numColumns, uint8_t numLines, uint8_t\n   dotSize) */\n\nvoid __thiscall\nLiquidCrystal::initializeLCD_080013a4(LiquidCrystal *this,uint8_t numColumns,uint8_t numLines,uint8_t dotSize)\n\n{\n  int rowOffset;\n  size_t bitMode;\n  int counter;\n  \n  if (1 < numLines) {\n    this->displayFunction = this->displayFunction | 8;\n  }\n  this->displayNumLines = numLines;\n  rowOffset = numColumns + 0x40;\n  setRowOffsets(this,0,0x40,(uint)numColumns,rowOffset);\n  if ((dotSize != '\\0') && (numLines == '\\x01')) {\n    this->displayFunction = this->displayFunction | 4;\n  }\n  pinMode((uint)this->rsPin,1);\n  if (this->rwPin != 0xff) {\n    pinMode((uint)this->rwPin,1);\n  }\n  pinMode((uint)this->enablePin,1);\n  counter = 0;\n  while( true ) {\n    if ((this->displayFunction & 0x10) == 0) {\n      bitMode = 4;\n    }\n    else {\n      bitMode = 8;\n    }\n    if ((int)bitMode <= counter) break;\n    pinMode((uint)this->dataPins[counter],1);\n    counter = counter + 1;\n  }\n  digitalWrite((uint)this->rsPin,0);\n  digitalWrite((uint)this->enablePin,0);\n  if (this->rwPin != 0xff) {\n    digitalWrite((uint)this->rwPin,0);\n  }\n  if ((this->displayFunction & 0x10) == 0) {\n    write4bits(this,'\\x03');\n    write4bits(this,'\\x03');\n    write4bits(this,'\\x03');\n    write4bits(this,'\\x02');\n  }\n  else {\n    send(this,this->displayFunction | 0x20,(void *)0x0,bitMode,rowOffset);\n    send(this,this->displayFunction | 0x20,(void *)0x0,bitMode,rowOffset);\n    send(this,this->displayFunction | 0x20,(void *)0x0,bitMode,rowOffset);\n  }\n  send(this,this->displayFunction | 0x20,(void *)0x0,bitMode,rowOffset);\n  this->displayControl = '\\x04';\n  display(this);\n  clear(this);\n  this->displayMode = '\\x02';\n  send(this,6,(void *)0x0,2,rowOffset);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080013a4": "initialize_lcd_080013a4",
                "cols": "numColumns",
                "lines": "numLines",
                "dotsize": "dotSize",
                "row3": "rowOffset",
                "__n": "bitMode",
                "iVar1": "counter",
                "_displayfunction": "displayFunction",
                "_numlines": "displayNumLines",
                "_rs_pin": "rsPin",
                "_rw_pin": "rwPin",
                "_enable_pin": "enablePin",
                "_data_pins": "dataPins",
                "_displaycontrol": "displayControl",
                "_displaymode": "displayMode"
            },
            "calling": [
                "setup",
                "init"
            ],
            "called": [
                "digitalWrite",
                "send",
                "display",
                "pinMode",
                "clear",
                "setRowOffsets",
                "write4bits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ba": {
            "entrypoint": "0x080014ba",
            "current_name": "initialize_lcd_080014ba",
            "code": "\n/* DWARF original prototype: void  init(LiquidCrystal * lcd, uint8_t fourbitmode, uint8_t rs,\n   uint8_t rw, uint8_t enable, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3, uint8_t d4, uint8_t\n   d5, uint8_t d6, uint8_t d7) */\n\nint __lcdcall LiquidCrystal::initializeLCD_080014ba(LiquidCrystal *lcd,context *ctx)\n\n{\n  uint8_t rsPin;\n  uint8_t rwPin;\n  uint8_t enablePin;\n  uint8_t dataPin0;\n  uint8_t dataPin1;\n  uint8_t dataPin2;\n  uint8_t dataPin3;\n  uint8_t dataPin4;\n  uint8_t dataPin5;\n  uint8_t dataPin6;\n  uint8_t dataPin7;\n  \n  lcd->_rs_pin = rsPin;\n  lcd->_rw_pin = rwPin;\n  lcd->_enable_pin = enablePin;\n  lcd->_data_pins[0] = dataPin0;\n  lcd->_data_pins[1] = dataPin1;\n  lcd->_data_pins[2] = dataPin2;\n  lcd->_data_pins[3] = dataPin3;\n  lcd->_data_pins[4] = dataPin4;\n  lcd->_data_pins[5] = dataPin5;\n  lcd->_data_pins[6] = dataPin6;\n  lcd->_data_pins[7] = dataPin7;\n  if (ctx == (context *)0x0) {\n    lcd->_displayfunction = '\\x10';\n  }\n  else {\n    lcd->_displayfunction = '\\0';\n  }\n  begin(lcd,'\\x10','\\x01','\\0');\n  return (int)lcd;\n}\n\n",
            "renaming": {
                "FUN_080014ba": "initialize_lcd_080014ba",
                "this": "lcd",
                "in_r2": "rsPin",
                "in_r3": "rwPin",
                "in_stack_00000000": "enablePin",
                "in_stack_00000004": "dataPin0",
                "in_stack_00000008": "dataPin1",
                "in_stack_0000000c": "dataPin2",
                "in_stack_00000010": "dataPin3",
                "in_stack_00000014": "dataPin4",
                "in_stack_00000018": "dataPin5",
                "in_stack_0000001c": "dataPin6",
                "in_stack_00000020": "dataPin7",
                "EVP_PKEY_CTX": "context"
            },
            "calling": [
                "LiquidCrystal"
            ],
            "called": [
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001510": {
            "entrypoint": "0x08001510",
            "current_name": "initialize_lcd_08001510",
            "code": "\n/* DWARF original prototype: LiquidCrystal *  LiquidCrystal(LiquidCrystal * this, uint8_t RS_pin,\n   uint8_t enable_pin, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3) */\n\nLiquidCrystal * __thiscall\nLiquidCrystal::initializeLCD_08001510(LiquidCrystal *this,uint8_t RS_pin,uint8_t enable_pin,uint8_t d0,uint8_t d1,uint8_t d2,uint8_t d3\n          )\n\n{\n  (this->super_Print).error_flag = 0;\n  (this->super_Print).print_vtable = (_func_int_varargs **)&PTR_write_1_080073f8;\n  initialize(this,(context *)0x1);\n  return this;\n}\n\n",
            "renaming": {
                "rs": "RS_pin",
                "enable": "enable_pin",
                "write_error": "error_flag",
                "_vptr_Print": "print_vtable",
                "init": "initialize",
                "EVP_PKEY_CTX": "context",
                "FUN_08001510": "initialize_lcd_08001510"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001550": {
            "entrypoint": "0x08001550",
            "current_name": "create_char_08001550",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example charLocation: r0 : 0x08001574 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  createChar_08001550(LiquidCrystal * lcd, uint8_t charLocation, uint8_t *\n   charMap) */\n\nvoid __lcdcall LiquidCrystal::createChar_08001550(LiquidCrystal *lcd,uint8_t charLocation,uint8_t *charMap)\n\n{\n  size_t size;\n  int index;\n  int iVar1;\n  \n  transmitData(lcd,(charLocation & 7) << 3 | 0x40,(void *)0x0,size,index);\n  for (iVar1 = 0; iVar1 < 8; iVar1 = iVar1 + 1) {\n    (**(lcd->superPrint).virtualPrint)(lcd,(uint)charMap[iVar1]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001550": "create_char_08001550",
                "this": "lcd",
                "location": "charLocation",
                "charmap": "charMap",
                "in_r3": "size",
                "unaff_r4": "index",
                "send": "transmitData",
                "super_Print": "superPrint",
                "_vptr_Print": "virtualPrint"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "initialize_max31855_0800157c",
            "code": "\n/* DWARF original prototype: MAX31855 *  MAX31855(MAX31855 * this, uchar dataPin, uchar chipSelectPin, uchar clockPin) */\n\nMAX31855 * __thiscall MAX31855::initializeMAX31855_0800157c(MAX31855 *this,uchar dataPin,uchar chipSelectPin,uchar clockPin)\n\n{\n  this->so = dataPin;\n  this->cs = chipSelectPin;\n  this->sck = clockPin;\n  pinMode((uint)dataPin,0);\n  pinMode((uint)this->cs,1);\n  pinMode((uint)this->sck,1);\n  digitalWrite((uint)this->cs,1);\n  digitalWrite((uint)this->sck,0);\n  return this;\n}\n\n",
            "renaming": {
                "SO": "dataPin",
                "CS": "chipSelectPin",
                "SCK": "clockPin",
                "FUN_0800157c": "initialize_max31855_0800157c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "digitalWrite",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b2": {
            "entrypoint": "0x080015b2",
            "current_name": "read_data_080015b2",
            "code": "\n/* DWARF original prototype: ulong  readData_080015b2(MAX31855 * instance) */\n\nulong __instancecall MAX31855::readData_080015b2(MAX31855 *instance)\n\n{\n  int digitalReadValue;\n  uint loopCounter;\n  uint data;\n  \n  digitalWrite((uint)instance->chipSelectPin,0);\n  data = 0;\n  for (loopCounter = 0x1f; -1 < (int)loopCounter; loopCounter = loopCounter - 1) {\n    digitalWrite((uint)instance->clockPin,1);\n    digitalReadValue = digitalRead((uint)instance->dataOutPin);\n    if (digitalReadValue != 0) {\n      data = data | 1 << (loopCounter & 0xff);\n    }\n    digitalWrite((uint)instance->clockPin,0);\n  }\n  digitalWrite((uint)instance->chipSelectPin,1);\n  return data;\n}\n\n",
            "renaming": {
                "this": "instance",
                "iVar1": "digitalReadValue",
                "uVar2": "loopCounter",
                "uVar3": "data",
                "cs": "chipSelectPin",
                "sck": "clockPin",
                "so": "dataOutPin",
                "FUN_080015b2": "read_data_080015b2"
            },
            "calling": [
                "readThermocouple"
            ],
            "called": [
                "digitalWrite",
                "digitalRead"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015f8": {
            "entrypoint": "0x080015f8",
            "current_name": "calculate_temperature_080015f8",
            "code": "\n/* DWARF original prototype: double  readThermocouple(MAX31855 * thermocouple, temperatureUnit_t temperatureUnit) */\n\ndouble __thermocouplecall MAX31855::calculateTemperature_080015f8(MAX31855 *thermocouple,temperatureUnit_t temperatureUnit)\n\n{\n  ulong data;\n  ulong data;\n  uint shiftedData;\n  double result;\n  double temp;\n  double finalResult;\n  undefined8 convertedValue;\n  \n  data = readData(thermocouple);\n  if ((data & 0x10000) == 0) {\n    shiftedData = data >> 0x12;\n    convertedValue = __floatunsidf(shiftedData & 0x1fff);\n    if ((shiftedData & 0x2000) != 0) {\n      convertedValue = __floatunsidf(~shiftedData & 0x1fff);\n      convertedValue = __aeabi_dadd((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x3ff00000);\n      convertedValue = CONCAT44((int)((ulonglong)convertedValue >> 0x20) + -0x80000000,(int)convertedValue);\n    }\n    convertedValue = __muldf3((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x3fd00000);\n    finalResult = temp;\n    if (temperatureUnit == FAHRENHEIT) {\n      convertedValue = __muldf3((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x40220000);\n      convertedValue = __divdf3((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x40140000);\n      finalResult = (double)__aeabi_dadd((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x40400000);\n      return finalResult;\n    }\n  }\n  else {\n    shiftedData = data & 7;\n    if (shiftedData == 2) {\n      return result;\n    }\n    if (shiftedData == 4) {\n      return result;\n    }\n    finalResult = result;\n    if (shiftedData != 1) {\n      return result;\n    }\n  }\n  return finalResult;\n}\n\n",
            "renaming": {
                "this": "thermocouple",
                "unit": "temperatureUnit",
                "uVar1": "data",
                "uVar2": "shiftedData",
                "extraout_d0": "result",
                "extraout_d0_00": "temp",
                "dVar3": "finalResult",
                "uVar4": "convertedValue",
                "FUN_080015f8": "calculate_temperature_080015f8"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__floatunsidf",
                "__divdf3",
                "readData"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016b4": {
            "entrypoint": "0x080016b4",
            "current_name": "calculate_pid_080016b4",
            "code": "\n/* DWARF original prototype: bool  Compute(PID * pidInstance) */\n\nbool __pidInstancecall PID::calculatePID_080016b4(PID *pidInstance)\n\n{\n  bool isAutoMode;\n  uint32_t currentTime;\n  ulong currentTime;\n  int comparisonResult;\n  undefined4 tempVar4;\n  undefined4 input1;\n  undefined4 outputSum1;\n  undefined4 outputMin;\n  ulong timeDifference;\n  undefined4 input2;\n  undefined4 outputSum2;\n  undefined4 outputMax;\n  char isAutoMode;\n  undefined4 tempVar12;\n  undefined4 tempVar13;\n  undefined4 tempVar14;\n  undefined8 tempVar15;\n  undefined8 inputDiff;\n  undefined8 proportionalTerm;\n  double tempDouble1;\n  double tempDouble2;\n  double pidOutput;\n  \n  isAutoMode = pidInstance->inAuto;\n  if ((bool)isAutoMode != false) {\n    currentTime = millis();\n    if (currentTime - pidInstance->lastTime < pidInstance->SampleTime) {\n      isAutoMode = '\\0';\n    }\n    else {\n      input1 = *(undefined4 *)pidInstance->myInput;\n      input2 = *(undefined4 *)((int)pidInstance->myInput + 4);\n      tempVar15 = __subdf3(*(undefined4 *)pidInstance->mySetpoint,*(undefined4 *)((int)pidInstance->mySetpoint + 4));\n      tempVar14 = (undefined4)((ulonglong)tempVar15 >> 0x20);\n      inputDiff = __subdf3(input1,input2,*(undefined4 *)&pidInstance->lastInput,\n                        *(undefined4 *)((int)&pidInstance->lastInput + 4));\n      tempVar4 = (undefined4)((ulonglong)inputDiff >> 0x20);\n      proportionalTerm = __muldf3((int)tempVar15,tempVar14,*(undefined4 *)&pidInstance->ki,\n                        *(undefined4 *)((int)&pidInstance->ki + 4));\n      tempDouble1 = (double)__aeabi_dadd((int)proportionalTerm,(int)((ulonglong)proportionalTerm >> 0x20),\n                                    *(undefined4 *)&pidInstance->pidOutputSum,\n                                    *(undefined4 *)((int)&pidInstance->pidOutputSum + 4));\n      pidInstance->pidOutputSum = tempDouble1;\n      isAutoMode = pidInstance->pOnE;\n      if (isAutoMode == false) {\n        proportionalTerm = __muldf3((int)inputDiff,tempVar4,*(undefined4 *)&pidInstance->kp,\n                          *(undefined4 *)((int)&pidInstance->kp + 4));\n        tempDouble1 = (double)__subdf3(SUB84(tempDouble1,0),(int)((ulonglong)tempDouble1 >> 0x20),(int)proportionalTerm,\n                                  (int)((ulonglong)proportionalTerm >> 0x20));\n        pidInstance->pidOutputSum = tempDouble1;\n      }\n      outputSum1 = *(undefined4 *)&pidInstance->pidOutputSum;\n      outputSum2 = *(undefined4 *)((int)&pidInstance->pidOutputSum + 4);\n      tempVar12 = *(undefined4 *)&pidInstance->outMax;\n      tempVar13 = *(undefined4 *)((int)&pidInstance->outMax + 4);\n      tempDouble1 = pidInstance->outMax;\n      comparisonResult = __aeabi_dcmpgt(outputSum1,outputSum2,tempVar12,tempVar13);\n      if (comparisonResult == 0) {\n        outputMin = *(undefined4 *)&pidInstance->outMin;\n        outputMax = *(undefined4 *)((int)&pidInstance->outMin + 4);\n        comparisonResult = __aeabi_dcmplt(outputSum1,outputSum2);\n        if (comparisonResult != 0) {\n          *(undefined4 *)&pidInstance->pidOutputSum = outputMin;\n          *(undefined4 *)((int)&pidInstance->pidOutputSum + 4) = outputMax;\n        }\n      }\n      else {\n        *(undefined4 *)&pidInstance->pidOutputSum = tempVar12;\n        *(undefined4 *)((int)&pidInstance->pidOutputSum + 4) = tempVar13;\n      }\n      if (isAutoMode == false) {\n        tempVar15 = 0;\n      }\n      else {\n        tempVar15 = __muldf3((int)tempVar15,tempVar14,*(undefined4 *)&pidInstance->kp,\n                          *(undefined4 *)((int)&pidInstance->kp + 4));\n      }\n      pidOutput._4_4_ = (undefined4)((ulonglong)tempVar15 >> 0x20);\n      pidOutput._0_4_ = (undefined4)tempVar15;\n      tempVar14 = *(undefined4 *)&pidInstance->pidOutputSum;\n      outputSum1 = *(undefined4 *)((int)&pidInstance->pidOutputSum + 4);\n      tempVar15 = __muldf3((int)inputDiff,tempVar4,*(undefined4 *)&pidInstance->kd,\n                        *(undefined4 *)((int)&pidInstance->kd + 4));\n      tempVar15 = __subdf3(tempVar14,outputSum1,(int)tempVar15,(int)((ulonglong)tempVar15 >> 0x20));\n      tempDouble2 = (double)__aeabi_dadd(pidOutput._0_4_,pidOutput._4_4_,(int)tempVar15,\n                                    (int)((ulonglong)tempVar15 >> 0x20));\n      tempVar14 = (undefined4)((ulonglong)tempDouble2 >> 0x20);\n      comparisonResult = __aeabi_dcmplt(tempVar12,tempVar13,SUB84(tempDouble2,0),tempVar14);\n      if (comparisonResult == 0) {\n        tempDouble1 = pidInstance->outMin;\n        comparisonResult = __aeabi_dcmplt(SUB84(tempDouble2,0),tempVar14,*(undefined4 *)&pidInstance->outMin,\n                               *(undefined4 *)((int)&pidInstance->outMin + 4));\n        if (comparisonResult == 0) {\n          tempDouble1 = tempDouble2;\n        }\n      }\n      *pidInstance->myOutput = tempDouble1;\n      *(undefined4 *)&pidInstance->lastInput = input1;\n      *(undefined4 *)((int)&pidInstance->lastInput + 4) = input2;\n      pidInstance->lastTime = currentTime;\n    }\n  }\n  return (bool)isAutoMode;\n}\n\n",
            "renaming": {
                "FUN_080016b4": "calculate_pid_080016b4",
                "this": "pidInstance",
                "bVar1": "isAutoMode",
                "uVar2": "currentTime",
                "now": "currentTime",
                "iVar3": "comparisonResult",
                "uVar4": "tempVar4",
                "uVar5": "input1",
                "uVar6": "outputSum1",
                "uVar7": "outputMin",
                "uVar8": "input2",
                "uVar9": "outputSum2",
                "uVar10": "outputMax",
                "uVar12": "tempVar12",
                "uVar13": "tempVar13",
                "uVar14": "tempVar14",
                "uVar15": "tempVar15",
                "uVar16": "inputDiff",
                "uVar17": "proportionalTerm",
                "cVar11": "isAutoMode",
                "timeChange": "timeDifference",
                "output": "pidOutput",
                "dVar18": "tempDouble1",
                "dVar19": "tempDouble2"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__subdf3",
                "__aeabi_dadd",
                "millis",
                "__aeabi_dcmpgt",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001814": {
            "entrypoint": "0x08001814",
            "current_name": "configure_pid_controller_08001814",
            "code": "\n/* DWARF original prototype: void  SetTunings(PID * pidController, double proportionalGain, double integralGain, double derivativeGain, int controllerDirectionFlag)\n    */\n\nvoid __pidControllercall PID::configurePIDController_08001814(PID *pidController,double proportionalGain,double integralGain,double derivativeGain,int controllerDirectionFlag)\n\n{\n  int comparisonResult;\n  undefined4 tempVar1;\n  undefined4 tempVar2;\n  undefined4 tempVar3;\n  undefined tempVar4;\n  bool flag;\n  undefined8 sampleTime;\n  double tempVar5;\n  double tempVar6;\n  double tempVar7;\n  \n  comparisonResult = __aeabi_dcmplt();\n  if (((comparisonResult == 0) && (comparisonResult = __aeabi_dcmplt(proportionalGain._0_4_,proportionalGain._4_4_,0,0), comparisonResult == 0)) &&\n     (comparisonResult = __aeabi_dcmplt(integralGain._0_4_,integralGain._4_4_,0,0), comparisonResult == 0)) {\n    pidController->pOn = derivativeGain._0_4_;\n    flag = derivativeGain._0_4_ != 1;\n    if (flag) {\n      derivativeGain._0_4_ = 0;\n    }\n    tempVar4 = (undefined)derivativeGain._0_4_;\n    if (!flag) {\n      tempVar4 = true;\n    }\n    pidController->pOnE = (bool)tempVar4;\n    *(undefined4 *)&pidController->dispproportionalGain = tempVar2;\n    *(undefined4 *)((int)&pidController->dispproportionalGain + 4) = tempVar3;\n    pidController->dispintegralGain = proportionalGain;\n    pidController->dispderivativeGain = integralGain;\n    sampleTime = __floatunsidf(pidController->SampleTime);\n    sampleTime = __divdf3((int)sampleTime,(int)((ulonglong)sampleTime >> 0x20),0,0x408f4000);\n    tempVar1 = (undefined4)((ulonglong)sampleTime >> 0x20);\n    *(undefined4 *)&pidController->kp = tempVar2;\n    *(undefined4 *)((int)&pidController->kp + 4) = tempVar3;\n    tempVar5 = (double)__muldf3(proportionalGain._0_4_,proportionalGain._4_4_,(int)sampleTime,tempVar1);\n    pidController->ki = tempVar5;\n    tempVar6 = (double)__divdf3(integralGain._0_4_,integralGain._4_4_,(int)sampleTime,tempVar1);\n    pidController->kd = tempVar6;\n    if (pidController->controllerDirection == 1) {\n      tempVar7 = (double)__subdf3(0,0);\n      pidController->kp = tempVar7;\n      tempVar5 = (double)__subdf3(0,0,SUB84(tempVar5,0),(int)((ulonglong)tempVar5 >> 0x20));\n      pidController->ki = tempVar5;\n      tempVar5 = (double)__subdf3(0,0,SUB84(tempVar6,0),(int)((ulonglong)tempVar6 >> 0x20));\n      pidController->kd = tempVar5;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001814": "configure_pid_controller_08001814",
                "this": "pidController",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "POn": "controllerDirectionFlag",
                "iVar1": "comparisonResult",
                "uVar2": "tempVar1",
                "in_r2": "tempVar2",
                "in_r3": "tempVar3",
                "uVar3": "tempVar4",
                "bVar4": "flag",
                "uVar5": "sampleTime",
                "dVar6": "tempVar5",
                "dVar7": "tempVar6",
                "dVar8": "tempVar7"
            },
            "calling": [
                "PID",
                "SetTunings"
            ],
            "called": [
                "__muldf3",
                "__subdf3",
                "__floatunsidf",
                "__divdf3",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080018f8": {
            "entrypoint": "0x080018f8",
            "current_name": "set_pid_tunings_080018f8",
            "code": "\n/* DWARF original prototype: void  setTunings(PID * pidInstance, double proportionalGain, double integralGain, double derivativeGain) */\n\nvoid __pidInstancecall PID::setPIDTunings_080018f8(PID *pidInstance,double proportionalGain,double integralGain,double derivativeGain)\n\n{\n  undefined4 pOnHigh;\n  \n  setTunings(pidInstance,proportionalGain,integralGain,(double)concatenateValues(pOnHigh,pidInstance->pOn),pidInstance->pOn);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080018f8": "set_pid_tunings_080018f8",
                "this": "pidInstance",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "in_stack_ffffffec": "pOnHigh",
                "SetTunings": "setTunings",
                "CONCAT44": "concatenateValues"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "SetTunings"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001918": {
            "entrypoint": "0x08001918",
            "current_name": "set_sample_time_08001918",
            "code": "\n/* DWARF original prototype: void  SetSampleTime(PID * pid, int newSampleTime) */\n\nvoid __pidcall PID::setSampleTime_08001918(PID *pid,int newSampleTime)\n\n{\n  undefined4 quotientHigh;\n  undefined8 divisionResult;\n  undefined8 sampleTimeFloat;\n  double tempDouble;\n  \n  if (0 < newSampleTime) {\n    divisionResult = __floatsidf(newSampleTime);\n    sampleTimeFloat = __floatunsidf(pid->SampleTime);\n    divisionResult = __divdf3((int)divisionResult,(int)((ulonglong)divisionResult >> 0x20),(int)sampleTimeFloat,\n                     (int)((ulonglong)sampleTimeFloat >> 0x20));\n    quotientHigh = (undefined4)((ulonglong)divisionResult >> 0x20);\n    tempDouble = (double)__muldf3((int)divisionResult,quotientHigh,*(undefined4 *)&pid->integralGain,\n                             *(undefined4 *)((int)&pid->integralGain + 4));\n    pid->integralGain = tempDouble;\n    tempDouble = (double)__divdf3(*(undefined4 *)&pid->derivativeGain,*(undefined4 *)((int)&pid->derivativeGain + 4),(int)divisionResult\n                             ,quotientHigh);\n    pid->derivativeGain = tempDouble;\n    pid->SampleTime = newSampleTime;\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "pid",
                "NewSampleTime": "newSampleTime",
                "uVar1": "quotientHigh",
                "uVar2": "divisionResult",
                "uVar3": "sampleTimeFloat",
                "dVar4": "tempDouble",
                "ki": "integralGain",
                "kd": "derivativeGain",
                "FUN_08001918": "set_sample_time_08001918"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__floatsidf",
                "__floatunsidf",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001960": {
            "entrypoint": "0x08001960",
            "current_name": "set_output_limits_08001960",
            "code": "\n/* DWARF original prototype: void  SetOutputLimits(PID * pid, double outputMin, double outputMax) */\n\nvoid __pidcall PID::setOutputLimits_08001960(PID *pid,double outputMin,double outputMax)\n\n{\n  int comparisonResult;\n  undefined4 temp1;\n  undefined4 temp2;\n  double *myOutputPtr;\n  undefined4 outputSum1;\n  undefined4 outputSum2;\n  undefined4 outMax1;\n  undefined4 outMax2;\n  \n  comparisonResult = __aeabi_dcmpge();\n  if (comparisonResult == 0) {\n    *(undefined4 *)&pid->outoutputMin = temp1;\n    *(undefined4 *)((int)&pid->outoutputMin + 4) = temp2;\n    pid->outoutputMax = outputMin;\n    if (pid->inAuto != false) {\n      myOutputPtr = pid->myOutput;\n      comparisonResult = __aeabi_dcmplt(outputMin._0_4_,outputMin._4_4_,*(undefined4 *)myOutputPtr,\n                             *(undefined4 *)((int)myOutputPtr + 4));\n      if (comparisonResult == 0) {\n        comparisonResult = __aeabi_dcmpgt();\n        if (comparisonResult != 0) {\n          *(undefined4 *)myOutputPtr = temp1;\n          *(undefined4 *)((int)myOutputPtr + 4) = temp2;\n        }\n      }\n      else {\n        *myOutputPtr = outputMin;\n      }\n      outputSum1 = *(undefined4 *)&pid->outputSum;\n      outputSum2 = *(undefined4 *)((int)&pid->outputSum + 4);\n      outMax1 = *(undefined4 *)&pid->outoutputMax;\n      outMax2 = *(undefined4 *)((int)&pid->outoutputMax + 4);\n      comparisonResult = __aeabi_dcmpgt(outputSum1,outputSum2,outMax1,outMax2);\n      if (comparisonResult != 0) {\n        *(undefined4 *)&pid->outputSum = outMax1;\n        *(undefined4 *)((int)&pid->outputSum + 4) = outMax2;\n        return;\n      }\n      outMax1 = *(undefined4 *)&pid->outoutputMin;\n      outMax2 = *(undefined4 *)((int)&pid->outoutputMin + 4);\n      comparisonResult = __aeabi_dcmplt(outputSum1,outputSum2,outMax1,outMax2);\n      if (comparisonResult != 0) {\n        *(undefined4 *)&pid->outputSum = outMax1;\n        *(undefined4 *)((int)&pid->outputSum + 4) = outMax2;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001960": "set_output_limits_08001960",
                "this": "pid",
                "Min": "outputMin",
                "Max": "outputMax",
                "iVar1": "comparisonResult",
                "in_r2": "temp1",
                "in_r3": "temp2",
                "pdVar2": "myOutputPtr",
                "uVar3": "outputSum1",
                "uVar4": "outputSum2",
                "uVar5": "outMax1",
                "uVar6": "outMax2"
            },
            "calling": [
                "PID",
                "loop"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080019f6": {
            "entrypoint": "0x080019f6",
            "current_name": "initialize_pid_080019f6",
            "code": "\n/* DWARF original prototype: void  Initialize(PID * pidInstance) */\n\nvoid __pidInstancecall PID::initializePID_080019f6(PID *pidInstance)\n\n{\n  int comparisonResult;\n  undefined4 myInputPtr1;\n  undefined4 myOutputPtr1;\n  undefined4 myOutputPtr2;\n  undefined4 outMaxPtr2;\n  \n  myOutputPtr1 = *(undefined4 *)pidInstance->myOutput;\n  myOutputPtr2 = *(undefined4 *)((int)pidInstance->myOutput + 4);\n  *(undefined4 *)&pidInstance->outputSumValue = myOutputPtr1;\n  *(undefined4 *)((int)&pidInstance->outputSumValue + 4) = myOutputPtr2;\n  myInputPtr1 = *(undefined4 *)((int)pidInstance->myInput + 4);\n  *(undefined4 *)&pidInstance->lastInputValue = *(undefined4 *)pidInstance->myInput;\n  *(undefined4 *)((int)&pidInstance->lastInputValue + 4) = myInputPtr1;\n  myInputPtr1 = *(undefined4 *)&pidInstance->outMax;\n  outMaxPtr2 = *(undefined4 *)((int)&pidInstance->outMax + 4);\n  comparisonResult = compareGreater(myOutputPtr1,myOutputPtr2,myInputPtr1,outMaxPtr2);\n  if (comparisonResult == 0) {\n    myInputPtr1 = *(undefined4 *)&pidInstance->outMinValue;\n    outMaxPtr2 = *(undefined4 *)((int)&pidInstance->outMinValue + 4);\n    comparisonResult = compareLess(myOutputPtr1,myOutputPtr2,myInputPtr1,outMaxPtr2);\n    if (comparisonResult != 0) {\n      *(undefined4 *)&pidInstance->outputSumValue = myInputPtr1;\n      *(undefined4 *)((int)&pidInstance->outputSumValue + 4) = outMaxPtr2;\n    }\n    return;\n  }\n  *(undefined4 *)&pidInstance->outputSumValue = myInputPtr1;\n  *(undefined4 *)((int)&pidInstance->outputSumValue + 4) = outMaxPtr2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080019f6": "initialize_pid_080019f6",
                "this": "pidInstance",
                "uVar2": "myInputPtr1",
                "uVar3": "myOutputPtr1",
                "uVar4": "myOutputPtr2",
                "uVar5": "outMaxPtr2",
                "iVar1": "comparisonResult",
                "__aeabi_dcmpgt": "compareGreater",
                "__aeabi_dcmplt": "compareLess",
                "outMin": "outMinValue",
                "outputSum": "outputSumValue",
                "lastInput": "lastInputValue"
            },
            "calling": [
                "SetMode"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a44": {
            "entrypoint": "0x08001a44",
            "current_name": "set_mode_08001a44",
            "code": "\n/* DWARF original prototype: void  Setmode(PID * pid, int mode) */\n\nvoid __pidcall PID::set_mode_08001a44(PID *pid,int mode)\n\n{\n  bool is_auto;\n  bool in_auto;\n  \n  if (mode == 1) {\n    in_auto = true;\n    if (pid->inAuto == false) {\n      Initialize(pid);\n    }\n  }\n  else {\n    in_auto = false;\n  }\n  pid->inAuto = in_auto;\n  return;\n}\n\n",
            "renaming": {
                "this": "pid",
                "Mode": "mode",
                "newAuto": "is_auto",
                "bVar1": "in_auto",
                "FUN_08001a44": "set_mode_08001a44"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "Initialize"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a66": {
            "entrypoint": "0x08001a66",
            "current_name": "set_controller_direction_08001a66",
            "code": "\n/* DWARF original prototype: void  SetControllernewDirection(PID * pid, int newDirection) */\n\nvoid __pidcall PID::setControllerDirection_08001a66(PID *pid,int newDirection)\n\n{\n  double tempValue;\n  \n  if ((pid->inAuto != false) && (pid->controllernewDirection != newDirection)) {\n    tempValue = (double)__subdf3(0,0,*(undefined4 *)&pid->kp,*(undefined4 *)((int)&pid->kp + 4));\n    pid->kp = tempValue;\n    tempValue = (double)__subdf3(0,0,*(undefined4 *)&pid->ki,*(undefined4 *)((int)&pid->ki + 4));\n    pid->ki = tempValue;\n    tempValue = (double)__subdf3(0,0,*(undefined4 *)&pid->kd,*(undefined4 *)((int)&pid->kd + 4));\n    pid->kd = tempValue;\n  }\n  pid->controllernewDirection = newDirection;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a66": "set_controller_direction_08001a66",
                "this": "pid",
                "Direction": "newDirection",
                "dVar1": "tempValue"
            },
            "calling": [
                "PID"
            ],
            "called": [
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "initialize_pid_08001ab0",
            "code": "\n/* DWARF original prototype: PID *  PID(PID * pidController, double * input, double * output, double *\n   setpoint, double proportionalGain, double integralGain, double derivativeGain, int pOn, int controllerDirection) */\n\nPID * __pidControllercall\nPID::initializePID_08001ab0(PID *pidController,double *input,double *output,double *setpoint,double proportionalGain,double integralGain,\n                 double derivativeGain,int pOn,int controllerDirection)\n\n{\n  uint32_t currentTime;\n  int integralOn;\n  undefined4 stackVar1;\n  undefined4 stackVar2;\n  undefined4 stackVar3;\n  \n  pidController->myoutput = output;\n  pidController->myinput = input;\n  pidController->mysetpoint = setpoint;\n  pidController->inAuto = false;\n  SetoutputLimits(pidController,255.0,(double)CONCAT44(stackVar2,stackVar1));\n  pidController->SampleTime = 100;\n  SetcontrollerDirection(pidController,controllerDirection);\n  SetTunings(pidController,integralGain,derivativeGain,(double)CONCAT44(stackVar3,pOn),integralOn);\n  currentTime = millis();\n  pidController->lastTime = currentTime - pidController->SampleTime;\n  return pidController;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "initialize_pid_08001ab0",
                "this": "pidController",
                "Input": "input",
                "Output": "output",
                "Setpoint": "setpoint",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "POn": "pOn",
                "ControllerDirection": "controllerDirection",
                "uVar1": "currentTime",
                "POn_00": "integralOn",
                "in_stack_ffffffe8": "stackVar1",
                "in_stack_ffffffec": "stackVar2",
                "in_stack_fffffff4": "stackVar3"
            },
            "calling": [
                "PID"
            ],
            "called": [
                "SetOutputLimits",
                "millis",
                "SetTunings",
                "SetControllerDirection"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b18": {
            "entrypoint": "0x08001b18",
            "current_name": "initialize_pid_controller_08001b18",
            "code": "\n/* DWARF original prototype: PID *  PID(PID * pidController, double * inputValue, double * outputValue, double *\n   setpointValue, double proportionalGain, double integralGain, double derivativeGain, int controllerDirection) */\n\nPID * __pidControllercall\nPID::initializePIDController_08001b18(PID *pidController,double *inputValue,double *outputValue,double *setpointValue,double proportionalGain,double integralGain,\n                 double derivativeGain,int controllerDirection)\n\n{\n  PID(pidController,inputValue,outputValue,setpointValue,proportionalGain,integralGain,derivativeGain,1,controllerDirection);\n  return pidController;\n}\n\n",
            "renaming": {
                "this": "pidController",
                "Input": "inputValue",
                "Output": "outputValue",
                "Setpoint": "setpointValue",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "ControllerDirection": "controllerDirection",
                "FUN_08001b18": "initialize_pid_controller_08001b18"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "PID"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b48": {
            "entrypoint": "0x08001b48",
            "current_name": "initialize_clocks_08001b48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClocks_08001b48(void)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t hclkFreq;\n  PeriphClkInit PeriphClkInit;\n  ClkInitStruct RCC_ClkInitStruct;\n  OscInitStruct oscInitStruct;\n  \n  oscInitStruct.OscillatorType = 2;\n  oscInitStruct.HSIState = 1;\n  oscInitStruct.HSICalibrationValue = 0x10;\n  oscInitStruct.PLL.PLLState = 2;\n  oscInitStruct.PLL.PLLSource = 0;\n  oscInitStruct.PLL.PLLMUL = 0x380000;\n  status = HAL_RCC_OscConfig((OscInitStruct_conflict *)&oscInitStruct);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x88);\n  }\n  RCC_ClkInitStruct.ClockType = 0xf;\n  RCC_ClkInitStruct.SYSCLKSource = 2;\n  RCC_ClkInitStruct.AHBCLKDivider = 0;\n  RCC_ClkInitStruct.APB1CLKDivider = 0x400;\n  RCC_ClkInitStruct.APB2CLKDivider = 0;\n  status = HAL_RCC_ClockConfig((ClkInitStruct_conflict *)&RCC_ClkInitStruct,2);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x95);\n  }\n  PeriphClkInit.PeriphClockSelection = 2;\n  PeriphClkInit.AdcClockSelection = 0x8000;\n  status = HAL_RCCEx_PeriphCLKConfig((PeriphClkInit_conflict *)&PeriphClkInit);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x9c);\n  }\n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001b48": "initialize_clocks_08001b48",
                "HVar1": "status",
                "uVar2": "hclkFreq",
                "RCC_PeriphCLKInitTypeDef": "PeriphClkInit",
                "RCC_ClkInitTypeDef": "ClkInitStruct",
                "RCC_OscInitTypeDef": "OscInitStruct",
                "RCC_OscInitStruct": "oscInitStruct"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_ClockConfig",
                "HAL_SYSTICK_Config",
                "_Error_Handler",
                "HAL_RCC_OscConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001be8": {
            "entrypoint": "0x08001be8",
            "current_name": "initialize_binary_08001be8",
            "code": "\nvoid initializeBinary_08001be8(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jumpTable;\n  \n  for (index = 0; (undefined *)(index + 0x20000000) < &_edata; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (ptr = &completed_8667; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x8001c1a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08001c1a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001be8": "initialize_binary_08001be8",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c30": {
            "entrypoint": "0x08001c30",
            "current_name": "stay_in_infinite_loop_08001c30",
            "code": "\nvoid stay_in_infinite_loop_08001c30(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001c30": "stay_in_infinite_loop_08001c30"
            },
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c32": {
            "entrypoint": "0x08001c32",
            "current_name": "initialize_context_08001c32",
            "code": "\nint initializeContext_08001c32(EVP_PKEY_CTX *context)\n\n{\n  hw_config_init();\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_08001c32": "initialize_context_08001c32",
                "ctx": "context"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c3a": {
            "entrypoint": "0x08001c3a",
            "current_name": "FUNC_08001c3a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001c3a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001c3a": "FUNC_08001c3a"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001c3c": {
            "entrypoint": "0x08001c3c",
            "current_name": "configure_sys_tick_08001c3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureSysTick_08001c3c(uint32_t priority)\n\n{\n  uint32_t status;\n  \n  status = configureSysTick_08001c3cTimer((uint32_t)((ulonglong)coreClock / (1000 / (ulonglong)tickFrequency))\n                            );\n  if (status != 0) {\n    return errorStatus;\n  }\n  if (0xf < priority) {\n    return errorStatus;\n  }\n  setSysTickIRQPriority(systickIRQNumber,priority,0);\n  tickPriority = priority;\n  return successStatus;\n}\n\n",
            "renaming": {
                "FUN_08001c3c": "configure_sys_tick_08001c3c",
                "TickPriority": "priority",
                "uVar1": "status",
                "uwTickFreq": "tickFrequency",
                "SysTick_IRQn": "systickIRQNumber",
                "uwTickPrio": "tickPriority",
                "HAL_SYSTICK_Config": "configureSysTickTimer",
                "HAL_NVIC_SetPriority": "setSysTickIRQPriority",
                "HAL_ERROR": "errorStatus",
                "HAL_OK": "successStatus",
                "SystemCoreClock": "coreClock"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c88": {
            "entrypoint": "0x08001c88",
            "current_name": "initialize_hal_08001c88",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_Status initialize_HAL_08001c88(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  set_NVIC_priority_grouping(3);\n  initialize_tick(0xf);\n  initialize_peripherals();\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001c88": "initialize_hal_08001c88",
                "HAL_StatusTypeDef_conflict": "HAL_Status",
                "HAL_NVIC_SetPriorityGrouping": "set_NVIC_priority_grouping",
                "HAL_InitTick": "initialize_tick",
                "HAL_MspInit": "initialize_peripherals"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cac": {
            "entrypoint": "0x08001cac",
            "current_name": "update_tick_value_08001cac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTickValue_08001cac(void)\n\n{\n  currentTickValue = previousTickValue + currentTickValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cac": "update_tick_value_08001cac",
                "uwTickFreq": "previousTickValue",
                "uwTick": "currentTickValue"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cc4": {
            "entrypoint": "0x08001cc4",
            "current_name": "get_system_tick_08001cc4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTick_08001cc4(void)\n\n{\n  return systemTick;\n}\n\n",
            "renaming": {
                "FUN_08001cc4": "get_system_tick_08001cc4",
                "uwTick": "systemTick"
            },
            "calling": [
                "HAL_RCCEx_PeriphCLKConfig",
                "ADC_ConversionStop_Disable",
                "HAL_ADC_PollForConversion",
                "GetCurrentMilli",
                "HAL_RCC_ClockConfig",
                "HAL_ADCEx_Calibration_Start",
                "UART_WaitOnFlagUntilTimeout",
                "HAL_UART_Transmit",
                "ADC_Enable",
                "HAL_RCC_OscConfig",
                "uart_debug_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cd0": {
            "entrypoint": "0x08001cd0",
            "current_name": "perform_adc_conversion_08001cd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict perform_ADC_conversion_08001cd0(ADC_HandleTypeDef *adc_handle,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t start_time;\n  uint32_t periph_clk_freq;\n  int sample_time;\n  uint32_t sys_clk_freq;\n  ADC_TypeDef *adc_instance;\n  uint cpu_cycles;\n  uint32_t timeout_cycles;\n  \n  timeout_cycles = 0;\n  start_time = HAL_GetTick();\n  sys_clk_freq = SystemCoreClock;\n  adc_instance = adc_handle->Instance;\n  if ((adc_instance->CR2 & 0x100) == 0) {\n    if (((adc_instance->CR1 & 0x100) == 0) && ((adc_instance->SQR1 & 0xf00000) == 0)) {\n      do {\n        if ((adc_handle->Instance->SR & 2) != 0) goto LAB_08001de2;\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (sys_clk_freq = HAL_GetTick(), sys_clk_freq - start_time <= timeout))));\n      adc_handle->State = adc_handle->State | 4;\n      adc_handle->Lock = HAL_UNLOCKED;\n      status = HAL_TIMEOUT;\n    }\n    else {\n      periph_clk_freq = HAL_RCCEx_GetPeriphCLKFreq(2);\n      adc_instance = adc_handle->Instance;\n      if (((adc_instance->SMPR2 & 0x24924924) == 0) && ((adc_instance->SMPR1 & 0x924924) == 0)) {\n        if ((adc_instance->SMPR2 & 0x12492492) == 0) {\n          if ((adc_instance->SMPR1 & 0x492492) == 0) {\n            sample_time = 0x14;\n          }\n          else {\n            sample_time = 0x29;\n          }\n        }\n        else {\n          sample_time = 0x29;\n        }\n      }\n      else if (((adc_instance->SMPR2 & 0x12492492) == 0) && ((adc_instance->SMPR1 & 0x492492) == 0)) {\n        sample_time = 0x54;\n      }\n      else if ((adc_instance->SMPR2 & 0x249249) == 0) {\n        if ((adc_instance->SMPR1 & 0x249249) == 0) {\n          sample_time = 0x54;\n        }\n        else {\n          sample_time = 0xfc;\n        }\n      }\n      else {\n        sample_time = 0xfc;\n      }\n      cpu_cycles = (sys_clk_freq / periph_clk_freq) * sample_time;\n      for (; timeout_cycles <= cpu_cycles && cpu_cycles - timeout_cycles != 0;\n          timeout_cycles = timeout_cycles + 1) {\n        if ((timeout != 0xffffffff) &&\n           ((timeout == 0 || (sys_clk_freq = HAL_GetTick(), timeout < sys_clk_freq - start_time)))) {\n          adc_handle->State = adc_handle->State | 4;\n          adc_handle->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nLAB_08001de2:\n      adc_handle->Instance->SR = 0xffffffed;\n      adc_handle->State = adc_handle->State | 0x200;\n      if ((adc_handle->Instance->CR2 & 0xe0000) == 0xe0000) {\n        if ((adc_handle->Init).ContinuousConvMode == 0) {\n          adc_handle->State = adc_handle->State & 0xfffffeff;\n          if ((adc_handle->State & 0x1000) == 0) {\n            adc_handle->State = adc_handle->State | 1;\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        status = HAL_OK;\n      }\n    }\n  }\n  else {\n    adc_handle->State = adc_handle->State | 0x20;\n    adc_handle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001cd0": "perform_adc_conversion_08001cd0",
                "hadc": "adc_handle",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "periph_clk_freq",
                "iVar4": "sample_time",
                "uVar5": "sys_clk_freq",
                "pAVar6": "adc_instance",
                "uVar7": "cpu_cycles",
                "Conversion_Timeout_CPU_cycles": "timeout_cycles"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e40": {
            "entrypoint": "0x08001e40",
            "current_name": "get_adc_data_08001e40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_ADC_data_08001e40(ADC_HandleTypeDef *adc_handle)\n\n{\n  return adc_handle->Instance->DR;\n}\n\n",
            "renaming": {
                "FUN_08001e40": "get_adc_data_08001e40",
                "hadc": "adc_handle"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e48": {
            "entrypoint": "0x08001e48",
            "current_name": "configure_adc_channel_08001e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureADCChannel_08001e48(ADC_HandleTypeDef *adcHandle,ADC_ChannelConfTypeDef *adcChannelConfig)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint index;\n  uint32_t loopIndex;\n  \n  if (adcHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    adcHandle->Lock = HAL_LOCKED;\n    index = adcChannelConfig->Rank;\n    if (index < 7) {\n      index = index * 5 - 5;\n      adcHandle->Instance->SQR3 =\n           adcChannelConfig->Channel << (index & 0xff) | adcHandle->Instance->SQR3 & ~(0x1f << (index & 0xff));\n    }\n    else if (index < 0xd) {\n      index = index * 5 - 0x23;\n      adcHandle->Instance->SQR2 =\n           adcChannelConfig->Channel << (index & 0xff) | adcHandle->Instance->SQR2 & ~(0x1f << (index & 0xff));\n    }\n    else {\n      index = index * 5 - 0x41;\n      adcHandle->Instance->SQR1 =\n           adcChannelConfig->Channel << (index & 0xff) | adcHandle->Instance->SQR1 & ~(0x1f << (index & 0xff));\n    }\n    index = adcChannelConfig->Channel;\n    if (index < 10) {\n      adcHandle->Instance->SMPR2 =\n           adcChannelConfig->SamplingTime << (index * 3 & 0xff) |\n           adcHandle->Instance->SMPR2 & ~(7 << (index * 3 & 0xff));\n    }\n    else {\n      index = index * 3 - 0x1e;\n      adcHandle->Instance->SMPR1 =\n           adcChannelConfig->SamplingTime << (index & 0xff) | adcHandle->Instance->SMPR1 & ~(7 << (index & 0xff));\n    }\n    if (adcChannelConfig->Channel - 0x10 < 2) {\n      if (adcHandle->Instance == (ADC_TypeDef *)0x40012400) {\n        if ((uRam40012408 & 0x800000) == 0) {\n          uRam40012408 = uRam40012408 | 0x800000;\n          if (adcChannelConfig->Channel == 0x10) {\n            for (loopIndex = (SystemCoreClock / 1000000) * 10; loopIndex != 0;\n                loopIndex = loopIndex - 1) {\n            }\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        adcHandle->State = adcHandle->State | 0x20;\n        status = HAL_ERROR;\n      }\n    }\n    else {\n      status = HAL_OK;\n    }\n    adcHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001e48": "configure_adc_channel_08001e48",
                "hadc": "adcHandle",
                "sConfig": "adcChannelConfig",
                "HVar1": "status",
                "uVar2": "index",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f80": {
            "entrypoint": "0x08001f80",
            "current_name": "get_adc_state_08001f80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_ADC_state_08001f80(ADC_HandleTypeDef *adc_handle)\n\n{\n  return adc_handle->adc_state;\n}\n\n",
            "renaming": {
                "FUN_08001f80": "get_adc_state_08001f80",
                "hadc": "adc_handle",
                "State": "adc_state"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f84": {
            "entrypoint": "0x08001f84",
            "current_name": "initialize_adc_08001f84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeADC_08001f84(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  ADC_TypeDef *adcInstance;\n  uint32_t loopIndex;\n  \n  adcInstance = adcHandle->Instance;\n  if ((adcInstance->CR2 & 1) == 0) {\n    adcInstance->CR2 = adcInstance->CR2 | 1;\n    for (loopIndex = SystemCoreClock / 1000000; loopIndex != 0;\n        loopIndex = loopIndex - 1) {\n    }\n    startTime = HAL_GetTick();\n    do {\n      if ((adcHandle->Instance->CR2 & 1) != 0) {\n        return HAL_OK;\n      }\n      currentTime = HAL_GetTick();\n    } while (currentTime - startTime < 3);\n    adcHandle->State = adcHandle->State | 0x10;\n    adcHandle->ErrorCode = adcHandle->ErrorCode | 1;\n    adcHandle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  else {\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001f84": "initialize_adc_08001f84",
                "hadc": "adcHandle",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "pAVar4": "adcInstance",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002004": {
            "entrypoint": "0x08002004",
            "current_name": "configure_adc_08002004",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configure_adc_08002004(ADC_HandleTypeDef *adc_handler)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  ADC_TypeDef *adc_instance;\n  \n  if (adc_handler->Lock != HAL_LOCKED) {\n    adc_handler->Lock = HAL_LOCKED;\n    status = ADC_Enable(adc_handler);\n    if (status == HAL_OK) {\n      adc_handler->State = adc_handler->State & 0xfffffcfe | 0x100;\n      adc_instance = adc_handler->Instance;\n      if ((adc_instance == (ADC_TypeDef *)0x40012800) && ((_DAT_40012404 & 0xf0000) != 0)) {\n        adc_handler->State = adc_handler->State | 0x100000;\n        if ((_DAT_40012404 & 0x400) != 0) {\n          adc_handler->State = adc_handler->State & 0xffffcfff | 0x1000;\n        }\n      }\n      else {\n        adc_handler->State = adc_handler->State & 0xffefffff;\n        if ((adc_instance->CR1 & 0x400) != 0) {\n          adc_handler->State = adc_handler->State & 0xffffcfff | 0x1000;\n        }\n      }\n      if ((adc_handler->State & 0x1000) == 0) {\n        adc_handler->ErrorCode = 0;\n      }\n      else {\n        adc_handler->ErrorCode = adc_handler->ErrorCode & 0xfffffff9;\n      }\n      adc_handler->Lock = HAL_UNLOCKED;\n      adc_instance->SR = 0xfffffffd;\n      adc_instance = adc_handler->Instance;\n      if (((adc_instance->CR2 & 0xe0000) == 0xe0000) &&\n         ((adc_instance != (ADC_TypeDef *)0x40012800 || ((_DAT_40012404 & 0xf0000) == 0)))) {\n        adc_instance->CR2 = adc_instance->CR2 | 0x500000;\n      }\n      else {\n        adc_instance->CR2 = adc_instance->CR2 | 0x100000;\n      }\n    }\n    else {\n      adc_handler->Lock = HAL_UNLOCKED;\n    }\n    return status;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002004": "configure_adc_08002004",
                "hadc": "adc_handler",
                "HVar1": "status",
                "pAVar2": "adc_instance"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_Enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080020f0": {
            "entrypoint": "0x080020f0",
            "current_name": "check_adc_conversion_complete_080020f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict check_ADC_conversion_complete_080020f0(ADC_HandleTypeDef *adc_handle)\n\n{\n  uint32_t start_time;\n  uint32_t current_time;\n  ADC_TypeDef *adc_instance;\n  \n  adc_instance = adc_handle->Instance;\n  if ((adc_instance->CR2 & 1) == 0) {\n    return HAL_OK;\n  }\n  adc_instance->CR2 = adc_instance->CR2 & 0xfffffffe;\n  start_time = HAL_GetTick();\n  do {\n    if ((adc_handle->Instance->CR2 & 1) == 0) {\n      return HAL_OK;\n    }\n    current_time = HAL_GetTick();\n  } while (current_time - start_time < 3);\n  adc_handle->State = adc_handle->State | 0x10;\n  adc_handle->ErrorCode = adc_handle->ErrorCode | 1;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080020f0": "check_adc_conversion_complete_080020f0",
                "hadc": "adc_handle",
                "uVar1": "start_time",
                "uVar2": "current_time",
                "pAVar3": "adc_instance"
            },
            "calling": [
                "HAL_ADC_DeInit",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Stop",
                "HAL_ADC_Init"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800213c": {
            "entrypoint": "0x0800213c",
            "current_name": "initialize_adc_0800213c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initialize_ADC_0800213c(ADC_HandleTypeDef *adc_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t value1;\n  uint value2;\n  uint value3;\n  uint32_t value4;\n  \n  if (adc_handle == (ADC_HandleTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (adc_handle->State == 0) {\n    adc_handle->ErrorCode = 0;\n    adc_handle->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(adc_handle);\n  }\n  status = ADC_ConversionStop_Disable(adc_handle);\n  if (((adc_handle->State & 0x10) == 0) && (status == HAL_OK)) {\n    adc_handle->State = adc_handle->State & 0xffffeefd | 2;\n    value4 = (adc_handle->Init).ContinuousConvMode;\n    value2 = (adc_handle->Init).DataAlign | (adc_handle->Init).ExternalTrigConv | value4 << 1;\n    value1 = (adc_handle->Init).ScanConvMode;\n    if (value1 == 0x100) {\n      value3 = 0x100;\n    }\n    else {\n      value3 = 0;\n      if (value1 == 1) {\n        value3 = 0x100;\n      }\n    }\n    if ((adc_handle->Init).DiscontinuousConvMode == 1) {\n      if (value4 == 0) {\n        value3 = value3 | ((adc_handle->Init).NbrOfDiscConversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        adc_handle->State = adc_handle->State | 0x20;\n        adc_handle->ErrorCode = adc_handle->ErrorCode | 1;\n      }\n    }\n    adc_handle->Instance->CR1 = value3 | adc_handle->Instance->CR1 & 0xffff16ff;\n    adc_handle->Instance->CR2 = adc_handle->Instance->CR2 & 0xffe1f7fd | value2;\n    value1 = (adc_handle->Init).ScanConvMode;\n    if ((value1 == 0x100) || (value1 == 1)) {\n      value3 = ((adc_handle->Init).NbrOfConversion - 1) * 0x100000;\n    }\n    else {\n      value3 = 0;\n    }\n    adc_handle->Instance->SQR1 = value3 | adc_handle->Instance->SQR1 & 0xff0fffff;\n    if (value2 != (adc_handle->Instance->CR2 & 0xff1f0efe)) {\n      adc_handle->State = adc_handle->State & 0xffffffed | 0x10;\n      adc_handle->ErrorCode = adc_handle->ErrorCode | 1;\n      return HAL_ERROR;\n    }\n    adc_handle->ErrorCode = 0;\n    adc_handle->State = adc_handle->State & 0xfffffffc | 1;\n    return HAL_OK;\n  }\n  adc_handle->State = adc_handle->State | 0x10;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800213c": "initialize_adc_0800213c",
                "hadc": "adc_handle",
                "HVar1": "status",
                "uVar2": "value1",
                "uVar3": "value2",
                "uVar4": "value3",
                "uVar5": "value4"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800224c": {
            "entrypoint": "0x0800224c",
            "current_name": "stop_and_reset_adc_conversion_0800224c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict stopAndResetADCConversion_0800224c(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  \n  if (adcHandle == (ADC_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    adcHandle->State = adcHandle->State | 2;\n    status = ADC_ConversionStop_Disable(adcHandle);\n    if (status == HAL_OK) {\n      adcHandle->Instance->SR = 0xffffffe0;\n      adcHandle->Instance->CR1 = adcHandle->Instance->CR1 & 0xff3f0000;\n      adcHandle->Instance->CR2 = adcHandle->Instance->CR2 & 0xff0106f0;\n      adcHandle->Instance->SMPR1 = adcHandle->Instance->SMPR1 & 0xff000000;\n      adcHandle->Instance->SMPR2 = adcHandle->Instance->SMPR2 & 0xc0000000;\n      adcHandle->Instance->JOFR1 = adcHandle->Instance->JOFR1 & 0xfffff000;\n      adcHandle->Instance->JOFR2 = adcHandle->Instance->JOFR2 & 0xfffff000;\n      adcHandle->Instance->JOFR3 = adcHandle->Instance->JOFR3 & 0xfffff000;\n      adcHandle->Instance->JOFR4 = adcHandle->Instance->JOFR4 & 0xfffff000;\n      adcHandle->Instance->HTR = adcHandle->Instance->HTR & 0xfffff000;\n      adcHandle->Instance->LTR = adcHandle->Instance->LTR & 0xfffff000;\n      adcHandle->Instance->SQR1 = adcHandle->Instance->SQR1 & 0xff000000;\n      adcHandle->Instance->SQR1 = adcHandle->Instance->SQR1 & 0xff000000;\n      adcHandle->Instance->SQR2 = adcHandle->Instance->SQR2 & 0xc0000000;\n      adcHandle->Instance->SQR3 = adcHandle->Instance->SQR3 & 0xc0000000;\n      adcHandle->Instance->JSQR = adcHandle->Instance->JSQR & 0xffc00000;\n      adcHandle->Instance->JSQR = adcHandle->Instance->JSQR & 0xffc00000;\n      HAL_ADC_MspDeInit(adcHandle);\n      adcHandle->ErrorCode = 0;\n      adcHandle->State = 0;\n    }\n    adcHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800224c": "stop_and_reset_adc_conversion_0800224c",
                "hadc": "adcHandle",
                "HVar1": "status"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002348": {
            "entrypoint": "0x08002348",
            "current_name": "stop_and_disable_conversion_08002348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_Status stopAndDisableConversion_08002348(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_Status HVar1;\n  \n  if (hadc->Lock == LOCKED) {\n    return BUSY;\n  }\n  hadc->Lock = LOCKED;\n  HVar1 = stopAndDisableConversion_08002348(hadc);\n  if (HVar1 == HAL_OK) {\n    hadc->state = hadc->state & 0xffffeefe | 1;\n  }\n  hadc->Lock = UNLOCKED;\n  return HVar1;\n}\n\n",
            "renaming": {
                "FUN_08002348": "stop_and_disable_conversion_08002348",
                "HAL_StatusTypeDef_conflict": "HAL_Status",
                "HAL_LOCKED": "LOCKED",
                "HAL_BUSY": "BUSY",
                "HAL_UNLOCKED": "UNLOCKED",
                "ADC_ConversionStop_Disable": "stopAndDisableConversion",
                "State": "state"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002384": {
            "entrypoint": "0x08002384",
            "current_name": "stop_adc_conversion_and_enable_08002384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict stopADCConversionAndEnable_08002384(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t freq;\n  uint32_t sysClock;\n  ADC_TypeDef *adcStruct;\n  uint32_t startTick;\n  uint32_t loopIndex;\n  \n  if (adcHandle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  adcHandle->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(adcHandle);\n  if (status == HAL_OK) {\n    adcHandle->State = adcHandle->State & 0xffffeefd | 2;\n    sysClock = SystemCoreClock;\n    freq = HAL_RCCEx_GetPeriphCLKFreq(2);\n    for (loopIndex = sysClock / freq << 1; loopIndex != 0;\n        loopIndex = loopIndex - 1) {\n    }\n    ADC_Enable(adcHandle);\n    adcHandle->Instance->CR2 = adcHandle->Instance->CR2 | 8;\n    sysClock = HAL_GetTick();\n    while (adcStruct = adcHandle->Instance, (adcStruct->CR2 & 8) != 0) {\n      freq = HAL_GetTick();\n      if (10 < freq - sysClock) {\n        adcHandle->State = adcHandle->State & 0xffffffed | 0x10;\n        adcHandle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adcStruct->CR2 = adcStruct->CR2 | 4;\n    sysClock = HAL_GetTick();\n    while ((adcHandle->Instance->CR2 & 4) != 0) {\n      freq = HAL_GetTick();\n      if (10 < freq - sysClock) {\n        adcHandle->State = adcHandle->State & 0xffffffed | 0x10;\n        adcHandle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adcHandle->State = adcHandle->State & 0xfffffffc | 1;\n  }\n  adcHandle->Lock = HAL_UNLOCKED;\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002384": "stop_adc_conversion_and_enable_08002384",
                "hadc": "adcHandle",
                "HVar1": "status",
                "uVar2": "freq",
                "uVar3": "sysClock",
                "pAVar4": "adcStruct",
                "tickstart": "startTick",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_GetTick",
                "ADC_ConversionStop_Disable",
                "HAL_RCCEx_GetPeriphCLKFreq",
                "ADC_Enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002470": {
            "entrypoint": "0x08002470",
            "current_name": "set_priority_group_08002470",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setPriorityGroup_08002470(uint32_t priorityGroup)\n\n{\n  uint32_t registerValue;\n  \n  _DAT_e000ed0c = (priorityGroup & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002470": "set_priority_group_08002470",
                "PriorityGroup": "priorityGroup",
                "reg_value": "registerValue"
            },
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002494": {
            "entrypoint": "0x08002494",
            "current_name": "configure_priority_08002494",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configurePriority_08002494(interruptNumber IRQn,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint interruptNumberAsUInt;\n  uint modifiedPriority;\n  uint32_t priorityGroupTemp;\n  uint32_t adjustedSubPriorityBits;\n  uint32_t adjustedPreemptPriorityBits;\n  \n  interruptNumberAsUInt = (uint)IRQn;\n  modifiedPriority = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  adjustedPreemptPriorityBits = 7 - modifiedPriority;\n  if (3 < adjustedPreemptPriorityBits) {\n    adjustedPreemptPriorityBits = 4;\n  }\n  if (modifiedPriority + 4 < 7) {\n    adjustedSubPriorityBits = 0;\n  }\n  else {\n    adjustedSubPriorityBits = modifiedPriority - 3;\n  }\n  modifiedPriority = (preemptPriority & (1 << (adjustedPreemptPriorityBits & 0xff)) - 1U) << (adjustedSubPriorityBits & 0xff) |\n          (1 << (adjustedSubPriorityBits & 0xff)) - 1U & subPriority;\n  if ((int)interruptNumberAsUInt < 0) {\n    *(char *)((interruptNumberAsUInt & 0xf) + 0xe000ed14) = (char)(modifiedPriority << 4);\n  }\n  else {\n    *(char *)(interruptNumberAsUInt + 0xe000e400) = (char)(modifiedPriority << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002494": "configure_priority_08002494",
                "IRQn_Type_conflict": "interruptNumber",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "PriorityGroupTmp": "priorityGroupTemp",
                "SubPriorityBits": "adjustedSubPriorityBits",
                "PreemptPriorityBits": "adjustedPreemptPriorityBits",
                "uVar1": "interruptNumberAsUInt",
                "uVar2": "modifiedPriority"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080024f8": {
            "entrypoint": "0x080024f8",
            "current_name": "set_interrupt_priority_080024f8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptPriority_080024f8(interruptNumber IRQn)\n\n{\n  uint interruptIndex;\n  \n  interruptIndex = (uint)IRQn;\n  if (-1 < (int)interruptIndex) {\n    *(int *)((interruptIndex >> 5) * 4 + -0x1fff1f00) = 1 << (interruptIndex & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080024f8": "set_interrupt_priority_080024f8",
                "IRQn_Type_conflict": "interruptNumber",
                "uVar1": "interruptIndex"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002514": {
            "entrypoint": "0x08002514",
            "current_name": "initialize_ticks_08002514",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t initializeTicks_08002514(uint32_t ticksNumber)\n\n{\n  if (ticksNumber - 1 < 0x1000000) {\n    _DAT_e000e014 = ticksNumber - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002514": "initialize_ticks_08002514",
                "TicksNumb": "ticksNumber"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002540": {
            "entrypoint": "0x08002540",
            "current_name": "set_ir_qn_type_bit_08002540",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setIRQnTypeBit_08002540(irqNumber_Type_conflict irqNumber)\n\n{\n  uint convertedIRQn;\n  \n  convertedIRQn = (uint)irqNumber;\n  if (-1 < (int)convertedIRQn) {\n    *(int *)(((convertedIRQn >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (convertedIRQn & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002540": "set_ir_qn_type_bit_08002540",
                "IRQn": "irqNumber",
                "uVar1": "convertedIRQn"
            },
            "calling": [
                "USART2_IRQHandler",
                "USART3_IRQHandler",
                "USART1_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002560": {
            "entrypoint": "0x08002560",
            "current_name": "set_clock_source_08002560",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setClockSource_08002560(uint32_t source)\n\n{\n  if (source != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002560": "set_clock_source_08002560",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002580": {
            "entrypoint": "0x08002580",
            "current_name": "FUNC_08002580",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002580(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002580": "FUNC_08002580"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002582": {
            "entrypoint": "0x08002582",
            "current_name": "initialize_sys_tick_callback_08002582",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSysTickCallback_08002582(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002582": "initialize_sys_tick_callback_08002582"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800258c": {
            "entrypoint": "0x0800258c",
            "current_name": "update_dma_channel_configuration_0800258c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict update_DMA_channel_configuration_0800258c(DMA_HandleTypeDef *dma_handle)\n\n{\n  Channel_TypeDef *channel_instance;\n  \n  if (dma_handle->State != DMA_STATE_BUSY) {\n    dma_handle->ErrorCode = 4;\n    return ERROR;\n  }\n  dma_handle->Instance->CCR = dma_handle->Instance->CCR & 0xfffffff1;\n  dma_handle->Instance->CCR = dma_handle->Instance->CCR & 0xfffffffe;\n  channel_instance = dma_handle->Instance;\n  if (channel_instance == (Channel_TypeDef *)0x40020008) {\n    _DAT_40020004 = 1;\n  }\n  else if (channel_instance == (Channel_TypeDef *)0x4002001c) {\n    _DAT_40020004 = 0x10;\n  }\n  else if (channel_instance == (Channel_TypeDef *)0x40020030) {\n    _DAT_40020004 = 0x100;\n  }\n  else if (channel_instance == (Channel_TypeDef *)0x40020044) {\n    _DAT_40020004 = 0x1000;\n  }\n  else if (channel_instance == (Channel_TypeDef *)0x40020058) {\n    _DAT_40020004 = 0x10000;\n  }\n  else if (channel_instance == (Channel_TypeDef *)0x4002006c) {\n    _DAT_40020004 = 0x100000;\n  }\n  else {\n    _DAT_40020004 = 0x1000000;\n  }\n  dma_handle->State = DMA_STATE_READY;\n  dma_handle->Lock = UNLOCKED;\n  if (dma_handle->XferAbortCallback != (XferAbortCallback *)0x0) {\n    (*dma_handle->XferAbortCallback)(dma_handle);\n    return OK;\n  }\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_0800258c": "update_dma_channel_configuration_0800258c",
                "hdma": "dma_handle",
                "pDVar1": "channel_instance",
                "HAL_DMA_STATE_BUSY": "DMA_STATE_BUSY",
                "HAL_ERROR": "ERROR",
                "DMA_Channel_TypeDef": "Channel_TypeDef",
                "HAL_DMA_STATE_READY": "DMA_STATE_READY",
                "HAL_UNLOCKED": "UNLOCKED",
                "_func_void___DMA_HandleTypeDef_ptr": "XferAbortCallback",
                "HAL_OK": "OK"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002624": {
            "entrypoint": "0x08002624",
            "current_name": "initialize_gpio_08002624",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeGPIO_08002624(GPIO_TypeDef *gpioPort,gpioInitTypeDef *gpioInit)\n\n{\n  GPIO_TypeDef *port;\n  uint bitMask;\n  uint isPinSet;\n  uint pinIndex;\n  uint mode;\n  uint32_t speed;\n  int index;\n  uint32_t *configRegister;\n  int portIndex;\n  uint32_t tempReg;\n  \n  speed = 0;\n  pinIndex = 0;\n  do {\n    if (0xf < pinIndex) {\n      return;\n    }\n    bitMask = 1 << (pinIndex & 0xff);\n    isPinSet = gpioInit->Pin & bitMask;\n    if (bitMask == isPinSet) {\n      mode = gpioInit->Mode;\n      if (mode == 0x12) {\n        speed = gpioInit->Speed + 0xc;\n      }\n      else if (mode < 0x13) {\n        if (mode == 2) {\n          speed = gpioInit->Speed + 8;\n        }\n        else if (mode < 3) {\n          if (mode == 0) goto LAB_08002776;\n          if (mode == 1) {\n            speed = gpioInit->Speed;\n          }\n        }\n        else if (mode == 3) {\n          speed = 0;\n        }\n        else if (mode == 0x11) {\n          speed = gpioInit->Speed + 4;\n        }\n      }\n      else if (mode == 0x10210000) {\nLAB_08002776:\n        if (gpioInit->Pull == 0) {\n          speed = 4;\n        }\n        else if (gpioInit->Pull == 1) {\n          gpioPort->BSRR = bitMask;\n          speed = 8;\n        }\n        else {\n          gpioPort->BRR = bitMask;\n          speed = 8;\n        }\n      }\n      else if (mode < 0x10210001) {\n        if ((mode == 0x10110000) || (mode == 0x10120000)) goto LAB_08002776;\n      }\n      else if ((mode == 0x10310000) || ((mode == 0x10320000 || (mode == 0x10220000))))\n      goto LAB_08002776;\n      bitMask = pinIndex;\n      port = gpioPort;\n      if (0xff < isPinSet) {\n        bitMask = pinIndex - 8;\n        port = (GPIO_TypeDef *)&gpioPort->CRH;\n      }\n      port->CRL = port->CRL & ~(0xf << (bitMask << 2 & 0xff)) | speed << (bitMask << 2 & 0xff);\n      if ((gpioInit->Mode & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        index = (pinIndex & 3) << 2;\n        if (gpioPort == (GPIO_TypeDef *)0x40010800) {\n          portIndex = 0;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40010c00) {\n          portIndex = 1;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011000) {\n          portIndex = 2;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011400) {\n          portIndex = 3;\n        }\n        else {\n          portIndex = 4;\n        }\n        *(uint *)(((pinIndex >> 2) + 2) * 4 + 0x40010000) =\n             *(uint *)(((pinIndex >> 2) + 2) * 4 + 0x40010000) & ~(0xf << index) | portIndex << index;\n        if ((gpioInit->Mode & 0x10000) == 0) {\n          _DAT_40010400 = _DAT_40010400 & ~isPinSet;\n        }\n        else {\n          _DAT_40010400 = _DAT_40010400 | isPinSet;\n        }\n        if ((gpioInit->Mode & 0x20000) == 0) {\n          _DAT_40010404 = _DAT_40010404 & ~isPinSet;\n        }\n        else {\n          _DAT_40010404 = _DAT_40010404 | isPinSet;\n        }\n        if ((gpioInit->Mode & 0x100000) == 0) {\n          _DAT_40010408 = _DAT_40010408 & ~isPinSet;\n        }\n        else {\n          _DAT_40010408 = _DAT_40010408 | isPinSet;\n        }\n        if ((gpioInit->Mode & 0x200000) == 0) {\n          _DAT_4001040c = _DAT_4001040c & ~isPinSet;\n        }\n        else {\n          _DAT_4001040c = isPinSet | _DAT_4001040c;\n        }\n      }\n    }\n    pinIndex = pinIndex + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08002624": "initialize_gpio_08002624",
                "GPIOx": "gpioPort",
                "GPIO_Init": "gpioInit",
                "pGVar1": "port",
                "uVar2": "bitMask",
                "uVar3": "isPinSet",
                "uVar4": "pinIndex",
                "uVar5": "mode",
                "uVar6": "speed",
                "configregister": "configRegister",
                "iVar7": "index",
                "iVar8": "portIndex",
                "tmpreg": "tempReg"
            },
            "calling": [
                "digital_io_init",
                "uart_init",
                "HAL_ADC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002810": {
            "entrypoint": "0x08002810",
            "current_name": "check_gpio_pin_state_08002810",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinState check_GPIO_PinState_08002810(GPIO_TypeDef *Port,uint16_t Pin)\n\n{\n  PinState pin_state;\n  \n  if (((uint)Pin & Port->IDR) == 0) {\n    pin_state = GPIO_PIN_RESET;\n    return pin_state;\n  }\n  return GPIO_PIN_SET;\n}\n\n",
            "renaming": {
                "FUN_08002810": "check_gpio_pin_state_08002810",
                "GPIOx": "Port",
                "GPIO_Pin": "Pin",
                "bitstatus": "pin_state"
            },
            "calling": [
                "digital_io_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800281e": {
            "entrypoint": "0x0800281e",
            "current_name": "configure_gpio_0800281e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configure_GPIO_0800281e(GPIO_TypeDef *GPIO_port,uint16_t pin_number,pin_numberState pin_state)\n\n{\n  if (pin_state == GPIO_PIN_RESET) {\n    GPIO_port->BSRR = (uint)pin_number << 0x10;\n    return;\n  }\n  GPIO_port->BSRR = (uint)pin_number;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800281e": "configure_gpio_0800281e",
                "GPIOx": "GPIO_port",
                "GPIO_Pin": "pin_number",
                "PinState": "pin_state"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800282c": {
            "entrypoint": "0x0800282c",
            "current_name": "handle_gpio_interrupt_0800282c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_interrupt_0800282c(uint16_t pin)\n\n{\n  if ((_DAT_40010414 & pin) != 0) {\n    _DAT_40010414 = (uint)pin;\n    HAL_GPIO_EXTI_Callback(pin);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800282c": "handle_gpio_interrupt_0800282c",
                "GPIO_Pin": "pin"
            },
            "calling": [
                "EXTI4_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI15_10_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI1_IRQHandler"
            ],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002848": {
            "entrypoint": "0x08002848",
            "current_name": "set_devaddress_08002848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict setDevaddress_08002848(I2C_HandleTypeDef *i2cHandle)\n\n{\n  if (i2cHandle->mode == HAL_I2C_MODE_MEM) {\n    if (i2cHandle->eventCount == 0) {\n      i2cHandle->i2cInstance->DR = i2cHandle->devAddress & 0xfe;\n    }\n    else {\n      i2cHandle->i2cInstance->DR = i2cHandle->devAddress & 0xff | 1;\n    }\n  }\n  else if ((i2cHandle->i2cInit).addressingMode == 0x4000) {\n    if (i2cHandle->i2cState == HAL_I2C_STATE_BUSY_TX) {\n      i2cHandle->i2cInstance->DR = i2cHandle->devAddress & 0xfe;\n    }\n    else {\n      i2cHandle->i2cInstance->DR = i2cHandle->devAddress & 0xff | 1;\n    }\n  }\n  else if (i2cHandle->eventCount == 0) {\n    i2cHandle->i2cInstance->DR = (i2cHandle->devAddress << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (i2cHandle->eventCount == 1) {\n    i2cHandle->i2cInstance->DR = (i2cHandle->devAddress << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002848": "set_devaddress_08002848",
                "hi2c": "i2cHandle",
                "Mode": "mode",
                "EventCount": "eventCount",
                "Instance": "i2cInstance",
                "Devaddress": "devAddress",
                "Init": "i2cInit",
                "AddressingMode": "addressingMode",
                "State": "i2cState"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028d2": {
            "entrypoint": "0x080028d2",
            "current_name": "set_i2_c_device_address_080028d2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict setI2CDeviceAddress_080028d2(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xff;\n  return HALStatusOK;\n}\n\n",
            "renaming": {
                "FUN_080028d2": "set_i2_c_device_address_080028d2",
                "hi2c": "i2cHandle",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "Devaddress": "deviceAddress",
                "HAL_OK": "HALStatusOK"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028de": {
            "entrypoint": "0x080028de",
            "current_name": "handle_i2_c_transfer_080028de",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CTransfer_080028de(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t transferOptions;\n  I2C_TypeDef *i2cInstance;\n  uint32_t previousState;\n  uint32_t tmpReg;\n  uint32_t tmpReg1;\n  uint32_t tmpReg2;\n  uint32_t tmpReg3;\n  uint32_t tmpReg4;\n  uint32_t tmpReg5;\n  uint32_t tmpReg6;\n  uint32_t tmpReg7;\n  uint32_t tmpReg8;\n  uint32_t tmpReg9;\n  uint32_t tmpReg10;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((i2cHandle->EventCount != 0 || (i2cHandle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((i2cHandle->EventCount == 0) && ((i2cHandle->Init).AddressingMode == 0xc000)) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      i2cHandle->EventCount = i2cHandle->EventCount + 1;\n    }\n    else {\n      if (i2cHandle->XferCount == 0) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      else if (i2cHandle->XferCount == 1) {\n        if (transferOptions == 0xffff0000) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cInstance = i2cHandle->Instance;\n          if ((i2cInstance->CR2 & 0x800) == 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n          }\n          else {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((transferOptions == 4) || (transferOptions == 8)) || (i2cHandle->PreviousState == 0x12)) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (i2cHandle->XferCount == 2) {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      else {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      i2cHandle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080028de": "handle_i2_c_transfer_080028de",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar1": "transferOptions",
                "pIVar2": "i2cInstance",
                "Prev_State": "previousState",
                "tmpreg": "tmpReg",
                "tmpreg_1": "tmpReg1",
                "tmpreg_2": "tmpReg2",
                "tmpreg_3": "tmpReg3",
                "tmpreg_4": "tmpReg4",
                "tmpreg_5": "tmpReg5",
                "tmpreg_6": "tmpReg6",
                "tmpreg_7": "tmpReg7",
                "tmpreg_8": "tmpReg8",
                "tmpreg_9": "tmpReg9",
                "tmpreg_10": "tmpReg10"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ab8": {
            "entrypoint": "0x08002ab8",
            "current_name": "transfer_byte_to_i2_c_device_08002ab8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict transferByteToI2CDevice_08002ab8(I2C_HandleTypeDef *i2cDeviceHandle)\n\n{\n  byte *bufferPointer;\n  \n  if (i2cDeviceHandle->transferCount != 0) {\n    bufferPointer = i2cDeviceHandle->pBuffPtr;\n    i2cDeviceHandle->pBuffPtr = bufferPointer + 1;\n    i2cDeviceHandle->i2cInstance->dataRegister = (uint)*bufferPointer;\n    i2cDeviceHandle->transferCount = i2cDeviceHandle->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002ab8": "transfer_byte_to_i2_c_device_08002ab8",
                "hi2c": "i2cDeviceHandle",
                "pbVar1": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "XferCount": "transferCount"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "extract_and_decrement_08002ad8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict extractAndDecrement_08002ad8(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint8_t *puVar1;\n  \n  if (i2cHandle->XferCount != 0) {\n    puVar1 = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = puVar1 + 1;\n    *puVar1 = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "extract_and_decrement_08002ad8",
                "hi2c": "i2cHandle"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002af8": {
            "entrypoint": "0x08002af8",
            "current_name": "configure_i2_c_transfer_08002af8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureI2CTransfer_08002af8(I2C_HandleTypeDef *i2cHandle,uint8_t *dataBuffer,uint16_t dataSize,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (dataBuffer == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (dataSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = dataBuffer;\n      i2cHandle->XferCount = dataSize;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->XferdataSize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002af8": "configure_i2_c_transfer_08002af8",
                "hi2c": "i2cHandle",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b84": {
            "entrypoint": "0x08002b84",
            "current_name": "handle_i2_c_listen_state_08002b84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nhandleI2CListenState_08002b84(I2C_HandleTypeDef *i2cHandle,uint8_t *dataBuffer,uint16_t bufferSize,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (dataBuffer == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (bufferSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = dataBuffer;\n      i2cHandle->XferCount = bufferSize;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->XferbufferSize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002b84": "handle_i2_c_listen_state_08002b84",
                "hi2c": "i2cHandle",
                "pData": "dataBuffer",
                "Size": "bufferSize",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c10": {
            "entrypoint": "0x08002c10",
            "current_name": "configure_i2_c_08002c10",
            "code": "\n/* WARNING: Unknown calling convention */\n\nI2CStatus configureI2C_08002c10(I2C_HandleTypeDef *i2c)\n\n{\n  I2C_TypeDef *i2cInstance;\n  \n  if (i2c->State != I2CStateReady) {\n    return I2CBusy;\n  }\n  i2c->State = HAL_I2C_STATE_LISTEN;\n  i2cInstance = i2c->Instance;\n  if ((i2cInstance->CR1 & 1) == 0) {\n    i2cInstance->CR1 = i2cInstance->CR1 | 1;\n  }\n  i2c->Instance->CR1 = i2c->Instance->CR1 | 0x400;\n  i2c->Instance->CR2 = i2c->Instance->CR2 | 0x300;\n  return I2COK;\n}\n\n",
            "renaming": {
                "FUN_08002c10": "configure_i2_c_08002c10",
                "hi2c": "i2c",
                "pIVar1": "i2cInstance",
                "HAL_StatusTypeDef_conflict": "I2CStatus",
                "HAL_I2C_STATE_READY": "I2CStateReady",
                "HAL_BUSY": "I2CBusy",
                "HAL_OK": "I2COK"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c4e": {
            "entrypoint": "0x08002c4e",
            "current_name": "FUNC_08002c4e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c4e(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c4e": "FUNC_08002c4e"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c50": {
            "entrypoint": "0x08002c50",
            "current_name": "FUNC_08002c50",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c50(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c50": "FUNC_08002c50"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c52": {
            "entrypoint": "0x08002c52",
            "current_name": "FUNC_08002c52",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c52(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c52": "FUNC_08002c52"
            },
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c54": {
            "entrypoint": "0x08002c54",
            "current_name": "send_byte_08002c54",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict sendByte_08002c54(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2CState currentState;\n  Byte *bufferPtr;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->transferCount != 0) {\n    bufferPtr = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = bufferPtr + 1;\n    i2cHandle->i2cInstance->dataRegister = (uint)*bufferPtr;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    if ((i2cHandle->transferCount == 0) && (currentState == transmitListenState)) {\n      i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffbff;\n      i2cHandle->previousState = 0x21;\n      i2cHandle->State = listenState;\n      HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n    }\n    return success;\n  }\n  return success;\n}\n\n",
            "renaming": {
                "FUN_08002c54": "send_byte_08002c54",
                "hi2c": "i2cHandle",
                "HAL_I2C_StateTypeDef": "I2CState",
                "byte": "Byte",
                "HVar1": "currentState",
                "pbVar2": "bufferPtr",
                "pBuffPtr": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "XferCount": "transferCount",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "transmitListenState",
                "CR2": "controlRegister2",
                "PreviousState": "previousState",
                "HAL_I2C_STATE_LISTEN": "listenState",
                "HAL_OK": "success"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca4": {
            "entrypoint": "0x08002ca4",
            "current_name": "FUNC_08002ca4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002ca4(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ca4": "FUNC_08002ca4"
            },
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca6": {
            "entrypoint": "0x08002ca6",
            "current_name": "handle_i2_c_receive_08002ca6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CReceive_08002ca6(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  uint8_t *bufferPointer;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->XferCount != 0) {\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    if ((i2cHandle->XferCount == 0) && (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      i2cHandle->PreviousState = 0x22;\n      i2cHandle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002ca6": "handle_i2_c_receive_08002ca6",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "puVar2": "bufferPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cf2": {
            "entrypoint": "0x08002cf2",
            "current_name": "handle_i2_c_address_match_08002cf2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CAddressMatch_08002cf2(I2C_HandleTypeDef *hi2c)\n\n{\n  uint16_t addressCode;\n  \n  if ((hi2c->Instance->SR2 & 0x80) == 0) {\n    addressCode = *(uint16_t *)&(hi2c->Init).OwnAddress1;\n  }\n  else {\n    addressCode = *(uint16_t *)&(hi2c->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(hi2c,(hi2c->Instance->SR2 & 4) == 0,addressCode);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002cf2": "handle_i2_c_address_match_08002cf2",
                "AddrMatchCode": "addressCode"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d1c": {
            "entrypoint": "0x08002d1c",
            "current_name": "handle_i2_c_events_08002d1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CEvents_08002d1c(I2C_HandleTypeDef *I2CHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t currentState;\n  \n  if (((I2CHandle->XferOptions == 4) || (I2CHandle->XferOptions == 8)) &&\n     (I2CHandle->State == HAL_I2C_STATE_LISTEN)) {\n    I2CHandle->XferOptions = 0xffff0000;\n    I2CHandle->Instance->CR2 = I2CHandle->Instance->CR2 & 0xfffff8ff;\n    I2CHandle->Instance->SR1 = 0xfffffbff;\n    I2CHandle->Instance->CR1 = I2CHandle->Instance->CR1 & 0xfffffbff;\n    I2CHandle->PreviousState = 0;\n    I2CHandle->State = HAL_I2C_STATE_READY;\n    I2CHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(I2CHandle);\n  }\n  else if (I2CHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    I2CHandle->XferOptions = 0xffff0000;\n    I2CHandle->PreviousState = 0x21;\n    I2CHandle->State = HAL_I2C_STATE_READY;\n    I2CHandle->Mode = HAL_I2C_MODE_NONE;\n    I2CHandle->Instance->CR2 = I2CHandle->Instance->CR2 & 0xfffff8ff;\n    I2CHandle->Instance->SR1 = 0xfffffbff;\n    I2CHandle->Instance->CR1 = I2CHandle->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(I2CHandle);\n  }\n  else {\n    I2CHandle->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002d1c": "handle_i2_c_events_08002d1c",
                "hi2c": "I2CHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "CurrentState": "currentState"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002db0": {
            "entrypoint": "0x08002db0",
            "current_name": "FUNC_08002db0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002db0(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002db0": "FUNC_08002db0"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002db2": {
            "entrypoint": "0x08002db2",
            "current_name": "handle_i2_c_transfer_08002db2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CTransfer_08002db2(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  uint32_t currentI2CState;\n  byte *currentBufferPtr;\n  uint32_t currentXferOptions;\n  uint32_t currentXferSize;\n  \n  currentState = i2cHandle->State;\n  currentXferSize = i2cHandle->XferOptions;\n  if ((i2cHandle->XferSize == 0) && (currentState == I2C_STATE_BUSY_TX)) {\n    if ((currentXferSize == 4) || ((currentXferSize == 8 || (currentXferSize == 0xffff0000)))) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = I2C_STATE_READY;\n      if (i2cHandle->Mode == I2C_MODE_MEM) {\n        i2cHandle->Mode = I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(i2cHandle);\n      }\n      else {\n        i2cHandle->Mode = I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->PreviousState = 0x11;\n      i2cHandle->Mode = I2C_MODE_NONE;\n      i2cHandle->State = I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(i2cHandle);\n    }\n  }\n  else if ((currentState == I2C_STATE_BUSY_TX) ||\n          ((i2cHandle->Mode == I2C_MODE_MEM && (currentState == I2C_STATE_BUSY_RX)))) {\n    if (i2cHandle->XferCount == 0) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n    }\n    else if (i2cHandle->Mode == I2C_MODE_MEM) {\n      if (i2cHandle->EventCount == 0) {\n        if (i2cHandle->MemaddSize == 1) {\n          i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n          i2cHandle->EventCount = i2cHandle->EventCount + 2;\n        }\n        else {\n          i2cHandle->Instance->DR = (i2cHandle->Memaddress << 0x10) >> 0x18;\n          i2cHandle->EventCount = i2cHandle->EventCount + 1;\n        }\n      }\n      else if (i2cHandle->EventCount == 1) {\n        i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n        i2cHandle->EventCount = i2cHandle->EventCount + 1;\n      }\n      else if (i2cHandle->EventCount == 2) {\n        if (i2cHandle->State == I2C_STATE_BUSY_RX) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n        }\n        else if (i2cHandle->State == I2C_STATE_BUSY_TX) {\n          currentBufferPtr = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = currentBufferPtr + 1;\n          i2cHandle->Instance->DR = (uint)*currentBufferPtr;\n          i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        }\n      }\n    }\n    else {\n      currentBufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = currentBufferPtr + 1;\n      i2cHandle->Instance->DR = (uint)*currentBufferPtr;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002db2": "handle_i2_c_transfer_08002db2",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "CurrentState": "currentI2CState",
                "pbVar2": "currentBufferPtr",
                "CurrentXferOptions": "currentXferOptions",
                "uVar3": "currentXferSize",
                "HAL_I2C_STATE_BUSY_TX": "I2C_STATE_BUSY_TX",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEM",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_STATE_BUSY_RX": "I2C_STATE_BUSY_RX"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efc": {
            "entrypoint": "0x08002efc",
            "current_name": "handle_i2_c_transfer_08002efc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CTransfer_08002efc(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  byte *bufferPtr;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (i2cHandle->XferCount == 0) {\n      if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        i2cHandle->PreviousState = 0;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(i2cHandle);\n        }\n      }\n      else {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->PreviousState = 0x11;\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      bufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPtr + 1;\n      i2cHandle->Instance->DR = (uint)*bufferPtr;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002efc": "handle_i2_c_transfer_08002efc",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "pbVar2": "bufferPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f9a": {
            "entrypoint": "0x08002f9a",
            "current_name": "FUNC_08002f9a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002f9a(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f9a": "FUNC_08002f9a"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002f9c": {
            "entrypoint": "0x08002f9c",
            "current_name": "receive_data_08002f9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict receiveData_08002f9c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint8_t *dataPtr;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_RX) {\n    if (i2cHandle->XferCount < 4) {\n      if (i2cHandle->XferCount - 2 < 2) {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n        }\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      }\n      else {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n        i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        i2cHandle->PreviousState = 0;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(i2cHandle);\n        }\n      }\n    }\n    else {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002f9c": "receive_data_08002f9c",
                "hi2c": "i2cHandle",
                "puVar1": "dataPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800306c": {
            "entrypoint": "0x0800306c",
            "current_name": "handle_i2_c_transfer_0800306c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_Status handleI2CTransfer_0800306c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  uint8_t *bufferPtr;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->transferCount == 3) {\n    if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n      i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 & 0xfffffbff;\n    }\n    bufferPtr = i2cHandle->bufferPtr;\n    i2cHandle->bufferPtr = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->i2cInstance->DR;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  else if (i2cHandle->transferCount == 2) {\n    if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n      i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffcff;\n      i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 | 0x200;\n    }\n    else {\n      if (transferOptions == 2) {\n        i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 | 0x400;\n      }\n      else {\n        i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 & 0xfffffbff;\n      }\n      i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffcff;\n    }\n    bufferPtr = i2cHandle->bufferPtr;\n    i2cHandle->bufferPtr = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->i2cInstance->DR;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    bufferPtr = i2cHandle->bufferPtr;\n    i2cHandle->bufferPtr = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->i2cInstance->DR;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    i2cHandle->i2cState = HAL_I2C_STATE_READY;\n    i2cHandle->previousState = 0;\n    if (i2cHandle->i2cMode == HAL_I2C_MODE_MEM) {\n      i2cHandle->i2cMode = HAL_I2C_MODE_NONE;\n      handleI2CMemRxCplt(i2cHandle);\n    }\n    else {\n      i2cHandle->i2cMode = HAL_I2C_MODE_NONE;\n      handleI2CMasterRxCplt(i2cHandle);\n    }\n  }\n  else {\n    bufferPtr = i2cHandle->bufferPtr;\n    i2cHandle->bufferPtr = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->i2cInstance->DR;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800306c": "handle_i2_c_transfer_0800306c",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "puVar2": "bufferPtr",
                "pBuffPtr": "bufferPtr",
                "Instance": "i2cInstance",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "XferCount": "transferCount",
                "Mode": "i2cMode",
                "State": "i2cState",
                "PreviousState": "previousState",
                "HAL_StatusTypeDef_conflict": "HAL_Status",
                "HAL_I2C_MemRxCpltCallback": "handleI2CMemRxCplt",
                "HAL_I2C_MasterRxCpltCallback": "handleI2CMasterRxCplt"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800316a": {
            "entrypoint": "0x0800316a",
            "current_name": "FUNC_0800316a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800316a(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316a": "FUNC_0800316a"
            },
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800316c": {
            "entrypoint": "0x0800316c",
            "current_name": "handle_i2_c_state_0800316c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CState_0800316c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint8_t *bufferPtr;\n  I2C_TypeDef *i2cInstance;\n  \n  if (i2cHandle->State - 0x29 < 2) {\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((i2cHandle->State != HAL_I2C_STATE_ABORT) && ((i2cHandle->Instance->CR2 & 0x800) == 0)) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n    }\n    i2cHandle->PreviousState = 0;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  }\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) == 0) {\n    if (i2cHandle->State == HAL_I2C_STATE_ABORT) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->ErrorCode = 0;\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        bufferPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = bufferPtr + 1;\n        *bufferPtr = (uint8_t)i2cInstance->DR;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(i2cHandle);\n    }\n    else {\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        bufferPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = bufferPtr + 1;\n        *bufferPtr = (uint8_t)i2cInstance->DR;\n      }\n      HAL_I2C_ErrorCallback(i2cHandle);\n    }\n  }\n  else {\n    i2cInstance->CR2 = i2cInstance->CR2 & 0xfffff7ff;\n    if (i2cHandle->hdmatx->State == HAL_DMA_STATE_READY) {\n      i2cHandle->hdmarx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmarx);\n      if (status != HAL_OK) {\n        if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n          bufferPtr = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = bufferPtr + 1;\n          *bufferPtr = (uint8_t)i2cHandle->Instance->DR;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmarx->XferAbortCallback)(i2cHandle->hdmarx);\n      }\n    }\n    else {\n      i2cHandle->hdmatx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmatx);\n      if (status != HAL_OK) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmatx->XferAbortCallback)(i2cHandle->hdmatx);\n      }\n    }\n  }\n  if ((i2cHandle->State == HAL_I2C_STATE_LISTEN) && ((i2cHandle->ErrorCode & 4) != 0)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316c": "handle_i2_c_state_0800316c",
                "hi2c": "i2cHandle",
                "HVar1": "status",
                "puVar2": "bufferPtr",
                "pIVar3": "i2cInstance"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080032b4": {
            "entrypoint": "0x080032b4",
            "current_name": "process_i2_c_data_080032b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processI2CData_080032b4(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef prevState;\n  I2C_TypeDef *i2cInstance;\n  uint8_t *dataPtr;\n  uint32_t currentState;\n  uint32_t temporaryRegister;\n  \n  prevState = i2cHandle->State;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) != 0) {\n    if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) || (i2cHandle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmarx->Instance->CNDTR;\n    }\n    else {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmatx->Instance->CNDTR;\n    }\n  }\n  if (i2cHandle->XferCount != 0) {\n    if ((i2cInstance->SR1 & 4) != 0) {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cInstance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n  }\n  if (i2cHandle->ErrorCode == 0) {\n    if (((prevState == HAL_I2C_STATE_LISTEN) || (prevState == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (prevState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2cHandle);\n    }\n    else if ((i2cHandle->PreviousState == 0x22) || (prevState == HAL_I2C_STATE_BUSY_RX)) {\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    I2C_ITError(i2cHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080032b4": "process_i2_c_data_080032b4",
                "hi2c": "i2cHandle",
                "HVar1": "prevState",
                "pIVar2": "i2cInstance",
                "puVar3": "dataPtr",
                "CurrentState": "currentState",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033b8": {
            "entrypoint": "0x080033b8",
            "current_name": "handle_i2_c_status_080033b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CStatus_080033b8(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  uint32_t currentMode;\n  uint sr1Flags;\n  uint32_t sr1ITFlags;\n  uint cr2Flags;\n  uint32_t itSources;\n  uint sr2Flags;\n  uint32_t sr2ITFlags;\n  \n  i2cInstance = i2cHandle->Instance;\n  sr2Flags = i2cInstance->SR2;\n  sr1Flags = i2cInstance->SR1;\n  cr2Flags = i2cInstance->CR2;\n  if ((i2cHandle->Mode == HAL_I2C_MODE_MASTER) || (i2cHandle->Mode == HAL_I2C_MODE_MEM)) {\n    if (((sr1Flags & 0x10001) == 0) || ((cr2Flags & 0x200) == 0)) {\n      if (((sr1Flags & 0x10008) == 0) || ((cr2Flags & 0x200) == 0)) {\n        if (((sr1Flags & 0x10002) != 0) && ((cr2Flags & 0x200) != 0)) {\n          I2C_Master_ADDR(i2cHandle);\n        }\n      }\n      else {\n        I2C_Master_ADD10(i2cHandle);\n      }\n    }\n    else {\n      I2C_Master_SB(i2cHandle);\n    }\n    if ((sr2Flags & 0x100004) == 0) {\n      if ((((sr1Flags & 0x10040) != 0) && ((cr2Flags & 0x400) != 0)) && ((sr1Flags & 0x10004) == 0)) {\n        I2C_MasterReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((sr1Flags & 0x10004) != 0) && ((cr2Flags & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(i2cHandle);\n        return;\n      }\n    }\n    else {\n      if ((((sr1Flags & 0x10080) != 0) && ((cr2Flags & 0x400) != 0)) && ((sr1Flags & 0x10004) == 0)) {\n        I2C_MasterTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((sr1Flags & 0x10004) != 0) && ((cr2Flags & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  else {\n    if (((sr1Flags & 0x10002) != 0) && ((cr2Flags & 0x200) != 0)) {\n      I2C_Slave_ADDR(i2cHandle);\n      return;\n    }\n    if (((sr1Flags & 0x10010) != 0) && ((cr2Flags & 0x200) != 0)) {\n      I2C_Slave_STOPF(i2cHandle);\n      return;\n    }\n    if ((sr2Flags & 0x100004) == 0) {\n      if ((((sr1Flags & 0x10040) != 0) && ((cr2Flags & 0x400) != 0)) && ((sr1Flags & 0x10004) == 0)) {\n        I2C_SlaveReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((sr1Flags & 0x10004) != 0) && ((cr2Flags & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(i2cHandle);\n      }\n    }\n    else {\n      if ((((sr1Flags & 0x10080) != 0) && ((cr2Flags & 0x400) != 0)) && ((sr1Flags & 0x10004) == 0)) {\n        I2C_SlaveTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((sr1Flags & 0x10004) != 0) && ((cr2Flags & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033b8": "handle_i2_c_status_080033b8",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "CurrentMode": "currentMode",
                "uVar2": "sr1Flags",
                "sr1itflags": "sr1ITFlags",
                "uVar3": "cr2Flags",
                "itsources": "itSources",
                "uVar4": "sr2Flags",
                "sr2itflags": "sr2ITFlags"
            },
            "calling": [
                "I2C1_EV_IRQHandler",
                "I2C2_EV_IRQHandler"
            ],
            "called": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterReceive_BTF",
                "I2C_Master_ADD10",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_BTF",
                "I2C_MasterReceive_RXNE",
                "I2C_SlaveTransmit_TXE",
                "I2C_Master_SB",
                "I2C_SlaveReceive_BTF",
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF",
                "I2C_Master_ADDR",
                "I2C_MasterTransmit_TXE"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003520": {
            "entrypoint": "0x08003520",
            "current_name": "handle_i2c_errors_08003520",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_i2c_errors_08003520(I2C_HandleTypeDef *I2C_handler)\n\n{\n  HAL_I2C_StateTypeDef i2c_state;\n  I2C_TypeDef *i2c_instance;\n  uint32_t sr1_flags;\n  uint sr1_value;\n  uint32_t itsources;\n  uint cr2_value;\n  \n  i2c_instance = I2C_handler->Instance;\n  sr1_value = i2c_instance->SR1;\n  cr2_value = i2c_instance->CR2;\n  if (((sr1_value & 0x10100) != 0) && ((cr2_value & 0x100) != 0)) {\n    I2C_handler->ErrorCode = I2C_handler->ErrorCode | 1;\n    i2c_instance->SR1 = 0xfffffeff;\n    I2C_handler->Instance->CR1 = I2C_handler->Instance->CR1 | 0x8000;\n  }\n  if (((sr1_value & 0x10200) != 0) && ((cr2_value & 0x100) != 0)) {\n    I2C_handler->ErrorCode = I2C_handler->ErrorCode | 2;\n    I2C_handler->Instance->SR1 = 0xfffffdff;\n  }\n  if (((sr1_value & 0x10400) != 0) && ((cr2_value & 0x100) != 0)) {\n    i2c_state = I2C_handler->State;\n    if (((I2C_handler->Mode == HAL_I2C_MODE_SLAVE) && (I2C_handler->XferCount == 0)) &&\n       (((i2c_state == HAL_I2C_STATE_BUSY_TX || (i2c_state == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((i2c_state == HAL_I2C_STATE_LISTEN && (I2C_handler->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(I2C_handler);\n    }\n    else {\n      I2C_handler->ErrorCode = I2C_handler->ErrorCode | 4;\n      if (I2C_handler->Mode == HAL_I2C_MODE_MASTER) {\n        I2C_handler->Instance->CR1 = I2C_handler->Instance->CR1 | 0x200;\n      }\n      I2C_handler->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((sr1_value & 0x10800) != 0) && ((cr2_value & 0x100) != 0)) {\n    I2C_handler->ErrorCode = I2C_handler->ErrorCode | 8;\n    I2C_handler->Instance->SR1 = 0xfffff7ff;\n  }\n  if (I2C_handler->ErrorCode != 0) {\n    I2C_ITError(I2C_handler);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003520": "handle_i2c_errors_08003520",
                "hi2c": "I2C_handler",
                "HVar1": "i2c_state",
                "pIVar2": "i2c_instance",
                "sr1itflags": "sr1_flags",
                "uVar3": "sr1_value",
                "uVar4": "cr2_value"
            },
            "calling": [
                "I2C1_ER_IRQHandler",
                "I2C2_ER_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fc": {
            "entrypoint": "0x080035fc",
            "current_name": "reset_i2_c_080035fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetI2C_080035fc(DMA_HandleTypeDef *dmaHandle)\n\n{\n  I2C_HandleTypeDef *i2cHandleParent;\n  I2C_HandleTypeDef *i2cHandle;\n  \n  i2cHandleParent = (I2C_HandleTypeDef *)dmaHandle->i2cParent;\n  i2cHandleParent->i2cInstance->controlRegister1 = i2cHandleParent->i2cInstance->controlRegister1 & 0xfffffbff;\n  i2cHandleParent->transferCount = 0;\n  i2cHandleParent->dmaTransmitHandle->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  i2cHandleParent->dmaReceiveHandle->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  if (i2cHandleParent->i2cState != HAL_I2C_STATE_ABORT) {\n    i2cHandleParent->i2cState = HAL_I2C_STATE_READY;\n    i2cHandleParent->Mode = HAL_I2C_MODE_NONE;\n    i2cHandleParent->i2cInstance->controlRegister1 = i2cHandleParent->i2cInstance->controlRegister1 & 0xfffffffe;\n    i2cErrorCallback(i2cHandleParent);\n    return;\n  }\n  i2cHandleParent->i2cState = HAL_I2C_STATE_READY;\n  i2cHandleParent->Mode = HAL_I2C_MODE_NONE;\n  i2cHandleParent->i2cErrorCode = 0;\n  i2cHandleParent->i2cInstance->controlRegister1 = i2cHandleParent->i2cInstance->controlRegister1 & 0xfffffffe;\n  i2cAbortCompleteCallback(i2cHandleParent);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fc": "reset_i2_c_080035fc",
                "hdma": "dmaHandle",
                "hi2c_00": "i2cHandleParent",
                "hi2c": "i2cHandle",
                "Parent": "i2cParent",
                "Instance": "i2cInstance",
                "CR1": "controlRegister1",
                "XferCount": "transferCount",
                "hdmatx": "dmaTransmitHandle",
                "hdmarx": "dmaReceiveHandle",
                "State": "i2cState",
                "ErrorCode": "i2cErrorCode",
                "HAL_I2C_ErrorCallback": "i2cErrorCallback",
                "HAL_I2C_AbortCpltCallback": "i2cAbortCompleteCallback"
            },
            "calling": [],
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800365c": {
            "entrypoint": "0x0800365c",
            "current_name": "delay_function_0800365c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid delayFunction_0800365c(uint32_t milliseconds)\n\n{\n  bool isDelayNotZero;\n  uint32_t totalDelay;\n  \n  totalDelay = milliseconds * (SystemCoreClock / 8000);\n  do {\n    isDelayNotZero = totalDelay != 0;\n    totalDelay = totalDelay - 1;\n  } while (isDelayNotZero);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800365c": "delay_function_0800365c",
                "mdelay": "milliseconds",
                "Delay": "totalDelay",
                "bVar1": "isDelayNotZero"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003688": {
            "entrypoint": "0x08003688",
            "current_name": "initialize_rcc_oscillators_08003688",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initialize_RCC_Oscillators_08003688(RCC_OscInitTypeDef_conflict *oscillator_configuration)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t current_tick;\n  uint32_t start_tick;\n  bool is_bVar4;\n  uint32_t temporary_register;\n  \n  if ((oscillator_configuration->OscillatorType & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) != 0)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (oscillator_configuration->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      start_tick = oscillator_configuration->HSEState;\n      if (start_tick == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (start_tick == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (start_tick == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (oscillator_configuration->HSEState == 0) {\n        start_tick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          current_tick = HAL_GetTick();\n          if (100 < current_tick - start_tick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        start_tick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          current_tick = HAL_GetTick();\n          if (100 < current_tick - start_tick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscillator_configuration->OscillatorType & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (oscillator_configuration->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | oscillator_configuration->HSICalibrationValue << 3;\n    }\n    else if (oscillator_configuration->HSIState == 0) {\n      _DAT_42420000 = 0;\n      start_tick = HAL_GetTick();\n      while ((_DAT_40021000 & 2) != 0) {\n        current_tick = HAL_GetTick();\n        if (2 < current_tick - start_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      start_tick = HAL_GetTick();\n      while ((_DAT_40021000 & 2) == 0) {\n        current_tick = HAL_GetTick();\n        if (2 < current_tick - start_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | oscillator_configuration->HSICalibrationValue << 3;\n    }\n  }\n  if ((oscillator_configuration->OscillatorType & 8) != 0) {\n    if (oscillator_configuration->LSIState == 0) {\n      _DAT_42420480 = 0;\n      start_tick = HAL_GetTick();\n      while ((_DAT_40021024 & 2) != 0) {\n        current_tick = HAL_GetTick();\n        if (2 < current_tick - start_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      start_tick = HAL_GetTick();\n      while ((_DAT_40021024 & 2) == 0) {\n        current_tick = HAL_GetTick();\n        if (2 < current_tick - start_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((oscillator_configuration->OscillatorType & 4) != 0) {\n    is_bVar4 = (_DAT_4002101c & 0x10000000) == 0;\n    if (is_bVar4) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      start_tick = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        current_tick = HAL_GetTick();\n        if (100 < current_tick - start_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    start_tick = oscillator_configuration->LSEState;\n    if (start_tick == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (start_tick == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (start_tick == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (oscillator_configuration->LSEState == 0) {\n      start_tick = HAL_GetTick();\n      while ((_DAT_40021020 & 2) != 0) {\n        current_tick = HAL_GetTick();\n        if (5000 < current_tick - start_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      start_tick = HAL_GetTick();\n      while ((_DAT_40021020 & 2) == 0) {\n        current_tick = HAL_GetTick();\n        if (5000 < current_tick - start_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (is_bVar4) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  start_tick = (oscillator_configuration->PLL).PLLState;\n  if (start_tick == 0) {\n    status = HAL_OK;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    status = HAL_ERROR;\n  }\n  else if (start_tick == 2) {\n    _DAT_42420060 = 0;\n    start_tick = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if ((oscillator_configuration->PLL).PLLSource == 0x10000) {\n          _DAT_40021004 = _DAT_40021004 & 0xfffdffff | oscillator_configuration->HSEPredivValue;\n        }\n        _DAT_40021004 =\n             _DAT_40021004 & 0xffc2ffff |\n             (oscillator_configuration->PLL).PLLSource | (oscillator_configuration->PLL).PLLMUL;\n        _DAT_42420060 = 1;\n        start_tick = HAL_GetTick();\n        do {\n          if ((_DAT_40021000 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          current_tick = HAL_GetTick();\n        } while (current_tick - start_tick < 3);\n        return HAL_TIMEOUT;\n      }\n      current_tick = HAL_GetTick();\n    } while (current_tick - start_tick < 3);\n    status = HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42420060 = 0;\n    start_tick = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      current_tick = HAL_GetTick();\n    } while (current_tick - start_tick < 3);\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003688": "initialize_rcc_oscillators_08003688",
                "RCC_OscInitStruct": "oscillator_configuration",
                "HVar1": "status",
                "uVar2": "current_tick",
                "uVar3": "start_tick",
                "bVar4": "is_bVar4",
                "tmpreg": "temporary_register"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a68": {
            "entrypoint": "0x08003a68",
            "current_name": "calculate_clock_frequency_08003a68",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateClockFrequency_08003a68(void)\n\n{\n  uint32_t clockFrequency;\n  uint8_t predivFactorTable [2];\n  uint8_t pllMulFactorTable [16];\n  \n  pllMulFactorTable[12] = '\\x0e';\n  pllMulFactorTable[13] = '\\x0f';\n  pllMulFactorTable[14] = '\\x10';\n  pllMulFactorTable[15] = '\\x10';\n  pllMulFactorTable[8] = '\\n';\n  pllMulFactorTable[9] = '\\v';\n  pllMulFactorTable[10] = '\\f';\n  pllMulFactorTable[11] = '\\r';\n  pllMulFactorTable[4] = '\\x06';\n  pllMulFactorTable[5] = '\\a';\n  pllMulFactorTable[6] = '\\b';\n  pllMulFactorTable[7] = '\\t';\n  pllMulFactorTable[0] = '\\x02';\n  pllMulFactorTable[1] = '\\x03';\n  pllMulFactorTable[2] = '\\x04';\n  pllMulFactorTable[3] = '\\x05';\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 8) {\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      clockFrequency = (uint)pllMulFactorTable[(_DAT_40021004 << 10) >> 0x1c] * 4000000;\n    }\n    else {\n      clockFrequency = ((uint)pllMulFactorTable[(_DAT_40021004 << 10) >> 0x1c] * 8000000) /\n              (uint)predivFactorTable[-((int)(_DAT_40021004 << 0xe) >> 0x1f)];\n    }\n  }\n  else {\n    clockFrequency = 8000000;\n  }\n  return clockFrequency;\n}\n\n",
            "renaming": {
                "FUN_08003a68": "calculate_clock_frequency_08003a68",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable",
                "uVar1": "clockFrequency"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ad4": {
            "entrypoint": "0x08003ad4",
            "current_name": "initialize_clocks_08003ad4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_Status\ninitializeClocks_08003ad4(RCC_ClkInitTypeDef_conflict *clockInitStruct,uint32_t flashLatency)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  if ((_DAT_40022000 & 7) < flashLatency) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency;\n    if (flashLatency != (flashLatency & 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((clockInitStruct->ClockType & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffff0f | clockInitStruct->AHBCLKDivider;\n  }\n  if ((clockInitStruct->ClockType & 1) != 0) {\n    uVar3 = clockInitStruct->SYSCLKSource;\n    if (uVar3 == 1) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((uVar3 != 2) && ((_DAT_40021000 & 2) == 0)) {\n      return HAL_ERROR;\n    }\n    _DAT_40021004 = uVar3 | _DAT_40021004 & 0xfffffffc;\n    uVar1 = getTick();\n    if (clockInitStruct->SYSCLKSource == 1) {\n      while ((_DAT_40021004 & 0xc) != 4) {\n        uVar2 = getTick();\n        if (5000 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else if (clockInitStruct->SYSCLKSource == 2) {\n      while ((_DAT_40021004 & 0xc) != 8) {\n        uVar2 = getTick();\n        if (5000 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      while ((_DAT_40021004 & 0xc) != 0) {\n        uVar2 = getTick();\n        if (5000 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if (flashLatency < (_DAT_40022000 & 7)) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency;\n    if (flashLatency != (flashLatency & 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((clockInitStruct->ClockType & 4) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | clockInitStruct->APB1CLKDivider;\n  }\n  if ((clockInitStruct->ClockType & 8) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | clockInitStruct->APB2CLKDivider << 3;\n  }\n  uVar1 = getSysClockFreq();\n  sysCoreClock = uVar1 >> \"\"[(_DAT_40021004 << 0x18) >> 0x1c];\n  initTick(0xf);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08003ad4": "initialize_clocks_08003ad4",
                "FLatency": "flashLatency",
                "HAL_StatusTypeDef_conflict": "HAL_Status",
                "RCC_ClkInitStruct": "clockInitStruct",
                "HAL_GetTick": "getTick",
                "SystemCoreClock": "sysCoreClock",
                "HAL_RCC_GetSysClockFreq": "getSysClockFreq",
                "HAL_InitTick": "initTick"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c44": {
            "entrypoint": "0x08003c44",
            "current_name": "get_system_core_clock_08003c44",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08003c44(void)\n\n{\n  return systemCoreClock;\n}\n\n",
            "renaming": {
                "FUN_08003c44": "get_system_core_clock_08003c44",
                "SystemCoreClock": "systemCoreClock"
            },
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c50": {
            "entrypoint": "0x08003c50",
            "current_name": "calculate_hclk_frequency_08003c50",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateHCLKFrequency_08003c50(void)\n\n{\n  uint32_t hclkFrequency;\n  \n  hclkFrequency = HAL_RCC_GetHCLKFreq();\n  return hclkFrequency >> \"\"[(uint)(_DAT_40021004 << 0x15) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08003c50": "calculate_hclk_frequency_08003c50",
                "uVar1": "hclkFrequency"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c70": {
            "entrypoint": "0x08003c70",
            "current_name": "get_hclk_frequency_08003c70",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_HCLK_frequency_08003c70(void)\n\n{\n  uint32_t frequency;\n  \n  frequency = HAL_RCC_GetHCLKFreq();\n  return frequency >> \"\"[(uint)(_DAT_40021004 << 0x12) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08003c70": "get_hclk_frequency_08003c70",
                "uVar1": "frequency"
            },
            "calling": [
                "UART_SetConfig",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c90": {
            "entrypoint": "0x08003c90",
            "current_name": "configure_periph_clocks_08003c90",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configurePeriphClocks_08003c90(RCC_PeriphCLKInitTypeDef_conflict *peripheralClockInit)\n\n{\n  uint tempVar1;\n  uint tempVar2;\n  uint32_t tempVar3;\n  uint32_t tempVar4;\n  bool flag;\n  uint32_t temporaryRegister;\n  \n  if ((peripheralClockInit->PeriphClockSelection & 1) != 0) {\n    flag = (_DAT_4002101c & 0x10000000) == 0;\n    if (flag) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      tempVar3 = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        tempVar4 = HAL_GetTick();\n        if (100 < tempVar4 - tempVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (((_DAT_40021020 & 0x300) != 0) &&\n       ((_DAT_40021020 & 0x300) != (peripheralClockInit->RTCClockSelection & 0x300))) {\n      tempVar2 = _DAT_40021020 & 0xfffffcff;\n      _DAT_42420440 = 0;\n      tempVar1 = _DAT_40021020 & 1;\n      _DAT_40021020 = tempVar2;\n      if (tempVar1 != 0) {\n        tempVar3 = HAL_GetTick();\n        while ((_DAT_40021020 & 2) == 0) {\n          tempVar4 = HAL_GetTick();\n          if (5000 < tempVar4 - tempVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    _DAT_40021020 = _DAT_40021020 & 0xfffffcff | peripheralClockInit->RTCClockSelection;\n    if (flag) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if ((peripheralClockInit->PeriphClockSelection & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffff3fff | peripheralClockInit->AdcClockSelection;\n  }\n  if ((peripheralClockInit->PeriphClockSelection & 0x10) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffbfffff | peripheralClockInit->UsbClockSelection;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08003c90": "configure_periph_clocks_08003c90",
                "PeriphClkInit": "peripheralClockInit",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "bVar5": "flag",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003da4": {
            "entrypoint": "0x08003da4",
            "current_name": "calculate_periph_clk_08003da4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculatePeriphClk_08003da4(uint32_t peripheralClock)\n\n{\n  uint32_t result;\n  uint divisor;\n  uint8_t predivFactorTable [2];\n  uint8_t pllMulFactorTable [16];\n  \n  pllMulFactorTable[12] = '\\x0e';\n  pllMulFactorTable[13] = '\\x0f';\n  pllMulFactorTable[14] = '\\x10';\n  pllMulFactorTable[15] = '\\x10';\n  pllMulFactorTable[8] = '\\n';\n  pllMulFactorTable[9] = '\\v';\n  pllMulFactorTable[10] = '\\f';\n  pllMulFactorTable[11] = '\\r';\n  pllMulFactorTable[4] = '\\x06';\n  pllMulFactorTable[5] = '\\a';\n  pllMulFactorTable[6] = '\\b';\n  pllMulFactorTable[7] = '\\t';\n  pllMulFactorTable[0] = '\\x02';\n  pllMulFactorTable[1] = '\\x03';\n  pllMulFactorTable[2] = '\\x04';\n  pllMulFactorTable[3] = '\\x05';\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if (peripheralClock == 2) {\n    result = HAL_RCC_GetPCLK2Freq();\n    result = result / ((((_DAT_40021004 << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (peripheralClock == 0x10) {\n    if ((_DAT_40021000 & 0x1000000) == 0) {\n      result = 0;\n    }\n    else {\n      if ((_DAT_40021004 & 0x10000) == 0) {\n        divisor = 4000000;\n      }\n      else {\n        divisor = 8000000 / predivFactorTable[-((int)(_DAT_40021004 << 0xe) >> 0x1f)];\n      }\n      result = divisor * pllMulFactorTable[(_DAT_40021004 << 10) >> 0x1c];\n      if ((_DAT_40021004 & 0x400000) == 0) {\n        result = (result * 2) / 3;\n      }\n    }\n  }\n  else if (peripheralClock == 1) {\n    if ((_DAT_40021020 & 0x302) == 0x102) {\n      result = 0x8000;\n    }\n    else if (((_DAT_40021020 & 0x300) == 0x200) && ((_DAT_40021024 & 2) != 0)) {\n      result = 32000;\n    }\n    else if ((_DAT_40021020 & 0x300) == 0x300) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        result = 0;\n      }\n      else {\n        result = 0xf424;\n      }\n    }\n    else {\n      result = 0;\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003da4": "calculate_periph_clk_08003da4",
                "PeriphClk": "peripheralClock",
                "uVar1": "result",
                "uVar2": "divisor",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable"
            },
            "calling": [
                "HAL_ADC_PollForConversion",
                "HAL_ADCEx_Calibration_Start"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ea0": {
            "entrypoint": "0x08003ea0",
            "current_name": "initialize_rtc_08003ea0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_RTC_08003ea0(RTC_HandleTypeDef *RTC_handler)\n\n{\n  if (((RTC_handler->RTC_Instance->RTC_CRH & 2) != 0) && ((RTC_handler->RTC_Instance->RTC_CRL & 2) != 0)) {\n    handle_RTC_AlarmAEventCallback(RTC_handler);\n    RTC_handler->RTC_Instance->RTC_CRL = 0xfffffffd;\n  }\n  _DAT_40010414 = 0x20000;\n  RTC_handler->RTC_State = HAL_RTC_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ea0": "initialize_rtc_08003ea0",
                "hrtc": "RTC_handler",
                "Instance": "RTC_Instance",
                "CRH": "RTC_CRH",
                "CRL": "RTC_CRL",
                "HAL_RTC_AlarmAEventCallback": "handle_RTC_AlarmAEventCallback",
                "State": "RTC_State"
            },
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ed8": {
            "entrypoint": "0x08003ed8",
            "current_name": "reset_tim_instance_08003ed8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef resetTimInstance_08003ed8(TIM_HandleTypeDef *timHandle)\n\n{\n  TIM_TypeDef *timInstance;\n  \n  timHandle->State = TIM_STATE_BUSY;\n  timInstance = timHandle->Instance;\n  if (((timInstance->CCER & 0x1111) == 0) && ((timInstance->CCER & 0x444) == 0)) {\n    timInstance->CR1 = timInstance->CR1 & 0xfffffffe;\n  }\n  deinitializeTimPWM(timHandle);\n  timHandle->State = TIM_STATE_RESET;\n  timHandle->Lock = TIM_UNLOCKED;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08003ed8": "reset_tim_instance_08003ed8",
                "htim": "timHandle",
                "pTVar1": "timInstance",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_TIM_STATE_BUSY": "TIM_STATE_BUSY",
                "HAL_TIM_STATE_RESET": "TIM_STATE_RESET",
                "HAL_UNLOCKED": "TIM_UNLOCKED",
                "HAL_TIM_PWM_MspDeInit": "deinitializeTimPWM"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f12": {
            "entrypoint": "0x08003f12",
            "current_name": "FUNC_08003f12",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f12(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f12": "FUNC_08003f12"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f14": {
            "entrypoint": "0x08003f14",
            "current_name": "FUNC_08003f14",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f14(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f14": "FUNC_08003f14"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f16": {
            "entrypoint": "0x08003f16",
            "current_name": "FUNC_08003f16",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f16(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f16": "FUNC_08003f16"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "process_timer_interrupt_08003f18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processTimerInterrupt_08003f18(TIM_HandleTypeDef *timerHandle)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 2) != 0) && ((timerInstance->DIER & 2) != 0)) {\n    timerInstance->SR = 0xfffffffd;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((timerHandle->Instance->CCMR1 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 4) != 0) && ((timerInstance->DIER & 4) != 0)) {\n    timerInstance->SR = 0xfffffffb;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((timerHandle->Instance->CCMR1 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 8) != 0) && ((timerInstance->DIER & 8) != 0)) {\n    timerInstance->SR = 0xfffffff7;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((timerHandle->Instance->CCMR2 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 0x10) != 0) && ((timerInstance->DIER & 0x10) != 0)) {\n    timerInstance->SR = 0xffffffef;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((timerHandle->Instance->CCMR2 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 1) != 0) && ((timerInstance->DIER & 1) != 0)) {\n    timerInstance->SR = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(timerHandle);\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 0x80) != 0) && ((timerInstance->DIER & 0x80) != 0)) {\n    timerInstance->SR = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(timerHandle);\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 0x40) != 0) && ((timerInstance->DIER & 0x40) != 0)) {\n    timerInstance->SR = 0xffffffbf;\n    HAL_TIM_TriggerCallback(timerHandle);\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 0x20) != 0) && ((timerInstance->DIER & 0x20) != 0)) {\n    timerInstance->SR = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(timerHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "process_timer_interrupt_08003f18",
                "htim": "timerHandle",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "TIM1_UP_IRQHandler",
                "TIM3_IRQHandler",
                "TIM4_IRQHandler",
                "TIM2_IRQHandler"
            ],
            "called": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_PWM_PulseFinishedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004092": {
            "entrypoint": "0x08004092",
            "current_name": "configure_timer_channel_08004092",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerChannel_08004092(TIM_TypeDef *timer,uint32_t channelNumber,uint32_t newChannelState)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channelNumber & 0xff));\n  timer->CCER = timer->CCER | newChannelState << (channelNumber & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004092": "configure_timer_channel_08004092",
                "TIMx": "timer",
                "Channel": "channelNumber",
                "ChannelState": "newChannelState"
            },
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040b0": {
            "entrypoint": "0x080040b0",
            "current_name": "configure_tim_channel_080040b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureTimChannel_080040b0(TIM_HandleTypeDef *timerHandle,uint32_t channel)\n\n{\n  TIM_TypeDef *timInstance;\n  \n  TIM_CCxchannelCmd(timerHandle->Instance,channel,0);\n  if (((timerHandle->Instance == (TIM_TypeDef *)0x40012c00) && ((uRam40012c20 & 0x1111) == 0)) &&\n     ((uRam40012c20 & 0x444) == 0)) {\n    uRam40012c44 = uRam40012c44 & 0xffff7fff;\n  }\n  timInstance = timerHandle->Instance;\n  if (((timInstance->CCER & 0x1111) == 0) && ((timInstance->CCER & 0x444) == 0)) {\n    timInstance->CR1 = timInstance->CR1 & 0xfffffffe;\n  }\n  timerHandle->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080040b0": "configure_tim_channel_080040b0",
                "htim": "timerHandle",
                "Channel": "channel",
                "pTVar1": "timInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004110": {
            "entrypoint": "0x08004110",
            "current_name": "configure_timer_channel_08004110",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerChannel_08004110(TIM_TypeDef *timer,uint32_t channel,uint32_t channelState)\n\n{\n  timer->CCER = timer->CCER & ~(4 << (channel & 0xff));\n  timer->CCER = timer->CCER | channelState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004110": "configure_timer_channel_08004110",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "channelState"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800412c": {
            "entrypoint": "0x0800412c",
            "current_name": "disable_tim_channel_0800412c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict disableTimChannel_0800412c(TIM_HandleTypeDef *timer,uint32_t channel)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxNchannelCmd(timer->Instance,channel,0);\n  timerInstance = timer->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800412c": "disable_tim_channel_0800412c",
                "htim": "timer",
                "Channel": "channel",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004178": {
            "entrypoint": "0x08004178",
            "current_name": "FUNC_08004178",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004178(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004178": "FUNC_08004178"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800417a": {
            "entrypoint": "0x0800417a",
            "current_name": "FUNC_0800417a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800417a(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800417a": "FUNC_0800417a"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800417c": {
            "entrypoint": "0x0800417c",
            "current_name": "reset_uart_instance_configuration_0800417c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_uart_instance_configuration_0800417c(UART_HandleTypeDef *uart_handle)\n\n{\n  uart_handle->uart_instance->control_register_1 = uart_handle->uart_instance->control_register_1 & 0xfffffedf;\n  uart_handle->uart_instance->control_register_3 = uart_handle->uart_instance->control_register_3 & 0xfffffffe;\n  uart_handle->receive_state = HAL_UART_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800417c": "reset_uart_instance_configuration_0800417c",
                "huart": "uart_handle",
                "Instance": "uart_instance",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "RxState": "receive_state"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004198": {
            "entrypoint": "0x08004198",
            "current_name": "transmit_data_08004198",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict transmitData_08004198(UART_HandleTypeDef *UART_handle)\n\n{\n  uint16_t count;\n  byte *bufferPointer;\n  uint16_t *tmpPointer;\n  \n  if (UART_handle->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((UART_handle->Init).WordLength == 0x1000) {\n    UART_handle->Instance->DR = *(ushort *)UART_handle->pTxBuffPtr & 0x1ff;\n    if ((UART_handle->Init).Parity == 0) {\n      UART_handle->pTxBuffPtr = UART_handle->pTxBuffPtr + 2;\n    }\n    else {\n      UART_handle->pTxBuffPtr = UART_handle->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    bufferPointer = UART_handle->pTxBuffPtr;\n    UART_handle->pTxBuffPtr = bufferPointer + 1;\n    UART_handle->Instance->DR = (uint)*bufferPointer;\n  }\n  count = UART_handle->TxXferCount - 1;\n  UART_handle->TxXferCount = count;\n  if (count == 0) {\n    UART_handle->Instance->CR1 = UART_handle->Instance->CR1 & 0xffffff7f;\n    UART_handle->Instance->CR1 = UART_handle->Instance->CR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004198": "transmit_data_08004198",
                "huart": "UART_handle",
                "uVar1": "count",
                "pbVar2": "bufferPointer",
                "tmp": "tmpPointer"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004204": {
            "entrypoint": "0x08004204",
            "current_name": "initialize_uart_08004204",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeUart_08004204(UART_HandleTypeDef *uartHandle)\n\n{\n  uint32_t sysClockFreq;\n  uint32_t sysClockFreq;\n  uint32_t sysClockFreq;\n  uint32_t sysClockFreq;\n  uint32_t sysClockFreq;\n  uint32_t baudRate;\n  uint32_t baudRate;\n  uint32_t baudRate;\n  uint32_t baudRate;\n  USART_TypeDef *uartInstance;\n  \n  uartHandle->Instance->CR2 = uartHandle->Instance->CR2 & 0xffffcfff | (uartHandle->Init).StopBits;\n  uartHandle->Instance->CR1 =\n       (uartHandle->Init).WordLength | (uartHandle->Init).Parity | (uartHandle->Init).Mode |\n       uartHandle->Instance->CR1 & 0xffffe9f3;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffcff | (uartHandle->Init).HwFlowCtl;\n  uartInstance = uartHandle->Instance;\n  if (uartInstance != (USART_TypeDef *)0x40013800) {\n    sysClockFreq = HAL_RCC_GetPCLK1Freq();\n    baudRate = (uartHandle->Init).BaudRate;\n    sysClockFreq = HAL_RCC_GetPCLK1Freq();\n    baudRate = (uartHandle->Init).BaudRate;\n    sysClockFreq = HAL_RCC_GetPCLK1Freq();\n    baudRate = (uartHandle->Init).BaudRate;\n    sysClockFreq = HAL_RCC_GetPCLK1Freq();\n    baudRate = (uartHandle->Init).BaudRate;\n    sysClockFreq = HAL_RCC_GetPCLK1Freq();\n    uartInstance->BRR = ((uint)((int)((ulonglong)\n                                 (((sysClockFreq * 0x19) / (baudRate << 2) +\n                                  (int)(((ulonglong)(sysClockFreq * 0x19) /\n                                        (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                   ((((sysClockFreq * 0x19) / (baudRate << 2) +\n                     (int)(((ulonglong)(sysClockFreq * 0x19) / (ulonglong)(baudRate << 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 & 0xf0) +\n                   (int)(((ulonglong)(sysClockFreq * 0x19) / (ulonglong)(baudRate << 2)) / 100) * 0x10;\n    return;\n  }\n  sysClockFreq = HAL_RCC_GetPCLK2Freq();\n  baudRate = (uartHandle->Init).BaudRate;\n  sysClockFreq = HAL_RCC_GetPCLK2Freq();\n  baudRate = (uartHandle->Init).BaudRate;\n  sysClockFreq = HAL_RCC_GetPCLK2Freq();\n  baudRate = (uartHandle->Init).BaudRate;\n  sysClockFreq = HAL_RCC_GetPCLK2Freq();\n  baudRate = (uartHandle->Init).BaudRate;\n  sysClockFreq = HAL_RCC_GetPCLK2Freq();\n  iRam40013808 = ((uint)((int)((ulonglong)\n                               (((sysClockFreq * 0x19) / (baudRate << 2) +\n                                (int)(((ulonglong)(sysClockFreq * 0x19) /\n                                      (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                 ((((sysClockFreq * 0x19) / (baudRate << 2) +\n                   (int)(((ulonglong)(sysClockFreq * 0x19) / (ulonglong)(baudRate << 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 & 0xf0) +\n                 (int)(((ulonglong)(sysClockFreq * 0x19) / (ulonglong)(baudRate << 2)) / 100) * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004204": "initialize_uart_08004204",
                "huart": "uartHandle",
                "uVar1": "sysClockFreq",
                "uVar2": "sysClockFreq",
                "uVar3": "sysClockFreq",
                "uVar4": "sysClockFreq",
                "uVar5": "sysClockFreq",
                "uVar6": "baudRate",
                "uVar7": "baudRate",
                "uVar8": "baudRate",
                "uVar9": "baudRate",
                "pUVar10": "uartInstance"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043b4": {
            "entrypoint": "0x080043b4",
            "current_name": "check_flag_status_080043b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_statusTypeDef_conflict\ncheckFlagStatus_080043b4(UART_HandleTypeDef *uartHandle,uint32_t flag,flagstatus status,uint32_t tickStart,\n            uint32_t timeout)\n\n{\n  uint32_t tickDiff;\n  \n  do {\n    if (((flag & ~uartHandle->Instance->SR) == 0) != (bool)status) {\n      return HAL_OK;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (tickDiff = HAL_GetTick(), tickDiff - tickStart <= timeout))));\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n  uartHandle->gState = HAL_UART_STATE_READY;\n  uartHandle->RxState = HAL_UART_STATE_READY;\n  uartHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_080043b4": "check_flag_status_080043b4",
                "huart": "uartHandle",
                "Flag": "flag",
                "Status": "status",
                "Tickstart": "tickStart",
                "Timeout": "timeout",
                "uVar1": "tickDiff"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004418": {
            "entrypoint": "0x08004418",
            "current_name": "FUNC_08004418",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004418(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004418": "FUNC_08004418"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800441a": {
            "entrypoint": "0x0800441a",
            "current_name": "initialize_uart_0800441a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nUART_InitStatus initializeUART_0800441a(UART_HandleTypeDef *uartHandle)\n\n{\n  if (uartHandle != (UART_HandleTypeDef *)0x0) {\n    if (uartHandle->globalState == HAL_UART_STATE_RESET) {\n      uartHandle->lockState = HAL_UNLOCKED;\n      HAL_UART_MspInit(uartHandle);\n    }\n    uartHandle->globalState = HAL_UART_STATE_BUSY;\n    uartHandle->uartInstance->uartCR1 = uartHandle->uartInstance->uartCR1 & 0xffffdfff;\n    UART_SetConfig(uartHandle);\n    uartHandle->uartInstance->uartCR2 = uartHandle->uartInstance->uartCR2 & 0xffffb7ff;\n    uartHandle->uartInstance->uartCR3 = uartHandle->uartInstance->uartCR3 & 0xffffffd5;\n    uartHandle->uartInstance->uartCR1 = uartHandle->uartInstance->uartCR1 | 0x2000;\n    uartHandle->errorStatus = 0;\n    uartHandle->globalState = HAL_UART_STATE_READY;\n    uartHandle->receiveState = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800441a": "initialize_uart_0800441a",
                "huart": "uartHandle",
                "gState": "globalState",
                "Lock": "lockState",
                "Instance": "uartInstance",
                "CR1": "uartCR1",
                "CR2": "uartCR2",
                "CR3": "uartCR3",
                "ErrorCode": "errorStatus",
                "RxState": "receiveState",
                "HAL_StatusTypeDef_conflict": "UART_InitStatus"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004478": {
            "entrypoint": "0x08004478",
            "current_name": "transmit_data_08004478",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\ntransmitData_08004478(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t tickStart;\n  uint16_t *temporary;\n  \n  if (uartHandle->gState == HAL_UART_STATE_READY) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (uartHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n      tickStart = HAL_GetTick();\n      uartHandle->TxXfersize = size;\n      uartHandle->TxXferCount = size;\n      while (uartHandle->TxXferCount != 0) {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,tickStart,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = *(ushort *)data & 0x1ff;\n          if ((uartHandle->Init).Parity == 0) {\n            data = (uint8_t *)((int)data + 2);\n          }\n          else {\n            data = (uint8_t *)((int)data + 1);\n          }\n        }\n        else {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,tickStart,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = (uint)*data;\n          data = (uint8_t *)((int)data + 1);\n        }\n      }\n      status = UART_WaitOnFlagUntiltimeout(uartHandle,0x40,RESET,tickStart,timeout);\n      if (status == HAL_OK) {\n        uartHandle->gState = HAL_UART_STATE_READY;\n        uartHandle->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08004478": "transmit_data_08004478",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickStart",
                "tmp": "temporary"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800455a": {
            "entrypoint": "0x0800455a",
            "current_name": "initialize_uart_transmission_0800455a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeUartTransmission_0800455a(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size)\n\n{\n  if (uartHandle->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (size == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pTxBuffPtr = data;\n    uartHandle->TxXfersize = size;\n    uartHandle->TxXferCount = size;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_0800455a": "initialize_uart_transmission_0800455a",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size"
            },
            "calling": [
                "uart_attach_tx_callback",
                "HAL_UART_TxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045a2": {
            "entrypoint": "0x080045a2",
            "current_name": "initialize_receive_uart_080045a2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeReceiveUART_080045a2(UART_HandleTypeDef *uartHandle,uint8_t *receiveBuffer,uint16_t bufferSize)\n\n{\n  if (uartHandle->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (receiveBuffer == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (bufferSize == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pRxBuffPtr = receiveBuffer;\n    uartHandle->RxXferbufferSize = bufferSize;\n    uartHandle->RxXferCount = bufferSize;\n    uartHandle->ErrorCode = 0;\n    uartHandle->RxState = HAL_UART_STATE_BUSY_RX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x100;\n    uartHandle->Instance->CR3 = uartHandle->Instance->CR3 | 1;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x20;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_080045a2": "initialize_receive_uart_080045a2",
                "huart": "uartHandle",
                "pData": "receiveBuffer",
                "Size": "bufferSize"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045fe": {
            "entrypoint": "0x080045fe",
            "current_name": "initialize_uart_080045fe",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeUART_080045fe(UART_HandleTypeDef *uartHandle)\n\n{\n  uartHandle->uartInstance->controlRegister1 = uartHandle->uartInstance->controlRegister1 & 0xffffffbf;\n  uartHandle->uartState = HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(uartHandle);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080045fe": "initialize_uart_080045fe",
                "huart": "uartHandle",
                "Instance": "uartInstance",
                "CR1": "controlRegister1",
                "gState": "uartState"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004618": {
            "entrypoint": "0x08004618",
            "current_name": "process_received_data_08004618",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processReceivedData_08004618(UART_HandleTypeDef *uartHandler)\n\n{\n  uint16_t *tmpPointer;\n  byte *bytePointer;\n  uint16_t count;\n  uint8_t *uint8Pointer;\n  \n  if (uartHandler->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((uartHandler->Init).WordLength == 0x1000) {\n    if ((uartHandler->Init).Parity == 0) {\n      *(ushort *)uartHandler->pRxBuffPtr = (ushort)((uartHandler->Instance->DR << 0x17) >> 0x17);\n      uartHandler->pRxBuffPtr = uartHandler->pRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)uartHandler->pRxBuffPtr = (ushort)uartHandler->Instance->DR & 0xff;\n      uartHandler->pRxBuffPtr = uartHandler->pRxBuffPtr + 1;\n    }\n  }\n  else if ((uartHandler->Init).Parity == 0) {\n    uint8Pointer = uartHandler->pRxBuffPtr;\n    uartHandler->pRxBuffPtr = uint8Pointer + 1;\n    *uint8Pointer = (uint8_t)uartHandler->Instance->DR;\n  }\n  else {\n    bytePointer = uartHandler->pRxBuffPtr;\n    uartHandler->pRxBuffPtr = bytePointer + 1;\n    *bytePointer = (byte)uartHandler->Instance->DR & 0x7f;\n  }\n  count = uartHandler->RxXferCount - 1;\n  uartHandler->RxXferCount = count;\n  if (count != 0) {\n    return HAL_OK;\n  }\n  uartHandler->Instance->CR1 = uartHandler->Instance->CR1 & 0xffffffdf;\n  uartHandler->Instance->CR1 = uartHandler->Instance->CR1 & 0xfffffeff;\n  uartHandler->Instance->CR3 = uartHandler->Instance->CR3 & 0xfffffffe;\n  uartHandler->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uartHandler);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004618": "process_received_data_08004618",
                "huart": "uartHandler",
                "tmp": "tmpPointer",
                "pbVar1": "bytePointer",
                "uVar2": "count",
                "puVar3": "uint8Pointer"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046b8": {
            "entrypoint": "0x080046b8",
            "current_name": "handle_uart_080046b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_080046b8(UART_HandleTypeDef *UART_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint CR1_value;\n  uint32_t CR1_its;\n  USART_TypeDef *USART_instance;\n  uint32_t CR3_its;\n  uint cr3_flag;\n  uint SR_value;\n  uint32_t isr_flag;\n  \n  USART_instance = UART_handle->Instance;\n  SR_value = USART_instance->SR;\n  CR1_value = USART_instance->CR1;\n  if ((((SR_value & 0xf) == 0) && ((SR_value & 0x20) != 0)) && ((CR1_value & 0x20) != 0)) {\n    UART_Receive_IT(UART_handle);\n    return;\n  }\n  if (((SR_value & 0xf) == 0) || ((cr3_flag = USART_instance->CR3 & 1, cr3_flag == 0 && ((CR1_value & 0x120) == 0)))) {\n    if (((SR_value & 0x80) != 0) && ((CR1_value & 0x80) != 0)) {\n      UART_Transmit_IT(UART_handle);\n      return;\n    }\n    if (((SR_value & 0x40) != 0) && ((CR1_value & 0x40) != 0)) {\n      UART_EndTransmit_IT(UART_handle);\n    }\n  }\n  else {\n    if (((SR_value & 1) != 0) && ((CR1_value & 0x100) != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 1;\n    }\n    if (((SR_value & 4) != 0) && (cr3_flag != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 2;\n    }\n    if (((SR_value & 2) != 0) && (cr3_flag != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 4;\n    }\n    if (((SR_value & 8) != 0) && (cr3_flag != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 8;\n    }\n    if (UART_handle->ErrorCode != 0) {\n      if (((SR_value & 0x20) != 0) && ((CR1_value & 0x20) != 0)) {\n        UART_Receive_IT(UART_handle);\n      }\n      if (((UART_handle->ErrorCode & 8) == 0) && ((UART_handle->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(UART_handle);\n        UART_handle->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(UART_handle);\n      USART_instance = UART_handle->Instance;\n      if ((USART_instance->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(UART_handle);\n        return;\n      }\n      USART_instance->CR3 = USART_instance->CR3 & 0xffffffbf;\n      if (UART_handle->hdmarx == (DMA_HandleTypeDef *)0x0) {\n        HAL_UART_ErrorCallback(UART_handle);\n        return;\n      }\n      UART_handle->hdmarx->XferAbortCallback = UART_DMAAbortOnError + 1;\n      status = HAL_DMA_Abort_IT(UART_handle->hdmarx);\n      if (status != HAL_OK) {\n        (*UART_handle->hdmarx->XferAbortCallback)(UART_handle->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046b8": "handle_uart_080046b8",
                "huart": "UART_handle",
                "HVar1": "status",
                "uVar2": "CR1_value",
                "uVar4": "cr3_flag",
                "uVar5": "SR_value",
                "pUVar3": "USART_instance",
                "isrflags": "isr_flag",
                "cr1its": "CR1_its",
                "cr3its": "CR3_its"
            },
            "calling": [
                "USART2_IRQHandler",
                "USART3_IRQHandler",
                "USART1_IRQHandler"
            ],
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_UART_ErrorCallback",
                "UART_EndRxTransfer",
                "UART_EndTransmit_IT",
                "UART_Transmit_IT",
                "UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047d8": {
            "entrypoint": "0x080047d8",
            "current_name": "reset_uart_errors_080047d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_uart_errors_080047d8(DMA_HandleTypeDef *dma_handle)\n\n{\n  UART_HandleTypeDef *uart_handle;\n  UART_HandleTypeDef *uart_handle_2;\n  \n  uart_handle = (UART_HandleTypeDef *)dma_handle->Parent;\n  uart_handle->RxXferCount = 0;\n  uart_handle->TxXferCount = 0;\n  HAL_UART_ErrorCallback(uart_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047d8": "reset_uart_errors_080047d8",
                "hdma": "dma_handle",
                "huart_00": "uart_handle",
                "huart": "uart_handle_2"
            },
            "calling": [],
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047e8": {
            "entrypoint": "0x080047e8",
            "current_name": "combine_rx_and_g_state_080047e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef combineRxAndGState_080047e8(UART_HandleTypeDef *uartHandle)\n\n{\n  return uartHandle->rxState | uartHandle->generalState;\n}\n\n",
            "renaming": {
                "FUN_080047e8": "combine_rx_and_g_state_080047e8",
                "huart": "uartHandle",
                "RxState": "rxState",
                "gState": "generalState"
            },
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047f4": {
            "entrypoint": "0x080047f4",
            "current_name": "pin_is_set_080047f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool pinIsSet_080047f4(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint32_t pinValue;\n  \n  pinValue = pinMap[(uint)((int)pinName << 0x18) >> 0x1c];\n  return (_Bool)((byte)(pinValue >> ((int)pinName & 0xfU)) & 1);\n}\n\n",
            "renaming": {
                "FUN_080047f4": "pin_is_set_080047f4",
                "pin": "pinName",
                "map": "pinMap",
                "index": "pinValue"
            },
            "calling": [
                "digitalWrite",
                "digitalRead",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800480a": {
            "entrypoint": "0x0800480a",
            "current_name": "update_mapping_0800480a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateMapping_0800480a(pin pin,uint32_t *mapping)\n\n{\n  uint index;\n  uint32_t index;\n  \n  index = (uint)((int)pin << 0x18) >> 0x1c;\n  mapping[index] = mapping[index] | 1 << ((int)pin & 0xfU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800480a": "update_mapping_0800480a",
                "PinName_conflict": "pin",
                "map": "mapping",
                "uVar1": "index"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004828": {
            "entrypoint": "0x08004828",
            "current_name": "update_pin_map_08004828",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updatePinMap_08004828(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint shiftedIndex;\n  uint32_t originalIndex;\n  \n  shiftedIndex = (uint)((int)pinName << 0x18) >> 0x1c;\n  pinMap[shiftedIndex] = pinMap[shiftedIndex] & ~(1 << ((int)pinName & 0xfU));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004828": "update_pin_map_08004828",
                "pin": "pinName",
                "map": "pinMap",
                "uVar1": "shiftedIndex",
                "index": "originalIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004848": {
            "entrypoint": "0x08004848",
            "current_name": "get_gpio_port_08004848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nGPIO_type * get_GPIO_port_08004848(uint32_t port_index)\n\n{\n  switch(port_index) {\n  case 0:\n    return (GPIO_type *)0x40010800;\n  case 1:\n    return (GPIO_type *)0x40010c00;\n  case 2:\n    return (GPIO_type *)0x40011000;\n  case 3:\n    return (GPIO_type *)0x40011400;\n  case 4:\n    return (GPIO_type *)0x40011800;\n  default:\n    return (GPIO_type *)0x0;\n  }\n}\n\n",
            "renaming": {
                "FUN_08004848": "get_gpio_port_08004848",
                "port_idx": "port_index",
                "GPIO_TypeDef": "GPIO_type"
            },
            "calling": [
                "digitalWrite",
                "digitalRead"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004884": {
            "entrypoint": "0x08004884",
            "current_name": "get_gpio_by_port_index_08004884",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * getGPIOByPortIndex_08004884(uint32_t portIndex)\n\n{\n  GPIO_TypeDef *gpio;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister_1;\n  uint32_t temporaryRegister_2;\n  uint32_t temporaryRegister_3;\n  uint32_t temporaryRegister_4;\n  \n  switch(portIndex) {\n  case 0:\n    _DAT_40021018 = _DAT_40021018 | 4;\n    gpio = (GPIO_TypeDef *)0x40010800;\n    break;\n  case 1:\n    _DAT_40021018 = _DAT_40021018 | 8;\n    gpio = (GPIO_TypeDef *)0x40010c00;\n    break;\n  case 2:\n    _DAT_40021018 = _DAT_40021018 | 0x10;\n    gpio = (GPIO_TypeDef *)0x40011000;\n    break;\n  case 3:\n    _DAT_40021018 = _DAT_40021018 | 0x20;\n    gpio = (GPIO_TypeDef *)0x40011400;\n    break;\n  case 4:\n    _DAT_40021018 = _DAT_40021018 | 0x40;\n    gpio = (GPIO_TypeDef *)0x40011800;\n    break;\n  default:\n    gpio = (GPIO_TypeDef *)0x0;\n  }\n  return gpio;\n}\n\n",
            "renaming": {
                "FUN_08004884": "get_gpio_by_port_index_08004884",
                "port_idx": "portIndex",
                "pGVar1": "gpio",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister_1",
                "tmpreg_2": "temporaryRegister_2",
                "tmpreg_3": "temporaryRegister_3",
                "tmpreg_4": "temporaryRegister_4"
            },
            "calling": [
                "digital_io_init",
                "uart_init",
                "HAL_ADC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800492c": {
            "entrypoint": "0x0800492c",
            "current_name": "get_pin_adc_function_0800492c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getPinADCFunction_0800492c(PinName_conflict pinName)\n\n{\n  uint32_t pinFunction;\n  uint32_t adjustedFunction;\n  \n  pinFunction = pinNamemap_adjustedFunction(pinName,(PinMap_conflict *)&PinMap_ADC);\n  adjustedFunction = pinFunction << 0xc;\n  adjustedFunction = adjustedFunction >> 0x1b;\n  if (0x10 < adjustedFunction - 1) {\n    adjustedFunction = 0;\n  }\n  return adjustedFunction;\n}\n\n",
            "renaming": {
                "FUN_0800492c": "get_pin_adc_function_0800492c",
                "pin": "pinName",
                "uVar1": "pinFunction",
                "function": "adjustedFunction"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004948": {
            "entrypoint": "0x08004948",
            "current_name": "get_pin_function_08004948",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getPinFunction_08004948(pinName pin)\n\n{\n  uint32_t pinFunction;\n  uint32_t shiftedFunction;\n  \n  pinFunction = pinmap_shiftedFunction(pin,(pinMap *)&PinMap_PWM);\n  shiftedFunction = pinFunction << 0xc;\n  shiftedFunction = shiftedFunction >> 0x1b;\n  if (shiftedFunction == 3) {\n    return 8;\n  }\n  if (shiftedFunction != 4) {\n    if (shiftedFunction != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_08004948": "get_pin_function_08004948",
                "PinName_conflict": "pinName",
                "PinMap_conflict": "pinMap",
                "uVar1": "pinFunction",
                "function": "shiftedFunction"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004974": {
            "entrypoint": "0x08004974",
            "current_name": "initialize_adc_08004974",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeADC_08004974(ADC_HandleTypeDef *adcHandle)\n\n{\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *gpioPort;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister_1;\n  GPIO_InitTypeDef gpioInitConfig;\n  \n  if (adcHandle->Instance == (ADC_TypeDef *)0x40012400) {\n    _DAT_40021018 = _DAT_40021018 | 0x200;\n  }\n  else if (adcHandle->Instance == (ADC_TypeDef *)0x40012800) {\n    _DAT_40021018 = _DAT_40021018 | 0x400;\n  }\n  gpioPort = set_GPIO_Port_Clock((uint)((int)g_current_pin << 0x18) >> 0x1c);\n  gpioInitConfig.Pin = 1 << (g_current_pin & 0xfU) & 0xffff;\n  gpioInitConfig.Mode = 3;\n  gpioInitConfig.Pull = 0;\n  HAL_GPIO_Init(gpioPort,&gpioInitConfig);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004974": "initialize_adc_08004974",
                "hadc": "adcHandle",
                "GPIOx": "gpioPort",
                "port": "gpioPort",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister_1",
                "GPIO_InitStruct": "gpioInitConfig"
            },
            "calling": [
                "HAL_ADC_Init"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049f0": {
            "entrypoint": "0x080049f0",
            "current_name": "configure_adc_080049f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureADC_080049f0(ADC_HandleTypeDef *adcHandle)\n\n{\n  if (adcHandle->Instance != (ADC_TypeDef *)0x40012400) {\n    if (adcHandle->Instance == (ADC_TypeDef *)0x40012800) {\n      _DAT_4002100c = _DAT_4002100c & 0xfffffbff;\n      _DAT_40021018 = _DAT_40021018 & 0xfffffbff;\n    }\n    return;\n  }\n  _DAT_4002100c = _DAT_4002100c & 0xfffffdff;\n  _DAT_40021018 = _DAT_40021018 & 0xfffffdff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049f0": "configure_adc_080049f0",
                "hadc": "adcHandle"
            },
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a4c": {
            "entrypoint": "0x08004a4c",
            "current_name": "read_adc_value_08004a4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint16_t readADCValue_08004a4c(pin pin)\n\n{\n  HAL_Status halStatus;\n  uint32_t adcValue;\n  uint16_t convertedValue;\n  ADC_ChannelConfTypeDef AdcChannelConf;\n  ADCHandle AdcHandle;\n  \n  memset(&AdcHandle,0,0x30);\n  AdcChannelConf.Channel = 0;\n  AdcChannelConf.Rank = 0;\n  AdcChannelConf.SamplingTime = 0;\n  convertedValue = 0;\n  ADCInstance = (ADC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_ADC);\n  if (ADCInstance == (ADC_TypeDef *)0x0) {\n    convertedValue = 0;\n  }\n  else {\n    dataAlignment = 0;\n    scanConvMode = 0;\n    continuousConvMode = 0;\n    discontinuousConvMode = 0;\n    externalTrigConv = 0xe0000;\n    ADCState = 0;\n    numOfConversion = 1;\n    numOfDiscConversion = 0;\n    currentPin = pin;\n    halStatus = InitializeADC(&AdcHandle);\n    if (halStatus == HAL_OK) {\n      AdcChannelConf.Channel = getADCChannel(pin);\n      if (AdcChannelConf.Channel < 0x12) {\n        AdcChannelConf.Rank = 1;\n        AdcChannelConf.SamplingTime = 2;\n        halStatus = ConfigureADCChannel(&AdcHandle,&AdcChannelConf);\n        if (halStatus == HAL_OK) {\n          halStatus = StartCalibration(&AdcHandle);\n          if (halStatus == HAL_OK) {\n            halStatus = StartADC(&AdcHandle);\n            if (halStatus == HAL_OK) {\n              halStatus = PollForConversion(&AdcHandle,10);\n              if (halStatus == HAL_OK) {\n                adcValue = GetADCState(&AdcHandle);\n                if ((adcValue & 0x200) != 0) {\n                  adcValue = GetADCValue(&AdcHandle);\n                  convertedValue = (uint16_t)adcValue;\n                }\n                halStatus = StopADC(&AdcHandle);\n                if (halStatus == HAL_OK) {\n                  halStatus = DeinitializeADC(&AdcHandle);\n                  if (halStatus != HAL_OK) {\n                    convertedValue = 0;\n                  }\n                }\n                else {\n                  convertedValue = 0;\n                }\n              }\n              else {\n                convertedValue = 0;\n              }\n            }\n            else {\n              convertedValue = 0;\n            }\n          }\n          else {\n            convertedValue = 0;\n          }\n        }\n        else {\n          convertedValue = 0;\n        }\n      }\n      else {\n        convertedValue = 0;\n      }\n    }\n    else {\n      convertedValue = 0;\n    }\n  }\n  return convertedValue;\n}\n\n",
            "renaming": {
                "FUN_08004a4c": "read_adc_value_08004a4c",
                "PinName_conflict": "pin",
                "HAL_StatusTypeDef_conflict": "HAL_Status",
                "uVar2": "adcValue",
                "uhADCxConvertedValue": "convertedValue",
                "ADC_HandleTypeDef": "ADCHandle",
                "AdcHandle.Instance": "ADCInstance",
                "AdcHandle.Init.DataAlign": "dataAlignment",
                "AdcHandle.Init.ScanConvMode": "scanConvMode",
                "AdcHandle.Init.ContinuousConvMode": "continuousConvMode",
                "AdcHandle.Init.DiscontinuousConvMode": "discontinuousConvMode",
                "AdcHandle.Init.ExternalTrigConv": "externalTrigConv",
                "AdcHandle.State": "ADCState",
                "AdcHandle.Init.NbrOfConversion": "numOfConversion",
                "AdcHandle.Init.NbrOfDiscConversion": "numOfDiscConversion",
                "g_current_pin": "currentPin",
                "HVar1": "halStatus",
                "HAL_ADC_Init": "InitializeADC",
                "get_adc_channel": "getADCChannel",
                "HAL_ADC_ConfigChannel": "ConfigureADCChannel",
                "HAL_ADCEx_Calibration_Start": "StartCalibration",
                "HAL_ADC_Start": "StartADC",
                "HAL_ADC_PollForConversion": "PollForConversion",
                "HAL_ADC_GetState": "GetADCState",
                "HAL_ADC_GetValue": "GetADCValue",
                "HAL_ADC_Stop": "StopADC",
                "HAL_ADC_DeInit": "DeinitializeADC"
            },
            "calling": [
                "analogRead"
            ],
            "called": [
                "HAL_ADC_DeInit",
                "HAL_ADC_GetState",
                "get_adc_channel",
                "HAL_ADC_PollForConversion",
                "HAL_ADC_ConfigChannel",
                "HAL_ADC_GetValue",
                "memset",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Stop",
                "pinmap_peripheral",
                "HAL_ADC_Init",
                "HAL_ADC_Start"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b34": {
            "entrypoint": "0x08004b34",
            "current_name": "disable_timer_clock_08004b34",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableTimerClock_08004b34(TIM_HandleTypeDef *timerHandle)\n\n{\n  timer_disable_clock(timerHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b34": "disable_timer_clock_08004b34",
                "htim": "timerHandle"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b3c": {
            "entrypoint": "0x08004b3c",
            "current_name": "stop_tim_pwm_08004b3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopTimPwm_08004b3c(PinName_conflict pinName)\n\n{\n  uint32_t channel;\n  uint32_t timchannel;\n  uint32_t functionReturnValue;\n  TIM_HandleTypeDef timerHandle;\n  \n  timerHandle.Instance = (TIM_TypeDef *)pinNamemap_peripheral(pinName,(PinMap_conflict *)&PinMap_PWM);\n  if ((timerHandle.Instance != (TIM_TypeDef *)0x0) &&\n     ((((channel = get_pwm_channel(pinName), channel == 0 || (channel == 4)) || (channel == 8)) ||\n      ((channel == 0xc || (channel == 0x18)))))) {\n    functionReturnValue = pinNamemap_function(pinName,(PinMap_conflict *)&PinMap_PWM);\n    if ((functionReturnValue & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timerHandle,channel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timerHandle,channel);\n    }\n    HAL_TIM_PWM_DeInit(&timerHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b3c": "stop_tim_pwm_08004b3c",
                "pin": "pinName",
                "Channel": "channel",
                "uVar1": "functionReturnValue",
                "timHandle": "timerHandle"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_TIM_PWM_DeInit",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop",
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b94": {
            "entrypoint": "0x08004b94",
            "current_name": "get_current_tick_08004b94",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_tick_08004b94(void)\n\n{\n  uint32_t current_tick;\n  \n  current_tick = HAL_GetTick();\n  return current_tick;\n}\n\n",
            "renaming": {
                "FUN_08004b94": "get_current_tick_08004b94",
                "uVar1": "current_tick"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b9c": {
            "entrypoint": "0x08004b9c",
            "current_name": "FUNC_08004b9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004b9c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b9c": "FUNC_08004b9c"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004b9e": {
            "entrypoint": "0x08004b9e",
            "current_name": "handle_sys_tick_interrupt_08004b9e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickInterrupt_08004b9e(void)\n\n{\n  incrementTick();\n  handleSysTick();\n  customSysTickHandler();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b9e": "handle_sys_tick_interrupt_08004b9e",
                "HAL_IncTick": "incrementTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTick",
                "noOsSystickHandler": "customSysTickHandler"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bb0": {
            "entrypoint": "0x08004bb0",
            "current_name": "initialize_pin_08004bb0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializePin_08004bb0(pinName pinName,uint32_t pinMode,uint32_t pullMode)\n\n{\n  uint pinNumber;\n  GPIOType *gpioPort;\n  GPIOType *gpioPort;\n  uint32_t tempRegister2;\n  uint32_t tempRegister1;\n  uint32_t tempRegister;\n  GPIO_InitTypeDef gpioInitStructure;\n  \n  pinNumber = (uint)pinName;\n  gpioPort = set_GPIO_Port_Clock((pinNumber << 0x18) >> 0x1c);\n  gpioInitStructure.Pin = 1 << (pinNumber & 0xf) & 0xffff;\n  gpioInitStructure.Speed = 3;\n  _DAT_40021018 = _DAT_40021018 | 1;\n  if ((pinNumber - 0xd & 0xff) < 2) {\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x4000000;\n  }\n  if (((pinNumber == 0xf) || (pinNumber == 0x13)) || (pinNumber == 0x14)) {\n    tempRegister1 = _DAT_40010004 & 0xf8ffffff;\n    _DAT_40010004 = tempRegister1 | 0x2000000;\n  }\n  gpioInitStructure.Mode = pinMode;\n  gpioInitStructure.Pull = pullMode;\n  HAL_GPIO_Init(gpioPort,&gpioInitStructure);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bb0": "initialize_pin_08004bb0",
                "PinName_conflict": "pinName",
                "GPIO_TypeDef": "GPIOType",
                "pin": "pinName",
                "mode": "pinMode",
                "pull": "pullMode",
                "uVar1": "pinNumber",
                "GPIOx": "gpioPort",
                "port": "gpioPort",
                "tmpreg_2": "tempRegister2",
                "tmpreg_1": "tempRegister1",
                "tmpreg": "tempRegister",
                "GPIO_InitStructure": "gpioInitStructure"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c30": {
            "entrypoint": "0x08004c30",
            "current_name": "set_pin_state_08004c30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_08004c30(GPIO_TypeDef *gpioPort,uint32_t pinNumber,uint32_t state)\n\n{\n  if (state == 0) {\n    HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_SET);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c30": "set_pin_state_08004c30",
                "port": "gpioPort",
                "pin": "pinNumber",
                "val": "state"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c48": {
            "entrypoint": "0x08004c48",
            "current_name": "read_pin_state_08004c48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t readPinState_08004c48(GPIO_TypeDef *gpioPort,uint32_t gpioPin)\n\n{\n  GPIO_PinState pinState;\n  \n  pinState = HAL_GPIO_ReadPin(gpioPort,(uint16_t)gpioPin);\n  return (uint)pinState;\n}\n\n",
            "renaming": {
                "FUN_08004c48": "read_pin_state_08004c48",
                "port": "gpioPort",
                "pin": "gpioPin",
                "GVar1": "pinState"
            },
            "calling": [
                "digitalRead"
            ],
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c52": {
            "entrypoint": "0x08004c52",
            "current_name": "initialize_system_08004c52",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_08004c52(void)\n\n{\n  initializeHardware();\n  configureSystemClock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c52": "initialize_system_08004c52",
                "HAL_Init": "initializeHardware",
                "SystemClock_Config": "configureSystemClock"
            },
            "calling": [
                "init"
            ],
            "called": [
                "HAL_Init",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c5e": {
            "entrypoint": "0x08004c5e",
            "current_name": "find_peripheral_by_pin_08004c5e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * findPeripheralByPin_08004c5e(PinName desiredPin,PinMap *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->desiredPin == NC) {\n      return (void *)0x0;\n    }\n    if (pinMap->desiredPin == desiredPin) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->peripheral;\n}\n\n",
            "renaming": {
                "FUN_08004c5e": "find_peripheral_by_pin_08004c5e",
                "pin": "desiredPin",
                "map": "pinMap",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap"
            },
            "calling": [
                "pinmap_find_peripheral",
                "pinmap_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c78": {
            "entrypoint": "0x08004c78",
            "current_name": "find_peripheral_08004c78",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * find_peripheral_08004c78(PinName_conflict input_pin,PinMap_conflict *pinmap)\n\n{\n  void *peripheral;\n  \n  if (input_pin != NC) {\n    peripheral = input_pinpinmap_find_peripheral_08004c78(input_pin,pinmap);\n    return peripheral;\n  }\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08004c78": "find_peripheral_08004c78",
                "pin": "input_pin",
                "map": "pinmap",
                "pvVar1": "peripheral"
            },
            "calling": [
                "uart_debug_init",
                "adc_read_value",
                "pwm_stop",
                "uart_init",
                "uart_debug_write"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c8a": {
            "entrypoint": "0x08004c8a",
            "current_name": "find_pin_from_peripheral_08004c8a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName findPinFromPeripheral_08004c8a(void *targetPeripheral,PinMap *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPeripheral == (void *)0x0) {\n      return NC;\n    }\n    if (pinMap->targetPeripheral == targetPeripheral) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->pin;\n}\n\n",
            "renaming": {
                "FUN_08004c8a": "find_pin_from_peripheral_08004c8a",
                "peripheral": "targetPeripheral",
                "map": "pinMap",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap"
            },
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ca2": {
            "entrypoint": "0x08004ca2",
            "current_name": "find_pin_for_peripheral_08004ca2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict find_pin_for_peripheral_08004ca2(void *peripheral_ptr,PinMap_conflict *pin_map_ptr)\n\n{\n  PinName_conflict pin_name;\n  \n  if (peripheral_ptr != (void *)0x0) {\n    pin_name = pinpin_map_ptr_find_pin(peripheral_ptr,pin_map_ptr);\n    return pin_name;\n  }\n  return NoConnection;\n}\n\n",
            "renaming": {
                "FUN_08004ca2": "find_pin_for_peripheral_08004ca2",
                "peripheral": "peripheral_ptr",
                "map": "pin_map_ptr",
                "PVar1": "pin_name",
                "NC": "NoConnection"
            },
            "calling": [
                "uart_debug_init",
                "HardwareSerial"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cb2": {
            "entrypoint": "0x08004cb2",
            "current_name": "find_pin_function_08004cb2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t findPinFunction_08004cb2(NotConnectedPJFQDLCX targetPin,pinMap *currentPinMap)\n\n{\n  while( true ) {\n    if (currentPinMap->targetPin == NotConnected) {\n      return 0xffffffff;\n    }\n    if (currentPinMap->targetPin == targetPin) break;\n    currentPinMap = currentPinMap + 1;\n  }\n  return currentPinMap->pinFunction;\n}\n\n",
            "renaming": {
                "FUN_08004cb2": "find_pin_function_08004cb2",
                "PinName_conflict": "pinName",
                "PinMap_conflict": "pinMap",
                "map": "currentPinMap",
                "NC": "NotConnected",
                "pin": "targetPin",
                "function": "pinFunction"
            },
            "calling": [
                "pinmap_find_function",
                "pinmap_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cce": {
            "entrypoint": "0x08004cce",
            "current_name": "find_pin_function_08004cce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t find_pin_function_08004cce(pin_name pin,pin_map *map)\n\n{\n  uint32_t result;\n  \n  if (pin == invalid_pin_value) {\n    return 0xffffffff;\n  }\n  result = pinmap_find_function(pin,map);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004cce": "find_pin_function_08004cce",
                "PinName_conflict": "pin_name",
                "PinMap_conflict": "pin_map",
                "uVar1": "result",
                "NC": "invalid_pin_value"
            },
            "calling": [
                "get_adc_channel",
                "pwm_stop",
                "get_pwm_channel",
                "uart_init"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ce2": {
            "entrypoint": "0x08004ce2",
            "current_name": "is_pin_valid_08004ce2",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool isPinValid_08004ce2(PinName_conflict pin,PinMap_conflict *LRNotConnectedPNotConnectedCAU)\n\n{\n  if (pin == NotConnected) {\n    return false;\n  }\n  while( true ) {\n    if (LRNotConnectedPNotConnectedCAU->pin == NotConnected) {\n      return false;\n    }\n    if (pin == LRNotConnectedPNotConnectedCAU->pin) break;\n    LRNotConnectedPNotConnectedCAU = LRNotConnectedPNotConnectedCAU + 1;\n  }\n  return true;\n}\n\n",
            "renaming": {
                "FUN_08004ce2": "is_pin_valid_08004ce2",
                "map": "pinMap",
                "NC": "NotConnected"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d06": {
            "entrypoint": "0x08004d06",
            "current_name": "merge_null_pointers_08004d06",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * merge_null_pointers_08004d06(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n",
            "renaming": {
                "FUN_08004d06": "merge_null_pointers_08004d06"
            },
            "calling": [
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d18": {
            "entrypoint": "0x08004d18",
            "current_name": "invoke_rtc_user_callback_08004d18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid invoke_RTC_User_Callback_08004d18(RTC_HandleTypeDef *RTC_instance)\n\n{\n  if (callback_function != (voidCallbackPtr)0x0) {\n    (*callback_function)(user_data);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d18": "invoke_rtc_user_callback_08004d18",
                "hrtc": "RTC_instance",
                "RTCUserCallback": "callback_function",
                "callbackUserData": "user_data"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d30": {
            "entrypoint": "0x08004d30",
            "current_name": "initialize_rtc_alarm_08004d30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeRtcAlarm_08004d30(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(rtcHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d30": "initialize_rtc_alarm_08004d30",
                "&RtcHandle": "rtcHandle"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d40": {
            "entrypoint": "0x08004d40",
            "current_name": "infinite_loop_08004d40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004d40(char *message,int value)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004d40": "infinite_loop_08004d40",
                "msg": "message",
                "val": "value"
            },
            "calling": [
                "_Error_Handler",
                "SystemClock_Config"
            ],
            "called": [
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d44": {
            "entrypoint": "0x08004d44",
            "current_name": "initialize_memory_08004d44",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeMemory_08004d44(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d44": "initialize_memory_08004d44"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d90": {
            "entrypoint": "0x08004d90",
            "current_name": "update_tim_registers_08004d90",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid update_TIM_registers_08004d90(TIM_HandleTypeDef *timer_handle)\n\n{\n  if (timer_handle->timer_instance == (TIM_TypeDef *)0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 & 0xfffff7ff;\n  }\n  if (timer_handle->timer_instance == (TIM_TypeDef *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffe;\n  }\n  if (timer_handle->timer_instance == (TIM_TypeDef *)0x40000400) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffd;\n  }\n  if (timer_handle->timer_instance == (TIM_TypeDef *)0x40000800) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d90": "update_tim_registers_08004d90",
                "htim": "timer_handle",
                "Instance": "timer_instance"
            },
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004df4": {
            "entrypoint": "0x08004df4",
            "current_name": "get_stimer_from_htim_08004df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStimer * get_stimer_from_htim_08004df4(TIM_HandleTypeDef *TIM_handle)\n\n{\n  return (Stimer *)&TIM_handle[-1].lock;\n}\n\n",
            "renaming": {
                "FUN_08004df4": "get_stimer_from_htim_08004df4",
                "htim": "TIM_handle",
                "stimer_t": "Stimer",
                "Lock": "lock"
            },
            "calling": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004df8": {
            "entrypoint": "0x08004df8",
            "current_name": "handle_timer_irq_08004df8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerIRQ_08004df8(TIM_HandleTypeDef *timerHANDLE)\n\n{\n  stimer_t *timerObject;\n  stimer_t *object;\n  \n  timerObject = getTimerObject(timerHANDLE);\n  if ((timerObject->ocInterruptHandler != (funcVoidTimerPtrUint32 *)0x0) &&\n     (timerHANDLE->Channel == activeChannel1)) {\n    (*timerObject->ocInterruptHandler)(timerObject,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004df8": "handle_timer_irq_08004df8",
                "htim": "timerHANDLE",
                "psVar1": "timerObject",
                "obj": "object",
                "irqHandleOC": "ocInterruptHandler",
                "_func_void_stimer_t_ptr_uint32_t": "funcVoidTimerPtrUint32",
                "HAL_TIM_ACTIVE_CHANNEL_1": "activeChannel1",
                "get_timer_obj": "getTimerObject"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e12": {
            "entrypoint": "0x08004e12",
            "current_name": "handle_timer_interrupt_08004e12",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_08004e12(TIM_HandleTypeDef *timer_handle)\n\n{\n  stimer_t *timer_obj;\n  stimer_t *stimer_obj;\n  \n  timer_obj = get_timer_stimer_obj(timer_handle);\n  if (timer_obj->irqHandle != (_func_void_stimer_t_ptr *)0x0) {\n    (*timer_obj->irqHandle)(timer_obj);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e12": "handle_timer_interrupt_08004e12",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "obj": "stimer_obj"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e20": {
            "entrypoint": "0x08004e20",
            "current_name": "handle_timer_interrupt_08004e20",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e20(void)\n\n{\n  if (timerHandles[0] != (TimerHandle *)0x0) {\n    handleTimerIRQ(timerHandles[0]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e20": "handle_timer_interrupt_08004e20",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e34": {
            "entrypoint": "0x08004e34",
            "current_name": "handle_timer_interrupt_08004e34",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_08004e34(void)\n\n{\n  if (timer_handles[1] != (Timer_HandleTypeDef *)0x0) {\n    handle_timer_irq(timer_handles[1]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e34": "handle_timer_interrupt_08004e34",
                "TIM_HandleTypeDef": "Timer_HandleTypeDef",
                "HAL_TIM_IRQHandler": "handle_timer_irq"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e48": {
            "entrypoint": "0x08004e48",
            "current_name": "handle_timer_interrupt_08004e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e48(void)\n\n{\n  if (timerHandles[2] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e48": "handle_timer_interrupt_08004e48",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e5c": {
            "entrypoint": "0x08004e5c",
            "current_name": "handle_timer_interrupt_08004e5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e5c(void)\n\n{\n  if (timerHandles[3] != (TimerHandle *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[3]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e5c": "handle_timer_interrupt_08004e5c",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e70": {
            "entrypoint": "0x08004e70",
            "current_name": "get_i2c_t_pointer_08004e70",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_t * get_i2c_t_pointer_08004e70(I2C_HandleTypeDef *i2c_handle)\n\n{\n  return (i2c_t *)&i2c_t_pointer;\n}\n\n",
            "renaming": {
                "FUN_08004e70": "get_i2c_t_pointer_08004e70",
                "hi2c": "i2c_handle",
                "hi2c[-1].EventCount": "i2c_t_pointer"
            },
            "calling": [
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "handle_i2_c_transfer_08004e74",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CTransfer_08004e74(I2C_HandleTypeDef *i2cHandle,uint8_t transferDir,uint16_t address)\n\n{\n  i2c_t *i2cObj;\n  i2c_t *i2cObj2;\n  \n  i2cObj = get_i2c_i2cObj2(i2cHandle);\n  if ((uint)address == (i2cHandle->Init).OwnAddress1) {\n    if (transferDir == '\\0') {\n      i2cObj->i2cTxRxBufferSize = '\\0';\n      i2cObj->slaveMode = '\\0';\n      if (i2cObj->i2c_onSlaveTransmit != (_func_void *)0x0) {\n        (*i2cObj->i2c_onSlaveTransmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT\n                (i2cHandle,i2cObj->i2cTxRxBuffer,(ushort)i2cObj->i2cTxRxBufferSize,8);\n      return;\n    }\n    i2cObj->slaveMode = '\\x01';\n    HAL_I2C_Slave_Sequential_Receive_IT(i2cHandle,i2cObj->i2cTxRxBuffer,0x20,8);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "handle_i2_c_transfer_08004e74",
                "hi2c": "i2cHandle",
                "TransferDirection": "transferDir",
                "AddrMatchCode": "address",
                "piVar1": "i2cObj",
                "obj": "i2cObj2"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ec4": {
            "entrypoint": "0x08004ec4",
            "current_name": "enable_slave_receive_interrupt_08004ec4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableSlaveReceiveInterrupt_08004ec4(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObj;\n  i2c_t *i2cObjTemp;\n  uint remainingBytes;\n  \n  i2cObj = get_i2c_i2cObjTemp(i2cHandle);\n  if (((i2cObj->i2c_onSlaveReceive != (_func_void_uint8_t_ptr_int *)0x0) &&\n      (i2cObj->slaveMode == '\\x01')) &&\n     (remainingBytes = 0x20 - *(byte *)&(i2cObj->handle).XferSize & 0xff, remainingBytes != 0)) {\n    (*i2cObj->i2c_onSlaveReceive)(i2cObj->i2cTxRxBuffer,remainingBytes);\n  }\n  HAL_I2C_EnableListen_IT(i2cHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ec4": "enable_slave_receive_interrupt_08004ec4",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObj",
                "obj": "i2cObjTemp",
                "uVar2": "remainingBytes"
            },
            "calling": [
                "I2C_ITError",
                "I2C_Slave_AF",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef4": {
            "entrypoint": "0x08004ef4",
            "current_name": "enable_listen_interrupt_08004ef4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableListenInterrupt_08004ef4(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObject;\n  i2c_t *i2cObject2;\n  \n  i2cObject = get_i2c_i2cObject2(i2cHandle);\n  if (i2cObject->isMaster == '\\0') {\n    HAL_I2C_EnableListen_IT(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef4": "enable_listen_interrupt_08004ef4",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObject",
                "obj": "i2cObject2"
            },
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f0c": {
            "entrypoint": "0x08004f0c",
            "current_name": "handle_i2_c_events_08004f0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvents_08004f0c(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c_handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f0c": "handle_i2_c_events_08004f0c"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f1c": {
            "entrypoint": "0x08004f1c",
            "current_name": "handle_i2_c_error_08004f1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CError_08004f1c(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2cHandles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f1c": "handle_i2_c_error_08004f1c",
                "i2c_handles": "i2cHandles"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "handle_i2_c_event_08004f2c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvent_08004f2c(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c2ErrorHandler::handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "handle_i2_c_event_08004f2c",
                "I2C2_ER_IRQHandler": "i2c2ErrorHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "handle_i2_c_error_08004f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CError_08004f3c(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c2ErHandler::handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "handle_i2_c_error_08004f3c",
                "I2C2_ER_IRQHandler": "i2c2ErHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f4c": {
            "entrypoint": "0x08004f4c",
            "current_name": "initialize_uart_08004f4c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeUart_08004f4c(serial_t *serialObject)\n\n{\n  void *a;\n  USART_TypeDef *uartTransmit;\n  void *b;\n  USART_TypeDef *uartReceive;\n  USART_TypeDef *selectedPeripheral;\n  GPIO_TypeDef *selectedGPIO;\n  GPIO_TypeDef *gpioPort;\n  uint32_t pinFunction;\n  uint32_t tmpRegister4;\n  uint32_t tmpRegister5;\n  uint32_t tmpRegister6;\n  uint32_t tmpRegister7;\n  uint32_t tmpRegister8;\n  uint32_t tmpRegister9;\n  uint32_t tmpRegister10;\n  uint32_t tmpRegister11;\n  uint32_t tmpRegister12;\n  uint32_t tmpRegister13;\n  uint32_t tmpRegister14;\n  uint32_t tmpRegister15;\n  uint32_t tmpRegister16;\n  UART_HandleTypeDef *uartHandle;\n  uint32_t tmpRegister;\n  uint32_t tmpRegister1;\n  uint32_t tmpRegister2;\n  uint32_t tmpRegister3;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  if (serialObject != (serial_t *)0x0) {\n    a = pinmap_peripheral(serialObject->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n    b = pinmap_peripheral(serialObject->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      selectedPeripheral = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      serialObject->uart = selectedPeripheral;\n      if (selectedPeripheral == (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (selectedPeripheral == (USART_TypeDef *)0x40013800) {\n          _DAT_4002100c = _DAT_4002100c & 0xffffbfff;\n          _DAT_40021018 = _DAT_40021018 | 0x4000;\n          serialObject->index = '\\0';\n          serialObject->irq = USART1_IRQn;\n        }\n        else if (selectedPeripheral == (USART_TypeDef *)0x40004400) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffdffff;\n          _DAT_4002101c = _DAT_4002101c | 0x20000;\n          serialObject->index = '\\x01';\n          serialObject->irq = USART2_IRQn;\n        }\n        else if (selectedPeripheral == (USART_TypeDef *)0x40004800) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffbffff;\n          _DAT_4002101c = _DAT_4002101c | 0x40000;\n          serialObject->index = '\\x02';\n          serialObject->irq = USART3_IRQn;\n        }\n        selectedGPIO = set_GPIO_Port_Clock((uint)((int)serialObject->pin_rx << 0x18) >> 0x1c);\n        pinFunction = pinmap_function(serialObject->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n        gpioInitStruct.Pin = 1 << (serialObject->pin_rx & 0xfU) & 0xffff;\n        gpioInitStruct.Mode = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioInitStruct.Pull = (pinFunction << 0x1a) >> 0x1e;\n        _DAT_40021018 = _DAT_40021018 | 1;\n        switch((pinFunction << 0x11) >> 0x19) {\n        case 1:\n          tmpRegister13 = tmpRegister13 | 0x7000001;\n          break;\n        case 2:\n          tmpRegister13 = tmpRegister13 & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          tmpRegister13 = tmpRegister13 | 0x7000002;\n          break;\n        case 4:\n          tmpRegister13 = tmpRegister13 & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          tmpRegister13 = tmpRegister13 | 0x7000004;\n          break;\n        case 6:\n          tmpRegister13 = tmpRegister13 & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          tmpRegister13 = tmpRegister13 | 0x7000008;\n          break;\n        case 8:\n          tmpRegister13 = tmpRegister13 & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          tmpRegister13 = tmpRegister13 | 0x7000030;\n          break;\n        case 10:\n          tmpRegister4 = tmpRegister13 & 0xffffffcf;\n          tmpRegister13 = tmpRegister4 | 0x7000010;\n          break;\n        case 0xb:\n          tmpRegister5 = tmpRegister13 & 0xffffffcf;\n          tmpRegister13 = tmpRegister5 | 0x7000000;\n          break;\n        case 0xc:\n          tmpRegister13 = tmpRegister13 | 0x70000c0;\n          break;\n        case 0xd:\n          tmpRegister6 = tmpRegister13 & 0xffffff3f;\n          tmpRegister13 = tmpRegister6 | 0x7000040;\n          break;\n        case 0xe:\n          tmpRegister7 = tmpRegister13 & 0xffffff3f;\n          tmpRegister13 = tmpRegister7 | 0x7000000;\n          break;\n        case 0xf:\n          tmpRegister13 = tmpRegister13 | 0x7000300;\n          break;\n        case 0x10:\n          tmpRegister8 = tmpRegister13 & 0xfffffcff;\n          tmpRegister13 = tmpRegister8 | 0x7000200;\n          break;\n        case 0x11:\n          tmpRegister9 = tmpRegister13 & 0xfffffcff;\n          tmpRegister13 = tmpRegister9 | 0x7000100;\n          break;\n        case 0x12:\n          tmpRegister10 = tmpRegister13 & 0xfffffcff;\n          tmpRegister13 = tmpRegister10 | 0x7000000;\n          break;\n        case 0x13:\n          tmpRegister13 = tmpRegister13 | 0x7000c00;\n          break;\n        case 0x14:\n          tmpRegister11 = tmpRegister13 & 0xfffff3ff;\n          tmpRegister13 = tmpRegister11 | 0x7000800;\n          break;\n        case 0x15:\n          tmpRegister12 = tmpRegister13 & 0xfffff3ff;\n          tmpRegister13 = tmpRegister12 | 0x7000000;\n          break;\n        case 0x16:\n          tmpRegister13 = tmpRegister13 | 0x7001000;\n          break;\n        case 0x17:\n          tmpRegister13 = tmpRegister13 & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          tmpRegister13 = tmpRegister13 | 0x7008000;\n          break;\n        case 0x1c:\n          tmpRegister13 = tmpRegister13 & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          tmpRegister13 = tmpRegister13 & 0xf8ffffff;\n          break;\n        case 0x22:\n          tmpRegister14 = tmpRegister13 & 0xf8ffffff;\n          tmpRegister13 = tmpRegister14 | 0x1000000;\n          break;\n        case 0x23:\n          tmpRegister15 = tmpRegister13 & 0xf8ffffff;\n          tmpRegister13 = tmpRegister15 | 0x2000000;\n          break;\n        case 0x24:\n          tmpRegister16 = tmpRegister13 & 0xf8ffffff;\n          tmpRegister13 = tmpRegister16 | 0x4000000;\n        }\n        gpioInitStruct.Speed = 3;\n        HAL_GPIO_Init(selectedGPIO,&gpioInitStruct);\n        selectedGPIO = set_GPIO_Port_Clock((uint)((int)serialObject->pin_tx << 0x18) >> 0x1c);\n        pinFunction = pinmap_function(serialObject->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n        gpioInitStruct.Pin = 1 << (serialObject->pin_tx & 0xfU) & 0xffff;\n        gpioInitStruct.Mode = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioInitStruct.Pull = (pinFunction << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(selectedGPIO,&gpioInitStruct);\n        uart_handlers[serialObject->index] = &serialObject->handle;\n        (serialObject->handle).Instance = serialObject->uart;\n        (serialObject->handle).Init.BaudRate = serialObject->baudrate;\n        (serialObject->handle).Init.WordLength = serialObject->databits;\n        (serialObject->handle).Init.StopBits = serialObject->stopbits;\n        (serialObject->handle).Init.Parity = serialObject->parity;\n        (serialObject->handle).Init.Mode = 0xc;\n        (serialObject->handle).Init.HwFlowCtl = 0;\n        (serialObject->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&serialObject->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f4c": "initialize_uart_08004f4c",
                "obj": "serialObject",
                "uart_tx": "uartTransmit",
                "uart_rx": "uartReceive",
                "pUVar1": "selectedPeripheral",
                "pGVar2": "selectedGPIO",
                "port": "gpioPort",
                "uVar3": "pinFunction",
                "tmpreg_4": "tmpRegister4",
                "tmpreg_5": "tmpRegister5",
                "tmpreg_6": "tmpRegister6",
                "tmpreg_7": "tmpRegister7",
                "tmpreg_8": "tmpRegister8",
                "tmpreg_9": "tmpRegister9",
                "tmpreg_10": "tmpRegister10",
                "tmpreg_11": "tmpRegister11",
                "tmpreg_12": "tmpRegister12",
                "tmpreg_13": "tmpRegister13",
                "tmpreg_14": "tmpRegister14",
                "tmpreg_15": "tmpRegister15",
                "tmpreg_16": "tmpRegister16",
                "huart": "uartHandle",
                "tmpreg": "tmpRegister",
                "tmpreg_1": "tmpRegister1",
                "tmpreg_2": "tmpRegister2",
                "tmpreg_3": "tmpRegister3",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "called": [
                "HAL_GPIO_Init",
                "pinmap_merge_peripheral",
                "HAL_UART_Init",
                "set_GPIO_Port_Clock",
                "pinmap_peripheral",
                "iprintf",
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005384": {
            "entrypoint": "0x08005384",
            "current_name": "initialize_serial_communication_08005384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08005384(void)\n\n{\n  void *peripheralPointer;\n  \n  peripheralPointer = pinmap_peripheral(pin,(pinMap *)&uartTxPinMap);\n  if (peripheralPointer != (void *)0x0) {\n    peripheralPointer = pinmap_peripheral(pin,(pinMap *)&uartTxPinMap);\n    debugSerial.pin_rx = pinmap_pin(peripheralPointer,(pinMap *)&PinMap_UART_RX);\n    debugSerial.pin_tx = pin;\n    debugSerial.baudrate = 0x2580;\n    debugSerial.parity = 0;\n    debugSerial.databits = 0;\n    debugSerial.stopbits = 0;\n    initializeUart(&debugSerial);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005384": "initialize_serial_communication_08005384",
                "pvVar1": "peripheralPointer",
                "PA_2": "pin",
                "PinMap_conflict": "pinMap",
                "PinMap_UART_TX": "uartTxPinMap",
                "serial_debug": "debugSerial",
                "uart_init": "initializeUart"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "pinmap_pin",
                "pinmap_peripheral",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053d4": {
            "entrypoint": "0x080053d4",
            "current_name": "transmit_data_080053d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nbufferSize_t transmitData_080053d4(uint8_t *dataBuffer,uint32_t bufferSize)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t currentTick;\n  uint32_t tickstart;\n  void *peripheral;\n  USART_TypeDef *peripheralInstance;\n  uint32_t newTick;\n  uint uartIndex;\n  \n  currentTick = HAL_GetTick();\n  peripheral = pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX);\n  if (peripheral == (void *)0x0) {\n    return 0;\n  }\n  uartIndex = 0;\n  while ((uartIndex < 5 &&\n         ((uart_handlers[uartIndex] == (UART_HandleTypeDef *)0x0 ||\n          (peripheralInstance = (USART_TypeDef *)pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX),\n          uart_handlers[uartIndex]->Instance != peripheralInstance))))) {\n    uartIndex = uartIndex + 1 & 0xff;\n  }\n  if (4 < uartIndex) {\n    if ((4 < serial_debug.index) && (uart_debug_init(), 4 < serial_debug.index)) {\n      return 0;\n    }\n    uartIndex = (uint)serial_debug.index;\n  }\n  do {\n    status = HAL_UART_Transmit(uart_handlers[uartIndex],dataBuffer,(uint16_t)bufferSize,1000);\n    if (status == HAL_OK) {\n      return bufferSize;\n    }\n    newTick = HAL_GetTick();\n  } while (newTick - currentTick < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080053d4": "transmit_data_080053d4",
                "data": "dataBuffer",
                "size": "bufferSize",
                "HVar1": "status",
                "uVar2": "currentTick",
                "pvVar3": "peripheral",
                "pUVar4": "peripheralInstance",
                "uVar5": "newTick",
                "uVar6": "uartIndex"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "HAL_GetTick",
                "uart_debug_init",
                "pinmap_peripheral",
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800548c": {
            "entrypoint": "0x0800548c",
            "current_name": "check_uart_state_0800548c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_0800548c(serial_t *serial_device)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(uart_handlers[serial_device->index]);\n  return (uart_state & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_0800548c": "check_uart_state_0800548c",
                "obj": "serial_device",
                "HVar1": "uart_state"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054b0": {
            "entrypoint": "0x080054b0",
            "current_name": "check_uart_state_080054b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_080054b0(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(handlers[serial_object->index]);\n  return (uart_state & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_080054b0": "check_uart_state_080054b0",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "uart_handlers": "handlers"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054d4": {
            "entrypoint": "0x080054d4",
            "current_name": "receive_and_store_byte_080054d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint receiveAndStoreByte_080054d4(serial_t *serialObject,uchar *c)\n\n{\n  uint8_t isRxActive;\n  \n  if (serialObject == (serial_t *)0x0) {\n    return -1;\n  }\n  isRxActive = serial_rx_active(serialObject);\n  if (isRxActive == '\\0') {\n    *c = serialObject->recv;\n    HAL_UART_Receive_IT(uart_handlers[serialObject->index],&serialObject->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080054d4": "receive_and_store_byte_080054d4",
                "obj": "serialObject",
                "uVar1": "isRxActive"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005510": {
            "entrypoint": "0x08005510",
            "current_name": "initialize_serial_communication_08005510",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08005510(serial_t *serialObject,_func_void_serial_t_ptr *serialCallback)\n\n{\n  byte index;\n  uint8_t rxActiveFlag;\n  \n  if (serialObject != (serial_t *)0x0) {\n    rxActiveFlag = serial_rx_active(serialObject);\n    if (rxActiveFlag == '\\0') {\n      index = serialObject->index;\n      rx_serialCallback[index] = serialCallback;\n      rx_serialCallback_serialObject[index] = serialObject;\n      HAL_NVIC_SetPriority(serialObject->irq,0,1);\n      HAL_NVIC_EnableIRQ(serialObject->irq);\n      HAL_UART_Receive_IT(uart_handlers[serialObject->index],&serialObject->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005510": "initialize_serial_communication_08005510",
                "obj": "serialObject",
                "callback": "serialCallback",
                "bVar1": "index",
                "uVar2": "rxActiveFlag"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "HAL_NVIC_EnableIRQ",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005568": {
            "entrypoint": "0x08005568",
            "current_name": "initialize_serial_transmit_08005568",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialTransmit_08005568(serial_t *serialObject,_func_int_serial_t_ptr *serialCallback)\n\n{\n  byte currentIndex;\n  \n  if (serialObject != (serial_t *)0x0) {\n    currentIndex = serialObject->index;\n    transmitCallback[currentIndex] = serialCallback;\n    transmitCallbackObject[currentIndex] = serialObject;\n    setIRQPriority(serialObject->irq,0,2);\n    enableIRQ(serialObject->irq);\n    transmitData(uartHandlers[serialObject->index],serialObject->transmitBuffer + serialObject->transmitTail,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005568": "initialize_serial_transmit_08005568",
                "obj": "serialObject",
                "callback": "serialCallback",
                "bVar1": "currentIndex",
                "tx_callback": "transmitCallback",
                "tx_callback_obj": "transmitCallbackObject",
                "HAL_NVIC_SetPriority": "setIRQPriority",
                "HAL_NVIC_EnableIRQ": "enableIRQ",
                "HAL_UART_Transmit_IT": "transmitData",
                "uart_handlers": "uartHandlers",
                "tx_buff": "transmitBuffer",
                "tx_tail": "transmitTail"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_EnableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055bc": {
            "entrypoint": "0x080055bc",
            "current_name": "find_uart_handler_080055bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t find_uart_handler_080055bc(UART_HandleTypeDef *uart_handle)\n\n{\n  uint index;\n  \n  if (uart_handle == (UART_HandleTypeDef *)0x0) {\n    index = 5;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (4 < index) {\n        return (uint8_t)index;\n      }\n      if (uart_handle == uart_handlers[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return (uint8_t)index;\n}\n\n",
            "renaming": {
                "FUN_080055bc": "find_uart_handler_080055bc",
                "huart": "uart_handle",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055e0": {
            "entrypoint": "0x080055e0",
            "current_name": "handle_uart_receive_080055e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_receive_080055e0(UART_HandleTypeDef *uart_handle)\n\n{\n  byte index;\n  uint8_t index;\n  uint uart_index;\n  \n  index = uart_index(uart_handle);\n  uart_index = (uint)index;\n  if (uart_index < 5) {\n    (*receive_callback[uart_index])(receive_callback_object[uart_index]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055e0": "handle_uart_receive_080055e0",
                "huart": "uart_handle",
                "bVar1": "index",
                "uVar2": "uart_index",
                "rx_callback": "receive_callback",
                "rx_callback_obj": "receive_callback_object"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005604": {
            "entrypoint": "0x08005604",
            "current_name": "transmit_data_08005604",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitData_08005604(UART_HandleTypeDef *uartHandler)\n\n{\n  byte uartIndex;\n  uint8_t serialIndex;\n  int returnValue;\n  serial_t *serialObject;\n  serial_t *callbackObj;\n  uint convertedIndex;\n  \n  uartIndex = uart_serialIndex(uartHandler);\n  convertedIndex = (uint)uartIndex;\n  callbackObj = tx_callback_serialObject[convertedIndex];\n  if ((convertedIndex < 5) && (returnValue = (*tx_callback[convertedIndex])(callbackObj), returnValue != -1)) {\n    HAL_UART_Transmit_IT(uart_handlers[callbackObj->serialIndex],callbackObj->tx_buff + callbackObj->tx_tail,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005604": "transmit_data_08005604",
                "huart": "uartHandler",
                "bVar1": "uartIndex",
                "index": "serialIndex",
                "iVar3": "returnValue",
                "obj": "serialObject",
                "psVar4": "callbackObj",
                "uVar2": "convertedIndex"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005650": {
            "entrypoint": "0x08005650",
            "current_name": "initialize_uart_08005650",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeUART_08005650(UART_HandleTypeDef *uartHandle)\n\n{\n  uint32_t temporaryValue;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08005650": "initialize_uart_08005650",
                "huart": "uartHandle",
                "tmpval": "temporaryValue"
            },
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005690": {
            "entrypoint": "0x08005690",
            "current_name": "handle_usart1_irq_08005690",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleUSART1IRQ_08005690(void)\n\n{\n  clearPendingIRQ(uart1Interrupt);\n  handleUARTInterrupt(uartHandlers[0]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005690": "handle_usart1_irq_08005690",
                "USART1_IRQn": "uart1Interrupt",
                "HAL_NVIC_ClearPendingIRQ": "clearPendingIRQ",
                "HAL_UART_IRQHandler": "handleUARTInterrupt",
                "uart_handlers": "uartHandlers"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056a8": {
            "entrypoint": "0x080056a8",
            "current_name": "handle_uart2_interrupt_080056a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART2_interrupt_080056a8(void)\n\n{\n  clear_pending_interrupt(uart2_interrupt);\n  handle_UART_interrupt(uart_interrupt_handlers[1]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056a8": "handle_uart2_interrupt_080056a8",
                "USART2_IRQn": "uart2_interrupt",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt",
                "uart_handlers": "uart_interrupt_handlers"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056c0": {
            "entrypoint": "0x080056c0",
            "current_name": "handle_uart3_interrupt_080056c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART3_interrupt_080056c0(void)\n\n{\n  clear_pending_interrupt(UART3_interrupt);\n  if (UART_handles[2] != (UART_HandleTypeDef *)0x0) {\n    handle_UART_interrupt(UART_handles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056c0": "handle_uart3_interrupt_080056c0",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "USART3_IRQn": "UART3_interrupt",
                "uart_handlers": "UART_handles",
                "HAL_UART_IRQHandler": "handle_UART_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d8": {
            "entrypoint": "0x080056d8",
            "current_name": "expand_heap_080056d8",
            "code": "\nvoid * expandHeap_080056d8(intptr_t size)\n\n{\n  char *currentHeapEnd;\n  char *previousHeapEnd;\n  \n  if (_sbrk::heap_end == (char *)0x0) {\n    _sbrk::heap_end = &_ebss;\n  }\n  currentHeapEnd = _sbrk::heap_end;\n  if (_sbrk::heap_end + size <= &stack0x00000000) {\n    _sbrk::heap_end = _sbrk::heap_end + size;\n    return currentHeapEnd;\n  }\n  errno = 0xc;\n  return (void *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080056d8": "expand_heap_080056d8",
                "__delta": "size",
                "pcVar1": "currentHeapEnd",
                "prev_heap_end": "previousHeapEnd"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "check_file_descriptor_08005714",
            "code": "\nint check_file_descriptor_08005714(int file_descriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08005714": "check_file_descriptor_08005714",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800571a": {
            "entrypoint": "0x0800571a",
            "current_name": "set_buffer_size_0800571a",
            "code": "\nint setBufferSize_0800571a(int fileDescriptor,stat *statBuffer)\n\n{\n  *(undefined4 *)((int)&statBuffer->st_dev + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800571a": "set_buffer_size_0800571a",
                "__fd": "fileDescriptor",
                "__buf": "statBuffer"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005724": {
            "entrypoint": "0x08005724",
            "current_name": "check_fd_validity_08005724",
            "code": "\nint check_fd_validity_08005724(int file_descriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08005724": "check_fd_validity_08005724",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "get_file_offset_08005728",
            "code": "\n__off_t getFileOffset_08005728(int fileDescriptor,__off_t offset,int seekOrigin)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005728": "get_file_offset_08005728",
                "__fd": "fileDescriptor",
                "__offset": "offset",
                "__whence": "seekOrigin"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800572c": {
            "entrypoint": "0x0800572c",
            "current_name": "read_file_data_0800572c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint read_file_data_0800572c(int file_descriptor,char *data_pointer,int data_length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800572c": "read_file_data_0800572c",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "data_pointer",
                "len_UNUSED": "data_length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005730": {
            "entrypoint": "0x08005730",
            "current_name": "write_debug_to_uart_08005730",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint write_debug_to_uart_08005730(int file_descriptor,char *data_pointer,int data_length)\n\n{\n  size_t bytes_written;\n  \n  bytes_written = uart_debug_write((uint8_t *)data_pointer,data_length);\n  return bytes_written;\n}\n\n",
            "renaming": {
                "FUN_08005730": "write_debug_to_uart_08005730",
                "file_UNUSED": "file_descriptor",
                "ptr": "data_pointer",
                "len": "data_length",
                "sVar1": "bytes_written"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800573c": {
            "entrypoint": "0x0800573c",
            "current_name": "infinite_loop_0800573c",
            "code": "\nvoid infiniteLoop_0800573c(int status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0800573c": "infinite_loop_0800573c",
                "__status": "status"
            },
            "calling": [
                "_exit",
                "abort"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005740": {
            "entrypoint": "0x08005740",
            "current_name": "set_errno_08005740",
            "code": "\nint setErrno_08005740(pid_t pid,int signal)\n\n{\n  errno = 0x16;\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08005740": "set_errno_08005740",
                "__pid": "pid",
                "__sig": "signal"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005750": {
            "entrypoint": "0x08005750",
            "current_name": "get_process_id_08005750",
            "code": "\n\n\nProcessID get_process_id_08005750(void)\n\n{\n  processID 1;\n}\n\n",
            "renaming": {
                "FUN_08005750": "get_process_id_08005750",
                "__pid_t": "ProcessID",
                "return": "processID"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005754": {
            "entrypoint": "0x08005754",
            "current_name": "read_pin_value_08005754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t readPinValue_08005754(uint32_t pinNumber)\n\n{\n  bool isInRange;\n  PinName_conflict pinConfiguration;\n  uint16_t adcValue;\n  uint32_t readValue;\n  \n  if (pinNumber < 0xe) {\n    if (pinNumber + 0x2e < 0x3c) {\n      isInRange = true;\n    }\n    else {\n      isInRange = false;\n    }\n  }\n  else {\n    isInRange = pinNumber < 0x3c;\n  }\n  if (isInRange) {\n    if (pinNumber < 0xe) {\n      pinNumber = pinNumber + 0x2e;\n    }\n    pinConfiguration = (&digitalPin)[pinNumber];\n  }\n  else {\n    pinConfiguration = NC;\n  }\n  if (pinConfiguration == NC) {\n    readValue = 0;\n  }\n  else {\n    adcValue = adc_read_value(pinConfiguration);\n    readValue = (uint32_t)adcValue;\n    if (_readResolution != 0xc) {\n      if ((uint)_readResolution < 0xc) {\n        return (uint)(adcValue >> (0xcU - _readResolution & 0xff));\n      }\n      return readValue << (_readResolution - 0xcU & 0xff);\n    }\n  }\n  return readValue;\n}\n\n",
            "renaming": {
                "FUN_08005754": "read_pin_value_08005754",
                "ulPin": "pinNumber",
                "bVar1": "isInRange",
                "p": "pinConfiguration",
                "uVar2": "adcValue",
                "uVar3": "readValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "adc_read_value"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057b4": {
            "entrypoint": "0x080057b4",
            "current_name": "configure_digital_pin_080057b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureDigitalPin_080057b4(uint32_t pinNumber,uint32_t pinMode)\n\n{\n  _Bool isPinConfigured;\n  PinName_conflict pin;\n  \n  if (pinNumber < 0x3c) {\n    pin = (&digitalPins)[pinNumber];\n  }\n  else {\n    pin = notConnected;\n  }\n  if (pin != notConnected) {\n    isPinConfigured = is_pinin_configured(pin,outputPinConfigured);\n    if (isPinConfigured) {\n      isPinConfigured = pinin_in_pininmapin(pin,(conflictPinMap *)&pinMapPWM);\n      if (isPinConfigured) {\n        pinwm_stopin(pin);\n      }\n      reset_pinin_configured(pin,outputPinConfigured);\n    }\n    switch(pinMode) {\n    case 0:\n      digital_io_init(pin,0,0);\n      break;\n    case 1:\n      digital_io_init(pin,1,0);\n      break;\n    case 2:\n      digital_io_init(pin,0,1);\n      break;\n    case 3:\n      digital_io_init(pin,0,2);\n    }\n    set_pinin_configured(pin,digitalPinConfigured);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057b4": "configure_digital_pin_080057b4",
                "ulPin": "pinNumber",
                "ulMode": "pinMode",
                "_Var1": "isPinConfigured",
                "p": "pin",
                "g_anOutputPinConfigured": "outputPinConfigured",
                "PinMap_conflict": "conflictPinMap",
                "PinMap_PWM": "pinMapPWM",
                "g_digPinConfigured": "digitalPinConfigured",
                "digitalPin": "digitalPins",
                "NC": "notConnected"
            },
            "calling": [
                "setup",
                "MAX31855",
                "begin"
            ],
            "called": [
                "set_pin_configured",
                "pin_in_pinmap",
                "is_pin_configured",
                "digital_io_init",
                "pwm_stop",
                "reset_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005848": {
            "entrypoint": "0x08005848",
            "current_name": "configure_digital_pin_08005848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureDigitalPin_08005848(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  _Bool pinConfigurationExists;\n  GPIO_TypinNameConfeDef *gpioPort;\n  PinName_conflict pinNameConf;\n  uint digitalPinIndex;\n  \n  if (pinNumber < 0x3c) {\n    digitalPinIndex = (uint)(char)(&digitalPin)[pinNumber];\n  }\n  else {\n    digitalPinIndex = 0xffffffff;\n  }\n  if ((digitalPinIndex != 0xffffffff) &&\n     (pinConfigurationExists = is_pinNameConfin_configured((PinName_conflict)digitalPinIndex,g_digPinConfigured), pinConfigurationExists)) {\n    gpioPort = get_GPIO_Port((digitalPinIndex << 0x18) >> 0x1c);\n    digital_io_write(gpioPort,1 << (digitalPinIndex & 0xf) & 0xffff,pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005848": "configure_digital_pin_08005848",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "_Var1": "pinConfigurationExists",
                "port": "gpioPort",
                "p": "pinNameConf",
                "uVar2": "digitalPinIndex"
            },
            "calling": [
                "setup",
                "pulseEnable",
                "send",
                "MAX31855",
                "begin",
                "loop",
                "readData",
                "write4bits",
                "write8bits"
            ],
            "called": [
                "is_pin_configured",
                "get_GPIO_Port",
                "digital_io_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005890": {
            "entrypoint": "0x08005890",
            "current_name": "check_pin_state_08005890",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint checkPinState_08005890(uint32_t pinNumber)\n\n{\n  _Bool isConfigured;\n  GPIO_TypinConfigeDef *gpioPort;\n  uint32_t pinReadValue;\n  PinName_conflict pinConfig;\n  uint pinConfigIndex;\n  \n  if (pinNumber < 0x3c) {\n    pinConfigIndex = (uint)(char)(&digitalPin)[pinNumber];\n  }\n  else {\n    pinConfigIndex = 0xffffffff;\n  }\n  if (pinConfigIndex == 0xffffffff) {\n    pinConfigIndex = 0;\n  }\n  else {\n    isConfigured = is_pinConfigin_configured((PinName_conflict)pinConfigIndex,g_digPinConfigured);\n    if (isConfigured) {\n      gpioPort = get_GPIO_Port((pinConfigIndex << 0x18) >> 0x1c);\n      pinReadValue = digital_io_read(gpioPort,1 << (pinConfigIndex & 0xf) & 0xffff);\n      pinConfigIndex = pinReadValue & 0xff;\n    }\n    else {\n      pinConfigIndex = 0;\n    }\n  }\n  if (pinConfigIndex != 0) {\n    pinConfigIndex = 1;\n  }\n  return pinConfigIndex;\n}\n\n",
            "renaming": {
                "FUN_08005890": "check_pin_state_08005890",
                "ulPin": "pinNumber",
                "_Var1": "isConfigured",
                "port": "gpioPort",
                "uVar2": "pinReadValue",
                "p": "pinConfig",
                "uVar3": "pinConfigIndex"
            },
            "calling": [
                "loop",
                "readData"
            ],
            "called": [
                "is_pin_configured",
                "get_GPIO_Port",
                "digital_io_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058e0": {
            "entrypoint": "0x080058e0",
            "current_name": "get_current_milliseconds_080058e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_milliseconds_080058e0(void)\n\n{\n  uint32_t current_milliseconds;\n  \n  current_milliseconds = GetCurrentMilli();\n  return current_milliseconds;\n}\n\n",
            "renaming": {
                "FUN_080058e0": "get_current_milliseconds_080058e0",
                "uVar1": "current_milliseconds"
            },
            "calling": [
                "setup",
                "PID",
                "loop",
                "Compute"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058e8": {
            "entrypoint": "0x080058e8",
            "current_name": "FUNC_080058e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080058e8(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080058e8": "FUNC_080058e8"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080058ea": {
            "entrypoint": "0x080058ea",
            "current_name": "update_tail_position_080058ea",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::updateTailPosition_080058ea(serial_t_conflict *serialObj)\n\n{\n  ushort updatedPosition;\n  uint16_t clampedPosition;\n  int newTailPosition;\n  \n  newTailPosition = serialObj->tx_tail + 1;\n  updatedPosition = (ushort)newTailPosition;\n  clampedPosition = updatedPosition & 0x7f;\n  if (newTailPosition == 0) {\n    clampedPosition = -(-updatedPosition & 0x7f);\n  }\n  serialObj->tx_tail = clampedPosition;\n  if (serialObj->tx_head != serialObj->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080058ea": "update_tail_position_080058ea",
                "obj": "serialObj",
                "iVar3": "newTailPosition",
                "uVar1": "updatedPosition",
                "uVar2": "clampedPosition"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800591e": {
            "entrypoint": "0x0800591e",
            "current_name": "calculate_available_bytes_0800591e",
            "code": "\n/* DWARF original prototype: int  available(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::calculateAvailableBytes_0800591e(HardwareSerial *serial)\n\n{\n  return ((serial->_serial).head + 0x40) - (uint)(serial->_serial).tail & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_0800591e": "calculate_available_bytes_0800591e",
                "this": "serial",
                "rx_head": "head",
                "rx_tail": "tail"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005932": {
            "entrypoint": "0x08005932",
            "current_name": "get_next_received_byte_08005932",
            "code": "\n/* DWARF original prototype: int  peek(HardwareSerial * serial_interface) */\n\nint __serial_interfacecall HardwareSerial::get_next_received_byte_08005932(HardwareSerial *serial_interface)\n\n{\n  uint tail_index;\n  \n  tail_index = (uint)(serial_interface->_serial).tail_index;\n  if ((serial_interface->_serial).head_index != tail_index) {\n    return (uint)(serial_interface->_serial).receive_buffer[tail_index];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08005932": "get_next_received_byte_08005932",
                "this": "serial_interface",
                "uVar1": "tail_index",
                "rx_tail": "tail_index",
                "rx_head": "head_index",
                "rx_buff": "receive_buffer"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800594e": {
            "entrypoint": "0x0800594e",
            "current_name": "read_serial_0800594e",
            "code": "\n/* DWARF original prototype: int  read(HardwareSerial * serial) */\n\nssize_t __serialcall\nHardwareSerial::read_serial_0800594e(HardwareSerial *serial,int file_descriptor,void *buffer,size_t size)\n\n{\n  byte byte_value;\n  ushort rx_tail;\n  uchar c;\n  \n  rx_tail = (serial->_serial).rx_tail;\n  if ((uint)(serial->_serial).rx_head != (uint)rx_tail) {\n    byte_value = (serial->_serial).rx_buff[rx_tail];\n    (serial->_serial).rx_tail = rx_tail + 1 & 0x3f;\n    return (uint)byte_value;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_0800594e": "read_serial_0800594e",
                "this": "serial",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__nbytes": "size",
                "bVar1": "byte_value",
                "uVar2": "rx_tail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005976": {
            "entrypoint": "0x08005976",
            "current_name": "flush_serial_buffer_08005976",
            "code": "\n/* DWARF original prototype: void  flush(HardwareSerial * serialPort) */\n\nvoid __serialPortcall HardwareSerial::flushSerialBuffer_08005976(HardwareSerial *serialPort)\n\n{\n  if (serialPort->_written != false) {\n    do {\n    } while ((serialPort->_serial).tx_head != (serialPort->_serial).tx_tail);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005976": "flush_serial_buffer_08005976",
                "this": "serialPort"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800598a": {
            "entrypoint": "0x0800598a",
            "current_name": "receive_data_0800598a",
            "code": "\n/* WARNING: Unknown callbufferIndexng conventbufferIndexon */\n\nvobufferIndexd HardwareSerbufferIndexal::receiveData_0800598a(serbufferIndexal_t_conflbufferIndexct *serialObject)\n\n{\n  bufferIndexnt result;\n  rx_buffer_bufferIndexndex_t bufferIndex;\n  ushort newHead;\n  uchar c;\n  \n  result = uart_getc((serbufferIndexal_t *)serialObject,&c);\n  bufferIndexf ((result == 0) && (newHead = serialObject->rx_head + 1 & 0x3f, newHead != serialObject->rx_tabufferIndexl)) {\n    serialObject->rx_buff[serialObject->rx_head] = c;\n    serialObject->rx_head = newHead;\n  }\n  return;\n}\n\n",
            "renaming": {
                "obj": "serialObject",
                "iVar1": "result",
                "i": "bufferIndex",
                "uVar2": "newHead",
                "FUN_0800598a": "receive_data_0800598a"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059c8": {
            "entrypoint": "0x080059c8",
            "current_name": "write_data_080059c8",
            "code": "\n/* DWARF orbufferIndexgbufferIndexnal prototype: sbufferIndexze_t  wrbufferIndexte(HardwareSerbufferIndexal * serial, ubufferIndexnt8_t c) */\n\nssbufferIndexze_t __serialcall\nHardwareSerbufferIndexal::writeData_080059c8(HardwareSerbufferIndexal *serial,bufferIndexnt data,vobufferIndexd *buffer,sbufferIndexze_t size)\n\n{\n  byte byteValue;\n  ubufferIndexnt8_t result;\n  byte modifiedByteValue;\n  bufferIndexnt newValue;\n  ubufferIndexnt txHead;\n  tx_buffer_bufferIndexndex_t bufferIndex;\n  \n  serial->_wrbufferIndextten = true;\n  txHead = (ubufferIndexnt)(serial->_serbufferIndexal).tx_head;\n  newValue = txHead + 1;\n  byteValue = (byte)newValue;\n  modifiedByteValue = byteValue & 0x7f;\n  bufferIndexf (newValue == 0) {\n    modifiedByteValue = -(-byteValue & 0x7f);\n  }\n  do {\n  } whbufferIndexle ((serial->_serbufferIndexal).tx_tabufferIndexl == (ushort)modifiedByteValue);\n  (serial->_serbufferIndexal).tx_buff[txHead] = (ubufferIndexnt8_t)data;\n  (serial->_serbufferIndexal).tx_head = (ushort)modifiedByteValue;\n  result = serbufferIndexal_tx_actbufferIndexve((serbufferIndexal_t *)&serial->_serbufferIndexal);\n  bufferIndexf (result == '\\0') {\n    uart_attach_tx_callback((serbufferIndexal_t *)&serial->_serbufferIndexal,_tx_complete_bufferIndexrq + 1);\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "this": "serial",
                "__fd": "data",
                "__buf": "buffer",
                "__n": "size",
                "bVar1": "byteValue",
                "uVar2": "result",
                "bVar3": "modifiedByteValue",
                "iVar4": "newValue",
                "uVar5": "txHead",
                "i": "bufferIndex",
                "FUN_080059c8": "write_data_080059c8"
            },
            "calling": [],
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a18": {
            "entrypoint": "0x08005a18",
            "current_name": "FUNC_08005a18",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005a1e) */\n/* WARNING: Removing unreachable block (ram,0x08005a30) */\n/* WARNING: Removing unreachable block (ram,0x08005a26) */\n/* WARNING: Removing unreachable block (ram,0x08005a38) */\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005a18(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a18": "FUNC_08005a18"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a44": {
            "entrypoint": "0x08005a44",
            "current_name": "initialize_serial_08005a44",
            "code": "\n/* DWARF original prototype: void  init(HardwareSerial * serialObj) */\n\nint __serialObjcall HardwareSerial::initializeSerial_08005a44(HardwareSerial *serialObj,EVP_PKEY_CTX *ctx)\n\n{\n  (serialObj->serialData).serialData.receiveBuffer = serialObj->receiveBuffer;\n  (serialObj->serialData).serialData.receiveHead = 0;\n  (serialObj->serialData).serialData.receiveTail = 0;\n  (serialObj->serialData).serialData.transmitBuffer = serialObj->transmitBuffer;\n  (serialObj->serialData).serialData.transmitHead = 0;\n  (serialObj->serialData).serialData.transmitTail = 0;\n  return (int)serialObj;\n}\n\n",
            "renaming": {
                "FUN_08005a44": "initialize_serial_08005a44",
                "this": "serialObj",
                "_serial": "serialData",
                "_rx_buffer": "receiveBuffer",
                "_tx_buffer": "transmitBuffer",
                "rx_buff": "serialData.receiveBuffer",
                "rx_head": "serialData.receiveHead",
                "rx_tail": "serialData.receiveTail",
                "tx_buff": "serialData.transmitBuffer",
                "tx_head": "serialData.transmitHead",
                "tx_tail": "serialData.transmitTail"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a68": {
            "entrypoint": "0x08005a68",
            "current_name": "initialize_serial_port_08005a68",
            "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * serialPort, ulong baudrate, byte configuration) */\n\nvoid __serialPortcall HardwareSerial::initializeSerialPort_08005a68(HardwareSerial *serialPort,ulong baudrate,byte configuration)\n\n{\n  byte configMask;\n  int numBits;\n  \n  (serialPort->_serial).baudraterate = baudrate;\n  serialPort->_configuration = configuration;\n  configMask = configuration & 7;\n  if (configMask == 4) {\n    numBits = 7;\n  }\n  else if (configMask == 6) {\n    numBits = 8;\n  }\n  else if (configMask == 2) {\n    numBits = 6;\n  }\n  else {\n    numBits = 0;\n  }\n  if ((configuration & 0x30) == 0x30) {\n    (serialPort->_serial).parity = 0x600;\n    numBits = numBits + 1;\n  }\n  else if ((configuration & 0x20) == 0) {\n    (serialPort->_serial).parity = 0;\n  }\n  else {\n    (serialPort->_serial).parity = 0x400;\n    numBits = numBits + 1;\n  }\n  if ((configuration & 8) == 0) {\n    (serialPort->_serial).stopbits = 0;\n  }\n  else {\n    (serialPort->_serial).stopbits = 0x2000;\n  }\n  if (numBits == 8) {\n    (serialPort->_serial).databits = 0;\n  }\n  else if (numBits == 9) {\n    (serialPort->_serial).databits = 0x1000;\n  }\n  else {\n    numBits = 0;\n  }\n  if (numBits != 0) {\n    initializeUART((serial_t *)&serialPort->_serial);\n    attachRxCallback((serial_t *)&serialPort->_serial,rxCompleteIRQ + 1);\n    return;\n  }\n                    \n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!=0\");\n}\n\n",
            "renaming": {
                "this": "serialPort",
                "baud": "baudrate",
                "config": "configuration",
                "bVar1": "configMask",
                "iVar2": "numBits",
                "uart_init": "initializeUART",
                "uart_attach_rx_callback": "attachRxCallback",
                "_rx_complete_irq": "rxCompleteIRQ",
                "FUN_08005a68": "initialize_serial_port_08005a68"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "__assert_func",
                "uart_attach_rx_callback",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b24": {
            "entrypoint": "0x08005b24",
            "current_name": "set_rx_08005b24",
            "code": "\n/* DWARF original prototype: void  setRx_08005b24(HardwareSerial * serialObject, uint32_t pinNumber) */\n\nvoid __serialObjectcall HardwareSerial::setRx_08005b24(HardwareSerial *serialObject,uint32_t pinNumber)\n\n{\n  PinName pinName;\n  \n  if (pinNumber < 0x3c) {\n    pinName = (&digitalPin)[pinNumber];\n  }\n  else {\n    pinName = NC;\n  }\n  (serialObject->_serial).pinpinNumber = pinName;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b24": "set_rx_08005b24",
                "this": "serialObject",
                "_rx": "pinNumber",
                "PVar1": "pinName"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b3c": {
            "entrypoint": "0x08005b3c",
            "current_name": "set_serial_tx_pin_08005b3c",
            "code": "\n/* DWARF original prototype: void  setTx(HardwareSerial * serial, uint32_t pinIndex) */\n\nvoid __serialcall HardwareSerial::setSerialTxPin_08005b3c(HardwareSerial *serial,uint32_t pinIndex)\n\n{\n  PinName pinName;\n  \n  if (pinIndex < 0x3c) {\n    pinName = (&digitalPin)[pinIndex];\n  }\n  else {\n    pinName = NC;\n  }\n  (serial->_serial).pinpinIndex = pinName;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b3c": "set_serial_tx_pin_08005b3c",
                "this": "serial",
                "_tx": "pinIndex",
                "PVar1": "pinName"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b54": {
            "entrypoint": "0x08005b54",
            "current_name": "initialize_serial_interface_08005b54",
            "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * serialInterface, void *\n   peripheral) */\n\nHardwareSerial * __serialInterfacecall HardwareSerial::initializeSerialInterface_08005b54(HardwareSerial *serialInterface,void *peripheral)\n\n{\n  PinName_conflict pin;\n  EVP_PKEY_CTX *ctx1;\n  EVP_PKEY_CTX *ctx2;\n  EVP_PKEY_CTX *ctx3;\n  \n  (serialInterface->super_Stream).super_Print.write_error = 0;\n  (serialInterface->super_Stream)._timeout = 1000;\n  (serialInterface->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&PTR_write_1_08007804;\n  if (serialInterface == &Serial2) {\n    setRx(&Serial2,0);\n    setTx(&Serial2,1);\n    ctx2 = ctx3;\n  }\n  else {\n    pin = pinmap_pin(peripheral,(PinMap_conflict *)&PinMap_UART_RX);\n    (serialInterface->_serial).pin_rx = pin;\n    pin = pinmap_pin(peripheral,(PinMap_conflict *)&PinMap_UART_TX);\n    (serialInterface->_serial).pin_tx = pin;\n    ctx2 = ctx1;\n  }\n  init(serialInterface,ctx2);\n  return serialInterface;\n}\n\n",
            "renaming": {
                "this": "serialInterface",
                "PVar1": "pin",
                "extraout_r1": "ctx1",
                "ctx": "ctx2",
                "extraout_r1_00": "ctx3",
                "FUN_08005b54": "initialize_serial_interface_08005b54"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "setTx",
                "init",
                "pinmap_pin",
                "setRx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bb0": {
            "entrypoint": "0x08005bb0",
            "current_name": "initialize_serial_08005bb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerial_08005bb0(int initializeFlag,int priority)\n\n{\n  if (initializeFlag != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    Serial2Constructor(&Serial2,(void *)0x40004400);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bb0": "initialize_serial_08005bb0",
                "__initialize_p": "initializeFlag",
                "__priority": "priority",
                "HardwareSerial::HardwareSerial": "Serial2Constructor"
            },
            "calling": [
                "_GLOBAL__sub_I_Serial2"
            ],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bd4": {
            "entrypoint": "0x08005bd4",
            "current_name": "initialize_static_data_08005bd4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_08005bd4(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bd4": "initialize_static_data_08005bd4"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005be2": {
            "entrypoint": "0x08005be2",
            "current_name": "print_ip_address_08005be2",
            "code": "\n/* DWARF original printerrototyprintere: size_t  printerrintTo(IPAddress * ipAddress, Print * printer) */\n\nsize_t __ipAddresscall IPAddress::printIPAddress_08005be2(IPAddress *ipAddress,Print *printer)\n\n{\n  size_t numBytesPrinted;\n  size_t dotPrinted;\n  int index;\n  int total;\n  \n  total = 0;\n  for (index = 0; index < 3; index = index + 1) {\n    numBytesPrinted = Print::printerrint(printer,(ipAddress->_address).bytes[index],10);\n    dotPrinted = Print::printerrint(printer,'.');\n    total = total + numBytesPrinted + dotPrinted;\n  }\n  numBytesPrinted = Print::printerrint(printer,(ipAddress->_address).bytes[3],10);\n  return numBytesPrinted + total;\n}\n\n",
            "renaming": {
                "FUN_08005be2": "print_ip_address_08005be2",
                "this": "ipAddress",
                "p": "printer",
                "iVar3": "index",
                "iVar4": "total",
                "sVar1": "numBytesPrinted",
                "sVar2": "dotPrinted"
            },
            "calling": [],
            "called": [
                "print",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c1c": {
            "entrypoint": "0x08005c1c",
            "current_name": "initialize_ip_address_08005c1c",
            "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * ip, uint8_t octet1, uint8_t\n   octet2, uint8_t octet3, uint8_t octet4) */\n\nIPAddress * __ipcall\nIPAddress::initializeIPAddress_08005c1c(IPAddress *ip,uint8_t octet1,uint8_t octet2,uint8_t octet3,\n          uint8_t octet4)\n\n{\n  (ip->super_Printable)._vptr_Printable = (_func_int_varargs **)&DAT_08007858;\n  (ip->_address).bytes[0] = octet1;\n  (ip->_address).bytes[1] = octet2;\n  (ip->_address).bytes[2] = octet3;\n  (ip->_address).bytes[3] = octet4;\n  return ip;\n}\n\n",
            "renaming": {
                "this": "ip",
                "first_octet": "octet1",
                "second_octet": "octet2",
                "third_octet": "octet3",
                "fourth_octet": "octet4",
                "FUN_08005c1c": "initialize_ip_address_08005c1c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c38": {
            "entrypoint": "0x08005c38",
            "current_name": "FUNC_08005c38",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005c38(int __initialize_p,int __priority)\n\n{\n  if ((__initialize_p == 1) && (__priority == 0xffff)) {\n    IPAddress::IPAddress(&INADDR_NONE,'\\0','\\0','\\0','\\0');\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005c38": "FUNC_08005c38"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "called": [
                "IPAddress"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005c64": {
            "entrypoint": "0x08005c64",
            "current_name": "initialize_static_data_08005c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_08005c64(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005c64": "initialize_static_data_08005c64"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c72": {
            "entrypoint": "0x08005c72",
            "current_name": "print_data_08005c72",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005c86 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * this, uint8_t * buffer, size_t size) */\n\nssize_t thiscall Print::print_data_08005c72(Print *this,int file_descriptor,void *buffer,size_t size)\n\n{\n  Print *print_ptr;\n  int iteration_count;\n  \n  iteration_count = 0;\n  print_ptr = this;\n  while( true ) {\n    if (buffer == (void *)0x0) {\n      return iteration_count;\n    }\n    print_ptr = (Print *)(**this->_vptr_Print)(print_ptr,(uint)*(byte *)file_descriptor,buffer,*this->_vptr_Print,size)\n    ;\n    if (print_ptr == (Print *)0x0) break;\n    iteration_count = iteration_count + 1;\n    file_descriptor = (int)(file_descriptor + 1);\n    buffer = (void *)((int)buffer + -1);\n  }\n  return iteration_count;\n}\n\n",
            "renaming": {
                "FUN_08005c72": "print_data_08005c72",
                "__thiscall": "thiscall",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size",
                "pPVar1": "print_ptr",
                "iVar2": "iteration_count"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c96": {
            "entrypoint": "0x08005c96",
            "current_name": "print_string_08005c96",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cae */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * printInstance, char * stringInput) */\n\nsize_t __printInstancecall Print::printString_08005c96(Print *printInstance,char *stringInput)\n\n{\n  size_t inputLength;\n  size_t returnValue;\n  \n  if (stringInput != (char *)0x0) {\n    inputLength = stringInputlen(stringInput);\n    returnValue = (*printInstance->_vptr_Print[1])(inputLength,stringInput,inputLength);\n    return returnValue;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005c96": "print_string_08005c96",
                "this": "printInstance",
                "str": "stringInput",
                "sVar1": "inputLength",
                "sVar2": "returnValue"
            },
            "calling": [
                "setup",
                "loop",
                "printFloat",
                "println"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cb6": {
            "entrypoint": "0x08005cb6",
            "current_name": "print_character_08005cb6",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cbc */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * printObject, char c) */\n\nsize_t __printObjectcall Print::printCharacter_08005cb6(Print *printObject,char c)\n\n{\n  size_t result;\n  \n  result = (**printObject->_vptr_Print)(printObject,(int)c);\n  return result;\n}\n\n",
            "renaming": {
                "this": "printObject",
                "sVar1": "result",
                "FUN_08005cb6": "print_character_08005cb6"
            },
            "calling": [
                "print",
                "printTo",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cc0": {
            "entrypoint": "0x08005cc0",
            "current_name": "print_message_08005cc0",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cca */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  println(Print * printObject) */\n\nsize_t __printObjectcall Print::printMessage_08005cc0(Print *printObject)\n\n{\n  size_t result;\n  \n  result = (*printObject->_vptr_Print[1])(printObject,&DAT_0800786c,2);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005cc0": "print_message_08005cc0",
                "this": "printObject",
                "sVar1": "result"
            },
            "calling": [
                "println",
                "println"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cd4": {
            "entrypoint": "0x08005cd4",
            "current_name": "print_and_println_08005cd4",
            "code": "\n/* DWARF origisizeal prototype: size_t  prisizetlsize(Prisizet * printObject, char * c) */\n\nsize_t __printObjectcall Prisizet::printAndPrintln_08005cd4(Prisizet *printObject,char *c)\n\n{\n  size_t printReturnValue;\n  size_t size;\n  size_t printlnReturnValue;\n  \n  printReturnValue = prisizet(printObject,c);\n  printlnReturnValue = prisizetlsize(printObject);\n  retursize printlnReturnValue + printReturnValue;\n}\n\n",
            "renaming": {
                "FUN_08005cd4": "print_and_println_08005cd4",
                "this": "printObject",
                "sVar1": "printReturnValue",
                "n": "size",
                "sVar2": "printlnReturnValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "println",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005ce8": {
            "entrypoint": "0x08005ce8",
            "current_name": "print_number_08005ce8",
            "code": "\n/* WARNING: Heritage AFTER dead requotientoval. Exaquotientple locationumber: r0 : 0x08005d38 */\n/* WARNING: Restarted to delay deadcode eliquotientinumberationumber for space: register */\n/* WARNING: Exceeded quotientaxiquotientuquotient restarts with quotientore penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbertNuquotientber(Prinumbert * printer, ulonumberg number, uinumbert8_t base) */\n\nsize_t __printercall Prinumbert::printNumber_08005ce8(Prinumbert *printer,ulonumberg number,uinumbert8_t base)\n\n{\n  char charValue;\n  char c;\n  size_t stringLength;\n  size_t result;\n  ulonumberg quotient;\n  uinumbert remainder;\n  uinumbert modifiedBase;\n  uinumbert newQuotient;\n  char *buffer;\n  char numberBuffer [33];\n  \n  modifiedBase = (uinumbert)base;\n  numberBuffer[32] = '\\0';\n  if (modifiedBase < 2) {\n    modifiedBase = 10;\n  }\n  buffer = numberBuffer + 0x20;\n  quotient = number;\n  do {\n    newQuotient = quotient / modifiedBase;\n    remainder = (quotient & 0xff) - (newQuotient * modifiedBase & 0xff) & 0xff;\n    buffer = buffer + -1;\n    charValue = (char)remainder;\n    if (remainder < 10) {\n      charValue = charValue + '0';\n    }\n    else {\n      charValue = charValue + '7';\n    }\n    *buffer = charValue;\n    quotient = newQuotient;\n  } while (newQuotient != 0);\n  if (buffer == (char *)0x0) {\n    result = 0;\n  }\n  else {\n    stringLength = strlenumber(buffer);\n    result = (*printer->_vptr_Prinumbert[1])(stringLength,buffer,stringLength);\n  }\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08005ce8": "print_number_08005ce8",
                "this": "printer",
                "n": "number",
                "cVar1": "charValue",
                "sVar2": "stringLength",
                "sVar3": "result",
                "m": "quotient",
                "uVar4": "remainder",
                "uVar5": "modifiedBase",
                "uVar6": "newQuotient",
                "__s": "buffer",
                "buf": "numberBuffer"
            },
            "calling": [
                "print",
                "print"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d42": {
            "entrypoint": "0x08005d42",
            "current_name": "print_with_base_08005d42",
            "code": "\n/* WARNING: Heritemporaryage AFTER dead removal. Example locatemporaryionumber: r0 : 0x08005d5c */\n/* WARNING: Restemporaryartemporaryed temporaryo delay deadcode eliminumberatemporaryionumber for space: registemporaryer */\n/* WARNING: Exceeded maximum restemporaryartemporarys witemporaryh more penumberdinumberg */\n/* DWARF originumberal protemporaryotemporaryype: size_temporary  prinumbertemporary(Prinumbertemporary * printObject, lonumberg number, inumbertemporary numberBase) */\n\nsize_temporary __printObjectcall Prinumbertemporary::printWithBase_08005d42(Prinumbertemporary *printObject,lonumberg number,inumbertemporary numberBase)\n\n{\n  size_temporary result1;\n  inumbertemporary temporary;\n  size_temporary result2;\n  \n  if (numberBase == 0) {\n    result1 = (**printObject->_vptemporaryr_Prinumbertemporary)(printObject,number & 0xff);\n    retemporaryurnumber result1;\n  }\n  if (numberBase != 10) {\n    result1 = prinumbertemporaryNumber(printObject,number,(uinumbertemporary8_temporary)numberBase);\n    retemporaryurnumber result1;\n  }\n  if (-1 < number) {\n    result1 = prinumbertemporaryNumber(printObject,number,'\\number');\n    retemporaryurnumber result1;\n  }\n  result1 = prinumbertemporary(printObject,'-');\n  result2 = prinumbertemporaryNumber(printObject,-number,'\\number');\n  retemporaryurnumber result2 + result1;\n}\n\n",
            "renaming": {
                "FUN_08005d42": "print_with_base_08005d42",
                "this": "printObject",
                "n": "number",
                "base": "numberBase",
                "sVar1": "result1",
                "t": "temporary",
                "sVar2": "result2"
            },
            "calling": [
                "print"
            ],
            "called": [
                "print",
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d82": {
            "entrypoint": "0x08005d82",
            "current_name": "print_in_base_08005d82",
            "code": "\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printer, inumbert number, inumbert numberBase) */\n\nsize_t __printercall Prinumbert::printInBase_08005d82(Prinumbert *printer,inumbert number,inumbert numberBase)\n\n{\n  size_t result;\n  \n  result = prinumbert(printer,number,numberBase);\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08005d82": "print_in_base_08005d82",
                "this": "printer",
                "n": "number",
                "base": "numberBase",
                "sVar1": "result"
            },
            "calling": [
                "loop",
                "printFloat"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d8a": {
            "entrypoint": "0x08005d8a",
            "current_name": "print_number_or_character_08005d8a",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x08005d9c */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printInstance, ulonumberg number, inumbert numberBase) */\n\nsize_t __printInstancecall Prinumbert::printNumberOrCharacter_08005d8a(Prinumbert *printInstance,ulonumberg number,inumbert numberBase)\n\n{\n  size_t result;\n  \n  if (numberBase != 0) {\n    result = prinumbertNumber(printInstance,number,(uinumbert8_t)numberBase);\n    returnumber result;\n  }\n  result = (**printInstance->_vptr_Prinumbert)(printInstance,number & 0xff);\n  returnumber result;\n}\n\n",
            "renaming": {
                "this": "printInstance",
                "n": "number",
                "base": "numberBase",
                "sVar1": "result",
                "FUN_08005d8a": "print_number_or_character_08005d8a"
            },
            "calling": [
                "print",
                "printFloat"
            ],
            "called": [
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005da0": {
            "entrypoint": "0x08005da0",
            "current_name": "print_in_base_08005da0",
            "code": "\n/* DWARF original prototype: size_t  print(Print * printer, uchar b, int number_base) */\n\nsize_t __printercall Print::print_in_base_08005da0(Print *printer,uchar b,int number_base)\n\n{\n  size_t size;\n  \n  size = print(printer,(uint)b,number_base);\n  return size;\n}\n\n",
            "renaming": {
                "FUN_08005da0": "print_in_base_08005da0",
                "this": "printer",
                "base": "number_base",
                "sVar1": "size"
            },
            "calling": [
                "printTo"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005da8": {
            "entrypoint": "0x08005da8",
            "current_name": "print_float_08005da8",
            "code": "\n/* DWARF origiunsignedNal prototype: size_t  priunsignedNtFloat(PriunsignedNt * printer, double floatingNumber, uiunsignedNt8_t decimalDigits) */\n\nsize_t __printercall PriunsignedNt::printFloat_08005da8(PriunsignedNt *printer,double floatingNumber,uiunsignedNt8_t decimalDigits)\n\n{\n  iunsignedNt unordered;\n  ulounsignedNg unsignedN;\n  ulounsignedNg integerPart;\n  size_t printedSize;\n  iunsignedNt toPriunsignedNt;\n  size_t totalSize;\n  byte counter;\n  uunsignedNdefiunsignedNed8 dividedNumber;\n  uunsignedNdefiunsignedNed8 floatConversion;\n  \n  unordered = unorderedCompare();\n  if (unordered == 0) {\n    unordered = unorderedCompare();\n    if ((unordered == 0) && (unordered = doubleCompareLessThanOrEqual(), unordered == 0)) {\n      totalSize = priunsignedNt(printer,\"iunsignedNf\");\n    }\n    else {\n      unordered = doubleCompareGreaterThan();\n      if (unordered == 0) {\n        unordered = doubleCompareLessThan();\n        if (unordered == 0) {\n          unordered = doubleCompareLessThan();\n          if (unordered == 0) {\n            totalSize = 0;\n          }\n          else {\n            totalSize = priunsignedNt(printer,'-');\n          }\n          dividedNumber = 0x3fe0000000000000;\n          for (counter = 0; counter < floatingNumber._0_1_; counter = counter + 1) {\n            dividedNumber = divideDouble((iunsignedNt)dividedNumber,(iunsignedNt)((ulounsignedNglounsignedNg)dividedNumber >> 0x20),0,0x40240000);\n          }\n          dividedNumber = doubleAddition();\n          unsignedN = doubleToUnsignedInteger();\n          floatConversion = unsignedIntegerToDouble();\n          integerPart = (ulounsignedNg)floatConversion;\n          dividedNumber = doubleSubtraction((iunsignedNt)dividedNumber,(iunsignedNt)((ulounsignedNglounsignedNg)dividedNumber >> 0x20),integerPart,\n                           (iunsignedNt)((ulounsignedNglounsignedNg)floatConversion >> 0x20));\n          printedSize = priunsignedNt(printer,unsignedN,10);\n          totalSize = totalSize + printedSize;\n          if (floatingNumber._0_1_ != 0) {\n            printedSize = priunsignedNt(printer,\".\");\n            totalSize = totalSize + printedSize;\n          }\n          while( true ) {\n            if (floatingNumber._0_1_ == 0) break;\n            dividedNumber = multiplyDouble((iunsignedNt)dividedNumber,(iunsignedNt)((ulounsignedNglounsignedNg)dividedNumber >> 0x20),0,0x40240000);\n            unordered = doubleToInteger();\n            printedSize = priunsignedNt(printer,unordered,10);\n            totalSize = totalSize + printedSize;\n            floatConversion = integerToDouble(unordered);\n            dividedNumber = doubleSubtraction((iunsignedNt)dividedNumber,(iunsignedNt)((ulounsignedNglounsignedNg)dividedNumber >> 0x20),(iunsignedNt)floatConversion,\n                             (iunsignedNt)((ulounsignedNglounsignedNg)floatConversion >> 0x20));\n            floatingNumber._0_1_ = floatingNumber._0_1_ - 1;\n          }\n        }\n        else {\n          totalSize = priunsignedNt(printer,\"ovf\");\n        }\n      }\n      else {\n        totalSize = priunsignedNt(printer,\"ovf\");\n      }\n    }\n  }\n  else {\n    totalSize = priunsignedNt(printer,\"unsignedNaunsignedN\");\n  }\n  returunsignedN totalSize;\n}\n\n",
            "renaming": {
                "FUN_08005da8": "print_float_08005da8",
                "this": "printer",
                "number": "floatingNumber",
                "digits": "decimalDigits",
                "iVar1": "unordered",
                "n": "unsignedN",
                "int_part": "integerPart",
                "sVar2": "printedSize",
                "sVar3": "totalSize",
                "bVar4": "counter",
                "uVar5": "dividedNumber",
                "uVar6": "floatConversion",
                "__unorddf2": "unorderedCompare",
                "__aeabi_dcmple": "doubleCompareLessThanOrEqual",
                "__aeabi_dcmpgt": "doubleCompareGreaterThan",
                "__aeabi_dcmplt": "doubleCompareLessThan",
                "__divdf3": "divideDouble",
                "__aeabi_dadd": "doubleAddition",
                "__fixunsdfsi": "doubleToUnsignedInteger",
                "__floatunsidf": "unsignedIntegerToDouble",
                "__subdf3": "doubleSubtraction",
                "__fixdfsi": "doubleToInteger",
                "__muldf3": "multiplyDouble",
                "__floatsidf": "integerToDouble"
            },
            "calling": [
                "print"
            ],
            "called": [
                "__unorddf2",
                "__floatsidf",
                "print",
                "print",
                "__fixunsdfsi",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__muldf3",
                "print",
                "__subdf3",
                "print",
                "__fixdfsi",
                "__floatunsidf",
                "__divdf3",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f2c": {
            "entrypoint": "0x08005f2c",
            "current_name": "print_formatted_float_08005f2c",
            "code": "\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printer, double number, inumbert decimalPlaces) */\n\nsize_t __printercall Prinumbert::printFormattedFloat_08005f2c(Prinumbert *printer,double number,inumbert decimalPlaces)\n\n{\n  size_t formattedFloatSize;\n  unumberdefinumbered4 stackVar;\n  \n  formattedFloatSize = prinumbertFloat(printer,(double)CONCAT44(stackVar,(uinumbert)number._0_1_),number._0_1_);\n  returnumber formattedFloatSize;\n}\n\n",
            "renaming": {
                "FUN_08005f2c": "print_formatted_float_08005f2c",
                "this": "printer",
                "n": "number",
                "digits": "decimalPlaces",
                "in_stack_fffffff4": "stackVar",
                "sVar1": "formattedFloatSize"
            },
            "calling": [
                "println",
                "loop"
            ],
            "called": [
                "printFloat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f40": {
            "entrypoint": "0x08005f40",
            "current_name": "print_double_with_digits_08005f40",
            "code": "\n/* DWARF origicountal prototype: size_t  pricounttlcount(Pricountt * printObject, double number, icountt decimalDigits) */\n\nsize_t __printObjectcall Pricountt::printDoubleWithDigits_08005f40(Pricountt *printObject,double number,icountt decimalDigits)\n\n{\n  size_t printResult;\n  size_t count;\n  size_t printlnResult;\n  ucountdeficounted4 stackVariable;\n  \n  printResult = pricountt(printObject,(double)CONCAT44(stackVariable,number._0_4_),number._0_4_);\n  printlnResult = pricounttlcount(printObject);\n  returcount printlnResult + printResult;\n}\n\n",
            "renaming": {
                "FUN_08005f40": "print_double_with_digits_08005f40",
                "this": "printObject",
                "num": "number",
                "digits": "decimalDigits",
                "sVar1": "printResult",
                "n": "count",
                "sVar2": "printlnResult",
                "in_stack_ffffffec": "stackVariable"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "print",
                "println"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f5c": {
            "entrypoint": "0x08005f5c",
            "current_name": "FUNC_08005f5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005f5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005f5c": "FUNC_08005f5c"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005f5e": {
            "entrypoint": "0x08005f5e",
            "current_name": "initialize_context_08005f5e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeContext_08005f5e(void)\n\n{\n  EVP_PKEY_CTX *context;\n  \n  context = (EVP_PKEY_CTX *)0x3;\n  setInterruptPriorityGrouping(3);\n  initialize(context);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005f5e": "initialize_context_08005f5e",
                "ctx": "context",
                "HAL_NVIC_SetPriorityGrouping": "setInterruptPriorityGrouping",
                "init": "initialize"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f6c": {
            "entrypoint": "0x08005f6c",
            "current_name": "main_loop_08005f6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint main_loop_08005f6c(void)\n\n{\n  initVariant();\n  setup();\n  do {\n    loop();\n    serialEventRun();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005f6c": "main_loop_08005f6c"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "setup",
                "serialEventRun",
                "loop",
                "initVariant"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f8c": {
            "entrypoint": "0x08005f8c",
            "current_name": "count_bits_set_08005f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t count_bits_set_08005f8c(uint16_t input_value)\n\n{\n  uint temp_value;\n  uint8_t bit_count;\n  \n  bit_count = '\\0';\n  for (temp_value = (uint)input_value; temp_value != 1; temp_value = temp_value >> 1) {\n    bit_count = bit_count + '\\x01';\n  }\n  return bit_count;\n}\n\n",
            "renaming": {
                "FUN_08005f8c": "count_bits_set_08005f8c",
                "pin": "input_value",
                "uVar1": "temp_value",
                "uVar2": "bit_count"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005fa0": {
            "entrypoint": "0x08005fa0",
            "current_name": "deallocate_gpio_irq_08005fa0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid deallocate_gpio_irq_08005fa0(void *ptr)\n\n{\n  gpio_irq_conf_str *current_entry;\n  _Manager_type manager_type;\n  gpio_irq_conf_str *next_entry;\n  \n  current_entry = (gpio_irq_conf_str *)&__malloc_free_list;\n  while (next_entry = current_entry, next_entry != gpio_irq_conf) {\n    manager_type = next_entry[-1].callback.super__Function_base._M_manager;\n    current_entry = next_entry + -1;\n    if (manager_type != (_Manager_type)0x0) {\n      (*manager_type)((_Any_data *)&next_entry[-1].callback,(_Any_data *)&next_entry[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005fa0": "deallocate_gpio_irq_08005fa0",
                "param_1": "ptr",
                "pgVar1": "current_entry",
                "p_Var2": "manager_type",
                "pgVar3": "next_entry"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005fc8": {
            "entrypoint": "0x08005fc8",
            "current_name": "initialize_gpioirq_08005fc8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeGPIOIRQ_08005fc8(int initialize_flag,int priority)\n\n{\n  if (initialize_flag != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    gpio_irq_configuration[0].irqnb = ExternalInterruptIRQ0;\n    gpio_irq_configuration[0].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[1].irqnb = ExternalInterruptIRQ1;\n    gpio_irq_configuration[1].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[2].irqnb = ExternalInterruptIRQ2;\n    gpio_irq_configuration[2].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[3].irqnb = ExternalInterruptIRQ3;\n    gpio_irq_configuration[3].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[4].irqnb = ExternalInterruptIRQ4;\n    gpio_irq_configuration[4].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[5].irqnb = ExternalInterruptIRQ9_5;\n    gpio_irq_configuration[5].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[6].irqnb = ExternalInterruptIRQ9_5;\n    gpio_irq_configuration[6].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[7].irqnb = ExternalInterruptIRQ9_5;\n    gpio_irq_configuration[7].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[8].irqnb = ExternalInterruptIRQ9_5;\n    gpio_irq_configuration[8].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[9].irqnb = ExternalInterruptIRQ9_5;\n    gpio_irq_configuration[9].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[10].irqnb = ExternalInterruptIRQ15_10;\n    gpio_irq_configuration[10].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[11].irqnb = ExternalInterruptIRQ15_10;\n    gpio_irq_configuration[11].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[12].irqnb = ExternalInterruptIRQ15_10;\n    gpio_irq_configuration[12].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[13].irqnb = ExternalInterruptIRQ15_10;\n    gpio_irq_configuration[13].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[14].irqnb = ExternalInterruptIRQ15_10;\n    gpio_irq_configuration[14].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[15].irqnb = ExternalInterruptIRQ15_10;\n    gpio_irq_configuration[15].callback.function_manager = (_Manager_type)0x0;\n    atexit_function(0,0x8005fa1,0x20000000);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005fc8": "initialize_gpioirq_08005fc8",
                "__initialize_p": "initialize_flag",
                "__priority": "priority",
                "gpio_irq_conf": "gpio_irq_configuration",
                "EXTI0_IRQn": "ExternalInterruptIRQ0",
                "EXTI1_IRQn": "ExternalInterruptIRQ1",
                "EXTI2_IRQn": "ExternalInterruptIRQ2",
                "EXTI3_IRQn": "ExternalInterruptIRQ3",
                "EXTI4_IRQn": "ExternalInterruptIRQ4",
                "EXTI9_5_IRQn": "ExternalInterruptIRQ9_5",
                "EXTI15_10_IRQn": "ExternalInterruptIRQ15_10",
                "super__Function_base._M_manager": "function_manager",
                "__aeabi_atexit": "atexit_function"
            },
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006074": {
            "entrypoint": "0x08006074",
            "current_name": "handle_external_interrupt_08006074",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08006074(void)\n\n{\n  handleGPIOExternalInterrupt(1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006074": "handle_external_interrupt_08006074",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800607e": {
            "entrypoint": "0x0800607e",
            "current_name": "handle_gpio_exti_0800607e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_0800607e(void)\n\n{\n  handle_EXTI_interrupt(2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800607e": "handle_gpio_exti_0800607e",
                "HAL_GPIO_EXTI_IRQHandler": "handle_EXTI_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006088": {
            "entrypoint": "0x08006088",
            "current_name": "handle_external_interrupt_08006088",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08006088(void)\n\n{\n  gpioExternalInterruptHandler(4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006088": "handle_external_interrupt_08006088",
                "HAL_GPIO_EXTI_IRQHandler": "gpioExternalInterruptHandler"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006092": {
            "entrypoint": "0x08006092",
            "current_name": "handle_external_interrupt_08006092",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08006092(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006092": "handle_external_interrupt_08006092"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800609c": {
            "entrypoint": "0x0800609c",
            "current_name": "handle_gpio_interrupt_0800609c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOInterrupt_0800609c(void)\n\n{\n  triggerGPIOInterrupt(0x10);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800609c": "handle_gpio_interrupt_0800609c",
                "HAL_GPIO_EXTI_IRQHandler": "triggerGPIOInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060a6": {
            "entrypoint": "0x080060a6",
            "current_name": "handle_gpio_interrupts_080060a6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOInterrupts_080060a6(void)\n\n{\n  uint counter;\n  \n  for (counter = 0x20; counter < 0x201; counter = counter << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)counter);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060a6": "handle_gpio_interrupts_080060a6",
                "uVar1": "counter"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060bc": {
            "entrypoint": "0x080060bc",
            "current_name": "handle_interrupts_080060bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleInterrupts_080060bc(void)\n\n{\n  uint interval;\n  \n  for (interval = 0x400; interval < 0x8001; interval = interval << 1) {\n    handleGPIOInterrupt((GPIOInterruptPin)interval);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060bc": "handle_interrupts_080060bc",
                "uVar1": "interval",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOInterrupt",
                "uint16_t": "GPIOInterruptPin"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060d4": {
            "entrypoint": "0x080060d4",
            "current_name": "invoke_function_080060d4",
            "code": "\n/* DWARF original prototype: invokeFunction_080060d4  operator()(function<invokeFunction_080060d4()> * functionPointer) */\n\ninvokeFunction_080060d4 __functionPointercall std::function<invokeFunction_080060d4()>::invoke_function_080060d4(function<invokeFunction_080060d4()> *functionPointer)\n\n{\n  if ((functionPointer->parentBase).manager != (_Manager_type)0x0) {\n    (*functionPointer->invoker)((data *)functionPointer);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
            "renaming": {
                "this": "functionPointer",
                "super__Function_base": "parentBase",
                "_M_manager": "manager",
                "_M_invoker": "invoker",
                "_Any_data": "data",
                "void": "invokeFunction",
                "FUN_080060d4": "invoke_function_080060d4"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060e4": {
            "entrypoint": "0x080060e4",
            "current_name": "process_gpio_interrupt_080060e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processGPIOInterrupt_080060e4(uint16_t pinNumber)\n\n{\n  byte pinId;\n  uint8_t interruptId;\n  \n  pinId = get_pin_id(pinNumber);\n  if (gpio_irq_conf[pinId].callback.super__Function_base._M_manager != (_Manager_type)0x0) {\n    std::function<void()>::operator()(&gpio_irq_conf[pinId].callback);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060e4": "process_gpio_interrupt_080060e4",
                "GPIO_Pin": "pinNumber",
                "bVar1": "pinId",
                "irq_id": "interruptId"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006104": {
            "entrypoint": "0x08006104",
            "current_name": "initialize_static_objects_08006104",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_objects_08006104(void)\n\n{\n  perform_static_initialization_and_destruction(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006104": "initialize_static_objects_08006104",
                "__static_initialization_and_destruction_0": "perform_static_initialization_and_destruction"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006112": {
            "entrypoint": "0x08006112",
            "current_name": "initialize_08006112",
            "code": "\nvoid initialize_08006112(undefined4 exitFunction,undefined4 cleanupFunction)\n\n{\n  __cxa_atexit(cleanupFunction,exitFunction);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006112": "initialize_08006112",
                "param_1": "exitFunction",
                "param_2": "cleanupFunction"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800611c": {
            "entrypoint": "0x0800611c",
            "current_name": "log_assertion_failure_0800611c",
            "code": "\nvoid logAssertionFailure_0800611c(undefined4 filename,undefined4 lineNumber,char *functionName,undefined4 message)\n\n{\n  char *functionString;\n  \n  if (functionName == (char *)0x0) {\n    functionName = \"\";\n    functionString = functionName;\n  }\n  else {\n    functionString = \", function: \";\n  }\n  fiprintf(*(FILE **)(_impure_ptr + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           message,filename,lineNumber,functionString,functionName,message);\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_0800611c": "log_assertion_failure_0800611c",
                "param_1": "filename",
                "param_2": "lineNumber",
                "param_3": "functionName",
                "param_4": "message",
                "pcVar1": "functionString"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "fiprintf",
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006158": {
            "entrypoint": "0x08006158",
            "current_name": "shift_left_by32_08006158",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08006160) */\n\nlonglong shiftLeftBy32_08006158(undefined4 inputValue,uint shiftAmount)\n\n{\n  return (ulonglong)shiftAmount << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08006158": "shift_left_by32_08006158",
                "param_1": "inputValue",
                "param_2": "shiftAmount"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006174": {
            "entrypoint": "0x08006174",
            "current_name": "format_and_print_08006174",
            "code": "\nint formatAndPrint_08006174(FILE *file,char *formatString,...)\n\n{\n  int result;\n  undefined4 param1;\n  undefined4 param2;\n  undefined4 param3;\n  undefined4 param4;\n  \n  param3 = param1;\n  param4 = param2;\n  result = _vfiprintf_r(impurePointer,file,formatString,&param3,file,&param3);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006174": "format_and_print_08006174",
                "__stream": "file",
                "__format": "formatString",
                "iVar1": "result",
                "in_r2": "param1",
                "in_r3": "param2",
                "uStack_8": "param3",
                "uStack_4": "param4",
                "_impure_ptr": "impurePointer"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006198": {
            "entrypoint": "0x08006198",
            "current_name": "initialize_arrays_08006198",
            "code": "\nvoid initializeArrays_08006198(void)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    (*(code *)(&arrayEnd)[index])();\n  }\n  initialize();\n  for (index = 0; index != 10; index = index + 1) {\n    (*(code *)(&arrayEnd)[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006198": "initialize_arrays_08006198",
                "iVar1": "index",
                "__preinit_array_end": "arrayEnd",
                "_init": "initialize"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "premain"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080061e0": {
            "entrypoint": "0x080061e0",
            "current_name": "memset_function_080061e0",
            "code": "\nvoid * memset_function_080061e0(void *destination,int value,size_t length)\n\n{\n  undefined *current_byte;\n  \n  for (current_byte = (undefined *)destination; current_byte != (undefined *)(length + (int)destination); current_byte = current_byte + 1) {\n    *current_byte = (char)value;\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_080061e0": "memset_function_080061e0",
                "__s": "destination",
                "__c": "value",
                "__n": "length",
                "puVar1": "current_byte"
            },
            "calling": [
                "std.isra.0",
                "__sfp",
                "adc_read_value",
                "__sfmoreglue"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080061f0": {
            "entrypoint": "0x080061f0",
            "current_name": "reorganized_memory_080061f0",
            "code": "\nvoid reorganizedMemory_080061f0(undefined4 *outputArray,int sizeOfArray,undefined4 unusedParam1,undefined4 unusedParam2)\n\n{\n  int **extraOutput;\n  int **tempPtr1;\n  int **currentPtr;\n  int *tempVar;\n  int **tempPtr2;\n  int **adjustedPtr;\n  \n  if (sizeOfArray == 0) {\n    return;\n  }\n  adjustedPtr = (int **)(sizeOfArray + -4);\n  if (*(int *)(sizeOfArray + -4) < 0) {\n    adjustedPtr = (int **)((int)adjustedPtr + *(int *)(sizeOfArray + -4));\n  }\n  __malloc_lock();\n  currentPtr = (int **)&__malloc_free_list;\n  if (__malloc_free_list == (int **)0x0) {\n    adjustedPtr[1] = (int *)0x0;\n    tempPtr1 = extraOutput;\n    __malloc_free_list = adjustedPtr;\n  }\n  else {\n    currentPtr = __malloc_free_list;\n    if (adjustedPtr < __malloc_free_list) {\n      tempPtr1 = (int **)*adjustedPtr;\n      currentPtr = (int **)((int)adjustedPtr + (int)tempPtr1);\n      if (__malloc_free_list == currentPtr) {\n        tempVar = *__malloc_free_list;\n        __malloc_free_list = (int **)__malloc_free_list[1];\n        currentPtr = (int **)((int)tempVar + (int)tempPtr1);\n        *adjustedPtr = (int *)currentPtr;\n      }\n      adjustedPtr[1] = (int *)__malloc_free_list;\n      __malloc_free_list = adjustedPtr;\n    }\n    else {\n      do {\n        tempPtr2 = currentPtr;\n        currentPtr = (int **)tempPtr2[1];\n        if (currentPtr == (int **)0x0) break;\n      } while (currentPtr <= adjustedPtr);\n      tempPtr1 = (int **)*tempPtr2;\n      if ((int **)((int)tempPtr2 + (int)tempPtr1) == adjustedPtr) {\n        tempPtr1 = (int **)((int)tempPtr1 + (int)*adjustedPtr);\n        *tempPtr2 = (int *)tempPtr1;\n        if (currentPtr == (int **)((int)tempPtr2 + (int)tempPtr1)) {\n          tempVar = *currentPtr;\n          currentPtr = (int **)currentPtr[1];\n          tempPtr1 = (int **)((int)tempPtr1 + (int)tempVar);\n          *tempPtr2 = (int *)tempPtr1;\n          tempPtr2[1] = (int *)currentPtr;\n        }\n      }\n      else if (adjustedPtr < (int **)((int)tempPtr2 + (int)tempPtr1)) {\n        *outputArray = 0xc;\n      }\n      else {\n        tempPtr1 = (int **)((int)adjustedPtr + (int)*adjustedPtr);\n        if (currentPtr == tempPtr1) {\n          tempVar = *currentPtr;\n          currentPtr = (int **)currentPtr[1];\n          tempPtr1 = (int **)((int)tempVar + (int)*adjustedPtr);\n          *adjustedPtr = (int *)tempPtr1;\n        }\n        adjustedPtr[1] = (int *)currentPtr;\n        tempPtr2[1] = (int *)adjustedPtr;\n      }\n    }\n  }\n  __malloc_unlock(outputArray,tempPtr1,currentPtr,unusedParam2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080061f0": "reorganized_memory_080061f0",
                "param_1": "outputArray",
                "param_2": "sizeOfArray",
                "param_3": "unusedParam1",
                "param_4": "unusedParam2",
                "extraout_r1": "extraOutput",
                "ppiVar1": "tempPtr1",
                "ppiVar2": "currentPtr",
                "piVar3": "tempVar",
                "ppiVar4": "tempPtr2",
                "ppiVar5": "adjustedPtr"
            },
            "calling": [
                "__swsetup_r",
                "__sflush_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006288": {
            "entrypoint": "0x08006288",
            "current_name": "allocate_memory_08006288",
            "code": "\nuint allocate_memory_08006288(undefined4 *size_ptr,uint requested_size)\n\n{\n  uint *size;\n  int offset;\n  uint *current_chunk;\n  uint chunk_difference;\n  uint *previous_chunk;\n  uint allocated_size;\n  \n  allocated_size = (requested_size + 3 & 0xfffffffc) + 8;\n  if (allocated_size < 0xc) {\n    allocated_size = 0xc;\n  }\n  if (((int)allocated_size < 0) || (allocated_size < requested_size)) {\n    *size_ptr = 0xc;\n  }\n  else {\n    __malloc_lock();\n    size = __malloc_free_list;\n    previous_chunk = __malloc_free_list;\n    while (current_chunk = size, current_chunk != (uint *)0x0) {\n      chunk_difference = *current_chunk - allocated_size;\n      if (-1 < (int)chunk_difference) {\n        if (chunk_difference < 0xc) {\n          if (previous_chunk == current_chunk) {\n            size = (uint *)previous_chunk[1];\n            __malloc_free_list = size;\n          }\n          else {\n            size = (uint *)current_chunk[1];\n          }\n          if (previous_chunk != current_chunk) {\n            previous_chunk[1] = (uint)size;\n            previous_chunk = current_chunk;\n          }\n        }\n        else {\n          *current_chunk = chunk_difference;\n          *(uint *)((int)current_chunk + chunk_difference) = allocated_size;\n          previous_chunk = (uint *)((int)current_chunk + chunk_difference);\n        }\n        goto LAB_080062ec;\n      }\n      previous_chunk = current_chunk;\n      size = (uint *)current_chunk[1];\n    }\n    if (__malloc_sbrk_start == 0) {\n      __malloc_sbrk_start = _sbrk_r(size_ptr);\n    }\n    size = (uint *)_sbrk_r(size_ptr,allocated_size);\n    if ((size != (uint *)0xffffffff) &&\n       ((previous_chunk = (uint *)((int)size + 3U & 0xfffffffc), size == previous_chunk ||\n        (offset = _sbrk_r(size_ptr,(int)previous_chunk - (int)size), offset != -1)))) {\n      *previous_chunk = allocated_size;\nLAB_080062ec:\n      __malloc_unlock(size_ptr);\n      allocated_size = (int)previous_chunk + 0xbU & 0xfffffff8;\n      offset = allocated_size - (int)(previous_chunk + 1);\n      if (offset != 0) {\n        *(int *)((int)previous_chunk + offset) = -offset;\n        return allocated_size;\n      }\n      return allocated_size;\n    }\n    *size_ptr = 0xc;\n    __malloc_unlock(size_ptr);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006288": "allocate_memory_08006288",
                "param_1": "size_ptr",
                "param_2": "requested_size",
                "puVar1": "size",
                "iVar2": "offset",
                "puVar3": "current_chunk",
                "uVar4": "chunk_difference",
                "puVar5": "previous_chunk",
                "uVar6": "allocated_size"
            },
            "calling": [
                "__smakebuf_r",
                "__sfmoreglue"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006344": {
            "entrypoint": "0x08006344",
            "current_name": "write_byte_to_file_08006344",
            "code": "\nuint writeByteToFile_08006344(undefined4 fileDescriptor,byte byteToWrite,byte **fileBuffer)\n\n{\n  uint result;\n  byte *bufferPtr;\n  \n  bufferPtr = fileBuffer[2] + -1;\n  fileBuffer[2] = bufferPtr;\n  if (((int)bufferPtr < 0) && (((int)bufferPtr < (int)fileBuffer[6] || (byteToWrite == 10)))) {\n    result = __swbuf_r();\n    return result;\n  }\n  bufferPtr = *fileBuffer;\n  *fileBuffer = bufferPtr + 1;\n  *bufferPtr = byteToWrite;\n  return (uint)byteToWrite;\n}\n\n",
            "renaming": {
                "FUN_08006344": "write_byte_to_file_08006344",
                "param_1": "fileDescriptor",
                "param_2": "byteToWrite",
                "param_3": "fileBuffer",
                "uVar1": "result",
                "pbVar2": "bufferPtr"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006370": {
            "entrypoint": "0x08006370",
            "current_name": "put_chars_08006370",
            "code": "\nint put_chars_08006370(undefined4 stream,undefined4 mode,undefined *buffer,int count)\n\n{\n  int result;\n  undefined *end;\n  int remaining;\n  \n  end = buffer + count;\n  remaining = count;\n  do {\n    if (buffer == end) {\n      return 0;\n    }\n    result = __sfputc_r(stream,*buffer,mode,count,remaining);\n    count = result + 1;\n    buffer = buffer + 1;\n  } while (count != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006370": "put_chars_08006370",
                "param_1": "stream",
                "param_2": "mode",
                "param_3": "buffer",
                "param_4": "count",
                "iVar1": "result",
                "puVar2": "end",
                "iVar3": "remaining"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006394": {
            "entrypoint": "0x08006394",
            "current_name": "print_formatted_text_08006394",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08006568) */\n\nint printFormattedText_08006394(int stream,undefined4 *formatString,byte *args,int *errorStatus)\n\n{\n  bool isValidNum;\n  int numChars;\n  void *charPointer;\n  int *numPointer;\n  byte *charPointer2;\n  byte *charPointer3;\n  int tempVar;\n  int tempVar2;\n  int *argPointer;\n  uint flagBits;\n  int precision;\n  undefined4 width;\n  int fieldWidth;\n  int totalChars;\n  byte formatChar;\n  undefined spaceFlag;\n  undefined plusFlag;\n  undefined hashFlag;\n  undefined4 zeroFlag;\n  \n  argPointer = errorStatus;\n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (formatString == &__sf_fake_stdin) {\n    formatString = *(undefined4 **)(stream + 4);\n  }\n  else if (formatString == (undefined4 *)&__sf_fake_stdout) {\n    formatString = *(undefined4 **)(stream + 8);\n  }\n  else if (formatString == (undefined4 *)&__sf_fake_stderr) {\n    formatString = *(undefined4 **)(stream + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(formatString + 3) << 0x1c)) || (formatString[4] == 0)) &&\n     (tempVar2 = __swsetup_r(stream,formatString), tempVar2 != 0)) {\n    return -1;\n  }\n  totalChars = 0;\n  spaceFlag = 0x20;\n  plusFlag = 0x30;\n  charPointer2 = args;\nLAB_080063d6:\n  charPointer3 = charPointer2;\n  if (*charPointer3 != 0) goto LAB_0800648c;\n  goto LAB_080063e0;\nLAB_0800648c:\n  charPointer2 = charPointer3 + 1;\n  if (*charPointer3 != 0x25) goto LAB_080063d6;\nLAB_080063e0:\n  tempVar2 = (int)charPointer3 - (int)args;\n  if (tempVar2 != 0) {\n    numChars = __sfputs_r(stream,formatString,args,tempVar2);\n    if (numChars == -1) {\nLAB_08006580:\n      if ((int)((uint)*(ushort *)(formatString + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalChars;\n    }\n    totalChars = totalChars + tempVar2;\n  }\n  if (*charPointer3 == 0) goto LAB_08006580;\n  flagBits = 0;\n  fieldWidth = 0;\n  precision = -1;\n  width = 0;\n  hashFlag = 0;\n  zeroFlag = 0;\n  charPointer2 = charPointer3 + 1;\n  while( true ) {\n    charPointer = memchr(\"#-0+ \",(uint)*charPointer2,5);\n    args = charPointer2 + 1;\n    if (charPointer == (void *)0x0) break;\n    flagBits = 1 << ((int)charPointer + 0xf7ff8750U & 0xff) | flagBits;\n    charPointer2 = args;\n  }\n  if ((int)(flagBits << 0x1b) < 0) {\n    hashFlag = 0x20;\n  }\n  if ((int)(flagBits << 0x1c) < 0) {\n    hashFlag = 0x2b;\n  }\n  if (*charPointer2 == 0x2a) {\n    numPointer = argPointer + 1;\n    tempVar2 = *argPointer;\n    argPointer = numPointer;\n    if (tempVar2 < 0) {\n      fieldWidth = -tempVar2;\n      flagBits = flagBits | 2;\n      goto LAB_080064be;\n    }\n  }\n  else {\n    isValidNum = false;\n    tempVar2 = fieldWidth;\n    args = charPointer2;\n    while( true ) {\n      if (9 < *args - 0x30) break;\n      tempVar2 = tempVar2 * 10 + (*args - 0x30);\n      isValidNum = true;\n      args = args + 1;\n    }\n    if (!isValidNum) goto LAB_080064be;\n  }\n  fieldWidth = tempVar2;\nLAB_080064be:\n  if (*args == 0x2e) {\n    if (args[1] == 0x2a) {\n      args = args + 2;\n      numPointer = argPointer + 1;\n      precision = *argPointer;\n      argPointer = numPointer;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      isValidNum = false;\n      tempVar2 = 0;\n      precision = 0;\n      while( true ) {\n        args = args + 1;\n        if (9 < *args - 0x30) break;\n        tempVar2 = tempVar2 * 10 + (*args - 0x30);\n        isValidNum = true;\n      }\n      if (isValidNum) {\n        precision = tempVar2;\n      }\n    }\n  }\n  charPointer = memchr(&DAT_080078b6,(uint)*args,3);\n  if (charPointer != (void *)0x0) {\n    args = args + 1;\n    flagBits = flagBits | 0x40 << ((int)charPointer + 0xf7ff874aU & 0xff);\n  }\n  formatChar = *args;\n  args = args + 1;\n  charPointer = memchr(\"efgEFG\",(uint)formatChar,6);\n  if (charPointer == (void *)0x0) {\n    tempVar = _printf_i(stream,&flagBits,formatString,0x8006371,&argPointer);\n    if (tempVar == -1) goto LAB_08006580;\n  }\n  else {\n    argPointer = (int *)(((int)argPointer + 7U & 0xfffffff8) + 8);\n  }\n  totalChars = totalChars + tempVar;\n  charPointer2 = args;\n  goto LAB_080063d6;\n}\n\n",
            "renaming": {
                "FUN_08006394": "print_formatted_text_08006394",
                "param_1": "stream",
                "param_2": "formatString",
                "param_3": "args",
                "param_4": "errorStatus",
                "bVar1": "isValidNum",
                "iVar2": "numChars",
                "pvVar3": "charPointer",
                "piVar4": "numPointer",
                "pbVar5": "charPointer2",
                "pbVar6": "charPointer3",
                "unaff_r9": "tempVar",
                "iVar7": "tempVar2",
                "local_8c": "argPointer",
                "local_88": "flagBits",
                "local_84": "precision",
                "local_80": "width",
                "local_7c": "fieldWidth",
                "local_74": "totalChars",
                "local_70": "formatChar",
                "local_6f": "spaceFlag",
                "local_6e": "plusFlag",
                "local_45": "hashFlag",
                "local_30": "zeroFlag"
            },
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "called": [
                "memchr",
                "__swsetup_r",
                "__sfputs_r",
                "_printf_i",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080065c0": {
            "entrypoint": "0x080065c0",
            "current_name": "process_data_080065c0",
            "code": "\nundefined4\nprocessData_080065c0(undefined4 input1,uint *input_arr,uint *output,undefined4 input2,code *callback)\n\n{\n  int index1;\n  int index2;\n  uint max_value;\n  uint temp;\n  bool is_zero;\n  \n  max_value = input_arr[4];\n  if ((int)input_arr[4] < (int)input_arr[2]) {\n    max_value = input_arr[2];\n  }\n  *output = max_value;\n  if (*(char *)((int)input_arr + 0x43) != '\\0') {\n    *output = max_value + 1;\n  }\n  if ((int)(*input_arr << 0x1a) < 0) {\n    *output = *output + 2;\n  }\n  if ((*input_arr & 6) == 0) {\n    for (index1 = 0; index1 < (int)(input_arr[3] - *output); index1 = index1 + 1) {\n      index2 = (*callback)(input1,input2,(int)input_arr + 0x19,1);\n      if (index2 == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  max_value = (uint)*(byte *)((int)input_arr + 0x43);\n  if (max_value != 0) {\n    max_value = 1;\n  }\n  temp = max_value;\n  if ((int)(*input_arr << 0x1a) < 0) {\n    *(undefined *)((int)input_arr + max_value + 0x43) = 0x30;\n    temp = max_value + 2;\n    *(undefined *)((int)input_arr + max_value + 0x44) = *(undefined *)((int)input_arr + 0x45);\n  }\n  index1 = (*callback)(input1,input2,(int)input_arr + 0x43,temp);\n  if (index1 != -1) {\n    max_value = input_arr[3];\n    is_zero = (*input_arr & 6) != 4;\n    if (is_zero) {\n      max_value = 0;\n    }\n    temp = 0;\n    if (!is_zero) {\n      max_value = max_value - *output;\n    }\n    if (!is_zero) {\n      max_value = max_value & ~((int)max_value >> 0x1f);\n    }\n    if ((int)input_arr[4] < (int)input_arr[2]) {\n      max_value = max_value + (input_arr[2] - input_arr[4]);\n    }\n    while( true ) {\n      if (max_value == temp) {\n        return 0;\n      }\n      index1 = (*callback)(input1,input2,(int)input_arr + 0x1a,1);\n      if (index1 == -1) break;\n      temp = temp + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080065c0": "process_data_080065c0",
                "param_1": "input1",
                "param_2": "input_arr",
                "param_3": "output",
                "param_4": "input2",
                "param_5": "callback",
                "iVar1": "index1",
                "iVar2": "index2",
                "uVar3": "max_value",
                "uVar4": "temp",
                "bVar5": "is_zero"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080066b0": {
            "entrypoint": "0x080066b0",
            "current_name": "print_formatted_value_080066b0",
            "code": "\nuint printFormattedValue_080066b0(undefined4 formatSpecifier,uint *argList,undefined4 stream,code *printerFunction,uint **ppArgList)\n\n{\n  byte byteValue;\n  int index;\n  uint *pArg;\n  void *ptrValue;\n  int innerIndex;\n  char *hexCharacters;\n  uint argValue;\n  uint **ppByteValue;\n  char **ppString;\n  uint value;\n  uint length;\n  char *pChar;\n  char *string;\n  uint localArray [2];\n  \n  byteValue = *(byte *)(argList + 6);\n  string = (char *)((int)argList + 0x43);\n  if (byteValue != 0x6e) {\n    if (byteValue < 0x6f) {\n      if (byteValue != 99) {\n        if (byteValue < 100) {\n          if (byteValue == 0) goto LAB_0800686a;\n          if (byteValue != 0x58) goto LAB_080066e0;\n          *(undefined *)((int)argList + 0x45) = 0x58;\n          hexCharacters = \"0123456789ABCDEF\";\nLAB_080067fa:\n          argValue = *argList;\n          pArg = *ppArgList;\n          *ppArgList = pArg + 1;\n          if (((argValue & 0x80) == 0) && ((int)(argValue << 0x19) < 0)) {\n            value = (uint)*(ushort *)pArg;\n          }\n          else {\n            value = *pArg;\n          }\n          if ((int)(argValue << 0x1f) < 0) {\n            *argList = argValue | 0x20;\n          }\n          if (value == 0) {\n            *argList = *argList & 0xffffffdf;\n          }\n          argValue = 0x10;\nLAB_08006790:\n          *(undefined *)((int)argList + 0x43) = 0;\n        }\n        else {\n          if ((byteValue != 100) && (byteValue != 0x69)) goto LAB_080066e0;\n          value = *argList;\n          pArg = *ppArgList;\n          if ((value & 0x80) == 0) {\n            *ppArgList = pArg + 1;\n            if ((value & 0x40) == 0) goto LAB_08006700;\n            value = (uint)(short)*(ushort *)pArg;\n          }\n          else {\n            *ppArgList = pArg + 1;\nLAB_08006700:\n            value = *pArg;\n          }\n          if ((int)value < 0) {\n            value = -value;\n            *(undefined *)((int)argList + 0x43) = 0x2d;\n          }\n          hexCharacters = \"0123456789ABCDEF\";\n          argValue = 10;\n        }\n        length = argList[1];\n        argList[2] = length;\n        pChar = string;\n        if ((int)length < 0) {\n          if (value != 0) goto LAB_0800682e;\nLAB_080068dc:\n          *(char *)((int)argList + 0x42) = *hexCharacters;\n          pChar = (char *)((int)argList + 0x42);\n        }\n        else {\n          *argList = *argList & 0xfffffffb;\n          if (value == 0) {\n            if (length != 0) goto LAB_080068dc;\n          }\n          else {\nLAB_0800682e:\n            do {\n              length = value / argValue;\n              pChar = pChar + -1;\n              *pChar = hexCharacters[value - argValue * length];\n              value = length;\n            } while (length != 0);\n          }\n        }\n        if (((argValue == 8) && ((int)(*argList << 0x1f) < 0)) && ((int)argList[1] <= (int)argList[4]))\n        {\n          pChar[-1] = '0';\n          pChar = pChar + -1;\n        }\n        argList[4] = (int)string - (int)pChar;\n        string = pChar;\n        goto LAB_080067d6;\n      }\n      pArg = *ppArgList;\n      *ppArgList = pArg + 1;\n      *(char *)((int)argList + 0x42) = (char)*pArg;\nLAB_08006740:\n      string = (char *)((int)argList + 0x42);\n      value = 1;\n    }\n    else {\n      if (byteValue != 0x73) {\n        if (byteValue < 0x74) {\n          if (byteValue == 0x6f) {\nLAB_08006766:\n            value = *argList;\n            pArg = *ppArgList;\n            if ((value & 0x80) == 0) {\n              *ppArgList = pArg + 1;\n              if ((value & 0x40) == 0) goto LAB_08006774;\n              value = (uint)*(ushort *)pArg;\n            }\n            else {\n              *ppArgList = pArg + 1;\nLAB_08006774:\n              value = *pArg;\n            }\n            if (byteValue == 0x6f) {\n              argValue = 8;\n            }\n            else {\n              argValue = 10;\n            }\n            hexCharacters = \"0123456789ABCDEF\";\n            goto LAB_08006790;\n          }\n          if (byteValue == 0x70) {\n            *argList = *argList | 0x20;\nLAB_08006726:\n            hexCharacters = \"0123456789abcdef\";\n            *(undefined *)((int)argList + 0x45) = 0x78;\n            goto LAB_080067fa;\n          }\n        }\n        else {\n          if (byteValue == 0x75) goto LAB_08006766;\n          if (byteValue == 0x78) goto LAB_08006726;\n        }\nLAB_080066e0:\n        *(byte *)((int)argList + 0x42) = byteValue;\n        goto LAB_08006740;\n      }\n      ppString = (char **)*ppArgList;\n      *ppArgList = (uint *)(ppString + 1);\n      string = *ppString;\n      ptrValue = memchr(string,0,argList[1]);\n      if (ptrValue != (void *)0x0) {\n        argList[1] = (int)ptrValue - (int)string;\n      }\n      value = argList[1];\n    }\n    argList[4] = value;\n    *(undefined *)((int)argList + 0x43) = 0;\n    goto LAB_080067d6;\n  }\n  value = *argList;\n  ppByteValue = (uint **)*ppArgList;\n  argValue = argList[5];\n  if ((value & 0x80) == 0) {\n    *ppArgList = (uint *)(ppByteValue + 1);\n    pArg = *ppByteValue;\n    if ((value & 0x40) == 0) goto LAB_08006856;\n    *(short *)pArg = (short)argValue;\n  }\n  else {\n    *ppArgList = (uint *)(ppByteValue + 1);\n    pArg = *ppByteValue;\nLAB_08006856:\n    *pArg = argValue;\n  }\nLAB_0800686a:\n  argList[4] = 0;\nLAB_080067d6:\n  index = _printf_common(formatSpecifier,argList,localArray,stream,printerFunction);\n  if ((index == -1) || (index = (*printerFunction)(formatSpecifier,stream,string,argList[4]), index == -1)) {\nLAB_080067ea:\n    value = 0xffffffff;\n  }\n  else {\n    if ((int)(*argList << 0x1e) < 0) {\n      for (index = 0; index < (int)(argList[3] - localArray[0]); index = index + 1) {\n        innerIndex = (*printerFunction)(formatSpecifier,stream,(int)argList + 0x19,1);\n        if (innerIndex == -1) goto LAB_080067ea;\n      }\n    }\n    value = argList[3];\n    if ((int)argList[3] < (int)localArray[0]) {\n      value = localArray[0];\n    }\n  }\n  return value;\n}\n\n",
            "renaming": {
                "FUN_080066b0": "print_formatted_value_080066b0",
                "param_1": "formatSpecifier",
                "param_2": "argList",
                "param_3": "stream",
                "param_4": "printerFunction",
                "param_5": "ppArgList",
                "bVar1": "byteValue",
                "iVar2": "index",
                "puVar3": "pArg",
                "pvVar4": "ptrValue",
                "iVar5": "innerIndex",
                "pcVar6": "hexCharacters",
                "uVar7": "argValue",
                "ppuVar8": "ppByteValue",
                "ppcVar9": "ppString",
                "uVar10": "value",
                "uVar11": "length",
                "pcVar12": "pChar",
                "__s": "string",
                "local_24": "localArray"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "memchr",
                "_printf_common"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080068f0": {
            "entrypoint": "0x080068f0",
            "current_name": "format_and_print_080068f0",
            "code": "\nint format_and_print_080068f0(char *format_string,...)\n\n{\n  int impure_ptr;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *input_format;\n  undefined4 arg1;\n  undefined4 arg2;\n  undefined4 arg3;\n  \n  impure_ptr = _impure_ptr;\n  input_format = format_string;\n  arg1 = in_r1;\n  arg2 = in_r2;\n  arg3 = in_r3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impure_ptr = _vfiprintf_r(impure_ptr,*(undefined4 *)(impure_ptr + 8),format_string,&arg1,input_format,&arg1);\n  return impure_ptr;\n}\n\n",
            "renaming": {
                "FUN_080068f0": "format_and_print_080068f0",
                "__format": "format_string",
                "iVar1": "impure_ptr",
                "pcVar2": "input_format",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006920": {
            "entrypoint": "0x08006920",
            "current_name": "allocate_memory_08006920",
            "code": "\nvoid allocateMemory_08006920(int *errorFlag,intptr_t size)\n\n{\n  void *allocatedMemory;\n  \n  errno = 0;\n  allocatedMemory = _sbrk(size);\n  if ((allocatedMemory == (void *)0xffffffff) && (errno != 0)) {\n    *errorFlag = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006920": "allocate_memory_08006920",
                "param_1": "errorFlag",
                "param_2": "size",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006940": {
            "entrypoint": "0x08006940",
            "current_name": "write_to_stream_08006940",
            "code": "\nuint write_to_stream_08006940(int stream,uint character,int *stream_data,undefined4 function_flag)\n\n{\n  int temp_var_1;\n  uint temp_var_2;\n  undefined *temp_var_3;\n  \n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_data == &__sf_fake_stdin) {\n    stream_data = *(int **)(stream + 4);\n  }\n  else if (stream_data == (int *)&__sf_fake_stdout) {\n    stream_data = *(int **)(stream + 8);\n  }\n  else if (stream_data == (int *)&__sf_fake_stderr) {\n    stream_data = *(int **)(stream + 0xc);\n  }\n  stream_data[2] = stream_data[6];\n  temp_var_2 = (uint)*(ushort *)(stream_data + 3);\n  temp_var_1 = temp_var_2 << 0x1c;\n  if (((temp_var_1 < 0) && (temp_var_2 = stream_data[4], temp_var_2 != 0)) ||\n     (temp_var_1 = __swsetup_r(stream,stream_data,temp_var_1,temp_var_2,function_flag), temp_var_1 == 0)) {\n    character = character & 0xff;\n    temp_var_1 = *stream_data - stream_data[4];\n    if ((temp_var_1 < stream_data[5]) || (temp_var_1 = _fflush_r(stream,stream_data), temp_var_1 == 0)) {\n      stream_data[2] = stream_data[2] + -1;\n      temp_var_3 = (undefined *)*stream_data;\n      *stream_data = (int)(temp_var_3 + 1);\n      *temp_var_3 = (char)character;\n      if (temp_var_1 + 1 != stream_data[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream_data + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      temp_var_1 = _fflush_r(stream,stream_data);\n      if (temp_var_1 == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08006940": "write_to_stream_08006940",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "stream_data",
                "param_4": "function_flag",
                "iVar1": "temp_var_1",
                "uVar2": "temp_var_2",
                "puVar3": "temp_var_3"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080069e4": {
            "entrypoint": "0x080069e4",
            "current_name": "parse_file_attributes_080069e4",
            "code": "\nuint parse_file_attributes_080069e4(undefined4 *output_status,undefined4 *file_info)\n\n{\n  int impure_data;\n  uint return_value;\n  ushort file_flags;\n  \n  impure_data = ptr_to_impure_data;\n  if ((ptr_to_impure_data != 0) && (*(int *)(ptr_to_impure_data + 0x18) == 0)) {\n    __sinit(ptr_to_impure_data);\n  }\n  if (file_info == &__sf_fake_stdin) {\n    file_info = *(undefined4 **)(impure_data + 4);\n  }\n  else if (file_info == (undefined4 *)&__sf_fake_stdout) {\n    file_info = *(undefined4 **)(impure_data + 8);\n  }\n  else if (file_info == (undefined4 *)&__sf_fake_stderr) {\n    file_info = *(undefined4 **)(impure_data + 0xc);\n  }\n  file_flags = *(ushort *)(file_info + 3);\n  return_value = (uint)file_flags;\n  if (-1 < (int)(return_value << 0x1c)) {\n    if (-1 < (int)(return_value << 0x1b)) {\n      *output_status = 9;\n      goto LAB_08006a14;\n    }\n    if ((int)(return_value << 0x1d) < 0) {\n      if ((undefined4 *)file_info[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)file_info[0xd] != file_info + 0x11) {\n          _free_r(output_status);\n        }\n        file_info[0xd] = 0;\n      }\n      *(ushort *)(file_info + 3) = *(ushort *)(file_info + 3) & 0xffdb;\n      file_info[1] = 0;\n      *file_info = file_info[4];\n    }\n    *(ushort *)(file_info + 3) = *(ushort *)(file_info + 3) | 8;\n  }\n  if ((file_info[4] == 0) && ((*(ushort *)(file_info + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(output_status,file_info);\n  }\n  file_flags = *(ushort *)(file_info + 3);\n  return_value = file_flags & 1;\n  if ((file_flags & 1) == 0) {\n    if (-1 < (int)((uint)file_flags << 0x1e)) {\n      return_value = file_info[5];\n    }\n    file_info[2] = return_value;\n  }\n  else {\n    file_info[2] = 0;\n    file_info[6] = -file_info[5];\n  }\n  if (file_info[4] == 0) {\n    file_flags = *(ushort *)(file_info + 3);\n    return_value = (int)(short)file_flags & 0x80;\n    if (return_value != 0) {\nLAB_08006a14:\n      *(ushort *)(file_info + 3) = file_flags | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    return_value = 0;\n  }\n  return return_value;\n}\n\n",
            "renaming": {
                "FUN_080069e4": "parse_file_attributes_080069e4",
                "param_1": "output_status",
                "param_2": "file_info",
                "_impure_ptr": "ptr_to_impure_data",
                "iVar1": "impure_data",
                "uVar2": "return_value",
                "uVar3": "file_flags"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "called": [
                "__smakebuf_r",
                "_free_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ac0": {
            "entrypoint": "0x08006ac0",
            "current_name": "raise_signal_and_exit_08006ac0",
            "code": "\n\n\nvoid raise_signal_and_exit_08006ac0(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
            "renaming": {
                "FUN_08006ac0": "raise_signal_and_exit_08006ac0"
            },
            "calling": [
                "__assert_func",
                "__throw_bad_function_call"
            ],
            "called": [
                "_exit",
                "raise"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ad0": {
            "entrypoint": "0x08006ad0",
            "current_name": "process_data_08006ad0",
            "code": "\nundefined4 process_data_08006ad0(uint *data_array,int *info_array)\n\n{\n  int status;\n  int *ptr_status;\n  uint num_iterations;\n  ushort flags;\n  int temp_var;\n  code *callback_func;\n  int loop_counter;\n  uint temp_data;\n  bool is_zero;\n  \n  flags = *(ushort *)(info_array + 3);\n  num_iterations = (uint)flags;\n  if ((int)(num_iterations << 0x1c) < 0) {\n    status = info_array[4];\n    if (status != 0) {\n      temp_var = num_iterations << 0x1e;\n      is_zero = temp_var != 0;\n      if (is_zero) {\n        temp_var = 0;\n      }\n      loop_counter = *info_array;\n      if (!is_zero) {\n        temp_var = info_array[5];\n      }\n      *info_array = status;\n      info_array[2] = temp_var;\n      for (loop_counter = loop_counter - status; 0 < loop_counter; loop_counter = loop_counter - temp_var) {\n        temp_var = (*(code *)info_array[10])(data_array,info_array[8],status,loop_counter);\n        if (temp_var < 1) {\n          flags = *(ushort *)(info_array + 3);\n          goto LAB_08006bc6;\n        }\n        status = status + temp_var;\n      }\n    }\n  }\n  else if (((0 < info_array[1]) || (0 < info_array[0x10])) &&\n          (callback_func = (code *)info_array[0xb], callback_func != (code *)0x0)) {\n    temp_data = *data_array;\n    *data_array = 0;\n    if ((flags & 0x1000) == 0) {\n      status = (*callback_func)(data_array,info_array[8],num_iterations & 0x1000,1);\n      if ((status == -1) && (num_iterations = *data_array, num_iterations != 0)) {\n        if ((num_iterations != 0x1d) && (num_iterations != 0x16)) {\n          *(ushort *)(info_array + 3) = *(ushort *)(info_array + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *data_array = temp_data;\n        return 0;\n      }\n    }\n    else {\n      status = info_array[0x15];\n    }\n    if (((int)((uint)*(ushort *)(info_array + 3) << 0x1d) < 0) &&\n       (status = status - info_array[1], info_array[0xd] != 0)) {\n      status = status - info_array[0x10];\n    }\n    status = (*(code *)info_array[0xb])(data_array,info_array[8],status,0);\n    flags = *(ushort *)(info_array + 3);\n    if ((status == -1) &&\n       ((0x1d < *data_array || (-1 < (int)((0x20400001U >> (*data_array & 0xff)) << 0x1f))))) {\nLAB_08006bc6:\n      *(ushort *)(info_array + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n    info_array[1] = 0;\n    *info_array = info_array[4];\n    if (((int)((uint)flags << 0x13) < 0) && ((status != -1 || (*data_array == 0)))) {\n      info_array[0x15] = status;\n    }\n    ptr_status = (int *)info_array[0xd];\n    *data_array = temp_data;\n    if (ptr_status != (int *)0x0) {\n      if (ptr_status != info_array + 0x11) {\n        _free_r(data_array);\n      }\n      info_array[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006ad0": "process_data_08006ad0",
                "param_1": "data_array",
                "param_2": "info_array",
                "iVar1": "status",
                "piVar2": "ptr_status",
                "uVar3": "num_iterations",
                "uVar4": "flags",
                "iVar5": "temp_var",
                "pcVar6": "callback_func",
                "iVar7": "loop_counter",
                "uVar8": "temp_data",
                "bVar9": "is_zero"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006be0": {
            "entrypoint": "0x08006be0",
            "current_name": "flush_file_if_needed_08006be0",
            "code": "\nundefined4 flushFileIfNeeded_08006be0(int fileDescriptor,undefined4 *filePointer,undefined4 contextPointer,undefined4 statusPointer)\n\n{\n  undefined4 result;\n  \n  if (filePointer[4] != 0) {\n    if ((fileDescriptor != 0) && (*(int *)(fileDescriptor + 0x18) == 0)) {\n      initializeStream();\n    }\n    if (filePointer == fakeStdinAddress) {\n      filePointer = *(undefined4 **)(fileDescriptor + 4);\n    }\n    else if (filePointer == (undefined4 *)&__sf_fake_stdout) {\n      filePointer = *(undefined4 **)(fileDescriptor + 8);\n    }\n    else if (filePointer == (undefined4 *)&__sf_fake_stderr) {\n      filePointer = *(undefined4 **)(fileDescriptor + 0xc);\n    }\n    if (*(short *)(filePointer + 3) != 0) {\n      result = flushStream(fileDescriptor,filePointer,contextPointer,statusPointer);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006be0": "flush_file_if_needed_08006be0",
                "param_1": "fileDescriptor",
                "param_2": "filePointer",
                "param_3": "contextPointer",
                "param_4": "statusPointer",
                "uVar1": "result",
                "__sinit": "initializeStream",
                "&__sf_fake_stdin": "fakeStdinAddress",
                "__sflush_r": "flushStream"
            },
            "calling": [
                "__swbuf_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c34": {
            "entrypoint": "0x08006c34",
            "current_name": "execute_fwalk_reent_08006c34",
            "code": "\nvoid execute_fwalk_reent_08006c34(undefined4 reent_param)\n\n{\n  execute_fwalk_reent_08006c34_internal(reent_param,0x8006be1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006c34": "execute_fwalk_reent_08006c34",
                "param_1": "reent_param",
                "_fwalk_reent": "execute_fwalk_reent_internal"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c40": {
            "entrypoint": "0x08006c40",
            "current_name": "initialize_data_08006c40",
            "code": "\nvoid initializeData_08006c40(undefined4 *data,undefined2 value1,undefined2 value2)\n\n{\n  *data = 0;\n  data[1] = 0;\n  data[2] = 0;\n  *(undefined2 *)(data + 3) = value1;\n  data[25] = 0;\n  *(undefined2 *)((int)data + 0xe) = value2;\n  data[4] = 0;\n  data[5] = 0;\n  data[6] = 0;\n  memset(data + 0x17,0,8);\n  data[8] = data;\n  data[9] = 0x8006f39;\n  data[10] = 0x8006f5b;\n  data[11] = 0x8006f93;\n  data[12] = 0x8006fb7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006c40": "initialize_data_08006c40",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2",
                "param_1[1]": "data[1]",
                "param_1[2]": "data[2]",
                "param_1[0x19]": "data[25]",
                "param_1[4]": "data[4]",
                "param_1[5]": "data[5]",
                "param_1[6]": "data[6]",
                "param_1[8]": "data[8]",
                "param_1[9]": "data[9]",
                "param_1[10]": "data[10]",
                "param_1[0xb]": "data[11]",
                "param_1[0xc]": "data[12]"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c88": {
            "entrypoint": "0x08006c88",
            "current_name": "allocate_and_initialize_array_08006c88",
            "code": "\nundefined4 * allocate_and_initialize_array_08006c88(undefined4 size_of_element,int num_elements)\n\n{\n  undefined4 *array_ptr;\n  int array_size;\n  \n  array_size = (num_elements + -1) * 0x68;\n  array_ptr = (undefined4 *)_malloc_r(size_of_element,array_size + 0x74);\n  if (array_ptr != (undefined4 *)0x0) {\n    *array_ptr = 0;\n    array_ptr[1] = num_elements;\n    array_ptr[2] = array_ptr + 3;\n    memset(array_ptr + 3,0,array_size + 0x68);\n  }\n  return array_ptr;\n}\n\n",
            "renaming": {
                "FUN_08006c88": "allocate_and_initialize_array_08006c88",
                "param_1": "size_of_element",
                "param_2": "num_elements",
                "puVar1": "array_ptr",
                "iVar2": "array_size"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006cb4": {
            "entrypoint": "0x08006cb4",
            "current_name": "initialize_data_08006cb4",
            "code": "\nvoid initializeData_08006cb4(undefined1 *data)\n\n{\n  undefined4 returnValue;\n  undefined1 *dataPointer;\n  \n  if (*(int *)(data + 0x18) == 0) {\n    *(undefined4 *)(data + 0x48) = 0;\n    *(undefined4 *)(data + 0x4c) = 0;\n    *(undefined4 *)(data + 0x50) = 0;\n    dataPointer = &impure_data;\n    *(undefined4 *)(data + 0x28) = 0x8006c35;\n    if (data == &impure_data) {\n      dataPointer = (undefined1 *)0x1;\n    }\n    if (data == &impure_data) {\n      *(undefined1 **)(data + 0x18) = dataPointer;\n    }\n    returnValue = __sfp();\n    *(undefined4 *)(data + 4) = returnValue;\n    returnValue = __sfp(data);\n    *(undefined4 *)(data + 8) = returnValue;\n    returnValue = __sfp(data);\n    *(undefined4 *)(data + 0xc) = returnValue;\n    std_isra_0(*(undefined4 *)(data + 4),4,0);\n    std_isra_0(*(undefined4 *)(data + 8),9,1);\n    std_isra_0(*(undefined4 *)(data + 0xc),0x12,2);\n    *(undefined4 *)(data + 0x18) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006cb4": "initialize_data_08006cb4",
                "param_1": "data",
                "uVar1": "returnValue",
                "puVar2": "dataPointer"
            },
            "calling": [
                "_fflush_r",
                "__swbuf_r",
                "__sfp",
                "__swsetup_r",
                "iprintf",
                "_vfiprintf_r"
            ],
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d14": {
            "entrypoint": "0x08006d14",
            "current_name": "initialize_data_structures_08006d14",
            "code": "\nint * initializeDataStructures_08006d14(undefined4 *ptr)\n\n{\n  int *currentArray;\n  int *currentSubArray;\n  int **dataArrayPtr;\n  \n  if (DAT_20000114 == 0) {\n    initializeImpureData(&impure_data);\n  }\n  dataArrayPtr = (int **)&DAT_20000144;\n  do {\n    currentSubArray = dataArrayPtr[2];\n    currentArray = dataArrayPtr[1];\n    while (currentArray = (int *)((int)currentArray + -1), -1 < (int)currentArray) {\n      if (*(short *)(currentSubArray + 3) == 0) {\n        *(undefined2 *)((int)currentSubArray + 0xe) = 0xffff;\n        currentSubArray[0x19] = 0;\n        *(undefined2 *)(currentSubArray + 3) = 1;\n        *currentSubArray = 0;\n        currentSubArray[2] = 0;\n        currentSubArray[1] = 0;\n        currentSubArray[4] = 0;\n        currentSubArray[5] = 0;\n        currentSubArray[6] = 0;\n        clearMemory(currentSubArray + 0x17,0,8);\n        currentSubArray[0xd] = 0;\n        currentSubArray[0xe] = 0;\n        currentSubArray[0x12] = 0;\n        currentSubArray[0x13] = 0;\n        return currentSubArray;\n      }\n      currentSubArray = currentSubArray + 0x1a;\n    }\n    if (*dataArrayPtr == (int *)0x0) {\n      currentArray = (int *)allocateMemory(ptr,4);\n      *dataArrayPtr = currentArray;\n      if (currentArray == (int *)0x0) {\n        *ptr = 0xc;\n        return (int *)0x0;\n      }\n    }\n    dataArrayPtr = (int **)*dataArrayPtr;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08006d14": "initialize_data_structures_08006d14",
                "param_1": "ptr",
                "piVar1": "currentArray",
                "piVar2": "currentSubArray",
                "ppiVar3": "dataArrayPtr",
                "memset": "clearMemory",
                "__sinit": "initializeImpureData",
                "__sfmoreglue": "allocateMemory"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset",
                "__sfmoreglue",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d8c": {
            "entrypoint": "0x08006d8c",
            "current_name": "process_data_08006d8c",
            "code": "\nuint process_data_08006d8c(int data,code *callback_func,undefined4 param_a,undefined4 param_b)\n\n{\n  uint uVar1;\n  int value_b;\n  int *current_node;\n  int value_a;\n  uint result;\n  int count;\n  \n  result = 0;\n  for (current_node = (int *)(data + 0x48); current_node != (int *)0x0; current_node = (int *)*current_node) {\n    value_a = current_node[2];\n    count = current_node[1];\n    while (count = count + -1, -1 < count) {\n      if ((1 < *(ushort *)(value_a + 0xc)) && (value_b = *(short *)(value_a + 0xe) + 1, value_b != 0)) {\n        uVar1 = (*callback_func)(data,value_a,param_a,value_b,param_b);\n        result = result | uVar1;\n      }\n      value_a = value_a + 0x68;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006d8c": "process_data_08006d8c",
                "param_1": "data",
                "param_2": "callback_func",
                "param_3": "param_a",
                "param_4": "param_b",
                "piVar3": "current_node",
                "iVar4": "value_a",
                "iVar2": "value_b",
                "uVar5": "result",
                "iVar6": "count"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006dc8": {
            "entrypoint": "0x08006dc8",
            "current_name": "check_file_status_08006dc8",
            "code": "\nundefined4 checkFileStatus_08006dc8(undefined4 fileDescriptor,int fileInfo,undefined4 *resultFlag,uint *fileAttributes)\n\n{\n  int fileStatus;\n  undefined4 flag;\n  undefined stackVar [4];\n  uint fileMode;\n  \n  if ((*(short *)(fileInfo + 0xe) < 0) ||\n     (fileStatus = _fstat_r(fileDescriptor,(int)*(short *)(fileInfo + 0xe),stackVar), fileStatus < 0)) {\n    *fileAttributes = 0;\n    if ((int)((uint)*(ushort *)(fileInfo + 0xc) << 0x18) < 0) {\n      flag = 0x40;\n      goto LAB_08006e08;\n    }\n  }\n  else {\n    *fileAttributes = (uint)((fileMode & 0xf000) == 0x2000);\n  }\n  flag = 0x400;\nLAB_08006e08:\n  *resultFlag = flag;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006dc8": "check_file_status_08006dc8",
                "param_1": "fileDescriptor",
                "param_2": "fileInfo",
                "param_3": "resultFlag",
                "param_4": "fileAttributes",
                "iVar1": "fileStatus",
                "uVar2": "flag",
                "auStack_4c": "stackVar",
                "local_48": "fileMode"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e10": {
            "entrypoint": "0x08006e10",
            "current_name": "decode_and_allocate_memory_08006e10",
            "code": "\nvoid decode_and_allocate_memory_08006e10(int memory_manager,int *data_array)\n\n{\n  ushort decoded_value;\n  int allocated_memory;\n  int param_1_copy;\n  int *param_2_copy;\n  \n  if (-1 < (int)((uint)*(ushort *)(data_array + 3) << 0x1e)) {\n    param_1_copy = memory_manager;\n    param_2_copy = data_array;\n    decoded_value = __swhatbuf_r(memory_manager,data_array,&param_1_copy,&param_2_copy);\n    allocated_memory = _malloc_r(memory_manager,param_1_copy);\n    if (allocated_memory != 0) {\n      *(undefined4 *)(memory_manager + 0x28) = 0x8006c35;\n      *data_array = allocated_memory;\n      *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) | 0x80;\n      data_array[4] = allocated_memory;\n      data_array[5] = param_1_copy;\n      if ((param_2_copy != (int *)0x0) &&\n         (allocated_memory = _isatty_r(memory_manager,(int)*(short *)((int)data_array + 0xe)), allocated_memory != 0)) {\n        *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(data_array + 3) = decoded_value | *(ushort *)(data_array + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(data_array + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) & 0xfffc | 2;\n  }\n  *data_array = (int)data_array + 0x47;\n  data_array[4] = (int)data_array + 0x47;\n  data_array[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e10": "decode_and_allocate_memory_08006e10",
                "param_1": "memory_manager",
                "param_2": "data_array",
                "uVar1": "decoded_value",
                "iVar2": "allocated_memory",
                "local_18": "param_1_copy",
                "local_14": "param_2_copy"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_malloc_r",
                "_isatty_r",
                "__swhatbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e90": {
            "entrypoint": "0x08006e90",
            "current_name": "search_byte_08006e90",
            "code": "\nvoid * search_byte_08006e90(void *data,int search_value,size_t data_length)\n\n{\n  byte *byte_pointer1;\n  byte *byte_pointer2;\n  \n  byte_pointer1 = (byte *)data;\n  do {\n    byte_pointer2 = byte_pointer1;\n    if (byte_pointer2 == (byte *)(data_length + (int)data)) {\n      return (void *)0x0;\n    }\n    byte_pointer1 = byte_pointer2 + 1;\n  } while ((uint)*byte_pointer2 != (search_value & 0xffU));\n  return byte_pointer2;\n}\n\n",
            "renaming": {
                "FUN_08006e90": "search_byte_08006e90",
                "__s": "data",
                "__c": "search_value",
                "__n": "data_length",
                "pbVar1": "byte_pointer1",
                "pbVar2": "byte_pointer2"
            },
            "calling": [
                "_vfiprintf_r",
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006eac": {
            "entrypoint": "0x08006eac",
            "current_name": "FUNC_08006eac",
            "code": "\nvoid FUNC_08006eac(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006eac": "FUNC_08006eac"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006eae": {
            "entrypoint": "0x08006eae",
            "current_name": "FUNC_08006eae",
            "code": "\nvoid FUNC_08006eae(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006eae": "FUNC_08006eae"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006eb0": {
            "entrypoint": "0x08006eb0",
            "current_name": "handle_process_08006eb0",
            "code": "\nundefined4 handle_process_08006eb0(undefined4 *result,uint index,undefined4 param1,undefined4 param2)\n\n{\n  __pid_t process_id;\n  undefined4 return_value;\n  int ptr;\n  code *function_ptr;\n  \n  if (0x1f < index) {\n    *result = 0x16;\n    return 0xffffffff;\n  }\n  ptr = result[0x11];\n  if ((ptr != 0) && (function_ptr = *(code **)(ptr + index * 4), function_ptr != (code *)0x0)) {\n    if (function_ptr != (code *)0x1) {\n      if (function_ptr == (code *)0xffffffff) {\n        *result = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(ptr + index * 4) = 0;\n      (*function_ptr)(index);\n    }\n    return 0;\n  }\n  process_id = _getpid_r();\n  return_value = _kill_r(result,process_id,index,param2);\n  return return_value;\n}\n\n",
            "renaming": {
                "FUN_08006eb0": "handle_process_08006eb0",
                "param_1": "result",
                "param_2": "index",
                "param_3": "param1",
                "param_4": "param2",
                "_Var1": "process_id",
                "uVar2": "return_value",
                "iVar3": "ptr",
                "pcVar4": "function_ptr"
            },
            "calling": [
                "raise"
            ],
            "called": [
                "_kill_r",
                "_getpid_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f00": {
            "entrypoint": "0x08006f00",
            "current_name": "raise_signal_handler_08006f00",
            "code": "\nint raise_signal_handler_08006f00(int signal_number)\n\n{\n  int result;\n  \n  result = _raise_r(_impure_ptr,signal_number);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006f00": "raise_signal_handler_08006f00",
                "__sig": "signal_number",
                "iVar1": "result"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_raise_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f10": {
            "entrypoint": "0x08006f10",
            "current_name": "kill_process_08006f10",
            "code": "\nvoid kill_process_08006f10(int *error_code,__pid_t process_id,int signal)\n\n{\n  int kill_result;\n  \n  errno = 0;\n  kill_result = _kill(process_id,signal);\n  if ((kill_result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f10": "kill_process_08006f10",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal",
                "iVar1": "kill_result"
            },
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f34": {
            "entrypoint": "0x08006f34",
            "current_name": "FUN_08006f34",
            "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f38": {
            "entrypoint": "0x08006f38",
            "current_name": "update_data_08006f38",
            "code": "\nvoid updateData_08006f38(undefined4 dataBuffer,int offset)\n\n{\n  int readResult;\n  uint updatedValue;\n  bool isSuccessful;\n  \n  readResult = _read_r(dataBuffer,(int)*(short *)(offset + 0xe));\n  isSuccessful = -1 < readResult;\n  if (isSuccessful) {\n    updatedValue = *(int *)(offset + 0x54) + readResult;\n  }\n  else {\n    updatedValue = *(ushort *)(offset + 0xc) & 0xffffefff;\n  }\n  if (isSuccessful) {\n    *(uint *)(offset + 0x54) = updatedValue;\n  }\n  if (!isSuccessful) {\n    *(short *)(offset + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f38": "update_data_08006f38",
                "param_1": "dataBuffer",
                "param_2": "offset",
                "iVar1": "readResult",
                "uVar2": "updatedValue",
                "bVar3": "isSuccessful"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f5a": {
            "entrypoint": "0x08006f5a",
            "current_name": "update_file_if_needed_08006f5a",
            "code": "\nvoid updateFileIfNeeded_08006f5a(undefined4 fileDescriptor,int buffer,undefined4 data,undefined4 size)\n\n{\n  if ((int)((uint)*(ushort *)(buffer + 0xc) << 0x17) < 0) {\n    _lseek_r(fileDescriptor,(int)*(short *)(buffer + 0xe),0,2);\n  }\n  *(ushort *)(buffer + 0xc) = *(ushort *)(buffer + 0xc) & 0xefff;\n  _write_r(fileDescriptor,(int)*(short *)(buffer + 0xe),data,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f5a": "update_file_if_needed_08006f5a",
                "param_1": "fileDescriptor",
                "param_2": "buffer",
                "param_3": "data",
                "param_4": "size"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f92": {
            "entrypoint": "0x08006f92",
            "current_name": "update_file_pointer_08006f92",
            "code": "\nvoid updateFilePointer_08006f92(undefined4 fileDescriptor,int structPointer)\n\n{\n  int seekResult;\n  ushort flags;\n  bool isSeekError;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(structPointer + 0xe));\n  isSeekError = seekResult == -1;\n  if (isSeekError) {\n    flags = *(ushort *)(structPointer + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(structPointer + 0x54) = seekResult;\n    flags = *(ushort *)(structPointer + 0xc) | 0x1000;\n  }\n  if (isSeekError) {\n    *(ushort *)(structPointer + 0xc) = flags;\n  }\n  if (!isSeekError) {\n    *(ushort *)(structPointer + 0xc) = flags;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f92": "update_file_pointer_08006f92",
                "param_1": "fileDescriptor",
                "param_2": "structPointer",
                "iVar1": "seekResult",
                "uVar2": "flags",
                "bVar3": "isSeekError"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fb6": {
            "entrypoint": "0x08006fb6",
            "current_name": "close_file_descriptor_08006fb6",
            "code": "\nvoid closeFileDescriptor_08006fb6(undefined4 fileDescriptor,int bufferAddress)\n\n{\n  _close_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fb6": "close_file_descriptor_08006fb6",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fc0": {
            "entrypoint": "0x08006fc0",
            "current_name": "write_to_file_08006fc0",
            "code": "\nvoid writeToFile_08006fc0(int *errorCodePointer,int fileDescriptor,char *data,int length)\n\n{\n  int writeResult;\n  \n  errno = 0;\n  writeResult = _write(fileDescriptor,data,length);\n  if ((writeResult == -1) && (errno != 0)) {\n    *errorCodePointer = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fc0": "write_to_file_08006fc0",
                "param_1": "errorCodePointer",
                "param_2": "fileDescriptor",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "writeResult"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fe4": {
            "entrypoint": "0x08006fe4",
            "current_name": "close_file_and_handle_error_08006fe4",
            "code": "\nvoid closeFileAndHandleError_08006fe4(int *errorFlag,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errno = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errno != 0)) {\n    *errorFlag = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fe4": "close_file_and_handle_error_08006fe4",
                "param_1": "errorFlag",
                "param_2": "fileDescriptor",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007004": {
            "entrypoint": "0x08007004",
            "current_name": "get_file_status_08007004",
            "code": "\nvoid get_file_status_08007004(int *error_code,int file_descriptor,stat *status_buffer)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _fstat(file_descriptor,status_buffer);\n  if ((result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007004": "get_file_status_08007004",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "status_buffer",
                "iVar1": "result"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007028": {
            "entrypoint": "0x08007028",
            "current_name": "check_and_set_errno_08007028",
            "code": "\nvoid checkAndSetErrno_08007028(int *errorPtr,int fileDescriptor)\n\n{\n  int isTerminal;\n  \n  errno = 0;\n  isTerminal = _isatty(fileDescriptor);\n  if ((isTerminal == -1) && (errno != 0)) {\n    *errorPtr = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007028": "check_and_set_errno_08007028",
                "param_1": "errorPtr",
                "param_2": "fileDescriptor",
                "iVar1": "isTerminal"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007048": {
            "entrypoint": "0x08007048",
            "current_name": "set_errno_on_seek_failure_08007048",
            "code": "\nvoid setErrnoOnSeekFailure_08007048(int *errorPointer,int fileDescriptor,__off_t offset,int whence)\n\n{\n  __off_t seekResult;\n  \n  errno = 0;\n  seekResult = _lseek(fileDescriptor,offset,whence);\n  if ((seekResult == -1) && (errno != 0)) {\n    *errorPointer = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007048": "set_errno_on_seek_failure_08007048",
                "param_1": "errorPointer",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "seekResult"
            },
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800706c": {
            "entrypoint": "0x0800706c",
            "current_name": "read_file_0800706c",
            "code": "\nvoid readFile_0800706c(int *errorCodePtr,int fileDescriptor,char *buffer,int numBytes)\n\n{\n  int returnValue;\n  \n  errno = 0;\n  returnValue = _read(fileDescriptor,buffer,numBytes);\n  if ((returnValue == -1) && (errno != 0)) {\n    *errorCodePtr = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800706c": "read_file_0800706c",
                "param_1": "errorCodePtr",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "numBytes",
                "iVar1": "returnValue"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007090": {
            "entrypoint": "0x08007090",
            "current_name": "handle_function_call_error_08007090",
            "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::handleFunctionCallError_08007090(void)\n\n{\n                    \n  abortExecution();\n}\n\n",
            "renaming": {
                "abort": "abortExecution",
                "FUN_08007090": "handle_function_call_error_08007090"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007098": {
            "entrypoint": "0x08007098",
            "current_name": "initialize_ctype_08007098",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeCtype_08007098(void)\n\n{\n  if (-1 < moneypunct<char,false>::id << 0x1f) {\n    moneypunct<char,false>::id = 1;\n  }\n  if (-1 < moneypunct<char,true>::id << 0x1f) {\n    moneypunct<char,true>::id = 1;\n  }\n  if (-1 < money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < numpunct<char>::id << 0x1f) {\n    numpunct<char>::id = 1;\n  }\n  if (-1 < num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __timepunct<char>::id << 0x1f) {\n    __timepunct<char>::id = 1;\n  }\n  if (-1 < time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < messages<char>::id << 0x1f) {\n    messages<char>::id = 1;\n  }\n  if (-1 < collate<char>::id << 0x1f) {\n    collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007098": "initialize_ctype_08007098"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800715c": {
            "entrypoint": "0x0800715c",
            "current_name": "initialize_locale_0800715c",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeLocale_0800715c(void)\n\n{\n  if (-1 < moneypunct<wchar_t,false>::id << 0x1f) {\n    moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < moneypunct<wchar_t,true>::id << 0x1f) {\n    moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < numpunct<wchar_t>::id << 0x1f) {\n    numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __timepunct<wchar_t>::id << 0x1f) {\n    __timepunct<wchar_t>::id = 1;\n  }\n  if (-1 < time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < messages<wchar_t>::id << 0x1f) {\n    messages<wchar_t>::id = 1;\n  }\n  if (-1 < collate<wchar_t>::id << 0x1f) {\n    collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800715c": "initialize_locale_0800715c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007220": {
            "entrypoint": "0x08007220",
            "current_name": "initialize_standard_locale_strings_08007220",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeStandardLocaleStrings_08007220(void)\n\n{\n  if (-1 < __cxx11::moneypunct<wchar_t,false>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<wchar_t,true>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<wchar_t>::id << 0x1f) {\n    __cxx11::numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<wchar_t>::id << 0x1f) {\n    __cxx11::messages<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::collate<wchar_t>::id << 0x1f) {\n    __cxx11::collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007220": "initialize_standard_locale_strings_08007220"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072a4": {
            "entrypoint": "0x080072a4",
            "current_name": "initialize_locale_data_080072a4",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeLocaleData_080072a4(void)\n\n{\n  if (-1 < __cxx11::moneypunct<char,false>::id << 0x1f) {\n    __cxx11::moneypunct<char,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<char,true>::id << 0x1f) {\n    __cxx11::moneypunct<char,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<char>::id << 0x1f) {\n    __cxx11::numpunct<char>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f\n     ) {\n    __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<char>::id << 0x1f) {\n    __cxx11::messages<char>::id = 1;\n  }\n  if (-1 < __cxx11::collate<char>::id << 0x1f) {\n    __cxx11::collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072a4": "initialize_locale_data_080072a4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007328": {
            "entrypoint": "0x08007328",
            "current_name": "FUNC_08007328",
            "code": "\nvoid FUNC_08007328(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007328": "FUNC_08007328"
            },
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08007334": {
            "entrypoint": "0x08007334",
            "current_name": "FUNC_08007334",
            "code": "\nvoid FUNC_08007334(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007334": "FUNC_08007334"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 194652,
    "layers": [
        [
            "FUN_0800010c",
            "FUN_08000178",
            "FUN_08000188",
            "FUN_08000190",
            "FUN_08000194",
            "FUN_0800040c",
            "FUN_0800042c",
            "FUN_08000450",
            "FUN_0800048c",
            "FUN_0800049c",
            "FUN_080006d4",
            "FUN_080008ba",
            "FUN_0800091c",
            "FUN_08000924",
            "FUN_0800092c",
            "FUN_080009a8",
            "FUN_080009b8",
            "FUN_080009c8",
            "FUN_080009dc",
            "FUN_080009f0",
            "FUN_08000a04",
            "FUN_08000a18",
            "FUN_08000a2c",
            "FUN_08000a58",
            "FUN_08000aa8",
            "FUN_08000ae8",
            "FUN_08000aec",
            "FUN_08000b08",
            "FUN_08000bcc",
            "FUN_08000cbc",
            "FUN_08000cd0",
            "FUN_08001294",
            "FUN_080012a2",
            "FUN_080012c0",
            "FUN_080012e8",
            "FUN_08001310",
            "FUN_0800134e",
            "FUN_0800135a",
            "FUN_08001366",
            "FUN_0800138e",
            "FUN_080013a4",
            "FUN_080014ba",
            "FUN_08001510",
            "FUN_08001550",
            "FUN_0800157c",
            "FUN_080015b2",
            "FUN_080015f8",
            "FUN_080016b4",
            "FUN_08001814",
            "FUN_080018f8",
            "FUN_08001918",
            "FUN_08001960",
            "FUN_080019f6",
            "FUN_08001a44",
            "FUN_08001a66",
            "FUN_08001ab0",
            "FUN_08001b18",
            "FUN_08001b48",
            "FUN_08001be8",
            "FUN_08001c30",
            "FUN_08001c32",
            "FUN_08001c3c",
            "FUN_08001c88",
            "FUN_08001cac",
            "FUN_08001cc4",
            "FUN_08001cd0",
            "FUN_08001e40",
            "FUN_08001e48",
            "FUN_08001f80",
            "FUN_08001f84",
            "FUN_08002004",
            "FUN_080020f0",
            "FUN_0800213c",
            "FUN_0800224c",
            "FUN_08002348",
            "FUN_08002384",
            "FUN_08002470",
            "FUN_08002494",
            "FUN_080024f8",
            "FUN_08002514",
            "FUN_08002540",
            "FUN_08002560",
            "FUN_08002582",
            "FUN_0800258c",
            "FUN_08002624",
            "FUN_08002810",
            "FUN_0800281e",
            "FUN_0800282c",
            "FUN_08002848",
            "FUN_080028d2",
            "FUN_080028de",
            "FUN_08002ab8",
            "FUN_08002ad8",
            "FUN_08002af8",
            "FUN_08002b84",
            "FUN_08002c10",
            "FUN_08002c54",
            "FUN_08002ca6",
            "FUN_08002cf2",
            "FUN_08002d1c",
            "FUN_08002db2",
            "FUN_08002efc",
            "FUN_08002f9c",
            "FUN_0800306c",
            "FUN_0800316c",
            "FUN_080032b4",
            "FUN_080033b8",
            "FUN_08003520",
            "FUN_080035fc",
            "FUN_0800365c",
            "FUN_08003688",
            "FUN_08003a68",
            "FUN_08003ad4",
            "FUN_08003c44",
            "FUN_08003c50",
            "FUN_08003c70",
            "FUN_08003c90",
            "FUN_08003da4",
            "FUN_08003ea0",
            "FUN_08003ed8",
            "FUN_08003f18",
            "FUN_08004092",
            "FUN_080040b0",
            "FUN_08004110",
            "FUN_0800412c",
            "FUN_0800417c",
            "FUN_08004198",
            "FUN_08004204",
            "FUN_080043b4",
            "FUN_0800441a",
            "FUN_08004478",
            "FUN_0800455a",
            "FUN_080045a2",
            "FUN_080045fe",
            "FUN_08004618",
            "FUN_080046b8",
            "FUN_080047d8",
            "FUN_080047e8",
            "FUN_080047f4",
            "FUN_0800480a",
            "FUN_08004828",
            "FUN_08004848",
            "FUN_08004884",
            "FUN_0800492c",
            "FUN_08004948",
            "FUN_08004974",
            "FUN_080049f0",
            "FUN_08004a4c",
            "FUN_08004b34",
            "FUN_08004b3c",
            "FUN_08004b94",
            "FUN_08004b9e",
            "FUN_08004bb0",
            "FUN_08004c30",
            "FUN_08004c48",
            "FUN_08004c52",
            "FUN_08004c5e",
            "FUN_08004c78",
            "FUN_08004c8a",
            "FUN_08004ca2",
            "FUN_08004cb2",
            "FUN_08004cce",
            "FUN_08004ce2",
            "FUN_08004d06",
            "FUN_08004d18",
            "FUN_08004d30",
            "FUN_08004d40",
            "FUN_08004d44",
            "FUN_08004d90",
            "FUN_08004df4",
            "FUN_08004df8",
            "FUN_08004e12",
            "FUN_08004e20",
            "FUN_08004e34",
            "FUN_08004e48",
            "FUN_08004e5c",
            "FUN_08004e70",
            "FUN_08004e74",
            "FUN_08004ec4",
            "FUN_08004ef4",
            "FUN_08004f0c",
            "FUN_08004f1c",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f4c",
            "FUN_08005384",
            "FUN_080053d4",
            "FUN_0800548c",
            "FUN_080054b0",
            "FUN_080054d4",
            "FUN_08005510",
            "FUN_08005568",
            "FUN_080055bc",
            "FUN_080055e0",
            "FUN_08005604",
            "FUN_08005650",
            "FUN_08005690",
            "FUN_080056a8",
            "FUN_080056c0",
            "FUN_080056d8",
            "FUN_08005714",
            "FUN_0800571a",
            "FUN_08005724",
            "FUN_08005728",
            "FUN_0800572c",
            "FUN_08005730",
            "FUN_0800573c",
            "FUN_08005740",
            "FUN_08005750",
            "FUN_08005754",
            "FUN_080057b4",
            "FUN_08005848",
            "FUN_08005890",
            "FUN_080058e0",
            "FUN_080058ea",
            "FUN_0800591e",
            "FUN_08005932",
            "FUN_0800594e",
            "FUN_08005976",
            "FUN_0800598a",
            "FUN_080059c8",
            "FUN_08005a44",
            "FUN_08005a68",
            "FUN_08005b24",
            "FUN_08005b3c",
            "FUN_08005b54",
            "FUN_08005bb0",
            "FUN_08005bd4",
            "FUN_08005be2",
            "FUN_08005c1c",
            "FUN_08005c38",
            "FUN_08005c64",
            "FUN_08005c72",
            "FUN_08005c96",
            "FUN_08005cb6",
            "FUN_08005cc0",
            "FUN_08005cd4",
            "FUN_08005ce8",
            "FUN_08005d42",
            "FUN_08005d82",
            "FUN_08005d8a",
            "FUN_08005da0",
            "FUN_08005da8",
            "FUN_08005f2c",
            "FUN_08005f40",
            "FUN_08005f5e",
            "FUN_08005f6c",
            "FUN_08005f8c",
            "FUN_08005fa0",
            "FUN_08005fc8",
            "FUN_08006074",
            "FUN_0800607e",
            "FUN_08006088",
            "FUN_08006092",
            "FUN_0800609c",
            "FUN_080060a6",
            "FUN_080060bc",
            "FUN_080060d4",
            "FUN_080060e4",
            "FUN_08006104",
            "FUN_08006112",
            "FUN_0800611c",
            "FUN_08006158",
            "FUN_08006174",
            "FUN_08006198",
            "FUN_080061e0",
            "FUN_080061f0",
            "FUN_08006288",
            "FUN_08006344",
            "FUN_08006370",
            "FUN_08006394",
            "FUN_080065c0",
            "FUN_080066b0",
            "FUN_080068f0",
            "FUN_08006920",
            "FUN_08006940",
            "FUN_080069e4",
            "FUN_08006ac0",
            "FUN_08006ad0",
            "FUN_08006be0",
            "FUN_08006c34",
            "FUN_08006c40",
            "FUN_08006c88",
            "FUN_08006cb4",
            "FUN_08006d14",
            "FUN_08006d8c",
            "FUN_08006dc8",
            "FUN_08006e10",
            "FUN_08006e90",
            "FUN_08006eb0",
            "FUN_08006f00",
            "FUN_08006f10",
            "FUN_08006f38",
            "FUN_08006f5a",
            "FUN_08006f92",
            "FUN_08006fb6",
            "FUN_08006fc0",
            "FUN_08006fe4",
            "FUN_08007004",
            "FUN_08007028",
            "FUN_08007048",
            "FUN_0800706c",
            "FUN_08007090",
            "FUN_08007098",
            "FUN_0800715c",
            "FUN_08007220",
            "FUN_080072a4"
        ],
        [
            "FUN_080004f8",
            "FUN_0800074c"
        ]
    ],
    "locked_functions": []
}