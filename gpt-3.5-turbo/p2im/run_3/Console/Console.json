{
    "functions": {
        "FUN_000026c0": {
            "renaming": {
                "FUN_000026c0": "reset_and_initialize_data_000026c0",
                "PTR_DAT_000026d4": "pointer_to_data",
                "reset_data_00002910": "reset_data"
            },
            "code": "void reset_and_initialize_data_000026c0(void)\n{\n  reset_data();\n  *(undefined4 *)PTR_DAT_000026d4 = 0;\n  return;\n}",
            "called": [
                "FUN_00002910"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "reset_and_initialize_data_000026c0"
        },
        "FUN_00004bd0": {
            "renaming": {
                "FUN_00004bd0": "allocate_memory_block_00004bd0",
                "*param_1": "*out_ptr",
                "param_2": "size",
                "param_3": "arg2",
                "param_4": "arg3",
                "puVar1": "ptr",
                "uVar2": "value",
                "puVar3": "list_head",
                "iVar4": "diff",
                "uVar5": "remaining_size",
                "puVar6": "current_block",
                "uVar7": "aligned_size"
            },
            "code": "uint allocate_memory_block_00004bd0(uint *out_ptr, uint size, uint arg2, uint arg3)\n{\n  uint aligned_size = (size + 3 & 0xfffffffc) + 8;\n  if (aligned_size < 0xc) {\n    aligned_size = 0xc;\n  }\n  if (((int)aligned_size < 0) || (aligned_size < size)) {\n    *out_ptr = 0xc;\n  }\n  else {\n    do_nothing_with_pointer_00005790();\n    uint *list_head = *(uint **)PTR_DAT_00004c7c;\n    uint *current_block = *(uint **)PTR_DAT_00004c7c;\n    while (current_block != (uint *)0x0) {\n      uint remaining_size = *current_block - aligned_size;\n      if (-1 < (int)remaining_size) {\n        if (0xb < remaining_size) {\n          *current_block = remaining_size;\n          current_block = (uint *)((int)current_block + remaining_size);\n          goto LAB_00004c34;\n        }\n        uint next_block = current_block[1];\n        if (list_head == current_block) {\n          *(uint *)PTR_DAT_00004c7c = next_block;\n        }\n        if (list_head != current_block) {\n          list_head[1] = next_block;\n        }\n        goto LAB_00004c42;\n      }\n      list_head = current_block;\n      current_block = (uint *)current_block[1];\n    }\n    if (*(int *)PTR_DAT_00004c80 == 0) {\n      uint value = get_value_or_default_00000428(out_ptr, 0, list_head, 0, arg3);\n      *(uint *)PTR_DAT_00004c80 = value;\n    }\n    current_block = (uint *)get_value_or_default_00000428(out_ptr, aligned_size);\n    if ((current_block != (uint *)0xffffffff) && ((current_block == (uint *)current_block + 1 || get_value_or_default_00000428(out_ptr, (int)current_block - (int)current_block) != -1))) {\n      *current_block = aligned_size;\n      do_nothing_with_pointer_0000579c(out_ptr);\n      uint block_end = (int)current_block + 0xbU & 0xfffffff8;\n      int diff = block_end - (int)(current_block + 1);\n      if (diff == 0) {\n        return block_end;\n      }\n      *(uint *)((int)current_block + diff) = (int)(current_block + 1) - block_end;\n      return block_end;\n    }\n    *out_ptr = 0xc;\n    do_nothing_with_pointer_0000579c(out_ptr);\n  }\n  return 0;\n}",
            "called": [
                "FUN_0000579c",
                "FUN_00005790",
                "FUN_00000428"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004bd0",
            "calling": [
                "FUN_000068f0",
                "FUN_00005700",
                "FUN_00004248",
                "FUN_00005100",
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_00004bd0"
        },
        "FUN_00000794": {
            "renaming": {
                "FUN_00000794": "create_interrupt_handler_data_00000794",
                "puVar2": "data_ptr",
                "iVar1": "num_words",
                "uVar3": "aligned_data_ptr",
                "piStack_14": "handler_data_ptr",
                "iStack_18": "i",
                "iStack_1c": "i"
            },
            "code": "int * create_interrupt_handler_data_00000794(void)\n{\n  int extraout_r1;\n  int num_words;\n  undefined4 *data_ptr;\n  uint aligned_data_ptr;\n  int *handler_data_ptr;\n  \n  check_for_enabled_IRQ_interrupts();\n  *(undefined4 *)(iRam000007d0 + *psRam000007cc * 4) = 0;\n  *piRam000007d4 = *piRam000007d4 - 1;\n  update_list(*puRam000007d8, 0);\n  data_ptr = puRam000007d8;\n  num_words = 0;\n  *puRam000007d8 = 0;\n  handle_IRQ_interrupt();\n  aligned_data_ptr = (int)data_ptr + num_words & 0xfffffffc;\n  handler_data_ptr = (int *)(aligned_data_ptr - 4);\n  *handler_data_ptr = 0x77777777;\n  if (((uint)handler_data_ptr & 7) != 0) {\n    handler_data_ptr = (int *)(aligned_data_ptr - 8);\n    *handler_data_ptr = 0x88888888;\n  }\n  handler_data_ptr[-1] = 0x1000000;\n  handler_data_ptr[-2] = num_words << 0xd;\n  handler_data_ptr[-3] = DAT_000008b4;\n  handler_data_ptr = handler_data_ptr - 4;\n  *handler_data_ptr = 0;\n  for (int i = 3; i > 0; i--)\n  {\n    handler_data_ptr = handler_data_ptr - 1;\n    *handler_data_ptr = i;\n  }\n  handler_data_ptr = handler_data_ptr - 1;\n  *handler_data_ptr = extraout_r1;\n  for (int i = 0xb; i > 3; i--)\n  {\n    handler_data_ptr = handler_data_ptr - 1;\n    *handler_data_ptr = i;\n  }\n  handler_data_ptr[-1] = -3;\n  return handler_data_ptr - 1;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000930",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000794",
            "calling": [],
            "imported": false,
            "current_name": "create_interrupt_handler_data_00000794"
        },
        "FUN_000064bc": {
            "renaming": {
                "FUN_000064bc": "process_input_000064bc",
                "param_1": "input",
                "param_2": "state",
                "param_3": "buffer",
                "param_4": "func_ptr",
                "puVar1": "char_ptr",
                "iVar2": "func_result",
                "uVar3": "remaining_chars",
                "ppbVar4": "byte_ptr_ptr",
                "pbVar5": "next_byte",
                "unaff_r6": "output_buffer",
                "pbVar6": "output_byte",
                "iVar7": "num_chars_processed"
            },
            "code": "undefined4 process_input_000064bc(undefined4 input, uint *state, byte **buffer, undefined4 *func_ptr) {\n  undefined *char_ptr;\n  int num_chars_processed;\n  uint remaining_chars;\n  byte **byte_ptr_ptr;\n  byte *next_byte;\n  byte *output_buffer;\n  int func_result;\n\n  if (state[2] == 0) {\n    if (state[6] == 0) {\n      remaining_chars = 1;\n    }\n    else {\n      remaining_chars = 0xffffffff;\n    }\n    state[2] = remaining_chars;\n  }\n  char_ptr = PTR_DAT_00006568;\n  if (-1 < (int)(*state << 0x1b)) {\n    byte_ptr_ptr = (byte **)*func_ptr;\n    *func_ptr = byte_ptr_ptr + 1;\n    next_byte = *byte_ptr_ptr;\n  }\n  num_chars_processed = 0;\n  do {\n    remaining_chars = state[6];\n    if (remaining_chars != 0) {\n      if (remaining_chars == 1) {\n        if (*(char *)(state[5] + (uint)**buffer) == '\\0') {\n          if (num_chars_processed == 0) {\n            return 1;\n          }\n        LAB_0000654a:\n          if (((*state & 0x10) == 0) && (state[3] = state[3] + 1, state[6] != 0)) {\n            *next_byte = 0;\n          }\n          state[4] = num_chars_processed + state[4];\n          return 0;\n        }\n      }\n      else if ((remaining_chars != 2) || ((int)((uint)(byte)char_ptr[**buffer] << 0x1c) < 0))\n        goto LAB_0000654a;\n    }\n    output_buffer = next_byte;\n    if (-1 < (int)(*state << 0x1b)) {\n      output_buffer = next_byte + 1;\n      *next_byte = **buffer;\n    }\n    next_byte = buffer[1];\n    *buffer = *buffer + 1;\n    remaining_chars = state[2] - 1;\n    buffer[1] = next_byte + -1;\n    num_chars_processed = num_chars_processed + 1;\n    state[2] = remaining_chars;\n    next_byte = output_buffer;\n    if ((remaining_chars == 0) || (((int)(next_byte + -1) < 1 &&\n         (func_result = (*(code *)state[0x60])(input, buffer, remaining_chars, (code *)state[0x60], func_ptr),\n          func_result != 0))))\n      goto LAB_0000654a;\n  } while( true );\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000064bc",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "process_input_000064bc"
        },
        "FUN_00002970": {
            "renaming": {
                "FUN_00002970": "clear_bit_in_uint_array_00002970",
                "DAT_00002990": "data",
                "ptr_data": "data_ptr"
            },
            "code": "void clear_bit_in_uint_array_00002970(void)\n{\n    uint *ptr_DAT_00002990 = (uint *)(DAT_00002990 + 0x14);\n    *ptr_DAT_00002990 = *ptr_DAT_00002990 & 0xffffffef;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002970",
            "calling": [
                "FUN_000026e4"
            ],
            "imported": false,
            "current_name": "clear_bit_in_uint_array_00002970"
        },
        "FUN_00000dc0": {
            "renaming": {
                "FUN_00000dc0": "check_for_interrupts_before_handling_00000dc0",
                "check_for_IRQ_interrupts_00000cc0": "check_for_IRQ_interrupts"
            },
            "code": "void check_for_interrupts_before_handling_00000dc0(void)\n{\n  check_for_IRQ_interrupts();\n  return;\n}",
            "called": [
                "FUN_00000cc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dc0",
            "calling": [],
            "imported": false,
            "current_name": "check_for_interrupts_before_handling_00000dc0"
        },
        "FUN_00000d0c": {
            "renaming": {
                "FUN_00000d0c": "enableIRQinterrupts_if_privileged_00000d0c",
                "param_1": "interrupt_bit",
                "bVar1": "is_privileged"
            },
            "code": "void enableIRQinterrupts_if_privileged_00000d0c(uint interrupt_bit)\n{\n  bool is_privileged = (bool)isCurrentModePrivileged();\n  if (is_privileged) {\n    enableIRQinterrupts((interrupt_bit & 1) == 1);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d0c",
            "calling": [
                "FUN_000010d4",
                "FUN_000024bc",
                "FUN_00002434",
                "FUN_00001c84",
                "FUN_00000428"
            ],
            "imported": false,
            "current_name": "enableIRQinterrupts_if_privileged_00000d0c"
        },
        "FUN_00003d94": {
            "renaming": {
                "FUN_00003d94": "perform_operation_00003d94",
                "param_1": "object_address",
                "param_2": "operation_parameter",
                "uVar1": "result"
            },
            "code": "int perform_operation_00003d94(int object_address, int operation_parameter)\n{\n  int result;\n  if (object_address == 0) {\n    result = -19;\n  }\n  else {\n    result = (**(code **)(*(int *)(object_address + 0xc) + 4))(*(int *)(object_address + 4),operation_parameter);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d94",
            "calling": [
                "FUN_0000305c"
            ],
            "imported": false,
            "current_name": "perform_operation_00003d94"
        },
        "FUN_0000579c": {
            "renaming": {
                "FUN_0000579c": "do_nothing_with_pointer_0000579c",
                "PTR_DAT_000057a4": "PTR_data",
                "do_nothing_000045ec": "do_nothing"
            },
            "code": "void do_nothing_with_pointer_0000579c(void)\n{\n  do_nothing(PTR_DAT_000057a4);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000579c",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_0000579c"
        },
        "FUN_000015d0": {
            "renaming": {
                "FUN_000015d0": "copy_data_to_memory_000015d0",
                "param_1": "index",
                "param_2": "offset",
                "param_3": "length",
                "iVar1": "memory_address",
                "local_c": "i"
            },
            "code": "void copy_data_to_memory_000015d0(int index, int offset, uint length)\n{\n    int memory_address = *(int *)(PTR_DAT_00001624 + index * 0x20);\n    for (uint i = 0; i < length; i++) {\n        do {\n        } while (-1 < *(char *)(memory_address + 4));\n        *(undefined *)(memory_address + 7) = *(undefined *)(i + offset);\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000015d0",
            "calling": [
                "FUN_00000e38"
            ],
            "imported": false,
            "current_name": "copy_data_to_memory_000015d0"
        },
        "FUN_00005e68": {
            "renaming": {
                "FUN_00005e68": "process_data_00005e68",
                "param_1": "data",
                "param_2": "data_length",
                "param_3": "end_of_string",
                "param_4": "string_length",
                "local_80": "data_copy",
                "local_7c": "end_of_string_index",
                "local_74": "string_start_pointer",
                "local_72": "string_terminator",
                "local_70": "data_start_pointer",
                "local_6c": "data_end",
                "local_5c": "string_start_pointer",
                "local_4c": "string_index",
                "local_38": "string_length_copy",
                "uStack_8": "string",
                "uStack_4": "string_index",
                "PTR_LAB_00004dea_1_00005eb4": "string_start_pointer",
                "*DAT_00005eb8": "process_data_helper"
            },
            "code": "void process_data_00005e68(int data, int data_length, int end_of_string, int string_length) {\n  int data_copy = data;\n  int end_of_string_index = find_end_of_string(end_of_string);\n  char *string_ptr = PTR_LAB_00004dea_1_00005eb4;\n  int string_index = 0;\n  int string_length_copy = string_length;\n  int string_terminator = 0xffff;\n  int data_end = end_of_string_index - data_length + 1;\n  *DAT_00005eb8(data_start_pointer, &data_copy, data_length, &string_ptr, &string_index, &string_length_copy, &string_terminator, &data_end);\n}\n\nvoid *DAT_00005eb8(int *data, int *data_index, int data_length, char **string, int *string_index, int *string_length, int *string_terminator, int *data_end) {\n  while (*data_index <= *data_end && *string_index < *string_length) {\n    if (*data == **string) {\n      (*data_index)++;\n      (*string)++;\n      (*string_index)++;\n    } else {\n      *data_index -= *string_index - 1;\n      *string_index = 0;\n      *string = PTR_LAB_00004dea_1_00005eb4;\n    }\n  }\n  *string_terminator = (*string_index == *string_length) ? 0 : *string_terminator;\n}\n",
            "called": [
                "FUN_00005ecc",
                "FUN_000061cc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e68",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "process_data_00005e68"
        },
        "FUN_00000dcc": {
            "renaming": {
                "FUN_00000dcc": "set_data_00000dcc",
                "DAT_00000df0": "data_ptr"
            },
            "code": "void set_data_00000dcc(void) {\n  int* DAT_00000df0 = DAT_00000df0;\n  DAT_00000df0[7] = 0xc520;\n  DAT_00000df0[7] = 0xd928;\n  *DAT_00000df0 = 0xd2;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dcc",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": false,
            "current_name": "set_data_00000dcc"
        },
        "FUN_0000285c": {
            "renaming": {
                "FUN_0000285c": "update_data_in_array_0000285c",
                "param_1": "new_data",
                "puVar1": "data_array_ptr",
                "DAT_00002890": "data_array"
            },
            "code": "void update_data_in_array_0000285c(int new_data) {\n    int* DAT_00002890_ptr;\n    DAT_00002890_ptr = DAT_00002890;\n    DAT_00002890[5] &= 0xffffffef;\n    *DAT_00002890_ptr = new_data;\n    DAT_00002890_ptr[5] |= 0x10;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000285c",
            "calling": [
                "FUN_00002600"
            ],
            "imported": false,
            "current_name": "update_data_in_array_0000285c"
        },
        "FUN_00000e58": {
            "renaming": {
                "FUN_00000e58": "wait_for_IRQ_interrupts_00000e58",
                "check_for_enabled_IRQ_interrupts_00000cd0": "enable_IRQ_interrupts"
            },
            "code": "void wait_for_IRQ_interrupts_00000e58(void)\n{\n  enable_IRQ_interrupts();\n  while(true)\n  {\n    // Infinite loop, waiting for interrupts\n  }\n}",
            "called": [
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e58",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "wait_for_IRQ_interrupts_00000e58"
        },
        "FUN_00001778": {
            "renaming": {
                "FUN_00001778": "set_flag_and_null_terminate_00001778",
                "DAT_000017d0": "data_start_ptr",
                "DAT_000017d8": "string_start_ptr",
                "PTR_": "ptr_",
                "current_value": "current_flag_value",
                "new_value": "new_flag_value",
                "data_ptr": "flag_data_ptr"
            },
            "code": "void set_flag_and_null_terminate_00001778(void)\n{\n    byte* data_ptr = (byte*)(DAT_000017d0 + 1);\n    byte current_value = *data_ptr;\n    byte new_value = (current_value & 0xCF) | 0x20;\n    *data_ptr = new_value;\n    null_terminate_string_00001710(DAT_000017d8, 2);\n    return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001778",
            "calling": [
                "FUN_000019c0",
                "FUN_0000191c"
            ],
            "imported": false,
            "current_name": "set_flag_and_null_terminate_00001778"
        },
        "FUN_000026d8": {
            "renaming": {
                "FUN_000026d8": "set_flag_and_return_000026d8",
                "PTR_0000294c": "PTR_0000294c",
                "DAT_0000294c": "DAT_0000294c"
            },
            "code": "void set_flag_and_return_000026d8(void)\n{\n  set_flag_on_0000294c();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026d8",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "set_flag_and_return_000026d8"
        },
        "FUN_00000566": {
            "renaming": {
                "FUN_00000566": "count_leading_zeroes_in_uint32_t_00000566",
                "param_1": "num",
                "bVar1": "byte_1",
                "bVar2": "byte_2",
                "bVar3": "byte_3",
                "bVar4": "byte_4",
                "uVar5": "leading_zeroes"
            },
            "code": "uint32_t count_leading_zeroes_in_uint32_t_00000566(uint32_t num) {\n  uint32_t bit_mask = 0x80000000;\n  uint8_t byte_arr[4];\n  memcpy(byte_arr, &num, sizeof(uint32_t));\n  uint32_t bit_arr[32];\n  for (int i = 0; i < 4; i++) {\n    for (int j = 0; j < 8; j++) {\n      bit_arr[i * 8 + j] = (byte_arr[i] & (1 << (7 - j))) >> (7 - j);\n    }\n  }\n  int count = 0;\n  for (int i = 0; i < 32; i++) {\n    if (bit_arr[i] == 0) {\n      count++;\n    } else {\n      break;\n    }\n  }\n  return count;\n}\n\nuint32_t count_leading_zeroes_in_uint32_t_00000566(uint32_t num) {\n  uint8_t byte_arr[4];\n  memcpy(byte_arr, &num, sizeof(uint32_t));\n  uint32_t bit_arr[32];\n  for (int i = 0; i < 4; i++) {\n    for (int j = 0; j < 8; j++) {\n      bit_arr[i * 8 + j] = (byte_arr[i] & (1 << (7 - j))) >> (7 - j);\n    }\n  }\n  uint32_t num_to_count_leading_zeroes = 0;\n  for (int i = 0; i < 32; i++) {\n    num_to_count_leading_zeroes |= bit_arr[i] << (31 - i);\n  }\n  uint32_t leading_zeroes = count_leading_zeroes_in_uint32_t_00000566(num_to_count_leading_zeroes);\n  if (num == 0) {\n    leading_zeroes = 32;\n  }\n  return leading_zeroes;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000566",
            "calling": [
                "FUN_00000610"
            ],
            "imported": false,
            "current_name": "count_leading_zeroes_in_uint32_t_00000566"
        },
        "FUN_00001d08": {
            "renaming": {
                "FUN_00001d08": "calculate_address_00001d08",
                "param_1": "address",
                "param_2": "offset",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int calculate_address_00001d08(uint32_t address, int offset)\n{\n  uint32_t upper_bits = address & 0xf0000000;\n  uint32_t lower_bits = address & 0xfffff;\n  int scaled_offset = offset * 4;\n  uint32_t shifted_lower_bits = lower_bits << 5;\n  uint32_t result = upper_bits | shifted_lower_bits | 0x2000000;\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d08",
            "calling": [
                "FUN_00001d3a"
            ],
            "imported": false,
            "current_name": "calculate_address_00001d08"
        },
        "FUN_000031fc": {
            "renaming": {
                "FUN_000031fc": "calculate_result_000031fc",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "iVar2": "temp1",
                "bVar1": "flag",
                "iVar3": "temp2",
                "param_1 - (uint)bVar1": "num1 - (uint)flag",
                "param_1 < 0": "num1 < 0",
                "iVar2 = param_2": "temp1 = num2",
                "iVar2 = 1": "temp1 = 1",
                "bVar1 = (byte)iVar2": "flag = (byte)temp1",
                "bVar1 = 0": "flag = 0",
                "iVar2 = param_1": "temp2 = num1",
                "iVar2 = param_1 + 3": "temp2 = num1 + 3",
                "param_3 = (((iVar2 >> 2) + param_1) - (int)((longlong)DAT_00003280 * (longlong)param_1 >> 0x25)) + (int)((longlong)DAT_00003280 * (longlong)param_1 >> 0x27) + *(int *)(DAT_00003284 + (param_2 + -1) * 4) + param_3;": "result = (((temp2 >> 2) + num1) - (int)((longlong)DAT_00003280 * (longlong)num1 >> 0x25)) + (int)((longlong)DAT_00003280 * (longlong)num1 >> 0x27) + *(int *)(DAT_00003284 + (num2 + -1) * 4) + num3;",
                "return param_3 + (((int)((ulonglong)((longlong)DAT_00003288 * (longlong)param_3) >> 0x20) + param_3 >> 2) - (param_3 >> 0x1f)) * -7;": "return result + (((int)((ulonglong)((longlong)DAT_00003288 * (longlong)result) >> 0x20) + result >> 2) - (result >> 0x1f)) * -7;"
            },
            "code": "int calculate_result_000031fc(int num1, int num2, int num3) {\n  int temp1 = num2;\n  if (num2 < 3) {\n    temp1 = 1;\n  }\n  byte flag = (byte)temp1;\n  if (num2 > 2) {\n    flag = 0;\n  }\n  num1 = num1 - (uint)flag;\n  int temp2 = num1;\n  if (num1 < 0) {\n    temp2 = num1 + 3;\n  }\n  int param_3 = (((iVar2 >> 2) + param_1) - (int)((longlong)DAT_00003280 * (longlong)param_1 >> 0x25)) + (int)((longlong)DAT_00003280 * (longlong)param_1 >> 0x27) + *(int *)(DAT_00003284 + (param_2 + -1) * 4) + param_3;\n  return param_3 + (((int)((ulonglong)((longlong)DAT_00003288 * (longlong)param_3) >> 0x20) + param_3 >> 2) - (param_3 >> 0x1f)) * -7;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031fc",
            "calling": [
                "FUN_0000328c"
            ],
            "imported": false,
            "current_name": "calculate_result_000031fc"
        },
        "FUN_000016ec": {
            "renaming": {
                "FUN_000016ec": "set_result_to_one_000016ec",
                "param_1": "input1",
                "param_2": "input2",
                "puVar1": "result",
                "*puVar1": "*result"
            },
            "code": "void set_result_to_one_000016ec(int input1, char input2) {\n  undefined *result = (undefined *)calculate_result(input1, input2);\n  *result = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016ec",
            "calling": [
                "FUN_00001a18",
                "FUN_00001778",
                "FUN_00001a3c",
                "FUN_0000182c",
                "FUN_00001a60"
            ],
            "imported": false,
            "current_name": "set_result_to_one_000016ec"
        },
        "FUN_00005100": {
            "renaming": {
                "FUN_00005100": "FUNC_00005100"
            },
            "code": "\nvoid FUNC_00005100(void)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined4 *puVar3;\n  undefined4 uVar4;\n  int iVar5;\n  char *pcVar6;\n  int iVar7;\n  int iVar8;\n  char cVar9;\n  char *pcVar10;\n  bool bVar11;\n  ushort *puVar12;\n  int *piVar13;\n  ushort *puVar14;\n  int *piVar15;\n  ushort local_3c;\n  ushort local_3a;\n  ushort local_38;\n  ushort local_36;\n  ushort local_34;\n  ushort local_32;\n  int local_30;\n  char *local_2c [2];\n  \n  uVar4 = *DAT_00005108;\n  iVar5 = get_data_000056b0();\n  puVar1 = PTR_DAT_000053d8;\n  pcVar6 = (char *)find_key_index_000056a0(uVar4,PTR_DAT_000053d4);\n  puVar2 = PTR_DAT_000053e0;\n  if (pcVar6 == (char *)0x0) {\n    *(undefined4 *)PTR_DAT_000053dc = 0;\n    *(undefined4 *)PTR_DAT_000053e4 = 0;\n    puVar3 = DAT_000053e8;\n    uVar4 = *(undefined4 *)puVar1;\n    *DAT_000053e8 = puVar2;\n    puVar3[1] = puVar2;\n    insert_node_at_end_of_list_00005780(uVar4);\n    *(undefined4 *)puVar1 = 0;\n  }\n  else if ((*(int *)puVar1 == 0) || (iVar7 = compare_bytes_00004e52(), iVar7 != 0)) {\n    insert_node_at_end_of_list_00005780(*(undefined4 *)puVar1);\n    iVar7 = find_end_of_string_00005ecc(pcVar6);\n    iVar7 = allocate_memory_block_00004bd0(uVar4,iVar7 + 1);\n    *(int *)puVar1 = iVar7;\n    if (iVar7 != 0) {\n      copy_string_00005ebc(iVar7,pcVar6);\n    }\n    if (*pcVar6 == ':') {\n      pcVar6 = pcVar6 + 1;\n    }\n    iVar7 = process_data_00005e68(pcVar6,PTR_s__10__0_9_____n_000053f0,PTR_DAT_000053ec,&local_30);\n    if (0 < iVar7) {\n      pcVar10 = pcVar6 + local_30;\n      if (pcVar6[local_30] == '-') {\n        pcVar10 = pcVar10 + 1;\n        iVar7 = -1;\n      }\n      else {\n        if (pcVar6[local_30] == '+') {\n          pcVar10 = pcVar10 + 1;\n        }\n        iVar7 = 1;\n      }\n      local_3a = 0;\n      local_38 = 0;\n      puVar12 = &local_3a;\n      piVar13 = &local_30;\n      puVar14 = &local_38;\n      piVar15 = &local_30;\n      iVar8 = process_data_00005e68(pcVar10,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                           &local_30,&local_38,&local_30);\n      puVar1 = PTR_DAT_00005400;\n      if (0 < iVar8) {\n        *(uint *)(iVar5 + 0x28) =\n             ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar7;\n        puVar3 = DAT_000053e8;\n        *DAT_000053e8 = PTR_DAT_000053ec;\n        pcVar10 = pcVar10 + local_30;\n        iVar7 = process_data_00005e68(pcVar10,PTR_s__10__0_9_____n_000053f0,puVar1,&local_30,puVar12,piVar13,\n                             puVar14,piVar15);\n        if (iVar7 < 1) {\n          puVar3[1] = *puVar3;\n          *(undefined4 *)PTR_DAT_000053dc = *(undefined4 *)(iVar5 + 0x28);\n          *(undefined4 *)PTR_DAT_000053e4 = 0;\n        }\n        else {\n          puVar3[1] = puVar1;\n          pcVar6 = pcVar10 + local_30;\n          if (pcVar10[local_30] == '-') {\n            pcVar6 = pcVar6 + 1;\n            iVar7 = -1;\n          }\n          else {\n            if (pcVar10[local_30] == '+') {\n              pcVar6 = pcVar6 + 1;\n            }\n            iVar7 = 1;\n          }\n          local_3c = 0;\n          local_3a = 0;\n          local_38 = 0;\n          local_30 = 0;\n          iVar8 = process_data_00005e68(pcVar6,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a\n                               ,&local_30,&local_38,&local_30);\n          if (iVar8 < 1) {\n            iVar7 = *(int *)(iVar5 + 0x28) + -0xe10;\n          }\n          else {\n            iVar7 = ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar7;\n          }\n          *(int *)(iVar5 + 0x50) = iVar7;\n          pcVar6 = pcVar6 + local_30;\n          bVar11 = false;\n          iVar7 = iVar5;\n          while( true ) {\n            if (*pcVar6 == ',') {\n              pcVar6 = pcVar6 + 1;\n            }\n            cVar9 = *pcVar6;\n            if (cVar9 == 'M') {\n              iVar8 = process_data_00005e68(pcVar6,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&local_36,&local_30,\n                                   &local_34,&local_30,&local_32,&local_30);\n              if (iVar8 != 3) {\n                return;\n              }\n              if (0xb < local_36 - 1) {\n                return;\n              }\n              if (4 < local_34 - 1) {\n                return;\n              }\n              if (6 < local_32) {\n                return;\n              }\n              *(uint *)(iVar7 + 0xc) = (uint)local_36;\n              *(uint *)(iVar7 + 0x10) = (uint)local_34;\n              *(undefined *)(iVar7 + 8) = 0x4d;\n              *(uint *)(iVar7 + 0x14) = (uint)local_32;\n              pcVar10 = pcVar6 + local_30;\n            }\n            else {\n              if (cVar9 == 'J') {\n                pcVar6 = pcVar6 + 1;\n              }\n              else {\n                cVar9 = 'D';\n              }\n              local_32 = parse_and_convert_number_00005fd8(pcVar6,local_2c,10);\n              pcVar10 = local_2c[0];\n              if (local_2c[0] == pcVar6) {\n                if (bVar11) {\n                  *(undefined *)(iVar5 + 0x30) = 0x4d;\n                  *(undefined4 *)(iVar5 + 0x34) = 0xb;\n                  *(undefined4 *)(iVar5 + 0x38) = 1;\n                  *(undefined4 *)(iVar5 + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(iVar5 + 8) = 0x4d;\n                  *(undefined4 *)(iVar5 + 0xc) = 3;\n                  *(undefined4 *)(iVar5 + 0x10) = 2;\n                  *(undefined4 *)(iVar5 + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(iVar7 + 8) = cVar9;\n                *(uint *)(iVar7 + 0x14) = (uint)local_32;\n              }\n            }\n            local_3c = 2;\n            local_3a = 0;\n            local_38 = 0;\n            local_30 = 0;\n            if (*pcVar10 == '/') {\n              process_data_00005e68(pcVar10,PTR_DAT_000053fc,&local_3c,&local_30,&local_3a,&local_30,\n                           &local_38,&local_30);\n            }\n            *(uint *)(iVar7 + 0x18) =\n                 (uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38;\n            iVar7 = iVar7 + 0x28;\n            pcVar6 = pcVar10 + local_30;\n            if (bVar11) break;\n            bVar11 = true;\n          }\n          calculate_day_of_week_00004f98(*(undefined4 *)(iVar5 + 4));\n          iVar7 = *(int *)(iVar5 + 0x28);\n          *(int *)PTR_DAT_000053dc = iVar7;\n          iVar7 = *(int *)(iVar5 + 0x50) - iVar7;\n          if (iVar7 != 0) {\n            iVar7 = 1;\n          }\n          *(int *)PTR_DAT_000053e4 = iVar7;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005ecc",
                "FUN_00005e68",
                "FUN_00005ebc",
                "FUN_00004e52",
                "FUN_000056a0",
                "FUN_00005780",
                "FUN_00004f98",
                "FUN_000056b0",
                "FUN_00004bd0",
                "FUN_00005fd8"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005100",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "FUNC_00005100"
        },
        "FUN_00005584": {
            "renaming": {
                "FUN_00005584": "divide_and_remainder_00005584",
                "param_1": "result",
                "param_2": "dividend",
                "param_3": "divisor",
                "uVar1": "remainder",
                "uVar2": "quotient"
            },
            "code": "void divide_and_remainder_00005584(uint *result, uint dividend, uint divisor) {\n  uint quotient, remainder;\n  quotient = dividend / divisor;\n  remainder = dividend % divisor;\n  if (dividend < 0) {\n    if (remainder > 0) {\n      quotient--;\n      remainder += divisor;\n    }\n  }\n  else if (remainder < 0) {\n    quotient++;\n    remainder -= divisor;\n  }\n  *result = quotient;\n  result[1] = remainder;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005584",
            "calling": [
                "FUN_00004634"
            ],
            "imported": false,
            "current_name": "divide_and_remainder_00005584"
        },
        "FUN_00004248": {
            "renaming": {
                "FUN_00004248": "allocate_and_initialize_memory_block_00004248",
                "param_1": "base_address",
                "param_2": "block_size",
                "puVar1": "memory_block_ptr",
                "iVar2": "last_index"
            },
            "code": "undefined4 * allocate_and_initialize_memory_block_00004248(undefined4 base_address, int block_size)\n{\n  undefined4 *memory_block_ptr;\n  int last_index = (block_size - 1) * 0x68;\n  memory_block_ptr = (undefined4 *)allocate_memory_block_00004bd0(base_address, last_index + 0x74);\n  if (memory_block_ptr != (undefined4 *)0x0) {\n    *memory_block_ptr = 0;\n    memory_block_ptr[1] = block_size;\n    memory_block_ptr[2] = memory_block_ptr + 3;\n    fill_array_with_value_00004622(memory_block_ptr + 3, 0, last_index + 0x68);\n  }\n  return memory_block_ptr;\n}\n",
            "called": [
                "FUN_00004bd0",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004248",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_memory_block_00004248"
        },
        "FUN_00001da2": {
            "renaming": {
                "FUN_00001da2": "get_bits_from_right_00001da2",
                "param_1": "input_value",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "ushort get_bits_from_right_00001da2(ushort input_value)\n{\n    ushort bits_to_keep = 7;\n    ushort shifted_value = input_value >> 6;\n    ushort masked_value = shifted_value & bits_to_keep;\n    return masked_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001da2",
            "calling": [
                "FUN_00001f80",
                "FUN_00001ddc"
            ],
            "imported": false,
            "current_name": "get_bits_from_right_00001da2"
        },
        "FUN_00001ec4": {
            "renaming": {
                "FUN_00001ec4": "extract_bits_and_write_to_memory_00001ec4",
                "param_1": "memory_address",
                "param_2": "bit_offset",
                "uVar1": "extracted_bits",
                "extract_bits_00001e0c": "extract_bits",
                "write_bits_to_memory_00001e44": "write_bits_to_memory"
            },
            "code": "void extract_bits_and_write_to_memory_00001ec4(undefined4 memory_address, undefined4 bit_offset){\n    undefined4 extracted_bits = extract_bits(memory_address, bit_offset);\n    write_bits_to_memory(memory_address, bit_offset, extracted_bits);\n    return;\n}",
            "called": [
                "FUN_00001e44",
                "FUN_00001e0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ec4",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "extract_bits_and_write_to_memory_00001ec4"
        },
        "FUN_00002744": {
            "renaming": {
                "FUN_00002744": "set_byte_value_00002744",
                "param_1": "value",
                "param_2": "parameter",
                "DAT_00002790": "data_ptr_00002790",
                "DAT_00002794": "data_ptr_00002794"
            },
            "code": "void set_byte_value_00002744(byte value, uint parameter)\n{\n    if (value < 0)\n    {\n        *(char *)((value & 0xf) + DAT_00002790 + 0x14) = (char)((parameter & 0xff) << 4);\n    }\n    else\n    {\n        *(char *)((char)value + DAT_00002794 + 0x300) = (char)((parameter & 0xff) << 4);\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002744",
            "calling": [
                "FUN_00002894"
            ],
            "imported": false,
            "current_name": "set_byte_value_00002744"
        },
        "FUN_00002624": {
            "renaming": {
                "FUN_00002624": "calculate_date_and_return_zero_00002624",
                "param_1": "input_date",
                "local_10": "first_different_value",
                "uStack_c": "stack_c",
                "find_first_different_value_0000281c": "find_first_different_value",
                "calculate_date_0000443c": "calculate_date"
            },
            "code": "int calculate_date_and_return_zero_00002624(int input_date)\n{\n    int first_different_value = find_first_different_value();\n    int stack_c = 0;\n    calculate_date(&first_different_value, input_date);\n    return 0;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_0000281c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002624",
            "calling": [
                "FUN_00003444"
            ],
            "imported": false,
            "current_name": "calculate_date_and_return_zero_00002624"
        },
        "FUN_00001e0c": {
            "renaming": {
                "FUN_00001e0c": "extract_bits_00001e0c",
                "param_1": "offset",
                "param_2": "data",
                "*PTR_DAT_00001e40": "ptr",
                "shifted_data": "shifted_data",
                "extracted_bits": "extracted_bits"
            },
            "code": "uint extract_bits_00001e0c(int offset, uint data) {\n    uint* *PTR_DAT_00001e40 = (uint*)(PTR_DAT_00001e40 + ((data >> 3) + offset * 4) * 4);\n    uint shifted_data = (data & 7) << 2;\n    uint extracted_bits = (**PTR_DAT_00001e40) >> shifted_data & 0xf;\n    return extracted_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e0c",
            "calling": [
                "FUN_00002028",
                "FUN_00001ec4"
            ],
            "imported": false,
            "current_name": "extract_bits_00001e0c"
        },
        "FUN_00000ef8": {
            "renaming": {
                "FUN_00000ef8": "do_nothing_00000ef8"
            },
            "code": "\nvoid do_nothing_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ef8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "do_nothing_00000ef8"
        },
        "FUN_000041d0": {
            "renaming": {
                "FUN_000041d0": "process_data_000041d0",
                "param_1": "data",
                "param_2": "param_2",
                "param_3": "param_3",
                "pcVar1": "function_pointer",
                "iVar2": "data_struct_address",
                "piVar5": "data_struct_pointer",
                "uVar7": "result",
                "puVar9": "struct_pointer",
                "iVar8": "inner_data_struct_address",
                "iVar6": "inner_data_struct_offset",
                "uVar3": "function_result",
                "iVar4": "offset_plus_one"
            },
            "code": "uint process_data_000041d0(int data, undefined4 param_2, undefined4 param_3)\n{\n  code *function_pointer = DAT_000041ec;\n  if (data == 0) {\n    int data_struct_address = *(int *)PTR_DAT_000041e8;\n    int *data_struct_pointer = (int *)(data_struct_address + 0x48);\n    uint result = 0;\n    undefined *struct_pointer = PTR_DAT_000041e8;\n    do {\n      int inner_data_struct_address = data_struct_pointer[1];\n      int inner_data_struct_offset = data_struct_pointer[2];\n      while (inner_data_struct_address = inner_data_struct_address + -1, -1 < inner_data_struct_address) {\n        if ((1 < *(ushort *)(inner_data_struct_offset + 0xc)) && (iVar4 = *(short *)(inner_data_struct_offset + 0xe) + 1, iVar4 != 0)) {\n          uint function_result = (*function_pointer)(data_struct_address,inner_data_struct_offset,param_3,iVar4,struct_pointer);\n          result = result | function_result;\n        }\n        inner_data_struct_offset = inner_data_struct_offset + 0x68;\n      }\n      data_struct_pointer = (int *)*data_struct_pointer;\n    } while (data_struct_pointer != (int *)0x0);\n    return result;\n  }\n  uint result = process_data_000041d0_00004158(*DAT_000041f0, data);\n  return result;\n}",
            "called": [
                "FUN_00004158"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041d0",
            "calling": [
                "FUN_00002e48"
            ],
            "imported": false,
            "current_name": "process_data_000041d0"
        },
        "FUN_0000459c": {
            "renaming": {
                "FUN_0000459c": "execute_functions_and_store_input_value_0000459c",
                "puVar1": "pointer_1",
                "puVar2": "pointer_2",
                "iVar3": "num_functions",
                "ppcVar4": "function_pointer",
                "iVar5": "i",
                "PTR_DAT_000045d8": "PTR_FUNCTIONS_END",
                "PTR_DAT_000045d4": "PTR_FUNCTIONS_START",
                "PTR_DAT_000045e0": "PTR_INPUT_VALUE",
                "PTR_DAT_000045dc": "PTR_RETURN_ADDRESS"
            },
            "code": "void execute_functions_and_store_input_value_0000459c(void)\n{\n  int num_functions = (int)PTR_DAT_000045d8 - (int)PTR_DAT_000045d4;\n  code **function_pointer = (code **)PTR_DAT_000045d4;\n  for (int i = 0; i < num_functions >> 2; i++) {\n    (**function_pointer)();\n    function_pointer++;\n  }\n  store_input_value_and_return_00000410();\n  function_pointer = (code **)PTR_DAT_000045d4;\n  int num_remaining_functions = (int)PTR_DAT_000045d8 - (int)PTR_DAT_000045d4 >> 2;\n  for (int i = 0; i < num_remaining_functions; i++) {\n    (**function_pointer)();\n    function_pointer++;\n  }\n  return;\n}",
            "called": [
                "FUN_00000410"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000459c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "execute_functions_and_store_input_value_0000459c"
        },
        "FUN_000014c4": {
            "renaming": {
                "FUN_000014c4": "update_data_000014c4",
                "param_1": "index",
                "param_2": "num",
                "pbVar1": "data_ptr",
                "uVar2": "data",
                "uVar3": "quotient"
            },
            "code": "void update_data_000014c4(int index, uint16_t num) {\\n\\\n        byte *data_ptr = *(byte **)(PTR_DAT_000015cc + index * 0x20);\\n\\\n        uint32_t data = *(uint32_t *)(PTR_DAT_000015cc + index * 0x20 + 4);\\n\\\n        data_ptr[3] &= 0xf3;\\n\\\n        data_ptr[2] = PTR_DAT_000015cc[index * 0x20 + 0x1d];\\n\\\n        uint32_t quotient = data / (num << 4);\\n\\\n        *data_ptr = (byte)(quotient >> 8) & 0x1f;\\n\\\n        data_ptr[1] = (byte)quotient;\\n\\\n        data_ptr[10] = (byte)((data << 2) / num + 1 >> 1) & 0x1f;\\n\\\n        data_ptr[0x10] |= 0x88;\\n\\\n        if ((data_ptr[0x10] & 0x70) == 0) {\\n\\\n            data_ptr[0x13] = 0;\\n\\\n        }\\n\\\n        else {\\n\\\n            data_ptr[0x13] = (char)(2 << (data_ptr[0x10] >> 4 & 7)) - 1;\\n\\\n        }\\n\\\n        data_ptr[0x15] = 1;\\n\\\n        data_ptr[0x11] = 0xc0;\\n\\\n        data_ptr[3] |= 0x2c;\\n\\\n        set_bit_in_array((int)(char)PTR_DAT_000015cc[index * 0x20 + 0x14]);\\n\\\n    }",
            "called": [
                "FUN_00001318"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000014c4",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "update_data_000014c4"
        },
        "FUN_00004b34": {
            "renaming": {
                "FUN_00004b34": "insert_node_at_end_00004b34",
                "param_1": "error_code",
                "param_2": "node_value",
                "param_3": "unused_param_a",
                "param_4": "unused_param_b",
                "puVar1": "head_node_ptr_ptr",
                "piVar2": "new_node_value_ptr",
                "extraout_r1": "previous_node_ptr_ptr",
                "ppiVar3": "previous_node_ptr_ptr",
                "ppiVar4": "current_node_ptr_ptr",
                "ppiVar5": "head_node_ptr_ptr",
                "ppiVar6": "current_node_ptr_ptr",
                "bVar7": "is_same_node"
            },
            "code": "void insert_node_at_end_00004b34(int* error_code, int node_value, int unused_param_a, int unused_param_b) {\n  int** previous_node_ptr_ptr;\n  int** current_node_ptr_ptr;\n  int** head_node_ptr_ptr = *(int***)PTR_DAT_00004bcc;\n  if (head_node_ptr_ptr == NULL) {\n    int* new_node_ptr = (int*)malloc(sizeof(int) * 2);\n    new_node_ptr[0] = node_value;\n    new_node_ptr[1] = NULL;\n    *(int***)PTR_DAT_00004bcc = &new_node_ptr;\n    current_node_ptr_ptr = &new_node_ptr;\n    previous_node_ptr_ptr = NULL;\n  } else {\n    current_node_ptr_ptr = head_node_ptr_ptr;\n    while (current_node_ptr_ptr[1] != NULL) {\n      previous_node_ptr_ptr = current_node_ptr_ptr;\n      current_node_ptr_ptr = (int**)current_node_ptr_ptr[1];\n    }\n    int* new_node_ptr = (int*)malloc(sizeof(int) * 2);\n    new_node_ptr[0] = node_value;\n    new_node_ptr[1] = NULL;\n    current_node_ptr_ptr[1] = &new_node_ptr;\n    previous_node_ptr_ptr = current_node_ptr_ptr;\n    current_node_ptr_ptr = &new_node_ptr;\n  }\n  do_nothing_with_pointer_0000579c(error_code, (int*)previous_node_ptr_ptr, (int*)current_node_ptr_ptr, unused_param_b);\n  return;\n}",
            "called": [
                "FUN_0000579c",
                "FUN_00005790"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004b34",
            "calling": [
                "FUN_0000404c",
                "FUN_00005780",
                "FUN_000060cc",
                "FUN_000054a8",
                "FUN_00006768",
                "FUN_00006192"
            ],
            "imported": false,
            "current_name": "insert_node_at_end_00004b34"
        },
        "FUN_000004f2": {
            "renaming": {
                "FUN_000004f2": "set_param_to_19_000004f2",
                "param_1": "param_value"
            },
            "code": "unsigned int set_param_to_19_000004f2(unsigned int *param_value)\n{\n    *param_value = 0x13;\n    return 0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004f2",
            "calling": [
                "FUN_00004e26",
                "FUN_00004dee"
            ],
            "imported": false,
            "current_name": "set_param_to_19_000004f2"
        },
        "FUN_00004e66": {
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "param_1": "string1",
                "param_2": "length",
                "param_3": "string2_length",
                "pbVar1": "string1_ptr",
                "pbVar2": "string2_ptr",
                "uVar3": "character_value"
            },
            "code": "int compare_strings_00004e66(byte *string1, int length, int string2_length)\n{\n  byte *string2_ptr;\n  byte *string1_ptr;\n  uint character_value;\n  \n  if (string2_length != 0) {\n    string2_ptr = (byte *)(length - 1);\n    string1_ptr = string1;\n    do {\n      character_value = (uint)*string1_ptr;\n      string2_ptr = string2_ptr + 1;\n      if ((character_value != *string2_ptr) || (string1_ptr + 1 == string1 + string2_length)) break;\n      string1_ptr = string1_ptr + 1;\n    } while (character_value != 0);\n    string2_length = character_value - *string2_ptr;\n  }\n  return string2_length;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e66",
            "calling": [
                "FUN_00003524",
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e66"
        },
        "FUN_00005ecc": {
            "renaming": {
                "FUN_00005ecc": "find_end_of_string_00005ecc",
                "param_1": "input_string",
                "pcVar2": "current_position",
                "cVar1": "current_char",
                "pcVar3": "current_position"
            },
            "code": "char* find_end_of_string_00005ecc(char* input_string) {\n  char current_char;\n  char* current_position = input_string;\n  do {\n    current_position++;\n    current_char = *current_position;\n  } while (current_char != '\\0');\n  return current_position + (-1 - (int)input_string);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ecc",
            "calling": [
                "FUN_00005e68",
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "find_end_of_string_00005ecc"
        },
        "FUN_0000129c": {
            "renaming": {
                "FUN_0000129c": "register_interrupt_handler_with_flag_0000129c",
                "param_1": "interrupt_handler",
                "PTR_00002434": "register_interrupt_handler_00002434",
                "DAT_00000004": "flag"
            },
            "code": "void register_interrupt_handler_with_flag_0000129c(void* interrupt_handler, int DAT_00000004) {\n  PTR_00002434(interrupt_handler, DAT_00000004);\n  return;\n}",
            "called": [
                "FUN_00002434"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000129c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": false,
            "current_name": "register_interrupt_handler_with_flag_0000129c"
        },
        "FUN_00001628": {
            "renaming": {
                "FUN_00001628": "check_and_call_function_00001628",
                "param_1": "index",
                "PTR_DAT_00001680": "ptr_data_1",
                "PTR_DAT_00001684": "ptr_data_2"
            },
            "code": "void check_and_call_function_00001628(int index)\n{\n    byte* flags = (byte*)(*(int*)(PTR_DAT_00001680 + index * 0x20) + 4);\n    int* function_ptr = (int*)(PTR_DAT_00001684 + index * 8);\n    if ((*flags & 0x20) != 0 && *function_ptr != 0)\n    {\n        code* function = **(code**)(function_ptr);\n        undefined4 arg1 = *(undefined4*)(function_ptr + 1);\n        undefined arg2 = *(undefined*)(*(int*)(PTR_DAT_00001680 + index * 0x20) + 7);\n        function(arg1, arg2);\n    }\n    check_flag_and_set_00001348();\n    return;\n}",
            "called": [
                "FUN_00001348"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001628",
            "calling": [
                "FUN_00001688"
            ],
            "imported": false,
            "current_name": "check_and_call_function_00001628"
        },
        "FUN_00001748": {
            "renaming": {
                "FUN_00001748": "setParamValue_00001748",
                "param_1": "newParamValue",
                "*(byte *)(DAT_00001774 + 3)": "currentParamValue",
                "paramAddress": "paramAddress",
                "currentParamValue": "currentParamValue",
                "maskedNewValue": "maskedNewValue"
            },
            "code": "void setParamValue_00001748(byte newParamValue) {\n    byte* paramAddress = (byte*)(DAT_00001774 + 3);\n    byte *(byte *)(DAT_00001774 + 3) = *paramAddress;\n    byte maskedNewValue = newParamValue | (*(byte *)(DAT_00001774 + 3) & 0x1f);\n    *paramAddress = maskedNewValue;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001748",
            "calling": [
                "FUN_000019c0",
                "FUN_00001bb8",
                "FUN_00001960",
                "FUN_0000191c",
                "FUN_000018bc"
            ],
            "imported": false,
            "current_name": "setParamValue_00001748"
        },
        "FUN_0000294c": {
            "renaming": {
                "FUN_0000294c": "set_flag_on_0000294c",
                "DAT_0000296c": "flag_ptr"
            },
            "code": "void set_flag_on_0000294c(uint32_t *DAT_0000296c)\n{\n  uint32_t flag_mask = 0x10;\n  *DAT_0000296c |= flag_mask;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000294c",
            "calling": [
                "FUN_000027b0",
                "FUN_000026d8"
            ],
            "imported": false,
            "current_name": "set_flag_on_0000294c"
        },
        "FUN_00005790": {
            "renaming": {
                "FUN_00005790": "do_nothing_with_pointer_00005790",
                "PTR_DAT_00005798": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_00005790(void)\n{\n  do_nothing(PTR_DAT_00005798);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005790",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00005790"
        },
        "FUN_00000534": {
            "renaming": {
                "FUN_00000534": "is_valid_input_00000534",
                "param_1": "input",
                "param_2": "size",
                "uVar1": "is_valid",
                "*param_1": "*input",
                "uVar1 = 1": "return 1",
                "uVar1 = 0": "return 0"
            },
            "code": "int is_valid_input_00000534(int *input, int size)\n{\n  *input = 0;\n  if (((size == 0) || (size == 1)) || (size == 2)) {\n    return 1;\n  }\n  else {\n    return 0;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000534",
            "calling": [
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "is_valid_input_00000534"
        },
        "FUN_000017dc": {
            "renaming": {
                "FUN_000017dc": "initialize_data_000017dc",
                "set_calculated_result_to_one_and_return_000016c8": "set_result_to_one_and_return",
                "DAT_00001820": "data_pointer_1",
                "DAT_00001824": "data_pointer_2",
                "PTR_00001828": "data_pointer_3"
            },
            "code": "void initialize_data_000017dc()\n{\n    set_result_to_one_and_return(DAT_00001820, 0x1d);\n    if ((*(uint *)(DAT_00001824 + 0x10) & 0x100) == 0) {\n        *(undefined4 *)(DAT_00001824 + 0x10) = 0x104;\n    }\n    *PTR_00001828 = *PTR_00001828 & 0xfff3ffff | 0x80000;\n    return;\n}",
            "called": [
                "FUN_000016c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000017dc",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "initialize_data_000017dc"
        },
        "FUN_00000410": {
            "renaming": {
                "FUN_00000410": "store_input_value_and_return_00000410",
                "store_input_value_00000df4": "store_input_value"
            },
            "code": "void store_input_value_and_return_00000410(void)\n{\n  store_input_value();\n  return;\n}",
            "called": [
                "FUN_00000df4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000410",
            "calling": [
                "FUN_0000459c"
            ],
            "imported": false,
            "current_name": "store_input_value_and_return_00000410"
        },
        "FUN_000005ca": {
            "renaming": {
                "FUN_000005ca": "reverse_linked_list_000005ca",
                "param_1": "head_ptr",
                "puVar1": "new_head_ptr",
                "*param_1": "*head_ptr",
                "undefined4": "node"
            },
            "code": "undefined4 *reverse_linked_list_000005ca(int *head_ptr)\n{\n  undefined4 *new_head_ptr;\n\n  if (*head_ptr == 0) {\n    new_head_ptr = (undefined4 *)0x0;\n  }\n  else {\n    new_head_ptr = *(undefined4 **)*head_ptr;\n    if (new_head_ptr == (undefined4 *)*head_ptr) {\n      *head_ptr = 0;\n    }\n    else {\n      *(undefined4 *)*head_ptr = *new_head_ptr;\n    }\n  }\n  return new_head_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000005ca",
            "calling": [
                "FUN_00000698"
            ],
            "imported": false,
            "current_name": "reverse_linked_list_000005ca"
        },
        "FUN_00005ff8": {
            "renaming": {
                "FUN_00005ff8": "do_nothing_with_data_00005ff8",
                "DAT_00006000": "DAT_data",
                "do_nothing_000045ec": "do_nothing"
            },
            "code": "void do_nothing_with_data_00005ff8(void)\n{\n  do_nothing(DAT_00006000);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ff8",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_00005ff8"
        },
        "FUN_00002714": {
            "renaming": {
                "FUN_00002714": "set_bit_in_array_00002714",
                "param_1": "bit_position",
                "DAT_00002740": "array_start_ptr"
            },
            "code": "void set_bit_in_array_00002714(uint8_t bit_position) {\n    uint32_t* array_ptr = (uint32_t*)(DAT_00002740 + ((uint32_t)bit_position >> 5) * 4);\n    *array_ptr = 1 << (bit_position & 0x1f);\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002714",
            "calling": [
                "FUN_00002894"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_00002714"
        },
        "FUN_000020e0": {
            "renaming": {
                "FUN_000020e0": "decode_and_return_data_000020e0",
                "DAT_000020f0": "data_to_decode",
                "decode_data_00002028": "decode_data"
            },
            "code": "void decode_and_return_data_000020e0(void)\n{\n  int data_length = 2;\n  decode_data(DAT_000020f0, data_length);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020e0",
            "calling": [],
            "imported": false,
            "current_name": "decode_and_return_data_000020e0"
        },
        "FUN_00005fec": {
            "renaming": {
                "FUN_00005fec": "do_nothing_with_data_00005fec",
                "DAT_00005ff4": "DAT_data",
                "do_nothing_000045e8": "do_nothing"
            },
            "code": "void do_nothing_with_data_00005fec(void)\n{\n  do_nothing(DAT_00005ff4);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fec",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_00005fec"
        },
        "FUN_00004f84": {
            "renaming": {
                "FUN_00004f84": "parse_string_to_uint_00004f84",
                "param_1": "string",
                "param_2": "endptr",
                "param_3": "base",
                "uVar1": "result",
                "uVar2": "digit",
                "uVar3": "flags",
                "uVar4": "digit_value",
                "iVar5": "status",
                "uVar6": "max_uint",
                "uVar7": "max_div",
                "pbVar8": "curr_char",
                "pbVar9": "next_char"
            },
            "code": "uint parse_string_to_uint_00004f84(byte *string, byte **endptr, uint base) {\n  uint result = 0;\n  int sign = 1;\n  byte *ptr = string;\n  while (*ptr == ' ') ptr++;\n  if (*ptr == '-') {\n    sign = -1;\n    ptr++;\n  } else if (*ptr == '+') {\n    ptr++;\n  }\n  if (base == 0) {\n    if (*ptr != '0') {\n      base = 10;\n    } else if (*(ptr + 1) == 'x' || *(ptr + 1) == 'X') {\n      base = 16;\n      ptr += 2;\n    } else {\n      base = 8;\n    }\n  } else if (base != 16 && *ptr == '0') {\n    base = 8;\n  }\n  while (1) {\n    uint digit = *ptr;\n    if (digit >= '0' && digit <= '9') {\n      digit -= '0';\n    } else if (digit >= 'a' && digit <= 'z') {\n      digit -= 'a' - 10;\n    } else if (digit >= 'A' && digit <= 'Z') {\n      digit -= 'A' - 10;\n    } else {\n      break;\n    }\n    if (digit >= base) {\n      break;\n    }\n    if (result > UINT_MAX / base || result * base > UINT_MAX - digit) {\n      *endptr = ptr;\n      return sign > 0 ? UINT_MAX : 0;\n    }\n    result = result * base + digit;\n    ptr++;\n  }\n  *endptr = ptr;\n  return sign > 0 ? result : -result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f84",
            "calling": [
                "FUN_0000328c",
                "FUN_00004042"
            ],
            "imported": false,
            "current_name": "parse_string_to_uint_00004f84"
        },
        "FUN_000028f0": {
            "renaming": {
                "FUN_000028f0": "get_data_from_pointer_000028f0",
                "DAT_0000290c": "data_array",
                "PTR_": "pointer_"
            },
            "code": "int get_data_from_pointer_000028f0(void)\n{\n  int* data_pointer = (int *)(DAT_0000290c + 8);\n  int data = *data_pointer;\n  int result = data + 1;\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000028f0",
            "calling": [
                "FUN_00002690"
            ],
            "imported": false,
            "current_name": "get_data_from_pointer_000028f0"
        },
        "FUN_00004f98": {
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "param_1": "year",
                "puVar1": "calendar",
                "uVar2": "is_leap_year",
                "uVar3": "day_of_week_offset",
                "iVar4": "day_of_week_flag",
                "iVar6": "i",
                "puVar5": "current_month",
                "uVar7": "century",
                "iVar8": "k",
                "iVar9": "day_of_week",
                "uVar10": "leap_years"
            },
            "code": "uint32_t calculate_day_of_week_00004f98(uint32_t year)\n{\n  uint32_t *calendar;\n  uint32_t day_of_week = 0;\n  uint32_t day_of_month;\n  uint32_t month;\n  uint32_t leap_years;\n  uint32_t i;\n\n  calendar = (uint32_t *)get_data_000056b0();\n\n  if (year < 0x7b2) {\n    return 0;\n  }\n\n  leap_years = count_leading_zeroes(year % 400);\n  i = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) + (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n\n  for (int j = 0; j < 14; j++) {\n    day_of_month = calendar[j * 10 + 5];\n    month = calendar[j * 10 + 2];\n\n    if (month == 'J') {\n      if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n        if (day_of_month < 0x3c) {\n          day_of_week = 0;\n        }\n        else {\n          day_of_week = 1;\n        }\n      }\n      else {\n        day_of_week = 0;\n      }\n      day_of_week += i + day_of_month - 1;\n    }\n    else if (month == 'D') {\n      day_of_week = i + day_of_month;\n    }\n    else {\n      uint32_t century = leap_years >> 5;\n      if (((year & 3) == 0) && (year % 100 != 0)) {\n        century = 1;\n      }\n      uint32_t k = 0;\n      uint32_t l = i;\n      while (k < calendar[j * 10 + 3]) {\n        l += calendar[century * 0x30 + k++ * 4 + 1];\n      }\n      uint32_t day_of_week_offset = day_of_month - (l + 4U) % 7;\n      if (day_of_week_offset < 0) {\n        day_of_week_offset += 7;\n      }\n      for (day_of_week_offset = (calendar[j * 10 + 4] - 1) * 7 + day_of_week_offset; calendar[century * 0x30 + k * 4 - 4] <= day_of_week_offset; day_of_week_offset -= 7) {\n      }\n      day_of_week = l + day_of_week_offset;\n    }\n    day_of_month = calendar[j * 10 + 10] + day_of_week * DAT_000050e0 + calendar[j * 10 + 6];\n    calendar[j * 10 + 8] = day_of_month;\n    calendar[j * 10 + 9] = (int)day_of_month >> 0x1f;\n  }\n\n  uint32_t last_day = calendar[9];\n  uint32_t first_day_of_year = calendar[19];\n  uint32_t is_leap_year = (int)((last_day - first_day_of_year) - (uint32_t)(calendar[8] < calendar[0x12])) < 0 != (SBORROW4(last_day, first_day_of_year) != SBORROW4(last_day - first_day_of_year, (uint32_t)(calendar[8] < calendar[0x12])));\n\n  return is_leap_year;\n}",
            "called": [
                "FUN_000056b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f98",
            "calling": [
                "FUN_00005100",
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_00004f98"
        },
        "FUN_00004dee": {
            "renaming": {
                "FUN_00004dee": "copy_data_to_memory_00004dee",
                "param_1": "source_address",
                "param_2": "destination_address",
                "param_3": "size",
                "param_4": "result",
                "uVar1": "result",
                "set_param_to_19_000004f2": "N/A",
                "*(ushort *)(param_2 + 0xc)": "current_value",
                "*(ushort *)(param_2 + 0xe)": "short_value"
            },
            "code": "unsigned int copy_data_to_memory_00004dee(unsigned int source_address, int destination_address, unsigned int size)\n{\n    unsigned int result = 0;\n    unsigned short* destination_ptr = (unsigned short*)destination_address;\n    unsigned short* source_ptr = (unsigned short*)source_address;\n    unsigned int i;\n    for (i = 0; i < size; i += 2)\n    {\n        *destination_ptr++ = *source_ptr++;\n    }\n    return result;\n}",
            "called": [
                "FUN_00000e38",
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dee",
            "calling": [],
            "imported": false,
            "current_name": "copy_data_to_memory_00004dee"
        },
        "FUN_00000fec": {
            "renaming": {
                "FUN_00000fec": "initialize_bitmask_00000fec",
                "param_1": "bitmask",
                "param_2": "bitmask_size",
                "*param_1": "bitmask[0]",
                "param_1[1]": "bitmask[1]",
                "param_1[2]": "bitmask[2]"
            },
            "code": "void initialize_bitmask_00000fec(uint32_t *bitmask, uint32_t bitmask_size) {\n    if ((bitmask_size & (bitmask_size - 1)) != 0) {\n        process_input(3, PTR_s_FAILED_ASSERTION__00001030);\n    }\n    bitmask[0] = 0;\n    bitmask[1] = 0;\n    bitmask[2] = bitmask_size - 1;\n    return;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000fec",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "initialize_bitmask_00000fec"
        },
        "FUN_00000428": {
            "renaming": {
                "FUN_00000428": "get_value_or_default_00000428",
                "param_1": "value",
                "param_2": "new_value",
                "uVar1": "irq_enabled",
                "local_c": "current_value"
            },
            "code": "int get_value_or_default_00000428(int* value, int new_value) {\n  int irq_enabled = check_for_enabled_IRQ_interrupts_00000cd0();\n  int current_value = *(int*)PTR_Elf32_Rel_ARRAY_00000484;\n  if ((DAT_00000488 < (uint)(new_value + current_value)) || ((uint)(new_value + current_value) < DAT_0000048c)) {\n    *value = 12;\n    current_value = -1;\n  }\n  else {\n    *(int*)PTR_Elf32_Rel_ARRAY_00000484 = new_value + current_value;\n  }\n  enableIRQinterrupts_if_privileged_00000d0c(irq_enabled);\n  return current_value;\n}",
            "called": [
                "FUN_00000d0c",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000428",
            "calling": [
                "FUN_00004bd0"
            ],
            "imported": false,
            "current_name": "get_value_or_default_00000428"
        },
        "FUN_000039e8": {
            "renaming": {
                "FUN_000039e8": "get_class_for_character_000039e8",
                "param_1": "character",
                "puVar1": "class"
            },
            "code": "char* get_class_for_character_000039e8(char character) {\n    char* class = PTR_s_CLASS_UNKNOWN_00003d20;\n    switch(character) {\n        case '\\0':\n            class = DAT_00003cc0;\n            break;\n        case '@':\n            class = DAT_00003cc4;\n            break;\n        case 'B':\n            class = DAT_00003cc8;\n            break;\n        case 'C':\n            class = PTR_s_ACT_SERVO_00003ccc;\n            break;\n        case 'D':\n            class = PTR_s_ACT_MOTOR_00003cd0;\n            break;\n        case 'E':\n            class = PTR_s_ACT_SWITCH_00003cd4;\n            break;\n        case 'F':\n            class = PTR_s_ACT_DIMMER_00003cd8;\n            break;\n        case -0x80:\n            class = PTR_s_SENSE_ANY_00003cdc;\n            break;\n        case -0x7f:\n            class = PTR_s_SENSE_BTN_00003ce0;\n            break;\n        case -0x7e:\n            class = PTR_s_SENSE_TEMP_00003ce4;\n            break;\n        case -0x7d:\n            class = PTR_s_SENSE_HUM_00003ce8;\n            break;\n        case -0x7c:\n            class = PTR_s_SENSE_LIGHT_00003cec;\n            break;\n        case -0x7b:\n            class = PTR_s_SENSE_ACCEL_00003cf0;\n            break;\n        case -0x7a:\n            class = PTR_s_SENSE_MAG_00003cf4;\n            break;\n        case -0x79:\n            class = PTR_s_SENSE_GYRO_00003cf8;\n            break;\n        case -0x78:\n            class = PTR_s_SENSE_COLOR_00003cfc;\n            break;\n        case -0x77:\n            class = PTR_s_SENSE_PRESS_00003d00;\n            break;\n        case -0x76:\n            class = PTR_s_SENSE_ANALOG_00003d04;\n            break;\n        case -0x75:\n            class = PTR_s_SENSE_UV_00003d08;\n            break;\n        case -0x74:\n            class = PTR_s_SENSE_OBJTEMP_00003d0c;\n            break;\n        case -0x73:\n            class = PTR_s_SENSE_PULSE_COUNT_00003d10;\n            break;\n        case -0x72:\n            class = PTR_s_SENSE_DISTANCE_00003d14;\n            break;\n        case -0x71:\n            class = PTR_s_SENSE_CO2_00003d18;\n            break;\n        default:\n            if (character == -1) {\n                return PTR_s_CLASS_ANY_00003d1c;\n            }\n    }\n    return class;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000039e8",
            "calling": [
                "FUN_00002f74",
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "get_class_for_character_000039e8"
        },
        "FUN_00000e38": {
            "renaming": {
                "FUN_00000e38": "copy_data_to_memory_00000e38",
                "param_1": "destination_address",
                "param_2": "source_address"
            },
            "code": "uint32_t copy_data_to_memory_00000e38(uint32_t destination_address, uint32_t source_address, uint32_t size)\n{\n    copy_data_to_memory_00000e38_000015d0(0, destination_address, source_address);\n    return source_address;\n}",
            "called": [
                "FUN_000015d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e38",
            "calling": [
                "FUN_00004dee"
            ],
            "imported": false,
            "current_name": "copy_data_to_memory_00000e38"
        },
        "FUN_00002294": {
            "renaming": {
                "FUN_00002294": "is_difference_equal_to_offset_00002294",
                "param_1": "input_param",
                "uVar1": "result",
                "iVar2": "offset",
                "bVar3": "is_difference_equal_to_offset"
            },
            "code": "int is_difference_equal_to_offset_00002294(int input_param)\n{\n  int offset = *(int *)(input_param + 4);\n  bool is_difference_equal_to_offset_00002294 = *(int *)(input_param + 0xc) - *(int *)(input_param + 8) == offset;\n  if (is_difference_equal_to_offset_00002294) {\n    offset = 1;\n  }\n  return (int)offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002294",
            "calling": [
                "FUN_00002364"
            ],
            "imported": false,
            "current_name": "is_difference_equal_to_offset_00002294"
        },
        "FUN_00003e9e": {
            "renaming": {
                "FUN_00003e9e": "count_digits_00003e9e",
                "param_1": "number",
                "param_2": "base",
                "param_3": "increment",
                "uVar1": "digit_count",
                "calculate_number_of_digits_00003ec4": "calculate_number_of_digits"
            },
            "code": "int count_digits_00003e9e(int number, int base, int increment) {\n  int digit_count = calculate_number_of_digits(number, base, increment);\n  return digit_count;\n}",
            "called": [
                "FUN_00003ec4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e9e",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "count_digits_00003e9e"
        },
        "FUN_00003378": {
            "renaming": {
                "FUN_00003378": "process_data_00003378",
                "param_1": "data_array",
                "PTR_s__04i__02i__02i__02i__02i__02i_000033bc": "PTR_s",
                "param_1[5]": "offset",
                "param_1[4]": "size",
                "param_1[3]": "arg1",
                "param_1[2]": "arg2",
                "param_1[1]": "arg3",
                "*param_1": "arg4"
            },
            "code": "int process_data_00003378(unsigned int *data_array)\\n\\\n{\\n\\\n    unsigned int offset = 0x76c;\\n\\\n    unsigned int size = data_array[4] + 1;\\n\\\n    unsigned int arg1 = data_array[3];\\n\\\n    unsigned int arg2 = data_array[2];\\n\\\n    unsigned int arg3 = data_array[1];\\n\\\n    unsigned int arg4 = data_array[0];\\n\\\n    process_data_00003378_helper(PTR_s__04i__02i__02i__02i__02i__02i_000033bc__04i__02i__02i__02i__02i__02i_000033bc, offset, size, arg1, arg2, arg3, arg4);\\n\\\n    return 0;\\n\\\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003378",
            "calling": [
                "FUN_00003444",
                "FUN_000033c0"
            ],
            "imported": false,
            "current_name": "process_data_00003378",
            "code_backup": "\nundefined4 FUN_00003378(undefined4 *param_1)\n\n{\n  FUNC_00004c84(PTR_s__04i__02i__02i__02i__02i__02i_000033bc,param_1[5] + 0x76c,param_1[4] + 1,\n               param_1[3],param_1[2],param_1[1],*param_1);\n  return 0;\n}\n\n"
        },
        "FUN_00006768": {
            "renaming": {
                "FUN_00006768": "process_data_00006768",
                "param_1": "memory_block",
                "param_2": "data_block",
                "param_3": "param_3",
                "param_4": "param_4",
                "uVar1": "data_block_value1",
                "iVar2": "data_block_value2",
                "uVar3": "data_block_value3",
                "uVar4": "data_block_value4",
                "uVar5": "data_block_value5",
                "PTR_DAT_00006868": "data_block_value5",
                "PTR_DAT_0000686c": "data_block_value6",
                "PTR_DAT_00006870": "data_block_value7",
                "PTR_DAT_00006874": "data_block_value8",
                "PTR_LAB_00006754_1_00006878": "data_block_value9",
                "initialize_memory_block_000042a4": "initialize_memory_block",
                "insert_node_at_end_00004b34": "insert_node_at_end",
                "process_data_00004158": "process_data_00004158",
                "allocate_memory_00005700": "allocate_memory",
                "process_data_000043a0": "process_data_000043a0",
                "process_data_0000404c": "process_data_0000404c"
            },
            "code": "undefined4 process_data_00006768(undefined4 *memory_block, undefined4 *data_block, undefined4 param_3, undefined4 param_4)\n{\n    ushort data_block_value1;\n    uint data_block_value2;\n    uint data_block_value3;\n    uint data_block_value4;\n    \n    if ((memory_block != NULL) && (memory_block[6] == 0)) {\n        initialize_memory_block();\n    }\n    if (data_block == (undefined4 *)PTR_DAT_00006868) {\n        data_block = (undefined4 *)memory_block[1];\n    }\n    else if (data_block == (undefined4 *)PTR_DAT_0000686c) {\n        data_block = (undefined4 *)memory_block[2];\n    }\n    else if (data_block == (undefined4 *)PTR_DAT_00006870) {\n        data_block = (undefined4 *)memory_block[3];\n    }\n    data_block_value1 = *(ushort *)(data_block + 3);\n    data_block[1] = 0;\n    data_block_value2 = (uint)*(ushort *)(data_block + 3);\n    if ((int)(data_block_value2 << 26) < 0) {\n        return 0xffffffff;\n    }\n    if ((int)(data_block_value2 << 29) < 0) {\n        if ((undefined4 *)data_block[0xd] != NULL) {\n            if ((undefined4 *)data_block[0xd] != data_block + 0x11) {\n                insert_node_at_end(memory_block);\n            }\n            data_block[1] = data_block[0x10];\n            data_block[0xd] = 0;\n            if (data_block[0x10] != 0) {\n                *data_block = data_block[0xf];\n                return 0;\n            }\n        }\n    }\n    else {\n        if ((int)(data_block_value2 << 27) >= 0) {\n            if ((int)(data_block_value2 << 28) < 0) {\n                if (process_data_00006768_00004158(memory_block, data_block, data_block_value2 << 0x1c, data_block_value2, param_4) != 0) {\n                    return 0xffffffff;\n                }\n                data_block[2] = 0;\n                *(ushort *)(data_block + 3) = *(ushort *)(data_block + 3) & 0xfff7;\n                data_block[6] = 0;\n            }\n            *(ushort *)(data_block + 3) = *(ushort *)(data_block + 3) | 4;\n        }\n        else {\n            *memory_block = 9;\n            data_block_value1 = data_block_value1 | 0x40;\n            goto LAB_000067b8;\n        }\n        \n    }\n    if (data_block[4] == 0) {\n        allocate_memory(memory_block, data_block);\n    }\n    data_block_value1 = *(ushort *)(data_block + 3);\n    data_block_value3 = *(ushort *)(data_block + 3);\n    if ((data_block_value1 & 3) != 0) {\n        *(ushort *)(data_block + 3) = 1;\n        process_data_00006768_000043a0(*(undefined4 *)PTR_DAT_00006874, PTR_LAB_00006754_1_00006878);\n        *(ushort *)(data_block + 3) = data_block_value3;\n        if ((data_block_value1 & 9) == 9) {\n            process_data_00006768_0000404c(memory_block, data_block);\n        }\n    }\n    data_block_value4 = data_block[4];\n    *data_block = data_block_value4;\n    if ((*(code *)data_block[9])(memory_block, data_block[8], data_block_value4, data_block[5]) > 0) {\n        return 0;\n    }\n    data_block_value1 = *(ushort *)(data_block + 3);\n    if ((*(code *)data_block[9])(memory_block, data_block[8], data_block_value4, data_block[5]) != 0) {\n        data_block[1] = 0;\n        return 0xffffffff;\n    }\n    else {\n        data_block_value1 = data_block_value1 | 0x20;\n    }\nLAB_000067b8:\n    data_block[1] = data_block_value1;\n    *(ushort *)(data_block + 3) = data_block_value1;\n    return 0xffffffff;\n}\n",
            "called": [
                "FUN_0000404c",
                "FUN_00005700",
                "FUN_000043a0",
                "FUN_00004158",
                "FUN_00004b34",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006768",
            "calling": [
                "FUN_00005e10"
            ],
            "imported": false,
            "current_name": "process_data_00006768"
        },
        "FUN_00000db0": {
            "renaming": {
                "FUN_00000db0": "initialize_data_and_calculated_value_to_zero_00000db0",
                "set_data_00000dcc": "initialize_data",
                "set_calculated_value_to_zero_00000d9c": "initialize_calculated_value"
            },
            "code": "void initialize_data_and_calculated_value_to_zero_00000db0(void)\n{\n  initialize_data();\n  initialize_calculated_value();\n  return;\n}",
            "called": [
                "FUN_00000dcc",
                "FUN_00000d9c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000db0",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "initialize_data_and_calculated_value_to_zero_00000db0"
        },
        "FUN_00002600": {
            "renaming": {
                "FUN_00002600": "process_data_00002600",
                "param_1": "input_data",
                "uVar1": "processed_data",
                "FUNC_000047e4": "calculate_processed_data",
                "update_data_in_array_0000285c": "update_data_in_array"
            },
            "code": "int process_data_00002600(int input_data)\n{\n  int processed_data = calculate_processed_data(input_data);\n  update_data_in_array(processed_data);\n  return 0;\n}",
            "called": [
                "FUN_0000285c",
                "FUN_000047e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002600",
            "calling": [
                "FUN_00003478"
            ],
            "imported": false,
            "current_name": "process_data_00002600"
        },
        "FUN_00003810": {
            "renaming": {
                "FUN_00003810": "get_ptr_from_switch_case_00003810",
                "param_1": "param",
                "puVar1": "ptr"
            },
            "code": "undefined * get_ptr_from_switch_case_00003810(int param) {\n  undefined *ptr;\n  ptr = PTR_LAB_00003914;\n  switch(param) {\n    case 2:\n      ptr = PTR_LAB_000038cc;\n      break;\n    case 3:\n      ptr = PTR_LAB_000038d0;\n      break;\n    case 4:\n      ptr = PTR_LAB_000038d4;\n      break;\n    case 5:\n      ptr = PTR_LAB_000038d8;\n      break;\n    case 6:\n      ptr = PTR_LAB_000038dc;\n      break;\n    case 7:\n      ptr = PTR_LAB_000038e0;\n      break;\n    case 8:\n      ptr = PTR_LAB_000038e4;\n      break;\n    case 9:\n      ptr = PTR_LAB_000038e8;\n      break;\n    case 10:\n      ptr = PTR_LAB_000038ec;\n      break;\n    case 11:\n      ptr = PTR_LAB_000038f0;\n      break;\n    case 12:\n      ptr = PTR_LAB_000038f4;\n      break;\n    case 13:\n      ptr = PTR_LAB_000038f8;\n      break;\n    case 14:\n      ptr = PTR_LAB_000038fc;\n      break;\n    case 15:\n      ptr = PTR_LAB_00003900;\n      break;\n    case 16:\n      ptr = PTR_LAB_00003904;\n      break;\n    case 17:\n      ptr = PTR_LAB_0000390c;\n      break;\n    case 19:\n      ptr = PTR_LAB_00003910;\n      break;\n    case 21:\n      ptr = PTR_LAB_00003908;\n  }\n  return ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003810",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "get_ptr_from_switch_case_00003810"
        },
        "FUN_00000ed8": {
            "renaming": {
                "FUN_00000ed8": "execute_function_00000ed8",
                "in_lr": "saved_register",
                "FUNC_00004c84": "call_func"
            },
            "code": "void execute_function_00000ed8(void)\n{\n  undefined4 saved_register;\n  call_func(PTR_DATA_00000ef4, saved_register);\n  return;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ed8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "execute_function_00000ed8",
            "code_backup": "\nvoid FUN_00000ed8(void)\n\n{\n  undefined4 in_lr;\n  \n  FUNC_00004c84(PTR_DAT_00000ef4,in_lr);\n  return;\n}\n\n"
        },
        "FUN_000031e0": {
            "renaming": {
                "FUN_000031e0": "playAlarmSound_000031e0",
                "process_input": "callAlarmFunction",
                "PTR_s_The_alarm_rang_000031f8": "alarmMessage"
            },
            "code": "void playAlarmSound_000031e0() \n{\n  callAlarmFunction(PTR_s_The_alarm_rang_000031f8);\n  return;\n}",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031e0",
            "calling": [],
            "imported": false,
            "current_name": "playAlarmSound_000031e0",
            "code_backup": "\nvoid FUN_000031e0(void)\n\n{\n  process_input(PTR_s_The_alarm_rang_000031f8);\n  return;\n}\n\n"
        },
        "FUN_000020f4": {
            "renaming": {
                "FUN_000020f4": "decode_and_print_data_000020f4",
                "DAT_00002104": "DAT_num_bytes_to_decode",
                "PTR_data_to_decode": "data_to_decode",
                "decode_data_00002028": "decode_data"
            },
            "code": "void decode_and_print_data_000020f4(void)\n{\n  char* PTR_data_to_decode = PTR_PTR_data_to_decode;\n  int num_bytes_to_decode = DAT_00002104;\n  decode_data(PTR_data_to_decode, num_bytes_to_decode);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020f4",
            "calling": [],
            "imported": false,
            "current_name": "decode_and_print_data_000020f4"
        },
        "FUN_0000687c": {
            "renaming": {
                "FUN_0000687c": "decode_0000687c",
                "param_1": "length",
                "param_2": "input",
                "pbVar1": "output",
                "uVar2": "end",
                "iVar3": "i",
                "uVar4": "current_char",
                "uVar5": "start",
                "uVar6": "next_char",
                "bVar7": "is_hat"
            },
            "code": "byte* decode_0000687c(int length, byte* input)\n{\n  byte* output;\n  uint current_char;\n  int i = length - 1;\n  bool is_hat = (uint)*input == 0x5e;\n  if (is_hat) {\n    current_char = (uint)input[1];\n    input += 2;\n  }\n  else {\n    current_char = (uint)*input;\n    input++;\n  }\n  do {\n    i++;\n    *(bool*)i = is_hat;\n  } while (i != length + 0xff);\n  if (current_char == 0) {\n    output = input - 1;\n  }\n  else {\n    do {\n      uint start = current_char;\n      *(bool*)(length + start) = !is_hat;\n      input++;\n      while (true) {\n        current_char = (uint)*--input;\n        if (current_char != 0x2d) break;\n        uint end = (uint)*++input;\n        if (end == 0x5d || end < start) goto continue_outer_loop;\n        do {\n          start++;\n          *(bool*)(length + start) = !is_hat;\n        } while (start < end);\n        int difference = ~current_char + end;\n        if (end <= current_char) {\n          difference = 0;\n        }\n        current_char = current_char + 1 + difference;\n        input++;\n      }\n      output = input - 1;\n    } while (current_char != 0x5d && current_char != 0);\n  }\n  return output;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000687c",
            "calling": [
                "FUN_0000656c",
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "decode_0000687c"
        },
        "FUN_00005edc": {
            "renaming": {
                "FUN_00005edc": "parse_number_00005edc",
                "param_1": "output",
                "param_2": "input",
                "param_3": "end",
                "param_4": "base",
                "uVar1": "num",
                "uVar2": "digit",
                "bVar3": "sign",
                "iVar4": "result",
                "uVar5": "temp",
                "uVar6": "max_num",
                "pbVar7": "ptr",
                "pbVar8": "next_ptr"
            },
            "code": "uint parse_number_00005edc(undefined4 *output, byte *input, byte **end, uint base) {\n  uint num = 0;\n  int sign = 1;\n  uint max_num = 0xffffffff / base;\n  uint digit;\n  byte *ptr = input;\n  while (isspace(*ptr)) {\n    ptr++;\n  }\n  if (*ptr == '-') {\n    sign = -1;\n    ptr++;\n  } else if (*ptr == '+') {\n    ptr++;\n  }\n  if (base == 0) {\n    if (*ptr != '0') {\n      base = 10;\n    } else if (toupper(*(ptr + 1)) == 'X') {\n      base = 16;\n      ptr += 2;\n    } else {\n      base = 8;\n    }\n  } else if (base == 16 && *ptr == '0' && toupper(*(ptr + 1)) == 'X') {\n    ptr += 2;\n  }\n  while (isxdigit(*ptr)) {\n    digit = isdigit(*ptr) ? *ptr - '0' : toupper(*ptr) - 'A' + 10;\n    if (digit >= base) {\n      break;\n    }\n    if (num > max_num || (num == max_num && digit > 0xffffffff % base)) {\n      *output = sign == -1 ? 0x22 : 0;\n      return 0xffffffff;\n    }\n    num = num * base + digit;\n    ptr++;\n  }\n  if (end != NULL) {\n    *end = ptr;\n  }\n  *output = sign == -1 ? -num : num;\n  return num;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005edc",
            "calling": [
                "FUN_00005fd8"
            ],
            "imported": false,
            "current_name": "parse_number_00005edc"
        },
        "FUN_00001eea": {
            "renaming": {
                "FUN_00001eea": "write_to_memory_and_update_flags_00001eea",
                "param_1": "address",
                "param_2": "data",
                "uVar1": "last_six_bits",
                "iVar2": "flagged_value",
                "iVar3": "bits_extracted"
            },
            "code": "int write_to_memory_and_update_flags_00001eea(unsigned short address, byte data) {\n  uint last_six_bits = extract_last_six_bits(address);\n  int flagged_value = get_flagged_value(address);\n  if ((char)data < 0) {\n    *(uint *)(flagged_value + 0x14) |= 1 << (last_six_bits & 0xff);\n  }\n  else {\n    *(uint *)(flagged_value + 0x14) &= ~(1 << (last_six_bits & 0xff));\n  }\n  int bits_extracted = extract_bits(address);\n  *(uint *)(bits_extracted + last_six_bits * 4) = data & 0x23 | 0x100;\n  return 0;\n}",
            "called": [
                "FUN_00001f80",
                "FUN_00001d80",
                "FUN_00001dc0",
                "FUN_00001d5e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001eea",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "write_to_memory_and_update_flags_00001eea"
        },
        "FUN_000023a4": {
            "renaming": {
                "FUN_000023a4": "process_input_with_interrupts_000023a4",
                "auStack_88": "input_buffer",
                "process_input": "initialize_memory",
                "process_input_loop_00002e6c": "process_input_loop",
                "uVar1": "result"
            },
            "code": "undefined4 process_input_with_interrupts_000023a4(void)\n{\n  undefined4 result;\n  undefined input_buffer[128];\n  check_software_interrupt_status(0);\n  initialize_memory(uRam000023c4);\n  result = process_input_loop(0, input_buffer, 0x80);\n  software_interrupt(0x3f);\n  return result;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_000023d0",
                "FUN_00002e6c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023a4",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "process_input_with_interrupts_000023a4"
        },
        "FUN_0000240c": {
            "renaming": {
                "FUN_0000240c": "get_next_pointer_0000240c",
                "param_1": "current_pointer",
                "puVar1": "next_pointer"
            },
            "code": "undefined4 *get_next_pointer_0000240c(undefined4 *current_pointer)\n{\n  undefined4 *next_pointer;\n  next_pointer = (undefined4 *)*current_pointer;\n  if (next_pointer != (undefined4 *)0x0) {\n    *current_pointer = *next_pointer;\n  }\n  return next_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000240c",
            "calling": [
                "FUN_000024bc"
            ],
            "imported": false,
            "current_name": "get_next_pointer_0000240c"
        },
        "FUN_00004280": {
            "renaming": {
                "FUN_00004280": "do_nothing_and_return_00004280",
                "PTR_DAT_00004288": "PTR_DATA"
            },
            "code": "void do_nothing_and_return_00004280(void)\n{\n  do_nothing(PTR_DAT_00004288);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004280",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_and_return_00004280"
        },
        "FUN_00001448": {
            "renaming": {
                "FUN_00001448": "write_to_memory_if_not_negative_00001448",
                "param_1": "index",
                "PTR_DAT_000014c0": "data_pointer",
                "first_short": "first_value",
                "second_short": "second_value",
                "first_undefined2": "first_address",
                "first_undefined4": "first_data",
                "second_undefined2": "second_address",
                "second_undefined4": "second_data"
            },
            "code": "void write_to_memory_if_not_negative_00001448(int index) {\n    short first_short = *(short *)(PTR_DAT_000014c0 + index * 0x20 + 8);\n    short second_short = *(short *)(PTR_DAT_000014c0 + index * 0x20 + 10);\n    if (first_short != -1) {\n        undefined2 first_undefined2 = *(undefined2 *)(PTR_DAT_000014c0 + index * 0x20 + 8);\n        undefined4 first_undefined4 = *(undefined4 *)(PTR_DAT_000014c0 + index * 0x20 + 0xc);\n        write_to_memory_00001f80(first_undefined2, first_undefined4);\n    }\n    if (second_short != -1) {\n        undefined2 second_undefined2 = *(undefined2 *)(PTR_DAT_000014c0 + index * 0x20 + 10);\n        undefined4 second_undefined4 = *(undefined4 *)(PTR_DAT_000014c0 + index * 0x20 + 0x10);\n        write_to_memory_00001f80(second_undefined2, second_undefined4);\n    }\n}",
            "called": [
                "FUN_00001f80"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001448",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "write_to_memory_if_not_negative_00001448"
        },
        "FUN_00001688": {
            "renaming": {
                "FUN_00001688": "call_check_function_00001688",
                "check_and_call_function_00001628": "check_and_call_function"
            },
            "code": "void call_check_function_00001688(void)\n{\n  check_and_call_function(0);\n  return;\n}",
            "called": [
                "FUN_00001628"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001688",
            "calling": [],
            "imported": false,
            "current_name": "call_check_function_00001688"
        },
        "FUN_00004042": {
            "renaming": {
                "FUN_00004042": "parse_string_to_uint_wrapper_00004042",
                "param_1": "str",
                "parse_string_to_uint_00004f84": "parse_string_to_uint",
                "0": "start",
                "10": "end"
            },
            "code": "void parse_string_to_uint_wrapper_00004042(char* str, int start, int end) {\n  parse_string_to_uint(str, start, end);\n  return;\n}",
            "called": [
                "FUN_00004f84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004042",
            "calling": [
                "FUN_0000305c",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "parse_string_to_uint_wrapper_00004042"
        },
        "FUN_00000cf0": {
            "renaming": {
                "FUN_00000cf0": "get_IRQ_interrupt_status_00000cf0",
                "bVar1": "is_privileged_mode",
                "uVar2": "status",
                "enableIRQinterrupts": "enable_IRQ_interrupts",
                "isCurrentModePrivileged": "is_current_mode_privileged",
                "isIRQinterruptsEnabled": "is_IRQ_interrupts_enabled"
            },
            "code": "undefined4 get_IRQ_interrupt_status_00000cf0(void)\n{\n  bool is_privileged_mode;\n  undefined4 status = 0;\n  enable_IRQ_interrupts();\n  is_privileged_mode = (bool)is_current_mode_privileged();\n  if (is_privileged_mode) {\n    status = is_IRQ_interrupts_enabled();\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cf0",
            "calling": [
                "FUN_00000930"
            ],
            "imported": false,
            "current_name": "get_IRQ_interrupt_status_00000cf0"
        },
        "FUN_00000f8c": {
            "renaming": {
                "FUN_00000f8c": "allocate_and_initialize_irq_handler_00000f8c",
                "uVar1": "irq_interrupts_enabled",
                "puVar2": "irq_handler_data_ptr",
                "uVar3": "irq_handler_data_size",
                "iStack_24": "irq_handler_data_stack_var",
                "piStack_20": "irq_handler_data_stack_ptr",
                "uStack_1c": "irq_handler_data_first_var",
                "local_18": "irq_handler_data_second_var",
                "local_14": "irq_handler_data_third_var",
                "*puRam00000fd4": "irq_handler_data_ptr_1",
                "uRam00000fd8": "irq_handler_data_size_1",
                "allocate_resource_000010d4": "allocate_resource",
                "*puRam00000fe0": "irq_handler_data_ptr_3",
                "uRam00000fe4": "irq_handler_data_size_2",
                "uRam00000fe8": "irq_handler_data_ptr_4",
                "handle_IRQ_interrupt_00000930": "handle_IRQ_interrupt",
                "process_input_00000f04": "process_input",
                "PTR_s_FAILED_ASSERTION__00001030": "PTR_s_FAILED_ASSERTION__00001030"
            },
            "code": "void allocate_and_initialize_irq_handler_00000f8c(void)\n{\n  uint irq_interrupts_enabled;\n  undefined4 *irq_handler_data_ptr;\n  uint irq_handler_data_size;\n  int irq_handler_data_stack_var;\n  int *irq_handler_data_stack_ptr;\n  undefined4 irq_handler_data_first_var;\n  undefined4 irq_handler_data_second_var;\n  undefined4 irq_handler_data_third_var;\n\n  check_for_enabled_IRQ_interrupts();\n\n  irq_handler_data_first_var = *irq_handler_data_ptr_1;\n  irq_handler_data_second_var = 0;\n  irq_handler_data_third_var = irq_handler_data_size_1;\n  allocate_resource(irq_handler_data_ptr_2, 0x100, 0xf, 0xc);\n\n  irq_handler_data_first_var = *irq_handler_data_ptr_3;\n  irq_handler_data_second_var = 0;\n  irq_handler_data_third_var = irq_handler_data_size_2;\n  irq_interrupts_enabled = 0xc;\n  allocate_resource(irq_handler_data_ptr_4, 0x600, 7);\n\n  irq_handler_data_stack_var = 0xfd3;\n  irq_interrupts_enabled = handle_IRQ_interrupt();\n  irq_interrupts_enabled = irq_interrupts_enabled >> 0x1e;\n  irq_handler_data_ptr = (undefined4 *)(irq_interrupts_enabled * 0x100);\n  irq_handler_data_stack_var = (irq_interrupts_enabled >> 0x1d) << 0x11;\n  irq_handler_data_stack_ptr = &irq_handler_data_stack_var;\n\n  if ((irq_interrupts_enabled & irq_interrupts_enabled - 1) != 0)\n  {\n    process_input(3, PTR_s_FAILED_ASSERTION__00001030);\n  }\n\n  *irq_handler_data_ptr = 0;\n  irq_handler_data_ptr[1] = 0;\n  irq_handler_data_ptr[2] = irq_interrupts_enabled - 1;\n  return;\n}",
            "called": [
                "FUN_000010d4",
                "FUN_00000930",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f8c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_irq_handler_00000f8c"
        },
        "FUN_00002894": {
            "renaming": {
                "FUN_00002894": "set_and_update_data_00002894",
                "param_1": "data",
                "param_2": "flag",
                "param_3": "value",
                "iVar1": "data_pointer",
                "DAT_000028e8": "DATA_START_ADDRESS",
                "PTR_DAT_000028ec": "DATA_PTR_OFFSET",
                "set_byte_value_00002744": "set_byte_value",
                "set_bit_in_array_00002714": "set_bit_in_array",
                "0x1c": "DATA_FLAG_OFFSET",
                "0x8": "DATA_VALUE_OFFSET"
            },
            "code": "void set_and_update_data_00002894(int data, uint32_t flag, uint32_t value)\n{\n  int data_pointer = DAT_000028e8;\n  *(uint *)(data_pointer + DATA_FLAG_OFFSET) = *(uint *)(data_pointer + DATA_FLAG_OFFSET) & ~flag;\n  *(int *)(data_pointer + DATA_VALUE_OFFSET) = data - 1;\n  *(uint32_t *)PTR_DAT_000028ec = value;\n  *(uint *)(data_pointer + DATA_FLAG_OFFSET) = *(uint *)(data_pointer + DATA_FLAG_OFFSET) | flag;\n  set_byte_value(0x2e, 10);\n  set_bit_in_array(0x2e);\n  return;\n}",
            "called": [
                "FUN_00002744",
                "FUN_00002714"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002894",
            "calling": [
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "set_and_update_data_00002894"
        },
        "FUN_00004158": {
            "renaming": {
                "FUN_00004158": "process_data_00004158",
                "param_1": "data_ptr",
                "param_2": "data",
                "uVar1": "result",
                "PTR_DAT_000041c4": "data_ptr_1",
                "PTR_DAT_000041c8": "data_ptr_2",
                "PTR_DAT_000041cc": "data_ptr_3"
            },
            "code": "int process_data_00004158(int data_ptr, char* data) {\n  int result = 0;\n  if (*(int *)(data + 0x10) != 0) {\n    if ((data_ptr != 0) && (*(int *)(data_ptr + 0x18) == 0)) {\n      call_function();\n    }\n    if (data == PTR_DAT_000041c4) {\n      data = *(char **)(data_ptr + 4);\n    }\n    else if (data == PTR_DAT_000041c8) {\n      data = *(char **)(data_ptr + 8);\n    }\n    else if (data == PTR_DAT_000041cc) {\n      data = *(char **)(data_ptr + 0xc);\n    }\n    if (*(short *)(data + 0xc) != 0) {\n      if ((*(int *)(data + 100) << 0x1f) >= 0 && (*(short *)(data + 0xc) << 0x10 >= 0)) {\n        do_nothing(*(int *)(data + 0x58));\n      }\n      result = process_data_00004158_0000404c(data_ptr, data);\n      if (*(int *)(data + 100) << 0x1f < 0 || (*(short *)(data + 0xc) << 0x10 < 0)) {\n        return result;\n      }\n      do_nothing(*(int *)(data + 0x58));\n      return result;\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_0000404c",
                "FUN_000045e8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004158",
            "calling": [
                "FUN_00005404",
                "FUN_00006768",
                "FUN_000041d0"
            ],
            "imported": false,
            "current_name": "process_data_00004158",
            "code_backup": "\nundefined4 FUN_00004158(int param_1,undefined *param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (*(int *)(param_2 + 0x10) != 0) {\n    if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n      FUNC_000042a4();\n    }\n    if (param_2 == PTR_DAT_000041c4) {\n      param_2 = *(undefined **)(param_1 + 4);\n    }\n    else if (param_2 == PTR_DAT_000041c8) {\n      param_2 = *(undefined **)(param_1 + 8);\n    }\n    else if (param_2 == PTR_DAT_000041cc) {\n      param_2 = *(undefined **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 0xc) != 0) {\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) && (-1 < (int)*(short *)(param_2 + 0xc) << 0x16)) {\n        do_nothing_000045e8(*(undefined4 *)(param_2 + 0x58));\n      }\n      uVar1 = process_data_0000404c(param_1,param_2);\n      if (*(int *)(param_2 + 100) << 0x1f < 0) {\n        return uVar1;\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x16) < 0) {\n        return uVar1;\n      }\n      do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n"
        },
        "FUN_00002654": {
            "renaming": {
                "FUN_00002654": "executeFunctionAndUpdateData_00002654",
                "param_1": "data",
                "param_2": "executeFunctionIfNotNull",
                "param_3": "param",
                "uVar1": "result"
            },
            "code": "int executeFunctionAndUpdateData_00002654(int data, int* executeFunctionIfNotNull, int param) {\n  int result = FUNC_000047e4(data);\n  *(int*)PTR_DAT_00002688 = executeFunctionIfNotNull;\n  set_and_update_data_00002894(result, PTR_executeFunctionIfNotNull_000026f0_1_0000268c, param);\n  return 0;\n}",
            "called": [
                "FUN_00002894",
                "FUN_000047e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002654",
            "calling": [
                "FUN_000033f4"
            ],
            "imported": false,
            "current_name": "executeFunctionAndUpdateData_00002654"
        },
        "FUN_00002538": {
            "renaming": {
                "FUN_00002538": "write_data_00002538",
                "param_1": "data",
                "param_2": "value",
                "DAT_00002584": "data_ptr_1",
                "DAT_00002588": "data_ptr_2"
            },
            "code": "void write_data_00002538(byte data, uint value) {\n  if (data < 0) {\n    *(char *)((data & 0xf) + DAT_00002584 + 0x14) = (char)((value & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)data + DAT_00002588 + 0x300) = (char)((value & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002538",
            "calling": [
                "FUN_0000258c"
            ],
            "imported": false,
            "current_name": "write_data_00002538"
        },
        "FUN_00004c84": {
            "renaming": {
                "FUN_00004c84": "process_data_00004c84",
                "param_1": "data",
                "param_2": "size",
                "param_3": "index",
                "param_4": "flag",
                "iVar1": "ptr",
                "uVar2": "data_value",
                "uStack_c": "flag_ptr",
                "uStack_8": "size_ptr",
                "uStack_4": "data_value_ptr"
            },
            "code": "void process_data_00004c84(int* data, int size, int index, int flag)\n{\n  int* ptr = *PTR_00004cb0;\n  int data_value = data[index];\n  if ((ptr != NULL) && (*(int *)(ptr + 0x18) == 0)) {\n    initialize(ptr);\n  }\n  manipulate_data(ptr, *(int *)(ptr + 8), data_value, &flag, size, &data_value);\n  return;\n}",
            "called": [
                "FUN_000057f8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004c84",
            "calling": [
                "FUN_00002b10",
                "FUN_00002a88",
                "FUN_00000f04",
                "FUN_00002ecc",
                "FUN_00002fe0",
                "FUN_0000316c",
                "FUN_00003694",
                "FUN_00003378",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00003524",
                "FUN_0000211c",
                "FUN_00000ed8"
            ],
            "imported": false,
            "current_name": "process_data_00004c84",
            "code_backup": "\nvoid FUN_00004c84(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  iVar1 = *DAT_00004cb0;\n  uVar2 = param_1;\n  uStack_c = param_2;\n  uStack_8 = param_3;\n  uStack_4 = param_4;\n  if ((iVar1 != 0) && (*(int *)(iVar1 + 0x18) == 0)) {\n    FUNC_000042a4(iVar1);\n  }\n  FUNC_000057f8(iVar1,*(undefined4 *)(iVar1 + 8),param_1,&uStack_c,uVar2,&uStack_c);\n  return;\n}\n\n"
        },
        "FUN_0000305c": {
            "renaming": {
                "FUN_0000305c": "process_device_data_0000305c",
                "param_1": "num_params",
                "param_2": "params",
                "uVar1": "param_value",
                "auStack_20": "params_array",
                "local_18": "num_params_to_use",
                "local_14": "device_index",
                "local_10": "uint_param",
                "local_c": "i"
            },
            "code": "void process_device_data_0000305c(int num_params, undefined4 *params)\n{\n  undefined2 param_value;\n  undefined2 params_array[4];\n  uint num_params_to_use;\n  int device_index;\n  undefined4 uint_param;\n  int nth_element_index;\n  int i;\n  uint result;\n  \n  if (num_params < 4) {\n    process_data(PTR_s_usage___s__s__device_id___value_0_00003154, *params, params[1]);\n  }\n  else {\n    uint_param = parse_string_to_uint_wrapper_00004042(params[2]);\n    nth_element_index = find_nth_element_00003d24(uint_param);\n    if (nth_element_index == 0) {\n      process_data(PTR_s_error__undefined_device_given_00003158);\n    }\n    else {\n      fill_array_with_value_00004622(params_array, 0, 8);\n      if (num_params > 5) {\n        num_params_to_use = 6;\n      }\n      else {\n        num_params_to_use = num_params;\n      }\n      for (i = 0; i < (int)(num_params_to_use - 3); i++) {\n        param_value = parse_string_to_uint_wrapper_00004042(params[i + 3]);\n        params_array[i] = param_value;\n      }\n      process_data(PTR_s_Writing_to_device___i____s_0000315c, uint_param, *(undefined4 *)(nth_element_index + 8));\n      display_data_object_00003694(params_array, num_params_to_use & 0xff);\n      result = perform_operation_00003d94(nth_element_index, params_array);\n      if ((int)result < 1) {\n        if (result == -0x86) {\n          process_data(PTR_s_error__device___i_is_not_writabl_00003160, uint_param);\n        }\n        else {\n          process_data(PTR_s_error__failure_to_write_to_devic_00003164, uint_param);\n        }\n      }\n      else {\n        process_data(PTR_s_data_successfully_written_to_dev_00003168, uint_param);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00003d94",
                "FUN_00003d24",
                "FUN_00003694",
                "FUN_00004042",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000305c",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "process_device_data_0000305c"
        },
        "FUN_000012b4": {
            "renaming": {
                "FUN_000012b4": "check_and_increment_difference_000012b4",
                "param_1": "data",
                "param_2": "length",
                "uVar1": "difference"
            },
            "code": "int check_and_increment_difference_000012b4(int* data, int length)\n{\n    int difference = check_difference_and_increment_00002364(data + 4, length);\n    process_interrupt_request_000024bc(data);\n    return difference;\n}",
            "called": [
                "FUN_000024bc",
                "FUN_00002364"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012b4",
            "calling": [],
            "imported": false,
            "current_name": "check_and_increment_difference_000012b4"
        },
        "FUN_00005b34": {
            "renaming": {
                "FUN_00005b34": "FUNC_00005b34"
            },
            "code": "\ncode * FUNC_00005b34(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5\n                   )\n\n{\n  bool bVar1;\n  byte bVar2;\n  undefined *puVar3;\n  int iVar4;\n  code *pcVar5;\n  int iVar6;\n  undefined *puVar7;\n  uint uVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint **ppuVar11;\n  uint uVar12;\n  undefined *puVar13;\n  code *local_24;\n  \n  puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n  bVar2 = *(byte *)(param_2 + 6);\n  puVar7 = (undefined *)((int)param_2 + 0x43);\n  local_24 = param_4;\n  if (0x78 < bVar2) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)param_2 + 0x42) = bVar2;\nLAB_00005bdc:\n    puVar7 = (undefined *)((int)param_2 + 0x42);\n    uVar8 = 1;\nLAB_00005d28:\n    param_2[4] = uVar8;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (bVar2 < 99) {\n    if (bVar2 == 0) goto LAB_00005d06;\n    if (bVar2 == 0x58) {\n      *(undefined *)((int)param_2 + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(bVar2) {\n  case 99:\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    *(char *)((int)param_2 + 0x42) = (char)uVar8;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    uVar10 = *param_2;\n    puVar9 = *param_5;\n    if ((int)(uVar10 << 0x18) < 0) {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n    }\n    else {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n      if ((uVar10 & 0x40) != 0) {\n        uVar8 = (uint)(short)uVar8;\n      }\n    }\n    if ((int)uVar8 < 0) {\n      uVar8 = -uVar8;\n      *(undefined *)((int)param_2 + 0x43) = 0x2d;\n    }\n    uVar10 = 10;\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*param_5;\n    uVar10 = *param_2;\n    uVar8 = param_2[5];\n    *param_5 = (uint *)(ppuVar11 + 1);\n    puVar9 = *ppuVar11;\n    if (((int)(uVar10 << 0x18) < 0) || (-1 < (int)(uVar10 << 0x19))) {\n      *puVar9 = uVar8;\n    }\n    else {\n      *(short *)puVar9 = (short)uVar8;\n    }\nLAB_00005d06:\n    param_2[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    puVar9 = *param_5;\n    uVar8 = *param_2;\n    *param_5 = puVar9 + 1;\n    if (((int)(uVar8 << 0x18) < 0) || (-1 < (int)(uVar8 << 0x19))) {\n      uVar8 = *puVar9;\n    }\n    else {\n      uVar8 = (uint)*(ushort *)puVar9;\n    }\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    if (bVar2 == 0x6f) {\n      uVar10 = 8;\n    }\n    else {\n      uVar10 = 10;\n    }\n    break;\n  case 0x70:\n    *param_2 = *param_2 | 0x20;\n  case 0x78:\n    puVar3 = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)param_2 + 0x45) = 0x78;\nLAB_00005ca8:\n    uVar10 = *param_2;\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    if ((-1 < (int)(uVar10 << 0x18)) && ((int)(uVar10 << 0x19) < 0)) {\n      uVar8 = uVar8 & 0xffff;\n    }\n    if ((int)(uVar10 << 0x1f) < 0) {\n      *param_2 = uVar10 | 0x20;\n    }\n    if (uVar8 == 0) {\n      *param_2 = *param_2 & 0xffffffdf;\n    }\n    uVar10 = 0x10;\n    break;\n  case 0x73:\n    puVar9 = *param_5;\n    *param_5 = puVar9 + 1;\n    puVar7 = (undefined *)*puVar9;\n    iVar4 = find_byte_sequence_00006010(puVar7,0,param_2[1],puVar9,param_1,param_2,param_3);\n    if (iVar4 != 0) {\n      param_2[1] = iVar4 - (int)puVar7;\n    }\n    uVar8 = param_2[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)param_2 + 0x43) = 0;\nLAB_00005c36:\n  uVar12 = param_2[1];\n  param_2[2] = uVar12;\n  if (-1 < (int)uVar12) {\n    *param_2 = *param_2 & 0xfffffffb;\n  }\n  puVar13 = puVar7;\n  if ((uVar8 != 0) || (uVar12 != 0)) {\n    do {\n      puVar13 = puVar13 + -1;\n      *puVar13 = puVar3[uVar8 - uVar10 * (uVar8 / uVar10)];\n      bVar1 = uVar10 <= uVar8;\n      uVar8 = uVar8 / uVar10;\n    } while (bVar1);\n  }\n  if (((uVar10 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4])) {\n    puVar13[-1] = 0x30;\n    puVar13 = puVar13 + -1;\n  }\n  param_2[4] = (int)puVar7 - (int)puVar13;\n  puVar7 = puVar13;\nLAB_00005c84:\n  iVar4 = encode_string_00005a58(param_1,param_2,&local_24,param_3,param_4);\n  if ((iVar4 == -1) || (iVar4 = (*param_4)(param_1,param_3,puVar7,param_2[4]), iVar4 == -1)) {\nLAB_00005c98:\n    pcVar5 = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar4 = 0; iVar4 < (int)(param_2[3] - (int)local_24); iVar4 = iVar4 + 1) {\n        iVar6 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar6 == -1) goto LAB_00005c98;\n      }\n    }\n    pcVar5 = (code *)param_2[3];\n    if ((int)(code *)param_2[3] < (int)local_24) {\n      pcVar5 = local_24;\n    }\n  }\n  return pcVar5;\n}\n\n",
            "called": [
                "FUN_00006010",
                "FUN_00005a58"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005b34",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "FUNC_00005b34"
        },
        "FUN_0000058e": {
            "renaming": {
                "FUN_0000058e": "copy_pointer_0000058e",
                "param_1": "source_pointer",
                "param_2": "destination_pointer",
                "*param_1": "*source_pointer",
                "*param_2": "*destination_pointer"
            },
            "code": "void copy_pointer_0000058e(int *source_pointer, undefined4 *destination_pointer) {\n    if (*source_pointer == 0) {\n        *destination_pointer = destination_pointer;\n    }\n    else {\n        *destination_pointer = *(undefined4 *)*source_pointer;\n        *(undefined4 **)*source_pointer = destination_pointer;\n    }\n    *source_pointer = (int)destination_pointer;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000058e",
            "calling": [
                "FUN_00000698"
            ],
            "imported": false,
            "current_name": "copy_pointer_0000058e"
        },
        "FUN_0000656c": {
            "renaming": {
                "FUN_0000656c": "FUNC_0000656c"
            },
            "code": "\nundefined4 FUNC_0000656c(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  code *pcVar3;\n  uint uVar4;\n  byte *pbVar5;\n  uint uVar6;\n  undefined4 *puVar7;\n  uint *puVar8;\n  uint *puVar9;\n  uint *puVar10;\n  int unaff_r9;\n  int iVar11;\n  undefined4 local_34 [4];\n  \n  local_34[0] = *(undefined4 *)PTR_PTR_DAT_00006744;\n  local_34[1] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  local_34[2] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  pcVar3 = (code *)PTR_LAB_00004f80_1_0000674c;\n  if (param_2[6] != 3) {\n    pcVar3 = (code *)PTR_LAB_00005fd4_1_00006748;\n  }\n  uVar6 = param_2[2];\n  uVar4 = uVar6 - 1;\n  if (0x15c < uVar4) {\n    unaff_r9 = uVar6 - 0x15d;\n    uVar6 = 0x15d;\n  }\n  if (0x15c < uVar4) {\n    param_2[2] = uVar6;\n  }\n  puVar10 = param_2 + 7;\n  if (uVar4 < 0x15d) {\n    unaff_r9 = 0;\n  }\n  *param_2 = *param_2 | 0xd00;\n  iVar11 = 0;\n  puVar9 = puVar10;\n  do {\n    iVar1 = find_byte_sequence_00006010(local_34[iVar11],**param_3,2);\n    if (iVar1 != 0) {\n      if (iVar11 == 1) {\n        if (param_2[1] == 0) {\n          param_2[1] = 8;\n          *param_2 = *param_2 | 0x200;\n        }\n        uVar4 = *param_2 & 0xfffffaff;\nLAB_000065f4:\n        *param_2 = uVar4;\n      }\n      else if (iVar11 == 2) {\n        if ((*param_2 & 0x600) != 0x200) goto LAB_00006624;\n        param_2[1] = 0x10;\n        uVar4 = *param_2 | 0x100;\n        goto LAB_000065f4;\n      }\n      uVar4 = param_2[2];\n      param_2[2] = uVar4 - 1;\n      if (uVar4 != 0) {\n        pbVar5 = *param_3;\n        *param_3 = pbVar5 + 1;\n        puVar8 = (uint *)((int)puVar9 + 1);\n        *(byte *)puVar9 = *pbVar5;\n        pbVar5 = param_3[1];\n        param_3[1] = pbVar5 + -1;\n        puVar9 = puVar8;\n        if (((int)(pbVar5 + -1) < 1) &&\n           (iVar1 = (*(code *)param_2[0x60])(param_1,param_3), iVar1 != 0)) {\n          iVar11 = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iVar11 = iVar11 + 1;\n  } while (iVar11 != 3);\n  if (param_2[1] == 0) {\n    param_2[1] = 10;\n  }\n  decode_0000687c(param_2[5],(int)PTR_DAT_00006750 - param_2[1]);\n  iVar11 = 0;\n  while( true ) {\n    puVar8 = puVar9;\n    if (param_2[2] == 0) break;\n    pbVar5 = *param_3;\n    uVar4 = (uint)*pbVar5;\n    if (*(char *)(param_2[5] + uVar4) == '\\0') break;\n    if ((uVar4 == 0x30) && ((int)(*param_2 << 0x14) < 0)) {\n      iVar11 = iVar11 + 1;\n      if (unaff_r9 != 0) {\n        unaff_r9 = unaff_r9 + -1;\n        param_2[2] = param_2[2] + 1;\n      }\n    }\n    else {\n      *param_2 = *param_2 & 0xfffff6ff;\n      puVar8 = (uint *)((int)puVar9 + 1);\n      *(byte *)puVar9 = *pbVar5;\n    }\n    pbVar5 = param_3[1];\n    param_3[1] = pbVar5 + -1;\n    if ((int)(pbVar5 + -1) < 1) {\n      iVar1 = (*(code *)param_2[0x60])(param_1,param_3);\n      if (iVar1 != 0) break;\n    }\n    else {\n      *param_3 = *param_3 + 1;\n    }\n    param_2[2] = param_2[2] - 1;\n    puVar9 = puVar8;\n  }\nLAB_000066ca:\n  if ((int)(*param_2 << 0x17) < 0) {\n    if (puVar10 < puVar8) {\n      (*(code *)param_2[0x5f])(param_1,*(byte *)((int)puVar8 + -1),param_3);\n      puVar8 = (uint *)((int)puVar8 + -1);\n    }\n    if (puVar8 == puVar10) {\n      return 1;\n    }\n  }\n  if ((*param_2 & 0x10) == 0) {\n    *(byte *)puVar8 = 0;\n    uVar2 = (*pcVar3)(param_1,puVar10,0,param_2[1]);\n    puVar7 = (undefined4 *)*param_4;\n    uVar4 = *param_2;\n    *param_4 = puVar7 + 1;\n    puVar7 = (undefined4 *)*puVar7;\n    if ((uVar4 & 0x20) == 0) {\n      if ((int)(uVar4 << 0x1f) < 0) {\n        *(short *)puVar7 = (short)uVar2;\n      }\n      else {\n        *puVar7 = uVar2;\n      }\n    }\n    else {\n      *puVar7 = uVar2;\n    }\n    param_2[3] = param_2[3] + 1;\n  }\n  param_2[4] = (uint)((int)puVar8 + param_2[4] + (iVar11 - (int)puVar10));\n  return 0;\n}\n\n",
            "called": [
                "FUN_0000687c",
                "FUN_00006010"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000656c",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "FUNC_0000656c"
        },
        "FUN_000025f4": {
            "renaming": {
                "FUN_000025f4": "initialize_flag_and_data_000025f4",
                "set_flag_and_initialize_000027b0": "set_flag_and_initialize_data"
            },
            "code": "void initialize_flag_and_data_000025f4()\n{\n  set_flag_and_initialize_data();\n  return;\n}",
            "called": [
                "FUN_000027b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000025f4",
            "calling": [
                "FUN_00002396"
            ],
            "imported": false,
            "current_name": "initialize_flag_and_data_000025f4"
        },
        "FUN_00001ddc": {
            "renaming": {
                "FUN_00001ddc": "set_calculated_address_00001ddc",
                "param_1": "address",
                "cVar1": "bits",
                "get_bits_from_right_00001da2": "get_bits_from_right",
                "set_calculated_address_to_one_00001d3a": "set_address",
                "DAT_00001e08": "DAT_calculated_address"
            },
            "code": "void set_calculated_address_00001ddc(char address) {\n  char bits = get_bits_from_right(address);\n  set_address(DAT_00001e08, bits + 9);\n  return;\n}",
            "called": [
                "FUN_00001d3a",
                "FUN_00001da2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ddc",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "set_calculated_address_00001ddc"
        },
        "FUN_00002ecc": {
            "renaming": {
                "FUN_00002ecc": "read_data_from_device_00002ecc",
                "param_1": "buffer",
                "param_2": "device_id",
                "auStack_1c": "data_buffer",
                "local_14": "device_data_size",
                "uVar1": "device_class",
                "uVar2": "device_data"
            },
            "code": "void read_data_from_device_00002ecc(void* buffer, int device_id)\n{\n    undefined4 device_data_size;\n    undefined4 device_class;\n    undefined data_buffer[8];\n\n    device_data_size = execute_device_read_function(device_id, data_buffer);\n    if ((int)device_data_size < 1) {\n        handle_error(PTR_s_error__failed_to_read_from_devic_00002f28, buffer);\n    }\n    else {\n        device_class = get_class_for_character_000039e8(*(undefined *)(*(int *)(device_id + 0xc) + 8));\n        handle_success(PTR_s_Reading_from___i___s__s__00002f2c, buffer, *(undefined4 *)(device_id + 8), device_class);\n        display_data_object_00003694(data_buffer, device_data_size & 0xff);\n    }\n    return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00003d64",
                "FUN_000039e8",
                "FUN_00003694"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002ecc",
            "calling": [
                "FUN_00002fe0",
                "FUN_00002f30"
            ],
            "imported": false,
            "current_name": "read_data_from_device_00002ecc"
        },
        "FUN_00000d76": {
            "renaming": {
                "FUN_00000d76": "set_calculated_value_to_zero_00000d76",
                "param_1": "value1",
                "param_2": "value2",
                "puVar1": "calculated_value_ptr",
                "calculate_value_00000d44": "calculate_value"
            },
            "code": "void set_calculated_value_to_zero_00000d76(undefined4 value1, undefined value2)\n{\n  undefined4 *calculated_value_ptr;\n  calculated_value_ptr = (undefined4 *)calculate_value(value1, value2);\n  *calculated_value_ptr = 0;\n  return;\n}",
            "called": [
                "FUN_00000d44"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d76",
            "calling": [
                "FUN_00000d9c"
            ],
            "imported": false,
            "current_name": "set_calculated_value_to_zero_00000d76"
        },
        "FUN_000057a8": {
            "renaming": {
                "FUN_000057a8": "process_input_000057a8",
                "param_1": "input",
                "param_2": "count",
                "param_3": "buffer",
                "iVar1": "index",
                "puVar2": "current_char"
            },
            "code": "int process_input_000057a8(int input, int *count, char *buffer, int buffer_size) {\n  int index = count[2] - 1;\n  count[2] = index;\n  if ((index < 0) && ((index < buffer_size) || (input == 10))) {\n    int result = process_input_000057a8_00005404();\n    return result;\n  }\n  char *current_char = &buffer[*count];\n  *current_char = (char)input;\n  *count = *count + 1;\n  return input;\n}",
            "called": [
                "FUN_00005404"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057a8",
            "calling": [
                "FUN_000057d2"
            ],
            "imported": false,
            "current_name": "process_input_000057a8"
        },
        "FUN_00001696": {
            "renaming": {
                "FUN_00001696": "calculate_result_00001696",
                "param_1": "input_value",
                "param_2": "multiplier",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int calculate_result_00001696(uint32_t input_value, int multiplier) {\n    uint32_t shifted_input = (input_value & 0xfffff) << 5;\n    uint32_t masked_input = input_value & 0xf0000000;\n    uint32_t result = (multiplier * 4) + shifted_input + masked_input + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001696",
            "calling": [
                "FUN_000016ec",
                "FUN_000016c8",
                "FUN_00001710"
            ],
            "imported": false,
            "current_name": "calculate_result_00001696"
        },
        "FUN_000008b8": {
            "renaming": {
                "FUN_000008b8": "count_elf32_rel_entries_000008b8",
                "local_c": "entry_ptr",
                "PTR_DAT_000008f4": "elf32_rel_array_start",
                "DAT_000008f8": "elf32_rel_entry_marker",
                "PTR_Elf32_Rel_ARRAY_000008fc": "elf32_rel_array_end"
            },
            "code": "int count_elf32_rel_entries_000008b8(void)\n{\n  int *entry_ptr;\n  for (entry_ptr = (int *)PTR_DAT_000008f4; (*entry_ptr == DAT_000008f8 && (entry_ptr < PTR_Elf32_Rel_ARRAY_000008fc)); entry_ptr++)\n  {\n  }\n  return ((int)PTR_Elf32_Rel_ARRAY_000008fc - (int)entry_ptr) & ~3;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000008b8",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "count_elf32_rel_entries_000008b8"
        },
        "FUN_000024bc": {
            "renaming": {
                "FUN_000024bc": "process_interrupt_request_000024bc",
                "param_1": "interrupt_request_status",
                "uVar1": "interrupt_flags",
                "uVar2": "irq_interrupt_status",
                "iVar3": "next_pointer"
            },
            "code": "void process_interrupt_request_000024bc(int *interrupt_request_status)\n{\n  undefined interrupt_flags;\n  undefined4 irq_interrupt_status;\n  int next_pointer;\n  \n  irq_interrupt_status = check_for_enabled_IRQ_interrupts_00000cd0();\n  if (*interrupt_request_status == 0) {\n    enableIRQinterrupts_if_privileged_00000d0c(irq_interrupt_status);\n  }\n  else if (*interrupt_request_status == -1) {\n    *interrupt_request_status = 0;\n    enableIRQinterrupts_if_privileged_00000d0c(irq_interrupt_status);\n  }\n  else {\n    next_pointer = get_next_pointer_0000240c(interrupt_request_status);\n    update_list_00000698(next_pointer - 8, 10);\n    if (*interrupt_request_status == 0) {\n      *interrupt_request_status = -1;\n    }\n    interrupt_flags = *(undefined *)(next_pointer - 3);\n    enableIRQinterrupts_if_privileged_00000d0c(irq_interrupt_status);\n    check_exception_00000738(interrupt_flags);\n  }\n  return;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000d0c",
                "FUN_0000240c",
                "FUN_00000cd0",
                "FUN_00000738"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000024bc",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": false,
            "current_name": "process_interrupt_request_000024bc"
        },
        "FUN_00000490": {
            "renaming": {
                "FUN_00000490": "compare_and_copy_wrapper_00000490",
                "param_1": "source",
                "param_2": "destination",
                "param_3": "N/A",
                "param_4": "N/A",
                "uVar1": "result"
            },
            "code": "int compare_and_copy_wrapper_00000490(int source, int destination) {\n  int result = compare_and_copy(source, destination);\n  return result;\n}",
            "called": [
                "FUN_00000e14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000490",
            "calling": [
                "FUN_00004dc8"
            ],
            "imported": false,
            "current_name": "compare_and_copy_wrapper_00000490"
        },
        "FUN_0000091c": {
            "renaming": {
                "FUN_0000091c": "get_data_pointer_0000091c",
                "PTR_DAT_0000092c": "data_pointer"
            },
            "code": "const void* get_data_pointer_0000091c() {\n  return PTR_DAT_0000092c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000091c",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_data_pointer_0000091c"
        },
        "FUN_00001f80": {
            "renaming": {
                "FUN_00001f80": "write_to_memory_00001f80",
                "param_1": "address",
                "param_2": "data",
                "uVar3": "bits_to_extract_from",
                "uVar4": "bits_to_write_to",
                "iVar1": "bits_to_extract",
                "iVar2": "last_six_bits",
                "uVar5": "old_data",
                "set_calculated_address_00001ddc": "set_calculated_address",
                "extractBits_00001d5e": "extractBits",
                "extract_last_six_bits_00001dc0": "extract_last_six_bits",
                "get_bits_from_right_00001da2": "get_bits_from_right",
                "extract_bits_and_write_to_memory_00001ec4": "extract_bits_and_write_to_memory"
            },
            "code": "void write_to_memory_00001f80(uint16_t address, uint32_t data) {\n  uint16_t bit_mask = 0x3F;\n  set_calculated_address(address);\n  uint16_t bits_to_extract = extractBits(address);\n  uint16_t last_six_bits = extract_last_six_bits(address);\n  uint32_t old_data = *(uint32_t *)(bits_to_extract + last_six_bits * 4);\n  *(uint32_t *)(bits_to_extract + last_six_bits * 4) = data;\n  if ((old_data & 0xf0000) != 0) {\n    uint16_t bits_to_extract_from = get_bits_from_right(address);\n    uint16_t bits_to_write_to = extract_last_six_bits(address);\n    extract_bits_and_write_to_memory_00001f80(bits_to_extract_from, bits_to_write_to);\n  }\n}",
            "called": [
                "FUN_00001dc0",
                "FUN_00001ddc",
                "FUN_00001ec4",
                "FUN_00001d5e",
                "FUN_00001da2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001f80",
            "calling": [
                "FUN_00001448",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "write_to_memory_00001f80"
        },
        "FUN_00000e64": {
            "renaming": {
                "FUN_00000e64": "set_flags_and_update_memory_00000e64",
                "DAT_00000ed0": "data",
                "findNextNonNull_00001034": "nextNonNull",
                "DAT_00000ed4": "baseAddress",
                "print_ascii_characters_and_set_flag_00001274": "print_chars_and_set_flag",
                "write_to_memory_and_update_flags_00001eea": "write_mem_and_update_flags",
                "set_bit_at_position_00001ff6": "set_bit_at_pos"
            },
            "code": "void set_flags_and_update_memory_00000e64(void)\n{\n  uint* nextNonNull = findNextNonNull_00001034;\n  uint* DAT_00000ed0 = DAT_00000ed0;\n  uint* DAT_00000ed4 = DAT_00000ed4;\n  *(uint *)(nextNonNull + DAT_00000ed0 + 4) |= 0x200;\n  *(uint *)(DAT_00000ed4 + 0x48) &= 0xfefff8ff;\n  print_ascii_characters_and_set_flag_00001274();\n  write_to_memory_and_update_flags_00001eea(0x2056,0x80);\n  write_to_memory_and_update_flags_00001eea(0x511a,0x80);\n  write_to_memory_and_update_flags_00001eea(0x2055,0x80);\n  set_bit_at_position_00001ff6(0x2056);\n  set_bit_at_position_00001ff6(0x511a);\n  set_bit_at_position_00001ff6(0x2055);\n  return;\n}\n",
            "called": [
                "FUN_00001ff6",
                "FUN_00001eea",
                "FUN_00001274"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e64",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "set_flags_and_update_memory_00000e64"
        },
        "FUN_000026e4": {
            "renaming": {
                "FUN_000026e4": "clear_bits_in_array_and_return_000026e4",
                "clear_bit_in_uint_array_00002970": "clear_bits_in_uint_array"
            },
            "code": "void clear_bits_in_array_and_return_000026e4(void)\n{\n  clear_bits_in_uint_array();\n  return;\n}",
            "called": [
                "FUN_00002970"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026e4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "clear_bits_in_array_and_return_000026e4"
        },
        "FUN_00000d44": {
            "renaming": {
                "FUN_00000d44": "calculate_value_00000d44",
                "param_1": "input_value",
                "param_2": "multiplier"
            },
            "code": "int calculate_value_00000d44(uint32_t input_value, int multiplier) {\n    uint32_t masked_value = input_value & 0xf0000000;\n    uint32_t shifted_value = (input_value & 0xfffff) << 5;\n    int constant_value = 0x2000000;\n    return multiplier * 4 + masked_value + shifted_value + constant_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d44",
            "calling": [
                "FUN_00000d76"
            ],
            "imported": false,
            "current_name": "calculate_value_00000d44"
        },
        "FUN_00000698": {
            "renaming": {
                "FUN_00000698": "update_list_00000698",
                "param_1": "index",
                "param_2": "length",
                "PTR_DAT_00000730": "list_pointer",
                "PTR_DAT_00000734": "list_status",
                "current_index": "index_value"
            },
            "code": "void update_list_00000698(int index, uint8_t length)\n{\n    if (length < 9)\n    {\n        uint8_t current_index = *(byte *)(index + 4);\n        if ((current_index > 8) && (reverse_linked_list(PTR_DAT_00000730 + (uint)*(byte *)(index + 5) * 4), *(int *)(PTR_DAT_00000730 + (uint)*(byte *)(index + 5) * 4) == 0))\n        {\n            *(uint *)PTR_DAT_00000734 = *(uint *)PTR_DAT_00000734 & ~(1 << *(sbyte *)(index + 5));\n        }\n    }\n    else\n    {\n        uint8_t current_index = *(byte *)(index + 4);\n        if (current_index < 9)\n        {\n            copy_pointer(PTR_DAT_00000730 + (uint)*(byte *)(index + 5) * 4,index + 8);\n            *(uint *)PTR_DAT_00000734 = *(uint *)PTR_DAT_00000734 | 1 << *(sbyte *)(index + 5);\n        }\n    }\n    *(char *)(index + 4) = (char)length;\n    return;\n}",
            "called": [
                "FUN_000005ca",
                "FUN_0000058e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000698",
            "calling": [
                "FUN_000010d4",
                "FUN_00000794",
                "FUN_000024bc",
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "update_list_00000698"
        },
        "FUN_00000cd0": {
            "renaming": {
                "FUN_00000cd0": "check_for_enabled_IRQ_interrupts_00000cd0",
                "bVar1": "is_current_mode_privileged",
                "uVar2": "is_IRQ_interrupts_enabled"
            },
            "code": "check_for_enabled_IRQ_interrupts_00000cd0bcheck_for_enabled_IRQ_interrupts_00000cd0ocheck_for_enabled_IRQ_interrupts_00000cd0ocheck_for_enabled_IRQ_interrupts_00000cd0lcheck_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0Icheck_for_enabled_IRQ_interrupts_00000cd0Rcheck_for_enabled_IRQ_interrupts_00000cd0Qcheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0ncheck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0ucheck_for_enabled_IRQ_interrupts_00000cd0pcheck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0ncheck_for_enabled_IRQ_interrupts_00000cd0acheck_for_enabled_IRQ_interrupts_00000cd0bcheck_for_enabled_IRQ_interrupts_00000cd0lcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0dcheck_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0=check_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0fcheck_for_enabled_IRQ_interrupts_00000cd0acheck_for_enabled_IRQ_interrupts_00000cd0lcheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0;check_for_enabled_IRQ_interrupts_00000cd0\ncheck_for_enabled_IRQ_interrupts_00000cd0bcheck_for_enabled_IRQ_interrupts_00000cd0ocheck_for_enabled_IRQ_interrupts_00000cd0ocheck_for_enabled_IRQ_interrupts_00000cd0lcheck_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0ccheck_for_enabled_IRQ_interrupts_00000cd0ucheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0ncheck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0mcheck_for_enabled_IRQ_interrupts_00000cd0ocheck_for_enabled_IRQ_interrupts_00000cd0dcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0pcheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0vcheck_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0lcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0gcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0dcheck_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0=check_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0fcheck_for_enabled_IRQ_interrupts_00000cd0acheck_for_enabled_IRQ_interrupts_00000cd0lcheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0;check_for_enabled_IRQ_interrupts_00000cd0\ncheck_for_enabled_IRQ_interrupts_00000cd0\ncheck_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0ccheck_for_enabled_IRQ_interrupts_00000cd0ucheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0ncheck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0mcheck_for_enabled_IRQ_interrupts_00000cd0ocheck_for_enabled_IRQ_interrupts_00000cd0dcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0pcheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0vcheck_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0lcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0gcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0dcheck_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0=check_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0(check_for_enabled_IRQ_interrupts_00000cd0bcheck_for_enabled_IRQ_interrupts_00000cd0ocheck_for_enabled_IRQ_interrupts_00000cd0ocheck_for_enabled_IRQ_interrupts_00000cd0lcheck_for_enabled_IRQ_interrupts_00000cd0)check_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0Ccheck_for_enabled_IRQ_interrupts_00000cd0ucheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0ncheck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0Mcheck_for_enabled_IRQ_interrupts_00000cd0ocheck_for_enabled_IRQ_interrupts_00000cd0dcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0Pcheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0vcheck_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0lcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0gcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0dcheck_for_enabled_IRQ_interrupts_00000cd0(check_for_enabled_IRQ_interrupts_00000cd0)check_for_enabled_IRQ_interrupts_00000cd0;check_for_enabled_IRQ_interrupts_00000cd0\ncheck_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0fcheck_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0(check_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0ccheck_for_enabled_IRQ_interrupts_00000cd0ucheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0ncheck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0mcheck_for_enabled_IRQ_interrupts_00000cd0ocheck_for_enabled_IRQ_interrupts_00000cd0dcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0pcheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0vcheck_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0lcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0gcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0dcheck_for_enabled_IRQ_interrupts_00000cd0)check_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0{check_for_enabled_IRQ_interrupts_00000cd0\ncheck_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0Icheck_for_enabled_IRQ_interrupts_00000cd0Rcheck_for_enabled_IRQ_interrupts_00000cd0Qcheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0ncheck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0ucheck_for_enabled_IRQ_interrupts_00000cd0pcheck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0ncheck_for_enabled_IRQ_interrupts_00000cd0acheck_for_enabled_IRQ_interrupts_00000cd0bcheck_for_enabled_IRQ_interrupts_00000cd0lcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0dcheck_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0=check_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0Icheck_for_enabled_IRQ_interrupts_00000cd0Rcheck_for_enabled_IRQ_interrupts_00000cd0Qcheck_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0ncheck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0ucheck_for_enabled_IRQ_interrupts_00000cd0pcheck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0Echeck_for_enabled_IRQ_interrupts_00000cd0ncheck_for_enabled_IRQ_interrupts_00000cd0acheck_for_enabled_IRQ_interrupts_00000cd0bcheck_for_enabled_IRQ_interrupts_00000cd0lcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0dcheck_for_enabled_IRQ_interrupts_00000cd0(check_for_enabled_IRQ_interrupts_00000cd0)check_for_enabled_IRQ_interrupts_00000cd0;check_for_enabled_IRQ_interrupts_00000cd0\ncheck_for_enabled_IRQ_interrupts_00000cd0}check_for_enabled_IRQ_interrupts_00000cd0\ncheck_for_enabled_IRQ_interrupts_00000cd0dcheck_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0acheck_for_enabled_IRQ_interrupts_00000cd0bcheck_for_enabled_IRQ_interrupts_00000cd0lcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0Icheck_for_enabled_IRQ_interrupts_00000cd0Rcheck_for_enabled_IRQ_interrupts_00000cd0Qcheck_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0ncheck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0ucheck_for_enabled_IRQ_interrupts_00000cd0pcheck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0(check_for_enabled_IRQ_interrupts_00000cd0)check_for_enabled_IRQ_interrupts_00000cd0;check_for_enabled_IRQ_interrupts_00000cd0\ncheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0ucheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0ncheck_for_enabled_IRQ_interrupts_00000cd0 check_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0Icheck_for_enabled_IRQ_interrupts_00000cd0Rcheck_for_enabled_IRQ_interrupts_00000cd0Qcheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0icheck_for_enabled_IRQ_interrupts_00000cd0ncheck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0rcheck_for_enabled_IRQ_interrupts_00000cd0ucheck_for_enabled_IRQ_interrupts_00000cd0pcheck_for_enabled_IRQ_interrupts_00000cd0tcheck_for_enabled_IRQ_interrupts_00000cd0scheck_for_enabled_IRQ_interrupts_00000cd0_check_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0ncheck_for_enabled_IRQ_interrupts_00000cd0acheck_for_enabled_IRQ_interrupts_00000cd0bcheck_for_enabled_IRQ_interrupts_00000cd0lcheck_for_enabled_IRQ_interrupts_00000cd0echeck_for_enabled_IRQ_interrupts_00000cd0dcheck_for_enabled_IRQ_interrupts_00000cd0;check_for_enabled_IRQ_interrupts_00000cd0",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cd0",
            "calling": [
                "FUN_000010d4",
                "FUN_00000f8c",
                "FUN_00000794",
                "FUN_00000f04",
                "FUN_000024bc",
                "FUN_00002434",
                "FUN_00000e58",
                "FUN_00001c84",
                "FUN_00000428"
            ],
            "imported": false,
            "current_name": "check_for_enabled_IRQ_interrupts_00000cd0"
        },
        "FUN_00000cc0": {
            "renaming": {
                "FUN_00000cc0": "check_for_IRQ_interrupts_00000cc0",
                "uVar2": "is_IRQ_interrupts_enabled",
                "bVar1": "is_privileged",
                "isCurrentModePrivileged": "is_current_mode_privileged",
                "isIRQinterruptsEnabled": "is_IRQ_interrupts_enabled",
                "disableIRQinterrupts": "disable_IRQ_interrupts",
                "uRam00000ccc": "input_buffer"
            },
            "code": "bool is_IRQ_interrupts_enabled = false;\n\ncheck_for_IRQ_interrupts_00000cc0(10, input_buffer);\n\nbool is_privileged = is_current_mode_privileged();\nif (is_privileged) {\n    is_IRQ_interrupts_enabled = is_IRQ_interrupts_enabled();\n}\n\ndisable_IRQ_interrupts();\n\nreturn is_IRQ_interrupts_enabled;",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cc0",
            "calling": [
                "FUN_00000dc0"
            ],
            "imported": false,
            "current_name": "check_for_IRQ_interrupts_00000cc0"
        },
        "FUN_00002994": {
            "renaming": {
                "FUN_00002994": "check_and_execute_flag_functions_00002994",
                "iVar1": "data",
                "check_flag_status_00002798": "check_flag_status"
            },
            "code": "void check_and_execute_flag_functions_00002994(void)\n{\n  int data = DAT_000029f8;\n  if (((*(uint *)(data + 0x14) & 4) != 0) && (*(int *)PTR_DAT_000029fc != 0)) {\n    *(uint *)(data + 0x1c) = *(uint *)(data + 0x1c) & 0xfffffffb;\n    (**(code **)PTR_DAT_000029fc)(*(undefined4 *)(PTR_DAT_000029fc + 4));\n  }\n  if (((*(uint *)(data + 0x14) & 2) != 0) && (*(int *)(PTR_DAT_000029fc + 8) != 0)) {\n    (**(code **)(PTR_DAT_000029fc + 8))(*(undefined4 *)(PTR_DAT_000029fc + 0xc));\n  }\n  check_flag_status();\n  return;\n}",
            "called": [
                "FUN_00002798"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002994",
            "calling": [],
            "imported": false,
            "current_name": "check_and_execute_flag_functions_00002994"
        },
        "FUN_00000d2a": {
            "renaming": {
                "FUN_00000d2a": "get_current_exception_number_if_privileged_mode_00000d2a",
                "uVar2": "current_exception_number",
                "bVar1": "is_privileged_mode"
            },
            "code": "uint get_current_exception_number_if_privileged_mode_00000d2a() {\n    bool is_privileged_mode = (bool) isCurrentModePrivileged();\n    uint current_exception_number = 0;\n    if (is_privileged_mode) {\n        current_exception_number = getCurrentExceptionNumber() & 0x1f;\n    }\n    return current_exception_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d2a",
            "calling": [
                "FUN_00000738"
            ],
            "imported": false,
            "current_name": "get_current_exception_number_if_privileged_mode_00000d2a"
        },
        "FUN_00001ff6": {
            "renaming": {
                "FUN_00001ff6": "set_bit_at_position_00001ff6",
                "param_1": "parameter",
                "uVar1": "extracted_bits",
                "iVar2": "flagged_value",
                "PTR_00001d80": "get_flagged_value",
                "PTR_00001dc0": "extract_last_six_bits",
                "memory_location": "memory_location",
                "bit_to_set": "bit_to_set"
            },
            "code": "void set_bit_at_position_00001ff6(uint8_t position)\n{\n  uint8_t extracted_bits = PTR_00001dc0(parameter);\n  int flagged_value = PTR_00001d80(parameter);\n  int* memory_location = (int*)(flagged_value + 4);\n  int bit_to_set = 1 << (extracted_bits & 0xff);\n  *memory_location = bit_to_set;\n  return;\n}",
            "called": [
                "FUN_00001d80",
                "FUN_00001dc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ff6",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_00001ff6"
        },
        "FUN_000013b8": {
            "renaming": {
                "FUN_000013b8": "store_input_value_000013b8",
                "param_1": "index",
                "param_2": "value",
                "param_3": "flag",
                "param_4": "address",
                "PTR_s_FAILED_ASSERTION__0000143c": "FAILED_ASSERTION_MSG",
                "PTR_DAT_00001440": "input_values",
                "PTR_DAT_00001444": "address_values",
                "PTR_DAT_00001444[param_1 * 0x20 + 0x1c]": "address_offsets[index]",
                "PTR_DAT_00001444[param_1 * 0x20 + 0x1e]": "address_flags[index]",
                "update_data_000014c4": "update_data",
                "set_address_value_at_offset_00001392": "set_address_value_at_offset",
                "write_to_memory_if_not_negative_00001448": "write_to_memory_if_not_negative",
                "uVar1": "result"
            },
            "code": "int store_input_value_000013b8(int index, int value, int flag, int address){\n  int result;\n  if (index != 0){\n    process_input(3, PTR_s_FAILED_ASSERTION__0000143c);\n  }\n  PTR_DAT_00001440[index] = value;\n  input_flags[index] = flag;\n  write_to_memory_if_not_negative(index);\n  set_address_value_at_offset(PTR_DAT_00001444[index], PTR_DAT_00001444[param_1 * 0x20 + 0x1c]);\n  if (PTR_DAT_00001444[param_1 * 0x20 + 0x1e] == 0){\n    update_data(index, value);\n    result = 0;\n  }\n  else {\n    result = -1;\n  }\n  return result;\n}",
            "called": [
                "FUN_00001392",
                "FUN_00000f04",
                "FUN_000014c4",
                "FUN_00001448"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000013b8",
            "calling": [
                "FUN_00000df4"
            ],
            "imported": false,
            "current_name": "store_input_value_000013b8"
        },
        "FUN_00002a88": {
            "renaming": {
                "FUN_00002a88": "print_command_descriptions_00002a88",
                "param_1": "command_list",
                "local_18": "command_description",
                "local_10": "index",
                "local_c": "command",
                "PTR_s___20s__s_00002b04": "header_format",
                "PTR_s_Command_00002b00": "command_string",
                "PTR_s_Description_00002afc": "description_string",
                "PTR_s__________________________________00002b08": "separator_string"
            },
            "code": "void print_command_descriptions_00002a88(int *command_list)\n{\n  int *command_description[2];\n  uint index;\n  int *command;\n  print_header(\"    %-20s %s\\n\", \"Command\", \"Description\");\n  print_separator();\n  command_description[0] = command_list;\n  command_description[1] = (int *)PTR_PTR_s_reboot_00002b0c;\n  for (index = 0; index < 2; index++) {\n    command = command_description[index];\n    if (command != (int *)0x0) {\n      for (; *command != 0; command = command + 3) {\n        print_command_description(*command, command[1]);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a88",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "print_command_descriptions_00002a88",
            "code_backup": "\nvoid FUN_00002a88(int *param_1)\n\n{\n  int *local_18 [2];\n  uint local_10;\n  int *local_c;\n  \n  FUNC_00004c84(PTR_s___20s__s_00002b04,PTR_s_Command_00002b00,PTR_s_Description_00002afc);\n  process_input(PTR_s__________________________________00002b08);\n  local_18[0] = param_1;\n  local_18[1] = (int *)PTR_PTR_s_reboot_00002b0c;\n  for (local_10 = 0; local_10 < 2; local_10 = local_10 + 1) {\n    local_c = local_18[local_10];\n    if (local_c != (int *)0x0) {\n      for (; *local_c != 0; local_c = local_c + 3) {\n        FUNC_00004c84(PTR_s___20s__s_00002b04,*local_c,local_c[1]);\n      }\n    }\n  }\n  return;\n}\n\n"
        },
        "FUN_00002f30": {
            "renaming": {
                "FUN_00002f30": "read_data_from_all_devices_00002f30",
                "local_10": "device_index",
                "local_c": "device_list",
                "PTR_DAT_00002f6c": "device_list_pointer",
                "read_data_from_device_00002ecc": "read_data_from_device",
                "process_input": "process_data",
                "PTR_DAT_00002f70": "processed_data_pointer"
            },
            "code": "void read_data_from_all_devices_00002f30(void)\n{\n  int device_index = 0;\n  undefined4 *device_list = *(undefined4 **)PTR_DAT_00002f6c;\n  while(device_list != (undefined4 *)0x0)\n  {\n    read_data_from_device(device_index, device_list);\n    process_data(PTR_DAT_00002f70);\n    device_index++;\n    device_list = (undefined4 *)*device_list;\n  }\n  return;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00002ecc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f30",
            "calling": [
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "read_data_from_all_devices_00002f30"
        },
        "FUN_00001e44": {
            "renaming": {
                "FUN_00001e44": "write_bits_to_memory_00001e44",
                "param_1": "base_address",
                "param_2": "bit_offset",
                "param_3": "value",
                "iVar1": "byte_offset",
                "mask": "mask",
                "memory_location": "memory_location"
            },
            "code": "void write_bits_to_memory_00001e44(int base_address, uint32_t bit_offset, int value) {\n    int byte_offset = bit_offset >> 3;\n    uint32_t bit_shift = (bit_offset & 7) << 2;\n    uint32_t mask = ~(0xf << bit_shift);\n    uint32_t *memory_location = (uint32_t *)(PTR_DAT_00001ec0 + (byte_offset + base_address * 4) * 4);\n    *memory_location = (*memory_location & mask) | (value << bit_shift);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e44",
            "calling": [
                "FUN_00001ec4"
            ],
            "imported": false,
            "current_name": "write_bits_to_memory_00001e44"
        },
        "FUN_00001318": {
            "renaming": {
                "FUN_00001318": "set_bit_in_array_00001318",
                "param_1": "bit",
                "DAT_00001344": "array",
                "(uint)(int)(char)param_1 >> 5": "bit >> 5",
                "1 << (param_1 & 0x1f)": "1 << offset",
                "*(int *)": "array[index] |= mask"
            },
            "code": "void set_bit_in_array_00001318(uint8_t bit, uint32_t* DAT_00001344) {\n    uint8_t index = bit >> 5;\n    uint8_t offset = bit & 0x1f;\n    uint32_t mask = 1 << offset;\n    DAT_00001344[index] |= mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001318",
            "calling": [
                "FUN_000014c4"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_00001318"
        },
        "FUN_00000900": {
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "uVar1": "main_stack_pointer"
            },
            "code": "uint32_t get_main_stack_pointer_00000900(void)\n{\n  uint32_t main_stack_pointer;\n  main_stack_pointer = getMainStackPointer();\n  return main_stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000900",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_main_stack_pointer_00000900"
        },
        "FUN_00004274": {
            "renaming": {
                "FUN_00004274": "do_nothing_and_return_00004274",
                "PTR_DAT_0000427c": "pointer_to_data",
                "do_nothing_000045e8": "do_nothing_with_pointer"
            },
            "code": "void do_nothing_and_return_00004274(void)\n{\n  do_nothing_with_pointer(PTR_DAT_0000427c);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004274",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_and_return_00004274"
        },
        "FUN_00002fe0": {
            "renaming": {
                "FUN_00002fe0": "process_device_data_00002fe0",
                "param_1": "num_params",
                "param_2": "params",
                "iVar1": "num_bytes",
                "uVar2": "device_id",
                "PTR_s_usage___s__s__device_id__all_00003050": "USAGE_STRING",
                "PTR_DAT_00003054": "BYTE_DATA",
                "compare_bytes_00004e52": "compare_bytes",
                "read_data_from_all_devices_00002f30": "read_data_from_all_devices",
                "parse_string_to_uint_wrapper_00004042": "parse_string_to_uint_wrapper",
                "find_nth_element_00003d24": "find_nth_element",
                "process_input": "handle_error",
                "PTR_s_error__undefined_device_id_given_00003058": "UNDEFINED_DEVICE_ID_ERROR"
            },
            "code": "void process_device_data_00002fe0(int num_params, undefined4 *params)\n{\n  int num_bytes;\n  undefined4 device_id;\n\n  if (num_params < 3) {\n    process_data(PTR_s_usage___s__s__device_id__all_00003050, *params, params[1]);\n  }\n  else {\n    num_bytes = compare_bytes(params[2], PTR_DAT_00003054);\n    if (num_bytes == 0) {\n      read_data_from_all_devices();\n    }\n    else {\n      device_id = parse_string_to_uint_wrapper(params[2]);\n      num_bytes = find_nth_element(device_id);\n      if (num_bytes == 0) {\n        process_input(PTR_s_error__undefined_device_id_given_00003058);\n      }\n      else {\n        read_data_from_device(device_id, num_bytes);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00004e52",
                "FUN_00002ecc",
                "FUN_00002f30",
                "FUN_00003d24",
                "FUN_00004042"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002fe0",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "process_device_data_00002fe0"
        },
        "FUN_00001dc0": {
            "renaming": {
                "FUN_00001dc0": "extract_last_six_bits_00001dc0",
                "param_1": "value",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "ushort extract_last_six_bits_00001dc0(ushort value)\n{\n    ushort last_six_bits = value & 0x3f;\n    return last_six_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001dc0",
            "calling": [
                "FUN_00001f80",
                "FUN_00001ff6",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "extract_last_six_bits_00001dc0"
        },
        "FUN_00000df4": {
            "renaming": {
                "FUN_00000df4": "store_input_value_00000df4",
                "PTR_check_and_increment_difference_000012b4_1_00000e10": "check_and_increment",
                "DAT_00000e0c": "difference",
                "store_input_value_000013b8": "store_input_value",
                "0": "input_num",
                "0x1c200": "value"
            },
            "code": "void store_input_value_00000df4(int input_num, int value, int (*PTR_check_and_increment_DAT_00000e0c_000012b4_1_00000e10)(int), int DAT_00000e0c) {\n  store_input_value_00000df4(input_num, value, PTR_check_and_increment_DAT_00000e0c_000012b4_1_00000e10, DAT_00000e0c);\n  return;\n}",
            "called": [
                "FUN_000013b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000df4",
            "calling": [
                "FUN_00000410"
            ],
            "imported": false,
            "current_name": "store_input_value_00000df4"
        },
        "FUN_00002400": {
            "renaming": {
                "FUN_00002400": "do_nothing_00002400"
            },
            "code": "\nvoid do_nothing_00002400(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002400",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "do_nothing_00002400"
        },
        "FUN_00002eb4": {
            "renaming": {
                "FUN_00002eb4": "processDataAndReturnSuccess_00002eb4",
                "process_data_0000211c": "processData"
            },
            "code": "int processDataAndReturnSuccess_00002eb4() {\n  processData();\n  return 0;\n}",
            "called": [
                "FUN_0000211c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002eb4",
            "calling": [],
            "imported": false,
            "current_name": "processDataAndReturnSuccess_00002eb4"
        },
        "FUN_0000328c": {
            "renaming": {
                "FUN_0000328c": "calculate_values_and_results_0000328c",
                "param_1": "input_values",
                "param_2": "output_values",
                "iVar1": "result",
                "local_10": "current_index",
                "local_a": "parsed_value"
            },
            "code": "int calculate_values_and_results_0000328c(int *input_values, int *output_values)\n{\n  int current_index = 0;\n  int parsed_value = parse_string_to_uint(input_values[current_index], &current_index, 10);\n  output_values[5] = parsed_value - 1892;\n  parsed_value = parse_string_to_uint(input_values[current_index] + 1, &current_index, 10);\n  output_values[4] = parsed_value - 1;\n  parsed_value = parse_string_to_uint(input_values[current_index] + 1, &current_index, 10);\n  output_values[3] = parsed_value;\n  parsed_value = parse_string_to_uint(input_values[1], &current_index, 10);\n  output_values[2] = parsed_value;\n  parsed_value = parse_string_to_uint(input_values[current_index] + 1, &current_index, 10);\n  output_values[1] = parsed_value;\n  parsed_value = parse_string_to_uint(input_values[current_index] + 1, &current_index, 10);\n  output_values[0] = parsed_value;\n  int result = calculate_result(output_values[5] + 1892, output_values[4] + 1, output_values[3]);\n  output_values[6] = result;\n  output_values[8] = -1;\n  return 0;\n}",
            "called": [
                "FUN_00004f84",
                "FUN_000031fc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000328c",
            "calling": [
                "FUN_000033f4",
                "FUN_00003478"
            ],
            "imported": false,
            "current_name": "calculate_values_and_results_0000328c"
        },
        "FUN_000041f4": {
            "renaming": {
                "FUN_000041f4": "initialize_data_000041f4",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2",
                "puVar1": "pointerVar1"
            },
            "code": "void initialize_data_000041f4(undefined4 *data, undefined2 value1, undefined2 value2) {\n    data[0] = 0;\n    data[1] = 0;\n    data[2] = 0;\n    data[3] = value1;\n    data[4] = 0;\n    data[5] = 0;\n    data[6] = 0;\n    data[7] = 0;\n    data[8] = data;\n    data[9] = PTR_compareAndCopyWrapper_00004dc8_1_0000422c;\n    data[10] = DAT_00004230;\n    data[11] = PTR_set_parameter_00004e26_1_00004234;\n    data[12] = PTR_LAB_00004e4a_1_00004238;\n}",
            "called": [
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041f4",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "initialize_data_000041f4"
        },
        "FUN_0000316c": {
            "renaming": {
                "FUN_0000316c": "process_device_data_0000316c",
                "param_1": "device_count",
                "param_2": "device_data",
                "iVar1": "comparison_result",
                "print_devices_info_00002f74": "print_devices_info",
                "compare_bytes_00004e52": "compare_bytes",
                "PTR_DAT_000031d4": "PTR_DAT_000031d4",
                "process_device_data_00002fe0": "process_device_data_00002fe0",
                "PTR_s_write_000031d8": "PTR_s_write_000031d8",
                "process_device_data_0000305c": "process_device_data_0000305c",
                "process_data_00004c84": "process_data_00004c84",
                "PTR_s_usage___s_read_write_000031dc": "PTR_s_usage___s_read_write_000031dc"
            },
            "code": "int process_device_data_0000316c(int device_count, unsigned int *device_data)\n{\n  int comparison_result;\n  if (device_count < 2) {\n    print_devices_info();\n  }\n  else {\n    comparison_result = compare_bytes(device_data[1],PTR_DAT_000031d4);\n    if (comparison_result == 0) {\n      process_device_data_0000316c_00002fe0(device_count,device_data);\n    }\n    else {\n      comparison_result = compare_bytes(device_data[1],PTR_s_write_000031d8);\n      if (comparison_result == 0) {\n        process_device_data_0000316c_0000305c(device_count,device_data);\n      }\n      else {\n        process_data_00004c84(PTR_s_usage___s_read_write_000031dc,*device_data);\n      }\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00004e52",
                "FUN_00002fe0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000316c",
            "calling": [],
            "imported": false,
            "current_name": "process_device_data_0000316c"
        },
        "FUN_000026f0": {
            "renaming": {
                "FUN_000026f0": "executeFunctionIfNotNull_000026f0",
                "param_1": "functionPtr",
                "PTR_DAT_00002710": "functionPtr",
                "int": "int",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void executeFunctionIfNotNull_000026f0(int* PTR_DAT_00002710) {\n  if (*PTR_DAT_00002710 != 0) {\n    (**(void (**)())PTR_DAT_00002710)();\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026f0",
            "calling": [],
            "imported": false,
            "current_name": "executeFunctionIfNotNull_000026f0"
        },
        "FUN_000057d2": {
            "renaming": {
                "FUN_000057d2": "process_input_000057d2",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input_str",
                "param_4": "input_len",
                "puVar2": "end_of_input",
                "iVar3": "index"
            },
            "code": "int process_input_000057d2(int input1, int input2, char *input_str, int input_len)\n{\n  int index = 0;\n  char *end_of_input = input_str + input_len;\n  do {\n    if (input_str == end_of_input) {\n      return 0;\n    }\n    index = process_input_000057d2_000057a8(input1, *input_str, input2, input_len, index);\n    input_len = index + 1;\n    input_str++;\n  } while (input_len != 0);\n  return index;\n}\n",
            "called": [
                "FUN_000057a8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057d2",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "process_input_000057d2"
        },
        "FUN_000056b8": {
            "renaming": {
                "FUN_000056b8": "set_flag_and_return_status_000056b8",
                "param_1": "input_value",
                "param_2": "input_array",
                "param_3": "flag",
                "param_4": "status",
                "iVar1": "result",
                "uVar2": "status_value",
                "auStack_68": "flag_value",
                "local_64": "local_value"
            },
            "code": "int set_flag_and_return_status_000056b8(int param_1, int param_2, int *flag, uint *status) {\n  int result;\n  int flag_value;\n  uint status_value;\n  if (*(short *)(param_2 + 0xe) < 0 || (result = set_flag_value(param_1, (int)*(short *)(param_2 + 0xe), &flag_value)) < 0) {\n    *status = 0;\n    if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x18) < 0) {\n      status_value = 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    *flag = (flag_value & 0xf000) == 0x2000;\n  }\n  status_value = 0x400;\nLAB_000056f8:\n  *status = status_value;\n  return 0;\n}",
            "called": [
                "FUN_00000514"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b8",
            "calling": [
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "set_flag_and_return_status_000056b8"
        },
        "FUN_00001a18": {
            "renaming": {
                "FUN_00001a18": "set_result_and_terminate_string_00001a18",
                "DAT_00001a34": "result",
                "PTR_DAT_00001a38": "ptr_data",
                "set_result_to_one_000016ec": "set_result_to_one",
                "null_terminate_string_00001734": "null_terminate_string"
            },
            "code": "void set_result_and_terminate_string_00001a18(void)\n{\n  set_DAT_00001a34_to_one(DAT_00001a34, 1);\n  null_terminate_string();\n  *PTR_DAT_00001a38 = 4;\n  return;\n}",
            "called": [
                "FUN_00001734",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a18",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_result_and_terminate_string_00001a18"
        },
        "FUN_00000d9c": {
            "renaming": {
                "FUN_00000d9c": "set_calculated_value_to_zero_00000d9c",
                "DAT_00000dac": "DAT_calculated_value",
                "set_calculated_value_to_zero_00000d76": "set_calculated_value_to_zero"
            },
            "code": "void set_calculated_value_to_zero_00000d9c(void)\n{\n  set_calculated_value_to_zero_00000d9c(DAT_00000dac,0);\n  return;\n}",
            "called": [
                "FUN_00000d76"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d9c",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": false,
            "current_name": "set_calculated_value_to_zero_00000d9c"
        },
        "FUN_00003ff4": {
            "renaming": {
                "FUN_00003ff4": "reverse_copy_and_fill_00003ff4",
                "param_1": "array_size",
                "param_2": "start_index",
                "param_3": "end_index",
                "param_4": "fill_value",
                "uVar1": "new_end_index"
            },
            "code": "uint reverse_copy_and_fill_00003ff4(uint array_size, uint start_index, uint end_index, undefined fill_value)\n{\n  uint new_end_index;\n  if ((start_index < end_index) && (array_size != 0)) {\n    new_end_index = end_index - start_index + array_size;\n    reverse_copy(start_index, end_index, new_end_index);\n    fill_array_with_value(start_index, fill_value, end_index - start_index);\n  }\n  else {\n    new_end_index = end_index;\n  }\n  return new_end_index;\n}",
            "called": [
                "FUN_000045ee",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ff4",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": false,
            "current_name": "reverse_copy_and_fill_00003ff4"
        },
        "FUN_00004634": {
            "renaming": {
                "FUN_00004634": "FUNC_00004634"
            },
            "code": "\nvoid FUNC_00004634(uint *param_1,uint param_2,undefined4 param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  bool bVar6;\n  uint *local_20;\n  uint local_1c;\n  undefined4 uStack_18;\n  \n  local_20 = param_1;\n  local_1c = param_2;\n  uStack_18 = param_3;\n  if (0x3b < *param_1) {\n    divide_and_remainder_00005584(&local_20,*param_1,0x3c);\n    uVar3 = param_1[1] + (int)local_20;\n    param_1[1] = uVar3;\n    if ((int)local_1c < 0) {\n      uVar3 = uVar3 - 1;\n      *param_1 = local_1c + 0x3c;\n    }\n    else {\n      *param_1 = local_1c;\n    }\n    if ((int)local_1c < 0) {\n      param_1[1] = uVar3;\n    }\n  }\n  if (0x3b < param_1[1]) {\n    divide_and_remainder_00005584(&local_20,param_1[1],0x3c);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[2] + (int)local_20;\n    param_1[2] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x3c;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar4;\n    }\n  }\n  if (0x17 < param_1[2]) {\n    divide_and_remainder_00005584(&local_20,param_1[2],0x18);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[3] + (int)local_20;\n    param_1[3] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x18;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[3] = uVar4;\n    }\n  }\n  if (0xb < param_1[4]) {\n    divide_and_remainder_00005584(&local_20,param_1[4],0xc);\n    bVar6 = (int)local_1c < 0;\n    uVar3 = param_1[5] + (int)local_20;\n    param_1[5] = uVar3;\n    if (bVar6) {\n      local_1c = local_1c + 0xc;\n      uVar3 = uVar3 - 1;\n    }\n    if (!bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[5] = uVar3;\n    }\n  }\n  puVar1 = PTR_DAT_000047e0;\n  uVar3 = param_1[5];\n  if ((uVar3 & 3) == 0) {\n    if (uVar3 == (uVar3 / 100) * 100) {\n      if ((uVar3 + 0x76c) % 400 == 0) {\n        iVar5 = 0x1d;\n      }\n      else {\n        iVar5 = 0x1c;\n      }\n    }\n    else {\n      iVar5 = 0x1d;\n    }\n  }\n  else {\n    iVar5 = 0x1c;\n  }\n  if ((int)param_1[3] < 1) {\n    while ((int)param_1[3] < 1) {\n      uVar3 = param_1[4];\n      param_1[4] = uVar3 - 1;\n      if (uVar3 - 1 == 0xffffffff) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 - 1;\n        param_1[4] = 0xb;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 == (uVar3 / 100) * 100) {\n            if ((uVar4 + 0x76b) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n      iVar2 = iVar5;\n      if (param_1[4] != 1) {\n        iVar2 = *(int *)(puVar1 + param_1[4] * 4);\n      }\n      param_1[3] = iVar2 + param_1[3];\n    }\n  }\n  else {\n    while( true ) {\n      uVar3 = param_1[4];\n      iVar2 = iVar5;\n      if (uVar3 != 1) {\n        iVar2 = *(int *)(puVar1 + uVar3 * 4);\n      }\n      if ((int)param_1[3] <= iVar2) break;\n      param_1[3] = param_1[3] - iVar2;\n      param_1[4] = uVar3 + 1;\n      if (uVar3 + 1 == 0xc) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 + 1;\n        param_1[4] = 0;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 % 100 == 0) {\n            if ((uVar4 + 0x76d) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005584"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00004634",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "FUNC_00004634"
        },
        "FUN_00001d5e": {
            "renaming": {
                "FUN_00001d5e": "extractBits_00001d5e",
                "param_1": "input"
            },
            "code": "uint16_t extractBits_00001d5e(ushort input) {\n    uint16_t mask = 0x7000;\n    uint16_t result = input & mask;\n    uint16_t constant = 0x40048000;\n    return result | constant;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d5e",
            "calling": [
                "FUN_00001f80",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "extractBits_00001d5e"
        },
        "FUN_0000191c": {
            "renaming": {
                "FUN_0000191c": "setFlagAndNullTerminate_0000191c",
                "set_flag_and_null_terminate_00001778": "setFlag",
                "setParamValue_00001748": "setParamValue",
                "*DAT_00001958": "*data",
                "*PTR_DAT_0000195c": "*ptrData"
            },
            "code": "void setFlagAndNullTerminate_0000191c() {\n    setFlag();\n    setParamValue(64);\n    *DAT_00001958 = *DAT_00001958 & 59;\n    while ((data[6] & 12) != 0) {\n    }\n    *PTR_DAT_0000195c = 1;\n    return;\n}",
            "called": [
                "FUN_00001778",
                "FUN_00001748"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000191c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "setFlagAndNullTerminate_0000191c"
        },
        "FUN_000050f4": {
            "renaming": {
                "FUN_000050f4": "get_pointer_000050f4",
                "PTR_DAT_000050fc": "pointer_data"
            },
            "code": "const char* get_pointer_000050f4() {\n  return PTR_DAT_000050fc;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050f4",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_pointer_000050f4"
        },
        "FUN_00005a58": {
            "renaming": {
                "FUN_00005a58": "encode_string_00005a58",
                "param_1": "param_length",
                "param_2": "param_array",
                "param_3": "output_length",
                "param_4": "param_4",
                "param_5": "encoder",
                "iVar1": "status",
                "uVar2": "return_value",
                "uVar3": "max_length",
                "uVar4": "loop_counter",
                "bVar5": "is_loop_counter_four",
                "extra_length": "extra_length",
                "remaining_length": "remaining_length"
            },
            "code": "undefined4 encode_string_00005a58(uint32_t param_length, uint32_t *param_array, uint32_t *output_length, uint32_t param_4, code *encoder)\\n\\\n    {\\n\\\n        int status;\\n\\\n        undefined4 return_value;\\n\\\n        uint32_t max_length = (param_array[4] < param_array[2]) ? param_array[2] : param_array[4];\\n\\\n        *output_length = max_length;\\n\\\n        if (*(char *)((int)param_array + 0x43) != \"\\0\")\\n\\\n        {\\n\\\n            *output_length = max_length + 1;\\n\\\n        }\\n\\\n        if ((int)(*param_array << 0x1a) < 0)\\n\\\n        {\\n\\\n            *output_length += 2;\\n\\\n        }\\n\\\n        uint32_t loop_counter = *param_array & 6;\\n\\\n        if (loop_counter == 0)\\n\\\n        {\\n\\\n            for (; loop_counter < (param_array[3] - *output_length); loop_counter++)\\n\\\n            {\\n\\\n                status = (*encoder)(param_length, param_4, (int)param_array + 0x19, 1);\\n\\\n                if (status == -1) goto error_label;\\n\\\n            }\\n\\\n        }\\n\\\n        uint32_t extra_length = (*(byte *)((int)param_array + 0x43) != 0) ? 1 : 0;\\n\\\n        if ((int)(*param_array << 0x1a) < 0)\\n\\\n        {\\n\\\n            *(undefined *)((int)param_array + extra_length + 0x43) = 0x30;\\n\\\n            *(undefined *)((int)param_array + extra_length + 0x44) = *(undefined *)((int)param_array + 0x45);\\n\\\n            extra_length += 2;\\n\\\n        }\\n\\\n        status = (*encoder)(param_length, param_4, (int)param_array + 0x43, extra_length);\\n\\\n        if (status == -1) goto error_label;\\n\\\n        uint32_t remaining_length = param_array[3];\\n\\\n        bool is_loop_counter_four = ((*param_array & 6) == 4);\\n\\\n        if (is_loop_counter_four)\\n\\\n        {\\n\\\n            remaining_length -= *output_length;\\n\\\n        }\\n\\\n        if (is_loop_counter_four)\\n\\\n        {\\n\\\n            remaining_length &= ~((int)remaining_length >> 0x1f);\\n\\\n        }\\n\\\n        else\\n\\\n        {\\n\\\n            remaining_length = 0;\\n\\\n        }\\n\\\n        if (param_array[4] < param_array[2])\\n\\\n        {\\n\\\n            remaining_length += (param_array[2] - param_array[4]);\\n\\\n        }\\n\\\n        for (uint32_t i = 0; i < remaining_length; i++)\\n\\\n        {\\n\\\n            status = (*encoder)(param_length, param_4, (int)param_array + 0x1a, 1);\\n\\\n            if (status == -1) goto error_label;\\n\\\n        }\\n\\\n        return_value = 0;\\n\\\n        error_label:\\n\\\n        return return_value;\\n\\\n    }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005a58",
            "calling": [
                "FUN_00005b34"
            ],
            "imported": false,
            "current_name": "encode_string_00005a58"
        },
        "FUN_000056b0": {
            "renaming": {
                "FUN_000056b0": "get_data_000056b0",
                "DAT_000056b4": "data_value"
            },
            "code": "int get_data_000056b0(void)\n{\n    return DAT_000056b4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b0",
            "calling": [
                "FUN_00005100",
                "FUN_00004f98",
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_data_000056b0"
        },
        "FUN_00003d24": {
            "renaming": {
                "FUN_00003d24": "find_nth_element_00003d24",
                "param_1": "n",
                "local_c": "current_element",
                "local_10": "element_count"
            },
            "code": "undefined4 * find_nth_element_00003d24(int n)\n{\n  undefined4 *current_element = *(undefined4 **)PTR_DAT_00003d60;\n  int element_count = 0;\n  while (element_count < n && current_element != (undefined4 *)0x0) {\n    current_element = (undefined4 *)*current_element;\n    element_count++;\n  }\n  return current_element;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d24",
            "calling": [
                "FUN_0000305c",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "find_nth_element_00003d24"
        },
        "FUN_000060cc": {
            "renaming": {
                "FUN_000060cc": "allocate_and_copy_array_000060cc",
                "param_1": "block_size",
                "param_2": "array_start",
                "param_3": "array_length",
                "param_4": "value_to_copy",
                "uVar1": "allocated_block_address",
                "uVar2": "calculated_value"
            },
            "code": "uint allocate_and_copy_array_000060cc(uint block_size, uint array_start, uint array_length, uint value_to_copy)\n{\n  uint allocated_block_address;\n  uint calculated_value;\n\n  if (array_start != 0) {\n    if (array_length == 0) {\n      insert_node_at_end();\n      allocated_block_address = array_length;\n    }\n    else {\n      calculated_value = calculate_value();\n      allocated_block_address = array_start;\n      if ((calculated_value < array_length) && (allocated_block_address = allocate_memory_block(block_size, array_length), allocated_block_address != 0)) {\n        copy_array(allocated_block_address, array_start, array_length);\n        insert_node_at_end(block_size, array_start);\n      }\n    }\n    return allocated_block_address;\n  }\n  allocated_block_address = allocate_memory_block(block_size, array_length, array_length, value_to_copy);\n  return allocated_block_address;\n}",
            "called": [
                "FUN_000060b0",
                "FUN_00006964",
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060cc",
            "calling": [
                "FUN_000068f0"
            ],
            "imported": false,
            "current_name": "allocate_and_copy_array_000060cc"
        },
        "FUN_00003dc4": {
            "renaming": {
                "FUN_00003dc4": "calculate_digits_00003dc4",
                "param_1": "num_digits",
                "param_2": "number",
                "local_20": "max_number",
                "local_14": "digit_ptr",
                "local_10": "remainder",
                "local_c": "digit_count"
            },
            "code": "int calculate_digits_00003dc4(int num_digits, uint number) {\n  uint max_number = DAT_00003e50;\n  uint remainder;\n  char *digit_ptr;\n  int digit_count;\n  \n  digit_count = 1;\n  if (max_number < number) {\n    digit_count = 10;\n  }\n  else {\n    for (remainder = 10; remainder <= number; remainder = remainder * 10) {\n      digit_count++;\n    }\n  }\n  if (num_digits != 0) {\n    digit_ptr = (char *)(digit_count + num_digits);\n    remainder = number;\n    do {\n      digit_ptr--;\n      *digit_ptr = (char)remainder + (char)(uint)((ulonglong)DAT_00003e54 * (ulonglong)remainder >> 0x23) * -10 + '0';\n      remainder = (uint)((ulonglong)DAT_00003e54 * (ulonglong)remainder >> 0x23);\n    } while (remainder != 0);\n  }\n  return digit_count;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003dc4",
            "calling": [
                "FUN_00003e58"
            ],
            "imported": false,
            "current_name": "calculate_digits_00003dc4"
        },
        "FUN_000022be": {
            "renaming": {
                "FUN_000022be": "increment_and_store_value_at_address_000022be",
                "param_1": "memory_address",
                "param_2": "value_to_store",
                "uVar1": "index",
                "DAT_00000404": "offset",
                "PTR_DAT_00000400": "memory_location"
            },
            "code": "void increment_and_store_value_at_address_000022be(int *memory_address, int value_to_store) {\n    uint index = memory_address[3];\n    memory_address[3] = index + 1;\n    uint DAT_00000404 = index & (memory_address[1] - 1U);\n    uint PTR_DAT_00000400 = *memory_address + DAT_00000404;\n    *(int *)(PTR_DAT_00000400) = value_to_store;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022be",
            "calling": [
                "FUN_00002364"
            ],
            "imported": false,
            "current_name": "increment_and_store_value_at_address_000022be"
        },
        "FUN_00002108": {
            "renaming": {
                "FUN_00002108": "decode_and_process_data_00002108",
                "DAT_00002118": "PTR_data_to_decode",
                "decode_data_00002028": "decode_data"
            },
            "code": "void decode_and_process_data_00002108(void)\n{\n  decode_data(DAT_00002118, 4);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002108",
            "calling": [],
            "imported": false,
            "current_name": "decode_and_process_data_00002108"
        },
        "FUN_00001d80": {
            "renaming": {
                "FUN_00001d80": "getFlaggedValue_00001d80",
                "param_1": "value",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "uint16_t getFlaggedValue_00001d80(ushort value) {\n    uint16_t mask = 0x1c0;\n    uint16_t flag = 0x400ff000;\n    return (value & mask) | flag;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d80",
            "calling": [
                "FUN_00001ff6",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "getFlaggedValue_00001d80"
        },
        "FUN_000033c0": {
            "renaming": {
                "FUN_000033c0": "check_alarm_and_return_zero_000033c0",
                "iVar1": "date_calculation_result",
                "auStack_2c": "alarm_data",
                "calculate_date_and_return_zero_00002690": "calculate_date",
                "process_input": "report_error",
                "PTR_s_rtc__error_getting_alarm_000033f0": "PTR_s_rtc__error_getting_alarm_000033f0",
                "process_data_00003378": "process_alarm_data"
            },
            "code": "bool check_alarm_and_return_zero_000033c0(void)\n{\n  int date_calculation_result;\n  undefined alarm_data[36];\n  date_calculation_result = calculate_date(alarm_data);\n  if (date_calculation_result != 0) {\n    report_error(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    process_alarm_data(alarm_data);\n  }\n  return date_calculation_result != 0;\n}",
            "called": [
                "FUN_00003378",
                "FUN_00004db8",
                "FUN_00002690"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "check_alarm_and_return_zero_000033c0",
            "code_backup": "\nbool FUN_000033c0(void)\n\n{\n  int iVar1;\n  undefined auStack_2c [36];\n  \n  iVar1 = calculate_date_and_return_zero_00002690(auStack_2c);\n  if (iVar1 != 0) {\n    process_input(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    process_data_00003378(auStack_2c);\n  }\n  return iVar1 != 0;\n}\n\n"
        },
        "FUN_00002b10": {
            "renaming": {
                "FUN_00002b10": "parse_command_line_args_00002b10",
                "param_1": "num_args",
                "param_2": "args",
                "local_48": "arg_pointers",
                "local_3c": "matching_command",
                "local_38": "arg_list",
                "local_34": "arg_index",
                "local_2d": "quote_type",
                "local_2c": "escaped_char",
                "local_28": "current_char",
                "local_24": "arg",
                "local_20": "i",
                "local_1c": "escaped_char_count",
                "local_18": "arg_count",
                "local_14": "current_arg"
            },
            "code": "void parse_command_line_args_00002b10(uint32_t num_args, char** args) {\\n    int arg_count = 0;\\n    int escaped_char_count = 0;\\n    char* current_arg = *args;\\n    while (*current_arg != \"\\0\") {\\n        if (*current_arg > 0x20) {\\n            if (*current_arg == \"\\\"\" || *current_arg == \"\\\"\") {\\n                char quote_type = *current_arg;\\n                do {\\n                    current_arg++;\\n                    if (*current_arg == \"\\0\") {\\n                        print_command_not_found_error();\\n                        return;\\n                    }\\n                    if (*current_arg == \"\\\\\") {\\n                        escaped_char_count++;\\n                        current_arg++;\\n                        if (*current_arg == \"\\0\") {\\n                            print_command_not_found_error();\\n                            return;\\n                        }\\n                    }\\n                } while (quote_type != *current_arg);\\n                if (*(current_arg + 1) > 0x20) {\\n                    print_command_not_found_error();\\n                    return;\\n                }\\n            }\\n            else {\\n                while (*current_arg != \"\\0\" && *current_arg != \"\\\"\") {\\n                    if (*current_arg == \"\\\\\") {\\n                        escaped_char_count++;\\n                        current_arg++;\\n                        if (*current_arg == \"\\0\") {\\n                            print_command_not_found_error();\\n                            return;\\n                        }\\n                    }\\n                    current_arg++;\\n                }\\n                arg_count++;\\n            }\\n        }\\n        if (*current_arg == \"\\0\") {\\n            break;\\n        }\\n        *current_arg = \"\\0\";\\n        current_arg++;\\n    }\\n    if (arg_count > 0) {\\n        char** arg_list = (char**)((int)args - ((arg_count + 1) * 4 + 7 & 0xfffffff8));\\n        arg_list[arg_count] = (char*)0x0;\\n        current_arg = *args;\\n        for (int i = 0; i < arg_count; i++) {\\n            while (*current_arg == \"\\0\") {\\n                current_arg++;\\n            }\\n            if (*current_arg == \"\\\"\" || *current_arg == \"\\\"\") {\\n                current_arg++;\\n            }\\n            arg_list[i] = current_arg;\\n            while (*current_arg != \"\\0\") {\\n                current_arg++;\\n            }\\n        }\\n        for (char** arg = arg_list; *arg != (char*)0x0 && escaped_char_count > 0; arg++) {\\n            for (char* c = *arg; *c != \"\\0\"; c++) {\\n                if (*c == \"\\\\\") {\\n                    for (char* d = c; *d != \"\\0\"; d++) {\\n                        *d = *(d + 1);\\n                    }\\n                    escaped_char_count--;\\n                    if (escaped_char_count == 0) {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        code* matching_command = find_matching_command(num_args, arg_list);\\n        if (matching_command == (code*)0x0) {\\n            if (compare_bytes(PTR_DAT_00002d8c, arg_list) == 0) {\\n                print_command_descriptions();\\n            }\\n            else {\\n                print_command_not_found_error();\\n            }\\n        }\\n        else {\\n            (*matching_command)(arg_count, arg_list);\\n        }\\n    }\\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00002a88",
                "FUN_00004db8",
                "FUN_00004e52",
                "FUN_00002a18"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002b10",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "parse_command_line_args_00002b10"
        },
        "FUN_00001b10": {
            "renaming": {
                "FUN_00001b10": "execute_command_00001b10",
                "param_1": "command_index",
                "uVar1": "result",
                "PTR_DAT_00001bb4": "commands",
                "PTR_DAT_00001bb0": "command_count_pointer",
                "set_param_value_and_terminate_string_000018bc": "set_param_value_and_terminate_string",
                "setFlagAndNullTerminate_0000191c": "set_flag_and_null_terminate",
                "initializeSystem_00001960": "initialize_system",
                "setFlagAndTerminateString_000019c0": "set_flag_and_terminate_string",
                "set_result_and_terminate_string_00001a18": "set_result_and_terminate_string_1",
                "set_result_and_terminate_string_00001a3c": "set_result_and_terminate_string_2",
                "initialize_data_00001a60": "initialize_data",
                "clear_bits_in_data_00001ad4": "clear_bits_in_data"
            },
            "code": "int execute_command_00001b10(byte command_index) {\n  int result;\n  if (command_index >= 8) {\n    result = -1;\n  }\n  else {\n    do {\n      switch(PTR_DAT_00001bb4[command_index + *PTR_DAT_00001bb0 * 8]) {\n        case 0:\n          set_param_value_and_terminate_string();\n          break;\n        case 1:\n          set_flag_and_null_terminate();\n          break;\n        case 2:\n          initialize_system();\n          break;\n        case 3:\n          set_flag_and_terminate_string();\n          break;\n        case 4:\n          set_result_and_terminate_string_1();\n          break;\n        case 5:\n          set_result_and_terminate_string_2();\n          break;\n        case 6:\n          initialize_data();\n          break;\n        case 7:\n          clear_bits_in_data();\n          break;\n        default:\n          return -1;\n      }\n    } while (command_index != *PTR_DAT_00001bb0);\n    result = 0;\n  }\n  return result;\n}",
            "called": [
                "FUN_00001a18",
                "FUN_000019c0",
                "FUN_00001960",
                "FUN_00001ad4",
                "FUN_00001a3c",
                "FUN_0000191c",
                "FUN_000018bc",
                "FUN_00001a60"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001b10",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "execute_command_00001b10"
        },
        "FUN_000047e4": {
            "renaming": {
                "FUN_000047e4": "FUNC_000047e4"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\nundefined8 FUNC_000047e4(int *param_1)\n\n{\n  longlong lVar1;\n  longlong lVar2;\n  int *piVar3;\n  uint uVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  int iVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  uint uVar15;\n  bool bVar16;\n  \n  piVar3 = (int *)get_data_000056b0();\n  FUNC_00004634(param_1);\n  uVar12 = param_1[5];\n  iVar11 = param_1[3] + -1 + *(int *)(PTR_DAT_00004adc + param_1[4] * 4);\n  if (((1 < param_1[4]) && ((uVar12 & 3) == 0)) &&\n     ((uVar12 != (uVar12 / 100) * 100 || (uVar12 + 0x76c == ((uVar12 + 0x76c) / 400) * 400)))) {\n    iVar11 = iVar11 + 1;\n  }\n  param_1[7] = iVar11;\n  if (20000 < (int)&PTR_DAT_00002710 + uVar12) {\n    iVar7 = -1;\n    iVar5 = -1;\n    goto LAB_00004aba;\n  }\n  if ((int)uVar12 < 0x47) {\n    if (uVar12 != 0x46) {\n      for (uVar9 = 0x45; (int)uVar12 < (int)uVar9; uVar9 = uVar9 - 1) {\n        if ((uVar9 & 3) == 0) {\n          if (uVar9 == (uVar9 / 100) * 100) {\n            if ((uVar9 + 0x76c) % 400 == 0) {\n              iVar7 = 0x16e;\n            }\n            else {\n              iVar7 = 0x16d;\n            }\n          }\n          else {\n            iVar7 = 0x16e;\n          }\n        }\n        else {\n          iVar7 = 0x16d;\n        }\n        iVar11 = iVar11 - iVar7;\n      }\n      if ((uVar9 & 3) == 0) {\n        if (uVar12 == (uVar12 / 100) * 100) {\n          iVar7 = 0x16d;\n          if ((uVar12 + 0x76c) % 400 == 0) {\n            iVar7 = 0x16e;\n          }\n        }\n        else {\n          iVar7 = 0x16e;\n        }\n      }\n      else {\n        iVar7 = 0x16d;\n      }\n      iVar11 = iVar11 - iVar7;\n    }\n  }\n  else {\n    uVar9 = 0x46;\n    do {\n      if ((uVar9 & 3) == 0) {\n        if (uVar9 % 100 == 0) {\n          if ((uVar9 + 0x76c) % 400 == 0) {\n            iVar7 = 0x16e;\n          }\n          else {\n            iVar7 = 0x16d;\n          }\n        }\n        else {\n          iVar7 = 0x16e;\n        }\n      }\n      else {\n        iVar7 = 0x16d;\n      }\n      uVar9 = uVar9 + 1;\n      iVar11 = iVar11 + iVar7;\n    } while (uVar12 != uVar9);\n  }\n  lVar1 = (longlong)DAT_00004ae0 * (longlong)iVar11 +\n          (longlong)(param_1[2] * 0xe10 + param_1[1] * 0x3c + *param_1);\n  uVar15 = (uint)lVar1;\n  iVar7 = (int)((ulonglong)lVar1 >> 0x20);\n  get_pointer_to_data_000050e8();\n  FUNC_00005100();\n  uVar9 = *(uint *)PTR_DAT_00004ae4;\n  if (*(uint *)PTR_DAT_00004ae4 == 0) {\nLAB_00004934:\n    uVar12 = piVar3[10];\n    iVar7 = (uint)lVar1 + uVar12;\n    iVar5 = (int)((ulonglong)lVar1 >> 0x20) +\n            ((int)uVar12 >> 0x1f) + (uint)CARRY4((uint)lVar1,uVar12);\n  }\n  else {\n    uVar14 = param_1[8];\n    uVar13 = uVar14;\n    if (0 < (int)uVar14) {\n      uVar13 = 1;\n    }\n    if ((piVar3[1] == param_1[5] + 0x76c) || (iVar5 = calculate_day_of_week_00004f98(), iVar5 != 0)) {\n      uVar10 = piVar3[0x14];\n      uVar4 = piVar3[0x12];\n      uVar8 = piVar3[10];\n      uVar9 = uVar4 - uVar8;\n      iVar5 = (piVar3[0x13] - ((int)uVar8 >> 0x1f)) - (uint)(uVar4 < uVar8);\n      if (((int)((iVar7 - iVar5) - (uint)(uVar15 < uVar9)) < 0 ==\n           (SBORROW4(iVar7,iVar5) != SBORROW4(iVar7 - iVar5,(uint)(uVar15 < uVar9)))) &&\n         (iVar6 = (piVar3[0x13] - ((int)uVar10 >> 0x1f)) - (uint)(uVar4 < uVar10),\n         bVar16 = uVar15 < uVar4 - uVar10,\n         (int)((iVar7 - iVar6) - (uint)bVar16) < 0 !=\n         (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)bVar16)))) goto LAB_00004a88;\n      uVar4 = piVar3[8] - uVar10;\n      iVar6 = (piVar3[9] - ((int)uVar10 >> 0x1f)) - (uint)((uint)piVar3[8] < uVar10);\n      if (*piVar3 != 0) {\n        if ((int)((iVar7 - iVar6) - (uint)(uVar15 < uVar4)) < 0 ==\n            (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)(uVar15 < uVar4))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        uVar9 = 0;\n        if ((int)uVar14 < 0) goto LAB_00004934;\nLAB_00004a14:\n        uVar15 = uVar13 ^ uVar9;\n        uVar13 = uVar9;\n        if (uVar15 == 1) {\n          if (uVar9 == 0) {\n            iVar7 = uVar10 - uVar8;\n          }\n          else {\n            iVar7 = uVar8 - uVar10;\n          }\n          iVar5 = param_1[3];\n          *param_1 = *param_1 + iVar7;\n          lVar2 = lVar1 + iVar7;\n          FUNC_00004634(param_1);\n          iVar5 = param_1[3] - iVar5;\n          lVar1 = lVar1 + iVar7;\n          if (iVar5 != 0) {\n            if (iVar5 < 2) {\n              if (iVar5 == -2 || iVar5 + 2 < 0 != SCARRY4(iVar5,2)) {\n                iVar5 = 1;\n              }\n            }\n            else {\n              iVar5 = -1;\n            }\n            iVar7 = iVar5 + param_1[7];\n            iVar11 = iVar11 + iVar5;\n            if (iVar7 < 0) {\n              uVar9 = uVar12 - 1;\n              if ((uVar9 & 3) == 0) {\n                if (uVar9 == (uVar9 / 100) * 100) {\n                  iVar7 = 0x16d;\n                  if ((uVar12 + 0x76b) % 400 != 0) {\n                    iVar7 = 0x16c;\n                  }\n                }\n                else {\n                  iVar7 = 0x16d;\n                }\n              }\n              else {\n                iVar7 = 0x16c;\n              }\n            }\n            else {\n              if ((uVar12 & 3) == 0) {\n                if (uVar12 == (uVar12 / 100) * 100) {\n                  iVar5 = 0x16d;\n                  if ((uVar12 + 0x76c) % 400 == 0) {\n                    iVar5 = 0x16e;\n                  }\n                }\n                else {\n                  iVar5 = 0x16e;\n                }\n              }\n              else {\n                iVar5 = 0x16d;\n              }\n              if (iVar5 <= iVar7) {\n                iVar7 = iVar7 - iVar5;\n              }\n            }\n            param_1[7] = iVar7;\n            lVar1 = lVar2;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((iVar7 - iVar6) - (uint)(uVar15 < uVar4)) < 0 !=\n          (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)(uVar15 < uVar4)))) {\nLAB_0000491e:\n        if ((int)((iVar7 - iVar5) - (uint)(uVar15 < uVar9)) < 0 ==\n            (SBORROW4(iVar7,iVar5) != SBORROW4(iVar7 - iVar5,(uint)(uVar15 < uVar9))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)uVar14) {\n        uVar9 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      uVar9 = uVar13;\n      if (uVar13 != 1) goto LAB_00004934;\n    }\n    uVar12 = piVar3[0x14];\n    iVar7 = (uint)lVar1 + uVar12;\n    iVar5 = (int)((ulonglong)lVar1 >> 0x20) +\n            ((int)uVar12 >> 0x1f) + (uint)CARRY4((uint)lVar1,uVar12);\n    uVar9 = 1;\n  }\n  get_pointer_000050f4();\n  param_1[8] = uVar9;\n  param_1[6] = (iVar11 + 4U) % 7;\nLAB_00004aba:\n  return CONCAT44(iVar5,iVar7);\n}\n\n",
            "called": [
                "FUN_00004634",
                "FUN_000050e8",
                "FUN_00005100",
                "FUN_00004f98",
                "FUN_000056b0",
                "FUN_000050f4"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000047e4",
            "calling": [
                "FUN_00002600",
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "FUNC_000047e4"
        },
        "FUN_000023c8": {
            "renaming": {
                "FUN_000023c8": "trigger_software_interrupt_000023c8"
            },
            "code": "void trigger_software_interrupt_000023c8(void)\n{\n  software_interrupt(0x3f);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023c8",
            "calling": [
                "FUN_000023d0"
            ],
            "imported": false,
            "current_name": "trigger_software_interrupt_000023c8"
        },
        "FUN_00002e48": {
            "renaming": {
                "FUN_00002e48": "process_input_and_data_00002e48",
                "process_input_and_return_00002a00": "process_input",
                "process_data_000041d0": "process_data",
                "*DAT_00002e68": "*data_ptr",
                "*(undefined4 *)(*DAT_00002e68 + 8)": "data"
            },
            "code": "process_input_and_data_00002e48vprocess_input_and_data_00002e48oprocess_input_and_data_00002e48iprocess_input_and_data_00002e48dprocess_input_and_data_00002e48 process_input_and_data_00002e48pprocess_input_and_data_00002e48rprocess_input_and_data_00002e48oprocess_input_and_data_00002e48cprocess_input_and_data_00002e48eprocess_input_and_data_00002e48sprocess_input_and_data_00002e48sprocess_input_and_data_00002e48_process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48pprocess_input_and_data_00002e48uprocess_input_and_data_00002e48tprocess_input_and_data_00002e48_process_input_and_data_00002e48aprocess_input_and_data_00002e48nprocess_input_and_data_00002e48dprocess_input_and_data_00002e48_process_input_and_data_00002e48*process_input_and_data_00002e48(process_input_and_data_00002e48uprocess_input_and_data_00002e48nprocess_input_and_data_00002e48dprocess_input_and_data_00002e48eprocess_input_and_data_00002e48fprocess_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48eprocess_input_and_data_00002e48dprocess_input_and_data_00002e484process_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48)process_input_and_data_00002e48(process_input_and_data_00002e48*process_input_and_data_00002e48Dprocess_input_and_data_00002e48Aprocess_input_and_data_00002e48Tprocess_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e482process_input_and_data_00002e48eprocess_input_and_data_00002e486process_input_and_data_00002e488process_input_and_data_00002e48 process_input_and_data_00002e48+process_input_and_data_00002e48 process_input_and_data_00002e488process_input_and_data_00002e48)process_input_and_data_00002e48(process_input_and_data_00002e48vprocess_input_and_data_00002e48oprocess_input_and_data_00002e48iprocess_input_and_data_00002e48dprocess_input_and_data_00002e48)process_input_and_data_00002e48\nprocess_input_and_data_00002e48{process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48tprocess_input_and_data_00002e48 process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48pprocess_input_and_data_00002e48uprocess_input_and_data_00002e48tprocess_input_and_data_00002e481process_input_and_data_00002e48 process_input_and_data_00002e48=process_input_and_data_00002e48 process_input_and_data_00002e480process_input_and_data_00002e48xprocess_input_and_data_00002e483process_input_and_data_00002e48eprocess_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48tprocess_input_and_data_00002e48 process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48pprocess_input_and_data_00002e48uprocess_input_and_data_00002e48tprocess_input_and_data_00002e482process_input_and_data_00002e48 process_input_and_data_00002e48=process_input_and_data_00002e48 process_input_and_data_00002e480process_input_and_data_00002e48xprocess_input_and_data_00002e482process_input_and_data_00002e480process_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48tprocess_input_and_data_00002e48*process_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48(process_input_and_data_00002e48uprocess_input_and_data_00002e48nprocess_input_and_data_00002e48dprocess_input_and_data_00002e48eprocess_input_and_data_00002e48fprocess_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48eprocess_input_and_data_00002e48dprocess_input_and_data_00002e484process_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48)process_input_and_data_00002e48(process_input_and_data_00002e48*process_input_and_data_00002e48Dprocess_input_and_data_00002e48Aprocess_input_and_data_00002e48Tprocess_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e482process_input_and_data_00002e48eprocess_input_and_data_00002e486process_input_and_data_00002e488process_input_and_data_00002e48 process_input_and_data_00002e48+process_input_and_data_00002e48 process_input_and_data_00002e488process_input_and_data_00002e48)process_input_and_data_00002e48_process_input_and_data_00002e48pprocess_input_and_data_00002e48tprocess_input_and_data_00002e48rprocess_input_and_data_00002e48 process_input_and_data_00002e48=process_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48Dprocess_input_and_data_00002e48Aprocess_input_and_data_00002e48Tprocess_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e482process_input_and_data_00002e48eprocess_input_and_data_00002e486process_input_and_data_00002e488process_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48tprocess_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48(process_input_and_data_00002e48uprocess_input_and_data_00002e48nprocess_input_and_data_00002e48dprocess_input_and_data_00002e48eprocess_input_and_data_00002e48fprocess_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48eprocess_input_and_data_00002e48dprocess_input_and_data_00002e484process_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48)process_input_and_data_00002e48(process_input_and_data_00002e48*process_input_and_data_00002e48Dprocess_input_and_data_00002e48Aprocess_input_and_data_00002e48Tprocess_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e482process_input_and_data_00002e48eprocess_input_and_data_00002e486process_input_and_data_00002e488process_input_and_data_00002e48 process_input_and_data_00002e48+process_input_and_data_00002e48 process_input_and_data_00002e488process_input_and_data_00002e48)process_input_and_data_00002e48 process_input_and_data_00002e48=process_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48(process_input_and_data_00002e48*process_input_and_data_00002e48(process_input_and_data_00002e48uprocess_input_and_data_00002e48nprocess_input_and_data_00002e48dprocess_input_and_data_00002e48eprocess_input_and_data_00002e48fprocess_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48eprocess_input_and_data_00002e48dprocess_input_and_data_00002e484process_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48)process_input_and_data_00002e48(process_input_and_data_00002e48*process_input_and_data_00002e48Dprocess_input_and_data_00002e48Aprocess_input_and_data_00002e48Tprocess_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e482process_input_and_data_00002e48eprocess_input_and_data_00002e486process_input_and_data_00002e488process_input_and_data_00002e48 process_input_and_data_00002e48+process_input_and_data_00002e48 process_input_and_data_00002e488process_input_and_data_00002e48)process_input_and_data_00002e48_process_input_and_data_00002e48pprocess_input_and_data_00002e48tprocess_input_and_data_00002e48rprocess_input_and_data_00002e48 process_input_and_data_00002e48+process_input_and_data_00002e48 process_input_and_data_00002e488process_input_and_data_00002e48)process_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48pprocess_input_and_data_00002e48rprocess_input_and_data_00002e48oprocess_input_and_data_00002e48cprocess_input_and_data_00002e48eprocess_input_and_data_00002e48sprocess_input_and_data_00002e48sprocess_input_and_data_00002e48_process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48pprocess_input_and_data_00002e48uprocess_input_and_data_00002e48tprocess_input_and_data_00002e48(process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48pprocess_input_and_data_00002e48uprocess_input_and_data_00002e48tprocess_input_and_data_00002e481process_input_and_data_00002e48)process_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48pprocess_input_and_data_00002e48rprocess_input_and_data_00002e48oprocess_input_and_data_00002e48cprocess_input_and_data_00002e48eprocess_input_and_data_00002e48sprocess_input_and_data_00002e48sprocess_input_and_data_00002e48_process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48pprocess_input_and_data_00002e48uprocess_input_and_data_00002e48tprocess_input_and_data_00002e48(process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48pprocess_input_and_data_00002e48uprocess_input_and_data_00002e48tprocess_input_and_data_00002e482process_input_and_data_00002e48)process_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48pprocess_input_and_data_00002e48rprocess_input_and_data_00002e48oprocess_input_and_data_00002e48cprocess_input_and_data_00002e48eprocess_input_and_data_00002e48sprocess_input_and_data_00002e48sprocess_input_and_data_00002e48_process_input_and_data_00002e48*process_input_and_data_00002e48(process_input_and_data_00002e48uprocess_input_and_data_00002e48nprocess_input_and_data_00002e48dprocess_input_and_data_00002e48eprocess_input_and_data_00002e48fprocess_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48eprocess_input_and_data_00002e48dprocess_input_and_data_00002e484process_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48)process_input_and_data_00002e48(process_input_and_data_00002e48*process_input_and_data_00002e48Dprocess_input_and_data_00002e48Aprocess_input_and_data_00002e48Tprocess_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e482process_input_and_data_00002e48eprocess_input_and_data_00002e486process_input_and_data_00002e488process_input_and_data_00002e48 process_input_and_data_00002e48+process_input_and_data_00002e48 process_input_and_data_00002e488process_input_and_data_00002e48)process_input_and_data_00002e48(process_input_and_data_00002e48*process_input_and_data_00002e48(process_input_and_data_00002e48uprocess_input_and_data_00002e48nprocess_input_and_data_00002e48dprocess_input_and_data_00002e48eprocess_input_and_data_00002e48fprocess_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48eprocess_input_and_data_00002e48dprocess_input_and_data_00002e484process_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48)process_input_and_data_00002e48(process_input_and_data_00002e48*process_input_and_data_00002e48Dprocess_input_and_data_00002e48Aprocess_input_and_data_00002e48Tprocess_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e482process_input_and_data_00002e48eprocess_input_and_data_00002e486process_input_and_data_00002e488process_input_and_data_00002e48 process_input_and_data_00002e48+process_input_and_data_00002e48 process_input_and_data_00002e488process_input_and_data_00002e48)process_input_and_data_00002e48)process_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48rprocess_input_and_data_00002e48eprocess_input_and_data_00002e48tprocess_input_and_data_00002e48uprocess_input_and_data_00002e48rprocess_input_and_data_00002e48nprocess_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48}process_input_and_data_00002e48",
            "called": [
                "FUN_00002a00",
                "FUN_000041d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e48",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "process_input_and_data_00002e48"
        },
        "FUN_00000930": {
            "renaming": {
                "FUN_00000930": "handle_IRQ_interrupt_00000930",
                "get_IRQ_interrupt_status_00000cf0": "get_IRQ_interrupt_status",
                "PTR_": "PTR_ (unchanged)",
                "DAT_": "DAT_ (unchanged)"
            },
            "code": "void handle_IRQ_interrupt_00000930(void)\n{\n  int IRQ_interrupt_status = get_IRQ_interrupt_status();\n  software_interrupt(1);\n  while(1);\n}",
            "called": [
                "FUN_00000cf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000930",
            "calling": [
                "FUN_00000f8c",
                "FUN_00000794"
            ],
            "imported": false,
            "current_name": "handle_IRQ_interrupt_00000930"
        },
        "FUN_00001348": {
            "renaming": {
                "FUN_00001348": "check_flag_and_set_00001348",
                "PTR_DAT_0000135c": "flag_ptr",
                "set_flag_on_0000093c": "set_flag"
            },
            "code": "void check_flag_and_set_00001348(void)\n{\n  int *PTR_DAT_0000135c = (int *)PTR_DAT_0000135c;\n  if (*PTR_DAT_0000135c != 0) {\n    set_flag_on_0000093c();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001348",
            "calling": [
                "FUN_00001628"
            ],
            "imported": false,
            "current_name": "check_flag_and_set_00001348"
        },
        "FUN_00001d3a": {
            "renaming": {
                "FUN_00001d3a": "set_calculated_address_to_one_00001d3a",
                "param_1": "address",
                "param_2": "data",
                "puVar1": "address_ptr"
            },
            "code": "void set_calculated_address_to_one_00001d3a(undefined4 address, undefined data) {\n  undefined4 *address_ptr;\n  address_ptr = (undefined4 *)calculate_address_00001d08(address, data);\n  *address_ptr = 1;\n  return;\n}",
            "called": [
                "FUN_00001d08"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d3a",
            "calling": [
                "FUN_00001ddc"
            ],
            "imported": false,
            "current_name": "set_calculated_address_to_one_00001d3a"
        },
        "FUN_00002434": {
            "renaming": {
                "FUN_00002434": "register_interrupt_handler_00002434",
                "param_1": "interrupt_handler",
                "param_2": "privilege_level",
                "uVar1": "success",
                "iVar2": "interrupt_handler_list"
            },
            "code": "int register_interrupt_handler_00002434(int *interrupt_handler, int privilege_level) {\n    int success = 0;\n    int interrupt_handler_list = *(int *)PTR_DAT_000024b8;\n    if (*interrupt_handler == 0) {\n        *interrupt_handler = -1;\n        enable_IRQ_if_privileged(check_for_enabled_IRQ_interrupts_00000cd0());\n        success = 1;\n    }\n    else if (privilege_level == 0) {\n        enable_IRQ_if_privileged(check_for_enabled_IRQ_interrupts_00000cd0());\n        success = 0;\n    }\n    else {\n        update_list_00000698(interrupt_handler_list, 2);\n        if (*interrupt_handler == -1) {\n            *interrupt_handler = interrupt_handler_list + 8;\n            *(int *)*interrupt_handler = 0;\n        }\n        else {\n            find_next_non_null(interrupt_handler, interrupt_handler_list);\n        }\n        enable_IRQ_if_privileged(check_for_enabled_IRQ_interrupts_00000cd0());\n        set_flag_on_0000093c();\n        success = 1;\n    }\n    return success;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000d0c",
                "FUN_0000093c",
                "FUN_00001034",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002434",
            "calling": [
                "FUN_0000129c"
            ],
            "imported": false,
            "current_name": "register_interrupt_handler_00002434"
        },
        "FUN_00005700": {
            "renaming": {
                "FUN_00005700": "allocate_memory_00005700",
                "param_1": "memory_size",
                "param_2": "memory_block",
                "uVar1": "flag",
                "iVar2": "allocated_block",
                "local_18": "local_size",
                "local_14": "local_block"
            },
            "code": "void allocate_memory_00005700(int memory_size, int *memory_block)\n{\n    ushort flag;\n    int local_size;\n    int *local_block;\n    \n    if ((int)((uint)*(ushort *)(memory_block + 3) << 0x1e) >= 0)\n    {\n        local_size = memory_size;\n        local_block = memory_block;\n        flag = set_flag_and_return_status(memory_size, memory_block, &local_size, &local_block);\n        int allocated_block = allocate_memory_00005700_block(memory_size, local_size);\n        if (allocated_block != 0)\n        {\n            *(undefined **)(memory_size + 0x28) = PTR_DAT_0000577c;\n            *memory_block = allocated_block;\n            *(ushort *)(memory_block + 3) = *(ushort *)(memory_block + 3) | 0x80;\n            memory_block[5] = local_size;\n            memory_block[4] = allocated_block;\n            if ((local_block != (int *)0x0) && (is_valid_input(memory_size, (int)*(short *)((int)memory_block + 0xe)) != 0))\n            {\n                *(ushort *)(memory_block + 3) = *(ushort *)(memory_block + 3) & 0xfffc | 1;\n            }\n            *(ushort *)(memory_block + 3) = flag | *(ushort *)(memory_block + 3);\n            return;\n        }\n        if ((int)(short)*(ushort *)(memory_block + 3) << 0x16 >= 0)\n        {\n            *(ushort *)(memory_block + 3) = *(ushort *)(memory_block + 3) & 0xfffc | 2;\n        }\n    }\n    *memory_block = (int)memory_block + 0x47;\n    memory_block[4] = (int)memory_block + 0x47;\n    memory_block[5] = 1;\n    return;\n}",
            "called": [
                "FUN_00000534",
                "FUN_00004bd0",
                "FUN_000056b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005700",
            "calling": [
                "FUN_000054a8",
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "allocate_memory_00005700"
        },
        "FUN_00002798": {
            "renaming": {
                "FUN_00002798": "check_flag_status_00002798",
                "PTR_DAT_000027ac": "flag_ptr",
                "set_flag_on_0000093c": "set_flag_on"
            },
            "code": "void check_flag_status_00002798(void)\n{\n  int* PTR_DAT_000027ac = (int*)PTR_DAT_000027ac;\n  if (*PTR_DAT_000027ac != 0) {\n    set_flag_on();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002798",
            "calling": [
                "FUN_00002994"
            ],
            "imported": false,
            "current_name": "check_flag_status_00002798"
        },
        "FUN_00003524": {
            "renaming": {
                "FUN_00003524": "process_rtc_command_00003524",
                "param_1": "num_params",
                "param_2": "command_ptr",
                "iVar1": "compare_result",
                "uVar2": "return_value",
                "initialize_rtc_commands_000034c0": "initialize_rtc_commands",
                "compare_strings_00004e66": "compare_strings",
                "PTR_s_poweron_00003638": "PTR_s_poweron",
                "set_flag_and_return_000026d8": "set_power_on_flag_and_return",
                "PTR_s_poweroff_0000363c": "PTR_s_poweroff",
                "clear_bits_in_array_and_return_000026e4": "clear_bits_in_array_and_return",
                "PTR_s_clearalarm_00003640": "PTR_s_clearalarm",
                "reset_and_initialize_data_000026c0": "reset_and_initialize_data",
                "PTR_s_getalarm_00003644": "PTR_s_getalarm",
                "check_alarm_and_return_zero_000033c0": "check_alarm_and_return_zero",
                "PTR_s_setalarm_00003648": "PTR_s_setalarm",
                "calculate_and_execute_alarm_000033f4": "calculate_and_execute_alarm",
                "PTR_s_gettime_0000364c": "PTR_s_gettime",
                "check_date_and_return_false_00003444": "check_date_and_return_false",
                "PTR_s_settime_00003650": "PTR_s_settime",
                "process_data_00004c84": "process_data",
                "PTR_s_unknown_command_or_missing_param_00003654": "PTR_s_unknown_command_or_missing_param",
                "calculate_and_process_00003478_00003478": "calculate_and_process_data"
            },
            "code": "int process_rtc_command_00003524(int num_params, int command_ptr)\n{\n    int compare_result;\n    int return_value;\n    if (num_params < 2) {\n        initialize_rtc_commands();\n        return 1;\n    }\n    compare_result = compare_strings(*(int *)(command_ptr + 4), PTR_s_poweron_00003638_00003638, 7);\n    if (compare_result == 0) {\n        set_power_on_flag_and_return();\n    }\n    else if (compare_result = compare_strings(*(int *)(command_ptr + 4), PTR_s_poweroff_0000363c_0000363c, 8), compare_result == 0) {\n        clear_bits_in_array_and_return();\n    }\n    else if (compare_result = compare_strings(*(int *)(command_ptr + 4), PTR_s_clearalarm_00003640_00003640, 8), compare_result == 0) {\n        reset_and_initialize_data();\n    }\n    else if (compare_result = compare_strings(*(int *)(command_ptr + 4), PTR_s_getalarm_00003644_00003644, 8), compare_result == 0) {\n        check_alarm_and_return_zero();\n    }\n    else if (compare_result = compare_strings(*(int *)(command_ptr + 4), PTR_s_setalarm_00003648_00003648, 8), compare_result == 0 && num_params == 4) {\n        calculate_and_execute_alarm(*(int *)(command_ptr + 8));\n    }\n    else if (compare_result = compare_strings(*(int *)(command_ptr + 4), PTR_s_gettime_0000364c_0000364c, 7), compare_result == 0) {\n        check_date_and_return_false();\n    }\n    else if (compare_result = compare_strings(*(int *)(command_ptr + 4), PTR_s_settime_00003650_00003650, 7), compare_result == 0 && num_params == 4) {\n        calculate_and_process_data(*(int *)(command_ptr + 8));\n    }\n    else {\n        process_data(PTR_s_unknown_command_or_missing_param_00003654_00003654, *(int *)(command_ptr + 4));\n        initialize_rtc_commands();\n        return_value = 1;\n    }\n    return_value = 0;\n    return return_value;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_000026c0",
                "FUN_00003478",
                "FUN_000033f4",
                "FUN_000026d8",
                "FUN_00003444",
                "FUN_00004e66",
                "FUN_000034c0",
                "FUN_000033c0",
                "FUN_000026e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003524",
            "calling": [],
            "imported": false,
            "current_name": "process_rtc_command_00003524"
        },
        "FUN_00001bb8": {
            "renaming": {
                "FUN_00001bb8": "parseDataFromSensor_00001bb8",
                "DAT_00001c74": "sensorData",
                "DAT_00001c78": "sensorName",
                "DAT_00001c7c": "sensorType",
                "PTR_DAT_00001c80": "sensorPointer",
                "null_terminate_string_00001710": "nullTerminateString",
                "setParamValue_00001748": "setParamValue"
            },
            "code": "void parseDataFromSensor_00001bb8(void)\n{\n    if ((DAT_00001c74[1] & 2) != 0) {\n        nullTerminateString(DAT_00001c78, 1);\n    }\n    if ((DAT_00001c74[5] & 0x40) != 0) {\n        if ((*DAT_00001c74 & 0xc0) == 0) {\n            *DAT_00001c74 = *DAT_00001c74 & 0x3f | 0x80;\n            do {\n            } while ((DAT_00001c74[6] & 0xc) != 8);\n        }\n        nullTerminateString(DAT_00001c7c, 6);\n        do {\n        } while ((DAT_00001c74[6] & 0x20) != 0);\n    }\n    setParamValue(0);\n    *DAT_00001c74 = *DAT_00001c74 & 0x3b | 4;\n    do {\n    } while ((DAT_00001c74[6] & 0x10) == 0);\n    do {\n    } while ((DAT_00001c74[6] & 0xc) != 0);\n    *PTR_DAT_00001c80 = 0;\n    return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001bb8",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "parseDataFromSensor_00001bb8"
        },
        "FUN_0000428c": {
            "renaming": {
                "FUN_0000428c": "do_nothing_with_data_0000428c",
                "DAT_00004294": "DAT_data",
                "do_nothing_000045e8": "do_nothing"
            },
            "code": "void do_nothing_with_data_0000428c(void)\n{\n  do_nothing(DAT_00004294);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000428c",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_0000428c"
        },
        "FUN_0000404c": {
            "renaming": {
                "FUN_0000404c": "process_data_0000404c",
                "param_1": "data_ptr",
                "param_2": "state_ptr",
                "iVar1": "data_len",
                "piVar2": "data_handler",
                "uVar3": "data_bitmask",
                "uVar4": "state_bitmask",
                "iVar5": "state_len",
                "pcVar6": "state_handler",
                "iVar7": "state_offset",
                "uVar8": "data_bitmask_copy",
                "bVar9": "data_error",
                "insert_node_at_end_00004b34": "insert_node_at_end"
            },
            "code": "int process_data_0000404c(uint *data_ptr, int *state_ptr) {\n  int data_len;\n  int state_len;\n  uint data_bitmask;\n  ushort state_bitmask;\n  int data_offset = 0;\n  int state_offset = 0;\n  code *data_handler;\n  int data_handler_result;\n  code *state_handler;\n  int state_handler_result;\n  bool data_error = false;\n  bool state_error = false;\n  \n  state_bitmask = *(ushort *)(state_ptr + 3);\n  data_bitmask = (uint)state_bitmask;\n  if ((int)(data_bitmask << 0x1c) < 0) {\n    state_len = state_ptr[4];\n    if (state_len != 0) {\n      data_len = data_bitmask << 0x1e;\n      data_error = data_len == 0;\n      data_handler = *(code **)(&state_ptr[0]);\n      if (data_error) {\n        data_len = state_ptr[5];\n      }\n      state_ptr[0] = state_len;\n      if (!data_error) {\n        data_len = 0;\n      }\n      state_ptr[2] = data_len;\n      for (state_offset = data_offset + state_len; data_offset < state_offset; data_offset += data_len) {\n        data_len = (*(code *)state_ptr[10])(data_ptr, state_ptr[8], state_len, data_offset);\n        if (data_len < 1) {\n          *(ushort *)(state_ptr + 3) = *(ushort *)(state_ptr + 3) | 0x40;\n          return -1;\n        }\n        state_len += data_len;\n      }\n    }\n  }\n  else {\n    if ((state_ptr[1] < 1) && (state_ptr[0x10] < 1)) {\n      return 0;\n    }\n    state_handler = (code *)state_ptr[0xb];\n    if (state_handler == (code *)0x0) {\n      return 0;\n    }\n    data_bitmask = *data_ptr;\n    *data_ptr = 0;\n    if ((state_bitmask & 0x1000) == 0) {\n      data_handler_result = (*state_handler)(data_ptr, state_ptr[8], state_bitmask & 0x1000, 1);\n      if ((data_handler_result == -1) && (*data_ptr != 0)) {\n        if ((*data_ptr == 0x1d) || (*data_ptr == 0x16)) {\n          *data_ptr = data_bitmask;\n          return 0;\n        }\n        state_bitmask = *(ushort *)(state_ptr + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      data_handler_result = state_ptr[0x15];\n    }\n    if (((int)((uint)*(ushort *)(state_ptr + 3) << 0x1d) < 0) &&\n       (data_handler_result = data_handler_result - state_ptr[1], state_ptr[0xd] != 0)) {\n      data_handler_result = data_handler_result - state_ptr[0x10];\n    }\n    state_handler_result = (*(code *)state_ptr[0xb])(data_ptr, state_ptr[8], data_handler_result, 0);\n    state_bitmask = *(ushort *)(state_ptr + 3);\n    if ((state_handler_result == -1) &&\n       ((0x1d < *data_ptr || (-1 < (int)((*(ushort *)&DAT_00004154 >> (*data_ptr & 0xff)) << 0x1f)))) {\nLAB_00004104:\n      *(ushort *)(state_ptr + 3) = state_bitmask | 0x40;\n      return state_handler_result;\n    }\n    state_ptr[1] = 0;\n    state_ptr[0] = state_ptr[4];\n    if (((int)((uint)state_bitmask << 0x13) < 0) && ((state_handler_result != -1 || (*data_ptr == 0)))) {\n      state_ptr[0x15] = state_handler_result;\n    }\n    data_handler = *(code **)(&state_ptr[0xd]);\n    *data_ptr = data_bitmask;\n    if (data_handler != (code *)0x0) {\n      if (data_handler != state_ptr + 0x11) {\n        insert_node_at_end_00004b34(data_ptr);\n      }\n      state_ptr[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000404c",
            "calling": [
                "FUN_00004158",
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "process_data_0000404c"
        },
        "FUN_00002f74": {
            "renaming": {
                "FUN_00002f74": "print_devices_info_00002f74",
                "local_14": "device_ptr",
                "local_18": "device_count",
                "uVar1": "class_id"
            },
            "code": "void print_devices_info_00002f74(void)\n{\n    undefined4 class_id;\n    int device_count = 0;\n    undefined4 *device_ptr = *(undefined4 **)PTR_DAT_00002fd0;\n    \n    if (device_ptr == (undefined4 *)0x0) {\n        process_input(PTR_s_No_devices_found_00002fd8);\n    }\n    else {\n        process_input(PTR_s_ID_Class_Name_00002fd4);\n    }\n    \n    for (; device_ptr != (undefined4 *)0x0; device_ptr = (undefined4 *)*device_ptr) {\n        class_id = get_class_for_character_000039e8(*(undefined *)(device_ptr[3] + 8));\n        process_data_00004c84(PTR_s___i__s__s_00002fdc,device_count,class_id,device_ptr[2]);\n        device_count++;\n    }\n    return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_000039e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f74",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "print_devices_info_00002f74",
            "code_backup": "\nvoid FUN_00002f74(void)\n\n{\n  undefined4 uVar1;\n  int local_18;\n  undefined4 *local_14;\n  \n  local_14 = *(undefined4 **)PTR_DAT_00002fd0;\n  local_18 = 0;\n  if (local_14 == (undefined4 *)0x0) {\n    process_input(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    process_input(PTR_s_ID_Class_Name_00002fd4);\n  }\n  for (; local_14 != (undefined4 *)0x0; local_14 = (undefined4 *)*local_14) {\n    uVar1 = get_class_for_character_000039e8(*(undefined *)(local_14[3] + 8));\n    FUNC_00004c84(PTR_s___i__s__s_00002fdc,local_18,uVar1,local_14[2]);\n    local_18 = local_18 + 1;\n  }\n  return;\n}\n\n"
        },
        "FUN_000010a0": {
            "renaming": {
                "FUN_000010a0": "count_elements_before_null_000010a0",
                "param_1": "array",
                "local_c": "current_element"
            },
            "code": "int count_elements_before_null_000010a0(int *array)\n{\n  int *current_element;\n  for (current_element = array; (int *)*current_element == current_element; current_element++) {\n  }\n  return (int)current_element - (int)array;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010a0",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "count_elements_before_null_000010a0"
        },
        "FUN_000012e2": {
            "renaming": {
                "FUN_000012e2": "compare_and_copy_000012e2",
                "param_1": "base_ptr",
                "param_2": "offset",
                "param_3": "flag",
                "iVar1": "result"
            },
            "code": "int compare_and_copy_000012e2(int base_ptr, undefined4 offset, undefined4 flag) {\n  int result;\n  while (true) {\n    result = compare_ptr_with_offset_and_copy_0000231c(base_ptr + 4, offset, flag);\n    if (result != 0) {\n      break;\n    }\n    register_interrupt_handler_with_flag_0000129c(base_ptr);\n  }\n  return result;\n}",
            "called": [
                "FUN_0000129c",
                "FUN_0000231c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012e2",
            "calling": [
                "FUN_00000e14"
            ],
            "imported": false,
            "current_name": "compare_and_copy_000012e2"
        },
        "FUN_000056a0": {
            "renaming": {
                "FUN_000056a0": "find_key_index_000056a0",
                "param_1": "key",
                "param_2": "array",
                "param_3": "index",
                "param_4": "array_length",
                "uStack_c": "key_count",
                "uStack_8": "i"
            },
            "code": "void find_key_index_000056a0(int key, int* array, int* index, int array_length, int key_count) {\n  *index = -1;\n  for (int i = 0; i < array_length; i++) {\n    if (array[i] == key) {\n      *index = i;\n      key_count--;\n      if (key_count == 0) {\n        break;\n      }\n    }\n  }\n}\n",
            "called": [
                "FUN_0000562c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056a0",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "find_key_index_000056a0"
        },
        "FUN_0000231c": {
            "renaming": {
                "FUN_0000231c": "compare_ptr_with_offset_and_copy_0000231c",
                "param_1": "offset",
                "param_2": "dest",
                "param_3": "count",
                "uVar1": "current_value",
                "iVar2": "is_equal",
                "local_20": "current_ptr",
                "local_14": "remaining_count"
            },
            "code": "int compare_ptr_with_offset_and_copy_0000231c(int offset, void* dest, int count) {\n  void* current_ptr = dest;\n  int remaining_count = count;\n  while (remaining_count != 0 && !is_ptr_equal_to_ptr_plus_offset(offset)) {\n    char current_value = increment_value(offset);\n    *(char*)current_ptr = current_value;\n    remaining_count--;\n    current_ptr = (char*)current_ptr + 1;\n  }\n  return count - remaining_count;\n}",
            "called": [
                "FUN_000022f0",
                "FUN_00002270"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000231c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": false,
            "current_name": "compare_ptr_with_offset_and_copy_0000231c"
        },
        "FUN_000061cc": {
            "renaming": {
                "FUN_000061cc": "FUNC_000061cc"
            },
            "code": "\nint FUNC_000061cc(int param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  uint uVar6;\n  int **local_2b0;\n  undefined auStack_2ac [256];\n  uint local_1ac;\n  undefined4 local_1a8;\n  uint local_1a4;\n  int local_1a0;\n  int local_19c;\n  undefined *local_198;\n  int local_194;\n  undefined *local_30;\n  code *local_2c;\n  \n  puVar2 = PTR_DAT_000064b4;\n  puVar1 = PTR_DAT_000064b0;\n  local_1a0 = 0;\n  local_19c = 0;\n  local_30 = PTR_LAB_00006118_1_000064a8;\n  local_2c = DAT_000064ac;\n  local_2b0 = param_4;\n  local_198 = auStack_2ac;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      uVar6 = (uint)*param_3;\n      if (uVar6 == 0) {\n        return local_1a0;\n      }\n      uVar4 = (byte)puVar1[uVar6] & 8;\n      pbVar5 = param_3 + 1;\n      if ((puVar1[uVar6] & 8) == 0) break;\n      while (((param_3 = pbVar5, 0 < (int)param_2[1] ||\n              (iVar3 = (*local_2c)(param_1,param_2), iVar3 == 0)) &&\n             ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0))) {\n        local_19c = local_19c + 1;\n        param_2[1] = param_2[1] + -1;\n        *param_2 = *param_2 + 1;\n      }\n    }\n    if (uVar6 == 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n    goto LAB_00006380;\n    if (**param_2 != uVar6) {\n      return local_1a0;\n    }\n    *param_2 = *param_2 + 1;\n    local_19c = local_19c + 1;\n    param_2[1] = param_2[1] + -1;\n    param_3 = pbVar5;\n  }\n  local_1a4 = uVar4;\n  local_1ac = uVar4;\n  if (param_3[1] == 0x2a) {\n    pbVar5 = param_3 + 2;\n    local_1ac = 0x10;\n  }\n  while( true ) {\n    uVar4 = (uint)*pbVar5;\n    if (9 < uVar4 - 0x30) break;\n    pbVar5 = pbVar5 + 1;\n    local_1a4 = (local_1a4 * 10 + uVar4) - 0x30;\n  }\n  iVar3 = find_byte_sequence_00006010(PTR_DAT_000064b4,uVar4,3);\n  if (iVar3 != 0) {\n    local_1ac = 1 << (iVar3 - (int)puVar2 & 0xffU) | local_1ac;\n    pbVar5 = pbVar5 + 1;\n  }\n  param_3 = pbVar5 + 1;\n  uVar4 = (uint)*pbVar5;\n  if (uVar4 < 0x79) {\n    if (0x57 < uVar4) {\n      switch(uVar4) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 = (byte *)decode_0000687c(auStack_2ac,param_3);\n        local_1ac = local_1ac | 0x40;\n        local_194 = 1;\n        break;\n      case 99:\n        local_1ac = local_1ac | 0x40;\n        local_194 = 0;\n        break;\n      case 100:\n      case 0x75:\n        local_1a8 = 10;\nLAB_000063a0:\n        if (uVar4 < 0x6f) {\n          local_194 = 3;\n        }\n        else {\n          local_194 = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_194 = 5;\n        break;\n      case 0x69:\n        local_1a8 = 0;\n        local_194 = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(local_1ac << 0x1b)) {\n          if ((int)(local_1ac << 0x1f) < 0) {\n            *(short *)*local_2b0 = (short)local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n          else {\n            **local_2b0 = local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_1a8 = 8;\n        local_194 = 4;\n        break;\n      case 0x70:\n        local_1ac = local_1ac | 0x20;\n      case 0x58:\n      case 0x78:\n        local_1ac = local_1ac | 0x200;\n        local_1a8 = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_194 = 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(local_1ac << 0x19)) {\n        while ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0) {\n          local_19c = local_19c + 1;\n          pbVar5 = param_2[1];\n          param_2[1] = pbVar5 + -1;\n          if ((int)(pbVar5 + -1) < 1) {\n            iVar3 = (*local_2c)(param_1,param_2);\n            if (iVar3 != 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 = *param_2 + 1;\n          }\n        }\n      }\n      if (local_194 < 3) {\n        iVar3 = process_input_000064bc(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else if (local_194 < 5) {\n        iVar3 = FUNC_0000656c(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else {\n        iVar3 = param_1;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (iVar3 == 1) {\n        return local_1a0;\n      }\n      if (iVar3 == 2) {\nLAB_00006380:\n        if (local_1a0 == 0) {\nLAB_00006388:\n          local_1a0 = -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) & 0x40) != 0) {\n          local_1a0 = -1;\n        }\n        return local_1a0;\n      }\n      goto LAB_000061f6;\n    }\n    pbVar5 = param_3;\n    if (uVar4 == 0x25) goto LAB_00006352;\n    if (uVar4 < 0x26) {\n      if (uVar4 != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (uVar4 - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_194 = 3;\n  local_1a8 = 10;\n  goto LAB_000063ac;\n}\n\n",
            "called": [
                "FUN_000064bc",
                "FUN_0000687c",
                "FUN_00006010",
                "FUN_0000656c",
                "FUN_00006192"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000061cc",
            "calling": [
                "FUN_00005e68"
            ],
            "imported": false,
            "current_name": "FUNC_000061cc"
        },
        "FUN_00002690": {
            "renaming": {
                "FUN_00002690": "calculate_date_and_return_zero_00002690",
                "param_1": "input_date",
                "local_10": "data",
                "uStack_c": "result",
                "get_data_from_pointer_000028f0": "get_data_from_pointer",
                "calculate_date_0000443c": "calculate_date"
            },
            "code": "int calculate_date_and_return_zero_00002690(int input_date)\n{\n    int data = get_data_from_pointer();\n    int result = 0;\n    calculate_date(&data, input_date);\n    return result;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_000028f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002690",
            "calling": [
                "FUN_000033c0"
            ],
            "imported": false,
            "current_name": "calculate_date_and_return_zero_00002690"
        },
        "FUN_00006010": {
            "renaming": {
                "FUN_00006010": "find_byte_sequence_00006010",
                "param_1": "data",
                "param_2": "target_byte",
                "param_3": "length",
                "bVar1": "current_byte",
                "cVar2": "byte_mask_0",
                "cVar3": "byte_mask_8",
                "cVar4": "byte_mask_16",
                "cVar5": "byte_mask_24",
                "pbVar6": "byte_pointer",
                "puVar7": "data_pointer",
                "pbVar8": "result_pointer",
                "uVar9": "i",
                "uVar10": "mask",
                "uVar11": "current_word",
                "uVar12": "next_word",
                "bVar13": "byte_found",
                "bVar14": "byte_found_8",
                "bVar15": "byte_found_16",
                "bVar16": "byte_found_24",
                "joined_r0x00006070": "byte_search_loop"
            },
            "code": "byte * find_byte_sequence_00006010(uint *data, uint target_byte, uint length) {\n    byte *result;\n    uint *current_data;\n    uint current_word;\n    uint mask;\n    bool byte_found;\n    bool word_found;\n    uint i;\n    uint j;\n\n    target_byte = target_byte & 0xff;\n\n    if ((int)length < 0x10) {\n        do {\n            if (length == 0) {\n                return (byte *)0x0;\n            }\n            current_data = (uint *)((int)data + 1);\n            result = (byte *)data;\n            byte_found = (*(byte *)data == target_byte);\n            length--;\n            data = current_data;\n        } while (!byte_found);\n    }\n    else {\n        mask = target_byte | target_byte << 8 | target_byte << 0x10 | target_byte << 0x18;\n        i = (uint)data & 7;\n\n        while (true) {\n            if (i == 0) {\n                j = length & 0xfffffff8;\n                do {\n                    current_data = data + 2;\n                    j -= 8;\n                    current_word = *data ^ mask;\n                    current_word |= data[1] ^ mask;\n                    word_found = (current_word != 0);\n\n                    if (word_found) {\n                        if (current_word & 1) {\n                            result = (byte *)((int)data + 1);\n                        }\n                        else {\n                            result = (byte *)((int)data + 2);\n                            if (current_word & 0x100) {\n                                result++;\n                            }\n                            if (current_word & 0x18000) {\n                                result++;\n                            }\n                        }\n                        return result - 1;\n                    }\n                    data = current_data;\n                } while (j != 0);\n                length &= 7;\n                do {\n                    if (length == 0) {\n                        return (byte *)0x0;\n                    }\n                    result = (byte *)data;\n                    byte_found = (*(byte *)data == target_byte);\n                    length--;\n                    current_data = (uint *)((int)data + 1);\n                    data = current_data;\n                } while (!byte_found);\n            }\n            current_data = (uint *)((int)data + 1);\n            length--;\n            byte_found = (*(byte *)data == target_byte);\n            data = current_data;\n            if (byte_found || length == 0) {\n                break;\n            }\n            i = (uint)current_data & 7;\n        }\n        result = (byte *)((int)current_data + -1);\n    }\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006010",
            "calling": [
                "FUN_00005b34",
                "FUN_000057f8",
                "FUN_000061cc",
                "FUN_0000656c"
            ],
            "imported": false,
            "current_name": "find_byte_sequence_00006010"
        },
        "FUN_00001cf0": {
            "renaming": {
                "FUN_00001cf0": "check_and_set_flag_if_not_zero_00001cf0",
                "PTR_DAT_00001d04": "flag_ptr",
                "set_flag_on_0000093c": "set_flag",
                "*PTR_DAT_00001d04": "*flag_ptr"
            },
            "code": "void check_and_set_flag_if_not_zero_00001cf0(void)\n{\n    int* PTR_DAT_00001d04 = (int*)PTR_DAT_00001d04;\n    if (*PTR_DAT_00001d04 != 0)\n    {\n        set_flag_on_0000093c();\n    }\n    return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001cf0",
            "calling": [
                "FUN_00002028"
            ],
            "imported": false,
            "current_name": "check_and_set_flag_if_not_zero_00001cf0"
        },
        "FUN_00003ec4": {
            "renaming": {
                "FUN_00003ec4": "calculate_number_of_digits_00003ec4",
                "param_1": "output",
                "param_2": "input",
                "param_3": "decimal_places",
                "iVar1": "digits",
                "uVar2": "result",
                "uVar3": "quotient",
                "local_10": "remainder",
                "local_c": "result"
            },
            "code": "int calculate_number_of_digits_00003ec4(undefined *output, uint input, int decimal_places) {\n  int result = 0;\n  if (decimal_places + 7 < 0 != SCARRY4(decimal_places,7)) {\n    process_input(3,PTR_s_FAILED_ASSERTION__00003fec);\n  }\n  if (decimal_places == 0) {\n    result = calculate_signed_number_of_digits(output, input);\n  }\n  else if (decimal_places < 1) {\n    uint divisor = *(uint *)(PTR_DAT_00003ff0 + decimal_places * -4);\n    uint quotient = input / divisor;\n    int remainder = input - divisor * quotient;\n    if (remainder < 0) {\n      remainder = -remainder;\n    }\n    if (quotient == 0 && (int)input < 0) {\n      if (output != (undefined *)0x0) {\n        *output = 0x2d;\n      }\n      result = 1;\n    }\n    if (output == (undefined *)0x0) {\n      int digits = calculate_signed_number_of_digits(0, quotient);\n      result = digits + 1 + result;\n    }\n    else {\n      int digits = calculate_signed_number_of_digits(output + result, quotient);\n      digits = result + digits;\n      result = digits + 1;\n      output[digits] = 0x2e;\n      uVar2 = calculate_signed_number_of_digits(output + result, remainder);\n      reverse_copy_and_fill(output + result, uVar2, -decimal_places, 0x30);\n    }\n    result = -decimal_places + result;\n  }\n  else {\n    result = calculate_signed_number_of_digits(output, input);\n    if (output != (undefined *)0x0) {\n      fill_array_with_value(output + result, 0x30, decimal_places);\n    }\n    result = decimal_places + result;\n  }\n  return result;\n}",
            "called": [
                "FUN_00000f04",
                "FUN_00003ff4",
                "FUN_00003e58",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ec4",
            "calling": [
                "FUN_00003e9e"
            ],
            "imported": false,
            "current_name": "calculate_number_of_digits_00003ec4"
        },
        "FUN_00001360": {
            "renaming": {
                "FUN_00001360": "calculate_address_offset_00001360",
                "param_1": "address",
                "param_2": "offset",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int calculate_address_offset_00001360(uint32_t address, int offset) {\n    uint32_t masked_address = address & 0xf0000000;\n    uint32_t lower_bits = address & 0xfffff;\n    uint32_t shifted_lower_bits = lower_bits << 5;\n    int result = offset * 4 + masked_address + shifted_lower_bits + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001360",
            "calling": [
                "FUN_00001392"
            ],
            "imported": false,
            "current_name": "calculate_address_offset_00001360"
        },
        "FUN_00004622": {
            "renaming": {
                "FUN_00004622": "fill_array_with_value_00004622",
                "param_1": "array",
                "param_2": "value",
                "param_3": "array_length",
                "puVar1": "end_of_array",
                "*param_1": "*array"
            },
            "code": "void fill_array_with_value_00004622(unsigned char *array, unsigned char value, int array_length) {\n  unsigned char *end_of_array;\n  end_of_array = array + array_length;\n  for (; array != end_of_array; array = array + 1) {\n    *array = value;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004622",
            "calling": [
                "FUN_00003ec4",
                "FUN_0000305c",
                "FUN_00004248",
                "FUN_000041f4",
                "FUN_00003ff4",
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "fill_array_with_value_00004622"
        },
        "FUN_0000093c": {
            "renaming": {
                "FUN_0000093c": "set_flag_on_0000093c",
                "PTR_DAT_00000954": "flag_address",
                "DAT_00000954": "flag_offset"
            },
            "code": "void set_flag_on_0000093c(void)\n{\n    uint32_t *flag = (uint32_t *)(DAT_00000954 + 4);\n    *flag |= 0x10000000;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000093c",
            "calling": [
                "FUN_00001cf0",
                "FUN_00002434",
                "FUN_00001348",
                "FUN_00000738",
                "FUN_00002798"
            ],
            "imported": false,
            "current_name": "set_flag_on_0000093c"
        },
        "FUN_00003658": {
            "renaming": {
                "FUN_00003658": "synchronize_data_00003658",
                "DAT_00003680": "data_address",
                "DAT_00003684": "data_value",
                "PTR_": "ptr_"
            },
            "code": "void synchronize_data_00003658(void)\n{\n  DataSynchronizationBarrier(0xf);\n  uint* data_ptr = (uint*)(DAT_00003680 + 0xc);\n  *data_ptr = DAT_00003684 | (*data_ptr & 0x700);\n  DataSynchronizationBarrier(0xf);\n  while(true) {\n    // Do nothing, infinite loop\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003658",
            "calling": [
                "FUN_00003688"
            ],
            "imported": false,
            "current_name": "synchronize_data_00003658"
        },
        "FUN_000019c0": {
            "renaming": {
                "FUN_000019c0": "setFlagAndTerminateString_000019c0",
                "set_flag_and_null_terminate_00001778": "setFlagAndNullTerminate",
                "setParamValue_00001748": "setParameterValue",
                "null_terminate_string_00001710": "nullTerminateString",
                "DAT_00001a0c": "DAT_buffer",
                "*DAT_00001a10": "*DAT_flag",
                "PTR_DAT_00001a14": "*PTR_result",
                "null_terminate_string_00001734": "nullTerminateString"
            },
            "code": "void setFlagAndTerminateString_000019c0() {\n    setFlagAndNullTerminate();\n    setParameterValue(64);\n    nullTerminateString(DAT_00001a0c, 1);\n    *DAT_00001a10 = (*DAT_00001a10 & 59) | 128;\n    while ((DAT_flag[6] & 12) != 8) {\n    }\n    nullTerminateString(DAT_string);\n    PTR_DAT_00001a14 = 3;\n    return;\n}",
            "called": [
                "FUN_00001778",
                "FUN_00001748",
                "FUN_00001734",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000019c0",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "setFlagAndTerminateString_000019c0"
        },
        "FUN_000060b0": {
            "renaming": {
                "FUN_000060b0": "copy_array_000060b0",
                "param_1": "dest_start",
                "param_2": "src",
                "param_3": "length",
                "puVar1": "next_src",
                "puVar2": "src_end",
                "puVar3": "dest"
            },
            "code": "void copy_array_000060b0(int dest_start, undefined *src, int length)\n{\n  undefined *src_end = src + length;\n  undefined *dest = (undefined *)(dest_start - 1);\n  if (src != src_end) {\n    do {\n      undefined *next_src = src + 1;\n      dest = dest + 1;\n      *dest = *src;\n      src = next_src;\n    } while (next_src != src_end);\n    return;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060b0",
            "calling": [
                "FUN_000068f0",
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "copy_array_000060b0"
        },
        "FUN_00006a14": {
            "renaming": {
                "FUN_00006a14": "FUNC_00006a14"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong FUNC_00006a14(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint uVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  if (param_4 == 0) {\n    if (param_2 < param_3) {\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 != 0) {\n        param_3 = param_3 << (uVar4 & 0xff);\n        param_2 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        param_1 = param_1 << (uVar4 & 0xff);\n      }\n      uVar7 = param_3 >> 0x10;\n      uVar9 = param_2 / uVar7;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar7 * uVar9) * 0x10000;\n      uVar1 = uVar9 * (param_3 & 0xffff);\n      uVar6 = uVar9;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar9 = (uVar5 - uVar1) / uVar7;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar7 * uVar9) * 0x10000;\n      uVar7 = uVar9 * (param_3 & 0xffff);\n      uVar1 = uVar9;\n      if (uVar5 <= uVar7 && uVar7 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar7 && uVar7 - uVar5 != 0)) {\n          uVar1 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar7;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n      puVar3 = (uint *)0x0;\n    }\n    else {\n      if (param_3 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        uVar12 = (*UNRECOVERED_JUMPTABLE)();\n        return uVar12;\n      }\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 == 0) {\n        param_2 = param_2 - param_3;\n        uVar10 = param_3 >> 0x10;\n        uVar8 = param_3 & 0xffff;\n        puVar3 = (uint *)0x1;\n      }\n      else {\n        param_3 = param_3 << (uVar4 & 0xff);\n        uVar10 = param_3 >> 0x10;\n        uVar6 = param_2 >> (0x20 - uVar4 & 0xff);\n        uVar1 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        uVar5 = uVar6 / uVar10;\n        uVar8 = param_3 & 0xffff;\n        uVar9 = uVar1 >> 0x10 | (uVar6 - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        param_1 = param_1 << (uVar4 & 0xff);\n        uVar6 = uVar5;\n        if (uVar9 <= uVar7 && uVar7 - uVar9 != 0) {\n          bVar11 = CARRY4(param_3,uVar9);\n          uVar9 = param_3 + uVar9;\n          uVar6 = uVar5 - 1;\n          if ((bVar11 == false) && (uVar9 <= uVar7 && uVar7 - uVar9 != 0)) {\n            uVar6 = uVar5 - 2;\n            uVar9 = uVar9 + param_3;\n          }\n        }\n        uVar5 = (uVar9 - uVar7) / uVar10;\n        param_2 = uVar1 & 0xffff | ((uVar9 - uVar7) - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        uVar1 = uVar5;\n        if (param_2 <= uVar7 && uVar7 - param_2 != 0) {\n          bVar11 = CARRY4(param_3,param_2);\n          param_2 = param_3 + param_2;\n          uVar1 = uVar5 - 1;\n          if ((bVar11 == false) && (param_2 <= uVar7 && uVar7 - param_2 != 0)) {\n            uVar1 = uVar5 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar7;\n        puVar3 = (uint *)(uVar1 | uVar6 << 0x10);\n      }\n      uVar7 = param_2 / uVar10;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar10 * uVar7) * 0x10000;\n      uVar1 = uVar8 * uVar7;\n      uVar6 = uVar7;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar7 = (uVar5 - uVar1) / uVar10;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar10 * uVar7) * 0x10000;\n      uVar8 = uVar8 * uVar7;\n      uVar1 = uVar7;\n      if (uVar5 <= uVar8 && uVar8 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar8 && uVar8 - uVar5 != 0)) {\n          uVar1 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar8;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = uVar5 >> (uVar4 & 0xff);\n      param_5[1] = 0;\n    }\n  }\n  else if (param_2 < param_4) {\n    puVar2 = param_5;\n    puVar3 = param_5;\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return 0;\n    }\n  }\n  else {\n    puVar3 = (uint *)count_leading_zeroes(param_4);\n    if (puVar3 != (uint *)0x0) {\n      uVar8 = 0x20 - (int)puVar3;\n      uVar5 = param_3 >> (uVar8 & 0xff) | param_4 << ((uint)puVar3 & 0xff);\n      uVar10 = uVar5 >> 0x10;\n      uVar4 = param_2 >> (uVar8 & 0xff);\n      uVar6 = param_1 >> (uVar8 & 0xff) | param_2 << ((uint)puVar3 & 0xff);\n      uVar7 = uVar4 / uVar10;\n      uVar1 = uVar6 >> 0x10 | (uVar4 - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      param_3 = param_3 << ((uint)puVar3 & 0xff);\n      param_1 = param_1 << ((uint)puVar3 & 0xff);\n      uVar4 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar4 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar4 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar7 = (uVar1 - uVar9) / uVar10;\n      uVar1 = uVar6 & 0xffff | ((uVar1 - uVar9) - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      uVar6 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar6 = uVar6 | uVar4 << 0x10;\n      uVar12 = (ulonglong)uVar6 * (ulonglong)param_3;\n      if (CONCAT44(uVar1 - uVar9,param_1) < uVar12) {\n        uVar12 = uVar12 - CONCAT44(uVar5,param_3);\n        uVar6 = uVar6 - 1;\n      }\n      if (param_5 != (uint *)0x0) {\n        uVar4 = ((uVar1 - uVar9) - (int)(uVar12 >> 0x20)) - (uint)(param_1 < (uint)uVar12);\n        *param_5 = uVar4 << (uVar8 & 0xff) | param_1 - (uint)uVar12 >> ((uint)puVar3 & 0xff);\n        param_5[1] = uVar4 >> ((uint)puVar3 & 0xff);\n      }\n      return (ulonglong)uVar6;\n    }\n    if ((param_4 < param_2) || (puVar2 = puVar3, param_3 <= param_1)) {\n      bVar11 = param_1 < param_3;\n      param_1 = param_1 - param_3;\n      param_2 = (param_2 - param_4) - (uint)bVar11;\n      puVar2 = (uint *)0x1;\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n    }\n  }\n  return CONCAT44(puVar3,puVar2);\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00006a14",
            "calling": [
                "FUN_00006974"
            ],
            "imported": false,
            "current_name": "FUNC_00006a14"
        },
        "FUN_000023d0": {
            "renaming": {
                "FUN_000023d0": "check_software_interrupt_status_000023d0",
                "param_1": "param",
                "uVar1": "result",
                "PTR_DAT_000023fc": "interrupt_status",
                "trigger_software_interrupt_000023c8": "trigger_software_interrupt"
            },
            "code": "int check_software_interrupt_status_000023d0(int param){\n  int* PTR_DAT_000023fc = (int*) PTR_DAT_000023fc;\n  if (*PTR_DAT_000023fc == 0) {\n    return trigger_software_interrupt(1, param, 0);\n  }\n  else {\n    return 0;\n  }\n}",
            "called": [
                "FUN_000023c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023d0",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": false,
            "current_name": "check_software_interrupt_status_000023d0"
        },
        "FUN_00000a30": {
            "renaming": {
                "FUN_00000a30": "process_input_00000a30",
                "in_r3": "register_value",
                "auStack_20": "output_buffer"
            },
            "code": "char* process_input_00000a30(int input_length, char* input_buffer)\n{\n    int register_value;\n    char output_buffer[24];\n\n    process_input_00000a30_00000f04(input_length, input_buffer);\n    return output_buffer + (-(int)PTR_DAT_00000a60 - *(int *)(register_value + 0x4c));\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a30",
            "calling": [],
            "imported": false,
            "current_name": "process_input_00000a30"
        },
        "FUN_000034c0": {
            "renaming": {
                "FUN_000034c0": "initialize_rtc_commands_000034c0",
                "PTR_s_usage__rtc__command___arguments__00003500": "usage_rtc_command_arguments",
                "PTR_s_commands__00003504": "commands",
                "PTR_s__poweron_power_the_interface_on_00003508": "power_on_interface",
                "PTR_s__poweroff_power_the_interface_of_0000350c": "power_off_interface",
                "PTR_s__clearalarm_deactivate_the_curre_00003510": "deactivate_current_alarm",
                "PTR_s__getalarm_print_the_currently_al_00003514": "print_current_alarm",
                "PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518": "set_alarm",
                "PTR_s__gettime_print_the_current_time_0000351c": "print_current_time",
                "PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520": "set_time"
            },
            "code": "int initialize_rtc_commands_000034c0() {\n  process_input(PTR_s_usage__rtc__command___arguments__00003500);\n  process_input(PTR_s_commands__00003504);\n  process_input(PTR_s__poweron_power_the_interface_on_00003508);\n  process_input(PTR_s__poweroff_power_the_interface_of_0000350c);\n  process_input(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  process_input(PTR_s__getalarm_print_the_currently_al_00003514);\n  process_input(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  process_input(PTR_s__gettime_print_the_current_time_0000351c);\n  process_input(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000034c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "initialize_rtc_commands_000034c0",
            "code_backup": "\nundefined4 FUN_000034c0(void)\n\n{\n  process_input(PTR_s_usage__rtc__command___arguments__00003500);\n  process_input(PTR_s_commands__00003504);\n  process_input(PTR_s__poweron_power_the_interface_on_00003508);\n  process_input(PTR_s__poweroff_power_the_interface_of_0000350c);\n  process_input(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  process_input(PTR_s__getalarm_print_the_currently_al_00003514);\n  process_input(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  process_input(PTR_s__gettime_print_the_current_time_0000351c);\n  process_input(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}\n\n"
        },
        "FUN_000050e8": {
            "renaming": {
                "FUN_000050e8": "get_pointer_to_data_000050e8",
                "PTR_DAT_000050f0": "pointer_to_data"
            },
            "code": "const char* get_pointer_to_data_000050e8() {\n  return PTR_DAT_000050f0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050e8",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_pointer_to_data_000050e8"
        },
        "FUN_000042a4": {
            "renaming": {
                "FUN_000042a4": "initialize_memory_block_000042a4",
                "param_1": "block_address",
                "uVar1": "allocation_result",
                "iVar2": "is_initialized",
                "bVar3": "is_self_referenced"
            },
            "code": "void initialize_memory_block_000042a4(int block_address)\n{\n    undefined4 allocation_result;\n    int is_initialized;\n    bool is_self_referenced;\n\n    do_nothing_with_data();\n    is_initialized = *(int *)(block_address + 0x18);\n    if (is_initialized == 0) {\n        *(undefined4 *)(block_address + 0x48) = 0;\n        *(undefined4 *)(block_address + 0x4c) = 0;\n        *(undefined4 *)(block_address + 0x50) = 0;\n        int ptr_dat = *(int *)PTR_DAT_0000430c;\n        *(undefined **)(block_address + 0x28) = PTR_DAT_00004310;\n        is_self_referenced = ptr_dat == block_address;\n        if (is_self_referenced) {\n            ptr_dat = 1;\n        }\n        if (is_self_referenced) {\n            *(int *)(block_address + 0x18) = ptr_dat;\n        }\n        allocation_result = allocate_and_initialize_memory_block_000042a4(block_address);\n        *(undefined4 *)(block_address + 4) = allocation_result;\n        allocation_result = allocate_and_initialize_memory_block_000042a4(block_address);\n        *(undefined4 *)(block_address + 8) = allocation_result;\n        allocation_result = allocate_and_initialize_memory_block_000042a4(block_address);\n        *(undefined4 *)(block_address + 0xc) = allocation_result;\n        initialize_data(*(undefined4 *)(block_address + 4), 4, 0);\n        initialize_data(*(undefined4 *)(block_address + 8), 9, 1);\n        initialize_data(*(undefined4 *)(block_address + 0xc), 0x12, 2);\n        *(undefined4 *)(block_address + 0x18) = 1;\n    }\n    do_nothing(DAT_000042a0);\n    return;\n}",
            "called": [
                "FUN_0000428c",
                "FUN_000041f4",
                "FUN_000045ec",
                "FUN_00004314"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000042a4",
            "calling": [
                "FUN_00004c84",
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_00005404",
                "FUN_00005e10",
                "FUN_000054a8",
                "FUN_00004158",
                "FUN_00006768",
                "FUN_00004418",
                "FUN_00004cb4",
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "initialize_memory_block_000042a4"
        },
        "FUN_00000514": {
            "renaming": {
                "FUN_00000514": "set_param_to_19_00000514",
                "*param_1": "*value_ptr",
                "param_1": "value_ptr",
                "*PTR_00000008": "*new_value_ptr",
                "PTR_00000008": "new_value_ptr",
                "DAT_00000004": "old_return_value",
                "0x13": "19"
            },
            "code": "int set_param_to_19_00000514(int *value_ptr)\n{\n    int new_value = 0x13;\n    *value_ptr = new_value;\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000514",
            "calling": [
                "FUN_000056b8"
            ],
            "imported": false,
            "current_name": "set_param_to_19_00000514"
        },
        "FUN_00002e9c": {
            "renaming": {
                "FUN_00002e9c": "synchronize_data_00002e9c"
            },
            "code": "int synchronize_data_00002e9c() {\n  synchronize_data_00002e9c_00003688();\n  return 0;\n}",
            "called": [
                "FUN_00003688"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e9c",
            "calling": [],
            "imported": false,
            "current_name": "synchronize_data_00002e9c"
        },
        "FUN_00001960": {
            "renaming": {
                "FUN_00001960": "initializeSystem_00001960",
                "setParamValue_00001748": "setParameter",
                "null_terminate_string_00001710": "nullTerminateString",
                "DAT_000019b4": "inputString",
                "*DAT_000019b8": "*outputValue",
                "PTR_DAT_000019bc": "*status"
            },
            "code": "void initializeSystem_00001960(void)\n{\n    setParameter(0xa0);\n    nullTerminateString(DAT_000019b4, 1);\n    *DAT_000019b8 = *DAT_000019b8 & 0x3b | 0x44;\n    do {\n    } while ((outputValue[6] & 0xc) != 4);\n    do {\n    } while ((outputValue[6] & 0x10) == 0);\n    PTR_DAT_000019bc = 2;\n    return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001960",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initializeSystem_00001960"
        },
        "FUN_00000990": {
            "renaming": {
                "FUN_00000990": "do_nothing_00000990"
            },
            "code": "\nvoid do_nothing_00000990(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000990",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "do_nothing_00000990"
        },
        "FUN_00001a3c": {
            "renaming": {
                "FUN_00001a3c": "set_result_and_terminate_string_00001a3c",
                "DAT_00001a58": "result",
                "PTR_DAT_00001a5c": "count",
                "DAT_00001734": "string",
                "set_result_to_one_000016ec": "set_result_to_one",
                "null_terminate_string_00001734": "null_terminate_string"
            },
            "code": "void set_result_and_terminate_string_00001a3c(void)\n{\n  set_DAT_00001a58_to_one(DAT_00001a58,1);\n  null_terminate_DAT_00001734(DAT_00001734);\n  *PTR_DAT_00001a5c = 5;\n  return;\n}",
            "called": [
                "FUN_00001734",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a3c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_result_and_terminate_string_00001a3c"
        },
        "FUN_000045ee": {
            "renaming": {
                "FUN_000045ee": "reverse_copy_000045ee",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "len",
                "puVar1": "dest_end",
                "puVar2": "src_end"
            },
            "code": "void reverse_copy_000045ee(char* dest, const char* src, int len) {\n  char* dest_end = dest + len;\n  if ((src < dest) && (dest < dest_end)) {\n    char* src_end = src + len;\n    while (src_end != src) {\n      dest_end--;\n      src_end--;\n      *dest_end = *src_end;\n    }\n  }\n  else {\n    dest--;\n    for (; src != dest_end; src++, dest++) {\n      *dest = *src;\n    }\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ee",
            "calling": [
                "FUN_00003ff4"
            ],
            "imported": false,
            "current_name": "reverse_copy_000045ee"
        },
        "FUN_00005404": {
            "renaming": {
                "FUN_00005404": "process_input_00005404",
                "param_1": "block_address",
                "param_2": "input_char",
                "param_3": "block_ptr",
                "param_4": "param_4",
                "iVar1": "block_size",
                "uVar2": "input_length",
                "puVar3": "block_data_ptr",
                "initialize_memory_block_000042a4": "initialize_memory_block",
                "PTR_DAT_0000549c": "PTR_DAT_0000549c",
                "PTR_DAT_000054a0": "PTR_DAT_000054a0",
                "PTR_DAT_000054a4": "PTR_DAT_000054a4",
                "process_data_000054a8": "process_data",
                "process_data_00004158": "process_data"
            },
            "code": "uint process_input_00005404(int block_address, uint input_char, int *block_ptr, undefined4 param_4)\n{\n  int block_size = block_ptr[0];\n  int block_data_offset = block_ptr[4];\n  int block_data_length = block_ptr[5];\n  int block_remaining_data_length = block_data_length - block_data_offset;\n\n  if ((block_address != 0) && (*(int *)(block_address + 0x18) == 0)) {\n    initialize_memory_block();\n  }\n\n  if (block_ptr == (int *)PTR_DAT_0000549c) {\n    block_ptr = *(int **)(block_address + 4);\n  }\n  else if (block_ptr == (int *)PTR_DAT_000054a0) {\n    block_ptr = *(int **)(block_address + 8);\n  }\n  else if (block_ptr == (int *)PTR_DAT_000054a4) {\n    block_ptr = *(int **)(block_address + 0xc);\n  }\n\n  block_ptr[2] = block_ptr[6];\n  uint input_length = (uint)*(ushort *)(block_ptr + 3);\n  int input_shifted_length = input_length << 0x1c;\n\n  if (((input_shifted_length < 0) && (block_remaining_data_length != 0)) || (process_data(block_address, block_ptr, input_shifted_length, block_ptr[4], param_4) == 0)) {\n    if (block_remaining_data_length < block_data_length) {\n      if (process_data(block_address, block_ptr) != 0) {\n        return 0xffffffff;\n      }\n    }\n    block_ptr[2] = block_ptr[2] + -1;\n    undefined *block_data_ptr = (undefined *)*block_ptr;\n    *block_ptr = (int)(block_data_ptr + 1);\n    *block_data_ptr = (char)input_char;\n\n    if (block_remaining_data_length + 1 == block_data_length) {\n      if (-1 < (int)((uint)*(ushort *)(block_ptr + 3) << 0x1f)) {\n        return input_char;\n      }\n      if (input_char != 10) {\n        return input_char;\n      }\n    }\n\n    if (process_data(block_address, block_ptr) == 0) {\n      return input_char;\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "FUN_000054a8",
                "FUN_00004158",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005404",
            "calling": [
                "FUN_000057a8",
                "FUN_00004db8",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "process_input_00005404"
        },
        "FUN_00006974": {
            "renaming": {
                "FUN_00006974": "calculate_result_00006974",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "sign",
                "iVar1": "quotient",
                "uVar2": "result",
                "local_8": "local_buffer"
            },
            "code": "undefined8 calculate_result_00006974(int dividend, int divisor, int remainder, int sign) {\n  int quotient;\n  undefined8 result;\n  undefined local_buffer[8];\n  \n  if (sign == 0 && remainder == 0) {\n    if (divisor < 0) {\n      dividend = 0;\n      divisor = -2147483648;\n    }\n    else if (divisor != 0 || dividend != 0) {\n      divisor = 2147483647;\n      dividend = -1;\n    }\n    return CONCAT44(divisor, dividend);\n  }\n  if (divisor < 0) {\n    quotient = -divisor - (uint)(dividend != 0);\n    if (sign < 0) {\n      result = FUNC_00006a14(-dividend, quotient, -remainder, -sign - (uint)(remainder != 0), local_buffer);\n      return result;\n    }\n    result = FUNC_00006a14(-dividend, quotient, remainder, sign, local_buffer);\n    return CONCAT44(-(int)((ulonglong)result >> 0x20) - (uint)((int)result != 0), -(int)result);\n  }\n  if (sign < 0) {\n    result = FUNC_00006a14(dividend, divisor, -remainder, -sign - (uint)(remainder != 0), local_buffer);\n    return CONCAT44(-(int)((ulonglong)result >> 0x20) - (uint)((int)result != 0), -(int)result);\n  }\n  result = FUNC_00006a14();\n  return result;\n}",
            "called": [
                "FUN_00006a14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006974",
            "calling": [
                "FUN_0000443c"
            ],
            "imported": false,
            "current_name": "calculate_result_00006974"
        },
        "FUN_00004314": {
            "renaming": {
                "FUN_00004314": "allocate_and_initialize_memory_block_00004314",
                "*param_1": "error_code",
                "piVar1": "current_block_ptr",
                "piVar2": "memory_block_ptr",
                "iVar3": "block_size",
                "ppiVar4": "block_list_ptr",
                "PTR_DAT_00004398": "MEMORY_BLOCK_SIZE_PTR",
                "DAT_0000439c": "MEMORY_BLOCK_INIT_VALUE"
            },
            "code": "int * allocate_and_initialize_memory_block_00004314(undefined4 *error_code){\n  int *memory_block_ptr;\n  int *current_block_ptr;\n  int block_size;\n  int **block_list_ptr;\n  do_nothing_and_return();\n  block_size = *(int *)PTR_DAT_00004398;\n  if (*(int *)(block_size + 0x18) == 0) {\n    initialize_memory_block(block_size);\n  }\n  block_list_ptr = (int **)(block_size + 0x48);\n  do {\n    current_block_ptr = block_list_ptr[1];\n    memory_block_ptr = block_list_ptr[2];\n    while (current_block_ptr = (int *)((int)current_block_ptr + -1), -1 < (int)current_block_ptr) {\n      if (*(short *)(memory_block_ptr + 3) == 0) {\n        memory_block_ptr[3] = DAT_0000439c;\n        memory_block_ptr[0x19] = 0;\n        do_nothing(memory_block_ptr + 0x16);\n        do_nothing_and_return();\n        memory_block_ptr[1] = 0;\n        memory_block_ptr[2] = 0;\n        memory_block_ptr[4] = 0;\n        memory_block_ptr[5] = 0;\n        *memory_block_ptr = 0;\n        memory_block_ptr[6] = 0;\n        fill_array_with_value(memory_block_ptr + 0x17,0,8);\n        memory_block_ptr[0xd] = 0;\n        memory_block_ptr[0xe] = 0;\n        memory_block_ptr[0x12] = 0;\n        memory_block_ptr[0x13] = 0;\n        return memory_block_ptr;\n      }\n      memory_block_ptr = memory_block_ptr + 0x1a;\n    }\n    if (*block_list_ptr == (int *)0x0) {\n      current_block_ptr = (int *)allocate_and_initialize_memory_block_00004314(block_size, 4);\n      *block_list_ptr = current_block_ptr;\n      if (current_block_ptr == (int *)0x0) {\n        do_nothing_and_return();\n        *error_code = 0xc;\n        return (int *)0x0;\n      }\n    }\n    block_list_ptr = (int **)*block_list_ptr;\n  } while(true);\n}",
            "called": [
                "FUN_000045e4",
                "FUN_00004274",
                "FUN_00004248",
                "FUN_00004280",
                "FUN_00004622",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004314",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_memory_block_00004314",
            "code_backup": "\nint * FUN_00004314(undefined4 *param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int iVar3;\n  int **ppiVar4;\n  \n  do_nothing_and_return_00004274();\n  iVar3 = *(int *)PTR_DAT_00004398;\n  if (*(int *)(iVar3 + 0x18) == 0) {\n    FUNC_000042a4(iVar3);\n  }\n  ppiVar4 = (int **)(iVar3 + 0x48);\n  do {\n    piVar1 = ppiVar4[1];\n    piVar2 = ppiVar4[2];\n    while (piVar1 = (int *)((int)piVar1 + -1), -1 < (int)piVar1) {\n      if (*(short *)(piVar2 + 3) == 0) {\n        piVar2[3] = DAT_0000439c;\n        piVar2[0x19] = 0;\n        do_nothing_000045e4(piVar2 + 0x16);\n        do_nothing_and_return_00004280();\n        piVar2[1] = 0;\n        piVar2[2] = 0;\n        piVar2[4] = 0;\n        piVar2[5] = 0;\n        *piVar2 = 0;\n        piVar2[6] = 0;\n        fill_array_with_value_00004622(piVar2 + 0x17,0,8);\n        piVar2[0xd] = 0;\n        piVar2[0xe] = 0;\n        piVar2[0x12] = 0;\n        piVar2[0x13] = 0;\n        return piVar2;\n      }\n      piVar2 = piVar2 + 0x1a;\n    }\n    if (*ppiVar4 == (int *)0x0) {\n      piVar1 = (int *)allocate_and_initialize_memory_block_00004248(param_1,4);\n      *ppiVar4 = piVar1;\n      if (piVar1 == (int *)0x0) {\n        do_nothing_and_return_00004280();\n        *param_1 = 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar4 = (int **)*ppiVar4;\n  } while( true );\n}\n\n"
        },
        "FUN_00004dc8": {
            "renaming": {
                "FUN_00004dc8": "compareAndCopyWrapper_00004dc8",
                "param_1": "destination",
                "param_2": "sourceIndex",
                "iVar1": "compareResult",
                "uVar2": "updatedValue",
                "bVar3": "isCompareResultValid"
            },
            "code": "void compareAndCopyWrapper_00004dc8(void* destination, int sourceIndex) {\n  int compareResult = compareAndCopyWrapper_00004dc8_00000490(destination, (int)*(short *)(sourceIndex + 0xe));\n  bool isCompareResultValid = compareResult >= 0;\n  uint updatedValue;\n  if (isCompareResultValid) {\n    updatedValue = *(int *)(sourceIndex + 0x54) + compareResult;\n    *(uint *)(sourceIndex + 0x54) = updatedValue;\n  }\n  else {\n    updatedValue = *(ushort *)(sourceIndex + 0xc) & 0xffffefff;\n    *(short *)(sourceIndex + 0xc) = (short)updatedValue;\n  }\n}\n",
            "called": [
                "FUN_00000490"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dc8",
            "calling": [],
            "imported": false,
            "current_name": "compareAndCopyWrapper_00004dc8"
        },
        "FUN_00005fd8": {
            "renaming": {
                "FUN_00005fd8": "parse_and_convert_number_00005fd8",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "parse_number_00005edc": "parse_number",
                "*DAT_00005fe8": "data"
            },
            "code": "void parse_and_convert_number_00005fd8(int* *DAT_00005fe8, int param1, int param2, int param3) {\n  parse_number(*DAT_00005fe8, param1, param2, param3);\n  return;\n}",
            "called": [
                "FUN_00005edc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd8",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "parse_and_convert_number_00005fd8"
        },
        "FUN_00005e10": {
            "renaming": {
                "FUN_00005e10": "read_byte_from_memory_00005e10",
                "param_1": "memory_block_address",
                "param_2": "current_position",
                "iVar1": "block_status",
                "uVar2": "byte_value",
                "pbVar3": "current_byte",
                "initialize_memory_block_000042a4": "initialize_memory_block",
                "process_data_00006768": "process_data"
            },
            "code": "uint read_byte_from_memory_00005e10(int memory_block_address, byte **current_position) {\n  int block_status = *(int *)(memory_block_address + 0x18);\n  if (memory_block_address != 0 && block_status == 0) {\n    initialize_memory_block();\n  }\n  if (current_position == (byte **)PTR_DAT_00005e5c) {\n    current_position = *(byte ***)(memory_block_address + 4);\n  }\n  else if (current_position == (byte **)PTR_DAT_00005e60) {\n    current_position = *(byte ***)(memory_block_address + 8);\n  }\n  else if (current_position == (byte **)PTR_DAT_00005e64) {\n    current_position = *(byte ***)(memory_block_address + 0xc);\n  }\n  int data_processing_result = process_data(memory_block_address, current_position);\n  if (data_processing_result == 0) {\n    (*current_position)[1] = (*current_position)[1] - 1;\n    byte *current_byte = *current_position;\n    *current_position = current_byte + 1;\n    uint byte_value = (uint)*current_byte;\n    return byte_value;\n  }\n  else {\n    return 0xffffffff;\n  }\n}",
            "called": [
                "FUN_00006768",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e10",
            "calling": [
                "FUN_00004418"
            ],
            "imported": false,
            "current_name": "read_byte_from_memory_00005e10"
        },
        "FUN_000033f4": {
            "renaming": {
                "FUN_000033f4": "calculate_and_execute_alarm_000033f4",
                "param_1": "alarm_time",
                "iVar1": "calculation_result",
                "uVar2": "execution_result",
                "auStack_2c": "calculation_data",
                "calculate_values_and_results_0000328c": "calculate_values_and_results",
                "executeFunctionAndUpdateData_00002654": "executeFunctionAndUpdateData",
                "PTR_FUN_000031e0_1_0000343c": "PTR_FUNCTION_1",
                "process_input": "log_error",
                "PTR_s_rtc__error_setting_alarm_00003440": "PTR_ERROR_SETTING_ALARM"
            },
            "code": "int calculate_and_execute_alarm_000033f4(int alarm_time){\n  int calculation_result;\n  undefined4 execution_result;\n  undefined calculation_data[36];\n  \n  calculation_result = calculate_values_and_results(alarm_time, calculation_data);\n  if (calculation_result == 0) {\n    execution_result = executeFunctionAndUpdateData(calculation_data, PTR_FUN_000031e0_1_0000343c, 0);\n    if (execution_result == -1) {\n      log_error(PTR_s_rtc__error_setting_alarm_00003440);\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n  else {\n    return 1;\n  }\n}",
            "called": [
                "FUN_00002654",
                "FUN_00004db8",
                "FUN_0000328c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033f4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "calculate_and_execute_alarm_000033f4",
            "code_backup": "\nundefined4 FUN_000033f4(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 = calculate_values_and_results_0000328c(param_1,auStack_2c);\n  if (iVar1 == 0) {\n    iVar1 = executeFunctionAndUpdateData_00002654(auStack_2c,PTR_FUN_000031e0_1_0000343c,0);\n    if (iVar1 == -1) {\n      process_input(PTR_s_rtc__error_setting_alarm_00003440);\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_0000443c": {
            "renaming": {
                "FUN_0000443c": "calculate_date_0000443c",
                "param_1": "start_date",
                "param_2": "result",
                "uVar2": "day_of_month",
                "uVar3": "days_since_2000",
                "uVar4": "days_since_1800",
                "uVar5": "years_since_1800",
                "uVar6": "year",
                "uVar7": "month",
                "uVar8": "days_since_1900",
                "bVar9": "is_negative",
                "calculate_result_00006974": "calculate_days_since_2000",
                "DAT_0000458c": "DAYS_IN_MONTH",
                "DAT_00004590": "DAYS_IN_YEAR",
                "DAT_00004594": "DAYS_SINCE_1900",
                "DAT_00004598": "DAYS_IN_4_YEARS"
            },
            "code": "uint* calculate_date_0000443c(uint32_t* start_date, uint32_t* result) {\n  uint32_t year = *start_date;\n  uint32_t month = start_date[1];\n  uint32_t days_since_2000 = calculate_days_since_2000(year, month, DAT_0000458c, 0);\n  bool is_negative = (int)days_since_2000 < 0;\n  if (is_negative) {\n    days_since_2000 += 0x15180;\n  }\n  uint32_t day_of_week = calculate_day_of_week(year, month, days_since_2000);\n  result[2] = days_since_2000 / 0xe10;\n  result[1] = (days_since_2000 % 0xe10) / 0x3c;\n  *result = (days_since_2000 % 0xe10) % 0x3c;\n  result[6] = (day_of_week + 3) % 7;\n  days_since_2000 = (is_negative) ? days_since_2000 - 0x23ab0 : days_since_2000;\n  uint32_t days_since_1900 = DAT_00004594 * (days_since_2000 / DAT_00004590) + days_since_2000;\n  uint32_t days_since_1800 = (days_since_1900 / 0x8eac + days_since_1900) - days_since_1900 / 0x5b4 - days_since_1900 / DAT_00004598;\n  uint32_t years_since_1800 = days_since_1800 / 0x16d;\n  days_since_1900 = (years_since_1800 / 100 - days_since_1800 / 0x5b4) + days_since_1900 + years_since_1800 * -0x16d;\n  uint32_t leap_years = (days_since_1900 < 0x132) ? ((years_since_1800 & 3) == 0 && (years_since_1800 != (years_since_1800 / 100) * 100)) ? 1 : count_leading_zeroes(years_since_1800 % 400) >> 5 : 0;\n  uint32_t day_of_month = (days_since_1900 < 0x132) ? *result + 0x3b + leap_years : *result - 0x132;\n  uint32_t days_in_month = (days_since_1900 < 0x132) ? days_in_month_table[leap_years][*result] : days_in_month_table[0][*result];\n  result[7] = day_of_month;\n  result[3] = days_since_1800 + 1 - (days_since_1800 * 0x99 + 2) / 5;\n  result[4] = days_since_1900 / 365 + 1900;\n  result[5] = days_since_1900 % 365 - 0x76c;\n  result[8] = 0;\n  return result;\n}\n",
            "called": [
                "FUN_00006974"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000443c",
            "calling": [
                "FUN_00002624",
                "FUN_00002690"
            ],
            "imported": false,
            "current_name": "calculate_date_0000443c"
        },
        "FUN_000027b0": {
            "renaming": {
                "FUN_000027b0": "set_flag_and_initialize_000027b0",
                "puVar1": "flag_ptr",
                "DAT_00002814": "flag_data_ptr",
                "DAT_00002818": "data_ptr"
            },
            "code": "void set_flag_and_initialize_000027b0(void)\n{\n  undefined4 *flag_ptr;\n  flag_ptr = DAT_00002814;\n  *(uint *)(DAT_00002818 + 0x103c) = *(uint *)(DAT_00002818 + 0x103c) | 0x20000000;\n  flag_ptr[4] = 1;\n  flag_ptr[4] = 0;\n  if ((flag_ptr[5] & 1) != 0) {\n    *flag_ptr = 0;\n  }\n  flag_ptr[4] = 0x104;\n  flag_ptr[2] = 0xffffff42;\n  flag_ptr[7] = 0;\n  set_flag_on_0000294c();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000027b0",
            "calling": [
                "FUN_000025f4"
            ],
            "imported": false,
            "current_name": "set_flag_and_initialize_000027b0"
        },
        "FUN_00005ebc": {
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "param_1": "destination",
                "param_2": "source",
                "cVar1": "current_char"
            },
            "code": "void copy_string_00005ebc(char *destination, char *source)\n{\n  char current_char;\n  do {\n    current_char = *source;\n    *destination = current_char;\n    source++;\n    destination++;\n  } while (current_char != '\\0');\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ebc",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "copy_string_00005ebc"
        },
        "FUN_00006192": {
            "renaming": {
                "FUN_00006192": "insert_node_if_not_end_00006192",
                "param_1": "value",
                "param_2": "node",
                "PTR_": "",
                "DAT_": "",
                "undefined4": "int",
                "insert_node_at_end_00004b34": "insert_node_at_end"
            },
            "code": "int insert_node_if_not_end_00006192(int value, int *node) {\n  int *next_node = (int *)node[13];\n  if (next_node != NULL && next_node != node + 17) {\n    insert_node_at_end();\n  }\n  node[1] = node[16];\n  node[13] = NULL;\n  if (node[16] != NULL) {\n    *node = node[15];\n    return 0;\n  }\n  *node = node[4];\n  node[1] = 0;\n  *(unsigned short *)(node + 6) |= 0x20;\n  return -1;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006192",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "insert_node_if_not_end_00006192"
        },
        "FUN_00001734": {
            "renaming": {
                "FUN_00001734": "null_terminate_string_00001734",
                "DAT_00001744": "string",
                "null_terminate_string_00001710": "null_terminate_string",
                "PTR_": "PTR_ (unchanged)"
            },
            "code": "void null_terminate_string_00001734(char* DAT_00001744, int length)\n{\n    DAT_00001744[length-1] = '\\0';\n}\n",
            "called": [
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001734",
            "calling": [
                "FUN_000019c0",
                "FUN_00001a18",
                "FUN_00001a3c"
            ],
            "imported": false,
            "current_name": "null_terminate_string_00001734"
        },
        "FUN_00000e14": {
            "renaming": {
                "FUN_00000e14": "compare_and_copy_wrapper_00000e14",
                "param_1": "val1",
                "param_2": "val2",
                "uVar1": "result",
                "DAT_00000e34": "data"
            },
            "code": "int compare_and_copy_wrapper_00000e14(void *DAT_00000e34, int val1, int val2) {\n  int result = compare_and_copy(DAT_00000e34, val1, val2);\n  return result;\n}",
            "called": [
                "FUN_000012e2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e14",
            "calling": [
                "FUN_00000490"
            ],
            "imported": false,
            "current_name": "compare_and_copy_wrapper_00000e14"
        },
        "FUN_0000281c": {
            "renaming": {
                "FUN_0000281c": "find_first_different_value_0000281c",
                "local_10": "index",
                "local_c": "current_value",
                "*DAT_00002858": "initial_value"
            },
            "code": "int find_first_different_value_0000281c(void)\n{\n  int index = 0;\n  int current_value;\n  int *DAT_00002858 = *DAT_00002858;\n  while (index < 3 && (current_value = *DAT_00002858, current_value != *DAT_00002858)) {\n    index++;\n  }\n  return current_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000281c",
            "calling": [
                "FUN_00002624"
            ],
            "imported": false,
            "current_name": "find_first_different_value_0000281c"
        },
        "FUN_00002270": {
            "renaming": {
                "FUN_00002270": "is_ptr_equal_to_ptr_plus_0xc_00002270",
                "param_1": "ptr",
                "iVar2": "ptr_plus_0xc",
                "bVar3": "is_equal",
                "uVar1": "result"
            },
            "code": "bool is_ptr_equal_to_ptr_plus_0xc_00002270(int ptr)\n{\n  int ptr_plus_0xc = *(int *)(ptr + 0xc);\n  bool is_equal = *(int *)(ptr + 8) == ptr_plus_0xc;\n  if (is_equal) {\n    return true;\n  }\n  else {\n    return false;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002270",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": false,
            "current_name": "is_ptr_equal_to_ptr_plus_0xc_00002270"
        },
        "FUN_00005780": {
            "renaming": {
                "FUN_00005780": "insert_node_at_end_of_list_00005780",
                "param_1": "data",
                "*DAT_0000578c": "head"
            },
            "code": "void insert_node_at_end_of_list_00005780(void* *DAT_0000578c, undefined4 data)\n{\n  insert_node_at_end_00004b34(**DAT_0000578c, data);\n  return;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005780",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "insert_node_at_end_of_list_00005780"
        },
        "FUN_000020cc": {
            "renaming": {
                "FUN_000020cc": "decode_and_process_data_000020cc",
                "DAT_000020dc": "data_to_decode",
                "decode_data_00002028": "decode_data"
            },
            "code": "void decode_and_process_data_000020cc(void)\n{\n  decode_data(DAT_000020dc, 1);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020cc",
            "calling": [],
            "imported": false,
            "current_name": "decode_and_process_data_000020cc"
        },
        "FUN_00002396": {
            "renaming": {
                "FUN_00002396": "initialize_flag_and_data_00002396",
                "DAT_000025f4": "N/A",
                "PTR_": "N/A",
                "initialize_flag_and_data_000025f4": "N/A"
            },
            "code": "void initialize_flag_and_data_00002396(void)\n{\n  initialize_flag();\n  initialize_data();\n  return;\n}",
            "called": [
                "FUN_000025f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002396",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "initialize_flag_and_data_00002396"
        },
        "FUN_00004cb4": {
            "renaming": {
                "FUN_00004cb4": "process_input_00004cb4",
                "param_1": "input_char",
                "puVar1": "memory_block",
                "uVar2": "memory_block_2_value",
                "puVar3": "memory_block_0",
                "unaff_r4": "unused_var_1",
                "unaff_r5": "unused_var_2",
                "DAT_00004cd8": "global_var",
                "initialize_memory_block_000042a4": "initialize_memory_block",
                "PTR_DAT_00005e04": "memory_block_1",
                "PTR_DAT_00005e08": "memory_block_2",
                "PTR_DAT_00005e0c": "memory_block_3",
                "do_nothing_000045e8": "do_nothing",
                "process_input_00005404": "process_input_helper"
            },
            "code": "uint process_input_00004cb4(uint input_char){\n  uint return_value;\n  uint *memory_block = *(uint **)(DAT_00004cd8 + 8);\n  if ((DAT_00004cd8 != 0) && (*(int *)(DAT_00004cd8 + 0x18) == 0)) {\n    initialize_memory_block(DAT_00004cd8);\n  }\n  if (memory_block == (uint *)PTR_DAT_00005e04) {\n    memory_block = *(uint **)(DAT_00004cd8 + 4);\n  }\n  else if (memory_block == (uint *)PTR_DAT_00005e08) {\n    memory_block = *(uint **)(DAT_00004cd8 + 8);\n  }\n  else if (memory_block == (uint *)PTR_DAT_00005e0c) {\n    memory_block = *(uint **)(DAT_00004cd8 + 0xc);\n  }\n  if ((-1 < (int)(memory_block[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(memory_block + 3) << 0x16))) {\n    do_nothing(memory_block[0x16]);\n  }\n  uint PTR_DAT_00005e08_value = memory_block[2] - 1;\n  memory_block[2] = PTR_DAT_00005e08_value;\n  if (((int)PTR_DAT_00005e08_value < 0) && (((int)PTR_DAT_00005e08_value < (int)memory_block[6] || (input_char == 10))))\n  {\n    return_value = process_input_00004cb4_helper(DAT_00004cd8,input_char,memory_block,input_char,unused_var_1,unused_var_2);\n  }\n  else {\n    uchar *memory_block_0 = (uchar *)*memory_block;\n    *memory_block = memory_block_0 + 1;\n    *memory_block_0 = (char)input_char;\n    return_value = input_char & 0xff;\n  }\n  if ((-1 < (int)(memory_block[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(memory_block + 3) << 0x16))) {\n    do_nothing(memory_block[0x16]);\n  }\n  return return_value;\n}",
            "called": [
                "FUN_00005404",
                "FUN_000045e8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cb4",
            "calling": [
                "FUN_00002a00"
            ],
            "imported": false,
            "current_name": "process_input_00004cb4"
        },
        "FUN_00003478": {
            "renaming": {
                "FUN_00003478": "calculate_and_process_00003478_00003478",
                "param_1": "input_value",
                "iVar1": "calculation_result",
                "uVar2": "return_value",
                "auStack_2c": "process_data"
            },
            "code": "int calculate_and_process_00003478_00003478(int input_value)\n{\n  int calculation_result;\n  undefined4 process_data[9];\n  \n  calculation_result = calculate_values_and_results_0000328c(input_value, process_data);\n  if (calculation_result == 0) {\n    calculation_result = process_data_00002600(process_data);\n    if (calculation_result == -1) {\n      process_input(PTR_s_rtc__error_setting_time_000034bc);\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n  else {\n    return 1;\n  }\n}",
            "called": [
                "FUN_0000328c",
                "FUN_00002600",
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003478",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "calculate_and_process_00003478_00003478",
            "code_backup": "\nundefined4 FUN_00003478(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 = calculate_values_and_results_0000328c(param_1,auStack_2c);\n  if (iVar1 == 0) {\n    iVar1 = process_data_00002600(auStack_2c);\n    if (iVar1 == -1) {\n      process_input(PTR_s_rtc__error_setting_time_000034bc);\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_00002028": {
            "renaming": {
                "FUN_00002028": "decode_data_00002028",
                "param_1": "data",
                "param_2": "flag",
                "iVar1": "extracted_bits",
                "uVar2": "flag_copy",
                "local_c": "bit_index"
            },
            "code": "void decode_data_00002028(int data, uint32_t flag)\n{\n    int bit_index;\n    uint32_t flag_copy = *(uint32_t *)(data + 0xa0);\n    for (bit_index = 0; bit_index < 32; bit_index++) {\n        if (((flag_copy & (1 << bit_index)) != 0) && ((*(uint32_t *)(data + bit_index * 4) & 0xf0000) != 0)) {\n            *(uint32_t *)(data + 0xa0) = (1 << bit_index);\n            int extracted_bits = extract_bits(flag, bit_index);\n            (**(code **)(PTR_DAT_000020b4 + extracted_bits * 0xc))(*(uint32_t *)(PTR_DAT_000020b4 + extracted_bits * 0xc + 4));\n        }\n    }\n    check_and_set_flag_if_not_zero_00001cf0();\n    return;\n}",
            "called": [
                "FUN_00001cf0",
                "FUN_00001e0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002028",
            "calling": [
                "FUN_000020f4",
                "FUN_000020e0",
                "FUN_000020b8",
                "FUN_000020cc",
                "FUN_00002108"
            ],
            "imported": false,
            "current_name": "decode_data_00002028"
        },
        "FUN_000016c8": {
            "renaming": {
                "FUN_000016c8": "set_calculated_result_to_one_and_return_000016c8",
                "param_1": "result",
                "param_2": "param_2",
                "puVar1": "result_ptr",
                "calculate_result_00001696": "calculate_result"
            },
            "code": "void set_calculated_result_to_one_and_return_000016c8(void* result, int param_2)\n{\n  int *result_ptr = (int *)calculate_result(param_1,param_2);\n  *result_ptr = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016c8",
            "calling": [
                "FUN_000017dc"
            ],
            "imported": false,
            "current_name": "set_calculated_result_to_one_and_return_000016c8"
        },
        "FUN_00001a60": {
            "renaming": {
                "FUN_00001a60": "initialize_data_00001a60",
                "DAT_00001ac4": "input_string",
                "DAT_00001ac8": "flag",
                "set_result_to_one_000016ec": "set_result",
                "DAT_00001acc": "success_flag",
                "PTR_DAT_00001ad0": "result_pointer"
            },
            "code": "void initialize_data_00001a60(void)\n{\n  null_terminate_string(DAT_00001ac4, 1);\n  *DAT_00001ac8 = *DAT_00001ac8 & 0x3f | 0x80;\n  while ((DAT_00001ac8[6] & 0xc) != 8);\n  set_result(DAT_00001acc, 6);\n  while ((DAT_00001ac8[6] & 0x20) == 0);\n  while ((DAT_00001ac8[6] & 0x40) == 0);\n  *PTR_DAT_00001ad0 = 6;\n  return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a60",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_data_00001a60"
        },
        "FUN_0000099c": {
            "renaming": {
                "FUN_0000099c": "initialize_and_allocate_resources_0000099c",
                "uStack_18": "stack_var",
                "local_14": "local_ptr1",
                "local_10": "local_ptr2",
                "local_c": "local_ptr3",
                "initialize_data_and_calculated_value_to_zero_00000db0": "initialize_data_and_calculated_value_to_zero",
                "DAT_00000a1c": "default_value",
                "PTR_Elf32_Rel_ARRAY_00000a20": "rel_array_ptr",
                "PTR_DAT_00000a24": "rel_array_end_ptr",
                "PTR_DAT_00000a28": "bss_start_ptr",
                "DAT_00000a2c": "bss_end_ptr",
                "do_nothing_00000990": "do_nothing",
                "set_flags_and_update_memory_00000e64": "set_flags_and_update_memory",
                "execute_functions_and_store_input_value_0000459c": "execute_functions_and_store_input_value",
                "allocate_and_initialize_irq_handler_00000f8c": "allocate_and_initialize_irq_handler"
            },
            "code": "void initialize_and_allocate_resources_0000099c(void)\n{\n    undefined4 stack_var;\n    undefined4 *local_ptr1;\n    undefined4 *local_ptr2;\n    undefined4 *local_ptr3;\n    \n    local_ptr1 = &stack_var;\n    local_ptr2 = data_array;\n    initialize_data_and_calculated_value_to_zero();\n    local_ptr3 = relocation_array;\n    while (local_ptr3 < &stack_var) {\n        *local_ptr3 = DAT_00000a1c;\n        local_ptr3++;\n    }\n    local_ptr3 = PTR_Elf32_Rel_ARRAY_00000a20;\n    while (local_ptr3 < PTR_DAT_00000a24) {\n        *local_ptr3 = *local_ptr2;\n        local_ptr2++;\n        local_ptr3++;\n    }\n    local_ptr3 = PTR_DAT_00000a28;\n    while (local_ptr3 < DAT_00000a2c) {\n        *local_ptr3 = 0;\n        local_ptr3++;\n    }\n    do_nothing();\n    set_flags_and_update_memory();\n    execute_functions_and_store_input_value();\n    allocate_and_initialize_irq_handler();\n    return;\n}\n",
            "called": [
                "FUN_00000f8c",
                "FUN_00000e64",
                "FUN_00000db0",
                "FUN_0000459c",
                "FUN_00000990"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000099c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_and_allocate_resources_0000099c"
        },
        "FUN_00002d94": {
            "renaming": {
                "FUN_00002d94": "process_input_and_return_00002d94",
                "param_1": "input_buffer",
                "param_2": "buffer_size",
                "iVar1": "input_byte",
                "bVar2": "return_value",
                "bVar3": "is_buffer_empty",
                "local_c": "current_char"
            },
            "code": "uint process_input_and_return_00002d94(uint8_t *input_buffer, int buffer_size) {\n  int input_byte;\n  uint8_t *current_char = input_buffer;\n  while ( true ) {\n    if (buffer_size + -1 <= (int)current_char - (int)input_buffer) {\n      return 0xffffffff;\n    }\n    input_byte = read_byte_from_memory();\n    if (input_byte < 0) break;\n    if ((input_byte == 0xd) || (input_byte == 10)) {\n      *current_char = 0;\n      process_input_and_return_00002d94(0xd);\n      process_input_and_return_00002d94(10);\n      bool is_buffer_empty = current_char == input_buffer;\n      if (is_buffer_empty) {\n        input_buffer = (uint8_t *)0x1;\n      }\n      byte return_value = (byte)input_buffer;\n      if (!is_buffer_empty) {\n        return_value = 0;\n      }\n      return (uint)return_value;\n    }\n    if ((input_byte == 8) || (input_byte == 0x7f)) {\n      if (current_char != input_buffer) {\n        current_char = current_char + -1;\n        *current_char = 0;\n        process_input_and_return_00002d94(8);\n        process_input_and_return_00002d94(0x20);\n        process_input_and_return_00002d94(8);\n      }\n    }\n    else {\n      *current_char = (char)input_byte;\n      process_input_and_return_00002d94(input_byte);\n      current_char = current_char + 1;\n    }\n  }\n  return 1;\n}",
            "called": [
                "FUN_00002a00",
                "FUN_00004418"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002d94",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "process_input_and_return_00002d94"
        },
        "FUN_00003918": {
            "renaming": {
                "FUN_00003918": "get_value_from_param_00003918",
                "param_1": "param"
            },
            "code": "int get_value_from_param_00003918(int param) {\n    switch(param) {\n        case 2:\n            return 0x68;\n        case 3:\n            return 0x6b;\n        case 6:\n            return 0x4d;\n        case 9:\n            return 0x47;\n        case 0xc:\n            return 0x54;\n        case 0xf:\n            return 0x50;\n        case 0xf1:\n            return 0x66;\n        case 0xf4:\n            return 0x70;\n        case 0xf7:\n            return 0x6e;\n        case 0xfa:\n            return 0x75;\n        case 0xfd:\n            return 0x6d;\n        default:\n            return 0;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003918",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "get_value_from_param_00003918"
        },
        "FUN_00003d64": {
            "renaming": {
                "FUN_00003d64": "execute_function_00003d64",
                "param_1": "function_pointer",
                "param_2": "argument",
                "uVar1": "result"
            },
            "code": "int execute_function_00003d64(int function_pointer, int argument){\n  int result;\n  if (function_pointer == 0) {\n    result = -19;\n  }\n  else {\n    result = (***(int ***)(function_pointer + 0xc))(*(int *)(function_pointer + 4), argument);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d64",
            "calling": [
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "execute_function_00003d64"
        },
        "FUN_00004e52": {
            "renaming": {
                "FUN_00004e52": "compare_bytes_00004e52",
                "param_1": "first_array",
                "param_2": "second_array",
                "uVar2": "index",
                "bVar1": "second_byte",
                "bVar3": "is_match"
            },
            "code": "int compare_bytes_00004e52(byte *first_array,byte *second_array)\n{\n  byte first_byte;\n  byte second_byte;\n  uint index = 0;\n  bool is_match;\n  do {\n    first_byte = *first_array;\n    second_byte = *second_array;\n    is_match = (first_byte == 1);\n    if (first_byte != 0) {\n      is_match = (first_byte == second_byte);\n    }\n    first_array = first_array + 1;\n    second_array = second_array + 1;\n    index = index + 1;\n  } while (is_match);\n  return (uint)first_byte - (uint)second_byte;\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e52",
            "calling": [
                "FUN_00002b10",
                "FUN_00004e52",
                "FUN_00005100",
                "FUN_00002fe0",
                "FUN_0000316c",
                "FUN_00002a18"
            ],
            "imported": false,
            "current_name": "compare_bytes_00004e52"
        },
        "FUN_000010d4": {
            "renaming": {
                "FUN_000010d4": "allocate_resource_000010d4",
                "param_1": "resource_size",
                "param_2": "resource_type",
                "param_3": "resource_flags",
                "param_4": "resource_alignment",
                "param_5": "param_5",
                "param_6": "param_6",
                "param_7": "param_7",
                "uVar1": "irq_flags",
                "uVar2": "resource_allocation_result",
                "iVar3": "resource_id",
                "uVar4": "aligned_resource_size",
                "puVar5": "resource_ptr",
                "local_30": "padding_size",
                "local_2c": "aligned_resource_address",
                "local_10": "i",
                "local_c": "list_index",
                "local_a": "first_free_resource_id",
                "PTR_DAT_0000126c": "resource_list_address",
                "PTR_DAT_00001270": "resource_count_address"
            },
            "code": "int allocate_resource_000010d4(uint resource_size, int resource_type, byte resource_flags, uint resource_alignment, undefined4 param_5, undefined4 param_6, undefined4 param_7)\n{\n    undefined4 irq_flags;\n    undefined4 resource_allocation_result;\n    int resource_id;\n    uint aligned_resource_size;\n    uint padding_size;\n    undefined4 *resource_ptr;\n    int i;\n    short first_free_resource_id = 0;\n    short resource_count = 0;\n\n    if (resource_flags < 0x10) {\n        padding_size = 0;\n        aligned_resource_size = resource_size;\n        if ((resource_size & 3) != 0) {\n            padding_size = 4 - (resource_size & 3);\n            aligned_resource_size = padding_size + resource_size;\n        }\n        aligned_resource_size = aligned_resource_size - 0x30U & 0xfffffffc;\n        resource_ptr = (undefined4 *)(aligned_resource_size + resource_alignment);\n        if ((resource_flags & 8) == 0) {\n            *(uint *)resource_alignment = resource_alignment;\n        }\n        else {\n            for (i = resource_alignment; i < aligned_resource_size + resource_alignment; i = i + 4) {\n                *(uint *)i = i;\n            }\n        }\n        irq_flags = check_for_enabled_IRQ_interrupts_00000cd0();\n        for (i = 1; i < 0x21; i = i + 1) {\n            if (*(int *)(PTR_DAT_0000126c + i * 4) == 0) {\n                first_free_resource_id = i;\n                break;\n            }\n        }\n        if (first_free_resource_id == 0) {\n            enableIRQinterrupts_if_privileged_00000d0c(irq_flags);\n            resource_allocation_result = -0x8b;\n        }\n        else {\n            *(undefined4 **)(PTR_DAT_0000126c + first_free_resource_id * 4) = resource_ptr;\n            *(short *)((int)resource_ptr + 6) = first_free_resource_id;\n            resource_allocation_result = allocate_memory_000007dc(param_5, param_6, resource_alignment, aligned_resource_size);\n            *resource_ptr = resource_allocation_result;\n            resource_ptr[9] = resource_alignment;\n            resource_ptr[0xb] = resource_type;\n            resource_ptr[10] = param_7;\n            *(byte *)((int)resource_ptr + 5) = resource_flags;\n            *(undefined *)(resource_ptr + 1) = 0;\n            resource_ptr[2] = 0;\n            resource_ptr[3] = 0;\n            resource_ptr[4] = 0;\n            initialize_bitmask_00000fec(resource_ptr + 5,0);\n            resource_ptr[8] = 0;\n            *(int *)PTR_DAT_00001270 = *(int *)PTR_DAT_00001270 + 1;\n            if ((resource_flags & 1) == 0) {\n                update_list_00000698(resource_ptr, 10);\n                if ((resource_flags & 4) == 0) {\n                    enableIRQinterrupts_if_privileged_00000d0c(irq_flags);\n                    check_exception_00000738(resource_flags);\n                    return (int)first_free_resource_id;\n                }\n            }\n            else {\n                update_list_00000698(resource_ptr, 1);\n            }\n            enableIRQinterrupts_if_privileged_00000d0c(irq_flags);\n            resource_id = (int)first_free_resource_id;\n        }\n    }\n    else {\n        resource_id = -0x16;\n    }\n    return resource_id;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000fec",
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_00000738",
                "FUN_000007dc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010d4",
            "calling": [
                "FUN_00000f8c"
            ],
            "imported": false,
            "current_name": "allocate_resource_000010d4"
        },
        "FUN_000045e4": {
            "renaming": {
                "FUN_000045e4": "do_nothing_000045e4"
            },
            "code": "\nvoid do_nothing_000045e4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e4",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e4"
        },
        "FUN_00000738": {
            "renaming": {
                "FUN_00000738": "check_exception_00000738",
                "param_1": "exception_number",
                "iVar1": "current_exception_number",
                "get_current_exception_number_if_privileged_mode_00000d2a": "get_current_exception_number_if_privileged_mode",
                "set_flag_on_0000093c": "set_exception_flag",
                "PTR_DAT_0000078c": "PTR_DAT_max_min_exception_numbers",
                "PTR_DAT_00000790": "PTR_DAT_exception_flag"
            },
            "code": "void check_exception_00000738(ushort exception_number)\n{\n  int current_exception_number = get_current_exception_number_if_privileged_mode();\n  int max_exception_number = *(byte *)(*(int *)PTR_DAT_0000078c + 4);\n  int min_exception_number = *(byte *)(*(int *)PTR_DAT_0000078c + 5);\n  \n  if (max_exception_number < 9 || exception_number < min_exception_number) {\n    if (current_exception_number == 0) {\n      set_exception_flag();\n    }\n    else {\n      *(undefined4 *)PTR_DAT_00000790 = 1;\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00000d2a",
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000738",
            "calling": [
                "FUN_000010d4",
                "FUN_000024bc"
            ],
            "imported": false,
            "current_name": "check_exception_00000738"
        },
        "FUN_00003e58": {
            "renaming": {
                "FUN_00003e58": "calculate_signed_number_of_digits_00003e58",
                "param_1": "number_string",
                "param_2": "number",
                "iVar1": "number_of_digits",
                "local_18": "absolute_number",
                "local_14": "number_string_copy"
            },
            "code": "int calculate_signed_number_of_digits_00003e58(char *number_string, int number) {\n    int number_of_digits = calculate_number_of_digits(number);\n    if (number < 0) {\n        *number_string = '-';\n        number_string++;\n        number_of_digits++;\n        number = -number;\n    }\n    number_of_digits += calculate_digits_00003dc4(number_string, number);\n    return number_of_digits;\n}",
            "called": [
                "FUN_00003dc4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e58",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": false,
            "current_name": "calculate_signed_number_of_digits_00003e58"
        },
        "FUN_00004e26": {
            "renaming": {
                "FUN_00004e26": "set_parameter_00004e26",
                "param_1": "parameter_value",
                "param_2": "parameter_data",
                "iVar1": "result",
                "uVar2": "updated_value",
                "bVar3": "is_error"
            },
            "code": "void set_parameter_00004e26(int parameter_value, int* parameter_data) {\n  int result = set_param_to_19_000004f2(parameter_value, (int)*(short *)(parameter_data + 0xe));\n  bool is_error = result == -1;\n  ushort updated_value;\n  if (is_error) {\n    updated_value = *(ushort *)(parameter_data + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(parameter_data + 0x54) = result;\n    updated_value = *(ushort *)(parameter_data + 0xc) | 0x1000;\n  }\n  *(ushort *)(parameter_data + 0xc) = updated_value;\n}\n",
            "called": [
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e26",
            "calling": [],
            "imported": false,
            "current_name": "set_parameter_00004e26"
        },
        "FUN_000045e8": {
            "renaming": {
                "FUN_000045e8": "do_nothing_000045e8"
            },
            "code": "\nvoid do_nothing_000045e8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e8",
            "calling": [
                "FUN_000057f8",
                "FUN_00005fec",
                "FUN_00004db8",
                "FUN_00005790",
                "FUN_00004274",
                "FUN_0000428c",
                "FUN_00004158",
                "FUN_00004418",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e8"
        },
        "FUN_000057f8": {
            "renaming": {
                "FUN_000057f8": "FUNC_000057f8"
            },
            "code": "\nint FUNC_000057f8(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  int iVar4;\n  int *piVar5;\n  bool bVar6;\n  byte *pbVar7;\n  int unaff_r7;\n  byte *pbVar8;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 uStack_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    initialize_memory_block_000042a4();\n  }\n  if (param_2 == PTR_DAT_00005a38) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR_DAT_00005a3c) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR_DAT_00005a40) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n    do_nothing_000045e8(*(undefined4 *)(param_2 + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar3 = process_data_000054a8(param_1,param_2), iVar3 != 0)) {\n    if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n      do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n    }\n    return -1;\n  }\n  puVar1 = PTR_s___0__00005a44;\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar8 = param_3;\n  local_8c = param_4;\nLAB_0000588e:\n  pbVar7 = pbVar8;\n  if (*pbVar7 != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  pbVar8 = pbVar7 + 1;\n  if (*pbVar7 != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  iVar3 = (int)pbVar7 - (int)param_3;\n  if (iVar3 != 0) {\n    iVar4 = process_input_000057d2(param_1,param_2,param_3,iVar3);\n    if (iVar4 == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n        do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar3;\n  }\n  if (*pbVar7 == 0) goto LAB_00005a06;\n  local_84 = -1;\n  uStack_80 = 0;\n  local_88 = 0;\n  local_7c = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar8 = pbVar7 + 1;\n  while( true ) {\n    pbVar7 = pbVar8 + 1;\n    iVar3 = find_byte_sequence_00006010(PTR_s___0__00005a44,*pbVar8,5);\n    puVar2 = PTR_DAT_00005a54;\n    if (iVar3 == 0) break;\n    local_88 = 1 << (iVar3 - (int)puVar1 & 0xffU) | local_88;\n    pbVar8 = pbVar7;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar8 == 0x2a) {\n    piVar5 = local_8c + 1;\n    local_7c = *local_8c;\n    local_8c = piVar5;\n    if (local_7c < 0) {\n      local_7c = -local_7c;\n      local_88 = local_88 | 2;\n    }\n  }\n  else {\n    bVar6 = false;\n    iVar3 = local_7c;\n    pbVar7 = pbVar8;\n    while( true ) {\n      if (9 < *pbVar7 - 0x30) break;\n      iVar3 = iVar3 * 10 + (*pbVar7 - 0x30);\n      bVar6 = true;\n      pbVar7 = pbVar7 + 1;\n    }\n    if (bVar6) {\n      local_7c = iVar3;\n    }\n  }\n  if (*pbVar7 == 0x2e) {\n    if (pbVar7[1] == 0x2a) {\n      local_84 = *local_8c;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n      pbVar7 = pbVar7 + 2;\n      local_8c = local_8c + 1;\n    }\n    else {\n      bVar6 = false;\n      local_84 = 0;\n      iVar3 = 0;\n      while( true ) {\n        pbVar7 = pbVar7 + 1;\n        if (9 < *pbVar7 - 0x30) break;\n        iVar3 = iVar3 * 10 + (*pbVar7 - 0x30);\n        bVar6 = true;\n      }\n      if (bVar6) {\n        local_84 = iVar3;\n      }\n    }\n  }\n  iVar3 = find_byte_sequence_00006010(PTR_DAT_00005a54,*pbVar7,3);\n  if (iVar3 != 0) {\n    local_88 = local_88 | 0x40 << (iVar3 - (int)puVar2 & 0xffU);\n    pbVar7 = pbVar7 + 1;\n  }\n  param_3 = pbVar7 + 1;\n  local_70 = *pbVar7;\n  iVar3 = find_byte_sequence_00006010(PTR_s_efgEFG_00005a48,local_70,6);\n  if (iVar3 == 0) {\n    iVar3 = FUNC_00005b34(param_1,&local_88,param_2,DAT_00005a50,&local_8c);\n  }\n  else {\n    iVar3 = param_1;\n    if (DAT_00005a4c == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar3 = unaff_r7;\n      goto LAB_000059b4;\n    }\n  }\n  if (iVar3 == -1) goto LAB_00005a06;\nLAB_000059b4:\n  local_74 = local_74 + iVar3;\n  pbVar8 = param_3;\n  unaff_r7 = iVar3;\n  goto LAB_0000588e;\n}\n\n",
            "called": [
                "FUN_00005b34",
                "FUN_00006010",
                "FUN_000045e8",
                "FUN_000054a8",
                "FUN_000045ec",
                "FUN_000042a4",
                "FUN_000057d2"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000057f8",
            "calling": [
                "FUN_00004c84"
            ],
            "imported": false,
            "current_name": "FUNC_000057f8"
        },
        "FUN_000018bc": {
            "renaming": {
                "FUN_000018bc": "set_param_value_and_terminate_string_000018bc",
                "setParamValue_00001748": "set_parameter_value",
                "DAT_00001910": "data_pointer",
                "null_terminate_string_00001710": "null_terminate_string",
                "DAT_00001914": "data_string",
                "PTR_DAT_00001918": "pointer_data"
            },
            "code": "void set_param_value_and_terminate_string_000018bc(void)\n{\n  set_parameter_value(160);\n  *DAT_00001910 = *DAT_00001910 & 59 | 4;\n  null_terminate_string(DAT_00001914, 1);\n  while((DAT_00001910[6] & 16) == 0);\n  while((DAT_00001910[6] & 12) != 0);\n  *PTR_DAT_00001918 = 0;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000018bc",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_param_value_and_terminate_string_000018bc"
        },
        "FUN_00000f04": {
            "renaming": {
                "FUN_00000f04": "process_input_00000f04",
                "param_1": "input_char",
                "param_2": "param_2",
                "uStack_18": "stack_var_18",
                "UNRECOVERED_JUMPTABLE": "jumptable_ptr",
                "local_10": "local_var_10",
                "local_9": "local_var_9"
            },
            "code": "void process_input_00000f04(char input_char, undefined4 param_2)\n{\n    undefined4 stack_var_18;\n    code *jumptable_ptr;\n    undefined4 local_var_10;\n    char local_var_9;\n\n    local_var_10 = param_2;\n    local_var_9 = input_char;\n\n    if (*piRam00000f4c == 0) {\n        *piRam00000f4c = 1;\n        if (input_char == '\\x03') {\n            execute_interrupt_handler();\n        }\n        process_data(uRam00000f50, local_var_10);\n        process_data(uRam00000f54);\n        process_data(uRam00000f58);\n    }\n\n    check_for_enabled_IRQ_interrupts();\n    do_nothing();\n    jumptable_ptr = (code *)0xf4d;\n    wait_for_IRQ_interrupts();\n    stack_var_18 = (int)&stack_var_18 + 1;\n    do_nothing();\n    process_data(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n    process_input_00000f04_with_interrupts();\n    (*jumptable_ptr)(0);\n    return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_0000211c",
                "FUN_00002400",
                "FUN_00000ed8",
                "FUN_00000ef8",
                "FUN_00000cd0",
                "FUN_000023a4",
                "FUN_00000e58"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f04",
            "calling": [
                "FUN_000013b8",
                "FUN_00003ec4",
                "FUN_00000cc0",
                "FUN_00000fec",
                "FUN_00001034",
                "FUN_00000a30"
            ],
            "imported": false,
            "current_name": "process_input_00000f04"
        },
        "FUN_00000610": {
            "renaming": {
                "FUN_00000610": "set_flag_if_not_already_set_00000610",
                "iVar1": "zeroes_count",
                "iVar2": "current_index",
                "uVar3": "return_value",
                "PTR_DAT_00000684": "flag_pointer",
                "PTR_DAT_00000688": "current_index_pointer",
                "PTR_DAT_0000068c": "zeroes_count_pointer",
                "PTR_DAT_00000690": "flag_indexes_pointer"
            },
            "code": "int set_flag_if_not_already_set_00000610() {\n    int current_index = *(int *)PTR_DAT_00000688;\n    *(undefined4 *)PTR_DAT_00000684 = 0;\n    int zeroes_count = count_leading_zeroes_in_uint32_t_00000566(*(undefined4 *)PTR_DAT_0000068c);\n    int flag_index = **(int **)(PTR_DAT_00000690 + zeroes_count * 4);\n\n    if (current_index != flag_index + -8) {\n        if ((current_index != 0) && (*(char *)(current_index + 4) == '\t')) {\n            *(undefined *)(current_index + 4) = 10;\n        }\n        *(undefined *)(flag_index - 4) = 9;\n        *(undefined2 *)PTR_DAT_00000694 = *(undefined2 *)(flag_index - 2);\n        *(int *)PTR_DAT_00000688 = flag_index - 8;\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\n",
            "called": [
                "FUN_00000566"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000610",
            "calling": [],
            "imported": false,
            "current_name": "set_flag_if_not_already_set_00000610"
        },
        "FUN_00003694": {
            "renaming": {
                "FUN_00003694": "display_data_object_00003694",
                "param_1": "object_address",
                "param_2": "object_size",
                "uVar1": "ptr_from_switch_case",
                "cVar2": "is_bit_set",
                "uVar3": "bit_mask",
                "bVar4": "is_bit_set_bool",
                "auStack_18": "stack_data",
                "local_10": "digit_count",
                "local_a": "value",
                "local_9": "i"
            },
            "code": "void display_data_object_00003694(int object_address, byte object_size)\n{\n    undefined4 uVar1;\n    char is_bit_set;\n    uint bit_mask;\n    bool is_bit_set_bool;\n    undefined stack_data[8];\n    int digit_count;\n    int index;\n    char value;\n    byte i;\n    if ((object_address == 0) || (object_size > 3))\n    {\n        display_error_message(\"Unable to display data object\");\n    }\n    else\n    {\n        process_data(\"Data:\");\n        for (i = 0; i < object_size; i++)\n        {\n            if (*(byte *)(object_address + 6) < 0x14)\n            {\n                bit_mask = 1 << (uint)*(byte *)(object_address + 6);\n                is_bit_set_bool = bit_mask != 0;\n                if (is_bit_set_bool)\n                {\n                    bit_mask = 1;\n                }\n                is_bit_set = (char)bit_mask;\n                if (!is_bit_set_bool)\n                {\n                    is_bit_set = '\\0';\n                }\n                if (is_bit_set == '\\0')\n                {\n                    continue;\n                }\n                value = '\\0';\n            }\n            else\n            {\n                value = get_value_from_param((int)*(char *)(object_address + 7));\n            }\n            process_data(\"[\", i, \"]\");\n            if (object_size < 2)\n            {\n                process_data(\"= \");\n            }\n            else\n            {\n                process_data(\"[\", i, \"] = \");\n            }\n            if (value == '\\0')\n            {\n                if (*(char *)(object_address + 7) == '\\0')\n                {\n                    process_data((int)*(short *)(object_address + (uint)i * 2));\n                }\n                else if ((*(char *)(object_address + 7) + 4 < 0 == SCARRY4((int)*(char *)(object_address + 7), 4)) && (*(char *)(object_address + 7) < '\\0'))\n                {\n                    digit_count = count_digits(stack_data, (int)*(short *)(object_address + (uint)i * 2), (int)*(char *)(object_address + 7));\n                    stack_data[digit_count] = 0;\n                    process_data(stack_data);\n                }\n                else\n                {\n                    process_data(\"%dE%d\", (int)*(short *)(object_address + (uint)i * 2), (int)*(char *)(object_address + 7));\n                }\n            }\n            else\n            {\n                process_data(\"%dm%c\", (int)*(short *)(object_address + (uint)i * 2), value);\n            }\n            uVar1 = get_ptr_from_switch_case(*(undefined *)(object_address + 6));\n            process_data(uVar1);\n        }\n    }\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00003e9e",
                "FUN_00003918",
                "FUN_00003810"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003694",
            "calling": [
                "FUN_0000305c",
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "display_data_object_00003694"
        },
        "FUN_00002364": {
            "renaming": {
                "FUN_00002364": "check_difference_and_increment_00002364",
                "param_1": "ptr_param1",
                "param_2": "dat_param2",
                "iVar1": "is_difference_equal"
            },
            "code": "int check_difference_and_increment_00002364(int* ptr_param1, unsigned char dat_param2) {\n  int is_difference_equal = is_difference_equal_to_offset(ptr_param1);\n  if (is_difference_equal == 0) {\n    increment_and_store_value_at_address(ptr_param1, dat_param2);\n    return 0;\n  }\n  else {\n    return -1;\n  }\n}",
            "called": [
                "FUN_000022be",
                "FUN_00002294"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002364",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": false,
            "current_name": "check_difference_and_increment_00002364"
        },
        "FUN_00001ad4": {
            "renaming": {
                "FUN_00001ad4": "clear_bits_in_data_00001ad4",
                "DAT_00001b08": "data_ptr",
                "PTR_DAT_00001b0c": "ptr_dat"
            },
            "code": "void clear_bits_in_data_00001ad4(void)\n{\n  unsigned char* DAT_00001b08 = DAT_00001b08;\n  *DAT_00001b08 = *DAT_00001b08 & 0x3f;\n  while ((DAT_00001b08[6] & 0xc) != 0xc);\n  *PTR_DAT_00001b0c = 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ad4",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "clear_bits_in_data_00001ad4"
        },
        "FUN_00001274": {
            "renaming": {
                "FUN_00001274": "print_ascii_characters_and_set_flag_00001274",
                "DAT_00001298": "PTR_flag",
                "print_ascii_characters_0000258c": "print_ascii_characters",
                "executeSensorCommand_00001c84": "execute_sensor_command",
                "initialize_flag_and_data_00002396": "initialize_flag_and_data"
            },
            "code": "void print_ascii_characters_and_set_flag_00001274(void)\n{\n  print_ascii_characters();\n  *DAT_00001298 |= 0x28;\n  execute_sensor_command();\n  initialize_flag_and_data();\n  return;\n}",
            "called": [
                "FUN_0000258c",
                "FUN_00001c84",
                "FUN_00002396"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001274",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "print_ascii_characters_and_set_flag_00001274"
        },
        "FUN_00002e6c": {
            "renaming": {
                "FUN_00002e6c": "process_input_loop_00002e6c",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "iVar1": "input_processed",
                "process_input_and_data_00002e48": "process_input_and_data",
                "process_input_and_return_00002d94": "process_input_and_return",
                "parse_command_line_args_00002b10": "parse_command_line_args"
            },
            "code": "void process_input_loop_00002e6c(int arg1, int arg2, int arg3)\n{\n  int input_processed = 0;\n  process_input_and_data();\n  do {\n    input_processed = process_input_and_return(arg2, arg3);\n    if (input_processed == 0) {\n      parse_command_line_args(arg1, arg2);\n    }\n    process_input_and_data();\n  } while(true);\n}",
            "called": [
                "FUN_00002d94",
                "FUN_00002b10",
                "FUN_00002e48"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e6c",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": false,
            "current_name": "process_input_loop_00002e6c"
        },
        "FUN_00003444": {
            "renaming": {
                "FUN_00003444": "check_date_and_return_false_00003444",
                "iVar1": "date_result",
                "auStack_2c": "date_info",
                "calculate_date_and_return_zero_00002624": "calculate_date_and_return_zero",
                "process_input": "print_error",
                "PTR_s_rtc__error_getting_time_00003474": "PTR_s_rtc__error_getting_time_00003474",
                "process_data_00003378": "process_data"
            },
            "code": "bool check_date_and_return_false_00003444()\n{\n  int date_result;\n  undefined date_info[36];\n  date_result = calculate_date_and_return_zero(date_info);\n  if (date_result != 0) {\n    print_error(PTR_s_rtc__error_getting_time_00003474);\n  } else {\n    process_data(date_info);\n  }\n  return date_result == 0;\n}",
            "called": [
                "FUN_00003378",
                "FUN_00004db8",
                "FUN_00002624"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003444",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "check_date_and_return_false_00003444",
            "code_backup": "\nbool FUN_00003444(void)\n\n{\n  int iVar1;\n  undefined auStack_2c [36];\n  \n  iVar1 = calculate_date_and_return_zero_00002624(auStack_2c);\n  if (iVar1 != 0) {\n    process_input(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    process_data_00003378(auStack_2c);\n  }\n  return iVar1 != 0;\n}\n\n"
        },
        "FUN_00003688": {
            "renaming": {
                "FUN_00003688": "synchronize_data_00003688"
            },
            "code": "void synchronize_data_00003688(void)\n{\n  synchronize_data_00003688_00003658();\n  return;\n}",
            "called": [
                "FUN_00003658"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003688",
            "calling": [
                "FUN_00002e9c"
            ],
            "imported": false,
            "current_name": "synchronize_data_00003688"
        },
        "FUN_00001392": {
            "renaming": {
                "FUN_00001392": "set_address_value_at_offset_00001392",
                "param_1": "base_address",
                "param_2": "offset",
                "puVar1": "address_to_set"
            },
            "code": "void set_address_value_at_offset_00001392(int base_address, unsigned char offset) {\n  int *address_to_set;\n  address_to_set = (int *)calculate_address_offset(base_address, offset);\n  *address_to_set = 1;\n  return;\n}",
            "called": [
                "FUN_00001360"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001392",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "set_address_value_at_offset_00001392"
        },
        "FUN_00002910": {
            "renaming": {
                "FUN_00002910": "reset_data_00002910",
                "DAT_00002944": "data_start"
            },
            "code": "void reset_data_00002910(void)\n{\n  int DAT_00002944 = DAT_00002944;\n  *(unsigned int *)(DAT_00002944 + 0x1c) &= 0xfffffffb;\n  *(undefined4 *)(DAT_00002944 + 8) = 0;\n  *(undefined4 *)PTR_DAT_00002948 = 0;\n  *(undefined4 *)(PTR_DAT_00002948 + 4) = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002910",
            "calling": [
                "FUN_000026c0"
            ],
            "imported": false,
            "current_name": "reset_data_00002910"
        },
        "FUN_00004418": {
            "renaming": {
                "FUN_00004418": "read_byte_from_memory_00004418",
                "uVar1": "byteRead",
                "ppbVar2": "memoryBlock",
                "pbVar3": "currentByte",
                "iVar4": "memoryBlockAddress",
                "PTR_DAT_00005620": "memoryBlockType1",
                "PTR_DAT_00005624": "memoryBlockType2",
                "PTR_DAT_00005628": "memoryBlockType3"
            },
            "code": "uint read_byte_from_memory_00004418(void)\n{\n  uint byteRead;\n  byte **memoryBlock = *(byte ***)(memoryBlockAddress + 4);\n  if ((memoryBlockAddress != 0) && (*(int *)(memoryBlockAddress + 0x18) == 0)) {\n    initialize_memory_block(memoryBlockAddress);\n  }\n  if (memoryBlock == (byte **)PTR_DAT_00005620) {\n    memoryBlock = *(byte ***)(memoryBlockAddress + 4);\n  }\n  else if (memoryBlock == (byte **)PTR_DAT_00005624) {\n    memoryBlock = *(byte ***)(memoryBlockAddress + 8);\n  }\n  else if (memoryBlock == (byte **)PTR_DAT_00005628) {\n    memoryBlock = *(byte ***)(memoryBlockAddress + 0xc);\n  }\n  if ((-1 < (int)memoryBlock[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(memoryBlock + 3) << 0x16))) {\n    do_nothing(memoryBlock[0x16]);\n  }\n  byte *currentByte = memoryBlock[1];\n  memoryBlock[1] = currentByte - 1;\n  if ((int)(currentByte - 1) < 0) {\n    byteRead = read_byte_from_memory_00004418(memoryBlockAddress, memoryBlock);\n  }\n  else {\n    byte *bytePointer = *memoryBlock;\n    *memoryBlock = bytePointer + 1;\n    byteRead = (uint)*bytePointer;\n  }\n  if ((-1 < (int)memoryBlock[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(memoryBlock + 3) << 0x16))) {\n    do_nothing(memoryBlock[0x16]);\n  }\n  return byteRead;\n}\n",
            "called": [
                "FUN_000045e8",
                "FUN_00005e10",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004418",
            "calling": [
                "FUN_00002d94"
            ],
            "imported": false,
            "current_name": "read_byte_from_memory_00004418"
        },
        "FUN_0000258c": {
            "renaming": {
                "FUN_0000258c": "print_ascii_characters_0000258c",
                "local_c": "counter"
            },
            "code": "void print_ascii_characters_0000258c(void)\n{\n  uint32_t counter;\n  *(uint32_t *)(DAT_000025ec + 8) = DAT_000025f0;\n  write_data_00002538(0xfffffffe, 1);\n  write_data_00002538(0xfffffffb, 1);\n  for (counter = 0; counter < 0x66; counter = counter + 1) {\n    write_data_00002538((int)(char)counter, 1);\n  }\n  *(uint32_t *)(DAT_000025ec + 0x10) |= 0x10;\n  *(uint32_t *)(DAT_000025ec + 0x14) |= 0x200;\n  return;\n}",
            "called": [
                "FUN_00002538"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000258c",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "print_ascii_characters_0000258c"
        },
        "FUN_00002a00": {
            "renaming": {
                "FUN_00002a00": "process_input_and_return_00002a00",
                "param_1": "input"
            },
            "code": "void process_input_and_return_00002a00(undefined4 input) {\n  process_input_00004cb4(input);\n  return;\n}",
            "called": [
                "FUN_00004cb4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a00",
            "calling": [
                "FUN_00002d94",
                "FUN_00002e48"
            ],
            "imported": false,
            "current_name": "process_input_and_return_00002a00"
        },
        "FUN_000043a0": {
            "renaming": {
                "FUN_000043a0": "process_data_000043a0",
                "param_1": "data_size",
                "param_2": "data_processor",
                "piVar2": "record_ptr",
                "uVar1": "processed_data",
                "iVar3": "record_data_ptr",
                "uVar4": "result",
                "iVar5": "record_count"
            },
            "code": "uint process_data_000043a0(int data_size, code *data_processor) {\n  uint result = 0;\n  int *record_ptr = (int *)(data_size + 0x48);\n  do {\n    int record_count = record_ptr[1];\n    int record_data_ptr = record_ptr[2];\n    while (record_count-- > 0) {\n      if ((1 < *(ushort *)(record_data_ptr + 0xc)) && (*(short *)(record_data_ptr + 0xe) != -1)) {\n        uint processed_data = (*data_processor)(record_data_ptr);\n        result |= processed_data;\n      }\n      record_data_ptr += 0x68;\n    }\n    record_ptr = (int *)*record_ptr;\n  } while (record_ptr != (int *)0x0);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043a0",
            "calling": [
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "process_data_000043a0"
        },
        "FUN_0000211c": {
            "renaming": {
                "FUN_0000211c": "process_data_0000211c",
                "local_40": "MAGIC_NUMBER",
                "local_3c": "count_offset",
                "local_38": "offset",
                "local_34": "value",
                "local_30": "index",
                "local_2c": "current_data",
                "local_28": "main_stack_pointer",
                "local_24": "data_pointer",
                "local_20": "elf32_rel_entries_count",
                "local_1a": "iteration_counter",
                "local_18": "total_count",
                "local_14": "count"
            },
            "code": "void process_data_0000211c()\n{\n    int count = 0;\n    int total_count = 0;\n    const uint16_t MAGIC_NUMBER = 0x515f;\n    const uint8_t MAX_ITERATIONS = 0x21;\n    uint8_t iteration_counter;\n    uint32_t *data_pointer;\n    uint32_t *main_stack_pointer;\n    uint32_t elf32_rel_entries_count = count_elf32_rel_entries();\n    FUNC_log(PTR_s__pid_____21s____9sQ___pri___stac_00002250, PTR_DAT_0000224c, PTR_s_state_00002248);\n    data_pointer = get_data_pointer();\n    main_stack_pointer = get_main_stack_pointer();\n    FUNC_log(PTR_s______isr_stack______________6i___00002254, 0x200, elf32_rel_entries_count, data_pointer, main_stack_pointer);\n    count += 0x200;\n    if (elf32_rel_entries_count > 0)\n    {\n        total_count += elf32_rel_entries_count;\n    }\n    for (iteration_counter = 1; iteration_counter < MAX_ITERATIONS; iteration_counter++)\n    {\n        uint32_t *current_data = *(uint32_t **)(PTR_DAT_00002258 + iteration_counter * 4);\n        if (current_data != NULL)\n        {\n            uint8_t index = *(uint8_t *)(current_data + 1);\n            uint32_t value = *(uint32_t *)(DAT_0000225c + index * 4);\n            uint32_t offset = (uint32_t)&MAGIC_NUMBER + (uint32_t)(8 < index);\n            uint32_t count_offset = current_data[0xb];\n            count += count_offset;\n            int elements_before_null = count_elements_before_null(current_data[9]);\n            count_offset -= elements_before_null;\n            total_count += count_offset;\n            FUNC_log(PTR_s___3hi_____20s_____8s___1s____3i___00002260, (int)*(short *)((int)current_data + 6), current_data[10], value, offset, *(uint8_t *)((int)current_data + 5), current_data[0xb], count_offset, current_data[9], *current_data);\n        }\n    }\n    FUNC_log(PTR_s___5s___21s__13s_6s__6i___5i__0000226c, PTR_DAT_00002264, PTR_DAT_00002268, PTR_DAT_00002264, PTR_DAT_00002264, count, total_count);\n}\n",
            "called": [
                "FUN_00004c84",
                "FUN_000008b8",
                "FUN_00000900",
                "FUN_000010a0",
                "FUN_0000091c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000211c",
            "calling": [
                "FUN_00000f04",
                "FUN_00002eb4"
            ],
            "imported": false,
            "current_name": "process_data_0000211c",
            "code_backup": "\nvoid FUN_0000211c(void)\n\n{\n  int iVar1;\n  undefined2 local_40;\n  int local_3c;\n  int local_38;\n  undefined4 local_34;\n  uint local_30;\n  undefined4 *local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  int local_20;\n  short local_1a;\n  int local_18;\n  int local_14;\n  \n  local_40 = 0x515f;\n  local_14 = 0;\n  local_18 = 0;\n  FUNC_00004c84(PTR_s__pid_____21s____9sQ___pri___stac_00002250,PTR_DAT_0000224c,PTR_s_state_00002248\n              );\n  local_20 = count_elf32_rel_entries_000008b8();\n  local_24 = get_data_pointer_0000091c();\n  local_28 = get_main_stack_pointer_00000900();\n  FUNC_00004c84(PTR_s______isr_stack______________6i___00002254,0x200,local_20,local_24,local_28);\n  local_14 = local_14 + 0x200;\n  if (0 < local_20) {\n    local_18 = local_20 + local_18;\n  }\n  for (local_1a = 1; local_1a < 0x21; local_1a = local_1a + 1) {\n    local_2c = *(undefined4 **)(PTR_DAT_00002258 + local_1a * 4);\n    if (local_2c != (undefined4 *)0x0) {\n      local_30 = (uint)*(byte *)(local_2c + 1);\n      local_34 = *(undefined4 *)(DAT_0000225c + local_30 * 4);\n      local_38 = (int)&local_40 + (uint)(8 < local_30);\n      local_3c = local_2c[0xb];\n      local_14 = local_3c + local_14;\n      iVar1 = count_elements_before_null_000010a0(local_2c[9]);\n      local_3c = local_3c - iVar1;\n      local_18 = local_3c + local_18;\n      FUNC_00004c84(PTR_s___3hi_____20s_____8s___1s____3i___00002260,\n                   (int)*(short *)((int)local_2c + 6),local_2c[10],local_34,local_38,\n                   *(undefined *)((int)local_2c + 5),local_2c[0xb],local_3c,local_2c[9],*local_2c);\n    }\n  }\n  FUNC_00004c84(PTR_s___5s___21s__13s_6s__6i___5i__0000226c,PTR_DAT_00002264,PTR_DAT_00002268,\n               PTR_DAT_00002264,PTR_DAT_00002264,local_14,local_18);\n  return;\n}\n\n"
        },
        "FUN_0000562c": {
            "renaming": {
                "FUN_0000562c": "find_key_index_0000562c",
                "param_1": "key_length",
                "param_2": "key_string",
                "param_3": "key_index",
                "cVar1": "current_char",
                "ppiVar2": "key_array_ptr",
                "piVar3": "current_key_ptr",
                "iVar4": "key_array_index",
                "pcVar5": "key_string_ptr",
                "piVar6": "current_key_string_ptr",
                "iVar7": "current_key_length"
            },
            "code": "int find_key_index_0000562c(undefined4 key_length, char *key_string, int *key_index)\n{\n  char current_char;\n  int **key_array_ptr;\n  int *current_key_ptr;\n  int key_array_index;\n  char *key_string_ptr;\n  int *current_key_string_ptr;\n  int current_key_length;\n  do_nothing_with_data_00005fec();\n  key_array_ptr = DAT_0000569c;\n  key_string_ptr = key_string;\n  if (*DAT_0000569c != (int *)0x0) {\n    do {\n      current_char = *key_string_ptr;\n      if (current_char == '\\0') {\n        key_array_index = (int)key_string_ptr - (int)key_string;\n        current_key_ptr = *DAT_0000569c;\n        while( true ) {\n          current_key_string_ptr = current_key_ptr;\n          if (*current_key_string_ptr == 0) break;\n          current_key_length = compare_strings_00004e66(*current_key_string_ptr,key_string,key_array_index);\n          current_key_ptr = current_key_string_ptr + 1;\n          if ((current_key_length == 0) && (current_key_length = *current_key_string_ptr, *(char *)(current_key_length + key_array_index) == '=')) {\n            *key_index = (int)current_key_string_ptr - (int)*key_array_ptr >> 2;\n            do_nothing_with_data_00005ff8(key_length);\n            return current_key_length + key_array_index + 1;\n          }\n        }\n        break;\n      }\n      key_string_ptr = key_string_ptr + 1;\n    } while (current_char != '=');\n  }\n  do_nothing_with_data_00005ff8(key_length);\n  return 0;\n}",
            "called": [
                "FUN_00005fec",
                "FUN_00005ff8",
                "FUN_00004e66"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000562c",
            "calling": [
                "FUN_000056a0"
            ],
            "imported": false,
            "current_name": "find_key_index_0000562c"
        },
        "FUN_000020b8": {
            "renaming": {
                "FUN_000020b8": "decode_and_initialize_data_000020b8",
                "DAT_000020c8": "DAT_buffer",
                "decode_data_00002028": "decode_data"
            },
            "code": "void decode_and_initialize_data_000020b8(){\n  decode_data(DAT_000020c8, 0);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020b8",
            "calling": [],
            "imported": false,
            "current_name": "decode_and_initialize_data_000020b8"
        },
        "FUN_00002a18": {
            "renaming": {
                "FUN_00002a18": "find_matching_byte_sequence_00002a18",
                "param_1": "sequence_list",
                "param_2": "search_byte",
                "local_18": "sequences",
                "local_10": "num_sequences",
                "local_c": "current_sequence",
                "iVar1": "comparison_result"
            },
            "code": "int find_matching_byte_sequence_00002a18(int *sequence_list, int search_byte) {\n  int sequence_index;\n  int *current_sequence;\n  uint num_sequences = 2;\n  int *sequences[num_sequences];\n  sequences[0] = sequence_list;\n  sequences[1] = (int *)PTR_PTR_s_reboot_00002a84;\n  for (sequence_index = 0; sequence_index < num_sequences; sequence_index++) {\n    current_sequence = sequences[sequence_index];\n    if (current_sequence != (int *)0x0) {\n      while (*current_sequence != 0) {\n        if (compare_bytes_00004e52(*current_sequence, search_byte) == 0) {\n          return current_sequence[2];\n        }\n        current_sequence = current_sequence + 3;\n      }\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a18",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "find_matching_byte_sequence_00002a18"
        },
        "FUN_000054a8": {
            "renaming": {
                "FUN_000054a8": "process_data_000054a8",
                "param_1": "output",
                "param_2": "input",
                "uVar1": "flags_1",
                "uVar2": "flags_2",
                "uVar3": "flags_3",
                "uVar4": "flags_4",
                "iVar5": "data_ptr"
            },
            "code": "uint process_data_000054a8(uint *output, uint *input)\n{\n  ushort flags_1;\n  ushort flags_2;\n  uint flags_3;\n  uint flags_4;\n  int data_ptr;\n  data_ptr = *data_start_ptr;\n  if ((data_ptr != 0) && (*(int *)(data_ptr + 0x18) == 0)) {\n    clear_data(data_ptr);\n  }\n  if (input == (uint *)data_ptr_1) {\n    input = *(uint **)(data_ptr + 4);\n  }\n  else if (input == (uint *)data_ptr_2) {\n    input = *(uint **)(data_ptr + 8);\n  }\n  else if (input == (uint *)data_ptr_3) {\n    input = *(uint **)(data_ptr + 0xc);\n  }\n  flags_3 = (uint)*(ushort *)(input + 3);\n  flags_2 = *(ushort *)(input + 3);\n  if (-1 < (int)(flags_3 << 0x1c)) {\n    if (-1 < (int)(flags_3 << 0x1b)) {\n      *output = 9;\n      goto LAB_000054d8;\n    }\n    if ((uint *)(input[0xd]) != (uint *)0x0) {\n      if ((uint *)(input[0xd]) != input + 0x11) {\n        insert_node_at_end(output);\n      }\n      input[0xd] = 0;\n    }\n    *(ushort *)(input + 3) = *(ushort *)(input + 3) & 0xffdb;\n    input[1] = 0;\n    *input = input[4];\n  }\n  if ((input[4] == 0) && ((*(ushort *)(input + 3) & 0x280) != 0x200)) {\n    allocate_memory(output, input);\n  }\n  flags_1 = *(ushort *)(input + 3);\n  flags_3 = (uint)flags_1;\n  flags_2 = *(ushort *)(input + 3);\n  flags_4 = flags_3 & 1;\n  if ((flags_1 & 1) == 0) {\n    if (-1 < (int)(flags_3 << 0x1e)) {\n      flags_4 = input[5];\n    }\n    input[2] = flags_4;\n  }\n  else {\n    input[2] = 0;\n    input[6] = -input[5];\n  }\n  if (input[4] != 0) {\n    return 0;\n  }\n  if ((flags_1 & 0x80) == 0) {\n    return flags_3 & 0x80;\n  }\n  LAB_000054d8:\n  *(ushort *)(input + 3) = flags_2 | 0x40;\n  return 0xffffffff;\n}",
            "called": [
                "FUN_00005700",
                "FUN_00004b34",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000054a8",
            "calling": [
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_00005404"
            ],
            "imported": false,
            "current_name": "process_data_000054a8",
            "code_backup": "\nuint FUN_000054a8(undefined4 *param_1,undefined4 *param_2)\n\n{\n  ushort uVar1;\n  ushort uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  \n  iVar5 = *DAT_00005574;\n  if ((iVar5 != 0) && (*(int *)(iVar5 + 0x18) == 0)) {\n    FUNC_000042a4(iVar5);\n  }\n  if (param_2 == (undefined4 *)PTR_DAT_00005578) {\n    param_2 = *(undefined4 **)(iVar5 + 4);\n  }\n  else if (param_2 == (undefined4 *)PTR_DAT_0000557c) {\n    param_2 = *(undefined4 **)(iVar5 + 8);\n  }\n  else if (param_2 == (undefined4 *)PTR_DAT_00005580) {\n    param_2 = *(undefined4 **)(iVar5 + 0xc);\n  }\n  uVar3 = (uint)*(ushort *)(param_2 + 3);\n  uVar2 = *(ushort *)(param_2 + 3);\n  if (-1 < (int)(uVar3 << 0x1c)) {\n    if (-1 < (int)(uVar3 << 0x1b)) {\n      *param_1 = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(uVar3 << 0x1d) < 0) {\n      if ((undefined4 *)param_2[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] != param_2 + 0x11) {\n          insert_node_at_end_00004b34(param_1);\n        }\n        param_2[0xd] = 0;\n      }\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xffdb;\n      param_2[1] = 0;\n      *param_2 = param_2[4];\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] == 0) && ((*(ushort *)(param_2 + 3) & 0x280) != 0x200)) {\n    allocate_memory_00005700(param_1,param_2);\n  }\n  uVar1 = *(ushort *)(param_2 + 3);\n  uVar3 = (uint)uVar1;\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar4 = uVar3 & 1;\n  if ((uVar1 & 1) == 0) {\n    if (-1 < (int)(uVar3 << 0x1e)) {\n      uVar4 = param_2[5];\n    }\n    param_2[2] = uVar4;\n  }\n  else {\n    param_2[2] = 0;\n    param_2[6] = -param_2[5];\n  }\n  if (param_2[4] != 0) {\n    return 0;\n  }\n  if ((uVar1 & 0x80) == 0) {\n    return uVar3 & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(param_2 + 3) = uVar2 | 0x40;\n  return 0xffffffff;\n}\n\n"
        },
        "FUN_000007dc": {
            "renaming": {
                "FUN_000007dc": "allocate_memory_000007dc",
                "param_1": "size",
                "param_2": "val1",
                "param_3": "val2",
                "param_4": "val3",
                "uVar1": "aligned_size",
                "local_14": "i",
                "local_10": "i"
            },
            "code": "int * allocate_memory_000007dc(int size, int val1, int val2, int val3)\n{\n  uint aligned_size = (size + val2) & 0xfffffffc;\n  int *mem_ptr = (int *)(aligned_size - 4);\n  *mem_ptr = 0x77777777;\n  if (((uint)mem_ptr & 7) != 0) {\n    mem_ptr = (int *)(aligned_size - 8);\n    *mem_ptr = 0x88888888;\n  }\n  mem_ptr[-1] = 0x1000000;\n  mem_ptr[-2] = val1;\n  mem_ptr[-3] = DAT_000008b4;\n  mem_ptr = mem_ptr - 4;\n  *mem_ptr = 0;\n  for (int i = 3; i > 0; i--) {\n    mem_ptr--;\n    *mem_ptr = i;\n  }\n  mem_ptr--;\n  *mem_ptr = val3;\n  for (int i = 0xb; i > 3; i--) {\n    mem_ptr--;\n    *mem_ptr = i;\n  }\n  mem_ptr[-1] = -3;\n  return mem_ptr - 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000007dc",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "allocate_memory_000007dc"
        },
        "FUN_00001710": {
            "renaming": {
                "FUN_00001710": "null_terminate_string_00001710",
                "param_1": "input_val",
                "param_2": "string_ptr",
                "puVar1": "result_ptr",
                "*puVar1": "*result_ptr",
                "calculate_result_00001696": "calculate_result"
            },
            "code": "void null_terminate_string_00001710(int input_val, char* string_ptr) {\n  char* result_ptr = (char*)calculate_result(input_val, string_ptr);\n  *result_ptr = '\\0';\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001710",
            "calling": [
                "FUN_000019c0",
                "FUN_00001bb8",
                "FUN_00001960",
                "FUN_00001778",
                "FUN_00001734",
                "FUN_0000182c",
                "FUN_000018bc",
                "FUN_00001a60"
            ],
            "imported": false,
            "current_name": "null_terminate_string_00001710"
        },
        "FUN_000045ec": {
            "renaming": {
                "FUN_000045ec": "do_nothing_000045ec"
            },
            "code": "\nvoid do_nothing_000045ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ec",
            "calling": [
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_0000579c",
                "FUN_00004158",
                "FUN_00004280",
                "FUN_00005ff8",
                "FUN_00004418",
                "FUN_00004cb4",
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ec"
        },
        "FUN_00001034": {
            "renaming": {
                "FUN_00001034": "findNextNonNull_00001034",
                "param_1": "list",
                "param_2": "index",
                "local_1c": "current"
            },
            "code": "void findNextNonNull_00001034(int **list, int index) {\n  int **current = list;\n  if (8 < *(byte *)(index + 4)) {\n    process_input_00000f04(3, PTR_s_FAILED_ASSERTION__0000109c);\n  }\n  while (*current != (int *)0x0 && (*(byte *)((int)*current + -3) <= *(byte *)(index + 5))) {\n    current = (int **)*current;\n  }\n  *(int **)(index + 8) = *current;\n  *current = (int *)(int **)(index + 8);\n  return;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001034",
            "calling": [
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "findNextNonNull_00001034"
        },
        "FUN_00006964": {
            "renaming": {
                "FUN_00006964": "calculate_value_00006964",
                "param_1": "num1",
                "param_2": "num2",
                "iVar1": "value"
            },
            "code": "int calculate_value_00006964(int num1, int num2)\n{\n  int value = *(int *)(num2 - 4) - 4;\n  if (*(int *)(num2 - 4) < 0) {\n    value += *(int *)(num2 + value);\n  }\n  return value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006964",
            "calling": [
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "calculate_value_00006964"
        },
        "FUN_0000182c": {
            "renaming": {
                "FUN_0000182c": "set_data_and_null_terminate_0000182c",
                "DAT_000018b4": "PTR_DAT_000018b4",
                "DAT_000018b8": "PTR_DAT_000018b8",
                "set_result_to_one_000016ec": "set_result_to_one",
                "null_terminate_string_00001710": "null_terminate_string",
                "*(byte *)(DAT_000018b4 + 8)": "*(data_ptr + 8)",
                "*(byte *)(DAT_000018b4 + 8) & 0xd0": "*(data_ptr + 8) &= mask",
                "DAT_000018b8,0": "result_ptr",
                "DAT_000018b4,1": "data_ptr, 1",
                "DAT_000018b4,0": "data_ptr, 0"
            },
            "code": "void set_data_and_null_terminate_0000182c(void)\n{\n    byte* data_ptr = DAT_000018b4;\n    byte* DAT_000018b8,0 = DAT_000018b8;\n    byte mask = 0xd0;\n    *(byte *)(DAT_000018b4 + 8) & 0xd0;\n    set_result_to_one(DAT_000018b8,0);\n    null_terminate_string(DAT_000018b4,1);\n    null_terminate_string(DAT_000018b4,0);\n    return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000182c",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "set_data_and_null_terminate_0000182c"
        },
        "FUN_00004db8": {
            "renaming": {
                "process_input": "process_input",
                "param_1": "input",
                "iVar2": "result",
                "pcVar1": "current_char",
                "iVar3": "memory_block",
                "pcVar4": "memory_block_char_pointer",
                "ppcVar5": "current_char_pointer",
                "initialize_memory_block_000042a4": "initialize_memory_block",
                "PTR_DAT_00004dac": "current_char_pointer_1",
                "PTR_DAT_00004db0": "current_char_pointer_2",
                "PTR_DAT_00004db4": "current_char_pointer_3",
                "do_nothing_000045e8": "do_nothing",
                "process_data_000054a8": "process_data",
                "process_input_00005404": "process_input",
                "FUN_00004db8": "process_input_00004db8"
            },
            "code": "int process_input_00004db8(int input)\n{\n  char current_char;\n  int memory_block = *memory_block_pointer;\n  if ((memory_block != 0) && (*(int *)(memory_block + 0x18) == 0)) {\n    initialize_memory_block_000042a4();\n  }\n  char **current_char_pointer = *(char ***)(memory_block + 8);\n  if (*(int *)(memory_block + 0x18) == 0) {\n    initialize_memory_block_000042a4(memory_block);\n  }\n  if (current_char_pointer == (char **)PTR_DAT_00004dac) {\n    current_char_pointer = *(char ***)(memory_block + 4);\n  }\n  else if (current_char_pointer == (char **)PTR_DAT_00004db0) {\n    current_char_pointer = *(char ***)(memory_block + 8);\n  }\n  else if (current_char_pointer == (char **)PTR_DAT_00004db4) {\n    current_char_pointer = *(char ***)(memory_block + 0xc);\n  }\n  if ((-1 < (int)current_char_pointer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(current_char_pointer + 3) << 0x16))) {\n    do_nothing_000045e8(current_char_pointer[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(current_char_pointer + 3) << 0x1c) < 0) && (current_char_pointer[4] != (char *)0x0)) || (iVar2 = process_data_000054a8(memory_block, current_char_pointer), iVar2 == 0)) {\n    char *current_output_char = (char *)(input - 1);\n    do {\n      while( true ) {\n        current_output_char = current_output_char + 1;\n        current_char = *current_output_char;\n        char *memory_block_char_pointer = current_char_pointer[2] + -1;\n        current_char_pointer[2] = memory_block_char_pointer;\n        if (current_char == '\\0') {\n          if (-1 < (int)memory_block_char_pointer) {\n            current_output_char = *current_char_pointer;\n            return_value = 10;\n            *current_char_pointer = current_output_char + 1;\n            *current_output_char = '\\n';\n            goto LAB_00004d64;\n          }\n          int result = process_input_00005404(memory_block, 10, current_char_pointer);\n          if (result != -1) {\n            return_value = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)memory_block_char_pointer < 0) && (((int)memory_block_char_pointer < (int)current_char_pointer[6] || (current_char == '\\n')))) break;\n        memory_block_char_pointer = *current_char_pointer;\n        *current_char_pointer = memory_block_char_pointer + 1;\n        *memory_block_char_pointer = current_char;\n      }\n      int result = process_input(memory_block, current_char, current_char_pointer);\n    } while (result != -1);\n  }\nLAB_00004d60:\n  return_value = -1;\nLAB_00004d64:\n  if ((-1 < (int)current_char_pointer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(current_char_pointer + 3) << 0x16))) {\n    do_nothing_000045e8(current_char_pointer[0x16]);\n  }\n  return return_value;\n}",
            "called": [
                "FUN_00005404",
                "FUN_000045e8",
                "FUN_000054a8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004db8",
            "calling": [
                "FUN_00002b10",
                "FUN_00002a88",
                "FUN_000031e0",
                "FUN_000033f4",
                "FUN_00002fe0",
                "FUN_00002f30",
                "FUN_00003444",
                "FUN_00003694",
                "FUN_000033c0",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00003478",
                "FUN_000023a4",
                "FUN_000034c0"
            ],
            "imported": false,
            "current_name": "process_input_00004db8"
        },
        "FUN_000022f0": {
            "renaming": {
                "FUN_000022f0": "increment_value_000022f0",
                "param_1": "array",
                "uVar1": "index",
                "PTR_": "array",
                "DAT_": "value"
            },
            "code": "undefined increment_value_000022f0(int *PTR_)\n{\n  uint index = PTR_[2];\n  PTR_[2] = index + 1;\n  uint offset = index & (PTR_[1] - 1U);\n  return *(undefined *)((offset) + *PTR_);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022f0",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": false,
            "current_name": "increment_value_000022f0"
        },
        "FUN_00001c84": {
            "renaming": {
                "FUN_00001c84": "executeSensorCommand_00001c84",
                "uVar1": "irqStatus",
                "check_for_enabled_IRQ_interrupts_00000cd0": "checkForEnabledIRQInterrupts",
                "parseDataFromSensor_00001bb8": "parseSensorData",
                "DAT_00001ce8": "sensorDataBuffer",
                "DAT_00001cec": "sensorDataBuffer",
                "set_data_and_null_terminate_0000182c": "setDataAndNullTerminate",
                "initialize_data_000017dc": "initializeData",
                "execute_command_00001b10": "executeCommand",
                "enableIRQinterrupts_if_privileged_00000d0c": "enableIRQInterruptsIfPrivileged"
            },
            "code": "void executeSensorCommand_00001c84(void)\n{\n  undefined4 irqStatus;\n  irqStatus = checkForEnabledIRQInterrupts();\n  parseSensorData();\n  *(undefined4 *)(DAT_00001ce8 + 0x1044) = 0x220000;\n  DAT_00001ce8[0xc] = 0;\n  *DAT_00001ce8 = *DAT_00001ce8 & 199 | 0x38;\n  DAT_00001ce8[4] = 0x13;\n  DAT_00001ce8[5] = 0;\n  setDataAndNullTerminate();\n  initializeData();\n  executeCommand(7);\n  enableIRQInterruptsIfPrivileged(irqStatus);\n  return;\n}",
            "called": [
                "FUN_00001bb8",
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_000017dc",
                "FUN_0000182c",
                "FUN_00001b10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001c84",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "executeSensorCommand_00001c84"
        },
        "FUN_000068f0": {
            "renaming": {
                "FUN_000068f0": "allocate_or_copy_array_000068f0",
                "param_1": "alloc_size",
                "param_2": "array_ptr",
                "iVar1": "new_array_ptr",
                "iVar2": "new_alloc_size"
            },
            "code": "int allocate_or_copy_array_000068f0(int alloc_size, int* array_ptr, int array_size)\n{\n  int new_array_ptr;\n  if ((int*)array_ptr[array_size] == array_ptr + array_size + 1) {\n    new_array_ptr = allocate_memory_block(alloc_size);\n    if (new_array_ptr != 0) {\n      array_ptr[array_size + 1] = new_array_ptr;\n      array_ptr[array_size] = alloc_size;\n      *(char*)(new_array_ptr + alloc_size - 1) = *(char*)(array_ptr + 0x11);\n      *(char*)(new_array_ptr + alloc_size - 2) = *(char*)(array_ptr + 0x10);\n      *(int*)(new_array_ptr + alloc_size - 3) = *(int*)(array_ptr + array_size);\n      *array_ptr = new_array_ptr + alloc_size - 3;\n      return 0;\n    }\n  }\n  else {\n    int new_alloc_size = array_ptr[array_size];\n    new_array_ptr = allocate_and_copy_array(new_alloc_size * 2, (int*)array_ptr[array_size], array_size);\n    if (new_array_ptr != 0) {\n      copy_array(new_array_ptr + new_alloc_size, new_array_ptr, new_alloc_size);\n      array_ptr[array_size] = new_array_ptr;\n      array_ptr[array_size + 1] = new_alloc_size * 2;\n      *array_ptr = new_array_ptr + new_alloc_size;\n      return 0;\n    }\n  }\n  return -1;\n}",
            "called": [
                "FUN_000060b0",
                "FUN_000060cc",
                "FUN_00004bd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000068f0",
            "calling": [],
            "imported": false,
            "current_name": "allocate_or_copy_array_000068f0"
        }
    },
    "used_tokens": 187420,
    "layers": [
        [
            "FUN_000064bc",
            "FUN_00002970",
            "FUN_00000d0c",
            "FUN_00003d94",
            "FUN_0000579c",
            "FUN_000015d0",
            "FUN_00000dcc",
            "FUN_0000285c",
            "FUN_00000566",
            "FUN_00001d08",
            "FUN_000031fc",
            "FUN_00005584",
            "FUN_00001da2",
            "FUN_00002744",
            "FUN_00001e0c",
            "FUN_000004f2",
            "FUN_00004e66",
            "FUN_00005ecc",
            "FUN_00001748",
            "FUN_0000294c",
            "FUN_00005790",
            "FUN_00000534",
            "FUN_000005ca",
            "FUN_00005ff8",
            "FUN_00002714",
            "FUN_00005fec",
            "FUN_00004f84",
            "FUN_000028f0",
            "FUN_000039e8",
            "FUN_00002294",
            "FUN_00003810",
            "FUN_0000687c",
            "FUN_00005edc",
            "FUN_0000240c",
            "FUN_00004280",
            "FUN_00000cf0",
            "FUN_00002538",
            "FUN_0000058e",
            "FUN_00001696",
            "FUN_000008b8",
            "FUN_0000091c",
            "FUN_00000d44",
            "FUN_00000cd0",
            "FUN_00000d2a",
            "FUN_00001e44",
            "FUN_00001318",
            "FUN_00000900",
            "FUN_00004274",
            "FUN_00001dc0",
            "FUN_000026f0",
            "FUN_00001d5e",
            "FUN_000050f4",
            "FUN_00005a58",
            "FUN_000056b0",
            "FUN_00003d24",
            "FUN_00003dc4",
            "FUN_000022be",
            "FUN_00001d80",
            "FUN_000023c8",
            "FUN_0000428c",
            "FUN_000010a0",
            "FUN_00006010",
            "FUN_00001360",
            "FUN_00004622",
            "FUN_0000093c",
            "FUN_00003658",
            "FUN_000060b0",
            "FUN_000050e8",
            "FUN_00000514",
            "FUN_000045ee",
            "FUN_00006974",
            "FUN_00005ebc",
            "FUN_0000281c",
            "FUN_00002270",
            "FUN_00003918",
            "FUN_00003d64",
            "FUN_00004e52",
            "FUN_00001ad4",
            "FUN_00002910",
            "FUN_000043a0",
            "FUN_000007dc",
            "FUN_00006964",
            "FUN_000022f0"
        ],
        [
            "FUN_000026c0",
            "FUN_00005e68",
            "FUN_00000e58",
            "FUN_000026d8",
            "FUN_000016ec",
            "FUN_00001ec4",
            "FUN_000014c4",
            "FUN_00004b34",
            "FUN_00004f98",
            "FUN_00000428",
            "FUN_00000e38",
            "FUN_00002600",
            "FUN_00004042",
            "FUN_00002894",
            "FUN_00000d76",
            "FUN_000026e4",
            "FUN_00000698",
            "FUN_00001ff6",
            "FUN_0000328c",
            "FUN_000041f4",
            "FUN_000056b8",
            "FUN_00003ff4",
            "FUN_00000930",
            "FUN_00001348",
            "FUN_00001d3a",
            "FUN_00002798",
            "FUN_0000231c",
            "FUN_00001cf0",
            "FUN_000023d0",
            "FUN_00005fd8",
            "FUN_0000443c",
            "FUN_000027b0",
            "FUN_000016c8",
            "FUN_00000738",
            "FUN_00003e58",
            "FUN_00004e26",
            "FUN_00000610",
            "FUN_00002364",
            "FUN_00003688",
            "FUN_00001392",
            "FUN_0000258c",
            "FUN_0000562c",
            "FUN_00002a18",
            "FUN_00001710"
        ],
        [
            "FUN_00004bd0",
            "FUN_00000794",
            "FUN_00001778",
            "FUN_00002624",
            "FUN_00001628",
            "FUN_000017dc",
            "FUN_00004dee",
            "FUN_00002654",
            "FUN_000025f4",
            "FUN_00001ddc",
            "FUN_000024bc",
            "FUN_00002994",
            "FUN_00000d9c",
            "FUN_00001bb8",
            "FUN_0000404c",
            "FUN_000056a0",
            "FUN_00002690",
            "FUN_00002e9c",
            "FUN_00001960",
            "FUN_00006192",
            "FUN_00001734",
            "FUN_00005780",
            "FUN_00002028",
            "FUN_00001a60",
            "FUN_000018bc",
            "FUN_0000182c"
        ],
        [
            "FUN_00004248",
            "FUN_000020e0",
            "FUN_00000db0",
            "FUN_000020f4",
            "FUN_00001688",
            "FUN_000012b4",
            "FUN_00001f80",
            "FUN_00001a18",
            "FUN_0000191c",
            "FUN_000060cc",
            "FUN_00002108",
            "FUN_00005700",
            "FUN_000019c0",
            "FUN_00001a3c",
            "FUN_000020cc",
            "FUN_00002396",
            "FUN_000020b8"
        ],
        [
            "FUN_00001eea",
            "FUN_00001448",
            "FUN_00001b10",
            "FUN_000068f0"
        ],
        [
            "FUN_00001c84"
        ],
        [
            "FUN_00001274"
        ],
        [
            "FUN_000031e0",
            "FUN_000034c0",
            "FUN_000033f4",
            "FUN_00003478"
        ],
        [
            "FUN_00003378",
            "FUN_00000ed8",
            "FUN_0000211c"
        ],
        [
            "FUN_00002eb4"
        ],
        [
            "FUN_00002a88",
            "FUN_000033c0",
            "FUN_00002f74",
            "FUN_00003444"
        ],
        [
            "FUN_00004158",
            "FUN_00004c84",
            "FUN_00004314",
            "FUN_000054a8"
        ],
        [
            "FUN_000041d0",
            "FUN_00002b10",
            "FUN_00003524",
            "FUN_000042a4"
        ],
        [
            "FUN_00006768",
            "FUN_00005404"
        ],
        [
            "FUN_000057a8",
            "FUN_00005e10",
            "FUN_00004cb4"
        ],
        [
            "FUN_000057d2",
            "FUN_00004418",
            "FUN_00002a00"
        ],
        [
            "FUN_00002e48",
            "FUN_00002d94"
        ],
        [
            "FUN_00002e6c"
        ],
        [
            "FUN_000023a4"
        ],
        [
            "FUN_00000f04"
        ],
        [
            "FUN_00000fec",
            "FUN_00000cc0",
            "FUN_000013b8",
            "FUN_00003ec4",
            "FUN_00000a30",
            "FUN_00001034"
        ],
        [
            "FUN_00000dc0",
            "FUN_00003e9e",
            "FUN_00000e64",
            "FUN_00000df4",
            "FUN_00002434",
            "FUN_000010d4"
        ],
        [
            "FUN_0000129c",
            "FUN_00000410",
            "FUN_00000f8c",
            "FUN_00003694"
        ],
        [
            "FUN_0000459c",
            "FUN_0000305c",
            "FUN_00002ecc",
            "FUN_000012e2"
        ],
        [
            "FUN_00002f30",
            "FUN_00000e14",
            "FUN_0000099c"
        ],
        [
            "FUN_00000490",
            "FUN_00002fe0"
        ],
        [
            "FUN_0000316c",
            "FUN_00004dc8"
        ],
        [
            "FUN_00004db8"
        ]
    ],
    "locked_functions": []
}