{
    "functions": {
        "FUN_000026c0": {
            "renaming": {
                "FUN_000026c0": "clear_rtc_alarm_callback_000026c0",
                "PTR_rtc_callback_000026d4": "rtc_alarm_callback_ptr"
            },
            "code": "void clear_rtc_alarm_callback_000026c0(void)\n{\n  rtt_clear_alarm();\n  *(undefined4 *)PTR_rtc_callback_000026d4 = 0;\n  return;\n}",
            "called": [
                "rtt_clear_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "clear_rtc_alarm_callback_000026c0"
        },
        "FUN_00004bd0": {
            "renaming": {
                "FUN_00004bd0": "allocate_memory_00004bd0",
                "param_1": "reent",
                "param_2": "size",
                "puVar1": "start_of_heap",
                "pvVar2": "memory_pointer",
                "puVar3": "current_block",
                "iVar4": "padding",
                "uVar5": "block_size",
                "puVar6": "previous_block",
                "uVar7": "adjusted_size"
            },
            "code": "uint allocate_memory_00004bd0(_reent *reent, uint size)\n{\n  undefined *start_of_heap = PTR___malloc_sbrk_start_00004c80;\n  void *memory_pointer;\n  uint *current_block;\n  uint block_size;\n  uint *previous_block;\n  uint adjusted_size = (size + 3 & 0xfffffffc) + 8;\n  if (adjusted_size < 0xc) {\n    adjusted_size = 0xc;\n  }\n  if (((int)adjusted_size < 0) || (adjusted_size < size)) {\n    reent->_errno = 0xc;\n  }\n  else {\n    __malloc_lock();\n    previous_block = *(uint **)PTR___malloc_free_list_00004c7c;\n    for (current_block = *(uint **)PTR___malloc_free_list_00004c7c; current_block != (uint *)0x0; current_block = (uint *)current_block[1]) {\n      block_size = *current_block - adjusted_size;\n      if (-1 < (int)block_size) {\n        if (0xb < block_size) {\n          *current_block = block_size;\n          current_block = (uint *)((int)current_block + block_size);\n          goto LAB_00004c34;\n        }\n        adjusted_size = current_block[1];\n        if (previous_block == current_block) {\n          *(uint *)PTR___malloc_free_list_00004c7c = adjusted_size;\n        }\n        if (previous_block != current_block) {\n          previous_block[1] = adjusted_size;\n        }\n        goto LAB_00004c42;\n      }\n      previous_block = current_block;\n    }\n    if (*(int *)PTR___malloc_sbrk_start_00004c80 == 0) {\n      memory_pointer = _sbrk_r(reent,0);\n      *(void **)start_of_heap = memory_pointer;\n    }\n    current_block = (uint *)_sbrk_r(reent,adjusted_size);\n    if ((current_block != (uint *)0xffffffff) && ((previous_block = (uint *)((int)current_block + 3U & 0xfffffffc), current_block == previous_block || (memory_pointer = _sbrk_r(reent,(int)previous_block - (int)current_block), memory_pointer != (void *)0xffffffff)))) {\nLAB_00004c34:\n      *previous_block = adjusted_size;\nLAB_00004c42:\n      __malloc_unlock(reent);\n      adjusted_size = (int)previous_block + 0xbU & 0xfffffff8;\n      uint padding = adjusted_size - (int)(previous_block + 1);\n      if (padding == 0) {\n        return adjusted_size;\n      }\n      *(uint *)((int)previous_block + padding) = (int)(previous_block + 1) - adjusted_size;\n      return adjusted_size;\n    }\n    reent->_errno = 0xc;\n    __malloc_unlock(reent);\n  }\n  return 0;\n}",
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004bd0",
            "calling": [
                "_tzset_unlocked_r",
                "__submore",
                "_realloc_r",
                "__sfmoreglue",
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00004bd0"
        },
        "FUN_00000794": {
            "renaming": {
                "FUN_00000794": "deactivate_thread_00000794",
                "PTR_sched_threads_000007d0": "PTR_sched_threads",
                "PTR_sched_active_pid_000007cc": "PTR_sched_active_pid",
                "PTR_sched_num_threads_000007d4": "PTR_sched_num_threads",
                "PTR_sched_active_thread_000007d8": "PTR_sched_active_thread"
            },
            "code": "void deactivate_thread_00000794(void)\n{\n  irq_disable();\n  int* num_threads = (int*)PTR_sched_num_threads_000007d4_000007d4;\n  *num_threads = *num_threads - 1;\n  short* active_pid = (short*)PTR_sched_active_pid_000007cc_000007cc;\n  thread_t** active_thread = (thread_t**)PTR_sched_active_thread_000007d8_000007d8;\n  *active_thread = NULL;\n  *(undefined4 *)(PTR_sched_threads_000007d0_000007d0 + (*active_pid * 4)) = 0;\n  sched_set_status(*active_thread, 0);\n  cpu_switch_context_exit();\n}",
            "called": [
                "cpu_switch_context_exit",
                "irq_disable",
                "sched_set_status"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000794",
            "calling": [],
            "imported": false,
            "current_name": "deactivate_thread_00000794"
        },
        "FUN_000064bc": {
            "renaming": {
                "FUN_000064bc": "process_data_000064bc",
                "param_1": "data_length",
                "param_2": "data",
                "param_3": "data_ptr",
                "param_4": "status",
                "puVar1": "function_pointer",
                "iVar2": "result",
                "iVar7": "processed_data_count",
                "uVar3": "current_length",
                "ppbVar4": "next_data_ptr",
                "pbVar5": "next_data_byte_ptr",
                "unaff_r6": "current_data_ptr",
                "pbVar6": "current_data_byte_ptr",
                "PTR_DAT_00006568": "function_pointer_data",
                "code": "function_pointer_type"
            },
            "code": "int process_data_000064bc(uint32_t data_length, uint32_t* data, uint8_t** data_ptr, uint32_t* status) {\n  uint8_t* current_data = NULL;\n  uint32_t current_length = 0;\n  uint32_t* function_pointer = (uint32_t*)PTR_DAT_00006568;\n  uint32_t* status_ptr = status;\n  uint32_t* data_length_ptr = data_length;\n  uint8_t** data_ptr_ptr = data_ptr;\n  if (data[2] == 0) {\n    if (data[6] == 0) {\n      *data_length_ptr = 1;\n    }\n    else {\n      *data_length_ptr = 0xffffffff;\n    }\n    data[2] = *data_length_ptr;\n  }\n  if (-1 < (int32_t)(*data << 0x1b)) {\n    uint8_t** next_data_ptr = (uint8_t**)*function_pointer;\n    *function_pointer = (uint32_t)next_data_ptr + sizeof(uint8_t*);\n    current_data = *next_data_ptr;\n  }\n  uint32_t processed_data_count = 0;\n  do {\n    current_length = data[2];\n    if (current_length != 0) {\n      if (current_length == 1) {\n        if (*(char*)(data[5] + (uint32_t)**data_ptr_ptr) == '\\0') {\n          if (processed_data_count == 0) {\n            return 1;\n          }\n          goto end_of_processing;\n        }\n      }\n      else if ((current_length == 2) && ((int32_t)((uint32_t)(uint8_t*)function_pointer[**data_ptr_ptr] << 0x1c) < 0)) {\n        goto end_of_processing;\n      }\n    }\n    uint8_t* current_data_ptr = current_data;\n    if (-1 < (int32_t)(*data << 0x1b)) {\n      current_data_ptr = current_data + 1;\n      *current_data = **data_ptr_ptr;\n    }\n    uint8_t* next_data_ptr = (*data_ptr_ptr)[1];\n    *data_ptr_ptr = *data_ptr_ptr + 1;\n    current_length--;\n    data[2] = current_length;\n    current_data = current_data_ptr;\n    if ((current_length == 0) || (((int32_t)(next_data_ptr + -1) < 1 && ((int32_t)(*(code*)data[0x60])(data_length, data_ptr, current_length, (code*)data[0x60], status_ptr) != 0)))) {\n      goto end_of_processing;\n    }\n    processed_data_count++;\n  } while (true);\n  end_of_processing:\n  if (((*data & 0x10) == 0) && (data[3] = data[3] + 1, data[6] != 0)) {\n    *current_data = 0;\n  }\n  data[4] = processed_data_count + data[4];\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000064bc",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "process_data_000064bc"
        },
        "FUN_00002970": {
            "renaming": {
                "FUN_00002970": "clear_rtc_alarm_flag_00002970",
                "rtt": "rtc_instance",
                "*(uint *)(DAT_00002990 + 0x14)": "alarm_flag_reg",
                "0xffffffef": "~(1 << 4)"
            },
            "code": "void clear_rtc_alarm_flag_00002970(void)\n{\n  RTC_Type *rtc_instance = (RTC_Type *)DAT_00002990;\n  uint32_t **(uint *)(DAT_00002990 + 0x14) = (uint32_t *)(DAT_00002990 + 0x14);\n  **(uint *)(DAT_00002990 + 0x14) &= ~(1 << 4);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002970",
            "calling": [
                "rtc_poweroff"
            ],
            "imported": false,
            "current_name": "clear_rtc_alarm_flag_00002970"
        },
        "FUN_00000dc0": {
            "renaming": {
                "FUN_00000dc0": "call_default_function_00000dc0"
            },
            "code": "void call_default_function_00000dc0(void)\n{\n  call_default_function_00000dc0();\n  return;\n}",
            "called": [
                "dummy_handler_default"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dc0",
            "calling": [],
            "imported": false,
            "current_name": "call_default_function_00000dc0"
        },
        "FUN_00000ca0": {
            "renaming": {
                "FUN_00000ca0": "usageFaultHandler_00000ca0",
                "PTR_s_USAGE_FAULT_HANDLER_00000cac": "usage_fault_handler"
            },
            "code": "void usageFaultHandler_00000ca0(void)\n{\n    core_panic(PANIC_USAGE_FAULT, PTR_s_USAGE_FAULT_HANDLER_00000cac);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ca0",
            "calling": [],
            "imported": false,
            "current_name": "usageFaultHandler_00000ca0"
        },
        "FUN_00000d0c": {
            "renaming": {
                "FUN_00000d0c": "enable_interrupts_if_privileged_00000d0c",
                "state": "interrupt_state",
                "bVar1": "is_privileged_mode"
            },
            "code": "void enable_interrupts_if_privileged_00000d0c(uint state)\n{\n  bool is_privileged_mode;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    enableIRQinterrupts((state & 1) == 1);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d0c",
            "calling": [
                "kinetis_mcg_init",
                "_sbrk_r",
                "thread_create",
                "mutex_unlock",
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "enable_interrupts_if_privileged_00000d0c"
        },
        "FUN_00003d94": {
            "renaming": {
                "FUN_00003d94": "write_device_data_00003d94",
                "dev": "device",
                "data": "data",
                "iVar1": "result"
            },
            "code": "int write_device_data_00003d94(saul_reg_t *device, phydat_t *data)\n{\n  int result;\n  if (device == NULL)\n  {\n    result = -19;\n  }\n  else\n  {\n    result = (*device->driver->write)(device->dev, data);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d94",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "write_device_data_00003d94"
        },
        "FUN_0000579c": {
            "renaming": {
                "FUN_0000579c": "release_malloc_lock_0000579c",
                "PTR___lock___malloc_recursive_mutex_000057a4": "malloc_lock"
            },
            "code": "void release_malloc_lock_0000579c(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___malloc_recursive_mutex_000057a4);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000579c",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "release_malloc_lock_0000579c"
        },
        "FUN_000015d0": {
            "renaming": {
                "FUN_000015d0": "send_data_000015d0",
                "uart": "uart_port",
                "data": "data_to_send",
                "len": "data_length",
                "iVar1": "uart_config",
                "dev": "uart_device",
                "i": "index"
            },
            "code": "void send_data_000015d0(uart_t uart, uint8_t *data, size_t len)\n{\n  int uart_config = *(int *)(PTR_uart_config_00001624 + uart * 0x20);\n  UART_Type *uart_device;\n  size_t i;\n  \n  uart_device = (UART_Type *)uart_config;\n  \n  for (i = 0; i < len; i++) {\n    while (uart_device->status & UART_STATUS_TX_FULL);\n    uart_device->data = data[i];\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000015d0",
            "calling": [
                "uart_stdio_write"
            ],
            "imported": false,
            "current_name": "send_data_000015d0"
        },
        "FUN_00004cdc": {
            "renaming": {
                "FUN_00004cdc": "print_string_00004cdc",
                "param_1": "file_descriptor",
                "param_2": "string",
                "cVar1": "character",
                "iVar2": "ret_val",
                "pcVar3": "buffer_pointer",
                "ppcVar4": "file_pointer",
                "uVar5": "return_value",
                "pcVar6": "string_pointer"
            },
            "code": "int print_string_00004cdc(int file_descriptor, char *string) {\n  char character;\n  int ret_val;\n  char *buffer_pointer;\n  char **file_pointer;\n  int is_lock_acquired;\n  if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n    __sinit();\n  }\n  file_pointer = *(char ***)(file_descriptor + 8);\n  if (*(int *)(file_descriptor + 0x18) == 0) {\n    __sinit(file_descriptor);\n  }\n  if (file_pointer == (char **)PTR___sf_fake_stdin_00004dac) {\n    file_pointer = *(char ***)(file_descriptor + 4);\n  }\n  else if (file_pointer == (char **)PTR___sf_fake_stdout_00004db0) {\n    file_pointer = *(char ***)(file_descriptor + 8);\n  }\n  else if (file_pointer == (char **)PTR___sf_fake_stderr_00004db4) {\n    file_pointer = *(char ***)(file_descriptor + 0xc);\n  }\n  is_lock_acquired = (-1 < (int)file_pointer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(file_pointer + 3) << 0x16));\n  if (is_lock_acquired) {\n    __retarget_lock_acquire_recursive(file_pointer[0x16]);\n  }\n  buffer_pointer = file_pointer[2] + -1;\n  ret_val = 0xffffffff;\n  while (*string) {\n    character = *string;\n    string++;\n    buffer_pointer++;\n    if (character == '\\0') {\n      if (-1 < (int)buffer_pointer) {\n        *file_pointer = *file_pointer + 1;\n        **file_pointer = '\\n';\n        ret_val = 0;\n        break;\n      }\n      else {\n        ret_val = __swbuf_r(file_descriptor, 10, file_pointer);\n        break;\n      }\n    }\n    if (((int)buffer_pointer < 0) && (((int)buffer_pointer < (int)file_pointer[6] || (character == '\\n')))) {\n      break;\n    }\n    *buffer_pointer = character;\n    *file_pointer = *file_pointer + 1;\n  }\n  if (is_lock_acquired) {\n    __retarget_lock_release_recursive(file_pointer[0x16]);\n  }\n  return ret_val;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__swbuf_r",
                "__swsetup_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cdc",
            "calling": [
                "puts"
            ],
            "imported": false,
            "current_name": "print_string_00004cdc"
        },
        "FUN_00005e68": {
            "renaming": {
                "FUN_00005e68": "scan_formatted_string_00005e68",
                "__s": "destination",
                "__format": "format_string",
                "local_80": "current_arg",
                "local_7c": "string_length",
                "local_74": "padding_bytes_1",
                "local_72": "padding_bytes_2",
                "local_70": "start_position",
                "local_6c": "destination_length",
                "local_5c": "impure_ptr_value_1",
                "local_4c": "impure_ptr_value_2",
                "local_38": "impure_ptr_value_3",
                "uStack_8": "argument_list"
            },
            "code": "int scan_formatted_string_00005e68(char *destination, char *format_string, ...) {\\n\\\n    int result;\\n\\\n    char *current_arg;\\n\\\n    char *start_position;\\n\\\n    size_t string_length;\\n\\\n    size_t destination_length;\\n\\\n    undefined2 padding_bytes_1 = 0x204;\\n\\\n    undefined2 padding_bytes_2 = 0xffff;\\n\\\n    undefined4 impure_ptr_value_1;\\n\\\n    undefined4 impure_ptr_value_2 = 0;\\n\\\n    undefined4 impure_ptr_value_3 = 0;\\n\\\n    impure_ptr_value_1 = *(undefined4 *)PTR__impure_ptr_00005eb8;\\n\\\n    va_list argument_list;\\n\\\n    va_start(argument_list, format_string);\\n\\\n    current_arg = va_arg(argument_list, char *);\\n\\\n    start_position = current_arg;\\n\\\n    string_length = strlen(current_arg);\\n\\\n    destination_length = string_length;\\n\\\n    result = __ssvfiscanf_r(impure_ptr_value_1, &current_arg, format_string, &impure_ptr_value_2);\\n\\\n    va_end(argument_list);\\n\\\n    return result;\\n\\\n}",
            "called": [
                "__ssvfiscanf_r",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e68",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "scan_formatted_string_00005e68"
        },
        "FUN_00000dcc": {
            "renaming": {
                "FUN_00000dcc": "initializeData_00000dcc",
                "DAT_00000df0": "dataPtr"
            },
            "code": "void initializeData_00000dcc(void)\n{\n    int* DAT_00000df0 = DAT_00000df0;\n    DAT_00000df0[7] = 0xc520;\n    DAT_00000df0[7] = 0xd928;\n    *DAT_00000df0 = 0xd2;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dcc",
            "calling": [
                "pre_startup"
            ],
            "imported": false,
            "current_name": "initializeData_00000dcc"
        },
        "FUN_0000285c": {
            "renaming": {
                "FUN_0000285c": "set_RTC_counter_0000285c",
                "counter": "new_counter",
                "puVar1": "counter_ptr",
                "rtt": "rtc"
            },
            "code": "void set_RTC_counter_0000285c(uint32_t counter)\n{\n  uint32_t *counter_ptr;\n  RTC_Type *rtc;\n  counter_ptr = DAT_00002890;\n  DAT_00002890[5] &= 0xffffffef;\n  *counter_ptr = counter;\n  counter_ptr[5] |= 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000285c",
            "calling": [
                "rtc_set_time"
            ],
            "imported": false,
            "current_name": "set_RTC_counter_0000285c"
        },
        "FUN_00000e58": {
            "renaming": {
                "FUN_00000e58": "wait_for_interrupt_00000e58",
                "irq_disable": "disable_interrupts"
            },
            "code": "void wait_for_interrupt_00000e58(void)\n{\n    disable_interrupts();\n    while(true) {\n        // Do nothing, waiting for interrupt\n    }\n}",
            "called": [
                "irq_disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e58",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "wait_for_interrupt_00000e58"
        },
        "FUN_00001778": {
            "renaming": {
                "FUN_00001778": "update_byte_at_address_00001778",
                "DAT_000017d0": "address",
                "DAT_000017d8": "bit_vector",
                "byte": "uint8_t",
                "current_value": "current_byte_value",
                "new_value": "new_byte_value"
            },
            "code": "void update_byte_at_address_00001778(void)\n{\n  byte* DAT_000017d0 = DAT_000017d0 + 1;\n  byte current_value = *DAT_000017d0;\n  byte new_value = (current_value & 0xcf) | 0x20;\n  *DAT_000017d0 = new_value;\n  bit_clear8(DAT_000017d8, 2);\n  return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001778",
            "calling": [
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "update_byte_at_address_00001778"
        },
        "FUN_000026d8": {
            "renaming": {
                "FUN_000026d8": "power_on_rtt_000026d8",
                "rtt_poweron": "rtt_poweron"
            },
            "code": "void power_on_rtt_000026d8(void)\n{\n    rtt_poweron();\n    return;\n}",
            "called": [
                "rtt_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026d8",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "power_on_rtt_000026d8"
        },
        "FUN_00000566": {
            "renaming": {
                "FUN_00000566": "count_leading_zero_bits_00000566",
                "v": "value",
                "bVar1": "byte1",
                "bVar2": "byte2",
                "bVar3": "byte3",
                "bVar4": "byte4",
                "uVar5": "result"
            },
            "code": "uint count_leading_zero_bits_00000566(uint value) {\n    uint mask = 0x80000000;\n    int count = 0;\n    while((value & mask) == 0 && mask != 0) {\n        count++;\n        mask >>= 1;\n    }\n    return count;\n}\n\nuint count_leading_zero_bits_00000566(uint value) {\n    uint byte1 = (byte)value;\n    uint byte2 = (byte)(value >> 8);\n    uint byte3 = (byte)(value >> 16);\n    uint byte4 = (byte)(value >> 24);\n    uint result = (count_leading_zero_bits_00000566(byte1) << 24) | (count_leading_zero_bits_00000566(byte2) << 16) | (count_leading_zero_bits_00000566(byte3) << 8) | count_leading_zero_bits_00000566(byte4);\n    if(value == 0) {\n        result = 0xFFFFFFFF;\n    }\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000566",
            "calling": [
                "sched_run"
            ],
            "imported": false,
            "current_name": "count_leading_zero_bits_00000566"
        },
        "FUN_00001d08": {
            "renaming": {
                "FUN_00001d08": "calculate_address_from_bit_offset_00001d08",
                "ptr": "ptr",
                "bit": "bit_offset",
                "(uint)ptr": "(uintptr_t)ptr",
                "bit * 4": "bit_offset_in_bytes",
                "((uint)ptr & 0xf0000000": "base_address",
                "((uint)ptr & 0xfffff) << 5)": "offset",
                "0x2000000": "constant_offset",
                "(void *)": "(void *)"
            },
            "code": "void * calculate_address_from_bit_offset_00001d08(void *ptr, uintptr_t bit_offset) {\n    uintptr_t base = (uintptr_t)ptr & 0xf0000000;\n    uintptr_t offset = ((uintptr_t)ptr & 0xfffff) << 5;\n    uintptr_t address = (bit_offset * 4) + base + offset + 0x2000000;\n    return (void *)address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d08",
            "calling": [
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_address_from_bit_offset_00001d08"
        },
        "FUN_000031fc": {
            "renaming": {
                "FUN_000031fc": "calculate_day_of_week_000031fc",
                "year": "input_year",
                "month": "input_month",
                "day": "input_day",
                "bVar1": "adjusted_month_byte",
                "iVar2": "adjusted_month",
                "iVar3": "year_adjustment",
                "DAT_00003280": "leap_year_correction_factor",
                "PTR_t_00003284": "month_offset_array",
                "DAT_00003288": "doomsday_correction_factor"
            },
            "code": "int calculate_day_of_week_000031fc(int year, int month, int day) {\n    int adjusted_month = month;\n    if (month < 3) {\n        adjusted_month = 1;\n    }\n    int leap_year_adjustment = 0;\n    if (adjusted_month > 2) {\n        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {\n            leap_year_adjustment = -1;\n        }\n    }\n    int year_adjustment = year - leap_year_adjustment;\n    if (year_adjustment < 0) {\n        year_adjustment += 3;\n    }\n    int doomsday = (year_adjustment / 4) + year_adjustment - ((DAT_00003280 * year_adjustment) >> 37) + ((DAT_00003280 * year_adjustment) >> 31) + *(int *)(PTR_t_00003284 + (adjusted_month - 1) * 4) + day;\n    return doomsday + (((DAT_00003288 * doomsday) >> 32 + doomsday / 4) - (doomsday >> 31)) * -7;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031fc",
            "calling": [
                "_parse_time"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_000031fc"
        },
        "FUN_000016ec": {
            "renaming": {
                "FUN_000016ec": "set_bit_000016ec",
                "ptr": "data",
                "bit": "bit_position",
                "puVar1": "bitband_address"
            },
            "code": "void set_bit_000016ec(uint8_t *data, uint8_t bit_position) {\n  uint32_t *bitband_address = bitband_addr(data,(uint32_t)bit_position);\n  *bitband_address = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016ec",
            "calling": [
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpi"
            ],
            "imported": false,
            "current_name": "set_bit_000016ec"
        },
        "FUN_00004e8c": {
            "renaming": {
                "_strtol_l_isra_0": "convert_string_to_long",
                "param_1": "result",
                "param_2": "str",
                "param_3": "endptr",
                "param_4": "base",
                "uVar1": "result_value",
                "uVar2": "current_char",
                "uVar3": "digit_value",
                "uVar4": "max_value",
                "iVar5": "overflow_flag",
                "uVar6": "max_div_base",
                "uVar7": "is_negative",
                "pbVar8": "current_char_ptr",
                "pbVar9": "next_char_ptr",
                "FUN_00004e8c": "convert_string_to_long_00004e8c"
            },
            "code": "uint convert_string_to_long_00004e8c(undefined4 *result, byte *str, byte **endptr, uint base) {\n  uint digit_value;\n  uint current_char;\n  uint is_negative = 0;\n  uint max_value;\n  int overflow_flag = 0;\n  uint result_value = 0;\n  uint max_div_base = 0x7fffffff / base;\n  byte *current_str = str;\n  do {\n    current_char = (uint)*current_str;\n    digit_value = (byte)PTR_DAT_00004f7c[current_char] & 8;\n    current_str++;\n  } while ((PTR_DAT_00004f7c[current_char] & 8) != 0);\n  if (current_char == 0x2d) {\n    current_char = (uint)*current_str;\n    is_negative = 1;\n    current_str++;\n  }\n  else if (current_char == 0x2b) {\n    current_char = (uint)*current_str;\n    current_str++;\n  }\n  if (base == 0) {\n    if (current_char != 0x30) {\n      base = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((base != 0x10) || (current_char != 0x30)) goto LAB_00004ed6;\n  if ((*current_str & 0xdf) == 0x58) {\n    current_char = (uint)current_str[1];\n    base = 0x10;\n    current_str += 2;\n  }\n  else {\n    current_char = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\nLAB_00004ed6:\n  max_value = max_div_base;\n  while (true) {\n    digit_value = current_char - 0x30;\n    if (9 < digit_value) {\n      if (current_char - 0x41 < 0x1a) {\n        digit_value = current_char - 0x37;\n      }\n      else {\n        if (0x19 < current_char - 0x61) break;\n        digit_value = current_char - 0x57;\n      }\n    }\n    if ((int)base <= (int)digit_value) break;\n    if (overflow_flag != -1) {\n      if ((max_value < result_value) || ((max_value == result_value && ((int)(max_div_base - base * result_value) < (int)digit_value)))) {\n        overflow_flag = -1;\n      }\n      else {\n        result_value = result_value * base + digit_value;\n        overflow_flag = 1;\n      }\n    }\n    current_char = (uint)*current_str;\n    current_str++;\n  }\n  if (overflow_flag == -1) {\n    *result = 0x22;\n    result_value = max_div_base;\n    if (endptr == (byte **)0x0) {\n      return max_div_base;\n    }\n  }\n  else {\n    if (is_negative != 0) {\n      result_value = -result_value;\n    }\n    if (endptr == (byte **)0x0) {\n      return result_value;\n    }\n    if (overflow_flag == 0) goto LAB_00004f64;\n  }\n  *endptr = current_str - 1;\nLAB_00004f64:\n  return result_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e8c",
            "calling": [
                "_strtol_r",
                "strtol"
            ],
            "imported": false,
            "current_name": "convert_string_to_long_00004e8c"
        },
        "FUN_00005100": {
            "renaming": {
                "FUN_00005100": "execute_impure_function_00005100",
                "PTR__impure_ptr_00005108": "impure_ptr_location",
                "FUN_00005100_r": "execute_impure_function_recursive"
            },
            "code": "void execute_impure_function_00005100(void)\n{\n  int* impure_ptr = *(int**)PTR__impure_ptr_00005108;\n  execute_impure_function_00005100_recursive(impure_ptr);\n  return;\n}",
            "called": [
                "_tzset_unlocked_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005100",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "execute_impure_function_00005100"
        },
        "FUN_00005584": {
            "renaming": {
                "FUN_00005584_t": "DivisionResult",
                "FUN_00005584": "divide_00005584",
                "__numer": "numerator",
                "__denom": "denominator",
                "in_r2": "abs_denominator",
                "iVar1": "remainder",
                "uVar2": "quotient"
            },
            "code": "typedef struct {\n    uint32_t quotient;\n    int32_t remainder;\n} DivisionResult;\n\nDivisionResult divide_00005584(int32_t numerator, int32_t denominator) {\n    uint32_t abs_numerator = (numerator < 0) ? -numerator : numerator;\n    uint32_t abs_denominator = (denominator < 0) ? -denominator : denominator;\n    uint32_t quotient = abs_numerator / abs_denominator;\n    int32_t remainder = abs_numerator % abs_denominator;\n    if (numerator < 0 && remainder != 0) {\n        quotient = -quotient - 1;\n        remainder = denominator - remainder;\n    }\n    if (denominator < 0 && remainder != 0) {\n        quotient = -quotient;\n        remainder = denominator + remainder;\n    }\n    return { quotient, remainder };\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005584",
            "calling": [
                "validate_structure"
            ],
            "imported": false,
            "current_name": "divide_00005584"
        },
        "FUN_00000cb0": {
            "renaming": {
                "FUN_00000cb0": "handle_debug_monitor_00000cb0",
                "PANIC_DEBUG_MON": "PANIC_DEBUG_MONITOR",
                "PTR_s_DEBUG_MON_HANDLER_00000cbc": "debug_monitor_handler"
            },
            "code": "void handle_debug_monitor_00000cb0(void)\n{\n    /* WARNING: This function does not return */\n    core_panic(PANIC_DEBUG_MONITOR, PTR_s_DEBUG_MON_HANDLER_00000cbc);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cb0",
            "calling": [],
            "imported": false,
            "current_name": "handle_debug_monitor_00000cb0"
        },
        "FUN_00004248": {
            "renaming": {
                "FUN_00004248": "_malloc_r_00004248",
                "param_1": "size",
                "param_2": "num_elements",
                "puVar1": "allocated_memory",
                "iVar2": "total_size"
            },
            "code": "_malloc_r_00004248 _malloc_r_00004248(int size, int num_elements) {\n    int total_size = (num_elements - 1) * 0x68 + 0x74;\n    undefined4 *allocated_memory = (undefined4 *)_malloc_r_00004248(size, total_size);\n    if (allocated_memory != NULL) {\n        *allocated_memory = 0;\n        allocated_memory[1] = num_elements;\n        allocated_memory[2] = allocated_memory + 3;\n        memset(allocated_memory + 3, 0, total_size - 0x74);\n    }\n    return allocated_memory;\n}",
            "called": [
                "memset",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004248",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "_malloc_r_00004248"
        },
        "FUN_00000f5c": {
            "renaming": {
                "FUN_00000f5c": "initialize_and_execute_00000f5c",
                "arg": "argument",
                "auto_init": "auto_initialize",
                "iprintf": "print_string",
                "main": "execute_main_function"
            },
            "code": "void * initialize_and_execute_00000f5c(void *argument)\n{\n  auto_initialize();\n  print_string(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  execute_main_function();\n  return (void *)0x0;\n}",
            "called": [
                "iprintf",
                "main",
                "auto_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f5c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_and_execute_00000f5c"
        },
        "FUN_00001da2": {
            "renaming": {
                "FUN_00001da2": "get_pin_value_00001da2",
                "pin": "gpio_pin",
                "pin_value": "gpio_pin_value"
            },
            "code": "int get_pin_value_00001da2(gpio_t pin) {\n  int pin_value = (pin >> 6) & 7;\n  return pin_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001da2",
            "calling": [
                "clk_en",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "get_pin_value_00001da2"
        },
        "FUN_00001ec4": {
            "renaming": {
                "FUN_00001ec4": "write_context_to_map_00001ec4",
                "port": "port_num",
                "pin": "pin_num",
                "ctx_00": "context_value",
                "ctx": "context"
            },
            "code": "void write_context_to_map_00001ec4(int port_num, int pin_num) {\n  int context_value = get_context_value(port_num, pin_num);\n  write_to_map(port_num, pin_num, context_value);\n  return;\n}",
            "called": [
                "write_map",
                "get_ctx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ec4",
            "calling": [
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "write_context_to_map_00001ec4"
        },
        "FUN_00002744": {
            "renaming": {
                "FUN_00002744": "set_irq_priority_00002744",
                "IRQn": "irq_num",
                "priority": "priority",
                "DMA0_IRQn": "DMA0_IRQn",
                "PTR_DAT_00002790": "NVIC_IPR_BASE_ADDR",
                "PTR_DAT_00002794": "NVIC_IPR_BASE_ADDR2"
            },
            "code": "void set_irq_priority_00002744(IRQn_Type irq_num, uint32_t priority) {\n  if (irq_num < DMA0_IRQn) {\n    char* nvic_ipr = (char*)((byte)irq_num & 0xf) + PTR_DAT_00002790 + 0x14;\n    *nvic_ipr = (char)((priority & 0xff) << 4);\n  }\n  else {\n    char* nvic_ipr = (char*)irq_num + PTR_DAT_00002794;\n    *nvic_ipr = (char)((priority & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002744",
            "calling": [
                "rtt_set_alarm"
            ],
            "imported": false,
            "current_name": "set_irq_priority_00002744"
        },
        "FUN_00002624": {
            "renaming": {
                "FUN_00002624": "convert_rtt_counter_to_utc_time_00002624",
                "time": "utc_time",
                "t": "counter_time",
                "rtt_get_counter()": "counter_time.seconds",
                "gmtime_r()": "gmtime_r()"
            },
            "code": "int convert_rtt_counter_to_utc_time_00002624(tm *utc_time)\n{\n  time_t counter_time;\n  counter_time.seconds = rtt_get_counter();\n  counter_time.nanoseconds = 0;\n  gmtime_r(&counter_time, utc_time);\n  return 0;\n}",
            "called": [
                "rtt_get_counter",
                "gmtime_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002624",
            "calling": [
                "_rtc_gettime"
            ],
            "imported": false,
            "current_name": "convert_rtt_counter_to_utc_time_00002624"
        },
        "FUN_00001e0c": {
            "renaming": {
                "FUN_00001e0c": "get_pin_value_00001e0c",
                "port": "port",
                "pin": "pin",
                "PTR_isr_map_00001e40": "PTR_isr_map_00001e40"
            },
            "code": "uint32_t get_pin_value_00001e0c(uint8_t port, uint8_t pin) {\n    uint32_t* pin_address = (uint32_t*)(PTR_isr_map_00001e40 + ((pin >> 3) + port * 4) * 4);\n    uint8_t pin_offset = (pin & 7U) << 2;\n    uint32_t pin_value = (*pin_address >> pin_offset) & 0xF;\n    return pin_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e0c",
            "calling": [
                "ctx_clear",
                "irq_handler"
            ],
            "imported": false,
            "current_name": "get_pin_value_00001e0c"
        },
        "FUN_00000ef8": {
            "renaming": {
                "FUN_00000ef8": "do_nothing_00000ef8"
            },
            "code": "\nvoid do_nothing_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ef8",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "do_nothing_00000ef8"
        },
        "FUN_000041d0": {
            "renaming": {
                "FUN_000041d0": "file_walk_000041d0",
                "__stream": "__file",
                "iVar1": "result",
                "PTR__global_impure_ptr_000041e8": "global_impure_ptr",
                "DAT_000041ec": "DAT",
                "_FUN_000041d0_r": "_file_walk_reent",
                "PTR__impure_ptr_000041f0": "impure_ptr"
            },
            "code": "int file_walk_000041d0(FILE *__stream)\n{\n  int result;\n  if (__stream == NULL) {\n    result = _fwalk_reent(*PTR__global_PTR__impure_ptr_000041f0_000041e8, DAT_000041ec);\n    return result;\n  }\n  result = _file_walk_000041d0_reent(*PTR__impure_ptr_000041f0, __stream);\n  return result;\n}",
            "called": [
                "_fflush_r",
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041d0",
            "calling": [
                "print_prompt",
                "lflush"
            ],
            "imported": false,
            "current_name": "file_walk_000041d0"
        },
        "FUN_0000459c": {
            "renaming": {
                "FUN_0000459c": "initialize_EVP_PKEY_CTX_0000459c",
                "param_1": "pkey_ctx",
                "puVar1": "pointer1",
                "puVar2": "pointer2",
                "iVar3": "num_functions",
                "ppcVar4": "functions",
                "iVar5": "i",
                "PTR___fini_array_end_000045d8": "DAT___fini_array_end_000045d8",
                "PTR___fini_array_end_000045d4": "DAT___fini_array_end_000045d4",
                "PTR___fini_array_end_000045e0": "DAT___fini_array_end_000045e0",
                "PTR___fini_array_end_000045dc": "DAT___fini_array_end_000045dc"
            },
            "code": "void initialize_EVP_PKEY_CTX_0000459c(EVP_PKEY_CTX *pkey_ctx) {\n  int num_functions = (int)PTR___fini_array_end_000045d8 - (int)PTR___fini_array_end_000045d4;\n  code **functions = (code **)PTR___fini_array_end_000045d4;\n  for (int i = 0; i < num_functions; i++) {\n    pkey_ctx = (EVP_PKEY_CTX *)(*functions)();\n    functions++;\n  }\n  _init(pkey_ctx);\n  functions = (code **)PTR___fini_array_end_000045dc;\n  int num_functions2 = (int)PTR___fini_array_end_000045e0 - (int)PTR___fini_array_end_000045dc;\n  for (int i = 0; i < num_functions2; i++) {\n    (*functions)();\n    functions++;\n  }\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000459c",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_0000459c"
        },
        "FUN_000014c4": {
            "renaming": {
                "FUN_000014c4": "configure_uart_000014c4",
                "uart": "uart_t",
                "baudrate": "uint32_t",
                "pbVar1": "config_ptr",
                "uVar2": "config_value",
                "uVar3": "ubd",
                "txfifo_size": "txfifo_size",
                "brfa": "brfa",
                "ubd": "ubd",
                "clk": "clk",
                "dev": "dev",
                "PTR_uart_config_000015cc": "uart_config_ptr"
            },
            "code": "void configure_uart_000014c4(uart_t uart, uint32_t baudrate)\n{\n  byte *config_ptr;\n  uint32_t config_value;\n  uint8_t txfifo_size;\n  uint8_t brfa;\n  uint16_t ubd;\n  uint32_t clk;\n  UART_Type *dev;\n  \n  config_ptr = *(byte **)(PTR_uart_config_000015cc + uart * 0x20);\n  config_value = *(uint32_t *)(PTR_uart_config_000015cc + uart * 0x20 + 4);\n  config_ptr[3] = config_ptr[3] & 0xf3;\n  config_ptr[2] = PTR_uart_config_000015cc[uart * 0x20 + 0x1d];\n  ubd = config_value / (baudrate << 4);\n  *config_ptr = (byte)(ubd >> 8) & 0x1f;\n  config_ptr[1] = (byte)ubd;\n  config_ptr[10] = (byte)((config_value << 2) / baudrate + 1 >> 1) & 0x1f;\n  config_ptr[0x10] = config_ptr[0x10] | 0x88;\n  if ((config_ptr[0x10] & 0x70) == 0) {\n    config_ptr[0x13] = 0;\n  }\n  else {\n    config_ptr[0x13] = (char)(2 << (config_ptr[0x10] >> 4 & 7)) - 1;\n  }\n  config_ptr[0x15] = 1;\n  config_ptr[0x11] = 0xc0;\n  config_ptr[3] = config_ptr[3] | 0x2c;\n  NVIC_EnableIRQ(PTR_uart_config_000015cc[uart * 0x20 + 0x14]);\n  return;\n}",
            "called": [
                "NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000014c4",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "configure_uart_000014c4"
        },
        "FUN_00004b34": {
            "renaming": {
                "FUN_00004b34": "allocate_memory_block_00004b34",
                "param_1": "error_code",
                "param_2": "block_size",
                "param_3": "unused_arg_1",
                "param_4": "unused_arg_2",
                "puVar1": "malloc_free_list",
                "piVar2": "block_size_ptr",
                "extraout_r1": "last_block_ptr",
                "ppiVar3": "next_block_ptr",
                "ppiVar4": "previous_block_ptr",
                "ppiVar5": "current_block_ptr",
                "ppiVar6": "last_block_ptr",
                "bVar7": "found_block"
            },
            "code": "void allocate_memory_block_00004b34(int* error_code, int block_size, int unused_arg_1, int unused_arg_2)\n{\n  unsigned char* malloc_free_list = NULL;\n  int **current_block_ptr = NULL;\n  int **previous_block_ptr = NULL;\n  int **next_block_ptr = NULL;\n  int **last_block_ptr = NULL;\n  bool found_block = false;\n  \n  if (block_size == 0) {\n    return;\n  }\n  \n  current_block_ptr = (int **)(block_size - 4);\n  if (*(int *)(block_size - 4) < 0) {\n    current_block_ptr = (int **)((int)current_block_ptr + *(int *)(block_size - 4));\n  }\n  __malloc_lock();\n  \n  malloc_free_list = PTR___malloc_free_list_00004bcc;\n  previous_block_ptr = *(int ***)malloc_free_list;\n  \n  if (previous_block_ptr == NULL) {\n    current_block_ptr[1] = NULL;\n    *(int ***)malloc_free_list = current_block_ptr;\n    last_block_ptr = (int **)extraout_r1;\n    next_block_ptr = (int **)malloc_free_list;\n  }\n  else if (current_block_ptr < previous_block_ptr) {\n    next_block_ptr = (int **)*current_block_ptr;\n    last_block_ptr = (int **)((int)current_block_ptr + (int)next_block_ptr);\n    found_block = previous_block_ptr == last_block_ptr;\n    if (found_block) {\n      last_block_ptr = (int **)*previous_block_ptr;\n      previous_block_ptr = (int **)previous_block_ptr[1];\n    }\n    current_block_ptr[1] = (int *)previous_block_ptr;\n    if (found_block) {\n      last_block_ptr = (int **)((int)last_block_ptr + (int)next_block_ptr);\n      *current_block_ptr = (int *)last_block_ptr;\n    }\n    *(int ***)malloc_free_list = current_block_ptr;\n  }\n  else {\n    do {\n      last_block_ptr = previous_block_ptr;\n      previous_block_ptr = (int **)last_block_ptr[1];\n      if (previous_block_ptr == NULL) break;\n    } while (previous_block_ptr <= current_block_ptr);\n    next_block_ptr = (int **)*last_block_ptr;\n    if ((int **)((int)last_block_ptr + (int)next_block_ptr) == current_block_ptr) {\n      next_block_ptr = (int **)((int)next_block_ptr + (int)*current_block_ptr);\n      *last_block_ptr = (int *)next_block_ptr;\n      if (previous_block_ptr == (int **)((int)last_block_ptr + (int)next_block_ptr)) {\n        int* block_size_ptr = *previous_block_ptr;\n        last_block_ptr[1] = previous_block_ptr[1];\n        next_block_ptr = (int **)((int)next_block_ptr + (int)block_size_ptr);\n        *last_block_ptr = (int *)next_block_ptr;\n      }\n    }\n    else if (current_block_ptr < (int **)((int)last_block_ptr + (int)next_block_ptr)) {\n      *error_code = 0xc;\n    }\n    else {\n      next_block_ptr = (int **)((int)current_block_ptr + (int)*current_block_ptr);\n      found_block = previous_block_ptr == next_block_ptr;\n      if (found_block) {\n        next_block_ptr = (int **)*previous_block_ptr;\n        previous_block_ptr = (int **)previous_block_ptr[1];\n      }\n      current_block_ptr[1] = (int *)previous_block_ptr;\n      if (found_block) {\n        next_block_ptr = (int **)((int)next_block_ptr + (int)*current_block_ptr);\n        *current_block_ptr = (int *)next_block_ptr;\n      }\n      last_block_ptr[1] = (int *)current_block_ptr;\n    }\n  }\n  __malloc_unlock(error_code,next_block_ptr,last_block_ptr,unused_arg_2);\n  return;\n}",
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004b34",
            "calling": [
                "__ssrefill_r",
                "_realloc_r",
                "__srefill_r",
                "__sflush_r",
                "free",
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_00004b34"
        },
        "FUN_000004f2": {
            "renaming": {
                "FUN_000004f2": "handle_file_position_error_000004f2",
                "r": "reent",
                "fd": "file_descriptor",
                "pos": "position",
                "dir": "direction"
            },
            "code": "_off_t handle_file_position_error_000004f2(_reent *reent, int file_descriptor, _off_t position, int direction) {\n    reent->errno = 0x13;\n    return -1;\n  }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004f2",
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "imported": false,
            "current_name": "handle_file_position_error_000004f2"
        },
        "FUN_0000423c": {
            "renaming": {
                "FUN_0000423c": "walk_reentrancy_checks_0000423c",
                "param_1": "reentrancy_structure",
                "DAT_00004244": "global_reentrancy_guard"
            },
            "code": "void walk_reentrancy_checks_0000423c(void* reentrancy_structure)\n{\n  _fwalk_reent(reentrancy_structure, DAT_00004244);\n  return;\n}",
            "called": [
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000423c",
            "calling": [],
            "imported": false,
            "current_name": "walk_reentrancy_checks_0000423c"
        },
        "FUN_00004e66": {
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "__s1": "str1",
                "__s2": "str2",
                "__n": "length",
                "pbVar1": "ptr1",
                "pbVar2": "ptr2",
                "uVar3": "curr_char"
            },
            "code": "int compare_strings_00004e66(char* str1, char* str2, size_t length) {\n  byte* ptr1;\n  byte* ptr2;\n  uint8_t curr_char;\n  \n  if (length == 0) {\n    return 0;\n  }\n  \n  ptr2 = (byte*)(str2 + length - 1);\n  ptr1 = (byte*)str1;\n  \n  do {\n    curr_char = (uint8_t)*ptr1;\n    ptr2++;\n    if (curr_char != *ptr2 || ptr1 + 1 == (byte*)(str1 + length)) {\n      break;\n    }\n    ptr1++;\n  } while (curr_char != 0);\n  \n  length = curr_char - *ptr2;\n  return length;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e66",
            "calling": [
                "_findenv_r",
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e66"
        },
        "FUN_00005ecc": {
            "renaming": {
                "FUN_00005ecc": "count_string_length_00005ecc",
                "__s": "input_string",
                "pcVar2": "current_char_ptr",
                "cVar1": "current_char",
                "pcVar3": "string_ptr"
            },
            "code": "size_t count_string_length_00005ecc(char* input_string) {\n    char current_char;\n    char* current_char_ptr;\n    char* string_ptr;\n    string_ptr = input_string;\n    do {\n        current_char_ptr = string_ptr + 1;\n        current_char = *string_ptr;\n        string_ptr = current_char_ptr;\n    } while (current_char != \"\\0\");\n    size_t string_length = (size_t)(current_char_ptr + (-1 - (int)input_string));\n    return string_length;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ecc",
            "calling": [
                "_tzset_unlocked_r",
                "siscanf"
            ],
            "imported": false,
            "current_name": "count_string_length_00005ecc"
        },
        "FUN_0000129c": {
            "renaming": {
                "FUN_0000129c": "lock_mutex_0000129c",
                "mutex": "mutex",
                "_FUN_0000129c": "acquire_mutex"
            },
            "code": "void lock_mutex_0000129c(mutex_t *mutex)\n{\n    acquire_mutex(mutex);\n    return;\n}",
            "called": [
                "_mutex_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000129c",
            "calling": [
                "isrpipe_read"
            ],
            "imported": false,
            "current_name": "lock_mutex_0000129c"
        },
        "FUN_00001628": {
            "renaming": {
                "FUN_00001628": "process_uart_data_00001628",
                "uart": "uart_instance",
                "data": "received_data",
                "dev": "uart_device",
                "PTR_uart_config_00001680": "uart_config_ptr",
                "PTR_config_00001684": "uart_callback_ptr"
            },
            "code": "void process_uart_data_00001628(uart_t uart) {\n  uint8_t received_data;\n  UART_Type *uart_device;\n  uint8_t uart_config_flags = *(uint8_t *)(PTR_uart_config_00001680 + uart * 0x20 + 4);\n  void (*uart_callback)(uint32_t, uint8_t) = (void (*)(uint32_t, uint8_t))*(uint32_t *)(PTR_config_00001684 + uart * 8);\n  if ((uart_config_flags & 0x20) && (uart_callback != 0)) {\n    uart_callback(*(uint32_t *)(PTR_config_00001684 + uart * 8 + 4), *(uint8_t *)(*(uint32_t *)(PTR_uart_config_00001680 + uart * 0x20) + 7));\n  }\n  cortexm_isr_end();\n  return;\n}",
            "called": [
                "cortexm_isr_end"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001628",
            "calling": [
                "isr_uart0_rx_tx"
            ],
            "imported": false,
            "current_name": "process_uart_data_00001628"
        },
        "FUN_00001748": {
            "renaming": {
                "FUN_00001748": "set_kinetis_mcg_fll_factor_00001748",
                "factor": "new_factor",
                "DAT_00001774": "PTR_dat_00001774",
                "KINETIS_MCG_FLL_FACTOR_2929": "KINETIS_MCG_FLL_FACTOR_MASK"
            },
            "code": "void set_kinetis_mcg_fll_factor_00001748(kinetis_mcg_fll_t factor){\n  kinetis_mcg_fll_t* fll_factor_ptr = (kinetis_mcg_fll_t *)(DAT_00001774 + 3);\n  kinetis_mcg_fll_t current_factor = *fll_factor_ptr;\n  kinetis_mcg_fll_t new_factor = (current_factor & ~KINETIS_MCG_FLL_FACTOR_2929) | factor;\n  *fll_factor_ptr = new_factor;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001748",
            "calling": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "set_kinetis_mcg_fll_factor_00001748"
        },
        "FUN_0000294c": {
            "renaming": {
                "FUN_0000294c": "set_rtc_alarm_flag_0000294c",
                "rtt": "rtc",
                "DAT_0000296c": "alarm_reg",
                "PTR_": "PTR_ and DAT_ variables are not renamed"
            },
            "code": "void set_rtc_alarm_flag_0000294c(void)\n{\n  RTC_Type *rtc;\n  uint32_t *DAT_0000296c = (uint32_t *)(DAT_0000296c + 0x14);\n  *DAT_0000296c |= 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000294c",
            "calling": [
                "rtt_init",
                "rtc_poweron"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_flag_0000294c"
        },
        "FUN_00005790": {
            "renaming": {
                "FUN_00005790": "acquire_recursive_lock_for_malloc_00005790",
                "PTR___lock___malloc_recursive_mutex_00005798": "malloc_recursive_mutex"
            },
            "code": "void acquire_recursive_lock_for_malloc_00005790(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___malloc_recursive_mutex_00005798);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005790",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_for_malloc_00005790"
        },
        "FUN_00000534": {
            "renaming": {
                "FUN_00000534": "check_standard_file_descriptor_00000534",
                "r": "reent",
                "fd": "file_descriptor",
                "iVar1": "is_standard_file_descriptor"
            },
            "code": "int check_standard_file_descriptor_00000534(_reent *reent, int file_descriptor) {\n  int is_standard_file_descriptor;\n  reent->_errno = 0;\n  if (((file_descriptor == STDIN_FILENO) || (file_descriptor == STDOUT_FILENO)) || (file_descriptor == STDERR_FILENO)) {\n    is_standard_file_descriptor = 1;\n  }\n  else {\n    is_standard_file_descriptor = 0;\n  }\n  return is_standard_file_descriptor;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000534",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_standard_file_descriptor_00000534"
        },
        "FUN_000017dc": {
            "renaming": {
                "FUN_000017dc": "set_bit_and_check_000017dc",
                "DAT_00001820": "data_ptr",
                "DAT_00001824": "flag_ptr",
                "DAT_00001828": "flag_bit"
            },
            "code": "void set_bit_and_check_000017dc(uint32_t *DAT_00001820, uint32_t *DAT_00001824, uint32_t DAT_00001828) {\n  bit_set32(*DAT_00001820, DAT_00001828);\n  if((*DAT_00001824 & 0x100) == 0) {\n    *DAT_00001824 = 0x104;\n  }\n  *DAT_00001820 = (*DAT_00001820 & 0xfff3ffff) | 0x80000;\n  return;\n}",
            "called": [
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000017dc",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_bit_and_check_000017dc"
        },
        "FUN_00000410": {
            "renaming": {
                "FUN_00000410": "initialize_EVP_PKEY_CTX_00000410",
                "ctx": "context",
                "uart_stdioFUN_00000410": "initialize_uart_stdio"
            },
            "code": "int initialize_EVP_PKEY_CTX_00000410(EVP_PKEY_CTX *context){\n  initialize_uart_stdio();\n  return (int)context;\n}",
            "called": [
                "uart_stdio_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000410",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_00000410"
        },
        "FUN_000005ca": {
            "renaming": {
                "FUN_000005ca": "remove_second_node_000005ca",
                "list": "list",
                "plVar1": "second_node",
                "first": "first_node"
            },
            "code": "clist_node_t* remove_second_node_000005ca(clist_node_t* list) {\\n\\\n  list_node *second_node;\\n\\\n  clist_node_t *first_node;\\n\\\n  \\n\\\n  if (list->next == NULL) {\\n\\\n    second_node = NULL;\\n\\\n  }\\n\\\n  else {\\n\\\n    second_node = list->next->next;\\n\\\n    if (second_node == list->next) {\\n\\\n      list->next = NULL;\\n\\\n    }\\n\\\n    else {\\n\\\n      list->next->next = second_node->next;\\n\\\n    }\\n\\\n  }\\n\\\n  return second_node;\\n\\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000005ca",
            "calling": [
                "sched_set_status"
            ],
            "imported": false,
            "current_name": "remove_second_node_000005ca"
        },
        "FUN_000043da": {
            "renaming": {
                "FUN_000043da": "find_and_execute_code_blocks_000043da",
                "param_1": "base_address",
                "param_2": "execute_code_block",
                "param_3": "param_3",
                "param_4": "param_4",
                "piVar3": "block_pointer",
                "uVar5": "result",
                "iVar6": "block_count",
                "iVar4": "block_address",
                "uVar1": "execute_result",
                "iVar2": "block_size"
            },
            "code": "uint find_and_execute_code_blocks_000043da(int base_address, code *execute_code_block, undefined4 param_3, undefined4 param_4)\n{\n  uint result = 0;\n  int *block_pointer = (int *)(base_address + 0x48);\n  do {\n    int block_count = block_pointer[1];\n    int block_address = block_pointer[2];\n    while (block_count-- > 0) {\n      if (*(ushort *)(block_address + 0xc) > 1) {\n        int block_size = *(short *)(block_address + 0xe) + 1;\n        if (block_size != 0) {\n          uint execute_result = (*execute_code_block)(base_address, block_address, param_3, block_size, param_4);\n          result |= execute_result;\n        }\n      }\n      block_address += 0x68;\n    }\n    block_pointer = (int *)*block_pointer;\n  } while (block_pointer != (int *)0x0);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043da",
            "calling": [
                "_cleanup_r",
                "fflush"
            ],
            "imported": false,
            "current_name": "find_and_execute_code_blocks_000043da"
        },
        "FUN_00005ff8": {
            "renaming": {
                "FUN_00005ff8": "release_recursive_mutex_00005ff8"
            },
            "code": "void release_recursive_mutex_00005ff8(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___env_recursive_mutex_00006000);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ff8",
            "calling": [
                "_findenv_r"
            ],
            "imported": false,
            "current_name": "release_recursive_mutex_00005ff8"
        },
        "FUN_00006754": {
            "renaming": {
                "FUN_00006754": "flush_file_00006754",
                "param_1": "file_ptr",
                "iVar1": "flush_result"
            },
            "code": "int flush_file_00006754(FILE *file_ptr) {\n  int flush_result;\n  if ((*(unsigned short *)&file_ptr->_IO_read_base & 9) == 9) {\n    flush_result = fflush(file_ptr);\n    return flush_result;\n  }\n  return 0;\n}",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006754",
            "calling": [],
            "imported": false,
            "current_name": "flush_file_00006754"
        },
        "FUN_00002714": {
            "renaming": {
                "FUN_00002714": "setInterruptPriority_00002714",
                "IRQn": "irqNumber",
                "DAT_00002740": "interruptRegisterBaseAddress"
            },
            "code": "void setInterruptPriority_00002714(IRQn_Type irqNumber) {\n    int* interruptRegister = (int*)(DAT_00002740 + ((uint)(int)irqNumber >> 5) * 4);\n    int interruptBit = 1 << (irqNumber & 0x1fU);\n    *interruptRegister = interruptBit;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002714",
            "calling": [
                "rtt_set_alarm"
            ],
            "imported": false,
            "current_name": "setInterruptPriority_00002714"
        },
        "FUN_000020e0": {
            "renaming": {
                "FUN_000020e0": "handle_interrupt_000020e0",
                "DAT_000020f0": "interrupt_type",
                "2": "IRQ_TYPE",
                "irq_handler": "handle_irq"
            },
            "code": "void handle_interrupt_000020e0(void)\n{\n  int DAT_000020f0 = 2;\n  irq_handler(DAT_000020f0);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020e0",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020e0"
        },
        "FUN_00004f80": {
            "renaming": {
                "FUN_00004f80": "parse_number_00004f80",
                "param_1": "output",
                "param_2": "input_string",
                "param_3": "end_ptr",
                "param_4": "base",
                "uVar1": "digit_value",
                "uVar2": "input_char",
                "uVar3": "flags",
                "uVar4": "digit",
                "iVar5": "status",
                "uVar6": "value_max",
                "uVar7": "value",
                "pbVar8": "current_char",
                "pbVar9": "start_char"
            },
            "code": "uint parse_number_00004f80(undefined4 *output, byte *input_string, byte **end_ptr, uint base) {\n  uint digit_value;\n  uint flags;\n  uint input_char;\n  uint is_negative;\n  int status;\n  uint value;\n  uint value_max;\n  byte *current_char;\n  byte *start_char;\n\n  start_char = input_string;\n  do {\n    current_char = start_char;\n    start_char = current_char + 1;\n    digit_value = (uint)*current_char;\n    flags = (byte)PTR_DAT_00004f7c[digit_value] & 8;\n  } while ((PTR_DAT_00004f7c[digit_value] & 8) != 0);\n\n  if (digit_value == 0x2d) {\n    digit_value = (uint)*start_char;\n    flags = 1;\n    start_char = current_char + 2;\n  }\n  else if (digit_value == 0x2b) {\n    digit_value = (uint)*start_char;\n    start_char = current_char + 2;\n  }\n\n  if (base == 0) {\n    if (digit_value != 0x30) {\n      base = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((base != 0x10) || (digit_value != 0x30)) {\n    goto LAB_00004ed6;\n  }\n\n  if ((*start_char & 0xdf) == 0x58) {\n    digit_value = (uint)start_char[1];\n    base = 0x10;\n    start_char = start_char + 2;\n  }\n  else {\n    digit_value = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\n\n  value_max = flags + 0x7fffffff;\n  is_negative = 0;\n  value = value_max / base;\n  status = 0;\n\n  do {\n    input_char = (uint)*start_char;\n    start_char = start_char + 1;\n    digit_value = input_char - 0x30;\n    if (digit_value > 9) {\n      if (input_char - 0x41 < 0x1a) {\n        digit_value = input_char - 0x37;\n      }\n      else {\n        if (0x19 < input_char - 0x61) break;\n        digit_value = input_char - 0x57;\n      }\n    }\n    if ((int)base <= (int)digit_value) break;\n    if (status != -1) {\n      if ((value < value_max) || ((value == value_max && ((int)(value_max - base * value) < (int)digit_value))))) {\n        status = -1;\n      }\n      else {\n        value = value * base + digit_value;\n        status = 1;\n      }\n    }\n  } while( true );\n\n  if (status == -1) {\n    *output = 0x22;\n    value = value_max;\n    if (end_ptr == (byte **)0x0) {\n      return value_max;\n    }\n  }\n  else {\n    if (flags != 0) {\n      value = -value;\n    }\n    if (end_ptr == (byte **)0x0) {\n      return value;\n    }\n    if (status == 0) goto LAB_00004f64;\n  }\n  input_string = start_char - 1;\nLAB_00004f64:\n  *end_ptr = input_string;\n  return value;\n}",
            "called": [
                "_strtol_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f80",
            "calling": [],
            "imported": false,
            "current_name": "parse_number_00004f80"
        },
        "FUN_00005fec": {
            "renaming": {
                "FUN_00005fec": "acquire_recursive_lock_00005fec",
                "PTR___lock___env_recursive_mutex_00005ff4": "PTR_recursive_lock_mutex"
            },
            "code": "void acquire_recursive_lock_00005fec(void)\n{\n    __retarget_lock_acquire_recursive(PTR___lock___env_recursive_mutex_00005ff4);\n    return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fec",
            "calling": [
                "_findenv_r"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_00005fec"
        },
        "FUN_00004f84": {
            "renaming": {
                "FUN_00004f84": "convert_string_to_long_00004f84",
                "__nptr": "string",
                "__endptr": "end_ptr",
                "__base": "base",
                "lVar1": "result",
                "*PTR__impure_ptr_00004f94": "unknown_pointer"
            },
            "code": "long convert_string_to_long_00004f84(char *string, char **end_ptr, int base) {\n  long result = strtol(string, end_ptr, base);\n  return result;\n}",
            "called": [
                "_strtol_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f84",
            "calling": [
                "atoi",
                "_parse_time"
            ],
            "imported": false,
            "current_name": "convert_string_to_long_00004f84"
        },
        "FUN_000028f0": {
            "renaming": {
                "FUN_000028f0": "get_RTC_value_plus_one_000028f0",
                "rtt": "rtt_ptr",
                "*(int *)(DAT_0000290c + 8)": "*data_ptr",
                "uint32_t": "uint32_t",
                "RTC_Type": "RTC_Type",
                "return": "return",
                "DAT_0000290c": "DAT_0000290c"
            },
            "code": "uint32_t get_RTC_value_plus_one_000028f0(void)\n{\n    RTC_Type* rtt_ptr;\n    uint32_t* data_ptr = (uint32_t*)(DAT_0000290c + 8);\n    return *(int *)(DAT_0000290c + 8) + 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000028f0",
            "calling": [
                "rtc_get_alarm"
            ],
            "imported": false,
            "current_name": "get_RTC_value_plus_one_000028f0"
        },
        "FUN_00004f98": {
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "param_1": "year",
                "puVar1": "time_zone_info",
                "uVar2": "result",
                "uVar3": "days_in_month",
                "iVar4": "is_leap_year",
                "puVar5": "months",
                "iVar6": "days_since_1900",
                "uVar7": "num_leading_zeroes",
                "iVar8": "month_index",
                "iVar9": "day_offset",
                "uVar10": "num_leading_zeroes",
                "PTR___month_lengths_000050e4": "month_lengths",
                "DAT_000050e0": "days_per_year"
            },
            "code": "uint32_t calculate_day_of_week_00004f98(uint32_t year)\n{\n    uint32_t *time_zone_info = (uint32_t *)__gettzinfo();\n    if ((int)year < 0x7b2) {\n        return 0;\n    }\n    else {\n        uint32_t num_leading_zeroes = count_leading_zeroes(year % 400);\n        uint32_t days_since_1900 = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) + (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n        time_zone_info[1] = year;\n        uint32_t *months = time_zone_info;\n        do {\n            uint32_t days_in_month = months[5];\n            if (*(char *)(months + 2) == 'J') {\n                if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n                    if ((int)days_in_month < 0x3c) {\n                        days_since_1900 += 0;\n                    }\n                    else {\n                        days_since_1900 += 1;\n                    }\n                }\n                else {\n                    days_since_1900 += 0;\n                }\n                days_since_1900 += days_in_month + -1;\n            }\n            else if (*(char *)(months + 2) == 'D') {\n                days_since_1900 += days_in_month;\n            }\n            else {\n                uint32_t month_length_index = num_leading_zeroes >> 5;\n                if (((year & 3) == 0) && (year % 100 != 0)) {\n                    month_length_index = 1;\n                }\n                uint32_t month_index = 1;\n                days_since_1900 += days_in_month;\n                while ((int)months[3] > month_index) {\n                    days_since_1900 += *(int *)(PTR___PTR___month_lengths_000050e4_000050e4 + month_index * 4 + month_length_index * 0x30 + -4);\n                    month_index++;\n                }\n                uint32_t day_of_week = days_in_month - (days_since_1900 + 4U) % 7;\n                if (day_of_week < 0) {\n                    day_of_week += 7;\n                }\n                for (day_of_week = (months[4] - 1) * 7 + day_of_week; *(int *)(PTR___PTR___month_lengths_000050e4_000050e4 + month_index * 4 + month_length_index * 0x30 + -4) <= day_of_week; day_of_week -= 7) {\n                }\n                days_since_1900 += day_of_week;\n            }\n            days_in_month = months[10] + DAT_000050e0 * days_since_1900 + months[6];\n            months[8] = days_in_month;\n            months[9] = (int)days_in_month >> 0x1f;\n            months = months + 10;\n        } while (time_zone_info + 0x14 != months);\n        uint32_t days_since_1970 = time_zone_info[9];\n        num_leading_zeroes = time_zone_info[0x13];\n        *time_zone_info = (uint32_t)((int)((days_since_1970 - num_leading_zeroes) - (uint32_t)(time_zone_info[8] < time_zone_info[0x12])) < 0 != (SBORROW4(days_since_1970,num_leading_zeroes) != SBORROW4(days_since_1970 - num_leading_zeroes,(uint32_t)(time_zone_info[8] < time_zone_info[0x12]))));\n        return 1;\n    }\n}",
            "called": [
                "__gettzinfo"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f98",
            "calling": [
                "mktime",
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_00004f98"
        },
        "FUN_00004dee": {
            "renaming": {
                "FUN_00004dee": "write_data_00004dee",
                "param_1": "reent_ptr",
                "param_2": "data_ptr",
                "param_3": "data",
                "param_4": "size",
                "ushort": "uint16_t",
                "int": "int32_t",
                "short": "int16_t"
            },
            "code": "void write_data_00004dee(_reent *reent_ptr, int data_ptr, void *data, size_t size) {\n    if ((int)((uint16_t)*(uint16_t *)(data_ptr + 0xc) << 0x17) < 0) {\n        _lseek_r(reent_ptr, (int)*(int16_t *)(data_ptr + 0xe), 0, 2);\n    }\n    *(uint16_t *)(data_ptr + 0xc) = *(uint16_t *)(data_ptr + 0xc) & 0xefff;\n    _write_r(reent_ptr, (int)*(int16_t *)(data_ptr + 0xe), data, size);\n    return;\n}",
            "called": [
                "_lseek_r",
                "_write_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dee",
            "calling": [],
            "imported": false,
            "current_name": "write_data_00004dee"
        },
        "FUN_00000fec": {
            "renaming": {
                "FUN_00000fec": "initialize_circular_buffer_00000fec",
                "cib_t": "circular_buffer_t",
                "cib": "circular_buffer",
                "size": "size",
                "PTR_assert_crash_message_00001030": "PTR_assert_crash_message_00001030"
            },
            "code": "void initialize_circular_buffer_00000fec(circular_buffer_t* circular_buffer, uint32_t size) {\n  if ((size & (size - 1)) != 0) {\n    core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_00001030);\n  }\n  circular_buffer->read_count = 0;\n  circular_buffer->write_count = 0;\n  circular_buffer->mask = size - 1;\n  return;\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000fec",
            "calling": [
                "thread_create"
            ],
            "imported": false,
            "current_name": "initialize_circular_buffer_00000fec"
        },
        "FUN_00000428": {
            "renaming": {
                "FUN_00000428": "allocate_memory_00000428",
                "r": "reent",
                "incr": "increment",
                "state_00": "interrupt_state_1",
                "state": "interrupt_state_2",
                "res": "result"
            },
            "code": "void * allocate_memory_00000428(_reent *reent,ptrdiff_t increment)\n{\n  uint interrupt_state_1;\n  uint interrupt_state_2;\n  void *result;\n  \n  interrupt_state_1 = irq_disable();\n  result = *(void **)PTR_heap_top_00000484;\n  if ((PTR__eram_00000488 < (undefined *)(increment + *(int *)PTR_heap_top_00000484)) ||\n     ((undefined *)(increment + *(int *)PTR_heap_top_00000484) < PTR__sheap_0000048c)) {\n    reent->_errno = 0xc;\n    result = (void *)0xffffffff;\n  }\n  else {\n    *(ptrdiff_t *)PTR_heap_top_00000484 = increment + *(int *)PTR_heap_top_00000484;\n  }\n  irq_restore(interrupt_state_1);\n  return result;\n}",
            "called": [
                "irq_disable",
                "irq_restore"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000428",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00000428"
        },
        "FUN_000039e8": {
            "renaming": {
                "FUN_000039e8": "getClassFromId_000039e8"
            },
            "code": "char * getClassFromId_000039e8(uint8_t class_id)\n{\n    char *class_name = PTR_s_CLASS_UNKNOWN_00003d20;\n    switch(class_id) {\n        case '\\0':\n            class_name = PTR_s_CLASS_UNDEF_00003cc0;\n            break;\n        case '@':\n            class_name = PTR_s_ACT_ANY_00003cc4;\n            break;\n        case 'B':\n            class_name = PTR_s_ACT_LED_RGB_00003cc8;\n            break;\n        case 'C':\n            class_name = PTR_s_ACT_SERVO_00003ccc;\n            break;\n        case 'D':\n            class_name = PTR_s_ACT_MOTOR_00003cd0;\n            break;\n        case 'E':\n            class_name = PTR_s_ACT_SWITCH_00003cd4;\n            break;\n        case 'F':\n            class_name = PTR_s_ACT_DIMMER_00003cd8;\n            break;\n        case 0x80:\n            class_name = PTR_s_SENSE_ANY_00003cdc;\n            break;\n        case 0x81:\n            class_name = PTR_s_SENSE_BTN_00003ce0;\n            break;\n        case 0x82:\n            class_name = PTR_s_SENSE_TEMP_00003ce4;\n            break;\n        case 0x83:\n            class_name = PTR_s_SENSE_HUM_00003ce8;\n            break;\n        case 0x84:\n            class_name = PTR_s_SENSE_LIGHT_00003cec;\n            break;\n        case 0x85:\n            class_name = PTR_s_SENSE_ACCEL_00003cf0;\n            break;\n        case 0x86:\n            class_name = PTR_s_SENSE_MAG_00003cf4;\n            break;\n        case 0x87:\n            class_name = PTR_s_SENSE_GYRO_00003cf8;\n            break;\n        case 0x88:\n            class_name = PTR_s_SENSE_COLOR_00003cfc;\n            break;\n        case 0x89:\n            class_name = PTR_s_SENSE_PRESS_00003d00;\n            break;\n        case 0x8a:\n            class_name = PTR_s_SENSE_ANALOG_00003d04;\n            break;\n        case 0x8b:\n            class_name = PTR_s_SENSE_UV_00003d08;\n            break;\n        case 0x8c:\n            class_name = PTR_s_SENSE_OBJTEMP_00003d0c;\n            break;\n        case 0x8d:\n            class_name = PTR_s_SENSE_PULSE_COUNT_00003d10;\n            break;\n        case 0x8e:\n            class_name = PTR_s_SENSE_DISTANCE_00003d14;\n            break;\n        case 0x8f:\n            class_name = PTR_s_SENSE_CO2_00003d18;\n            break;\n        case 0xff:\n            return PTR_s_CLASS_ANY_00003d1c;\n        default:\n            break;\n    }\n    return class_name;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000039e8",
            "calling": [
                "probe",
                "list"
            ],
            "imported": false,
            "current_name": "getClassFromId_000039e8"
        },
        "FUN_00000e38": {
            "renaming": {
                "FUN_00000e38": "write_to_uart_00000e38",
                "buffer": "data",
                "len": "length"
            },
            "code": "int write_to_uart_00000e38(char *buffer, int length)\n{\n  uart_write(0, (uint8_t *)buffer, length);\n  return length;\n}",
            "called": [
                "uart_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e38",
            "calling": [
                "_write_r"
            ],
            "imported": false,
            "current_name": "write_to_uart_00000e38"
        },
        "FUN_00002294": {
            "renaming": {
                "FUN_00002294": "is_ring_buffer_full_00002294",
                "rb": "ring_buffer",
                "bVar1": "is_full",
                "uVar2": "buffer_size",
                "bVar3": "buffer_full"
            },
            "code": "uint8_t is_ring_buffer_full_00002294(tsrb_t *ring_buffer) {\n    uint32_t buffer_size = ring_buffer->size;\n    bool buffer_full = (ring_buffer->writes - ring_buffer->reads == buffer_size);\n    uint8_t is_full = buffer_full ? 1 : 0;\n    return is_full;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002294",
            "calling": [
                "tsrb_add_one"
            ],
            "imported": false,
            "current_name": "is_ring_buffer_full_00002294"
        },
        "FUN_00003e9e": {
            "renaming": {
                "FUN_00003e9e": "format_integer_with_decimal_00003e9e",
                "out": "output_string",
                "val": "input_integer",
                "fp_digits": "decimal_places",
                "sVar1": "formatted_length",
                "fmt_s32_dfp": "format_signed_decimal_fixed_point"
            },
            "code": "size_t format_integer_with_decimal_00003e9e(char *output_string, int16_t input_integer, int decimal_places) {\n  size_t formatted_length = format_signed_decimal_fixed_point(output_string, (int)input_integer, decimal_places);\n  return formatted_length;\n}",
            "called": [
                "fmt_s32_dfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e9e",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "format_integer_with_decimal_00003e9e"
        },
        "FUN_00003378": {
            "renaming": {
                "FUN_00003378": "print_time_00003378",
                "time": "time",
                "PTR_s__04i__02i__02i__02i__02i__02i_000033bc": "iprintf",
                "tm_year": "year",
                "tm_mon": "month",
                "tm_mday": "day",
                "tm_hour": "hour",
                "tm_min": "minute",
                "tm_sec": "second"
            },
            "code": "int print_time_00003378(tm *time)\n{\n  int year = time->tm_year + 1900;\n  int month = time->tm_mon + 1;\n  int day = time->tm_mday;\n  int hour = time->tm_hour;\n  int minute = time->tm_min;\n  int second = time->tm_sec;\n  PTR_s__04i__02i__02i__02i__02i__02i_000033bc(\"Current time: %04d-%02d-%02d %02d:%02d:%02d\\n\", year, month, day, hour, minute, second);\n  return 0;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003378",
            "calling": [
                "_rtc_getalarm",
                "_rtc_gettime"
            ],
            "imported": false,
            "current_name": "print_time_00003378"
        },
        "FUN_00006768": {
            "renaming": {
                "FUN_00006768": "processIO_00006768",
                "param_1": "file_info",
                "param_2": "stream",
                "param_3": "flags",
                "param_4": "mode",
                "uVar1": "previous_status",
                "iVar2": "flush_result",
                "uVar3": "buffer_size",
                "uVar4": "status",
                "uVar5": "length"
            },
            "code": "undefined4 processIO_00006768(undefined4 *file_info, undefined4 *stream, undefined4 flags, undefined4 mode)\n{\n  ushort status = *(ushort *)(stream + 3);\n  uint length = (uint)*(ushort *)(stream + 3);\n  if ((file_info != (undefined4 *)0x0) && (file_info[6] == 0)) {\n    __sinit();\n  }\n  if (stream == (undefined4 *)PTR___sf_fake_stdin_00006868) {\n    stream = (undefined4 *)file_info[1];\n  }\n  else if (stream == (undefined4 *)PTR___sf_fake_stdout_0000686c) {\n    stream = (undefined4 *)file_info[2];\n  }\n  else if (stream == (undefined4 *)PTR___sf_fake_stderr_00006870) {\n    stream = (undefined4 *)file_info[3];\n  }\n  stream[1] = 0;\n  if ((int)(length << 0x1a) < 0) {\n    return 0xffffffff;\n  }\n  if ((int)(length << 0x1d) < 0) {\n    if ((undefined4 *)stream[0xd] != (undefined4 *)0x0) {\n      if ((undefined4 *)stream[0xd] != stream + 0x11) {\n        _free_r(file_info);\n      }\n      stream[1] = stream[0x10];\n      stream[0xd] = 0;\n      if (stream[0x10] != 0) {\n        *stream = stream[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 < (int)(length << 0x1b)) {\n      *file_info = 9;\n      status |= 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(length << 0x1c) < 0) {\n      int flush_result = _fflush_r(file_info,stream,length << 0x1c,length,mode);\n      if (flush_result != 0) {\n        return 0xffffffff;\n      }\n      stream[2] = 0;\n      *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xfff7;\n      stream[6] = 0;\n    }\n    *(ushort *)(stream + 3) = *(ushort *)(stream + 3) | 4;\n  }\n  if (stream[4] == 0) {\n    __smakebuf_r(file_info,stream);\n  }\n  status = *(ushort *)(stream + 3);\n  ushort previous_status = *(ushort *)(stream + 3);\n  if ((status & 3) != 0) {\n    *(ushort *)(stream + 3) = 1;\n    _fwalk(*(undefined4 *)PTR__global_impure_ptr_00006874,DAT_00006878);\n    *(ushort *)(stream + 3) = previous_status;\n    if ((status & 9) == 9) {\n      __sflush_r(file_info,stream);\n    }\n  }\n  uint buffer_size = stream[4];\n  *stream = buffer_size;\n  int read_result = (*(code *)stream[9])(file_info,stream[8],buffer_size,stream[5]);\n  stream[1] = read_result;\n  if (0 < read_result) {\n    return 0;\n  }\n  status = *(ushort *)(stream + 3);\n  if (read_result != 0) {\n    buffer_size = 0;\n  }\n  else {\n    status |= 0x20;\n  }\n  if (read_result != 0) {\n    stream[1] = buffer_size;\n    status |= 0x40;\n  }\nLAB_000067b8:\n  *(ushort *)(stream + 3) = status;\n  return 0xffffffff;\n}",
            "called": [
                "_fwalk",
                "__sflush_r",
                "_free_r",
                "_fflush_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006768",
            "calling": [
                "__srget_r"
            ],
            "imported": false,
            "current_name": "processIO_00006768"
        },
        "FUN_00000db0": {
            "renaming": {
                "FUN_00000db0": "disable_watchdog_and_fix_cpu_errata_00000db0",
                "wdog_disable": "disable_watchdog",
                "cpu_errata_fixes": "fix_cpu_errata"
            },
            "code": "void disable_watchdog_and_fix_cpu_errata_00000db0(void)\n{\n  disable_watchdog();\n  fix_cpu_errata();\n  return;\n}",
            "called": [
                "wdog_disable",
                "cpu_errata_fixes"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000db0",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "disable_watchdog_and_fix_cpu_errata_00000db0"
        },
        "FUN_00002600": {
            "renaming": {
                "FUN_00002600": "convert_time_to_counter_00002600",
                "time": "time_val",
                "counter": "time_counter"
            },
            "code": "int convert_time_to_counter_00002600(tm *time_struct)\n{\n  uint32_t counter;\n  time_t time;\n  \n  time = mktime((tm *)time_struct);\n  rtt_set_counter(counter);\n  return 0;\n}",
            "called": [
                "rtt_set_counter",
                "mktime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002600",
            "calling": [
                "_rtc_settime"
            ],
            "imported": false,
            "current_name": "convert_time_to_counter_00002600"
        },
        "FUN_00003810": {
            "renaming": {
                "FUN_00003810": "get_character_string_00003810",
                "unit": "unit_code",
                "pcVar1": "string_ptr"
            },
            "code": "char * get_character_string_00003810(uint8_t unit)\n{\n  char *string_ptr;\n  string_ptr = PTR_DAT_00003914;\n  switch(unit) {\n    case '\\x02':\n      string_ptr = PTR_DAT_000038cc;\n      break;\n    case '\\x03':\n      string_ptr = PTR_DAT_000038d0;\n      break;\n    case '\\x04':\n      string_ptr = PTR_DAT_000038d4;\n      break;\n    case '\\x05':\n      string_ptr = PTR_PTR_s_R_000038d8;\n      break;\n    case '\\x06':\n      string_ptr = PTR_DAT_000038dc;\n      break;\n    case '\\a':\n      string_ptr = PTR_DAT_000038e0;\n      break;\n    case '\\b':\n      string_ptr = PTR_DAT_000038e4;\n      break;\n    case '\\t':\n      string_ptr = PTR_DAT_000038e8;\n      break;\n    case '\\n':\n      string_ptr = PTR_DAT_000038ec;\n      break;\n    case '\\v':\n      string_ptr = PTR_DAT_000038f0;\n      break;\n    case '\\f':\n      string_ptr = PTR_DAT_000038f4;\n      break;\n    case '\\r':\n      string_ptr = PTR_DAT_000038f8;\n      break;\n    case '\\x0e':\n      string_ptr = PTR_DAT_000038fc;\n      break;\n    case '\\x0f':\n      string_ptr = PTR_DAT_00003900;\n      break;\n    case '\\x10':\n      string_ptr = PTR_DAT_00003904;\n      break;\n    case '\\x11':\n      string_ptr = PTR_DAT_0000390c;\n      break;\n    case '\\x13':\n      string_ptr = PTR_DAT_00003910;\n      break;\n    case '\\x15':\n      string_ptr = PTR_DAT_00003908;\n  }\n  return string_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003810",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "get_character_string_00003810"
        },
        "FUN_0000041c": {
            "renaming": {
                "FUN_0000041c": "do_nothing_0000041c"
            },
            "code": "\nvoid do_nothing_0000041c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000041c",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0000041c"
        },
        "FUN_00000ed8": {
            "renaming": {
                "FUN_00000ed8": "printLR_00000ed8",
                "in_lr": "lr_pointer",
                "lr_ptr": "lr",
                "PTR_DAT_00000ef4": "lr_format"
            },
            "code": "void printLR_00000ed8(uint32_t* lr_pointer)\n{\n    uint32_t* lr = lr_pointer;\n    iprintf(lr);\n    return;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ed8",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "printLR_00000ed8"
        },
        "FUN_000031e0": {
            "renaming": {
                "FUN_000031e0": "printAlarmMessage_000031e0",
                "arg": "message",
                "PTR_s_The_alarm_rang_000031f8": "alarmMessage"
            },
            "code": "void printAlarmMessage_000031e0(void *message)\n{\n    char *PTR_s_The_alarm_rang_000031f8 = (char*) message;\n    puts(PTR_s_The_alarm_rang_000031f8);\n    return;\n}",
            "called": [
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031e0",
            "calling": [],
            "imported": false,
            "current_name": "printAlarmMessage_000031e0"
        },
        "FUN_000004d4": {
            "renaming": {
                "FUN_000004d4": "set_errno_to_19_000004d4",
                "r": "reent",
                "fd": "file_descriptor"
            },
            "code": "int set_errno_to_19_000004d4(_reent *reent, int file_descriptor) {\n  reent->_errno = 0x13;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004d4",
            "calling": [
                "__sclose"
            ],
            "imported": false,
            "current_name": "set_errno_to_19_000004d4"
        },
        "FUN_000020f4": {
            "renaming": {
                "FUN_000020f4": "handle_irq_000020f4",
                "DAT_00002104": "irq_num",
                "irq_handler": "irq_handler",
                "priority": "priority"
            },
            "code": "void handle_irq_000020f4(void)\n{\n  int DAT_00002104 = DAT_00002104;\n  int priority = 3;\n  irq_handler(DAT_00002104, priority);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020f4",
            "calling": [],
            "imported": false,
            "current_name": "handle_irq_000020f4"
        },
        "FUN_0000687c": {
            "renaming": {
                "FUN_0000687c": "reverse_and_flip_0000687c",
                "param_1": "length",
                "param_2": "input",
                "pbVar1": "output_pointer",
                "uVar2": "end_char_code",
                "iVar3": "output_index",
                "uVar4": "current_char_code",
                "uVar5": "char_code",
                "uVar6": "end_char_code_plus_one",
                "bVar7": "is_first_char_caret"
            },
            "code": "byte* reverse_and_flip_0000687c(int length, byte* input)\n{\n  byte* output_pointer;\n  uint current_char_code;\n  bool is_first_char_caret = ((uint)*input == 0x5e);\n  if (is_first_char_caret) {\n    current_char_code = (uint)input[1];\n    input += 2;\n  }\n  else {\n    current_char_code = (uint)*input;\n    input += 1;\n  }\n  int output_index = length - 1;\n  do {\n    output_index++;\n    *(bool*)output_index = is_first_char_caret;\n  } while (output_index != length + 0xff);\n  if (current_char_code == 0) {\n    output_pointer = input - 1;\n  }\n  else {\n    do {\n      uint char_code = current_char_code;\n      *(bool*)(length + char_code) = !is_first_char_caret;\n      input += 1;\n      while (true) {\n        current_char_code = (uint)input[-1];\n        if (current_char_code != 0x2d) break;\n        uint end_char_code = (uint)*input;\n        if ((end_char_code == 0x5d) || (char_code > end_char_code)) goto end_loop;\n        do {\n          char_code++;\n          *(bool*)(length + char_code) = !is_first_char_caret;\n        } while (char_code < end_char_code);\n        int diff = end_char_code - current_char_code - 1;\n        if (end_char_code <= current_char_code) {\n          diff = 0;\n        }\n        current_char_code = end_char_code + diff + 1;\n        input += 2;\n      }\n      output_pointer = input - 1;\n    } while ((current_char_code != 0x5d) && (output_pointer = input - 1, current_char_code != 0));\n  }\n  end_loop:\n  return output_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000687c",
            "calling": [
                "_scanf_i",
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "reverse_and_flip_0000687c"
        },
        "FUN_00004dea": {
            "renaming": {
                "FUN_00004dea": "return_zero_00004dea"
            },
            "code": "int return_zero_00004dea(void) {\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dea",
            "calling": [],
            "imported": false,
            "current_name": "return_zero_00004dea"
        },
        "FUN_00005edc": {
            "renaming": {
                "_strtoul_l_isra_0": "convert_string_to_unsigned_integer",
                "param_1": "output",
                "param_2": "input_string",
                "param_3": "next_character",
                "param_4": "base",
                "uVar1": "total_value",
                "uVar2": "current_character_value",
                "bVar3": "is_hex",
                "iVar4": "loop_status",
                "uVar5": "current_digit_value",
                "uVar6": "max_value",
                "pbVar7": "current_character",
                "pbVar8": "next_character_candidate",
                "FUN_00005edc": "convert_string_to_unsigned_integer_00005edc"
            },
            "code": "uint convert_string_to_unsigned_integer_00005edc(undefined4 *output, byte *input_string, byte **next_character, uint base)\n{\n  uint current_character_value;\n  uint total_value = 0;\n  byte *current_character = input_string;\n  uint max_value = 0xffffffff / base;\n  bool is_negative = false;\n\n  while ((*current_character_value = (uint)*current_character) && (PTR_DAT_00005fd0[*current_character_value] & 8)) {\n    current_character++;\n  }\n\n  if (*current_character_value == 0x2d) {\n    is_negative = true;\n    current_character_value = (uint)*(++current_character);\n  }\n  else if (*current_character_value == 0x2b) {\n    current_character_value = (uint)*(++current_character);\n  }\n\n  if (base == 0) {\n    if (current_character_value != 0x30) {\n      base = 10;\n    }\n  }\n  else if ((base != 0x10) || (current_character_value != 0x30)) {\n    base = 10;\n  }\n\n  if ((*current_character == 0x58) && ((*(current_character + 1) & 0xdf) == 0x58)) {\n    base = 0x10;\n    current_character_value = (uint)*(current_character + 1);\n    current_character += 2;\n  }\n\n  while (true) {\n    current_character_value = (uint)*current_character;\n    if (current_character_value == 0) {\n      break;\n    }\n    uint current_digit_value = current_character_value - 0x30;\n    if (current_digit_value > 9) {\n      if (current_character_value - 0x41 < 0x1a) {\n        current_digit_value = current_character_value - 0x37;\n      }\n      else {\n        break;\n      }\n    }\n    if (base <= current_digit_value) {\n      break;\n    }\n    if (((int)total_value < 0) || (max_value < total_value)) {\n      total_value = 0xffffffff;\n      break;\n    }\n    else {\n      total_value = total_value * base + current_digit_value;\n    }\n    current_character++;\n  }\n\n  if (is_negative) {\n    total_value = -total_value;\n  }\n\n  if (next_character == NULL) {\n    return total_value;\n  }\n  else if (total_value == 0xffffffff) {\n    *output = 0x22;\n    return 0xffffffff;\n  }\n  else if (current_character == input_string) {\n    return 0;\n  }\n  else {\n    *next_character = current_character;\n    return total_value;\n  }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005edc",
            "calling": [
                "_strtoul_r",
                "strtoul"
            ],
            "imported": false,
            "current_name": "convert_string_to_unsigned_integer_00005edc"
        },
        "FUN_00001eea": {
            "renaming": {
                "FUN_00001eea": "configure_gpio_pin_00001eea",
                "pin": "gpio_pin",
                "mode": "gpio_mode",
                "uVar1": "pin_number",
                "pGVar2": "gpio_pin",
                "pPVar3": "port_pin",
                "iVar4": "pin_number"
            },
            "code": "int configure_gpio_pin_00001eea(gpio_t pin, gpio_mode_t mode)\n{\n  uint8_t pin_number = pin_num(pin);\n  GPIO_Type *gpio_pin = gpio(pin);\n  PORT_Type *port_pin = port(pin);\n  configure_gpio_pin_00001eea_port(pin, 0);\n  if (mode < GPIO_IN) {\n    gpio_pin->PDDR |= (1 << (pin_number & 0xff));\n  }\n  else {\n    gpio_pin->PDDR &= ~(1 << (pin_number & 0xff));\n  }\n  port_pin->PCR[pin_number] = (byte)mode & 0x23 | 0x100;\n  return 0;\n}",
            "called": [
                "port",
                "gpio",
                "gpio_init_port",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001eea",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "configure_gpio_pin_00001eea"
        },
        "FUN_000023a4": {
            "renaming": {
                "FUN_000023a4": "start_shell_000023a4",
                "line_buf": "input_buffer",
                "PTR_s_Welcome_to_RIOT__000023c4": "welcome_message",
                "shell_run": "shell_run",
                "(shell_command_t *)0x0": "(shell_command_t *)0x0",
                "startForkserver": "start_fork_server"
            },
            "code": "int start_shell_000023a4(void)\n{\n  char input_buffer[128];\n  start_fork_server(0);\n  puts(PTR_s_Welcome_to_RIOT__000023c4);\n  /* WARNING: Subroutine does not return */\n  shell_run((shell_command_t *)0x0, input_buffer, 0x80);\n}",
            "called": [
                "shell_run",
                "puts",
                "startForkserver"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023a4",
            "calling": [
                "main_trampoline"
            ],
            "imported": false,
            "current_name": "start_shell_000023a4"
        },
        "FUN_0000240c": {
            "renaming": {
                "FUN_0000240c": "remove_first_node_0000240c",
                "list": "head",
                "plVar1": "first_node"
            },
            "code": "list_node_t * remove_first_node_0000240c(list_node_t *head)\n{\n  list_node_t *first_node = head->next;\n  if (first_node != NULL) {\n    head->next = first_node->next;\n  }\n  return first_node;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000240c",
            "calling": [
                "mutex_unlock"
            ],
            "imported": false,
            "current_name": "remove_first_node_0000240c"
        },
        "FUN_00004280": {
            "renaming": {
                "FUN_00004280": "release_recursive_mutex_00004280",
                "PTR___lock___sfp_recursive_mutex_00004288": "sfp_recursive_mutex"
            },
            "code": "void release_recursive_mutex_00004280(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___sfp_recursive_mutex_00004288);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004280",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "release_recursive_mutex_00004280"
        },
        "FUN_00001448": {
            "renaming": {
                "FUN_00001448": "initialize_uart_ports_00001448",
                "uart": "uart_number",
                "PTR_uart_config_000014c0": "uart_config_ptr",
                "config_1": "uart_config_1",
                "config_2": "uart_config_2",
                "port_1": "uart_port_1",
                "port_2": "uart_port_2",
                "pin_1": "uart_pin_1",
                "pin_2": "uart_pin_2"
            },
            "code": "void initialize_uart_ports_00001448(uart_t uart) {\n  short config_1 = *(short *)(PTR_uart_config_000014c0 + uart * 0x20 + 8);\n  if (config_1 != -1) {\n    gpio_t port_1 = *(gpio_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 8);\n    uint32_t pin_1 = *(uint32_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 0xc);\n    gpio_init_port(port_1, pin_1);\n  }\n  short config_2 = *(short *)(PTR_uart_config_000014c0 + uart * 0x20 + 10);\n  if (config_2 != -1) {\n    gpio_t port_2 = *(gpio_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 10);\n    uint32_t pin_2 = *(uint32_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 0x10);\n    gpio_init_port(port_2, pin_2);\n  }\n  return;\n}",
            "called": [
                "gpio_init_port"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001448",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_ports_00001448"
        },
        "FUN_00001688": {
            "renaming": {
                "FUN_00001688": "handle_uart_interrupt_00001688"
            },
            "code": "void handle_uart_interrupt_00001688(void)\n{\n  irq_handler_uart(0);\n  return;\n}",
            "called": [
                "irq_handler_uart"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001688",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_00001688"
        },
        "FUN_00004042": {
            "renaming": {
                "FUN_00004042": "convert_string_to_long_00004042",
                "__nptr": "string_to_convert",
                "lVar1": "converted_long"
            },
            "code": "long convert_string_to_long_00004042(char* string_to_convert)\n{\n  long converted_long = strtol(string_to_convert, (char**)0x0, 10);\n  return converted_long;\n}",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004042",
            "calling": [
                "read",
                "write"
            ],
            "imported": false,
            "current_name": "convert_string_to_long_00004042"
        },
        "FUN_00000cf0": {
            "renaming": {
                "FUN_00000cf0": "is_IRQ_interrupts_enabled_00000cf0",
                "uVar2": "are_interrupts_enabled",
                "bVar1": "is_privileged_mode",
                "isCurrentModePrivileged": "is_Current_Mode_Privileged",
                "isIRQinterruptsEnabled": "is_IRQ_interrupts_enabled",
                "result": "N/A"
            },
            "code": "uint is_IRQ_interrupts_enabled_00000cf0(void)\n{\n  bool is_privileged_mode;\n  uint are_interrupts_enabled;\n\n  enable_IRQ_interrupts();\n  are_interrupts_enabled = 0;\n  is_privileged_mode = (bool)is_Current_Mode_Privileged();\n  if (is_privileged_mode) {\n    are_interrupts_enabled = is_IRQ_interrupts_enabled_00000cf0();\n  }\n  return are_interrupts_enabled;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cf0",
            "calling": [
                "cpu_switch_context_exit"
            ],
            "imported": false,
            "current_name": "is_IRQ_interrupts_enabled_00000cf0"
        },
        "FUN_00006cd4": {
            "renaming": {
                "FUN_00006cd4": "do_nothing_00006cd4"
            },
            "code": "\nvoid do_nothing_00006cd4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006cd4",
            "calling": [
                "__aeabi_ldivmod"
            ],
            "imported": false,
            "current_name": "do_nothing_00006cd4"
        },
        "FUN_00000f8c": {
            "renaming": {
                "FUN_00000f8c": "create_idle_and_main_threads_00000f8c",
                "PTR_idle_stack_00000fdc": "idle_stack_pointer",
                "PTR_main_stack_00000fe8": "main_stack_pointer",
                "DAT_00000fd8": "idle_thread_priority",
                "PTR_idle_name_00000fd4": "idle_thread_name",
                "DAT_00000fe4": "main_thread_priority",
                "PTR_main_name_00000fe0": "main_thread_name"
            },
            "code": "void create_idle_and_main_threads_00000f8c(void)\\n{\\n  irq_disable();\\n  thread_create(PTR_idle_stack_00000fdc, 0x100, \"\\x0f\", 0xc, DAT_00000fd8, (void *)0x0, *(char **)PTR_idle_name_00000fd4);\\n  thread_create(PTR_main_stack_00000fe8, 0x600, \"\\a\", 0xc, DAT_00000fe4, (void *)0x0, *(char **)PTR_main_name_00000fe0);\\n  cpu_switch_context_exit();\\n}",
            "called": [
                "cpu_switch_context_exit",
                "irq_disable",
                "thread_create"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f8c",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "create_idle_and_main_threads_00000f8c"
        },
        "FUN_00002894": {
            "renaming": {
                "FUN_00002894": "set_rtc_alarm_00002894",
                "alarm": "alarm_time",
                "cb": "callback",
                "arg": "callback_arg",
                "iVar1": "rtt_dat",
                "rtt": "RTC_Type",
                "control_reg": "uint *control_reg"
            },
            "code": "void set_rtc_alarm_00002894(uint32_t alarm_time, rtt_cb_t callback, void *callback_arg)\n{\n    int rtt_dat = DAT_000028e8;\n    uint *control_reg = (uint *)(rtt_dat + 0x1c);\n\n    // Clear the alarm enable bit\n    *control_reg &= 0xfffffffb;\n\n    // Set the alarm time\n    *(uint32_t *)(rtt_dat + 8) = alarm_time - 1;\n\n    // Set the callback function and argument\n    *(rtt_cb_t *)PTR_rtt_callback_000028ec = callback;\n    *(void **)(PTR_rtt_callback_000028ec + 4) = callback_arg;\n\n    // Enable the alarm and set the priority\n    *control_reg |= 4;\n    NVIC_SetPriority(RTC_IRQn, 10);\n    NVIC_EnableIRQ(RTC_IRQn);\n    return;\n}",
            "called": [
                "NVIC_SetPriority",
                "NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002894",
            "calling": [
                "rtc_set_alarm"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_00002894"
        },
        "FUN_00004158": {
            "renaming": {
                "FUN_00004158": "flush_if_not_fake_stdin_00004158",
                "param_1": "stream_id",
                "param_2": "stream",
                "uVar1": "result"
            },
            "code": "int flush_if_not_fake_stdin_00004158(int stream_id, char *stream) {\n  int result;\n  if (*(int *)(stream + 0x10) != 0) {\n    if ((stream_id != 0) && (*(int *)(stream_id + 0x18) == 0)) {\n      __sinit();\n    }\n    if (stream == PTR___sf_fake_stdin_000041c4) {\n      stream = *(char **)(stream_id + 4);\n    }\n    else if (stream == PTR___sf_fake_stdout_000041c8) {\n      stream = *(char **)(stream_id + 8);\n    }\n    else if (stream == PTR___sf_fake_stderr_000041cc) {\n      stream = *(char **)(stream_id + 0xc);\n    }\n    if (*(short *)(stream + 0xc) != 0) {\n      if ((-1 < *(int *)(stream + 100) << 0x1f) && (-1 < (int)*(short *)(stream + 0xc) << 0x16)) {\n        __retarget_lock_acquire_recursive(*(int *)(stream + 0x58));\n      }\n      result = __sflush_r(stream_id, stream);\n      if (*(int *)(stream + 100) << 0x1f < 0) {\n        return result;\n      }\n      if ((int)((uint)*(ushort *)(stream + 0xc) << 0x16) < 0) {\n        return result;\n      }\n      __retarget_lock_release_recursive(*(int *)(stream + 0x58));\n      return result;\n    }\n  }\n  return 0;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__sflush_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004158",
            "calling": [
                "__swbuf_r",
                "__srefill_r",
                "fflush"
            ],
            "imported": false,
            "current_name": "flush_if_not_fake_stdin_00004158"
        },
        "FUN_00002654": {
            "renaming": {
                "FUN_00002654": "set_rtc_alarm_00002654",
                "time": "alarm_time",
                "cb": "callback_function",
                "arg": "callback_arg",
                "alarm": "alarm_timestamp",
                "t": "alarm_time_t"
            },
            "code": "int set_rtc_alarm_00002654(tm *alarm_time, rtc_alarm_cb_t callback_function, void *callback_arg)\n{\n    uint32_t alarm_timestamp;\n    time_t alarm_time_t;\n\n    alarm_timestamp = mktime(alarm_time);\n    *(rtc_alarm_cb_t *)PTR_rtc_callback_00002688 = callback_function;\n    rtt_set_alarm(alarm_timestamp, DAT_0000268c, callback_arg);\n    return 0;\n}",
            "called": [
                "mktime",
                "rtt_set_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002654",
            "calling": [
                "_rtc_setalarm"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_00002654"
        },
        "FUN_00000aa8": {
            "renaming": {
                "FUN_00000aa8": "handle_hard_fault_00000aa8",
                "sp": "stack_pointer",
                "corrupted": "is_corrupted",
                "exc_return": "exception_return_address",
                "r4_to_r11_stack": "r4_to_r11_stack",
                "iVar1": "stack_size_left",
                "uVar2": "bus_fault_address_register",
                "uVar3": "memory_manage_fault_address_register",
                "uVar4": "configurable_fault_status_register",
                "uVar5": "hard_fault_status_register",
                "uVar6": "data_fault_status_register",
                "uVar7": "auxiliary_fault_status_register",
                "uVar8": "r0_register",
                "uVar9": "r1_register",
                "uVar10": "r2_register",
                "uVar11": "r3_register",
                "uVar12": "r12_register",
                "stack_left": "stack_size_left",
                "psr": "program_status_register",
                "lr": "link_register",
                "r12": "r12_register",
                "r3": "r3_register",
                "r2": "r2_register",
                "r1": "r1_register",
                "r0": "r0_register",
                "afsr": "auxiliary_fault_status_register",
                "dfsr": "data_fault_status_register",
                "hfsr": "hard_fault_status_register",
                "cfsr": "configurable_fault_status_register",
                "mmfar": "memory_manage_fault_address_register",
                "bfar": "bus_fault_address_register",
                "orig_sp": "original_stack_pointer",
                "pc": "program_counter",
                "PTR_isr_stack_00000c28": "ISR_STACK_POINTER",
                "DAT_00000c2c": "ISR_STACK_POINTER_LIMIT",
                "PTR_s__ISR_stack_overflowed_00000c30": "ISR_STACK_OVERFLOW_MESSAGE",
                "PTR_s_Stack_pointer_corrupted__reset_t_00000c34": "STACK_POINTER_CORRUPTED_MESSAGE",
                "PTR_s_FSR_FAR__00000c44": "FAULT_STATUS_AND_ADDRESS_MESSAGE",
                "PTR_s__CFSR__0x_08lx_00000c48": "CFSR_FORMAT_STRING",
                "PTR_s__HFSR__0x_08lx_00000c4c": "HFSR_FORMAT_STRING",
                "PTR_s__DFSR__0x_08lx_00000c50": "DFSR_FORMAT_STRING",
                "PTR_s__AFSR__0x_08lx_00000c54": "AFSR_FORMAT_STRING",
                "PTR_s__BFAR__0x_08lx_00000c5c": "BFAR_FORMAT_STRING",
                "PTR_s_MMFAR__0x_08lx_00000c64": "MMFAR_FORMAT_STRING",
                "PTR_DAT_00000c68": "EXCEPTION_RETURN_ADDRESS_MESSAGE",
                "PTR_s_EXC_RET__0x_08lx_00000c6c": "EXCEPTION_RETURN_ADDRESS_FORMAT_STRING",
                "PTR_s_Attempting_to_reconstruct_state_f_00000c70": "ATTEMPTING_TO_RECONSTRUCT_STATE_MESSAGE",
                "PTR_s_In_GDB__set__pc_0x_lx_frame_0_bt_00000c74": "IN_GDB_MESSAGE",
                "PTR_s__ISR_stack_overflowed_by_at_leas_00000c78": "ISR_STACK_OVERFLOWED_MESSAGE",
                "PANIC_HARD_FAULT": "PANIC_HARD_FAULT",
                "PTR_s_HARD_FAULT_HANDLER_00000c7c": "HARD_FAULT_HANDLER_MESSAGE",
                "software_bkpt": "software_breakpoint",
                "core_panic": "panic"
            },
            "code": "void handle_hard_fault_00000aa8(uint32_t *stack_pointer, uint32_t is_corrupted, uint32_t exception_return_address, uint32_t *r4_to_r11_stack)\n{\n    int stack_size_left;\n    uint32_t program_status_register;\n    uint32_t link_register;\n    uint32_t r12_register;\n    uint32_t r3_register;\n    uint32_t r2_register;\n    uint32_t r1_register;\n    uint32_t r0_register;\n    uint32_t auxiliary_fault_status_register;\n    uint32_t data_fault_status_register;\n    uint32_t hard_fault_status_register;\n    uint32_t configurable_fault_status_register;\n    uint32_t memory_manage_fault_address_register;\n    uint32_t bus_fault_address_register;\n    uint32_t *original_stack_pointer;\n    uint32_t program_counter;\n\n    program_counter = 0;\n    if (*(int *)PTR_isr_stack_00000c28 != DAT_00000c2c)\n    {\n        puts(PTR_s__ISR_stack_overflowed_00000c30);\n    }\n    if (is_corrupted == 0)\n    {\n        r0_register = *stack_pointer;\n        r1_register = stack_pointer[1];\n        r2_register = stack_pointer[2];\n        r3_register = stack_pointer[4];\n        r12_register = stack_pointer[5];\n        program_counter = stack_pointer[6];\n        puts(CONTEXT_BEFORE_HARD_FAULT_MESSAGE);\n        iprintf(\"r0: 0x%08lx r1: 0x%08lx r2: 0x%08lx\\n\", r0_register, r1_register, r2_register);\n        iprintf(\"r12: 0x%08lx lr: 0x%08lx pc: 0x%08lx\\n\", r12_register, r3_register, program_counter);\n    }\n    else\n    {\n        puts(PTR_s_Stack_pointer_corrupted__reset_t_00000c34);\n    }\n    puts(PTR_s_FSR_FAR__00000c44);\n    iprintf(\"CFSR: 0x%08lx\\n\", configurable_fault_status_register);\n    iprintf(\"HFSR: 0x%08lx\\n\", hard_fault_status_register);\n    iprintf(\"DFSR: 0x%08lx\\n\", data_fault_status_register);\n    iprintf(\"AFSR: 0x%08lx\\n\", auxiliary_fault_status_register);\n    if ((configurable_fault_status_register & BFAR_VALID_MASK) != 0)\n    {\n        iprintf(\"BFAR: 0x%08lx\\n\", bus_fault_address_register);\n    }\n    if ((configurable_fault_status_register & MMAR_VALID_MASK) != 0)\n    {\n        iprintf(\"MMFAR: 0x%08lx\\n\", memory_manage_fault_address_register);\n    }\n    puts(PTR_DAT_00000c68);\n    iprintf(\"exc return: 0x%08lx\\n\", exception_return_address);\n    if (is_corrupted == 0)\n    {\n        puts(PTR_s_Attempting_to_reconstruct_state_f_00000c70);\n        iprintf(\"In GDB, set $pc=0x%lx, frame=0x0, bt=0\\n\", program_counter);\n        stack_size_left = _stack_size_left(STACK_SIZE);\n        if (stack_size_left < 0)\n        {\n            iprintf(\"ISR stack overflowed by at least %d bytes\\n\", -stack_size_left);\n        }\n    }\n    software_bkpt(1);\n    core_panic(PANIC_HARD_FAULT, PTR_s_HARD_FAULT_HANDLER_00000c7c);\n}",
            "called": [
                "iprintf",
                "puts",
                "core_panic",
                "_stack_size_left"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000aa8",
            "calling": [
                "hard_fault_default"
            ],
            "imported": false,
            "current_name": "handle_hard_fault_00000aa8"
        },
        "FUN_00002538": {
            "renaming": {
                "FUN_00002538": "set_irq_priority_00002538",
                "IRQn": "irq",
                "priority": "priority",
                "*(char *)(((byte)IRQn & 0xf) + DAT_00002584 + 0x14)": "nvic_ipr[(uint32_t)irq >> 2] &= ~(0xff << (((uint32_t)irq & 3) * 8));\nnvic_ipr[(uint32_t)irq >> 2] |= (priority & 0xff) << (((uint32_t)irq & 3) * 8));",
                "DMA0_IRQn": "DMA0_IRQn",
                "*(char *)(IRQn + DAT_00002588 + 0x300)": "NVIC->IP[irq - 16] &= ~(0xff << 4);\nNVIC->IP[irq - 16] |= (priority & 0xff) << 4;",
                "return;": ""
            },
            "code": "void set_irq_priority_00002538(IRQn_Type irq, uint32_t priority)\n{\n  if (irq < DMA0_IRQn) {\n    uint32_t* nvic_ipr = (uint32_t*)((uint32_t)&NVIC->IPR[0]);\n    nvic_ipr[(uint32_t)irq >> 2] &= ~(0xff << (((uint32_t)irq & 3) * 8));\n    nvic_ipr[(uint32_t)irq >> 2] |= (priority & 0xff) << (((uint32_t)irq & 3) * 8);\n  }\n  else {\n    NVIC->IP[irq - 16] &= ~(0xff << 4);\n    NVIC->IP[irq - 16] |= (priority & 0xff) << 4;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002538",
            "calling": [
                "cortexm_init"
            ],
            "imported": false,
            "current_name": "set_irq_priority_00002538"
        },
        "FUN_00004c84": {
            "renaming": {
                "FUN_00004c84": "print_formatted_string_00004c84",
                "__format": "format_string",
                "uStack_c": "stack_0x10",
                "uStack_8": "stack_0xc",
                "uStack_4": "stack_0x8",
                "in_r1": "unused_variable",
                "in_r2": "unused_variable",
                "in_r3": "unused_variable",
                "iVar1": "impure_ptr",
                "pcVar2": "format"
            },
            "code": "int print_formatted_string_00004c84(char *format_string, ...)\n{\n  undefined4 stack_0x10;\n  undefined4 stack_0xc;\n  undefined4 stack_0x8;\n  int result;\n  int impure_ptr = *(int *)PTR__impure_ptr_00004cb0;\n  char *format = format_string;\n  stack_0x10 = 0;\n  stack_0xc = 0;\n  stack_0x8 = 0;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  result = _vfprintf_r(impure_ptr,*(undefined4 *)(impure_ptr + 8),format_string,&stack_0x10,format,&stack_0x10);\n  return result;\n}",
            "called": [
                "_vfprintf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004c84",
            "calling": [
                "phydat_dump",
                "_print_time",
                "ps",
                "write",
                "cpu_print_last_instruction",
                "list",
                "main_trampoline",
                "read",
                "print_help",
                "hard_fault_handler",
                "_rtc_handler",
                "core_panic",
                "_saul",
                "handle_input_line",
                "probe"
            ],
            "imported": false,
            "current_name": "print_formatted_string_00004c84"
        },
        "FUN_0000305c": {
            "renaming": {
                "FUN_0000305c": "write_data_to_device_0000305c",
                "argc": "argument_count",
                "argv": "arguments",
                "iVar1": "value",
                "data": "data",
                "dim": "dimension",
                "dev": "device",
                "num": "device_num",
                "i": "i",
                "PTR_s_usage___s__s__device_id___value_0_00003154": "usage_string",
                "PTR_s_error__undefined_device_given_00003158": "undefined_device_error",
                "PTR_s_Writing_to_device___i____s_0000315c": "writing_device_string",
                "PTR_s_error__device___i_is_not_writabl_00003160": "device_not_writable_error",
                "PTR_s_error__failure_to_FUN_0000305c_to_devic_00003164": "failure_to_write_data_error",
                "PTR_s_data_successfully_written_to_dev_00003168": "data_successfully_written_string"
            },
            "code": "void write_data_to_device_0000305c(int argument_count, char **arguments) {\n  int device_num, value, dimension, i;\n  phydat_t data;\n  saul_reg_t *device;\n\n  if (argument_count < 4) {\n    iprintf(PTR_s_usage___s__s__device_id___value_0_00003154, *arguments, arguments[1]);\n  }\n  else {\n    device_num = atoi(arguments[2]);\n    device = saul_reg_find_nth(device_num);\n    if (device == (saul_reg_t *)0x0) {\n      puts(PTR_s_error__undefined_device_given_00003158);\n    }\n    else {\n      memset(&data, 0, 8);\n      if (argument_count > 5) {\n        argument_count = 6;\n      }\n      dimension = argument_count - 3;\n      for (i = 0; i < dimension; i++) {\n        value = atoi(arguments[i + 3]);\n        data.val[i] = (int16_t)value;\n      }\n      iprintf(PTR_s_Writing_to_device___i____s_0000315c, device_num, device->name);\n      phydat_dump(&data, (uint8_t)dimension);\n      int result = saul_reg_write_data_to_device_0000305c(device, &data);\n      if (result < 1) {\n        if (result == -0x86) {\n          iprintf(PTR_s_error__device___i_is_not_writabl_00003160, device_num);\n        }\n        else {\n          iprintf(PTR_s_error__failure_to_write_data_to_device_0000305c_to_devic_00003164, device_num);\n        }\n      }\n      else {\n        iprintf(PTR_s_data_successfully_written_to_dev_00003168, device_num);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "phydat_dump",
                "saul_reg_find_nth",
                "atoi",
                "iprintf",
                "saul_reg_write",
                "memset",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000305c",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "write_data_to_device_0000305c"
        },
        "FUN_000012b4": {
            "renaming": {
                "FUN_000012b4": "add_one_to_tsrb_and_unlock_mutex_000012b4",
                "isrpipe": "input_isrpipe",
                "c": "input_character",
                "iVar1": "add_result",
                "res": "unused_variable"
            },
            "code": "int add_one_to_tsrb_and_unlock_mutex_000012b4(isrpipe_t *isrpipe, char character){\n  int add_result;\n  add_result = tsrb_add_one(&isrpipe->tsrb, character);\n  mutex_unlock(&isrpipe->mutex);\n  return add_result;\n}",
            "called": [
                "tsrb_add_one",
                "mutex_unlock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012b4",
            "calling": [],
            "imported": false,
            "current_name": "add_one_to_tsrb_and_unlock_mutex_000012b4"
        },
        "FUN_00005b34": {
            "renaming": {
                "FUN_00005b34": "FUNC_00005b34"
            },
            "code": "\ncode * FUNC_00005b34(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  bool bVar1;\n  byte bVar2;\n  undefined *puVar3;\n  int iVar4;\n  code *pcVar5;\n  void *pvVar6;\n  int iVar7;\n  undefined *__s;\n  uint uVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint **ppuVar11;\n  uint uVar12;\n  undefined *puVar13;\n  uint *puVar14;\n  undefined4 uVar15;\n  code *local_24;\n  \n  puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n  bVar2 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  puVar14 = param_2;\n  uVar15 = param_3;\n  local_24 = param_4;\n  if (0x78 < bVar2) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)param_2 + 0x42) = bVar2;\nLAB_00005bdc:\n    __s = (undefined *)((int)param_2 + 0x42);\n    uVar8 = 1;\nLAB_00005d28:\n    param_2[4] = uVar8;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (bVar2 < 99) {\n    if (bVar2 == 0) goto LAB_00005d06;\n    if (bVar2 == 0x58) {\n      *(undefined *)((int)param_2 + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(bVar2) {\n  case 99:\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    *(char *)((int)param_2 + 0x42) = (char)uVar8;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    uVar10 = *param_2;\n    puVar9 = *param_5;\n    if ((int)(uVar10 << 0x18) < 0) {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n    }\n    else {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n      if ((uVar10 & 0x40) != 0) {\n        uVar8 = (uint)(short)uVar8;\n      }\n    }\n    if ((int)uVar8 < 0) {\n      uVar8 = -uVar8;\n      *(undefined *)((int)param_2 + 0x43) = 0x2d;\n    }\n    uVar10 = 10;\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*param_5;\n    uVar10 = *param_2;\n    uVar8 = param_2[5];\n    *param_5 = (uint *)(ppuVar11 + 1);\n    puVar9 = *ppuVar11;\n    if (((int)(uVar10 << 0x18) < 0) || (-1 < (int)(uVar10 << 0x19))) {\n      *puVar9 = uVar8;\n    }\n    else {\n      *(short *)puVar9 = (short)uVar8;\n    }\nLAB_00005d06:\n    param_2[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    puVar9 = *param_5;\n    uVar8 = *param_2;\n    *param_5 = puVar9 + 1;\n    if (((int)(uVar8 << 0x18) < 0) || (-1 < (int)(uVar8 << 0x19))) {\n      uVar8 = *puVar9;\n    }\n    else {\n      uVar8 = (uint)*(ushort *)puVar9;\n    }\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    if (bVar2 == 0x6f) {\n      uVar10 = 8;\n    }\n    else {\n      uVar10 = 10;\n    }\n    break;\n  case 0x70:\n    *param_2 = *param_2 | 0x20;\n  case 0x78:\n    puVar3 = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)param_2 + 0x45) = 0x78;\nLAB_00005ca8:\n    uVar10 = *param_2;\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    if ((-1 < (int)(uVar10 << 0x18)) && ((int)(uVar10 << 0x19) < 0)) {\n      uVar8 = uVar8 & 0xffff;\n    }\n    if ((int)(uVar10 << 0x1f) < 0) {\n      *param_2 = uVar10 | 0x20;\n    }\n    if (uVar8 == 0) {\n      *param_2 = *param_2 & 0xffffffdf;\n    }\n    uVar10 = 0x10;\n    break;\n  case 0x73:\n    puVar9 = *param_5;\n    *param_5 = puVar9 + 1;\n    __s = (undefined *)*puVar9;\n    pvVar6 = memchr(__s,0,param_2[1]);\n    if (pvVar6 != (void *)0x0) {\n      param_2[1] = (int)pvVar6 - (int)__s;\n    }\n    uVar8 = param_2[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)param_2 + 0x43) = 0;\nLAB_00005c36:\n  uVar12 = param_2[1];\n  param_2[2] = uVar12;\n  if (-1 < (int)uVar12) {\n    *param_2 = *param_2 & 0xfffffffb;\n  }\n  puVar13 = __s;\n  if ((uVar8 != 0) || (uVar12 != 0)) {\n    do {\n      puVar13 = puVar13 + -1;\n      *puVar13 = puVar3[uVar8 - uVar10 * (uVar8 / uVar10)];\n      bVar1 = uVar10 <= uVar8;\n      uVar8 = uVar8 / uVar10;\n    } while (bVar1);\n  }\n  if (((uVar10 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4])) {\n    puVar13[-1] = 0x30;\n    puVar13 = puVar13 + -1;\n  }\n  param_2[4] = (int)__s - (int)puVar13;\n  __s = puVar13;\nLAB_00005c84:\n  iVar4 = _printf_common(param_1,param_2,&local_24,param_3,param_4,puVar14,uVar15);\n  if ((iVar4 == -1) || (iVar4 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar4 == -1)) {\nLAB_00005c98:\n    pcVar5 = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar4 = 0; iVar4 < (int)(param_2[3] - (int)local_24); iVar4 = iVar4 + 1) {\n        iVar7 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar7 == -1) goto LAB_00005c98;\n      }\n    }\n    pcVar5 = (code *)param_2[3];\n    if ((int)(code *)param_2[3] < (int)local_24) {\n      pcVar5 = local_24;\n    }\n  }\n  return pcVar5;\n}\n\n",
            "called": [
                "_printf_common",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005b34",
            "calling": [
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "FUNC_00005b34"
        },
        "FUN_0000058e": {
            "renaming": {
                "FUN_0000058e": "insert_node_at_end_0000058e",
                "list": "head",
                "new_node": "new_node",
                "list->next": "head->next",
                "new_node->next": "new_node->next",
                "list->next->next": "head->next->next"
            },
            "code": "void insert_node_at_end_0000058e(clist_node_t *head, clist_node_t *new_node)\n{\n  if (head->next == NULL) {\n    new_node->next = new_node;\n  }\n  else {\n    new_node->next = head->next;\n    head->next = new_node;\n  }\n  head->next = new_node;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000058e",
            "calling": [
                "sched_set_status"
            ],
            "imported": false,
            "current_name": "insert_node_at_end_0000058e"
        },
        "FUN_0000656c": {
            "renaming": {
                "FUN_0000656c": "FUNC_0000656c"
            },
            "code": "\nundefined4 FUNC_0000656c(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  void *pvVar1;\n  int iVar2;\n  undefined4 uVar3;\n  code *pcVar4;\n  uint uVar5;\n  byte *pbVar6;\n  uint uVar7;\n  undefined4 *puVar8;\n  uint *puVar9;\n  uint *puVar10;\n  uint *puVar11;\n  int unaff_r9;\n  int iVar12;\n  void *local_34 [4];\n  \n  local_34[0] = *(void **)PTR_PTR_DAT_00006744;\n  local_34[1] = (void *)*(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  local_34[2] = (void *)*(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  pcVar4 = DAT_0000674c;\n  if (param_2[6] != 3) {\n    pcVar4 = DAT_00006748;\n  }\n  uVar7 = param_2[2];\n  uVar5 = uVar7 - 1;\n  if (0x15c < uVar5) {\n    unaff_r9 = uVar7 - 0x15d;\n    uVar7 = 0x15d;\n  }\n  if (0x15c < uVar5) {\n    param_2[2] = uVar7;\n  }\n  puVar11 = param_2 + 7;\n  if (uVar5 < 0x15d) {\n    unaff_r9 = 0;\n  }\n  *param_2 = *param_2 | 0xd00;\n  iVar12 = 0;\n  puVar10 = puVar11;\n  do {\n    pvVar1 = memchr(local_34[iVar12],(uint)**param_3,2);\n    if (pvVar1 != (void *)0x0) {\n      if (iVar12 == 1) {\n        if (param_2[1] == 0) {\n          param_2[1] = 8;\n          *param_2 = *param_2 | 0x200;\n        }\n        uVar5 = *param_2 & 0xfffffaff;\nLAB_000065f4:\n        *param_2 = uVar5;\n      }\n      else if (iVar12 == 2) {\n        if ((*param_2 & 0x600) != 0x200) goto LAB_00006624;\n        param_2[1] = 0x10;\n        uVar5 = *param_2 | 0x100;\n        goto LAB_000065f4;\n      }\n      uVar5 = param_2[2];\n      param_2[2] = uVar5 - 1;\n      if (uVar5 != 0) {\n        pbVar6 = *param_3;\n        *param_3 = pbVar6 + 1;\n        puVar9 = (uint *)((int)puVar10 + 1);\n        *(byte *)puVar10 = *pbVar6;\n        pbVar6 = param_3[1];\n        param_3[1] = pbVar6 + -1;\n        puVar10 = puVar9;\n        if (((int)(pbVar6 + -1) < 1) &&\n           (iVar2 = (*(code *)param_2[0x60])(param_1,param_3), iVar2 != 0)) {\n          iVar12 = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iVar12 = iVar12 + 1;\n  } while (iVar12 != 3);\n  if (param_2[1] == 0) {\n    param_2[1] = 10;\n  }\n  __sccl(param_2[5],(int)PTR_DAT_00006750 - param_2[1]);\n  iVar12 = 0;\n  while( true ) {\n    puVar9 = puVar10;\n    if (param_2[2] == 0) break;\n    pbVar6 = *param_3;\n    uVar5 = (uint)*pbVar6;\n    if (*(char *)(param_2[5] + uVar5) == '\\0') break;\n    if ((uVar5 == 0x30) && ((int)(*param_2 << 0x14) < 0)) {\n      iVar12 = iVar12 + 1;\n      if (unaff_r9 != 0) {\n        unaff_r9 = unaff_r9 + -1;\n        param_2[2] = param_2[2] + 1;\n      }\n    }\n    else {\n      *param_2 = *param_2 & 0xfffff6ff;\n      puVar9 = (uint *)((int)puVar10 + 1);\n      *(byte *)puVar10 = *pbVar6;\n    }\n    pbVar6 = param_3[1];\n    param_3[1] = pbVar6 + -1;\n    if ((int)(pbVar6 + -1) < 1) {\n      iVar2 = (*(code *)param_2[0x60])(param_1,param_3);\n      if (iVar2 != 0) break;\n    }\n    else {\n      *param_3 = *param_3 + 1;\n    }\n    param_2[2] = param_2[2] - 1;\n    puVar10 = puVar9;\n  }\nLAB_000066ca:\n  if ((int)(*param_2 << 0x17) < 0) {\n    if (puVar11 < puVar9) {\n      (*(code *)param_2[0x5f])(param_1,*(byte *)((int)puVar9 + -1),param_3);\n      puVar9 = (uint *)((int)puVar9 + -1);\n    }\n    if (puVar9 == puVar11) {\n      return 1;\n    }\n  }\n  if ((*param_2 & 0x10) == 0) {\n    *(byte *)puVar9 = 0;\n    uVar3 = (*pcVar4)(param_1,puVar11,0,param_2[1]);\n    puVar8 = (undefined4 *)*param_4;\n    uVar5 = *param_2;\n    *param_4 = puVar8 + 1;\n    puVar8 = (undefined4 *)*puVar8;\n    if ((uVar5 & 0x20) == 0) {\n      if ((int)(uVar5 << 0x1f) < 0) {\n        *(short *)puVar8 = (short)uVar3;\n      }\n      else {\n        *puVar8 = uVar3;\n      }\n    }\n    else {\n      *puVar8 = uVar3;\n    }\n    param_2[3] = param_2[3] + 1;\n  }\n  param_2[4] = (uint)((int)puVar9 + param_2[4] + (iVar12 - (int)puVar11));\n  return 0;\n}\n\n",
            "called": [
                "__sccl",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000656c",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "FUNC_0000656c"
        },
        "FUN_000025f4": {
            "renaming": {
                "FUN_000025f4": "initialize_real_time_trace_000025f4"
            },
            "code": "void initialize_real_time_trace_000025f4()\n{\n  rtt_init();\n  return;\n}",
            "called": [
                "rtt_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000025f4",
            "calling": [
                "periph_init"
            ],
            "imported": false,
            "current_name": "initialize_real_time_trace_000025f4"
        },
        "FUN_00001ddc": {
            "renaming": {
                "FUN_00001ddc": "set_gpio_pin_00001ddc",
                "pin": "gpio_pin",
                "iVar1": "port_number",
                "port_num": "get_port_number",
                "bit_set32": "set_bit_in_register"
            },
            "code": "void set_gpio_pin_00001ddc(gpio_t pin)\n{\n  int port_number;\n  port_number = get_port_number(pin);\n  set_bit_in_register(DAT_00001e08, (char)port_number + '\\t');\n  return;\n}",
            "called": [
                "port_num",
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ddc",
            "calling": [
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_00001ddc"
        },
        "FUN_00002ecc": {
            "renaming": {
                "FUN_00002ecc": "read_sensor_data_00002ecc",
                "num": "sensor_num",
                "dev": "sensor_device",
                "iVar1": "read_result",
                "pcVar2": "driver_type",
                "pcVar3": "device_name",
                "res": "sensor_data",
                "dim": "data_dim",
                "PTR_s_error__failed_to_read_from_devic_00002f28": "error__failed_to_read_from_device",
                "PTR_s_Reading_from___i___s__s__00002f2c": "Reading_from_sensor"
            },
            "code": "void read_sensor_data_00002ecc(int sensor_num, saul_reg_t *sensor_device) {\n  int read_result;\n  char *device_name;\n  char *driver_type;\n  phydat_t sensor_data;\n  int data_dim;\n  read_result = saul_reg_read(sensor_device, &sensor_data);\n  if (read_result < 1) {\n    iprintf(PTR_s_error__failed_to_read_from_devic_00002f28, sensor_num);\n  }\n  else {\n    device_name = sensor_device->name;\n    driver_type = saul_class_to_str(sensor_device->driver->type);\n    iprintf(PTR_s_Reading_from___i___s__s__00002f2c, sensor_num, device_name, driver_type);\n    phydat_dump(&sensor_data, (uint8_t)read_result);\n  }\n  return;\n}",
            "called": [
                "phydat_dump",
                "saul_reg_read",
                "iprintf",
                "saul_class_to_str"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002ecc",
            "calling": [
                "read",
                "probe_all"
            ],
            "imported": false,
            "current_name": "read_sensor_data_00002ecc"
        },
        "FUN_00000d76": {
            "renaming": {
                "FUN_00000d76": "clear_bit_at_position_00000d76",
                "ptr": "memory_location",
                "bit": "bit_position",
                "puVar1": "bit_address"
            },
            "code": "void clear_bit_at_position_00000d76(uint32_t *memory_location, uint8_t bit_position)\n{\n    undefined4 *bit_address = (undefined4 *)bitband_addr(memory_location, (uint)bit_position);\n    *bit_address = 0;\n    return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d76",
            "calling": [
                "cpu_errata_fixes"
            ],
            "imported": false,
            "current_name": "clear_bit_at_position_00000d76"
        },
        "FUN_000057a8": {
            "renaming": {
                "FUN_000057a8": "write_char_to_buffer_000057a8",
                "param_1": "file_descriptor",
                "param_2": "character",
                "param_3": "buffer",
                "iVar1": "buffer_length",
                "puVar2": "next_char_position"
            },
            "code": "int write_char_to_buffer_000057a8(int file_descriptor, int character, int *buffer) {\n  int buffer_length = buffer[2] - 1;\n  buffer[2] = buffer_length;\n  if ((buffer_length < 0) && ((buffer_length < buffer[6]) || (character == 10))) {\n    int result = __swbuf_r();\n    return result;\n  }\n  char *next_char_position = (char *)*buffer;\n  *buffer = (int)next_char_position + 1;\n  *next_char_position = (char)character;\n  return character;\n}",
            "called": [
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057a8",
            "calling": [
                "__sfputs_r"
            ],
            "imported": false,
            "current_name": "write_char_to_buffer_000057a8"
        },
        "FUN_00004298": {
            "renaming": {
                "FUN_00004298": "release_recursive_mutex_00004298",
                "PTR___lock___sinit_recursive_mutex_000042a0": "sinit_recursive_mutex"
            },
            "code": "void release_recursive_mutex_00004298(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___sinit_recursive_mutex_000042a0);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004298",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "release_recursive_mutex_00004298"
        },
        "FUN_00001696": {
            "renaming": {
                "FUN_00001696": "calculate_memory_address_00001696",
                "ptr": "ptr",
                "bit": "bit",
                "uint": "uintptr_t",
                "shifted_ptr": "shifted_ptr",
                "calculated_address": "calculated_address"
            },
            "code": "void* calculate_memory_address_00001696(void* ptr, uintptr_t bit) {\n    uintptr_t shifted_ptr = ((uintptr_t)ptr & 0xf0000000) | (((uintptr_t)ptr & 0xfffff) << 5);\n    uintptr_t calculated_address = (bit * 4) + shifted_ptr + 0x2000000;\n    return (void*)calculated_address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001696",
            "calling": [
                "bit_set8",
                "bit_clear8",
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_memory_address_00001696"
        },
        "FUN_000008b8": {
            "renaming": {
                "FUN_000008b8": "count_used_words_000008b8",
                "num_used_words": "num_used_words",
                "ptr": "curr_ptr",
                "PTR_isr_stack_000008f4": "PTR_isr_stack_000008f4",
                "DAT_000008f8": "data",
                "PTR_heap_top_000008fc": "heap_top"
            },
            "code": "int count_used_words_000008b8(void)\n{\n  ptrdiff_t num_used_words;\n  uint32_t *curr_ptr;\n  uint32_t *PTR_heap_top_000008fc = PTR_PTR_heap_top_000008fc_000008fc;\n  uint32_t DAT_000008f8 = DAT_000008f8;\n  \n  for (curr_ptr = (uint32_t *)PTR_isr_stack_000008f4; (curr_ptr < PTR_heap_top_000008fc) && (*curr_ptr == DAT_000008f8); curr_ptr++) {\n  }\n  \n  return ((int)PTR_heap_top_000008fc - (int)curr_ptr) & ~0x3;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000008b8",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "count_used_words_000008b8"
        },
        "FUN_000024bc": {
            "renaming": {
                "FUN_000024bc": "mutex_lock_000024bc",
                "mutex": "mutex",
                "state": "irq_flags",
                "plVar2": "head",
                "process_priority": "priority",
                "irqstate": "irqstate",
                "__m____": "__m____",
                "next": "next",
                "process": "thread",
                "bVar1": "priority"
            },
            "code": "void mutex_lock_000024bc(mutex_t *mutex)\n{\n  byte priority;\n  uint irq_flags;\n  list_node_t *head;\n  thread_t *thread;\n  irq_flags = irq_disable();\n  if (mutex->queue.next == NULL) {\n    irq_restore(irq_flags);\n  }\n  else if (mutex->queue.next == (list_node_t *)0xffffffff) {\n    mutex->queue.next = NULL;\n    irq_restore(irq_flags);\n  }\n  else {\n    head = list_remove_head(&mutex->queue);\n    thread = (thread_t *)(head - 2);\n    sched_set_status(thread, THREAD_STATUS_BLOCKED);\n    if (mutex->queue.next == NULL) {\n      mutex->queue.next = (list_node_t *)0xffffffff;\n    }\n    priority = *(byte *)((int)&head[-1].next + 1);\n    irq_restore(irq_flags);\n    sched_switch((ushort)priority);\n  }\n}",
            "called": [
                "irq_disable",
                "irq_restore",
                "sched_set_status",
                "list_remove_head",
                "sched_switch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000024bc",
            "calling": [
                "isrpipe_write_one"
            ],
            "imported": false,
            "current_name": "mutex_lock_000024bc"
        },
        "FUN_00000490": {
            "renaming": {
                "FUN_00000490": "read_uart_data_00000490",
                "r": "reent",
                "fd": "file_descriptor",
                "buffer": "data_buffer",
                "count": "buffer_size",
                "iVar1": "read_count"
            },
            "code": "_ssize_t read_uart_data_00000490(_reent *reent, int file_descriptor, void *data_buffer, size_t buffer_size) {\n  int read_count = uart_stdio_read((char *)data_buffer, buffer_size);\n  return read_count;\n}",
            "called": [
                "uart_stdio_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000490",
            "calling": [
                "__sread"
            ],
            "imported": false,
            "current_name": "read_uart_data_00000490"
        },
        "FUN_0000091c": {
            "renaming": {
                "FUN_0000091c": "get_isr_stack_pointer_0000091c",
                "PTR_isr_stack_0000092c": "isr_stack_pointer"
            },
            "code": "void * get_isr_stack_pointer_0000091c(void)\n{\n  return PTR_isr_stack_0000092c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000091c",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "get_isr_stack_pointer_0000091c"
        },
        "FUN_00005d80": {
            "renaming": {
                "FUN_00005d80": "write_to_buffer_00005d80",
                "param_1": "file_descriptor",
                "param_2": "character",
                "param_3": "stream_buffer",
                "iVar1": "buffer_index",
                "puVar2": "buffer_ptr"
            },
            "code": "uint write_to_buffer_00005d80(int file_descriptor, uint character, undefined4 *stream_buffer)\n{\n  int buffer_index = 0;\n  undefined *buffer_ptr;\n  if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_buffer == (undefined4 *)PTR___sf_fake_stdin_00005e04) {\n    stream_buffer = *(undefined4 **)(file_descriptor + 4);\n  }\n  else if (stream_buffer == (undefined4 *)PTR___sf_fake_stdout_00005e08) {\n    stream_buffer = *(undefined4 **)(file_descriptor + 8);\n  }\n  else if (stream_buffer == (undefined4 *)PTR___sf_fake_stderr_00005e0c) {\n    stream_buffer = *(undefined4 **)(file_descriptor + 0xc);\n  }\n  if ((-1 < (int)(stream_buffer[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream_buffer + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(stream_buffer[0x16]);\n  }\n  buffer_index = stream_buffer[2] + -1;\n  stream_buffer[2] = buffer_index;\n  if ((buffer_index < 0) && ((buffer_index < (int)stream_buffer[6] || ((character & 0xff) == 10)))) {\n    character = __swbuf_r(file_descriptor, character, stream_buffer);\n  }\n  else {\n    buffer_ptr = (undefined *)*stream_buffer;\n    *stream_buffer = buffer_ptr + 1;\n    *buffer_ptr = (char)character;\n    character = character & 0xff;\n  }\n  if ((-1 < (int)(stream_buffer[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream_buffer + 3) << 0x16))) {\n    __retarget_lock_release_recursive(stream_buffer[0x16]);\n  }\n  return character;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__swbuf_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005d80",
            "calling": [
                "putchar"
            ],
            "imported": false,
            "current_name": "write_to_buffer_00005d80"
        },
        "FUN_00001f80": {
            "renaming": {
                "FUN_00001f80": "configure_pin_00001f80",
                "pin": "pin",
                "pcr": "configuration",
                "*pPVar1": "port",
                "iVar2": "pin_num",
                "pin_00": "pin_num",
                "uVar3": "previous_configuration",
                "isr_state": "not_used"
            },
            "code": "void configure_pin_00001f80(gpio_t pin, uint32_t configuration) {\n  PORT_Type *port;\n  int pin_num;\n  uint32_t previous_configuration;\n  \n  enable_clock(pin);\n  port = get_port(pin);\n  pin_num = get_pin_num(pin);\n  previous_configuration = port->PCR[pin_num];\n  port->PCR[pin_num] = configuration;\n  if ((previous_configuration & 0xf0000) != 0) {\n    int port_num = get_port_num(pin);\n    int pin_num = get_pin_num(pin);\n    clear_interrupt_context(port_num, pin_num);\n  }\n  return;\n}",
            "called": [
                "ctx_clear",
                "clk_en",
                "port",
                "port_num",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001f80",
            "calling": [
                "gpio_init",
                "uart_init_pins"
            ],
            "imported": false,
            "current_name": "configure_pin_00001f80"
        },
        "FUN_00000e64": {
            "renaming": {
                "FUN_00000e64": "initialize_cpu_and_gpio_pins_00000e64",
                "DAT_00000ed0": "thread_list_offset",
                "DAT_00000ed4": "gpio_register_base_address",
                "PTR_2056": "CPU_PIN_1",
                "PTR_511a": "CPU_PIN_2",
                "PTR_2055": "CPU_PIN_3"
            },
            "code": "void initialize_cpu_and_gpio_pins_00000e64(void)\n{\n    uint32_t *thread_list_ptr = thread_add_to_list + DAT_00000ed0 + 4;\n    *thread_list_ptr |= 0x200;\n    uint32_t *gpio_reg_ptr = DAT_00000ed4 + 0x48;\n    *gpio_reg_ptr &= 0xfefff8ff;\n    cpu_init();\n    gpio_init(PTR_2056, GPIO_OUT);\n    gpio_init(PTR_511a, GPIO_OUT);\n    gpio_init(PTR_2055, GPIO_OUT);\n    gpio_set(PTR_2056);\n    gpio_set(PTR_511a);\n    gpio_set(PTR_2055);\n    return;\n}",
            "called": [
                "gpio_set",
                "gpio_init",
                "cpu_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e64",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "initialize_cpu_and_gpio_pins_00000e64"
        },
        "FUN_000026e4": {
            "renaming": {
                "FUN_000026e4": "power_off_rtt_000026e4",
                "No parameter name": "No parameter name",
                "No variable name": "No variable name"
            },
            "code": "void power_off_rtt_000026e4(void)\n{\n  rtt_poweroff();\n  return;\n}",
            "called": [
                "rtt_poweroff"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026e4",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "power_off_rtt_000026e4"
        },
        "FUN_00000d44": {
            "renaming": {
                "FUN_00000d44": "calculate_memory_address_00000d44",
                "ptr": "ptr",
                "bit": "bit",
                "uint": "uintptr_t",
                "upper_bits": "upper_bits",
                "lower_bits": "lower_bits",
                "offset": "offset",
                "result": "result"
            },
            "code": "void * calculate_memory_address_00000d44(void *ptr, uintptr_t bit) {\n    uintptr_t ptr_uint = (uintptr_t) ptr;\n    uintptr_t upper_bits = ptr_uint & 0xf0000000;\n    uintptr_t lower_bits = ptr_uint & 0xfffff;\n    uintptr_t offset = (lower_bits << 5) + 0x2000000;\n    uintptr_t result = (bit * 4) + upper_bits + offset;\n    return (void *) result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d44",
            "calling": [
                "bit_clear32"
            ],
            "imported": false,
            "current_name": "calculate_memory_address_00000d44"
        },
        "FUN_00000698": {
            "renaming": {
                "FUN_00000698": "update_process_status_00000698",
                "process": "thread",
                "status": "new_status",
                "PTR_sched_runqueues_00000730": "sched_runqueues",
                "PTR_runqueue_bitcache_00000734": "runqueue_bitcache",
                "priority": "thread_priority"
            },
            "code": "void update_process_status_00000698(thread_t *process, uint new_status) {\n  if (new_status < 9) {\n    if ((process->status > 8) &&\n       (clist_lpop((clist_node_t *)(PTR_PTR_sched_runqueues_00000730_00000730 + (uint)process->priority * 4)),\n       *(int *)(PTR_PTR_sched_runqueues_00000730_00000730 + (uint)process->priority * 4) == 0)) {\n      *(uint *)PTR_PTR_runqueue_bitcache_00000734_00000734 &= ~(1 << process->priority);\n    }\n  }\n  else if (process->status < 9) {\n    clist_rpush((clist_node_t *)(PTR_PTR_sched_runqueues_00000730_00000730 + (uint)process->priority * 4), &process->rq_entry);\n    *(uint *)PTR_PTR_runqueue_bitcache_00000734_00000734 |= 1 << process->priority;\n  }\n  process->status = (uint8_t)new_status;\n  return;\n}",
            "called": [
                "clist_lpop",
                "clist_rpush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000698",
            "calling": [
                "thread_create",
                "mutex_unlock",
                "sched_task_exit",
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "update_process_status_00000698"
        },
        "FUN_00000cd0": {
            "renaming": {
                "FUN_00000cd0": "getIRQinterruptsEnabledStatus_00000cd0",
                "uVar2": "interruptsEnabled",
                "bVar1": "isPrivilegedMode",
                "mask": "mask",
                "result": "result"
            },
            "code": "uint32_t getIRQinterruptsEnabledStatus_00000cd0(void)\n{\n  bool isPrivilegedMode = (bool)isCurrentModePrivileged();\n  uint32_t interruptsEnabled = 0;\n  if (isPrivilegedMode) {\n    interruptsEnabled = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return interruptsEnabled;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cd0",
            "calling": [
                "kinetis_mcg_init",
                "pm_off",
                "_sbrk_r",
                "thread_create",
                "mutex_unlock",
                "sched_task_exit",
                "_mutex_lock",
                "core_panic",
                "kernel_init"
            ],
            "imported": false,
            "current_name": "getIRQinterruptsEnabledStatus_00000cd0"
        },
        "FUN_00000cc0": {
            "renaming": {
                "FUN_00000cc0": "panic_handler_dummy_00000cc0",
                "PANIC_DUMMY_HANDLER": "panic_type_dummy",
                "PTR_s_DUMMY_HANDLER_00000ccc": "dummy_handler"
            },
            "code": "void panic_handler_dummy_00000cc0(void)\n{\n    core_panic(PANIC_DUMMY_HANDLER, PTR_s_DUMMY_HANDLER_00000ccc);\n}\n",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cc0",
            "calling": [
                "dummy_handler"
            ],
            "imported": false,
            "current_name": "panic_handler_dummy_00000cc0"
        },
        "FUN_00002994": {
            "renaming": {
                "FUN_00002994": "check_RTC_and_call_callbacks_00002994",
                "iVar1": "data",
                "rtt": "RTC_Type *rtc"
            },
            "code": "void check_RTC_and_call_callbacks_00002994(void)\n{\n  int data = DAT_000029f8;\n  RTC_Type *rtc = (RTC_Type *) data;\n  if (((*(uint *)(data + 0x14) & 4) != 0) && (*(int *)PTR_rtt_callback_000029fc != 0)) {\n    *(uint *)(data + 0x1c) &= 0xfffffffb;\n    (**(code **)PTR_rtt_callback_000029fc)(*(undefined4 *)(PTR_rtt_callback_000029fc + 4));\n  }\n  if (((*(uint *)(data + 0x14) & 2) != 0) && (*(int *)(PTR_rtt_callback_000029fc + 8) != 0)) {\n    (**(code **)(PTR_rtt_callback_000029fc + 8))(*(undefined4 *)(PTR_rtt_callback_000029fc + 0xc));\n  }\n  cortexm_isr_end();\n  return;\n}",
            "called": [
                "cortexm_isr_end"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002994",
            "calling": [],
            "imported": false,
            "current_name": "check_RTC_and_call_callbacks_00002994"
        },
        "FUN_00000d2a": {
            "renaming": {
                "FUN_00000d2a": "get_exception_number_if_privileged_00000d2a",
                "uVar2": "exception_number",
                "bVar1": "is_privileged_mode"
            },
            "code": "uint32_t get_exception_number_if_privileged_00000d2a(void)\n{\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  uint32_t exception_number = 0;\n  if (is_privileged_mode)\n  {\n    exception_number = getCurrentExceptionNumber() & 0x1f;\n  }\n  return exception_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d2a",
            "calling": [
                "sched_switch"
            ],
            "imported": false,
            "current_name": "get_exception_number_if_privileged_00000d2a"
        },
        "FUN_00001ff6": {
            "renaming": {
                "FUN_00001ff6": "set_gpio_pin_high_00001ff6",
                "pin": "gpio_pin",
                "uVar1": "pin_number",
                "pGVar2": "gpio_instance",
                "pin_num": "get_pin_number",
                "gpio": "get_gpio_instance",
                "PSOR": "set_output_register"
            },
            "code": "void set_gpio_pin_high_00001ff6(gpio_t pin)\n{\n  uint32_t pin_number = get_pin_number(pin);\n  GPIO_Type *gpio_instance = get_gpio_instance(pin);\n  gpio_instance->PSOR = 1 << (pin_number & 0xff);\n  return;\n}",
            "called": [
                "gpio",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ff6",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_high_00001ff6"
        },
        "FUN_000013b8": {
            "renaming": {
                "FUN_000013b8": "initialize_uart_000013b8",
                "uart": "uart_id",
                "baudrate": "baud_rate",
                "rx_cb": "rx_callback",
                "arg": "callback_arg",
                "PTR_assert_crash_message_0000143c": "assert_crash_message",
                "PTR_config_00001440": "config_rx_callback",
                "PTR_uart_config_00001444": "uart_config",
                "FUN_000013b8_pins": "initialize_uart_pins",
                "FUN_000013b8_uart": "initialize_uart_peripheral",
                "iVar1": "return_value"
            },
            "code": "int initialize_uart_000013b8(uart_t uart, uint32_t baudrate, uart_rx_cb_t rx_callback, void *callback_arg) {\\n    int return_value;\\n    if (uart != 0) {\\n        core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_0000143c);\\n    }\\n    *(uart_rx_cb_t *)PTR_config_00001440 = rx_callback;\\n    *(void **)config_callback_arg = callback_arg;\\n    initialize_uart_000013b8_pins(0);\\n    bit_set32(*(uint32_t **)PTR_uart_config_00001444 + 0x18, PTR_uart_config_00001444[0x1c]);\\n    if (PTR_uart_config_00001444[0x1e] == \"\\0\") {\\n        initialize_uart_000013b8_peripheral(0, baudrate);\\n        return_value = 0;\\n    }\\n    else {\\n        return_value = -1;\\n    }\\n    return return_value;\\n}",
            "called": [
                "uart_init_pins",
                "uart_init_uart",
                "core_panic",
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000013b8",
            "calling": [
                "uart_stdio_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_000013b8"
        },
        "FUN_00000f80": {
            "renaming": {
                "FUN_00000f80": "infinite_loop_00000f80",
                "arg": "arg"
            },
            "code": "void * infinite_loop_00000f80(void *arg)\n{\n  do {\n    // Do nothing block with infinite loop\n  } while( true );\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f80",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_00000f80"
        },
        "FUN_00002a88": {
            "renaming": {
                "FUN_00002a88": "print_shell_commands_00002a88",
                "command_list": "shell_commands",
                "command_lists": "all_command_lists",
                "i": "index",
                "entry": "current_command",
                "PTR_s___20s__s_00002b04": "COMMAND_DESCRIPTION_FORMAT",
                "PTR_s_Command_00002b00": "COMMAND_NAME_LABEL",
                "PTR_s_Description_00002afc": "COMMAND_DESCRIPTION_LABEL",
                "PTR_s__________________________________00002b08": "SEPARATOR_LABEL",
                "shell_command_t": "ShellCommand",
                "uint": "uint32_t"
            },
            "code": "void print_shell_commands_00002a88(shell_command_t *command_list) {\n  shell_command_t *command_lists[2];\n  uint32_t index;\n  shell_command_t *current_command;\n\n  iprintf(\"%s\\t%s\\n\", \"Command\", \"Description\");\n  puts(\"------------------------------------------------\");\n  command_lists[0] = command_list;\n  command_lists[1] = (shell_command_t *)PTR__shell_command_list_00002b0c;\n  for (index = 0; index < 2; index++) {\n    current_command = command_lists[index];\n    if (current_command != (shell_command_t *)0x0) {\n      for (; current_command->name != (char *)0x0; current_command++) {\n        iprintf(\"%s\\t%s\\n\", current_command->name, current_command->desc);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "iprintf",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a88",
            "calling": [
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "print_shell_commands_00002a88"
        },
        "FUN_00002f30": {
            "renaming": {
                "FUN_00002f30": "print_saul_devices_00002f30",
                "dev": "current_device",
                "i": "device_count"
            },
            "code": "void print_saul_devices_00002f30(void)\n{\n  int device_count = 0;\n  saul_reg_t *current_device = *(saul_reg_t **)PTR_saul_reg_00002f6c;\n  while (current_device != (saul_reg_t *)0x0) {\n    probe(device_count, current_device);\n    puts(PTR_DAT_00002f70);\n    device_count++;\n    current_device = current_device->next;\n  }\n  return;\n}",
            "called": [
                "puts",
                "probe"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f30",
            "calling": [
                "read"
            ],
            "imported": false,
            "current_name": "print_saul_devices_00002f30"
        },
        "FUN_00001e44": {
            "renaming": {
                "FUN_00001e44": "set_pin_00001e44",
                "port": "port_number",
                "pin": "pin_number",
                "ctx": "context_value",
                "iVar1": "pin_index",
                "PTR_isr_map_00001ec0": "isr_map_ptr",
                "uint": "uint32_t",
                "mask": "mask"
            },
            "code": "void set_pin_00001e44(int port_number, int pin_number, int context_value) {\n  int pin_index = pin_number >> 3;\n  uint32_t* PTR_isr_map_00001ec0 = (uint32_t*)PTR_isr_map_00001ec0;\n  uint32_t* pin_map_ptr = PTR_isr_map_00001ec0 + (pin_index + port_number * 4) * 4;\n  uint32_t mask = 0xf << ((pin_number & 7U) << 2);\n  *pin_map_ptr = (*pin_map_ptr & ~mask) | (context_value << ((pin_number & 7U) << 2));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e44",
            "calling": [
                "ctx_clear"
            ],
            "imported": false,
            "current_name": "set_pin_00001e44"
        },
        "FUN_00001318": {
            "renaming": {
                "FUN_00001318": "set_interrupt_priority_00001318",
                "IRQn": "irq",
                "DAT_00001344": "interrupt_enable_register_address"
            },
            "code": "void set_interrupt_priority_00001318(IRQn_Type irq)\n{\n    int* interrupt_enable_register = (int*)(DAT_00001344 + ((uint)(int)irq >> 5) * 4);\n    int interrupt_enable_bit = 1 << (irq & 0x1fU);\n    *interrupt_enable_register = interrupt_enable_bit;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001318",
            "calling": [
                "uart_init_uart"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_00001318"
        },
        "FUN_00000900": {
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "pvVar1": "main_stack_pointer",
                "result": "N/A",
                "msp": "N/A"
            },
            "code": "void *get_main_stack_pointer_00000900(void)\n{\n  void *main_stack_pointer;\n  main_stack_pointer = (void *)getMainStackPointer();\n  return main_stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000900",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "get_main_stack_pointer_00000900"
        },
        "FUN_00004274": {
            "renaming": {
                "FUN_00004274": "acquire_recursive_mutex_00004274"
            },
            "code": "void acquire_recursive_mutex_00004274(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___sfp_recursive_mutex_0000427c);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004274",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "acquire_recursive_mutex_00004274"
        },
        "FUN_00002fe0": {
            "renaming": {
                "FUN_00002fe0": "parse_arguments_00002fe0",
                "argc": "argument_count",
                "argv": "arguments",
                "iVar1": "device_id",
                "dev_00": "device",
                "dev": "all_devices",
                "num": "i",
                "PTR_s_usage___s__s__device_id__all_00003050": "usage_message",
                "PTR_DAT_00003054": "DEVICE_ALL",
                "probe_all": "probe_all_devices",
                "PTR_s_error__undefined_device_id_given_00003058": "error_message",
                "probe": "probe_device"
            },
            "code": "void parse_arguments_00002fe0(int argument_count, char **arguments)\n{\n  int device_id;\n  saul_reg_t *device;\n  saul_reg_t *all_devices;\n  int i;\n  \n  if (argument_count < 3) {\n    iprintf(PTR_s_usage___s__s__device_id__all_00003050, *arguments, arguments[1]);\n  }\n  else {\n    if (strcmp(arguments[2], PTR_DAT_00003054) == 0) {\n      probe_all_devices();\n    }\n    else {\n      device_id = atoi(arguments[2]);\n      device = saul_reg_find_nth(device_id);\n      if (device == NULL) {\n        puts(PTR_s_error__undefined_device_id_given_00003058);\n      }\n      else {\n        probe_device(device_id, device);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "saul_reg_find_nth",
                "atoi",
                "iprintf",
                "probe_all",
                "strcmp",
                "puts",
                "probe"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002fe0",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "parse_arguments_00002fe0"
        },
        "FUN_00001dc0": {
            "renaming": {
                "FUN_00001dc0": "get_gpio_pin_number_00001dc0",
                "pin": "gpio_pin",
                "pin_number": "pin_number"
            },
            "code": "int get_gpio_pin_number_00001dc0(gpio_t gpio_pin)\n{\n  int pin_number = gpio_pin & 0x3f;\n  return pin_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001dc0",
            "calling": [
                "gpio_set",
                "gpio_init",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "get_gpio_pin_number_00001dc0"
        },
        "FUN_00000df4": {
            "renaming": {
                "FUN_00000df4": "initialize_uart_00000df4",
                "DAT_00000e10": "data_bits",
                "PTR_uart_stdio_isrpipe_00000e0c": "NULL",
                "uart_init": "uart_init",
                "0": "0",
                "0x1c200": "baud_rate"
            },
            "code": "void initialize_uart_00000df4(void)\n{\n    int baud_rate = 115200;\n    int clock_rate = 7372800;\n    int DAT_00000e10 = 8;\n    int parity = 0;\n    int stop_bits = 1;\n    uart_init(0, baud_rate, clock_rate, PTR_uart_stdio_isrpipe_00000e0c);\n    return;\n}",
            "called": [
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000df4",
            "calling": [
                "_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_00000df4"
        },
        "FUN_00002400": {
            "renaming": {
                "FUN_00002400": "do_nothing_00002400"
            },
            "code": "\nvoid do_nothing_00002400(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002400",
            "calling": [
                "main_trampoline"
            ],
            "imported": false,
            "current_name": "do_nothing_00002400"
        },
        "FUN_00002eb4": {
            "renaming": {
                "FUN_00002eb4": "print_status_00002eb4",
                "argc": "arg_count",
                "argv": "arg_values",
                "ps": "print_system_status"
            },
            "code": "int print_status_00002eb4(int arg_count, char **arg_values)\n{\n  print_system_status();\n  return 0;\n}",
            "called": [
                "ps"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002eb4",
            "calling": [],
            "imported": false,
            "current_name": "print_status_00002eb4"
        },
        "FUN_0000328c": {
            "renaming": {
                "FUN_0000328c": "convert_input_to_time_struct_0000328c",
                "argv": "input_args",
                "time": "time_struct",
                "lVar1": "input_value",
                "end": "end_ptr",
                "i": "input_short",
                "iVar2": "day_of_week"
            },
            "code": "int convert_input_to_time_struct_0000328c(char **input_args, tm *time_struct){\n  long input_value;\n  int day_of_week;\n  char *end_ptr;\n  short input_short;\n  \n  input_value = strtol(*input_args,&end_ptr,10);\n  input_short = (short)input_value;\n  time_struct->tm_year = input_short - 1900;\n  \n  input_value = strtol(end_ptr + 1,&end_ptr,10);\n  input_short = (short)input_value;\n  time_struct->tm_mon = input_short - 1;\n  \n  input_value = strtol(end_ptr + 1,&end_ptr,10);\n  input_short = (short)input_value;\n  time_struct->tm_mday = (int)input_short;\n  \n  input_value = strtol(input_args[1],&end_ptr,10);\n  input_short = (short)input_value;\n  time_struct->tm_hour = (int)input_short;\n  \n  input_value = strtol(end_ptr + 1,&end_ptr,10);\n  input_short = (short)input_value;\n  time_struct->tm_min = (int)input_short;\n  \n  input_value = strtol(end_ptr + 1,&end_ptr,10);\n  input_short = (short)input_value;\n  time_struct->tm_sec = (int)input_short;\n  \n  day_of_week = dow(time_struct->tm_year + 1900, time_struct->tm_mon + 1, time_struct->tm_mday);\n  time_struct->tm_wday = day_of_week;\n  time_struct->tm_isdst = -1;\n  return 0;\n}",
            "called": [
                "dow",
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000328c",
            "calling": [
                "_rtc_setalarm",
                "_rtc_settime"
            ],
            "imported": false,
            "current_name": "convert_input_to_time_struct_0000328c"
        },
        "FUN_000041f4": {
            "renaming": {
                "FUN_000041f4": "initialize_data_structure_000041f4",
                "param_1": "data_structure_ptr",
                "param_2": "value_1",
                "param_3": "value_2",
                "*param_1": "*data_structure_ptr",
                "param_1[1]": "*(data_structure_ptr + 1)",
                "param_1[2]": "*(data_structure_ptr + 2)",
                "*(undefined2 *)(param_1 + 3)": "*(data_structure_ptr + 3)",
                "param_1[4]": "*(data_structure_ptr + 4)",
                "param_1[5]": "*(data_structure_ptr + 5)",
                "param_1[6]": "*(data_structure_ptr + 6)",
                "param_1[7]": "*(data_structure_ptr + 7)",
                "param_1[8]": "*(data_structure_ptr + 8)",
                "param_1[9]": "*(data_structure_ptr + 9)",
                "param_1[10]": "*(data_structure_ptr + 10)",
                "param_1[11]": "*(data_structure_ptr + 11)",
                "param_1[12]": "*(data_structure_ptr + 12)"
            },
            "code": "void initialize_data_structure_000041f4(undefined4 *data_structure_ptr, undefined2 value_1, undefined2 value_2){\n  *data_structure_ptr = 0;\n  *(data_structure_ptr + 1) = 0;\n  *(data_structure_ptr + 2) = 0;\n  *(data_structure_ptr + 3) = value_1;\n  *(data_structure_ptr + 4) = 0;\n  *(data_structure_ptr + 5) = 0;\n  *(data_structure_ptr + 6) = 0;\n  *(data_structure_ptr + 7) = 0;\n  *(data_structure_ptr + 8) = data_structure_ptr;\n  *(data_structure_ptr + 9) = 0;\n  *(data_structure_ptr + 10) = 0;\n  *(data_structure_ptr + 11) = 0;\n  *(data_structure_ptr + 12) = value_2;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041f4",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_000041f4"
        },
        "FUN_0000316c": {
            "renaming": {
                "FUN_0000316c": "main_0000316c",
                "argc": "argument_count",
                "argv": "argument_values",
                "iVar1": "comparison_result",
                "list": "list_directory_contents",
                "PTR_DAT_000031d4": "file_read_pointer",
                "read": "read_from_file",
                "PTR_s_write_000031d8": "file_write_pointer",
                "write": "write_to_file",
                "iprintf": "print_usage_statement",
                "PTR_s_usage___s_read_write_000031dc": "usage_statement"
            },
            "code": "int main_0000316c(int argc, char **argv) {\n    int comparison_result;\n    if (argc < 2) {\n        list_directory_contents();\n    }\n    else {\n        comparison_result = strcmp(argv[1], PTR_DAT_000031d4);\n        if (comparison_result == 0) {\n            read_from_file(argc, argv);\n        }\n        else {\n            comparison_result = strcmp(argv[1], PTR_s_write_000031d8);\n            if (comparison_result == 0) {\n                write_to_file(argc, argv);\n            }\n            else {\n                print_PTR_s_usage___s_read_write_000031dc(PTR_s_usage___s_read_write_000031dc, *argv);\n            }\n        }\n    }\n    return 0;\n}",
            "called": [
                "read",
                "iprintf",
                "strcmp",
                "write",
                "list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000316c",
            "calling": [],
            "imported": false,
            "current_name": "main_0000316c"
        },
        "FUN_000026f0": {
            "renaming": {
                "FUN_000026f0": "execute_rtc_callback_000026f0",
                "arg": "argument",
                "PTR_rtc_callback_00002710": "rtc_callback_ptr",
                "int": "integer",
                "code": "function_pointer",
                "callback_func_ptr": "callback_function_pointer"
            },
            "code": "void execute_rtc_callback_000026f0(void *arg)\n{\n  int *PTR_rtc_callback_00002710 = (int *)PTR_rtc_callback_00002710;\n  if (*PTR_rtc_callback_00002710 != 0) {\n    code *callback_func_ptr = *(code **)PTR_rtc_callback_00002710;\n    (*callback_func_ptr)(arg);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026f0",
            "calling": [],
            "imported": false,
            "current_name": "execute_rtc_callback_000026f0"
        },
        "FUN_0000510c": {
            "renaming": {
                "FUN_0000510c": "FUNC_0000510c"
            },
            "code": "\nvoid FUNC_0000510c(undefined4 param_1)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  int iVar4;\n  char *pcVar5;\n  void *__ptr;\n  size_t sVar6;\n  char *pcVar7;\n  int iVar8;\n  int iVar9;\n  ulong uVar10;\n  char cVar11;\n  bool bVar12;\n  ushort *puVar13;\n  int *piVar14;\n  ushort *puVar15;\n  int *piVar16;\n  ushort local_3c;\n  ushort local_3a;\n  ushort local_38;\n  ushort local_36;\n  ushort local_34;\n  ushort local_32;\n  int local_30;\n  char *local_2c [2];\n  \n  iVar4 = __gettzinfo();\n  puVar1 = PTR_prev_tzenv_000053d8;\n  pcVar5 = (char *)_getenv_r(param_1,PTR_DAT_000053d4);\n  puVar2 = PTR_LAB_00007a5e_1_000053e0;\n  if (pcVar5 == (char *)0x0) {\n    *(undefined4 *)PTR__timezone_000053dc = 0;\n    *(undefined4 *)PTR__daylight_000053e4 = 0;\n    puVar3 = PTR__tzname_000053e8;\n    __ptr = *(void **)puVar1;\n    *(undefined **)PTR__tzname_000053e8 = puVar2;\n    *(undefined **)(puVar3 + 4) = puVar2;\n    free(__ptr);\n    *(undefined4 *)puVar1 = 0;\n  }\n  else if ((*(char **)puVar1 == (char *)0x0) ||\n          (iVar8 = strcmp(pcVar5,*(char **)puVar1), iVar8 != 0)) {\n    free(*(void **)puVar1);\n    sVar6 = strlen(pcVar5);\n    pcVar7 = (char *)_malloc_r(param_1,sVar6 + 1);\n    *(char **)puVar1 = pcVar7;\n    if (pcVar7 != (char *)0x0) {\n      strcpy(pcVar7,pcVar5);\n    }\n    if (*pcVar5 == ':') {\n      pcVar5 = pcVar5 + 1;\n    }\n    iVar8 = siscanf(pcVar5,PTR_s__10__0_9_____n_000053f0,PTR___tzname_std_000053ec,&local_30);\n    if (0 < iVar8) {\n      pcVar7 = pcVar5 + local_30;\n      if (pcVar5[local_30] == '-') {\n        pcVar7 = pcVar7 + 1;\n        iVar8 = -1;\n      }\n      else {\n        if (pcVar5[local_30] == '+') {\n          pcVar7 = pcVar7 + 1;\n        }\n        iVar8 = 1;\n      }\n      local_3a = 0;\n      local_38 = 0;\n      puVar13 = &local_3a;\n      piVar14 = &local_30;\n      puVar15 = &local_38;\n      piVar16 = &local_30;\n      iVar9 = siscanf(pcVar7,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                      &local_30,&local_38,&local_30);\n      puVar1 = PTR___tzname_dst_00005400;\n      if (0 < iVar9) {\n        *(uint *)(iVar4 + 0x28) =\n             ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar8;\n        puVar2 = PTR__tzname_000053e8;\n        *(undefined **)PTR__tzname_000053e8 = PTR___tzname_std_000053ec;\n        pcVar7 = pcVar7 + local_30;\n        iVar8 = siscanf(pcVar7,PTR_s__10__0_9_____n_000053f0,puVar1,&local_30,puVar13,piVar14,\n                        puVar15,piVar16);\n        if (iVar8 < 1) {\n          *(undefined4 *)(puVar2 + 4) = *(undefined4 *)puVar2;\n          *(undefined4 *)PTR__timezone_000053dc = *(undefined4 *)(iVar4 + 0x28);\n          *(undefined4 *)PTR__daylight_000053e4 = 0;\n        }\n        else {\n          *(undefined **)(puVar2 + 4) = puVar1;\n          pcVar5 = pcVar7 + local_30;\n          if (pcVar7[local_30] == '-') {\n            pcVar5 = pcVar5 + 1;\n            iVar8 = -1;\n          }\n          else {\n            if (pcVar7[local_30] == '+') {\n              pcVar5 = pcVar5 + 1;\n            }\n            iVar8 = 1;\n          }\n          local_3c = 0;\n          local_3a = 0;\n          local_38 = 0;\n          local_30 = 0;\n          iVar9 = siscanf(pcVar5,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                          &local_30,&local_38,&local_30);\n          if (iVar9 < 1) {\n            iVar8 = *(int *)(iVar4 + 0x28) + -0xe10;\n          }\n          else {\n            iVar8 = ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar8;\n          }\n          *(int *)(iVar4 + 0x50) = iVar8;\n          pcVar5 = pcVar5 + local_30;\n          bVar12 = false;\n          iVar8 = iVar4;\n          while( true ) {\n            if (*pcVar5 == ',') {\n              pcVar5 = pcVar5 + 1;\n            }\n            cVar11 = *pcVar5;\n            if (cVar11 == 'M') {\n              iVar9 = siscanf(pcVar5,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&local_36,&local_30,&local_34\n                              ,&local_30,&local_32,&local_30);\n              if (iVar9 != 3) {\n                return;\n              }\n              if (0xb < local_36 - 1) {\n                return;\n              }\n              if (4 < local_34 - 1) {\n                return;\n              }\n              if (6 < local_32) {\n                return;\n              }\n              *(uint *)(iVar8 + 0xc) = (uint)local_36;\n              *(uint *)(iVar8 + 0x10) = (uint)local_34;\n              *(undefined *)(iVar8 + 8) = 0x4d;\n              *(uint *)(iVar8 + 0x14) = (uint)local_32;\n              pcVar7 = pcVar5 + local_30;\n            }\n            else {\n              if (cVar11 == 'J') {\n                pcVar5 = pcVar5 + 1;\n              }\n              else {\n                cVar11 = 'D';\n              }\n              uVar10 = strtoul(pcVar5,local_2c,10);\n              local_32 = (ushort)uVar10;\n              pcVar7 = local_2c[0];\n              if (local_2c[0] == pcVar5) {\n                if (bVar12) {\n                  *(undefined *)(iVar4 + 0x30) = 0x4d;\n                  *(undefined4 *)(iVar4 + 0x34) = 0xb;\n                  *(undefined4 *)(iVar4 + 0x38) = 1;\n                  *(undefined4 *)(iVar4 + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(iVar4 + 8) = 0x4d;\n                  *(undefined4 *)(iVar4 + 0xc) = 3;\n                  *(undefined4 *)(iVar4 + 0x10) = 2;\n                  *(undefined4 *)(iVar4 + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(iVar8 + 8) = cVar11;\n                *(ulong *)(iVar8 + 0x14) = uVar10 & 0xffff;\n              }\n            }\n            local_3c = 2;\n            local_3a = 0;\n            local_38 = 0;\n            local_30 = 0;\n            if (*pcVar7 == '/') {\n              siscanf(pcVar7,PTR_DAT_000053fc,&local_3c,&local_30,&local_3a,&local_30,&local_38,\n                      &local_30);\n            }\n            *(uint *)(iVar8 + 0x18) =\n                 (uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38;\n            iVar8 = iVar8 + 0x28;\n            pcVar5 = pcVar7 + local_30;\n            if (bVar12) break;\n            bVar12 = true;\n          }\n          __tzcalc_limits(*(undefined4 *)(iVar4 + 4));\n          iVar8 = *(int *)(iVar4 + 0x28);\n          *(int *)PTR__timezone_000053dc = iVar8;\n          iVar8 = *(int *)(iVar4 + 0x50) - iVar8;\n          if (iVar8 != 0) {\n            iVar8 = 1;\n          }\n          *(int *)PTR__daylight_000053e4 = iVar8;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "__gettzinfo",
                "__tzcalc_limits",
                "_getenv_r",
                "strcpy",
                "siscanf",
                "strlen",
                "strcmp",
                "free",
                "_malloc_r",
                "strtoul"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000510c",
            "calling": [
                "_tzset_unlocked"
            ],
            "imported": false,
            "current_name": "FUNC_0000510c"
        },
        "FUN_000057d2": {
            "renaming": {
                "FUN_000057d2": "write_to_stream_000057d2",
                "param_1": "stream",
                "param_2": "status",
                "param_3": "buffer",
                "param_4": "size",
                "puVar2": "end_of_buffer",
                "iVar3": "count",
                "iVar1": "result"
            },
            "code": "int write_to_stream_000057d2(int stream, int status, char *buffer, int size) {\n  int count = 0;\n  char *end_of_buffer = buffer + size;\n  while (buffer != end_of_buffer) {\n    if (buffer == end_of_buffer) {\n      return 0;\n    }\n    int result = __sfputc_r(stream, *buffer, status, size, count);\n    size = result + 1;\n    buffer = buffer + 1;\n  }\n  return result;\n}",
            "called": [
                "__sfputc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057d2",
            "calling": [
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_000057d2"
        },
        "FUN_00000958": {
            "renaming": {
                "FUN_00000958": "runScheduler_00000958",
                "bVar1": "isPrivileged",
                "iVar2": "processStackPointer",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "unaff_r4": "unusedParam1",
                "unaff_r5": "unusedParam2",
                "unaff_r6": "unusedParam3",
                "unaff_r7": "unusedParam4",
                "unaff_r8": "unusedParam5",
                "unaff_r9": "unusedParam6",
                "unaff_r10": "unusedParam7",
                "unaff_r11": "unusedParam8",
                "in_lr": "unusedParam9",
                "ppcVar3": "nextThread",
                "activeThread": "activeThread"
            },
            "code": "void runScheduler_00000958(void)\n{\n  bool isPrivileged;\n  int processStackPointer;\n  code *jumpTable;\n  int **activeThread = (int **)PTR_sched_active_thread_00000970;\n  code **nextThread = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  \n  processStackPointer = getProcessStackPointer();\n  *(undefined4 *)(processStackPointer + -4) = unaff_r11;\n  *(undefined4 *)(processStackPointer + -8) = unaff_r10;\n  *(undefined4 *)(processStackPointer + -0xc) = unaff_r9;\n  *(undefined4 *)(processStackPointer + -0x10) = unaff_r8;\n  *(undefined4 *)(processStackPointer + -0x14) = unaff_r7;\n  *(undefined4 *)(processStackPointer + -0x18) = unaff_r6;\n  *(undefined4 *)(processStackPointer + -0x1c) = unaff_r5;\n  *(undefined4 *)(processStackPointer + -0x20) = unaff_r4;\n  *(undefined4 *)(processStackPointer + -0x24) = in_lr;\n  \n  *activeThread = (int *)(processStackPointer + -0x24);\n  isr_svc();\n  sched_run();\n  jumpTable = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  isPrivileged = (bool)isCurrentModePrivileged();\n  if (isPrivileged) {\n    setProcessStackPointer(nextThread);\n  }\n  (*jumpTable)(jumpTable, nextThread);\n  return;\n}",
            "called": [
                "isr_svc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000958",
            "calling": [],
            "imported": false,
            "current_name": "runScheduler_00000958"
        },
        "FUN_000056b8": {
            "renaming": {
                "FUN_000056b8": "check_file_type_000056b8",
                "param_1": "reent",
                "param_2": "file_descriptor",
                "param_3": "file_type",
                "param_4": "error_code",
                "iVar1": "status",
                "uVar2": "type",
                "sStack_68": "file_info"
            },
            "code": "int check_file_type_000056b8(_reent *reent, int file_descriptor, uint32_t *file_type, uint32_t *error_code)\n{\n    int status;\n    uint32_t type;\n    struct stat file_info;\n    \n    if (*(short *)(file_descriptor + 0xe) < 0 || (status = _fstat_r(reent, *(short *)(file_descriptor + 0xe), &file_info)) < 0)\n    {\n        *error_code = 0;\n        if ((int)((uint)*(ushort *)(file_descriptor + 0xc) << 0x18) < 0)\n        {\n            type = 0x40;\n        }\n    }\n    else\n    {\n        type = (uint32_t)((file_info.st_mode & 0xf000) == 0x2000);\n        *error_code = 0;\n    }\n    \n    *file_type = type;\n    return 0;\n}",
            "called": [
                "_fstat_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b8",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_file_type_000056b8"
        },
        "FUN_00001a18": {
            "renaming": {
                "FUN_00001a18": "enable_PLL_and_set_mode_to_4_00001a18",
                "DAT_00001a34": "PLL_control_register",
                "PTR_current_mode_00001a38": "current_mode"
            },
            "code": "void enable_PLL_and_set_mode_to_4_00001a18(void)\n{\n  set_bit_high(DAT_DAT_00001a34, BIT0);\n  disable_PLL_clock();\n  *PTR_current_mode_00001a38 = 4;\n  return;\n}",
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a18",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "enable_PLL_and_set_mode_to_4_00001a18"
        },
        "FUN_00000d9c": {
            "renaming": {
                "FUN_00000d9c": "clear_null_terminator_00000d9c",
                "DAT_00000dac": "data_pointer"
            },
            "code": "void clear_null_terminator_00000d9c(void)\n{\n  bit_clear32(DAT_00000dac, '\\0');\n  return;\n}",
            "called": [
                "bit_clear32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d9c",
            "calling": [
                "pre_startup"
            ],
            "imported": false,
            "current_name": "clear_null_terminator_00000d9c"
        },
        "FUN_00003ff4": {
            "renaming": {
                "FUN_00003ff4": "pad_string_00003ff4",
                "out": "output",
                "in_len": "input_length",
                "pad_len": "desired_length",
                "pad_char": "padding_character",
                "sVar1": "padded_length",
                "n": "unused"
            },
            "code": "size_t pad_string_00003ff4(char *output, size_t input_length, size_t desired_length, char padding_character) {\n    size_t padded_length = input_length;\n    if ((input_length < desired_length) && (padded_length = desired_length, output != (char *)0x0)) {\n      memmove(output + (desired_length - input_length), output, input_length);\n      memset(output, (uint)(byte)padding_character, desired_length - input_length);\n    }\n    return padded_length;\n  }",
            "called": [
                "memset",
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ff4",
            "calling": [
                "fmt_s32_dfp"
            ],
            "imported": false,
            "current_name": "pad_string_00003ff4"
        },
        "FUN_00004634": {
            "renaming": {
                "FUN_00004634": "FUNC_00004634"
            },
            "code": "\nvoid FUNC_00004634(uint *param_1,uint param_2,undefined4 param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  bool bVar6;\n  uint *local_20;\n  uint local_1c;\n  undefined4 uStack_18;\n  \n  local_20 = param_1;\n  local_1c = param_2;\n  uStack_18 = param_3;\n  if (0x3b < *param_1) {\n    div((int)&local_20,*param_1);\n    uVar3 = param_1[1] + (int)local_20;\n    param_1[1] = uVar3;\n    if ((int)local_1c < 0) {\n      uVar3 = uVar3 - 1;\n      *param_1 = local_1c + 0x3c;\n    }\n    else {\n      *param_1 = local_1c;\n    }\n    if ((int)local_1c < 0) {\n      param_1[1] = uVar3;\n    }\n  }\n  if (0x3b < param_1[1]) {\n    div((int)&local_20,param_1[1]);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[2] + (int)local_20;\n    param_1[2] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x3c;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar4;\n    }\n  }\n  if (0x17 < param_1[2]) {\n    div((int)&local_20,param_1[2]);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[3] + (int)local_20;\n    param_1[3] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x18;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[3] = uVar4;\n    }\n  }\n  if (0xb < param_1[4]) {\n    div((int)&local_20,param_1[4]);\n    bVar6 = (int)local_1c < 0;\n    uVar3 = param_1[5] + (int)local_20;\n    param_1[5] = uVar3;\n    if (bVar6) {\n      local_1c = local_1c + 0xc;\n      uVar3 = uVar3 - 1;\n    }\n    if (!bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[5] = uVar3;\n    }\n  }\n  puVar1 = PTR_DAYS_IN_MONTH_000047e0;\n  uVar3 = param_1[5];\n  if ((uVar3 & 3) == 0) {\n    if (uVar3 == (uVar3 / 100) * 100) {\n      if ((uVar3 + 0x76c) % 400 == 0) {\n        iVar5 = 0x1d;\n      }\n      else {\n        iVar5 = 0x1c;\n      }\n    }\n    else {\n      iVar5 = 0x1d;\n    }\n  }\n  else {\n    iVar5 = 0x1c;\n  }\n  if ((int)param_1[3] < 1) {\n    while ((int)param_1[3] < 1) {\n      uVar3 = param_1[4];\n      param_1[4] = uVar3 - 1;\n      if (uVar3 - 1 == 0xffffffff) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 - 1;\n        param_1[4] = 0xb;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 == (uVar3 / 100) * 100) {\n            if ((uVar4 + 0x76b) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n      iVar2 = iVar5;\n      if (param_1[4] != 1) {\n        iVar2 = *(int *)(puVar1 + param_1[4] * 4);\n      }\n      param_1[3] = iVar2 + param_1[3];\n    }\n  }\n  else {\n    while( true ) {\n      uVar3 = param_1[4];\n      iVar2 = iVar5;\n      if (uVar3 != 1) {\n        iVar2 = *(int *)(puVar1 + uVar3 * 4);\n      }\n      if ((int)param_1[3] <= iVar2) break;\n      param_1[3] = param_1[3] - iVar2;\n      param_1[4] = uVar3 + 1;\n      if (uVar3 + 1 == 0xc) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 + 1;\n        param_1[4] = 0;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 % 100 == 0) {\n            if ((uVar4 + 0x76d) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "div"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00004634",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "FUNC_00004634"
        },
        "FUN_00001d5e": {
            "renaming": {
                "FUN_00001d5e": "get_port_from_gpio_00001d5e",
                "pin": "gpio_pin",
                "PTR_": "No renaming necessary",
                "DAT_": "No renaming necessary",
                "PORT_Type": "No renaming necessary",
                "port_address": "No renaming necessary",
                "GPIO_PIN_MASK": "No renaming necessary",
                "PORT_BASE_ADDRESS": "No renaming necessary"
            },
            "code": "PORT_Type * get_port_from_gpio_00001d5e(gpio_t gpio_pin)\n{\n    const uint32_t PORT_BASE_ADDRESS = 0x40048000;\n    const uint32_t GPIO_PIN_MASK = 0x7000;\n    uint32_t port_address = (uint32_t)gpio_pin & GPIO_PIN_MASK;\n    return (PORT_Type *)(port_address | PORT_BASE_ADDRESS);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d5e",
            "calling": [
                "gpio_init",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "get_port_from_gpio_00001d5e"
        },
        "FUN_0000191c": {
            "renaming": {
                "FUN_0000191c": "enable_oscillator_and_set_fll_factor_0000191c",
                "DAT_00001958": "data_register",
                "PTR_current_mode_0000195c": "current_mode_pointer"
            },
            "code": "void enable_oscillator_and_set_fll_factor_0000191c(void)\n{\n  kinetis_mcg_enable_osc();\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1920);\n  *DAT_00001958 = *DAT_00001958 & 0x3b;\n  do {\n  } while ((DAT_00001958[6] & 0xc) != 0);\n  *PTR_current_mode_0000195c = 1;\n  return;\n}",
            "called": [
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_enable_osc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000191c",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "enable_oscillator_and_set_fll_factor_0000191c"
        },
        "FUN_000050f4": {
            "renaming": {
                "FUN_000050f4": "release_timezone_mutex_000050f4",
                "PTR___lock___tz_mutex_000050fc": "timezone_mutex"
            },
            "code": "void release_timezone_mutex_000050f4(void)\n{\n  __retarget_lock_release(PTR___lock___tz_mutex_000050fc);\n  return;\n}",
            "called": [
                "__retarget_lock_release"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050f4",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "release_timezone_mutex_000050f4"
        },
        "FUN_00000c80": {
            "renaming": {
                "FUN_00000c80": "handle_memory_management_exception_00000c80",
                "PTR_s_MEM_MANAGE_HANDLER_00000c8c": "mem_manage_handler"
            },
            "code": "void handle_memory_management_exception_00000c80(void)\n{\n    core_panic(PANIC_MEM_MANAGE, PTR_s_MEM_MANAGE_HANDLER_00000c8c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000c80",
            "calling": [],
            "imported": false,
            "current_name": "handle_memory_management_exception_00000c80"
        },
        "FUN_00000a40": {
            "renaming": {
                "FUN_00000a40": "calculateRequiredStackSpace_00000a40",
                "required": "requiredSpace",
                "auStack_18": "stackSpace",
                "sp": "stackPointer"
            },
            "code": "int calculateRequiredStackSpace_00000a40(uint32_t requiredSpace) {\n  undefined stackSpace [12];\n  uint32_t *stackPointer;\n  return (int)(stackSpace + (-(int)PTR_isr_stack_00000a60 - requiredSpace));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a40",
            "calling": [
                "hard_fault_handler"
            ],
            "imported": false,
            "current_name": "calculateRequiredStackSpace_00000a40"
        },
        "FUN_00005a58": {
            "renaming": {
                "FUN_00005a58": "count_chars_00005a58",
                "param_1": "input_param",
                "param_2": "input_array",
                "param_3": "output_array",
                "param_4": "output_len",
                "param_5": "callback_func",
                "uVar2": "result",
                "uVar3": "char_count",
                "uVar4": "j",
                "bVar5": "is_four",
                "iVar1": "callback_result",
                "max_len": "max_length",
                "*param_3": "*output_array",
                "*param_2": "*input_array",
                "LAB_00005afc": "error_handling"
            },
            "code": "undefined4 count_chars_00005a58(uint32_t input_param, uint32_t *input_array, uint32_t *output_array, uint32_t output_len, code *callback_func)\n{\n  int i;\n  undefined4 result;\n  uint32_t max_len = input_array[4] < input_array[2] ? input_array[2] : input_array[4];\n  *output_array = max_len;\n  if (*(char *)((int)input_array + 0x43) != '\\0') {\n    *output_array = max_len + 1;\n  }\n  if ((int)(*input_array << 0x1a) < 0) {\n    *output_array = *output_array + 2;\n  }\n  uint32_t char_count = *input_array & 6;\n  if (char_count == 0) {\n    for (; (int)char_count < (int)(input_array[3] - *output_array); char_count++) {\n      int callback_result = (*callback_func)(input_param, output_len, (int)input_array + 0x19, 1);\n      if (callback_result == -1) goto LAB_00005afc;\n    }\n  }\n  char_count = (uint32_t)*(byte *)((int)input_array + 0x43);\n  if (char_count != 0) {\n    char_count = 1;\n  }\n  if ((int)(*input_array << 0x1a) < 0) {\n    *(undefined *)((int)input_array + char_count + 0x43) = 0x30;\n    *(undefined *)((int)input_array + char_count + 0x44) = *(undefined *)((int)input_array + 0x45);\n    char_count += 2;\n  }\n  int callback_result = (*callback_func)(input_param, output_len, (int)input_array + 0x43, char_count);\n  if (callback_result == -1) {\n    result = 0xffffffff;\n  }\n  else {\n    uint32_t remaining_len = input_array[3];\n    bool is_four = (*input_array & 6) == 4;\n    if (is_four) {\n      remaining_len = remaining_len - *output_array;\n    }\n    if (is_four) {\n      remaining_len &= ~((int)remaining_len >> 0x1f);\n    }\n    else {\n      remaining_len = 0;\n    }\n    if (input_array[4] < input_array[2]) {\n      remaining_len += (input_array[2] - input_array[4]);\n    }\n    for (uint32_t j = 0; remaining_len != j; j++) {\n      int callback_result = (*callback_func)(input_param, output_len, (int)input_array + 0x1a, 1);\n      if (callback_result == -1) goto LAB_00005afc;\n    }\n    result = 0;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005a58",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "count_chars_00005a58"
        },
        "FUN_000056b0": {
            "renaming": {
                "FUN_000056b0": "getTimeZoneInfo_000056b0",
                "PTR_tzinfo_000056b4": "timeZoneInfo"
            },
            "code": "const char* getTimeZoneInfo_000056b0(void)\n{\n  return PTR_tzinfo_000056b4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b0",
            "calling": [
                "mktime",
                "__tzcalc_limits",
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "getTimeZoneInfo_000056b0"
        },
        "FUN_00003d24": {
            "renaming": {
                "FUN_00003d24": "get_saul_reg_at_position_00003d24",
                "pos": "position",
                "i": "current_position",
                "tmp": "current_saul_reg"
            },
            "code": "saul_reg_t* get_saul_reg_at_position_00003d24(int position)\n{\n  int current_position = 0;\n  saul_reg_t* current_saul_reg = *(saul_reg_t**)PTR_saul_reg_00003d60;\n  \n  while (current_position < position && current_saul_reg != (saul_reg_t*)0x0)\n  {\n    current_saul_reg = current_saul_reg->next;\n    current_position++;\n  }\n  \n  return current_saul_reg;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d24",
            "calling": [
                "read",
                "write"
            ],
            "imported": false,
            "current_name": "get_saul_reg_at_position_00003d24"
        },
        "FUN_000060cc": {
            "renaming": {
                "FUN_000060cc": "allocate_memory_000060cc",
                "param_1": "size",
                "param_2": "ptr1",
                "param_3": "ptr2",
                "param_4": "size2",
                "pvVar1": "new_ptr",
                "pvVar2": "usable_size"
            },
            "code": "void* allocate_memory_000060cc(size_t size, void* ptr1, void* ptr2, size_t size2)\n{\n    void* new_ptr;\n    void* usable_size;\n\n    if (ptr1 != NULL) {\n        if (ptr2 == NULL) {\n            free(ptr1);\n            new_ptr = ptr2;\n        }\n        else {\n            usable_size = (void*) malloc_usable_size(ptr1);\n            new_ptr = ptr2;\n            if ((usable_size < ptr2) && (new_ptr = (void*) malloc(size), new_ptr != NULL)) {\n                memcpy(new_ptr, ptr1, size2);\n                free(ptr1);\n            }\n        }\n        return new_ptr;\n    }\n    new_ptr = (void*) malloc(size2);\n    return new_ptr;\n}",
            "called": [
                "_free_r",
                "_malloc_r",
                "memcpy",
                "_malloc_usable_size_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060cc",
            "calling": [
                "__submore"
            ],
            "imported": false,
            "current_name": "allocate_memory_000060cc"
        },
        "FUN_000022be": {
            "renaming": {
                "FUN_000022be": "write_to_ring_buffer_000022be",
                "rb": "ring_buffer",
                "c": "data",
                "uVar1": "current_writes",
                "buf": "buffer",
                "size": "buffer_size"
            },
            "code": "void write_to_ring_buffer_000022be(tsrb_t *ring_buffer, char data) \n{\n    uint32_t current_writes = ring_buffer->writes;\n    ring_buffer->writes = current_writes + 1;\n    uint32_t buffer_index = current_writes & (ring_buffer->size - 1);\n    ring_buffer->buf[buffer_index] = data;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022be",
            "calling": [
                "tsrb_add_one"
            ],
            "imported": false,
            "current_name": "write_to_ring_buffer_000022be"
        },
        "FUN_00003dc4": {
            "renaming": {
                "FUN_00003dc4": "calculate_num_digits_00003dc4",
                "out": "out_str",
                "val": "input_num",
                "local_20": "remainder",
                "ptr": "digit_ptr",
                "tmp": "divisor",
                "len": "num_digits"
            },
            "code": "size_t calculate_num_digits_00003dc4(char *out, uint32_t val)\n{\n  uint32_t divisor = 1000000000;\n  char *digit_ptr;\n  uint32_t remainder;\n  size_t num_digits = 1;\n  if (DAT_00003e50 < val) {\n    num_digits = 10;\n  }\n  else {\n    while (divisor > val) {\n      divisor /= 10;\n    }\n    while (divisor != 0) {\n      num_digits++;\n      remainder = val % divisor;\n      val = val / divisor;\n      *digit_ptr = (char)val + '0';\n      digit_ptr++;\n      val = remainder;\n      divisor /= 10;\n    }\n  }\n  return num_digits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003dc4",
            "calling": [
                "fmt_s32_dec"
            ],
            "imported": false,
            "current_name": "calculate_num_digits_00003dc4"
        },
        "FUN_00002108": {
            "renaming": {
                "FUN_00002108": "handle_irq_00002108",
                "DAT_00002118": "interrupt_number"
            },
            "code": "void handle_irq_00002108(void)\n{\n  irq_handler(DAT_00002118, 4);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002108",
            "calling": [],
            "imported": false,
            "current_name": "handle_irq_00002108"
        },
        "FUN_00000c90": {
            "renaming": {
                "FUN_00000c90": "handle_bus_fault_00000c90",
                "PANIC_BUS_FAULT": "panic_type",
                "PTR_s_BUS_FAULT_HANDLER_00000c9c": "bus_fault_handler"
            },
            "code": "void handle_bus_fault_00000c90(void)\n{\n    core_panic(PANIC_BUS_FAULT, PTR_s_BUS_FAULT_HANDLER_00000c9c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000c90",
            "calling": [],
            "imported": false,
            "current_name": "handle_bus_fault_00000c90"
        },
        "FUN_00001d80": {
            "renaming": {
                "FUN_00001d80": "get_gpio_type_from_pin_number_00001d80",
                "FUN_00001d80_t": "pin_number",
                "pin": "pin_number",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "GPIO_Type* get_gpio_type_from_pin_number_00001d80(uint32_t pin_number) {\n    uint32_t masked_pin_number = pin_number & 0x1c0;\n    uint32_t base_address = 0x400ff000;\n    return (GPIO_Type*)(masked_pin_number | base_address);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d80",
            "calling": [
                "gpio_set",
                "gpio_init"
            ],
            "imported": false,
            "current_name": "get_gpio_type_from_pin_number_00001d80"
        },
        "FUN_000033c0": {
            "renaming": {
                "FUN_000033c0": "get_rtc_alarm_status_000033c0",
                "iVar1": "alarm_status",
                "t": "current_time",
                "_print_time": "print_current_time"
            },
            "code": "int get_rtc_alarm_status_000033c0(void)\n{\n  int alarm_status;\n  tm current_time;\n  alarm_status = rtc_get_alarm(&current_time);\n  if (alarm_status != 0) {\n    puts(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    print_current_time(&current_time);\n  }\n  return (uint)(alarm_status != 0);\n}",
            "called": [
                "rtc_get_alarm",
                "_print_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "get_rtc_alarm_status_000033c0"
        },
        "FUN_00002b10": {
            "renaming": {
                "FUN_00002b10": "parse_shell_command_00002b10",
                "command_list": "command_list",
                "line": "command_line",
                "iVar1": "cmd_not_found",
                "pcVar2": "next_char",
                "local_48": "command_line_copy",
                "local_44": "current_command",
                "handler": "command_handler",
                "argv": "args",
                "local_34": "num_args",
                "quote_char": "quote_char",
                "d": "d",
                "c": "c",
                "arg": "arg",
                "i": "i",
                "contains_esc_seq": "contains_escape_sequence",
                "argc": "num_args",
                "pos": "current_char",
                "PTR_INCORRECT_QUOTING_00002d88": "PTR_INCORRECT_QUOTING"
            },
            "code": "void parse_shell_command_00002b10(shell_command_t *command_list, char *command_line) {\\n    shell_command_t *current_command = command_list;\\n    char *current_char = command_line;\\n    uint32_t num_args = 0;\\n    uint32_t contains_escape_sequence = 0;\\n    char *arg_pos;\\n    char **args;\\n    uint32_t i;\\n    shell_command_handler_t command_handler;\\n    char quote_char;\\n    char *d;\\n    char *c;\\n    char **arg;\\n    int cmd_not_found;\\n    \\n    while (true) {\\n        if (*current_char > 0x20) {\\n            if ((*current_char == \"\\\"\") || (*current_char == \"\\\"\")) {\\n                quote_char = *current_char;\\n                do {\\n                    current_char++;\\n                    if (*current_char == \"\\\") {\\n                        contains_escape_sequence++;\\n                        current_char++;\\n                    }\\n                } while (quote_char != *current_char);\\n                if (*++current_char > 0x20) {\\n                    puts(*(char **)PTR_INCORRECT_QUOTING_00002d88_00002d88);\\n                    return;\\n                }\\n            }\\n            else {\\n                do {\\n                    if (*current_char == \"\\\") {\\n                        contains_escape_sequence++;\\n                        current_char++;\\n                    }\\n                    current_char++;\\n                } while (*current_char > 0x20);\\n            }\\n            num_args++;\\n        }\\n        if (*current_char == \"\\0\") break;\\n        *current_char++ = \"\\0\";\\n    }\\n    if (num_args != 0) {\\n        args = (char **)malloc((num_args + 1) * sizeof(char *));\\n        arg_pos = command_line;\\n        for (i = 0; i < num_args; i++) {\\n            while (*arg_pos == \"\\0\") arg_pos++;\\n            if ((*arg_pos == \"\\\"\") || (*arg_pos == \"\\\"\")) arg_pos++;\\n            args[i] = arg_pos;\\n            while (*arg_pos != \"\\0\") arg_pos++;\\n        }\\n        args[num_args] = NULL;\\n        for (arg = args; (contains_escape_sequence != 0 && (*arg != NULL)); arg++) {\\n            for (c = *arg; *c != \"\\0\"; c++) {\\n                if (*c == \"\\\\\") {\\n                    for (d = c; *d != \"\\0\"; d++) {\\n                        *d = d[1];\\n                    }\\n                    contains_escape_sequence--;\\n                    if (contains_escape_sequence == 0) break;\\n                }\\n            }\\n        }\\n        command_handler = find_handler(command_list, args[0]);\\n        if (command_handler == NULL) {\\n            cmd_not_found = strcmp(PTR_DAT_00002d8c, args[0]);\\n            if (cmd_not_found == 0) {\\n                print_help(current_command);\\n            }\\n            else {\\n                iprintf(PTR_s_shell__command_not_found___s_00002d90, *(undefined4 *)args);\\n            }\\n        }\\n        else {\\n            (*command_handler)(num_args, args);\\n        }\\n        free(args);\\n    }\\n}",
            "called": [
                "iprintf",
                "find_handler",
                "print_help",
                "strcmp",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002b10",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "parse_shell_command_00002b10"
        },
        "FUN_00001b10": {
            "renaming": {
                "FUN_00001b10": "set_kinetis_mcg_mode_00001b10",
                "mode": "mcg_mode",
                "iVar1": "result",
                "PTR_mcg_mode_routing_00001bb4": "mcg_mode_routing",
                "PTR_current_mode_00001bb0": "current_mode",
                "KINETIS_MCG_MODE_FEI": "0",
                "KINETIS_MCG_MODE_FEE": "1",
                "KINETIS_MCG_MODE_FBI": "2",
                "KINETIS_MCG_MODE_FBE": "3",
                "KINETIS_MCG_MODE_BLPI": "4",
                "KINETIS_MCG_MODE_BLPE": "5",
                "KINETIS_MCG_MODE_PBE": "6",
                "KINETIS_MCG_MODE_PEE": "7"
            },
            "code": "int set_kinetis_mcg_mode_00001b10(kinetis_mcg_mode_t mode) {\n  int result = 0;\n  if (mode < KINETIS_MCG_MODE_NUMOF) {\n    do {\n      uint8_t mode_index = (uint8_t)*PTR_PTR_current_mode_00001bb0_00001bb0;\n      uint8_t mcg_mode = PTR_PTR_mcg_mode_routing_00001bb4_00001bb4[(uint)mode + (uint)mode_index * 8];\n      switch(mcg_mode) {\n        case KINETIS_MCG_MODE_FEI:\n          kinetis_mcg_set_fei();\n          break;\n        case KINETIS_MCG_MODE_FEE:\n          kinetis_mcg_set_fee();\n          break;\n        case KINETIS_MCG_MODE_FBI:\n          kinetis_mcg_set_fbi();\n          break;\n        case KINETIS_MCG_MODE_FBE:\n          kinetis_mcg_set_fbe();\n          break;\n        case KINETIS_MCG_MODE_BLPI:\n          kinetis_mcg_set_blpi();\n          break;\n        case KINETIS_MCG_MODE_BLPE:\n          kinetis_mcg_set_blpe();\n          break;\n        case KINETIS_MCG_MODE_PBE:\n          kinetis_mcg_set_pbe();\n          break;\n        case KINETIS_MCG_MODE_PEE:\n          kinetis_mcg_set_pee();\n          break;\n        default:\n          return -1;\n      }\n    } while (mode != *PTR_PTR_current_mode_00001bb0_00001bb0);\n  }\n  else {\n    result = -1;\n  }\n  return result;\n}",
            "called": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_pee",
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001b10",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_kinetis_mcg_mode_00001b10"
        },
        "FUN_000047e4": {
            "renaming": {
                "FUN_000047e4": "FUNC_000047e4"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\ntime_t FUNC_000047e4(tm *__tp)\n\n{\n  longlong lVar1;\n  int *piVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  int iVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  time_t tVar15;\n  bool bVar16;\n  \n  piVar2 = (int *)__gettzinfo();\n  validate_structure(__tp);\n  uVar11 = __tp->tm_year;\n  iVar10 = __tp->tm_mday + -1 + *(int *)(PTR__DAYS_BEFORE_MONTH_00004adc + __tp->tm_mon * 4);\n  if (((1 < __tp->tm_mon) && ((uVar11 & 3) == 0)) &&\n     ((uVar11 != (uVar11 / 100) * 100 || (uVar11 + 0x76c == ((uVar11 + 0x76c) / 400) * 400)))) {\n    iVar10 = iVar10 + 1;\n  }\n  __tp->tm_yday = iVar10;\n  if (20000 < (int)&PTR_rtc_callback_00002710 + uVar11) {\n    return -1;\n  }\n  if ((int)uVar11 < 0x47) {\n    if (uVar11 != 0x46) {\n      for (uVar8 = 0x45; (int)uVar11 < (int)uVar8; uVar8 = uVar8 - 1) {\n        if ((uVar8 & 3) == 0) {\n          if (uVar8 == (uVar8 / 100) * 100) {\n            if ((uVar8 + 0x76c) % 400 == 0) {\n              iVar6 = 0x16e;\n            }\n            else {\n              iVar6 = 0x16d;\n            }\n          }\n          else {\n            iVar6 = 0x16e;\n          }\n        }\n        else {\n          iVar6 = 0x16d;\n        }\n        iVar10 = iVar10 - iVar6;\n      }\n      if ((uVar8 & 3) == 0) {\n        if (uVar11 == (uVar11 / 100) * 100) {\n          iVar6 = 0x16d;\n          if ((uVar11 + 0x76c) % 400 == 0) {\n            iVar6 = 0x16e;\n          }\n        }\n        else {\n          iVar6 = 0x16e;\n        }\n      }\n      else {\n        iVar6 = 0x16d;\n      }\n      iVar10 = iVar10 - iVar6;\n    }\n  }\n  else {\n    uVar8 = 0x46;\n    do {\n      if ((uVar8 & 3) == 0) {\n        if (uVar8 % 100 == 0) {\n          if ((uVar8 + 0x76c) % 400 == 0) {\n            iVar6 = 0x16e;\n          }\n          else {\n            iVar6 = 0x16d;\n          }\n        }\n        else {\n          iVar6 = 0x16e;\n        }\n      }\n      else {\n        iVar6 = 0x16d;\n      }\n      uVar8 = uVar8 + 1;\n      iVar10 = iVar10 + iVar6;\n    } while (uVar11 != uVar8);\n  }\n  lVar1 = (longlong)DAT_00004ae0 * (longlong)iVar10 +\n          (longlong)(__tp->tm_hour * 0xe10 + __tp->tm_min * 0x3c + __tp->tm_sec);\n  uVar14 = (uint)lVar1;\n  iVar6 = (int)((ulonglong)lVar1 >> 0x20);\n  __tz_lock();\n  _tzset_unlocked();\n  uVar8 = *(uint *)PTR__daylight_00004ae4;\n  if (*(uint *)PTR__daylight_00004ae4 == 0) {\nLAB_00004934:\n    tVar15 = uVar14 + piVar2[10];\n  }\n  else {\n    uVar13 = __tp->tm_isdst;\n    uVar12 = uVar13;\n    if (0 < (int)uVar13) {\n      uVar12 = 1;\n    }\n    if ((piVar2[1] == __tp->tm_year + 0x76c) || (iVar4 = __tzcalc_limits(), iVar4 != 0)) {\n      uVar9 = piVar2[0x14];\n      uVar3 = piVar2[0x12];\n      uVar7 = piVar2[10];\n      uVar8 = uVar3 - uVar7;\n      iVar4 = (piVar2[0x13] - ((int)uVar7 >> 0x1f)) - (uint)(uVar3 < uVar7);\n      if (((int)((iVar6 - iVar4) - (uint)(uVar14 < uVar8)) < 0 ==\n           (SBORROW4(iVar6,iVar4) != SBORROW4(iVar6 - iVar4,(uint)(uVar14 < uVar8)))) &&\n         (iVar5 = (piVar2[0x13] - ((int)uVar9 >> 0x1f)) - (uint)(uVar3 < uVar9),\n         bVar16 = uVar14 < uVar3 - uVar9,\n         (int)((iVar6 - iVar5) - (uint)bVar16) < 0 !=\n         (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)bVar16)))) goto LAB_00004a88;\n      uVar3 = piVar2[8] - uVar9;\n      iVar5 = (piVar2[9] - ((int)uVar9 >> 0x1f)) - (uint)((uint)piVar2[8] < uVar9);\n      if (*piVar2 != 0) {\n        if ((int)((iVar6 - iVar5) - (uint)(uVar14 < uVar3)) < 0 ==\n            (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)(uVar14 < uVar3))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        uVar8 = 0;\n        if ((int)uVar13 < 0) goto LAB_00004934;\nLAB_00004a14:\n        uVar13 = uVar12 ^ uVar8;\n        uVar12 = uVar8;\n        if (uVar13 == 1) {\n          if (uVar8 == 0) {\n            iVar6 = uVar9 - uVar7;\n          }\n          else {\n            iVar6 = uVar7 - uVar9;\n          }\n          iVar4 = __tp->tm_mday;\n          uVar14 = uVar14 + iVar6;\n          __tp->tm_sec = __tp->tm_sec + iVar6;\n          validate_structure(__tp);\n          iVar4 = __tp->tm_mday - iVar4;\n          if (iVar4 != 0) {\n            if (iVar4 < 2) {\n              if (iVar4 == -2 || iVar4 + 2 < 0 != SCARRY4(iVar4,2)) {\n                iVar4 = 1;\n              }\n            }\n            else {\n              iVar4 = -1;\n            }\n            iVar6 = iVar4 + __tp->tm_yday;\n            iVar10 = iVar10 + iVar4;\n            if (iVar6 < 0) {\n              uVar8 = uVar11 - 1;\n              if ((uVar8 & 3) == 0) {\n                if (uVar8 == (uVar8 / 100) * 100) {\n                  iVar6 = 0x16d;\n                  if ((uVar11 + 0x76b) % 400 != 0) {\n                    iVar6 = 0x16c;\n                  }\n                }\n                else {\n                  iVar6 = 0x16d;\n                }\n              }\n              else {\n                iVar6 = 0x16c;\n              }\n            }\n            else {\n              if ((uVar11 & 3) == 0) {\n                if (uVar11 == (uVar11 / 100) * 100) {\n                  iVar4 = 0x16d;\n                  if ((uVar11 + 0x76c) % 400 == 0) {\n                    iVar4 = 0x16e;\n                  }\n                }\n                else {\n                  iVar4 = 0x16e;\n                }\n              }\n              else {\n                iVar4 = 0x16d;\n              }\n              if (iVar4 <= iVar6) {\n                iVar6 = iVar6 - iVar4;\n              }\n            }\n            __tp->tm_yday = iVar6;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((iVar6 - iVar5) - (uint)(uVar14 < uVar3)) < 0 !=\n          (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)(uVar14 < uVar3)))) {\nLAB_0000491e:\n        if ((int)((iVar6 - iVar4) - (uint)(uVar14 < uVar8)) < 0 ==\n            (SBORROW4(iVar6,iVar4) != SBORROW4(iVar6 - iVar4,(uint)(uVar14 < uVar8))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)uVar13) {\n        uVar8 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      uVar8 = uVar12;\n      if (uVar12 != 1) goto LAB_00004934;\n    }\n    tVar15 = uVar14 + piVar2[0x14];\n    uVar8 = 1;\n  }\n  __tz_unlock();\n  __tp->tm_isdst = uVar8;\n  __tp->tm_wday = (iVar10 + 4U) % 7;\n  return tVar15;\n}\n\n",
            "called": [
                "__gettzinfo",
                "__tz_unlock",
                "__tzcalc_limits",
                "validate_structure",
                "__tz_lock",
                "_tzset_unlocked"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000047e4",
            "calling": [
                "rtc_set_time",
                "rtc_set_alarm"
            ],
            "imported": false,
            "current_name": "FUNC_000047e4"
        },
        "FUN_000023c8": {
            "renaming": {
                "FUN_000023c8": "read_and_return_value_000023c8",
                "a0": "value_to_read",
                "a1": "unused_parameter",
                "a2": "unused_variable"
            },
            "code": "uint32_t read_and_return_value_000023c8(uint32_t value_to_read, uint32_t unused_parameter, int32_t unused_variable) {\n  software_interrupt(0x3f);\n  return value_to_read;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023c8",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "read_and_return_value_000023c8"
        },
        "FUN_00002e48": {
            "renaming": {
                "FUN_00002e48": "print_greater_than_space_00002e48",
                "PTR__impure_ptr_00002e68": "impure_ptr",
                "FILE": "file_ptr"
            },
            "code": "void print_greater_than_space_00002e48(void)\n{\n  int PTR__impure_ptr_00002e68 = *(int*)PTR__PTR__impure_ptr_00002e68_00002e68;\n  FILE* file_ptr = *(FILE**)(PTR__impure_ptr_00002e68 + 8);\n  _putchar('>');\n  _putchar(' ');\n  fflush(file_ptr);\n  return;\n}",
            "called": [
                "_putchar",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e48",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "print_greater_than_space_00002e48"
        },
        "FUN_00000930": {
            "renaming": {
                "FUN_00000930": "enable_interrupt_and_trigger_software_interrupt_00000930",
                "irq_enable": "enable_interrupt",
                "software_interrupt": "trigger_software_interrupt",
                "do": "while(true)"
            },
            "code": "void enable_interrupt_and_trigger_software_interrupt_00000930(void)\n{\n  enable_interrupt();\n  trigger_software_interrupt(1);\n  while(true){}\n}\n",
            "called": [
                "irq_enable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000930",
            "calling": [
                "sched_task_exit",
                "kernel_init"
            ],
            "imported": false,
            "current_name": "enable_interrupt_and_trigger_software_interrupt_00000930"
        },
        "FUN_00001348": {
            "renaming": {
                "FUN_00001348": "check_for_context_switch_request_00001348",
                "PTR_sched_context_switch_request_0000135c": "context_switch_request"
            },
            "code": "void check_for_context_switch_request_00001348(void)\n{\n  int* PTR_sched_context_switch_request_0000135c = (int*)PTR_sched_PTR_sched_context_switch_request_0000135c_0000135c;\n  if (*PTR_sched_context_switch_request_0000135c != 0) {\n    thread_yield_higher();\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001348",
            "calling": [
                "irq_handler_uart"
            ],
            "imported": false,
            "current_name": "check_for_context_switch_request_00001348"
        },
        "FUN_00006118": {
            "renaming": {
                "FUN_00006118": "reverse_and_add_char_to_buffer_00006118",
                "param_1": "buffer_start",
                "param_2": "char_to_add",
                "param_3": "buffer",
                "param_4": "buffer_end",
                "iVar1": "result",
                "uVar2": "buffer_ptr_2",
                "uVar3": "buffer_ptr",
                "LAB_00006120": "end_of_function"
            },
            "code": "uint reverse_and_add_char_to_buffer_00006118(undefined4 buffer_start, uint char_to_add, uint *buffer, undefined4 buffer_end) {\n  int buffer_length = buffer[0xd];\n  uint buffer_ptr = *buffer;\n  uint buffer_ptr_2 = buffer[1];\n  if (buffer_length == 0) {\n    if (buffer[4] != 0 && buffer[4] < buffer_ptr && *(byte *)(buffer_ptr - 1) == char_to_add) {\n      *buffer = buffer_ptr - 1;\n      buffer[1] = buffer_ptr_2 + 1;\n      return char_to_add;\n    }\n    buffer[0xf] = buffer_ptr;\n    buffer[0x10] = buffer_ptr_2;\n    buffer[0xd] = (uint)(buffer + 0x11);\n    buffer[0xe] = 3;\n    *(undefined *)((int)buffer + 0x46) = (char)char_to_add;\n    *buffer = (uint)(undefined *)((int)buffer + 0x46);\n    buffer_ptr_2 = 1;\n  } else {\n    if ((int)buffer[0xe] <= (int)buffer_ptr_2) {\n      int result = __submore(buffer_start, buffer, buffer_ptr_2, buffer[0xe], buffer_end);\n      if (result != 0) {\n        buffer_ptr = 0xffffffff;\n        goto LAB_00006120;\n      }\n    }\n    buffer_ptr = *buffer;\n    *buffer = buffer_ptr - 1;\n    *(char *)(buffer_ptr - 1) = (char)char_to_add;\n    buffer_ptr_2++;\n  }\n  buffer[1] = buffer_ptr_2;\n  if (buffer_start == 0xffffffff) {\nLAB_00006120:\n    buffer_start = 0xffffffff;\n  }\n  return buffer_start;\n}",
            "called": [
                "__submore"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006118",
            "calling": [],
            "imported": false,
            "current_name": "reverse_and_add_char_to_buffer_00006118"
        },
        "FUN_00001d3a": {
            "renaming": {
                "FUN_00001d3a": "set_bit_in_uint32_array_00001d3a",
                "ptr": "array",
                "bit": "bit_index",
                "puVar1": "bit_pointer"
            },
            "code": "void set_bit_in_uint32_array_00001d3a(uint32_t *array, uint8_t bit_index) {\n  undefined4 *bit_pointer;\n  bit_pointer = (undefined4 *)bitband_addr(array, (uint)bit_index);\n  *bit_pointer = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d3a",
            "calling": [
                "clk_en"
            ],
            "imported": false,
            "current_name": "set_bit_in_uint32_array_00001d3a"
        },
        "FUN_00002434": {
            "renaming": {
                "FUN_00002434": "acquire_mutex_00002434",
                "*mutex": "mutex",
                "blocking": "blocking",
                "state": "flags",
                "iVar1": "success",
                "*process": "current_thread",
                "irqstate": "flags",
                "*me": "current_thread",
                "queue": "queue",
                "next": "next",
                "PTR_sched_active_thread_000024b8": "get_current_thread",
                "2": "THREAD_BLOCKED",
                "(list_node *)0x0": "NULL",
                "(list_node *)0xffffffff": "(list_node*)-1"
            },
            "code": "int acquire_mutex_00002434(mutex_t* mutex, int blocking) {\n    uint32_t flags;\n    int success = 0;\n    thread_t* current_thread = PTR_sched_active_thread_000024b8();\n\n    flags = disable_interrupts();\n\n    if (mutex->queue.next == NULL) {\n        mutex->queue.next = (list_node*)-1;\n        success = 1;\n    }\n    else if (blocking == 0) {\n        success = 0;\n    }\n    else {\n        sched_set_status(current_thread, THREAD_BLOCKED);\n        if (mutex->queue.next == (list_node*)-1) {\n            mutex->queue.next = &(current_thread->rq_entry);\n            current_thread->rq_entry.next = NULL;\n        }\n        else {\n            thread_add_to_list(&(mutex->queue), current_thread);\n        }\n\n        enable_interrupts(flags);\n        thread_yield_higher();\n        success = 1;\n    }\n\n    return success;\n}",
            "called": [
                "thread_yield_higher",
                "thread_add_to_list",
                "irq_disable",
                "irq_restore",
                "sched_set_status"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002434",
            "calling": [
                "mutex_lock"
            ],
            "imported": false,
            "current_name": "acquire_mutex_00002434"
        },
        "FUN_00005700": {
            "renaming": {
                "FUN_00005700": "allocate_memory_00005700",
                "param_1": "reent",
                "param_2": "memory_block",
                "uVar1": "flag",
                "iVar2": "allocated_memory",
                "local_18": "local_reent",
                "local_14": "local_memory_block"
            },
            "code": "void allocate_memory_00005700(_reent *reent, int *memory_block)\n{\n    ushort flag;\n    int allocated_memory;\n    _reent *local_reent;\n    int *local_memory_block;\n\n    if (-1 < (int)((uint)*(ushort *)(memory_block + 3) << 0x1e)) {\n        local_reent = reent;\n        local_memory_block = memory_block;\n        flag = __swhatbuf_r(reent, memory_block, &local_reent, &local_memory_block);\n        allocated_memory = _malloc_r(reent, local_reent);\n        if (allocated_memory != 0) {\n            reent->__cleanup = DAT_0000577c;\n            *memory_block = allocated_memory;\n            *(ushort *)(memory_block + 3) = *(ushort *)(memory_block + 3) | 0x80;\n            memory_block[5] = (int)local_reent;\n            memory_block[4] = allocated_memory;\n            if ((local_memory_block != (int *)0x0) && (_isatty_r(reent, (int)*(short *)((int)memory_block + 0xe)) != 0)) {\n                *(ushort *)(memory_block + 3) = *(ushort *)(memory_block + 3) & 0xfffc | 1;\n            }\n            *(ushort *)(memory_block + 3) = flag | *(ushort *)(memory_block + 3);\n            return;\n        }\n        if ((int)(short)*(ushort *)(memory_block + 3) << 0x16 < 0) {\n            return;\n        }\n        *(ushort *)(memory_block + 3) = *(ushort *)(memory_block + 3) & 0xfffc | 2;\n    }\n    *memory_block = (int)memory_block + 0x47;\n    memory_block[4] = (int)memory_block + 0x47;\n    memory_block[5] = 1;\n    return;\n}",
            "called": [
                "__swhatbuf_r",
                "_malloc_r",
                "_isatty_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005700",
            "calling": [
                "__srefill_r",
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00005700"
        },
        "FUN_00002798": {
            "renaming": {
                "FUN_00002798": "check_for_context_switch_request_00002798",
                "PTR_sched_context_switch_request_000027ac": "context_switch_request",
                "*PTR_sched_context_switch_request_000027ac": "*context_switch_request"
            },
            "code": "void check_for_context_switch_request_00002798(void)\n{\n    int* PTR_sched_context_switch_request_000027ac = (int*) PTR_sched_PTR_sched_context_switch_request_000027ac_000027ac;\n    if (*PTR_sched_PTR_sched_context_switch_request_000027ac_000027ac != 0)\n    {\n        thread_yield_higher();\n    }\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002798",
            "calling": [
                "isr_rtc"
            ],
            "imported": false,
            "current_name": "check_for_context_switch_request_00002798"
        },
        "FUN_00003524": {
            "renaming": {
                "FUN_00003524": "process_rtc_command_00003524",
                "argc": "arg_count",
                "argv": "arg_values",
                "iVar1": "result",
                "_rtc_usage": "print_rtc_usage",
                "PTR_s_poweron_00003638": "PTR_s_poweron",
                "rtc_poweron": "rtc_poweron",
                "PTR_s_poweroff_0000363c": "PTR_s_poweroff",
                "rtc_poweroff": "rtc_poweroff",
                "PTR_s_clearalarm_00003640": "PTR_s_clearalarm",
                "rtc_clear_alarm": "rtc_clear_alarm",
                "PTR_s_getalarm_00003644": "PTR_s_getalarm",
                "_rtc_getalarm": "get_rtc_alarm",
                "PTR_s_setalarm_00003648": "PTR_s_setalarm",
                "_rtc_setalarm": "set_rtc_alarm",
                "PTR_s_gettime_0000364c": "PTR_s_gettime",
                "_rtc_gettime": "get_rtc_time",
                "PTR_s_settime_00003650": "PTR_s_settime",
                "_rtc_settime": "set_rtc_time"
            },
            "code": "int process_rtc_command_00003524(int arg_count, char **arg_values)\n{\n    int result;\n\n    if (arg_count < 2) {\n        print_rtc_usage();\n        result = 1;\n    }\n    else {\n        int cmp_res = strncmp(arg_values[1], PTR_s_poweron_00003638_00003638, 7);\n        if (cmp_res == 0) {\n            rtc_poweron();\n        }\n        else {\n            cmp_res = strncmp(arg_values[1], PTR_s_poweroff_0000363c_0000363c, 8);\n            if (cmp_res == 0) {\n                rtc_poweroff();\n            }\n            else {\n                cmp_res = strncmp(arg_values[1], PTR_s_clearalarm_00003640_00003640, 8);\n                if (cmp_res == 0) {\n                    rtc_clear_alarm();\n                }\n                else {\n                    cmp_res = strncmp(arg_values[1], PTR_s_getalarm_00003644_00003644, 8);\n                    if (cmp_res == 0) {\n                        get_rtc_alarm();\n                    }\n                    else {\n                        cmp_res = strncmp(arg_values[1], PTR_s_setalarm_00003648_00003648, 8);\n                        if ((cmp_res == 0) && (arg_count == 4)) {\n                            set_rtc_alarm(arg_values + 2);\n                        }\n                        else {\n                            cmp_res = strncmp(arg_values[1], PTR_s_gettime_0000364c_0000364c, 7);\n                            if (cmp_res == 0) {\n                                get_rtc_time();\n                            }\n                            else {\n                                cmp_res = strncmp(arg_values[1], PTR_s_settime_00003650_00003650, 7);\n                                if ((cmp_res != 0) || (arg_count != 4)) {\n                                    print_unknown_command_or_missing_param_error(arg_values[1]);\n                                    print_rtc_usage();\n                                    return 1;\n                                }\n                                set_rtc_time(arg_values + 2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        result = 0;\n    }\n    return result;\n}",
            "called": [
                "_rtc_setalarm",
                "rtc_poweroff",
                "_rtc_usage",
                "rtc_clear_alarm",
                "iprintf",
                "_rtc_settime",
                "strncmp",
                "_rtc_getalarm",
                "_rtc_gettime",
                "rtc_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003524",
            "calling": [],
            "imported": false,
            "current_name": "process_rtc_command_00003524"
        },
        "FUN_00001bb8": {
            "renaming": {
                "FUN_00001bb8": "set_kinetis_mcg_fll_factor_00001bb8",
                "DAT_00001c74": "pll_status_register",
                "DAT_00001c78": "pll_control_register",
                "DAT_00001c7c": "pll_control_register",
                "PTR_current_mode_00001c80": "current_mode_ptr"
            },
            "code": "void set_kinetis_mcg_fll_factor_00001bb8(void)\n{\n  if ((DAT_00001c74[1] & 2) != 0) {\n    clear_bit(DAT_00001c78, 1);\n  }\n  if ((DAT_00001c74[5] & 0x40) != 0) {\n    if ((*DAT_00001c74 & 0xc0) == 0) {\n      *DAT_00001c74 = *DAT_00001c74 & 0x3f | 0x80;\n      do {\n      } while ((DAT_00001c74[6] & 0xc) != 8);\n    }\n    clear_bit(DAT_00001c78, 6);\n    do {\n    } while ((DAT_00001c74[6] & 0x20) != 0);\n  }\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_640);\n  *DAT_00001c74 = *DAT_00001c74 & 0x3b | 4;\n  do {\n  } while ((DAT_00001c74[6] & 0x10) == 0);\n  do {\n  } while ((DAT_00001c74[6] & 0xc) != 0);\n  *PTR_current_mode_00001c80 = 0;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001bb8",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_kinetis_mcg_fll_factor_00001bb8"
        },
        "FUN_0000428c": {
            "renaming": {
                "FUN_0000428c": "acquire_recursive_lock_0000428c",
                "PTR___lock___sinit_recursive_mutex_00004294": "sinit_recursive_mutex"
            },
            "code": "void acquire_recursive_lock_0000428c(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___sinit_recursive_mutex_00004294);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000428c",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_0000428c"
        },
        "FUN_0000404c": {
            "renaming": {
                "FUN_0000404c": "process_data_0000404c",
                "param_1": "data_ptr",
                "param_2": "params_ptr",
                "iVar1": "total_bytes_read",
                "piVar2": "read_size_ptr",
                "uVar3": "uVar3",
                "uVar4": "flags",
                "iVar5": "data_size",
                "pcVar6": "read_func_ptr",
                "iVar7": "read_result",
                "chunk_size": "chunk_size",
                "is_offset_zero": "is_offset_zero",
                "chunk_offset": "chunk_offset",
                "data_offset": "remaining_bytes",
                "is_data_complete": "is_data_complete"
            },
            "code": "int process_data_0000404c(uint *data_ptr, int *params_ptr)\n{\n  int total_bytes_read = 0;\n  int *read_size_ptr;\n  uint uVar3;\n  ushort flags;\n  int data_size;\n  code *read_func_ptr;\n  int read_result;\n  int remaining_bytes;\n  uint uVar8;\n  bool is_data_complete;\n  \n  flags = *(ushort *)(params_ptr + 3);\n  data_size = (int)flags;\n  if ((int)(data_size << 0x1c) < 0) {\n    int chunk_size = params_ptr[4];\n    if (chunk_size != 0) {\n      int chunk_offset = data_size << 0x1e;\n      bool is_offset_zero = chunk_offset == 0;\n      int data_offset = *params_ptr;\n      if (is_offset_zero) {\n        chunk_offset = params_ptr[5];\n      }\n      *params_ptr = chunk_size;\n      if (!is_offset_zero) {\n        chunk_offset = 0;\n      }\n      params_ptr[2] = chunk_offset;\n      for (data_offset = data_offset - chunk_size; 0 < data_offset; data_offset = data_offset - chunk_offset) {\n        read_size_ptr = (int *)params_ptr[10];\n        read_result = (*(code *)read_size_ptr)(data_ptr,params_ptr[8],chunk_size,data_offset);\n        if (read_result < 1) {\n          *(ushort *)(params_ptr + 3) = *(ushort *)(params_ptr + 3) | 0x40;\n          return -1;\n        }\n        chunk_size = chunk_size + read_result;\n      }\n    }\n  }\n  else {\n    if ((params_ptr[1] < 1) && (params_ptr[0x10] < 1)) {\n      return 0;\n    }\n    read_func_ptr = (code *)params_ptr[0xb];\n    if (read_func_ptr == (code *)0x0) {\n      return 0;\n    }\n    uVar8 = *data_ptr;\n    *data_ptr = 0;\n    if ((flags & 0x1000) == 0) {\n      read_result = (*read_func_ptr)(data_ptr,params_ptr[8],data_size & 0x1000,1);\n      if ((read_result == -1) && (uVar3 = *data_ptr, uVar3 != 0)) {\n        if ((uVar3 == 0x1d) || (uVar3 == 0x16)) {\n          *data_ptr = uVar8;\n          return 0;\n        }\n        flags = *(ushort *)(params_ptr + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      read_result = params_ptr[0x15];\n    }\n    if (((int)((uint)*(ushort *)(params_ptr + 3) << 0x1d) < 0) &&\n       (read_result = read_result - params_ptr[1], params_ptr[0xd] != 0)) {\n      read_result = read_result - params_ptr[0x10];\n    }\n    read_result = (*(code *)params_ptr[0xb])(data_ptr,params_ptr[8],read_result,0);\n    flags = *(ushort *)(params_ptr + 3);\n    if ((read_result == -1) &&\n       ((0x1d < *data_ptr || (-1 < (int)((flags >> (*data_ptr & 0xff)) << 0x1f))))) {\nLAB_00004104:\n      *(ushort *)(params_ptr + 3) = flags | 0x40;\n      return read_result;\n    }\n    params_ptr[1] = 0;\n    *params_ptr = params_ptr[4];\n    if (((int)((uint)flags << 0x13) < 0) && ((read_result != -1 || (*data_ptr == 0)))) {\n      params_ptr[0x15] = read_result;\n    }\n    read_size_ptr = (int *)params_ptr[0xd];\n    *data_ptr = uVar8;\n    if (read_size_ptr != (int *)0x0) {\n      if (read_size_ptr != params_ptr + 0x11) {\n        _free_r(data_ptr);\n      }\n      params_ptr[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000404c",
            "calling": [
                "__srefill_r",
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "process_data_0000404c"
        },
        "FUN_00002f74": {
            "renaming": {
                "FUN_00002f74": "print_saul_devices_00002f74",
                "pcVar1": "class_name",
                "i": "device_count",
                "dev": "current_device"
            },
            "code": "void print_saul_devices_00002f74(void)\n{\n  char *class_name;\n  int device_count = 0;\n  saul_reg_t *current_device = *(saul_reg_t **)PTR_saul_reg_00002fd0;\n  if (current_device == (saul_reg_t *)0x0) {\n    puts(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    puts(PTR_s_ID_Class_Name_00002fd4);\n  }\n  while (current_device != (saul_reg_t *)0x0) {\n    class_name = saul_class_to_str(current_device->driver->type);\n    iprintf(PTR_s___i__s__s_00002fdc, device_count, class_name, current_device->name);\n    device_count++;\n    current_device = current_device->next;\n  }\n  return;\n}",
            "called": [
                "iprintf",
                "puts",
                "saul_class_to_str"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f74",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "print_saul_devices_00002f74"
        },
        "FUN_000010a0": {
            "renaming": {
                "FUN_000010a0": "calculateStackSpace_000010a0",
                "stack": "stackPointer",
                "space_free": "freeSpace",
                "stackp": "currentStackPointer"
            },
            "code": "uintptr_t calculateStackSpace_000010a0(char *stackPointer)\n{\n  uintptr_t freeSpace;\n  uintptr_t *currentStackPointer;\n  \n  for (currentStackPointer = (uintptr_t *)stackPointer; (uintptr_t *)*currentStackPointer == currentStackPointer; currentStackPointer = currentStackPointer + 1) {\n  }\n  return (int)currentStackPointer - (int)stackPointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010a0",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "calculateStackSpace_000010a0"
        },
        "FUN_000012e2": {
            "renaming": {
                "FUN_000012e2": "read_from_isrpipe_000012e2",
                "isrpipe_t": "isrpipe",
                "buffer": "buffer",
                "count": "count",
                "iVar1": "read_result",
                "res": "mutex_locked"
            },
            "code": "int read_from_isrpipe_000012e2(isrpipe_t *isrpipe, char *buffer, size_t count) {\n  int read_result;\n  int mutex_locked = 0;\n  while (true) {\n    read_result = tsrb_get(&isrpipe->tsrb, buffer, count);\n    if (read_result != 0) {\n      break;\n    }\n    mutex_lock(&isrpipe->mutex);\n    mutex_locked = 1;\n  }\n  if (mutex_locked) {\n    mutex_unlock(&isrpipe->mutex);\n  }\n  return read_result;\n}",
            "called": [
                "mutex_lock",
                "tsrb_get"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012e2",
            "calling": [
                "uart_stdio_read"
            ],
            "imported": false,
            "current_name": "read_from_isrpipe_000012e2"
        },
        "FUN_000056a0": {
            "renaming": {
                "FUN_000056a0": "find_environment_variable_000056a0",
                "param_1": "env_var_name",
                "param_2": "env_var_value",
                "param_3": "env_var_value_size",
                "uStack_c": "env_var",
                "uStack_8": "unused"
            },
            "code": "void find_environment_variable_000056a0(char* env_var_name, char* env_var_value, size_t env_var_value_size)\n{\n    char* env_var = NULL;\n    env_var = getenv(env_var_name);\n    if (env_var != NULL)\n    {\n        strncpy(env_var_value, env_var, env_var_value_size);\n    }\n    else\n    {\n        env_var_value[0] = '\\0';\n    }\n}",
            "called": [
                "_findenv_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056a0",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "find_environment_variable_000056a0"
        },
        "FUN_0000231c": {
            "renaming": {
                "FUN_0000231c": "copy_from_ring_buffer_0000231c",
                "rb": "ring_buffer",
                "dst": "destination_buffer",
                "n": "num_bytes_to_copy",
                "cVar1": "current_char",
                "iVar2": "is_buffer_empty",
                "local_20": "destination_ptr",
                "tmp": "bytes_remaining",
                "_pop": "tsrb_pop"
            },
            "code": "int copy_from_ring_buffer_0000231c(tsrb_t *ring_buffer, char *destination_buffer, size_t num_bytes_to_copy)\n{\n  char current_char;\n  int is_buffer_empty;\n  char *destination_ptr;\n  size_t bytes_remaining;\n  \n  destination_ptr = destination_buffer;\n  bytes_remaining = num_bytes_to_copy;\n  while ((bytes_remaining != 0 && (is_buffer_empty = tsrb_empty(ring_buffer), is_buffer_empty == 0))) {\n    current_char = tsrb_pop(ring_buffer);\n    *destination_ptr = current_char;\n    bytes_remaining--;\n    destination_ptr++;\n  }\n  return num_bytes_to_copy - bytes_remaining;\n}",
            "called": [
                "tsrb_empty",
                "_pop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000231c",
            "calling": [
                "isrpipe_read"
            ],
            "imported": false,
            "current_name": "copy_from_ring_buffer_0000231c"
        },
        "FUN_000061cc": {
            "renaming": {
                "FUN_000061cc": "FUNC_000061cc"
            },
            "code": "\nint FUNC_000061cc(int param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  void *pvVar4;\n  uint uVar5;\n  byte *pbVar6;\n  uint uVar7;\n  int **local_2b0;\n  undefined auStack_2ac [256];\n  uint local_1ac;\n  undefined4 local_1a8;\n  uint local_1a4;\n  int local_1a0;\n  int local_19c;\n  undefined *local_198;\n  int local_194;\n  undefined4 local_30;\n  code *local_2c;\n  \n  puVar2 = PTR_DAT_000064b4;\n  puVar1 = PTR_DAT_000064b0;\n  local_1a0 = 0;\n  local_19c = 0;\n  local_30 = DAT_000064a8;\n  local_2c = DAT_000064ac;\n  local_2b0 = param_4;\n  local_198 = auStack_2ac;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      uVar7 = (uint)*param_3;\n      if (uVar7 == 0) {\n        return local_1a0;\n      }\n      uVar5 = (byte)puVar1[uVar7] & 8;\n      pbVar6 = param_3 + 1;\n      if ((puVar1[uVar7] & 8) == 0) break;\n      while (((param_3 = pbVar6, 0 < (int)param_2[1] ||\n              (iVar3 = (*local_2c)(param_1,param_2), iVar3 == 0)) &&\n             ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0))) {\n        local_19c = local_19c + 1;\n        param_2[1] = param_2[1] + -1;\n        *param_2 = *param_2 + 1;\n      }\n    }\n    if (uVar7 == 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n    goto LAB_00006380;\n    if (**param_2 != uVar7) {\n      return local_1a0;\n    }\n    *param_2 = *param_2 + 1;\n    local_19c = local_19c + 1;\n    param_2[1] = param_2[1] + -1;\n    param_3 = pbVar6;\n  }\n  local_1a4 = uVar5;\n  local_1ac = uVar5;\n  if (param_3[1] == 0x2a) {\n    pbVar6 = param_3 + 2;\n    local_1ac = 0x10;\n  }\n  while( true ) {\n    uVar5 = (uint)*pbVar6;\n    if (9 < uVar5 - 0x30) break;\n    pbVar6 = pbVar6 + 1;\n    local_1a4 = (local_1a4 * 10 + uVar5) - 0x30;\n  }\n  pvVar4 = memchr(PTR_DAT_000064b4,uVar5,3);\n  if (pvVar4 != (void *)0x0) {\n    local_1ac = 1 << ((int)pvVar4 - (int)puVar2 & 0xffU) | local_1ac;\n    pbVar6 = pbVar6 + 1;\n  }\n  param_3 = pbVar6 + 1;\n  uVar5 = (uint)*pbVar6;\n  if (uVar5 < 0x79) {\n    if (0x57 < uVar5) {\n      switch(uVar5) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 = (byte *)__sccl(auStack_2ac,param_3);\n        local_1ac = local_1ac | 0x40;\n        local_194 = 1;\n        break;\n      case 99:\n        local_1ac = local_1ac | 0x40;\n        local_194 = 0;\n        break;\n      case 100:\n      case 0x75:\n        local_1a8 = 10;\nLAB_000063a0:\n        if (uVar5 < 0x6f) {\n          local_194 = 3;\n        }\n        else {\n          local_194 = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_194 = 5;\n        break;\n      case 0x69:\n        local_1a8 = 0;\n        local_194 = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(local_1ac << 0x1b)) {\n          if ((int)(local_1ac << 0x1f) < 0) {\n            *(short *)*local_2b0 = (short)local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n          else {\n            **local_2b0 = local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_1a8 = 8;\n        local_194 = 4;\n        break;\n      case 0x70:\n        local_1ac = local_1ac | 0x20;\n      case 0x58:\n      case 0x78:\n        local_1ac = local_1ac | 0x200;\n        local_1a8 = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_194 = 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(local_1ac << 0x19)) {\n        while ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0) {\n          local_19c = local_19c + 1;\n          pbVar6 = param_2[1];\n          param_2[1] = pbVar6 + -1;\n          if ((int)(pbVar6 + -1) < 1) {\n            iVar3 = (*local_2c)(param_1,param_2);\n            if (iVar3 != 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 = *param_2 + 1;\n          }\n        }\n      }\n      if (local_194 < 3) {\n        iVar3 = _scanf_chars(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else if (local_194 < 5) {\n        iVar3 = _scanf_i(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else {\n        iVar3 = param_1;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (iVar3 == 1) {\n        return local_1a0;\n      }\n      if (iVar3 == 2) {\nLAB_00006380:\n        if (local_1a0 == 0) {\nLAB_00006388:\n          local_1a0 = -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) & 0x40) != 0) {\n          local_1a0 = -1;\n        }\n        return local_1a0;\n      }\n      goto LAB_000061f6;\n    }\n    pbVar6 = param_3;\n    if (uVar5 == 0x25) goto LAB_00006352;\n    if (uVar5 < 0x26) {\n      if (uVar5 != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (uVar5 - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_194 = 3;\n  local_1a8 = 10;\n  goto LAB_000063ac;\n}\n\n",
            "called": [
                "_scanf_i",
                "__ssrefill_r",
                "__sccl",
                "_scanf_chars",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000061cc",
            "calling": [
                "siscanf"
            ],
            "imported": false,
            "current_name": "FUNC_000061cc"
        },
        "FUN_00002690": {
            "renaming": {
                "FUN_00002690": "convert_rtt_alarm_to_tm_00002690",
                "time": "time_info",
                "t": "alarm_time"
            },
            "code": "int convert_rtt_alarm_to_tm_00002690(tm *time)\n{\n    time_t alarm_time;\n    alarm_time = rtt_get_alarm();\n    tm *time_info = gmtime_r(&alarm_time, time);\n    return 0;\n}",
            "called": [
                "gmtime_r",
                "rtt_get_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002690",
            "calling": [
                "_rtc_getalarm"
            ],
            "imported": false,
            "current_name": "convert_rtt_alarm_to_tm_00002690"
        },
        "FUN_00006010": {
            "renaming": {
                "FUN_00006010": "find_byte_in_memory_00006010",
                "__s": "memory",
                "__c": "byte_to_find",
                "__n": "length",
                "bVar1": "byte",
                "cVar2": "char1",
                "cVar3": "char2",
                "cVar4": "char3",
                "cVar5": "char4",
                "pbVar6": "byte_ptr1",
                "puVar7": "uint_ptr",
                "pbVar8": "byte_ptr2",
                "uVar9": "byte_mask",
                "uVar10": "mem_align",
                "uVar11": "length_aligned",
                "uVar12": "compare_result1",
                "uVar13": "compare_result2",
                "bVar14": "compare_bit1",
                "bVar15": "compare_bit2",
                "bVar16": "compare_bit3",
                "bVar17": "compare_bit4"
            },
            "code": "void * find_byte_in_memory_00006010(void *memory, int byte_to_find, size_t length) {\n  unsigned char *mem = (unsigned char *)memory;\n  unsigned char byte = (unsigned char)byte_to_find;\n  if (length < 16) {\n    while (length--) {\n      if (*mem == byte) {\n        return (void *)mem;\n      }\n      mem++;\n    }\n    return NULL;\n  }\n  unsigned long long mem_align = (unsigned long long)mem & 7;\n  unsigned long long byte_8 = byte | ((unsigned long long)byte << 8) | ((unsigned long long)byte << 16) | ((unsigned long long)byte << 24) | ((unsigned long long)byte << 32) | ((unsigned long long)byte << 40) | ((unsigned long long)byte << 48) | ((unsigned long long)byte << 56);\n  length &= ~7;\n  while (length) {\n    if (mem_align == 0) {\n      unsigned long long mem_8 = *(unsigned long long *)mem;\n      if ((mem_8 ^ byte_8) != 0) {\n        int index = __builtin_ffsll(mem_8 ^ byte_8) - 1;\n        return (void *)(mem + index);\n      }\n      mem += 8;\n      length -= 8;\n    } else {\n      if (*mem == byte) {\n        return (void *)mem;\n      }\n      mem++;\n      length--;\n    }\n    mem_align = (unsigned long long)mem & 7;\n  }\n  return NULL;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006010",
            "calling": [
                "_scanf_i",
                "__ssvfiscanf_r",
                "_vfprintf_r",
                "_printf_i"
            ],
            "imported": false,
            "current_name": "find_byte_in_memory_00006010"
        },
        "FUN_00001cf0": {
            "renaming": {
                "FUN_00001cf0": "check_and_yield_if_requested_00001cf0",
                "PTR_sched_context_switch_request_00001d04": "context_switch_request_ptr",
                "*PTR_sched_context_switch_request_00001d04": "*context_switch_request_ptr"
            },
            "code": "void check_and_yield_if_requested_00001cf0(void)\n{\n    int *PTR_sched_context_switch_request_00001d04 = (int *)PTR_sched_context_switch_request_00001d04;\n    if (*PTR_sched_context_switch_request_00001d04 != 0) {\n        thread_yield_higher();\n    }\n    return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001cf0",
            "calling": [
                "irq_handler"
            ],
            "imported": false,
            "current_name": "check_and_yield_if_requested_00001cf0"
        },
        "FUN_00003ec4": {
            "renaming": {
                "FUN_00003ec4": "format_decimal_00003ec4",
                "out": "output_buffer",
                "val": "value",
                "fp_digits": "fractional_digits",
                "val_00": "quotient",
                "iVar2": "integer_digits",
                "div_len": "divisor",
                "abs": "remainder",
                "e": "unused",
                "div": "unused",
                "pos": "buffer_position",
                "fmt_s32_dec": "format_integer",
                "fmt_lpad": "format_left_pad",
                "PTR_assert_crash_message_00003fec": "PTR_assert_crash_message_00003fec",
                "PTR__tenmap_00003ff0": "PTR__tenmap_00003ff0",
                "SCARRY4": "SCARRY4",
                "PANIC_ASSERT_FAIL": "PANIC_ASSERT_FAIL",
                "memset": "memset",
                "char": "char",
                "uint": "uint32_t",
                "int": "int32_t",
                "size_t": "size_t"
            },
            "code": "size_t format_decimal_00003ec4(char *output_buffer, int32_t value, int fractional_digits) {\n  size_t buffer_position = 0;\n  if (fractional_digits + 7 < 0 != SCARRY4(fractional_digits,7)) {\n    core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_00003fec);\n  }\n  if (fractional_digits == 0) {\n    buffer_position = format_integer(output_buffer, value);\n  }\n  else if (fractional_digits < 1) {\n    uint32_t divisor = *(uint32_t *)(PTR__tenmap_00003ff0 + fractional_digits * -4);\n    uint32_t quotient = (uint32_t)value / divisor;\n    int32_t remainder = value - divisor * quotient;\n    if (remainder < 0) {\n      remainder = -remainder;\n    }\n    if ((quotient == 0) && (value < 0)) {\n      if (output_buffer != (char *)0x0) {\n        *output_buffer = '-';\n      }\n      buffer_position = 1;\n    }\n    if (output_buffer == (char *)0x0) {\n      size_t integer_digits = format_integer((char *)0x0, quotient);\n      buffer_position = integer_digits + 1 + buffer_position;\n    }\n    else {\n      size_t integer_digits = format_integer(output_buffer + buffer_position, quotient);\n      buffer_position += integer_digits;\n      output_buffer[buffer_position] = '.';\n      size_t fractional_digits = format_integer(output_buffer + buffer_position + 1, remainder);\n      format_left_pad(output_buffer + buffer_position + 1, fractional_digits, -fractional_digits, '0');\n      buffer_position = -fractional_digits + buffer_position;\n    }\n  }\n  else {\n    size_t integer_digits = format_integer(output_buffer, value);\n    if (output_buffer != (char *)0x0) {\n      memset(output_buffer + integer_digits, '0', fractional_digits);\n    }\n    buffer_position = fractional_digits + integer_digits;\n  }\n  return buffer_position;\n}",
            "called": [
                "fmt_s32_dec",
                "fmt_lpad",
                "memset",
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ec4",
            "calling": [
                "fmt_s16_dfp"
            ],
            "imported": false,
            "current_name": "format_decimal_00003ec4"
        },
        "FUN_00001360": {
            "renaming": {
                "FUN_00001360": "calculate_address_00001360",
                "ptr": "input_pointer",
                "bit": "bit_offset",
                "lower_bits": "lower_bits_mask",
                "upper_bits": "upper_bits_mask",
                "shifted_lower_bits": "shifted_lower_bits_mask",
                "offset": "calculated_offset"
            },
            "code": "void * calculate_address_00001360(void *ptr,uintptr_t bit)\n{\n  uint lower_bits = (uint)ptr & 0xfffff;\n  uint upper_bits = (uint)ptr & 0xf0000000;\n  uint shifted_lower_bits = lower_bits << 5;\n  uint offset = bit * 4 + shifted_lower_bits + 0x2000000;\n  return (void *)(offset | upper_bits);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001360",
            "calling": [
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_address_00001360"
        },
        "FUN_00004622": {
            "renaming": {
                "FUN_00004622": "fill_memory_with_value_00004622",
                "__s": "memory",
                "__c": "value",
                "__n": "size",
                "puVar1": "byte_ptr"
            },
            "code": "void * fill_memory_with_value_00004622(void *memory, int value, size_t size)\n{\n  unsigned char *byte_ptr;\n  for (byte_ptr = (unsigned char *)memory; byte_ptr != (unsigned char *)(size + (int)memory); byte_ptr = byte_ptr + 1) {\n    *byte_ptr = (unsigned char)value;\n  }\n  return memory;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004622",
            "calling": [
                "std",
                "__sfmoreglue",
                "fmt_s32_dfp",
                "fmt_lpad",
                "__sfp",
                "write"
            ],
            "imported": false,
            "current_name": "fill_memory_with_value_00004622"
        },
        "FUN_0000093c": {
            "renaming": {
                "FUN_0000093c": "set_flag_for_data_0000093c",
                "DAT_00000954": "data_ptr",
                "uint": "uint32_t",
                "*": "*",
                "data": "data",
                "flag_bit": "flag_bit"
            },
            "code": "void set_flag_for_data_0000093c(void)\n{\n  uint32_t *DAT_00000954 = (uint32_t *)DAT_00000954;\n  uint32_t data = *(DAT_00000954 + 1);\n  uint32_t flag_bit = 0x10000000;\n  *(DAT_00000954 + 1) = data | flag_bit;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000093c",
            "calling": [
                "cortexm_isr_end",
                "_mutex_lock",
                "sched_switch",
                "cortexm_isr_end",
                "cortexm_isr_end"
            ],
            "imported": false,
            "current_name": "set_flag_for_data_0000093c"
        },
        "FUN_00003658": {
            "renaming": {
                "FUN_00003658": "synchronize_data_00003658",
                "DAT_00003680": "ptr_data",
                "DAT_00003684": "val_data",
                "PTR_": "ptr_",
                "DAT_": "data_"
            },
            "code": "void synchronize_data_00003658(void)\n{\n  DataSynchronizationBarrier(0xf);\n  uint* ptr = (uint *)(DAT_00003680 + 0xc);\n  uint val = DAT_00003684 | (*ptr & 0x700);\n  *ptr = val;\n  DataSynchronizationBarrier(0xf);\n  while(true)\n  {\n    // Do nothing loop\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003658",
            "calling": [
                "pm_reboot"
            ],
            "imported": false,
            "current_name": "synchronize_data_00003658"
        },
        "FUN_000019c0": {
            "renaming": {
                "FUN_000019c0": "enable_oscillator_and_set_fll_factor_000019c0",
                "DAT_00001a0c": "flag_register",
                "DAT_00001a10": "control_register",
                "PTR_current_mode_00001a14": "current_mode_ptr",
                "KINETIS_MCG_FLL_FACTOR_1920": "FLL_FACTOR",
                "FLAG_BIT_0": "BIT_0",
                "CONTROL_BIT_MASK": "BIT_MASK",
                "STATUS_BIT_MASK": "BIT_MASK",
                "EXPECTED_STATUS": "TARGET_STATUS",
                "MODE_3": "OPERATING_MODE"
            },
            "code": "void enable_oscillator_and_set_fll_factor_000019c0(void)\n{\n    kinetis_mcg_enable_osc();\n    kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1920);\n    bit_clear8(DAT_00001a0c, FLAG_BIT_0);\n    *DAT_00001a10 |= CONTROL_BIT_MASK;\n    while((status_register & STATUS_BIT_MASK) != EXPECTED_STATUS);\n    kinetis_mcg_disable_pll();\n    *PTR_current_mode_00001a14 = MODE_3;\n    return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000019c0",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "enable_oscillator_and_set_fll_factor_000019c0"
        },
        "FUN_000060b0": {
            "renaming": {
                "FUN_000060b0": "reverse_copy_000060b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_bytes",
                "puVar1": "temp_ptr",
                "puVar2": "end_of_source",
                "puVar3": "dest_ptr"
            },
            "code": "void* reverse_copy_000060b0(void* destination, const void* source, size_t num_bytes) {\n    unsigned char* dest = (unsigned char*)destination + num_bytes - 1;\n    const unsigned char* src = (const unsigned char*)source;\n    while (num_bytes--) {\n        *dest-- = *src++;\n    }\n    return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060b0",
            "calling": [
                "__submore",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "reverse_copy_000060b0"
        },
        "FUN_00006a14": {
            "renaming": {
                "FUN_00006a14": "FUNC_00006a14"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong FUNC_00006a14(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint uVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  if (param_4 == 0) {\n    if (param_2 < param_3) {\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 != 0) {\n        param_3 = param_3 << (uVar4 & 0xff);\n        param_2 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        param_1 = param_1 << (uVar4 & 0xff);\n      }\n      uVar7 = param_3 >> 0x10;\n      uVar9 = param_2 / uVar7;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar7 * uVar9) * 0x10000;\n      uVar1 = uVar9 * (param_3 & 0xffff);\n      uVar6 = uVar9;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar9 = (uVar5 - uVar1) / uVar7;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar7 * uVar9) * 0x10000;\n      uVar7 = uVar9 * (param_3 & 0xffff);\n      uVar1 = uVar9;\n      if (uVar5 <= uVar7 && uVar7 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar7 && uVar7 - uVar5 != 0)) {\n          uVar1 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar7;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n      puVar3 = (uint *)0x0;\n    }\n    else {\n      if (param_3 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        uVar12 = (*UNRECOVERED_JUMPTABLE)();\n        return uVar12;\n      }\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 == 0) {\n        param_2 = param_2 - param_3;\n        uVar10 = param_3 >> 0x10;\n        uVar8 = param_3 & 0xffff;\n        puVar3 = (uint *)0x1;\n      }\n      else {\n        param_3 = param_3 << (uVar4 & 0xff);\n        uVar10 = param_3 >> 0x10;\n        uVar6 = param_2 >> (0x20 - uVar4 & 0xff);\n        uVar1 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        uVar5 = uVar6 / uVar10;\n        uVar8 = param_3 & 0xffff;\n        uVar9 = uVar1 >> 0x10 | (uVar6 - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        param_1 = param_1 << (uVar4 & 0xff);\n        uVar6 = uVar5;\n        if (uVar9 <= uVar7 && uVar7 - uVar9 != 0) {\n          bVar11 = CARRY4(param_3,uVar9);\n          uVar9 = param_3 + uVar9;\n          uVar6 = uVar5 - 1;\n          if ((bVar11 == false) && (uVar9 <= uVar7 && uVar7 - uVar9 != 0)) {\n            uVar6 = uVar5 - 2;\n            uVar9 = uVar9 + param_3;\n          }\n        }\n        uVar5 = (uVar9 - uVar7) / uVar10;\n        param_2 = uVar1 & 0xffff | ((uVar9 - uVar7) - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        uVar1 = uVar5;\n        if (param_2 <= uVar7 && uVar7 - param_2 != 0) {\n          bVar11 = CARRY4(param_3,param_2);\n          param_2 = param_3 + param_2;\n          uVar1 = uVar5 - 1;\n          if ((bVar11 == false) && (param_2 <= uVar7 && uVar7 - param_2 != 0)) {\n            uVar1 = uVar5 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar7;\n        puVar3 = (uint *)(uVar1 | uVar6 << 0x10);\n      }\n      uVar7 = param_2 / uVar10;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar10 * uVar7) * 0x10000;\n      uVar1 = uVar8 * uVar7;\n      uVar6 = uVar7;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar7 = (uVar5 - uVar1) / uVar10;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar10 * uVar7) * 0x10000;\n      uVar8 = uVar8 * uVar7;\n      uVar1 = uVar7;\n      if (uVar5 <= uVar8 && uVar8 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar8 && uVar8 - uVar5 != 0)) {\n          uVar1 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar8;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = uVar5 >> (uVar4 & 0xff);\n      param_5[1] = 0;\n    }\n  }\n  else if (param_2 < param_4) {\n    puVar2 = param_5;\n    puVar3 = param_5;\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return 0;\n    }\n  }\n  else {\n    puVar3 = (uint *)count_leading_zeroes(param_4);\n    if (puVar3 != (uint *)0x0) {\n      uVar8 = 0x20 - (int)puVar3;\n      uVar5 = param_3 >> (uVar8 & 0xff) | param_4 << ((uint)puVar3 & 0xff);\n      uVar10 = uVar5 >> 0x10;\n      uVar4 = param_2 >> (uVar8 & 0xff);\n      uVar6 = param_1 >> (uVar8 & 0xff) | param_2 << ((uint)puVar3 & 0xff);\n      uVar7 = uVar4 / uVar10;\n      uVar1 = uVar6 >> 0x10 | (uVar4 - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      param_3 = param_3 << ((uint)puVar3 & 0xff);\n      param_1 = param_1 << ((uint)puVar3 & 0xff);\n      uVar4 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar4 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar4 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar7 = (uVar1 - uVar9) / uVar10;\n      uVar1 = uVar6 & 0xffff | ((uVar1 - uVar9) - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      uVar6 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar6 = uVar6 | uVar4 << 0x10;\n      uVar12 = (ulonglong)uVar6 * (ulonglong)param_3;\n      if (CONCAT44(uVar1 - uVar9,param_1) < uVar12) {\n        uVar12 = uVar12 - CONCAT44(uVar5,param_3);\n        uVar6 = uVar6 - 1;\n      }\n      if (param_5 != (uint *)0x0) {\n        uVar4 = ((uVar1 - uVar9) - (int)(uVar12 >> 0x20)) - (uint)(param_1 < (uint)uVar12);\n        *param_5 = uVar4 << (uVar8 & 0xff) | param_1 - (uint)uVar12 >> ((uint)puVar3 & 0xff);\n        param_5[1] = uVar4 >> ((uint)puVar3 & 0xff);\n      }\n      return (ulonglong)uVar6;\n    }\n    if ((param_4 < param_2) || (puVar2 = puVar3, param_3 <= param_1)) {\n      bVar11 = param_1 < param_3;\n      param_1 = param_1 - param_3;\n      param_2 = (param_2 - param_4) - (uint)bVar11;\n      puVar2 = (uint *)0x1;\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n    }\n  }\n  return CONCAT44(puVar3,puVar2);\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00006a14",
            "calling": [
                "__aeabi_ldivmod"
            ],
            "imported": false,
            "current_name": "FUNC_00006a14"
        },
        "FUN_000023d0": {
            "renaming": {
                "FUN_000023d0": "execute_afl_call_000023d0",
                "ticks": "ticks",
                "uVar1": "result",
                "PTR_noHyperCall_000023fc": "PTR_noHyperCall_000023fc",
                "aflCall": "aflCall"
            },
            "code": "uint32_t execute_afl_call_000023d0(int ticks)\n{\n  uint32_t result;\n  if (*(int *)PTR_noHyperCall_000023fc == 0) {\n    result = aflCall(1, ticks, 0);\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023d0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "execute_afl_call_000023d0"
        },
        "FUN_00000a30": {
            "renaming": {
                "FUN_00000a30": "handle_nmi_00000a30",
                "PTR_s_NMI_HANDLER_00000a3c": "nmi_handler_ptr"
            },
            "code": "void handle_nmi_00000a30(void)\n{\n    core_panic(PANIC_NMI_HANDLER, PTR_s_NMI_HANDLER_00000a3c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a30",
            "calling": [],
            "imported": false,
            "current_name": "handle_nmi_00000a30"
        },
        "FUN_000034c0": {
            "renaming": {
                "FUN_000034c0": "print_rtc_commands_000034c0",
                "PTR_s_usage__rtc__command___arguments__00003500": "command_usage",
                "PTR_s_commands__00003504": "available_commands",
                "PTR_s__poweron_power_the_interface_on_00003508": "power_on_interface",
                "PTR_s__poweroff_power_the_interface_of_0000350c": "power_off_interface",
                "PTR_s__clearalarm_deactivate_the_curre_00003510": "deactivate_current_alarm",
                "PTR_s__getalarm_print_the_currently_al_00003514": "print_current_alarm",
                "PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518": "set_alarm",
                "PTR_s__gettime_print_the_current_time_0000351c": "print_current_time",
                "PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520": "set_time"
            },
            "code": "int print_rtc_commands_000034c0(void)\n{\n  puts(PTR_s_usage__rtc__command___arguments__00003500);\n  puts(PTR_s_commands__00003504);\n  puts(PTR_s__poweron_power_the_interface_on_00003508);\n  puts(PTR_s__poweroff_power_the_interface_of_0000350c);\n  puts(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  puts(PTR_s__getalarm_print_the_currently_al_00003514);\n  puts(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  puts(PTR_s__gettime_print_the_current_time_0000351c);\n  puts(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}",
            "called": [
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000034c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "print_rtc_commands_000034c0"
        },
        "FUN_000050e8": {
            "renaming": {
                "FUN_000050e8": "acquire_time_zone_lock_000050e8",
                "PTR___lock___tz_mutex_000050f0": "time_zone_lock"
            },
            "code": "void acquire_time_zone_lock_000050e8(void)\n{\n    __retarget_lock_acquire(PTR___lock___tz_mutex_000050f0);\n    return;\n}",
            "called": [
                "__retarget_lock_acquire"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050e8",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "acquire_time_zone_lock_000050e8"
        },
        "FUN_000042a4": {
            "renaming": {
                "FUN_000042a4": "initialize_data_000042a4",
                "param_1": "data",
                "uVar1": "result",
                "iVar2": "global_data",
                "bVar3": "is_global_data",
                "PTR__global_impure_ptr_0000430c": "GLOBAL_DATA_PTR",
                "DAT_00004310": "GLOBAL_CONSTANT",
                "FIRST_VAR_OFFSET": "0x48",
                "SECOND_VAR_OFFSET": "0x4c",
                "THIRD_VAR_OFFSET": "0x50",
                "FIRST_VAR_PTR_OFFSET": "0x4",
                "SECOND_VAR_PTR_OFFSET": "0x8",
                "THIRD_VAR_PTR_OFFSET": "0xc",
                "DATA_OFFSET": "0x18",
                "get_first_var": "__sfp",
                "get_second_var": "__sfp",
                "get_third_var": "__sfp",
                "set_data": "std"
            },
            "code": "void initialize_data_000042a4(int data)\n{\n    acquire_lock();\n    if (*(int *)(data + DATA_OFFSET) == 0)\n    {\n        *(undefined4 *)(data + FIRST_VAR_OFFSET) = 0;\n        *(undefined4 *)(data + SECOND_VAR_OFFSET) = 0;\n        *(undefined4 *)(data + THIRD_VAR_OFFSET) = 0;\n        int global_data = *(int *)PTR__global_impure_ptr_0000430c;\n        *(undefined4 *)(data + FOURTH_VAR_OFFSET) = DAT_00004310;\n        bool is_global_data = global_data == data;\n        if (is_global_data)\n        {\n            global_data = 1;\n        }\n        if (is_global_data)\n        {\n            *(int *)(data + DATA_OFFSET) = global_data;\n        }\n        undefined4 first_var = get_first_var(data);\n        *(undefined4 *)(data + FIRST_VAR_PTR_OFFSET) = first_var;\n        undefined4 second_var = get_second_var(data);\n        *(undefined4 *)(data + SECOND_VAR_PTR_OFFSET) = second_var;\n        undefined4 third_var = get_third_var(data);\n        *(undefined4 *)(data + THIRD_VAR_PTR_OFFSET) = third_var;\n        set_data(first_var, 4, 0);\n        set_data(second_var, 9, 1);\n        set_data(third_var, 0x12, 2);\n        *(undefined4 *)(data + DATA_OFFSET) = 1;\n    }\n    release_lock();\n}\n",
            "called": [
                "__sinit_lock_acquire",
                "__sinit_lock_release",
                "std",
                "__sfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000042a4",
            "calling": [
                "__swbuf_r",
                "__srefill_r",
                "_fflush_r",
                "__sfp",
                "_puts_r",
                "getchar",
                "iprintf",
                "putchar",
                "__swsetup_r",
                "_vfprintf_r",
                "__srget_r",
                "_putc_r",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "initialize_data_000042a4"
        },
        "FUN_00000514": {
            "renaming": {
                "FUN_00000514": "set_errno_to_0x13_00000514",
                "r": "reent",
                "fd": "file_descriptor",
                "st": "file_status",
                "PTR_": "PTR_ (unchanged)",
                "DAT_": "DAT_ (unchanged)"
            },
            "code": "int set_errno_to_0x13_00000514(_reent *reent, int file_descriptor, stat *file_status) {\n  reent->errno = 0x13;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000514",
            "calling": [
                "__swhatbuf_r"
            ],
            "imported": false,
            "current_name": "set_errno_to_0x13_00000514"
        },
        "FUN_00002e9c": {
            "renaming": {
                "FUN_00002e9c": "reboot_system_00002e9c",
                "argc": "argument_count",
                "argv": "arguments"
            },
            "code": "int reboot_system_00002e9c(int argc, char **argv) {\n    pm_reboot();\n    return 0;\n}",
            "called": [
                "pm_reboot"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e9c",
            "calling": [],
            "imported": false,
            "current_name": "reboot_system_00002e9c"
        },
        "FUN_00001960": {
            "renaming": {
                "FUN_00001960": "initialize_system_clock_00001960",
                "DAT_000019b4": "system_control_register",
                "DAT_000019b8": "system_status_register",
                "PTR_current_mode_000019bc": "current_mode_pointer",
                "KINETIS_MCG_FLL_FACTOR_1464": "fll_factor_1464",
                "BIT_0": "BIT_0",
                "BITMASK_2_3": "BITMASK_2_3",
                "BIT_2": "BIT_2",
                "BIT_4": "BIT_4",
                "MODE_2": "MODE_2"
            },
            "code": "void initialize_system_clock_00001960(void)\n{\n  set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  clear_bit(DAT_000019b4, BIT_0);\n  *DAT_000019b8 = (*DAT_000019b8 & 0x3b) | 0x44;\n  while ((DAT_000019b8[6] & BITMASK_2_3) != BIT_2);\n  while ((DAT_000019b8[6] & BIT_4) == 0);\n  *PTR_current_mode_000019bc = MODE_2;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001960",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "initialize_system_clock_00001960"
        },
        "FUN_00000990": {
            "renaming": {
                "FUN_00000990": "do_nothing_00000990"
            },
            "code": "\nvoid do_nothing_00000990(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000990",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "do_nothing_00000990"
        },
        "FUN_00001a3c": {
            "renaming": {
                "FUN_00001a3c": "set_current_mode_to_five_00001a3c",
                "DAT_00001a58": "DAT_current_mode",
                "kinetis_mcg_disable_pll": "disable_pll",
                "*PTR_current_mode_00001a5c": "*PTR_current_mode"
            },
            "code": "void set_current_mode_to_five_00001a3c(void)\n{\n  set_bit_high(DAT_00001a58, 1);\n  disable_pll();\n  *PTR_current_mode_00001a5c = 5;\n  return;\n}",
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a3c",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_current_mode_to_five_00001a3c"
        },
        "FUN_000045ee": {
            "renaming": {
                "FUN_000045ee": "reverse_copy_000045ee",
                "__dest": "dest",
                "__src": "src",
                "__n": "n",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "code": "void * reverse_copy_000045ee(void *dest, const void *src, size_t n) {\n  unsigned char *dest_ptr = (unsigned char *) dest;\n  const unsigned char *src_ptr = (const unsigned char *) src;\n  if (src_ptr < dest_ptr) {\n    for (size_t i = n; i > 0; --i) {\n      dest_ptr[i - 1] = src_ptr[i - 1];\n    }\n  }\n  else {\n    for (size_t i = 0; i < n; ++i) {\n      dest_ptr[i] = src_ptr[i];\n    }\n  }\n  return dest;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ee",
            "calling": [
                "fmt_lpad"
            ],
            "imported": false,
            "current_name": "reverse_copy_000045ee"
        },
        "FUN_00005404": {
            "renaming": {
                "FUN_00005404": "write_to_stream_00005404",
                "param_1": "stream_id",
                "param_2": "character",
                "param_3": "stream_ptr",
                "param_4": "param_4",
                "iVar1": "num_bytes_written",
                "uVar2": "uVar2",
                "puVar3": "buffer_ptr"
            },
            "code": "uint write_to_stream_00005404(int stream_id, uint character, int *stream_ptr, undefined4 param_4)\n{\n  int num_bytes_written;\n  uint uVar2;\n  undefined *buffer_ptr;\n  \n  if ((stream_id != 0) && (*(int *)(stream_id + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_ptr == (int *)PTR___sf_fake_stdin_0000549c) {\n    stream_ptr = *(int **)(stream_id + 4);\n  }\n  else if (stream_ptr == (int *)PTR___sf_fake_stdout_000054a0) {\n    stream_ptr = *(int **)(stream_id + 8);\n  }\n  else if (stream_ptr == (int *)PTR___sf_fake_stderr_000054a4) {\n    stream_ptr = *(int **)(stream_id + 0xc);\n  }\n  stream_ptr[2] = stream_ptr[6];\n  uVar2 = (uint)*(ushort *)(stream_ptr + 3);\n  num_bytes_written = uVar2 << 0x1c;\n  if (((num_bytes_written < 0) && (uVar2 = stream_ptr[4], uVar2 != 0)) ||\n     (num_bytes_written = __swsetup_r(stream_id, stream_ptr, num_bytes_written, uVar2, param_4), num_bytes_written == 0)) {\n    num_bytes_written = *stream_ptr - stream_ptr[4];\n    character = character & 0xff;\n    if ((num_bytes_written < stream_ptr[5]) || (num_bytes_written = _fflush_r(stream_id, stream_ptr), num_bytes_written == 0)) {\n      stream_ptr[2] = stream_ptr[2] + -1;\n      buffer_ptr = (undefined *)*stream_ptr;\n      *stream_ptr = (int)(buffer_ptr + 1);\n      *buffer_ptr = (char)character;\n      if (stream_ptr[5] != num_bytes_written + 1) {\n        if (-1 < (int)((uint)*(ushort *)(stream_ptr + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      num_bytes_written = _fflush_r(stream_id, stream_ptr);\n      if (num_bytes_written == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005404",
            "calling": [
                "_puts_r",
                "__sfputc_r",
                "_putc_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_00005404"
        },
        "FUN_00006974": {
            "renaming": {
                "FUN_00006974": "divide_00006974",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "unused",
                "iVar1": "quotient",
                "local_8": "unused"
            },
            "code": "int divide_00006974(int divide_00006974nd, int divisor, int* remainder) {\n  int quotient;\n  \n  if (divisor == 0) {\n    if (divide_00006974nd < 0) {\n      divide_00006974nd = 0;\n      divisor = -2147483648;\n    }\n    else if (divide_00006974nd != 0) {\n      divide_00006974nd = 2147483647;\n      divisor = 1;\n    }\n    quotient = __aeabi_idiv0(divide_00006974nd, divisor);\n    return quotient;\n  }\n  if (divide_00006974nd < 0) {\n    quotient = -divide_00006974nd - (int)(divisor != 0);\n    if (*remainder < 0) {\n      quotient = __udivmoddi4(-divisor, quotient, -*remainder, -*remainder - (int)(*remainder != 0), remainder);\n      return -quotient;\n    }\n    quotient = __udivmoddi4(-divisor, quotient, *remainder, *remainder, remainder);\n    return -quotient;\n  }\n  if (*remainder < 0) {\n    quotient = __udivmoddi4(divide_00006974nd, divisor, -*remainder, -*remainder - (int)(*remainder != 0), remainder);\n    return -quotient;\n  }\n  quotient = __udivmoddi4(divide_00006974nd, divisor, *remainder, *remainder, remainder);\n  return quotient;\n}",
            "called": [
                "__udivmoddi4",
                "__aeabi_idiv0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006974",
            "calling": [
                "gmtime_r"
            ],
            "imported": false,
            "current_name": "divide_00006974"
        },
        "FUN_00004314": {
            "renaming": {
                "FUN_00004314": "allocate_memory_for_stream_00004314",
                "param_1": "stream",
                "piVar1": "stream_ptr",
                "piVar2": "stream_array_ptr",
                "iVar3": "global_impure_ptr",
                "ppiVar4": "next_stream_ptr_ptr"
            },
            "code": "int * allocate_memory_for_stream_00004314(FILE *stream){\n    int *stream_ptr;\n    int *stream_array_ptr;\n    int global_impure_ptr;\n    int **next_stream_ptr_ptr;\n    \n    acquire_lock_for_stream_allocation();\n    global_impure_ptr = *(int *)PTR__global_impure_ptr_00004398;\n    if (*(int *)(global_impure_ptr + 0x18) == 0){\n        __sinit(global_impure_ptr);\n    }\n    next_stream_ptr_ptr = (int **)(global_impure_ptr + 0x48);\n    do{\n        stream_array_ptr = next_stream_ptr_ptr[1];\n        stream_ptr = next_stream_ptr_ptr[2];\n        while (stream_array_ptr = (int *)((int)stream_array_ptr + -1), -1 < (int)stream_array_ptr){\n            if (*(short *)(stream_ptr + 3) == 0){\n                stream_ptr[3] = DAT_0000439c;\n                stream_ptr[0x19] = 0;\n                __retarget_lock_init_recursive(stream_ptr + 0x16);\n                release_lock_for_stream_allocation();\n                stream_ptr[1] = 0;\n                stream_ptr[2] = 0;\n                stream_ptr[4] = 0;\n                stream_ptr[5] = 0;\n                *stream_ptr = 0;\n                stream_ptr[6] = 0;\n                memset(stream_ptr + 0x17,0,8);\n                stream_ptr[0xd] = 0;\n                stream_ptr[0xe] = 0;\n                stream_ptr[0x12] = 0;\n                stream_ptr[0x13] = 0;\n                return stream_ptr;\n            }\n            stream_ptr = stream_ptr + 0x1a;\n        }\n        if (*next_stream_ptr_ptr == (int *)0x0){\n            stream_array_ptr = (int *)__sfmoreglue(stream, 4);\n            *next_stream_ptr_ptr = stream_array_ptr;\n            if (stream_array_ptr == (int *)0x0){\n                release_lock_for_stream_allocation();\n                *stream = 0xc;\n                return (int *)0x0;\n            }\n        }\n        next_stream_ptr_ptr = (int **)*next_stream_ptr_ptr;\n    }while(true);\n}",
            "called": [
                "__sfmoreglue",
                "memset",
                "__sfp_lock_release",
                "__retarget_lock_init_recursive",
                "__sfp_lock_acquire",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004314",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "allocate_memory_for_stream_00004314"
        },
        "FUN_00005fd4": {
            "renaming": {
                "FUN_00005fd4": "parse_uint_from_string_00005fd4",
                "param_1": "result",
                "param_2": "str",
                "param_3": "endptr",
                "param_4": "base",
                "uVar1": "current_value",
                "uVar2": "digit_value",
                "bVar3": "is_base_prefix",
                "iVar4": "overflow",
                "uVar5": "max_digit_value",
                "uVar6": "max_dividend",
                "pbVar7": "current_char_ptr",
                "pbVar8": "next_char_ptr"
            },
            "code": "uint parse_uint_from_string_00005fd4(undefined4 *result, byte *str, byte **endptr, uint base) {\n  uint digit_value;\n  uint current_value;\n  byte current_char;\n  int is_negative = 0;\n  int overflow = 0;\n  uint max_dividend = 0xffffffff / base;\n  uint i = 0;\n  byte *current_ptr = str;\n  while ((PTR_DAT_00005fd0[*current_ptr] & 8) != 0) {\n    current_ptr++;\n  }\n  if (*current_ptr == 0x2d) {\n    is_negative = 1;\n    current_char = *(++current_ptr);\n    i++;\n  }\n  else if (*current_ptr == 0x2b) {\n    current_char = *(++current_ptr);\n    i++;\n  }\n  if (base == 0) {\n    if (*current_ptr != 0x30) {\n      base = 10;\n      goto end_of_base_check;\n    }\n  }\n  else if (base != 16 || *current_ptr != 0x30) {\n    end_of_base_check:\n    if ((*current_ptr & 0xdf) == 0x58) {\n      current_char = *(current_ptr + 1);\n      base = 16;\n      i += 2;\n    }\n    else {\n      if (base == 0) {\n        base = 8;\n      }\n    }\n    while (1) {\n      if (i >= 0x20) {\n        overflow = 1;\n        break;\n      }\n      digit_value = current_char - 0x30;\n      if (digit_value > 9) {\n        if (current_char - 0x41 < 0x1a) {\n          digit_value = current_char - 0x37;\n        }\n        else {\n          if (current_char - 0x61 > 0x19) {\n            break;\n          }\n          digit_value = current_char - 0x57;\n        }\n      }\n      if (digit_value >= base) {\n        break;\n      }\n      if ((i < 0 || max_dividend < current_value) || (max_dividend == current_value && (~(base * max_dividend) < digit_value))) {\n        overflow = 1;\n        break;\n      }\n      current_value = current_value * base + digit_value;\n      i++;\n      current_char = *(current_ptr + i);\n    }\n  }\n  if (overflow) {\n    *result = 0x22;\n    if (endptr == (byte **)0x0) {\n      return 0xffffffff;\n    }\n    else {\n      *endptr = current_ptr;\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (is_negative) {\n      current_value = -current_value;\n    }\n    if (endptr == (byte **)0x0) {\n      return current_value;\n    }\n    else {\n      if (i == 0) {\n        *endptr = current_ptr;\n      }\n      else {\n        *endptr = current_ptr + i;\n      }\n      return current_value;\n    }\n  }\n}",
            "called": [
                "_strtoul_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd4",
            "calling": [],
            "imported": false,
            "current_name": "parse_uint_from_string_00005fd4"
        },
        "FUN_00004dc8": {
            "renaming": {
                "FUN_00004dc8": "read_data_from_file_00004dc8",
                "param_1": "reent",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "_Var1": "bytes_read",
                "uVar2": "new_offset",
                "bVar3": "success"
            },
            "code": "void read_data_from_file_00004dc8(_reent *reent, int file_descriptor, void *buffer, size_t buffer_size) {\n  _ssize_t bytes_read = _read_r(reent, (int)*(short *)(file_descriptor + 0xe), buffer, buffer_size);\n  bool success = bytes_read >= 0;\n  if (success) {\n    uint new_offset = *(int *)(file_descriptor + 0x54) + bytes_read;\n    *(uint *)(file_descriptor + 0x54) = new_offset;\n  }\n  else {\n    uint current_offset = *(ushort *)(file_descriptor + 0xc) & 0xffffefff;\n    *(short *)(file_descriptor + 0xc) = (short)current_offset;\n  }\n}",
            "called": [
                "_read_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dc8",
            "calling": [],
            "imported": false,
            "current_name": "read_data_from_file_00004dc8"
        },
        "FUN_00005fd8": {
            "renaming": {
                "<original_function_name>": "FUN_00005fd8",
                "__nptr": "str",
                "__endptr": "endptr",
                "__base": "base",
                "uVar1": "result",
                "PTR__impure_ptr_00005fe8": "PTR__impure_ptr_00005fe8",
                "FUN_00005fd8": "convert_string_to_ulong_00005fd8"
            },
            "code": "unsigned long convert_string_to_ulong_00005fd8(char *str, char **endptr, int base) {\n                      unsigned long result = strtoul(str, endptr, base);\n                      return result;\n                    }",
            "called": [
                "_strtoul_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd8",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "convert_string_to_ulong_00005fd8"
        },
        "FUN_00005e10": {
            "renaming": {
                "FUN_00005e10": "read_from_stream_00005e10",
                "param_1": "file_descriptor",
                "param_2": "stream_buffer_ptr",
                "iVar1": "refill_result",
                "uVar2": "read_byte",
                "pbVar3": "stream_buffer",
                "PTR___sf_fake_stdin_00005e5c": "original_stdin_ptr",
                "PTR___sf_fake_stdout_00005e60": "original_stdout_ptr",
                "PTR___sf_fake_stderr_00005e64": "original_stderr_ptr"
            },
            "code": "uint read_from_stream_00005e10(int file_descriptor, byte **stream_buffer_ptr) {\n  int refill_result;\n  uint read_byte;\n  byte *stream_buffer;\n  if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_buffer_ptr == (byte **)PTR___sf_fake_stdin_00005e5c) {\n    stream_buffer_ptr = *(byte ***)(file_descriptor + 4);\n  }\n  else if (stream_buffer_ptr == (byte **)PTR___sf_fake_stdout_00005e60) {\n    stream_buffer_ptr = *(byte ***)(file_descriptor + 8);\n  }\n  else if (stream_buffer_ptr == (byte **)PTR___sf_fake_stderr_00005e64) {\n    stream_buffer_ptr = *(byte ***)(file_descriptor + 0xc);\n  }\n  refill_result = __srefill_r(file_descriptor, stream_buffer_ptr);\n  if (refill_result == 0) {\n    stream_buffer_ptr[1] = stream_buffer_ptr[1] + -1;\n    stream_buffer = *stream_buffer_ptr;\n    *stream_buffer_ptr = stream_buffer + 1;\n    read_byte = (uint)*stream_buffer;\n  }\n  else {\n    read_byte = 0xffffffff;\n  }\n  return read_byte;\n}",
            "called": [
                "__srefill_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e10",
            "calling": [
                "_getc_r"
            ],
            "imported": false,
            "current_name": "read_from_stream_00005e10"
        },
        "FUN_000033f4": {
            "renaming": {
                "FUN_000033f4": "set_alarm_if_valid_time_000033f4",
                "argv": "arguments",
                "iVar1": "is_valid_time",
                "now": "current_time",
                "rtc_set_alarm": "rtc_set_alarm",
                "DAT_0000343c": "DAT_0000343c",
                "PTR_s_rtc__error_setting_alarm_00003440": "PTR_s_rtc__error_setting_alarm_00003440"
            },
            "code": "int set_alarm_if_valid_time_000033f4(char **arguments)\n{\n  int is_valid_time;\n  tm current_time;\n  is_valid_time = parse_time(arguments, &current_time);\n  if (is_valid_time == 0) {\n    int alarm_set_result = rtc_set_alarm(&current_time, DAT_0000343c, (void *)0x0);\n    if (alarm_set_result == -1) {\n      puts(PTR_s_rtc__error_setting_alarm_00003440);\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n  else {\n    return 1;\n  }\n}",
            "called": [
                "_parse_time",
                "puts",
                "rtc_set_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033f4",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "set_alarm_if_valid_time_000033f4"
        },
        "FUN_0000443c": {
            "renaming": {
                "FUN_0000443c": "convert_time_0000443c",
                "__timer": "time",
                "__tp": "time_struct",
                "iVar1": "quotient",
                "uVar2": "remainder1",
                "uVar3": "days",
                "uVar4": "weekday_offset",
                "iVar5": "adjusted_days",
                "uVar6": "year",
                "uVar9": "month",
                "bVar10": "is_negative",
                "tVar7": "time[0]",
                "tVar8": "time[1]",
                "DAT_0000458c": "3600 * 24",
                "DAT_00004590": "365",
                "DAT_00004594": "1900",
                "DAT_00004598": "100"
            },
            "code": "tm* convert_time_0000443c(time_t* time, tm* time_struct)\n{\n    int quotient;\n    uint remainder1;\n    uint remainder2;\n    uint days;\n    int weekday_offset;\n    uint adjusted_days;\n    uint year;\n    uint month;\n    uint day;\n    uint leap_years;\n    uint century_years;\n    uint year_within_century;\n    uint leap_year_adjustment;\n    uint days_since_jan_1st;\n\n    quotient = __aeabi_ldivmod(*time, time[1], PTR_DAT_0000458c, 0);\n    remainder1 = PTR_DAT_0000458c;\n    __aeabi_ldivmod(*time, time[1], PTR_DAT_0000458c, 0);\n    bool is_negative = (int)remainder1 < 0;\n    if (is_negative) {\n        remainder1 += 0x15180;\n        quotient += 0xafa6b;\n    }\n    else {\n        quotient += 0xafa6c;\n    }\n    time_struct->tm_hour = remainder1 / 0xe10;\n    time_struct->tm_min = (remainder1 % 0xe10) / 0x3c;\n    time_struct->tm_sec = (remainder1 % 0xe10) % 0x3c;\n    weekday_offset = (quotient + 3) % 7;\n    adjusted_days = quotient;\n    if ((int)quotient < 0) {\n        adjusted_days = quotient - 0x23ab0;\n    }\n    year = PTR_DAT_00004594 * (adjusted_days / PTR_DAT_00004590) + quotient;\n    leap_years = year / 4 - year / DAT_00004598 + year / 400;\n    century_years = year / DAT_00004598;\n    year_within_century = year % DAT_00004598;\n    leap_year_adjustment = 0;\n    if (year_within_century == 0) {\n        if (century_years % 4 == 0) {\n            leap_year_adjustment = 1;\n        }\n    }\n    else if (year_within_century % 4 == 0) {\n        leap_year_adjustment = 1;\n    }\n    days_since_jan_1st = adjusted_days - (leap_years - century_years + year_within_century) + leap_year_adjustment;\n    month = (days_since_jan_1st * 5 + 2) / 153;\n    day = days_since_jan_1st - (month * 153 + 2) / 5 + 1;\n    if (month >= 10) {\n        month -= 10;\n    }\n    else {\n        month += 2;\n    }\n    time_struct->tm_yday = days_since_jan_1st;\n    time_struct->tm_mday = day;\n    time_struct->tm_mon = month;\n    time_struct->tm_year = year - DAT_00004594;\n    time_struct->tm_isdst = 0;\n    return time_struct;\n}",
            "called": [
                "__aeabi_ldivmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000443c",
            "calling": [
                "rtc_get_alarm",
                "rtc_get_time"
            ],
            "imported": false,
            "current_name": "convert_time_0000443c"
        },
        "FUN_000027b0": {
            "renaming": {
                "FUN_000027b0": "initialize_RTC_and_power_on_000027b0",
                "puVar1": "rtc_data_ptr",
                "rtt": "rtc_instance_ptr",
                "DAT_00002814": "PTR_RTC_DATA",
                "DAT_00002818": "PTR_RTC_CTRL_ADDR",
                "uint": "uint32_t"
            },
            "code": "void initialize_RTC_and_power_on_000027b0(void)\n{\n    uint32_t *rtc_data_ptr;\n    RTC_Type *rtc_instance_ptr;\n\n    rtc_data_ptr = DAT_00002814;\n    *(uint32_t *)(DAT_00002818 + 0x103c) |= 0x20000000;\n    rtc_data_ptr[4] = 1;\n    rtc_data_ptr[4] = 0;\n    if ((rtc_data_ptr[5] & 1) != 0) {\n        *rtc_data_ptr = 0;\n    }\n    rtc_data_ptr[4] = 0x104;\n    rtc_data_ptr[2] = 0xffffff42;\n    rtc_data_ptr[7] = 0;\n    rtc_instance_ptr = get_RTC_instance();\n    power_on_RTC(rtc_instance_ptr);\n    return;\n}",
            "called": [
                "rtt_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000027b0",
            "calling": [
                "rtc_init"
            ],
            "imported": false,
            "current_name": "initialize_RTC_and_power_on_000027b0"
        },
        "FUN_00005ebc": {
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "current_character",
                "pcVar2": "destination_pointer"
            },
            "code": "char* copy_string_00005ebc(char* destination, char* source) {\n  char current_character;\n  char* destination_pointer = destination;\n  do {\n    current_character = *source;\n    *destination_pointer = current_character;\n    source++;\n    destination_pointer++;\n  } while (current_character != '\\0');\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ebc",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "copy_string_00005ebc"
        },
        "FUN_00006192": {
            "renaming": {
                "FUN_00006192": "freeMemoryBlock_00006192",
                "param_1": "size",
                "param_2": "heapStart",
                "heapStart[13]": "nextBlock",
                "heapStart + 17": "nextBlock + 16",
                "_free_r": "free",
                "heapStart[1]": "heapStart[1]",
                "heapStart[16]": "nextBlock",
                "*heapStart": "*heapStart",
                "heapStart[15]": "heapStart[14]",
                "heapStart[4]": "heapStart[4]",
                "*(unsigned short *)(heapStart + 3)": "*(unsigned short *)(heapStart + 3)"
            },
            "code": "unsigned int freeMemoryBlock_00006192(unsigned int size, unsigned int *heapStart) {\n  unsigned int *nextBlock = (unsigned int *)heapStart[13];\n  if (nextBlock != NULL) {\n    if (nextBlock != heapStart + 17) {\n      free(nextBlock);\n    }\n    heapStart[1] = heapStart[16];\n    heapStart[13] = NULL;\n    if (heapStart[16] != 0) {\n      *heapStart = heapStart[15];\n      return 0;\n    }\n  }\n  *heapStart = heapStart[4];\n  heapStart[1] = 0;\n  *(unsigned short *)(heapStart + 3) |= 0x20;\n  return 0xffffffff;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006192",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "freeMemoryBlock_00006192"
        },
        "FUN_00001734": {
            "renaming": {
                "FUN_00001734": "clear_bit_at_position_six_00001734",
                "DAT_00001744": "data_register",
                "'\\x06'": "BIT_POSITION_SIX"
            },
            "code": "void clear_bit_at_position_six_00001734(void)\n{\n  bit_clear8(DAT_00001744, BIT_POSITION_SIX);\n  return;\n}",
            "called": [
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001734",
            "calling": [
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi"
            ],
            "imported": false,
            "current_name": "clear_bit_at_position_six_00001734"
        },
        "FUN_00000e14": {
            "renaming": {
                "FUN_00000e14": "read_isr_pipe_00000e14",
                "count": "bytes_to_read",
                "buffer": "read_buffer",
                "iVar1": "bytes_read"
            },
            "code": "int read_isr_pipe_00000e14(char *buffer, int count)\n{\n  int bytes_read = isrpipe_read((isrpipe_t *)PTR_uart_stdio_isrpipe_00000e34, buffer, count);\n  return bytes_read;\n}",
            "called": [
                "isrpipe_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e14",
            "calling": [
                "_read_r"
            ],
            "imported": false,
            "current_name": "read_isr_pipe_00000e14"
        },
        "FUN_0000281c": {
            "renaming": {
                "FUN_0000281c": "read_RTC_value_0000281c",
                "rtt": "rtc_type_ptr",
                "i": "loop_counter",
                "t": "rtc_value"
            },
            "code": "uint32_t read_RTC_value_0000281c(void)\n{\n  RTC_Type *rtc_type_ptr;\n  int loop_counter = 0;\n  uint32_t rtc_value;\n  while ((loop_counter < 3 && (rtc_value = *DAT_00002858, rtc_value != *DAT_00002858))) {\n    loop_counter++;\n  }\n  return rtc_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000281c",
            "calling": [
                "rtc_get_time"
            ],
            "imported": false,
            "current_name": "read_RTC_value_0000281c"
        },
        "FUN_00002270": {
            "renaming": {
                "FUN_00002270": "get_write_status_00002270",
                "rb": "ring_buffer",
                "uVar2": "num_writes",
                "bVar3": "is_read_equal_to_write",
                "bVar1": "write_status"
            },
            "code": "uint32_t get_write_status_00002270(tsrb_t *ring_buffer) {\n    uint32_t num_writes = ring_buffer->writes;\n    bool is_read_equal_to_write = (ring_buffer->reads == num_writes);\n    uint8_t write_status = is_read_equal_to_write ? 1 : 0;\n    return (uint32_t)write_status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002270",
            "calling": [
                "tsrb_get"
            ],
            "imported": false,
            "current_name": "get_write_status_00002270"
        },
        "FUN_00005780": {
            "renaming": {
                "FUN_00005780": "call_function_with_ptr_00005780",
                "__ptr": "data_ptr",
                "_FUN_00005780_r": "function_with_ptr"
            },
            "code": "void call_function_with_ptr_00005780(void *data_ptr)\n{\n  function_with_ptr(*(undefined4 *)PTR__impure_ptr_0000578c, data_ptr);\n  return;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005780",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "call_function_with_ptr_00005780"
        },
        "FUN_000020cc": {
            "renaming": {
                "FUN_000020cc": "handle_irq_000020cc",
                "DAT_000020dc": "data"
            },
            "code": "void handle_irq_000020cc(void)\n{\n  irq_handler(DAT_000020dc, 1);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020cc",
            "calling": [],
            "imported": false,
            "current_name": "handle_irq_000020cc"
        },
        "FUN_00002396": {
            "renaming": {
                "FUN_00002396": "initialize_rtc_00002396",
                "rtc_init": "rtc_initialize"
            },
            "code": "void initialize_rtc_00002396(void)\n{\n  rtc_init();\n  return;\n}",
            "called": [
                "rtc_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002396",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initialize_rtc_00002396"
        },
        "FUN_00004e4a": {
            "renaming": {
                "<original_function_name>": "FUN_00004e4a",
                "param_1": "reent_ptr",
                "param_2": "file_descriptor",
                "*param_1": "*reent_ptr",
                "*(short *)(param_2 + 0xe)": "file_mode",
                "FUN_00004e4a": "close_file_00004e4a"
            },
            "code": "void close_file_00004e4a(_reent *reent_ptr, int file_descriptor){\n                     int file_mode = *(short *)(file_descriptor + 0xe);\n                     _close_r(reent_ptr, file_mode);\n                   }",
            "called": [
                "_close_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e4a",
            "calling": [],
            "imported": false,
            "current_name": "close_file_00004e4a"
        },
        "FUN_00004cb4": {
            "renaming": {
                "FUN_00004cb4": "put_char_00004cb4",
                "__c": "character",
                "PTR__impure_ptr_00004cd8": "impure_ptr"
            },
            "code": "int put_char_00004cb4(int character)\n{\n  undefined4 in_r3;\n  int PTR__impure_ptr_00004cd8 = *(int *)PTR__PTR__impure_ptr_00004cd8_00004cd8;\n  if ((PTR__impure_ptr_00004cd8 != 0) && (*(int *)(PTR__impure_ptr_00004cd8 + 0x18) == 0)) {\n    __sinit(PTR__impure_ptr_00004cd8);\n  }\n  int result = _putc_r(PTR__impure_ptr_00004cd8, character, *(undefined4 *)(PTR__impure_ptr_00004cd8 + 8), in_r3);\n  return result;\n}",
            "called": [
                "_putc_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cb4",
            "calling": [
                "_putchar"
            ],
            "imported": false,
            "current_name": "put_char_00004cb4"
        },
        "FUN_00003478": {
            "renaming": {
                "FUN_00003478": "set_rtc_time_00003478",
                "argv": "arguments",
                "iVar1": "parse_result",
                "now": "current_time"
            },
            "code": "int set_rtc_time_00003478(char **arguments)\n{\n    int parse_result;\n    tm current_time;\n    parse_result = parse_time(arguments, &current_time);\n    if (parse_result == 0) {\n        int set_time_result = rtc_set_time(&current_time);\n        if (set_time_result == -1) {\n            puts(PTR_s_rtc__error_setting_time_000034bc);\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    else {\n        return 1;\n    }\n}",
            "called": [
                "rtc_set_time",
                "_parse_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003478",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "set_rtc_time_00003478"
        },
        "FUN_00002028": {
            "renaming": {
                "FUN_00002028": "handle_interrupts_00002028",
                "port_num": "port_number",
                "iVar1": "context_index",
                "uVar2": "interrupt_status",
                "ctx": "pin_mask",
                "status": "interrupt_status",
                "i": "index",
                "PTR_isr_ctx_000020b4": "isr_context_ptr"
            },
            "code": "void handle_interrupts_00002028(PORT_Type *port, int port_number) {\n  int context_index;\n  uint32_t interrupt_status;\n  uint32_t pin_mask;\n  int i;\n  interrupt_status = port->ISFR;\n  for (i = 0; i < 0x20; i++) {\n    pin_mask = 1 << (i & 0xffU);\n    if ((interrupt_status & pin_mask) && ((port->PCR[i] & 0xf0000) != 0)) {\n      port->ISFR = pin_mask;\n      context_index = get_interrupt_context_index(port_number, i);\n      (**(code **)(PTR_isr_ctx_000020b4 + context_index * 0xc))(*(undefined4 *)(PTR_isr_ctx_000020b4 + context_index * 0xc + 4));\n    }\n  }\n  end_interrupt_handler();\n}\n",
            "called": [
                "cortexm_isr_end",
                "get_ctx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002028",
            "calling": [
                "isr_porte",
                "isr_portd",
                "isr_portb",
                "isr_portc",
                "isr_porta"
            ],
            "imported": false,
            "current_name": "handle_interrupts_00002028"
        },
        "FUN_000016c8": {
            "renaming": {
                "FUN_000016c8": "set_bit_at_position_000016c8",
                "ptr": "data",
                "bit": "position",
                "puVar1": "bit_address"
            },
            "code": "void set_bit_at_position_000016c8(uint32_t *data, uint8_t position) {\n  undefined4 *bit_address = (undefined4 *)bitband_addr(data, (uint)position);\n  *bit_address = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016c8",
            "calling": [
                "kinetis_mcg_init_erclk32k"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_000016c8"
        },
        "FUN_00001a60": {
            "renaming": {
                "FUN_00001a60": "initialize_mode_00001a60",
                "bit_clear8": "clear_bit",
                "DAT_00001ac4": "data_1",
                "DAT_00001ac8": "data_2",
                "bit_set8": "set_bit",
                "DAT_00001acc": "data_3",
                "PTR_current_mode_00001ad0": "current_mode"
            },
            "code": "void initialize_mode_00001a60(void)\n{\n  clear_bit(DAT_00001ac4, 1);\n  *DAT_00001ac8 = (*DAT_00001ac8 & 0x3f) | 0x80;\n  while ((DAT_00001ac8[6] & 0xc) != 8);\n  set_bit(DAT_00001acc, 6);\n  while ((DAT_00001ac8[6] & 0x20) == 0);\n  while ((DAT_00001ac8[6] & 0x40) == 0);\n  *PTR_PTR_current_mode_00001ad0_00001ad0 = 6;\n  return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a60",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "initialize_mode_00001a60"
        },
        "FUN_000004b2": {
            "renaming": {
                "FUN_000004b2": "write_to_uart_000004b2",
                "r": "reent",
                "fd": "file_descriptor",
                "data": "data_buffer",
                "count": "data_size",
                "iVar1": "write_result"
            },
            "code": "_ssize_t write_to_uart_000004b2(_reent *reent, int file_descriptor, void *data_buffer, size_t data_size) {\n  int write_result;\n  \n  write_result = uart_stdio_write((char *)data_buffer, data_size);\n  return write_result;\n}",
            "called": [
                "uart_stdio_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004b2",
            "calling": [
                "__swrite"
            ],
            "imported": false,
            "current_name": "write_to_uart_000004b2"
        },
        "FUN_0000099c": {
            "renaming": {
                "FUN_0000099c": "initialize_system_0000099c",
                "uStack_18": "stack_limit",
                "top": "stack_top",
                "src": "etext",
                "pre_startup": "pre_startup",
                "dst": "isr_stack",
                "DAT_00000a1c": "isr_stack_init_value",
                "heap_top_00000a20": "heap_top",
                "sched_num_threads_00000a24": "sched_num_threads",
                "post_startup": "post_startup",
                "board_init": "board_init",
                "__libc_init_array": "__libc_init_array",
                "kernel_init": "kernel_init"
            },
            "code": "void initialize_system_0000099c(void)\n{\n  uint32_t stack_limit;\n  uint32_t *stack_top;\n  uint32_t *src;\n  uint32_t *dst;\n  \n  stack_top = &stack_limit;\n  src = (uint32_t *)etext;\n  pre_startup();\n  dst = (uint32_t *)isr_stack;\n  while (dst < &stack_limit) {\n    *dst = DAT_00000a1c;\n    dst++;\n  }\n  dst = (uint32_t *)heap_top;\n  while (dst < sched_num_threads) {\n    *dst = *src;\n    src++;\n    dst++;\n  }\n  dst = (uint32_t *)sched_num_threads;\n  while (dst < sheap) {\n    *dst = 0;\n    dst++;\n  }\n  post_startup();\n  board_init();\n  __libc_init_array();\n  kernel_init();\n  return;\n}",
            "called": [
                "pre_startup",
                "board_init",
                "post_startup",
                "kernel_init",
                "__libc_init_array"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000099c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_system_0000099c"
        },
        "FUN_00002d94": {
            "renaming": {
                "FUN_00002d94": "read_line_00002d94",
                "buf": "buffer",
                "size": "size",
                "c_00": "character",
                "bVar1": "byte_var",
                "bVar2": "bool_var",
                "c": "counter",
                "line_buf_ptr": "buffer_ptr",
                "_putchar": "putchar",
                "uint": "unsigned int"
            },
            "code": "int read_line_00002d94(char *buffer, size_t size) {\n  int character;\n  byte byte_var;\n  bool bool_var;\n  int counter;\n  char *buffer_ptr;\n\n  buffer_ptr = buffer;\n  while (true) {\n    if ((int)(size - 1) <= (int)buffer_ptr - (int)buffer) {\n      return -1;\n    }\n    character = getchar();\n    if (character < 0) break;\n    if ((character == 0xd) || (character == 10)) {\n      *buffer_ptr = '\\0';\n      putchar(0xd);\n      putchar(10);\n      bool_var = buffer_ptr == buffer;\n      if (bool_var) {\n        buffer = (char *)0x1;\n      }\n      byte_var = (byte)buffer;\n      if (!bool_var) {\n        byte_var = 0;\n      }\n      return (uint)byte_var;\n    }\n    if ((character == 8) || (character == 0x7f)) {\n      if (buffer_ptr != buffer) {\n        buffer_ptr = buffer_ptr + -1;\n        *buffer_ptr = '\\0';\n        putchar(8);\n        putchar(0x20);\n        putchar(8);\n      }\n    }\n    else {\n      *buffer_ptr = (char)character;\n      putchar(character);\n      buffer_ptr = buffer_ptr + 1;\n    }\n  }\n  return 1;\n}",
            "called": [
                "getchar",
                "_putchar"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002d94",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "read_line_00002d94"
        },
        "FUN_00003918": {
            "renaming": {
                "FUN_00003918": "scale_to_prefix_00003918",
                "scale": "scale",
                "cVar1": "prefix"
            },
            "code": "char scale_to_prefix_00003918(int8_t scale)\n{\n  char prefix;\n  switch(scale) {\n  case 2:\n    prefix = 'h';\n    break;\n  case 3:\n    prefix = 'k';\n    break;\n  case 6:\n    prefix = 'M';\n    break;\n  case 9:\n    prefix = 'G';\n    break;\n  case 12:\n    prefix = 'T';\n    break;\n  case 15:\n    prefix = 'P';\n    break;\n  case -15:\n    prefix = 'f';\n    break;\n  case -12:\n    prefix = 'p';\n    break;\n  case -9:\n    prefix = 'n';\n    break;\n  case -6:\n    prefix = 'u';\n    break;\n  case -3:\n    prefix = 'm';\n    break;\n  default:\n    prefix = '\\0';\n    break;\n  }\n  return prefix;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003918",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "scale_to_prefix_00003918"
        },
        "FUN_00003d64": {
            "renaming": {
                "FUN_00003d64": "read_sensor_data_00003d64",
                "dev": "sensor",
                "res": "data",
                "iVar1": "result"
            },
            "code": "int read_sensor_data_00003d64(saul_reg_t *sensor, phydat_t *data) {\n  int result;\n  if (sensor == NULL) {\n    result = -19;\n  }\n  else {\n    result = (*sensor->driver->read)(sensor->dev, data);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d64",
            "calling": [
                "probe"
            ],
            "imported": false,
            "current_name": "read_sensor_data_00003d64"
        },
        "FUN_00004e52": {
            "renaming": {
                "FUN_00004e52": "compare_strings_00004e52",
                "__s1": "str1",
                "__s2": "str2",
                "bVar1": "char1",
                "uVar2": "char2",
                "bVar3": "is_equal"
            },
            "code": "int compare_strings_00004e52(char* str1, char* str2) {\\n    int result;\\n    while (*str1 != \"\\0\" && *str2 != \"\\0\") {\\n        if (*str1 != *str2) {\\n            result = *str1 - *str2;\\n            break;\\n        }\\n        str1++;\\n        str2++;\\n    }\\n    result = *str1 - *str2;\\n    return result;\\n}",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e52",
            "calling": [
                "_tzset_unlocked_r",
                "read",
                "find_handler",
                "strcmp",
                "_saul",
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e52"
        },
        "FUN_000010d4": {
            "renaming": {
                "FUN_000010d4": "create_thread_000010d4",
                "stack": "stack_start",
                "stacksize": "stack_size",
                "priority": "priority",
                "flags": "flags",
                "function": "function",
                "arg": "arg",
                "name": "name",
                "state_00": "state",
                "pcVar1": "stack_pointer",
                "stack_size": "aligned_stack_size",
                "process": "thread",
                "local_30": "total_stack_size",
                "local_2c": "stack_pointer",
                "stackp": "stack_pointer",
                "i": "pid"
            },
            "code": "kernel_pid_t create_thread_000010d4(char *stack, int stack_size, char priority, int flags, thread_task_func_t function, void *arg, char *name) {\n  uint state;\n  char *stack_aligned;\n  uint aligned_stack_size;\n  thread_t *thread;\n  uintptr_t *stack_max;\n  uintptr_t misalignment;\n  int total_stack_size;\n  uintptr_t *stack_pointer;\n  kernel_pid_t pid;\n  \n  if ((byte)priority >= 0x10) {\n    return -0x16;\n  }\n  \n  stack_aligned = (char *)ALIGN_BACKWARD(stack, 4);\n  misalignment = (uintptr_t)stack - (uintptr_t)stack_aligned;\n  aligned_stack_size = stack_size - misalignment;\n  thread = (thread_t *)(stack_aligned + aligned_stack_size - sizeof(thread_t));\n  \n  if ((flags & 8U) == 0) {\n    *stack_aligned = (uintptr_t)stack_aligned;\n  }\n  else {\n    for (stack_pointer = (uintptr_t *)stack_aligned; stack_pointer < (uintptr_t *)(stack_aligned + aligned_stack_size); stack_pointer++) {\n      *stack_pointer = (uintptr_t)stack_pointer;\n    }\n  }\n  \n  state = irq_disable();\n  pid = 0;\n  for (kernel_pid_t i = 1; i < 0x21; i++) {\n    if (*(int *)(PTR_sched_threads_0000126c + i * 4) == 0) {\n      pid = i;\n      break;\n    }\n  }\n  \n  if (pid == 0) {\n    irq_restore(state);\n    return -0x8b;\n  }\n  \n  *(thread_t **)(PTR_sched_threads_0000126c + pid * 4) = thread;\n  thread->pid = pid;\n  thread->stack_start = stack_aligned;\n  thread->stack_size = stack_size;\n  thread->name = name;\n  thread->priority = priority;\n  thread->status = THREAD_STATUS_PENDING;\n  (thread->rq_entry).next = NULL;\n  thread->wait_data = NULL;\n  (thread->msg_waiters).next = NULL;\n  cib_init(&thread->msg_queue, 0);\n  thread->msg_array = NULL;\n  *(int *)PTR_sched_num_threads_00001270 = *(int *)PTR_sched_num_threads_00001270 + 1;\n  \n  if ((flags & THREAD_CREATE_FLAG_SUSPENDED) == 0) {\n    thread_set_status(thread, THREAD_STATUS_RUNNING);\n    if ((flags & THREAD_CREATE_FLAG_WOUT_YIELD) == 0) {\n      irq_restore(state);\n      sched_switch((ushort)(byte)priority);\n    }\n  }\n  else {\n    thread_set_status(thread, THREAD_STATUS_SUSPENDED);\n  }\n  \n  irq_restore(state);\n  return pid;\n}",
            "called": [
                "irq_disable",
                "thread_stack_init",
                "cib_init",
                "irq_restore",
                "sched_set_status",
                "sched_switch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010d4",
            "calling": [
                "kernel_init"
            ],
            "imported": false,
            "current_name": "create_thread_000010d4"
        },
        "FUN_000045e4": {
            "renaming": {
                "FUN_000045e4": "do_nothing_000045e4"
            },
            "code": "\nvoid do_nothing_000045e4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e4",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e4"
        },
        "FUN_00000738": {
            "renaming": {
                "FUN_00000738": "check_thread_priority_00000738",
                "other_prio": "other_priority",
                "iVar1": "is_irq",
                "current_prio": "current_priority",
                "active_thread": "active_thread",
                "on_runqueue": "is_on_runqueue"
            },
            "code": "void check_thread_priority_00000738(uint16_t other_priority) {\n  int is_irq;\n  uint16_t current_priority;\n  thread_t *active_thread;\n  int is_on_runqueue;\n  \n  active_thread = *(thread_t **)PTR_sched_active_thread_0000078c;\n  current_priority = *(byte *)(active_thread + 4);\n  \n  if (current_priority < 9 || other_priority < *(byte *)(active_thread + 5)) {\n    is_irq = irq_is_in();\n    if (is_irq == 0) {\n      thread_yield_higher();\n    }\n    else {\n      *(undefined4 *)PTR_sched_context_switch_request_00000790 = 1;\n    }\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher",
                "irq_is_in"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000738",
            "calling": [
                "thread_create",
                "mutex_unlock"
            ],
            "imported": false,
            "current_name": "check_thread_priority_00000738"
        },
        "FUN_000045e6": {
            "renaming": {
                "FUN_000045e6": "do_nothing_000045e6"
            },
            "code": "\nvoid do_nothing_000045e6(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e6",
            "calling": [
                "__tz_lock"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e6"
        },
        "FUN_00003e58": {
            "renaming": {
                "FUN_00003e58": "convert_int_to_string_00003e58",
                "out": "output_string",
                "val": "input_value",
                "local_18": "absolute_value",
                "local_14": "current_position",
                "negative": "is_negative",
                "sVar1": "string_length"
            },
            "code": "size_t convert_int_to_string_00003e58(char *output_string, int32_t input_value) {\n  size_t string_length;\n  uint32_t absolute_value;\n  char *current_position;\n  uint is_negative = 0;\n  absolute_value = input_value;\n  current_position = output_string;\n  if (input_value < 0) {\n    if (output_string != NULL) {\n      current_position = output_string + 1;\n      *output_string = '-';\n    }\n    absolute_value = -input_value;\n    is_negative = 1;\n  }\n  string_length = fmt_u32_dec(current_position, absolute_value);\n  if (is_negative) {\n    string_length++;\n  }\n  return string_length;\n}",
            "called": [
                "fmt_u32_dec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e58",
            "calling": [
                "fmt_s32_dfp"
            ],
            "imported": false,
            "current_name": "convert_int_to_string_00003e58"
        },
        "FUN_00004e26": {
            "renaming": {
                "FUN_00004e26": "seek_file_00004e26",
                "param_1": "reentrant",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "file_offset",
                "uVar2": "flags",
                "bVar3": "error_flag"
            },
            "code": "void seek_file_00004e26(_reent *reentrant,int file_descriptor,_off_t offset,int whence)\n{\n  _off_t file_offset;\n  ushort flags;\n  bool error_flag;\n  file_offset = _lseek_r(reentrant,(int)*(short *)(file_descriptor + 0xe),offset,whence);\n  error_flag = file_offset == -1;\n  if (error_flag) {\n    flags = *(ushort *)(file_descriptor + 0xc) & 0xefff;\n  }\n  else {\n    *(_off_t *)(file_descriptor + 0x54) = file_offset;\n    flags = *(ushort *)(file_descriptor + 0xc) | 0x1000;\n  }\n  if (error_flag) {\n    *(ushort *)(file_descriptor + 0xc) = flags;\n  }\n  if (!error_flag) {\n    *(ushort *)(file_descriptor + 0xc) = flags;\n  }\n  return;\n}",
            "called": [
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e26",
            "calling": [],
            "imported": false,
            "current_name": "seek_file_00004e26"
        },
        "FUN_00000978": {
            "renaming": {
                "FUN_00000978": "run_active_thread_00000978",
                "bVar1": "is_privileged_mode",
                "UNRECOVERED_JUMPTABLE": "jump_table",
                "ppcVar2": "process_stack_pointer",
                "PTR_sched_active_thread_0000098c": "active_thread_ptr"
            },
            "code": "void run_active_thread_00000978(void)\n{\n  bool is_privileged_mode;\n  code *jump_table;\n  code **process_stack_pointer;\n  \n  jump_table = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  process_stack_pointer = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    setProcessStackPointer(process_stack_pointer);\n  }\n  /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n  /* WARNING: Treating indirect jump as call */\n  (*jump_table)(jump_table,process_stack_pointer);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000978",
            "calling": [],
            "imported": false,
            "current_name": "run_active_thread_00000978"
        },
        "FUN_000045e8": {
            "renaming": {
                "FUN_000045e8": "do_nothing_000045e8"
            },
            "code": "\nvoid do_nothing_000045e8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e8",
            "calling": [
                "_puts_r",
                "__sinit_lock_acquire",
                "_fflush_r",
                "_vfprintf_r",
                "__sfp_lock_acquire",
                "_putc_r",
                "__malloc_lock",
                "__env_lock",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e8"
        },
        "FUN_000057f8": {
            "renaming": {
                "FUN_000057f8": "FUNC_000057f8"
            },
            "code": "\nint FUNC_000057f8(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  int iVar4;\n  int iVar5;\n  void *pvVar6;\n  int *piVar7;\n  byte *pbVar8;\n  int unaff_r7;\n  byte *pbVar9;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 uStack_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == PTR___sf_fake_stdin_00005a38) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR___sf_fake_stdout_00005a3c) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR___sf_fake_stderr_00005a40) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n    __retarget_lock_acquire_recursive(*(undefined4 *)(param_2 + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar4 = __swsetup_r(param_1,param_2), iVar4 != 0)) {\n    if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n      __retarget_lock_release_recursive(*(undefined4 *)(param_2 + 0x58));\n    }\n    return -1;\n  }\n  puVar2 = PTR_s___0__00005a44;\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar9 = param_3;\n  local_8c = param_4;\nLAB_0000588e:\n  pbVar8 = pbVar9;\n  if (*pbVar8 != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  pbVar9 = pbVar8 + 1;\n  if (*pbVar8 != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  iVar4 = (int)pbVar8 - (int)param_3;\n  if (iVar4 != 0) {\n    iVar5 = __sfputs_r(param_1,param_2,param_3,iVar4);\n    if (iVar5 == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n        __retarget_lock_release_recursive(*(undefined4 *)(param_2 + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar4;\n  }\n  if (*pbVar8 == 0) goto LAB_00005a06;\n  local_84 = -1;\n  uStack_80 = 0;\n  local_88 = 0;\n  local_7c = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar9 = pbVar8 + 1;\n  while( true ) {\n    pbVar8 = pbVar9 + 1;\n    pvVar6 = memchr(PTR_s___0__00005a44,(uint)*pbVar9,5);\n    puVar3 = PTR_DAT_00005a54;\n    if (pvVar6 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar6 - (int)puVar2 & 0xffU) | local_88;\n    pbVar9 = pbVar8;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar9 == 0x2a) {\n    piVar7 = local_8c + 1;\n    local_7c = *local_8c;\n    local_8c = piVar7;\n    if (local_7c < 0) {\n      local_7c = -local_7c;\n      local_88 = local_88 | 2;\n    }\n  }\n  else {\n    bVar1 = false;\n    iVar4 = local_7c;\n    pbVar8 = pbVar9;\n    while( true ) {\n      if (9 < *pbVar8 - 0x30) break;\n      iVar4 = iVar4 * 10 + (*pbVar8 - 0x30);\n      bVar1 = true;\n      pbVar8 = pbVar8 + 1;\n    }\n    if (bVar1) {\n      local_7c = iVar4;\n    }\n  }\n  if (*pbVar8 == 0x2e) {\n    if (pbVar8[1] == 0x2a) {\n      local_84 = *local_8c;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n      pbVar8 = pbVar8 + 2;\n      local_8c = local_8c + 1;\n    }\n    else {\n      bVar1 = false;\n      local_84 = 0;\n      iVar4 = 0;\n      while( true ) {\n        pbVar8 = pbVar8 + 1;\n        if (9 < *pbVar8 - 0x30) break;\n        iVar4 = iVar4 * 10 + (*pbVar8 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar4;\n      }\n    }\n  }\n  pvVar6 = memchr(PTR_DAT_00005a54,(uint)*pbVar8,3);\n  if (pvVar6 != (void *)0x0) {\n    local_88 = local_88 | 0x40 << ((int)pvVar6 - (int)puVar3 & 0xffU);\n    pbVar8 = pbVar8 + 1;\n  }\n  param_3 = pbVar8 + 1;\n  local_70 = *pbVar8;\n  pvVar6 = memchr(PTR_s_efgEFG_00005a48,(uint)local_70,6);\n  if (pvVar6 == (void *)0x0) {\n    iVar4 = _printf_i(param_1,&local_88,param_2,DAT_00005a50,&local_8c);\n  }\n  else {\n    iVar4 = param_1;\n    if (DAT_00005a4c == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar4 = unaff_r7;\n      goto LAB_000059b4;\n    }\n  }\n  if (iVar4 == -1) goto LAB_00005a06;\nLAB_000059b4:\n  local_74 = local_74 + iVar4;\n  pbVar9 = param_3;\n  unaff_r7 = iVar4;\n  goto LAB_0000588e;\n}\n\n",
            "called": [
                "__sfputs_r",
                "__retarget_lock_acquire_recursive",
                "__swsetup_r",
                "memchr",
                "__retarget_lock_release_recursive",
                "_printf_i",
                "__sinit"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000057f8",
            "calling": [
                "iprintf"
            ],
            "imported": false,
            "current_name": "FUNC_000057f8"
        },
        "FUN_000018bc": {
            "renaming": {
                "FUN_000018bc": "initialize_system_clock_000018bc",
                "DAT_00001910": "GPIOB_PDOR",
                "DAT_00001914": "bit_mask",
                "PTR_current_mode_00001918": "current_mode"
            },
            "code": "void initialize_system_clock_000018bc(void)\n{\n  set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  *DAT_00001910 = (*DAT_00001910 & 0x3b) | 4;\n  clear_bit8(*DAT_00001910,1);\n  while ((*(DAT_00001910+6) & 0x10) == 0);\n  while ((*(DAT_00001910+6) & 0xc) != 0);\n  *PTR_current_mode_00001918 = 0;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000018bc",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "initialize_system_clock_000018bc"
        },
        "FUN_00000974": {
            "renaming": {
                "FUN_00000974": "run_active_thread_00000974",
                "PTR_sched_active_thread_0000098c": "sched_active_thread",
                "isCurrentModePrivileged": "is_privileged_mode",
                "UNRECOVERED_JUMPTABLE": "active_thread_function",
                "ppcVar2": "active_thread_stack_pointer"
            },
            "code": "void run_active_thread_00000974(void)\n{\n  bool is_privileged_mode;\n  code *active_thread_function;\n  code **active_thread_stack_pointer;\n  \n  sched_run();\n  active_thread_function = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  active_thread_stack_pointer = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    setProcessStackPointer(active_thread_stack_pointer);\n  }\n  (*active_thread_function)(active_thread_function, active_thread_stack_pointer);\n  return;\n}",
            "called": [
                "sched_run"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000974",
            "calling": [
                "isr_pendsv"
            ],
            "imported": false,
            "current_name": "run_active_thread_00000974"
        },
        "FUN_00000f04": {
            "renaming": {
                "FUN_00000f04": "crash_handler_00000f04",
                "crash_code": "code",
                "message": "msg",
                "local_10": "msg",
                "local_9": "code",
                "PTR_crashed_00000f4c": "crashed_flag",
                "PANIC_ASSERT_FAIL": "PANIC_ASSERT_FAIL",
                "cpu_print_last_instruction": "cpu_print_last_instruction",
                "PTR_s_____RIOT_kernel_panic___s_00000f50": "PTR_s_____RIOT_kernel_panic___s_00000f50",
                "ps": "ps",
                "PTR_DAT_00000f54": "PTR_DAT_00000f54",
                "PTR_s_____halted__00000f58": "PTR_s_____halted__00000f58",
                "irq_disable": "irq_disable",
                "panic_arch": "panic_arch",
                "pm_off": "pm_off",
                "auto_init": "auto_init",
                "uStack_14": "stack_14",
                "uStack_18": "stack_18"
            },
            "code": "void crash_handler_00000f04(crash_handler_00000f04_t crash_code, char *message) {\n    int *PTR_crashed_00000f4c = (int *) PTR_crashed_00000f4c;\n    char *msg = message;\n    crash_handler_00000f04_t code = crash_code;\n\n    if (*PTR_crashed_00000f4c == 0) {\n        *PTR_crashed_00000f4c = 1;\n        if (code == PANIC_ASSERT_FAIL) {\n            cpu_print_last_instruction();\n        }\n        iprintf(PTR_s_____RIOT_kernel_panic___s_00000f50, msg);\n        ps();\n        iprintf(PTR_DAT_00000f54);\n        iprintf(PTR_s_____halted__00000f58);\n    }\n\n    irq_disable();\n    panic_arch();\n    int stack_14 = 0xf4d;\n    pm_off();\n    int *stack_18 = (int *)&stack_18 + 1;\n    auto_init();\n    iprintf(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n    main();\n}",
            "called": [
                "irq_disable",
                "ps",
                "iprintf",
                "pm_off",
                "panic_arch",
                "cpu_print_last_instruction"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f04",
            "calling": [
                "thread_add_to_list",
                "bus_fault_default",
                "cib_init",
                "fmt_s32_dfp",
                "uart_init",
                "mem_manage_default",
                "debug_mon_default",
                "hard_fault_handler",
                "dummy_handler_default",
                "nmi_default",
                "usage_fault_default"
            ],
            "imported": false,
            "current_name": "crash_handler_00000f04"
        },
        "FUN_00000610": {
            "renaming": {
                "FUN_00000610": "get_next_thread_to_run_00000610",
                "uVar1": "bit_index",
                "iVar2": "active_thread_id",
                "iVar3": "next_thread_id",
                "active_thread": "active_thread",
                "nextrq": "nextrq",
                "__m____": "runqueue_node",
                "next_thread": "next_thread"
            },
            "code": "int get_next_thread_to_run_00000610(void)\n{\n  uint bit_index;\n  int active_thread_id;\n  int next_thread_id;\n  thread_t *active_thread;\n  int nextrq;\n  clist_node_t *runqueue_node;\n  thread_t *next_thread;\n  \n  *(undefined4 *)sched_context_switch_request = 0;\n  active_thread_id = *(int *)sched_active_thread;\n  bit_index = bitarithm_lsb(*(uint *)runqueue_bitcache);\n  next_thread_id = **(int **)(queues + bit_index * 4);\n  if (active_thread_id == next_thread_id + -8) {\n    active_thread_id = 0;\n  }\n  else {\n    if ((active_thread_id != 0) && (*(char *)(active_thread_id + 4) == '\t')) {\n      *(undefined *)(active_thread_id + 4) = 10;\n    }\n    *(undefined *)(next_thread_id + -4) = 9;\n    *(undefined2 *)sched_active_pid = *(undefined2 *)(next_thread_id + -2);\n    *(int *)sched_active_thread = next_thread_id + -8;\n    active_thread_id = 1;\n  }\n  return active_thread_id;\n}",
            "called": [
                "bitarithm_lsb"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000610",
            "calling": [
                "isr_svc"
            ],
            "imported": false,
            "current_name": "get_next_thread_to_run_00000610"
        },
        "FUN_00003694": {
            "renaming": {
                "FUN_00003694": "display_phydat_data_00003694",
                "data": "phydat_data",
                "dim": "num_dimensions",
                "sVar1": "length",
                "pcVar2": "unit_string",
                "cVar3": "bit_mask",
                "uVar4": "bit_shift",
                "bVar5": "is_unit_valid",
                "num": "num_str",
                "i": "index",
                "PTR_s_Unable_to_display_data_object_000037e4": "Unable to display data object.",
                "PTR_s_Data__000037e8": "Data:\n",
                "PTR_DAT_000037f0": "  [",
                "PTR_s__000037f8": "\n",
                "PTR_s___u__000037f4": "%u:\n",
                "PTR_DAT_00003800": "    %d\n",
                "PTR_PTR_DAT_00003804": "    %s\n",
                "PTR_s__iE_i_00003808": "    %dE%d\n",
                "PTR_s__6d__c_000037fc": "    %d%c\n",
                "PTR_DAT_0000380c": "  %s\n",
                "phydat_t": "phydat_data_t"
            },
            "code": "void display_phydat_data_00003694(phydat_t *data, uint8_t num_dimensions) {PTR_s__000037f8  size_t length;PTR_s__000037f8  char *unit_string;PTR_s__000037f8  char scale_prefix;PTR_s__000037f8  uint8_t i;PTR_s__000037f8  char num_str[8];PTR_s__000037f8  bool is_unit_valid;PTR_s__000037f8  uint8_t bit_shift;PTR_s__000037f8  char bit_mask;PTR_s__000037f8PTR_s__000037f8  if ((data == NULL) || (num_dimensions > 3)) {PTR_s__000037f8    puts(\"PTR_s_Unable_to_display_data_object_000037e4\");PTR_s__000037f8  }PTR_s__000037f8  else {PTR_s__000037f8    iprintf(\"Data:\\n\");PTR_s__000037f8    for (i = 0; i < num_dimensions; i++) {PTR_s__000037f8      is_unit_valid = (data->unit < 20);PTR_s__000037f8      if (is_unit_valid) {PTR_s__000037f8        bit_shift = data->unit;PTR_s__000037f8        bit_mask = (uint8_t)(1 << bit_shift);PTR_s__000037f8        is_unit_valid = (bool)(DAT_000037ec & bit_mask);PTR_s__000037f8      }PTR_s__000037f8      if (is_unit_valid) {PTR_s__000037f8        scale_prefix = 0;PTR_s__000037f8      }PTR_s__000037f8      else {PTR_s__000037f8        scale_prefix = phydat_prefix_from_scale(data->scale);PTR_s__000037f8      }PTR_s__000037f8      iprintf(\"PTR_DAT_000037f0\");PTR_s__000037f8      if (num_dimensions < 2) {PTR_s__000037f8        iprintf(\"\\n\");PTR_s__000037f8      }PTR_s__000037f8      else {PTR_s__000037f8        iprintf(\"%u:\\n\", i);PTR_s__000037f8      }PTR_s__000037f8      if (scale_prefix == 0) {PTR_s__000037f8        if (data->scale == 0) {PTR_s__000037f8          iprintf(\"    %d\\n\", data->val[i]);PTR_s__000037f8        }PTR_s__000037f8        else if ((data->scale + 4 < 0 == SCARRY4((int)data->scale,4)) && (data->scale < 0)) {PTR_s__000037f8          length = fmt_s16_dfp(num_str, data->val[i], (int)data->scale);PTR_s__000037f8          num_str[length] = 0;PTR_s__000037f8          iprintf(\"    %s\\n\", num_str);PTR_s__000037f8        }PTR_s__000037f8        else {PTR_s__000037f8          iprintf(\"    %dE%d\\n\", data->val[i], (int)data->scale);PTR_s__000037f8        }PTR_s__000037f8      }PTR_s__000037f8      else {PTR_s__000037f8        iprintf(\"    %d%c\\n\", data->val[i], (char)scale_prefix);PTR_s__000037f8      }PTR_s__000037f8      unit_string = phydat_unit_to_str(data->unit);PTR_s__000037f8      iprintf(\"  %s\\n\", unit_string);PTR_s__000037f8      data++;PTR_s__000037f8    }PTR_s__000037f8  }PTR_s__000037f8}PTR_s__000037f8",
            "called": [
                "fmt_s16_dfp",
                "phydat_unit_to_str",
                "phydat_prefix_from_scale",
                "iprintf",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003694",
            "calling": [
                "write",
                "probe"
            ],
            "imported": false,
            "current_name": "display_phydat_data_00003694"
        },
        "FUN_00002364": {
            "renaming": {
                "FUN_00002364": "check_tsrb_full_00002364",
                "rb": "tsrb",
                "c": "char_to_push",
                "iVar1": "is_full"
            },
            "code": "int check_tsrb_full_00002364(tsrb_t *tsrb, char c) {\n  int is_full = tsrb_full(tsrb);\n  if (is_full == 0) {\n    push_to_tsrb(tsrb, c);\n    is_full = 0;\n  }\n  else {\n    is_full = -1;\n  }\n  return is_full;\n}",
            "called": [
                "tsrb_full",
                "_push"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002364",
            "calling": [
                "isrpipe_write_one"
            ],
            "imported": false,
            "current_name": "check_tsrb_full_00002364"
        },
        "FUN_00001ad4": {
            "renaming": {
                "FUN_00001ad4": "set_mode_to_7_00001ad4",
                "DAT_00001b08": "mode_flags",
                "PTR_current_mode_00001b0c": "current_mode"
            },
            "code": "void set_mode_to_7_00001ad4(void)\n{\n  *DAT_00001b08 = *DAT_00001b08 & 0x3f;\n  while ((DAT_00001b08[6] & 0xc) != 0xc);\n  *PTR_current_mode_00001b0c = 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ad4",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_mode_to_7_00001ad4"
        },
        "FUN_00001274": {
            "renaming": {
                "FUN_00001274": "initialize_peripherals_00001274",
                "DAT_00001298": "DAT_PERIPH",
                "cortexm_init": "initialize_cortexm",
                "kinetis_mcg_init": "initialize_kinetis_mcg",
                "periph_init": "initialize_peripheral_devices"
            },
            "code": "void initialize_peripherals_00001274(void)\n{\n  initialize_cortexm();\n  *DAT_00001298 |= 0x28;\n  initialize_kinetis_mcg();\n  initialize_peripheral_devices();\n  return;\n}",
            "called": [
                "cortexm_init",
                "kinetis_mcg_init",
                "periph_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001274",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "initialize_peripherals_00001274"
        },
        "FUN_00002e6c": {
            "renaming": {
                "FUN_00002e6c": "shell_command_loop_00002e6c",
                "shell_commands": "commands",
                "line_buf": "input_buffer",
                "len": "buffer_len",
                "iVar1": "read_result",
                "res": "handle_result",
                "print_prompt": "print_shell_prompt",
                "readline": "read_input_line",
                "handle_input_line": "handle_input_line"
            },
            "code": "void shell_command_loop_00002e6c(shell_command_t *commands, char *input_buffer, int buffer_len)\n{\n    int read_result;\n    int handle_result;\n\n    print_shell_prompt();\n    do {\n        read_result = read_input_line(input_buffer, buffer_len);\n        if (read_result == 0) {\n            handle_result = handle_input_line(commands, input_buffer);\n        }\n        print_shell_prompt();\n    } while (true);\n}",
            "called": [
                "readline",
                "print_prompt",
                "handle_input_line"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e6c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "shell_command_loop_00002e6c"
        },
        "FUN_00003444": {
            "renaming": {
                "FUN_00003444": "get_rtc_time_or_error_00003444",
                "iVar1": "rtc_error_code",
                "t": "current_time",
                "_print_time": "print_current_time"
            },
            "code": "int get_rtc_time_or_error_00003444(void)\n{\n  int rtc_error_code;\n  tm current_time;\n  rtc_error_code = rtc_get_time(&current_time);\n  if (rtc_error_code != 0) {\n    puts(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    print_current_time(&current_time);\n  }\n  return (uint)(rtc_error_code != 0);\n}",
            "called": [
                "_print_time",
                "rtc_get_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003444",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "get_rtc_time_or_error_00003444"
        },
        "FUN_00003688": {
            "renaming": {
                "FUN_00003688": "reset_system_00003688"
            },
            "code": "void reset_system_00003688(void)\n{\n  NVIC_SystemReset();\n  return;\n}",
            "called": [
                "NVIC_SystemReset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003688",
            "calling": [
                "_reboot_handler"
            ],
            "imported": false,
            "current_name": "reset_system_00003688"
        },
        "FUN_00001392": {
            "renaming": {
                "FUN_00001392": "set_bit_to_one_00001392",
                "ptr": "pointer_to_word",
                "bit": "bit_position",
                "puVar1": "bit_band_address"
            },
            "code": "void set_bit_to_one_00001392(uint32_t *pointer_to_word, uint8_t bit_position)\n{\n  uint32_t* bit_band_address = bitband_addr(pointer_to_word, (uint)bit_position);\n  *bit_band_address = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001392",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "set_bit_to_one_00001392"
        },
        "FUN_00002910": {
            "renaming": {
                "FUN_00002910": "clear_rtt_callback_00002910",
                "iVar1": "data",
                "rtt": "rtt_callback_address",
                "PTR_rtt_callback_00002948": "rtt_callback_address",
                "DAT_00002944": "data_address"
            },
            "code": "void clear_rtt_callback_00002910(void)\n{\n  int data = DAT_00002944;\n  uint32_t* address = (uint32_t*)(data + 0x1c);\n  *address &= 0xfffffffb;\n  *(uint32_t*)(data + 8) = 0;\n  *(uint32_t*)PTR_rtt_callback_00002948 = 0;\n  *(uint32_t*)(PTR_rtt_callback_00002948 + 4) = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002910",
            "calling": [
                "rtc_clear_alarm"
            ],
            "imported": false,
            "current_name": "clear_rtt_callback_00002910"
        },
        "FUN_00004418": {
            "renaming": {
                "FUN_00004418": "get_char_from_stdin_00004418",
                "PTR__impure_ptr_00004438": "PTR__impure_ptr",
                "_getc_r": "get_char_r",
                "iVar1": "impure_ptr_val",
                "char_val": "char_val"
            },
            "code": "int get_char_from_stdin_00004418(void)\n{\n  int impure_ptr_val = *(int *)PTR__impure_ptr_00004438_00004438;\n  if ((impure_ptr_val != 0) && (*(int *)(impure_ptr_val + 0x18) == 0)) {\n    __sinit(impure_ptr_val);\n  }\n  int char_val = _getc_r(impure_ptr_val,*(undefined4 *)(impure_ptr_val + 4));\n  return char_val;\n}",
            "called": [
                "__sinit",
                "_getc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004418",
            "calling": [
                "readline"
            ],
            "imported": false,
            "current_name": "get_char_from_stdin_00004418"
        },
        "FUN_0000258c": {
            "renaming": {
                "FUN_0000258c": "initialize_interrupt_priorities_0000258c",
                "DAT_000025ec": "interrupt_controller_base_address",
                "DAT_000025f0": "default_priority",
                "PRIORITY_OFFSET": "0x08",
                "DEFAULT_PRIORITY": "0x80",
                "LOWEST_PRIORITY": "0xFF",
                "NVIC_SetPriority": "set_interrupt_priority",
                "PendSV_IRQn": "PendSV_interrupt_number",
                "SVCall_IRQn": "SVCall_interrupt_number",
                "TOTAL_INTERRUPTS": "0x66",
                "IRQn_Type": "interrupt_number_type",
                "INTERRUPT_CONTROL_OFFSET": "0x10",
                "INTERRUPT_CONTROL_MASK": "0x10",
                "INTERRUPT_ENABLE_OFFSET": "0x14",
                "INTERRUPT_ENABLE_MASK": "0x200"
            },
            "code": "void initialize_interrupt_priorities_0000258c(void)\n{\n  uint32_t i;\n  *(uint32_t *)(DAT_000025ec + PRIORITY_OFFSET) = DEFAULT_PRIORITY;\n  NVIC_SetPriority(PendSV_IRQn, LOWEST_PRIORITY);\n  NVIC_SetPriority(SVCall_IRQn, LOWEST_PRIORITY);\n  for (i = 0; i < TOTAL_INTERRUPTS; i++) {\n    NVIC_SetPriority((IRQn_Type)i, LOWEST_PRIORITY);\n  }\n  *(uint32_t *)(DAT_000025ec + INTERRUPT_CONTROL_OFFSET) |= INTERRUPT_CONTROL_MASK;\n  *(uint32_t *)(DAT_000025ec + INTERRUPT_ENABLE_OFFSET) |= INTERRUPT_ENABLE_MASK;\n  return;\n}",
            "called": [
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000258c",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initialize_interrupt_priorities_0000258c"
        },
        "FUN_00002a00": {
            "renaming": {
                "FUN_00002a00": "print_character_00002a00",
                "c": "character"
            },
            "code": "void print_character_00002a00(int character)\n{\n  putchar(character);\n  return;\n}",
            "called": [
                "putchar"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a00",
            "calling": [
                "readline",
                "print_prompt"
            ],
            "imported": false,
            "current_name": "print_character_00002a00"
        },
        "FUN_00000a64": {
            "renaming": {
                "FUN_00000a64": "handle_hard_fault_exception_00000a64",
                "sp": "stack_pointer",
                "corrupted": "is_corrupted_stack",
                "unaff_r4": "r4",
                "unaff_r5": "r5",
                "unaff_r6": "r6",
                "unaff_r7": "r7",
                "unaff_r8": "r8",
                "unaff_r9": "r9",
                "unaff_r10": "r10",
                "unaff_r11": "r11",
                "in_lr": "in_lr",
                "PTR__eram_00000aa0": "eram_start_address",
                "&stack0x00000000": "&main_stack_start_address",
                "DAT_00000a9c": "eram_end_address",
                "PTR_heap_top_00000aa4": "heap_top_address",
                "BADSPACEBASE": "BADSPACEBASE",
                "getMainStackPointer()": "getMainStackPointer()",
                "getProcessStackPointer()": "getProcessStackPointer()",
                "hard_fault_handler": "hard_fault_handler"
            },
            "code": "void handle_hard_fault_exception_00000a64(void)\n{\n  uint32_t *stack_pointer;\n  uint32_t is_corrupted_stack = 0;\n  uint32_t r4 = 0;\n  undefined4 r5 = 0;\n  undefined4 r6 = 0;\n  undefined4 r7 = 0;\n  undefined4 r8 = 0;\n  undefined4 r9 = 0;\n  undefined4 r10 = 0;\n  undefined4 r11 = 0;\n  uint in_lr;\n  \n  if ((PTR__eram_00000aa0 < &main_stack_start_address) || (&main_stack_start_address <= DAT_00000a9c)) {\n    is_corrupted_stack = 1;\n    PTR_heap_top_00000aa4 = (BADSPACEBASE *)heap_start_address;\n  }\n  \n  in_lr = __get_LR();\n  if ((in_lr & 4) == 0) {\n    stack_pointer = (uint32_t *)getMainStackPointer();\n  }\n  else {\n    stack_pointer = (uint32_t *)getProcessStackPointer();\n  }\n  \n  *(undefined4 *)((int)PTR_heap_top_00000aa4 - 4) = r11;\n  *(undefined4 *)((int)PTR_heap_top_00000aa4 - 8) = r10;\n  *(undefined4 *)((int)PTR_heap_top_00000aa4 - 0xc) = r9;\n  *(undefined4 *)((int)PTR_heap_top_00000aa4 - 0x10) = r8;\n  *(undefined4 *)((int)PTR_heap_top_00000aa4 - 0x14) = r7;\n  *(undefined4 *)((int)PTR_heap_top_00000aa4 - 0x18) = r6;\n  *(undefined4 *)((int)PTR_heap_top_00000aa4 - 0x1c) = r5;\n  *(uint32_t *)((int)PTR_heap_top_00000aa4 - 0x20) = r4;\n  \n  hard_fault_handler(stack_pointer, is_corrupted_stack, in_lr, (uint32_t *)((int)PTR_heap_top_00000aa4 - 0x20));\n}",
            "called": [
                "hard_fault_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a64",
            "calling": [],
            "imported": false,
            "current_name": "handle_hard_fault_exception_00000a64"
        },
        "FUN_000043a0": {
            "renaming": {
                "FUN_000043a0": "find_matching_values_000043a0",
                "param_1": "base_address",
                "param_2": "function_pointer",
                "piVar2": "current_address",
                "uVar4": "result",
                "iVar5": "current_item",
                "iVar3": "current_sub_item",
                "uVar1": "value"
            },
            "code": "uint find_matching_values_000043a0(int base_address, code *function_pointer){\n  uint result = 0;\n  int *current_address = (int *)(base_address + 0x48);\n  do {\n    int current_item = current_address[1];\n    int current_sub_item = current_address[2];\n    while (current_item = current_item - 1, -1 < current_item) {\n      if ((1 < *(ushort *)(current_sub_item + 0xc)) && (*(short *)(current_sub_item + 0xe) != -1)) {\n        uint value = (*function_pointer)(current_sub_item);\n        result = result | value;\n      }\n      current_sub_item = current_sub_item + 0x68;\n    }\n    current_address = (int *)*current_address;\n  } while (current_address != (int *)0x0);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043a0",
            "calling": [
                "__srefill_r"
            ],
            "imported": false,
            "current_name": "find_matching_values_000043a0"
        },
        "FUN_0000211c": {
            "renaming": {
                "FUN_0000211c": "print_thread_stats_0000211c",
                "queued_name": "queued_name",
                "iVar2": "isr_usage",
                "pvVar3": "isr_start",
                "pvVar4": "isr_sp",
                "uVar5": "stack_free",
                "puVar6": "thread",
                "uVar7": "state_name",
                "queued": "queued",
                "sname": "state_name_str",
                "state": "state_id",
                "p": "thread",
                "isr_sp": "isr_sp",
                "isr_start": "isr_start",
                "isr_usage": "isr_usage",
                "i": "i",
                "overall_used": "overall_used",
                "overall_stacksz": "overall_stacksz"
            },
            "code": "void print_thread_stats_0000211c(void)\n{\n  char queued_name[2] = {0x51, 0x5f};\n  int overall_used = 0;\n  int overall_stacksz = 0x200;\n  char *queued;\n  char *sname;\n  int state;\n  thread_t *thread;\n  void *isr_sp;\n  void *isr_start;\n  int isr_usage;\n  kernel_pid_t i;\n\n  iprintf(\"PID\\t\\tSTATE\\tPRI\\tSTACK\\n\");\n\n  isr_usage = thread_isr_stack_usage();\n  isr_start = thread_isr_stack_start();\n  isr_sp = thread_isr_stack_pointer();\n  iprintf(\"ISR stack:\\t%d/%d bytes\\tstart: %p\\tend: %p\\n\", isr_usage, overall_stacksz, isr_start, isr_sp);\n\n  overall_used = isr_usage;\n\n  for (i = 1; i < 0x21; i++) {\n    thread = *(thread_t **)(PTR_sched_threads_00002258 + i * 4);\n    if (thread != NULL) {\n      state = *(int *)(thread + 1);\n      queued = thread[9];\n      sname = *(char **)(PTR_state_names_0000225c + state * 4);\n      overall_stacksz += thread[11];\n      overall_used += thread[11] - thread_measure_stack_free(queued);\n      iprintf(\"%d\\t%s\\t%d\\t%d/%d bytes\\n\", *(short *)(thread + 3), sname, thread[10], thread[11] - thread_measure_stack_free(queued), thread[11]);\n    }\n  }\n\n  iprintf(\"Overall stack usage:\\t%d/%d bytes\\n\", overall_used, overall_stacksz);\n}\n",
            "called": [
                "thread_isr_stack_pointer",
                "thread_isr_stack_start",
                "iprintf",
                "thread_isr_stack_usage",
                "thread_measure_stack_free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000211c",
            "calling": [
                "_ps_handler",
                "core_panic"
            ],
            "imported": false,
            "current_name": "print_thread_stats_0000211c"
        },
        "FUN_0000562c": {
            "renaming": {
                "FUN_0000562c": "find_environment_variable_index_0000562c",
                "param_1": "lock",
                "param_2": "variable_name",
                "param_3": "index",
                "puVar2": "environ_pointer",
                "pcVar5": "env_value",
                "ppcVar3": "env_pointer",
                "iVar4": "variable_comparison_result",
                "ppcVar6": "current_env_pointer",
                "__n": "variable_name_length",
                "cVar1": "current_char"
            },
            "code": "char *find_environment_variable_index_0000562c(int lock, char *variable_name, int *index) {\n  char current_char;\n  char **env_pointer;\n  int variable_name_length;\n  char *env_value;\n  __env_lock();\n  env_pointer = environ_pointer;\n  if (*environ_pointer != NULL) {\n    do {\n      current_char = *variable_name;\n      if (current_char == '\\0') {\n        variable_name_length = (int)variable_name - (int)env_value;\n        while (*env_pointer != NULL) {\n          if (strncmp(*env_pointer, variable_name, variable_name_length) == 0 && (*env_pointer)[variable_name_length] == '=') {\n            *index = (int)env_pointer - (int)environ_pointer >> 2;\n            __env_unlock(lock);\n            return *env_pointer + variable_name_length + 1;\n          }\n          env_pointer++;\n        }\n        break;\n      }\n      variable_name++;\n    } while (current_char != '=');\n  }\n  __env_unlock(lock);\n  return NULL;\n}",
            "called": [
                "__env_unlock",
                "strncmp",
                "__env_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000562c",
            "calling": [
                "_getenv_r"
            ],
            "imported": false,
            "current_name": "find_environment_variable_index_0000562c"
        },
        "FUN_000020b8": {
            "renaming": {
                "FUN_000020b8": "handle_irq_000020b8",
                "DAT_000020c8": "device_data"
            },
            "code": "void handle_irq_000020b8(void)\n{\n  irq_handler(DAT_000020c8, 0);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020b8",
            "calling": [],
            "imported": false,
            "current_name": "handle_irq_000020b8"
        },
        "FUN_00002a18": {
            "renaming": {
                "FUN_00002a18": "find_command_handler_00002a18",
                "command_list": "command_list",
                "command": "command",
                "iVar1": "strcmp_result",
                "command_lists": "command_lists",
                "i": "i",
                "entry": "entry"
            },
            "code": "find_command_handler_00002a18tfind_command_handler_00002a18yfind_command_handler_00002a18pfind_command_handler_00002a18efind_command_handler_00002a18dfind_command_handler_00002a18efind_command_handler_00002a18ffind_command_handler_00002a18 find_command_handler_00002a18sfind_command_handler_00002a18tfind_command_handler_00002a18rfind_command_handler_00002a18ufind_command_handler_00002a18cfind_command_handler_00002a18tfind_command_handler_00002a18 find_command_handler_00002a18sfind_command_handler_00002a18hfind_command_handler_00002a18efind_command_handler_00002a18lfind_command_handler_00002a18lfind_command_handler_00002a18_find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18tfind_command_handler_00002a18 find_command_handler_00002a18{find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18cfind_command_handler_00002a18hfind_command_handler_00002a18afind_command_handler_00002a18rfind_command_handler_00002a18*find_command_handler_00002a18 find_command_handler_00002a18nfind_command_handler_00002a18afind_command_handler_00002a18mfind_command_handler_00002a18efind_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18sfind_command_handler_00002a18hfind_command_handler_00002a18efind_command_handler_00002a18lfind_command_handler_00002a18lfind_command_handler_00002a18_find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18hfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18lfind_command_handler_00002a18efind_command_handler_00002a18rfind_command_handler_00002a18_find_command_handler_00002a18tfind_command_handler_00002a18 find_command_handler_00002a18hfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18lfind_command_handler_00002a18efind_command_handler_00002a18rfind_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18}find_command_handler_00002a18 find_command_handler_00002a18sfind_command_handler_00002a18hfind_command_handler_00002a18efind_command_handler_00002a18lfind_command_handler_00002a18lfind_command_handler_00002a18_find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18tfind_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18tfind_command_handler_00002a18yfind_command_handler_00002a18pfind_command_handler_00002a18efind_command_handler_00002a18dfind_command_handler_00002a18efind_command_handler_00002a18ffind_command_handler_00002a18 find_command_handler_00002a18sfind_command_handler_00002a18tfind_command_handler_00002a18rfind_command_handler_00002a18ufind_command_handler_00002a18cfind_command_handler_00002a18tfind_command_handler_00002a18 find_command_handler_00002a18sfind_command_handler_00002a18hfind_command_handler_00002a18efind_command_handler_00002a18lfind_command_handler_00002a18lfind_command_handler_00002a18_find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18hfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18lfind_command_handler_00002a18efind_command_handler_00002a18rfind_command_handler_00002a18_find_command_handler_00002a18tfind_command_handler_00002a18 find_command_handler_00002a18(find_command_handler_00002a18*find_command_handler_00002a18sfind_command_handler_00002a18hfind_command_handler_00002a18efind_command_handler_00002a18lfind_command_handler_00002a18lfind_command_handler_00002a18_find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18hfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18lfind_command_handler_00002a18efind_command_handler_00002a18rfind_command_handler_00002a18_find_command_handler_00002a18tfind_command_handler_00002a18)find_command_handler_00002a18(find_command_handler_00002a18cfind_command_handler_00002a18hfind_command_handler_00002a18afind_command_handler_00002a18rfind_command_handler_00002a18*find_command_handler_00002a18)find_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18sfind_command_handler_00002a18hfind_command_handler_00002a18efind_command_handler_00002a18lfind_command_handler_00002a18lfind_command_handler_00002a18_find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18hfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18lfind_command_handler_00002a18efind_command_handler_00002a18rfind_command_handler_00002a18_find_command_handler_00002a18tfind_command_handler_00002a18 find_command_handler_00002a18ffind_command_handler_00002a18ifind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18hfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18lfind_command_handler_00002a18efind_command_handler_00002a18rfind_command_handler_00002a18(find_command_handler_00002a18sfind_command_handler_00002a18hfind_command_handler_00002a18efind_command_handler_00002a18lfind_command_handler_00002a18lfind_command_handler_00002a18_find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18tfind_command_handler_00002a18*find_command_handler_00002a18 find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18lfind_command_handler_00002a18ifind_command_handler_00002a18sfind_command_handler_00002a18tfind_command_handler_00002a18,find_command_handler_00002a18 find_command_handler_00002a18cfind_command_handler_00002a18hfind_command_handler_00002a18afind_command_handler_00002a18rfind_command_handler_00002a18*find_command_handler_00002a18 find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18)find_command_handler_00002a18 find_command_handler_00002a18{find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18ifind_command_handler_00002a18nfind_command_handler_00002a18tfind_command_handler_00002a18 find_command_handler_00002a18sfind_command_handler_00002a18tfind_command_handler_00002a18rfind_command_handler_00002a18cfind_command_handler_00002a18mfind_command_handler_00002a18pfind_command_handler_00002a18_find_command_handler_00002a18rfind_command_handler_00002a18efind_command_handler_00002a18sfind_command_handler_00002a18ufind_command_handler_00002a18lfind_command_handler_00002a18tfind_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18sfind_command_handler_00002a18hfind_command_handler_00002a18efind_command_handler_00002a18lfind_command_handler_00002a18lfind_command_handler_00002a18_find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18tfind_command_handler_00002a18*find_command_handler_00002a18 find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18lfind_command_handler_00002a18ifind_command_handler_00002a18sfind_command_handler_00002a18tfind_command_handler_00002a18sfind_command_handler_00002a18[find_command_handler_00002a182find_command_handler_00002a18]find_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18ufind_command_handler_00002a18ifind_command_handler_00002a18nfind_command_handler_00002a18tfind_command_handler_00002a18 find_command_handler_00002a18ifind_command_handler_00002a18 find_command_handler_00002a18=find_command_handler_00002a18 find_command_handler_00002a180find_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18sfind_command_handler_00002a18hfind_command_handler_00002a18efind_command_handler_00002a18lfind_command_handler_00002a18lfind_command_handler_00002a18_find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18tfind_command_handler_00002a18*find_command_handler_00002a18 find_command_handler_00002a18efind_command_handler_00002a18nfind_command_handler_00002a18tfind_command_handler_00002a18rfind_command_handler_00002a18yfind_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18lfind_command_handler_00002a18ifind_command_handler_00002a18sfind_command_handler_00002a18tfind_command_handler_00002a18sfind_command_handler_00002a18[find_command_handler_00002a180find_command_handler_00002a18]find_command_handler_00002a18 find_command_handler_00002a18=find_command_handler_00002a18 find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18lfind_command_handler_00002a18ifind_command_handler_00002a18sfind_command_handler_00002a18tfind_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18lfind_command_handler_00002a18ifind_command_handler_00002a18sfind_command_handler_00002a18tfind_command_handler_00002a18sfind_command_handler_00002a18[find_command_handler_00002a181find_command_handler_00002a18]find_command_handler_00002a18 find_command_handler_00002a18=find_command_handler_00002a18 find_command_handler_00002a18(find_command_handler_00002a18sfind_command_handler_00002a18hfind_command_handler_00002a18efind_command_handler_00002a18lfind_command_handler_00002a18lfind_command_handler_00002a18_find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18tfind_command_handler_00002a18*find_command_handler_00002a18)find_command_handler_00002a18Pfind_command_handler_00002a18Tfind_command_handler_00002a18Rfind_command_handler_00002a18_find_command_handler_00002a18_find_command_handler_00002a18sfind_command_handler_00002a18hfind_command_handler_00002a18efind_command_handler_00002a18lfind_command_handler_00002a18lfind_command_handler_00002a18_find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18lfind_command_handler_00002a18ifind_command_handler_00002a18sfind_command_handler_00002a18tfind_command_handler_00002a18_find_command_handler_00002a180find_command_handler_00002a180find_command_handler_00002a180find_command_handler_00002a180find_command_handler_00002a182find_command_handler_00002a18afind_command_handler_00002a188find_command_handler_00002a184find_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18wfind_command_handler_00002a18hfind_command_handler_00002a18ifind_command_handler_00002a18lfind_command_handler_00002a18efind_command_handler_00002a18 find_command_handler_00002a18(find_command_handler_00002a18ifind_command_handler_00002a18 find_command_handler_00002a18<find_command_handler_00002a18 find_command_handler_00002a182find_command_handler_00002a18)find_command_handler_00002a18 find_command_handler_00002a18{find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18efind_command_handler_00002a18nfind_command_handler_00002a18tfind_command_handler_00002a18rfind_command_handler_00002a18yfind_command_handler_00002a18 find_command_handler_00002a18=find_command_handler_00002a18 find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18_find_command_handler_00002a18lfind_command_handler_00002a18ifind_command_handler_00002a18sfind_command_handler_00002a18tfind_command_handler_00002a18sfind_command_handler_00002a18[find_command_handler_00002a18ifind_command_handler_00002a18]find_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18ifind_command_handler_00002a18ffind_command_handler_00002a18 find_command_handler_00002a18(find_command_handler_00002a18efind_command_handler_00002a18nfind_command_handler_00002a18tfind_command_handler_00002a18rfind_command_handler_00002a18yfind_command_handler_00002a18 find_command_handler_00002a18!find_command_handler_00002a18=find_command_handler_00002a18 find_command_handler_00002a18Nfind_command_handler_00002a18Ufind_command_handler_00002a18Lfind_command_handler_00002a18Lfind_command_handler_00002a18)find_command_handler_00002a18 find_command_handler_00002a18{find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18wfind_command_handler_00002a18hfind_command_handler_00002a18ifind_command_handler_00002a18lfind_command_handler_00002a18efind_command_handler_00002a18 find_command_handler_00002a18(find_command_handler_00002a18efind_command_handler_00002a18nfind_command_handler_00002a18tfind_command_handler_00002a18rfind_command_handler_00002a18yfind_command_handler_00002a18-find_command_handler_00002a18>find_command_handler_00002a18nfind_command_handler_00002a18afind_command_handler_00002a18mfind_command_handler_00002a18efind_command_handler_00002a18 find_command_handler_00002a18!find_command_handler_00002a18=find_command_handler_00002a18 find_command_handler_00002a18Nfind_command_handler_00002a18Ufind_command_handler_00002a18Lfind_command_handler_00002a18Lfind_command_handler_00002a18)find_command_handler_00002a18 find_command_handler_00002a18{find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18sfind_command_handler_00002a18tfind_command_handler_00002a18rfind_command_handler_00002a18cfind_command_handler_00002a18mfind_command_handler_00002a18pfind_command_handler_00002a18_find_command_handler_00002a18rfind_command_handler_00002a18efind_command_handler_00002a18sfind_command_handler_00002a18ufind_command_handler_00002a18lfind_command_handler_00002a18tfind_command_handler_00002a18 find_command_handler_00002a18=find_command_handler_00002a18 find_command_handler_00002a18sfind_command_handler_00002a18tfind_command_handler_00002a18rfind_command_handler_00002a18cfind_command_handler_00002a18mfind_command_handler_00002a18pfind_command_handler_00002a18(find_command_handler_00002a18efind_command_handler_00002a18nfind_command_handler_00002a18tfind_command_handler_00002a18rfind_command_handler_00002a18yfind_command_handler_00002a18-find_command_handler_00002a18>find_command_handler_00002a18nfind_command_handler_00002a18afind_command_handler_00002a18mfind_command_handler_00002a18efind_command_handler_00002a18,find_command_handler_00002a18 find_command_handler_00002a18cfind_command_handler_00002a18ofind_command_handler_00002a18mfind_command_handler_00002a18mfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18)find_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18ifind_command_handler_00002a18ffind_command_handler_00002a18 find_command_handler_00002a18(find_command_handler_00002a18sfind_command_handler_00002a18tfind_command_handler_00002a18rfind_command_handler_00002a18cfind_command_handler_00002a18mfind_command_handler_00002a18pfind_command_handler_00002a18_find_command_handler_00002a18rfind_command_handler_00002a18efind_command_handler_00002a18sfind_command_handler_00002a18ufind_command_handler_00002a18lfind_command_handler_00002a18tfind_command_handler_00002a18 find_command_handler_00002a18=find_command_handler_00002a18=find_command_handler_00002a18 find_command_handler_00002a180find_command_handler_00002a18)find_command_handler_00002a18 find_command_handler_00002a18{find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18rfind_command_handler_00002a18efind_command_handler_00002a18tfind_command_handler_00002a18ufind_command_handler_00002a18rfind_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18efind_command_handler_00002a18nfind_command_handler_00002a18tfind_command_handler_00002a18rfind_command_handler_00002a18yfind_command_handler_00002a18-find_command_handler_00002a18>find_command_handler_00002a18hfind_command_handler_00002a18afind_command_handler_00002a18nfind_command_handler_00002a18dfind_command_handler_00002a18lfind_command_handler_00002a18efind_command_handler_00002a18rfind_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18}find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18efind_command_handler_00002a18nfind_command_handler_00002a18tfind_command_handler_00002a18rfind_command_handler_00002a18yfind_command_handler_00002a18+find_command_handler_00002a18+find_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18}find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18}find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18ifind_command_handler_00002a18+find_command_handler_00002a18+find_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18}find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18\\find_command_handler_00002a18\nfind_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18 find_command_handler_00002a18rfind_command_handler_00002a18efind_command_handler_00002a18tfind_command_handler_00002a18ufind_command_handler_00002a18rfind_command_handler_00002a18nfind_command_handler_00002a18 find_command_handler_00002a18Nfind_command_handler_00002a18Ufind_command_handler_00002a18Lfind_command_handler_00002a18Lfind_command_handler_00002a18;find_command_handler_00002a18\\find_command_handler_00002a18nfind_command_handler_00002a18}find_command_handler_00002a18",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a18",
            "calling": [
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "find_command_handler_00002a18"
        },
        "FUN_000054a8": {
            "renaming": {
                "FUN_000054a8": "read_input_000054a8",
                "param_1": "read_bytes",
                "param_2": "stream",
                "uVar1": "flags",
                "uVar2": "flags",
                "uVar3": "size",
                "uVar4": "result",
                "iVar5": "impure_ptr"
            },
            "code": "uint read_input_000054a8(uint *read_bytes, uint *stream)\n{\n  ushort flags;\n  uint size;\n  uint result;\n  int impure_ptr = *(int *)PTR__impure_ptr_00005574;\n  if((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0))\n  {\n    __sinit(impure_ptr);\n  }\n  if(stream == (uint *)PTR___sf_fake_stdin_00005578)\n  {\n    stream = *(uint **)(impure_ptr + 4);\n  }\n  else if(stream == (uint *)PTR___sf_fake_stdout_0000557c)\n  {\n    stream = *(uint **)(impure_ptr + 8);\n  }\n  else if(stream == (uint *)PTR___sf_fake_stderr_00005580)\n  {\n    stream = *(uint **)(impure_ptr + 0xc);\n  }\n  size = (uint)*(ushort *)(stream + 3);\n  flags = *(ushort *)(stream + 3);\n  if(-1 < (int)(size << 0x1c))\n  {\n    if(-1 < (int)(size << 0x1b))\n    {\n      *read_bytes = 9;\n      goto LAB_000054d8;\n    }\n    if((uint *)(stream[0xd]) != (uint *)0x0)\n    {\n      if((uint *)(stream[0xd]) != stream + 0x11)\n      {\n        _free_r(read_bytes);\n      }\n      stream[0xd] = 0;\n    }\n    *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xffdb;\n    stream[1] = 0;\n    *stream = stream[4];\n  }\n  if((stream[4] == 0) && ((*(ushort *)(stream + 3) & 0x280) != 0x200))\n  {\n    __smakebuf_r(read_bytes, stream);\n  }\n  flags = *(ushort *)(stream + 3);\n  size = (uint)flags;\n  result = size & 1;\n  if((flags & 1) == 0)\n  {\n    if(-1 < (int)(size << 0x1e))\n    {\n      result = stream[5];\n    }\n    stream[2] = result;\n  }\n  else\n  {\n    stream[2] = 0;\n    stream[6] = -stream[5];\n  }\n  if(stream[4] != 0)\n  {\n    return 0;\n  }\n  if((flags & 0x80) == 0)\n  {\n    return size & 0x80;\n  }\n  LAB_000054d8:\n  *(ushort *)(stream + 3) = flags | 0x40;\n  return 0xffffffff;\n}",
            "called": [
                "_free_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000054a8",
            "calling": [
                "_puts_r",
                "__swbuf_r",
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "read_input_000054a8"
        },
        "FUN_000007dc": {
            "renaming": {
                "FUN_000007dc": "create_thread_stack_000007dc",
                "task_func": "thread_task_func",
                "arg": "argument",
                "stack_start": "stack_start",
                "stack_size": "stack_size",
                "uVar1": "aligned_stack_size",
                "stk": "stack_pointer",
                "i_1": "inner_loop_counter",
                "i": "outer_loop_counter"
            },
            "code": "char * create_thread_stack_000007dc(thread_task_func_t task_func, void *arg, void *stack_start, int stack_size) {\n    uint32_t *stack_pointer;\n    uint32_t aligned_stack_size = (stack_size + (int)stack_start) & 0xfffffffc;\n    stack_pointer = (uint32_t *)(aligned_stack_size - 4);\n    *stack_pointer = 0x77777777;\n    if (((uint)stack_pointer & 7) != 0) {\n        stack_pointer = (uint32_t *)(aligned_stack_size - 8);\n        *stack_pointer = 0x88888888;\n    }\n    stack_pointer[-1] = 0x1000000;\n    stack_pointer[-2] = (uint32_t)task_func;\n    stack_pointer[-3] = DAT_000008b4;\n    stack_pointer = stack_pointer - 4;\n    *stack_pointer = 0;\n    for (int i = 3; i > 0; i--) {\n        stack_pointer--;\n        *stack_pointer = i;\n    }\n    stack_pointer--;\n    *stack_pointer = (uint32_t)arg;\n    for (int i = 0xb; i > 3; i--) {\n        stack_pointer--;\n        *stack_pointer = i;\n    }\n    stack_pointer[-1] = 0xfffffffd;\n    return (char *)(stack_pointer - 1);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000007dc",
            "calling": [
                "thread_create"
            ],
            "imported": false,
            "current_name": "create_thread_stack_000007dc"
        },
        "FUN_00001710": {
            "renaming": {
                "FUN_00001710": "clear_bit_at_position_00001710",
                "ptr": "data",
                "bit": "position",
                "puVar1": "bit_address"
            },
            "code": "void clear_bit_at_position_00001710(uint8_t *data, uint8_t position) {\n  undefined *bit_address = (undefined *)bitband_addr(data, (uint)position);\n  *bit_address = 0;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001710",
            "calling": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_disable_pll",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "clear_bit_at_position_00001710"
        },
        "FUN_000045ea": {
            "renaming": {
                "FUN_000045ea": "do_nothing_000045ea"
            },
            "code": "\nvoid do_nothing_000045ea(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ea",
            "calling": [
                "__tz_unlock"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ea"
        },
        "FUN_000045ec": {
            "renaming": {
                "FUN_000045ec": "do_nothing_000045ec"
            },
            "code": "\nvoid do_nothing_000045ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ec",
            "calling": [
                "_puts_r",
                "__sinit_lock_release",
                "__env_unlock",
                "__malloc_unlock",
                "_fflush_r",
                "__sfp_lock_release",
                "_vfprintf_r",
                "_putc_r",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ec"
        },
        "FUN_00001034": {
            "renaming": {
                "FUN_00001034": "insert_thread_into_list_00001034",
                "list": "head",
                "thread": "thread",
                "local_1c": "current_node",
                "list_entry": "list_entry",
                "__m____": "__m____",
                "new_node": "new_node",
                "my_prio": "thread_priority"
            },
            "code": "void insert_thread_into_list_00001034(list_node_t *head, thread_t *thread) {\n  list_node_t *current_node;\n  thread_t *list_entry;\n  clist_node_t *__m____;\n  list_node_t *new_node;\n  uint16_t thread_priority;\n  \n  if (thread->status < 9) {\n    current_node = head;\n    while ((current_node->next != (list_node *)0x0 &&\n           (*(byte *)((int)&current_node->next[-1].next + 1) <= thread->priority))) {\n      current_node = current_node->next;\n    }\n    (thread->rq_entry).next = current_node->next;\n    current_node->next = &thread->rq_entry;\n    return;\n  }\n  core_panic(PANIC_ASSERT_FAIL,PTR_assert_crash_message_0000109c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001034",
            "calling": [
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "insert_thread_into_list_00001034"
        },
        "FUN_000055ac": {
            "renaming": {
                "FUN_000055ac": "read_byte_000055ac",
                "param_1": "file_descriptor",
                "param_2": "buffer",
                "uVar1": "byte_read",
                "pbVar2": "buffer_pointer"
            },
            "code": "uint read_byte_000055ac(int file_descriptor, byte **buffer) {\n  uint byte_read;\n  byte *buffer_pointer;\n  if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n    __sinit();\n  }\n  if (buffer == (byte **)original_stdin) {\n    buffer = *(byte ***)(file_descriptor + 4);\n  }\n  else if (buffer == (byte **)original_stdout) {\n    buffer = *(byte ***)(file_descriptor + 8);\n  }\n  else if (buffer == (byte **)original_stderr) {\n    buffer = *(byte ***)(file_descriptor + 0xc);\n  }\n  if ((-1 < (int)buffer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(buffer + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(buffer[0x16]);\n  }\n  buffer_pointer = buffer[1];\n  buffer[1] = buffer_pointer - 1;\n  if ((int)(buffer_pointer - 1) < 0) {\n    byte_read = __srget_r(file_descriptor, buffer);\n  }\n  else {\n    buffer_pointer = *buffer;\n    *buffer = buffer_pointer + 1;\n    byte_read = (uint)*buffer_pointer;\n  }\n  if ((-1 < (int)buffer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(buffer + 3) << 0x16))) {\n    __retarget_lock_release_recursive(buffer[0x16]);\n  }\n  return byte_read;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive",
                "__srget_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000055ac",
            "calling": [
                "getchar"
            ],
            "imported": false,
            "current_name": "read_byte_000055ac"
        },
        "FUN_00006964": {
            "renaming": {
                "FUN_00006964": "calculate_value_of_array_index_00006964",
                "param_1": "index",
                "param_2": "array",
                "iVar1": "offset"
            },
            "code": "int calculate_value_of_array_index_00006964(int index, int* array) {\n    int offset = *(array - 1) - 4;\n    if (*(array - 1) < 0) {\n        offset += *(array + offset);\n    }\n    return offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006964",
            "calling": [
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "calculate_value_of_array_index_00006964"
        },
        "FUN_0000182c": {
            "renaming": {
                "FUN_0000182c": "clear_bits_and_set_flag_0000182c",
                "DAT_000018b4": "data_ptr",
                "DAT_000018b8": "flag_ptr"
            },
            "code": "void clear_bits_and_set_flag_0000182c(void)\n{\n  uint8_t flag_mask = 0xd0;\n  uint8_t *DAT_000018b4 = DAT_000018b4;\n  DAT_000018b4[8] &= flag_mask;\n  bit_set8(DAT_000018b8, 0);\n  bit_clear8(DAT_000018b4, 1);\n  bit_clear8(DAT_000018b4, 0);\n  return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000182c",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "clear_bits_and_set_flag_0000182c"
        },
        "FUN_00004db8": {
            "renaming": {
                "FUN_00004db8": "perform_string_operation_00004db8",
                "__s": "input_string",
                "iVar1": "result",
                "_FUN_00004db8_r": "recursive_string_operation"
            },
            "code": "int perform_string_operation_00004db8(char* input_string) {\n  int result = recursive_string_operation(*(undefined4*)PTR__impure_ptr_00004dc4, input_string);\n  return result;\n}",
            "called": [
                "_puts_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004db8",
            "calling": [
                "phydat_dump",
                "_rtc_setalarm",
                "_rtc_usage",
                "write",
                "list",
                "main",
                "read",
                "print_help",
                "_rtc_settime",
                "probe_all",
                "_rtc_getalarm",
                "_rtc_gettime",
                "hard_fault_handler",
                "_alarm_handler",
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "perform_string_operation_00004db8"
        },
        "FUN_000022f0": {
            "renaming": {
                "FUN_000022f0": "read_next_char_000022f0",
                "rb": "ring_buffer",
                "uVar1": "num_reads",
                "reads": "num_reads",
                "size": "buffer_size",
                "buf": "ring_buffer->buf",
                "&": "and",
                "-": "minus",
                "1": "one",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "char read_next_char_000022f0(tsrb_t *ring_buffer) {\n  uint32_t num_reads = ring_buffer->reads;\n  ring_buffer->reads = num_reads + 1;\n  uint32_t buffer_size = ring_buffer->size;\n  uint32_t buffer_index_mask = buffer_size - 1;\n  return ring_buffer->buf[num_reads & buffer_index_mask];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022f0",
            "calling": [
                "tsrb_get"
            ],
            "imported": false,
            "current_name": "read_next_char_000022f0"
        },
        "FUN_00001c84": {
            "renaming": {
                "FUN_00001c84": "initialize_system_clock_00001c84",
                "state": "interrupt_state",
                "mask": "clock_config",
                "kinetis_mcg_set_safe_mode": "set_safe_mode",
                "DAT_00001ce8": "memory_address",
                "DAT_00001cec": "register_address",
                "configure_mcgirclk": "configure_internal_reference_clock",
                "configure_erclk32k": "configure_external_reference_clock",
                "kinetis_mcg_set_mode": "set_mode",
                "KINETIS_MCG_MODE_PEE": "PLL_engaged_external",
                "irq_disable": "disable_interrupts",
                "irq_restore": "restore_interrupts"
            },
            "code": "void initialize_system_clock_00001c84(void)\n{\n  uint32_t state;\n  uint32_t clock_config;\n\n  state = disable_interrupts();\n  set_safe_mode();\n  *(uint32_t *)(DAT_00001ce8 + 0x1044) = 0x220000;\n  DAT_00001cec[12] = 0;\n  *DAT_00001cec = *DAT_00001cec & 199 | 0x38;\n  DAT_00001cec[4] = 0x13;\n  DAT_00001cec[5] = 0;\n  configure_mcgirclk();\n  configure_erclk32k();\n  set_mode(KINETIS_MCG_MODE_PEE);\n  restore_interrupts(state);\n}\n",
            "called": [
                "kinetis_mcg_init_erclk32k",
                "irq_disable",
                "irq_restore",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_mode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001c84",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initialize_system_clock_00001c84"
        },
        "FUN_000068f0": {
            "renaming": {
                "FUN_000068f0": "flash_configuration_field_000068f0",
                "param_1": "memory",
                "param_2": "configurations",
                "pvVar1": "new_memory",
                "__n": "current_configuration"
            },
            "code": "undefined4 flash_configuration_field_000068f0(void *memory, void **configurations)\n{\n  void *new_memory;\n  void *current_configuration;\n\n  if ((void **)configurations[13] == configurations + 17) {\n    new_memory = (void *)_malloc_r(memory,0x400);\n    if (new_memory != (void *)0x0) {\n      configurations[14] = flash_configuration_field_000068f0;\n      configurations[13] = new_memory;\n      *(undefined *)((int)new_memory + 0x3ff) = *(undefined *)((int)configurations + 0x46);\n      *(undefined *)((int)new_memory + 0x3fe) = *(undefined *)((int)configurations + 0x45);\n      *(undefined *)((int)new_memory + 0x3fd) = *(undefined *)(configurations + 17);\n      *configurations = (void *)((int)new_memory + 0x3fd);\n      return 0;\n    }\n  }\n  else {\n    current_configuration = configurations[14];\n    new_memory = (void *)_realloc_r(memory,configurations[13],(void *)((int)current_configuration << 1));\n    if (new_memory != (void *)0x0) {\n      memcpy((void *)((int)new_memory + (int)current_configuration),new_memory,(size_t)current_configuration);\n      configurations[13] = new_memory;\n      configurations[14] = (void *)((int)current_configuration << 1);\n      *configurations = (void *)((int)new_memory + (int)current_configuration);\n      return 0;\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "_realloc_r",
                "memcpy",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000068f0",
            "calling": [
                "_sungetc_r"
            ],
            "imported": false,
            "current_name": "flash_configuration_field_000068f0"
        }
    },
    "used_tokens": 203357,
    "layers": [
        [
            "FUN_000026c0",
            "FUN_00004bd0",
            "FUN_00000794",
            "FUN_000064bc",
            "FUN_00002970",
            "FUN_00000ca0",
            "FUN_00000d0c",
            "FUN_00003d94",
            "FUN_0000579c",
            "FUN_000015d0",
            "FUN_00004cdc",
            "FUN_00005e68",
            "FUN_00000dcc",
            "FUN_0000285c",
            "FUN_00000e58",
            "FUN_00001778",
            "FUN_000026d8",
            "FUN_00000566",
            "FUN_00001d08",
            "FUN_000031fc",
            "FUN_000016ec",
            "FUN_00004e8c",
            "FUN_00005584",
            "FUN_00000cb0",
            "FUN_00004248",
            "FUN_00000f5c",
            "FUN_00001da2",
            "FUN_00001ec4",
            "FUN_00002744",
            "FUN_00002624",
            "FUN_00001e0c",
            "FUN_0000459c",
            "FUN_000014c4",
            "FUN_00004b34",
            "FUN_000004f2",
            "FUN_0000423c",
            "FUN_00004e66",
            "FUN_00005ecc",
            "FUN_00001628",
            "FUN_00001748",
            "FUN_0000294c",
            "FUN_00005790",
            "FUN_00000534",
            "FUN_000017dc",
            "FUN_000005ca",
            "FUN_000043da",
            "FUN_00005ff8",
            "FUN_00006754",
            "FUN_00002714",
            "FUN_000020e0",
            "FUN_00004f80",
            "FUN_00005fec",
            "FUN_000028f0",
            "FUN_00004f98",
            "FUN_00004dee",
            "FUN_00000fec",
            "FUN_00000428",
            "FUN_000039e8",
            "FUN_00000e38",
            "FUN_00002294",
            "FUN_00003e9e",
            "FUN_00003378",
            "FUN_00006768",
            "FUN_00000db0",
            "FUN_00002600",
            "FUN_00003810",
            "FUN_00000ed8",
            "FUN_000031e0",
            "FUN_000004d4",
            "FUN_000020f4",
            "FUN_0000687c",
            "FUN_00004dea",
            "FUN_00005edc",
            "FUN_000023a4",
            "FUN_0000240c",
            "FUN_00004280",
            "FUN_00001448",
            "FUN_00001688",
            "FUN_00004042",
            "FUN_00000cf0",
            "FUN_00000f8c",
            "FUN_00002894",
            "FUN_00004158",
            "FUN_00002654",
            "FUN_00000aa8",
            "FUN_00002538",
            "FUN_00004c84",
            "FUN_000012b4",
            "FUN_0000058e",
            "FUN_000025f4",
            "FUN_00001ddc",
            "FUN_00002ecc",
            "FUN_00000d76",
            "FUN_000057a8",
            "FUN_00004298",
            "FUN_00001696",
            "FUN_000008b8",
            "FUN_000024bc",
            "FUN_00000490",
            "FUN_0000091c",
            "FUN_00005d80",
            "FUN_00001f80",
            "FUN_00000e64",
            "FUN_000026e4",
            "FUN_00000d44",
            "FUN_00000698",
            "FUN_00000cd0",
            "FUN_00000cc0",
            "FUN_00002994",
            "FUN_00000d2a",
            "FUN_00001ff6",
            "FUN_00000f80",
            "FUN_00002a88",
            "FUN_00002f30",
            "FUN_00001e44",
            "FUN_00001318",
            "FUN_00000900",
            "FUN_00004274",
            "FUN_00002fe0",
            "FUN_00001dc0",
            "FUN_00000df4",
            "FUN_00002eb4",
            "FUN_0000328c",
            "FUN_000041f4",
            "FUN_0000316c",
            "FUN_000026f0",
            "FUN_000057d2",
            "FUN_00000958",
            "FUN_000056b8",
            "FUN_00001a18",
            "FUN_00000d9c",
            "FUN_00003ff4",
            "FUN_00001d5e",
            "FUN_0000191c",
            "FUN_000050f4",
            "FUN_00000c80",
            "FUN_00000a40",
            "FUN_00005a58",
            "FUN_000056b0",
            "FUN_00003d24",
            "FUN_000060cc",
            "FUN_000022be",
            "FUN_00003dc4",
            "FUN_00002108",
            "FUN_00000c90",
            "FUN_00001d80",
            "FUN_000033c0",
            "FUN_00002b10",
            "FUN_00001b10",
            "FUN_000023c8",
            "FUN_00002e48",
            "FUN_00000930",
            "FUN_00001348",
            "FUN_00006118",
            "FUN_00001d3a",
            "FUN_00002434",
            "FUN_00005700",
            "FUN_00002798",
            "FUN_00003524",
            "FUN_00001bb8",
            "FUN_0000428c",
            "FUN_0000404c",
            "FUN_00002f74",
            "FUN_000010a0",
            "FUN_000012e2",
            "FUN_000056a0",
            "FUN_0000231c",
            "FUN_00002690",
            "FUN_00006010",
            "FUN_00001cf0",
            "FUN_00003ec4",
            "FUN_00001360",
            "FUN_00004622",
            "FUN_0000093c",
            "FUN_00003658",
            "FUN_000019c0",
            "FUN_000060b0",
            "FUN_000023d0",
            "FUN_00000a30",
            "FUN_000034c0",
            "FUN_000050e8",
            "FUN_00000514",
            "FUN_00002e9c",
            "FUN_00001960",
            "FUN_00001a3c",
            "FUN_000045ee",
            "FUN_00005404",
            "FUN_00006974",
            "FUN_00005fd4",
            "FUN_00004dc8",
            "FUN_00005e10",
            "FUN_000033f4",
            "FUN_0000443c",
            "FUN_000027b0",
            "FUN_00005ebc",
            "FUN_00006192",
            "FUN_00001734",
            "FUN_00000e14",
            "FUN_0000281c",
            "FUN_00002270",
            "FUN_000020cc",
            "FUN_00002396",
            "FUN_00004e4a",
            "FUN_00004cb4",
            "FUN_00003478",
            "FUN_00002028",
            "FUN_000016c8",
            "FUN_00001a60",
            "FUN_000004b2",
            "FUN_0000099c",
            "FUN_00002d94",
            "FUN_00003918",
            "FUN_00003d64",
            "FUN_00004e52",
            "FUN_000010d4",
            "FUN_00000738",
            "FUN_00003e58",
            "FUN_00004e26",
            "FUN_00000978",
            "FUN_000018bc",
            "FUN_00000974",
            "FUN_00000610",
            "FUN_00003694",
            "FUN_00002364",
            "FUN_00001ad4",
            "FUN_00001274",
            "FUN_00002e6c",
            "FUN_00003444",
            "FUN_00003688",
            "FUN_00001392",
            "FUN_00002910",
            "FUN_00004418",
            "FUN_0000258c",
            "FUN_00002a00",
            "FUN_00000a64",
            "FUN_000043a0",
            "FUN_0000211c",
            "FUN_0000562c",
            "FUN_000020b8",
            "FUN_00002a18",
            "FUN_000054a8",
            "FUN_000007dc",
            "FUN_00001710",
            "FUN_00001034",
            "FUN_000055ac",
            "FUN_00006964",
            "FUN_0000182c",
            "FUN_000022f0",
            "FUN_000068f0"
        ],
        [
            "FUN_00000dc0",
            "FUN_00005100",
            "FUN_000041d0",
            "FUN_0000129c",
            "FUN_00000410",
            "FUN_00004f84",
            "FUN_00001eea",
            "FUN_0000305c",
            "FUN_000013b8",
            "FUN_000042a4",
            "FUN_00004314",
            "FUN_00005fd8",
            "FUN_00005780",
            "FUN_00000f04",
            "FUN_00004db8",
            "FUN_00001c84"
        ]
    ],
    "locked_functions": []
}